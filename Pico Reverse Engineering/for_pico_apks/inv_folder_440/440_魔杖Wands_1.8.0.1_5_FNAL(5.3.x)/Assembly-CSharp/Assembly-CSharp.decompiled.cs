using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Net;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security;
using System.Security.Cryptography;
using System.Security.Permissions;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using AOT;
using Assets.Cortopia.Scripts.WandsInput;
using Assets.Scripts;
using Assets.Scripts.Animation;
using Assets.Scripts.CustomEvents;
using Assets.Scripts.Enums;
using Assets.Scripts.Environmental;
using Assets.Scripts.InteractObjects;
using Assets.Scripts.Interfaces;
using Assets.Scripts.ItemDatabase;
using Assets.Scripts.Misc;
using Assets.Scripts.Network;
using Assets.Scripts.Network.Matchmaking;
using Assets.Scripts.Pickup;
using Assets.Scripts.Platform;
using Assets.Scripts.Platform.Achievements;
using Assets.Scripts.PlayFab;
using Assets.Scripts.Player;
using Assets.Scripts.Relics;
using Assets.Scripts.Reporting;
using Assets.Scripts.SaveLoad;
using Assets.Scripts.SaveLoad.Converters;
using Assets.Scripts.Season;
using Assets.Scripts.Settings;
using Assets.Scripts.Sound;
using Assets.Scripts.Spells;
using Assets.Scripts.Spells.Defense;
using Assets.Scripts.Spells.Interfaces;
using Assets.Scripts.Spells.Projectile;
using Assets.Scripts.Spells.TileEffects;
using Assets.Scripts.Spells.Turret;
using Assets.Scripts.Spells.Utils;
using Assets.Scripts.Tiles;
using Assets.Scripts.UI;
using Assets.Scripts.UI.Basement;
using Assets.Scripts.UI.Button;
using Assets.Scripts.UI.Lobby;
using Assets.Scripts.UI.SpellSelection;
using Assets.Scripts.UI.Workshop;
using Assets.Scripts.UI.Workshop.CharacterSelection.MirrorStates;
using Assets.Scripts.UI.Workshop.SpellTable;
using Assets.Scripts.UI.Workshop.Tutorial;
using Assets.Scripts.UI.Workshop.WandStation;
using Assets.Scripts.Utils;
using Assets.Scripts.Utils.Json;
using Assets.Scripts.Utils.Tweeners;
using Assets.Scripts.WandsExceptions;
using Assets.Scripts.WandsIAP;
using Assets.Scripts.WandsInput;
using Assets.Scripts.WandsInput.Haptics;
using Assets.Scripts.Workshop;
using BoundarySystem_Ext;
using Cortopia.AI.Memory;
using Cortopia.AI.Predictions;
using Cortopia.BE.Runtime;
using Cortopia.BE.Runtime.Actions;
using Cortopia.BE.Runtime.Actions.Conditions;
using Cortopia.BE.Runtime.Actions.Connectors;
using Cortopia.BE.Runtime.Components.Senses.Hearing;
using Cortopia.BE.Runtime.Components.Senses.Sight;
using Cortopia.BE.Runtime.Components.Senses.Sight.Collections;
using Cortopia.BE.Runtime.Instance;
using Cortopia.CortopiaAttributes;
using Cortopia.PlayFabManager;
using Cortopia.Scripts.AI;
using Cortopia.Scripts.AI.Casting;
using Cortopia.Scripts.AI.Casting.Interfaces;
using Cortopia.Scripts.AI.Casting.Spells;
using Cortopia.Scripts.AI.Movement;
using Cortopia.Scripts.AI.Params;
using Cortopia.Scripts.AI.Stats;
using Cortopia.Scripts.AI.Targeting;
using Cortopia.Scripts.Aiming;
using Cortopia.Scripts.Animation.Constraints;
using Cortopia.Scripts.Attributes;
using Cortopia.Scripts.Enums;
using Cortopia.Scripts.InteractObjects;
using Cortopia.Scripts.Network;
using Cortopia.Scripts.Pawns;
using Cortopia.Scripts.Platform;
using Cortopia.Scripts.Player;
using Cortopia.Scripts.Player.Input;
using Cortopia.Scripts.Season;
using Cortopia.Scripts.Spells.Tile;
using Cortopia.Scripts.Spells.Utils;
using Cortopia.Scripts.UI;
using Cortopia.Scripts.UI.HUD;
using Cortopia.Scripts.Vanity;
using Cortopia.Scripts.Wand;
using Cortopia.Scripts.Wand.Properties;
using Cortopia.Scripts.WandsInput;
using CortopiaEvents;
using DG.Tweening;
using ExitGames.Client.Photon;
using I2.Loc;
using InControl;
using LitJson;
using MIVR;
using MagicalFX;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Serialization;
using OVR.OpenVR;
using Oculus.Platform;
using Oculus.Platform.Models;
using Oculus.Spatializer.Propagation;
using Photon.Pun;
using Photon.Realtime;
using Photon.Voice.PUN;
using Photon.Voice.Unity;
using PlayFab;
using PlayFab.ClientModels;
using PlayFab.Json;
using PlayFab.MultiplayerModels;
using PlayFab.SharedModels;
using Pvr_UnitySDKAPI;
using Pvr_UnitySDKAPI.Achievement;
using RootMotion.FinalIK;
using TMPro;
using UnityEngine;
using UnityEngine.Audio;
using UnityEngine.EventSystems;
using UnityEngine.Events;
using UnityEngine.Experimental.Rendering;
using UnityEngine.Networking;
using UnityEngine.PostProcessing;
using UnityEngine.Purchasing;
using UnityEngine.Rendering;
using UnityEngine.SceneManagement;
using UnityEngine.U2D;
using UnityEngine.UI;
using UnityEngine.XR;
using Valve.VR;
using Viveport;
using Viveport.Core;
using Viveport.Internal;

[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: SecurityPermission(SecurityAction.RequestMinimum, SkipVerification = true)]
[assembly: AssemblyVersion("0.0.0.0")]
[module: UnverifiableCode]
public class DecalHandler : MonoBehaviour
{
	private Material material;

	private Projector proj;

	private Shader shader;

	private Material TempMaterial;

	public float time;

	private float OneProcent;

	private float currentValue = 1f;

	public float FadeOutTime = 5f;

	private float CurrentTime;

	public float directionBlending = 0.5f;

	private void Start()
	{
		proj = base.transform.gameObject.GetComponent<Projector>();
		Ray ray = new Ray(base.transform.position, base.transform.forward);
		if (Physics.Raycast(ray, out var hitInfo))
		{
			if (hitInfo.collider.tag == "Player")
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
			else
			{
				base.transform.parent = hitInfo.transform;
				UnityEngine.Object.Destroy(base.gameObject, FadeOutTime + time);
			}
			Quaternion b = Quaternion.LookRotation(-hitInfo.normal, base.transform.up);
			Quaternion rotation = Quaternion.Slerp(base.transform.rotation, b, directionBlending);
			base.transform.rotation = rotation;
		}
		material = proj.material;
		shader = material.shader;
		OneProcent = 1f / time;
		TempMaterial = new Material(shader);
		TempMaterial.CopyPropertiesFromMaterial(material);
		TempMaterial.SetFloat("_FadeOutValue", 1f);
		proj.material = TempMaterial;
	}

	private void Update()
	{
		CurrentTime += 1f * Time.deltaTime;
		if (CurrentTime >= FadeOutTime)
		{
			currentValue -= OneProcent * Time.deltaTime;
			if (currentValue <= 0f)
			{
				currentValue = 0f;
			}
			TempMaterial.SetFloat("_FadeOutValue", currentValue);
		}
	}
}
[RequireComponent(typeof(Camera))]
public class EnableCameraDepthInForward : MonoBehaviour
{
	private void Start()
	{
		Set();
	}

	private void Set()
	{
		if (GetComponent<Camera>().depthTextureMode == DepthTextureMode.None)
		{
			GetComponent<Camera>().depthTextureMode = DepthTextureMode.Depth;
		}
	}
}
public class ParticleLockedRoll : MonoBehaviour
{
	private ParticleSystem Ps;

	private ParticleSystem.Particle[] particles;

	private float lastRotation;

	private void Start()
	{
		Ps = base.transform.gameObject.GetComponent<ParticleSystem>();
	}

	private void LateUpdate()
	{
		InitializeIfneeded();
		int num = Ps.GetParticles(particles);
		if (Camera.main == null)
		{
			return;
		}
		float z = Camera.main.transform.rotation.eulerAngles.z;
		float num2 = z - lastRotation;
		if (lastRotation != z)
		{
			for (int i = 0; i < num; i++)
			{
				particles[i].rotation += num2;
			}
			lastRotation = z;
			Ps.SetParticles(particles, num);
		}
	}

	private void InitializeIfneeded()
	{
		if (particles == null || particles.Length < Ps.main.maxParticles)
		{
			particles = new ParticleSystem.Particle[Ps.main.maxParticles];
		}
	}
}
public class PortalPosition : MonoBehaviour
{
	public GameObject tempEnemy;

	private void Start()
	{
		if (tempEnemy != null)
		{
			EnemySpawns(tempEnemy);
		}
	}

	private void EnemySpawns(GameObject enemy)
	{
		Renderer[] componentsInChildren = enemy.GetComponentsInChildren<Renderer>();
		float y = base.transform.position.y;
		Renderer[] array = componentsInChildren;
		foreach (Renderer renderer in array)
		{
			if (renderer.material != null)
			{
				Material material = renderer.material;
				material.SetFloat("_PortalPos", y);
			}
		}
	}
}
[RequireComponent(typeof(LineRenderer))]
public class RFX4_TrailRenderer : MonoBehaviour
{
	public float VertexLifeTime = 2f;

	public float TrailLifeTime = 2f;

	[Range(0.001f, 1f)]
	public float MinVertexDistance = 0.01f;

	public float Gravity = 0.01f;

	public Vector3 Force = new Vector3(0f, 0f, 0f);

	public float InheritVelocity;

	public float Drag = 0.01f;

	[Range(0.001f, 10f)]
	public float Frequency = 1f;

	[Range(0.001f, 10f)]
	public float OffsetSpeed = 0.5f;

	public bool RandomTurbulenceOffset;

	[Range(0.001f, 10f)]
	public float Amplitude = 2f;

	public float TurbulenceStrength = 0.1f;

	public AnimationCurve VelocityByDistance = AnimationCurve.EaseInOut(0f, 1f, 1f, 1f);

	public float AproximatedFlyDistance = -1f;

	public bool SmoothCurves;

	private LineRenderer lineRenderer;

	private List<Vector3> positions;

	private List<float> currentTimes;

	private List<Vector3> velocities;

	[HideInInspector]
	public float currentLifeTime;

	private Transform t;

	private Vector3 prevPosition;

	private Vector3 startPosition;

	private List<Vector3> controlPoints = new List<Vector3>();

	private int curveCount;

	private const float MinimumSqrDistance = 0.01f;

	private const float DivisionThreshold = -0.99f;

	private const float SmoothCurvesScale = 0.5f;

	private float currentVelocity;

	private float turbulenceRandomOffset;

	private bool isInitialized;

	private void Start()
	{
		Init();
		isInitialized = true;
	}

	private void OnEnable()
	{
		if (isInitialized)
		{
			Init();
		}
	}

	private void Init()
	{
		positions = new List<Vector3>();
		currentTimes = new List<float>();
		velocities = new List<Vector3>();
		currentLifeTime = 0f;
		curveCount = 0;
		currentVelocity = 0f;
		t = base.transform;
		prevPosition = t.position;
		startPosition = t.position;
		lineRenderer = GetComponent<LineRenderer>();
		positions.Add(t.position);
		currentTimes.Add(currentLifeTime);
		velocities.Add(Vector3.zero);
		turbulenceRandomOffset = ((!RandomTurbulenceOffset) ? 0f : (UnityEngine.Random.Range(0f, 10000f) / 1000f));
	}

	private void Update()
	{
		UpdatePositionsCount();
		UpdateForce();
		UpdateImpulse();
		UpdateVelocity();
		int lastDeletedIndex = GetLastDeletedIndex();
		RemovePositionsBeforeIndex(lastDeletedIndex);
		if (SmoothCurves && positions.Count > 2)
		{
			InterpolateBezier(positions, 0.5f);
			List<Vector3> drawingPoints = GetDrawingPoints();
			lineRenderer.positionCount = drawingPoints.Count;
			lineRenderer.SetPositions(drawingPoints.ToArray());
		}
		else
		{
			lineRenderer.positionCount = positions.Count;
			lineRenderer.SetPositions(positions.ToArray());
		}
	}

	private int GetLastDeletedIndex()
	{
		int result = -1;
		int count = currentTimes.Count;
		for (int i = 1; i < count; i++)
		{
			currentTimes[i] -= Time.deltaTime;
			if (currentTimes[i] <= 0f)
			{
				result = i;
			}
		}
		return result;
	}

	private void UpdatePositionsCount()
	{
		if (!(TrailLifeTime > 0.0001f) || !(currentLifeTime > TrailLifeTime))
		{
			currentLifeTime += Time.deltaTime;
			Vector3 vector = ((positions.Count == 0) ? Vector3.zero : positions[positions.Count - 1]);
			if (Mathf.Abs((t.position - vector).magnitude) > MinVertexDistance && positions.Count > 0)
			{
				AddInterpolatedPositions(vector, t.position);
			}
		}
	}

	private void AddInterpolatedPositions(Vector3 start, Vector3 end)
	{
		float magnitude = (start - end).magnitude;
		int num = (int)(magnitude / MinVertexDistance);
		float num2 = currentTimes.LastOrDefault();
		Vector3 zero = Vector3.zero;
		for (int i = 1; i <= num - 1; i++)
		{
			Vector3 item = start + (end - start) * i * 1f / num;
			float item2 = num2 + (VertexLifeTime - num2) * (float)i * 1f / (float)num;
			positions.Add(item);
			currentTimes.Add(item2);
			velocities.Add(zero);
		}
	}

	private void RemovePositionsBeforeIndex(int lastDeletedIndex)
	{
		if (lastDeletedIndex != -1)
		{
			int num = positions.Count - lastDeletedIndex;
			if (num == 1)
			{
				positions.Clear();
				currentTimes.Clear();
				velocities.Clear();
			}
			else
			{
				positions.RemoveRange(0, lastDeletedIndex);
				currentTimes.RemoveRange(0, lastDeletedIndex);
				velocities.RemoveRange(0, lastDeletedIndex);
			}
		}
	}

	private void UpdateForce()
	{
		if (positions.Count < 1)
		{
			return;
		}
		Vector3 vector = Gravity * Vector3.down * Time.deltaTime;
		Vector3 vector2 = t.rotation * Force * Time.deltaTime;
		for (int i = 0; i < positions.Count; i++)
		{
			Vector3 zero = Vector3.zero;
			if (TurbulenceStrength > 1E-06f)
			{
				Vector3 vector3 = positions[i] / Frequency;
				float num = (Time.time + turbulenceRandomOffset) * OffsetSpeed;
				vector3 -= num * Vector3.one;
				zero.x += (Mathf.PerlinNoise(vector3.z, vector3.y) * 2f - 1f) * Amplitude * Time.deltaTime * TurbulenceStrength / 10f;
				zero.y += (Mathf.PerlinNoise(vector3.x, vector3.z) * 2f - 1f) * Amplitude * Time.deltaTime * TurbulenceStrength / 10f;
				zero.z += (Mathf.PerlinNoise(vector3.y, vector3.x) * 2f - 1f) * Amplitude * Time.deltaTime * TurbulenceStrength / 10f;
			}
			Vector3 vector4 = vector + vector2 + zero;
			if (AproximatedFlyDistance > 0.01f)
			{
				float num2 = Mathf.Abs((positions[i] - startPosition).magnitude);
				vector4 *= VelocityByDistance.Evaluate(Mathf.Clamp01(num2 / AproximatedFlyDistance));
			}
			velocities[i] += vector4;
		}
	}

	private void UpdateImpulse()
	{
		if (velocities.Count != 0)
		{
			currentVelocity = (t.position - prevPosition).magnitude / Time.deltaTime;
			Vector3 normalized = (t.position - prevPosition).normalized;
			prevPosition = t.position;
			velocities[velocities.Count - 1] += currentVelocity * InheritVelocity * normalized * Time.deltaTime;
		}
	}

	private void UpdateVelocity()
	{
		if (velocities.Count == 0)
		{
			return;
		}
		int count = positions.Count;
		for (int i = 0; i < count; i++)
		{
			if (Drag > 1E-05f)
			{
				velocities[i] -= Drag * velocities[i] * Time.deltaTime;
			}
			if (velocities[i].magnitude < 1E-05f)
			{
				velocities[i] = Vector3.zero;
			}
			positions[i] += velocities[i] * Time.deltaTime;
		}
	}

	public void InterpolateBezier(List<Vector3> segmentPoints, float scale)
	{
		controlPoints.Clear();
		if (segmentPoints.Count < 2)
		{
			return;
		}
		for (int i = 0; i < segmentPoints.Count; i++)
		{
			if (i == 0)
			{
				Vector3 vector = segmentPoints[i];
				Vector3 vector2 = segmentPoints[i + 1];
				Vector3 vector3 = vector2 - vector;
				Vector3 item = vector + scale * vector3;
				controlPoints.Add(vector);
				controlPoints.Add(item);
			}
			else if (i == segmentPoints.Count - 1)
			{
				Vector3 vector4 = segmentPoints[i - 1];
				Vector3 vector5 = segmentPoints[i];
				Vector3 vector6 = vector5 - vector4;
				Vector3 item2 = vector5 - scale * vector6;
				controlPoints.Add(item2);
				controlPoints.Add(vector5);
			}
			else
			{
				Vector3 vector7 = segmentPoints[i - 1];
				Vector3 vector8 = segmentPoints[i];
				Vector3 vector9 = segmentPoints[i + 1];
				Vector3 normalized = (vector9 - vector7).normalized;
				Vector3 item3 = vector8 - scale * normalized * (vector8 - vector7).magnitude;
				Vector3 item4 = vector8 + scale * normalized * (vector9 - vector8).magnitude;
				controlPoints.Add(item3);
				controlPoints.Add(vector8);
				controlPoints.Add(item4);
			}
		}
		curveCount = (controlPoints.Count - 1) / 3;
	}

	public List<Vector3> GetDrawingPoints()
	{
		List<Vector3> list = new List<Vector3>();
		for (int i = 0; i < curveCount; i++)
		{
			List<Vector3> list2 = FindDrawingPoints(i);
			if (i != 0)
			{
				list2.RemoveAt(0);
			}
			list.AddRange(list2);
		}
		return list;
	}

	private List<Vector3> FindDrawingPoints(int curveIndex)
	{
		List<Vector3> list = new List<Vector3>();
		Vector3 item = CalculateBezierPoint(curveIndex, 0f);
		Vector3 item2 = CalculateBezierPoint(curveIndex, 1f);
		list.Add(item);
		list.Add(item2);
		FindDrawingPoints(curveIndex, 0f, 1f, list, 1);
		return list;
	}

	private int FindDrawingPoints(int curveIndex, float t0, float t1, List<Vector3> pointList, int insertionIndex)
	{
		Vector3 vector = CalculateBezierPoint(curveIndex, t0);
		Vector3 vector2 = CalculateBezierPoint(curveIndex, t1);
		if ((vector - vector2).sqrMagnitude < 0.01f)
		{
			return 0;
		}
		float num = (t0 + t1) / 2f;
		Vector3 vector3 = CalculateBezierPoint(curveIndex, num);
		Vector3 normalized = (vector - vector3).normalized;
		Vector3 normalized2 = (vector2 - vector3).normalized;
		if (Vector3.Dot(normalized, normalized2) > -0.99f || Mathf.Abs(num - 0.5f) < 0.0001f)
		{
			int num2 = 0;
			num2 += FindDrawingPoints(curveIndex, t0, num, pointList, insertionIndex);
			pointList.Insert(insertionIndex + num2, vector3);
			num2++;
			return num2 + FindDrawingPoints(curveIndex, num, t1, pointList, insertionIndex + num2);
		}
		return 0;
	}

	public Vector3 CalculateBezierPoint(int curveIndex, float t)
	{
		int num = curveIndex * 3;
		Vector3 p = controlPoints[num];
		Vector3 p2 = controlPoints[num + 1];
		Vector3 p3 = controlPoints[num + 2];
		Vector3 p4 = controlPoints[num + 3];
		return CalculateBezierPoint(t, p, p2, p3, p4);
	}

	private Vector3 CalculateBezierPoint(float t, Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3)
	{
		float num = 1f - t;
		float num2 = t * t;
		float num3 = num * num;
		float num4 = num3 * num;
		float num5 = num2 * t;
		Vector3 vector = num4 * p0;
		vector += 3f * num3 * t * p1;
		vector += 3f * num * num2 * p2;
		return vector + num5 * p3;
	}
}
public class CustomDissolve : MonoBehaviour
{
	public enum EventType
	{
		StartDissolve,
		EndDissolve,
		StartUndissolve,
		EndUnsidissolve
	}

	public class EventInfo
	{
		public EventType messageInfo;

		public CustomDissolve sender;
	}

	public delegate void CallbackEventHandler(EventInfo eventInfo);

	public float dissolveDuration = 5f;

	public Texture2D noiseTexture;

	public Color dissolveColor = Color.white;

	[Range(0f, 10f)]
	public float dissolveThickness = 3f;

	public float tilingX = 1f;

	public float tilingY = 1f;

	private List<Shader> originalObjetsShader;

	private Shader dissolveShader;

	private bool dissolve;

	private float t;

	private float startValue;

	private float endValue;

	private UnityEngine.Component[] renderers;

	public CallbackEventHandler CallBackFunction;

	private EventType nextType;

	private void Start()
	{
		dissolveShader = Shader.Find("3y3net/CustomDissolve");
		renderers = GetComponentsInChildren<Renderer>();
		originalObjetsShader = new List<Shader>();
		if (!(dissolveShader == null))
		{
			ReplaceShaders();
		}
	}

	private void Update()
	{
		if (!dissolve)
		{
			return;
		}
		UnityEngine.Component[] array = renderers;
		for (int i = 0; i < array.Length; i++)
		{
			Renderer renderer = (Renderer)array[i];
			Material[] materials = renderer.materials;
			foreach (Material material in materials)
			{
				material.SetFloat("_DissolveAmount", Mathf.Lerp(startValue, endValue, t));
			}
		}
		if (t < 1f)
		{
			t += Time.deltaTime / dissolveDuration;
			return;
		}
		dissolve = false;
		if (CallBackFunction != null)
		{
			EventInfo eventInfo = new EventInfo();
			eventInfo.sender = this;
			eventInfo.messageInfo = nextType;
			CallBackFunction(eventInfo);
		}
	}

	public void Dissolve()
	{
		t = 0f;
		startValue = 1f;
		endValue = 0f;
		dissolve = true;
		if (CallBackFunction != null)
		{
			EventInfo eventInfo = new EventInfo();
			eventInfo.sender = this;
			eventInfo.messageInfo = EventType.StartDissolve;
			CallBackFunction(eventInfo);
		}
		nextType = EventType.EndDissolve;
	}

	public void Undissolve()
	{
		t = 0f;
		startValue = 0f;
		endValue = 1f;
		dissolve = true;
		if (CallBackFunction != null)
		{
			EventInfo eventInfo = new EventInfo();
			eventInfo.sender = this;
			eventInfo.messageInfo = EventType.StartUndissolve;
			CallBackFunction(eventInfo);
		}
		nextType = EventType.EndUnsidissolve;
	}

	public void ReplaceShaders()
	{
		UnityEngine.Component[] array = renderers;
		for (int i = 0; i < array.Length; i++)
		{
			Renderer renderer = (Renderer)array[i];
			Material[] materials = renderer.materials;
			foreach (Material material in materials)
			{
				originalObjetsShader.Add(material.shader);
				material.shader = dissolveShader;
				material.SetTexture("_Noise", noiseTexture);
				material.SetColor("_DissolveColor", dissolveColor);
				material.SetFloat("_GlowThickness", dissolveThickness);
				material.SetFloat("_GlowThickness", dissolveThickness);
				material.SetTextureScale("_Noise", new Vector2(tilingX, tilingY));
			}
		}
	}

	public void RestoreShaders()
	{
		int num = 0;
		UnityEngine.Component[] componentsInChildren = GetComponentsInChildren<Renderer>();
		UnityEngine.Component[] array = componentsInChildren;
		for (int i = 0; i < array.Length; i++)
		{
			Renderer renderer = (Renderer)array[i];
			Material[] materials = renderer.materials;
			foreach (Material material in materials)
			{
				material.shader = originalObjetsShader[num++];
			}
		}
	}
}
namespace MagicalFX
{
	public class FX_Rotation : MonoBehaviour
	{
		public Vector3 Speed = Vector3.up;

		private void Start()
		{
		}

		private void FixedUpdate()
		{
			base.transform.Rotate(Speed);
		}
	}
}
namespace Cortopia.Scripts.AI.Actions
{
	public class ChangeStatsProfile : BE_Action
	{
		public StatsManagementProfileType NewProfile;

		[SerializeField]
		[HideInInspector]
		private StatsDataManager m_statsDataManager;

		public override void Initialize()
		{
			base.Description = "Uses stats component to change stats management profile type";
		}

		public override void Process()
		{
			if (m_statsDataManager == null)
			{
				m_statsDataManager = GetValidComponent<StatsDataManager>(OwnerNode.Owner);
			}
			if (m_statsDataManager.CurrentProfileType != NewProfile)
			{
				m_statsDataManager.ChangeProfile(NewProfile);
			}
			Finish();
		}
	}
	public class PredictingIncomingProjectile : BE_Action
	{
		public float WithinDuration = 0.5f;

		[SerializeField]
		[HideInInspector]
		private Prediction m_prediction;

		public override void Initialize()
		{
			base.Description = "Uses Prediction-component to check weither a projectile is predicted to hit the current tile within a timeframe";
			AddTransitionConnector(new TransitionConnector("True", 0));
			AddTransitionConnector(new TransitionConnector("False", 1));
		}

		public override void Process()
		{
			if (m_prediction == null)
			{
				m_prediction = GetValidComponent<Prediction>(OwnerNode.Owner);
			}
			if (m_prediction.IsPredictingIncomingProjectile(WithinDuration))
			{
				OwnerNode.PerformTransition(GetTransitionIndexByName("True"));
			}
			else
			{
				OwnerNode.PerformTransition(GetTransitionIndexByName("False"));
			}
		}
	}
	public class StatCheck : RelationalCondition
	{
		public enum StatType
		{
			Health,
			Mana
		}

		public StatType Type;

		public RelationalOperator Relation;

		public float Value;

		public bool UseFactor;

		[SerializeField]
		[HideInInspector]
		private StatsDataManager m_statsDataManager;

		public override void Initialize()
		{
			base.Description = "Uses the sight sense to determin if a target is in line of sight within distance, returns the closest target. The distance param defaults to the sight's FOV-distance if distance is equal to or less than zero";
			AddTransitionConnector(new TransitionConnector("True", 0));
			AddTransitionConnector(new TransitionConnector("False", 1));
		}

		public override void Process()
		{
			if (m_statsDataManager == null)
			{
				m_statsDataManager = GetValidComponent<StatsDataManager>(OwnerNode.Owner);
			}
			float currentValue = GetCurrentValue();
			if (Evaluate(Relation, currentValue, Value))
			{
				OwnerNode.PerformTransition(GetTransitionIndexByName("True"));
			}
			else
			{
				OwnerNode.PerformTransition(GetTransitionIndexByName("False"));
			}
		}

		private float GetCurrentValue()
		{
			return Type switch
			{
				StatType.Health => (!UseFactor) ? m_statsDataManager.GetCurrentHealth() : m_statsDataManager.GetCurrentHealthFactor(), 
				StatType.Mana => (!UseFactor) ? m_statsDataManager.GetCurrentMana() : m_statsDataManager.GetCurrentManaFactor(), 
				_ => 0f, 
			};
		}

		public override void DrawCustomProperties()
		{
		}
	}
}
namespace Cortopia.Scripts.AI
{
	public class BotAI : BE_AI, IBotCaster, IBotMover, IBotTargeter
	{
		[StructLayout(LayoutKind.Sequential, Size = 1)]
		private struct SpellPriorityPaths
		{
			public const string Default = "Bots/VindicatorSpellPriority";

			public const string Impossible = "Bots/ImpossibleSpellPriority";
		}

		private static readonly float[] sm_difficultyLevels = new float[6] { 0.1f, 0.35f, 0.65f, 1f, 1f, 1f };

		[Header("Scaling Difficulty")]
		[SerializeField]
		private bool m_useScalingDifficulty = true;

		[SerializeField]
		private float m_levelBasedScalingRatio = 0.66f;

		[SerializeField]
		private int m_minLevel = 1;

		[SerializeField]
		private int m_maxLevel = 10;

		[SerializeField]
		private AnimationCurve m_levelScaling;

		[SerializeField]
		private int m_minRating = 1000;

		[SerializeField]
		private int m_maxRating = 2500;

		[SerializeField]
		private AnimationCurve m_ratingScaling;

		[Header("Settings")]
		[SerializeField]
		[Range(0f, 1f)]
		private float m_accurracy = 1f;

		[SerializeField]
		[Range(0f, 0.3f)]
		private float m_reactionTime = 0.15f;

		[Header("Spells")]
		[SerializeField]
		private Spell[] m_availableSpells = Array.Empty<Spell>();

		private BotControl m_botControl;

		private BotWandControl m_wandControl;

		private float m_resetAllOutDuration;

		private EventToken m_damageTakenEventToken;

		private EventToken m_teleportEndEventToken;

		private EventToken m_matchEndedEventToken;

		public const float MinAccurracy = 0f;

		public const float MaxAccuracy = 1f;

		public const float MinTeleportCooldown = 0.2f;

		private const float MinReactionTime = 0f;

		private const float MaxReactionTime = 0.3f;

		private const float ResetAllOutDelay = 30f;

		private const float CooldownMultiplier = 20f;

		private const float ReactiveActionMultiplier = 2f;

		private const float MinHandMovementDuration = 0.05f;

		private const float MaxHandMovementDuration = 0.2f;

		private Collider[] m_currentVisibleTeleportColliders = new Collider[32];

		private float m_difficulty;

		private float m_defensiveResultDuration;

		private bool m_defensiveSuccessResult;

		private int m_backupSpellAttempt;

		public Spell[] AvailableSpells
		{
			[CompilerGenerated]
			get
			{
				return m_availableSpells;
			}
		}

		public TeleportHandler TeleportHandler
		{
			[CompilerGenerated]
			get
			{
				return m_botControl.TeleportHandler;
			}
		}

		public WandManager Wand
		{
			[CompilerGenerated]
			get
			{
				return m_botControl.Wand;
			}
		}

		public BotWandControl WandControl
		{
			[CompilerGenerated]
			get
			{
				return (!(m_wandControl != null)) ? (m_wandControl = m_botControl.Wand.GetWandControl() as BotWandControl) : m_wandControl;
			}
		}

		public Aim Aim
		{
			[CompilerGenerated]
			get
			{
				return m_botControl.Aim;
			}
		}

		public SpellPriorities SpellPriority { get; private set; }

		public Tile CurrentTile
		{
			[CompilerGenerated]
			get
			{
				return m_botControl.GetCurrentTile();
			}
		}

		public Tile HighlightedTile
		{
			[CompilerGenerated]
			get
			{
				return m_botControl.HighlightedTile;
			}
		}

		public bool HasActiveCollarsOnCurrentTile
		{
			[CompilerGenerated]
			get
			{
				return Prediction.IsCollarsActiveOnTile(CurrentTile);
			}
		}

		public bool IsCurrentTileInescapeable
		{
			[CompilerGenerated]
			get
			{
				return CurrentTile.GetEffectActive(Spell.Spell_PetrifyingPrison) || HasActiveCollarsOnCurrentTile;
			}
		}

		public bool IsActivatingPickup { get; private set; }

		public PickupBase ActivePickup { get; private set; }

		public BotTargeting Targeting { get; private set; }

		public BotCharacter Character { get; private set; }

		public CharacterMovement CharacterMovement { get; private set; }

		public StatsDataManager StatsDataManager { get; private set; }

		public BehaviourParams BehaviourParams { get; private set; } = new BehaviourParams();


		public BotMovement BotMovement { get; private set; }

		public Prediction Prediction { get; private set; }

		public Sight Sight { get; private set; }

		public Memory Memory { get; private set; }

		public Hearing Hearing { get; private set; }

		public BotSpellCasting SpellCasting { get; private set; }

		public bool Enabled { get; set; }

		public float TeleportCost { get; private set; }

		protected override void OnEnable()
		{
			base.OnEnable();
			m_damageTakenEventToken = EventHub.Subscribe<Events.DamageTakenEvent>(OnDamageTaken);
			m_teleportEndEventToken = EventHub.Subscribe<Events.TeleportEndedEvent>(OnTeleportEnd);
			m_matchEndedEventToken = EventHub.Subscribe<Events.MatchEndedEvent>(OnMatchEnded);
			SpellCasting.enabled = true;
			Memory.enabled = true;
		}

		protected void OnDisable()
		{
			EventHub.Unsubscribe<Events.DamageTakenEvent>(m_damageTakenEventToken);
			EventHub.Unsubscribe<Events.TeleportEndedEvent>(m_teleportEndEventToken);
			EventHub.Unsubscribe<Events.MatchEndedEvent>(m_matchEndedEventToken);
			SpellCasting.enabled = false;
			Memory.enabled = false;
		}

		public void Initialize(BotControl botControl, BotCharacter character, Sight sight, Hearing hearing)
		{
			BehaviourParams.Reset();
			base.Objective = new BE_Objective(IsPlayerDead);
			m_botControl = botControl;
			Character = character;
			Sight = sight;
			Hearing = hearing;
			Memory = GetComponent<Memory>();
			StatsDataManager = GetComponent<StatsDataManager>();
			CharacterMovement = Character.GetComponent<CharacterMovement>();
			Prediction = GetComponent<Prediction>();
			BotMovement = new BotMovement(this);
			SetSelectedDifficultyLevel((int)BotDifficultyUtils.DifficultyLevel);
			LoadSpellPriority();
			Targeting = new BotTargeting(this, m_accurracy, Mathf.Max(1f, m_reactionTime * 10f));
		}

		public void RandomizeSpells()
		{
			SpellCasting = GetComponent<BotSpellCasting>();
			SpellCasting.RandomizeSpells();
			m_availableSpells = new Spell[SpellCasting.Spells.Length];
			for (int i = 0; i < SpellCasting.Spells.Length; i++)
			{
				if (SpellCasting.Spells[i] != null)
				{
					m_availableSpells[i] = SpellCasting.Spells[i].SpellType;
				}
			}
		}

		private void SetSelectedDifficultyLevel(int level)
		{
			SetBotDifficulty(sm_difficultyLevels[level - 1]);
		}

		private void LoadSpellPriority()
		{
			string path = ((BotDifficultyUtils.DifficultyLevel != BotDifficultyLevel.Impossible) ? "Bots/VindicatorSpellPriority" : "Bots/ImpossibleSpellPriority");
			SpellPriority = Resources.Load<SpellPriorities>(path);
		}

		private void SetBotDifficulty(float difficulty)
		{
			m_difficulty = difficulty;
			m_accurracy = Mathf.Lerp(0f, 1f, m_difficulty);
			m_reactionTime = Mathf.Lerp(0.3f, 0f, m_difficulty);
			BehaviourParams.DecisionParams.ReactionToActionTime = m_reactionTime * 2f;
			BehaviourParams.DecisionParams.CooldownTime = m_reactionTime * 20f;
			BehaviourParams.DecisionParams.TeleportCooldownTime = 0.2f + m_reactionTime * 20f;
			BehaviourParams.MovementParams.HandMovementDuration = Mathf.Lerp(0.2f, 0.05f, m_difficulty);
		}

		private void SetScalingDifficulty(int level, int rating)
		{
			if (m_useScalingDifficulty)
			{
				float time = Mathf.Clamp((float)(level - m_minLevel) / (float)(m_maxLevel - m_minLevel), 0f, 1f);
				float time2 = Mathf.Clamp((float)(rating - m_minRating) / (float)(m_maxRating - m_minRating), 0f, 1f);
				float num = m_levelScaling.Evaluate(time) * m_levelBasedScalingRatio;
				float num2 = m_ratingScaling.Evaluate(time2) * (1f - m_levelBasedScalingRatio);
				SetBotDifficulty(num + num2);
			}
		}

		[Conditional("UNITY_EDITOR")]
		private void AddToDebugString(string s)
		{
		}

		[Conditional("UNITY_EDITOR")]
		private void PrintDebugString()
		{
		}

		public void AbortSpellCasting()
		{
			Wand.AbortSpellCasting();
			SpellCasting.ActiveSpell?.Deactivate();
			BehaviourParams.SpellParams.UseUrgentTeleport = false;
			BehaviourParams.SpellParams.IsDefensiveSpellActive = false;
		}

		private bool IsPlayerDead()
		{
			return PlayerManager.Instance.PlayerControl.Health <= 0f;
		}

		private void OnDamageTaken(Events.DamageTakenEvent eventData)
		{
			if (!(eventData.CharacterControl != m_botControl))
			{
				BehaviourParams.DecisionParams.IsAvoidingDamage = true;
				if (!Targeting.HasValidAimTarget(CurrentTile))
				{
					BotMovement.FaceAvailableTile();
				}
			}
		}

		private void OnTeleportEnd(Events.TeleportEndedEvent eventData)
		{
			EndTeleport();
		}

		private void OnMatchEnded(Events.MatchEndedEvent eventData)
		{
			SpellCasting.enabled = false;
			Memory.enabled = false;
		}

		public void TryTrackTileHit()
		{
			m_botControl.TryTrackTileHit(WandHand.Right);
		}

		public void Teleport(BE_Action action)
		{
			if (IsCurrentTileInescapeable)
			{
				TryCastBackupSpell(action);
			}
			else
			{
				CastSpell(SpellActionType.Teleport, action);
			}
		}

		private void CastSpell(SpellActionType spellActionType, BE_Action action)
		{
			if (IsActivatingPickup)
			{
				DeactivatePickup();
			}
			SpellCasting.CastAction(spellActionType, action);
		}

		private void TryCastBackupSpell(BE_Action action)
		{
			switch (m_backupSpellAttempt)
			{
			default:
				return;
			case 0:
				PrimaryAttack(action);
				break;
			case 1:
				SecondaryAttack(action);
				break;
			case 2:
				Utility(action);
				break;
			}
			m_backupSpellAttempt = (m_backupSpellAttempt + 1) % 3;
		}

		public void PrimaryAttack(BE_Action action)
		{
			CastSpell(SpellActionType.Primary, action);
		}

		public void SecondaryAttack(BE_Action action)
		{
			CastSpell(SpellActionType.Secondary, action);
		}

		public void Utility(BE_Action action)
		{
			CastSpell(SpellActionType.Utility, action);
		}

		public void Defend(BE_Action action)
		{
			if (CanTryToDefend())
			{
				CastSpell(SpellActionType.Defensive, action);
			}
		}

		public void AvoidDamageAction(BE_Action action)
		{
			if (m_botControl.TeleportHandler.isActiveAndEnabled && !m_botControl.IsTeleportLocked && !IsCurrentTileInescapeable)
			{
				BehaviourParams.SpellParams.UseUrgentTeleport = true;
				Teleport(action);
			}
			else
			{
				SpellCasting.DefendInstantly();
			}
		}

		public void FacePlayer(BE_Action action)
		{
			if (Sight.IsInLineOfSight(PlayerManager.Instance.PlayerControl.Collider) && !BehaviourParams.DecisionParams.HasReactedToSound)
			{
				BotMovement.FacePlayer();
			}
			else
			{
				Teleport(action);
			}
			BehaviourParams.DecisionParams.HasReactedToSound = true;
		}

		public void AvoidDamageInstantly()
		{
			if (m_botControl.TeleportHandler.isActiveAndEnabled && !m_botControl.IsTeleportLocked && PunSingleton<TimeManager>.Instance.CurrentMatchTime - Memory.LastTeleportTime >= m_reactionTime && !IsCurrentTileInescapeable)
			{
				SpellCasting.TeleportInstantly();
			}
			else
			{
				SpellCasting.DefendInstantly();
			}
		}

		public void DefendInstantly()
		{
			if (CanTryToDefend())
			{
				SpellCasting.DefendInstantly();
			}
		}

		[Conditional("UNITY_EDITOR")]
		private void DrawCoordinate(Vector3 pos, Color color)
		{
			float num = 0.2f;
			UnityEngine.Debug.DrawLine(pos + new Vector3(0f - num, 0f, 0f), pos + new Vector3(num, 0f, 0f), color, 2f);
			UnityEngine.Debug.DrawLine(pos + new Vector3(0f, 0f - num, 0f), pos + new Vector3(0f, num, 0f), color, 2f);
			UnityEngine.Debug.DrawLine(pos + new Vector3(0f, 0f, 0f - num), pos + new Vector3(0f, 0f, num), color, 2f);
		}

		public void TryFindHealth(BE_Action action)
		{
			List<Tile> list = new List<Tile>(3);
			foreach (Tile allTile in PunSingleton<TileManager>.Instance.AllTiles)
			{
				foreach (PickupBase pickup in allTile.Pickups)
				{
					if (pickup.PickUpType == PickupType.Health && (allTile == CurrentTile || allTile.IsUnoccupied) && !allTile.GetEffectActive(Spell.Spell_CurseOfTheUndead) && !allTile.GetEffectActive(Spell.Spell_AcidCloud))
					{
						list.Add(allTile);
					}
				}
			}
			if (list.Count < 1 || m_botControl.IsCurseActive)
			{
				Utility(action);
			}
			else
			{
				Tile currentTile = m_botControl.GetCurrentTile();
				if (list.Contains(currentTile))
				{
					foreach (PickupBase pickup2 in currentTile.Pickups)
					{
						if (pickup2.PickUpType == PickupType.Health)
						{
							if (BotMovement.IsLookingAtTarget())
							{
								ActivatePickup(pickup2);
							}
							else if (!BotMovement.HasRotationTarget)
							{
								BotMovement.LookAtCollider(pickup2.Collider);
							}
							return;
						}
					}
				}
				int num = Sight.FindTargets(m_currentVisibleTeleportColliders, Constants.BotTeleportMask);
				for (int i = 0; i < num; i++)
				{
					Tile component = m_currentVisibleTeleportColliders[i].transform.parent.GetComponent<Tile>();
					if (list.Contains(component) && TryTeleportToTile(component))
					{
						return;
					}
				}
			}
			Teleport(action);
		}

		private void ActivatePickup(PickupBase pickup)
		{
			IsActivatingPickup = true;
			ActivePickup = pickup;
			ActivePickup.LookEnter();
		}

		private void DeactivatePickup()
		{
			ActivePickup.LookExit();
			ActivePickup = null;
			IsActivatingPickup = false;
		}

		private void StartTeleport()
		{
		}

		private void EndTeleport()
		{
			BehaviourParams.MovementParams.TurnInPlaceTimes = 0;
			BehaviourParams.DecisionParams.IsAvoidingDamage = false;
			BehaviourParams.SpellParams.UseUrgentTeleport = false;
			BehaviourParams.DecisionParams.HasReactedToSound = false;
			Memory.LastTeleportTime = PunSingleton<TimeManager>.Instance.CurrentMatchTime;
			BehaviourParams.DecisionParams.SetTeleportCooldown(shouldActivate: true);
			Memory.RegisterTileVisited(m_botControl.GetCurrentTile());
		}

		private void HandleAllOutBehaviour()
		{
			if (!StatsDataManager.CurrentProfile.UseAllOutAttack)
			{
				BehaviourParams.SpellParams.AllowedToDepleteMana = false;
			}
			if (!BehaviourParams.SpellParams.AllowedToDepleteMana)
			{
				m_resetAllOutDuration += Time.deltaTime;
				if (m_resetAllOutDuration >= 30f && StatsDataManager.CurrentProfile.UseAllOutAttack)
				{
					BehaviourParams.SpellParams.AllowedToDepleteMana = true;
					m_resetAllOutDuration = 0f;
				}
			}
			if (BehaviourParams.SpellParams.AllowedToDepleteMana && StatsDataManager.GetCurrentMana() <= 0f)
			{
				BehaviourParams.SpellParams.AllowedToDepleteMana = false;
			}
		}

		private void AdaptiveReactions()
		{
			if (Prediction.PredictingInstantDamage)
			{
				DefendInstantly();
			}
			else if (Prediction.AvoidTrajectoryFromTile != null)
			{
				BotMovement.MoveOutOfSightFrom(Prediction.AvoidTrajectoryFromTile);
			}
			else if (Prediction.IsTileUnsafe(m_botControl.GetCurrentTile()))
			{
				int num = Sight.FindTargets(m_currentVisibleTeleportColliders, Constants.BotTeleportMask);
				if (num <= 0)
				{
					BotMovement.FaceAvailableTile();
				}
				BehaviourParams.DecisionParams.IsAvoidingDamage = true;
			}
		}

		public bool TryTeleportToTile(Tile targetTile)
		{
			return !IsCurrentTileInescapeable && SpellCasting.TryTeleportToTile(targetTile);
		}

		private bool CanTryToDefend()
		{
			if (m_difficulty >= 1f)
			{
				return true;
			}
			if (m_defensiveResultDuration <= 0f)
			{
				m_defensiveSuccessResult = UnityEngine.Random.Range(0f, 1f) <= m_difficulty;
				m_defensiveResultDuration = UnityEngine.Random.Range(0f, m_reactionTime);
			}
			return m_defensiveSuccessResult;
		}

		private void UpdateDefensiveSuccesRate()
		{
			if (m_defensiveResultDuration > 0f)
			{
				m_defensiveResultDuration -= Time.deltaTime;
			}
		}

		protected override void Update()
		{
			if (Enabled)
			{
				base.Update();
				UpdateDefensiveSuccesRate();
				BehaviourParams.DecisionParams.UpdateCooldown(Time.deltaTime);
				AdaptiveReactions();
				BotMovement.UpdateMovement();
				HandleAllOutBehaviour();
				if (Sight.IsVisible(PlayerManager.Instance.PlayerControl.Collider))
				{
					Memory.RegisterOpponentTile(PlayerManager.Instance.PlayerControl.GetCurrentTile());
				}
			}
		}

		public void ResetBot()
		{
			Memory.Clear();
			BehaviourParams.MovementParams.SetPreparingFire(setActive: false);
			BehaviourParams.DecisionParams.IsAvoidingDamage = true;
			m_updateInterval = m_reactionTime;
			TeleportCost = m_botControl.WandControl.GetSpell<Tile_Teleport>().GetCastCost();
		}
	}
}
namespace Cortopia.Scripts.AI.Casting
{
	public class BotSpellCasting : MonoBehaviour
	{
		[SerializeField]
		private Spell[] m_primarySpellTypes;

		[SerializeField]
		private Spell[] m_secondarySpellTypes;

		[SerializeField]
		private Spell[] m_utilitySpellTypes;

		[SerializeField]
		private Spell[] m_defensiveSpellTypes;

		private System.Random m_rng = new System.Random();

		private AISpell[] m_currentSpells;

		private BotSpellEvents m_spellEvents;

		public AISpell ActiveSpell { get; private set; }

		public AISpell[] Spells
		{
			get
			{
				if (m_currentSpells == null)
				{
					m_currentSpells = GetRandomSpells();
				}
				return m_currentSpells;
			}
		}

		public void RandomizeSpells()
		{
			m_currentSpells = GetRandomSpells();
		}

		private AISpell[] GetRandomSpells()
		{
			bool flag = BotDifficultyUtils.DifficultyLevel == BotDifficultyLevel.Impossible;
			List<Spell> list = new List<Spell>(5);
			list.Add(Spell.Spell_Teleport);
			List<Spell> list2 = list;
			Spell excludedElement = (flag ? Spell.Spell_MagicMissile : Spell.None);
			list2.Add(m_primarySpellTypes.GetRandomElement(excludedElement));
			excludedElement = (flag ? Spell.Spell_Demi : Spell.None);
			list2.Add(m_secondarySpellTypes.GetRandomElement(excludedElement));
			list2.Add(m_utilitySpellTypes.GetRandomElement());
			list2.Add(m_defensiveSpellTypes.GetRandomElement());
			return GetInstantiatedSpells(list2.ToArray());
		}

		private AISpell[] GetInstantiatedSpells(Spell[] randomSpellTypes)
		{
			m_spellEvents = new BotSpellEvents
			{
				OnPress = OnSpellPress,
				OnRelease = OnSpellRelease
			};
			AISpell[] array = new AISpell[randomSpellTypes.Length];
			for (int i = 0; i < randomSpellTypes.Length; i++)
			{
				array[i] = GetAISpellInstanceFromType(randomSpellTypes[i]);
			}
			return array;
		}

		private AISpell GetAISpellInstanceFromType(Spell spellType)
		{
			BotAI component = GetComponent<BotAI>();
			return spellType switch
			{
				Spell.Spell_BlazingMeteor => new Cortopia.Scripts.AI.Casting.Spells.BlazingMeteor(component, m_spellEvents), 
				Spell.Spell_ChillingClutch => new Cortopia.Scripts.AI.Casting.Spells.ChillingClutch(component, m_spellEvents), 
				Spell.Spell_Demi => new Cortopia.Scripts.AI.Casting.Spells.Demi(component, m_spellEvents), 
				Spell.Spell_DevilsSpit => new Cortopia.Scripts.AI.Casting.Spells.DevilsSpit(component, m_spellEvents), 
				Spell.Spell_ElectricFist => new Cortopia.Scripts.AI.Casting.Spells.ElectricFist(component, m_spellEvents), 
				Spell.Spell_HeavenlyDome => new HeavenlyDome(component, m_spellEvents), 
				Spell.Spell_MagicMissile => new MagicMissile(component, m_spellEvents), 
				Spell.Spell_ShieldOfLight => new ShieldOfLight(component, m_spellEvents), 
				Spell.Spell_SkullSpecter => new Cortopia.Scripts.AI.Casting.Spells.SkullSpecter(component, m_spellEvents), 
				Spell.Spell_SoilSpikes => new SoilSpikes(component, m_spellEvents), 
				Spell.Spell_StoneDemon => new Cortopia.Scripts.AI.Casting.Spells.StoneDemon(component, m_spellEvents), 
				Spell.Spell_Teleport => new Teleport(component, m_spellEvents), 
				_ => null, 
			};
		}

		private void Shuffle<T>(T[] spells)
		{
			int num = spells.Length;
			while (num > 1)
			{
				num--;
				int num2 = m_rng.Next(num + 1);
				T val = spells[num2];
				spells[num2] = spells[num];
				spells[num] = val;
			}
		}

		public void CastAction(SpellActionType spellType, BE_Action action)
		{
			if (Spells[(int)spellType] != null)
			{
				Spells[(int)spellType].CastAction(action);
			}
		}

		private void OnSpellPress(AISpell spell)
		{
			if (ActiveSpell != null && spell != ActiveSpell)
			{
				ActiveSpell.Deactivate();
			}
			ActiveSpell = spell;
		}

		private void OnSpellRelease(AISpell spell)
		{
			ActiveSpell = null;
		}

		public void DefendInstantly()
		{
			((IDefender)Spells[4]).DefendInstantly();
		}

		public void TeleportInstantly()
		{
			((Teleport)Spells[0]).TeleportInstantly();
		}

		public bool TryTeleportToTile(Tile targetTile)
		{
			return ((Teleport)Spells[0]).TryTeleportToTile(targetTile);
		}

		private void Update()
		{
			if (ActiveSpell != null)
			{
				ActiveSpell.Update();
			}
		}
	}
	public struct BotSpellEvents
	{
		public Action<AISpell> OnPress;

		public Action<AISpell> OnRelease;
	}
}
namespace Cortopia.Scripts.AI.Casting.Interfaces
{
	public interface IBotCaster
	{
		BehaviourParams BehaviourParams { get; }

		TeleportHandler TeleportHandler { get; }

		WandManager Wand { get; }

		BotWandControl WandControl { get; }

		Aim Aim { get; }

		Tile CurrentTile { get; }

		Tile HighlightedTile { get; }

		SpellPriorities SpellPriority { get; }

		BotTargeting Targeting { get; }

		BotMovement BotMovement { get; }

		Sight Sight { get; }

		StatsDataManager StatsDataManager { get; }

		Prediction Prediction { get; }

		Memory Memory { get; }

		BotSpellCasting SpellCasting { get; }

		float TeleportCost { get; }

		bool IsCurrentTileInescapeable { get; }

		bool IsActivatingPickup { get; }

		PickupBase ActivePickup { get; }

		void Teleport(BE_Action action);

		void AvoidDamageAction(BE_Action action);

		void AvoidDamageInstantly();

		bool TryTeleportToTile(Tile tile);

		void PrimaryAttack(BE_Action action);

		void SecondaryAttack(BE_Action action);

		void Utility(BE_Action action);

		void Defend(BE_Action action);

		void DefendInstantly();

		void TryTrackTileHit();

		void AbortSpellCasting();
	}
	public interface IBotMover
	{
		BotTargeting Targeting { get; }

		BotCharacter Character { get; }

		Sight Sight { get; }

		CharacterMovement CharacterMovement { get; }

		StatsDataManager StatsDataManager { get; }

		BehaviourParams BehaviourParams { get; }

		BotMovement BotMovement { get; }

		Prediction Prediction { get; }

		Memory Memory { get; }

		BotSpellCasting SpellCasting { get; }

		bool TryTeleportToTile(Tile targetTile);
	}
	public interface IBotTargeter
	{
		Aim Aim { get; }

		Sight Sight { get; }

		BotMovement BotMovement { get; }

		BotWandControl WandControl { get; }

		Tile HighlightedTile { get; }

		void TryTrackTileHit();
	}
}
namespace Cortopia.Scripts.AI.Casting
{
	public enum SpellActionType
	{
		Teleport,
		Primary,
		Secondary,
		Utility,
		Defensive
	}
}
namespace Cortopia.Scripts.AI.Casting.Spells
{
	public abstract class AISpell
	{
		protected const float DefaultRaycastLength = 30f;

		protected IBotCaster m_caster;

		protected BotSpellEvents m_spellEvents;

		private const int MinHoldTime = 50;

		private const int MaxHoldTime = 300;

		public abstract Spell SpellType { get; }

		public SpellBase ActiveSpell
		{
			[CompilerGenerated]
			get
			{
				return m_caster.WandControl.ActiveSpell;
			}
		}

		public AISpell(IBotCaster botCaster, BotSpellEvents spellEvents)
		{
			m_caster = botCaster;
			m_spellEvents = spellEvents;
		}

		public abstract void CastAction(BE_Action action);

		protected void SelectSpellIfNeeded()
		{
			Spell? spell = ActiveSpell?.Type;
			if (spell.GetValueOrDefault() == SpellType && spell.HasValue)
			{
				return;
			}
			int num = -1;
			for (int i = 0; i < m_caster.WandControl.AvailableSpells.Count; i++)
			{
				if (m_caster.WandControl.AvailableSpells[i].Type == SpellType)
				{
					num = i;
					break;
				}
			}
			if (num < 0)
			{
				WandsLogger.LogError("Spell " + SpellType.ToString() + " not found in available spells");
			}
			if (ActiveSpell != m_caster.WandControl.AvailableSpells[num])
			{
				m_caster.WandControl.SelectSpell(num);
			}
		}

		protected void SetCooldown(bool shouldActivate)
		{
			m_caster.BehaviourParams.DecisionParams.SetCooldown(shouldActivate);
		}

		protected void SetCustomCooldown(float factor)
		{
			m_caster.BehaviourParams.DecisionParams.SetCustomCooldown(factor);
		}

		protected bool IsOnCooldown()
		{
			return m_caster.BehaviourParams.DecisionParams.IsOnCooldown;
		}

		protected void CastSpell()
		{
			SpellPress();
			ReleaseSpellAfterDelay();
		}

		protected void ReleaseSpellAfterDelay()
		{
			Task.Delay(Mathf.FloorToInt(Mathf.Lerp(300f, 50f, m_caster.Targeting.Accuracy))).ContinueWith(delegate
			{
				SpellRelease();
			}, TaskScheduler.FromCurrentSynchronizationContext());
		}

		protected virtual void SpellPress()
		{
			if (ActiveSpell.CanCast())
			{
				m_spellEvents.OnPress(this);
				ActiveSpell.SpellPress();
			}
			else
			{
				m_caster.BehaviourParams.MovementParams.SetPreparingFire(setActive: false);
			}
		}

		protected virtual void SpellHold()
		{
			ActiveSpell.SpellHold();
			SetCooldown(shouldActivate: true);
		}

		protected virtual void SpellRelease()
		{
			ActiveSpell.SpellRelease();
			m_caster.Memory.RegisterSpellCast(ActiveSpell);
			SetCooldown(shouldActivate: true);
			m_spellEvents.OnRelease(this);
			m_caster.BehaviourParams.MovementParams.SetPreparingFire(setActive: false);
		}

		public void Update()
		{
			SpellHold();
		}

		public void Deactivate()
		{
			SpellRelease();
		}

		protected bool IsTargetValid(BotAimTargetType targetType)
		{
			BotAimTarget aimTarget = m_caster.Targeting.AimTarget;
			aimTarget.FromTile = m_caster.CurrentTile;
			aimTarget.TargetType = BotAimTargetType.Offensive;
			return m_caster.Targeting.HasValidAimTarget(m_caster.CurrentTile, aimTarget) ? true : false;
		}

		protected void CastSpellOrTeleport(BE_Action action, Vector3 targetPos)
		{
			if (!m_caster.Targeting.GetHasValidTrajectory(targetPos, (ActiveSpell as SpellBase_Projectile).m_collisionRadius, out var validHandPosition))
			{
				if (!m_caster.IsCurrentTileInescapeable)
				{
					m_caster.Teleport(action);
				}
			}
			else
			{
				m_caster.BehaviourParams.MovementParams.SetPreparingFire(setActive: true);
				m_caster.Targeting.AimAtPosition(validHandPosition, targetPos, m_caster.BehaviourParams.MovementParams.HandMovementDuration, CastSpellAfterAiming);
			}
		}

		protected virtual void CastSpellAfterAiming()
		{
			m_caster.Targeting.SetAimTarget(new BotAimTarget(m_caster.CurrentTile, BotAimTargetType.Offensive, m_caster.Aim.AimRay));
			CastSpell();
		}

		[Conditional("UNITY_EDITOR")]
		protected void DrawCoordinate(Vector3 pos, Color color)
		{
			float num = 0.2f;
			UnityEngine.Debug.DrawLine(pos + new Vector3(0f - num, 0f, 0f), pos + new Vector3(num, 0f, 0f), color, 2f);
			UnityEngine.Debug.DrawLine(pos + new Vector3(0f, 0f - num, 0f), pos + new Vector3(0f, num, 0f), color, 2f);
			UnityEngine.Debug.DrawLine(pos + new Vector3(0f, 0f, 0f - num), pos + new Vector3(0f, 0f, num), color, 2f);
		}
	}
	public class BlazingMeteor : AISpell
	{
		private const float BelowHeadTargetDistance = 0.1f;

		public override Spell SpellType
		{
			[CompilerGenerated]
			get
			{
				return Spell.Spell_BlazingMeteor;
			}
		}

		public BlazingMeteor(IBotCaster botCaster, BotSpellEvents spellEvents)
			: base(botCaster, spellEvents)
		{
		}

		public override void CastAction(BE_Action action)
		{
			if (m_caster.BehaviourParams.DecisionParams.IsAvoidingDamage && !m_caster.IsCurrentTileInescapeable)
			{
				m_caster.Teleport(action);
			}
			else if (m_caster.WandControl.CanCastSpell() && !IsOnCooldown() && !m_caster.BehaviourParams.MovementParams.IsPreparingFire && m_caster.Memory.IsAllowedToStackSpell(SpellType, m_caster.SpellPriority.GetMaxStackEntries(SpellType)))
			{
				SelectSpellIfNeeded();
				if (!m_caster.Wand.OutOfEnergy(base.ActiveSpell) && m_caster.StatsDataManager.AllowedToCast(base.ActiveSpell, m_caster.SpellPriority.GetModifiedPriorityForSpell(SpellType, m_caster.Memory.GetSpellStacks(SpellType)), m_caster.BehaviourParams.SpellParams.AllowedToDepleteMana))
				{
					CastSpellOrTeleport(action, m_caster.Targeting.GetModifiedTargetPosition(m_caster.Targeting.GetTargetHeadPosition(0.1f)));
				}
			}
		}
	}
	public class ChillingClutch : AISpell
	{
		private const float BelowHeadTargetDistance = 0.1f;

		private const float AimRadiusFactor = 0.8f;

		public override Spell SpellType
		{
			[CompilerGenerated]
			get
			{
				return Spell.Spell_ChillingClutch;
			}
		}

		public ChillingClutch(IBotCaster botCaster, BotSpellEvents spellEvents)
			: base(botCaster, spellEvents)
		{
		}

		public override void CastAction(BE_Action action)
		{
			if (m_caster.BehaviourParams.DecisionParams.IsAvoidingDamage && !m_caster.IsCurrentTileInescapeable)
			{
				m_caster.Teleport(action);
			}
			else if (m_caster.WandControl.CanCastSpell() && !IsOnCooldown() && !m_caster.BehaviourParams.MovementParams.IsPreparingFire && m_caster.Memory.IsAllowedToStackSpell(SpellType, m_caster.SpellPriority.GetMaxStackEntries(SpellType)))
			{
				SelectSpellIfNeeded();
				if (!m_caster.Wand.OutOfEnergy(base.ActiveSpell) && m_caster.StatsDataManager.AllowedToCast(base.ActiveSpell, m_caster.SpellPriority.GetModifiedPriorityForSpell(SpellType, m_caster.Memory.GetSpellStacks(SpellType)), m_caster.BehaviourParams.SpellParams.AllowedToDepleteMana))
				{
					CastSpellOrTeleport(action, m_caster.Targeting.GetModifiedTargetPosition(m_caster.Targeting.GetTargetHeadPosition(0.1f), 0.8f));
				}
			}
		}
	}
	public abstract class Defensive : AISpell, IDefender
	{
		private float m_shieldDuration;

		private float m_currentShieldDuration;

		private float m_castCost;

		private float m_reactiveDuration;

		private const float PredictingIncomingProjectilesTime = 0.5f;

		private const float MinDefensiveCooldown = 0.1f;

		private const float DefensiveCooldownFactor = 0.25f;

		protected abstract float MinDefenseDuration { get; }

		protected abstract float CostReserveFactor { get; }

		public Defensive(IBotCaster botCaster, BotSpellEvents spellEvents)
			: base(botCaster, spellEvents)
		{
		}

		public override void CastAction(BE_Action action)
		{
			if (m_caster.BehaviourParams.DecisionParams.IsAvoidingDamage && !m_caster.IsCurrentTileInescapeable)
			{
				m_caster.AvoidDamageAction(action);
			}
			else if (!m_caster.BehaviourParams.MovementParams.IsPreparingFire && CanUseDefensiveSpell())
			{
				if (m_caster.BehaviourParams.SpellParams.IsDefensiveSpellActive)
				{
					m_shieldDuration = GetShieldDuration();
					m_currentShieldDuration = 0f;
				}
				else if (CanAffordSpell(m_caster.TeleportCost))
				{
					SpellPress();
				}
				else
				{
					m_caster.AvoidDamageAction(action);
				}
			}
		}

		private float GetReactiveDuration()
		{
			if (m_reactiveDuration <= 0f)
			{
				m_reactiveDuration = MinDefenseDuration * (1f - m_caster.Targeting.Accuracy);
			}
			return m_reactiveDuration;
		}

		private float GetCastCost()
		{
			if (m_castCost <= 0f)
			{
				SelectSpellIfNeeded();
				m_castCost = base.ActiveSpell.GetCastCost();
			}
			return m_castCost;
		}

		private bool CanAffordSpell(float margin = 0f)
		{
			SelectSpellIfNeeded();
			float castCost = GetCastCost();
			return m_caster.StatsDataManager.AllowedToCast(base.ActiveSpell, m_caster.SpellPriority.GetModifiedPriorityForSpell(SpellType, m_caster.Memory.GetSpellStacks(SpellType)), allowedToDepleteMana: true) && m_caster.StatsDataManager.GetCurrentMana() > castCost + castCost / CostReserveFactor + margin;
		}

		private void ActivateShield()
		{
			m_shieldDuration = GetShieldDuration();
			m_caster.BehaviourParams.SpellParams.IsDefensiveSpellActive = true;
		}

		private float GetShieldDuration()
		{
			float timeUntilLastPredictedImpactOnCurrentTile = m_caster.Prediction.GetTimeUntilLastPredictedImpactOnCurrentTile(0.5f);
			float num = timeUntilLastPredictedImpactOnCurrentTile + MinDefenseDuration;
			float reactiveDuration = GetReactiveDuration();
			return Mathf.Max(num + UnityEngine.Random.Range(reactiveDuration, reactiveDuration + reactiveDuration), MinDefenseDuration);
		}

		private bool IsManaLow()
		{
			float currentMana = m_caster.StatsDataManager.GetCurrentMana();
			return (currentMana <= m_caster.TeleportCost + 1f && currentMana >= m_caster.TeleportCost) ? true : false;
		}

		private void UpdateDuration()
		{
			m_currentShieldDuration += Time.deltaTime;
			if (IsManaLow() && !m_caster.IsCurrentTileInescapeable)
			{
				SpellRelease();
				m_caster.AvoidDamageInstantly();
			}
			else if (m_currentShieldDuration >= m_shieldDuration)
			{
				float timeUntilLastPredictedImpactOnCurrentTile = m_caster.Prediction.GetTimeUntilLastPredictedImpactOnCurrentTile(0.5f);
				if (timeUntilLastPredictedImpactOnCurrentTile <= 0f)
				{
					SpellRelease();
				}
				else
				{
					m_shieldDuration = GetShieldDuration();
				}
			}
		}

		private void Reset()
		{
			m_currentShieldDuration = 0f;
		}

		protected override void SpellPress()
		{
			base.SpellPress();
			ActivateShield();
		}

		protected override void SpellHold()
		{
			base.SpellHold();
			UpdateDuration();
		}

		protected override void SpellRelease()
		{
			Reset();
			m_caster.BehaviourParams.SpellParams.IsDefensiveSpellActive = false;
			base.SpellRelease();
			SetCustomCooldown(Mathf.Max(m_caster.BehaviourParams.DecisionParams.CooldownTime * 0.25f, 0.1f));
		}

		protected virtual bool CanUseDefensiveSpell()
		{
			if (m_caster.BehaviourParams.DecisionParams.CanDoReactiveAction)
			{
				SelectSpellIfNeeded();
				return m_caster.WandControl.CanCastSpell();
			}
			return false;
		}

		public virtual void DefendInstantly()
		{
			if (CanUseDefensiveSpell() && CanAffordSpell())
			{
				SpellPress();
			}
		}
	}
	public class Demi : AISpell
	{
		private const float BelowHeadTargetDistance = 0.1f;

		private const float AimRadiusFactor = 0.5f;

		public override Spell SpellType
		{
			[CompilerGenerated]
			get
			{
				return Spell.Spell_Demi;
			}
		}

		public Demi(IBotCaster botCaster, BotSpellEvents spellEvents)
			: base(botCaster, spellEvents)
		{
		}

		public override void CastAction(BE_Action action)
		{
			if (m_caster.BehaviourParams.DecisionParams.IsAvoidingDamage && !m_caster.IsCurrentTileInescapeable)
			{
				m_caster.Teleport(action);
			}
			else if (m_caster.WandControl.CanCastSpell() && !IsOnCooldown() && !m_caster.BehaviourParams.MovementParams.IsPreparingFire && m_caster.Memory.IsAllowedToStackSpell(SpellType, m_caster.SpellPriority.GetMaxStackEntries(SpellType)))
			{
				SelectSpellIfNeeded();
				if (!m_caster.Wand.OutOfEnergy(base.ActiveSpell) && m_caster.StatsDataManager.AllowedToCast(base.ActiveSpell, m_caster.SpellPriority.GetModifiedPriorityForSpell(SpellType, m_caster.Memory.GetSpellStacks(SpellType)), m_caster.BehaviourParams.SpellParams.AllowedToDepleteMana))
				{
					CastSpellOrTeleport(action, m_caster.Targeting.GetModifiedTargetPosition(m_caster.Targeting.GetTargetHeadPosition(0.1f), 0.5f));
				}
			}
		}
	}
	public class DevilsSpit : AISpell
	{
		private const int MaxIterations = 15;

		private const int MinIterations = 5;

		private static readonly Vector3[] sm_trajectoryPoints = new Vector3[3];

		private static readonly Vector2 sm_trajectoryCurveRotationOffset = new Vector2(15f, 30f);

		public override Spell SpellType
		{
			[CompilerGenerated]
			get
			{
				return Spell.Spell_DevilsSpit;
			}
		}

		public DevilsSpit(IBotCaster botCaster, BotSpellEvents spellEvents)
			: base(botCaster, spellEvents)
		{
		}

		public override void CastAction(BE_Action action)
		{
			if (m_caster.BehaviourParams.DecisionParams.IsAvoidingDamage && !m_caster.IsCurrentTileInescapeable)
			{
				m_caster.Teleport(action);
			}
			else
			{
				if (!m_caster.WandControl.CanCastSpell() || IsOnCooldown() || m_caster.BehaviourParams.MovementParams.IsPreparingFire || !m_caster.Memory.IsAllowedToStackSpell(SpellType, m_caster.SpellPriority.GetMaxStackEntries(SpellType)))
				{
					return;
				}
				SelectSpellIfNeeded();
				if (m_caster.Wand.OutOfEnergy(base.ActiveSpell) || !m_caster.StatsDataManager.AllowedToCast(base.ActiveSpell, m_caster.SpellPriority.GetModifiedPriorityForSpell(SpellType, m_caster.Memory.GetSpellStacks(SpellType)), m_caster.BehaviourParams.SpellParams.AllowedToDepleteMana))
				{
					return;
				}
				Vector3 modifiedTargetPosition = m_caster.Targeting.GetModifiedTargetPosition(PlayerManager.Instance.PlayerControl.Collider.transform.position + PlayerManager.Instance.PlayerControl.Collider.center);
				if (!m_caster.Targeting.GetHasValidTrajectory(modifiedTargetPosition, (base.ActiveSpell as SpellBase_Projectile).m_collisionRadius, out var validHandPosition))
				{
					if (!m_caster.IsCurrentTileInescapeable)
					{
						m_caster.Teleport(action);
					}
				}
				else
				{
					m_caster.BehaviourParams.MovementParams.SetPreparingFire(setActive: true);
					m_caster.Targeting.AimAtPosition(validHandPosition, modifiedTargetPosition, m_caster.BehaviourParams.MovementParams.HandMovementDuration, CastSpellAfterAiming);
				}
			}
		}

		protected override void CastSpellAfterAiming()
		{
			SpellBase_Projectile spellBase_Projectile = base.ActiveSpell as SpellBase_Projectile;
			Vector3 currentHitPoint = m_caster.WandControl.GetCurrentHitPoint(spellBase_Projectile.m_collisionRadius);
			SpellPress();
			int num = Mathf.RoundToInt(Mathf.Lerp(5f, 15f, m_caster.Targeting.Accuracy));
			for (int i = 0; i < num; i++)
			{
				Vector2 vector = sm_trajectoryCurveRotationOffset;
				float min = 0f - vector.x;
				Vector2 vector2 = sm_trajectoryCurveRotationOffset;
				float xAngle = UnityEngine.Random.Range(min, vector2.x);
				Vector2 vector3 = sm_trajectoryCurveRotationOffset;
				float min2 = 0f - vector3.y;
				Vector2 vector4 = sm_trajectoryCurveRotationOffset;
				float yAngle = UnityEngine.Random.Range(min2, vector4.y);
				Vector3 cachedTipPoint = m_caster.WandControl.CachedTipPoint;
				m_caster.Aim.AimPivot.Rotate(xAngle, yAngle, 0f);
				Vector3 currentHitPoint2 = m_caster.WandControl.GetCurrentHitPoint(spellBase_Projectile.m_collisionRadius);
				SetTrajectoryPoints(cachedTipPoint, currentHitPoint2, currentHitPoint);
				if (!m_caster.Prediction.IsTrajectoryBlocked(sm_trajectoryPoints, spellBase_Projectile.m_collisionRadius))
				{
					break;
				}
				if (i == num - 1)
				{
					SetTrajectoryPoints(cachedTipPoint, Vector3.Lerp(cachedTipPoint, currentHitPoint, 0.5f), currentHitPoint);
				}
			}
			ReleaseSpellAfterDelay();
		}

		private void SetTrajectoryPoints(Vector3 start, Vector3 mid, Vector3 end)
		{
			sm_trajectoryPoints[0] = start;
			sm_trajectoryPoints[1] = mid;
			sm_trajectoryPoints[2] = end;
		}
	}
	public class ElectricFist : AISpell
	{
		private const float BelowHeadTargetDistance = 0.1f;

		private const float AimRadiusFactor = 0.7f;

		public override Spell SpellType
		{
			[CompilerGenerated]
			get
			{
				return Spell.Spell_ElectricFist;
			}
		}

		public ElectricFist(IBotCaster botCaster, BotSpellEvents spellEvents)
			: base(botCaster, spellEvents)
		{
		}

		public override void CastAction(BE_Action action)
		{
			if (m_caster.BehaviourParams.DecisionParams.IsAvoidingDamage && !m_caster.IsCurrentTileInescapeable)
			{
				m_caster.Teleport(action);
			}
			else if (m_caster.WandControl.CanCastSpell() && !IsOnCooldown() && !m_caster.BehaviourParams.MovementParams.IsPreparingFire && m_caster.Memory.IsAllowedToStackSpell(SpellType, m_caster.SpellPriority.GetMaxStackEntries(SpellType)))
			{
				SelectSpellIfNeeded();
				if (!m_caster.Wand.OutOfEnergy(base.ActiveSpell) && m_caster.StatsDataManager.AllowedToCast(base.ActiveSpell, m_caster.SpellPriority.GetModifiedPriorityForSpell(SpellType, m_caster.Memory.GetSpellStacks(SpellType)), m_caster.BehaviourParams.SpellParams.AllowedToDepleteMana))
				{
					CastSpellOrTeleport(action, m_caster.Targeting.GetModifiedTargetPosition(m_caster.Targeting.GetTargetHeadPosition(0.1f), 0.7f));
				}
			}
		}
	}
	public class HeavenlyDome : Defensive
	{
		private const float DefaultCostReserveFactor = 5f;

		private const float DefaultMinDefenseDuration = 0.12f;

		public override Spell SpellType
		{
			[CompilerGenerated]
			get
			{
				return Spell.Spell_HeavenlyDome;
			}
		}

		protected override float MinDefenseDuration
		{
			[CompilerGenerated]
			get
			{
				return 0.12f;
			}
		}

		protected override float CostReserveFactor
		{
			[CompilerGenerated]
			get
			{
				return 5f;
			}
		}

		public HeavenlyDome(IBotCaster botCaster, BotSpellEvents spellEvents)
			: base(botCaster, spellEvents)
		{
		}
	}
	public interface IDefender
	{
		void DefendInstantly();
	}
	public class MagicMissile : AISpell
	{
		private const float BelowHeadTargetDistance = 0.1f;

		private const float AimRadiusFactor = 0.7f;

		public override Spell SpellType
		{
			[CompilerGenerated]
			get
			{
				return Spell.Spell_MagicMissile;
			}
		}

		public MagicMissile(IBotCaster botCaster, BotSpellEvents spellEvents)
			: base(botCaster, spellEvents)
		{
		}

		public override void CastAction(BE_Action action)
		{
			if (m_caster.BehaviourParams.DecisionParams.IsAvoidingDamage && !m_caster.IsCurrentTileInescapeable)
			{
				m_caster.Teleport(action);
			}
			else if (m_caster.WandControl.CanCastSpell() && !IsOnCooldown() && !m_caster.BehaviourParams.MovementParams.IsPreparingFire && m_caster.Memory.IsAllowedToStackSpell(SpellType, m_caster.SpellPriority.GetMaxStackEntries(SpellType)))
			{
				SelectSpellIfNeeded();
				if (!m_caster.Wand.OutOfEnergy(base.ActiveSpell) && m_caster.StatsDataManager.AllowedToCast(base.ActiveSpell, m_caster.SpellPriority.GetModifiedPriorityForSpell(SpellType, m_caster.Memory.GetSpellStacks(SpellType)), m_caster.BehaviourParams.SpellParams.AllowedToDepleteMana))
				{
					CastSpellOrTeleport(action, m_caster.Targeting.GetModifiedTargetPosition(m_caster.Targeting.GetTargetHeadPosition(0.1f), 0.7f));
				}
			}
		}
	}
	public class ShieldOfLight : Defensive
	{
		private const float DefaultShieldCostReserveFactor = 5f;

		private const float DefaultMinDefenseDuration = 0.12f;

		private const int ProjectileAimDistance = 10;

		private const float ShieldAimDistance = 0.3f;

		public override Spell SpellType
		{
			[CompilerGenerated]
			get
			{
				return Spell.Spell_ShieldOfLight;
			}
		}

		protected override float MinDefenseDuration
		{
			[CompilerGenerated]
			get
			{
				return 0.12f;
			}
		}

		protected override float CostReserveFactor
		{
			[CompilerGenerated]
			get
			{
				return 5f;
			}
		}

		public ShieldOfLight(IBotCaster botCaster, BotSpellEvents spellEvents)
			: base(botCaster, spellEvents)
		{
		}

		protected override void SpellPress()
		{
			if (m_caster.BehaviourParams.MovementParams.IsPreparingFire)
			{
				return;
			}
			Vector3 vector = m_caster.CurrentTile.transform.position + Vector3.up;
			Vector3 vector2 = ((!m_caster.Prediction.PredictingInstantDamage) ? m_caster.Prediction.CurrentTileHitPrediction.ProjectileDirection : m_caster.Prediction.InstantSpellHitPrediction.ProjectileDirection);
			Vector3 vector3 = vector - vector2;
			Quaternion rotation = Quaternion.identity;
			float headRotationDeltaAngle = m_caster.BotMovement.GetHeadRotationDeltaAngle(vector3);
			float headIKRotationThreshold = m_caster.BotMovement.GetHeadIKRotationThreshold();
			if (headRotationDeltaAngle > headIKRotationThreshold)
			{
				if (m_caster.BotMovement.HasRotationTarget)
				{
					m_caster.AvoidDamageInstantly();
					return;
				}
				rotation = Quaternion.Euler(0f, headRotationDeltaAngle, 0f);
				m_caster.BotMovement.FacePosition(vector3);
			}
			Vector3 vector4 = vector2 * 0.3f;
			Vector3 handPosition = vector - Quaternion.Inverse(rotation) * vector4;
			Vector3 modifiedTargetPosition = m_caster.Targeting.GetModifiedTargetPosition(vector - vector2 * 10f);
			m_caster.BehaviourParams.MovementParams.SetPreparingFire(setActive: true);
			m_caster.Targeting.AimAtPosition(handPosition, modifiedTargetPosition, m_caster.BehaviourParams.MovementParams.HandMovementDuration, CastSpellAfterAiming);
		}

		protected override void CastSpellAfterAiming()
		{
			m_caster.Targeting.SetAimTarget(new BotAimTarget(m_caster.CurrentTile, BotAimTargetType.Defensive, m_caster.Aim.AimRay));
			base.SpellPress();
		}
	}
	public class SkullSpecter : AISpell
	{
		private const float MaxAllowedWaitTime = 3f;

		private const float AimTime = 0.2f;

		private static readonly List<Tile> sm_availableTiles = new List<Tile>(16);

		private static readonly int sm_playerOneLayer = LayerMask.NameToLayer("Player1");

		private Collider[] m_currentTeleportColliders = new Collider[32];

		private Tile m_currentTile;

		public override Spell SpellType
		{
			[CompilerGenerated]
			get
			{
				return Spell.Spell_SkullSpecter;
			}
		}

		public SkullSpecter(BotAI botAI, BotSpellEvents spellEvents)
			: base(botAI, spellEvents)
		{
		}

		public override void CastAction(BE_Action action)
		{
			if (m_caster.BehaviourParams.DecisionParams.IsAvoidingDamage && !m_caster.IsCurrentTileInescapeable)
			{
				m_caster.Teleport(action);
			}
			else
			{
				if (!m_caster.WandControl.CanCastSpell() || IsOnCooldown() || m_caster.BehaviourParams.MovementParams.IsPreparingFire || !m_caster.Memory.IsAllowedToStackSpell(SpellType, m_caster.SpellPriority.GetMaxStackEntries(SpellType)) || m_caster.Targeting.HasValidAimTarget(m_caster.CurrentTile))
				{
					return;
				}
				int num = m_caster.Sight.FindTargets(m_currentTeleportColliders, Constants.BotTeleportMask, InFieldOfView: false);
				sm_availableTiles.Clear();
				for (int i = 0; i < num; i++)
				{
					Collider collider = m_currentTeleportColliders[i];
					if (m_caster.Sight.IsInLineOfSight(collider))
					{
						Tile component = collider.transform.parent.GetComponent<Tile>();
						if (component.IsUnoccupied)
						{
							sm_availableTiles.Add(component);
						}
					}
				}
				Collider collider2 = null;
				foreach (Tile sm_availableTile in sm_availableTiles)
				{
					Vector3 center = sm_availableTile.BotTeleportCollider.bounds.center;
					Ray ray = new Ray(center, PlayerManager.Instance.PlayerControl.Collider.transform.position + PlayerManager.Instance.PlayerControl.Collider.center - center);
					if (Physics.Raycast(ray, out var hitInfo, 30f, m_caster.WandControl.HitMask) && hitInfo.collider.gameObject.layer.Equals(sm_playerOneLayer))
					{
						collider2 = sm_availableTile.BotTeleportCollider;
						m_currentTile = sm_availableTile;
						break;
					}
				}
				if (collider2 != null)
				{
					Vector3 validHandPosition;
					Vector3 targetColliderPosition;
					AimResult hasValidTrajectoryToCollider = m_caster.Targeting.GetHasValidTrajectoryToCollider(collider2, out validHandPosition, out targetColliderPosition);
					switch (hasValidTrajectoryToCollider)
					{
					case AimResult.NonValidTrajectory:
						m_caster.BotMovement.FaceAvailableTile();
						break;
					case AimResult.NonValidSightray:
						m_caster.BotMovement.FaceAvailableTile();
						break;
					case AimResult.Success:
						SelectSpellIfNeeded();
						if (m_caster.StatsDataManager.AllowedToCast(base.ActiveSpell, m_caster.SpellPriority.GetModifiedPriorityForSpell(SpellType, m_caster.Memory.GetSpellStacks(SpellType)), m_caster.BehaviourParams.SpellParams.AllowedToDepleteMana))
						{
							m_caster.BehaviourParams.MovementParams.SetPreparingFire(setActive: true);
							m_caster.Targeting.AimAtPosition(validHandPosition, targetColliderPosition, 0.2f, CastSpellAfterAiming);
						}
						break;
					default:
						WandsLogger.LogError($"AimResult not implemented: {hasValidTrajectoryToCollider}");
						break;
					}
				}
				else if (m_caster.Targeting.ElapsedTimeSinceTargetChange > 3f)
				{
					m_caster.BotMovement.FaceAvailableTile();
				}
			}
		}

		protected override void CastSpellAfterAiming()
		{
			if (!m_currentTile.IsOccupied)
			{
				base.CastSpellAfterAiming();
			}
			else
			{
				m_caster.BehaviourParams.MovementParams.SetPreparingFire(setActive: false);
			}
		}
	}
	public class SoilSpikes : AISpell
	{
		private ComponentCollection<Tile> m_currentAvailableTiles = new ComponentCollection<Tile>(16);

		private Collider[] m_currentTeleportColliders = new Collider[32];

		private Tile m_currentTile;

		public override Spell SpellType
		{
			[CompilerGenerated]
			get
			{
				return Spell.Spell_SoilSpikes;
			}
		}

		public SoilSpikes(BotAI botAI, BotSpellEvents spellEvents)
			: base(botAI, spellEvents)
		{
		}

		public override void CastAction(BE_Action action)
		{
			if (m_caster.BehaviourParams.DecisionParams.IsAvoidingDamage && !m_caster.IsCurrentTileInescapeable)
			{
				m_caster.Teleport(action);
			}
			else
			{
				if (!m_caster.WandControl.CanCastSpell() || IsOnCooldown() || m_caster.BehaviourParams.MovementParams.IsPreparingFire || !m_caster.Memory.IsAllowedToStackSpell(SpellType, m_caster.SpellPriority.GetMaxStackEntries(SpellType)))
				{
					return;
				}
				if (!m_caster.Targeting.HasValidAimTarget(m_caster.CurrentTile, m_caster.Targeting.AimTarget))
				{
					Vector3 vector = Vector3.forward;
					int num = m_caster.Sight.FindTargets(m_currentTeleportColliders, Constants.BotTeleportMask, InFieldOfView: false);
					bool flag = false;
					int num2 = 0;
					for (int i = 0; i < num; i++)
					{
						Collider collider = m_currentTeleportColliders[i];
						if (m_caster.Sight.IsInLineOfSight(collider))
						{
							m_currentTile = collider.transform.parent.GetComponent<Tile>();
							if (m_currentTile.IsUnoccupied)
							{
								m_currentAvailableTiles.Components[num2] = m_currentTile;
								num2++;
							}
						}
					}
					m_currentAvailableTiles.Count = num2;
					for (int j = 0; j < m_currentAvailableTiles.Count; j++)
					{
						m_currentTile = m_currentAvailableTiles.Components[j];
						vector = m_currentTile.transform.position;
						Ray ray = new Ray(vector, PlayerManager.Instance.PlayerControl.Collider.transform.position + PlayerManager.Instance.PlayerControl.Collider.center - vector);
						if (Physics.Raycast(ray, out var hitInfo, 30f, m_caster.WandControl.HitMask) && hitInfo.collider.gameObject.layer.Equals(LayerMask.NameToLayer("Player1")))
						{
							flag = true;
							break;
						}
					}
					if (!flag)
					{
						return;
					}
					m_caster.Aim.AimAtPosition(vector);
					m_caster.Targeting.SetAimTarget(new BotAimTarget(m_caster.CurrentTile, BotAimTargetType.Offensive, m_caster.Aim.AimRay));
				}
				SelectSpellIfNeeded();
				if (m_caster.StatsDataManager.AllowedToCast(base.ActiveSpell, m_caster.SpellPriority.GetModifiedPriorityForSpell(SpellType, m_caster.Memory.GetSpellStacks(SpellType)), m_caster.BehaviourParams.SpellParams.AllowedToDepleteMana))
				{
					CastSpell();
				}
			}
		}
	}
	public class StoneDemon : AISpell
	{
		private Collider[] m_currentTeleportColliders = new Collider[32];

		private Tile m_currentTile;

		private const float MaxAllowedWaitTime = 3f;

		private static readonly List<Tile> sm_availableTiles = new List<Tile>(16);

		private static readonly int sm_playerOneLayer = LayerMask.NameToLayer("Player1");

		public override Spell SpellType
		{
			[CompilerGenerated]
			get
			{
				return Spell.Spell_StoneDemon;
			}
		}

		public StoneDemon(BotAI botAI, BotSpellEvents spellEvents)
			: base(botAI, spellEvents)
		{
		}

		public override void CastAction(BE_Action action)
		{
			if (m_caster.BehaviourParams.DecisionParams.IsAvoidingDamage && !m_caster.IsCurrentTileInescapeable)
			{
				m_caster.Teleport(action);
			}
			else
			{
				if (!m_caster.WandControl.CanCastSpell() || IsOnCooldown() || m_caster.BehaviourParams.MovementParams.IsPreparingFire || !m_caster.Memory.IsAllowedToStackSpell(SpellType, m_caster.SpellPriority.GetMaxStackEntries(SpellType)) || HasActiveDemon() || m_caster.Targeting.HasValidAimTarget(m_caster.CurrentTile))
				{
					return;
				}
				int num = m_caster.Sight.FindTargets(m_currentTeleportColliders, Constants.BotTeleportMask, InFieldOfView: false);
				sm_availableTiles.Clear();
				bool flag = false;
				for (int i = 0; i < num; i++)
				{
					Collider collider = m_currentTeleportColliders[i];
					if (m_caster.Sight.IsInLineOfSight(collider))
					{
						Tile component = collider.transform.parent.GetComponent<Tile>();
						if (component.IsUnoccupied)
						{
							sm_availableTiles.Add(component);
						}
					}
				}
				Collider targetCollider = null;
				foreach (Tile sm_availableTile in sm_availableTiles)
				{
					Vector3 position = sm_availableTile.transform.position;
					Ray ray = new Ray(position, PlayerManager.Instance.PlayerControl.Collider.transform.position + PlayerManager.Instance.PlayerControl.Collider.center - position);
					if (Physics.Raycast(ray, out var hitInfo, 30f, m_caster.WandControl.HitMask) && hitInfo.collider.gameObject.layer.Equals(sm_playerOneLayer))
					{
						flag = true;
						targetCollider = sm_availableTile.BotTeleportCollider;
						m_currentTile = sm_availableTile;
						break;
					}
				}
				if (flag)
				{
					Vector3 validHandPosition;
					Vector3 targetColliderPosition;
					AimResult hasValidTrajectoryToCollider = m_caster.Targeting.GetHasValidTrajectoryToCollider(targetCollider, out validHandPosition, out targetColliderPosition);
					switch (hasValidTrajectoryToCollider)
					{
					case AimResult.NonValidTrajectory:
						m_caster.BotMovement.FaceAvailableTile();
						break;
					case AimResult.NonValidSightray:
						m_caster.BotMovement.FaceAvailableTile();
						break;
					case AimResult.Success:
						SelectSpellIfNeeded();
						if (m_caster.StatsDataManager.AllowedToCast(base.ActiveSpell, m_caster.SpellPriority.GetModifiedPriorityForSpell(SpellType, m_caster.Memory.GetSpellStacks(SpellType)), m_caster.BehaviourParams.SpellParams.AllowedToDepleteMana))
						{
							m_caster.BehaviourParams.MovementParams.SetPreparingFire(setActive: true);
							m_caster.Targeting.AimAtPosition(validHandPosition, targetColliderPosition, m_caster.BehaviourParams.MovementParams.HandMovementDuration, CastSpellAfterAiming);
						}
						break;
					default:
						WandsLogger.LogError("AimResult not implemented: " + hasValidTrajectoryToCollider);
						break;
					}
				}
				else if (m_caster.Targeting.ElapsedTimeSinceTargetChange > 3f)
				{
					m_caster.BotMovement.FaceAvailableTile();
				}
			}
		}

		protected override void CastSpellAfterAiming()
		{
			if (m_currentTile.IsOccupied)
			{
				m_caster.BehaviourParams.MovementParams.SetPreparingFire(setActive: false);
			}
			else
			{
				base.CastSpellAfterAiming();
			}
		}

		private bool HasActiveDemon()
		{
			foreach (Tile allTile in PunSingleton<TileManager>.Instance.AllTiles)
			{
				if (allTile.Occupant != null && allTile.IsTileOccupiedBySummoned())
				{
					Assets.Scripts.Spells.TileEffects.StoneDemon component = allTile.Occupant.gameObject.GetComponent<Assets.Scripts.Spells.TileEffects.StoneDemon>();
					if (component != null && ((TurretDemon)component.Turret).Wielder.IsBot)
					{
						return true;
					}
				}
			}
			return false;
		}
	}
	public class Teleport : AISpell
	{
		private Collider[] m_currentVisibleTeleportColliders = new Collider[32];

		private Collider m_currentTeleportCollider;

		private Tile m_currentTile;

		private readonly HashSet<Tile> m_excludedTiles = new HashSet<Tile>();

		public override Spell SpellType
		{
			[CompilerGenerated]
			get
			{
				return Spell.Spell_Teleport;
			}
		}

		public Teleport(BotAI botAI, BotSpellEvents spellEvents)
			: base(botAI, spellEvents)
		{
		}

		private bool TryActivateTeleport(Vector3 validHandPosition, Vector3 targetColliderPosition)
		{
			SelectSpellIfNeeded();
			if (!m_caster.WandControl.CanCastSpell() && !base.ActiveSpell.CanCast())
			{
				return false;
			}
			float priority = m_caster.SpellPriority.GetModifiedPriorityForSpell(SpellType, m_caster.Memory.GetSpellStacks(SpellType));
			bool allowedToDepleteMana = m_caster.BehaviourParams.SpellParams.AllowedToDepleteMana;
			if (m_caster.BehaviourParams.SpellParams.UseUrgentTeleport)
			{
				priority = 1f;
				allowedToDepleteMana = true;
			}
			if (m_caster.StatsDataManager.AllowedToCast(base.ActiveSpell, priority, allowedToDepleteMana) && !m_caster.BehaviourParams.DecisionParams.IsOnCooldown)
			{
				m_caster.BehaviourParams.MovementParams.SetPreparingFire(setActive: true);
				m_caster.Targeting.AimAtPosition(validHandPosition, targetColliderPosition, m_caster.BehaviourParams.MovementParams.HandMovementDuration, CastSpellAfterAiming);
				return true;
			}
			return false;
		}

		protected override void CastSpellAfterAiming()
		{
			if (m_currentTile.IsOccupied)
			{
				m_caster.BehaviourParams.MovementParams.SetPreparingFire(setActive: false);
				return;
			}
			m_caster.Targeting.SetAimTarget(new BotAimTarget(m_caster.CurrentTile, BotAimTargetType.Teleport, m_caster.Aim.AimRay));
			SpellPress();
			SpellRelease();
			m_caster.BehaviourParams.DecisionParams.SetTeleportCooldown(shouldActivate: true);
		}

		private bool TryAimAtAvailableTile(out Vector3 validHandPosition, out Vector3 targetColliderPosition)
		{
			int num = m_caster.Sight.FindTargets(m_currentVisibleTeleportColliders, Constants.BotTeleportMask);
			validHandPosition = Vector3.zero;
			targetColliderPosition = Vector3.zero;
			if (num < 1)
			{
				m_caster.BotMovement.FaceAvailableTile();
				return false;
			}
			m_excludedTiles.Clear();
			m_excludedTiles.AddRange(PunSingleton<TileManager>.Instance.AllTiles);
			for (int i = 0; i < num; i++)
			{
				m_currentTile = m_currentVisibleTeleportColliders[i].transform.parent.GetComponent<Tile>();
				if (!m_currentTile.IsOccupied)
				{
					if (m_caster.Prediction.IsTileSafe(m_currentTile))
					{
						m_excludedTiles.Remove(m_currentTile);
					}
					else if (m_caster.BehaviourParams.MovementParams.TurnInPlaceTimes > 1)
					{
						m_excludedTiles.Remove(m_currentTile);
					}
				}
			}
			m_currentTile = PunSingleton<TileManager>.Instance.GetRandomTile(m_excludedTiles, avoidElevatorTiles: false, tryAvoidActivEffects: true);
			if (m_currentTile == null)
			{
				if (m_caster.CurrentTile.IsEffectActive)
				{
					m_currentTile = PunSingleton<TileManager>.Instance.GetRandomTile(m_excludedTiles, avoidElevatorTiles: false, tryAvoidActivEffects: false);
				}
				if (m_currentTile == null)
				{
					m_caster.BotMovement.TurnAround();
					m_caster.BehaviourParams.MovementParams.TurnInPlaceTimes++;
					return false;
				}
			}
			m_currentTeleportCollider = m_currentTile.BotTeleportCollider;
			AimResult hasValidTrajectoryToCollider = m_caster.Targeting.GetHasValidTrajectoryToCollider(m_currentTeleportCollider, out validHandPosition, out targetColliderPosition);
			switch (hasValidTrajectoryToCollider)
			{
			case AimResult.NonValidSightray:
				WandsLogger.LogError("Non-valid sight ray on teleport!");
				break;
			case AimResult.NonValidTrajectory:
				m_caster.BotMovement.TurnAround();
				break;
			case AimResult.Success:
				return true;
			default:
				WandsLogger.LogError("AimResult not implemented: " + hasValidTrajectoryToCollider);
				break;
			}
			return false;
		}

		public override void CastAction(BE_Action action)
		{
			if (!m_caster.BotMovement.HasRotationTarget && !m_caster.TeleportHandler.IsTeleporting)
			{
				Vector3 validHandPosition;
				Vector3 targetColliderPosition;
				if (m_caster.BehaviourParams.SpellParams.IsDefensiveSpellActive)
				{
					m_caster.AbortSpellCasting();
				}
				else if (!m_caster.BehaviourParams.MovementParams.IsPreparingFire && m_caster.BehaviourParams.DecisionParams.IsReadyToTeleport(m_caster.BehaviourParams.SpellParams.UseUrgentTeleport) && m_caster.Memory.IsAllowedToStackSpell(SpellType, m_caster.SpellPriority.GetMaxStackEntries(SpellType)) && TryAimAtAvailableTile(out validHandPosition, out targetColliderPosition) && TryActivateTeleport(validHandPosition, targetColliderPosition))
				{
				}
			}
		}

		public void TeleportInstantly()
		{
			if (!m_caster.TeleportHandler.IsTeleporting && !m_caster.BehaviourParams.MovementParams.IsPreparingFire && TryAimAtAvailableTile(out var validHandPosition, out var targetColliderPosition))
			{
				m_caster.BehaviourParams.SpellParams.UseUrgentTeleport = true;
				if (TryActivateTeleport(validHandPosition, targetColliderPosition))
				{
				}
			}
		}

		public bool TryTeleportToTile(Tile targetTile)
		{
			if (m_caster.TeleportHandler.IsTeleporting || m_caster.BehaviourParams.SpellParams.IsDefensiveSpellActive || m_caster.BehaviourParams.MovementParams.IsPreparingFire || !m_caster.BehaviourParams.DecisionParams.IsReadyToTeleport(m_caster.BehaviourParams.SpellParams.UseUrgentTeleport) || !m_caster.Memory.IsAllowedToStackSpell(SpellType, m_caster.SpellPriority.GetMaxStackEntries(SpellType)))
			{
				return false;
			}
			if (targetTile.IsOccupied)
			{
				return false;
			}
			Vector3 validHandPosition;
			Vector3 targetColliderPosition;
			AimResult hasValidTrajectoryToCollider = m_caster.Targeting.GetHasValidTrajectoryToCollider(targetTile.BotTeleportCollider, out validHandPosition, out targetColliderPosition);
			switch (hasValidTrajectoryToCollider)
			{
			case AimResult.Success:
			{
				SelectSpellIfNeeded();
				float priority = m_caster.SpellPriority.GetModifiedPriorityForSpell(SpellType, m_caster.Memory.GetSpellStacks(SpellType));
				bool allowedToDepleteMana = m_caster.BehaviourParams.SpellParams.AllowedToDepleteMana;
				if (m_caster.BehaviourParams.SpellParams.UseUrgentTeleport)
				{
					priority = 1f;
					allowedToDepleteMana = true;
				}
				if (m_caster.StatsDataManager.AllowedToCast(base.ActiveSpell, priority, allowedToDepleteMana))
				{
					m_caster.BehaviourParams.MovementParams.SetPreparingFire(setActive: true);
					m_currentTile = targetTile;
					m_caster.Targeting.AimAtPosition(validHandPosition, targetColliderPosition, m_caster.BehaviourParams.MovementParams.HandMovementDuration, CastSpellAfterAiming);
					return true;
				}
				break;
			}
			default:
				WandsLogger.LogError("AimResult not implemented: " + hasValidTrajectoryToCollider);
				return false;
			case AimResult.NonValidTrajectory:
			case AimResult.NonValidSightray:
				break;
			}
			return false;
		}
	}
}
namespace Cortopia.AI.Memory
{
	public class Memory : MonoBehaviour
	{
		public const int TileQueueCapacity = 8;

		public const int SpellQueueCapacity = 8;

		private Queue<Tile> m_visitedTiles = new Queue<Tile>(8);

		private Queue<SpellBase> m_spellQueue = new Queue<SpellBase>(8);

		private float m_lastOpponentDamageTime = float.MinValue;

		private float m_lastDamageTime = float.MinValue;

		private EventToken m_damageTakenEventToken;

		public float LastTeleportTime { get; set; } = float.MinValue;


		public SpellBase MostRecentSpell { get; private set; }

		public Tile MostRecentOpponentTile { get; private set; }

		public Tile PreferredTile { get; set; }

		public Queue<SpellBase> SpellQueue
		{
			[CompilerGenerated]
			get
			{
				return m_spellQueue;
			}
		}

		private void OnEnable()
		{
			m_damageTakenEventToken = EventHub.Subscribe<Events.DamageTakenEvent>(OnDamageTaken);
		}

		private void OnDisable()
		{
			Clear();
			EventHub.Unsubscribe<Events.DamageTakenEvent>(m_damageTakenEventToken);
		}

		public void Clear()
		{
			m_spellQueue.Clear();
			m_visitedTiles.Clear();
			m_lastDamageTime = float.MinValue;
			m_lastOpponentDamageTime = float.MinValue;
			LastTeleportTime = float.MinValue;
			MostRecentSpell = null;
			MostRecentOpponentTile = null;
			PreferredTile = null;
		}

		private void OnDamageTaken(Events.DamageTakenEvent eventData)
		{
			if (eventData.CharacterControl is BotControl)
			{
				m_lastDamageTime = GetCurrentTime();
			}
			if (eventData.CharacterControl is PlayerControl)
			{
				m_lastOpponentDamageTime = GetCurrentTime();
			}
		}

		public void RegisterOpponentTile(Tile tile)
		{
			MostRecentOpponentTile = tile;
		}

		public void RegisterTileVisited(Tile tile)
		{
			UpdateList(tile, m_visitedTiles, 8);
		}

		public void RegisterSpellCast(SpellBase spell)
		{
			MostRecentSpell = spell;
			UpdateList(spell, m_spellQueue, 8);
		}

		private void UpdateList<T>(T element, Queue<T> collection, int capacity)
		{
			if (collection.Count + 1 > capacity)
			{
				collection.Dequeue();
			}
			collection.Enqueue(element);
		}

		public void RegisterOpponentDamage()
		{
			m_lastOpponentDamageTime = GetCurrentTime();
		}

		public void RegisterDamage()
		{
			m_lastDamageTime = GetCurrentTime();
		}

		public float GetDurationSinceOpponentDamaged()
		{
			return m_lastOpponentDamageTime - GetCurrentTime();
		}

		public float GetDurationSinceDamaged()
		{
			return m_lastDamageTime - GetCurrentTime();
		}

		private float GetCurrentTime()
		{
			float num = PunSingleton<TimeManager>.Instance.CurrentMatchTime;
			if (num == 0f)
			{
				num = Time.timeSinceLevelLoad;
			}
			return num;
		}

		public int GetSpellStacks(Spell spellType)
		{
			int num = 0;
			foreach (SpellBase item in m_spellQueue)
			{
				if (item.IsType(spellType))
				{
					num++;
				}
			}
			return num;
		}

		public bool IsAllowedToStackSpell(Spell spellType, int maxStacks)
		{
			return GetSpellStacks(spellType) <= maxStacks;
		}
	}
}
namespace Cortopia.Scripts.AI.Movement
{
	public class BotMovement
	{
		private const float MaxDurationNotFacingPlayer = 5f;

		private const float RotationTargetDeltaTolerance = 2f;

		private const float HandOffsetTolerance = 0.01f;

		private ComponentCollection<Tile> m_currentAvailableTiles = new ComponentCollection<Tile>(16);

		private Collider[] m_currentTeleportColliders = new Collider[32];

		private Tile m_currentTile;

		private IBotMover m_botMover;

		private Quaternion m_rotationTarget;

		private float m_durationAwayFromPlayer;

		public bool HasRotationTarget { get; private set; }

		public bool ShouldFacePlayer { get; private set; }

		public BotMovement(IBotMover botMover)
		{
			m_botMover = botMover;
		}

		public float GetHeadIKRotationThreshold()
		{
			return m_botMover.CharacterMovement.GetHeadIKRotationThreshold();
		}

		public void LookAtCollider(Collider targetCollider)
		{
			if (!HasRotationTarget)
			{
				m_rotationTarget = Quaternion.LookRotation(targetCollider.transform.position - m_botMover.CharacterMovement.HeadIk.position);
				m_botMover.CharacterMovement.HeadTrackingTarget.Rotation = m_rotationTarget;
				HasRotationTarget = true;
			}
		}

		public Vector3 GetFacingDirection()
		{
			return m_botMover.CharacterMovement.HeadIk.forward;
		}

		public Vector3 GetCharacterRootForward()
		{
			return m_botMover.Character.CharacterRenderer.Body.forward;
		}

		public Quaternion GetCharacterRootRotation()
		{
			return m_botMover.Character.CharacterRenderer.Body.transform.rotation;
		}

		public float GetHeadRotationDeltaAngle(Vector3 targetPosition)
		{
			Vector3 facingDirection = GetFacingDirection();
			Vector3 vector = targetPosition - m_botMover.CharacterMovement.HeadIk.position;
			facingDirection = new Vector3(facingDirection.x, 0f, facingDirection.z).normalized;
			vector = new Vector3(vector.x, 0f, vector.z).normalized;
			return Vector3.Angle(facingDirection, vector);
		}

		public void FacePlayer()
		{
			if (!HasRotationTarget)
			{
				Vector3 vector = PlayerManager.Instance.PlayerControl.Collider.transform.position + PlayerManager.Instance.PlayerControl.Collider.center;
				m_rotationTarget = Quaternion.LookRotation(vector - m_botMover.CharacterMovement.HeadIk.position);
				m_botMover.CharacterMovement.HeadTrackingTarget.Rotation = m_rotationTarget;
				HasRotationTarget = true;
			}
			ShouldFacePlayer = true;
		}

		public void FacePosition(Vector3 position)
		{
			if (!HasRotationTarget)
			{
				m_rotationTarget = Quaternion.LookRotation(position - m_botMover.CharacterMovement.HeadIk.position);
				m_botMover.CharacterMovement.HeadTrackingTarget.Rotation = m_rotationTarget;
				HasRotationTarget = true;
			}
		}

		public void FaceAvailableTile()
		{
			if (HasRotationTarget)
			{
				if (!ShouldFacePlayer)
				{
					return;
				}
				ShouldFacePlayer = false;
			}
			int num = m_botMover.Sight.FindTargets(m_currentTeleportColliders, Constants.BotTeleportMask, InFieldOfView: false);
			int num2 = 0;
			for (int i = 0; i < num; i++)
			{
				Collider collider = m_currentTeleportColliders[i];
				if (m_botMover.Sight.IsInLineOfSight(collider))
				{
					m_currentTile = collider.transform.parent.GetComponent<Tile>();
					if (m_currentTile.IsUnoccupied)
					{
						m_currentAvailableTiles.Components[num2] = m_currentTile;
						num2++;
					}
				}
			}
			m_currentAvailableTiles.Count = num2;
			m_currentTile = m_botMover.Sight.GetClosest(m_currentAvailableTiles.Components, m_currentAvailableTiles.Count);
			if (m_currentTile == null)
			{
				TurnAround();
			}
			if (!HasRotationTarget)
			{
				m_rotationTarget = Quaternion.LookRotation(m_currentTile.TeleportCollider.transform.position - m_botMover.CharacterMovement.HeadIk.position);
				m_botMover.CharacterMovement.HeadTrackingTarget.Rotation = m_rotationTarget;
				HasRotationTarget = true;
			}
			ShouldFacePlayer = false;
		}

		public void TurnAround()
		{
			if (!HasRotationTarget)
			{
				m_rotationTarget = Quaternion.LookRotation(-m_botMover.CharacterMovement.HeadIk.transform.forward);
				m_botMover.CharacterMovement.HeadTrackingTarget.Rotation = m_rotationTarget;
				HasRotationTarget = true;
			}
		}

		private float GetTargetRotationDelta()
		{
			return Quaternion.Angle(m_botMover.CharacterMovement.HeadIk.rotation, m_rotationTarget);
		}

		public bool IsLookingAtTarget()
		{
			return m_botMover.CharacterMovement.HeadIk.rotation.AlmostEquals(m_rotationTarget, 2f);
		}

		private bool IsLookingAtPosition(Vector3 position)
		{
			return m_botMover.CharacterMovement.HeadIk.rotation.AlmostEquals(Quaternion.LookRotation(position - m_botMover.CharacterMovement.HeadIk.position), 2f);
		}

		private void UpdateRotation()
		{
			if (m_botMover.CharacterMovement.HeadIk.rotation.AlmostEquals(m_rotationTarget, 2f))
			{
				HasRotationTarget = false;
			}
		}

		public void MoveOutOfSightFrom(Tile avoidTile)
		{
			m_botMover.BehaviourParams.SpellParams.UseUrgentTeleport = true;
			m_botMover.BehaviourParams.DecisionParams.IsAvoidingDamage = true;
			int num = m_botMover.Sight.FindTargets(m_currentTeleportColliders, Constants.BotTeleportMask);
			for (int i = 0; i < num; i++)
			{
				m_currentTile = m_currentTeleportColliders[i].transform.parent.GetComponent<Tile>();
				if (m_botMover.Sight.IsRayBlocked(m_currentTile.BotTeleportCollider.bounds.center, avoidTile.BotTeleportCollider.bounds.center))
				{
					m_botMover.TryTeleportToTile(m_currentTile);
				}
			}
			if (!m_botMover.Sight.IsInLineOfSight(avoidTile.BotTeleportCollider))
			{
				m_botMover.BehaviourParams.SpellParams.UseUrgentTeleport = false;
			}
		}

		public void UpdateMovement()
		{
			if (HasRotationTarget)
			{
				UpdateRotation();
			}
			if (!ShouldFacePlayer)
			{
				m_durationAwayFromPlayer += Time.deltaTime;
				if (m_durationAwayFromPlayer >= 5f)
				{
					FacePlayer();
					m_durationAwayFromPlayer = 0f;
				}
			}
		}

		[Conditional("UNITY_EDITOR")]
		private void DrawCoordinate(Vector3 pos, Color color)
		{
			float num = 0.2f;
			UnityEngine.Debug.DrawLine(pos + new Vector3(0f - num, 0f, 0f), pos + new Vector3(num, 0f, 0f), color, 2f);
			UnityEngine.Debug.DrawLine(pos + new Vector3(0f, 0f - num, 0f), pos + new Vector3(0f, num, 0f), color, 2f);
			UnityEngine.Debug.DrawLine(pos + new Vector3(0f, 0f, 0f - num), pos + new Vector3(0f, 0f, num), color, 2f);
		}
	}
}
namespace Cortopia.Scripts.AI.Params
{
	public class BehaviourParams
	{
		public SpellParams SpellParams = new SpellParams();

		public MovementParams MovementParams = new MovementParams();

		public DecisionParams DecisionParams = new DecisionParams();

		public void Reset()
		{
			SpellParams = new SpellParams();
			MovementParams = new MovementParams();
			DecisionParams = new DecisionParams();
		}
	}
	public class DecisionParams
	{
		protected float m_cooldownDuration;

		protected float m_teleportCoolDownDuration;

		public bool IsAvoidingDamage;

		public bool HasReactedToSound;

		public float TeleportCooldownTime { get; set; }

		public float ReactionToActionTime { get; set; }

		public float CooldownTime { get; set; }

		public bool IsOnCooldown
		{
			[CompilerGenerated]
			get
			{
				return m_cooldownDuration > 0f;
			}
		}

		public bool CanDoReactiveAction
		{
			[CompilerGenerated]
			get
			{
				return m_cooldownDuration <= CooldownTime - ReactionToActionTime;
			}
		}

		public bool IsReadyToTeleport(bool urgentTeleport)
		{
			if (urgentTeleport)
			{
				return (m_teleportCoolDownDuration <= Mathf.Max(TeleportCooldownTime * 0.5f, 0.2f)) ? true : false;
			}
			return m_teleportCoolDownDuration <= 0f;
		}

		public void SetCooldown(bool shouldActivate)
		{
			m_cooldownDuration = ((!shouldActivate) ? 0f : CooldownTime);
		}

		public void SetCustomCooldown(float factor)
		{
			m_cooldownDuration = CooldownTime * factor;
		}

		public void SetTeleportCooldown(bool shouldActivate)
		{
			m_teleportCoolDownDuration = ((!shouldActivate) ? 0f : TeleportCooldownTime);
		}

		public void UpdateCooldown(float deltaTime)
		{
			if (m_cooldownDuration > 0f)
			{
				m_cooldownDuration -= deltaTime;
			}
			if (m_teleportCoolDownDuration > 0f)
			{
				m_teleportCoolDownDuration -= deltaTime;
			}
		}
	}
	public class MovementParams
	{
		public bool UseRaisedHandPosition;

		public bool HasHandPositionTarget;

		public bool HasRotationTarget;

		public bool ShouldFacePlayer;

		public bool IsPreparingFire;

		public int TurnInPlaceTimes;

		public float HandMovementDuration;

		public void SetPreparingFire(bool setActive)
		{
			IsPreparingFire = setActive;
		}
	}
	public class SpellParams
	{
		public bool AllowedToDepleteMana;

		public bool IsDefensiveSpellActive;

		public bool UseUrgentTeleport;
	}
	[CreateAssetMenu(fileName = "SpellPriority", menuName = "Spells/Priority", order = 1)]
	public class SpellPriorities : ScriptableObject
	{
		public const float Max = 1f;

		public const float Min = 0f;

		[Tooltip("The factor to be randomly added or subtracted from the spell priority.\n\nAt factor 0.2 a spell with priority 0.5 will be modified within the range of 0.4 to 0.6\n\n(priority +/- priority * factor)")]
		[SerializeField]
		private float m_randomPriorityFactor = 0.2f;

		[Header("Spell Priorities")]
		[SerializeField]
		private SpellPriority[] m_spellPriorities = new SpellPriority[12]
		{
			new SpellPriority(Spell.Spell_BlazingMeteor, 0.75f, 0.06f, 4),
			new SpellPriority(Spell.Spell_ChillingClutch, 0.6f, 0.05f, 4),
			new SpellPriority(Spell.Spell_Demi, 0.8f, 0.1f, 4),
			new SpellPriority(Spell.Spell_DevilsSpit, 0.7f, 0.04f, 6),
			new SpellPriority(Spell.Spell_ElectricFist, 0.7f, 0.04f, 6),
			new SpellPriority(Spell.Spell_HeavenlyDome, 1f, 0f, 8),
			new SpellPriority(Spell.Spell_MagicMissile, 0.7f, 0.04f, 6),
			new SpellPriority(Spell.Spell_ShieldOfLight, 1f, 0f, 8),
			new SpellPriority(Spell.Spell_SkullSpecter, 0.8f, 0.06f, 4),
			new SpellPriority(Spell.Spell_SoilSpikes, 0.8f, 0.05f, 1),
			new SpellPriority(Spell.Spell_StoneDemon, 0.8f, 0.05f, 1),
			new SpellPriority(Spell.Spell_Teleport, 0.8f, 0.1f, 8)
		};

		public float RandomPriorityFactor => m_randomPriorityFactor;

		private SpellPriority GetPriority(Spell spellType)
		{
			for (int i = 0; i < m_spellPriorities.Length; i++)
			{
				if (m_spellPriorities[i].SpellType == spellType)
				{
					return m_spellPriorities[i];
				}
			}
			WandsLogger.LogError("No priority set for spell " + spellType);
			return SpellPriority.Invalid;
		}

		private float GetModifiedPriority(SpellPriority spellPriority, int stacks)
		{
			float num = spellPriority.Priority - spellPriority.DecreasePerStack * (float)stacks;
			float num2 = UnityEngine.Random.Range(0f - num * RandomPriorityFactor, num * RandomPriorityFactor);
			return Mathf.Clamp(num + num2, 0f, 1f);
		}

		public float GetModifiedPriorityForSpell(Spell spellType, int stacks)
		{
			return GetModifiedPriority(GetPriority(spellType), stacks);
		}

		public int GetMaxStackEntries(Spell spellType)
		{
			for (int i = 0; i < m_spellPriorities.Length; i++)
			{
				if (m_spellPriorities[i].SpellType == spellType)
				{
					return m_spellPriorities[i].MaxStackEntries;
				}
			}
			return SpellPriority.Invalid.MaxStackEntries;
		}
	}
}
[Serializable]
public struct SpellPriority
{
	public static readonly SpellPriority Invalid = new SpellPriority(Spell.None, 0f, 0f, 0);

	[SerializeField]
	private Spell m_spellType;

	[SerializeField]
	private float m_priority;

	[SerializeField]
	private float m_decreasePerStack;

	[SerializeField]
	private int m_maxStackEntries;

	public Spell SpellType
	{
		[CompilerGenerated]
		get
		{
			return m_spellType;
		}
	}

	public float Priority
	{
		[CompilerGenerated]
		get
		{
			return m_priority;
		}
	}

	public float DecreasePerStack
	{
		[CompilerGenerated]
		get
		{
			return m_decreasePerStack;
		}
	}

	public int MaxStackEntries
	{
		[CompilerGenerated]
		get
		{
			return m_maxStackEntries;
		}
	}

	public SpellPriority(Spell type, float priority, float decreasePerStack, int maxStackEntries)
	{
		m_spellType = type;
		m_priority = priority;
		m_decreasePerStack = decreasePerStack;
		m_maxStackEntries = maxStackEntries;
	}
}
namespace Cortopia.AI.Predictions
{
	public class Prediction : MonoBehaviour
	{
		private const int MaxPredictionIterations = 500;

		private const int TrajectoryResolution = 9;

		private LayerMask m_botTrajectoryBlockMask;

		[SerializeField]
		private float m_defencePredictionMaxDuration = 5f;

		private float m_timeSinceLasteDefensiveSpell;

		private EventToken m_projectileCastEventToken;

		private EventToken m_defensiveSpellCastEventToken;

		private EventToken m_tilePredictedUnsafeEventToken;

		private EventToken m_tilePredictedSafeEventToken;

		private EventToken m_instantSpellInitiatedEventToken;

		private EventToken m_instantSpellChargedEventToken;

		private EventToken m_instantSpellReleasedEventToken;

		private EventToken m_predictableCurverCastEventToken;

		private EventToken m_collarsActivatedEventToken;

		private EventToken m_collarsDeactivatedEventToken;

		private List<TileHitPrediction> m_predictedTileHits = new List<TileHitPrediction>(16);

		private List<Tile> m_tilesWithCollarsActive = new List<Tile>(16);

		private float m_secondsUntilImpact;

		public TileHitPrediction InstantSpellHitPrediction;

		public Action<Tile> GetCurrentTile;

		public List<TileHitPrediction> PredictedTileHits { get; }

		public Tile AvoidTrajectoryFromTile { get; private set; }

		public bool PredictingDefence { get; private set; }

		public bool PredictingInstantDamage { get; private set; }

		public TileHitPrediction CurrentTileHitPrediction { get; private set; }

		public HashSet<Tile> UnsafeTiles { get; private set; } = new HashSet<Tile>();


		private void OnEnable()
		{
			m_botTrajectoryBlockMask = LayerMask.GetMask("Environment", "Train");
			m_projectileCastEventToken = EventHub.Subscribe<Events.ProjectileCastEvent>(OnProjectileCast);
			m_tilePredictedUnsafeEventToken = EventHub.Subscribe<Events.TilePredictedUnsafeEvent>(OnTilePredictedUnsafe);
			m_tilePredictedSafeEventToken = EventHub.Subscribe<Events.TilePredictedSafeEvent>(OnTilePredictedSafe);
			m_defensiveSpellCastEventToken = EventHub.Subscribe<Events.DefensiveSpellCastEvent>(OnDefensiveSpellCast);
			m_instantSpellInitiatedEventToken = EventHub.Subscribe<Events.InstantSpellInitiatedEvent>(OnInstantSpellInitiated);
			m_instantSpellChargedEventToken = EventHub.Subscribe<Events.InstantSpellChargedEvent>(OnInstantSpellCharged);
			m_instantSpellReleasedEventToken = EventHub.Subscribe<Events.InstantSpellReleasedEvent>(OnInstantSpellReleased);
			m_predictableCurverCastEventToken = EventHub.Subscribe<Events.PredictableCurverCastEvent>(OnPredictableCurverCast);
			m_collarsActivatedEventToken = EventHub.Subscribe<Events.CollarsActivatedEvent>(OnCollarsActivated);
			m_collarsDeactivatedEventToken = EventHub.Subscribe<Events.CollarsDeactivatedEvent>(OnCollarsDeactivated);
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe<Events.ProjectileCastEvent>(m_projectileCastEventToken);
			EventHub.Unsubscribe<Events.TilePredictedUnsafeEvent>(m_tilePredictedUnsafeEventToken);
			EventHub.Unsubscribe<Events.TilePredictedSafeEvent>(m_tilePredictedSafeEventToken);
			EventHub.Unsubscribe<Events.DefensiveSpellCastEvent>(m_defensiveSpellCastEventToken);
			EventHub.Unsubscribe<Events.InstantSpellInitiatedEvent>(m_instantSpellInitiatedEventToken);
			EventHub.Unsubscribe<Events.InstantSpellChargedEvent>(m_instantSpellChargedEventToken);
			EventHub.Unsubscribe<Events.InstantSpellReleasedEvent>(m_instantSpellReleasedEventToken);
			EventHub.Unsubscribe<Events.PredictableCurverCastEvent>(m_predictableCurverCastEventToken);
			EventHub.Unsubscribe<Events.CollarsActivatedEvent>(m_collarsActivatedEventToken);
			EventHub.Unsubscribe<Events.CollarsDeactivatedEvent>(m_collarsDeactivatedEventToken);
		}

		private void OnTilePredictedUnsafe(Events.TilePredictedUnsafeEvent eventData)
		{
			UnsafeTiles.Add(eventData.Tile);
		}

		private void OnTilePredictedSafe(Events.TilePredictedSafeEvent eventData)
		{
			UnsafeTiles.Remove(eventData.Tile);
		}

		private void OnCollarsActivated(Events.CollarsActivatedEvent eventData)
		{
			if (!m_tilesWithCollarsActive.Contains(eventData.Tile))
			{
				m_tilesWithCollarsActive.Add(eventData.Tile);
			}
		}

		private void OnCollarsDeactivated(Events.CollarsDeactivatedEvent eventData)
		{
			m_tilesWithCollarsActive.Remove(eventData.Tile);
		}

		private void OnDefensiveSpellCast(Events.DefensiveSpellCastEvent eventData)
		{
			SetDefencePrediction(shouldPredictDefence: true);
		}

		private void OnInstantSpellInitiated(Events.InstantSpellInitiatedEvent eventData)
		{
		}

		private void OnInstantSpellCharged(Events.InstantSpellChargedEvent eventData)
		{
			Vector3 position = PlayerManager.Instance.BotControl.GetCurrentTile().BotTeleportCollider.transform.position;
			Vector3 fromPosition = eventData.FromPosition;
			Vector3 direction = position - fromPosition;
			Ray ray = new Ray(fromPosition, direction);
			if (!Physics.Raycast(ray, direction.magnitude, m_botTrajectoryBlockMask))
			{
				PredictingInstantDamage = true;
				m_secondsUntilImpact = eventData.TimeUntilFullyCharged + (float)PhotonNetwork.GetPing() * 0.001f + 0.15f;
				InstantSpellHitPrediction = new TileHitPrediction(PlayerManager.Instance.BotControl.GetCurrentTile(), GetCurrentTime() + m_secondsUntilImpact, direction.normalized);
			}
		}

		private void OnInstantSpellReleased(Events.InstantSpellReleasedEvent eventData)
		{
			PredictingInstantDamage = false;
		}

		private void OnProjectileCast(Events.ProjectileCastEvent eventData)
		{
			SetDefencePrediction(shouldPredictDefence: false);
			if (eventData != null && (!(eventData.Damage <= 0f) || PlayerManager.Instance.BotControl.IsCurseActive))
			{
				PredictTilesHit(eventData.MoveVectors, eventData.Speed, eventData.Acceleration, eventData.MaxSpeed, eventData.ProjectileRadius, eventData.SplashDamageRadius, eventData.ReturnToSender, eventData.ProjectileMover);
			}
		}

		private void OnPredictableCurverCast(Events.PredictableCurverCastEvent eventData)
		{
			IPredictableCurver predictableCurver = eventData.PredictableCurver;
			float num = 0f;
			float num2 = 0f;
			Vector3 startPosition = predictableCurver.StartPosition;
			Collider[] array = new Collider[8];
			float currentTime = GetCurrentTime();
			Tile componentInParent;
			while (true)
			{
				num += Time.fixedDeltaTime;
				if (num >= predictableCurver.LifeTime)
				{
					return;
				}
				num2 = predictableCurver.StartSpeed * predictableCurver.Curve.Evaluate(num / predictableCurver.LifeTime);
				startPosition += predictableCurver.Direction * num2 * Time.fixedDeltaTime;
				int num3 = Physics.OverlapSphereNonAlloc(startPosition, predictableCurver.Radius, array, Constants.BotTeleportMask);
				if (num3 > 0)
				{
					componentInParent = array[0].GetComponentInParent<Tile>();
					if (componentInParent != null && componentInParent != PlayerManager.Instance.PlayerControl.GetCurrentTile())
					{
						break;
					}
				}
			}
			m_predictedTileHits.Add(new TileHitPrediction(componentInParent, currentTime + num, predictableCurver));
		}

		private void PredictTilesHit(Vector3[] vectors, float speed, float accelerationSpeed, float maxSpeed, float projectileRadius, float splashDamageRadius, bool returnToSender, ProjectileMover projectileMover)
		{
			bool flag = false;
			Vector3 vector = vectors[0];
			Vector3 vector2 = vector;
			float num = 0f;
			float currentTime = GetCurrentTime();
			float simpleBezierLength = Bezier.GetSimpleBezierLength(vectors[0], vectors[1], vectors[2]);
			float num2 = speed;
			float num3 = 0f;
			int num4 = 0;
			while (!flag)
			{
				num4++;
				if (num4 > 500)
				{
					flag = true;
				}
				if (num2 < maxSpeed)
				{
					num2 += accelerationSpeed * Time.fixedDeltaTime;
					if (num2 >= maxSpeed)
					{
						num2 = maxSpeed;
					}
				}
				num += num2 * Time.fixedDeltaTime / (simpleBezierLength * ((!returnToSender) ? 0.1f : (-0.1f)));
				vector2 = Bezier.GetPoint(vectors[0], vectors[1], vectors[2], num);
				if (Vector3.Distance(vectors[0], vector2) <= 2f)
				{
					continue;
				}
				num3 = Time.fixedDeltaTime * (float)num4;
				Vector3 direction = vector2 - vector;
				float magnitude = direction.magnitude;
				if (Physics.Raycast(vector, direction, out var hitInfo, magnitude, Constants.BotTeleportMask))
				{
					Tile componentInParent = hitInfo.transform.GetComponentInParent<Tile>();
					if ((bool)componentInParent)
					{
						float num5 = num3 + Time.fixedDeltaTime * (hitInfo.distance / magnitude);
						m_predictedTileHits.Add(new TileHitPrediction(componentInParent, currentTime + num5, direction.normalized, projectileMover));
					}
				}
				if (num >= 1f)
				{
					flag = true;
					if (!(splashDamageRadius > 0f))
					{
						break;
					}
					Collider[] array = Physics.OverlapSphere(vector2, splashDamageRadius, Constants.BotTeleportMask);
					Collider[] array2 = array;
					foreach (Collider collider in array2)
					{
						Tile componentInParent2 = collider.transform.GetComponentInParent<Tile>();
						if ((bool)componentInParent2)
						{
							m_predictedTileHits.Add(new TileHitPrediction(componentInParent2, currentTime + num3, direction.normalized, projectileMover));
						}
					}
					break;
				}
				vector = vector2;
			}
		}

		private void UpdateDefencePrediction()
		{
			if (PredictingDefence)
			{
				m_timeSinceLasteDefensiveSpell += Time.fixedDeltaTime;
				if (m_defencePredictionMaxDuration >= m_timeSinceLasteDefensiveSpell)
				{
					SetDefencePrediction(shouldPredictDefence: false);
				}
			}
		}

		private void SetDefencePrediction(bool shouldPredictDefence)
		{
			PredictingDefence = shouldPredictDefence;
			m_timeSinceLasteDefensiveSpell = 0f;
		}

		public bool IsTrajectoryBlocked(Vector3[] arcPoints, float radius)
		{
			Vector3 vector = arcPoints[0];
			Vector3 vector2 = arcPoints[0];
			for (int i = 1; i < 9; i++)
			{
				vector2 = Bezier.GetPoint(arcPoints[0], arcPoints[1], arcPoints[2], (float)i / 9f);
				Vector3 direction = vector2 - vector;
				Ray ray = new Ray(vector, direction);
				if (Physics.SphereCast(ray, radius, out var _, direction.magnitude, m_botTrajectoryBlockMask))
				{
					return true;
				}
				vector = vector2;
			}
			return false;
		}

		public bool IsTileUnsafe(Tile tile)
		{
			return UnsafeTiles.Contains(tile);
		}

		public bool IsPredictingIncomingProjectile(float duration)
		{
			float currentTime = GetCurrentTime();
			Tile currentTile = PlayerManager.Instance.BotControl.GetCurrentTile();
			foreach (TileHitPrediction predictedTileHit in m_predictedTileHits)
			{
				if (predictedTileHit.Tile != currentTile || !predictedTileHit.IsProjectileMoving() || !(predictedTileHit.HitMatchTime <= currentTime + duration))
				{
					continue;
				}
				CurrentTileHitPrediction = predictedTileHit;
				m_secondsUntilImpact = predictedTileHit.HitMatchTime - currentTime;
				return true;
			}
			return false;
		}

		public float GetTimeUntilLastPredictedImpactOnCurrentTile(float withinDuration)
		{
			float currentTime = GetCurrentTime();
			Tile currentTile = PlayerManager.Instance.BotControl.GetCurrentTile();
			float num = ((!PredictingInstantDamage) ? 0f : (InstantSpellHitPrediction.HitMatchTime - currentTime));
			foreach (TileHitPrediction predictedTileHit in m_predictedTileHits)
			{
				if (!(predictedTileHit.Tile != currentTile) && predictedTileHit.IsProjectileMoving() && predictedTileHit.HitMatchTime <= currentTime + withinDuration && predictedTileHit.HitMatchTime - currentTime > num)
				{
					num = predictedTileHit.HitMatchTime - currentTime;
				}
			}
			return num;
		}

		public bool IsTileSafe(Tile tile)
		{
			if (UnsafeTiles.Contains(tile))
			{
				return false;
			}
			foreach (TileHitPrediction predictedTileHit in m_predictedTileHits)
			{
				if (predictedTileHit.Tile == tile)
				{
					return false;
				}
			}
			return true;
		}

		public bool IsCollarsActiveOnTile(Tile tile)
		{
			return m_tilesWithCollarsActive.Contains(tile);
		}

		public float GetSecondsUntilImpacFromLastPrediction()
		{
			return m_secondsUntilImpact;
		}

		private float GetCurrentTime()
		{
			float num = PunSingleton<TimeManager>.Instance.CurrentMatchTime;
			if (num == 0f)
			{
				num = Time.timeSinceLevelLoad;
			}
			return num;
		}

		private void FixedUpdate()
		{
			UpdateDefencePrediction();
			if (m_predictedTileHits.Count <= 0)
			{
				return;
			}
			float currentTime = GetCurrentTime();
			for (int num = m_predictedTileHits.Count - 1; num >= 0; num--)
			{
				TileHitPrediction item = m_predictedTileHits[num];
				if (currentTime >= item.HitMatchTime + Time.fixedDeltaTime)
				{
					m_predictedTileHits.Remove(item);
				}
			}
		}
	}
	public struct TileHitPrediction
	{
		public Tile Tile;

		public float HitMatchTime;

		public Func<bool> IsProjectileMoving;

		public Vector3 ProjectileDirection;

		public TileHitPrediction(Tile tile, float hitMatchTime, Vector3 hitDirection, ProjectileMover projecitleMover)
		{
			Tile = tile;
			HitMatchTime = hitMatchTime;
			IsProjectileMoving = () => projecitleMover.IsMoving;
			ProjectileDirection = hitDirection;
		}

		public TileHitPrediction(Tile tile, float hitMatchTime, Vector3 hitDirection)
		{
			Tile = tile;
			HitMatchTime = hitMatchTime;
			IsProjectileMoving = () => true;
			ProjectileDirection = hitDirection;
		}

		public TileHitPrediction(Tile tile, float hitMatchTime, IPredictableCurver predictableCurver)
		{
			Tile = tile;
			HitMatchTime = hitMatchTime;
			IsProjectileMoving = () => predictableCurver != null;
			ProjectileDirection = predictableCurver.Direction;
		}
	}
}
namespace Cortopia.Scripts.AI
{
	public enum BotDifficultyLevel
	{
		NotSelected,
		VeryEasy,
		Easy,
		Normal,
		Hard,
		Unfair,
		Impossible
	}
	public static class BotDifficultyUtils
	{
		[StructLayout(LayoutKind.Sequential, Size = 1)]
		private struct Stats
		{
			public const float MaxHealthDefault = 100f;

			public const float MaxHealthUnfair = 200f;

			public const float MaxHealthImpossible = 350f;

			public const float MaxManaDefault = 100f;

			public const float MaxManaUnfair = 200f;

			public const float MaxManaImpossible = 350f;

			public const float MaxRegenDefault = 17f;

			public const float MaxRegenHard = 20f;

			public const float MaxRegenUnfair = 30f;

			public const float MaxRegenImpossible = 50f;
		}

		private static readonly IDictionary<BotDifficultyLevel, BotRating> sm_ratingChart = new Dictionary<BotDifficultyLevel, BotRating>
		{
			{
				BotDifficultyLevel.NotSelected,
				new BotRating(0, 0, 0)
			},
			{
				BotDifficultyLevel.VeryEasy,
				new BotRating(0, 1, 0)
			},
			{
				BotDifficultyLevel.Easy,
				new BotRating(1600, 1, 0)
			},
			{
				BotDifficultyLevel.Normal,
				new BotRating(1750, 2, 0)
			},
			{
				BotDifficultyLevel.Hard,
				new BotRating(2000, 10, 0)
			},
			{
				BotDifficultyLevel.Unfair,
				new BotRating(2500, 100, 0)
			},
			{
				BotDifficultyLevel.Impossible,
				new BotRating(3000, 200, 0)
			}
		};

		private static GameObject sm_selectedTooltip;

		public static BotDifficultyLevel DifficultyLevel = BotDifficultyLevel.NotSelected;

		public static int Elo
		{
			[CompilerGenerated]
			get
			{
				return sm_ratingChart[DifficultyLevel].Elo;
			}
		}

		public static int Level
		{
			[CompilerGenerated]
			get
			{
				return sm_ratingChart[DifficultyLevel].Level;
			}
		}

		public static int SeasonScore
		{
			[CompilerGenerated]
			get
			{
				return sm_ratingChart[DifficultyLevel].SeasonScore;
			}
		}

		public static bool IsSelected(BotDifficultyLevel difficultyLevel)
		{
			return difficultyLevel == DifficultyLevel;
		}

		public static void SetSelectedTooltip(GameObject tooltip)
		{
			sm_selectedTooltip = tooltip;
		}

		public static void LookEnter()
		{
			sm_selectedTooltip.SetActive(value: false);
		}

		public static void LookExit()
		{
			sm_selectedTooltip.SetActive(value: true);
		}

		public static float GetMaxHealth()
		{
			switch (DifficultyLevel)
			{
			case BotDifficultyLevel.NotSelected:
			case BotDifficultyLevel.VeryEasy:
			case BotDifficultyLevel.Easy:
			case BotDifficultyLevel.Normal:
			case BotDifficultyLevel.Hard:
				return 100f;
			case BotDifficultyLevel.Unfair:
				return 200f;
			case BotDifficultyLevel.Impossible:
				return 350f;
			default:
				throw new NotImplementedException($"{DifficultyLevel} not a valid selected bot difficulty level.");
			}
		}

		public static Tuple<float, float> GetManaStats()
		{
			switch (DifficultyLevel)
			{
			case BotDifficultyLevel.NotSelected:
			case BotDifficultyLevel.VeryEasy:
			case BotDifficultyLevel.Easy:
			case BotDifficultyLevel.Normal:
				return new Tuple<float, float>(100f, 17f);
			case BotDifficultyLevel.Hard:
				return new Tuple<float, float>(100f, 20f);
			case BotDifficultyLevel.Unfair:
				return new Tuple<float, float>(200f, 30f);
			case BotDifficultyLevel.Impossible:
				return new Tuple<float, float>(350f, 50f);
			default:
				throw new NotImplementedException($"{DifficultyLevel} not a valid selected bot difficulty level.");
			}
		}

		public static void TryUnlockReward()
		{
			if (DifficultyLevel == BotDifficultyLevel.Impossible)
			{
				GameControl.Instance.Player.TryUnlockImpossibleBotReward();
			}
		}
	}
	public class BotRating
	{
		public int Elo;

		public int Level;

		public int SeasonScore;

		public BotRating(int elo, int level, int seasonScore)
		{
			Elo = elo;
			Level = level;
			SeasonScore = seasonScore;
		}
	}
}
namespace Cortopia.Scripts.AI.Stats
{
	public class StatsDataManager : MonoBehaviour
	{
		[SerializeField]
		private StatsManagementProfile m_stalkProfile;

		[SerializeField]
		private StatsManagementProfile m_offensiveProfile;

		[SerializeField]
		private StatsManagementProfile m_defensiveProfile;

		public StatsManagementProfileType CurrentProfileType;

		private StatsData m_health;

		private StatsData m_mana;

		public StatsManagementProfile CurrentProfile { get; private set; }

		private void Start()
		{
			Pawn component = GetComponent<Pawn>();
			m_health = component.GetHealthData();
			m_mana = component.GetManaData();
			ChangeProfile(StatsManagementProfileType.Stalk);
		}

		public void ChangeProfile(StatsManagementProfileType newProfile)
		{
			CurrentProfileType = newProfile;
			switch (CurrentProfileType)
			{
			case StatsManagementProfileType.Stalk:
				CurrentProfile = m_stalkProfile;
				break;
			case StatsManagementProfileType.Offensive:
				CurrentProfile = m_offensiveProfile;
				break;
			case StatsManagementProfileType.Defensive:
				CurrentProfile = m_defensiveProfile;
				break;
			}
		}

		public bool AllowedToCast(SpellBase spell, float priority, bool allowedToDepleteMana)
		{
			if (CurrentProfile == null)
			{
				return false;
			}
			int castCost = spell.GetCastCost();
			float num = CurrentProfile.MaxManaReserveTarget;
			if (priority > 0.75f)
			{
				num = CurrentProfile.MinManaReserveTarget;
			}
			else if (priority > 0.25f)
			{
				num = CurrentProfile.NormalManaReserveTarget;
			}
			if (allowedToDepleteMana)
			{
				if (m_mana.Current - (float)castCost >= 0f)
				{
					return true;
				}
			}
			else if (m_mana.Current - (float)castCost >= num)
			{
				return true;
			}
			return false;
		}

		public float GetCurrentHealthFactor()
		{
			return m_health.Fill;
		}

		public float GetCurrentManaFactor()
		{
			return m_mana.Fill;
		}

		public float GetCurrentHealth()
		{
			return m_health.Current;
		}

		public float GetCurrentMana()
		{
			return m_mana.Current;
		}
	}
	[Serializable]
	public class StatsManagementProfile
	{
		public StatsManagementProfileType StatsManagementProfileType;

		public float MaxManaReserveTarget = 100f;

		public float NormalManaReserveTarget = 50f;

		public float MinManaReserveTarget;

		public bool UseAllOutAttack;
	}
	public enum StatsManagementProfileType
	{
		Stalk,
		Offensive,
		Defensive
	}
}
namespace Cortopia.Scripts.AI.Targeting
{
	public enum AimResult
	{
		NonValidTrajectory,
		NonValidSightray,
		Success
	}
	public struct BotAimTarget
	{
		public Tile FromTile;

		public float Time;

		public BotAimTargetType TargetType;

		public Ray AimRay;

		public BotAimTarget(Tile fromTile, BotAimTargetType targetType, Ray aimRay)
		{
			FromTile = fromTile;
			Time = PunSingleton<TimeManager>.Instance.CurrentMatchTime;
			TargetType = targetType;
			AimRay = aimRay;
		}

		public bool IsEqual(BotAimTarget otherAimTarget)
		{
			return otherAimTarget.TargetType == TargetType && otherAimTarget.FromTile == FromTile && otherAimTarget.AimRay.origin == AimRay.origin && otherAimTarget.AimRay.direction == AimRay.direction;
		}
	}
	public enum BotAimTargetType
	{
		Offensive,
		Defensive,
		Pickup,
		Teleport
	}
	public class BotTargeting
	{
		private const float AimAccuracyTolerance = 1.2f;

		private const float AimTargetRadius = 2f;

		private IBotTargeter m_botTargeter;

		private float m_validationDuration;

		private int m_currentAimOffsetPosition = -1;

		private static readonly Vector3[] sm_aimOffsetPositions = new Vector3[5]
		{
			new Vector3(0.3f, 0f, 0.2f),
			new Vector3(-0.1f, -0.2f, 0.4f),
			new Vector3(0.3f, -0.5f, 0.2f),
			new Vector3(-0.1f, -0.5f, 0.4f),
			new Vector3(0f, 0f, 0.4f)
		};

		private Vector3? m_wandOffset;

		private Vector3 WandOffset
		{
			get
			{
				if (!m_wandOffset.HasValue)
				{
					m_wandOffset = m_botTargeter.WandControl.WandMeshTransform.parent.localPosition * m_botTargeter.WandControl.Transform.localScale.x;
				}
				return m_wandOffset.Value;
			}
		}

		public BotAimTarget AimTarget { get; private set; }

		public float Accuracy { get; }

		public float ElapsedTimeSinceTargetChange
		{
			[CompilerGenerated]
			get
			{
				return PunSingleton<TimeManager>.Instance.CurrentMatchTime - AimTarget.Time;
			}
		}

		public BotTargeting(IBotTargeter botTargeter, float accuracy, float validationDuration)
		{
			m_botTargeter = botTargeter;
			Accuracy = accuracy;
			m_validationDuration = validationDuration;
		}

		public void SetAimTarget(BotAimTarget aimTarget)
		{
			AimTarget = aimTarget;
		}

		public bool HasValidAimTarget(Tile fromTile)
		{
			return HasValidAimTarget(fromTile, AimTarget);
		}

		public bool HasValidAimTarget(Tile fromTile, BotAimTarget aimTarget)
		{
			return (fromTile == AimTarget.FromTile && AimTarget.IsEqual(aimTarget) && PunSingleton<TimeManager>.Instance.CurrentMatchTime - AimTarget.Time <= m_validationDuration) ? true : false;
		}

		public Vector3 GetModifiedTargetPosition(Vector3 targetPos, float aimRadiusFactor = 1f)
		{
			Vector3 normalized = (targetPos - m_botTargeter.WandControl.CachedTipPoint).normalized;
			float num = (1f - Accuracy) * 2f * aimRadiusFactor;
			Vector3 vector = new Vector3(UnityEngine.Random.Range(0f - num, num), UnityEngine.Random.Range(0f - num, num), 0f);
			return targetPos + Quaternion.LookRotation(normalized) * vector;
		}

		public Vector3 GetTargetHeadPosition(float belowHeadDistance)
		{
			PlayerControl playerControl = PlayerManager.Instance.PlayerControl;
			return playerControl.CameraTransform.position - new Vector3(0f, belowHeadDistance, 0f);
		}

		public AimResult GetHasValidTrajectoryToCollider(Collider targetCollider, out Vector3 validHandPosition, out Vector3 targetColliderPosition)
		{
			validHandPosition = Vector3.zero;
			targetColliderPosition = Vector3.zero;
			SightRay unblockedSightRayForCollider = m_botTargeter.Sight.GetUnblockedSightRayForCollider(targetCollider);
			if (unblockedSightRayForCollider.IsInvalid())
			{
				return AimResult.NonValidSightray;
			}
			targetColliderPosition = unblockedSightRayForCollider.End;
			if (GetHasValidTrajectory(targetColliderPosition, useTileTracking: true, out validHandPosition))
			{
				return AimResult.Success;
			}
			return AimResult.NonValidTrajectory;
		}

		public bool GetHasValidTrajectory(Vector3 targetPos, bool useTileTracking, out Vector3 validHandPosition)
		{
			return GetHasValidTrajectory(targetPos, 0f, 1.2f, useTileTracking, out validHandPosition);
		}

		public bool GetHasValidTrajectory(Vector3 targetPos, float radius, out Vector3 validHandPosition, float aimOffsetTolerance = 1.2f)
		{
			return GetHasValidTrajectory(targetPos, radius, aimOffsetTolerance, useTileTracking: false, out validHandPosition);
		}

		private bool GetHasValidTrajectory(Vector3 targetPosition, float radius, float aimOffsetTolerance, bool useTileTracking, out Vector3 validHandPosition)
		{
			for (int i = 0; i < sm_aimOffsetPositions.Length; i++)
			{
				validHandPosition = m_botTargeter.Sight.Origin.position + m_botTargeter.WandControl.Wielder.Character.CharacterRenderer.Body.rotation * sm_aimOffsetPositions[i];
				if ((!useTileTracking) ? GetHasValidTrajectory(validHandPosition, targetPosition, radius, aimOffsetTolerance) : GetIsHighlightingTile(validHandPosition, targetPosition, radius))
				{
					m_currentAimOffsetPosition = i;
					return true;
				}
			}
			validHandPosition = Vector3.zero;
			m_currentAimOffsetPosition = -1;
			return false;
		}

		public void AimAtPosition(Vector3 handPosition, Vector3 aimTarget, float duration, Action onAimedAtPosition)
		{
			m_botTargeter.Aim.AimAtPosition(aimTarget, duration, delegate
			{
				onAimedAtPosition();
			});
		}

		private bool GetIsHighlightingTile(Vector3 fromPosition, Vector3 targetPosition, float radius)
		{
			Vector3 hitPointOrClosest = m_botTargeter.Aim.GetHitPointOrClosest(0f, 150f);
			m_botTargeter.Aim.AimAtPosition(targetPosition);
			Vector3 hitPointOrClosest2 = m_botTargeter.Aim.GetHitPointOrClosest(radius);
			m_botTargeter.Aim.SetAimDistance(hitPointOrClosest2);
			m_botTargeter.TryTrackTileHit();
			m_botTargeter.Aim.AimAtPosition(hitPointOrClosest);
			m_botTargeter.Aim.SetAimDistance(hitPointOrClosest);
			return m_botTargeter.HighlightedTile != null;
		}

		private bool GetHasValidTrajectory(Vector3 fromPosition, Vector3 targetPosition, float radius, float minTargetDistance)
		{
			Vector3 hitPointOrClosest = m_botTargeter.Aim.GetHitPointOrClosest(0f, 150f);
			m_botTargeter.Aim.AimAtPosition(targetPosition);
			Vector3 hitPointOrClosest2 = m_botTargeter.Aim.GetHitPointOrClosest(radius);
			bool result = (hitPointOrClosest2 - targetPosition).sqrMagnitude <= minTargetDistance;
			m_botTargeter.Aim.AimAtPosition(hitPointOrClosest);
			m_botTargeter.Aim.SetAimDistance(hitPointOrClosest);
			return result;
		}

		[Conditional("UNITY_EDITOR")]
		private void DrawUntestedCoordinatesAndFinalAim(Vector3 targetPosition, Vector3 validHandPosition)
		{
		}

		[Conditional("UNITY_EDITOR")]
		private void DrawCoordinate(Vector3 pos, Color color)
		{
		}

		[Conditional("UNITY_EDITOR")]
		private void DrawCoordinate(Vector3 pos, Color color, float duration)
		{
		}
	}
	public struct BotTileTarget
	{
		public Tile FromTile;

		public float Time;

		public BotAimTargetType TargetType;

		public Tile Tile;

		public BotTileTarget(Tile fromTile, float time, BotAimTargetType targetType, Tile tile)
		{
			FromTile = fromTile;
			Time = time;
			TargetType = targetType;
			Tile = tile;
		}

		public bool IsEqual(BotTileTarget otherTileTarget)
		{
			return otherTileTarget.TargetType == TargetType && otherTileTarget.FromTile == FromTile && otherTileTarget.Tile == Tile;
		}
	}
}
namespace Cortopia.Scripts.Aiming
{
	public class Aim
	{
		protected const float StandardAimLength = 1.2f;

		protected const float OriginForwardHead = 0.75f;

		protected AimData m_aimData;

		protected AimInput m_aimInput;

		public LayerMask AimHitMask { get; set; }

		public Transform AimPivot { get; protected set; }

		public Transform WandPivot { get; protected set; }

		public float AimDistance { get; private set; }

		public Ray AimRay
		{
			[CompilerGenerated]
			get
			{
				return new Ray(AimPivot.position, AimPivot.forward);
			}
		}

		public Aim(AimData data)
		{
			m_aimData = data;
			AimHitMask = m_aimData.AimHitMask;
		}

		public void SetPivotTransforms(Transform aimPivot, Transform wandPivot)
		{
			AimPivot = aimPivot;
			if (!(wandPivot == null))
			{
				WandPivot = wandPivot;
				wandPivot.SetParent(AimPivot.parent, ResetBehaviour.PositionAndRotation);
			}
		}

		public virtual Vector3 GetAimOrigin(float offset = 0f)
		{
			offset += 0.75f;
			return AimRay.GetPoint(offset);
		}

		public void SetAimDistance(Vector3 endPoint)
		{
			AimDistance = (endPoint - AimRay.origin).magnitude;
		}

		public void AimAtPosition(Vector3 newAimPosition)
		{
			AimPivot.rotation = Quaternion.LookRotation(newAimPosition - AimPivot.position);
		}

		public void AimAtPosition(Vector3 newAimPosition, float duration, TweenCallback onComplete)
		{
			AimPivot.DORotateQuaternion(Quaternion.LookRotation(newAimPosition - AimPivot.position), duration).SetEase(Ease.InOutSine).OnComplete(onComplete);
		}

		public Vector3 GetHitPointOrClosest(float collisionRadius)
		{
			return GetHitPointOrClosest(collisionRadius, m_aimData.MaxAimDistance);
		}

		public Vector3 GetHitPointOrClosest(float collisionRadius, float maxDistance)
		{
			RaycastHit hitInfo;
			if (collisionRadius > 0f)
			{
				if (Physics.SphereCast(AimRay, collisionRadius, out hitInfo, maxDistance, AimHitMask))
				{
					return hitInfo.point;
				}
			}
			else if (Physics.Raycast(AimRay, out hitInfo, maxDistance, AimHitMask))
			{
				return hitInfo.point;
			}
			return AimRay.GetPoint(maxDistance);
		}

		public bool RaycastTeleportTile(out RaycastHit hit)
		{
			return Physics.Raycast(AimRay, out hit, m_aimData.MaxAimDistance, m_aimData.TeleportHitMask);
		}
	}
}
namespace Assets.Scripts.Animation
{
	public class AnimationConstants
	{
		public const string Hit = "Hit";

		public const string NewAttack = "NewAttack";

		public const string IsChanneling = "isChannelling";

		public const string IsDead = "isDead";

		public const string IsMirrored = "isMirrored";

		public const string InLobby = "inLobby";

		public const string HitDirectionX = "HitDirectionX";

		public const string HitDirectionY = "HitDirectionY";

		public const string AttackAnimation = "AttackAnimation";

		public const string ChannelAnimation = "ChannelAnimation";
	}
	public class AnimationNetworkRelay : MonoBehaviourPun
	{
		public Wielder Wielder { get; set; }

		public CustomAnimationController CustomAnimationController { get; set; }

		private RpcTarget RPCTarget
		{
			[CompilerGenerated]
			get
			{
				return (!PlayForAll) ? RpcTarget.Others : RpcTarget.All;
			}
		}

		private bool PlayForAll => Wielder.IsBot;

		public void PlayAttackAnimation(AttackAnimationType animationType)
		{
			base.photonView.RPC("PunPlayAttackAnimation", RPCTarget, (int)animationType);
		}

		[PunRPC]
		private void PunPlayAttackAnimation(int animationIndex)
		{
			CustomAnimationController?.OneShotAttackAnimation(animationIndex);
		}

		public void PlayChannelingAnimation(ChannelAnimationType animationType)
		{
			base.photonView.RPC("PunPlayChannelingAnimation", RPCTarget, true, (int)animationType);
		}

		public void StopChannelingAnimation(ChannelAnimationType animationType)
		{
			base.photonView.RPC("PunPlayChannelingAnimation", RPCTarget, false, (int)animationType);
		}

		[PunRPC]
		private void PunPlayChannelingAnimation(bool isChanneling, int animationIndex)
		{
			CustomAnimationController?.ChannelAttackAnimation(animationIndex, isChanneling);
		}

		public void PlayHitAnimation(Vector2 hitNormal)
		{
			base.photonView.RPC("PunPlayHitAnimation", RPCTarget, hitNormal);
		}

		[PunRPC]
		private void PunPlayHitAnimation(Vector2 hitNormal)
		{
			CustomAnimationController?.OnHit(hitNormal);
			if (Wielder.IsBot)
			{
				Wielder.BotCharacter?.OnLocalHit();
			}
			else
			{
				Wielder.RemoteCharacter?.OnLocalHit();
			}
		}

		public void SetDeadAnimationState(bool isDead)
		{
			base.photonView.RPC("PunSetDeadAnimationState", RPCTarget, isDead);
		}

		[PunRPC]
		private void PunSetDeadAnimationState(bool isDead)
		{
			CustomAnimationController?.DeathAnimationToggle(isDead);
		}
	}
	public class AnimationSceneController : MonoBehaviour
	{
		private CustomAnimationController[] m_allAnimationsControllers;

		private void Start()
		{
			m_allAnimationsControllers = UnityEngine.Object.FindObjectsOfType<CustomAnimationController>();
		}

		private void Update()
		{
			HandleMouseInput();
			HandleDebugInput();
		}

		private void HandleMouseInput()
		{
			if (Input.GetMouseButtonDown(0))
			{
				Attack();
			}
		}

		private void HandleDebugInput()
		{
			if (Input.GetKeyDown("1"))
			{
				CustomAnimationController[] allAnimationsControllers = m_allAnimationsControllers;
				foreach (CustomAnimationController customAnimationController in allAnimationsControllers)
				{
					customAnimationController.OneShotAttackAnimation(0);
				}
			}
			if (Input.GetKeyDown("2"))
			{
				CustomAnimationController[] allAnimationsControllers2 = m_allAnimationsControllers;
				foreach (CustomAnimationController customAnimationController2 in allAnimationsControllers2)
				{
					customAnimationController2.OneShotAttackAnimation(1);
				}
			}
			if (Input.GetKeyDown("3"))
			{
				CustomAnimationController[] allAnimationsControllers3 = m_allAnimationsControllers;
				foreach (CustomAnimationController customAnimationController3 in allAnimationsControllers3)
				{
					customAnimationController3.OneShotAttackAnimation(2);
				}
			}
			if (Input.GetKeyDown("u"))
			{
				CustomAnimationController[] allAnimationsControllers4 = m_allAnimationsControllers;
				foreach (CustomAnimationController customAnimationController4 in allAnimationsControllers4)
				{
					customAnimationController4.DeathAnimationToggle();
				}
			}
			if (Input.GetKeyDown("e"))
			{
				CustomAnimationController[] allAnimationsControllers5 = m_allAnimationsControllers;
				foreach (CustomAnimationController customAnimationController5 in allAnimationsControllers5)
				{
					customAnimationController5.MirrorAnimator(!customAnimationController5.Animator.GetBool("isMirrored"));
				}
			}
			if (Input.GetKeyDown("q"))
			{
				CustomAnimationController[] allAnimationsControllers6 = m_allAnimationsControllers;
				foreach (CustomAnimationController customAnimationController6 in allAnimationsControllers6)
				{
					customAnimationController6.ChannelAttackAnimation(0, isChannelling: true);
				}
			}
			if (Input.GetKeyDown("w"))
			{
				CustomAnimationController[] allAnimationsControllers7 = m_allAnimationsControllers;
				foreach (CustomAnimationController customAnimationController7 in allAnimationsControllers7)
				{
					customAnimationController7.ChannelAttackAnimation(1, isChannelling: true);
				}
			}
			if (Input.GetKeyUp("q"))
			{
				CustomAnimationController[] allAnimationsControllers8 = m_allAnimationsControllers;
				foreach (CustomAnimationController customAnimationController8 in allAnimationsControllers8)
				{
					customAnimationController8.ChannelAttackAnimation(0, isChannelling: false);
				}
			}
			if (Input.GetKeyUp("w"))
			{
				CustomAnimationController[] allAnimationsControllers9 = m_allAnimationsControllers;
				foreach (CustomAnimationController customAnimationController9 in allAnimationsControllers9)
				{
					customAnimationController9.ChannelAttackAnimation(1, isChannelling: false);
				}
			}
			if (Input.GetKeyDown("r"))
			{
				CustomAnimationController[] allAnimationsControllers10 = m_allAnimationsControllers;
				foreach (CustomAnimationController customAnimationController10 in allAnimationsControllers10)
				{
					customAnimationController10.LobbyAnimationToggle();
				}
			}
		}

		private void Attack()
		{
			Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
			if (Physics.Raycast(ray, out var hitInfo))
			{
				Vector3 vector = base.transform.position - hitInfo.point;
				hitInfo.collider.GetComponentInParent<CustomAnimationController>()?.OnHit(new Vector2(vector.x, vector.z).normalized);
				UnityEngine.Debug.DrawLine(ray.origin, hitInfo.point, Color.red, 5f);
			}
		}
	}
}
namespace Cortopia.Scripts.Animation.Constraints
{
	public class LerpConstraint : MonoBehaviour
	{
		[Header("Constrained Transforms")]
		[SerializeField]
		private Transform m_parentJoint;

		[SerializeField]
		private Transform m_childJoint;

		[Header("Position Settings")]
		[SerializeField]
		private bool m_constrainPosition;

		[SerializeField]
		private bool m_keepPositionOffset;

		[SerializeField]
		private float m_positionLerpStrength;

		[Header("Rotation Settings")]
		[SerializeField]
		private bool m_constrainRotation;

		[SerializeField]
		private bool m_keepRotationOffset;

		[SerializeField]
		private float m_rotationLerpStrength;

		[Header("General Settings")]
		[SerializeField]
		private bool m_constrainOnStart;

		private bool m_isConstrainActive;

		private Vector3 m_childPositionOffset;

		private Quaternion m_childRotationOffset;

		private Quaternion m_parentRotationOffset;

		private Matrix4x4 m_parentMatrix;

		private Vector3 m_targetPosition;

		private Quaternion m_targetRotation;

		private float m_deltaAngle;

		private float m_deltaDistance;

		private void Start()
		{
			if (m_constrainOnStart)
			{
				ActivateConstraint();
			}
		}

		private void Update()
		{
			if (m_isConstrainActive)
			{
				Constrain();
			}
		}

		public void ActivateConstraint()
		{
			m_childPositionOffset = DivideVectors(Quaternion.Inverse(m_parentJoint.rotation) * (m_childJoint.position - m_parentJoint.position), m_parentJoint.lossyScale);
			m_childRotationOffset = m_childJoint.rotation;
			m_parentRotationOffset = m_parentJoint.rotation;
			m_isConstrainActive = true;
		}

		public void DeactivateConstraint()
		{
			m_isConstrainActive = false;
		}

		private void Constrain()
		{
			if (m_constrainPosition)
			{
				if (m_keepPositionOffset)
				{
					m_parentMatrix = Matrix4x4.TRS(m_parentJoint.position, m_parentJoint.rotation, m_parentJoint.lossyScale);
					m_targetPosition = m_parentMatrix.MultiplyPoint3x4(m_childPositionOffset);
				}
				else
				{
					m_targetPosition = m_parentJoint.transform.position;
				}
				m_deltaDistance = Vector3.Magnitude(m_targetPosition - m_childJoint.position) * m_positionLerpStrength;
				m_childJoint.position = Vector3.Lerp(m_childJoint.position, m_targetPosition, Time.deltaTime * m_deltaDistance);
			}
			if (m_constrainRotation)
			{
				if (m_keepRotationOffset)
				{
					m_targetRotation = m_parentJoint.rotation * Quaternion.Inverse(m_parentRotationOffset) * m_childRotationOffset;
				}
				else
				{
					m_targetRotation = m_parentJoint.transform.rotation;
				}
				m_deltaAngle = Quaternion.Angle(m_childJoint.rotation, m_targetRotation) * m_rotationLerpStrength;
				m_childJoint.rotation = Quaternion.Slerp(m_childJoint.rotation, m_targetRotation, Time.deltaTime * m_deltaAngle);
			}
		}

		private Vector3 DivideVectors(Vector3 num, Vector3 den)
		{
			return new Vector3(num.x / den.x, num.y / den.y, num.z / den.z);
		}
	}
}
namespace Assets.Scripts.Animation
{
	[RequireComponent(typeof(Animator))]
	public class CustomAnimationController : MonoBehaviour
	{
		[SerializeField]
		private Animator m_animator;

		private CharacterMovement m_characterMovement;

		public Animator Animator => m_animator;

		private void Start()
		{
			m_characterMovement = GetComponentInParent<CharacterMovement>();
		}

		public void OnHit(Vector2 AttackDirection)
		{
			Animator.SetFloat("HitDirectionX", AttackDirection.x);
			Animator.SetFloat("HitDirectionY", AttackDirection.y);
			Animator.SetTrigger("Hit");
		}

		public void OneShotAttackAnimation(int animationType)
		{
			Animator.SetBool("isChannelling", value: false);
			Animator.SetInteger("AttackAnimation", animationType);
			Animator.SetTrigger("NewAttack");
			m_characterMovement.TryTemporarilyDisableLocomotion();
		}

		public void ChannelAttackAnimation(int animationType, bool isChannelling)
		{
			if (isChannelling)
			{
				Animator.SetInteger("ChannelAnimation", animationType);
				Animator.SetTrigger("NewAttack");
				Animator.SetBool("isChannelling", isChannelling);
			}
			else
			{
				Animator.SetBool("isChannelling", isChannelling);
			}
		}

		public void DeathAnimationToggle()
		{
			DeathAnimationToggle(!Animator.GetBool("isDead"));
		}

		public void DeathAnimationToggle(bool isDead)
		{
			m_characterMovement.SetDead(isDead);
			Animator.SetBool("isChannelling", !isDead);
			Animator.SetBool("isDead", isDead);
		}

		public void MirrorAnimator(bool isMirrored)
		{
			if (base.gameObject.activeSelf)
			{
				Animator.SetBool("isMirrored", isMirrored);
			}
		}

		public void LobbyAnimationToggle()
		{
			LobbyAnimationToggle(!Animator.GetBool("inLobby"));
		}

		public void LobbyAnimationToggle(bool inLobby)
		{
			if (base.gameObject.activeSelf)
			{
				Animator.SetBool("inLobby", inLobby);
			}
		}
	}
	public class DesertDoorAnimationState : StateMachineBehaviour
	{
		private SplitAudioSoundPlayer[] m_audioPlayers;

		public void OnDoorAnimationStart(Animator animator, float duration)
		{
			if (m_audioPlayers.IsNullOrEmpty())
			{
				m_audioPlayers = animator.GetComponentsInChildren<SplitAudioSoundPlayer>();
			}
			SplitAudioSoundPlayer[] audioPlayers = m_audioPlayers;
			foreach (SplitAudioSoundPlayer splitAudioSoundPlayer in audioPlayers)
			{
				splitAudioSoundPlayer.PlaySplitAudio(duration);
			}
		}

		public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			OnDoorAnimationStart(animator, stateInfo.length);
		}
	}
	public class FloatingObject : MonoBehaviour
	{
		[SerializeField]
		private float m_amplitude;

		[SerializeField]
		private float m_speed;

		private float m_tempY;

		private Vector3 m_tempPos;

		private void Start()
		{
			m_tempPos = base.transform.position;
			m_tempY = m_tempPos.y;
		}

		private void Update()
		{
			m_tempPos.y = m_tempY + m_amplitude * Mathf.Sin(m_speed * Time.time);
			base.transform.position = m_tempPos;
		}
	}
	[RequireComponent(typeof(Animator))]
	public abstract class HandAnimator : MonoBehaviour
	{
		public const float WandGripMainAngle = 0f;

		public const float PistolGripMainAngle = 0f;

		protected const string IndexTrigger = "HandIndexFinger";

		protected const string HandTrigger = "HandLongFinger";

		protected const string ThumbButtons = "HandThumb";

		protected const string WandGripTrigger = "WandGrip";

		protected const string IndexClick = "HandActivate";

		protected const string DefaultGrip = "DefaultGrip";

		[SerializeField]
		protected AimInput m_hand = AimInput.RightHand;

		[SerializeField]
		protected Transform m_aimPoint;

		protected bool m_isPrimaryHand;

		protected bool m_isHoldingWand;

		protected bool m_isHoldingIndexTrigger;

		protected bool m_isHoldingHandTrigger;

		protected float m_holdWeight;

		protected Animator m_animator;

		protected PlayerControl m_playerControl;

		private void Awake()
		{
			m_animator = GetComponent<Animator>();
			m_animator.SetBool("HandThumb", value: true);
		}

		private void Update()
		{
			if (!m_isHoldingWand && !m_isPrimaryHand)
			{
				TrackHandTrigger();
			}
			TrackIndexTrigger();
		}

		public void SetPlayerReference(PlayerControl playerControl)
		{
			m_playerControl = playerControl;
		}

		public virtual void ChangePrimaryHand(AimInput aimInput, bool isDualWielding)
		{
			if (GameControl.Instance.IsCurrentLevel(Level.Arena))
			{
				m_isHoldingWand = isDualWielding || aimInput == m_hand;
				return;
			}
			m_isHoldingWand = false;
			m_isPrimaryHand = aimInput == m_hand;
			if (m_isPrimaryHand)
			{
				m_isHoldingHandTrigger = true;
				SetAnimationBool("HandLongFinger", value: true);
			}
		}

		public virtual void ChangeWandGrip(WandGrip wandGrip)
		{
			if (m_isHoldingWand)
			{
				base.transform.localRotation = Quaternion.Euler(0f, (wandGrip != 0) ? 0f : 0f, 0f);
				m_animator.SetBool("DefaultGrip", wandGrip == GameControl.Instance.Platform.DefaultWandGrip);
			}
			else
			{
				base.transform.localRotation = Quaternion.identity;
			}
		}

		public void DisableWandGrip()
		{
			SetAnimationBool("WandGrip", value: false);
		}

		protected void TryEnableWandGrip()
		{
			SetAnimationTrigger("WandGrip");
			SetAnimationBool("WandGrip", value: true);
			SetAnimationBool("HandIndexFinger", value: false);
			ClearAnimationTrigger("HandActivate");
		}

		protected virtual void TrackIndexTrigger()
		{
		}

		protected virtual void TrackHandTrigger()
		{
		}

		protected void SetAnimationBool(string boolName, bool value)
		{
			if (!string.IsNullOrEmpty(boolName))
			{
				m_animator.SetBool(boolName, value);
			}
		}

		protected void SetAnimationTrigger(string triggerName)
		{
			if (!string.IsNullOrEmpty(triggerName))
			{
				m_animator.SetTrigger(triggerName);
			}
		}

		protected void ClearAnimationTrigger(string triggerName)
		{
			if (!string.IsNullOrEmpty(triggerName))
			{
				m_animator.ResetTrigger(triggerName);
			}
		}
	}
	public class OculusHandAnimator : HandAnimator
	{
		private OVRInput.RawButton m_indexTrigger = OVRInput.RawButton.RIndexTrigger;

		private OVRInput.RawButton m_handTrigger = OVRInput.RawButton.RHandTrigger;

		public override void ChangePrimaryHand(AimInput aimInput, bool isDualWielding)
		{
			base.ChangePrimaryHand(aimInput, isDualWielding);
			switch (m_hand)
			{
			case AimInput.LeftHand:
				m_indexTrigger = OVRInput.RawButton.LIndexTrigger;
				m_handTrigger = OVRInput.RawButton.LHandTrigger;
				break;
			case AimInput.RightHand:
				m_indexTrigger = OVRInput.RawButton.RIndexTrigger;
				m_handTrigger = OVRInput.RawButton.RHandTrigger;
				break;
			}
			if (m_isHoldingWand)
			{
				TryEnableWandGrip();
			}
			else
			{
				DisableWandGrip();
			}
		}

		protected override void TrackIndexTrigger()
		{
			if (OVRInput.GetUp(m_indexTrigger, OVRInput.Controller.Touch))
			{
				m_isHoldingIndexTrigger = false;
				ClearAnimationTrigger("HandActivate");
				SetAnimationBool("HandIndexFinger", value: false);
			}
			if (OVRInput.GetDown(m_indexTrigger, OVRInput.Controller.Touch))
			{
				m_holdWeight = 0f;
				if (m_isHoldingWand)
				{
					SetAnimationTrigger("HandActivate");
					return;
				}
				SetAnimationBool("HandIndexFinger", value: true);
			}
			if (m_isHoldingWand && OVRInput.Get(m_indexTrigger, OVRInput.Controller.Touch))
			{
				if (m_holdWeight < 0.15f)
				{
					m_holdWeight += Time.deltaTime;
				}
				else if (m_isHoldingIndexTrigger != !m_playerControl.Input.IsDragEnabled)
				{
					m_isHoldingIndexTrigger = !m_playerControl.Input.IsDragEnabled;
					SetAnimationBool("HandIndexFinger", m_isHoldingIndexTrigger);
				}
			}
		}

		protected override void TrackHandTrigger()
		{
			if (OVRInput.Get(m_handTrigger, OVRInput.Controller.Touch))
			{
				if (!m_isHoldingHandTrigger)
				{
					m_isHoldingHandTrigger = true;
					SetAnimationBool("HandLongFinger", value: true);
				}
			}
			else if (m_isHoldingHandTrigger)
			{
				m_isHoldingHandTrigger = false;
				SetAnimationBool("HandLongFinger", value: false);
			}
		}
	}
	public class PicoHandAnimator : HandAnimator
	{
		private Pvr_KeyCode m_indexTrigger = Pvr_KeyCode.TRIGGER;

		private Pvr_KeyCode m_handTrigger = Pvr_KeyCode.Right;

		private int Hand = 1;

		public override void ChangePrimaryHand(AimInput aimInput, bool isDualWielding)
		{
			base.ChangePrimaryHand(aimInput, isDualWielding);
			switch (m_hand)
			{
			case AimInput.LeftHand:
				Hand = 0;
				m_handTrigger = Pvr_KeyCode.Left;
				break;
			case AimInput.RightHand:
				Hand = 1;
				m_handTrigger = Pvr_KeyCode.Right;
				break;
			}
			if (m_isHoldingWand)
			{
				TryEnableWandGrip();
			}
			else
			{
				DisableWandGrip();
			}
		}

		protected override void TrackIndexTrigger()
		{
			if (Controller.UPvr_GetKeyUp(Hand, m_indexTrigger))
			{
				m_isHoldingIndexTrigger = false;
				ClearAnimationTrigger("HandActivate");
				SetAnimationBool("HandIndexFinger", value: false);
			}
			if (Controller.UPvr_GetKeyDown(Hand, m_indexTrigger))
			{
				m_holdWeight = 0f;
				if (m_isHoldingWand)
				{
					SetAnimationTrigger("HandActivate");
					return;
				}
				SetAnimationBool("HandIndexFinger", value: true);
			}
			if (m_isHoldingWand && Controller.UPvr_GetKey(Hand, m_indexTrigger))
			{
				if (m_holdWeight < 0.15f)
				{
					m_holdWeight += Time.deltaTime;
				}
				else if (m_isHoldingIndexTrigger != !m_playerControl.Input.IsDragEnabled)
				{
					m_isHoldingIndexTrigger = !m_playerControl.Input.IsDragEnabled;
					SetAnimationBool("HandIndexFinger", m_isHoldingIndexTrigger);
				}
			}
		}

		protected override void TrackHandTrigger()
		{
			if (Controller.UPvr_GetKey(Hand, m_handTrigger))
			{
				if (!m_isHoldingHandTrigger)
				{
					m_isHoldingHandTrigger = true;
					SetAnimationBool("HandLongFinger", value: true);
				}
			}
			else if (m_isHoldingHandTrigger)
			{
				m_isHoldingHandTrigger = false;
				SetAnimationBool("HandLongFinger", value: false);
			}
		}
	}
	public class PlayStationHandAnimator : HandAnimator
	{
	}
}
public class RandomIdleSelector : StateMachineBehaviour
{
	[TextArea]
	public string Notes = "Needs to connect to a 1D blend tree. Blend should have the same idle as this clip on spot 0. IdleVariations is the amount of motion clips in the blend tree without the idle at 0. VariationChance is the probability of playing a variation. Min and Max Loops let you add some control on when variations can play";

	[Header("1D Blend tree Parameter")]
	public string BlendParameterName;

	[Header("Blend Motion Clips excluding spot 0")]
	public int IdleVariations;

	[Header("Probability to transition into Variation")]
	public float VariationChance;

	[Header("Loop Controls")]
	public int MinLoops;

	public int MaxLoops;

	private float _elapsedTime;

	private int _currentLoop;

	public override void OnStateEnter(Animator animator, AnimatorStateInfo animatorStateInfo, int layerIndex)
	{
		animator.SetFloat(BlendParameterName, 0f);
		_currentLoop = 0;
		_elapsedTime = 0f;
	}

	public override void OnStateUpdate(Animator animator, AnimatorStateInfo animatorStateInfo, int layerIndex)
	{
		if (_elapsedTime > animatorStateInfo.length)
		{
			_currentLoop++;
			if (_currentLoop < MinLoops)
			{
				animator.SetFloat(BlendParameterName, 0f);
			}
			else if (_currentLoop >= MaxLoops)
			{
				animator.SetFloat(BlendParameterName, _getRandomVariation());
			}
			else
			{
				animator.SetFloat(BlendParameterName, _selectRandomIdle());
			}
			_elapsedTime = 0f;
		}
		_elapsedTime += Time.deltaTime;
	}

	private float _selectRandomIdle()
	{
		float num = UnityEngine.Random.Range(0f, 1f);
		if (num < VariationChance)
		{
			return _getRandomVariation();
		}
		return 0f;
	}

	private int _getRandomVariation()
	{
		return UnityEngine.Random.Range(1, IdleVariations + 1);
	}
}
namespace Assets.Scripts.Animation
{
	public class SanctumGateAnimationListener : MonoBehaviour
	{
		[SerializeField]
		private DoorHandler m_doorHandler;

		public void PlaySoundEffect(GateSoundClipType clipType)
		{
			m_doorHandler.PlaySoundEffect(clipType);
		}
	}
	public class ViveHandAnimator : HandAnimator
	{
		[SerializeField]
		private float m_wandGripOpenVrAngle = 25f;

		[SerializeField]
		private float m_pistolGripOpenVrAngle = -40f;

		private SteamVR_Action_Boolean m_indexTrigger;

		private SteamVR_Action_Boolean m_handTrigger;

		public override void ChangePrimaryHand(AimInput aimInput, bool isDualWielding)
		{
			base.ChangePrimaryHand(aimInput, isDualWielding);
			switch (m_hand)
			{
			case AimInput.LeftHand:
				m_indexTrigger = SteamVR_Actions.Wands.IndexLeft;
				m_handTrigger = SteamVR_Actions.Wands.GrabLeft;
				break;
			case AimInput.RightHand:
				m_indexTrigger = SteamVR_Actions.Wands.IndexRight;
				m_handTrigger = SteamVR_Actions.Wands.GrabRight;
				break;
			}
			if (m_isHoldingWand)
			{
				TryEnableWandGrip();
			}
			else
			{
				DisableWandGrip();
			}
		}

		public override void ChangeWandGrip(WandGrip wandGrip)
		{
			if (m_isHoldingWand)
			{
				base.transform.localRotation = Quaternion.Euler(0f, (wandGrip != 0) ? m_pistolGripOpenVrAngle : m_wandGripOpenVrAngle, 0f);
				m_animator.SetBool("DefaultGrip", wandGrip == GameControl.Instance.Platform.DefaultWandGrip);
			}
			else
			{
				base.transform.localRotation = Quaternion.identity;
			}
		}

		protected override void TrackIndexTrigger()
		{
			if (m_indexTrigger == null)
			{
				return;
			}
			if (m_indexTrigger.stateUp)
			{
				m_isHoldingIndexTrigger = false;
				ClearAnimationTrigger("HandActivate");
				SetAnimationBool("HandIndexFinger", value: false);
			}
			if (m_indexTrigger.stateDown)
			{
				m_holdWeight = 0f;
				if (m_isHoldingWand)
				{
					SetAnimationTrigger("HandActivate");
					return;
				}
				SetAnimationBool("HandIndexFinger", value: true);
			}
			if (m_isHoldingWand && m_indexTrigger.state)
			{
				if (m_holdWeight < 0.15f)
				{
					m_holdWeight += Time.deltaTime;
				}
				else if (m_isHoldingIndexTrigger != !m_playerControl.Input.IsDragEnabled)
				{
					m_isHoldingIndexTrigger = !m_playerControl.Input.IsDragEnabled;
					SetAnimationBool("HandIndexFinger", m_isHoldingIndexTrigger);
				}
			}
		}

		protected override void TrackHandTrigger()
		{
			if (m_handTrigger == null)
			{
				return;
			}
			if (m_handTrigger.state)
			{
				if (!m_isHoldingHandTrigger)
				{
					m_isHoldingHandTrigger = true;
					SetAnimationBool("HandLongFinger", value: true);
				}
			}
			else if (m_isHoldingHandTrigger)
			{
				m_isHoldingHandTrigger = false;
				SetAnimationBool("HandLongFinger", value: false);
			}
		}
	}
}
public class Bezier
{
	public static Vector3 GetPoint(Vector3 p0, Vector3 p1, Vector3 p2, float t)
	{
		t = Mathf.Clamp01(t);
		float num = 1f - t;
		return num * num * p0 + 2f * num * t * p1 + t * t * p2;
	}

	public static Vector3 GetFirstDerivative(Vector3 p0, Vector3 p1, Vector3 p2, float t)
	{
		return 2f * (1f - t) * (p1 - p0) + 2f * t * (p2 - p1);
	}

	public static Vector3 GetVelocity(Vector3 p0, Vector3 p1, Vector3 p2, Vector3 currentPos, float t)
	{
		return GetPoint(p0, p1, p2, t) - currentPos;
	}

	public static Vector3 GetDirection(Vector3 p0, Vector3 p1, Vector3 p2, Vector3 currentPos, float t)
	{
		return GetVelocity(p0, p1, p2, currentPos, t).normalized;
	}

	public static float GetSimpleBezierLength(Vector3 p0, Vector3 p1, Vector3 p2)
	{
		return Vector3.Distance(p0, p1) + Vector3.Distance(p1, p2);
	}
}
public class BezierCurve : MonoBehaviour
{
	public Vector3[] m_points;

	public void SetPoints(Vector3[] points)
	{
		if (points.Length != 3)
		{
			WandsLogger.LogError("Expecting Vector3 array with the size of 3");
		}
		else
		{
			m_points = points;
		}
	}

	public void Reset()
	{
		m_points = new Vector3[3]
		{
			new Vector3(1f, 0f, 0f),
			new Vector3(2f, 0f, 0f),
			new Vector3(3f, 0f, 0f)
		};
	}

	public Vector3 GetCleanPoint(float t)
	{
		return Bezier.GetPoint(m_points[0], m_points[1], m_points[2], t);
	}

	public Vector3 GetPoint(float t)
	{
		return base.transform.TransformPoint(Bezier.GetPoint(m_points[0], m_points[1], m_points[2], t));
	}

	public float GetLength()
	{
		return Bezier.GetSimpleBezierLength(m_points[0], m_points[1], m_points[2]);
	}

	public float GetLength(Vector3 currentPos, float t)
	{
		return Vector3.Distance(currentPos, GetPoint(t));
	}

	public Vector3 GetVelocity(float t)
	{
		return base.transform.TransformPoint(Bezier.GetFirstDerivative(m_points[0], m_points[1], m_points[2], t)) - base.transform.position;
	}

	public Vector3 GetDirection(float t)
	{
		return GetVelocity(t).normalized;
	}
}
public abstract class BezierFollower : MonoBehaviourPun
{
	public const float StepLength = 0.1f;

	protected readonly Vector3[] m_moveVectors = new Vector3[3];

	protected Vector3[] m_originalMoveVectors;

	public float BezierLength { get; private set; }

	protected Vector3 P0 => m_moveVectors[0];

	protected Vector3 P1 => m_moveVectors[1];

	protected Vector3 P2 => m_moveVectors[2];

	public Vector3[] Points => m_moveVectors;

	public void SetBezierPointsAndLength(params Vector3[] moveVectors)
	{
		if (moveVectors.Length == 2)
		{
			SetBezierPointsAndLength(moveVectors[0], MathUtils.GetMidPoint(moveVectors[0], moveVectors[1]), moveVectors[1]);
		}
		else if (moveVectors.Length < 2)
		{
			WandsLogger.Log("At least two Vectors are needed to calculate bezier curve!", LogType.Error);
		}
		else
		{
			SetBezierPointsAndLength(moveVectors[0], moveVectors[1], moveVectors[2]);
		}
	}

	private void SetBezierPointsAndLength(Vector3 p0, Vector3 p1, Vector3 p2)
	{
		if (m_originalMoveVectors.IsNullOrEmpty())
		{
			m_originalMoveVectors = new Vector3[3] { p0, p1, p2 };
		}
		m_moveVectors[0] = p0;
		m_moveVectors[1] = p1;
		m_moveVectors[2] = p2;
		BezierLength = Bezier.GetSimpleBezierLength(p0, p1, p2);
	}

	public void ResetBezierCurve(Vector3 forward)
	{
		Vector3 vector = base.transform.position + forward * BezierLength;
		SetBezierPointsAndLength(base.transform.position, MathUtils.GetMidPoint(base.transform.position, vector), vector);
	}

	public Vector3 GetPoint(float t)
	{
		return Bezier.GetPoint(P0, P1, P2, t);
	}

	public float GetLength(Vector3 currentPos, float t)
	{
		return Vector3.Distance(currentPos, GetPoint(t));
	}

	public Vector3 GetVelocity(Vector3 currentPos, float t)
	{
		return Bezier.GetPoint(P0, P1, P2, t) - currentPos;
	}

	public Vector3 GetDirection(Vector3 currentPos, float t)
	{
		return GetVelocity(currentPos, t).normalized;
	}
}
public class CacheAnimator : MonoBehaviour
{
	private Transform idlePos;

	private Transform openPos;

	private Transform cachePos;

	private Animator anim;

	private ParticleSystem cacheFx;

	public string season;

	public bool activated;

	private void Start()
	{
		idlePos = base.transform.Find("idlePosition").transform;
		openPos = base.transform.Find("openPosition").transform;
		cachePos = base.transform.Find("cachePosition").transform;
		idlePos.rotation = Quaternion.Euler(UnityEngine.Random.Range(-180, 180), UnityEngine.Random.Range(-180, 180), UnityEngine.Random.Range(-180, 180));
		if (season == "default")
		{
			anim = base.transform.Find("cachePosition").transform.Find("defaultcache").gameObject.GetComponent<Animator>();
			cacheFx = base.transform.Find("cachePosition").transform.Find("cacheFx").transform.Find("defaultcache").gameObject.GetComponent<ParticleSystem>();
		}
	}

	private void Update()
	{
		idlePos.Rotate(20f * Time.deltaTime, 20f * Time.deltaTime, 20f * Time.deltaTime);
		if (!activated)
		{
			cachePos.rotation = Quaternion.Slerp(cachePos.rotation, idlePos.rotation, 1f * Time.deltaTime);
		}
		else
		{
			cachePos.rotation = Quaternion.Slerp(cachePos.rotation, openPos.rotation, 2f * Time.deltaTime);
		}
	}

	private void OnMouseDown()
	{
		if (!activated)
		{
			anim.SetTrigger("open");
			activated = true;
			cacheFx.Play();
		}
	}
}
namespace Cortopia.Scripts.CortopiaAttributes
{
	public class MinSizeAttribute : CortopiaAttribute
	{
		public int Size { get; private set; }

		public MinSizeAttribute(int size)
		{
			Size = size;
		}
	}
}
namespace Assets.Scripts.CustomEvents
{
	public class CustomEvent
	{
		public Dictionary<CustomEventSpecialSettings, string> SpecialSettings;

		private CustomEventElo m_customEventElo;

		private Action<CustomEvent> m_claimCallback;

		private bool m_isAvailableForCurrentUser;

		public readonly Dictionary<Language, string> Name;

		public readonly Dictionary<Language, string> Description;

		public readonly int Id;

		public readonly DateTime StartDate;

		public readonly DateTime EndDate;

		public readonly bool IsRanked;

		public Action<CustomEvent, bool> OnIsEligibleForReward;

		public bool IsActive { get; private set; }

		public bool IsUpcoming { get; private set; }

		public bool IsAvailableForCurrentUser
		{
			[CompilerGenerated]
			get
			{
				return m_isAvailableForCurrentUser;
			}
		}

		public bool IsPlayerEligibleForReward { get; set; }

		public string RewardCode { get; set; }

		public string Url { get; set; }

		public bool RewardClaimed { get; set; }

		public List<CustomEventReward> Rewards { get; private set; }

		public List<Dictionary<Language, CustomEventReward>> RealRewards { get; private set; }

		public string RewardsString
		{
			get
			{
				string text = string.Empty;
				foreach (CustomEventReward reward in Rewards)
				{
					if (text != string.Empty)
					{
						text += ",";
					}
					string text2 = text;
					text = text2 + reward.Amount + ((!(reward.Name == "relicDust")) ? "x " : " ") + ScriptLocalization.Get(reward.TranslationPath);
				}
				foreach (Dictionary<Language, CustomEventReward> realReward in RealRewards)
				{
					CustomEventReward customEventReward = realReward[GameControl.Instance.GetCurrentLanguage()];
					if (text != string.Empty)
					{
						text += ",";
					}
					string text2 = text;
					text = text2 + customEventReward.Amount + "x " + customEventReward.Name;
				}
				return text;
			}
		}

		public CustomEvent(JToken name, int id, JToken description, DateTime startDate, DateTime endDate, bool ranked, string region, Dictionary<string, bool> devices, JToken specialSettings)
		{
			Name = new Dictionary<Language, string>
			{
				{
					Language.English,
					(string)name["En"]
				},
				{
					Language.Chinese,
					(string)name["Cn"]
				},
				{
					Language.Japanese,
					(string)name["Jp"]
				},
				{
					Language.French,
					(string)name["Fr"]
				},
				{
					Language.German,
					(string)name["De"]
				},
				{
					Language.Spanish,
					(string)name["Es"]
				},
				{
					Language.Korean,
					(string)name["Kr"]
				},
				{
					Language.Hindi,
					(string)name["In"]
				}
			};
			Id = id;
			Description = new Dictionary<Language, string>
			{
				{
					Language.English,
					(string)description["En"]
				},
				{
					Language.Chinese,
					(string)description["Cn"]
				},
				{
					Language.Japanese,
					(string)description["Jp"]
				},
				{
					Language.French,
					(string)description["Fr"]
				},
				{
					Language.German,
					(string)description["De"]
				},
				{
					Language.Spanish,
					(string)description["Es"]
				},
				{
					Language.Korean,
					(string)description["Kr"]
				},
				{
					Language.Hindi,
					(string)description["In"]
				}
			};
			StartDate = startDate;
			EndDate = endDate;
			IsRanked = ranked;
			CheckAvailabilityForCurrentUser(region, devices);
			RecalculateActiveStatus();
			SpecialSettings = new Dictionary<CustomEventSpecialSettings, string> { 
			{
				CustomEventSpecialSettings.XpMultiplier,
				(specialSettings["xpMul"].Type != JTokenType.Integer) ? ((string)specialSettings["xpMul"]) : ((int)specialSettings["xpMul"]).ToString()
			} };
			Rewards = new List<CustomEventReward>(2);
			RealRewards = new List<Dictionary<Language, CustomEventReward>>(2);
			if (!IsActive && !IsUpcoming && m_isAvailableForCurrentUser)
			{
				CustomEventRewardControl.FetchIsEligibleForReward(this, OnIsEligibleForRewardFetched);
			}
		}

		private void OnRewardsClaimed(bool claimed)
		{
			RewardClaimed = claimed;
			if (!claimed)
			{
				if (m_claimCallback != null)
				{
					m_claimCallback(this);
				}
				return;
			}
			Assets.Scripts.Player.Player player = GameControl.Instance.Player;
			List<WandType> list = new List<WandType>(4);
			List<CharacterType> list2 = new List<CharacterType>(4);
			int num = 0;
			foreach (CustomEventReward reward in Rewards)
			{
				if (reward.Name.ToLower() == "relicdust")
				{
					num += reward.Amount;
				}
				else if (reward.IsWand)
				{
					list.Add(reward.WandType);
				}
				else if (reward.IsCharacter)
				{
					list2.Add(reward.CharacterType);
				}
			}
			if (!list.IsEmpty())
			{
				player.TryAddWandsToInventory(list, saveToServer: true);
			}
			if (!list2.IsEmpty())
			{
				player.TryAddCharactersToInventory(list2, saveToServer: true);
			}
			if (num > 0)
			{
				player.AddVirtualCurrency(num, VirtualCurrencySource.CustomEventReward, saveToServer: true);
			}
			if (m_claimCallback != null)
			{
				m_claimCallback(this);
			}
		}

		public void RecalculateActiveStatus()
		{
			IsActive = StartDate < DateTime.UtcNow && EndDate > DateTime.UtcNow;
			IsUpcoming = StartDate > DateTime.UtcNow;
		}

		public void ClaimReward(Action<CustomEvent> callback)
		{
			CustomEventRewardControl.ClaimReward(this, OnRewardsClaimed);
			m_claimCallback = callback;
		}

		private void OnIsEligibleForRewardFetched(bool result)
		{
			if (result)
			{
				CustomEventRewardControl.FetchRewards(this);
			}
			if (OnIsEligibleForReward != null)
			{
				OnIsEligibleForReward(this, result);
			}
		}

		private void CheckAvailabilityForCurrentUser(string region, Dictionary<string, bool> devices)
		{
			if (string.Compare(region, "All", ignoreCase: true) != 0)
			{
				if (GameControl.Instance.Platform.Type != PlatformType.Pico)
				{
					return;
				}
				if (GameControl.Instance.PlatformSettings.IsChinaBuild)
				{
					if (string.Compare(region, "China", ignoreCase: true) != 0)
					{
						return;
					}
				}
				else if (string.Compare(region, "Other", ignoreCase: true) != 0)
				{
					return;
				}
				m_isAvailableForCurrentUser = true;
				return;
			}
			PlatformType type = GameControl.Instance.Platform.Type;
			string empty = string.Empty;
			switch (type)
			{
			case PlatformType.GearVr:
			case PlatformType.Go:
			case PlatformType.Pico:
			case PlatformType.MiVr:
			case PlatformType.Quest:
			case PlatformType.PlayStation:
				empty = GameControl.Instance.Platform.Type.ToString().ToLower();
				break;
			case PlatformType.Rift:
				empty = "rifto";
				break;
			case PlatformType.Steam:
				empty = ((!IsUsingRiftOnOpenVR()) ? "vives" : "rifts");
				break;
			case PlatformType.Viveport:
				empty = ((!IsUsingRiftOnOpenVR()) ? "vivev" : "riftv");
				break;
			default:
				m_isAvailableForCurrentUser = true;
				return;
			}
			if (devices.TryGetValue(empty, out m_isAvailableForCurrentUser) && m_isAvailableForCurrentUser)
			{
			}
		}

		private bool IsUsingRiftOnOpenVR()
		{
			ControlType controlType = (GameControl.Instance.Platform as OpenVRPlatform).ControlType;
			return controlType == ControlType.RiftTouchLeft || controlType == ControlType.RiftTouchRight;
		}
	}
	public class CustomEventControl : MonoBehaviour
	{
		private enum Tab
		{
			Global,
			CurrentEvents,
			PastEvents,
			PlayStation
		}

		private const float MinimumMinutesBetweenFetches = 5f;

		private const int MaxDaysAlive = 5;

		[SerializeField]
		private GameObject m_childGameObject;

		[SerializeField]
		private CustomEventTab m_globalTab;

		[SerializeField]
		private ButtonTextColorPulser m_currentEventsTab;

		[SerializeField]
		private ButtonTextColorPulser m_pastEventsTab;

		[SerializeField]
		private GameObject m_rewardMarkerPastEventsTab;

		[SerializeField]
		private CustomEventTab m_playstationTab;

		[SerializeField]
		private GameObject m_season;

		[SerializeField]
		private GameObject m_currentEventsGroup;

		[SerializeField]
		private GameObject m_pastEventsGroup;

		[SerializeField]
		private CustomEventInfo m_eventInfo;

		[SerializeField]
		private GameObject m_playStationLeaderboard;

		[SerializeField]
		private CustomEventName[] m_activeEventComponents = Array.Empty<CustomEventName>();

		[SerializeField]
		private CustomEventName[] m_upcomingEventComponents = Array.Empty<CustomEventName>();

		[SerializeField]
		private CustomEventName[] m_pastEventComponents = Array.Empty<CustomEventName>();

		[SerializeField]
		private GameObject m_internetMissingMessage;

		[SerializeField]
		private GameObject m_rewardMarkerLeaderboardTab;

		[SerializeField]
		private WorkshopTile m_blackboardTile;

		private Tab m_tab;

		private CustomEventTab m_defaultTab;

		private DateTime m_lastActiveUpcomingFetch;

		private DateTime m_lastPastFetch;

		private List<CustomEvent> m_activeAndUpcomingCustomEvents;

		private List<CustomEvent> m_sortedPastEvents = new List<CustomEvent>(7);

		private EventToken m_rewardClaimedEventToken;

		private bool IsActive
		{
			[CompilerGenerated]
			get
			{
				return m_childGameObject.activeSelf;
			}
		}

		private void OnEnable()
		{
			m_rewardClaimedEventToken = EventHub.Subscribe<Events.EventRewardClaimedEvent>(OnRewardClaimed);
			m_blackboardTile.OnInteract += CheckSortedEventsForClaims;
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe(m_rewardClaimedEventToken);
			m_blackboardTile.OnInteract -= CheckSortedEventsForClaims;
		}

		private void Awake()
		{
			StopPastEventsPulse();
			m_defaultTab = ((GameControl.Instance.Platform.Type != PlatformType.PlayStation) ? m_globalTab : m_playstationTab);
			m_defaultTab.Interact();
			ResetFetchTimers();
			FetchIfAllowed(ref m_lastActiveUpcomingFetch, CustomEventFetcher.Instance.FetchActiveAndUpcomingEvents, OnActiveAndUpcomingEventsFetched);
			FetchIfAllowed(ref m_lastPastFetch, CustomEventFetcher.Instance.FetchPastEvents, OnPastEventsFetched);
		}

		public void ActivateLeaderboards()
		{
			m_defaultTab.Interact();
			TryRestartPastEventsPulse();
			FetchIfAllowed(ref m_lastActiveUpcomingFetch, CustomEventFetcher.Instance.FetchActiveAndUpcomingEvents, OnActiveAndUpcomingEventsFetched);
			FetchIfAllowed(ref m_lastPastFetch, CustomEventFetcher.Instance.FetchPastEvents, OnPastEventsFetched);
		}

		public void DeactivateLeaderboards()
		{
			m_tab = Tab.Global;
			CheckSortedEventsForClaims();
		}

		public void ResetFetchTimers()
		{
			m_lastActiveUpcomingFetch = DateTime.Now.Subtract(TimeSpan.FromMinutes(6.0));
			m_lastPastFetch = DateTime.Now.Subtract(TimeSpan.FromMinutes(6.0));
		}

		public void ShowGlobalLeaderboard()
		{
			m_tab = Tab.Global;
			if (!TryDisplayInternetMissingMessage())
			{
				m_season.SetActive(value: true);
				m_currentEventsGroup.SetActive(value: false);
				m_pastEventsGroup.SetActive(value: false);
				m_eventInfo.SetActive(active: false);
				m_playStationLeaderboard.SetActive(value: false);
			}
		}

		public void ShowCurrentEvents()
		{
			m_tab = Tab.CurrentEvents;
			if (TryDisplayInternetMissingMessage())
			{
				return;
			}
			m_season.SetActive(value: false);
			m_currentEventsGroup.SetActive(value: true);
			m_pastEventsGroup.SetActive(value: false);
			m_eventInfo.SetActive(active: false);
			m_playStationLeaderboard.SetActive(value: false);
			if (m_activeAndUpcomingCustomEvents.IsNullOrEmpty())
			{
				return;
			}
			foreach (CustomEvent activeAndUpcomingCustomEvent in m_activeAndUpcomingCustomEvents)
			{
				WandsSave.SetPlayerPref("e" + activeAndUpcomingCustomEvent.Id, value: true);
			}
		}

		public void ShowPastEvents()
		{
			m_tab = Tab.PastEvents;
			if (!TryDisplayInternetMissingMessage())
			{
				m_season.SetActive(value: false);
				m_currentEventsGroup.SetActive(value: false);
				m_pastEventsGroup.SetActive(value: true);
				m_eventInfo.SetActive(active: false);
				m_playStationLeaderboard.SetActive(value: false);
			}
		}

		public void ShowPlayStationLeaderboard()
		{
			m_tab = Tab.PlayStation;
			if (!TryDisplayInternetMissingMessage())
			{
				m_season.SetActive(value: false);
				m_currentEventsGroup.SetActive(value: false);
				m_pastEventsGroup.SetActive(value: false);
				m_eventInfo.SetActive(active: false);
				m_playStationLeaderboard.SetActive(value: true);
			}
		}

		public void ShowEventInfo(CustomEventName customEventName)
		{
			if (!TryDisplayInternetMissingMessage())
			{
				m_season.SetActive(value: false);
				m_currentEventsGroup.SetActive(value: false);
				m_pastEventsGroup.SetActive(value: false);
				m_eventInfo.SetActive(active: true);
				m_eventInfo.SetCustomEventInfo(customEventName.CustomEvent);
			}
		}

		public void ClaimRewards()
		{
			m_eventInfo.CustomEvent.ClaimReward(OnRewardsClaimed);
			ResetFetchTimers();
			Interactable.LockAllLook = true;
			Interactable.LockAllInteraction = true;
		}

		private bool TryDisplayInternetMissingMessage()
		{
			if (UnityEngine.Application.internetReachability != 0)
			{
				m_internetMissingMessage.SetActive(value: false);
				return false;
			}
			m_season.SetActive(value: false);
			m_currentEventsGroup.SetActive(value: false);
			m_pastEventsGroup.SetActive(value: false);
			m_eventInfo.SetActive(active: false);
			m_internetMissingMessage.SetActive(value: true);
			return true;
		}

		private bool FetchIfAllowed(ref DateTime lastFetch, Action<Action<List<CustomEvent>>> fetchMethod, Action<List<CustomEvent>> callback)
		{
			if ((DateTime.Now - lastFetch).TotalMinutes >= 5.0)
			{
				fetchMethod(callback);
				lastFetch = DateTime.Now;
				return true;
			}
			return false;
		}

		private void OnRewardsClaimed(CustomEvent customEvent)
		{
			Interactable.LockAllLook = false;
			Interactable.LockAllInteraction = false;
			m_eventInfo.SetCustomEventInfo(customEvent);
			Events.EventRewardClaimedEvent eventRewardClaimedEvent = new Events.EventRewardClaimedEvent();
			eventRewardClaimedEvent.CustomEvent = customEvent;
			EventHub.Publish(eventRewardClaimedEvent);
		}

		private void AssignCustomEvent(List<CustomEvent> events, CustomEventName[] eventObjects)
		{
			int count = events.Count;
			for (int i = 0; i < eventObjects.Length; i++)
			{
				if (i >= count)
				{
					eventObjects[i].gameObject.SetActive(value: false);
					continue;
				}
				CustomEventName customEventName = eventObjects[i];
				customEventName.SetCustomEvent(events[i]);
				customEventName.gameObject.SetActive(value: true);
			}
		}

		private List<CustomEvent>[] SplitActiveAndUpcoming(List<CustomEvent> customEvents)
		{
			List<CustomEvent> list = new List<CustomEvent>(customEvents.Count);
			List<CustomEvent> list2 = new List<CustomEvent>(customEvents.Count);
			foreach (CustomEvent customEvent in customEvents)
			{
				if (customEvent.IsActive)
				{
					list.Add(customEvent);
				}
				else if (customEvent.IsUpcoming)
				{
					list2.Add(customEvent);
				}
			}
			return new List<CustomEvent>[2] { list, list2 };
		}

		private void OnPastEventsFetched(List<CustomEvent> customEvents)
		{
			foreach (CustomEvent sortedPastEvent in m_sortedPastEvents)
			{
				sortedPastEvent.OnIsEligibleForReward = (Action<CustomEvent, bool>)Delegate.Remove(sortedPastEvent.OnIsEligibleForReward, new Action<CustomEvent, bool>(OnIsEligibleForReward));
			}
			m_sortedPastEvents.Clear();
			foreach (CustomEvent customEvent in customEvents)
			{
				if (customEvent.IsPlayerEligibleForReward && !customEvent.RewardClaimed)
				{
					m_sortedPastEvents.Add(customEvent);
					TryStartPastEventsPulse();
				}
				else if (DateTime.Today.Date.Subtract(customEvent.EndDate.Date).TotalDays <= 5.0)
				{
					m_sortedPastEvents.Add(customEvent);
				}
				else
				{
					customEvent.OnIsEligibleForReward = (Action<CustomEvent, bool>)Delegate.Combine(customEvent.OnIsEligibleForReward, new Action<CustomEvent, bool>(OnIsEligibleForReward));
				}
			}
			SortPastEventsAndAssignToUI();
			if (m_tab == Tab.PastEvents)
			{
				m_pastEventsGroup.SetActive(value: true);
			}
		}

		private void OnIsEligibleForReward(CustomEvent customEvent, bool result)
		{
			if (result && !customEvent.RewardClaimed)
			{
				m_sortedPastEvents.Add(customEvent);
				TryStartPastEventsPulse();
				SortPastEventsAndAssignToUI();
			}
		}

		private void SortPastEventsAndAssignToUI()
		{
			m_sortedPastEvents = m_sortedPastEvents.OrderByDescending((CustomEvent x) => x.EndDate.Day).ToList();
			AssignCustomEvent(m_sortedPastEvents, m_pastEventComponents);
		}

		private void StopPastEventsPulse()
		{
			m_rewardMarkerLeaderboardTab.SetActive(value: false);
			m_rewardMarkerPastEventsTab.SetActive(value: false);
			m_pastEventsTab.StopPulse();
		}

		private void TryRestartPastEventsPulse()
		{
			StopPastEventsPulse();
			CheckSortedEventsForClaims();
		}

		private void CheckSortedEventsForClaims()
		{
			for (int i = 0; i < m_sortedPastEvents.Count; i++)
			{
				CustomEvent customEvent = m_sortedPastEvents[i];
				if (customEvent.IsPlayerEligibleForReward && !customEvent.RewardClaimed)
				{
					TryStartPastEventsPulse();
					break;
				}
			}
		}

		private void TryStartPastEventsPulse()
		{
			if (IsActive)
			{
				TryStartTabsPulse();
			}
			else if (m_tab != Tab.PastEvents)
			{
				TryStartMainPulse();
			}
		}

		private void TryStartMainPulse()
		{
			if (!m_rewardMarkerLeaderboardTab.activeSelf)
			{
				m_rewardMarkerLeaderboardTab.SetActive(value: true);
			}
		}

		private void TryStartTabsPulse()
		{
			if (!m_pastEventsTab.IsPulsing)
			{
				m_pastEventsTab.StartPulse();
				m_rewardMarkerPastEventsTab.SetActive(value: true);
			}
		}

		private void OnActiveAndUpcomingEventsFetched(List<CustomEvent> events)
		{
			List<CustomEvent>[] array = SplitActiveAndUpcoming(events);
			AssignCustomEvent(array[0], m_activeEventComponents);
			AssignCustomEvent(array[1], m_upcomingEventComponents);
			m_activeAndUpcomingCustomEvents = events;
			if (m_tab == Tab.CurrentEvents)
			{
				m_currentEventsGroup.SetActive(value: true);
				return;
			}
			foreach (CustomEvent @event in events)
			{
				if (!WandsSave.GetBoolPref("e" + @event.Id))
				{
					m_currentEventsTab.StartPulse();
					break;
				}
			}
		}

		private void OnRewardClaimed(Events.EventRewardClaimedEvent eventData)
		{
			TryRestartPastEventsPulse();
		}
	}
	[Serializable]
	public class LeaderboardData
	{
		public int[] Ranks;

		public string[] Names;

		public int[] Ratings;

		public int Placement;
	}
	[Serializable]
	public class ResultData
	{
		public bool Result;

		public int Error;
	}
	[Serializable]
	public class CustomEventData
	{
		public JToken Name;

		public int Id;

		public JToken Description;

		public string StartDate;

		public string EndDate;

		public string Ranked;

		public string Regions;

		public Dictionary<string, bool> Devices;

		public JToken Special;
	}
	public class CustomEventElo
	{
		private int m_elo;

		private int m_eventId;

		private bool m_canUpdateElo;

		private Coroutine m_fetchEloFromServerCoroutine;

		private Coroutine m_changeEloOnServerCoroutine;

		public CustomEventElo(int eventId)
		{
			m_eventId = eventId;
		}

		public void FetchElo(Action<CustomEventElo, bool> callback)
		{
			if (GameControl.Instance.Player == null || GameControl.Instance.Player.LogInObject == null)
			{
				WandsLogger.LogError("Could not fetch elo for event " + m_eventId + ", Player is probably not logged in.", LogColor.CustomEvent);
				callback?.Invoke(this, arg2: false);
				return;
			}
			if (m_fetchEloFromServerCoroutine != null)
			{
				CustomEventEloControl.Instance.StopCoroutine(m_fetchEloFromServerCoroutine);
				m_fetchEloFromServerCoroutine = null;
			}
			m_fetchEloFromServerCoroutine = CustomEventEloControl.Instance.StartCoroutine(FetchEloFromServer(callback));
		}

		public void ChangeElo(int eloChange, Action<CustomEventElo, bool> callback)
		{
			if (GameControl.Instance.Player == null || GameControl.Instance.Player.LogInObject == null)
			{
				WandsLogger.LogError("Could not change elo for event " + m_eventId + ", Player is probably not logged in.", LogColor.CustomEvent);
				callback?.Invoke(this, arg2: false);
				return;
			}
			if (m_changeEloOnServerCoroutine != null)
			{
				CustomEventEloControl.Instance.StopCoroutine(m_changeEloOnServerCoroutine);
				m_changeEloOnServerCoroutine = null;
			}
			m_changeEloOnServerCoroutine = CustomEventEloControl.Instance.StartCoroutine(ChangeEloOnServer(eloChange, callback));
		}

		private void OnEloFetchedFromServer(JObject jsonObject, object[] parameters)
		{
			m_elo = (int)jsonObject["rating"];
			m_canUpdateElo = true;
			(parameters[0] as Action<CustomEventElo, bool>)?.Invoke(this, arg2: true);
		}

		private void OnEloFetchFailed(string message, object[] parameters)
		{
			(parameters[0] as Action<CustomEventElo, bool>)?.Invoke(this, arg2: false);
			throw new UnityException("CustomEventElo | OnEloFetchFailed: " + message);
		}

		private IEnumerator FetchEloFromServer(Action<CustomEventElo, bool> callback)
		{
			string url = "https://api.wandsgame.com/v1/events/get-rating.php";
			string[] fieldNames = new string[5] { "username", "password", "id", "userId", "userName" };
			string[] fieldValues = new string[5]
			{
				"user",
				"618d2b1c6c62d635b6bf06f2d0637da7f5d9d2e542c16af874732a61ac363ac7",
				m_eventId.ToString(),
				GameControl.Instance.Player.LogInObject.UserId,
				GameControl.Instance.Player.LogInObject.UserName
			};
			yield return CustomEventFetcher.Instance.FetchJsonObjectFromServer(url, fieldNames, fieldValues, '{', OnEloFetchedFromServer, OnEloFetchFailed, callback);
		}

		private void OnChangeEloOnServerSuccess(object data, object[] parameters)
		{
			ResultData resultData = JsonConvert.DeserializeObject<ResultData>(data.ToString());
			if (resultData.Result)
			{
				(parameters[0] as Action<CustomEventElo, bool>)?.Invoke(this, arg2: true);
			}
			else
			{
				OnChangeEloFailed(resultData.Error.ToString(), parameters);
			}
		}

		private void OnChangeEloFailed(string message, object[] parameters)
		{
			(parameters[0] as Action<CustomEventElo, bool>)?.Invoke(this, arg2: false);
			switch (message)
			{
			case "1000":
				WandsLogger.LogError("CustomEventElo | Tried to change elo on event that was not active", LogColor.CustomEvent);
				break;
			case "1001":
				WandsLogger.LogError("CustomEventElo | Could not SELECT from database", LogColor.CustomEvent);
				break;
			default:
				WandsLogger.LogError("CustomEventElo | Unexpected error: " + message, LogColor.CustomEvent);
				break;
			}
		}

		private IEnumerator ChangeEloOnServer(int eloChange, Action<CustomEventElo, bool> callback)
		{
			if (!m_canUpdateElo)
			{
				float timeOutTimer = 0f;
				while (!m_canUpdateElo)
				{
					timeOutTimer += Time.deltaTime;
					if (timeOutTimer >= 5f)
					{
						callback?.Invoke(this, arg2: false);
						throw new UnityException("CustomEventElo | Could not change elo: canUpdateElo flag not set, make sure FetchElo is called before ChangeElo");
					}
					yield return null;
				}
			}
			m_elo += eloChange;
			string url = "https://api.wandsgame.com/v1/events/update-rating.php";
			string[] fieldNames = new string[5] { "username", "password", "id", "userId", "rating" };
			string[] fieldValues = new string[5]
			{
				"user",
				"618d2b1c6c62d635b6bf06f2d0637da7f5d9d2e542c16af874732a61ac363ac7",
				m_eventId.ToString(),
				GameControl.Instance.Player.LogInObject.UserId,
				m_elo.ToString()
			};
			yield return CustomEventFetcher.Instance.FetchUnserializedJsonDataFromServer(url, fieldNames, fieldValues, '{', OnChangeEloOnServerSuccess, OnChangeEloFailed, callback);
		}
	}
	public class CustomEventEloControl : MonoBehaviour
	{
		private static CustomEventEloControl sm_instance;

		private const int PointsPerWin = 1;

		private Dictionary<int, CustomEventElo> m_customEventElos;

		private EventToken m_eloChangedEventToken;

		public static CustomEventEloControl Instance
		{
			get
			{
				if (sm_instance == null)
				{
					WandsLogger.LogError("CustomEventEloControl is null. Ignore if CustomEvents is not enabled", LogColor.CustomEvent);
				}
				return sm_instance;
			}
		}

		private void Awake()
		{
			if (sm_instance == null)
			{
				sm_instance = this;
				m_customEventElos = new Dictionary<int, CustomEventElo>();
			}
		}

		private void OnEnable()
		{
			if (sm_instance == this)
			{
				m_eloChangedEventToken = EventHub.Subscribe<Events.EloChangedEvent>(OnEloChanged);
			}
		}

		private void OnDisable()
		{
			if (sm_instance == this)
			{
				EventHub.Unsubscribe<Events.EloChangedEvent>(m_eloChangedEventToken);
			}
		}

		private void OnEloChanged(Events.EloChangedEvent eventData)
		{
			if (EloUtils.ShouldAffectCustomEventRating && eventData.EndState == EndState.Won)
			{
				EloChanged();
			}
		}

		private void EloChanged()
		{
			foreach (CustomEventElo value in m_customEventElos.Values)
			{
				value.ChangeElo(1, null);
			}
		}

		public bool HasCustomEventElo(int eventId)
		{
			return m_customEventElos.ContainsKey(eventId);
		}

		public CustomEventElo CreateCustomEventElo(int eventId)
		{
			CustomEventElo customEventElo = new CustomEventElo(eventId);
			m_customEventElos.Add(eventId, customEventElo);
			customEventElo.FetchElo(null);
			return customEventElo;
		}

		public CustomEventElo GetCustomEventElo(int eventId)
		{
			return m_customEventElos[eventId];
		}

		public bool RemoveCustomEventElo(int eventId)
		{
			return m_customEventElos.Remove(eventId);
		}

		public CustomEventElo[] GetAllCustomEventElos()
		{
			CustomEventElo[] array = new CustomEventElo[m_customEventElos.Count];
			int num = 0;
			foreach (CustomEventElo value in m_customEventElos.Values)
			{
				array[num++] = value;
			}
			return array;
		}
	}
	public class CustomEventFetcher : MonoBehaviour
	{
		private const string UserPassword = "618d2b1c6c62d635b6bf06f2d0637da7f5d9d2e542c16af874732a61ac363ac7";

		private static readonly string[] sm_fieldNames = new string[2] { "username", "password" };

		private static readonly string[] sm_fieldValues = new string[2] { "user", "618d2b1c6c62d635b6bf06f2d0637da7f5d9d2e542c16af874732a61ac363ac7" };

		private bool m_isUserNameSet;

		private EventToken m_sceneLoadedEventToken;

		private static CustomEventFetcher sm_instance;

		public static CustomEventFetcher Instance
		{
			get
			{
				if (sm_instance == null)
				{
					WandsLogger.LogError("CustomEventFetcher is null. Ignore this if not using CustomEvents");
				}
				return sm_instance;
			}
		}

		public int ExperienceMultiplier { get; private set; }

		private void Awake()
		{
			if (sm_instance == null)
			{
				sm_instance = this;
			}
			else
			{
				UnityEngine.Object.Destroy(this);
			}
		}

		private void OnEnable()
		{
			if (sm_instance == this)
			{
				m_sceneLoadedEventToken = EventHub.Subscribe<Events.SceneLoadedEvent>(OnSceneLoaded);
			}
		}

		private void OnDestroy()
		{
			StopAllCoroutines();
			if (sm_instance == this)
			{
				EventHub.Unsubscribe<Events.SceneLoadedEvent>(m_sceneLoadedEventToken);
			}
		}

		private void OnSceneLoaded(Events.SceneLoadedEvent eventData)
		{
			if (eventData.Level.ContainsFlag(Level.Workshop | Level.Lobby))
			{
				FetchActiveEvents();
				TrySetUserName();
			}
		}

		private void TrySetUserName()
		{
			if (!m_isUserNameSet && GameControl.Instance.Player != null && GameControl.Instance.Player.IsLoggedInToPlatform)
			{
				string path = "https://api.wandsgame.com/v1/events/set-user-name.php";
				string[] fieldNames = new string[4] { "username", "password", "userId", "userName" };
				string[] fieldValues = new string[4]
				{
					"user",
					"618d2b1c6c62d635b6bf06f2d0637da7f5d9d2e542c16af874732a61ac363ac7",
					GameControl.Instance.Player.LogInObject.UserId,
					GameControl.Instance.Player.LogInObject.UserName
				};
				StartCoroutine(FetchJsonObjectFromServer(path, fieldNames, fieldValues, '{', OnUserNameUpdated, OnUserNameUpdateFailed));
			}
		}

		private void OnUserNameUpdated(JObject jsonObject, object[] parameters)
		{
			m_isUserNameSet = (bool)jsonObject["result"];
			if (!m_isUserNameSet)
			{
				WandsLogger.LogError("Could not update username. message id: " + (int)jsonObject["message"], LogColor.CustomEvent);
			}
		}

		private void OnUserNameUpdateFailed(string error, object[] parameters)
		{
			m_isUserNameSet = false;
			WandsLogger.LogError("Could not update username. Message: " + error, LogColor.CustomEvent);
		}

		private void OnEventsFetched(JArray jsonArray, object[] parameters)
		{
			Action<List<CustomEvent>> action = ((parameters.Length <= 0) ? null : ((Action<List<CustomEvent>>)parameters[0]));
			List<CustomEvent> list = ExtractCustomEvents(jsonArray);
			ExperienceMultiplier = 1;
			for (int i = 0; i < list.Count; i++)
			{
				CustomEvent customEvent = list[i];
				if (customEvent == null)
				{
					continue;
				}
				if (customEvent.IsActive)
				{
					int num = int.Parse(customEvent.SpecialSettings[CustomEventSpecialSettings.XpMultiplier]);
					if (num > ExperienceMultiplier)
					{
						ExperienceMultiplier = num;
					}
					if (customEvent.IsRanked && customEvent.IsAvailableForCurrentUser && !CustomEventEloControl.Instance.HasCustomEventElo(customEvent.Id))
					{
						CustomEventEloControl.Instance.CreateCustomEventElo(customEvent.Id);
					}
				}
				else if (!customEvent.IsActive && !customEvent.IsUpcoming && CustomEventEloControl.Instance.HasCustomEventElo(customEvent.Id))
				{
					CustomEventEloControl.Instance.RemoveCustomEventElo(customEvent.Id);
				}
			}
			action?.Invoke(list);
		}

		public WWW CreateWWW(string path, string[] fieldNames, string[] fieldValues)
		{
			WWWForm wWWForm = new WWWForm();
			if (fieldNames != null && fieldValues != null)
			{
				for (int i = 0; i < fieldNames.Length; i++)
				{
					wWWForm.AddField(fieldNames[i], fieldValues[i]);
				}
			}
			return new WWW(path, wWWForm);
		}

		public IEnumerator FetchJsonArrayFromServer(string path, string[] fieldNames, string[] fieldValues, char expectedFirstCharacter, Action<JArray, object[]> OnFinished, Action<string, object[]> OnError, params object[] invokeParameters)
		{
			WWW www = CreateWWW(path, fieldNames, fieldValues);
			yield return www;
			string responseText = www.text;
			if (string.IsNullOrEmpty(responseText))
			{
				OnError?.Invoke("FetchJsonFromServer | Returned text is null or empty", invokeParameters);
				yield break;
			}
			string text = responseText;
			text = ((responseText[0] != expectedFirstCharacter) ? responseText.Substring(1) : responseText);
			if (text[0] != expectedFirstCharacter)
			{
				OnError?.Invoke($"FetchJsonFromServer | First character ('{responseText[0]}' or '{text[0]}') is not expected character ('{expectedFirstCharacter}')", invokeParameters);
				yield break;
			}
			object deserializedObj = null;
			Task.Run(delegate
			{
				deserializedObj = JsonConvert.DeserializeObject(text);
			}).ContinueWith(delegate(Task t)
			{
				if (t.IsFaulted)
				{
					OnError?.Invoke("FetchJsonFromServer Exception | " + t.Exception, invokeParameters);
				}
				else
				{
					OnFinished?.Invoke(new JArray(deserializedObj), invokeParameters);
				}
			}, TaskScheduler.FromCurrentSynchronizationContext());
		}

		public IEnumerator FetchJsonObjectFromServer(string path, string[] fieldNames, string[] fieldValues, char expectedFirstCharacter, Action<JObject, object[]> OnFinished, Action<string, object[]> OnError, params object[] invokeParameters)
		{
			WWW www = CreateWWW(path, fieldNames, fieldValues);
			yield return www;
			string responseText = www.text;
			if (string.IsNullOrEmpty(responseText))
			{
				OnError?.Invoke("FetchJsonFromServer | Returned text is null or empty", invokeParameters);
				yield break;
			}
			string text2 = responseText;
			text2 = ((responseText[0] != expectedFirstCharacter) ? responseText.Substring(1) : responseText);
			if (text2[0] != expectedFirstCharacter)
			{
				OnError?.Invoke($"FetchJsonFromServer | First character ('{responseText[0]}' or '{text2[0]}') is not expected character ('{expectedFirstCharacter}')", invokeParameters);
				yield break;
			}
			try
			{
				OnFinished?.Invoke(JObject.Parse(text2), invokeParameters);
			}
			catch (Exception ex)
			{
				OnError?.Invoke("FetchJsonFromServer Exception | " + ex, invokeParameters);
			}
		}

		public IEnumerator FetchUnserializedJsonDataFromServer(string path, string[] fieldNames, string[] fieldValues, char expectedFirstCharacter, Action<object, object[]> OnFinished, Action<string, object[]> OnError, params object[] invokeParameters)
		{
			WWW www = CreateWWW(path, fieldNames, fieldValues);
			yield return www;
			string responseText = www.text;
			if (string.IsNullOrEmpty(responseText))
			{
				OnError?.Invoke("FetchJsonFromServer | Returned text is null or empty", invokeParameters);
				yield break;
			}
			string text2 = responseText;
			text2 = ((responseText[0] != expectedFirstCharacter) ? responseText.Substring(1) : responseText);
			if (text2[0] != expectedFirstCharacter)
			{
				OnError?.Invoke($"FetchJsonFromServer | First character ('{responseText[0]}' or '{text2[0]}') is not expected character ('{expectedFirstCharacter}')", invokeParameters);
				yield break;
			}
			try
			{
				OnFinished?.Invoke(text2, invokeParameters);
			}
			catch (Exception ex)
			{
				OnError?.Invoke("FetchJsonFromServer Exception | " + ex, invokeParameters);
			}
		}

		private void OnEventsFetchFailed(string message, object[] parameters)
		{
			WandsLogger.LogError($"CustomEventFetcher | OnEventsFecthFailed: Event fetch failed with message \"{message}\". Internet connection is \"{UnityEngine.Application.internetReachability}\"");
		}

		private List<CustomEvent> ExtractCustomEvents(JArray jsonArray)
		{
			JToken[] array = jsonArray.Values().ToArray();
			List<CustomEvent> list = new List<CustomEvent>(array.Length);
			JToken[] array2 = array;
			foreach (JToken jToken in array2)
			{
				CustomEventData customEventData = jToken.ToObject<CustomEventData>();
				list.Add(new CustomEvent(customEventData.Name, customEventData.Id, customEventData.Description, Convert.ToDateTime(customEventData.StartDate), Convert.ToDateTime(customEventData.EndDate), customEventData.Ranked.Equals("1"), customEventData.Regions, customEventData.Devices, customEventData.Special));
			}
			return list;
		}

		public void FetchActiveAndUpcomingEvents(Action<List<CustomEvent>> onActiveUpcomingEventsFetched = null)
		{
			string path = "https://api.wandsgame.com/v1/events/get-active-and-upcoming-events.php";
			StartCoroutine(FetchJsonArrayFromServer(path, sm_fieldNames, sm_fieldValues, '[', OnEventsFetched, OnEventsFetchFailed, onActiveUpcomingEventsFetched));
		}

		public void FetchActiveEvents(Action<List<CustomEvent>> onActiveEventsFetched = null)
		{
			string path = "https://api.wandsgame.com/v1/events/get-active-events.php";
			StartCoroutine(FetchJsonArrayFromServer(path, sm_fieldNames, sm_fieldValues, '[', OnEventsFetched, OnEventsFetchFailed, onActiveEventsFetched));
		}

		public void FetchUpcomingEvents(Action<List<CustomEvent>> onUpcomingEventsFetched = null)
		{
			string path = "https://api.wandsgame.com/v1/events/get-upcoming-events.php";
			StartCoroutine(FetchJsonArrayFromServer(path, sm_fieldNames, sm_fieldValues, '[', OnEventsFetched, OnEventsFetchFailed, onUpcomingEventsFetched));
		}

		public void FetchPastEvents(Action<List<CustomEvent>> onPastEventsFetched = null)
		{
			string path = "https://api.wandsgame.com/v1/events/get-past-events.php";
			string[] fieldNames = new string[4] { "username", "password", "userId", "version" };
			string[] fieldValues = new string[4]
			{
				"user",
				"618d2b1c6c62d635b6bf06f2d0637da7f5d9d2e542c16af874732a61ac363ac7",
				GameControl.Instance.Player.LogInObject.UserId,
				"2"
			};
			StartCoroutine(FetchJsonArrayFromServer(path, fieldNames, fieldValues, '[', OnEventsFetched, OnEventsFetchFailed, onPastEventsFetched));
		}
	}
	public class CustomEventInfo : MonoBehaviour
	{
		private enum TextMeshType
		{
			Name,
			Description,
			TimeText,
			Timer
		}

		[Header("Ranked")]
		[SerializeField]
		private GameObject m_rankedGroup;

		[SerializeField]
		private TextMeshPro m_rankedEventName;

		[SerializeField]
		private TextMeshPro m_rankedEventDescription;

		[SerializeField]
		private TextMeshPro m_rankedEventTimeText;

		[SerializeField]
		private TextMeshPro m_rankedEventTimer;

		[SerializeField]
		private CustomEventLeaderboard m_rankedEventLeaderboard;

		[SerializeField]
		private TextMeshPro m_rewardText;

		[SerializeField]
		private TextMeshPro m_claimReward;

		[SerializeField]
		private TextMeshPro m_rewardClaimed;

		[Header("Unranked")]
		[SerializeField]
		private GameObject m_unrankedGroup;

		[SerializeField]
		private TextMeshPro m_unrankedEventName;

		[SerializeField]
		private TextMeshPro m_unrankedEventDescription;

		[SerializeField]
		private TextMeshPro m_unrankedEventTimeText;

		[SerializeField]
		private TextMeshPro m_unrankedEventTimer;

		public CustomEvent CustomEvent { get; private set; }

		private void OnDisable()
		{
			StopAllCoroutines();
		}

		public void SetActive(bool active)
		{
			base.gameObject.SetActive(active);
		}

		private TextMeshPro GetCorrectTextMesh(TextMeshType type)
		{
			bool flag = !CustomEvent.IsRanked || CustomEvent.IsUpcoming;
			return type switch
			{
				TextMeshType.Name => (!flag) ? m_rankedEventName : m_unrankedEventName, 
				TextMeshType.Description => (!flag) ? m_rankedEventDescription : m_unrankedEventDescription, 
				TextMeshType.TimeText => (!flag) ? m_rankedEventTimeText : m_unrankedEventTimeText, 
				TextMeshType.Timer => (!flag) ? m_rankedEventTimer : m_unrankedEventTimer, 
				_ => null, 
			};
		}

		private IEnumerator SetDateText()
		{
			WaitForSeconds wait = new WaitForSeconds(1f);
			TextMeshPro timer = GetCorrectTextMesh(TextMeshType.Timer);
			timer.gameObject.SetActive(value: true);
			while (true)
			{
				TimeSpan timeSpan = GetCorrectTimeSpan();
				if (timeSpan.TotalSeconds < 0.0)
				{
					break;
				}
				timer.text = GetDateText(timeSpan);
				yield return wait;
			}
			yield return new WaitForSeconds(0.5f);
			CustomEvent.RecalculateActiveStatus();
			SetCustomEventInfo(CustomEvent);
		}

		public void SetCustomEventInfo(CustomEvent customEvent)
		{
			bool flag = !customEvent.IsRanked || customEvent.IsUpcoming;
			CustomEvent = customEvent;
			m_rankedGroup.SetActive(!flag);
			if (!flag)
			{
				m_rankedEventLeaderboard.LoadLeaderboard(customEvent);
			}
			m_rewardText.gameObject.SetActive(value: false);
			m_claimReward.gameObject.SetActive(value: false);
			m_rewardClaimed.gameObject.SetActive(value: false);
			m_unrankedGroup.SetActive(flag);
			TextMeshPro correctTextMesh = GetCorrectTextMesh(TextMeshType.Name);
			correctTextMesh.text = customEvent.Name[GameControl.Instance.GetCurrentLanguage()];
			if (correctTextMesh.text == string.Empty)
			{
				correctTextMesh.text = customEvent.Name[Language.English];
			}
			TextMeshPro correctTextMesh2 = GetCorrectTextMesh(TextMeshType.Description);
			correctTextMesh2.text = customEvent.Description[GameControl.Instance.GetCurrentLanguage()];
			if (correctTextMesh2.text == string.Empty)
			{
				correctTextMesh2.text = customEvent.Description[Language.English];
			}
			StopCoroutine("SetDateText");
			if (customEvent.IsActive || customEvent.IsUpcoming)
			{
				TextMeshPro correctTextMesh3 = GetCorrectTextMesh(TextMeshType.TimeText);
				correctTextMesh3.gameObject.SetActive(value: true);
				correctTextMesh3.GetComponent<Localize>().SetTerm("Workshop/Blackboard/" + ((!customEvent.IsActive) ? "StartsIn" : "TimeRemaining"));
				StartCoroutine("SetDateText");
				return;
			}
			TextMeshPro correctTextMesh4 = GetCorrectTextMesh(TextMeshType.TimeText);
			TextMeshPro correctTextMesh5 = GetCorrectTextMesh(TextMeshType.Timer);
			correctTextMesh4.gameObject.SetActive(value: false);
			correctTextMesh5.gameObject.SetActive(value: false);
			if (customEvent.IsPlayerEligibleForReward)
			{
				m_rewardText.gameObject.SetActive(value: true);
				if (customEvent.RewardClaimed)
				{
					m_rewardClaimed.gameObject.SetActive(value: true);
				}
				else
				{
					m_claimReward.gameObject.SetActive(value: true);
				}
				m_rewardText.text = customEvent.RewardsString;
			}
		}

		private TimeSpan GetCorrectTimeSpan()
		{
			if (CustomEvent.IsActive)
			{
				return CustomEvent.EndDate - DateTime.UtcNow;
			}
			if (CustomEvent.IsUpcoming)
			{
				return CustomEvent.StartDate - DateTime.UtcNow;
			}
			return DateTime.UtcNow - CustomEvent.EndDate;
		}

		private string GetDateText(TimeSpan timeSpan)
		{
			string text = string.Empty;
			if (timeSpan.TotalDays >= 1.0)
			{
				text = $"{timeSpan.Days}D ";
			}
			if (timeSpan.TotalHours >= 1.0)
			{
				text += string.Format("{0}H ", timeSpan.Hours.ToString("00"));
			}
			if (timeSpan.TotalMinutes >= 1.0)
			{
				text += string.Format("{0}M ", timeSpan.Minutes.ToString("00"));
			}
			return text += string.Format("{0}S", timeSpan.Seconds.ToString("00"));
		}
	}
	public class CustomEventLeaderboard : MonoBehaviour
	{
		[SerializeField]
		private Transform m_namesParent;

		[SerializeField]
		private GameObject m_linesGameObject;

		[SerializeField]
		[HideInInspector]
		private TextMeshPro[] m_names = Array.Empty<TextMeshPro>();

		[SerializeField]
		[HideInInspector]
		private TextMeshPro[] m_points = Array.Empty<TextMeshPro>();

		public void LoadLeaderboard(CustomEvent customEvent)
		{
			for (int i = 0; i < m_namesParent.childCount; i++)
			{
				m_namesParent.GetChild(i).gameObject.SetActive(value: false);
			}
			m_linesGameObject.SetActive(value: false);
			FetchLeaderboard(customEvent.Id);
		}

		private void OnLeaderboardFetched(int[] userRanks, string[] userNames, int[] userRatings, int place)
		{
			for (int i = 0; i < userNames.Length; i++)
			{
				Transform child = m_namesParent.GetChild(i);
				child.gameObject.SetActive(value: true);
				int num = userNames[i].IndexOf('_') + 1;
				if (num >= userNames[i].Length)
				{
					num = 0;
				}
				int num2 = userRanks[i];
				if (num2 == place)
				{
					m_names[i].text = $"{num2}. {GameControl.Instance.Player.LogInObject.UserName}";
					m_linesGameObject.transform.localPosition = child.localPosition;
				}
				else
				{
					m_names[i].text = $"{num2}. {userNames[i].Substring(num)}";
				}
				m_points[i].text = $"{userRatings[i]}";
			}
			m_linesGameObject.SetActive(place != 0);
		}

		private void OnFetchLeaderboardSuccess(object data, object[] parameters)
		{
			try
			{
				LeaderboardData leaderboardData = JsonConvert.DeserializeObject<LeaderboardData>(data.ToString());
				OnLeaderboardFetched(leaderboardData.Ranks, leaderboardData.Names, leaderboardData.Ratings, leaderboardData.Placement);
			}
			catch (Exception ex)
			{
				OnFetchLeaderboardFailed(ex.ToString(), parameters);
			}
		}

		private void OnFetchLeaderboardFailed(string message, object[] parameters)
		{
			throw new UnityException($"CustomEventLeaderboard | OnFetchLeaderboardFailed: Could not fetch leaderboard. Message: \"{message}\".");
		}

		private void FetchLeaderboard(int eventId)
		{
			string path = "https://api.wandsgame.com/v1/events/get-leaderboard.php";
			string[] fieldNames = new string[4] { "username", "password", "id", "userId" };
			string[] fieldValues = new string[4]
			{
				"user",
				"618d2b1c6c62d635b6bf06f2d0637da7f5d9d2e542c16af874732a61ac363ac7",
				eventId.ToString(),
				GameControl.Instance.Player.LogInObject.UserId
			};
			StartCoroutine(CustomEventFetcher.Instance.FetchUnserializedJsonDataFromServer(path, fieldNames, fieldValues, '{', OnFetchLeaderboardSuccess, OnFetchLeaderboardFailed));
		}
	}
	public class CustomEventName : InteractableButton
	{
		[SerializeField]
		private TextMeshPro m_nameText;

		[SerializeField]
		private Localize m_timeLocalize;

		[SerializeField]
		private LocalizationParamsManager m_timeLocalizationParamsManager;

		private bool m_updateEventTime;

		public CustomEvent CustomEvent { get; private set; }

		private void OnEnable()
		{
			m_updateEventTime = CustomEvent != null && (CustomEvent.IsActive || CustomEvent.IsUpcoming);
		}

		private void Update()
		{
			if (m_updateEventTime)
			{
				UpdateTimeTextContiniuous();
			}
		}

		public void SetCustomEvent(CustomEvent customEvent)
		{
			CustomEvent = customEvent;
			UpdateEventName();
			if (customEvent.IsActive || customEvent.IsUpcoming)
			{
				m_updateEventTime = true;
				return;
			}
			TimeSpan correctTimeSpan = GetCorrectTimeSpan();
			if (correctTimeSpan.TotalDays < 2.0)
			{
				m_timeLocalize.SetTerm("Workshop/Blackboard/EndedSingle");
				m_timeLocalizationParamsManager.SetParameterValue("DAYS", (!(correctTimeSpan.TotalDays < 1.0)) ? "1" : "<1");
			}
			else
			{
				m_timeLocalize.SetTerm("Workshop/Blackboard/Ended");
				m_timeLocalizationParamsManager.SetParameterValue("DAYS", correctTimeSpan.Days.ToString());
			}
		}

		private void UpdateEventName()
		{
			string text = CustomEvent.Name[GameControl.Instance.GetCurrentLanguage()];
			if (string.IsNullOrEmpty(text))
			{
				text = CustomEvent.Name[Language.English];
			}
			m_nameText.text = text;
		}

		private void UpdateTimeTextContiniuous()
		{
			if (GetCorrectTimeSpan().TotalSeconds >= 1.0)
			{
				UpdateTimeText();
				return;
			}
			if (CustomEvent.IsActive || CustomEvent.IsUpcoming)
			{
				CustomEventControl componentInParent = base.gameObject.GetComponentInParent<CustomEventControl>();
				componentInParent.ResetFetchTimers();
				componentInParent.ShowCurrentEvents();
			}
			m_updateEventTime = false;
		}

		private TimeSpan GetCorrectTimeSpan()
		{
			if (CustomEvent.IsActive)
			{
				return CustomEvent.EndDate - DateTime.UtcNow;
			}
			if (CustomEvent.IsUpcoming)
			{
				return CustomEvent.StartDate - DateTime.UtcNow;
			}
			return DateTime.UtcNow - CustomEvent.EndDate;
		}

		private void UpdateTimeText()
		{
			TimeSpan correctTimeSpan = GetCorrectTimeSpan();
			string term = ((!CustomEvent.IsActive) ? "Workshop/Blackboard/StartsIn" : "Workshop/Blackboard/TimeRemaining");
			m_timeLocalize.SetTerm(term);
			string text = string.Empty;
			if (correctTimeSpan.TotalDays >= 1.0)
			{
				text = text + correctTimeSpan.Days + "D ";
			}
			if (correctTimeSpan.TotalHours >= 1.0)
			{
				text += ((correctTimeSpan.Hours < 10) ? $"0{correctTimeSpan.Hours}H " : $"{correctTimeSpan.Hours}H ");
			}
			if (correctTimeSpan.TotalMinutes >= 1.0)
			{
				text += ((correctTimeSpan.Minutes < 10) ? $"0{correctTimeSpan.Minutes}M " : $"{correctTimeSpan.Minutes}M ");
			}
			text += ((correctTimeSpan.Seconds < 10) ? $"0{correctTimeSpan.Seconds}S" : $"{correctTimeSpan.Seconds}S");
			m_timeLocalizationParamsManager.SetParameterValue("TIME", text);
		}
	}
	public class CustomEventReward
	{
		public readonly string Name;

		public readonly string TranslationPath;

		public readonly int Amount;

		public readonly WandType WandType;

		public readonly CharacterType CharacterType;

		public readonly bool IsCharacter;

		public readonly bool IsWand;

		public CustomEventReward(string name, int amount)
		{
			Name = name;
			Amount = amount;
		}

		public CustomEventReward(string name, int amount, string translationPath)
		{
			Name = name;
			TranslationPath = translationPath;
			Amount = amount;
		}

		public CustomEventReward(CharacterType characterType, int amount)
		{
			Name = characterType.ToString();
			CatalogItemWrapper character = WandsDatabase.GetCharacter(characterType);
			TranslationPath = character.DisplayName;
			Amount = amount;
			CharacterType = characterType;
			IsCharacter = true;
		}

		public CustomEventReward(WandType wandType, int amount)
		{
			Name = wandType.ToString();
			CatalogItemWrapper wand = WandsDatabase.GetWand(wandType);
			TranslationPath = wand.DisplayName ?? string.Empty;
			Amount = amount;
			WandType = wandType;
			IsWand = true;
		}
	}
	public static class CustomEventRewardControl
	{
		public static void ClaimReward(CustomEvent customEvent, Action<bool> callBack)
		{
			string path = "https://api.wandsgame.com/v1/events/collect-reward.php";
			string[] fieldNames = new string[4] { "username", "password", "userId", "eventId" };
			string[] fieldValues = new string[4]
			{
				"user",
				"618d2b1c6c62d635b6bf06f2d0637da7f5d9d2e542c16af874732a61ac363ac7",
				GameControl.Instance.Player.LogInObject.UserId,
				customEvent.Id.ToString()
			};
			CustomEventFetcher.Instance.StartCoroutine(CustomEventFetcher.Instance.FetchUnserializedJsonDataFromServer(path, fieldNames, fieldValues, '{', OnRewardClaimed, OnRewardClaimFailed, callBack));
		}

		public static void OnRewardClaimed(object data, object[] parameters)
		{
			Action<bool> action = parameters[0] as Action<bool>;
			ResultData resultData = JsonConvert.DeserializeObject<ResultData>(data.ToString());
			if (resultData.Result)
			{
				action?.Invoke(obj: true);
			}
			else
			{
				OnRewardClaimFailed(data.ToJson(), parameters);
			}
		}

		public static void OnRewardClaimFailed(string message, object[] parameters)
		{
			if (parameters[0] is Action<bool> action)
			{
				action(obj: false);
			}
			throw new UnityException("CustomEventRewardControl | OnRewardClaimFailed: Reward claim failed with message \"" + message + "\"");
		}

		public static void FetchIsEligibleForReward(CustomEvent customEvent, Action<bool> callBack)
		{
			string path = "https://api.wandsgame.com/v1/events/get-is-eligible-for-reward.php";
			string[] fieldNames = new string[4] { "username", "password", "userId", "eventId" };
			string[] fieldValues = new string[4]
			{
				"user",
				"618d2b1c6c62d635b6bf06f2d0637da7f5d9d2e542c16af874732a61ac363ac7",
				GameControl.Instance.Player.LogInObject.UserId,
				customEvent.Id.ToString()
			};
			CustomEventFetcher.Instance.StartCoroutine(CustomEventFetcher.Instance.FetchUnserializedJsonDataFromServer(path, fieldNames, fieldValues, '{', OnFetchIsEligibleForRewardSuccess, OnFetchIsEligibleForRewardFailed, customEvent, callBack));
		}

		private static void OnFetchIsEligibleForRewardSuccess(object data, object[] parameters)
		{
			CustomEvent customEvent = parameters[0] as CustomEvent;
			Action<bool> action = parameters[1] as Action<bool>;
			ResultData resultData = JsonConvert.DeserializeObject<ResultData>(data.ToString());
			customEvent.IsPlayerEligibleForReward = resultData.Result;
			if (resultData.Result)
			{
				action?.Invoke(obj: true);
				customEvent.RewardClaimed = false;
			}
			else if (resultData.Error == 1)
			{
				customEvent.RewardClaimed = true;
				customEvent.IsPlayerEligibleForReward = true;
				action?.Invoke(obj: true);
			}
			else
			{
				OnFetchIsEligibleForRewardFailed(string.Empty, new object[3]
				{
					parameters[0],
					parameters[1],
					JsonConvert.DeserializeObject(data.ToString())
				});
			}
		}

		private static void OnFetchIsEligibleForRewardFailed(string message, object[] parameters)
		{
			CustomEvent customEvent = parameters[0] as CustomEvent;
			Action<bool> action = parameters[1] as Action<bool>;
			customEvent.IsPlayerEligibleForReward = false;
			action?.Invoke(obj: false);
			string text = message;
			if (parameters.Length > 2)
			{
				JToken jToken = (parameters[2] as JObject)["error"];
				text = ((jToken.Type != JTokenType.Integer) ? ((string)jToken) : ((int)jToken).ToString());
				switch (text)
				{
				case "1":
					return;
				case "2":
					return;
				case "3":
					return;
				}
			}
			throw new UnityException("CustomEventRewardControl | FetchIsEligibleForRewardFailed: Fetch  Error code: " + text);
		}

		public static void FetchRewards(CustomEvent customEvent)
		{
			string path = "https://api.wandsgame.com/v1/events/get-rewards.php";
			string[] fieldNames = new string[4] { "username", "password", "userId", "eventId" };
			string[] fieldValues = new string[4]
			{
				"user",
				"618d2b1c6c62d635b6bf06f2d0637da7f5d9d2e542c16af874732a61ac363ac7",
				GameControl.Instance.Player.LogInObject.UserId,
				customEvent.Id.ToString()
			};
			CustomEventFetcher.Instance.StartCoroutine(CustomEventFetcher.Instance.FetchJsonArrayFromServer(path, fieldNames, fieldValues, '[', OnFetchRewardsSuccess, OnFetchRewardsFailed, customEvent));
		}

		public static void OnFetchRewardsSuccess(JArray jsonData, object[] parameters)
		{
			if (jsonData.ToJson().Length <= 2)
			{
				return;
			}
			CustomEvent customEvent = (CustomEvent)parameters[0];
			foreach (JToken item2 in jsonData.Values())
			{
				string text = (string)item2["item"];
				int amount = (int)item2["amount"];
				CharacterType result;
				WandType result2;
				if (text == "realItem")
				{
					Dictionary<Language, CustomEventReward> dictionary = new Dictionary<Language, CustomEventReward>();
					dictionary.Add(Language.English, new CustomEventReward((item2["itemNameEn"] == null) ? string.Empty : ((string)item2["itemNameEn"]), amount));
					dictionary.Add(Language.Chinese, new CustomEventReward((item2["itemNameCn"] == null) ? string.Empty : ((string)item2["itemNameCn"]), amount));
					dictionary.Add(Language.Japanese, new CustomEventReward((item2["itemNameJp"] == null) ? string.Empty : ((string)item2["itemNameJp"]), amount));
					dictionary.Add(Language.French, new CustomEventReward((item2["itemNameFr"] == null) ? string.Empty : ((string)item2["itemNameFr"]), amount));
					dictionary.Add(Language.German, new CustomEventReward((item2["itemNameDe"] == null) ? string.Empty : ((string)item2["itemNameDe"]), amount));
					dictionary.Add(Language.Spanish, new CustomEventReward((item2["itemNameEs"] == null) ? string.Empty : ((string)item2["itemNameEs"]), amount));
					dictionary.Add(Language.Korean, new CustomEventReward((item2["itemNameKr"] == null) ? string.Empty : ((string)item2["itemNameKr"]), amount));
					dictionary.Add(Language.Hindi, new CustomEventReward((item2["itemNameIn"] == null) ? string.Empty : ((string)item2["itemNameIn"]), amount));
					Dictionary<Language, CustomEventReward> item = dictionary;
					customEvent.RealRewards.Add(item);
				}
				else if (text.ToLower() == "relicdust")
				{
					customEvent.Rewards.Add(new CustomEventReward(text, amount, "Workshop/Projector/RelicDust"));
				}
				else if (Enum.TryParse<CharacterType>(text, out result))
				{
					customEvent.Rewards.Add(new CustomEventReward(result, amount));
				}
				else if (Enum.TryParse<WandType>(text, out result2))
				{
					customEvent.Rewards.Add(new CustomEventReward(result2, amount));
				}
				else
				{
					WandsLogger.LogError("Couldn't parse event reward.", LogColor.CustomEvent);
				}
			}
		}

		public static void OnFetchRewardsFailed(string message, object[] parameters)
		{
			throw new UnityException($"CustomEventRewardControl | OnFetchRewardsFailed: Fetching rewards failed with message \"{message}\"");
		}
	}
	public class CustomEventTab : InteractableButton
	{
		private static CustomEventTab sm_selectedTab;

		[SerializeField]
		private TextMeshPro m_text;

		[SerializeField]
		private Color m_defaultColor = Color.white;

		[SerializeField]
		private Color m_hoverColor = Color.white;

		[SerializeField]
		private Color m_selectedColor = Color.white;

		[SerializeField]
		private ButtonTextColorPulser m_buttonTextColorFader;

		[SerializeField]
		private GameObject m_chalkLine;

		[SerializeField]
		private GameObject m_chalkEffect;

		private void Start()
		{
			m_chalkLine.SetActive(value: false);
			m_chalkEffect.SetActive(value: false);
		}

		public override void LookEnter()
		{
			if (!base.LookLocked)
			{
				m_buttonTextColorFader.PausePulse();
				m_text.color = m_hoverColor;
				m_chalkEffect.SetActive(value: true);
				base.LookEnter();
				PunSingleton<SoundManager>.Instance.PlayLocalSoundAtPoint("chalk_hover", 1f, base.transform.position, 1);
			}
		}

		public override void LookExit()
		{
			if (!base.LookLocked)
			{
				if (m_buttonTextColorFader.IsPaused)
				{
					m_buttonTextColorFader.StartPulse();
				}
				else if (sm_selectedTab != this)
				{
					m_text.color = m_defaultColor;
				}
				m_chalkEffect.SetActive(value: false);
				base.LookExit();
			}
		}

		public override void Interact()
		{
			m_buttonTextColorFader.StopPulse(m_selectedColor);
			m_chalkLine.SetActive(value: true);
			m_chalkEffect.SetActive(value: false);
			if (sm_selectedTab != this)
			{
				if (sm_selectedTab != null)
				{
					sm_selectedTab.Unselect();
				}
				sm_selectedTab = this;
			}
			base.Interact();
			EnableInteractions();
			PunSingleton<SoundManager>.Instance?.PlayLocalSoundAtPoint("chalk_press", 1f, base.transform.position, 1);
		}

		public void Unselect()
		{
			LockLook(locked: false);
			m_chalkLine.SetActive(value: false);
			m_text.color = m_defaultColor;
		}
	}
	public class CustomEventTextColorer : WandsButtonHighlighter
	{
		[SerializeField]
		private TextMeshPro m_eventName;

		[SerializeField]
		private TextMeshPro m_eventTime;

		[SerializeField]
		private Color m_defaultColor = Color.white;

		[SerializeField]
		private Color m_hoverColor = Color.black;

		public override void LookEnter()
		{
			m_eventName.color = m_hoverColor;
			m_eventTime.color = m_hoverColor;
		}

		public override void LookExit()
		{
			m_eventName.color = m_defaultColor;
			m_eventTime.color = m_defaultColor;
		}
	}
}
namespace Assets.Scripts.InteractObjects
{
	[Serializable]
	public class DustContainerPrefabs
	{
		public GameObject Standard;
	}
	[Serializable]
	public class OutfitPrefabs
	{
		public GameObject Blau;

		public GameObject Weyman;

		public GameObject Inquisitor;

		public GameObject Fennec;

		public GameObject Knot;

		public GameObject Takeo;
	}
	[Serializable]
	public class RendererMaterialPair
	{
		private Renderer m_renderer;

		private Material m_material;

		public RendererMaterialPair(Renderer renderer, Material material)
		{
			m_material = GameControl.Instance.AssetHandler.ReplaceMaterial(material);
			m_renderer = renderer;
			m_renderer.sharedMaterial = m_material;
		}

		public void SetMaterialHighlighted(bool highlighted)
		{
			if (!m_renderer.sharedMaterial.HasProperty("_Highlighted"))
			{
				WandsLogger.LogError($"Trying to highlight object <{m_renderer.name}> but material lacks highlighted property");
			}
			else
			{
				m_renderer.sharedMaterial.SetFloat("_Highlighted", (!highlighted) ? 0f : 1f);
			}
		}
	}
	[Serializable]
	public class WandPrefabs
	{
		public GameObject Classic;

		public GameObject Inductor;

		public GameObject Sword;

		public GameObject Lion;

		public GameObject Remnant;

		public GameObject Scepter;
	}
}
namespace Assets.Scripts.Enums
{
	public enum AchievementType
	{
		Unknown = -1,
		[Obsolete]
		Craftsman,
		[Obsolete]
		Duelist,
		[Obsolete]
		Wands,
		[Obsolete]
		Winner,
		[Obsolete]
		Addict,
		[Obsolete]
		TrainingForDummies,
		TutorialComplete,
		WinFirstDuel,
		WinAllArenas,
		ChangeRelicLoadout,
		ChangeTitle,
		Deal200Damage,
		Win25Duels,
		Unlock20Relics,
		Purchase7Wands,
		Purchase9Characters,
		ReachLevel100
	}
	public enum ActivatedSubtitlesReasonType
	{
		Blackboard,
		PreTutorial
	}
	public enum AimInput
	{
		Head = 1,
		Remote = 2,
		LeftHand = 4,
		RightHand = 8,
		Hand = 12
	}
	public enum AnimationType
	{
		SelectStart = 1,
		SelectIdle = 2,
		SelectWand = 4,
		WalkForward = 8,
		WalkRight = 16,
		HitSmallForward = 32,
		HitSmallBack = 64,
		HitSmallRight = 128,
		HitSmallLeft = 256,
		CastSmall = 512,
		CastMedium = 1024,
		CastLarge = 2048,
		CastArea = 4096,
		CastShield = 8192,
		CastCharge = 16384,
		Dead = 32768,
		OnDummy = 33255,
		OnGhost = -33256
	}
	public enum AreaOfEffectBehaviour
	{
		OneShot,
		Timed,
		Mine
	}
	public enum Arena
	{
		None = 0,
		AspisPrison = 1,
		TempleOfOphidian = 2,
		TheCelestialHalls = 4,
		OrtusStation = 8,
		DeadMastersVale = 16,
		Marrakech = 32,
		Market = 64,
		SanctumOfSahir = 128,
		TheCelestialHalls_AIBot = 256,
		FountainOfTheFallen = 512,
		EasternRealms = 24
	}
	public enum AssetBundleType
	{
		Default,
		Vanity,
		Spells,
		Platform,
		UI,
		CombinedUI,
		VFX,
		CombinedCharacter
	}
	public enum AttackAnimationType
	{
		Light,
		Heavy,
		TileEffect,
		Channeling
	}
	public enum BlackboardState
	{
		News,
		Tutorial,
		Leaderboards,
		Profile,
		Options,
		Credits,
		Titles
	}
	public enum BtnOptionsTypes
	{
		Sfx,
		Aim,
		PlayerVoIP,
		OpponentVoIP,
		Hand,
		Language,
		PositionalTrackingOpponent,
		Grip,
		ControlSchemeWandInput,
		ResetTutorial,
		Subtitle,
		ControlSchemeDualWield
	}
	public enum ButtonState
	{
		Equip,
		Equipped,
		Unlock,
		Locked
	}
	public enum ChannelAnimationType
	{
		Default,
		Fast
	}
	public enum CharacterEquipSource
	{
		Drag,
		Equip,
		Teleport
	}
	public enum CharacterMaterialType
	{
		Default,
		Rim,
		Highlight
	}
	public enum CharacterMirrorState
	{
		Buy,
		Buying,
		Equip,
		Equipped,
		Special
	}
	public enum CharacterType
	{
		Scavenger,
		Collector,
		Widow,
		Raven,
		Inquisitor,
		Templar,
		Vindicator,
		General,
		Vanguard,
		Assassin,
		Komuso,
		Nemesis
	}
	public static class EnumHelper
	{
		public static readonly string[] CharacterTypeNames = new string[12]
		{
			"Scavenger", "Collector", "Widow", "Raven", "Inquisitor", "Templar", "Vindicator", "General", "Vanguard", "Assassin",
			"Komuso", "Nemesis"
		};

		private static string[] sm_tagTypeStrings = new string[10] { "Unknown", "Player", "Dummy", "Lava", "Environment", "Shield", "Projectile", "Destructable", "KillPlane", "Train" };

		public static bool TryParse(string name, out TagType type)
		{
			int num = Array.IndexOf(sm_tagTypeStrings, name);
			type = ((num > 0) ? ((TagType)num) : TagType.Unknown);
			return type != TagType.Unknown;
		}
	}
	public enum ConnectionType
	{
		Release = 1,
		Develop = 2,
		Beta = 4,
		Trailer = 8,
		CIN = 0x10
	}
	public enum ControlType
	{
		GearVr = 1,
		GearVrRemote = 2,
		GoRemote = 4,
		MiVrRemote = 8,
		Daydream = 131072,
		Pico = 16,
		Gamepad = 32,
		RiftTouchRight = 64,
		RiftTouchLeft = 128,
		ViveController = 256,
		Unsupported = 512,
		QuestRight = 1024,
		QuestLeft = 2048,
		PlayStationMotion = 4096,
		PlayStationDualShock = 8192,
		ViveKnuckles = 16384,
		ViveCosmos = 32768,
		WindowsMixedReality = 65536,
		PicoNeo2 = 262144,
		DualWieldButtons = 314560,
		DualWieldTouchpad = 65792,
		DualWield = 380352
	}
	public enum CostType
	{
		Mana,
		Health
	}
	public enum CountdownType
	{
		Warmup,
		MatchStart,
		Default
	}
	public enum CrystalState
	{
		Neutral,
		Healing,
		Damaging
	}
	public enum CustomEventSpecialSettings
	{
		XpMultiplier
	}
	public enum DamageType
	{
		Once,
		OnceContinuous,
		Continuous
	}
	public enum DesertTempleEnvironmentType
	{
		Sandstorm,
		Gas
	}
	public enum DesertTempleStage
	{
		BuildUpSandstorm,
		StartSandstorm,
		OpenOutsideDoors,
		CloseOutsideDoors,
		BuildUpGas,
		OpenInnerDoors,
		StartGas,
		CloseInnerDoors
	}
	public enum DummyType
	{
		Local,
		Twin,
		Projection
	}
	public enum EffectType
	{
		OrtusPickup,
		CelestialPortal,
		AcidCamEffect,
		AstralCamEffect,
		AstralProjectionEffect,
		ChillingClutchLingeringEffect,
		SandstormEffect,
		GasEffect,
		Count
	}
	public enum EInputMethod
	{
		MouseKeyboard,
		Gamepad,
		GearVrTouchpad,
		GearVrOrientation,
		Daydream,
		RiftController,
		Pico
	}
	public enum EmitterState
	{
		Play,
		Pause,
		Stop
	}
	public enum EndState
	{
		Draw = 1,
		Won = 2,
		Lost = 4,
		ConnectionLostClient = 8,
		ConnectionLostServer = 16,
		Close = 32,
		ForceLost = 64,
		FoundMatch = 128,
		MatchEnd = 199,
		Disconnected = 24
	}
	public enum EnemyAttackType
	{
		Straight,
		Arching
	}
	public enum EnemyMovementType
	{
		Moving,
		Stationary
	}
	public enum EnemyType
	{
		None,
		Trash,
		Arcer,
		Hulk
	}
	public enum GameAccess
	{
		Free,
		Full
	}
	public enum GateSoundClipType
	{
		LightSmall,
		LightLarge,
		ScarabSeal
	}
	public enum HandMaterialType
	{
		Default,
		Astral
	}
	public enum VibrationForce
	{
		Light,
		Medium,
		Hard
	}
	public enum VibrateController
	{
		Primary,
		Secondary,
		Both,
		GamePad
	}
	public enum VibrationType
	{
		None,
		Continuous,
		Timed,
		TimedIncreasing
	}
	public enum HitSfxType
	{
		Default,
		Shield,
		Lava,
		Player
	}
	public enum IconState
	{
		Selected,
		Deselected,
		Channeling,
		Disabled
	}
	public enum InfoType
	{
		InteractWand,
		InteractRelics,
		InteractUnsupported,
		LoadoutLocked,
		LoadoutUnlocked,
		LoadoutIncomplete,
		SpellToken,
		SpellInfo,
		Empty
	}
}
namespace Assets.Scripts.WandsInput
{
	public enum InputButtons
	{
		ActionMain,
		ActionSecond,
		Home,
		Back
	}
}
namespace Assets.Scripts.Enums
{
	[Flags]
	public enum InputState
	{
		None = 0,
		Down = 1,
		Up = 2,
		Hold = 4,
		AxisRight = 8,
		AxisLeft = 0x10,
		AxisUp = 0x20,
		AxisDown = 0x40,
		Axis = 0x78
	}
	public enum ItemMaterialType
	{
		Default,
		Locked
	}
	public enum ItemRarity
	{
		Common,
		Rare,
		Epic
	}
	public enum ItemType
	{
		Wand = 1,
		Character
	}
	public enum JoinState
	{
		Ranked = 0,
		[Obsolete("Deprecated in favor of HostFriendly.")]
		HostPublic = 1,
		HostFriendly = 1,
		[Obsolete("Invite only is not used anymore.")]
		HostInviteOnly = 2,
		Join = 3,
		Exploration = 4,
		Bot = 5,
		None = 6
	}
	public enum Language
	{
		English,
		Chinese,
		Japanese,
		French,
		German,
		Spanish,
		Korean,
		Hindi
	}
	public enum Legacy_CharacterType
	{
		Weyman,
		Blau,
		Inquisitor,
		Fennec,
		Knot,
		Takeo
	}
	public enum Legacy_LootCacheType
	{
		Default,
		Special
	}
	public enum Legacy_MaskType
	{
		Termite_1,
		Termite_2,
		Termite_3,
		Termite_4,
		Termite_5,
		Termite_6,
		Descendant_1,
		Descendant_2,
		Descendant_3,
		Descendant_4,
		Descendant_5,
		Tranquil_1,
		Tranquil_2,
		Tranquil_3,
		Tranquil_4,
		Tranquil_5,
		Guard_1,
		Guard_2,
		Guard_3,
		Guard_4,
		Guard_5,
		Frenzied_1,
		Frenzied_2,
		Frenzied_3,
		Frenzied_4,
		Frenzied_5,
		Plague_1,
		Plague_2,
		Plague_3,
		Plague_4,
		Plague_5,
		Plague_6,
		Chameleon_1,
		Chameleon_2,
		Chameleon_3,
		Chameleon_4,
		Chameleon_5,
		Skull_1,
		Skull_2,
		Skull_3,
		Skull_4,
		Skull_5,
		Vitis_1,
		Vitis_2,
		Vitis_3
	}
	public enum Legacy_OutfitType
	{
		Weyman_1,
		Weyman_2,
		Blau_1,
		Blau_2,
		Inquisitor_1,
		Inquisitor_2,
		Fennec_1,
		Fennec_2,
		Knot_1,
		Knot_2,
		Takeo_1,
		Takeo_2
	}
	public enum Legacy_WandType
	{
		Classic,
		Sword,
		Inductor,
		Lion,
		Remnant,
		Scepter,
		SnakeGold,
		SnakeSilver,
		SnakeJade,
		Invicta,
		None
	}
	[Flags]
	public enum Level
	{
		Unknown = 0,
		MainMenu = 1,
		Workshop = 2,
		Basement = 4,
		Lobby = 8,
		AspisPrison = 0x10,
		TempleOfOphidian = 0x20,
		TheCelestialHalls = 0x40,
		OrtusStation = 0x80,
		DeadMastersVale = 0x100,
		Marrakech = 0x200,
		Market = 0x400,
		SanctumOfSahir = 0x800,
		TheCelestialHalls_AIBot = 0x1000,
		FountainOfTheFallen = 0x2000,
		UnpausableLevel = 7,
		InteractableLevel = 0xF,
		Arena = 0x39F4
	}
	public enum LobbyLeaveReason
	{
		Quit = 1,
		MatchFound = 2,
		Left = 4
	}
	public enum LobbyState
	{
		Pre,
		Post
	}
	public enum LogColor
	{
		Default,
		System,
		Loading,
		Login,
		PlayFab,
		Bundles,
		Debug,
		PlayerData,
		Tutorial,
		Database,
		ObjectPooling,
		PlayerPrefs,
		Conversion,
		CustomEvent,
		Photon,
		Inventory,
		PlayFabFieldParsing,
		VoIP,
		Events,
		Matchmaking,
		Achievements,
		Audio,
		WandProperty
	}
	public enum MaskMeshType
	{
		Termite,
		Descendant,
		Tranquil,
		Guard,
		Frenzied,
		Plague,
		Chameleon,
		Skull,
		Vitis
	}
	public enum MatchEndReasonType
	{
		Elimination = 1,
		Time = 2,
		OpponentLeft = 4,
		ExcessivePause = 8,
		OpponentDisconnect = 0x10,
		FoundMatch = 0x20
	}
	public enum MatchRewardType
	{
		Win,
		Loss,
		Draw,
		FirstMatchOfTheDay,
		FirstWinOfTheDay,
		FlawlessVictory,
		WinWithoutPickups,
		FirstBlood,
		HighestDamage,
		Stop
	}
	public enum MatchStartedReasonType
	{
		Exploration = 1,
		NormalMatch = 2,
		Rematch = 4,
		Bot = 8
	}
	[Flags]
	public enum MatchType
	{
		Competitive = 1,
		[Obsolete("Deprecated in favor of Friendly.")]
		Public = 2,
		Friendly = 2,
		[Obsolete("Invite only is not used anymore.")]
		InviteOnly = 4,
		Exhibition = 8,
		Exploration = 0x10,
		Tutorial = 0x20,
		Bot = 0x40,
		None = 0x80,
		Matchmade = 9,
		Casual = 0x42,
		SoloExperience = 0xB0,
		SinglePlayer = 0xF0,
		MultiPlayer = -241
	}
	public enum MirusMenuType
	{
		Start,
		DuelFriend,
		StartDuel,
		[Obsolete("Invite only is not used anymore, this menu no longer exists")]
		HostFriend,
		LevelSelect,
		ExplorationLevelSelect,
		MatchSelect,
		OfflinePlay,
		Close,
		Exploration,
		Basement,
		FreeVersion,
		FreeVersionInformation,
		ThankYou
	}
	public enum MusicType
	{
		Default,
		LastMinute
	}
	public enum NetworkState
	{
		Unavailable = 0,
		Offline = 1,
		InProgress = 2,
		InLobby = 4,
		InRoom = 8,
		Connected = 12
	}
	public enum Option
	{
		None,
		Menu,
		Quit,
		Options,
		Music,
		PlayerVoIP,
		OpponentVoIP,
		Grip,
		Ready,
		ControlSchemeWandInput,
		ControlSchemeDualWield
	}
	public enum ParseState
	{
		Success,
		Failure,
		Exception
	}
	public enum PickupType
	{
		Health,
		Mana,
		FreeTeleport
	}
	[Flags]
	public enum PlatformBuildTarget
	{
		OculusAndroid = 2,
		[Obsolete("Google build target is deprecated.")]
		Google = 4,
		Pico = 8,
		Rift = 0x10,
		Steam = 0x20,
		Viveport = 0x40,
		MiVr = 0x80,
		Quest = 0x100,
		PlayStation = 0x200,
		PicoNeo2 = 0x400
	}
	[Flags]
	public enum PlatformType
	{
		GearVr = 1,
		Go = 2,
		[Obsolete("Google platform type is deprecated.")]
		Google = 4,
		Pico = 8,
		Rift = 0x10,
		Steam = 0x20,
		Viveport = 0x40,
		MiVr = 0x80,
		Quest = 0x100,
		PlayStation = 0x200,
		PicoNeo2 = 0x400
	}
	public enum PlatformTarget
	{
		Oculus = 275,
		OculusAndroid = 259,
		Pico = 1032,
		Android = 1419,
		LowEndMobile = 139,
		HighEndMobile = 1280,
		PC = 624,
		PlayStation = 512,
		Invite = 307,
		OpenVr = 96,
		Android3DoF = 139,
		Android6DoF = 1280,
		SixDoF = 1904
	}
	public enum PoolObjectType
	{
		Teleport,
		TeleportArrive,
		ArmorOfTheSunStart,
		ArmorOfTheSunEnd,
		CerberusCollarsInit,
		CurseOfTheUndeadExplosion,
		OxymoraProjectileBad,
		OxymoraProjectileGood,
		SkullSpecterInit,
		SkullSpecterProjectile,
		StoneDemonProjectile,
		ShockRifleSmall,
		DevilsTwinDead,
		TrailProjectile,
		SkeletonProjectile,
		ValeCrystalProjectile,
		ValeCrystalHeal,
		TrashProjectile,
		ArcerProjectile,
		HulkLightning,
		CurseOfTheUndeadLingering,
		TileDamageOccupier
	}
	public enum PositionalTracking
	{
		NotAllowed,
		Allowed,
		Used
	}
	[Flags]
	public enum PostTutorialTriggerType
	{
		TeleportedToPortal = 1,
		EnteredLobby = 2,
		FoundOpponent = 8,
		EnteredWorkshop = 0x10
	}
	public enum PrimaryAxisState
	{
		Release = -1,
		Up = 1,
		Down = 4,
		Left = 2,
		Right = 3
	}
	public enum ProjectileBehaviour
	{
		Arching,
		Straight,
		Threaded,
		Homing,
		Scatter,
		Instant,
		Arrow,
		Tile
	}
	public enum RatingTitle
	{
		GoatHerder,
		DustCollector,
		RelicChaser,
		Beyonder,
		Wandsmith,
		Outlaw,
		Wielder,
		Aspirant,
		Duelist,
		Tactician,
		Veteran,
		Champion,
		GrandMaster,
		Legend,
		Developer,
		Bot
	}
	public enum RelicType
	{
		Life,
		Death,
		Chaos,
		Order,
		Teleport
	}
}
namespace Cortopia.Scripts.Enums
{
	public enum ResetBehaviour
	{
		Position = 1,
		Rotation = 2,
		Scale = 4,
		PositionAndRotation = 3,
		All = 7
	}
}
namespace Assets.Scripts.Enums
{
	public enum ReticleType
	{
		Default,
		Defense,
		CloseCombat,
		Tile
	}
	public enum RewardType
	{
		Spell,
		Dust
	}
	public enum RoomCreationReason
	{
		None = 0,
		Debug = 1,
		Basement = 2,
		Survival = 4,
		Coordinated = 8,
		HostRanked = 16,
		[Obsolete("Deprecated in favor of HostFriendly.")]
		HostPublic = 32,
		HostFriendly = 32,
		[Obsolete("Invite only is not used anymore.")]
		HostInviteOnly = 64,
		LevelExploration = 128,
		Bot = 256,
		SinglePlayer = 135,
		Friendly = 352
	}
	public enum RoomCreationType
	{
		Create,
		JoinOrCreate,
		Join
	}
	public enum RotationDirection
	{
		Left,
		Right,
		Back
	}
	public enum SlotState
	{
		Enabled = 1,
		Disabled = 2,
		Occupied = 4,
		Locked = 8,
		Undraggable = 10
	}
	public enum Spell
	{
		None,
		Spell_Teleport,
		Spell_ShieldOfLight,
		Spell_HeavenlyDome,
		Spell_ArmorOfTheSun,
		Spell_LightningStrike,
		Spell_AcidCloud,
		Spell_DevilsTwins,
		Spell_HailOfDeath,
		Spell_DevilsSpit,
		Spell_FlamingPhoenix,
		Spell_ElectricFist,
		Spell_ChaosLeap,
		Spell_BlazingMeteor,
		Spell_StoneDemon,
		Spell_SoilSpikes,
		Spell_PetrifyingPrison,
		Spell_MagicMissile,
		Spell_BloodBolt,
		Spell_CurseOfTheUndead,
		Spell_DragonsBreath,
		Spell_Oxymora,
		Spell_Demi,
		Spell_DiscOfAntioch,
		Spell_CerberusCollars,
		Spell_ChillingClutch,
		Spell_SkullSpecter,
		Spell_Rocket,
		Spell_Alchemy,
		Spell_ShockRifle,
		Spell_Dispel,
		Spell_DivineRetribution,
		Spell_ComboShot,
		Spell_AstralProjection,
		Spell_CalciteShield,
		Spell_CrystalShards
	}
	public enum TagType
	{
		Unknown,
		Player,
		Dummy,
		Lava,
		Environment,
		Shield,
		Projectile,
		Destructable,
		KillPlane,
		Train
	}
}
public enum TileOccupyState
{
	Unoccupied,
	Occupied,
	Locked
}
namespace Assets.Scripts.Enums
{
	public enum Title
	{
		SeasonOneChampion = 100,
		SeasonTwoChampion = 101,
		SeasonThreeChampion = 102,
		SeasonFourChampion = 103,
		SeasonFiveChampion = 104,
		SeasonSixChampion = 105,
		SeasonSevenChampion = 106,
		SeasonEightChampion = 107,
		SeasonNineChampion = 108,
		SeasonTenChampion = 109,
		SeasonElevenChampion = 110,
		SeasonTwelveChampion = 111,
		SeasonThirteenChampion = 112,
		SeasonFourteenChampion = 113,
		SeasonFifteenChampion = 114,
		SeasonSixteenChampion = 115,
		SeasonSeventeenChampion = 116,
		SeasonEighteenChampion = 117,
		SeasonNineteenChampion = 118,
		SeasonTwentyChampion = 119,
		SeasonTwentyOneChampion = 120,
		SeasonTwentyTwoChampion = 121,
		SeasonTwentyThreeChampion = 122,
		SeasonTwentyFourChampion = 123,
		SeasonTwentyFiveChampion = 124,
		SeasonTwentySixChampion = 125,
		SeasonTwentySevenChampion = 126,
		SeasonTwentyEightChampion = 127,
		SeasonTwentyNineChampion = 128,
		SeasonThirtyChampion = 129,
		SeasonThirtyOneChampion = 130,
		SeasonThirtyTwoChampion = 131,
		SeasonThirtyThreeChampion = 132,
		SeasonThirtyFourChampion = 133,
		SeasonThirtyFiveChampion = 134,
		SeasonThirtySixChampion = 135,
		SeasonThirtySevenChampion = 136,
		SeasonThirtyEightChampion = 137,
		SeasonThirtyNineChampion = 138,
		SeasonFourtyChampion = 139,
		SeasonFourtyOneChampion = 140,
		SeasonFourtyTwoChampion = 141,
		SeasonFourtyThreeChampion = 142,
		SeasonFourtyFourChampion = 143,
		SeasonFourtyFiveChampion = 144,
		SeasonFourtySixChampion = 145,
		SeasonFourtySevenChampion = 146,
		SeasonFourtyEightChampion = 147,
		SeasonFourtyNineChampion = 148,
		SeasonFiftyChampion = 149,
		SeasonOneTopTen = 200,
		SeasonTwoTopTen = 201,
		SeasonThreeTopTen = 202,
		SeasonFourTopTen = 203,
		SeasonFiveTopTen = 204,
		SeasonSixTopTen = 205,
		SeasonSevenTopTen = 206,
		SeasonEightTopTen = 207,
		SeasonNineTopTen = 208,
		SeasonTenTopTen = 209,
		SeasonElevenTopTen = 210,
		SeasonTwelveTopTen = 211,
		SeasonThirteenTopTen = 212,
		SeasonFourteenTopTen = 213,
		SeasonFifteenTopTen = 214,
		SeasonSixteenTopTen = 215,
		SeasonSeventeenTopTen = 216,
		SeasonEighteenTopTen = 217,
		SeasonNineteenTopTen = 218,
		SeasonTwentyTopTen = 219,
		SeasonTwentyOneTopTen = 220,
		SeasonTwentyTwoTopTen = 221,
		SeasonTwentyThreeTopTen = 222,
		SeasonTwentyFourTopTen = 223,
		SeasonTwentyFiveTopTen = 224,
		SeasonTwentySixTopTen = 225,
		SeasonTwentySevenTopTen = 226,
		SeasonTwentyEightTopTen = 227,
		SeasonTwentyNineTopTen = 228,
		SeasonThirtyTopTen = 229,
		SeasonThirtyOneTopTen = 230,
		SeasonThirtyTwoTopTen = 231,
		SeasonThirtyThreeTopTen = 232,
		SeasonThirtyFourTopTen = 233,
		SeasonThirtyFiveTopTen = 234,
		SeasonThirtySixTopTen = 235,
		SeasonThirtySevenTopTen = 236,
		SeasonThirtyEightTopTen = 237,
		SeasonThirtyNineTopTen = 238,
		SeasonFourtyTopTen = 239,
		SeasonFourtyOneTopTen = 240,
		SeasonFourtyTwoTopTen = 241,
		SeasonFourtyThreeTopTen = 242,
		SeasonFourtyFourTopTen = 243,
		SeasonFourtyFiveTopTen = 244,
		SeasonFourtySixTopTen = 245,
		SeasonFourtySevenTopTen = 246,
		SeasonFourtyEightTopTen = 247,
		SeasonFourtyNineTopTen = 248,
		SeasonFiftyTopTen = 249,
		SeasonOneTopHundred = 300,
		SeasonTwoTopHundred = 301,
		SeasonThreeTopHundred = 302,
		SeasonFourTopHundred = 303,
		SeasonFiveTopHundred = 304,
		SeasonSixTopHundred = 305,
		SeasonSevenTopHundred = 306,
		SeasonEightTopHundred = 307,
		SeasonNineTopHundred = 308,
		SeasonTenTopHundred = 309,
		SeasonElevenTopHundred = 310,
		SeasonTwelveTopHundred = 311,
		SeasonThirteenTopHundred = 312,
		SeasonFourteenTopHundred = 313,
		SeasonFifteenTopHundred = 314,
		SeasonSixteenTopHundred = 315,
		SeasonSeventeenTopHundred = 316,
		SeasonEighteenTopHundred = 317,
		SeasonNineteenTopHundred = 318,
		SeasonTwentyTopHundred = 319,
		SeasonTwentyOneTopHundred = 320,
		SeasonTwentyTwoTopHundred = 321,
		SeasonTwentyThreeTopHundred = 322,
		SeasonTwentyFourTopHundred = 323,
		SeasonTwentyFiveTopHundred = 324,
		SeasonTwentySixTopHundred = 325,
		SeasonTwentySevenTopHundred = 326,
		SeasonTwentyEightTopHundred = 327,
		SeasonTwentyNineTopHundred = 328,
		SeasonThirtyTopHundred = 329,
		SeasonThirtyOneTopHundred = 330,
		SeasonThirtyTwoTopHundred = 331,
		SeasonThirtyThreeTopHundred = 332,
		SeasonThirtyFourTopHundred = 333,
		SeasonThirtyFiveTopHundred = 334,
		SeasonThirtySixTopHundred = 335,
		SeasonThirtySevenTopHundred = 336,
		SeasonThirtyEightTopHundred = 337,
		SeasonThirtyNineTopHundred = 338,
		SeasonFourtyTopHundred = 339,
		SeasonFourtyOneTopHundred = 340,
		SeasonFourtyTwoTopHundred = 341,
		SeasonFourtyThreeTopHundred = 342,
		SeasonFourtyFourTopHundred = 343,
		SeasonFourtyFiveTopHundred = 344,
		SeasonFourtySixTopHundred = 345,
		SeasonFourtySevenTopHundred = 346,
		SeasonFourtyEightTopHundred = 347,
		SeasonFourtyNineTopHundred = 348,
		SeasonFiftyTopHundred = 349,
		RelicWielder = 400,
		WielderInTraining = 401,
		RelicMentor = 402,
		HolyAdjudicator = 500,
		HunterOfTheDamned = 501,
		Centurion = 502,
		AngelOfDeath = 503,
		Sinner = 504,
		Dilettante = 1000,
		Apprentice = 1001,
		Journeyman = 1002,
		Adept = 1003,
		Expert = 1004,
		Master = 1005,
		GrandMaster = 1006,
		Legend = 1007,
		Prophet = 1008,
		Conqueror = 1009,
		KingOfTheBeyond = 1010,
		QueenOfTheBeyond = 1011,
		Demigod = 1012,
		Vindicator = 2000
	}
	public enum TutorialConditionType
	{
		State,
		PlayerLevelEqual,
		PlayerLevelLesserThan,
		PlayerLevelGreaterThan,
		SpellTokensEqual,
		SpellTokensLesserThan,
		SpellTokensGreaterThan,
		SpellSlotState,
		DragTimeLesserThan,
		DragTimeGreaterThan,
		SpellEqual,
		SpellNotEqual,
		PostTutorialStateNotTriggered,
		DevelopmentBuild,
		PlayerInputLocked,
		MatchTypeContainsFlag
	}
	public enum TutorialReactionType
	{
		ProgressTutorial,
		ActivatePostTutorialTrigger
	}
	public enum TutorialState
	{
		None = 0,
		EnteredWorkshop = 1,
		ReadLetter = 2,
		TeleportedToPortal = 3,
		ActivatedPortal = 4,
		EnteringBasement = 5,
		EnteredBasement = 6,
		SelectedSpell = 7,
		CastSpell = 8,
		LeftBasement = 9,
		TeleportedToSpellTable = 10,
		SelectedRelic = 11,
		UnlockedRelic = 12,
		TeleportedToSpellTableWithoutSpellTokens = 13,
		SpellTableCompleted = 14,
		TeleportedToWandStation = 15,
		TeleportedToWardrobe = 16,
		Completed = 100,
		Any = 101
	}
	public enum TweenerControlOption
	{
		None,
		ResetOnAwake,
		PlayOnAwake
	}
	public enum UpdateUserDataSource
	{
		None,
		LevelUp,
		UserDataEmpty,
		ReSave,
		Clear,
		RewardClaimed,
		UpdateRating,
		FirstTimeUser,
		AddExperience,
		AddVirtualCurrency,
		BuySpell,
		UnlockSpell,
		UnlockSpells,
		BuyCharacter,
		UnlockCharacter,
		UnlockCharacters,
		BuyWand,
		UnlockWand,
		UnlockWands,
		UnlockTitle,
		UnlockTitles,
		UpdateLoadout,
		SetGameAccess
	}
	public enum VirtualCurrencySource
	{
		Debug = 1,
		Dailies = 2,
		LevelUp = 4,
		PurchasedWand = 8,
		PurchasedCharacter = 0x10,
		Conversion = 0x20,
		CustomEventReward = 0x40,
		LoadedUserData = 0x80
	}
	[Flags]
	public enum WandInput
	{
		None = 0,
		Point = 1,
		Move = 2,
		Stick = 4,
		Press = 8,
		Swipe = 0x10,
		Directional = 0xC,
		Pointing = 3,
		PressMove = 0xA
	}
	public enum WandGrip
	{
		Wand,
		Pistol
	}
	public enum WandHand
	{
		Right,
		Left
	}
	public enum WandsColor
	{
		ProjectorBlack,
		White
	}
	public enum WandStates
	{
		Active,
		InActive,
		Highlighted,
		Invisible,
		Selected
	}
	public enum WandType
	{
		Classic,
		Inductor,
		Sword,
		Lion,
		Remnant,
		Scepter,
		ScarabOfSahir,
		Invicta,
		Snake,
		Claw,
		Vigil,
		Spine,
		Armament,
		Staff,
		Crystal
	}
}
namespace Assets.Scripts.Environmental
{
	public class AutoRotate : MonoBehaviour
	{
		public float m_speed = 180f;

		private RectTransform m_rectTf;

		private void Start()
		{
			m_rectTf = GetComponent<RectTransform>();
		}

		private void FixedUpdate()
		{
			if (!(m_rectTf == null))
			{
				m_rectTf.Rotate(Vector3.forward, Time.deltaTime * m_speed, Space.Self);
			}
		}
	}
	[RequireComponent(typeof(PhotonView), typeof(Rigidbody))]
	public class Boulder : MonoBehaviourPunCallbacks, IPauseObject
	{
		private const float BotAvoidDistance = 3f;

		private const float BotAvoidRadius = 3f;

		[SerializeField]
		private SoundHandler m_soundHandler;

		[SerializeField]
		private AudioClip m_boulderStartClip;

		[SerializeField]
		private AudioSource m_loopingAudioSource;

		[SerializeField]
		private int m_damageOnImpact = 20;

		[SerializeField]
		private Transform m_boulderModel;

		[SerializeField]
		private Transform[] m_trajectoryPoints = Array.Empty<Transform>();

		[SerializeField]
		private float m_boulderRotationPerFrame = 90f;

		[SerializeField]
		private float m_journeyTime = 12f;

		[SerializeField]
		private GameObject m_enableWhenRolling;

		private Rigidbody m_rigidBody;

		private Vector3 m_startingPosition;

		private Vector3 m_endingPosition;

		private float[] m_distanceTrajectoryPoints;

		private float m_totalDistanceOfTravel;

		private float m_timeOfJourneySegment;

		private List<string> m_affectedTiles = new List<string>();

		private float m_startTime;

		private int m_stepsCounter = 1;

		private bool m_followPath;

		private Collider[] m_botPreditionColliders = new Collider[4];

		private List<Collider> m_unsafeTileColliders = new List<Collider>(4);

		private List<Collider> m_collidersPreditctedSafe = new List<Collider>(4);

		private RaycastHit m_hit = default(RaycastHit);

		private EventToken m_matchPausedEventToken;

		private EventToken m_matchEndedEventToken;

		public bool IsPaused { get; set; }

		public float JourneyTime
		{
			[CompilerGenerated]
			get
			{
				return m_journeyTime + m_boulderStartClip.length;
			}
		}

		public override void OnEnable()
		{
			base.OnEnable();
			m_matchPausedEventToken = EventHub.Subscribe<Events.MatchPausedEvent>(OnMatchPaused);
			m_matchEndedEventToken = EventHub.Subscribe<Events.MatchEndedEvent>(OnMatchEnded);
		}

		public override void OnDisable()
		{
			base.OnDisable();
			StopAllCoroutines();
			EventHub.Unsubscribe<Events.MatchPausedEvent>(m_matchPausedEventToken);
			EventHub.Unsubscribe<Events.MatchEndedEvent>(m_matchEndedEventToken);
		}

		private void Start()
		{
			m_rigidBody = GetComponent<Rigidbody>();
			PrepareDistances();
			ResetValues();
			SetEnabledWhenRollingActive(active: false);
		}

		private void FixedUpdate()
		{
			if (!IsPaused && m_followPath)
			{
				DetectCollision();
				Movement();
			}
		}

		public void Pause(bool pause)
		{
			IsPaused = pause;
		}

		private void OnMatchPaused(Events.MatchPausedEvent eventData)
		{
			Pause(eventData.IsPaused);
		}

		private void OnMatchEnded(Events.MatchEndedEvent eventData)
		{
			StopAllCoroutines();
			m_followPath = false;
		}

		private void PrepareDistances()
		{
			m_distanceTrajectoryPoints = new float[m_trajectoryPoints.Length - 1];
			for (int i = 0; i < m_distanceTrajectoryPoints.Length; i++)
			{
				m_distanceTrajectoryPoints[i] = Vector3.Distance(m_trajectoryPoints[i].position, m_trajectoryPoints[i + 1].position);
			}
			m_totalDistanceOfTravel = Vector3.Distance(m_trajectoryPoints[0].position, m_trajectoryPoints[m_trajectoryPoints.Length - 1].position);
		}

		private void ResetValues()
		{
			m_stepsCounter = 1;
			m_startingPosition = m_trajectoryPoints[0].position;
			m_endingPosition = m_trajectoryPoints[m_stepsCounter].position;
			m_timeOfJourneySegment = m_journeyTime * (m_distanceTrajectoryPoints[m_stepsCounter - 1] / m_totalDistanceOfTravel);
		}

		private void AdjustToNextPoint()
		{
			m_startTime = PunSingleton<TimeManager>.Instance.CurrentMatchTime;
			m_stepsCounter++;
			m_timeOfJourneySegment = m_journeyTime * (m_distanceTrajectoryPoints[m_stepsCounter - 1] / m_totalDistanceOfTravel);
			m_startingPosition = m_trajectoryPoints[m_stepsCounter - 1].position;
			m_endingPosition = m_trajectoryPoints[m_stepsCounter].position;
		}

		private float DeterminePosition(float fracJourney)
		{
			if (Vector3.Distance(m_rigidBody.position, m_endingPosition) < 0.01f && m_stepsCounter < m_trajectoryPoints.Length - 1)
			{
				AdjustToNextPoint();
				return 0f;
			}
			return fracJourney;
		}

		private void DetectCollision()
		{
			if (MonoSingleton<NetworkManager>.Instance.CurrentMatchType.ContainsFlag(MatchType.Bot))
			{
				int num = Physics.OverlapSphereNonAlloc(m_rigidBody.position + m_rigidBody.transform.forward * 3f, 3f, m_botPreditionColliders, 1 << LayerMask.NameToLayer("Tile"));
				if (num > 0)
				{
					m_collidersPreditctedSafe = new List<Collider>(m_unsafeTileColliders);
					for (int i = 0; i < num; i++)
					{
						Collider collider = m_botPreditionColliders[i];
						if (!m_unsafeTileColliders.Contains(collider))
						{
							Tile component = collider.transform.GetComponent<Tile>();
							Events.TilePredictedUnsafeEvent tilePredictedUnsafeEvent = new Events.TilePredictedUnsafeEvent();
							tilePredictedUnsafeEvent.Tile = component;
							EventHub.Publish(tilePredictedUnsafeEvent);
							m_unsafeTileColliders.Add(collider);
						}
						m_collidersPreditctedSafe.Remove(collider);
					}
					foreach (Collider item in m_collidersPreditctedSafe)
					{
						if (m_unsafeTileColliders.Contains(item))
						{
							m_unsafeTileColliders.Remove(item);
							Tile component = item.transform.GetComponent<Tile>();
							Events.TilePredictedSafeEvent tilePredictedSafeEvent = new Events.TilePredictedSafeEvent();
							tilePredictedSafeEvent.Tile = component;
							EventHub.Publish(tilePredictedSafeEvent);
						}
					}
				}
			}
			if (!Physics.SphereCast(m_rigidBody.position, 1f, m_rigidBody.transform.forward, out m_hit, 1f, 1 << LayerMask.NameToLayer("Tile")) || m_affectedTiles.Contains(m_hit.collider.name))
			{
				return;
			}
			m_affectedTiles.Add(m_hit.collider.name);
			Tile component2 = m_hit.collider.GetComponent<Tile>();
			if (component2.IsUnoccupied)
			{
				return;
			}
			m_soundHandler.PlaySound("ophidian_stonewheel_impact");
			if (component2.OccupantWielder != null && component2.OccupantWielder.IsLocal)
			{
				component2.OccupantWielder.TakeDamage(DamageType.Once, m_damageOnImpact, (component2.OccupantWielder.transform.position - m_rigidBody.position).normalized);
			}
			else
			{
				if (!(component2.Occupant != null) || !component2.Occupant.IsMine)
				{
					return;
				}
				if (component2.OccupantTwin != null)
				{
					component2.OccupantTwin.OnHit(m_damageOnImpact);
					return;
				}
				TurretBase componentInChildren = component2.Occupant.GetComponentInChildren<TurretBase>();
				if (componentInChildren != null)
				{
					componentInChildren.OnHit(m_damageOnImpact);
				}
			}
		}

		private void Movement()
		{
			m_boulderModel.Rotate(Vector3.down, m_boulderRotationPerFrame * Time.deltaTime);
			float num = DeterminePosition((PunSingleton<TimeManager>.Instance.CurrentMatchTime - m_startTime) / m_timeOfJourneySegment);
			m_rigidBody.MovePosition(Vector3.Lerp(m_startingPosition, m_endingPosition, num));
			if (num >= 1f && m_stepsCounter == m_trajectoryPoints.Length - 1)
			{
				m_followPath = false;
				m_soundHandler.PlaySound("ophidian_stonewheel_end");
				m_loopingAudioSource.Stop();
				SetEnabledWhenRollingActive(active: false);
			}
		}

		private void ResetBoulder()
		{
			ResetValues();
			m_affectedTiles.Clear();
			m_rigidBody.position = m_startingPosition;
			m_boulderModel.localRotation = Quaternion.Euler(0f, 0f, 90f);
		}

		public IEnumerator StartBoulderMovement(float currentMatchTime)
		{
			ResetBoulder();
			m_soundHandler.PlaySound("ophidian_stonewheel_start");
			yield return new CustomWaitForSeconds(m_boulderStartClip.length);
			m_followPath = false;
			m_startTime = currentMatchTime + m_boulderStartClip.length;
			m_followPath = true;
			m_loopingAudioSource.Play();
			SetEnabledWhenRollingActive(active: true);
		}

		private void SetEnabledWhenRollingActive(bool active)
		{
			if (m_enableWhenRolling == null)
			{
				WandsLogger.Log("Boulder: m_enableWhenRolling is not set. It probably should be.", LogType.Error);
			}
			else
			{
				m_enableWhenRolling.SetActive(active);
			}
		}
	}
	[RequireComponent(typeof(PhotonView))]
	public class BoulderHandler : MonoBehaviourPun
	{
		[SerializeField]
		private Boulder[] m_boulders = Array.Empty<Boulder>();

		[SerializeField]
		private float m_initialWaitTime;

		private EventToken m_matchResetEventToken;

		private void OnDisable()
		{
			EventHub.Unsubscribe<Events.MatchResetEvent>(m_matchResetEventToken);
		}

		private void Start()
		{
			m_matchResetEventToken = EventHub.Subscribe<Events.MatchResetEvent>(OnMatchReset);
			StartBoulderMovement();
		}

		private void OnMatchReset(Events.MatchResetEvent eventData)
		{
			StartBoulderMovement();
		}

		private void StartBoulderMovement()
		{
			StopAllCoroutines();
			if (PhotonNetwork.IsMasterClient)
			{
				StartCoroutine(BoulderMovement());
			}
		}

		private IEnumerator BoulderMovement()
		{
			yield return new CustomWaitForSeconds(m_initialWaitTime);
			for (int i = 0; i < m_boulders.Length; i++)
			{
				base.photonView.RPC("PunActivateBoulder", RpcTarget.AllBufferedViaServer, i, PunSingleton<TimeManager>.Instance.CurrentMatchTime);
				yield return new CustomWaitForSeconds(m_boulders[i].JourneyTime);
			}
			StartBoulderMovement();
		}

		[PunRPC]
		private void PunActivateBoulder(int boulderIndex, float currentTime)
		{
			StartCoroutine(m_boulders[boulderIndex].StartBoulderMovement(currentTime));
		}
	}
	[RequireComponent(typeof(PhotonView))]
	public class Crystal : MonoBehaviourPun, IPauseObject
	{
		private const float AnticipationTime = 3f;

		[SerializeField]
		private List<CrystalState> m_acceptedStates = new List<CrystalState>();

		[Header("Sounds")]
		[SerializeField]
		private SoundHandler m_soundHandler;

		[Header("Visuals")]
		[SerializeField]
		private Renderer[] m_renderers = Array.Empty<Renderer>();

		[SerializeField]
		private Color m_originalColor = Color.white;

		[Header("Timing")]
		[SerializeField]
		private float m_neutralCycleTime = 25f;

		[SerializeField]
		private float m_damageCycleTime = 5f;

		[Header("Shooting")]
		[SerializeField]
		private float m_shootingInterval = 3f;

		[SerializeField]
		private int m_damageAmount = 10;

		[SerializeField]
		private Transform m_projectileSpawnPoint;

		[SerializeField]
		private Tile[] m_visibleTiles = Array.Empty<Tile>();

		[SerializeField]
		private float m_projectileSpeed = 0.5f;

		[SerializeField]
		private float m_aimProjectileSpeed = 10f;

		private CrystalState m_crystalState;

		private Color m_nextColor;

		private float m_nextStateDuration;

		private bool m_suddenDeath;

		private bool m_hasCreatedPools;

		private float m_anticipationPerState;

		private IPoolObject m_projectile;

		private ProjectileMoverEnvironment m_trailRendererPoolObject;

		private EventToken m_matchPausedEventToken;

		private EventToken m_matchResetEventToken;

		private EventToken m_suddenDeathStartedEventToken;

		private EventToken m_matchEndedEventToken;

		public bool IsPaused { get; private set; }

		public float FireTime
		{
			[CompilerGenerated]
			get
			{
				return PunSingleton<TimeManager>.Instance.CurrentRoomTime + 0.15f;
			}
		}

		private void OnEnable()
		{
			m_matchPausedEventToken = EventHub.Subscribe<Events.MatchPausedEvent>(OnMatchPaused);
			m_matchResetEventToken = EventHub.Subscribe<Events.MatchResetEvent>(OnMatchReset);
			m_suddenDeathStartedEventToken = EventHub.Subscribe<Events.SuddenDeathStartedEvent>(OnSuddenDeathStarted);
			m_matchEndedEventToken = EventHub.Subscribe<Events.MatchEndedEvent>(OnMatchEnded);
		}

		private void OnDisable()
		{
			StopAllCoroutines();
			EventHub.Unsubscribe<Events.MatchPausedEvent>(m_matchPausedEventToken);
			EventHub.Unsubscribe<Events.MatchResetEvent>(m_matchResetEventToken);
			EventHub.Unsubscribe<Events.SuddenDeathStartedEvent>(m_suddenDeathStartedEventToken);
			EventHub.Unsubscribe<Events.MatchEndedEvent>(m_matchEndedEventToken);
		}

		private void Start()
		{
			m_visibleTiles.QuickSort((Tile tile) => Vector3.Distance(tile.transform.position, m_projectileSpawnPoint.position));
			m_anticipationPerState = 3f / (float)m_acceptedStates.Count;
		}

		public void Pause(bool pause)
		{
			IsPaused = pause;
		}

		private void OnMatchPaused(Events.MatchPausedEvent eventData)
		{
			Pause(eventData.IsPaused);
		}

		private void OnSuddenDeathStarted(Events.SuddenDeathStartedEvent eventData)
		{
			OnSuddenDeath();
		}

		private void OnMatchEnded(Events.MatchEndedEvent eventData)
		{
			StopAllCoroutines();
			PunChangeState(CrystalState.Neutral);
		}

		private void OnMatchReset(Events.MatchResetEvent eventData)
		{
			TrySpawnCrystalSpells();
			StopAllCoroutines();
			PunChangeState(CrystalState.Neutral);
			StartChangeState();
		}

		private void TrySpawnCrystalSpells()
		{
			if (!m_hasCreatedPools)
			{
				m_hasCreatedPools = true;
				m_projectile = Spawn(PoolObjectType.ValeCrystalProjectile, null);
				ObjectPoolHandler.CreateObjectPool(2, PoolObjectType.ValeCrystalHeal);
				m_trailRendererPoolObject = Spawn(PoolObjectType.TrailProjectile, null) as ProjectileMoverEnvironment;
			}
		}

		private void StartChangeState()
		{
			switch (m_crystalState)
			{
			case CrystalState.Damaging:
				m_nextStateDuration = m_damageCycleTime + 3f;
				break;
			case CrystalState.Healing:
				m_nextStateDuration = 13f;
				break;
			case CrystalState.Neutral:
				m_nextStateDuration = m_neutralCycleTime;
				break;
			}
			if (PhotonNetwork.IsMasterClient && !m_suddenDeath)
			{
				StartCoroutine(ChangeStateCountdown(m_nextStateDuration));
			}
		}

		private IEnumerator ChangeStateCountdown(float waitTime)
		{
			yield return new CustomWaitForSeconds(waitTime);
			m_crystalState = ((m_crystalState == CrystalState.Neutral) ? m_acceptedStates.GetRandomElement(CrystalState.Neutral) : CrystalState.Neutral);
			base.photonView.RPC("PunChangeState", RpcTarget.AllViaServer, m_crystalState);
			PrepareAction();
			StartChangeState();
		}

		[PunRPC]
		private void PunChangeState(CrystalState crystalState)
		{
			float delay = m_anticipationPerState;
			switch (crystalState)
			{
			case CrystalState.Damaging:
				m_soundHandler.PlaySound("crystal_offensive_state");
				m_nextColor = Color.red;
				break;
			case CrystalState.Neutral:
				delay = 0f;
				m_nextColor = m_originalColor;
				break;
			case CrystalState.Healing:
				m_soundHandler.PlaySound("crystal_healing_state");
				m_nextColor = Color.yellow;
				break;
			}
			if ((((object)m_trailRendererPoolObject != null) ? m_trailRendererPoolObject.TrailRenderer : null) != null)
			{
				m_trailRendererPoolObject.TrailRenderer.time = m_shootingInterval / 3f;
				m_trailRendererPoolObject.TrailRenderer.material.SetColor("_TintColor", m_nextColor);
			}
			for (int i = 0; i < m_renderers.Length; i++)
			{
				Renderer renderer = m_renderers[i];
				renderer.material.DOColor(m_nextColor, m_anticipationPerState).SetDelay(delay);
			}
		}

		private void FireLineProjectile(Vector3[] bezierPoints)
		{
			(GrabFromPool(PoolObjectType.TrailProjectile) as ProjectileMover).EnableObject(bezierPoints[0], FireTime, 1, 0, bezierPoints, m_aimProjectileSpeed, 0);
		}

		private void Fire(Vector3[] arcPoints)
		{
			(GrabFromPool(PoolObjectType.ValeCrystalProjectile) as ProjectileMover).EnableObject(arcPoints[0], FireTime, 1, 0, arcPoints, m_projectileSpeed, m_damageAmount);
		}

		private void PrepareAction()
		{
			switch (m_crystalState)
			{
			case CrystalState.Damaging:
				StartCoroutine(Damage());
				break;
			case CrystalState.Healing:
				StartCoroutine(Heal());
				break;
			}
		}

		private IEnumerator Damage()
		{
			yield return new CustomWaitForSeconds(3f);
			int tileIndex = GetClosestOccupiedTileIndex();
			int counter = (int)(m_damageCycleTime / m_shootingInterval);
			for (int i = 0; i < counter; i++)
			{
				yield return new CustomWaitForSeconds(m_shootingInterval / 2f);
				Vector3[] bezierPoints = GetBezierPoints(AimAtTarget(tileIndex) + Vector3.up);
				FireLineProjectile(bezierPoints);
				yield return new CustomWaitForSeconds(m_shootingInterval / 2f);
				Fire(bezierPoints);
			}
		}

		private IEnumerator Heal()
		{
			yield return new CustomWaitForSeconds(3f);
			int tileIndex = GetClosestOccupiedTileIndex();
			FireLineProjectile(GetBezierPoints(AimAtTarget(tileIndex) + Vector3.up));
			GrabFromPool(PoolObjectType.ValeCrystalHeal).EnableObject(AimAtTarget(tileIndex), m_visibleTiles[tileIndex].photonView.ViewID);
		}

		private int GetClosestOccupiedTileIndex()
		{
			int num = -1;
			int num2 = -1;
			for (int i = 0; i < m_visibleTiles.Length; i++)
			{
				if (!m_visibleTiles[i].IsOccupied)
				{
					continue;
				}
				if (m_visibleTiles[i].ActiveHealEffect != null)
				{
					num2 = i;
					continue;
				}
				if (m_visibleTiles[i].OccupantWielder != null || m_visibleTiles[i].OccupantTwin != null)
				{
					return i;
				}
				if (num < 0)
				{
					num = i;
				}
			}
			if (num < 0)
			{
				num = UnityEngine.Random.Range(0, m_visibleTiles.Length);
				if (num == num2)
				{
					num++;
					if (num > m_visibleTiles.Length)
					{
						num = 0;
					}
				}
			}
			return num;
		}

		private Vector3 AimAtTarget(int tileId)
		{
			if (m_visibleTiles[tileId].OccupantWielder == null)
			{
				if (m_visibleTiles[tileId].OccupantTwin != null)
				{
					return m_visibleTiles[tileId].OccupantTwin.Collider.transform.position;
				}
				return m_visibleTiles[tileId].transform.position;
			}
			if (m_visibleTiles[tileId].OccupantWielder.IsLocal)
			{
				return m_visibleTiles[tileId].OccupantWielder.CharacterControl.ColliderTransform.position;
			}
			return m_visibleTiles[tileId].OccupantWielder.RemoteCharacter.Collider.transform.position;
		}

		private void OnSuddenDeath()
		{
			m_suddenDeath = true;
			StopAllCoroutines();
			m_crystalState = CrystalState.Neutral;
			base.photonView.RPC("PunChangeState", RpcTarget.AllViaServer, m_crystalState);
		}

		private Vector3[] GetBezierPoints(Vector3 targetPos)
		{
			return new Vector3[3]
			{
				m_projectileSpawnPoint.position,
				MathUtils.GetMidPoint(m_projectileSpawnPoint.position, targetPos),
				targetPos
			};
		}

		public IPoolObject GrabFromPool(PoolObjectType type)
		{
			switch (type)
			{
			case PoolObjectType.TrailProjectile:
				return m_trailRendererPoolObject;
			case PoolObjectType.ValeCrystalProjectile:
				return m_projectile;
			case PoolObjectType.ValeCrystalHeal:
				return ObjectPoolHandler.GrabFromPool(PoolObjectType.ValeCrystalHeal);
			default:
				WandsLogger.LogError("Type not supported!", LogColor.ObjectPooling);
				return null;
			}
		}

		private IPoolObject Spawn(PoolObjectType type, object[] data)
		{
			return NetworkUtils.Instantiate($"Vfx/{type}", Vector3.zero, Quaternion.identity, 0, data).GetComponent<IPoolObject>();
		}
	}
	[RequireComponent(typeof(PhotonView))]
	public class DesertController : MonoBehaviourPun, IPauseObject
	{
		[SerializeField]
		private float m_environmentEffectDamage = 10f;

		[Header("Duration")]
		[Tooltip("Duration of the sandstorm fade")]
		[SerializeField]
		private float m_sandstormFadeTime = 40f;

		[Tooltip("Duration of the sandstorm travel")]
		[SerializeField]
		private float m_sandstormTravelTime = 35f;

		[Tooltip("Duration of the gas fade in")]
		[SerializeField]
		private float m_gasFadeTime = 15f;

		[Tooltip("Duration of the gas travel")]
		[SerializeField]
		private float m_gasTravelTime = 30f;

		[Header("Timing")]
		[Tooltip("Start the Sandstorm build up after this many seconds in the match")]
		[SerializeField]
		private float m_startSandstormBuildup = 10f;

		[Tooltip("Start the Sandstorm after this many seconds in the match")]
		[SerializeField]
		private float m_startSandstorm = 20f;

		[Tooltip("Open the outside doors after this many seconds in the match")]
		[SerializeField]
		private float m_openOutsideDoors = 20f;

		[Tooltip("Close the outside doors after this many seconds in the match")]
		[SerializeField]
		private float m_closeOutsideDoors = 60f;

		[Tooltip("Start the Gas build up after this many seconds in the match")]
		[SerializeField]
		private float m_startGasBuildup = 105f;

		[Tooltip("Open the inside doors after this many seconds in the match")]
		[SerializeField]
		private float m_openInnerDoors = 105f;

		[Tooltip("Start the Gas after this many seconds in the match")]
		[SerializeField]
		private float m_startGas = 120f;

		[Tooltip("Close the inside doors after this many seconds in the match")]
		[SerializeField]
		private float m_closeInnerDoors = 150f;

		[Header("Tiles")]
		[SerializeField]
		private GameObject m_outsideTilesParent;

		[SerializeField]
		private GameObject m_insideTilesParent;

		[SerializeField]
		private GameObject m_treasureTilesParent;

		[Header("Environment")]
		[SerializeField]
		private GameObject m_outside;

		[SerializeField]
		private GameObject m_middle;

		[SerializeField]
		private GameObject m_inner;

		[SerializeField]
		private GameObject m_outsideDoor;

		[SerializeField]
		private GameObject m_innerDoor;

		[Header("Colliders")]
		[SerializeField]
		private GameObject m_outsideColliders;

		[SerializeField]
		private GameObject m_middleColliders;

		[SerializeField]
		private GameObject m_innerColliders;

		private EventToken m_matchResetEventToken;

		private EventToken m_matchPausedEventToken;

		private EventToken m_activateDesertDoorsToken;

		private EventToken m_matchEndEventToken;

		private bool m_isLevelProgressing;

		private bool m_isInnerSanctumReached;

		private float m_currentTimer;

		private List<TileDamageOccupier> m_occupyObjectPool = new List<TileDamageOccupier>();

		private DesertTempleStage m_currentStage;

		private DesertTempleEnvironmentType m_type;

		public bool IsPaused { get; set; }

		public Tile[] OutsideTiles { get; private set; }

		public Tile[] InsideTiles { get; private set; }

		public Tile[] TreasureTiles { get; private set; }

		private void OnEnable()
		{
			m_matchPausedEventToken = EventHub.Subscribe<Events.MatchPausedEvent>(OnMatchPaused);
			m_matchResetEventToken = EventHub.Subscribe<Events.MatchResetEvent>(OnMatchReset);
			m_matchEndEventToken = EventHub.Subscribe<Events.MatchEndedEvent>(OnMatchEnded);
			m_activateDesertDoorsToken = EventHub.Subscribe<Events.ActivateDesertTempleDoorsEvent>(EnableEnvironment);
		}

		private void OnDisable()
		{
			StopAllCoroutines();
			EventHub.Unsubscribe<Events.MatchPausedEvent>(m_matchPausedEventToken);
			EventHub.Unsubscribe<Events.MatchResetEvent>(m_matchResetEventToken);
			EventHub.Unsubscribe<Events.ActivateDesertTempleDoorsEvent>(m_activateDesertDoorsToken);
			EventHub.Unsubscribe<Events.MatchEndedEvent>(m_matchEndEventToken);
		}

		private void Awake()
		{
			OutsideTiles = m_outsideTilesParent.GetComponentsInChildren<Tile>();
			InsideTiles = m_insideTilesParent.GetComponentsInChildren<Tile>();
			TreasureTiles = m_treasureTilesParent.GetComponentsInChildren<Tile>();
		}

		private void Start()
		{
			m_middle.SetActive(value: false);
			m_inner.SetActive(value: false);
			m_innerDoor.SetActive(value: false);
			OccupyTiles(TileOccupyState.Occupied, TreasureTiles);
			OccupyTiles(TileOccupyState.Occupied, InsideTiles);
			m_currentTimer = m_startSandstormBuildup;
		}

		public void Pause(bool pause)
		{
			IsPaused = pause;
		}

		private void OnMatchPaused(Events.MatchPausedEvent eventData)
		{
			Pause(eventData.IsPaused);
		}

		private void OnMatchReset(Events.MatchResetEvent eventData)
		{
			if (m_occupyObjectPool.IsEmpty())
			{
				CreateObjectPool(Mathf.Max(OutsideTiles.Length, InsideTiles.Length), m_environmentEffectDamage);
			}
			if (PhotonNetwork.IsMasterClient && !m_isInnerSanctumReached && m_currentStage == DesertTempleStage.BuildUpSandstorm)
			{
				m_isLevelProgressing = true;
			}
		}

		private void OnMatchEnded(Events.MatchEndedEvent eventData)
		{
			StopAllCoroutines();
			m_isLevelProgressing = false;
		}

		private void FixedUpdate()
		{
			if (!IsPaused && m_isLevelProgressing && !(PunSingleton<TimeManager>.Instance.CurrentMatchTime < m_currentTimer))
			{
				base.photonView.RPC("PunDesertStageActivate", RpcTarget.AllBufferedViaServer, m_currentStage, PunSingleton<TimeManager>.Instance.CurrentMatchTime, m_type);
				switch (m_currentStage)
				{
				case DesertTempleStage.BuildUpSandstorm:
					m_currentTimer = m_startSandstorm;
					m_type = DesertTempleEnvironmentType.Sandstorm;
					break;
				case DesertTempleStage.StartSandstorm:
					m_currentTimer = m_openOutsideDoors;
					m_type = DesertTempleEnvironmentType.Sandstorm;
					break;
				case DesertTempleStage.OpenOutsideDoors:
					m_currentTimer = m_closeOutsideDoors;
					m_type = DesertTempleEnvironmentType.Sandstorm;
					break;
				case DesertTempleStage.CloseOutsideDoors:
					m_currentTimer = m_startGasBuildup;
					m_type = DesertTempleEnvironmentType.Sandstorm;
					break;
				case DesertTempleStage.BuildUpGas:
					m_currentTimer = m_openInnerDoors;
					m_type = DesertTempleEnvironmentType.Gas;
					break;
				case DesertTempleStage.OpenInnerDoors:
					m_currentTimer = m_startGas;
					m_type = DesertTempleEnvironmentType.Gas;
					break;
				case DesertTempleStage.StartGas:
					m_currentTimer = m_closeInnerDoors;
					m_type = DesertTempleEnvironmentType.Gas;
					break;
				case DesertTempleStage.CloseInnerDoors:
					m_type = DesertTempleEnvironmentType.Gas;
					m_currentTimer = 210f;
					m_isInnerSanctumReached = true;
					m_isLevelProgressing = false;
					break;
				}
				m_currentStage = (DesertTempleStage)((int)(m_currentStage + 1) % Enum.GetValues(typeof(DesertTempleStage)).Length);
			}
		}

		[PunRPC]
		private void PunDesertStageActivate(DesertTempleStage stage, float matchTime, DesertTempleEnvironmentType type)
		{
			switch (stage)
			{
			case DesertTempleStage.BuildUpSandstorm:
			{
				Events.BuildupSandstormDesertTempleEvent buildupSandstormDesertTempleEvent = new Events.BuildupSandstormDesertTempleEvent();
				buildupSandstormDesertTempleEvent.JourneyTime = m_sandstormFadeTime;
				EventHub.Publish(buildupSandstormDesertTempleEvent);
				break;
			}
			case DesertTempleStage.StartSandstorm:
			{
				Events.ActivateSandstormDesertTempleEvent activateSandstormDesertTempleEvent = new Events.ActivateSandstormDesertTempleEvent();
				activateSandstormDesertTempleEvent.JourneyTime = m_sandstormTravelTime;
				activateSandstormDesertTempleEvent.CurrentMatchTime = matchTime;
				EventHub.Publish(activateSandstormDesertTempleEvent);
				break;
			}
			case DesertTempleStage.OpenOutsideDoors:
			{
				Events.ActivateDesertTempleDoorsEvent activateDesertTempleDoorsEvent = new Events.ActivateDesertTempleDoorsEvent();
				activateDesertTempleDoorsEvent.EnvironmentType = type;
				activateDesertTempleDoorsEvent.Enable = true;
				EventHub.Publish(activateDesertTempleDoorsEvent);
				break;
			}
			case DesertTempleStage.CloseOutsideDoors:
			{
				Events.ActivateDesertTempleDoorsEvent activateDesertTempleDoorsEvent = new Events.ActivateDesertTempleDoorsEvent();
				activateDesertTempleDoorsEvent.EnvironmentType = type;
				activateDesertTempleDoorsEvent.Enable = false;
				EventHub.Publish(activateDesertTempleDoorsEvent);
				break;
			}
			case DesertTempleStage.BuildUpGas:
			{
				Events.BuildupGasDesertTempleEvent buildupGasDesertTempleEvent = new Events.BuildupGasDesertTempleEvent();
				buildupGasDesertTempleEvent.JourneyTime = m_gasFadeTime;
				EventHub.Publish(buildupGasDesertTempleEvent);
				break;
			}
			case DesertTempleStage.StartGas:
			{
				Events.ActivateGasDesertTempleEvent activateGasDesertTempleEvent = new Events.ActivateGasDesertTempleEvent();
				activateGasDesertTempleEvent.JourneyTime = m_gasTravelTime;
				activateGasDesertTempleEvent.CurrentMatchTime = matchTime;
				EventHub.Publish(activateGasDesertTempleEvent);
				break;
			}
			case DesertTempleStage.OpenInnerDoors:
			{
				Events.ActivateDesertTempleDoorsEvent activateDesertTempleDoorsEvent = new Events.ActivateDesertTempleDoorsEvent();
				activateDesertTempleDoorsEvent.EnvironmentType = type;
				activateDesertTempleDoorsEvent.Enable = true;
				EventHub.Publish(activateDesertTempleDoorsEvent);
				break;
			}
			case DesertTempleStage.CloseInnerDoors:
			{
				Events.ActivateDesertTempleDoorsEvent activateDesertTempleDoorsEvent = new Events.ActivateDesertTempleDoorsEvent();
				activateDesertTempleDoorsEvent.EnvironmentType = type;
				activateDesertTempleDoorsEvent.Enable = false;
				EventHub.Publish(activateDesertTempleDoorsEvent);
				break;
			}
			}
		}

		public void OccupyTiles(TileOccupyState occupyState, Tile[] m_tiles)
		{
			if (m_tiles.IsNullOrEmpty())
			{
				return;
			}
			if (occupyState == TileOccupyState.Unoccupied)
			{
				foreach (Tile tile in m_tiles)
				{
					PunSingleton<TileManager>.Instance?.OccupyTile(tile, occupyState);
				}
				return;
			}
			ResetPool();
			foreach (Tile tile2 in m_tiles)
			{
				PunSingleton<TileManager>.Instance?.OccupyTile(tile2, occupyState, base.photonView);
			}
		}

		private IEnumerator DelayedEnableEnviroment(TileOccupyState occupyState, bool enable, float time, GameObject enviroment, GameObject colliders, Tile[] tiles, GameObject door = null)
		{
			yield return new WaitForSeconds(time);
			enviroment.SetActive(enable);
			colliders.SetActive(enable);
			door?.SetActive(enable);
			if (occupyState == TileOccupyState.Unoccupied)
			{
				yield return new WaitForSeconds(4.2f);
			}
			OccupyTiles(occupyState, tiles);
		}

		private void EnableEnvironment(Events.ActivateDesertTempleDoorsEvent eventData)
		{
			if (eventData.Enable)
			{
				switch (eventData.EnvironmentType)
				{
				case DesertTempleEnvironmentType.Sandstorm:
					StartCoroutine(DelayedEnableEnviroment(TileOccupyState.Unoccupied, enable: true, 15f, m_middle, m_middleColliders, InsideTiles, m_innerDoor));
					break;
				case DesertTempleEnvironmentType.Gas:
					StartCoroutine(DelayedEnableEnviroment(TileOccupyState.Unoccupied, enable: true, 15f, m_inner, m_innerColliders, TreasureTiles));
					break;
				}
			}
			else
			{
				switch (eventData.EnvironmentType)
				{
				case DesertTempleEnvironmentType.Sandstorm:
					StartCoroutine(DelayedEnableEnviroment(TileOccupyState.Locked, enable: false, 15f, m_outside, m_outsideColliders, OutsideTiles));
					break;
				case DesertTempleEnvironmentType.Gas:
					StartCoroutine(DelayedEnableEnviroment(TileOccupyState.Locked, enable: false, 15f, m_middle, m_middleColliders, InsideTiles, m_outsideDoor));
					break;
				}
			}
		}

		public void CreateObjectPool(int poolSize, params object[] data)
		{
			for (int i = 0; i < poolSize; i++)
			{
				m_occupyObjectPool.Add(NetworkUtils.Instantiate("Vfx/" + PoolObjectType.TileDamageOccupier, Vector3.zero, Quaternion.identity, 0, data).GetComponent<TileDamageOccupier>());
			}
		}

		public TileDamageOccupier GrabFromPool()
		{
			if (m_occupyObjectPool.IsNullOrEmpty())
			{
				WandsLogger.LogError("No TileDamageOccupiers available!", LogColor.ObjectPooling);
				return null;
			}
			foreach (TileDamageOccupier item in m_occupyObjectPool)
			{
				if (item.IsActive)
				{
					continue;
				}
				return item;
			}
			WandsLogger.LogError("All TileDamageOccupiers are being used!", LogColor.ObjectPooling);
			return null;
		}

		public void ResetPool()
		{
			foreach (TileDamageOccupier item in m_occupyObjectPool)
			{
				item.DisableObject();
			}
		}
	}
	[RequireComponent(typeof(PhotonView), typeof(Rigidbody))]
	public class DesertTempleEnvironment : MonoBehaviourPun, IPauseObject
	{
		private const float BotSafetyDistance = 10f;

		[SerializeField]
		private DesertTempleEnvironmentType m_type;

		[SerializeField]
		private DesertController m_desertController;

		[Header("Movement")]
		[SerializeField]
		private Vector3 m_endPosition = Vector3.zero;

		[Header("Effects")]
		[SerializeField]
		private EffectType m_effectType;

		[SerializeField]
		private AudioSource m_loopingAudioSource;

		[SerializeField]
		private ParticleSystem m_startUpEffect;

		[SerializeField]
		private List<MeshRenderer> m_effectRenderers;

		[SerializeField]
		private List<ParticleSystem> m_effectParticleSystems;

		[SerializeField]
		private List<Material> m_effectMaterials;

		private EventToken m_matchPausedEventToken;

		private EventToken m_matchResetEventToken;

		private EventToken m_activateSandstormDesertTempleToken;

		private EventToken m_activateGasDesertTempleToken;

		private EventToken m_buildupSandstormDesertTempleToken;

		private EventToken m_buildupGasDesertTempleToken;

		private EventToken m_activateDesertDoorsToken;

		private Rigidbody m_rigidbody;

		private Vector3 m_startPosition;

		private bool m_followPath;

		private int m_tileCounter;

		private float m_startTime;

		private float m_movePercentage;

		private float m_journeyTime;

		private bool m_isBotMatch;

		private float m_safetyDistance;

		private Tile[] m_affectableTiles;

		private Tile m_nextTile;

		private HashSet<Tile> m_unsafeTiles = new HashSet<Tile>();

		public bool IsPaused { get; set; }

		private void OnEnable()
		{
			m_matchPausedEventToken = EventHub.Subscribe<Events.MatchPausedEvent>(OnMatchPaused);
			m_matchResetEventToken = EventHub.Subscribe<Events.MatchResetEvent>(OnMatchReset);
			m_activateDesertDoorsToken = EventHub.Subscribe<Events.ActivateDesertTempleDoorsEvent>(DisableEnvironment);
			switch (m_type)
			{
			case DesertTempleEnvironmentType.Sandstorm:
				m_buildupSandstormDesertTempleToken = EventHub.Subscribe<Events.BuildupSandstormDesertTempleEvent>(BuildupSandstorm);
				m_activateSandstormDesertTempleToken = EventHub.Subscribe<Events.ActivateSandstormDesertTempleEvent>(ActivateSandstorm);
				break;
			case DesertTempleEnvironmentType.Gas:
				m_buildupGasDesertTempleToken = EventHub.Subscribe<Events.BuildupGasDesertTempleEvent>(BuildupGas);
				m_activateGasDesertTempleToken = EventHub.Subscribe<Events.ActivateGasDesertTempleEvent>(ActivateGas);
				break;
			}
		}

		private void OnDisable()
		{
			StopAllCoroutines();
			EventHub.Unsubscribe<Events.MatchPausedEvent>(m_matchPausedEventToken);
			EventHub.Unsubscribe<Events.MatchResetEvent>(m_matchResetEventToken);
			EventHub.Unsubscribe<Events.ActivateDesertTempleDoorsEvent>(m_activateDesertDoorsToken);
			switch (m_type)
			{
			case DesertTempleEnvironmentType.Sandstorm:
				EventHub.Unsubscribe<Events.BuildupSandstormDesertTempleEvent>(m_buildupSandstormDesertTempleToken);
				EventHub.Unsubscribe<Events.ActivateSandstormDesertTempleEvent>(m_activateSandstormDesertTempleToken);
				break;
			case DesertTempleEnvironmentType.Gas:
				EventHub.Unsubscribe<Events.ActivateGasDesertTempleEvent>(m_activateGasDesertTempleToken);
				EventHub.Unsubscribe<Events.BuildupGasDesertTempleEvent>(m_buildupGasDesertTempleToken);
				break;
			}
		}

		private void BuildupSandstorm(Events.BuildupSandstormDesertTempleEvent eventData)
		{
			SetRenderersEnabled(enable: true);
			FadeInSound();
			EnableMaterials(enable: true, eventData.JourneyTime);
			if (m_startUpEffect != null)
			{
				m_startUpEffect.Play();
			}
		}

		private void BuildupGas(Events.BuildupGasDesertTempleEvent eventData)
		{
			SetRenderersEnabled(enable: true);
			FadeInSound();
			EnableMaterials(enable: true, eventData.JourneyTime);
			if (m_startUpEffect != null)
			{
				m_startUpEffect.Play();
			}
		}

		private void SetRenderersEnabled(bool enable)
		{
			foreach (MeshRenderer effectRenderer in m_effectRenderers)
			{
				effectRenderer.enabled = enable;
			}
			foreach (ParticleSystem effectParticleSystem in m_effectParticleSystems)
			{
				if (enable)
				{
					effectParticleSystem.Play();
				}
				else
				{
					effectParticleSystem.Stop();
				}
			}
		}

		private void ActivateSandstorm(Events.ActivateSandstormDesertTempleEvent eventData)
		{
			m_journeyTime = eventData.JourneyTime;
			StartSandstormMovement(eventData.CurrentMatchTime);
		}

		private void ActivateGas(Events.ActivateGasDesertTempleEvent eventData)
		{
			m_journeyTime = eventData.JourneyTime;
			StartSandstormMovement(eventData.CurrentMatchTime);
		}

		private void DisableEnvironment(Events.ActivateDesertTempleDoorsEvent eventData)
		{
			if (eventData.Enable || eventData.EnvironmentType != m_type)
			{
				return;
			}
			FadeOutSound();
			Task.Delay(10000).ContinueWith(delegate
			{
				EnableMaterials(enable: false, 0f);
				if (m_startUpEffect != null)
				{
					m_startUpEffect.Stop();
				}
				SetRenderersEnabled(enable: false);
				ResetBotAvoidance();
			}, TaskScheduler.FromCurrentSynchronizationContext());
		}

		private void ResetBotAvoidance()
		{
			foreach (Tile unsafeTile in m_unsafeTiles)
			{
				Events.TilePredictedSafeEvent tilePredictedSafeEvent = new Events.TilePredictedSafeEvent();
				tilePredictedSafeEvent.Tile = m_nextTile;
				EventHub.Publish(tilePredictedSafeEvent);
			}
			m_unsafeTiles.Clear();
		}

		private void Start()
		{
			m_rigidbody = GetComponent<Rigidbody>();
			if (m_affectableTiles.IsNullOrEmpty())
			{
				SetupAffectableTiles();
			}
			if (m_effectMaterials.IsNullOrEmpty())
			{
				WandsLogger.LogError("DesertTempleEnvironment | m_sandStormMaterials[0] is null, cannot reset alpha on shared material.");
			}
			else
			{
				Color color = m_effectMaterials[0].GetColor("_TintColor");
				color.a = 0f;
				m_effectMaterials[0].SetColor("_TintColor", color);
			}
			m_startPosition = base.transform.position;
			if (m_startUpEffect != null)
			{
				m_startUpEffect.Stop();
			}
		}

		public void Pause(bool pause)
		{
			IsPaused = pause;
		}

		private void OnMatchPaused(Events.MatchPausedEvent eventData)
		{
			Pause(eventData.IsPaused);
		}

		private void SetupAffectableTiles()
		{
			m_affectableTiles = ((m_type != 0) ? m_desertController.InsideTiles : m_desertController.OutsideTiles);
			m_affectableTiles.QuickSort((Tile tile) => tile.transform.position.x);
		}

		public virtual void OnMatchReset(Events.MatchResetEvent eventData)
		{
			m_isBotMatch = PunSingleton<SceneControl>.Instance.CurrentMatchType == MatchType.Bot;
			if (m_isBotMatch)
			{
				m_safetyDistance = ((!m_isBotMatch) ? 0f : 10f);
			}
			ResetTilesAndMovePlayer();
		}

		private void StartSandstormMovement(float currentRoomTime)
		{
			if (m_affectableTiles.IsNullOrEmpty())
			{
				SetupAffectableTiles();
			}
			m_nextTile = m_affectableTiles[m_tileCounter];
			base.transform.position = m_startPosition;
			m_startTime = currentRoomTime;
			m_movePercentage = 0f;
			m_followPath = true;
		}

		private void FixedUpdate()
		{
			if (!IsPaused && m_followPath)
			{
				m_movePercentage = (PunSingleton<TimeManager>.Instance.CurrentMatchTime - m_startTime) / m_journeyTime;
				m_rigidbody.MovePosition(Vector3.Lerp(m_startPosition, m_endPosition, m_movePercentage));
				DetectCollision();
				if (m_movePercentage >= 1f)
				{
					m_followPath = false;
				}
			}
		}

		private void DetectCollision()
		{
			if (m_nextTile == null || !(m_nextTile.transform.position.x < base.transform.position.x + m_safetyDistance))
			{
				return;
			}
			if (m_isBotMatch && m_nextTile.transform.position.x > base.transform.position.x)
			{
				if (m_unsafeTiles.Add(m_nextTile))
				{
					Events.TilePredictedUnsafeEvent tilePredictedUnsafeEvent = new Events.TilePredictedUnsafeEvent();
					tilePredictedUnsafeEvent.Tile = m_nextTile;
					EventHub.Publish(tilePredictedUnsafeEvent);
				}
				return;
			}
			TileDamageOccupier tileDamageOccupier = m_desertController.GrabFromPool();
			if (!(tileDamageOccupier == null))
			{
				tileDamageOccupier.EnableObject(m_nextTile.transform.position, m_nextTile.photonView.ViewID, (int)m_effectType);
				m_tileCounter++;
				if (m_tileCounter < m_affectableTiles.Length)
				{
					m_nextTile = m_affectableTiles[m_tileCounter];
				}
				else
				{
					m_nextTile = null;
				}
			}
		}

		private void ResetTilesAndMovePlayer()
		{
			MatchType? matchType = PunSingleton<SceneControl>.Instance?.CurrentMatchType;
			if (matchType.GetValueOrDefault() == MatchType.Exploration && matchType.HasValue && m_tileCounter != 0)
			{
				if (m_affectableTiles.IsNullOrEmpty())
				{
					SetupAffectableTiles();
				}
				if (m_affectableTiles.Contains(PlayerManager.Instance.PlayerControl.GetCurrentTile()))
				{
					m_desertController.OccupyTiles(TileOccupyState.Locked, m_affectableTiles);
					Tile[] tiles = ((m_type != 0) ? m_desertController.TreasureTiles : m_desertController.InsideTiles);
					Wielder localWielder = PlayerManager.Instance.LocalWielder;
					localWielder.TeleportRandomly(tiles);
				}
			}
		}

		private void EnableMaterials(bool enable, float waitTime)
		{
			foreach (Material effectMaterial in m_effectMaterials)
			{
				effectMaterial.DOKill();
				effectMaterial.DOFade(enable ? 1 : 0, "_TintColor", waitTime);
			}
		}

		private void FadeInSound()
		{
			if (!(m_loopingAudioSource == null))
			{
				m_loopingAudioSource.volume = 0f;
				m_loopingAudioSource.Play();
				m_loopingAudioSource.DOFade(1f, 10f);
			}
		}

		private void FadeOutSound()
		{
			if (m_loopingAudioSource != null)
			{
				m_loopingAudioSource.DOFade(0f, 10f).OnComplete(StopSound);
			}
		}

		private void StopSound()
		{
			if (!(m_loopingAudioSource == null))
			{
				m_loopingAudioSource.Stop();
				m_loopingAudioSource.clip.UnloadAudioData();
			}
		}
	}
	[RequireComponent(typeof(PhotonView))]
	public class DoorHandler : MonoBehaviourPun
	{
		[Header("Animators")]
		[SerializeField]
		private Animator m_outsideDoor;

		[SerializeField]
		private Animator m_insideDoor;

		[Header("Sound players")]
		[SerializeField]
		private AudioSource m_effectAudioSource;

		[SerializeField]
		private AudioClip[] m_effectAudioClips = Array.Empty<AudioClip>();

		[SerializeField]
		private AudioSource m_backgroundEffectAudioSource;

		[SerializeField]
		private SplitAudioSoundPlayer m_outsideDoorSfx;

		[SerializeField]
		private SplitAudioSoundPlayer m_insideDoorSfx;

		private EventToken m_activateDesertDoorsToken;

		private void OnEnable()
		{
			m_activateDesertDoorsToken = EventHub.Subscribe<Events.ActivateDesertTempleDoorsEvent>(ActivateDoors);
			if (m_effectAudioClips.IsNullOrEmpty())
			{
				WandsLogger.LogError("No audio clips available");
				return;
			}
			if (m_effectAudioClips.Length != Enum.GetValues(typeof(GateSoundClipType)).Length)
			{
				WandsLogger.LogError("Expected number of audio clips did not match actual number");
				return;
			}
			AudioClip[] effectAudioClips = m_effectAudioClips;
			for (int i = 0; i < effectAudioClips.Length; i++)
			{
				effectAudioClips[i]?.LoadAudioData();
			}
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe<Events.ActivateDesertTempleDoorsEvent>(m_activateDesertDoorsToken);
			AudioClip[] effectAudioClips = m_effectAudioClips;
			for (int i = 0; i < effectAudioClips.Length; i++)
			{
				effectAudioClips[i]?.UnloadAudioData();
			}
		}

		private void ActivateDoors(Events.ActivateDesertTempleDoorsEvent eventData)
		{
			float delay = ((!eventData.Enable) ? 0f : 18f);
			float duration = ((!eventData.Enable) ? 10f : 7f);
			string trigger = ((!eventData.Enable) ? "Close" : "Open");
			switch (eventData.EnvironmentType)
			{
			case DesertTempleEnvironmentType.Gas:
				if (eventData.Enable)
				{
					MoveAndPlayDoorActivationClip(m_insideDoor.transform);
				}
				m_insideDoor.SetTrigger(trigger);
				m_insideDoorSfx.PlaySplitAudio(delay, duration);
				break;
			case DesertTempleEnvironmentType.Sandstorm:
				if (eventData.Enable)
				{
					MoveAndPlayDoorActivationClip(m_outsideDoor.transform);
				}
				m_outsideDoor.SetTrigger(trigger);
				m_outsideDoorSfx.PlaySplitAudio(delay, duration);
				break;
			}
		}

		private void MoveAndPlayDoorActivationClip(Transform tf)
		{
			m_effectAudioSource.transform.position = tf.transform.position;
			m_backgroundEffectAudioSource.transform.position = tf.transform.position;
			m_backgroundEffectAudioSource.Play();
		}

		public void PlaySoundEffect(GateSoundClipType clipType)
		{
			PlayAudioClip(m_effectAudioClips[(int)clipType]);
		}

		private void PlayAudioClip(AudioClip clip)
		{
			if (clip == null)
			{
				WandsLogger.LogError("Audio clip was null");
				return;
			}
			if (m_effectAudioSource.isPlaying)
			{
				m_effectAudioSource.Stop();
			}
			m_effectAudioSource.clip = clip;
			m_effectAudioSource.Play();
		}
	}
	public class LocalMove : MonoBehaviour
	{
		public float m_speedMp = 1f;

		public float m_moveValue = 0.01f;

		public void Update()
		{
			float y = Mathf.Sin(Time.time * m_speedMp) * m_moveValue;
			base.transform.localPosition = new Vector3(0f, y, 0f);
		}
	}
	[RequireComponent(typeof(PhotonView), typeof(Rigidbody))]
	public class Move : MonoBehaviourPun, IPauseObject
	{
		[Header("Move")]
		[SerializeField]
		private Vector3 m_endPosOffset = Vector3.zero;

		[SerializeField]
		protected float m_moveTime = 12f;

		[SerializeField]
		protected bool m_networkSync = true;

		[Header("Sound")]
		[SerializeField]
		private bool m_playSound = true;

		[SerializeField]
		private AudioSource[] m_audioSources = Array.Empty<AudioSource>();

		protected Rigidbody m_rigidBody;

		protected bool m_move;

		protected int m_moveIndex;

		protected float m_startTime;

		private Vector3 m_startPosition;

		private Vector3 m_endPosition;

		private float m_pauseTime;

		private EventToken m_matchPausedEventToken;

		private EventToken m_matchResetEventToken;

		private EventToken m_matchEndedEventToken;

		public bool IsPaused { get; private set; }

		public bool IsAffectedByEnvironment { get; set; }

		protected virtual void OnEnable()
		{
			m_matchPausedEventToken = EventHub.Subscribe<Events.MatchPausedEvent>(OnMatchPaused);
			m_matchResetEventToken = EventHub.Subscribe<Events.MatchResetEvent>(OnMatchReset);
			m_matchEndedEventToken = EventHub.Subscribe<Events.MatchEndedEvent>(OnMatchEnded);
		}

		protected virtual void OnDisable()
		{
			StopAllCoroutines();
			m_move = false;
			EventHub.Unsubscribe<Events.MatchPausedEvent>(m_matchPausedEventToken);
			EventHub.Unsubscribe<Events.MatchResetEvent>(m_matchResetEventToken);
			EventHub.Unsubscribe<Events.MatchEndedEvent>(m_matchEndedEventToken);
		}

		protected virtual void Start()
		{
			m_startPosition = base.transform.position;
			m_endPosition = base.transform.position + m_endPosOffset;
			m_rigidBody = GetComponent<Rigidbody>();
		}

		private void FixedUpdate()
		{
			if (m_move)
			{
				UpdateMove();
			}
		}

		protected virtual void UpdateMove()
		{
			float num = ((!m_networkSync) ? Time.time : PunSingleton<TimeManager>.Instance.CurrentMatchTime) - m_startTime;
			float num2 = Mathf.Clamp01(num / m_moveTime);
			if (m_moveIndex % 2 == 0)
			{
				m_rigidBody.MovePosition(Vector3.Lerp(m_startPosition, m_endPosition, MathUtils.SmoothStep(num2)));
			}
			else
			{
				m_rigidBody.MovePosition(Vector3.Lerp(m_endPosition, m_startPosition, MathUtils.SmoothStep(num2)));
			}
			if (Mathf.Approximately(num2, 1f) && !IsAffectedByEnvironment)
			{
				m_move = false;
				SetMoveProperties((!m_networkSync) ? Time.time : PunSingleton<TimeManager>.Instance.CurrentMatchTime, increaseIndex: true);
				StartMovement();
			}
		}

		protected void OnMatchEnded(Events.MatchEndedEvent eventData)
		{
			StopAllCoroutines();
			m_move = false;
		}

		protected void OnMatchReset(Events.MatchResetEvent eventData)
		{
			if (PhotonNetwork.IsMasterClient)
			{
				base.photonView.RPC("PunInitiateMovement", RpcTarget.AllBufferedViaServer);
			}
		}

		[PunRPC]
		protected void PunInitiateMovement()
		{
			InitiateMovement();
		}

		protected void InitiateMovement()
		{
			IsAffectedByEnvironment = false;
			m_moveIndex = 0;
			SetMoveProperties((!m_networkSync) ? Time.time : PunSingleton<TimeManager>.Instance.CurrentMatchTime);
			StartMovement();
		}

		public virtual void StartMovement()
		{
			PlaySound();
			m_move = true;
		}

		public void PauseMovement()
		{
			m_move = false;
			m_pauseTime = ((!m_networkSync) ? Time.time : PunSingleton<TimeManager>.Instance.CurrentMatchTime) - m_startTime;
			StopSound();
		}

		public void UnPauseMovement()
		{
			SetMoveProperties(((!m_networkSync) ? Time.time : PunSingleton<TimeManager>.Instance.CurrentMatchTime) - m_pauseTime);
			m_move = true;
		}

		private void SetMoveProperties(float time, bool increaseIndex = false)
		{
			m_startTime = time;
			if (increaseIndex)
			{
				m_moveIndex++;
			}
		}

		protected void PlaySound()
		{
			if (!m_playSound)
			{
				return;
			}
			if (m_audioSources.IsNullOrEmpty())
			{
				m_audioSources = GetComponentsInChildren<AudioSource>();
			}
			if (m_audioSources.Length == 1)
			{
				m_audioSources[0].Play();
			}
			else if (m_audioSources.Length > 1)
			{
				for (int i = 0; i < m_audioSources.Length; i++)
				{
					m_audioSources[i].Play();
				}
			}
		}

		private void StopSound()
		{
			if (m_audioSources.IsNullOrEmpty())
			{
				return;
			}
			if (m_audioSources.Length == 1)
			{
				m_audioSources[0].Stop();
			}
			else if (m_audioSources.Length > 1)
			{
				for (int i = 0; i < m_audioSources.Length; i++)
				{
					m_audioSources[i].Stop();
				}
			}
		}

		public void Pause(bool pause)
		{
			IsPaused = pause;
			if (pause)
			{
				PauseMovement();
			}
			else
			{
				UnPauseMovement();
			}
		}

		private void OnMatchPaused(Events.MatchPausedEvent eventData)
		{
			Pause(eventData.IsPaused);
		}
	}
	[RequireComponent(typeof(AudioSource))]
	public class Portal : MonoBehaviour
	{
		[StructLayout(LayoutKind.Sequential, Size = 1)]
		private struct Multipliers
		{
			public const float Mana = 1.5f;

			public const float Damage = 2f;
		}

		[SerializeField]
		private Tile m_connectedTile;

		[SerializeField]
		private GameObject m_portalEffects;

		private Wielder m_portalWielder;

		private CharacterControl m_characterControl;

		private AudioSource m_audioSource;

		private EventToken m_sceneLoadInitiatedEventToken;

		private void OnEnable()
		{
			m_sceneLoadInitiatedEventToken = EventHub.Subscribe<Events.SceneLoadInitiatedEvent>(OnSceneLoadInitiated);
			m_connectedTile.OnTileOccupied += OnTileOccupied;
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe<Events.SceneLoadInitiatedEvent>(m_sceneLoadInitiatedEventToken);
			m_connectedTile.OnTileOccupied -= OnTileOccupied;
		}

		private void Start()
		{
			m_audioSource = GetComponent<AudioSource>();
		}

		private void OnSceneLoadInitiated(Events.SceneLoadInitiatedEvent eventData)
		{
			SetEnabled(enabled: false);
		}

		private void SetEnabled(bool enabled)
		{
			if (m_characterControl != null)
			{
				m_characterControl.SetManaMultiplier((!enabled) ? 1f : 1.5f);
				m_characterControl.SetDamageReceivedMultiplier((!enabled) ? 1f : 2f);
			}
			if (m_portalWielder != null)
			{
				m_portalWielder.SetCameraEffectActive(EffectType.CelestialPortal, enabled);
			}
			SetPortalVfx(enabled);
		}

		private void OnTileOccupied(bool occupied)
		{
			SetEnabled(enabled: false);
			if (occupied)
			{
				m_portalWielder = m_connectedTile.OccupantWielder;
				m_characterControl = ((!(m_portalWielder != null)) ? null : m_portalWielder.CharacterControl);
				SetEnabled(enabled: true);
			}
			else
			{
				m_portalWielder = null;
				m_characterControl = null;
			}
		}

		private void SetPortalVfx(bool enabled)
		{
			if (!enabled)
			{
				m_portalEffects.transform.SetParent(base.transform);
				m_audioSource.Stop();
				m_portalEffects.SetActive(value: false);
			}
			else if (m_portalWielder != null)
			{
				CapsuleCollider collider = m_portalWielder.GetCollider();
				m_portalEffects.transform.SetParent(collider.transform);
				m_portalEffects.transform.localPosition = collider.center;
				m_audioSource.Play();
				m_portalEffects.SetActive(value: true);
			}
		}
	}
	[RequireComponent(typeof(PhotonView), typeof(Rigidbody), typeof(Renderer))]
	public class RisingLava : MonoBehaviourPun, IPauseObject
	{
		[Header("Movement")]
		[SerializeField]
		private Vector3 m_endPosition = Vector3.zero;

		[SerializeField]
		private float m_waitTimeBeforeRise;

		[SerializeField]
		private float m_riseTime;

		[Header("Damage")]
		[SerializeField]
		private float m_damagePerSecond = 20f;

		[Header("Tiles")]
		[SerializeField]
		private Move m_elevatorMove;

		[SerializeField]
		private Tile m_cellTile;

		private float m_startTime;

		private float m_movePercentage;

		private bool m_followPath;

		private bool m_hasPublishedUnsafeEvent;

		private Vector3 m_startPosition;

		private Renderer m_boxRenderer;

		private Rigidbody m_rigidbody;

		private List<string> m_affectedTiles = new List<string>();

		private TileDamageOccupier m_tileDamageEffect;

		private EventToken m_matchPausedEventToken;

		private EventToken m_matchResetEventToken;

		public bool IsPaused { get; set; }

		private void OnEnable()
		{
			m_matchPausedEventToken = EventHub.Subscribe<Events.MatchPausedEvent>(OnMatchPaused);
			m_matchResetEventToken = EventHub.Subscribe<Events.MatchResetEvent>(OnMatchReset);
		}

		private void OnDisable()
		{
			StopAllCoroutines();
			EventHub.Unsubscribe<Events.MatchPausedEvent>(m_matchPausedEventToken);
			EventHub.Unsubscribe<Events.MatchResetEvent>(m_matchResetEventToken);
		}

		private void Start()
		{
			m_rigidbody = GetComponent<Rigidbody>();
			m_boxRenderer = GetComponent<Renderer>();
			m_startPosition = base.transform.position;
		}

		private void FixedUpdate()
		{
			if (IsPaused || !m_followPath)
			{
				return;
			}
			m_movePercentage = (PunSingleton<TimeManager>.Instance.CurrentMatchTime - m_startTime) / m_riseTime;
			if ((object)m_rigidbody != null)
			{
				m_rigidbody.MovePosition(Vector3.Lerp(m_startPosition, m_endPosition, m_movePercentage));
			}
			if (MonoSingleton<NetworkManager>.Instance.CurrentMatchType.ContainsFlag(MatchType.Bot))
			{
				if (m_movePercentage > 0.5f)
				{
					if (!m_hasPublishedUnsafeEvent)
					{
						Events.TilePredictedUnsafeEvent tilePredictedUnsafeEvent = new Events.TilePredictedUnsafeEvent();
						tilePredictedUnsafeEvent.Tile = m_cellTile;
						EventHub.Publish(tilePredictedUnsafeEvent);
						m_hasPublishedUnsafeEvent = true;
					}
				}
				else if (m_hasPublishedUnsafeEvent)
				{
					Events.TilePredictedSafeEvent tilePredictedSafeEvent = new Events.TilePredictedSafeEvent();
					tilePredictedSafeEvent.Tile = m_cellTile;
					EventHub.Publish(tilePredictedSafeEvent);
					m_hasPublishedUnsafeEvent = false;
				}
			}
			if (m_movePercentage >= 1f)
			{
				m_followPath = false;
			}
			DetectCollision();
		}

		public void Pause(bool pause)
		{
			IsPaused = pause;
		}

		private void OnMatchPaused(Events.MatchPausedEvent eventData)
		{
			Pause(eventData.IsPaused);
		}

		private void OnMatchReset(Events.MatchResetEvent eventData)
		{
			ResetMatch();
			if (m_tileDamageEffect != null)
			{
				m_tileDamageEffect.DisableObject();
			}
			else if (base.photonView.IsMine)
			{
				m_tileDamageEffect = InstantiateTileDamageEffect(m_damagePerSecond, base.photonView.ViewID) as TileDamageOccupier;
			}
		}

		private void ResetMatch()
		{
			ResetTilesAndPlayer();
			StartMovement();
		}

		private void StartMovement()
		{
			m_followPath = false;
			StopAllCoroutines();
			if (PhotonNetwork.IsMasterClient)
			{
				StartCoroutine(MovementCountdown(m_waitTimeBeforeRise));
			}
		}

		private IEnumerator MovementCountdown(float waitTime)
		{
			yield return new CustomWaitForSeconds(waitTime);
			base.photonView.RPC("PunStartLavaMovement", RpcTarget.AllBufferedViaServer, PunSingleton<TimeManager>.Instance.CurrentMatchTime);
		}

		[PunRPC]
		private void PunStartLavaMovement(float currentMatchTime)
		{
			base.transform.position = m_startPosition;
			m_startTime = currentMatchTime;
			m_followPath = true;
		}

		private void DetectCollision()
		{
			if (Physics.BoxCast(m_boxRenderer.bounds.center, m_boxRenderer.bounds.extents, base.transform.forward, out var hitInfo, Quaternion.identity, 0.1f, 1 << LayerMask.NameToLayer("Tile")) && !m_affectedTiles.Contains(hitInfo.collider.name))
			{
				m_affectedTiles.Add(hitInfo.collider.name);
				OccupyTile(hitInfo.collider.GetComponent<Tile>());
			}
		}

		private void OccupyTile(Tile targetedTile)
		{
			if (!(targetedTile != m_cellTile))
			{
				m_elevatorMove.IsAffectedByEnvironment = true;
				if (base.photonView.IsMine)
				{
					m_tileDamageEffect.EnableObject(m_cellTile.transform.position, m_cellTile.photonView.ViewID);
				}
			}
		}

		private void ResetTilesAndPlayer()
		{
			MatchType? matchType = PunSingleton<SceneControl>.Instance?.CurrentMatchType;
			if (matchType.GetValueOrDefault() == MatchType.Exploration && matchType.HasValue && !m_affectedTiles.IsNullOrEmpty())
			{
				m_affectedTiles.Clear();
				Wielder occupantWielder = m_cellTile.OccupantWielder;
				if (occupantWielder != null)
				{
					occupantWielder.TeleportRandomly(PunSingleton<TileManager>.Instance.AllTiles.Exclude(m_cellTile).ToArray());
				}
			}
		}

		private IPoolObject InstantiateTileDamageEffect(params object[] data)
		{
			return NetworkUtils.Instantiate($"Vfx/{PoolObjectType.TileDamageOccupier}", Vector3.zero, Quaternion.identity, 0, data).GetComponent<IPoolObject>();
		}
	}
	public class Rotate : Move
	{
		[SerializeField]
		private enum RotationAxis
		{
			X,
			Y,
			Z
		}

		[SerializeField]
		private RotationAxis m_axis;

		[SerializeField]
		private float m_rotationSpeed = 10f;

		private Quaternion m_startRotation;

		private Quaternion m_endRotation;

		protected override void Start()
		{
			m_rigidBody = GetComponent<Rigidbody>();
			if (m_rigidBody == null)
			{
				WandsLogger.Log("Move object has no RigidBody, disabling rotation script!", base.gameObject, LogType.Warning);
				base.enabled = false;
			}
			m_startRotation = m_rigidBody.rotation;
			m_endRotation = Quaternion.Euler(m_rigidBody.rotation.eulerAngles + new Vector3(0f, 180f, 0f));
		}

		protected override void UpdateMove()
		{
			float num = PunSingleton<TimeManager>.Instance.CurrentMatchTime - m_startTime;
			if (!(num < 0f))
			{
				float num2 = Mathf.Clamp01(num / m_rotationSpeed);
				m_rigidBody.MoveRotation(Quaternion.Slerp(m_startRotation, m_endRotation, num2));
				if (Mathf.Approximately(num2, 1f))
				{
					m_move = false;
					m_rigidBody.rotation = m_startRotation;
					m_startTime = PunSingleton<TimeManager>.Instance.CurrentMatchTime;
					StartMovement();
				}
			}
		}

		public override void StartMovement()
		{
			if (!NetworkUtils.ConnectedToGame)
			{
				m_startTime = Time.time;
			}
			m_move = true;
		}
	}
}
namespace Cortopia.Scripts.Environmental
{
	public class RubiksCube : MonoBehaviourPun
	{
		[SerializeField]
		private Animator m_animator;

		private readonly int AnimatorParamScramble = Animator.StringToHash("Scramble");

		public virtual bool TryScramble()
		{
			Scramble();
			return true;
		}

		protected void Scramble()
		{
			base.photonView.RPC("PunScramble", RpcTarget.AllViaServer);
		}

		public void Unscramble()
		{
			base.photonView.RPC("PunUnscramble", RpcTarget.AllViaServer);
		}

		[PunRPC]
		protected void PunScramble()
		{
			m_animator.SetBool(AnimatorParamScramble, value: true);
		}

		[PunRPC]
		protected virtual void PunUnscramble()
		{
			m_animator.SetBool(AnimatorParamScramble, value: false);
		}
	}
	public class RubiksHandler : MonoBehaviour
	{
		private enum RubiksState
		{
			Disabled,
			Scramble,
			Unscramble
		}

		public const float ScrambleTime = 12f;

		[SerializeField]
		[Range(1f, 5f)]
		private int m_minCubesToScramble = 3;

		[SerializeField]
		private MinMax m_timeBetweenScrambles = new MinMax(15f, 25f);

		[SerializeField]
		private RubiksCube[] m_rubiksCubes = Array.Empty<RubiksCube>();

		private RubiksState m_currentState;

		private IList<RubiksCube> m_scrambledCubes;

		private float m_nextScramble;

		private EventToken m_countdownEndedEventToken;

		private EventToken m_matchEndedEventToken;

		private void OnEnable()
		{
			m_countdownEndedEventToken = EventHub.Subscribe<Events.CountdownEndedEvent>(OnCountdownEnded);
			m_matchEndedEventToken = EventHub.Subscribe<Events.MatchEndedEvent>(OnMatchEnded);
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe(m_countdownEndedEventToken);
			EventHub.Unsubscribe(m_matchEndedEventToken);
		}

		private void Update()
		{
			switch (m_currentState)
			{
			case RubiksState.Scramble:
				if (!(PunSingleton<TimeManager>.Instance.CurrentMatchTime < m_nextScramble))
				{
					ScrambleCubes();
					SetNextUnscramble();
				}
				break;
			case RubiksState.Unscramble:
				if (!(PunSingleton<TimeManager>.Instance.CurrentMatchTime < m_nextScramble))
				{
					UnscrambleCubes();
					SetNextScramble();
				}
				break;
			}
		}

		private void OnCountdownEnded(Events.CountdownEndedEvent eventData)
		{
			if (PhotonNetwork.IsMasterClient)
			{
				m_scrambledCubes = new List<RubiksCube>(m_rubiksCubes.Length);
				SetNextScramble();
			}
		}

		private void OnMatchEnded(Events.MatchEndedEvent eventData)
		{
			m_currentState = RubiksState.Disabled;
		}

		private void SetNextScramble()
		{
			m_nextScramble = PunSingleton<TimeManager>.Instance.CurrentMatchTime + UnityEngine.Random.Range(m_timeBetweenScrambles.Min, m_timeBetweenScrambles.Max);
			m_currentState = RubiksState.Scramble;
		}

		private void SetNextUnscramble()
		{
			m_nextScramble = PunSingleton<TimeManager>.Instance.CurrentMatchTime + 12f;
			m_currentState = RubiksState.Unscramble;
		}

		private void ScrambleCubes()
		{
			m_scrambledCubes.Clear();
			RubiksCube[] array = m_rubiksCubes.GetRandomElements(UnityEngine.Random.Range(m_minCubesToScramble, m_rubiksCubes.Length)).ToArray();
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i].TryScramble())
				{
					m_scrambledCubes.Add(array[i]);
				}
			}
		}

		private void UnscrambleCubes()
		{
			for (int i = 0; i < m_scrambledCubes.Count; i++)
			{
				m_scrambledCubes[i].Unscramble();
			}
		}
	}
	public class RubiksTile : RubiksCube
	{
		[SerializeField]
		private Tile m_tile;

		public override bool TryScramble()
		{
			if (m_tile.IsOccupied)
			{
				return false;
			}
			PunSingleton<TileManager>.Instance.OccupyTile(m_tile, TileOccupyState.Locked, base.photonView, delegate(Tile tile, bool occupySuccessful)
			{
				OnOccupyDone(occupySuccessful);
			});
			return true;
		}

		[PunRPC]
		protected override void PunUnscramble()
		{
			base.PunUnscramble();
			if (base.photonView.IsMine)
			{
				PunSingleton<TileManager>.Instance.OccupyTile(m_tile, TileOccupyState.Unoccupied, base.photonView, null, buffered: false, forced: true);
			}
		}

		private void OnOccupyDone(bool occupySuccessful)
		{
			if (occupySuccessful)
			{
				Scramble();
			}
		}
	}
}
namespace Assets.Scripts.Environmental
{
	public class ScrollingUVs : MonoBehaviour
	{
		public int materialIndex;

		public Vector2 uvAnimationRate = new Vector2(1f, 0f);

		public string textureName = "_MainTex";

		private Renderer _renderer;

		private Vector2 _uvOffset;

		private void Start()
		{
			_renderer = GetComponent<Renderer>();
		}

		private void LateUpdate()
		{
			if (!(_renderer == null))
			{
				_uvOffset += uvAnimationRate * Time.deltaTime;
				if (_renderer.enabled)
				{
					_renderer.materials[materialIndex].SetTextureOffset(textureName, _uvOffset);
				}
			}
		}
	}
	[RequireComponent(typeof(PhotonView))]
	public class Skeleton : MonoBehaviourPun, IPauseObject
	{
		[SerializeField]
		private float m_waitForApperance = 60f;

		[SerializeField]
		private Animator m_skeletonAnimator;

		[SerializeField]
		private SkeletonAnimationEvents m_skeletonAnimationEvents;

		[SerializeField]
		private Tile[] m_targetedTiles = Array.Empty<Tile>();

		[Header("Shooting")]
		[SerializeField]
		private Transform m_projectileSpawnPoint;

		[SerializeField]
		private float m_fireInterval = 25f;

		[SerializeField]
		private int m_projectileDamage = 10;

		[SerializeField]
		private float m_projectileSpeed = 0.5f;

		[SerializeField]
		private float m_aimProjectileSpeed = 10f;

		private float m_entraceTime;

		private float m_fireTime;

		private ProjectileMover m_projectile;

		private ProjectileMoverEnvironment m_trailRendererPoolObject;

		private EventToken m_matchPausedEventToken;

		private EventToken m_matchResetEventToken;

		private EventToken m_matchEndedEventToken;

		public bool IsPaused { get; set; }

		public float FireTime
		{
			[CompilerGenerated]
			get
			{
				return PunSingleton<TimeManager>.Instance.CurrentRoomTime + 0.15f;
			}
		}

		private void OnEnable()
		{
			m_matchPausedEventToken = EventHub.Subscribe<Events.MatchPausedEvent>(OnMatchPaused);
			m_matchResetEventToken = EventHub.Subscribe<Events.MatchResetEvent>(OnMatchReset);
			m_matchEndedEventToken = EventHub.Subscribe<Events.MatchEndedEvent>(OnMatchEnded);
		}

		private void OnDisable()
		{
			StopAllCoroutines();
			EventHub.Unsubscribe<Events.MatchPausedEvent>(m_matchPausedEventToken);
			EventHub.Unsubscribe<Events.MatchResetEvent>(m_matchResetEventToken);
			EventHub.Unsubscribe<Events.MatchEndedEvent>(m_matchEndedEventToken);
		}

		private void Start()
		{
			m_entraceTime = m_skeletonAnimator.runtimeAnimatorController.animationClips[0].length;
			m_fireTime = m_skeletonAnimator.runtimeAnimatorController.animationClips[2].length * 0.73f;
		}

		public void Pause(bool pause)
		{
			IsPaused = pause;
		}

		private void OnMatchPaused(Events.MatchPausedEvent eventData)
		{
			Pause(eventData.IsPaused);
		}

		private void OnMatchReset(Events.MatchResetEvent eventData)
		{
			m_skeletonAnimationEvents.Reset();
			StopAllCoroutines();
			m_projectile = InstantiateProjectile() as ProjectileMover;
			m_trailRendererPoolObject = InstantiateProjectileTrail() as ProjectileMoverEnvironment;
			m_trailRendererPoolObject.TrailRenderer.time = m_fireTime / 3f;
			if (PhotonNetwork.IsMasterClient)
			{
				StartCoroutine(SkeletonController(m_waitForApperance));
			}
		}

		private void OnMatchEnded(Events.MatchEndedEvent eventData)
		{
			StopAllCoroutines();
		}

		private IEnumerator SkeletonController(float waitTime)
		{
			yield return new CustomWaitForSeconds(waitTime);
			base.photonView.RPC("PunShowSkeleton", RpcTarget.AllBufferedViaServer);
			yield return new CustomWaitForSeconds(m_entraceTime);
			while (true)
			{
				yield return new CustomWaitForSeconds(m_fireInterval - m_fireTime);
				Vector3 selectedTilePosition = m_targetedTiles.GetRandomElement().transform.position + new Vector3(0f, 1.3f, 0f);
				Vector3[] arcPoints = new Vector3[3]
				{
					m_projectileSpawnPoint.position,
					MathUtils.GetMidPoint(m_projectileSpawnPoint.position, selectedTilePosition),
					selectedTilePosition
				};
				base.photonView.RPC("PunFireWarningShoot", RpcTarget.AllViaServer, arcPoints);
				yield return new CustomWaitForSeconds(m_fireTime);
				base.photonView.RPC("PunFireProjectile", RpcTarget.AllViaServer, arcPoints);
			}
		}

		[PunRPC]
		private void PunFireWarningShoot(Vector3[] arcPoints)
		{
			m_skeletonAnimator.SetTrigger("Fire");
			if (PhotonNetwork.IsMasterClient)
			{
				m_trailRendererPoolObject.EnableObject(arcPoints[0], FireTime, 1, 0, arcPoints, m_aimProjectileSpeed, 0);
			}
		}

		[PunRPC]
		private void PunFireProjectile(Vector3[] arcPoints)
		{
			m_skeletonAnimator.SetTrigger("Idle");
			if (PhotonNetwork.IsMasterClient)
			{
				m_projectile.EnableObject(arcPoints[0], FireTime, 1, 0, arcPoints, m_projectileSpeed, m_projectileDamage);
			}
		}

		[PunRPC]
		private void PunShowSkeleton()
		{
			m_skeletonAnimationEvents.gameObject.SetActive(value: true);
		}

		private IPoolObject InstantiateProjectile(params object[] data)
		{
			return NetworkUtils.Instantiate(PoolObjectType.SkeletonProjectile.ToString(), Vector3.zero, Quaternion.identity, 0, data).GetComponent<IPoolObject>();
		}

		private IPoolObject InstantiateProjectileTrail(params object[] data)
		{
			return NetworkUtils.Instantiate("Vfx/" + PoolObjectType.TrailProjectile, Vector3.zero, Quaternion.identity, 0, data).GetComponent<IPoolObject>();
		}
	}
	public class SkeletonAnimationEvents : MonoBehaviour
	{
		[SerializeField]
		private AudioSource[] m_dropAudioSources;

		[SerializeField]
		private AudioClip[] m_skeletonAudioClips;

		[SerializeField]
		private AudioClip[] m_breathingClips;

		private AudioSource MainAudioSource => m_dropAudioSources[0];

		public void Reset()
		{
			AudioSource[] dropAudioSources = m_dropAudioSources;
			foreach (AudioSource audioSource in dropAudioSources)
			{
				audioSource.Stop();
			}
			base.gameObject.SetActive(value: false);
		}

		public void PlayAudio(int value)
		{
			AudioSource audioSource = GetAudioSource();
			if (audioSource != null)
			{
				audioSource.clip = m_skeletonAudioClips[value];
				audioSource.Play();
			}
		}

		public void Breathing()
		{
			MainAudioSource.Stop();
			MainAudioSource.clip = m_breathingClips.GetRandomElement();
			MainAudioSource.Play();
		}

		public void Shoot()
		{
			MainAudioSource.Stop();
			MainAudioSource.clip = m_skeletonAudioClips[7];
			MainAudioSource.Play();
		}

		private AudioSource GetAudioSource()
		{
			AudioSource[] dropAudioSources = m_dropAudioSources;
			foreach (AudioSource audioSource in dropAudioSources)
			{
				if (!audioSource.isPlaying)
				{
					return audioSource;
				}
			}
			WandsLogger.Log("All AudioSources is busy!", LogType.Warning);
			return null;
		}
	}
	public class TileDamageOccupier : MonoBehaviourPun, IPunInstantiateMagicCallback, IPoolObject, IPauseObject
	{
		private float m_damagePerSecond;

		private Tile m_connectedTile;

		private Wielder m_targetWielder;

		private Summoned m_summoned;

		private bool m_shouldEnableEffectWhenDamaging;

		private bool m_isBeingDestroyed;

		private EffectType m_effectType;

		private EventToken m_pauseGameEventToken;

		private EventToken m_unpauseGameEventToken;

		public bool IsPaused { get; set; }

		public bool IsActive { get; private set; }

		private void OnEnable()
		{
			m_unpauseGameEventToken = EventHub.Subscribe<Events.MatchPausedEvent>(OnMatchPaused);
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe<Events.MatchPausedEvent>(m_unpauseGameEventToken);
		}

		private void OnDestroy()
		{
			m_isBeingDestroyed = true;
		}

		private void OnMatchPaused(Events.MatchPausedEvent eventData)
		{
			Pause(eventData.IsPaused);
		}

		public void Pause(bool pause)
		{
			IsPaused = pause;
		}

		public void OnPhotonInstantiate(PhotonMessageInfo info)
		{
			if (!m_isBeingDestroyed)
			{
				m_damagePerSecond = (float)base.photonView.InstantiationData[0];
				base.transform.SetParent(ObjectPoolHandler.PoolParent);
				DisableObject();
			}
		}

		private void LateUpdate()
		{
			if (!IsPaused)
			{
				if (m_targetWielder != null)
				{
					m_targetWielder.TakeDamage(DamageType.Continuous, m_damagePerSecond * Time.deltaTime, Vector2.up);
				}
				else if (m_summoned != null)
				{
					m_summoned.OnHit(m_damagePerSecond * Time.deltaTime);
				}
			}
		}

		public void EnableObject(Vector3 position, params object[] data)
		{
			if (!m_isBeingDestroyed)
			{
				IsActive = true;
				base.photonView.RPC("PunEnableObject", RpcTarget.AllViaServer, position, data);
			}
		}

		[PunRPC]
		private void PunEnableObject(Vector3 position, params object[] data)
		{
			base.transform.position = position;
			base.gameObject.SetActive(value: true);
			m_connectedTile = PhotonView.Find((int)data[0]).GetComponent<Tile>();
			m_connectedTile.OnTileOccupied += OnTileOccupied;
			if (data.Length > 1)
			{
				m_shouldEnableEffectWhenDamaging = true;
				m_effectType = (EffectType)(int)data[1];
			}
			else
			{
				m_shouldEnableEffectWhenDamaging = false;
			}
			if (m_connectedTile.IsUnoccupied)
			{
				PunSingleton<TileManager>.Instance.OccupyTile(m_connectedTile, TileOccupyState.Locked, base.photonView, null, buffered: false, forced: true);
			}
			else if (m_connectedTile.IsOccupied)
			{
				TileOccupy();
			}
		}

		private void OnTileOccupied(bool occupy)
		{
			if (occupy)
			{
				TileOccupy();
			}
			else
			{
				TileUnoccupy();
			}
		}

		private void TileOccupy()
		{
			if ((((object)m_connectedTile == null) ? null : m_connectedTile.Occupant?.Owner) == null || !m_connectedTile.Occupant.Owner.IsLocal)
			{
				return;
			}
			if (m_connectedTile.OccupantWielder != null)
			{
				Wielder occupantWielder = m_connectedTile.OccupantWielder;
				if (m_shouldEnableEffectWhenDamaging && m_targetWielder != occupantWielder)
				{
					occupantWielder.SetCameraEffectActive(m_effectType, active: true);
				}
				m_targetWielder = occupantWielder;
			}
			else if (m_connectedTile.OccupantTwin != null)
			{
				m_connectedTile.OccupantTwin.OnHit();
			}
			else if (m_connectedTile.IsEffectActive)
			{
				m_summoned = m_connectedTile.Occupant.GetComponent<Summoned>();
				if (m_summoned == null)
				{
					m_connectedTile.RemoveActiveTraps();
				}
			}
			PunSingleton<TileManager>.Instance.TrySetTileAvailable(m_connectedTile);
		}

		private void TileUnoccupy()
		{
			ResetTarget();
			if (!m_isBeingDestroyed)
			{
				PunSingleton<TileManager>.Instance.OccupyTile(m_connectedTile, TileOccupyState.Locked, base.photonView, null, buffered: false, forced: true);
			}
		}

		public void DisableObject()
		{
			if (m_connectedTile != null)
			{
				m_connectedTile.OnTileOccupied -= OnTileOccupied;
				PunSingleton<TileManager>.Instance.OccupyTile(m_connectedTile, TileOccupyState.Unoccupied, null, null, buffered: false, forced: true);
				m_connectedTile = null;
			}
			ResetTarget();
			base.gameObject.SetActive(value: false);
			IsActive = false;
		}

		private void ResetTarget()
		{
			if (!(m_targetWielder == null))
			{
				if (m_shouldEnableEffectWhenDamaging)
				{
					m_targetWielder.SetCameraEffectActive(m_effectType, active: false);
				}
				Wielder targetWielder = m_targetWielder;
				m_targetWielder = null;
				targetWielder.AbortContinuousHit();
			}
		}

		PhotonView IPoolObject.get_photonView()
		{
			return base.photonView;
		}
	}
	[RequireComponent(typeof(PhotonView), typeof(AudioSource), typeof(Rigidbody))]
	public class Train : MonoBehaviourPun, IPauseObject
	{
		[SerializeField]
		private Transform[] m_wheels = Array.Empty<Transform>();

		[SerializeField]
		private LoadSfx[] m_cartSfxHandlers = Array.Empty<LoadSfx>();

		[SerializeField]
		private GameObject m_pickUpCart;

		[SerializeField]
		private PickupBase m_pickUp;

		[Header("Movement")]
		[SerializeField]
		private Vector3 m_endPosition = Vector3.zero;

		[SerializeField]
		private AnimationCurve m_speedMultiplier = AnimationCurve.Linear(0f, 0f, 1f, 1f);

		[SerializeField]
		private float m_journeyTime;

		[SerializeField]
		private float m_wheelRotationPerFrame;

		[Header("Sounds")]
		[SerializeField]
		private AudioClip[] m_audioClips = Array.Empty<AudioClip>();

		private bool m_playedStopSound;

		private bool m_playedStartSound;

		private Vector3 m_startPosition;

		private float m_startTime;

		private float m_journeyLength;

		private bool m_followPath;

		private Rigidbody m_rigidbody;

		private AudioSource m_audioSource;

		private float m_nextPosition;

		private bool m_isStopping;

		private Vector3 m_previousPosition;

		private EventToken m_matchPausedEventToken;

		private EventToken m_matchResetEventToken;

		private EventToken m_matchEndedEventToken;

		public bool IsPaused { get; set; }

		private void OnEnable()
		{
			m_matchPausedEventToken = EventHub.Subscribe<Events.MatchPausedEvent>(OnMatchPaused);
			m_matchResetEventToken = EventHub.Subscribe<Events.MatchResetEvent>(OnMatchReset);
			m_matchEndedEventToken = EventHub.Subscribe<Events.MatchEndedEvent>(OnMatchEnded);
		}

		private void OnDisable()
		{
			StopAllCoroutines();
			EventHub.Unsubscribe<Events.MatchPausedEvent>(m_matchPausedEventToken);
			EventHub.Unsubscribe<Events.MatchResetEvent>(m_matchResetEventToken);
			EventHub.Unsubscribe<Events.MatchEndedEvent>(m_matchEndedEventToken);
		}

		private void Start()
		{
			m_rigidbody = GetComponent<Rigidbody>();
			m_audioSource = GetComponent<AudioSource>();
			m_startPosition = base.transform.position;
		}

		public void Pause(bool pause)
		{
			IsPaused = pause;
			LoadSfx[] cartSfxHandlers = m_cartSfxHandlers;
			foreach (LoadSfx loadSfx in cartSfxHandlers)
			{
				loadSfx.SetLoadSourcePaused(pause);
			}
		}

		private void OnMatchPaused(Events.MatchPausedEvent eventData)
		{
			Pause(eventData.IsPaused);
		}

		private void OnMatchReset(Events.MatchResetEvent eventData)
		{
			StartMovement();
		}

		private void OnMatchEnded(Events.MatchEndedEvent eventData)
		{
			StopAllCoroutines();
			m_followPath = false;
		}

		private void StartMovement()
		{
			if (!m_followPath)
			{
				m_followPath = false;
				StopAllCoroutines();
				if (PhotonNetwork.IsMasterClient)
				{
					StartCoroutine(StartMovementCountdown(UnityEngine.Random.Range(4, 12)));
				}
			}
		}

		private IEnumerator StartMovementCountdown(int waitTime)
		{
			yield return new CustomWaitForSeconds(waitTime);
			base.photonView.RPC("PunStartTrainMovement", RpcTarget.AllBufferedViaServer, PunSingleton<TimeManager>.Instance.CurrentMatchTime);
		}

		[PunRPC]
		private void PunStartTrainMovement(float currentRoomTime)
		{
			if (m_pickUp.PickUpObject.gameObject.activeInHierarchy)
			{
				m_isStopping = true;
				m_pickUpCart.SetActive(value: true);
				m_pickUp.transform.SetParent(base.transform, worldPositionStays: false);
			}
			else
			{
				m_isStopping = false;
				m_pickUp.transform.SetParent(null, worldPositionStays: false);
				m_pickUpCart.SetActive(value: false);
			}
			base.transform.position = m_startPosition;
			m_startTime = currentRoomTime;
			m_journeyLength = Vector3.Distance(m_startPosition, m_endPosition);
			m_nextPosition = 0f;
			m_followPath = true;
			m_playedStopSound = false;
			m_rigidbody.position = base.transform.position;
		}

		private void FixedUpdate()
		{
			if (IsPaused || !m_followPath)
			{
				return;
			}
			if (m_isStopping)
			{
				float num = (PunSingleton<TimeManager>.Instance.CurrentMatchTime - m_startTime) / m_journeyTime * (1f - m_speedMultiplier.keys[4].time + m_speedMultiplier.keys[1].time);
				float num2 = m_speedMultiplier.Evaluate(num);
				if (num2 < 0.001f)
				{
					num2 = 0f;
				}
				else if (num2 > 0.99f)
				{
					num2 = 1f;
				}
				m_nextPosition += (num - m_nextPosition) * num2;
				if ((object)m_rigidbody != null)
				{
					m_rigidbody.MovePosition(m_rigidbody.position + m_rigidbody.transform.forward * m_journeyLength / m_journeyTime * num2 * Time.fixedDeltaTime);
				}
				SoundActivation(num);
			}
			else
			{
				m_nextPosition = (PunSingleton<TimeManager>.Instance.CurrentMatchTime - m_startTime) / m_journeyTime;
				if ((object)m_rigidbody != null)
				{
					m_rigidbody.MovePosition(Vector3.Lerp(m_startPosition, m_endPosition, m_nextPosition));
				}
			}
			Transform[] wheels = m_wheels;
			foreach (Transform transform in wheels)
			{
				transform.Rotate(Vector3.right, m_wheelRotationPerFrame * (base.transform.position - m_previousPosition).magnitude);
			}
			m_previousPosition = base.transform.position;
			if (m_nextPosition >= 1f)
			{
				m_followPath = false;
				if (PhotonNetwork.IsMasterClient)
				{
					StartMovement();
				}
			}
		}

		public void SetSfxActive(bool enable, float fadeTime)
		{
			if (!m_cartSfxHandlers.IsNullOrEmpty())
			{
				for (int i = 0; i < m_cartSfxHandlers.Length; i++)
				{
					m_cartSfxHandlers[i].ToggleLoadSource(enable, fadeTime + (float)i);
				}
			}
		}

		private void SoundActivation(float nextPosition)
		{
			if (!m_playedStopSound && nextPosition >= m_speedMultiplier.keys[1].time)
			{
				m_playedStopSound = true;
				m_audioSource.clip = m_audioClips[0];
				m_audioSource.Play();
				SetSfxActive(enable: false, 0.001f);
			}
			if (!m_playedStartSound && nextPosition >= m_speedMultiplier.keys[3].time)
			{
				m_playedStartSound = true;
				m_audioSource.clip = m_audioClips[1];
				m_audioSource.Play();
				SetSfxActive(enable: true, m_audioClips[1].length);
			}
		}
	}
	public class TrainCollider : MonoBehaviour, IPauseObject
	{
		[SerializeField]
		private LayerMask m_collisionMask;

		[SerializeField]
		private bool m_toggleOn;

		[SerializeField]
		private float m_fadeTime = 1f;

		[SerializeField]
		private AudioSource m_audioSource;

		private EventToken m_matchPausedEventToken;

		public bool IsPaused { get; set; }

		private void OnEnable()
		{
			m_matchPausedEventToken = EventHub.Subscribe<Events.MatchPausedEvent>(OnMatchPaused);
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe<Events.MatchPausedEvent>(m_matchPausedEventToken);
		}

		public void Pause(bool pause)
		{
			IsPaused = true;
			if (!(m_audioSource == null))
			{
				if (pause)
				{
					m_audioSource.Pause();
				}
				else
				{
					m_audioSource.UnPause();
				}
			}
		}

		private void OnMatchPaused(Events.MatchPausedEvent eventData)
		{
			Pause(eventData.IsPaused);
		}

		private void OnTriggerEnter(Collider collider)
		{
			if (collider.gameObject.layer == base.gameObject.layer)
			{
				if (m_fadeTime > 0f)
				{
					collider.GetComponent<Train>()?.SetSfxActive(m_toggleOn, m_fadeTime);
				}
				if (m_audioSource != null && !m_audioSource.isPlaying)
				{
					m_audioSource.Play();
				}
			}
		}
	}
	public class TrainHandler : Move
	{
		[Header("Train")]
		[SerializeField]
		private Rigidbody[] m_trains = Array.Empty<Rigidbody>();

		[SerializeField]
		private Vector3[] m_endPosOffsets = Array.Empty<Vector3>();

		[SerializeField]
		[Range(15f, 40f)]
		private float m_randomMoveTimeMin = 15f;

		[SerializeField]
		[Range(15f, 40f)]
		private float m_randomMoveTimeMax = 20f;

		private float[] m_moveTimes;

		private Vector3[] m_startPositions;

		private Vector3[] m_endPositions;

		protected override void Start()
		{
			m_startPositions = new Vector3[m_trains.Length];
			m_endPositions = new Vector3[m_trains.Length];
			m_moveTimes = new float[m_trains.Length];
			for (int i = 0; i < m_trains.Length; i++)
			{
				ref Vector3 reference = ref m_startPositions[i];
				reference = m_trains[i].position;
				ref Vector3 reference2 = ref m_endPositions[i];
				reference2 = m_trains[i].position + m_endPosOffsets[i];
			}
		}

		protected override void UpdateMove()
		{
			for (int i = 0; i < m_trains.Length; i++)
			{
				float num = PunSingleton<TimeManager>.Instance.CurrentMatchTime - GetCurrentMoveTime(i);
				float num2 = Mathf.Clamp01(num / GetMoveTime(i));
				m_trains[i].MovePosition(Vector3.Lerp(m_startPositions[i], m_endPositions[i], MathUtils.SmoothStep(num2)));
				if (Mathf.Approximately(num2, 1f))
				{
					m_move = false;
					SetMoveProperties(i);
					StartMovement(i);
				}
			}
		}

		public override void StartMovement()
		{
			for (int i = 0; i < m_trains.Length; i++)
			{
				SetMoveProperties(i);
				StartMovement(i);
			}
		}

		private void StartMovement(int index)
		{
			if (m_trains != null && m_trains.Length > index)
			{
				m_trains[index].gameObject.SetActive(value: false);
				m_trains[index].position = m_startPositions[index];
				m_trains[index].gameObject.SetActive(value: true);
				m_move = true;
			}
		}

		private void SetMoveProperties(int index)
		{
			if (PhotonNetwork.IsMasterClient)
			{
				ExitGames.Client.Photon.Hashtable hashtable = new ExitGames.Client.Photon.Hashtable();
				hashtable.Add($"MT{index}", PunSingleton<TimeManager>.Instance.CurrentMatchTime);
				hashtable.Add($"MT{index + m_trains.Length}", SetGetMoveTime(index));
				ExitGames.Client.Photon.Hashtable propertiesToSet = hashtable;
				PhotonNetwork.CurrentRoom.SetCustomProperties(propertiesToSet);
			}
		}

		private float SetGetMoveTime(int index)
		{
			float num = UnityEngine.Random.Range(m_randomMoveTimeMin, m_randomMoveTimeMax);
			m_moveTimes[index] = ((!(num > 0f)) ? m_moveTime : num);
			return m_moveTimes[index];
		}

		private float GetCurrentMoveTime(int index)
		{
			return (float)PhotonNetwork.CurrentRoom.CustomProperties[$"MT{index}"];
		}

		private float GetMoveTime(int index)
		{
			return (float)PhotonNetwork.CurrentRoom.CustomProperties[$"MT{index + m_trains.Length}"];
		}
	}
	[RequireComponent(typeof(SplitAudioSoundPlayer))]
	public class ValeHealEffect : MonoBehaviourPun, IPunInstantiateMagicCallback, IPoolObject, IPauseObject
	{
		public const float DefaultHealingCycleTime = 10f;

		public const float DefaultHealingPerSeconds = 2f;

		private SplitAudioSoundPlayer m_soundPlayer;

		private Tile m_connectedTile;

		private Wielder m_targetWielder;

		private EventToken m_matchPausedEventToken;

		private EventToken m_matchResetEventToken;

		private EventToken m_matchEndedEventToken;

		public bool IsPaused { get; set; }

		private void OnEnable()
		{
			m_matchPausedEventToken = EventHub.Subscribe<Events.MatchPausedEvent>(OnMatchPaused);
			m_matchResetEventToken = EventHub.Subscribe<Events.MatchResetEvent>(OnMatchReset);
			m_matchEndedEventToken = EventHub.Subscribe<Events.MatchEndedEvent>(OnMatchEnded);
		}

		private void OnDisable()
		{
			StopAllCoroutines();
			EventHub.Unsubscribe<Events.MatchPausedEvent>(m_matchPausedEventToken);
			EventHub.Unsubscribe<Events.MatchResetEvent>(m_matchResetEventToken);
			EventHub.Unsubscribe<Events.MatchEndedEvent>(m_matchEndedEventToken);
		}

		private void FixedUpdate()
		{
			if (!IsPaused && !(m_targetWielder == null) && m_targetWielder.IsLocal)
			{
				if (m_targetWielder.CharacterControl.IsCurseActive)
				{
					m_targetWielder.TakeDamage(DamageType.Continuous, 2f * Time.fixedDeltaTime, Vector2.up);
				}
				else
				{
					m_targetWielder.ChangeHealth(2f * Time.fixedDeltaTime);
				}
			}
		}

		private void OnMatchReset(Events.MatchResetEvent eventData)
		{
			PunDisableObject();
		}

		private void OnMatchEnded(Events.MatchEndedEvent eventData)
		{
			PunDisableObject();
		}

		private void OnMatchPaused(Events.MatchPausedEvent eventData)
		{
			Pause(eventData.IsPaused);
		}

		public void Pause(bool pause)
		{
			IsPaused = pause;
		}

		public void OnPhotonInstantiate(PhotonMessageInfo info)
		{
			m_soundPlayer = GetComponent<SplitAudioSoundPlayer>();
			DisableGameObject();
		}

		public void EnableObject(Vector3 position, params object[] data)
		{
			base.photonView.RPC("PunEnableObject", RpcTarget.AllViaServer, position, data);
		}

		private IEnumerator DisableAfterTime()
		{
			yield return new CustomWaitForSeconds(10f);
			DisableObject();
		}

		[PunRPC]
		private void PunEnableObject(Vector3 position, params object[] data)
		{
			m_connectedTile = PhotonView.Find((int)data[0]).GetComponent<Tile>();
			if (m_connectedTile == null)
			{
				WandsLogger.LogError("ValeHealEffect | Connected tile not found");
				return;
			}
			m_connectedTile.ActiveHealEffect = this;
			m_connectedTile.OnTileOccupied += OnTileOccupied;
			base.transform.SetParent(m_connectedTile.transform, ResetBehaviour.Position);
			if (m_connectedTile.IsOccupied)
			{
				TileOccupy();
			}
			base.gameObject.SetActive(value: true);
			m_soundPlayer.PlaySplitAudio();
			if (base.photonView.IsMine)
			{
				StartCoroutine(DisableAfterTime());
			}
		}

		private void OnTileOccupied(bool occupy)
		{
			if (occupy)
			{
				TileOccupy();
			}
			else
			{
				TileUnoccupy();
			}
		}

		private void TileOccupy()
		{
			if (m_connectedTile.OccupantWielder != null && m_connectedTile.OccupantWielder.IsLocal)
			{
				m_targetWielder = m_connectedTile.OccupantWielder;
			}
		}

		private void TileUnoccupy()
		{
			if ((object)m_targetWielder != null)
			{
				m_targetWielder.AbortContinuousHit();
			}
			m_targetWielder = null;
		}

		public virtual void DisableObject()
		{
			StopAllCoroutines();
			base.photonView?.RPC("PunDisableObject", RpcTarget.AllViaServer);
			ObjectPoolHandler.TryReturnToPool(PoolObjectType.ValeCrystalHeal, this);
		}

		[PunRPC]
		private void PunDisableObject()
		{
			m_soundPlayer.FadeOutLoop(0.5f, DisableGameObject);
			if (m_connectedTile != null)
			{
				m_connectedTile.ActiveHealEffect = null;
				m_connectedTile.OnTileOccupied -= OnTileOccupied;
			}
			if (m_targetWielder != null)
			{
				TileUnoccupy();
			}
		}

		private void DisableGameObject()
		{
			base.gameObject.SetActive(value: false);
		}

		PhotonView IPoolObject.get_photonView()
		{
			return base.photonView;
		}
	}
}
namespace CortopiaEvents
{
	public class Events
	{
		public class SpellSlotDragBeginEvent : EventBase
		{
			public SpellSlot SpellSlot;

			public WandSlot WandSlot;
		}

		public class SpellSlotDragEndEvent : EventBase
		{
			public SpellSlot SpellSlot;

			public WandSlot WandSlot;
		}

		public class SpellSlotSelectedEvent : EventBase
		{
			public SpellSlot SpellSlot;

			public WandSlot WandSlot;
		}

		public class SpellSlotDeselectedEvent : EventBase
		{
			public SpellSlot SpellSlot;
		}

		public class SpellUnlockedEvent : EventBase
		{
		}

		public class SpellInfoUpdatedEvent : EventBase
		{
			public SpellSlot SpellSlot;
		}

		public class MatchPausedEvent : EventBase
		{
			public bool IsPaused;

			public int PausesLeft;
		}

		public class LobbyPausedEvent : EventBase
		{
			public bool IsPaused;
		}

		public class MatchResetEvent : EventBase
		{
			public MatchType MatchType;
		}

		public class SuddenDeathStartedEvent : EventBase
		{
		}

		public class MatchEndedEvent : EventBase
		{
			public EndState EndState;
		}

		public class ConnectToMatch : EventBase
		{
			public string RoomName;

			public JoinState JoinState;

			public Arena Arena;

			public MatchType MatchType;
		}

		public class ConnectedToMatchRoom : EventBase
		{
			public string RoomName;

			public RoomCreationReason CreationReason;

			public JoinState JoinState;

			public Arena Arena;

			public MatchType MatchType;
		}

		public class ConnectedToMatchLobby : EventBase
		{
		}

		public class ReceivedRoomListUpdate : EventBase
		{
			public RoomInfo[] Rooms;
		}

		public class ConnectToMatchRoomFailed : EventBase
		{
		}

		public class ConnectToMatchLobbyFailed : EventBase
		{
		}

		public class ConnectedToPhotonMasterEvent : EventBase
		{
		}

		public class MatchTypeUpdatedEvent : EventBase
		{
			public MatchType MatchType;
		}

		public class EnterPreMatchEvent : EventBase
		{
		}

		public class EnterPostMatchEvent : EventBase
		{
		}

		public class PostMatchUiSkippedEvent : EventBase
		{
		}

		public class TryToFindNewMatchEvent : EventBase
		{
		}

		public class PlayerReadyEvent : EventBase
		{
			public bool IsLocalPlayer;

			public bool IsReady;
		}

		public class PlayerRequestedRematchEvent : EventBase
		{
			public bool IsLocalPlayer;
		}

		public class WielderSpawnedEvent : EventBase
		{
			public Wielder Wielder;
		}

		public class PlayerControlSpawnedEvent : EventBase
		{
			public PlayerControl PlayerControl;
		}

		public class BotControlSpawnedEvent : EventBase
		{
			public BotControl BotControl;
		}

		public class TileAreaEnterEvent : EventBase
		{
		}

		public class TileAreaExitEvent : EventBase
		{
		}

		public class ResetToTileAreaEvent : EventBase
		{
			public Vector3 TilePosition;
		}

		public class WandPositionValidationEvent : EventBase
		{
			public bool IsWandPositionValid;
		}

		public class OnCameraRecenteredEvent : EventBase
		{
		}

		public class DamageTakenEvent : EventBase
		{
			public CharacterControl CharacterControl;

			public float Damage;
		}

		public class TeleportEndedEvent : EventBase
		{
		}

		public class TilePredictedUnsafeEvent : EventBase
		{
			public Tile Tile;
		}

		public class TilePredictedSafeEvent : EventBase
		{
			public Tile Tile;
		}

		public class DefensiveSpellCastEvent : EventBase
		{
		}

		public class InstantSpellInitiatedEvent : EventBase
		{
			public Tile Tile;
		}

		public class InstantSpellChargedEvent : EventBase
		{
			public Vector3 FromPosition;

			public float TimeUntilFullyCharged;
		}

		public class InstantSpellReleasedEvent : EventBase
		{
		}

		public class PredictableCurverCastEvent : EventBase
		{
			public IPredictableCurver PredictableCurver;
		}

		public class CollarsActivatedEvent : EventBase
		{
			public Tile Tile;
		}

		public class CollarsDeactivatedEvent : EventBase
		{
			public Tile Tile;
		}

		public class BotDifficultySelectedEvent : EventBase
		{
			public BotDifficultyLevel DifficultyLevel;
		}

		public class CountdownEndedEvent : EventBase
		{
		}

		public class CountdownStartedEvent : EventBase
		{
			public float Time;
		}

		public class CountdownCanceledEvent : EventBase
		{
		}

		public class CountdownPausedEvent : EventBase
		{
		}

		public class CountdownTimeUpdatedEvent : EventBase
		{
			public float Time;
		}

		public class FinalCountdownStartedEvent : EventBase
		{
		}

		public class EloChangedEvent : EventBase
		{
			public EndState EndState;

			public MatchType MatchType;

			public int EloChange;
		}

		public class DestructableSpawnedEvent : EventBase
		{
			public IDestructableObject Destructable;
		}

		public class SceneLoadInitiatedEvent : EventBase
		{
			public Level CurrentLevel;

			public Level LevelToLoad;
		}

		public class SceneLoadedEvent : EventBase
		{
			public Scene Scene;

			public LoadSceneMode LoadSceneMode;

			public Level Level;
		}

		public class LeadboardLoadedEvent : EventBase
		{
			public LeaderboardType LeaderboardType;
		}

		public class WandUiToggledEvent : EventBase
		{
		}

		public class ActivateDesertTempleDoorsEvent : EventBase
		{
			public bool Enable;

			public DesertTempleEnvironmentType EnvironmentType;
		}

		public class ActivateSandstormDesertTempleEvent : EventBase
		{
			public float JourneyTime;

			public float CurrentMatchTime;
		}

		public class BuildupSandstormDesertTempleEvent : EventBase
		{
			public float JourneyTime;
		}

		public class BuildupGasDesertTempleEvent : EventBase
		{
			public float JourneyTime;
		}

		public class ActivateGasDesertTempleEvent : EventBase
		{
			public float JourneyTime;

			public float CurrentMatchTime;
		}

		public class UserFetchCompletedEvent : EventBase
		{
			public string ErrorMsg;

			public string AccountID;

			public string EncryptionID;

			public bool IsLoggedIn = true;
		}

		public class MirrorOpenedEvent : EventBase
		{
		}

		public class MirrorClosedEvent : EventBase
		{
		}

		public class AssetBundlesLoadedEvent : EventBase
		{
		}

		public class AreaBundlesLoadedEvent : EventBase
		{
		}

		public class InternetConnectionVerifiedEvent : EventBase
		{
		}

		public class InternetConnectionNotAvailableEvent : EventBase
		{
		}

		public class InternetRequiredButNotAvailableEvent : EventBase
		{
		}

		public class PlatformLoginFailedEvent : EventBase
		{
		}

		public class PlayFabLoadingEvent : EventBase
		{
			public bool Success;

			public LoginErrorCode ErrorCode;
		}

		public class PlayfabDataLoadedEvent : EventBase
		{
			public bool Success;
		}

		public class PlayFabSessionExpiredEvent : EventBase
		{
		}

		public class InitiateStartupSceneLoadEvent : EventBase
		{
			public Level LoadLevel;
		}

		public class StartupSceneFinishedLoadingEvent : EventBase
		{
		}

		public class ActivateStartupSceneEvent : EventBase
		{
		}

		public class GameSaveDataLoadedEvent : EventBase
		{
		}

		public class LevelInitializedEvent : EventBase
		{
			public Level Level;
		}

		public class WriteEntitlementFailedMessage : EventBase
		{
			public string Message;
		}

		public class WriteDebugMessage : EventBase
		{
			public string Message;
		}

		public class PurchasedFullGameEvent : EventBase
		{
		}

		public class PurchasedFullGameFailedEvent : EventBase
		{
		}

		public class PrimaryInputDownEvent : EventBase
		{
		}

		public class LoadoutSelectedEvent : EventBase
		{
			public int WandIndex;
		}

		public class TutorialProgressedEvent : EventBase
		{
			public TutorialState State;
		}

		public class TutorialVoiceOverCompleted : EventBase
		{
			public TutorialState State;
		}

		public class TutorialVoiceOverClipStartedEvent : EventBase
		{
			public AudioClip AudioClip;
		}

		public class TutorialVoiceOverClipCompletedEvent : EventBase
		{
			public AudioClip AudioClip;
		}

		public class PostTutorialTriggeredEvent : EventBase
		{
			public PostTutorialTriggerType Trigger;
		}

		public class OnSubtitlesShowEvent : EventBase
		{
			public bool IsShown;
		}

		public class WorkshopTileChangedEvent : EventBase
		{
			public WorkshopTile NewTile;
		}

		public class WandPurchasedEvent : EventBase
		{
			public WandType WandType;
		}

		public class WandTypeChangedEvent : EventBase
		{
			public WandType WandType;

			public WandHand WandHand;
		}

		public class WandLoadoutSwitchedEvent : EventBase
		{
		}

		public class WorkshopWandOpenedEvent : EventBase
		{
		}

		public class WorkshopWandClosedEvent : EventBase
		{
		}

		public class WandStationWandSelectedEvent : EventBase
		{
			public WandStationWand Wand;
		}

		public class TitleChangedEvent : EventBase
		{
			public Title Title;
		}

		public class WandStationPageChangedEvent : EventBase
		{
			public int Index;
		}

		public class VirtualCurrencyChanged : EventBase
		{
			public int Amount;
		}

		public class SpellSelectActivatedEvent : EventBase
		{
			public bool Active;
		}

		public class CharacterTypeChangedEvent : EventBase
		{
			public CharacterType CharacterType;
		}

		public class FriendlyMatchesUpdatedEvent : EventBase
		{
			public IReadOnlyList<RoomInfo> RoomInfos;
		}

		public class PortalLeverInteractedWithEvent : EventBase
		{
			public bool Enabled;
		}

		public class PortalLeverRotatedEvent : EventBase
		{
			public bool Enabled;
		}

		public class TriedStartingWithoutCompleteLoadoutEvent : EventBase
		{
		}

		public class EventRewardClaimedEvent : EventBase
		{
			public CustomEvent CustomEvent;
		}

		public class SpellSelectedEvent : EventBase
		{
			public SpellBase Spell;
		}

		public class SpellCastEvent : EventBase
		{
			public Spell Spell;
		}

		public class ProjectileCastEvent : EventBase
		{
			public Spell Spell;

			public Vector3[] MoveVectors;

			public float Speed;

			public float Acceleration;

			public float MaxSpeed;

			public int OpponentId;

			public float ProjectileRadius;

			public float SplashDamageRadius;

			public float Damage;

			public DamageType DamageType;

			public bool ReturnToSender;

			public ProjectileMover ProjectileMover;
		}

		public class EnergyDepletedEvent : EventBase
		{
			public CostType CostType;

			public Vector3 WandPosition;

			public WandHand WandHand;
		}

		public class ArmorActivationEvent : EventBase
		{
			public bool IsActive;
		}

		public class CurseActivationEvent : EventBase
		{
			public bool IsActive;
		}

		public class ChillingClutchActivationEvent : EventBase
		{
			public bool IsActive;
		}

		public class FreeTeleportActivationEvent : EventBase
		{
			public bool IsActive;
		}

		public class OpponentMissingEvent : EventBase
		{
		}

		public class MatchmakingErrorEvent : EventBase
		{
		}

		public class MatchmakingStartedEvent : EventBase
		{
		}

		public class MatchmakingFinishedEvent : EventBase
		{
		}

		public class PlayerNameUpdated : EventBase
		{
			public Photon.Realtime.Player PhotonPlayer;
		}
	}
	public class InputEvents
	{
		public class PlatformInputUpdated : EventBase
		{
			public AimInput AimInput;

			public WandInput WandInput;

			public bool IsDualWieldEnabled;
		}

		public class WandControllerSpawnedEvent : EventBase
		{
			public AimInput AimInput;

			public WandGrip WandGrip;

			public bool IsDualWieldEnabled;
		}

		public class WandControllerDespawnedEvent : EventBase
		{
		}

		public class WandGripChangedEvent : EventBase
		{
			public WandGrip WandGrip;
		}

		public class InputChangedEvent : EventBase
		{
			public AimInput AimInput;

			public WandInput WandInput;

			public WandGrip WandGrip;

			public bool IsDualWieldEnabled;
		}

		public class DualWieldStateUpdatedEvent : EventBase
		{
			public bool IsDualWieldEnabled;
		}

		public class SystemMenuInputEvent : EventBase
		{
		}

		public class RotateCameraEvent : EventBase
		{
			public RotationDirection RotationDirection;
		}

		public class RecenterCameraEvent : EventBase
		{
		}

		public class ControllerConnectionStatusChanged : EventBase
		{
			public bool IsConnected;
		}
	}
}
namespace Cortopia.Scripts.CustomEvents
{
	public static class SpellEvents
	{
		public static Action OnSpellCollision;

		public static void RegisterListener(Action eventHandler)
		{
			OnSpellCollision = (Action)Delegate.Combine(OnSpellCollision, eventHandler);
		}

		public static void UnregisterListener(Action eventHandler)
		{
			OnSpellCollision = (Action)Delegate.Combine(OnSpellCollision, eventHandler);
		}
	}
}
public abstract class ExpandedSingleton<T> : MonoBehaviour where T : ExpandedSingleton<T>
{
	protected static T sm_instance;

	public static T Instance
	{
		get
		{
			if (sm_instance == null)
			{
				sm_instance = UnityEngine.Object.FindObjectOfType<T>();
				if (sm_instance == null)
				{
					GameObject gameObject = new GameObject(typeof(T).ToString());
					sm_instance = gameObject.AddComponent<T>();
				}
			}
			return sm_instance;
		}
	}

	protected virtual void Awake()
	{
		if (sm_instance == null || sm_instance != this)
		{
			sm_instance = this as T;
		}
	}

	protected virtual void OnDisable()
	{
		sm_instance = (T)null;
	}
}
namespace Assets.Scripts
{
	public class GameControl : MonoBehaviour
	{
		private const byte MaxBackendDataRetrievalAttempts = 5;

		[SerializeField]
		private LoadSfx m_loadSfx;

		[SerializeField]
		private WandsSceneManager m_sceneManager;

		[SerializeField]
		private StartupOptionsHandler m_startupOptionsHandler;

		[Header("Platform")]
		[SerializeField]
		private WandsLeaderboards m_leaderboards;

		[SerializeField]
		private WandsLanguageController m_languageController;

		private ISaveManager m_saveManager;

		private ServerBridge m_serverBridge;

		private LobbyArenaControl m_lobbyArenaHandler;

		private string m_clientVersionClean;

		private Version m_clientVersion;

		private Action m_onFinishedLoading;

		private byte m_backendDataRetrievalAttemptCounter;

		private EventToken m_sceneLoadedEventToken;

		private EventToken m_userFetchedEventToken;

		private EventToken m_systemMenuInputEventToken;

		private EventToken m_playFabSessionExpiredEventToken;

		private EventToken m_photonNetworkDisconnectedEventToken;

		private static string sm_persistantDebugMessage;

		public static GameControl Instance { get; set; }

		public Version ClientVersion
		{
			[CompilerGenerated]
			get
			{
				return m_clientVersion ?? (m_clientVersion = Version.Parse(PlatformSettings.ClientVersion));
			}
		}

		public string NetworkVersion
		{
			[CompilerGenerated]
			get
			{
				return GetNetworkVersion();
			}
		}

		public string PlayfabClientVersion
		{
			[CompilerGenerated]
			get
			{
				return PlatformSettings.PlayfabVersion;
			}
		}

		public ServerBridge ServerBridge
		{
			[CompilerGenerated]
			get
			{
				return (!(m_serverBridge != null)) ? (m_serverBridge = GetComponent<ServerBridge>()) : m_serverBridge;
			}
		}

		public LobbyArenaControl LobbyArenaControl
		{
			[CompilerGenerated]
			get
			{
				return (!(m_lobbyArenaHandler != null)) ? (m_lobbyArenaHandler = base.gameObject.AddComponent<LobbyArenaControl>()) : m_lobbyArenaHandler;
			}
		}

		public WandsLeaderboards Leaderboards
		{
			[CompilerGenerated]
			get
			{
				return (!(m_leaderboards != null)) ? (m_leaderboards = GetComponentInChildren<WandsLeaderboards>()) : m_leaderboards;
			}
		}

		public bool MusicEnabled
		{
			[CompilerGenerated]
			get
			{
				return WandsSave.GetBoolPref("MO", defaultValue: true);
			}
		}

		public bool PositionalTrackingOpponentEnabled
		{
			[CompilerGenerated]
			get
			{
				return WandsSave.GetBoolPref("PTO", defaultValue: true);
			}
		}

		public bool IsGamePaused
		{
			[CompilerGenerated]
			get
			{
				bool? flag = PunSingleton<PauseManager>.Instance?.IsGamePaused;
				return flag.HasValue && flag.Value;
			}
		}

		public AssetHandler AssetHandler { get; set; }

		public Assets.Scripts.Player.Player Player { get; set; }

		public Assets.Scripts.Platform.Platform Platform { get; set; }

		public WandsBuildSettings PlatformSettings { get; set; }

		public ICloudManager CloudManager { get; private set; }

		public StartupOptionsHandler PreTutorialHandler { get; private set; }

		public PlayerControl PlayerControl { get; private set; }

		public bool IsDualWieldSupportedAndActive
		{
			[CompilerGenerated]
			get
			{
				return Platform.ControlType.ContainsFlag(ControlType.DualWield) && WandsSave.IsDualWieldEnabled;
			}
		}

		public bool IsDevelopmentBuild
		{
			[CompilerGenerated]
			get
			{
				return PlatformSettings.ConnectionType == ConnectionType.Develop;
			}
		}

		public bool CanPlayerEarnRating
		{
			[CompilerGenerated]
			get
			{
				return Player.HasUnlockedRating && !Player.SaveData.IsDeveloper;
			}
		}

		private string GetNetworkVersion()
		{
			string text = PlatformSettings.NetworkVersion;
			if (Instance.Platform.Type == PlatformType.PicoNeo2 && Instance.PlatformSettings.IsChinaBuild)
			{
				Version version = Version.Parse(text);
				Version version2 = new Version(version.Major, version.Minor + 1000, version.Build);
				text = version2.ToString();
			}
			return text;
		}

		private void OnEnable()
		{
			if (Instance != this)
			{
				return;
			}
			m_sceneLoadedEventToken = EventHub.Subscribe<Events.SceneLoadedEvent>(OnSceneLoaded);
			m_userFetchedEventToken = EventHub.Subscribe<Events.UserFetchCompletedEvent>(OnUserFetchCompleted);
			m_systemMenuInputEventToken = EventHub.Subscribe<InputEvents.SystemMenuInputEvent>(OnSystemMenuPress);
			m_playFabSessionExpiredEventToken = EventHub.Subscribe<Events.PlayFabSessionExpiredEvent>(OnPlayFabSessionExpired);
			UnityEngine.Application.logMessageReceivedThreaded += HandleUnityLogMessages;
			JsonConvert.DefaultSettings = () => new JsonSerializerSettings
			{
				Converters = new JsonConverter[1]
				{
					new PlayFabJsonObjectConverter()
				},
				Error = delegate(object _, Newtonsoft.Json.Serialization.ErrorEventArgs e)
				{
					WandsLogger.LogError(string.Format("[JsonDeserialization] Unable to serialize {0}. Path: {1} | Member: {2}", (e.CurrentObject ?? "<null>").ToString(), e.ErrorContext.Path, e.ErrorContext.Member));
				}
			};
		}

		private void OnDisable()
		{
			if (!(Instance != this))
			{
				EventHub.Unsubscribe<Events.SceneLoadedEvent>(m_sceneLoadedEventToken);
				EventHub.Unsubscribe<Events.UserFetchCompletedEvent>(m_userFetchedEventToken);
				EventHub.Unsubscribe<InputEvents.SystemMenuInputEvent>(m_systemMenuInputEventToken);
				EventHub.Unsubscribe<Events.PlayFabSessionExpiredEvent>(m_playFabSessionExpiredEventToken);
				UnityEngine.Application.logMessageReceivedThreaded -= HandleUnityLogMessages;
			}
		}

		private void Awake()
		{
			if (Instance == null)
			{
				Instance = this;
			}
			if (Instance != this)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}

		public void SpawnPlayerControl()
		{
			PlayerControl = UnityEngine.Object.Instantiate(Resources.Load<PlayerControl>("PlayerControl"), Vector3.zero, Quaternion.identity);
		}

		public void InternetConnectionVerified()
		{
			if (PreTutorialHandler != null)
			{
				PreTutorialHandler.Reset();
				return;
			}
			if (IsCurrentLevel(Level.MainMenu))
			{
				ToggleLoadSource(active: true);
			}
			m_languageController.SetStartLanguage(Platform);
			if (IsExpectedConnectionType(ConnectionType.Trailer))
			{
				string deviceUniqueIdentifier = SystemInfo.deviceUniqueIdentifier;
				AccountIDFetchComplete(CreateCloudManager(), deviceUniqueIdentifier.Substring(0, Mathf.Min(deviceUniqueIdentifier.Length, 20)), deviceUniqueIdentifier, didLogInToPlatform: false);
			}
			else
			{
				Platform.FetchLoggedInUser();
			}
		}

		private void OnPlayFabSessionExpired(Events.PlayFabSessionExpiredEvent eventData)
		{
			AttemptCloudServiceLogin();
		}

		private void OnSceneLoaded(Events.SceneLoadedEvent eventData)
		{
			SceneLoaded(eventData.Level);
		}

		private void SceneLoaded(Level level)
		{
			switch (level)
			{
			case Level.MainMenu:
				Platform.SetPlatformPartyChatActive(active: true);
				return;
			case Level.Workshop:
				Platform.SetPlatformPartyChatActive(active: true);
				Player.UnlockLoadoutsByLevel(Player.SaveData.LevelData.Level);
				break;
			case Level.Lobby:
				Platform.SetPlatformPartyChatActive(active: false);
				break;
			}
			ToggleLoadSource(active: false);
		}

		public string GetClientVersionString()
		{
			if (string.IsNullOrEmpty(m_clientVersionClean) && ClientVersion != null)
			{
				Version clientVersion = ClientVersion;
				int num = Mathf.Max(clientVersion.Revision, 0);
				string versionSuffix = GetVersionSuffix(num);
				if (string.IsNullOrEmpty(versionSuffix))
				{
					m_clientVersionClean = clientVersion.ToString().Substring(0, 5);
				}
				else
				{
					num = Mathf.Max(num, 1);
					m_clientVersionClean = $"{clientVersion.Major}.{clientVersion.Minor}.{clientVersion.Build}{versionSuffix}{num}";
				}
				if (Instance.PlatformSettings.IsChinaBuild)
				{
					m_clientVersionClean += ".cn";
				}
			}
			return m_clientVersionClean;
		}

		public string GetVersionSuffix(int revisionVersion)
		{
			switch (GetConnectionType())
			{
			case ConnectionType.Develop:
			case ConnectionType.CIN:
				return "d";
			case ConnectionType.Beta:
				return "b";
			case ConnectionType.Trailer:
				return "t";
			default:
				return (revisionVersion <= 0) ? string.Empty : "p";
			}
		}

		public bool IsCurrentLevel(Level compareLevel)
		{
			switch (compareLevel)
			{
			case Level.Unknown:
			case Level.MainMenu:
			case Level.Workshop:
			case Level.Basement:
			case Level.Lobby:
			case Level.AspisPrison:
			case Level.TempleOfOphidian:
			case Level.TheCelestialHalls:
			case Level.OrtusStation:
			case Level.DeadMastersVale:
			case Level.SanctumOfSahir:
				return m_sceneManager.GetCurrentLevel() == compareLevel;
			case Level.UnpausableLevel:
			case Level.InteractableLevel:
			case Level.Arena:
				return m_sceneManager.GetCurrentLevel().ContainsFlag(compareLevel);
			default:
				throw new NotImplementedException("Compare level not recognized");
			}
		}

		public Level GetCurrentLevel(bool callBeforeLevelLoaded = false)
		{
			return m_sceneManager.GetCurrentLevel(callBeforeLevelLoaded);
		}

		public Level GetPreviousLevel()
		{
			return m_sceneManager.PreviousLevel;
		}

		public ConnectionType GetConnectionType()
		{
			return PlatformSettings.ConnectionType;
		}

		public bool IsExpectedConnectionType(ConnectionType expectedType)
		{
			return GetConnectionType().ContainsFlag(expectedType);
		}

		public AimInput GetInputAim()
		{
			AimInput? aimInput = PlayerControl.Input?.AimInput;
			return (!aimInput.HasValue) ? AimInput.Head : aimInput.Value;
		}

		public WandType[] GetWandTypes()
		{
			return new WandType[2]
			{
				Player.GetWand(),
				Player.GetWand(WandHand.Left)
			};
		}

		public Language GetCurrentLanguage()
		{
			Language? language = (((object)m_languageController != null) ? new Language?(m_languageController.GetLanguage()) : null);
			return language.HasValue ? language.Value : Language.English;
		}

		public void SetLanguage(Language language)
		{
			if ((object)m_languageController != null)
			{
				m_languageController.SetLanguage(language);
			}
		}

		public string GetNextLanguage(bool setLanguage)
		{
			return ((object)m_languageController != null) ? m_languageController.GetNextLanguage(setLanguage) : null;
		}

		public WandGrip ToggleWandGrip()
		{
			WandGrip wandGrip2 = (WandsSave.WandGrip = ((WandsSave.WandGrip != WandGrip.Pistol) ? WandGrip.Pistol : WandGrip.Wand));
			InputEvents.WandGripChangedEvent wandGripChangedEvent = new InputEvents.WandGripChangedEvent();
			wandGripChangedEvent.WandGrip = wandGrip2;
			EventHub.Publish(wandGripChangedEvent);
			return wandGrip2;
		}

		public void TogglePrimaryHand()
		{
			bool value = !WandsSave.GetBoolPref("P1", defaultValue: true);
			WandsSave.SetPlayerPref("P1", value);
			PlayerControl.UpdateInputMethod(force: true);
		}

		public void ToggleLoadSource(bool active)
		{
			if (m_loadSfx != null)
			{
				m_loadSfx.ToggleLoadSource(active);
			}
		}

		public void ToggleMusic(bool active)
		{
			WandsSave.SetPlayerPref("MO", active);
		}

		public void LeaveGame(float waitTime, bool penalizePlayer, bool quitGame)
		{
			switch (m_sceneManager.GetCurrentLevel())
			{
			case Level.MainMenu:
			case Level.Workshop:
				return;
			case Level.Basement:
				MonoSingleton<TutorialEntrance>.Instance.Interact();
				return;
			}
			if (penalizePlayer && RoomProperty.GetMatchType() == MatchType.Competitive)
			{
				AddRatingPenalty();
				waitTime += 1f;
			}
			PunSingleton<TileManager>.Instance?.HideTeleportBeacons();
			if (quitGame)
			{
				if (waitTime > 0f)
				{
					Invoke("QuitGame", waitTime);
				}
				else
				{
					QuitGame();
				}
			}
			else
			{
				ReturnToWorkshop(waitTime);
			}
		}

		private void AddRatingPenalty()
		{
			int a = Player.Rating - 24;
			int a2 = Player.SeasonScore - 10;
			TryUpdatePlayerRating(Mathf.Max(a, 0));
			TryUpdateSeasonScore(Mathf.Max(a2, 0));
		}

		private void ReturnToWorkshop(float delay = 0f)
		{
			CancelInvoke();
			m_photonNetworkDisconnectedEventToken = EventHub.Subscribe<NetworkEvents.PhotonNetworkDisconnectedEvent>(delegate
			{
				OnPhotonNetworkDisconnected(delay);
			});
			MonoSingleton<NetworkManager>.Instance.Disconnect();
		}

		private void OnPhotonNetworkDisconnected(float delay)
		{
			if (m_photonNetworkDisconnectedEventToken != null)
			{
				EventHub.Unsubscribe<NetworkEvents.PhotonNetworkDisconnectedEvent>(m_photonNetworkDisconnectedEventToken);
				m_photonNetworkDisconnectedEventToken = null;
			}
			ExpandedSingleton<LevelLoader>.Instance.LoadLevel(Level.Workshop, (!(delay > 0f)) ? 0.25f : delay);
		}

		public void QuitGame()
		{
			CancelInvoke();
			StopAllCoroutines();
			UnityEngine.Application.Quit();
		}

		public void UnlockSpell(Spell spell)
		{
			Player.TryAddSpellToInventory(spell, saveToServer: true);
			if (Player.GetNumberOfOwnedSpells() >= 24)
			{
				UnlockAchievement(Assets.Scripts.Enums.AchievementType.Unlock20Relics);
			}
		}

		public void BuyWand(WandType wand)
		{
			Player.BuyWand(wand);
			if (Player.GetNumberOfOwnedWands() >= 8)
			{
				UnlockAchievement(Assets.Scripts.Enums.AchievementType.Purchase7Wands);
			}
		}

		public void BuyCharacter(CharacterType character)
		{
			Player.BuyCharacter(character);
			if (Player.GetNumberOfOwnedCharacters() >= 10)
			{
				UnlockAchievement(Assets.Scripts.Enums.AchievementType.Purchase9Characters);
			}
		}

		public void UnlockAllSpells()
		{
			List<Spell> list = new List<Spell>(Constants.BaseSpells);
			if (IsCurrentLevel(Level.Workshop))
			{
				for (int i = 0; i < list.Count; i++)
				{
					MonoSingleton<SpellSelectUI>.Instance.UnlockSpell(list[i]);
				}
			}
			Player.TryAddSpellsToInventory(list, saveToServer: true);
		}

		public void LoadLeaderboards()
		{
			Leaderboards.Load(CloudManager);
		}

		public void UnlockAchievement(Assets.Scripts.Enums.AchievementType achievementType)
		{
			if (!achievementType.IsObsolete() && Platform is IAchievementPlatform achievementPlatform && !Player.IsAchievementUnlocked(achievementType))
			{
				Player.RecordAchievementUnlocked(achievementType);
				achievementPlatform.AchievementHandler.UnlockAchievement(AchievementRepository.GetAchievement(achievementType)).Done(delegate
				{
				}, delegate
				{
				});
			}
		}

		public void IncrementAchievement(Assets.Scripts.Enums.AchievementType achievementType, int incrementValue, int target)
		{
			if (achievementType.IsObsolete() || !(Platform is IAchievementPlatform achievementPlatform) || Player.IsAchievementUnlocked(achievementType))
			{
				return;
			}
			int num = Player.RecordAchievementIncremented(achievementType, incrementValue);
			IAchievementHandler achievementHandler = achievementPlatform.AchievementHandler;
			if (achievementHandler.HandlesIncrementalAchievements)
			{
				achievementHandler.IncrementAchievement(AchievementRepository.GetAchievement(achievementType), incrementValue).Done(delegate
				{
					Player.RecordAchievementUnlocked(achievementType);
				});
			}
			else if (num >= target)
			{
				UnlockAchievement(achievementType);
			}
		}

		public void TryUpdatePlayerRating(int newRating)
		{
			if (CanPlayerEarnRating && EloUtils.ShouldAffectRating && !IsExpectedConnectionType((ConnectionType)12))
			{
				Player.UpdateRating(newRating, saveToServer: true);
			}
		}

		public void TryUpdateSeasonScore(int newScore)
		{
			if (CanPlayerEarnRating && EloUtils.ShouldAffectRating && !IsExpectedConnectionType((ConnectionType)12))
			{
				Player.UpdateSeasonScore(newScore, saveToServer: true);
			}
		}

		public void TogglePositionalTrackingOpponent(bool active)
		{
			WandsSave.SetPlayerPref("PTO", active);
		}

		public bool IsControlScheme(WandInput wandInput)
		{
			return WandsSave.GetIntPref("CS", (int)Platform.SupportedWandInputs[0]) == (int)wandInput;
		}

		public WandInput GetControlScheme()
		{
			return (WandInput)WandsSave.GetIntPref("CS", (int)Platform.SupportedWandInputs[0]);
		}

		public void SetControlScheme(WandInput scheme)
		{
			WandsSave.SetPlayerPref("CS", (int)scheme);
			PlayerControl.UpdateInputMethod(force: false);
		}

		private void OnSystemMenuPress(InputEvents.SystemMenuInputEvent eventData)
		{
			Platform.OnSystemMenuPress(GetCurrentLevel(), IsGamePaused);
		}

		private void OnApplicationPause(bool pauseStatus)
		{
			if (m_sceneManager.GetCurrentLevel() == Level.Workshop && !pauseStatus && Platform != null && string.IsNullOrEmpty(Platform.AccountID))
			{
				Platform.FetchLoggedInUser();
			}
			if (!(PunSingleton<PauseManager>.Instance == null) && PunSingleton<PauseManager>.Instance.IsGamePaused != pauseStatus && (!(PunSingleton<SceneControl>.Instance != null) || !PunSingleton<SceneControl>.Instance.GameOver))
			{
				PunSingleton<PauseManager>.Instance.PauseGame(pauseStatus, PhotonNetwork.LocalPlayer.ActorNumber);
			}
		}

		public void OnUserFetchCompleted(Events.UserFetchCompletedEvent eventData)
		{
			if (string.IsNullOrEmpty(eventData.ErrorMsg))
			{
				AccountIDFetchComplete(CreateCloudManager(), eventData.AccountID, eventData.EncryptionID, eventData.IsLoggedIn);
			}
			else
			{
				AccountIDFetchFailed(Platform.Type, eventData.ErrorMsg);
			}
		}

		private void AccountIDFetchFailed(PlatformType platformType, string errorMessage = null)
		{
			WandsLogger.LogError($"AccountID fetch failed with message: {errorMessage}");
			Level currentLevel = GetCurrentLevel();
			if (currentLevel != Level.MainMenu)
			{
				throw new UnityException($"Expected {Level.MainMenu}, got {currentLevel}");
			}
			EventHub.Publish(new Events.PlatformLoginFailedEvent());
		}

		private void AccountIDFetchComplete(ICloudManager cloudManager, string userName, string userId, bool didLogInToPlatform)
		{
			CloudManager = cloudManager;
			m_saveManager = new SaveManager(CloudManager);
			Player = new Assets.Scripts.Player.Player(m_saveManager, new PlayerLogInObject(userName, userId, didLogInToPlatform));
			MonoSingleton<NetworkManager>.Instance.SetPlayerInfo(Platform.AccountID, userId);
			Platform.CreateIAPController(OnIAPInitialized);
		}

		private void OnIAPInitialized()
		{
			AttemptCloudServiceLogin();
		}

		public void AttemptCloudServiceLogin()
		{
			CloudManager.LogIn<LoginResult>(Player.LogInObject.UserId, createAccount: true, LogInToCloudSuccess, LogInToCloudFailure);
		}

		private void LogInToCloudSuccess(LoginResult loginResult)
		{
			Player.PlayFabPlayerId = loginResult.PlayFabId;
			Player.NewPlayFabUser = loginResult.NewlyCreated;
			Player.PlayFabEntityKey = loginResult.EntityToken.Entity;
			PlayerProperty.Set("PI", Player.PlayFabPlayerId);
			MinimumVersionControl.GetMinimumVersion(CloudManager, OnGetMinimumVersion);
		}

		private void LogInToCloudFailure(string errorMessage)
		{
			LoginErrorCode errorCode = LoginErrorCode.LoginFailed;
			WandsLogger.LogError("PlayFab login failed: " + errorMessage);
			Events.PlayFabLoadingEvent playFabLoadingEvent = new Events.PlayFabLoadingEvent();
			playFabLoadingEvent.Success = false;
			playFabLoadingEvent.ErrorCode = errorCode;
			EventHub.Publish(playFabLoadingEvent);
		}

		private void OnGetMinimumVersion()
		{
			Events.PlayFabLoadingEvent playFabLoadingEvent;
			if (IsExpectedConnectionType(ConnectionType.Release) && MinimumVersionControl.MinimumVersion > ClientVersion)
			{
				WandsLogger.LogError($"Player is on version {ClientVersion} but should be on version {MinimumVersionControl.MinimumVersion} to proceed");
				playFabLoadingEvent = new Events.PlayFabLoadingEvent();
				playFabLoadingEvent.Success = false;
				playFabLoadingEvent.ErrorCode = LoginErrorCode.ClientVersionBehind;
				EventHub.Publish(playFabLoadingEvent);
				return;
			}
			playFabLoadingEvent = new Events.PlayFabLoadingEvent();
			playFabLoadingEvent.Success = true;
			EventHub.Publish(playFabLoadingEvent);
			if (Player.NewPlayFabUser)
			{
				Player.SaveUserName(LoadNewUser);
				return;
			}
			Player.SaveUserName();
			LoadCombinedBackendRepresentation();
		}

		public void LoadNewUser()
		{
			Player.HandleFirstTimeUser(LoadCombinedBackendRepresentation);
		}

		private void LoadCombinedBackendRepresentation()
		{
			m_backendDataRetrievalAttemptCounter = 0;
			CloudManager.GetCombinedBackendRepresentation<ExecuteCloudScriptResult>(Platform.Type.ToString(), PlatformSettings.PlayfabVersion, OnGetCombinedBackendRepresentationSuccess, OnGetCombinedBackendRepresentationFailure);
		}

		private void OnGetCombinedBackendRepresentationSuccess(ExecuteCloudScriptResult result)
		{
			CombinedBackendRepresentation dataObject = null;
			Task.Run(delegate
			{
				dataObject = JsonConvert.DeserializeObject<CombinedBackendRepresentation>(result.FunctionResult.ToString());
				SeasonControl.Initialize(dataObject.SeasonInformation);
				PlayFabTitleData.Initialize(dataObject.TitleData);
				WandsDatabase.Initialize(dataObject.CatalogItems);
				NewsControl.Initialize(dataObject.News);
				PlatformSupportControl.Initialize(dataObject.PlatformSupport);
			}).ContinueWith(delegate(Task task)
			{
				if (task.IsFaulted)
				{
					WandsLogger.LogError("OnGetCombinedBackendRepresentationSuccess exception: " + task.Exception);
				}
				else
				{
					ObjectPoolHandler.Initialize();
					Player.Initialize(dataObject.UserInventory, dataObject.UserData, dataObject.Rating);
					Leaderboards.Initialize(dataObject.Leaderboard, dataObject.LeaderboardAroundPlayer);
					if (Platform.Type == PlatformType.PlayStation)
					{
						LoadLeaderboards();
					}
					WandsAnalytics.SendCustomEvent(CustomEventType.player_login, new Dictionary<string, object>
					{
						{ "Rating", Player.Rating },
						{
							"VirtualCurrency",
							Player.SaveData.VirtualCurrency
						}
					});
					LoadGame();
				}
			}, TaskScheduler.FromCurrentSynchronizationContext());
		}

		private void OnGetCombinedBackendRepresentationFailure(string errorMessage)
		{
			m_backendDataRetrievalAttemptCounter++;
			if (m_backendDataRetrievalAttemptCounter < 5)
			{
				WandsLogger.LogError($"GameControl | Failed to retrieve combined user data from backend with error [{errorMessage}], was attempt number {m_backendDataRetrievalAttemptCounter}, retrying...");
				CloudManager.GetCombinedBackendRepresentation<ExecuteCloudScriptResult>(Platform.Type.ToString(), PlatformSettings.PlayfabVersion, OnGetCombinedBackendRepresentationSuccess, OnGetCombinedBackendRepresentationFailure);
				return;
			}
			WandsLogger.LogError($"GameControl | Failed to retrieve combined user data from backend with error [{errorMessage}], was attempt number {m_backendDataRetrievalAttemptCounter}, giving up.");
			Events.PlayfabDataLoadedEvent playfabDataLoadedEvent = new Events.PlayfabDataLoadedEvent();
			playfabDataLoadedEvent.Success = false;
			EventHub.Publish(playfabDataLoadedEvent);
		}

		private void LoadGame()
		{
			EventHub.Publish(new Events.GameSaveDataLoadedEvent());
			if (m_sceneManager.GetCurrentLevel() == Level.MainMenu)
			{
				Events.PlayfabDataLoadedEvent playfabDataLoadedEvent = new Events.PlayfabDataLoadedEvent();
				playfabDataLoadedEvent.Success = true;
				EventHub.Publish(playfabDataLoadedEvent);
				if (PlatformSettings.ShowStartupOptions || PlatformSupportControl.HasDeprecationDate() || !WandsSave.GetBoolPref("PT"))
				{
					PreTutorialHandler = UnityEngine.Object.Instantiate(m_startupOptionsHandler);
					return;
				}
				Events.InitiateStartupSceneLoadEvent initiateStartupSceneLoadEvent = new Events.InitiateStartupSceneLoadEvent();
				initiateStartupSceneLoadEvent.LoadLevel = Level.Workshop;
				EventHub.Publish(initiateStartupSceneLoadEvent);
			}
		}

		public void BuyFullGame()
		{
			if (!Player.HasGameAccess(GameAccess.Full))
			{
				Platform.BuyFullGame();
			}
		}

		public static void PrintDebug(string msg, bool persistant = false)
		{
			if (Instance.GetConnectionType() == ConnectionType.Develop)
			{
				if (persistant)
				{
					sm_persistantDebugMessage = msg;
				}
				else if (!string.IsNullOrEmpty(sm_persistantDebugMessage))
				{
					return;
				}
				Level currentLevel = Instance.GetCurrentLevel(callBeforeLevelLoaded: true);
				if (currentLevel == Level.MainMenu || currentLevel == Level.Workshop)
				{
					Events.WriteDebugMessage writeDebugMessage = new Events.WriteDebugMessage();
					writeDebugMessage.Message = msg;
					EventHub.Publish(writeDebugMessage);
				}
			}
		}

		private void HandleUnityLogMessages(string logString, string stackTrace, LogType type)
		{
			WandsLogger.LogAnalytics(type, logString, stackTrace);
		}

		private ICloudManager CreateCloudManager()
		{
			return new Assets.Scripts.PlayFab.PlayFabManager();
		}
	}
}
namespace Assets.Scripts.WandsIAP
{
	public class IAPController : IStoreListener
	{
		private static IStoreController m_storeController;

		private static IExtensionProvider m_storeExtensionProvider;

		private static string m_productIdWandsGame = "wandsgame";

		private Action m_onInitializedCallback;

		private bool IsInitialized => m_storeController != null && m_storeExtensionProvider != null;

		public IAPController(Action onInitialized)
		{
			m_onInitializedCallback = onInitialized;
			if (m_storeController == null)
			{
				InitializePurchasing();
			}
		}

		private void InitializePurchasing()
		{
			if (!IsInitialized)
			{
				ConfigurationBuilder configurationBuilder = ConfigurationBuilder.Instance(StandardPurchasingModule.Instance());
				configurationBuilder.AddProduct(m_productIdWandsGame, ProductType.NonConsumable);
				UnityPurchasing.Initialize(this, configurationBuilder);
			}
		}

		public void OnInitialized(IStoreController controller, IExtensionProvider extensions)
		{
			m_storeController = controller;
			m_storeExtensionProvider = extensions;
			m_onInitializedCallback();
		}

		public void OnInitializeFailed(InitializationFailureReason error)
		{
			WandsLogger.Log("Initialization failed. " + error, LogType.Error);
			m_onInitializedCallback();
		}

		public PurchaseProcessingResult ProcessPurchase(PurchaseEventArgs args)
		{
			if (args.purchasedProduct.definition.id.Equals(m_productIdWandsGame))
			{
				GameControl.Instance.Player.SetGameAccess(GameAccess.Full, saveToServer: true, delegate
				{
					GameControl.Instance.Invoke("PublishPurchaseEvent", 1f);
				});
			}
			return PurchaseProcessingResult.Complete;
		}

		public void OnPurchaseFailed(UnityEngine.Purchasing.Product product, PurchaseFailureReason failureReason)
		{
			EventHub.Publish(new Events.PurchasedFullGameFailedEvent());
		}

		private void PublishPurchaseEvent()
		{
			EventHub.Publish(new Events.PurchasedFullGameEvent());
			WandsAnalytics.SendCustomEvent(CustomEventType.player_purchased_game, new Dictionary<string, object>
			{
				{
					"Level",
					GameControl.Instance.Player.SaveData.LevelData.Level
				},
				{
					"MatchesPlayed",
					GameControl.Instance.Player.SaveData.MatchData.MatchesPlayed
				},
				{
					"SpellsUnlocked",
					GameControl.Instance.Player.GetNumberOfOwnedSpells() - 1
				},
				{
					"Rating",
					GameControl.Instance.Player.Rating
				}
			});
		}

		private void BuyProductID(string productId)
		{
			string text = string.Empty;
			if (!IsInitialized)
			{
				text = "BuyProductID FAIL. Not initialized.";
			}
			UnityEngine.Purchasing.Product product = m_storeController.products.WithID(productId);
			if (product == null)
			{
				text = "Purchasing failed. Product(" + productId + ") did not exist.";
			}
			if (!product.availableToPurchase)
			{
				text = "Purchasing failed. Product(" + productId + ") is not available for purchase.";
			}
			if (!text.IsNullOrEmpty())
			{
				EventHub.Publish(new Events.PurchasedFullGameFailedEvent());
			}
			else
			{
				m_storeController.InitiatePurchase(product);
			}
		}

		public void BuyFullGame()
		{
			BuyProductID(m_productIdWandsGame);
		}

		public bool HasFullGameReceipt()
		{
			return m_storeController.products.WithStoreSpecificID(m_productIdWandsGame).hasReceipt;
		}

		public string GetFullGamePrice()
		{
			return m_storeController.products.WithStoreSpecificID(m_productIdWandsGame).metadata.localizedPriceString;
		}
	}
}
public class CleanInteractObject : InteractObject
{
	protected override void Interact()
	{
	}

	protected override void Interact(InputButtons inputBtn)
	{
	}
}
public class ControlsImg : InteractObject
{
	[Header("Controls")]
	[SerializeField]
	private SpriteRenderer[] m_imgRenderers = Array.Empty<SpriteRenderer>();

	[SerializeField]
	private GameObject[] m_txtHolders = Array.Empty<GameObject>();

	[SerializeField]
	private Sprite[] m_texturesGearVR = Array.Empty<Sprite>();

	[SerializeField]
	private Sprite[] m_texturesOrientationController = Array.Empty<Sprite>();

	[SerializeField]
	private Sprite[] m_texturesDaydream = Array.Empty<Sprite>();

	protected override void OnEnable()
	{
		base.OnEnable();
	}

	protected override void OnDisable()
	{
		base.OnDisable();
	}

	public override void Start()
	{
		base.Start();
		SetInteractable(active: false);
		UpdateControlImages();
	}

	private void Update()
	{
		GameControl.Instance.PlayerControl.Input.TryTrackInteractObjects();
	}

	protected override void Interact()
	{
		PunSingleton<SoundManager>.Instance.PlayLocalSoundAtPoint("menu_click01", 1f, base.transform.position, 1);
		MonoSingleton<ArenaUI>.Instance?.ToggleMenuActive(enable: true);
		SetInteractable(active: false);
	}

	protected override void Interact(InputButtons inputBtn)
	{
		if (inputBtn == InputButtons.ActionMain)
		{
			PunSingleton<SoundManager>.Instance.PlayLocalSoundAtPoint("menu_click01", 1f, base.transform.position, 1);
			MonoSingleton<ArenaUI>.Instance?.ToggleMenuActive(enable: true);
			SetInteractable(active: false);
		}
	}

	public override void SetInteractable(bool active)
	{
		if (active && MonoSingleton<ArenaUI>.Instance != null)
		{
			Transform menuTransform = MonoSingleton<ArenaUI>.Instance.GetMenuTransform();
			base.transform.position = menuTransform.position;
			base.transform.rotation = menuTransform.rotation;
		}
		base.SetInteractable(active);
		if (m_highlightEffect != null)
		{
			m_highlightEffect.gameObject.SetActive(active);
		}
	}

	private void UpdateControlImages()
	{
		int num = 4;
		switch (GameControl.Instance.Platform.Type)
		{
		case PlatformType.GearVr:
		case PlatformType.Go:
			if (GameControl.Instance.GetInputAim() != AimInput.Head)
			{
				num = 2;
			}
			break;
		case PlatformType.Pico:
			num = 0;
			break;
		}
		for (int i = 0; i < m_imgRenderers.Length; i++)
		{
			m_imgRenderers[i].sprite = num switch
			{
				0 => m_texturesDaydream[i], 
				2 => m_texturesOrientationController[i], 
				_ => m_texturesGearVR[i], 
			};
		}
		for (int j = 0; j < m_txtHolders.Length; j++)
		{
			m_txtHolders[j].SetActive(j == num || j == num + 1);
		}
	}
}
public class Credits : InteractObject
{
	[Header("Credits")]
	public Transform m_creditsPaper;

	public Collider m_toggleCollider;

	private bool m_isScaling;

	private const float SCALE_MP = 1f;

	protected override void Interact()
	{
		if (!(m_creditsPaper == null) && !m_isScaling)
		{
			m_isScaling = true;
			PunSingleton<SoundManager>.Instance.PlayLocalSoundAtPoint("menu_click03", 1f, base.transform.position);
			StartCoroutine("ScalePaper");
		}
	}

	protected override void Interact(InputButtons inputBtn)
	{
		if (inputBtn == InputButtons.ActionMain && !(m_creditsPaper == null) && !m_isScaling)
		{
			m_isScaling = true;
			PunSingleton<SoundManager>.Instance.PlayLocalSoundAtPoint("menu_click03", 1f, base.transform.position);
			StartCoroutine("ScalePaper");
		}
	}

	private IEnumerator ScalePaper()
	{
		Vector3 startScale = m_creditsPaper.localScale;
		Vector3 endScale = ((!(startScale == Vector3.zero)) ? Vector3.zero : (Vector3.one * 1f));
		float currentTime = 0f;
		float t = 0f;
		while (t < 1f)
		{
			currentTime += Time.deltaTime;
			t = currentTime / 0.5f;
			m_creditsPaper.localScale = Vector3.Lerp(startScale, endScale, t);
			yield return null;
		}
		m_toggleCollider.enabled = m_creditsPaper.localScale == Vector3.one * 1f;
		m_isScaling = false;
	}
}
namespace Assets.Scripts.InteractObjects
{
	public abstract class Interactable : MonoBehaviour
	{
		public delegate void InteractDelegate();

		public delegate void LookEnterDelegate();

		public delegate void LookExitDelegate();

		[SerializeField]
		private bool m_lockInteract;

		[SerializeField]
		private bool m_lockLook;

		[SerializeField]
		protected GameObject m_particleEffect;

		protected Collider m_collider;

		public HashSet<Action<Interactable>> OnLookEnterListeners { get; } = new HashSet<Action<Interactable>>();


		public HashSet<Action<Interactable>> OnLookExitListeners { get; } = new HashSet<Action<Interactable>>();


		public HashSet<Action<Interactable>> OnInteractListeners { get; } = new HashSet<Action<Interactable>>();


		public Collider Collider
		{
			get
			{
				if (m_collider == null)
				{
					m_collider = GetComponent<Collider>();
					if (m_collider == null)
					{
						m_collider = GetComponentInParent<Collider>();
						if (m_collider == null)
						{
							m_collider = GetComponentInChildren<Collider>();
						}
					}
				}
				return m_collider;
			}
		}

		public bool InteractionLocked
		{
			get
			{
				return m_lockInteract || LockAllInteraction;
			}
			set
			{
				if (ExpandedSingleton<LevelLoader>.Instance.IsLoadingLevel)
				{
					value = true;
				}
				Collider.enabled = !value;
				if (value)
				{
					LookExit();
				}
				ToggleParticleEffects(!value);
				m_lockInteract = value;
			}
		}

		public bool LookLocked
		{
			get
			{
				return m_lockLook || LockAllLook;
			}
			set
			{
				if (ExpandedSingleton<LevelLoader>.Instance.IsLoadingLevel)
				{
					value = true;
				}
				if (value)
				{
					LookExit();
				}
				ToggleParticleEffects(!value);
				m_lockLook = value;
			}
		}

		public static bool LockAllInteraction { get; set; }

		public static bool LockAllLook { get; set; }

		public event LookEnterDelegate OnLookEnter;

		public event LookExitDelegate OnLookExit;

		public event InteractDelegate OnInteract;

		public virtual void LookEnter()
		{
			if (LookLocked)
			{
				return;
			}
			Action<Interactable>[] array = new Action<Interactable>[OnLookEnterListeners.Count];
			OnLookEnterListeners.CopyTo(array);
			foreach (Action<Interactable> action in array)
			{
				if (action != null && OnLookEnterListeners.Contains(action))
				{
					action(this);
				}
			}
			if (this.OnLookEnter != null)
			{
				this.OnLookEnter();
			}
		}

		public virtual void LookExit()
		{
			if (m_lockLook)
			{
				return;
			}
			Action<Interactable>[] array = new Action<Interactable>[OnLookExitListeners.Count];
			OnLookExitListeners.CopyTo(array);
			foreach (Action<Interactable> action in array)
			{
				if (action != null && OnLookExitListeners.Contains(action))
				{
					action(this);
				}
			}
			if (this.OnLookExit != null)
			{
				this.OnLookExit();
			}
		}

		public void ToggleParticleEffects(bool active)
		{
			if (m_particleEffect != null)
			{
				m_particleEffect.SetActive(active);
			}
		}

		public virtual void Interact()
		{
			if (m_lockInteract)
			{
				return;
			}
			Action<Interactable>[] array = new Action<Interactable>[OnInteractListeners.Count];
			OnInteractListeners.CopyTo(array);
			foreach (Action<Interactable> action in array)
			{
				if (action != null && OnInteractListeners.Contains(action))
				{
					action(this);
				}
			}
			if (this.OnInteract != null)
			{
				this.OnInteract();
			}
		}

		public void LockInteraction(bool locked)
		{
			m_lockInteract = locked;
		}

		public void LockLook(bool locked)
		{
			m_lockLook = locked;
		}
	}
	public class InteractableButton : Interactable
	{
		public struct SingleCheckAction
		{
			public Action OnSuccess;

			public Action OnFailure;
		}

		[SerializeField]
		private UnityEvent _onClick;

		protected WandsButtonHighlighter[] m_buttonHighlighters;

		[SerializeField]
		[Tooltip("If interacting with this button will launch a multiplayer feature")]
		private bool m_requiresMultiplayerFeatures;

		[SerializeField]
		[Tooltip("If interacting with this button will launch an online feature that requires parental access")]
		private bool m_requiresParentalOnlineAccess;

		public Queue<SingleCheckAction> SingleCheckActions { get; } = new Queue<SingleCheckAction>();


		private event Action OnPreClick;

		protected virtual void Awake()
		{
			m_buttonHighlighters = GetComponentsInChildren<WandsButtonHighlighter>(includeInactive: true);
		}

		public void AddClickListener(Action action)
		{
			OnPreClick += action;
		}

		public void RemoveClickListener(Action action)
		{
			OnPreClick -= action;
		}

		protected void DisableInteractions()
		{
			Interactable.LockAllInteraction = true;
			Interactable.LockAllLook = true;
		}

		protected void EnableInteractions()
		{
			Interactable.LockAllInteraction = false;
			Interactable.LockAllLook = false;
		}

		public override void Interact()
		{
			if (base.InteractionLocked || (_onClick == null && this.OnPreClick == null))
			{
				return;
			}
			base.Interact();
			if (m_requiresParentalOnlineAccess || m_requiresMultiplayerFeatures)
			{
				DisableInteractions();
				MonoSingleton<NetworkManager>.Instance.IsInternetReachable(delegate(bool hasInternet)
				{
					if (hasInternet)
					{
						GameControl.Instance.Platform.TryPlayOnline(delegate(bool success)
						{
							EnableInteractions();
							if (success)
							{
								Success();
							}
							else
							{
								Failure();
							}
						}, m_requiresMultiplayerFeatures);
					}
					else
					{
						EnableInteractions();
						Failure();
						WandsLogger.LogError("Internet is not reachable.");
						EventHub.Publish(new Events.InternetRequiredButNotAvailableEvent());
					}
				});
			}
			else
			{
				Success();
			}
		}

		private void Success()
		{
			if (this.OnPreClick != null)
			{
				this.OnPreClick();
			}
			if (_onClick != null)
			{
				_onClick.Invoke();
			}
			while (SingleCheckActions.Count > 0)
			{
				SingleCheckActions.Dequeue().OnSuccess?.Invoke();
			}
		}

		private void Failure()
		{
			while (SingleCheckActions.Count > 0)
			{
				SingleCheckActions.Dequeue().OnFailure?.Invoke();
			}
		}

		public override void LookEnter()
		{
			if (base.LookLocked)
			{
				return;
			}
			base.LookEnter();
			if (m_buttonHighlighters != null)
			{
				WandsButtonHighlighter[] buttonHighlighters = m_buttonHighlighters;
				foreach (WandsButtonHighlighter wandsButtonHighlighter in buttonHighlighters)
				{
					wandsButtonHighlighter.LookEnter();
				}
			}
		}

		public override void LookExit()
		{
			if (base.LookLocked)
			{
				return;
			}
			base.LookExit();
			if (m_buttonHighlighters != null)
			{
				WandsButtonHighlighter[] buttonHighlighters = m_buttonHighlighters;
				foreach (WandsButtonHighlighter wandsButtonHighlighter in buttonHighlighters)
				{
					wandsButtonHighlighter.LookExit();
				}
			}
		}

		protected virtual void OnDisable()
		{
			LookExit();
		}
	}
	public class InteractableGameObject : Interactable
	{
		[SerializeField]
		private Renderer[] m_renderer;

		private List<RendererMaterialPair> m_meshMaterials;

		protected virtual void Start()
		{
			if (!m_renderer.IsNullOrEmpty())
			{
				m_meshMaterials = new List<RendererMaterialPair>();
				Renderer[] renderer = m_renderer;
				foreach (Renderer renderer2 in renderer)
				{
					RendererMaterialPair rendererMaterialPair = new RendererMaterialPair(renderer2, renderer2.sharedMaterial);
					rendererMaterialPair.SetMaterialHighlighted(highlighted: false);
					m_meshMaterials.Add(rendererMaterialPair);
				}
			}
		}

		public override void LookEnter()
		{
			if (base.LookLocked)
			{
				return;
			}
			base.LookEnter();
			if (m_meshMaterials.IsNullOrEmpty())
			{
				return;
			}
			foreach (RendererMaterialPair meshMaterial in m_meshMaterials)
			{
				meshMaterial.SetMaterialHighlighted(highlighted: true);
			}
		}

		public override void LookExit()
		{
			if (base.LookLocked)
			{
				return;
			}
			base.LookExit();
			if (m_meshMaterials.IsNullOrEmpty())
			{
				return;
			}
			foreach (RendererMaterialPair meshMaterial in m_meshMaterials)
			{
				meshMaterial.SetMaterialHighlighted(highlighted: false);
			}
		}
	}
	public class InteractableText : Interactable
	{
		[SerializeField]
		protected TMP_Text m_textComponent;

		private Color m_defaultColor;

		public override void LookEnter()
		{
			if (!base.LookLocked)
			{
				m_defaultColor = m_textComponent.color;
				m_textComponent.color = Colors.TextHighlight;
				base.LookEnter();
			}
		}

		public override void LookExit()
		{
			if (!base.LookLocked)
			{
				m_textComponent.color = m_defaultColor;
				base.LookExit();
			}
		}

		public void SetColor(Color color)
		{
			m_textComponent.color = color;
		}

		public Color GetColor()
		{
			return m_textComponent.color;
		}
	}
	public class InteractableUnlockable : Interactable
	{
		[SerializeField]
		protected List<UnlockableRendererMaterialPair> m_meshMaterials = new List<UnlockableRendererMaterialPair>(2);

		protected virtual bool IsHighlightToggleActive
		{
			[CompilerGenerated]
			get
			{
				return true;
			}
		}

		protected virtual void Start()
		{
			foreach (UnlockableRendererMaterialPair meshMaterial in m_meshMaterials)
			{
				meshMaterial.ReplaceMaterial(ItemMaterialType.Default);
			}
		}

		public override void LookEnter()
		{
			if (!base.LookLocked)
			{
				base.LookEnter();
				SetHighlighted(highlighted: true);
			}
		}

		public override void LookExit()
		{
			if (!base.LookLocked)
			{
				base.LookExit();
				SetHighlighted(highlighted: false);
			}
		}

		public void AssignMaterial(ItemMaterialType type, bool highlighted)
		{
			if (m_meshMaterials.IsNullOrEmpty())
			{
				return;
			}
			foreach (UnlockableRendererMaterialPair meshMaterial in m_meshMaterials)
			{
				meshMaterial.AssignMaterial(type, highlighted);
			}
		}

		protected void SetHighlighted(bool highlighted)
		{
			if (!IsHighlightToggleActive)
			{
				return;
			}
			foreach (UnlockableRendererMaterialPair meshMaterial in m_meshMaterials)
			{
				if (highlighted)
				{
					meshMaterial.SetHighlighted();
				}
				else
				{
					meshMaterial.SetDefault();
				}
			}
		}
	}
	public abstract class InteractObject : MonoBehaviourPun
	{
		public static List<InteractObject> AllInteractables = new List<InteractObject>();

		private static LayerMask sm_mask;

		[Header("Interact Object")]
		public Renderer m_affectedMesh;

		public Material m_highlightMat;

		public Material m_originalMat;

		public GameObject m_highlightEffect;

		protected bool _isHighlighted;

		private Collider _collider;

		public bool IsInteractable { get; protected set; }

		protected Collider Col
		{
			get
			{
				if (_collider == null)
				{
					_collider = GetComponent<Collider>();
				}
				return _collider;
			}
		}

		public static void SetIObjsActive(Type type, bool enable)
		{
			AllInteractables = AllInteractables.OrderBy((InteractObject i) => (!(i.GetType() == type)) ? 1 : 0).ToList();
			foreach (InteractObject allInteractable in AllInteractables)
			{
				if (allInteractable.GetType() != type)
				{
					break;
				}
				allInteractable.SetInteractable(enable);
			}
		}

		protected virtual void OnEnable()
		{
			AllInteractables.Add(this);
		}

		protected virtual void OnDisable()
		{
			AllInteractables.Remove(this);
		}

		public virtual void Start()
		{
			if (m_affectedMesh != null)
			{
				m_originalMat = m_affectedMesh.sharedMaterial;
			}
		}

		public void OnInteract()
		{
			Interact();
		}

		public void OnInteract(InputButtons inputBtn)
		{
			Interact(inputBtn);
		}

		public void OnHold(InputButtons inputBtn)
		{
			Hold(inputBtn);
		}

		public virtual void OnLookEnter()
		{
			LookEnter();
		}

		public virtual void OnLookExit()
		{
			LookExit();
		}

		public virtual void SetInteractable(bool active)
		{
			if (ExpandedSingleton<LevelLoader>.Instance.IsLoadingLevel)
			{
				active = false;
			}
			IsInteractable = active;
			if (Col != null)
			{
				Col.enabled = active;
			}
			if (!active)
			{
				OnLookExit();
			}
			if (m_highlightEffect != null)
			{
				m_highlightEffect.SetActive(active);
			}
		}

		protected virtual void Interact()
		{
		}

		protected abstract void Interact(InputButtons inputBtn);

		protected virtual void Hold(InputButtons inputBtn)
		{
		}

		protected virtual void LookEnter()
		{
			SetHighlighted(value: true);
		}

		protected virtual void LookExit()
		{
			SetHighlighted(value: false);
		}

		protected virtual void SetHighlighted(bool value)
		{
			SetHighlighted(value, force: false);
		}

		protected virtual void SetHighlighted(bool value, bool force, bool reset = false)
		{
			if (m_affectedMesh == null || _isHighlighted == value)
			{
				return;
			}
			_isHighlighted = value;
			if (m_highlightMat != null)
			{
				if (value)
				{
					m_affectedMesh.material = m_highlightMat;
				}
				else
				{
					m_affectedMesh.sharedMaterial = m_originalMat;
				}
			}
		}
	}
}
namespace Cortopia.Scripts.InteractObjects
{
	public interface IWandInteractable
	{
		void Interact(WandHand wandHand);

		void LookEnter(WandHand wandHand);

		void LookExit(WandHand wandHand);
	}
}
public class MirrorObject : InteractObject
{
	private PortalHandler m_mirror;

	protected override void Interact()
	{
	}

	protected override void Interact(InputButtons inputBtn)
	{
	}
}
[RequireComponent(typeof(InteractableGameObject))]
public class MusicBox : MonoBehaviour
{
	public Transform m_ballerina;

	public float m_rotationSpeed = 5f;

	private bool m_isPlaying;

	private AudioSource m_audioSource;

	private Phonograph m_phonograph;

	private WaitForSeconds m_rotationWait;

	private Interactable _interactable;

	private AudioSource AudioSource
	{
		get
		{
			if (m_audioSource == null)
			{
				m_audioSource = GetComponent<AudioSource>();
			}
			return m_audioSource;
		}
	}

	private void Awake()
	{
		_interactable = GetComponent<Interactable>();
		_interactable.OnInteract += Interact;
		m_rotationWait = new WaitForSeconds(5f);
	}

	private void Interact()
	{
		if (m_phonograph == null)
		{
			m_phonograph = UnityEngine.Object.FindObjectOfType<Phonograph>();
		}
		PunSingleton<SoundManager>.Instance.FadeMusic(m_isPlaying, 1f);
		TogglePlaying(!m_isPlaying);
	}

	public void TogglePlaying(bool playing)
	{
		m_isPlaying = playing;
		if (playing)
		{
			AudioSource.Play();
			StartCoroutine(RotateBallerina());
			_interactable.LookExit();
		}
		else
		{
			StopAllCoroutines();
			if (AudioSource.isPlaying)
			{
				PunSingleton<SoundManager>.Instance.PlaySoundAtPoint($"{base.name.ToLower()}_stop", 1f, base.transform.position);
				AudioSource.Stop();
			}
		}
		_interactable.ToggleParticleEffects(!playing);
	}

	private IEnumerator RotateBallerina()
	{
		yield return m_rotationWait;
		while (m_isPlaying || AudioSource.isPlaying)
		{
			if (m_ballerina != null)
			{
				m_ballerina.Rotate(new Vector3(0f, 0f, Time.deltaTime * m_rotationSpeed), Space.Self);
			}
			yield return null;
		}
		TogglePlaying(playing: false);
		PunSingleton<SoundManager>.Instance.FadeMusic(fadeIn: true, 1f);
	}
}
[RequireComponent(typeof(AudioSource))]
public class Phonograph : InteractableGameObject
{
	private AudioSource m_audioSource;

	private bool m_isPlaying;

	private void Awake()
	{
		m_audioSource = GetComponent<AudioSource>();
	}

	public override void Interact()
	{
		if (!base.InteractionLocked)
		{
			if (m_isPlaying)
			{
				PunSingleton<SoundManager>.Instance.FadeMusic(fadeIn: true, 1f);
			}
			TogglePlaying(!m_isPlaying);
		}
	}

	private void TogglePlaying(bool shouldPlay)
	{
		m_isPlaying = shouldPlay;
		if (shouldPlay)
		{
			m_audioSource.Play();
			StartCoroutine(WaitForMusicEnd());
		}
		else
		{
			StopAllCoroutines();
			if (m_audioSource.isPlaying)
			{
				m_audioSource.Stop();
				PunSingleton<SoundManager>.Instance.PlaySoundAtPoint($"{base.name.ToLower()}_stop", 1f, base.transform.position);
			}
		}
		ToggleParticleEffects(!shouldPlay);
	}

	private IEnumerator WaitForMusicEnd()
	{
		while (m_audioSource.isPlaying)
		{
			yield return new WaitForEndOfFrame();
		}
		TogglePlaying(shouldPlay: false);
		PunSingleton<SoundManager>.Instance.FadeMusic(fadeIn: true, 1f);
	}
}
namespace Assets.Scripts.InteractObjects
{
	[RequireComponent(typeof(InteractableGameObject))]
	public class PortalLever : MonoBehaviour, IWorkshopTileListener
	{
		[SerializeField]
		private float m_rotationTime = 0.5f;

		[SerializeField]
		private float m_degrees;

		private bool m_opened;

		private Interactable m_interactable;

		private void Awake()
		{
			m_interactable = GetComponent<Interactable>();
		}

		private void OnEnable()
		{
			m_interactable.OnInteract += OnInteract;
		}

		private void OnDisable()
		{
			m_interactable.OnInteract -= OnInteract;
		}

		private void OnInteract()
		{
			m_opened = !m_opened;
			m_interactable.InteractionLocked = true;
			if (PunSingleton<SoundManager>.Instance.IsMusicPlaying())
			{
				PunSingleton<SoundManager>.Instance.FadeMusic(fadeIn: false, 1f);
			}
			PunSingleton<SoundManager>.Instance.PlayLocalSoundAtPoint("portal_lever", 1f, base.transform.position, 1);
			base.transform.DORotate(base.transform.eulerAngles + new Vector3(0f, 0f, m_degrees * (float)(m_opened ? 1 : (-1))), m_rotationTime).SetEase(Ease.InQuart).OnComplete(OnRotateComplete);
			Events.PortalLeverInteractedWithEvent portalLeverInteractedWithEvent = new Events.PortalLeverInteractedWithEvent();
			portalLeverInteractedWithEvent.Enabled = m_opened;
			EventHub.Publish(portalLeverInteractedWithEvent);
		}

		private void OnRotateComplete()
		{
			m_interactable.InteractionLocked = false;
			MonoSingleton<PortalHandler>.Instance.Toggle();
		}

		public void ToggleInteractionActive(bool active)
		{
			m_interactable.LockInteraction(!active);
			m_interactable.LockLook(!active);
		}

		public void ToggleActive(bool active)
		{
		}
	}
	public class StartBotMatchActivationObject : MonoBehaviour
	{
		[SerializeField]
		private GameObject m_wand;

		private void OnEnable()
		{
			m_wand.SetActive(PlayFabTitleData.GetBotsEnabled());
		}
	}
	[RequireComponent(typeof(InteractableUnlockable))]
	public class StartBotMatchWand : MonoBehaviour
	{
		[SerializeField]
		private GameObject m_tooltip;

		private InteractableUnlockable m_interactable;

		private void Awake()
		{
			m_interactable = GetComponent<InteractableUnlockable>();
		}

		private void OnEnable()
		{
			m_interactable.OnInteract += Interact;
			m_interactable.OnLookEnter += LookEnter;
			m_interactable.OnLookExit += LookExit;
		}

		private void OnDisable()
		{
			m_interactable.OnInteract -= Interact;
			m_interactable.OnLookEnter -= LookEnter;
			m_interactable.OnLookExit -= LookExit;
		}

		public void Interact()
		{
			PunSingleton<LobbyManager>.Instance.StartBotMatch();
			Interactable.LockAllInteraction = true;
			Interactable.LockAllLook = true;
		}

		private void LookEnter()
		{
			m_tooltip.SetActive(value: true);
		}

		private void LookExit()
		{
			m_tooltip.SetActive(value: false);
		}
	}
	public class TutorialEntrance : MonoSingleton<TutorialEntrance>
	{
		[SerializeField]
		private Tile m_connectedTile;

		[SerializeField]
		private float m_fadeTime = 1f;

		[SerializeField]
		private Interactable m_interactable;

		[SerializeField]
		private AudioSource m_audioSource;

		private EventToken m_connectedToMatchRoomToken;

		private EventToken m_connectToMatchRoomFailedToken;

		private void OnEnable()
		{
			m_connectedToMatchRoomToken = EventHub.Subscribe<Events.ConnectedToMatchRoom>(OnConnectedToMatchRoom);
			m_connectToMatchRoomFailedToken = EventHub.Subscribe<Events.ConnectToMatchRoomFailed>(OnConnectToMatchRoomFailed);
		}

		protected override void OnDisable()
		{
			base.OnDisable();
			EventHub.Unsubscribe<Events.ConnectedToMatchRoom>(m_connectedToMatchRoomToken);
			EventHub.Unsubscribe<Events.ConnectToMatchRoomFailed>(m_connectToMatchRoomFailedToken);
		}

		protected override void Awake()
		{
			base.Awake();
			m_interactable.OnInteract += Interact;
		}

		private void OnDestroy()
		{
			StopAllCoroutines();
			m_interactable.OnInteract -= Interact;
		}

		private void Update()
		{
			if (!(m_connectedTile == null) && m_interactable.InteractionLocked == m_connectedTile.IsOccupied)
			{
				m_interactable.InteractionLocked = !m_connectedTile.IsOccupied;
			}
		}

		public void Interact()
		{
			if (MonoSingleton<SnapshotHandler>.Instance != null)
			{
				MonoSingleton<SnapshotHandler>.Instance.TransitionTo(2, 1f);
			}
			m_audioSource.Stop();
			m_audioSource.Play();
			ExpandedSingleton<FadeHandler>.Instance.FadeOut(m_fadeTime, Color.black);
			Interactable.LockAllInteraction = true;
			Interactable.LockAllLook = true;
			switch (GameControl.Instance.GetCurrentLevel())
			{
			case Level.Workshop:
				LoadBasement();
				break;
			case Level.Basement:
				MonoSingleton<NetworkManager>.Instance.Disconnect();
				LoadWorkshop();
				break;
			}
		}

		private void OnConnectedToMatchRoom(Events.ConnectedToMatchRoom eventData)
		{
			if (eventData.CreationReason == RoomCreationReason.Basement && GameControl.Instance.GetCurrentLevel() == Level.Workshop)
			{
				WandsAnalytics.SendCustomEvent(CustomEventType.player_entered_basement);
				StartCoroutine(LoadLevelOnNetworkChange(Level.Basement));
			}
		}

		private void OnConnectToMatchRoomFailed(Events.ConnectToMatchRoomFailed eventData)
		{
			Level currentLevel = GameControl.Instance.GetCurrentLevel();
			if (currentLevel == Level.Workshop)
			{
				OnEnterBasementFailed("Wasn't able to go into basement: Could not connect to server");
			}
		}

		private void LoadWorkshop()
		{
			WandsAnalytics.SendCustomEvent(CustomEventType.player_left_basement);
			StartCoroutine(LoadLevelOnNetworkChange(Level.Workshop));
		}

		private void LoadBasement()
		{
			MonoSingleton<SpellSelectUI>.Instance.SetSpellSelectionActive(enable: false, playSound: false, saveSelection: true);
			MonoSingleton<NetworkManager>.Instance.ConnectToMatchRoom(null, RoomCreationType.Create, RoomCreationReason.Basement, Arena.None, MatchType.Tutorial);
		}

		private IEnumerator LoadLevelOnNetworkChange(Level levelToLoad)
		{
			while (ExpandedSingleton<FadeHandler>.Instance.IsFading)
			{
				yield return null;
			}
			ExpandedSingleton<LevelLoader>.Instance.LoadLevel(levelToLoad);
			ExpandedSingleton<LevelLoader>.Instance.SetLoadingSound(m_audioSource);
		}

		private void OnEnterBasementFailed(string reason)
		{
			WandsLogger.LogError("Could not enter the Basement: " + reason);
			ExpandedSingleton<FadeHandler>.Instance.FadeIn(m_fadeTime);
			Interactable.LockAllInteraction = false;
			Interactable.LockAllLook = false;
		}
	}
	[Serializable]
	public class UnlockableRendererMaterialPair
	{
		[SerializeField]
		private Renderer[] m_renderers = Array.Empty<Renderer>();

		[SerializeField]
		private Material[] m_materials = Array.Empty<Material>();

		public Renderer[] Renderers
		{
			[CompilerGenerated]
			get
			{
				return m_renderers;
			}
		}

		public void PreloadMaterials()
		{
			m_materials = GameControl.Instance.AssetHandler.ReplaceMaterials(m_materials);
		}

		public void ReplaceMaterial(ItemMaterialType startType)
		{
			if (m_renderers.IsNullOrEmpty() || m_materials.IsNullOrEmpty())
			{
				WandsLogger.LogError("Renderers or materials is null");
				return;
			}
			string name = m_materials[(int)startType].name;
			Renderer[] renderers = m_renderers;
			foreach (Renderer renderer in renderers)
			{
				if (renderer.sharedMaterial.name != name)
				{
					renderer.sharedMaterial = m_materials[(int)startType];
				}
			}
		}

		public void AssignMaterial(ItemMaterialType type, bool highlighted)
		{
			if (m_renderers.IsEmpty() || m_materials.IsEmpty())
			{
				return;
			}
			string name = m_materials[(int)type].name;
			Renderer[] renderers = m_renderers;
			foreach (Renderer renderer in renderers)
			{
				if (renderer.sharedMaterial.name != name)
				{
					renderer.material = m_materials[(int)type];
					renderer.material.SetFloat("_Highlighted", (!highlighted) ? 0f : 1f);
				}
			}
		}

		public void SetHighlighted()
		{
			Renderer[] renderers = m_renderers;
			foreach (Renderer renderer in renderers)
			{
				renderer.material.SetFloat("_Highlighted", 1f);
			}
		}

		public void SetDefault()
		{
			Renderer[] renderers = m_renderers;
			foreach (Renderer renderer in renderers)
			{
				renderer.material.SetFloat("_Highlighted", 0f);
			}
		}
	}
	[RequireComponent(typeof(InteractableUnlockable))]
	public class WandHandle : MonoBehaviour
	{
		[Header("Wand Handle")]
		[SerializeField]
		private WorkshopWand m_workshopWand;

		[SerializeField]
		private Renderer m_mainMeshRenderer;

		[SerializeField]
		private Renderer[] m_additionalWandRenderers = Array.Empty<Renderer>();

		[SerializeField]
		private BoxCollider m_baseCollider;

		[SerializeField]
		private BoxCollider m_tipCollider;

		[SerializeField]
		private BoxCollider m_relicCollider;

		private InteractableUnlockable m_interactable;

		private InteractableUnlockable m_tipInteractable;

		public BoxCollider BaseCollider
		{
			[CompilerGenerated]
			get
			{
				return m_baseCollider;
			}
		}

		public BoxCollider TipCollider
		{
			[CompilerGenerated]
			get
			{
				return m_tipCollider;
			}
		}

		public BoxCollider RelicCollider
		{
			[CompilerGenerated]
			get
			{
				return m_relicCollider;
			}
		}

		private void Awake()
		{
			m_interactable = GetComponent<InteractableUnlockable>();
			if (m_workshopWand != null)
			{
				m_interactable.OnInteract += m_workshopWand.Interact;
				if (m_tipCollider != null)
				{
					m_tipInteractable = m_tipCollider.GetComponent<InteractableUnlockable>();
				}
			}
		}

		public void SetActive(bool active, bool dissolve = true)
		{
			if (!active)
			{
				LockInteractables(locked: true);
			}
			else if (m_workshopWand != null && m_mainMeshRenderer != null)
			{
				m_workshopWand.SetWandTipTransform(m_additionalWandRenderers[0].transform);
			}
			if (!dissolve)
			{
				base.gameObject.SetActive(active);
				if (m_mainMeshRenderer.material.HasProperty("_SliceAmount"))
				{
					SetDissolveValue((!active) ? 1f : 0f);
				}
			}
			else
			{
				base.gameObject.SetActive(value: true);
				StartCoroutine(Dissolve(active));
			}
		}

		private IEnumerator Dissolve(bool enable)
		{
			if (m_mainMeshRenderer.material.HasProperty("_SliceAmount"))
			{
				float startValue = m_mainMeshRenderer.material.GetFloat("_SliceAmount");
				float endValue = ((!enable) ? 1f : 0f);
				float t = 0f;
				while (t < 1f)
				{
					t += Time.deltaTime;
					float lerpValue = Mathf.Lerp(startValue, endValue, t);
					SetDissolveValue(lerpValue);
					yield return null;
				}
			}
			if (enable)
			{
				LockInteractables(locked: false);
			}
			else
			{
				base.gameObject.SetActive(value: false);
			}
		}

		private void SetDissolveValue(float value)
		{
			m_mainMeshRenderer.material.SetFloat("_SliceAmount", value);
			if (!m_additionalWandRenderers.IsEmpty())
			{
				for (int i = 0; i < m_additionalWandRenderers.Length; i++)
				{
					m_additionalWandRenderers[i].material.SetFloat("_SliceAmount", value);
				}
			}
		}

		public void LockInteractables(bool locked)
		{
			if (m_interactable != null)
			{
				m_interactable.LockInteraction(locked);
				m_interactable.LockLook(locked);
			}
			if (m_tipInteractable != null)
			{
				m_tipInteractable.LockInteraction(locked);
				m_tipInteractable.LockLook(locked);
			}
		}
	}
	public class WorkshopWand : InteractableGameObject
	{
		private const float MoveStepSmall = 0.2f;

		private const float MoveStepBig = 0.2f;

		private const float MoveStepPingPong = 0.19f;

		private const float MoveTimePingPong = 0.1f;

		[Header("Wand")]
		[SerializeField]
		private Transform m_wandTipTransform;

		[SerializeField]
		private WandHandle m_currentWand;

		[SerializeField]
		private WandHandle[] m_wands = Array.Empty<WandHandle>();

		private BoxCollider[] m_handleCol;

		private BoxCollider m_relicCollider;

		private Vector3? m_originalPos;

		private Vector3 m_startPos;

		private Vector3 m_endPos;

		private Vector3? m_originalPosBig;

		private Vector3 m_startPosBig;

		private Vector3 m_endPosBig;

		private bool m_isOpen;

		private float m_currentTime;

		private EventToken m_wandTypeChangedEventToken;

		private EventToken m_loadoutChangedEventToken;

		public bool IsMoving { get; private set; }

		public Transform WandTipTransform
		{
			[CompilerGenerated]
			get
			{
				return m_wandTipTransform;
			}
		}

		public WandHandle CurrentWand
		{
			[CompilerGenerated]
			get
			{
				return m_currentWand;
			}
		}

		private void OnEnable()
		{
			m_wandTypeChangedEventToken = EventHub.Subscribe<Events.WandTypeChangedEvent>(OnWandTypeChanged);
			m_loadoutChangedEventToken = EventHub.Subscribe<Events.WandLoadoutSwitchedEvent>(OnLoadoutChanged);
			ChangeWandLooks(GameControl.Instance.Player.GetWand(), dissolve: false);
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe(m_wandTypeChangedEventToken);
			EventHub.Unsubscribe(m_loadoutChangedEventToken);
		}

		private void Awake()
		{
			int wand = (int)GameControl.Instance.Player.GetWand();
			for (int i = 0; i < m_wands.Length; i++)
			{
				if (i == wand)
				{
					SetCurrentWand(m_wands[i], dissolve: false);
				}
				else
				{
					m_wands[i].SetActive(active: false, dissolve: false);
				}
			}
		}

		private void Update()
		{
			if (IsMoving)
			{
				m_currentTime += Time.deltaTime;
				float num = Mathf.Clamp01(m_currentTime / 0.75f);
				m_wandTipTransform.position = Vector3.Lerp(m_startPos, m_endPos, num);
				m_currentWand.transform.position = Vector3.Lerp(m_startPosBig, m_endPosBig, num);
				if (Mathf.Approximately(num, 1f))
				{
					IsMoving = false;
					m_handleCol[0].enabled = true;
					m_handleCol[1].enabled = true;
					LockInteraction(locked: false);
					LockLook(locked: false);
					MonoSingleton<SpellSelectUI>.Instance.RelicHandler.UpdateRelicIconSharedMaterials(MonoSingleton<SpellSelectUI>.Instance.AllSpellSlots, MonoSingleton<SpellSelectUI>.Instance.IsSpellSelectActive);
				}
			}
		}

		public void SetWandTipTransform(Transform wandHandleRenderer)
		{
			m_wandTipTransform = wandHandleRenderer;
		}

		private void OnWandTypeChanged(Events.WandTypeChangedEvent eventData)
		{
			ChangeWandLooks(eventData.WandType);
		}

		private void OnLoadoutChanged(Events.WandLoadoutSwitchedEvent eventData)
		{
			ChangeWandLooks(GameControl.Instance.Player.GetWand());
		}

		public void LockWandHandles(bool locked)
		{
			WandHandle[] wands = m_wands;
			foreach (WandHandle wandHandle in wands)
			{
				wandHandle.LockInteractables(locked);
			}
		}

		public override void Interact()
		{
			if (!base.InteractionLocked)
			{
				if (MonoSingleton<SpellSelectUI>.Instance.IsSpellSelectActive)
				{
					TryCloseWand();
					return;
				}
				MonoSingleton<SpellSelectUI>.Instance.SetSpellSelectionActive(enable: true, playSound: true, saveSelection: true);
				TryOpenWand();
				m_relicCollider.enabled = false;
			}
		}

		public void ForceCloseWand()
		{
			if (!GameControl.Instance.IsDualWieldSupportedAndActive)
			{
				MoveWandHandle(open: false);
			}
		}

		public void TryCloseWand()
		{
			if (!GameControl.Instance.IsDualWieldSupportedAndActive && MonoSingleton<SpellSelectUI>.Instance.TryCloseWand())
			{
				MoveWandHandle(open: false);
				m_relicCollider.enabled = true;
			}
		}

		public void TryOpenWand()
		{
			if (!GameControl.Instance.IsDualWieldSupportedAndActive)
			{
				MoveWandHandle(open: true);
			}
		}

		public void FailMoveWandHandle(TweenCallback onStepComplete)
		{
			LockInteraction(locked: true);
			LockLook(locked: true);
			Transform wandTipTransform = m_wandTipTransform;
			Vector3? originalPos = m_originalPos;
			wandTipTransform.DOMove(((!originalPos.HasValue) ? Vector3.zero : originalPos.Value) + base.transform.forward * 0.19f, 0.1f).SetLoops(2, LoopType.Yoyo).OnStepComplete(onStepComplete)
				.OnComplete(OnFailMoveComplete);
			Transform target = m_currentWand.transform;
			Vector3? originalPosBig = m_originalPosBig;
			target.DOMove(((!originalPosBig.HasValue) ? Vector3.zero : originalPosBig.Value) - base.transform.forward * 0.19f, 0.1f).SetLoops(2, LoopType.Yoyo);
		}

		private void OnFailMoveComplete()
		{
			LockInteraction(locked: false);
			LockLook(locked: false);
		}

		private void MoveWandHandle(bool open)
		{
			if (!m_originalPos.HasValue)
			{
				Start();
				m_originalPos = m_wandTipTransform.position;
			}
			if (!m_originalPosBig.HasValue)
			{
				m_originalPosBig = m_currentWand.transform.position;
			}
			LockInteraction(locked: true);
			LockLook(locked: true);
			m_currentTime = 0f;
			m_startPos = ((!open) ? m_wandTipTransform.position : m_originalPos.Value);
			m_endPos = ((!open) ? m_originalPos.Value : (m_originalPos.Value + base.transform.forward * 0.2f));
			m_startPosBig = ((!open) ? m_currentWand.transform.position : m_originalPosBig.Value);
			m_endPosBig = ((!open) ? m_originalPosBig.Value : (m_originalPosBig.Value - base.transform.forward * 0.2f));
			IsMoving = true;
			m_isOpen = open;
			if (open)
			{
				EventHub.Publish(new Events.WorkshopWandOpenedEvent());
			}
			else
			{
				EventHub.Publish(new Events.WorkshopWandClosedEvent());
			}
		}

		private void ChangeWandLooks(WandType wandType, bool dissolve = true)
		{
			if (m_originalPos.HasValue && m_originalPosBig.HasValue)
			{
				m_currentWand.transform.position = m_originalPosBig.Value;
				m_wandTipTransform.position = m_originalPos.Value;
			}
			if (m_wands.IsNullOrEmpty())
			{
				return;
			}
			WandHandle wandHandle = m_wands[(int)wandType];
			if (!(m_currentWand == wandHandle))
			{
				if (m_currentWand != null)
				{
					m_currentWand.SetActive(active: false, (!m_currentWand.gameObject.activeSelf || !m_isOpen) && dissolve);
				}
				SetCurrentWand(wandHandle, dissolve);
			}
		}

		private void SetCurrentWand(WandHandle wand, bool dissolve)
		{
			m_currentWand = wand;
			m_currentWand.SetActive(active: true, (!wand.gameObject.activeSelf || !m_isOpen) && dissolve);
			SetColliderRefs(wand);
			m_originalPosBig = wand.transform.position;
			m_originalPos = m_wandTipTransform.position;
			if (m_isOpen)
			{
				wand.transform.position -= base.transform.forward * 0.2f;
				m_wandTipTransform.position += base.transform.forward * 0.2f;
			}
		}

		private void SetColliderRefs(WandHandle wand)
		{
			m_handleCol = new BoxCollider[2];
			m_handleCol[0] = wand.BaseCollider;
			m_handleCol[1] = wand.TipCollider;
			m_relicCollider = wand.RelicCollider;
		}
	}
}
namespace Cortopia.Scripts.InteractObjects
{
	public class WorkshopWandVisualChanger : MonoBehaviour
	{
		[SerializeField]
		private WandHand m_wandHand;

		[SerializeField]
		private WandHandle[] m_wands = Array.Empty<WandHandle>();

		private WandType m_currentWandType;

		private EventToken m_wandTypeChangedEventToken;

		private EventToken m_loadoutChangedEventToken;

		private void OnEnable()
		{
			m_wandTypeChangedEventToken = EventHub.Subscribe<Events.WandTypeChangedEvent>(OnWandTypeChanged);
			m_loadoutChangedEventToken = EventHub.Subscribe<Events.WandLoadoutSwitchedEvent>(OnLoadoutChanged);
			ChangeWandLooks(GameControl.Instance.Player.GetWand(m_wandHand), dissolve: false);
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe(m_wandTypeChangedEventToken);
			EventHub.Unsubscribe(m_loadoutChangedEventToken);
		}

		private void OnWandTypeChanged(Events.WandTypeChangedEvent eventData)
		{
			if (eventData.WandHand == m_wandHand)
			{
				ChangeWandLooks(eventData.WandType, dissolve: true);
			}
		}

		private void OnLoadoutChanged(Events.WandLoadoutSwitchedEvent eventData)
		{
			WandType wand = GameControl.Instance.Player.GetWand(m_wandHand);
			if (m_currentWandType != wand)
			{
				ChangeWandLooks(wand, dissolve: true);
			}
		}

		private void ChangeWandLooks(WandType wandType, bool dissolve)
		{
			if (m_wands.IsNullOrEmpty())
			{
				WandsLogger.LogError("Wand Handles not present");
				return;
			}
			m_currentWandType = wandType;
			WandHandle[] wands = m_wands;
			foreach (WandHandle wandHandle in wands)
			{
				bool active = wandHandle.name.Contains(wandType.ToString().ToLower());
				wandHandle.SetActive(active, dissolve);
			}
		}
	}
}
namespace Assets.Scripts.Interfaces
{
	public interface IAimTracker
	{
		Transform AimPivotTransform { get; }

		Ray CameraRay { get; }

		Ray AimRay { get; }

		AimInput AimInput { get; set; }

		void TryInstantiateCamera();

		void TryUpdateAimPivot(AimInput aimInput, WandInput wandInput);

		void UpdateHandedness(AimInput aimInput);
	}
	public interface ICursable
	{
		void EnableCurse(float waitTime, CurseLingeringEffect curseLinderingEffect);

		void DisableCurse();
	}
	public interface IDamageable
	{
		float Health { get; }

		bool TakeDamage(DamageType damageType, float damage, Vector2 hitDirection);

		Transform GetHitTransform();

		void ApplyChillingClutch(float chillingClutchPercent, float time);
	}
}
public interface IDestructableObject
{
	void OnHit(float damage);
}
namespace Assets.Scripts.Interfaces
{
	public interface IDragObject
	{
		bool IsBeingDragged { get; }

		bool IsDraggable { get; }

		bool IsSnappable { get; }

		bool ShouldRaycastToDragPlane { get; }

		float DragTime { get; }

		event DragBeginDelegate OnDragBegin;

		event DragEndDelegate OnDragEnd;

		void BeginDrag(Vector3 dragPoint, Vector3 cameraPoint);

		void Drag(Vector3 dragPoint, Vector3 cameraPoint);

		void EndDrag();

		void SnapToObject(ISnapObject snapObject);
	}
	public delegate void DragBeginDelegate();
	public delegate void DragEndDelegate();
	public interface IEffectEmitter
	{
		ParticleSystem[] Emitters { get; set; }

		void SetEmitterState(EmitterState newState, GameObject effectParent, bool refetchEmitters = false);
	}
	public interface IInputListener
	{
		PlayerInput PlayerInput { get; }

		void OnMenuInput(InputState inputState);

		void OnPrimaryAxisInput(InputState inputState);

		void OnSecondaryAxisInput(InputState inputState);

		void OnRecenterInput(InputState inputState);

		void OnReverseInput(InputState inputState);

		void OnPrimaryInput(InputState inputState);

		void OnSecondaryInput(InputState inputState);

		void OnTeleportInput(InputState inputState);

		void OnPointTriggerInput(InputState inputState);

		void OnSwipeInput(InputState inputState, float speed);

		void OnInteractionInput(InputState inputState);
	}
	public interface IInputListenerTwoWands : IInputListener
	{
		void OnInteractionLeftInput(InputState inputState);

		void OnAutoTeleportLeftInput(InputState inputState);

		void OnAutoTeleportRightInput(InputState inputState);

		void OnSpellInput01(InputState inputState);

		void OnSpellInput02(InputState inputState);

		void OnSpellInput03(InputState inputState);

		void OnSpellInput04(InputState inputState);
	}
	public interface IPauseObject
	{
		bool IsPaused { get; }

		void Pause(bool pause);
	}
	public interface IPoolObject
	{
		PhotonView photonView { get; }

		void EnableObject(Vector3 position, params object[] data);

		void DisableObject();
	}
	public interface IProjectileAccelerate
	{
		bool ShouldAccelerate { get; set; }

		float AccelerationSpeed { get; set; }

		float MaxSpeed { get; }

		void Accelerate();
	}
	public interface IProjectileSplash
	{
		SplashDamageHandler SplashDamageHandler { get; }
	}
	public interface ISnapObject
	{
		Vector3 SnapPoint { get; }

		Quaternion SnapRotation { get; }

		bool IsSnappable { get; }
	}
	public interface ITileSpell
	{
		void SetHighlightTile(Tile tile);

		Tile GetHighlightedTile();

		void ResetHighlightedTile();

		void TrackTiles();
	}
	public interface ITileTimedEffect
	{
		AudioSource LoopingAudioSource { get; }

		IEnumerator LatentStart(float waitTime);

		IEnumerator LatentDestroy(float waitTime);
	}
	public interface ITileTrap
	{
		bool IsArmed { get; set; }

		bool HasDeployed { get; set; }

		IEnumerator ArmTrap(float armTime);

		void DeployTrap();
	}
	public interface IUnlockable
	{
		Vector3 StartingPosition { get; }

		Quaternion StartingRotation { get; }

		Sequence MoveToUnlock(Transform parent, float time);

		Sequence ReturnToSlot(float time);

		void Unlock(GameObject vfx);
	}
}
namespace Cortopia.Scripts.Attributes
{
	public interface IVisibilityToggleable
	{
		bool ShouldBeEnabled { get; }
	}
}
namespace Assets.Scripts.Interfaces
{
	public interface IWandControllable
	{
		WandManager WandManager { get; }

		void SetWandControl(WandManager wandManager);
	}
	public interface IWorkshopTileListener
	{
		void ToggleInteractionActive(bool active);

		void ToggleActive(bool active);
	}
}
namespace Assets.Scripts.ItemDatabase
{
	public class CatalogItemWrapper
	{
		public CatalogItem RawItem { get; private set; }

		public string ItemId => RawItem.ItemId;

		public int DustPrice => (int)RawItem.VirtualCurrencyPrices["RD"];

		public int SpellTokenPrice => (int)RawItem.VirtualCurrencyPrices["ST"];

		public string DisplayName => RawItem.DisplayName;

		public string Description => RawItem.Description;

		public CatalogItemWrapper(CatalogItem catalogItem)
		{
			RawItem = catalogItem;
		}
	}
	public enum CatalogVersion
	{
		Wands,
		Characters,
		Titles,
		Spells
	}
	public class CatalogWrapper
	{
		public string CatalogVersion;

		public List<CatalogItem> Items;
	}
	public class LegacyItemPrices
	{
		public readonly Dictionary<Legacy_MaskType, int> Masks = new Dictionary<Legacy_MaskType, int>
		{
			{
				Legacy_MaskType.Termite_1,
				50
			},
			{
				Legacy_MaskType.Termite_2,
				50
			},
			{
				Legacy_MaskType.Termite_3,
				50
			},
			{
				Legacy_MaskType.Termite_4,
				200
			},
			{
				Legacy_MaskType.Termite_5,
				400
			},
			{
				Legacy_MaskType.Descendant_1,
				50
			},
			{
				Legacy_MaskType.Descendant_2,
				50
			},
			{
				Legacy_MaskType.Descendant_3,
				50
			},
			{
				Legacy_MaskType.Descendant_4,
				200
			},
			{
				Legacy_MaskType.Descendant_5,
				400
			},
			{
				Legacy_MaskType.Tranquil_1,
				0
			},
			{
				Legacy_MaskType.Tranquil_2,
				50
			},
			{
				Legacy_MaskType.Tranquil_3,
				50
			},
			{
				Legacy_MaskType.Tranquil_4,
				200
			},
			{
				Legacy_MaskType.Tranquil_5,
				400
			},
			{
				Legacy_MaskType.Guard_1,
				50
			},
			{
				Legacy_MaskType.Guard_2,
				50
			},
			{
				Legacy_MaskType.Guard_3,
				50
			},
			{
				Legacy_MaskType.Guard_4,
				200
			},
			{
				Legacy_MaskType.Guard_5,
				400
			},
			{
				Legacy_MaskType.Frenzied_1,
				0
			},
			{
				Legacy_MaskType.Frenzied_2,
				50
			},
			{
				Legacy_MaskType.Frenzied_3,
				50
			},
			{
				Legacy_MaskType.Frenzied_4,
				200
			},
			{
				Legacy_MaskType.Frenzied_5,
				200
			},
			{
				Legacy_MaskType.Plague_1,
				50
			},
			{
				Legacy_MaskType.Plague_2,
				50
			},
			{
				Legacy_MaskType.Plague_3,
				50
			},
			{
				Legacy_MaskType.Plague_4,
				200
			},
			{
				Legacy_MaskType.Plague_5,
				400
			},
			{
				Legacy_MaskType.Plague_6,
				400
			},
			{
				Legacy_MaskType.Chameleon_1,
				50
			},
			{
				Legacy_MaskType.Chameleon_2,
				50
			},
			{
				Legacy_MaskType.Chameleon_3,
				50
			},
			{
				Legacy_MaskType.Chameleon_4,
				200
			},
			{
				Legacy_MaskType.Skull_1,
				400
			},
			{
				Legacy_MaskType.Skull_2,
				400
			},
			{
				Legacy_MaskType.Skull_3,
				400
			},
			{
				Legacy_MaskType.Skull_4,
				400
			},
			{
				Legacy_MaskType.Skull_5,
				400
			},
			{
				Legacy_MaskType.Vitis_1,
				-1
			},
			{
				Legacy_MaskType.Vitis_2,
				-1
			},
			{
				Legacy_MaskType.Vitis_3,
				-1
			}
		};

		public readonly Dictionary<Legacy_OutfitType, int> Outfits = new Dictionary<Legacy_OutfitType, int>
		{
			{
				Legacy_OutfitType.Weyman_1,
				0
			},
			{
				Legacy_OutfitType.Weyman_2,
				2000
			},
			{
				Legacy_OutfitType.Blau_1,
				0
			},
			{
				Legacy_OutfitType.Blau_2,
				2000
			},
			{
				Legacy_OutfitType.Fennec_1,
				1000
			},
			{
				Legacy_OutfitType.Fennec_2,
				2000
			},
			{
				Legacy_OutfitType.Knot_1,
				1000
			},
			{
				Legacy_OutfitType.Knot_2,
				2000
			},
			{
				Legacy_OutfitType.Takeo_1,
				1000
			},
			{
				Legacy_OutfitType.Takeo_2,
				2000
			},
			{
				Legacy_OutfitType.Inquisitor_1,
				-1
			},
			{
				Legacy_OutfitType.Inquisitor_2,
				-1
			}
		};

		public readonly Dictionary<Legacy_WandType, int> Wands = new Dictionary<Legacy_WandType, int>
		{
			{
				Legacy_WandType.Classic,
				0
			},
			{
				Legacy_WandType.Sword,
				1000
			},
			{
				Legacy_WandType.Inductor,
				1000
			},
			{
				Legacy_WandType.Lion,
				2000
			},
			{
				Legacy_WandType.Remnant,
				1500
			},
			{
				Legacy_WandType.Scepter,
				1500
			},
			{
				Legacy_WandType.SnakeGold,
				-1
			},
			{
				Legacy_WandType.SnakeSilver,
				-1
			},
			{
				Legacy_WandType.SnakeJade,
				-1
			},
			{
				Legacy_WandType.Invicta,
				-1
			}
		};

		public readonly Dictionary<Legacy_LootCacheType, int> LootCaches = new Dictionary<Legacy_LootCacheType, int> { 
		{
			Legacy_LootCacheType.Default,
			25
		} };
	}
	public static class WandsDatabase
	{
		public static LegacyItemPrices LegacyItems = new LegacyItemPrices();

		private static Dictionary<WandType, CatalogItemWrapper> Wands = new Dictionary<WandType, CatalogItemWrapper>();

		private static Dictionary<CharacterType, CatalogItemWrapper> Characters = new Dictionary<CharacterType, CatalogItemWrapper>();

		private static Dictionary<Title, CatalogItemWrapper> Titles = new Dictionary<Title, CatalogItemWrapper>();

		private static Dictionary<Spell, CatalogItemWrapper> Spells = new Dictionary<Spell, CatalogItemWrapper>();

		private static Action m_onCompleted;

		public static void Initialize(List<CatalogItem>[] catalogs)
		{
			foreach (List<CatalogItem> items in catalogs)
			{
				PopulateItemLists(items);
			}
		}

		public static void PopulateItemLists(List<CatalogItem> items)
		{
			foreach (CatalogItem item in items)
			{
				if (item.Bundle == null)
				{
					JObject jObject = JObject.Parse(item.CustomData);
					int num = jObject.GetValue("Type").Value<int>();
					CatalogVersion catalogVersion = (CatalogVersion)Enum.Parse(typeof(CatalogVersion), item.CatalogVersion);
					switch (catalogVersion)
					{
					case CatalogVersion.Wands:
					{
						WandType wandType = (WandType)num;
						Wands.Add(wandType, new CatalogItemWrapper(item));
						WandProperties.Create(wandType, jObject);
						break;
					}
					case CatalogVersion.Characters:
						Characters.Add((CharacterType)num, new CatalogItemWrapper(item));
						break;
					case CatalogVersion.Titles:
						Titles.Add((Title)num, new CatalogItemWrapper(item));
						break;
					case CatalogVersion.Spells:
						Spells.Add((Spell)num, new CatalogItemWrapper(item));
						break;
					default:
						throw new NotImplementedException("CatalogVersion not implemented: " + catalogVersion);
					}
				}
			}
		}

		public static CatalogItemWrapper GetWand(WandType type)
		{
			if (!Wands.ContainsKey(type))
			{
				return null;
			}
			return Wands[type];
		}

		public static Dictionary<WandType, CatalogItemWrapper> GetAllWands()
		{
			return new Dictionary<WandType, CatalogItemWrapper>(Wands);
		}

		public static Dictionary<WandType, CatalogItemWrapper> GetAllWandsNonAlloc()
		{
			return Wands;
		}

		public static CatalogItemWrapper GetCharacter(CharacterType type)
		{
			if (Characters.TryGetValue(type, out var value))
			{
				return value;
			}
			WandsLogger.LogError($"Couldn't fetch character of type {type} in character data.", LogColor.Database);
			return null;
		}

		public static Dictionary<CharacterType, CatalogItemWrapper> GetAllCharacters()
		{
			return new Dictionary<CharacterType, CatalogItemWrapper>(Characters);
		}

		public static Dictionary<CharacterType, CatalogItemWrapper> GetAllCharactersNonAlloc()
		{
			return Characters;
		}

		public static CatalogItemWrapper GetTitle(Title type)
		{
			if (!Titles.ContainsKey(type))
			{
				return null;
			}
			return Titles[type];
		}

		public static Dictionary<Title, CatalogItemWrapper> GetAllTitles()
		{
			return new Dictionary<Title, CatalogItemWrapper>(Titles);
		}

		public static Dictionary<Title, CatalogItemWrapper> GetAllTitlesNonAlloc()
		{
			return Titles;
		}

		public static CatalogItemWrapper GetSpell(Spell type)
		{
			if (!Spells.ContainsKey(type))
			{
				return null;
			}
			return Spells[type];
		}

		public static Dictionary<Spell, CatalogItemWrapper> GetAllSpells()
		{
			return new Dictionary<Spell, CatalogItemWrapper>(Spells);
		}

		public static Dictionary<Spell, CatalogItemWrapper> GetAllSpellsNonAlloc()
		{
			return Spells;
		}
	}
}
public class LevelLoader : ExpandedSingleton<LevelLoader>
{
	private static WaitForSeconds sm_shortWait = new WaitForSeconds(0.25f);

	private AudioSource m_loadSound;

	private UnityEngine.AsyncOperation m_asyncOp;

	private EventToken m_areaBundlesLoadedEventToken;

	private bool m_hasLoadedAreaBundles;

	public bool IsLoadingLevel { get; private set; }

	private void OnEnable()
	{
		m_areaBundlesLoadedEventToken = EventHub.Subscribe<Events.AreaBundlesLoadedEvent>(OnAreaBundlesLoaded);
	}

	protected override void OnDisable()
	{
		EventHub.Unsubscribe<Events.AreaBundlesLoadedEvent>(m_areaBundlesLoadedEventToken);
		m_areaBundlesLoadedEventToken = null;
	}

	public void SetLoadingSound(AudioSource source)
	{
		if (!(source == null))
		{
			source.transform.SetParent(ExpandedSingleton<LevelLoader>.Instance.transform);
			m_loadSound = source;
		}
	}

	private void TryRemoveLoadSound()
	{
		if (m_loadSound != null)
		{
			UnityEngine.Object.Destroy(m_loadSound.gameObject);
		}
	}

	public bool LoadLevel(Level level, float delayTime = 0f, bool forceIfSameScene = false)
	{
		return LoadLevelInternal(level, delayTime, forceIfSameScene);
	}

	public bool LoadLevel(Arena arena, float delayTime = 0f, bool forceIfSameScene = false)
	{
		Level level = (Level)Enum.Parse(typeof(Level), arena.ToString());
		return LoadLevelInternal(level, delayTime, forceIfSameScene);
	}

	private bool LoadLevelInternal(Level level, float delayTime = 0f, bool forceIfSameScene = false)
	{
		string text = level.ToString();
		if (SceneManagerHelper.ActiveSceneName == text && !forceIfSameScene)
		{
			return false;
		}
		if (string.IsNullOrEmpty(text))
		{
			WandsLogger.LogError("Can't load empty scene");
			return false;
		}
		return LoadLevel(level, delayTime);
	}

	private bool LoadLevel(Level level, float delayTime = 0f)
	{
		if (IsLoadingLevel)
		{
			return false;
		}
		IsLoadingLevel = true;
		StartCoroutine(StartLevelLoad(level, delayTime));
		return true;
	}

	private IEnumerator StartLevelLoad(Level level, float delayTime)
	{
		PhotonNetwork.IsMessageQueueRunning = false;
		yield return sm_shortWait;
		if (MonoSingleton<ArenaUI>.Instance != null)
		{
			MonoSingleton<ArenaUI>.Instance.ResetHUD();
			MonoSingleton<ArenaUI>.Instance.DisableNotification(force: true);
		}
		yield return sm_shortWait;
		ExpandedSingleton<FadeHandler>.Instance?.SetMaterialRenderQueue(6000);
		if (!ExpandedSingleton<FadeHandler>.Instance.IsFading)
		{
			ExpandedSingleton<FadeHandler>.Instance?.FadeOut(0.5f, Color.black);
		}
		while (ExpandedSingleton<FadeHandler>.Instance.IsFading)
		{
			yield return null;
		}
		m_hasLoadedAreaBundles = false;
		Events.SceneLoadInitiatedEvent sceneLoadInitiatedEvent = new Events.SceneLoadInitiatedEvent();
		sceneLoadInitiatedEvent.CurrentLevel = GameControl.Instance.GetCurrentLevel();
		sceneLoadInitiatedEvent.LevelToLoad = level;
		EventHub.Publish(sceneLoadInitiatedEvent);
		while (m_loadSound != null && m_loadSound.isPlaying)
		{
			yield return null;
		}
		PunSingleton<SoundManager>.Instance?.MuteAll();
		GameControl.Instance.ToggleLoadSource(active: true);
		while (!m_hasLoadedAreaBundles)
		{
			yield return null;
		}
		m_asyncOp = SceneManager.LoadSceneAsync(level.ToString());
		m_asyncOp.allowSceneActivation = false;
		while (MonoSingleton<NetworkManager>.Instance.NetworkState == NetworkState.InProgress)
		{
			delayTime -= Time.deltaTime;
			delayTime = Mathf.Max(delayTime, 0f);
			yield return null;
		}
		if (PhotonNetwork.InRoom)
		{
			PhotonNetwork.RemoveRPCs(PhotonNetwork.LocalPlayer);
		}
		yield return new WaitForSeconds(delayTime);
		SetCameraRender();
		yield return m_asyncOp.isDone;
		m_asyncOp.allowSceneActivation = true;
		TurnOnInteractObjects();
		TryRemoveLoadSound();
		IsLoadingLevel = false;
	}

	private void TurnOnInteractObjects()
	{
		Interactable.LockAllInteraction = false;
		Interactable.LockAllLook = false;
	}

	private void SetCameraRender()
	{
		GameControl.Instance.PlayerControl.SetCameraCullingMask(1 << LayerMask.NameToLayer("Fade"));
	}

	private void OnAreaBundlesLoaded(Events.AreaBundlesLoadedEvent eventData)
	{
		m_hasLoadedAreaBundles = true;
	}
}
namespace Assets.Scripts.Platform
{
	public class LoadingListener : MonoBehaviour
	{
		[SerializeField]
		private GameObject m_listener;

		private EventToken m_gameInitializedEventToken;

		private void OnEnable()
		{
			if (GameControl.Instance != null && GameControl.Instance.AssetHandler.HasLoaded)
			{
				GameInitialized();
			}
			else
			{
				m_gameInitializedEventToken = EventHub.Subscribe<Events.GameSaveDataLoadedEvent>(OnGameInitialized);
			}
		}

		private void OnDisable()
		{
			if (m_gameInitializedEventToken != null)
			{
				EventHub.Unsubscribe<Events.GameSaveDataLoadedEvent>(m_gameInitializedEventToken);
			}
		}

		private void OnGameInitialized(Events.GameSaveDataLoadedEvent eventData)
		{
			GameInitialized();
		}

		private void GameInitialized()
		{
			if ((bool)m_listener)
			{
				m_listener.SetActive(value: true);
			}
			Events.LevelInitializedEvent levelInitializedEvent = new Events.LevelInitializedEvent();
			levelInitializedEvent.Level = GameControl.Instance.GetCurrentLevel(callBeforeLevelLoaded: true);
			EventHub.Publish(levelInitializedEvent);
		}
	}
}
namespace Assets.Scripts.Network
{
	public class MainMenuManager : MonoBehaviour
	{
		private const string BackendUnresponsiveTerm = "Info/BackendUnresponsive";

		private const string EntitlementFailedTerm = "Info/EntitlementFailed";

		private const string AssetRetrievalTerm = "Info/AssetRetrieval";

		private const string DataRetrievalTerm = "Info/DataRetrieval";

		private const string LoginTerm = "Info/Login";

		private const string UnsupportedInputTerm = "Info/UnsupportedInput";

		private const string InternetRequiredTerm = "Info/InternetRequired";

		private const string UpdateRequiredTerm = "Info/UpdateRequired";

		private const string LoadingTerm = "Info/Loading";

		[SerializeField]
		private TextMeshPro m_infoText;

		[SerializeField]
		private Localize m_infoLocalize;

		private bool m_isInputSupported = true;

		private bool m_hasLoadedPlayfabData;

		private bool m_hasLoadedAssetBundles;

		private bool m_hasLoadedAreaBundles;

		private string m_oculusRoomId;

		private Coroutine m_quitCoroutine;

		private Coroutine m_levelLoadCoroutine;

		private UnityEngine.AsyncOperation m_asyncSceneLoadOp;

		private EventToken m_inputChangedEventToken;

		private EventToken m_levelInitializedEventToken;

		private EventToken m_platformLoginFailedEventToken;

		private EventToken m_playFabLoadingEventToken;

		private EventToken m_playfabDataLoadedEventToken;

		private EventToken m_assetBundlesLoadedToken;

		private EventToken m_initiateStartupSceneLoadEventToken;

		private EventToken m_writeStartupDebugMessageToken;

		private EventToken m_writeEntitlementFailedMessageToken;

		private EventToken m_internetConnectedMessageToken;

		private EventToken m_internetConnectionNotAvailableMessageToken;

		private EventToken m_areaBundlesLoadedEventToken;

		protected void OnEnable()
		{
			m_inputChangedEventToken = EventHub.Subscribe<InputEvents.InputChangedEvent>(OnInputChanged);
			m_levelInitializedEventToken = EventHub.Subscribe<Events.LevelInitializedEvent>(OnLevelInitialized);
			m_platformLoginFailedEventToken = EventHub.Subscribe<Events.PlatformLoginFailedEvent>(OnPlatformLoginFailed);
			m_playFabLoadingEventToken = EventHub.Subscribe<Events.PlayFabLoadingEvent>(OnPlayFabLoadingEvent);
			m_playfabDataLoadedEventToken = EventHub.Subscribe<Events.PlayfabDataLoadedEvent>(OnPlayfabDataLoaded);
			m_assetBundlesLoadedToken = EventHub.Subscribe<Events.AssetBundlesLoadedEvent>(OnAssetBundlesLoaded);
			m_initiateStartupSceneLoadEventToken = EventHub.Subscribe<Events.InitiateStartupSceneLoadEvent>(OnInitiateStartupSceneLoad);
			m_writeStartupDebugMessageToken = EventHub.Subscribe<Events.WriteDebugMessage>(OnWriteStartupDebugMessage);
			m_writeEntitlementFailedMessageToken = EventHub.Subscribe<Events.WriteEntitlementFailedMessage>(OnWriteEntitlementFailedMessage);
			m_internetConnectedMessageToken = EventHub.Subscribe<Events.InternetConnectionVerifiedEvent>(OnInternetConnectedEvent);
			m_internetConnectionNotAvailableMessageToken = EventHub.Subscribe<Events.InternetConnectionNotAvailableEvent>(OnInternetConnectionNotAvailableEvent);
			m_areaBundlesLoadedEventToken = EventHub.Subscribe<Events.AreaBundlesLoadedEvent>(OnAreaBundlesLoaded);
		}

		protected void OnDisable()
		{
			EventHub.Unsubscribe<InputEvents.InputChangedEvent>(m_inputChangedEventToken);
			EventHub.Unsubscribe<Events.LevelInitializedEvent>(m_levelInitializedEventToken);
			EventHub.Unsubscribe<Events.PlatformLoginFailedEvent>(m_platformLoginFailedEventToken);
			EventHub.Unsubscribe<Events.PlayFabLoadingEvent>(m_playFabLoadingEventToken);
			EventHub.Unsubscribe<Events.PlayfabDataLoadedEvent>(m_playfabDataLoadedEventToken);
			EventHub.Unsubscribe<Events.AssetBundlesLoadedEvent>(m_assetBundlesLoadedToken);
			EventHub.Unsubscribe<Events.InitiateStartupSceneLoadEvent>(m_initiateStartupSceneLoadEventToken);
			EventHub.Unsubscribe<Events.WriteDebugMessage>(m_writeStartupDebugMessageToken);
			EventHub.Unsubscribe<Events.WriteEntitlementFailedMessage>(m_writeEntitlementFailedMessageToken);
			EventHub.Unsubscribe<Events.InternetConnectionVerifiedEvent>(m_internetConnectedMessageToken);
			EventHub.Unsubscribe<Events.InternetConnectionNotAvailableEvent>(m_internetConnectionNotAvailableMessageToken);
			EventHub.Unsubscribe<Events.AreaBundlesLoadedEvent>(m_areaBundlesLoadedEventToken);
		}

		private IEnumerator QuitAfterTime(float waitTime)
		{
			yield return new WaitForSeconds(waitTime);
			UnityEngine.Debug.LogError("Player either not logged in or not entitled to play Wands");
			UnityEngine.Application.Quit();
		}

		private void OnInputChanged(InputEvents.InputChangedEvent eventData)
		{
			m_isInputSupported = eventData.WandInput != WandInput.None;
			if (!m_isInputSupported)
			{
				WriteInfo("Info/UnsupportedInput");
			}
		}

		private void OnLevelInitialized(Events.LevelInitializedEvent eventData)
		{
			if (eventData.Level != Level.MainMenu)
			{
				return;
			}
			if (m_infoLocalize == null || m_infoText == null)
			{
				WandsLogger.LogError("Localize or Text component missing");
				return;
			}
			if (XRDevice.isPresent && GameControl.Instance.Platform.Type.ContainsFlag(PlatformTarget.Android))
			{
				InputTracking.Recenter();
			}
			WriteInfo("Info/Login");
		}

		private void OnPlatformLoginFailed(Events.PlatformLoginFailedEvent eventData)
		{
			LoginFailed("Generic", autoQuit: true);
		}

		private void OnPlayFabLoadingEvent(Events.PlayFabLoadingEvent eventData)
		{
			if (eventData.Success)
			{
				WriteInfo("Info/DataRetrieval");
				return;
			}
			switch (eventData.ErrorCode)
			{
			case LoginErrorCode.LoginFailed:
				LoginFailed();
				break;
			case LoginErrorCode.ClientVersionBehind:
				RequireClientUpdate();
				break;
			case LoginErrorCode.ConnectionToDataBaseFailed:
				ConnectionToDatabaseFailed();
				break;
			default:
				throw new NotImplementedException($"ErrorCode not implemented: <{eventData.ErrorCode}>");
			}
		}

		private void OnAssetBundlesLoaded(Events.AssetBundlesLoadedEvent eventData)
		{
			m_hasLoadedAssetBundles = true;
		}

		private void OnPlayfabDataLoaded(Events.PlayfabDataLoadedEvent eventData)
		{
			if (eventData.Success)
			{
				m_hasLoadedPlayfabData = true;
			}
			else
			{
				WriteInfo("Info/BackendUnresponsive");
			}
		}

		private void OnInitiateStartupSceneLoad(Events.InitiateStartupSceneLoadEvent eventData)
		{
			LocalizationManager.CacheType = CacheType.Persistant;
			if (!m_hasLoadedAssetBundles)
			{
				WriteInfo("Info/AssetRetrieval");
			}
			TryLoadLevel(eventData.LoadLevel, holdSceneActivation: false);
		}

		private void OnWriteStartupDebugMessage(Events.WriteDebugMessage eventData)
		{
			if (GameControl.Instance.IsExpectedConnectionType(ConnectionType.Develop))
			{
				WriteInfo("Debug | ", eventData.Message);
			}
		}

		private void OnWriteEntitlementFailedMessage(Events.WriteEntitlementFailedMessage eventData)
		{
			if (m_quitCoroutine == null)
			{
				StopAllCoroutines();
				WandsLogger.LogError($"Entitlement Issue: {eventData.Message}");
				WriteInfo("Info/EntitlementFailed");
				m_quitCoroutine = StartCoroutine(QuitAfterTime(10f));
			}
		}

		private void OnInternetConnectedEvent(Events.InternetConnectionVerifiedEvent eventData)
		{
			GameControl.Instance.InternetConnectionVerified();
		}

		private void OnInternetConnectionNotAvailableEvent(Events.InternetConnectionNotAvailableEvent eventData)
		{
			if (m_quitCoroutine == null)
			{
				StopAllCoroutines();
				WriteInfo("Info/InternetRequired");
			}
		}

		private void OnAreaBundlesLoaded(Events.AreaBundlesLoadedEvent eventData)
		{
			if (m_quitCoroutine == null)
			{
				m_hasLoadedAreaBundles = true;
			}
		}

		public void LoginFailed(string platform = "Generic", bool autoQuit = false)
		{
			if (m_quitCoroutine != null)
			{
				return;
			}
			StopAllCoroutines();
			MonoSingleton<NetworkManager>.Instance.IsInternetReachable(delegate(bool success)
			{
				if (success)
				{
					GameControl.Instance.AttemptCloudServiceLogin();
				}
				else
				{
					WriteInfo("Info/LoginFailed/" + platform);
					if (autoQuit)
					{
						m_quitCoroutine = StartCoroutine(QuitAfterTime(10f));
					}
				}
			}, forceCheckIfNotAlreadyInProgress: false);
		}

		public void RequireClientUpdate()
		{
			if (m_quitCoroutine == null)
			{
				StopAllCoroutines();
				WriteInfo("Info/UpdateRequired");
			}
		}

		private void ConnectionToDatabaseFailed()
		{
			if (m_quitCoroutine == null)
			{
				StopAllCoroutines();
				WriteInfo(string.Concat("Info/BackendUnresponsive"));
				m_quitCoroutine = StartCoroutine(QuitAfterTime(10f));
			}
		}

		private void TryLoadLevel(Level level, bool holdSceneActivation)
		{
			if (m_levelLoadCoroutine != null)
			{
				StopCoroutine(m_levelLoadCoroutine);
				m_levelLoadCoroutine = null;
			}
			m_levelLoadCoroutine = StartCoroutine(LoadLevelAsync(level));
		}

		private IEnumerator LoadLevelAsync(Level level)
		{
			while (!m_hasLoadedAssetBundles || !m_hasLoadedPlayfabData || !m_hasLoadedAreaBundles)
			{
				yield return null;
			}
			WriteInfo(ScriptLocalization.Get("Info/Loading"), ScriptLocalization.Get($"Levels/{level}"));
			yield return new WaitForSeconds(1f);
			ExpandedSingleton<FadeHandler>.Instance.FadeOut(0.5f);
			yield return new WaitForSeconds(0.5f);
			m_asyncSceneLoadOp = SceneManager.LoadSceneAsync(level.ToString());
			m_asyncSceneLoadOp.allowSceneActivation = false;
			while (m_asyncSceneLoadOp.progress < 0.9f)
			{
				yield return null;
			}
			EventHub.Publish(new Events.StartupSceneFinishedLoadingEvent());
			GameControl.Instance.PlayerControl.ToggleInputActive(active: false);
			yield return new WaitForSeconds(0.5f);
			m_asyncSceneLoadOp.allowSceneActivation = true;
		}

		public void WriteInfo(params string[] terms)
		{
			if (!terms.IsNullOrEmpty())
			{
				string text = string.Empty;
				foreach (string text2 in terms)
				{
					text = string.Concat(text, text2 + " ");
				}
				m_infoLocalize.SetTerm(null);
				m_infoText.text = text.TrimEnd(' ');
			}
		}

		public void WriteInfo(string term)
		{
			if (!string.IsNullOrEmpty(term) && !m_infoLocalize.Term.Equals(term))
			{
				m_infoLocalize.SetTerm(term);
			}
		}
	}
}
namespace Assets.Scripts
{
	public struct MatchReward
	{
		public MatchRewardType Type;

		public float ExperienceGain;

		public float ExperienceMultiplier;

		public float DustGain;

		public float DustMultiplier;

		public MatchReward(MatchRewardType type, float experienceGain, float experienceMultiplier, float dustGain, float dustMultiplier)
		{
			Type = type;
			ExperienceGain = experienceGain;
			ExperienceMultiplier = experienceMultiplier;
			DustGain = dustGain;
			DustMultiplier = dustMultiplier;
		}
	}
	public class LobbyArenaControl : MonoBehaviour
	{
		private int m_totalXpGain;

		private ISet<MatchRewardType> m_playerEarnedBadges = new HashSet<MatchRewardType>();

		private Queue<MatchReward> m_playerEarnedRewards = new Queue<MatchReward>();

		private Queue<MatchRewardType> m_opponentEarnedBadges = new Queue<MatchRewardType>();

		private EloHandler m_eloHandler;

		private MatchType m_matchType;

		private EventToken m_matchEndedEventToken;

		private EventToken m_sceneLoadedEventToken;

		public PlayerMatchStatsData PlayerData { get; private set; }

		public PlayerMatchStatsData OpponentData { get; private set; }

		public int PlayerLevel { get; private set; }

		public int PlayerExperience { get; private set; }

		public int TotalDustGain { get; private set; }

		public int[] MatchScores { get; private set; }

		public int[] PrevEloRatings { get; private set; }

		public int[] UpdatedEloRatings { get; private set; }

		public EndState MatchEndState { get; private set; }

		public int? PrevSeasonScore { get; private set; }

		public int? UpdatedSeasonScore { get; private set; }

		private EloHandler EloHandler
		{
			[CompilerGenerated]
			get
			{
				return m_eloHandler ?? (m_eloHandler = new EloHandler());
			}
		}

		private MatchType MatchType
		{
			[CompilerGenerated]
			get
			{
				return (m_matchType == MatchType.None) ? (m_matchType = RoomProperty.GetMatchType()) : m_matchType;
			}
		}

		private bool ShouldAffectRating
		{
			[CompilerGenerated]
			get
			{
				return EloUtils.ShouldAffectRating;
			}
		}

		private bool CanPlayerEarnRating
		{
			[CompilerGenerated]
			get
			{
				return GameControl.Instance.CanPlayerEarnRating;
			}
		}

		private void OnEnable()
		{
			m_sceneLoadedEventToken = EventHub.Subscribe<Events.SceneLoadedEvent>(OnLevelUpdated);
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe<Events.SceneLoadedEvent>(m_sceneLoadedEventToken);
		}

		private void Start()
		{
			ResetMatchScores();
		}

		private void OnLevelUpdated(Events.SceneLoadedEvent eventData)
		{
			UpdateLevel(eventData.Level);
		}

		private void UpdateLevel(Level level)
		{
			switch (level)
			{
			case Level.Unknown:
			case Level.MainMenu:
			case Level.Basement:
			case Level.Lobby:
				return;
			case Level.Workshop:
				ResetMatchScores();
				ClearMatchStats();
				return;
			}
			if (!PunSingleton<SceneControl>.Instance.CurrentMatchType.ContainsFlag(MatchType.SoloExperience))
			{
				EmptyQueues();
				EloHandler.SetStartValues();
				if (m_matchEndedEventToken == null)
				{
					m_matchEndedEventToken = EventHub.Subscribe<Events.MatchEndedEvent>(OnMatchEnded);
				}
			}
		}

		private void OnMatchEnded(Events.MatchEndedEvent eventData)
		{
			ArenaMatchEnd(eventData.EndState);
		}

		public void ResetMatchScores()
		{
			MatchScores = new int[2];
		}

		private void ClearMatchStats()
		{
			PlayerData = null;
			OpponentData = null;
		}

		private void ArenaMatchEnd(EndState endState)
		{
			EventHub.Unsubscribe<Events.MatchEndedEvent>(m_matchEndedEventToken);
			m_matchEndedEventToken = null;
			MatchEndState = endState;
			UpdateSeasonScore(endState);
			UpdateEloRatings(endState, MatchType);
			CheckBadgesEarned(endState);
			switch (endState)
			{
			case EndState.Won:
				MatchScores[0]++;
				break;
			case EndState.Lost:
				MatchScores[1]++;
				break;
			}
			ClearMatchStats();
			foreach (Wielder allWielder in PlayerManager.Instance.AllWielders)
			{
				SavePlayerStatsData(allWielder.Owner);
			}
		}

		private void SavePlayerStatsData(Photon.Realtime.Player player)
		{
			int remainingHealth = (int)PlayerProperty.Get("HP", player);
			int manaUsed = (int)PlayerProperty.Get("MA", player);
			int num = (int)PlayerProperty.Get("DD", player);
			int pickupsUsed = (int)PlayerProperty.Get("PU", player);
			if (player.IsLocal)
			{
				PlayerData = new PlayerMatchStatsData(remainingHealth, manaUsed, num, pickupsUsed);
				if (num >= 200)
				{
					GameControl.Instance.UnlockAchievement(Assets.Scripts.Enums.AchievementType.Deal200Damage);
				}
			}
			else
			{
				OpponentData = new PlayerMatchStatsData(remainingHealth, manaUsed, num, pickupsUsed);
			}
		}

		private void UpdateEloRatings(EndState endState, MatchType matchType)
		{
			PrevEloRatings = EloHandler.GetPlayerScores(getActualScores: true);
			UpdatedEloRatings = ((!ShouldAffectRating) ? PrevEloRatings : GetUpdatedRatings(endState));
			if (CanPlayerEarnRating)
			{
				int eloChange = UpdatedEloRatings[0] - PrevEloRatings[0];
				Events.EloChangedEvent eloChangedEvent = new Events.EloChangedEvent();
				eloChangedEvent.EndState = endState;
				eloChangedEvent.MatchType = matchType;
				eloChangedEvent.EloChange = eloChange;
				EventHub.Publish(eloChangedEvent);
			}
		}

		private void UpdateSeasonScore(EndState endState)
		{
			PrevSeasonScore = GameControl.Instance.Player.SeasonScore;
			UpdatedSeasonScore = ((!SeasonControl.SeasonLocked) ? GetUpdatedSeasonScore(endState) : PrevSeasonScore.Value);
		}

		private int[] GetUpdatedRatings(EndState endState)
		{
			return (!ShouldAffectRating) ? EloHandler.GetPlayerScores() : EloHandler.GetUpdatedRatings(endState);
		}

		private int GetUpdatedSeasonScore(EndState endState)
		{
			if (ShouldAffectRating && CanPlayerEarnRating)
			{
				return EloHandler.GetUpdatedSeasonScore(endState);
			}
			return GameControl.Instance.Player.SeasonScore;
		}

		private void SaveLevelData(PlayerLevelData levelData)
		{
			PlayerLevel = levelData.Level;
			PlayerExperience = levelData.CurrentExperience;
		}

		private void EmptyQueues()
		{
			m_playerEarnedRewards.Clear();
			m_opponentEarnedBadges.Clear();
		}

		private void CheckBadgesEarned(EndState state)
		{
			SaveLevelData(GameControl.Instance.Player.SaveData.LevelData);
			m_totalXpGain = 0;
			TotalDustGain = 0;
			m_playerEarnedBadges.Clear();
			m_opponentEarnedBadges.Clear();
			BadgeUtils.CheckBadgesEarned(state, PlayerManager.Instance.LocalWielder, PlayerManager.Instance.GetOpponentWielder(), EnqueuePlayerBadge, EnqueueOpponentBadge);
		}

		public bool GetBadgeEarned(string name)
		{
			MatchRewardType result = MatchRewardType.Stop;
			return Enum.TryParse<MatchRewardType>(name, out result) && (m_playerEarnedBadges.Contains(result) || m_opponentEarnedBadges.Contains(result));
		}

		public bool GetPlayerBadgeEarned(string name)
		{
			MatchRewardType result = MatchRewardType.Stop;
			return Enum.TryParse<MatchRewardType>(name, out result) && m_playerEarnedBadges.Contains(result);
		}

		public bool DequeuePlayerBadge(out MatchReward matchReward)
		{
			if (m_playerEarnedRewards.IsNullOrEmpty())
			{
				matchReward = default(MatchReward);
				return false;
			}
			matchReward = m_playerEarnedRewards.Dequeue();
			return true;
		}

		public MatchRewardType DequeueOpponentBadge()
		{
			return (!m_opponentEarnedBadges.IsNullOrEmpty()) ? m_opponentEarnedBadges.Dequeue() : MatchRewardType.Stop;
		}

		private void EnqueuePlayerBadge(MatchRewardType badge)
		{
			if (badge == MatchRewardType.Stop)
			{
				GameControl.Instance.Player.AddExperience(m_totalXpGain);
				GameControl.Instance.Player.AddVirtualCurrency(TotalDustGain, VirtualCurrencySource.Dailies, saveToServer: true);
			}
			else if (m_playerEarnedBadges.Add(badge))
			{
				MatchRewardsObject matchRewardEntry = PlayFabTitleData.GetMatchRewardEntry(badge);
				int num = matchRewardEntry.XPReward * CustomEventFetcher.Instance.ExperienceMultiplier;
				int dustReward = matchRewardEntry.DustReward;
				RewardModifiers rewardModifiers = GameControl.Instance.Player.RewardModifiers;
				m_totalXpGain += (int)((float)num * rewardModifiers.Experience);
				TotalDustGain += (int)((float)dustReward * rewardModifiers.Currency);
				MatchReward item = new MatchReward(badge, num, rewardModifiers.Experience, dustReward, rewardModifiers.Currency);
				m_playerEarnedRewards.Enqueue(item);
			}
		}

		private void EnqueueOpponentBadge(MatchRewardType badge)
		{
			if (!m_opponentEarnedBadges.Contains(badge))
			{
				m_opponentEarnedBadges.Enqueue(badge);
			}
		}
	}
	public class LobbyManager : PunSingleton<LobbyManager>
	{
		private static bool sm_forceSpawnBot;

		[SerializeField]
		private CountdownHandler m_countdownHandler;

		[SerializeField]
		private float m_survivalTransitionTime = 5f;

		[SerializeField]
		private Transform m_remoteCharacterSpawnParent;

		private bool m_isInitialized;

		private bool m_rematchPending;

		private float m_readyRematchWaitTime;

		private Coroutine m_awaitOpponentCoroutine;

		private WaitForSeconds m_opponentWait = new WaitForSeconds(0.5f);

		private Transform m_relicIconParent;

		private GameObject m_teleportArrive;

		private EventToken m_countdownEndedEventToken;

		private EventToken m_photonPlayerConnectedEventToken;

		private EventToken m_photonPlayerDisconnectedEventToken;

		private EventToken m_wielderSpawnedEventToken;

		private EventToken m_levelInitializedEventToken;

		private EventToken m_photonConnectionFailedEventToken;

		private EventToken m_lobbyPausedEventToken;

		private EventToken m_connectedToMatchRoomEventToken;

		private bool IsBotMatch
		{
			[CompilerGenerated]
			get
			{
				return MonoSingleton<NetworkManager>.Instance.CurrentMatchType.ContainsFlag(MatchType.Bot);
			}
		}

		public CountdownHandler CountdownHandler
		{
			[CompilerGenerated]
			get
			{
				return m_countdownHandler;
			}
		}

		public Transform RemoteCharacterSpawnParent
		{
			[CompilerGenerated]
			get
			{
				return m_remoteCharacterSpawnParent;
			}
		}

		public Transform RelicIconParent
		{
			[CompilerGenerated]
			get
			{
				return (!(m_relicIconParent != null)) ? (m_relicIconParent = base.transform.RetrieveChild("Relic_Icons")) : m_relicIconParent;
			}
		}

		public int ReadyRematchCount { get; private set; }

		public bool IsReady { get; private set; }

		public LobbyState State { get; private set; }

		private void OnEnable()
		{
			m_photonPlayerConnectedEventToken = EventHub.Subscribe<NetworkEvents.PhotonPlayerConnectedEvent>(OnPhotonPlayerConnected);
			m_photonPlayerDisconnectedEventToken = EventHub.Subscribe<NetworkEvents.PhotonPlayerDisconnectedEvent>(OnPhotonPlayerDisconnected);
			m_countdownEndedEventToken = EventHub.Subscribe<Events.CountdownEndedEvent>(OnCountdownEnded);
			m_wielderSpawnedEventToken = EventHub.Subscribe<Events.WielderSpawnedEvent>(OnWielderSpawned);
			m_levelInitializedEventToken = EventHub.Subscribe<Events.LevelInitializedEvent>(OnLevelInitialized);
			m_photonConnectionFailedEventToken = EventHub.Subscribe<NetworkEvents.PhotonConnectionFailedEvent>(OnPhotonConnectionFailedEvent);
			m_lobbyPausedEventToken = EventHub.Subscribe<Events.LobbyPausedEvent>(OnLobbyPaused);
		}

		protected override void OnDisable()
		{
			base.OnDisable();
			StopAllCoroutines();
			EventHub.Unsubscribe<NetworkEvents.PhotonPlayerConnectedEvent>(m_photonPlayerConnectedEventToken);
			EventHub.Unsubscribe<NetworkEvents.PhotonPlayerDisconnectedEvent>(m_photonPlayerDisconnectedEventToken);
			EventHub.Unsubscribe<Events.CountdownEndedEvent>(m_countdownEndedEventToken);
			EventHub.Unsubscribe<Events.WielderSpawnedEvent>(m_wielderSpawnedEventToken);
			EventHub.Unsubscribe<Events.LevelInitializedEvent>(m_levelInitializedEventToken);
			EventHub.Unsubscribe<NetworkEvents.PhotonConnectionFailedEvent>(m_photonConnectionFailedEventToken);
			EventHub.Unsubscribe<Events.LobbyPausedEvent>(m_lobbyPausedEventToken);
			if (m_connectedToMatchRoomEventToken != null)
			{
				EventHub.Unsubscribe<Events.ConnectedToMatchRoom>(m_connectedToMatchRoomEventToken);
				m_connectedToMatchRoomEventToken = null;
			}
		}

		protected override void Awake()
		{
			base.Awake();
			m_teleportArrive = GameObjectLoader.GetGameObject(AssetBundleType.Spells, PoolObjectType.TeleportArrive.ToString());
		}

		private void Start()
		{
			if (GameControl.Instance.Player != null)
			{
				WandsAnalytics.SendCustomEvent(CustomEventType.player_entered_lobby, new Dictionary<string, object>
				{
					{
						"ArenaId",
						(int)(PhotonNetwork.InRoom ? GetNextArena() : Arena.None)
					},
					{
						"Rating",
						GameControl.Instance.Player.Rating
					},
					{
						"MatchesPlayed",
						GameControl.Instance.Player.SaveData.MatchData.MatchesPlayed
					},
					{
						"SpellsUnlocked",
						GameControl.Instance.Player.GetNumberOfOwnedSpells() - 1
					}
				});
			}
			LobbyState newState = ((GameControl.Instance.GetPreviousLevel().ContainsFlag(Level.Arena) && (bool)RoomProperty.GetRoomProperty("C5")) ? LobbyState.Post : LobbyState.Pre);
			ChangeState(newState, force: true);
			m_isInitialized = true;
		}

		private void OnWielderSpawned(Events.WielderSpawnedEvent eventData)
		{
			if (PlayerManager.Instance.IsGameFull && State != LobbyState.Post)
			{
				ChangeState(LobbyState.Pre, force: true);
			}
		}

		private void OnLevelInitialized(Events.LevelInitializedEvent eventData)
		{
			PhotonNetwork.IsMessageQueueRunning = true;
			if (IsBotMatch && (GameControl.Instance.GetPreviousLevel().ContainsFlag(Level.Workshop) || sm_forceSpawnBot))
			{
				sm_forceSpawnBot = false;
				BotControl botControl = UnityEngine.Object.Instantiate(Resources.Load<BotControl>("BotControl"));
				botControl.SpawnInLobby();
				MonoSingleton<LobbyUI>.Instance.PlayerConnected();
				StartWaitForOpponent(showMsg: true);
			}
		}

		private void OnCountdownEnded(Events.CountdownEndedEvent eventData)
		{
			EndCountdown();
		}

		private void OnPhotonPlayerConnected(NetworkEvents.PhotonPlayerConnectedEvent eventData)
		{
			PhotonPlayerConnected(eventData.PhotonPlayer);
		}

		private void OnLobbyPaused(Events.LobbyPausedEvent eventData)
		{
			if (!NetworkUtils.ConnectedToGame)
			{
				OnConnectionLost();
			}
			else if (PlayerManager.Instance.IsGameFull && State == LobbyState.Pre)
			{
				if (eventData.IsPaused)
				{
					CountdownHandler.PauseCountdown();
				}
				else
				{
					CountdownHandler.StartCountdown();
				}
			}
		}

		private void PhotonPlayerConnected(Photon.Realtime.Player otherPlayer)
		{
			if (PhotonNetwork.IsMasterClient)
			{
				ResetVariables();
				MonoSingleton<LobbyUI>.Instance.PlayerConnected();
				StartWaitForOpponent(showMsg: true);
			}
		}

		private void OnPhotonPlayerDisconnected(NetworkEvents.PhotonPlayerDisconnectedEvent eventData)
		{
			PhotonPlayerDisconnected(eventData.PhotonPlayer);
		}

		private void PhotonPlayerDisconnected(Photon.Realtime.Player otherPlayer)
		{
			if (m_isInitialized)
			{
				StopAllCoroutines();
				PlayerManager.Instance?.RemoveRemoteCharacter();
				MonoSingleton<NetworkManager>.Instance.ResetMatchType();
				CountdownHandler.CancelCountdown();
				MonoSingleton<LobbyUI>.Instance.PlayerDisconnected(State != LobbyState.Post);
				ReadyRematchCount = ((m_rematchPending || IsReady) ? 1 : 0);
				RoomProperty.SetRoomProperty("A3", value: false);
				if (State != LobbyState.Post)
				{
					ResetRoomProperties();
				}
			}
		}

		private void OnPhotonConnectionFailedEvent(NetworkEvents.PhotonConnectionFailedEvent eventData)
		{
			OnConnectionLost();
		}

		private void OnConnectedToMatchRoom(Events.ConnectedToMatchRoom eventData)
		{
			if (m_connectedToMatchRoomEventToken != null)
			{
				EventHub.Unsubscribe<Events.ConnectedToMatchRoom>(m_connectedToMatchRoomEventToken);
				m_connectedToMatchRoomEventToken = null;
			}
			ExpandedSingleton<LevelLoader>.Instance.LoadLevel(Level.Lobby, 0f, forceIfSameScene: true);
		}

		private void OnConnectionLost()
		{
			MonoSingleton<LobbyUI>.Instance.OnConnectionLost();
			GameControl.Instance.LeaveGame(m_survivalTransitionTime, penalizePlayer: false, quitGame: false);
		}

		public void ChangeState(LobbyState newState, bool force = false)
		{
			if (newState != State || force)
			{
				State = newState;
				switch (newState)
				{
				case LobbyState.Pre:
					ChangeToPreState();
					break;
				case LobbyState.Post:
					ChangeToPostState();
					break;
				default:
					throw new NotImplementedException("LobbyState not implemented: " + newState);
				}
			}
		}

		private void ChangeToPreState()
		{
			(PunSingleton<SoundManager>.Instance as SoundManagerLobby)?.PlayLobbyMusic();
			EventHub.Publish(new Events.EnterPreMatchEvent());
			if (PhotonNetwork.IsMasterClient && !PlayerManager.Instance.IsGameFull)
			{
				ResetRoomProperties();
			}
		}

		private void ChangeToPostState()
		{
			ShowPostMatchScenery();
			EventHub.Publish(new Events.EnterPostMatchEvent());
		}

		public void StartBotMatch()
		{
			if (State == LobbyState.Pre)
			{
				sm_forceSpawnBot = true;
				m_connectedToMatchRoomEventToken = EventHub.Subscribe<Events.ConnectedToMatchRoom>(OnConnectedToMatchRoom);
				MonoSingleton<NetworkManager>.Instance.LeaveAndCreateNewRoom(null, RoomCreationType.Create, RoomCreationReason.Bot, ArenaUtils.GetRandomArena(Arena.None, MatchType.Bot), MatchType.Bot);
				ExpandedSingleton<FadeHandler>.Instance.FadeOut(1f);
			}
		}

		[PunRPC]
		public void ShowLobbyScenery()
		{
			ChangeState(LobbyState.Pre);
		}

		private void ShowPostMatchScenery()
		{
			ResetVariables();
		}

		private void ResetRoomProperties()
		{
			RoomProperty.SetRoomProperty("A6", value: false);
			RoomProperty.SetRoomProperty("C5", value: false);
			RoomProperty.SetRoomProperty("A3", value: false);
			if (GameControl.Instance.GetPreviousLevel() != Level.Workshop || !MonoSingleton<NetworkManager>.Instance.CurrentMatchType.ContainsFlag(MatchType.Casual))
			{
				MatchType matchType = RoomProperty.GetMatchType();
				Arena result = Arena.None;
				Enum.TryParse<Arena>((string)RoomProperty.GetRoomProperty("A2"), out result);
				RoomProperty.SetRoomProperty("A2", ArenaUtils.GetRandomArena(result, matchType).ToString());
			}
		}

		private void ResetVariables()
		{
			IsReady = false;
			m_rematchPending = false;
			ReadyRematchCount = 0;
		}

		public void RequestRematch()
		{
			if (!PlayerManager.Instance.IsGameFull)
			{
				ResetRoomProperties();
			}
			else if (!m_rematchPending)
			{
				if (IsBotMatch)
				{
					ReadyRematchCount = 1;
				}
				m_rematchPending = true;
				base.photonView.RPC("PunPingRematch", RpcTarget.Others, false);
				PunPingRematch(localRequest: true);
				if (PhotonNetwork.IsMasterClient)
				{
					StopAllCoroutines();
					m_readyRematchWaitTime = 0f;
					StartCoroutine(PendingRematch());
				}
			}
		}

		[PunRPC]
		private void PunPingRematch(bool localRequest)
		{
			ReadyRematchCount = (ReadyRematchCount + 1).Wrap(0, 2);
			Events.PlayerRequestedRematchEvent playerRequestedRematchEvent = new Events.PlayerRequestedRematchEvent();
			playerRequestedRematchEvent.IsLocalPlayer = localRequest;
			EventHub.Publish(playerRequestedRematchEvent);
		}

		private IEnumerator PendingRematch()
		{
			while (m_readyRematchWaitTime < 2f)
			{
				m_readyRematchWaitTime += Time.deltaTime;
				yield return null;
			}
			while (ReadyRematchCount < 2)
			{
				yield return null;
			}
			InitiateRematch(startWaitForOpponent: true);
		}

		public void InitiateRematch(bool startWaitForOpponent)
		{
			ResetVariables();
			ResetRoomProperties();
			base.photonView.RPC("ShowLobbyScenery", RpcTarget.AllViaServer);
			RoomProperty.SetRoomProperty("A3", startWaitForOpponent);
			if (startWaitForOpponent)
			{
				StartWaitForOpponent();
			}
		}

		public void ToggleReady()
		{
			IsReady = !IsReady;
			if (IsBotMatch)
			{
				ReadyRematchCount = 1;
			}
			base.photonView.RPC("PunPingReady", RpcTarget.Others, IsReady, false);
			PunPingReady(IsReady, localRequest: true);
			if (PhotonNetwork.IsMasterClient)
			{
				StopAllCoroutines();
				if (IsReady)
				{
					StartCoroutine(PendingReady());
				}
			}
		}

		[PunRPC]
		private void PunPingReady(bool isReady, bool localRequest)
		{
			ReadyRematchCount = Mathf.Clamp(ReadyRematchCount + (isReady ? 1 : (-1)), 0, 2);
			Events.PlayerReadyEvent playerReadyEvent = new Events.PlayerReadyEvent();
			playerReadyEvent.IsReady = isReady;
			playerReadyEvent.IsLocalPlayer = localRequest;
			EventHub.Publish(playerReadyEvent);
		}

		private IEnumerator PendingReady()
		{
			while (ReadyRematchCount < 2)
			{
				yield return null;
			}
			CountdownHandler.SetCountdownTime(5f);
		}

		public void StartWaitForOpponent(bool showMsg = false)
		{
			if (m_awaitOpponentCoroutine != null)
			{
				StopCoroutine(m_awaitOpponentCoroutine);
				m_awaitOpponentCoroutine = null;
			}
			m_awaitOpponentCoroutine = StartCoroutine(AwaitOpponent());
		}

		private IEnumerator AwaitOpponent()
		{
			while (PlayerManager.Instance.WielderCount < 2)
			{
				yield return null;
			}
			yield return m_opponentWait;
			CountdownHandler.StartCountdown();
		}

		private void EndCountdown()
		{
			UnityEngine.Object.Instantiate(m_teleportArrive).GetComponent<PoolObject>().PunEnableObject(new Vector3(0f, 0f, -2.5f));
			PlayerManager.Instance?.RemoveRemoteCharacter();
			if (PhotonNetwork.IsMasterClient)
			{
				RoomProperty.SetRoomProperty("A4", (PhotonNetwork.CurrentRoom.Name + PhotonNetwork.Time).GetHashCode());
				StartMatch();
			}
		}

		private void StartMatch()
		{
			ClearPlayerObjects();
			StartCoroutine(AwaitWielderDestroyed());
		}

		private void ClearPlayerObjects()
		{
			PlayerManager.Instance.PlayerControl.ToggleInputActive(active: false);
			Wielder opponent = null;
			if (PlayerManager.Instance.CanGetOpponentWielder(out opponent))
			{
				opponent.RemoteCharacter?.DestroySelf();
				if (IsBotMatch)
				{
					PlayerManager.Instance.RemoveWielder(opponent);
					UnityEngine.Object.Destroy(opponent);
				}
				else
				{
					PhotonNetwork.RemoveRPCs(opponent.Owner);
					PhotonNetwork.RemoveRPCs(opponent.photonView);
					PhotonNetwork.DestroyPlayerObjects(opponent.Owner.ActorNumber);
				}
			}
			Wielder localWielder = PlayerManager.Instance.LocalWielder;
			PhotonNetwork.RemoveRPCs(localWielder.Owner);
			PhotonNetwork.RemoveRPCs(localWielder.photonView);
			PhotonNetwork.DestroyPlayerObjects(localWielder.Owner.ActorNumber);
		}

		private IEnumerator AwaitWielderDestroyed()
		{
			WaitForSeconds wait = new WaitForSeconds(1f);
			while (PlayerManager.Instance.WielderCount > 0)
			{
				PlayerManager.Instance.UpdateWielderList();
				yield return wait;
			}
			yield return wait;
			InitiateSceneryChange();
		}

		public void InitiateSceneryChange()
		{
			base.photonView.RPC("PunLoadRematchLevel", RpcTarget.AllViaServer, (int)GetNextArena());
		}

		private Arena GetNextArena()
		{
			string text = (string)RoomProperty.GetRoomProperty("A2");
			Arena result = Arena.None;
			if (string.IsNullOrEmpty(text))
			{
				if (UnityEngine.Application.isEditor)
				{
					return Arena.AspisPrison;
				}
				object[] obj = new object[4]
				{
					"RoomProperty ARENA was not set. InRoom: ",
					PhotonNetwork.InRoom,
					". Players in room: ",
					null
				};
				int? num = PhotonNetwork.PlayerList?.Length;
				obj[3] = (num.HasValue ? num.Value : 0);
				WandsLogger.LogError(string.Concat(obj));
			}
			else if (Enum.TryParse<Arena>(text, out result))
			{
				return result;
			}
			throw new UnityException("Couldn't parse RoomProperty Arena. Was " + text);
		}

		[PunRPC]
		private void PunLoadRematchLevel(int arenaValue)
		{
			WandsAnalytics.SendCustomEvent(CustomEventType.player_left_lobby, new Dictionary<string, object> { { "Reason", 2 } });
			ExpandedSingleton<LevelLoader>.Instance.LoadLevel((Arena)arenaValue, 1f);
		}

		private void OnApplicationQuit()
		{
			WandsAnalytics.SendCustomEvent(CustomEventType.player_left_lobby, new Dictionary<string, object> { { "Reason", 1 } });
			Matchmaker.CancelMatchmaking();
		}
	}
}
namespace Assets.Scripts.Network
{
	public class MatchManager : MonoBehaviour
	{
		private EventToken m_photonConnectionFailedEventToken;

		private EventToken m_photonPlayerDisconnectedEventToken;

		private EventToken m_playerControlSpawnedEventToken;

		private EventToken m_levelInitializedEventToken;

		private void OnEnable()
		{
			m_photonConnectionFailedEventToken = EventHub.Subscribe<NetworkEvents.PhotonConnectionFailedEvent>(OnPhotonConnectionFailedEvent);
			m_photonPlayerDisconnectedEventToken = EventHub.Subscribe<NetworkEvents.PhotonPlayerDisconnectedEvent>(OnPhotonPlayerDisconnectedEvent);
			m_playerControlSpawnedEventToken = EventHub.Subscribe<Events.PlayerControlSpawnedEvent>(OnPlayerControlSpawnedEvent);
			m_levelInitializedEventToken = EventHub.Subscribe<Events.LevelInitializedEvent>(OnLevelInitializedEvent);
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe<NetworkEvents.PhotonConnectionFailedEvent>(m_photonConnectionFailedEventToken);
			EventHub.Unsubscribe<NetworkEvents.PhotonPlayerDisconnectedEvent>(m_photonPlayerDisconnectedEventToken);
			EventHub.Unsubscribe<Events.PlayerControlSpawnedEvent>(m_playerControlSpawnedEventToken);
			EventHub.Unsubscribe<Events.LevelInitializedEvent>(m_levelInitializedEventToken);
		}

		private void OnLevelInitializedEvent(Events.LevelInitializedEvent eventData)
		{
			PhotonNetwork.IsMessageQueueRunning = true;
		}

		private void OnPhotonPlayerDisconnectedEvent(NetworkEvents.PhotonPlayerDisconnectedEvent eventData)
		{
			if (eventData.PhotonPlayer != null && PhotonNetwork.IsMasterClient)
			{
				PhotonNetwork.RemoveRPCs(eventData.PhotonPlayer);
				PhotonNetwork.RemoveRPCs(PunSingleton<SoundManager>.Instance.photonView);
			}
		}

		public void OnPhotonConnectionFailedEvent(NetworkEvents.PhotonConnectionFailedEvent eventData)
		{
			switch (eventData.Cause)
			{
			case DisconnectCause.ServerTimeout:
				EndGame(EndState.ConnectionLostServer);
				break;
			case DisconnectCause.Exception:
			case DisconnectCause.ClientTimeout:
				EndGame(EndState.ConnectionLostClient);
				break;
			default:
				WandsLogger.LogError($"MatchManager OnPhotonConnectionFailedEvent did not handle the following photon connection loss gracefully: {eventData.Cause}");
				break;
			}
		}

		public void OnPlayerControlSpawnedEvent(Events.PlayerControlSpawnedEvent eventData)
		{
			if (GameControl.Instance.GetCurrentLevel() == Level.Basement)
			{
				PlayerManager.Instance.PlayerControl.ToggleInputActive(active: true);
			}
		}

		private void EndGame(EndState endState)
		{
			if (GameControl.Instance.IsGamePaused && PunSingleton<SceneControl>.Instance != null)
			{
				PunSingleton<SceneControl>.Instance.EndMatchPause(EndState.ForceLost);
			}
			if (!GameControl.Instance.GetCurrentLevel().ContainsFlag(Level.Arena))
			{
				WandsLogger.LogError("MatchManager | Trying to end game while not being in an arena!");
				return;
			}
			if (PlayerManager.Instance.PlayerControl != null)
			{
				PlayerManager.Instance.PlayerControl.ToggleInputActive(active: true);
				PlayerManager.Instance.PlayerControl.SetSpellInputActive(active: false);
			}
			else
			{
				WandsLogger.LogError("MatchManager | Local player is null!");
			}
			PunSingleton<SceneControl>.Instance.CountdownHandler.StopAllCoroutines();
			Move[] array = UnityEngine.Object.FindObjectsOfType<Move>();
			for (int i = 0; i < array.Length; i++)
			{
				array[i].PauseMovement();
			}
			if (MonoSingleton<NetworkManager>.Instance.CurrentMatchType.ContainsFlag(MatchType.Bot))
			{
				Wielder opponentWielder = PlayerManager.Instance.GetOpponentWielder();
				if (opponentWielder != null && opponentWielder.IsBot)
				{
					opponentWielder.BotControl?.PauseFromNetworkDisconnection();
				}
			}
			MonoSingleton<ArenaUI>.Instance?.SetEndMenuActive(endState);
		}
	}
}
[RequireComponent(typeof(MeshFilter))]
public class MeshMorpher : MonoBehaviour
{
	public Mesh[] m_Meshes;

	public bool m_AnimateAutomatically = true;

	public float m_OneLoopLength = 1f;

	public WrapMode m_WrapMode = WrapMode.Loop;

	private float m_AutomaticTime;

	private int m_SrcMesh = -1;

	private int m_DstMesh = -1;

	private float m_Weight = -1f;

	private Mesh m_Mesh;

	private bool m_animate;

	private bool m_enable;

	public bool IsAnimating => m_animate;

	public void SetComplexMorph(int srcIndex, int dstIndex, float t)
	{
		if (m_SrcMesh != srcIndex || m_DstMesh != dstIndex || !Mathf.Approximately(m_Weight, t))
		{
			Vector3[] vertices = m_Meshes[srcIndex].vertices;
			Vector3[] vertices2 = m_Meshes[dstIndex].vertices;
			Vector3[] array = new Vector3[m_Mesh.vertexCount];
			for (int i = 0; i < array.Length; i++)
			{
				ref Vector3 reference = ref array[i];
				reference = Vector3.Lerp(vertices[i], vertices2[i], t);
			}
			m_Mesh.vertices = array;
			m_Mesh.RecalculateBounds();
		}
	}

	public void SetMorph(float t)
	{
		int value = (int)t;
		value = Mathf.Clamp(value, 0, m_Meshes.Length - 2);
		float num = t - (float)value;
		num = Mathf.Clamp(t - (float)value, 0f, 1f);
		SetComplexMorph(value, value + 1, num);
	}

	private void Awake()
	{
		base.enabled = m_AnimateAutomatically;
		MeshFilter meshFilter = GetComponent(typeof(MeshFilter)) as MeshFilter;
		for (int i = 0; i < m_Meshes.Length; i++)
		{
			if (m_Meshes[i] == null)
			{
				m_AnimateAutomatically = false;
				return;
			}
		}
		if (m_Meshes.Length < 2)
		{
			m_AnimateAutomatically = false;
			return;
		}
		meshFilter.sharedMesh = m_Meshes[0];
		m_Mesh = meshFilter.mesh;
		int vertexCount = m_Mesh.vertexCount;
		for (int j = 0; j < m_Meshes.Length; j++)
		{
			if (m_Meshes[j].vertexCount != vertexCount)
			{
				m_AnimateAutomatically = false;
				break;
			}
		}
	}

	public void SetVinesActive(bool enable)
	{
		m_WrapMode = WrapMode.Once;
		m_AutomaticTime = ((!enable) ? ((float)(m_Meshes.Length - 1)) : 0f);
		m_enable = enable;
		m_animate = true;
		AudioSource component = GetComponent<AudioSource>();
		if (component != null)
		{
			if (enable)
			{
				component.PlayDelayed(m_OneLoopLength);
			}
			else
			{
				component.Stop();
			}
		}
	}

	private void Update()
	{
		if (!m_animate || !m_AnimateAutomatically)
		{
			return;
		}
		float num = Time.deltaTime * (float)(m_Meshes.Length - 1) / m_OneLoopLength;
		m_AutomaticTime += ((!m_enable) ? (0f - num) : num);
		float num2 = ((m_WrapMode == WrapMode.Loop) ? Mathf.Repeat(m_AutomaticTime, m_Meshes.Length - 1) : ((m_WrapMode != WrapMode.PingPong) ? Mathf.Clamp(m_AutomaticTime, 0f, m_Meshes.Length - 1) : Mathf.PingPong(m_AutomaticTime, m_Meshes.Length - 1)));
		if (num2 < (float)(m_Meshes.Length - 1) && num2 > 0f)
		{
			SetMorph(num2);
			return;
		}
		if (!m_enable)
		{
			GetComponent<Renderer>().enabled = false;
		}
		m_animate = false;
	}
}
namespace Assets.Scripts.Platform
{
	public static class MinimumVersionControl
	{
		private static Action m_onCompleted;

		public static Version MinimumVersion { get; private set; }

		public static void GetMinimumVersion(ICloudManager cloudManager, Action onCompleted)
		{
			m_onCompleted = onCompleted;
			cloudManager.GetMinimumVersion<ExecuteCloudScriptResult>(OnGetMinimumVersionSuccess, OnGetMinimumVersionError);
		}

		private static void OnGetMinimumVersionSuccess(ExecuteCloudScriptResult result)
		{
			JsonObject jsonObject = (JsonObject)result.FunctionResult;
			try
			{
				MinimumVersion = Version.Parse(jsonObject["PlayStation"].ToString());
				m_onCompleted();
			}
			catch (Exception ex)
			{
				WandsLogger.LogError($"MinimumVersion is defined wrong on the Playfab CloudScript: {ex.Message}");
			}
		}

		private static void OnGetMinimumVersionError(string error)
		{
			WandsLogger.LogError("RequestMinimumVersion Error: " + error);
			Events.PlayfabDataLoadedEvent playfabDataLoadedEvent = new Events.PlayfabDataLoadedEvent();
			playfabDataLoadedEvent.Success = false;
			EventHub.Publish(playfabDataLoadedEvent);
		}
	}
}
[ExecuteInEditMode]
public class MirrorReflection : MonoBehaviour
{
	public bool m_DisablePixelLights = true;

	public int m_TextureSize = 256;

	public float m_ClipPlaneOffset = 0.07f;

	public LayerMask m_ReflectLayers = -1;

	private System.Collections.Hashtable m_ReflectionCameras = new System.Collections.Hashtable();

	private RenderTexture m_ReflectionTexture;

	private int m_OldReflectionTextureSize;

	private static bool s_InsideRendering;

	public void OnWillRenderObject()
	{
		Renderer component = GetComponent<Renderer>();
		if (!base.enabled || !component || !component.sharedMaterial || !component.enabled)
		{
			return;
		}
		Camera current = Camera.current;
		if (!current || s_InsideRendering)
		{
			return;
		}
		s_InsideRendering = true;
		CreateMirrorObjects(current, out var reflectionCamera);
		Vector3 position = base.transform.position;
		Vector3 up = base.transform.up;
		int pixelLightCount = QualitySettings.pixelLightCount;
		if (m_DisablePixelLights)
		{
			QualitySettings.pixelLightCount = 0;
		}
		UpdateCameraModes(current, reflectionCamera);
		float w = 0f - Vector3.Dot(up, position) - m_ClipPlaneOffset;
		Vector4 plane = new Vector4(up.x, up.y, up.z, w);
		Matrix4x4 reflectionMat = Matrix4x4.zero;
		CalculateReflectionMatrix(ref reflectionMat, plane);
		Vector3 position2 = current.transform.position;
		Vector3 position3 = reflectionMat.MultiplyPoint(position2);
		reflectionCamera.worldToCameraMatrix = current.worldToCameraMatrix * reflectionMat;
		Vector4 clipPlane = CameraSpacePlane(reflectionCamera, position, up, 1f);
		Matrix4x4 projectionMatrix = current.CalculateObliqueMatrix(clipPlane);
		reflectionCamera.projectionMatrix = projectionMatrix;
		reflectionCamera.cullingMask = -17 & m_ReflectLayers.value;
		reflectionCamera.targetTexture = m_ReflectionTexture;
		GL.invertCulling = true;
		reflectionCamera.transform.position = position3;
		reflectionCamera.useOcclusionCulling = false;
		Vector3 eulerAngles = current.transform.eulerAngles;
		reflectionCamera.transform.eulerAngles = new Vector3(0f, eulerAngles.y, eulerAngles.z);
		reflectionCamera.Render();
		reflectionCamera.transform.position = position2;
		GL.invertCulling = false;
		Material[] sharedMaterials = component.sharedMaterials;
		Material[] array = sharedMaterials;
		foreach (Material material in array)
		{
			if (material.HasProperty("_ReflectionTex"))
			{
				material.SetTexture("_ReflectionTex", m_ReflectionTexture);
			}
		}
		if (m_DisablePixelLights)
		{
			QualitySettings.pixelLightCount = pixelLightCount;
		}
		s_InsideRendering = false;
	}

	private void OnDisable()
	{
		if ((bool)m_ReflectionTexture)
		{
			UnityEngine.Object.DestroyImmediate(m_ReflectionTexture);
			m_ReflectionTexture = null;
		}
		foreach (DictionaryEntry reflectionCamera in m_ReflectionCameras)
		{
			UnityEngine.Object.DestroyImmediate(((Camera)reflectionCamera.Value).gameObject);
		}
		m_ReflectionCameras.Clear();
	}

	private void UpdateCameraModes(Camera src, Camera dest)
	{
		if (dest == null)
		{
			return;
		}
		dest.clearFlags = src.clearFlags;
		dest.backgroundColor = src.backgroundColor;
		if (src.clearFlags == CameraClearFlags.Skybox)
		{
			Skybox skybox = src.GetComponent(typeof(Skybox)) as Skybox;
			Skybox skybox2 = dest.GetComponent(typeof(Skybox)) as Skybox;
			if (!skybox || !skybox.material)
			{
				skybox2.enabled = false;
			}
			else
			{
				skybox2.enabled = true;
				skybox2.material = skybox.material;
			}
		}
		dest.farClipPlane = src.farClipPlane;
		dest.nearClipPlane = src.nearClipPlane;
		dest.orthographic = src.orthographic;
		dest.fieldOfView = src.fieldOfView;
		dest.aspect = src.aspect;
		dest.orthographicSize = src.orthographicSize;
	}

	private void CreateMirrorObjects(Camera currentCamera, out Camera reflectionCamera)
	{
		reflectionCamera = null;
		if (!m_ReflectionTexture || m_OldReflectionTextureSize != m_TextureSize)
		{
			if ((bool)m_ReflectionTexture)
			{
				UnityEngine.Object.DestroyImmediate(m_ReflectionTexture);
			}
			m_ReflectionTexture = new RenderTexture(m_TextureSize, m_TextureSize, 16);
			m_ReflectionTexture.name = "__MirrorReflection" + GetInstanceID();
			m_ReflectionTexture.isPowerOfTwo = true;
			m_ReflectionTexture.hideFlags = HideFlags.DontSave;
			m_OldReflectionTextureSize = m_TextureSize;
		}
		reflectionCamera = m_ReflectionCameras[currentCamera] as Camera;
		if (!reflectionCamera)
		{
			GameObject gameObject = new GameObject("Mirror Refl Camera id" + GetInstanceID() + " for " + currentCamera.GetInstanceID(), typeof(Camera), typeof(Skybox));
			reflectionCamera = gameObject.GetComponent<Camera>();
			reflectionCamera.enabled = false;
			reflectionCamera.transform.position = base.transform.position;
			reflectionCamera.transform.rotation = base.transform.rotation;
			reflectionCamera.gameObject.AddComponent<FlareLayer>();
			gameObject.hideFlags = HideFlags.HideAndDontSave;
			m_ReflectionCameras[currentCamera] = reflectionCamera;
		}
	}

	private static float sgn(float a)
	{
		if (a > 0f)
		{
			return 1f;
		}
		if (a < 0f)
		{
			return -1f;
		}
		return 0f;
	}

	private Vector4 CameraSpacePlane(Camera cam, Vector3 pos, Vector3 normal, float sideSign)
	{
		Vector3 point = pos + normal * m_ClipPlaneOffset;
		Matrix4x4 worldToCameraMatrix = cam.worldToCameraMatrix;
		Vector3 lhs = worldToCameraMatrix.MultiplyPoint(point);
		Vector3 rhs = worldToCameraMatrix.MultiplyVector(normal).normalized * sideSign;
		return new Vector4(rhs.x, rhs.y, rhs.z, 0f - Vector3.Dot(lhs, rhs));
	}

	private static void CalculateReflectionMatrix(ref Matrix4x4 reflectionMat, Vector4 plane)
	{
		reflectionMat.m00 = 1f - 2f * plane[0] * plane[0];
		reflectionMat.m01 = -2f * plane[0] * plane[1];
		reflectionMat.m02 = -2f * plane[0] * plane[2];
		reflectionMat.m03 = -2f * plane[3] * plane[0];
		reflectionMat.m10 = -2f * plane[1] * plane[0];
		reflectionMat.m11 = 1f - 2f * plane[1] * plane[1];
		reflectionMat.m12 = -2f * plane[1] * plane[2];
		reflectionMat.m13 = -2f * plane[3] * plane[1];
		reflectionMat.m20 = -2f * plane[2] * plane[0];
		reflectionMat.m21 = -2f * plane[2] * plane[1];
		reflectionMat.m22 = 1f - 2f * plane[2] * plane[2];
		reflectionMat.m23 = -2f * plane[3] * plane[2];
		reflectionMat.m30 = 0f;
		reflectionMat.m31 = 0f;
		reflectionMat.m32 = 0f;
		reflectionMat.m33 = 1f;
	}
}
public class Bound : MonoBehaviour
{
	private Renderer m_renderer;

	private bool m_isActive;

	public static LayerMask Mask => 1 << LayerMask.NameToLayer("TileBound");

	private void Start()
	{
		m_renderer = GetComponent<Renderer>();
	}

	public void SetActive(bool value)
	{
		if (m_isActive != value)
		{
			Color color = m_renderer.material.color;
			color.a = ((!value) ? 0f : 0.6f);
			m_renderer.material.color = color;
			m_isActive = value;
		}
	}
}
public class CameraRotate : MonoBehaviour
{
}
public class Colors : MonoBehaviour
{
	public static readonly Color ClearWhite = new Color(1f, 1f, 1f, 0f);

	public static readonly Color ArmorActiveRim = new Color(1f, 1f, 0.53f, 1f);

	public static readonly Color TextGold = new Color(1f, 0.85f, 0.6f, 1f);

	public static readonly Color TextBlackboard = new Color(0.37f, 0.3f, 0.06f, 1f);

	public static readonly Color TextHighlight = new Color(1f, 1f, 1f, 1f);

	public static readonly Color TextInactive = new Color(0.35f, 0.35f, 0.35f, 1f);

	public static readonly Color RadialDefault = new Color(1f, 0.185f, 0f, 1f);

	public static readonly Color RadialHighlight = new Color(1f, 0.31f, 0f, 1f);

	public static readonly Color FormAcceptEnable = new Color(0.8f, 0.8f, 0.8f, 1f);

	public static readonly Color FormAcceptDisable = new Color(0.31f, 0.31f, 0.31f, 1f);

	public static readonly Color TileColor = new Color(0f, 0.32f, 0.47f, 1f);

	public static readonly Color TileEffectColor = new Color(0f, 0.32f, 0f, 1f);

	public static readonly Color TileColorLeft = new Color(0f, 0.32f, 0.47f, 1f);

	public static readonly Color TileColorRight = new Color(0f, 0.32f, 0f, 1f);

	public static readonly Color HealthDefault = GetColor(101f, 12f, 12f, 255f);

	public static readonly Color HealthArmorActive = GetColor(155f, 155f, 75f, 255f);

	public static readonly Color ManaDefault = GetColor(9f, 36f, 104f, 255f);

	public static readonly Color ManaSuddenDeath = GetColor(9f, 36f, 255f, 255f);

	public static readonly Color IconSelected = Color.yellow;

	public static readonly Color IconSelectedDiscrete = Color.cyan;

	public static readonly Color IconDisabled = new Color(0.35f, 0.35f, 0.35f, 0.85f);

	public static readonly Color IconEnabled = Color.white;

	public static readonly Color IconBackgroundColor = new Color(0f, 0f, 0f, 0.25f);

	public static readonly Color[] RarityColors = new Color[3]
	{
		GetColor(255f, 215f, 155f, 192f),
		GetColor(155f, 185f, 255f, 192f),
		GetColor(255f, 155f, 255f, 192f)
	};

	public static readonly IReadOnlyDictionary<Spell, Color> LingeringEffectColors = new Dictionary<Spell, Color>
	{
		{
			Spell.Spell_Teleport,
			GetColor(9f, 36f, 255f, 255f)
		},
		{
			Spell.Spell_ArmorOfTheSun,
			GetColor(155f, 155f, 75f, 255f)
		},
		{
			Spell.Spell_CurseOfTheUndead,
			GetColor(132f, 25f, 244f, 255f)
		},
		{
			Spell.Spell_ChillingClutch,
			GetColor(0f, 202f, 255f, 255f)
		}
	};

	public static Color GetColor(float r, float g, float b, float a)
	{
		return new Color(r / 255f, g / 255f, b / 255f, a / 255f);
	}

	public static Color GetColor(WandsColor color)
	{
		return color switch
		{
			WandsColor.ProjectorBlack => GetColor(35f, 35f, 35f, 255f), 
			WandsColor.White => Color.white, 
			_ => Color.black, 
		};
	}
}
public class Constants
{
	public const string PROJECT_ID = "96335c74-719a-4fd9-ad83-d1c46984ac36";

	private const int WarmupLength = 25;

	public const float MATCH_LENGTH = 3.5f;

	public const float WARMUP_TIME = 30f;

	public const float COUNTDOWN_TIME = 5f;

	public const float TELEPORT_SPEED = 45f;

	public const float TELEPORT_COLLIDER_RADIUS = 1f;

	public const int MAX_VIRTUAL_CURRENCY = 16000;

	public const float DefaultMaxHealth = 100f;

	public const float DefaultMaxMana = 100f;

	public const float DefaultManaRegenSpeed3DoF = 17f;

	public const float DefaultManaRegenSpeed6DoF = 13f;

	public const float DefaultManaRegenSpeedBotLevel4 = 20f;

	public const float DefaultManaRegenSpeedBotLevel5 = 30f;

	public const float SuddenDeathManaRegenMultiplier = 1.5f;

	public const float AimPointBuffer = 0.05f;

	public const float AimMinSize = 0.1f;

	public const float FlashAlphaValue = 0.55f;

	public const int MaximumFreeToPlayLevel = 3;

	public const float WandGripAngle = -28f;

	public const float CameraHeight = 1.7f;

	public const float CameraAimHeight = 1.5f;

	public const int DEFAULT_RATING = 1500;

	public const int RATING_STANDARD_LOSS = 24;

	public const int SEASON_SCORE_STANDARD_LOSS = 10;

	public const int RatingLevelRequirement = 5;

	public const float PAUSE_TIME = 15f;

	public const int MAX_PAUSE_COUNT = 3;

	public const float PAUSE_COUNTDOWN_TIME = 3f;

	public const float PLAYER_RECENTER_TIME = 0.5f;

	public const float HOLD_WEIGHT = 0.15f;

	public const float UnlockableDragSpeed = 8f;

	public const float UnlockableMoveTime = 1f;

	public const float ProjectileNetworkSyncValue = 0.15f;

	public const float WorkshopWandMovementTime = 0.75f;

	public const float MinCameraHeight = 1.1f;

	public const float MaxCameraHeight = 1.55f;

	public const float MaxCameraHeightMobile = 1.43f;

	public const string SURVIVAL_WAND_NAME = "Survival";

	public const string Source = "Source";

	public const string PlayerLayerName = "Player";

	public const string Player1LayerName = "Player1";

	public const string Player2LayerName = "Player2";

	public const string ShieldLayerName = "Shield";

	public const string TileLayerName = "Tile";

	public const string TeleportLayerName = "Teleport";

	public const string BotTeleportLayerName = "Ignore Collision";

	public const float SanctumDoorOpenTime = 7f;

	public const float SanctumDoorCloseTime = 10f;

	public const float HighlightTweenTime = 0.1f;

	public const float FadeOutAlpha = 0.2f;

	public const float ChannelEffectFadeAlpha = 0.5f;

	public const float StatsUpdateDelayTime = 1f;

	public const float SpellAvailabilityFadeTime = 0.25f;

	public const float IconBackgroundAlphaEnabled = 0.25f;

	public const float IconBackgroundAlphaDisabled = 0.35f;

	public static readonly Vector3 IconHighlightScale = Vector3.one * 0.9f;

	public static readonly Vector3 SelectMarkerHighlightScale = Vector3.one * 1.1f;

	public static readonly Vector3 ChannelingEffectRotationVector = new Vector3(0f, 0f, -360f);

	public const string DISSOLVE_POWER = "_DissolvePower";

	public const string DISSOLVE_VALUE = "_DissolveValue";

	public const string DISSOLVE_SLICE_AMOUNT = "_SliceAmount";

	public const string FILL_AMOUNT = "_Fill";

	public const string CUTOFF_AMOUNT = "_Cutoff";

	public const string HIGHLIGHTED = "_Highlighted";

	public const string COLOR = "_Color";

	public const string CORE_COLOR = "_CoreColor";

	public const string TINT_COLOR = "_TintColor";

	public const string COLOR_PROPERTY = "_GlobalMultiplierColor";

	public const string RIM_COLOR_PROPERTY = "_RimColor";

	public const string OUTLINE_COLOR_PROPERTY = "_OutlineColor";

	public const string NOISE_COLOR_PROPERTY = "_NoiseColor";

	public const string SoftnessTextProperty = "_OutlineSoftness";

	public const string DilateTextProperty = "_FaceDilate";

	public const string MaxValueProperty = "_MaxValue";

	public const string LowValueProperty = "_LowValue";

	public const string GradientColorPropertyLeft = "_Color";

	public const string GradientColorPropertyRight = "_Color2";

	public const string EQ_FREQUENCY = "Frequency-EQ";

	public const string MUSIC_EQ = "Music-EQ";

	public const string MUSIC_VOLUME_PARAM = "Music-Counter-Volume";

	public const string MUSIC_OPT_VOLUME_PARAM = "Music-Optional-Volume";

	public const string TXT_END_STATE = "END_STATE";

	public const string TXT_MATCH_TIME_MIN = "MATCH_TIME_MIN";

	public const string TXT_MATCH_TIME_SEC = "MATCH_TIME_SEC";

	public const string TXT_TIMER = "TIMER";

	public const string TXT_STATUS_EFFECT = "STATUS_EFFECT";

	public const string TXT_STATUS_CAUSE = "STATUS_CAUSE";

	public const int MaxSwipePoints = 30;

	public const float TickThreshold = 0.15f;

	public const float MinPressCenterOffsetHorizontal = 0.25f;

	public const float MinPressCenterOffsetVertical = 0.1f;

	public const float MinSwipeCenterOffset = 0.25f;

	public const float MinSwipeDistance = 0.65f;

	public const float MinSwipeDistanceSqr = 0.42249995f;

	public const string PHOTON_APP_ID = "e1482f05-acd1-4d76-aa43-111ca44535af";

	public const string PHOTON_APP_ID_CHINA = "2c619b76-c11f-49d7-9ee8-903a09970bb7";

	public const string API_BASE_URL = "https://api.wandsgame.com";

	public const RpcTarget RPCMaster = RpcTarget.MasterClient;

	public const RpcTarget RPCAll = RpcTarget.All;

	public const RpcTarget RPCAllViaServer = RpcTarget.AllViaServer;

	public const RpcTarget RPCAllBuffered = RpcTarget.AllBuffered;

	public const RpcTarget RPCAllBufferedViaServer = RpcTarget.AllBufferedViaServer;

	public const RpcTarget RPCOthers = RpcTarget.Others;

	public const RpcTarget RPCOthersBuffered = RpcTarget.OthersBuffered;

	public static readonly IReadOnlyList<WandInput> DefaultAndroidWandInputs = new List<WandInput>
	{
		WandInput.Press,
		WandInput.Swipe,
		WandInput.Point
	};

	public static readonly IReadOnlyList<WandInput> DefaultPcWandInputs = new List<WandInput> { WandInput.Stick };

	public static readonly List<Spell> DefaultSpells = new List<Spell>
	{
		Spell.Spell_Teleport,
		Spell.Spell_DevilsSpit,
		Spell.Spell_ShieldOfLight,
		Spell.Spell_AcidCloud,
		Spell.Spell_BlazingMeteor
	};

	public static readonly ISet<Spell> InitialUnlockableGuidanceSpells = new HashSet<Spell>
	{
		Spell.Spell_ElectricFist,
		Spell.Spell_MagicMissile,
		Spell.Spell_DiscOfAntioch,
		Spell.Spell_ChillingClutch,
		Spell.Spell_SkullSpecter
	};

	public static readonly ISet<Spell> BaseSpells = new HashSet<Spell>
	{
		Spell.Spell_Teleport,
		Spell.Spell_ShieldOfLight,
		Spell.Spell_HeavenlyDome,
		Spell.Spell_ArmorOfTheSun,
		Spell.Spell_LightningStrike,
		Spell.Spell_AcidCloud,
		Spell.Spell_DevilsTwins,
		Spell.Spell_HailOfDeath,
		Spell.Spell_DevilsSpit,
		Spell.Spell_FlamingPhoenix,
		Spell.Spell_ElectricFist,
		Spell.Spell_ChaosLeap,
		Spell.Spell_BlazingMeteor,
		Spell.Spell_StoneDemon,
		Spell.Spell_SoilSpikes,
		Spell.Spell_PetrifyingPrison,
		Spell.Spell_MagicMissile,
		Spell.Spell_BloodBolt,
		Spell.Spell_CurseOfTheUndead,
		Spell.Spell_DragonsBreath,
		Spell.Spell_Oxymora,
		Spell.Spell_Demi,
		Spell.Spell_DiscOfAntioch,
		Spell.Spell_CerberusCollars,
		Spell.Spell_ChillingClutch,
		Spell.Spell_SkullSpecter
	};

	public static readonly ICollection<Spell> ChargeableSpells = new List<Spell>
	{
		Spell.Spell_ShieldOfLight,
		Spell.Spell_HeavenlyDome,
		Spell.Spell_LightningStrike,
		Spell.Spell_HailOfDeath,
		Spell.Spell_DevilsSpit,
		Spell.Spell_FlamingPhoenix,
		Spell.Spell_ElectricFist,
		Spell.Spell_MagicMissile,
		Spell.Spell_BloodBolt,
		Spell.Spell_DragonsBreath,
		Spell.Spell_DiscOfAntioch,
		Spell.Spell_CalciteShield,
		Spell.Spell_CrystalShards
	};

	public static readonly ISet<CharacterType> DefaultCharacters = new HashSet<CharacterType>
	{
		CharacterType.Scavenger,
		CharacterType.Inquisitor
	};

	public static readonly ISet<CharacterType> BaseCharacters = new HashSet<CharacterType>
	{
		CharacterType.Scavenger,
		CharacterType.Collector,
		CharacterType.Widow,
		CharacterType.Raven,
		CharacterType.Inquisitor,
		CharacterType.Vindicator,
		CharacterType.General,
		CharacterType.Vanguard,
		CharacterType.Assassin,
		CharacterType.Komuso,
		CharacterType.Nemesis
	};

	public static readonly ISet<CharacterType> SpecialCharacters = new HashSet<CharacterType> { CharacterType.Templar };

	public static readonly WandType[] DefaultWands = new WandType[2];

	public static readonly ISet<WandType> BaseWands = new HashSet<WandType>
	{
		WandType.Classic,
		WandType.Sword,
		WandType.Inductor,
		WandType.Lion,
		WandType.Remnant,
		WandType.Scepter,
		WandType.ScarabOfSahir,
		WandType.Snake,
		WandType.Claw,
		WandType.Vigil,
		WandType.Spine,
		WandType.Armament,
		WandType.Staff
	};

	public static readonly ISet<WandType> SpecialWands = new HashSet<WandType>
	{
		WandType.Invicta,
		WandType.Crystal
	};

	public static readonly IList<Title> DefaultTitles = new List<Title>
	{
		Title.RelicWielder,
		Title.WielderInTraining,
		Title.RelicMentor,
		Title.Dilettante
	};

	public static readonly IReadOnlyDictionary<RatingTitle, int> RatingTitles = new Dictionary<RatingTitle, int>
	{
		{
			RatingTitle.GoatHerder,
			0
		},
		{
			RatingTitle.DustCollector,
			1500
		},
		{
			RatingTitle.RelicChaser,
			1550
		},
		{
			RatingTitle.Beyonder,
			1600
		},
		{
			RatingTitle.Wandsmith,
			1650
		},
		{
			RatingTitle.Outlaw,
			1700
		},
		{
			RatingTitle.Wielder,
			1750
		},
		{
			RatingTitle.Aspirant,
			1800
		},
		{
			RatingTitle.Duelist,
			1900
		},
		{
			RatingTitle.Tactician,
			2000
		},
		{
			RatingTitle.Veteran,
			2100
		},
		{
			RatingTitle.Champion,
			2200
		},
		{
			RatingTitle.GrandMaster,
			2300
		},
		{
			RatingTitle.Legend,
			2500
		}
	};

	public static readonly IReadOnlyDictionary<Title, int> SkillLevelTitles = new Dictionary<Title, int>
	{
		{
			Title.Dilettante,
			0
		},
		{
			Title.Apprentice,
			1600
		},
		{
			Title.Journeyman,
			1700
		},
		{
			Title.Adept,
			1800
		},
		{
			Title.Expert,
			1900
		},
		{
			Title.Master,
			2100
		},
		{
			Title.GrandMaster,
			2300
		},
		{
			Title.Legend,
			2500
		},
		{
			Title.Prophet,
			2600
		},
		{
			Title.Conqueror,
			2700
		},
		{
			Title.KingOfTheBeyond,
			2800
		},
		{
			Title.QueenOfTheBeyond,
			2800
		},
		{
			Title.Demigod,
			2900
		}
	};

	public static readonly int[] LoadoutUnlocksPerLevel = new int[20]
	{
		0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 1
	};

	public static readonly IList<Arena> BaseLevels = new List<Arena>
	{
		Arena.AspisPrison,
		Arena.TempleOfOphidian,
		Arena.TheCelestialHalls,
		Arena.OrtusStation,
		Arena.DeadMastersVale,
		Arena.SanctumOfSahir
	};

	public static readonly IList<Arena> CustomLevelQueue = new List<Arena>();

	public static readonly IList<Language> BaseLanguages = new List<Language>
	{
		Language.English,
		Language.Chinese,
		Language.Japanese,
		Language.French,
		Language.German,
		Language.Spanish
	};

	public static readonly IList<Language> GoogleExclusiveLanguages = new List<Language>
	{
		Language.Korean,
		Language.Hindi
	};

	public static readonly Dictionary<PlatformType, string> PlatformIdentifierNames = new Dictionary<PlatformType, string>
	{
		{
			PlatformType.GearVr,
			"HUD/MobilePc"
		},
		{
			PlatformType.Go,
			"HUD/MobilePc"
		},
		{
			PlatformType.Pico,
			"HUD/MobilePc"
		},
		{
			PlatformType.Rift,
			"HUD/MobilePc"
		},
		{
			PlatformType.Steam,
			"HUD/MobilePc"
		},
		{
			PlatformType.Viveport,
			"HUD/MobilePc"
		},
		{
			PlatformType.MiVr,
			"HUD/MobilePc"
		},
		{
			PlatformType.Quest,
			"HUD/MobilePc"
		},
		{
			PlatformType.PlayStation,
			"HUD/PlayStation"
		}
	};

	public const string OculusUserNamePrefix = "OVR_";

	public const string GearVrUserNamePrefix = "OC_";

	public const string GoogleUserNamePrefix = "G_";

	public const string PicoUserNamePrefix = "P_";

	public const string SteamUserNamePrefix = "S_";

	public const string ViveportUserNamePrefix = "V_";

	public const string MiVRUserNamePrefix = "MI_";

	public const string PlayStationUserNamePrefix = "PS4_";

	public const int MaxLeaderboardResults = 10;

	public const int NumberOfLoadouts = 3;

	public const int NumberOfLoadoutSpells = 5;

	public const int NumberOfLoadoutWands = 2;

	public const int SpellCost = 1;

	public const float VanityItemWorthModifier = 0.1f;

	public const string DustPriceIdentifier = "RD";

	public const float IKInterpolationStrength = 10f;

	public static LayerMask TileMask => 1 << LayerMask.NameToLayer("Tile");

	public static LayerMask TeleportMask => 1 << LayerMask.NameToLayer("Teleport");

	public static LayerMask Player1Mask => 1 << LayerMask.NameToLayer("Player1");

	public static LayerMask BotTeleportMask => 1 << LayerMask.NameToLayer("Ignore Collision");
}
namespace Assets.Scripts.Misc
{
	public class CountdownHandler : MonoBehaviourPun
	{
		[SerializeField]
		private float m_countdownTime;

		private float m_currentCountdownTime;

		public bool IsCountdownActive { get; private set; }

		private void Start()
		{
			m_currentCountdownTime = m_countdownTime;
		}

		public void StartCountdown()
		{
			if (!IsCountdownActive && PhotonNetwork.IsMasterClient)
			{
				base.photonView.RPC("PunStartCountdown", RpcTarget.AllBuffered, m_currentCountdownTime);
			}
		}

		public void SetCountdownTime(float time)
		{
			if (IsCountdownActive && PhotonNetwork.IsMasterClient)
			{
				base.photonView.RPC("PunSetCountdownTime", RpcTarget.AllBuffered, time);
			}
		}

		public void PauseCountdown()
		{
			if (IsCountdownActive && PhotonNetwork.IsMasterClient)
			{
				base.photonView.RPC("PunPauseCountdown", RpcTarget.AllBuffered, m_currentCountdownTime);
			}
		}

		public void CancelCountdown()
		{
			if (IsCountdownActive && PhotonNetwork.IsMasterClient)
			{
				base.photonView.RPC("PunCancelCountdown", RpcTarget.AllBuffered);
			}
		}

		[PunRPC]
		private void PunStartCountdown(float time)
		{
			StartCoroutine(Countdown(time));
		}

		[PunRPC]
		private void PunSetCountdownTime(float time)
		{
			StopAllCoroutines();
			StartCoroutine(Countdown(time));
		}

		[PunRPC]
		private void PunPauseCountdown(float time)
		{
			Events.CountdownTimeUpdatedEvent countdownTimeUpdatedEvent = new Events.CountdownTimeUpdatedEvent();
			countdownTimeUpdatedEvent.Time = time;
			EventHub.Publish(countdownTimeUpdatedEvent);
			EventHub.Publish(new Events.CountdownPausedEvent());
			StopAllCoroutines();
			m_currentCountdownTime = time;
			IsCountdownActive = false;
		}

		[PunRPC]
		private void PunCancelCountdown()
		{
			Events.CountdownTimeUpdatedEvent countdownTimeUpdatedEvent = new Events.CountdownTimeUpdatedEvent();
			countdownTimeUpdatedEvent.Time = m_currentCountdownTime;
			EventHub.Publish(countdownTimeUpdatedEvent);
			EventHub.Publish(new Events.CountdownCanceledEvent());
			StopAllCoroutines();
			m_currentCountdownTime = m_countdownTime;
			IsCountdownActive = false;
		}

		[PunRPC]
		private void PunCountdownCompleted()
		{
			Events.CountdownTimeUpdatedEvent countdownTimeUpdatedEvent = new Events.CountdownTimeUpdatedEvent();
			countdownTimeUpdatedEvent.Time = 0f;
			EventHub.Publish(countdownTimeUpdatedEvent);
			EventHub.Publish(new Events.CountdownEndedEvent());
			StopAllCoroutines();
			m_currentCountdownTime = m_countdownTime;
			IsCountdownActive = false;
		}

		private IEnumerator Countdown(float time)
		{
			m_currentCountdownTime = time;
			IsCountdownActive = true;
			Events.CountdownStartedEvent countdownStartedEvent = new Events.CountdownStartedEvent();
			countdownStartedEvent.Time = time;
			EventHub.Publish(countdownStartedEvent);
			Events.CountdownTimeUpdatedEvent countdownTimeUpdatedEvent = new Events.CountdownTimeUpdatedEvent();
			countdownTimeUpdatedEvent.Time = m_currentCountdownTime;
			EventHub.Publish(countdownTimeUpdatedEvent);
			if (time >= 5f - Mathf.Epsilon)
			{
				while (m_currentCountdownTime > 5f + Mathf.Epsilon)
				{
					yield return new CustomWaitForSeconds(1f);
					m_currentCountdownTime -= 1f;
					countdownTimeUpdatedEvent = new Events.CountdownTimeUpdatedEvent();
					countdownTimeUpdatedEvent.Time = m_currentCountdownTime;
					EventHub.Publish(countdownTimeUpdatedEvent);
				}
				EventHub.Publish(new Events.FinalCountdownStartedEvent());
			}
			while (m_currentCountdownTime > 0f)
			{
				yield return new CustomWaitForSeconds(1f);
				m_currentCountdownTime -= 1f;
				countdownTimeUpdatedEvent = new Events.CountdownTimeUpdatedEvent();
				countdownTimeUpdatedEvent.Time = m_currentCountdownTime;
				EventHub.Publish(countdownTimeUpdatedEvent);
			}
			if (PhotonNetwork.IsMasterClient)
			{
				base.photonView.RPC("PunCountdownCompleted", RpcTarget.AllBuffered);
			}
		}
	}
}
public class DebugTimeScaler : MonoBehaviour
{
	public void ChangeTimeScale(float targetTime)
	{
		Time.timeScale = targetTime;
		Time.fixedDeltaTime = 0.02f * Time.timeScale;
	}
}
namespace Assets.Scripts.Misc
{
	public static class EloDebugger
	{
		public static float SkillRatingPrevious { get; private set; }

		public static float SkillRating { get; private set; }

		public static float SkillRatingChangeBase { get; private set; }

		public static float SkillRatingChange { get; private set; }

		public static float SeasonScorePrevious { get; private set; }

		public static float SeasonScoreChangeBase { get; private set; }

		public static float SeasonScoreChange { get; private set; }

		public static void SetSkillRatingValues(float skillRatingPrevious, float skillRating, float changeBase, float changeActual)
		{
			SkillRatingPrevious = skillRatingPrevious;
			SkillRating = skillRating;
			SkillRatingChangeBase = changeBase;
			SkillRatingChange = changeActual;
		}

		public static void SetSeasonScoreValues(float seasonScorePrevious, float changeBase, float changeActual)
		{
			SeasonScorePrevious = seasonScorePrevious;
			SeasonScoreChangeBase = changeBase;
			SeasonScoreChange = changeActual;
		}
	}
	public class EloHandler
	{
		private int m_opponentRating;

		private int m_opponentLevel;

		public void SetStartValues()
		{
			Photon.Realtime.Player opponent = PlayerManager.Instance.GetOpponent();
			if (opponent != null)
			{
				m_opponentRating = (int)PlayerProperty.Get("EL", opponent);
				m_opponentLevel = (int)PlayerProperty.Get("PL", opponent);
			}
		}

		public int[] GetPlayerScores(bool getActualScores = false)
		{
			return new int[2]
			{
				(!getActualScores && !GameControl.Instance.Player.HasUnlockedRating) ? 1500 : GameControl.Instance.Player.Rating,
				(m_opponentRating <= 0) ? 1500 : m_opponentRating
			};
		}

		public int[] GetUpdatedRatings(EndState endState)
		{
			return GetUpdatedRatings(endState, GetPlayerScores());
		}

		public int GetUpdatedSeasonScore(EndState endState)
		{
			return GetUpdatedSeasonScore(endState, GetPlayerScores(), GameControl.Instance.Player.SeasonScore);
		}

		public int[] GetUpdatedRatings(EndState endState, int[] eloRatings, bool updateRating = true)
		{
			if (eloRatings.Length != 2)
			{
				WandsLogger.LogError("Can't calculate ELO due to too few ratings to base it on.", LogColor.PlayerData);
				return new int[2] { -1, -1 };
			}
			return CalculateAndReturnELO(endState, eloRatings, updateRating);
		}

		public int GetUpdatedSeasonScore(EndState endState, int[] eloRatings, int seasonScore, bool updateSeasonScore = true)
		{
			if (eloRatings.Length != 2)
			{
				WandsLogger.LogError("Can't calculate Season Score due to too few elo ratings to base it on.", LogColor.PlayerData);
				return 0;
			}
			return CalculateAndReturnSeasonScore(endState, eloRatings, seasonScore, updateSeasonScore);
		}

		private int CalculateAndReturnSeasonScore(EndState endState, int[] eloRatings, int seasonScore, bool updateSeasonScore)
		{
			if (!GameControl.Instance.CanPlayerEarnRating)
			{
				return 0;
			}
			RewardModifiers rewardModifiers = GameControl.Instance.Player.RewardModifiers;
			float num = rewardModifiers.Score;
			switch (endState)
			{
			case EndState.Won:
				eloRatings[0] = seasonScore + 1500;
				if ((int)PlayerProperty.Get("HP", PlayerManager.Instance.GetOpponent()) == 0)
				{
					num += rewardModifiers.KOMultiplier.WinMultiplier % 1f;
				}
				break;
			case EndState.Lost:
			case EndState.ForceLost:
				if ((int)PlayerProperty.Get("HP") == 0)
				{
					num += rewardModifiers.KOMultiplier.LoseMultiplier % 1f;
				}
				break;
			}
			int[] seasonScoreChange = EloUtils.GetSeasonScoreChange(endState, eloRatings);
			int num2 = (int)((float)seasonScoreChange[0] * num);
			seasonScore += num2;
			seasonScore = Mathf.Max(0, seasonScore);
			if (updateSeasonScore)
			{
				GameControl.Instance.TryUpdateSeasonScore(seasonScore);
			}
			return seasonScore;
		}

		private int[] CalculateAndReturnELO(EndState endState, int[] eloRatings, bool updateRating)
		{
			int num = eloRatings[0];
			int num2 = eloRatings[1];
			int kFactor = EloUtils.GetKFactor(num);
			int kFactor2 = EloUtils.GetKFactor(num2);
			int[] eloChange = EloUtils.GetEloChange(endState, eloRatings, kFactor, kFactor2);
			int num3 = (int)((float)eloChange[0] * GameControl.Instance.Player.RewardModifiers.Score);
			num += num3;
			num2 += eloChange[1];
			if (m_opponentLevel < 5)
			{
				num2 = 0;
			}
			if (!GameControl.Instance.CanPlayerEarnRating)
			{
				num = 0;
			}
			if (updateRating)
			{
				GameControl.Instance.TryUpdatePlayerRating(num);
			}
			return new int[2] { num, num2 };
		}
	}
	public class ExperienceObject
	{
		public int Value { get; private set; }

		public string Description { get; private set; }

		public ExperienceObject(int value, string description)
		{
			Value = value;
			Description = description;
		}
	}
	[RequireComponent(typeof(Light))]
	public class FlickeringLight : MonoBehaviour
	{
		[SerializeField]
		private float m_minLightIntensity = 0.5f;

		[SerializeField]
		private float m_maxLightIntensity = 1f;

		[SerializeField]
		[Range(0f, 1f)]
		private float m_speedFactor = 0.2f;

		private float m_startIntensity;

		private float m_endIntensity;

		private float m_timeValue;

		private Light m_light;

		private void Start()
		{
			m_light = GetComponent<Light>();
			SetEndValue();
		}

		private void Update()
		{
			m_timeValue += Time.deltaTime;
			float num = m_timeValue / m_speedFactor;
			m_light.intensity = Mathf.Lerp(m_startIntensity, m_endIntensity, num);
			if (num >= 1f)
			{
				SetEndValue();
			}
		}

		private void SetEndValue()
		{
			m_timeValue = 0f;
			m_startIntensity = m_light.intensity;
			m_endIntensity = UnityEngine.Random.Range(m_minLightIntensity, m_maxLightIntensity);
		}
	}
}
public class MatchTimer : MonoBehaviourPunCallbacks
{
	private const string TimeToStartProp = "st";

	public double SecondsBeforeStart = 20.0;

	private double m_timeToStart;

	public bool IsItTimeYet
	{
		[CompilerGenerated]
		get
		{
			return IsTimeToStartKnown && PhotonNetwork.Time > m_timeToStart;
		}
	}

	public bool IsTimeToStartKnown
	{
		[CompilerGenerated]
		get
		{
			return m_timeToStart > 0.0010000000474974513;
		}
	}

	public double SecondsUntilItsTime
	{
		get
		{
			if (IsTimeToStartKnown)
			{
				double num = m_timeToStart - PhotonNetwork.Time;
				return (!(num > 0.0)) ? 0.0 : num;
			}
			return 0.0;
		}
	}

	private void OnGUI()
	{
		GUILayout.Label("Is it time yet: " + IsItTimeYet);
		GUILayout.Label("Seconds until it's time: " + (float)SecondsUntilItsTime);
	}

	private void Update()
	{
		if (PhotonNetwork.IsMasterClient && !IsTimeToStartKnown && PhotonNetwork.Time > 9.999999747378752E-05)
		{
			m_timeToStart = PhotonNetwork.Time + SecondsBeforeStart;
			ExitGames.Client.Photon.Hashtable hashtable = new ExitGames.Client.Photon.Hashtable();
			hashtable.Add("st", m_timeToStart);
			ExitGames.Client.Photon.Hashtable propertiesToSet = hashtable;
			PhotonNetwork.CurrentRoom.SetCustomProperties(propertiesToSet);
		}
	}

	public override void OnRoomPropertiesUpdate(ExitGames.Client.Photon.Hashtable propertiesThatChanged)
	{
		if (propertiesThatChanged.ContainsKey("st"))
		{
			m_timeToStart = (double)propertiesThatChanged["st"];
		}
	}
}
public class PlaySfx : MonoBehaviour
{
	public AudioSource[] m_source;

	public void PlaySfxNow()
	{
		if (m_source != null)
		{
			PlaySfxNow(2);
		}
	}

	public void PlaySfxNow(int sourceIndex)
	{
		if (m_source != null && m_source.Length >= sourceIndex)
		{
			m_source[sourceIndex].Stop();
			m_source[sourceIndex].Play();
		}
	}
}
[RequireComponent(typeof(MeshFilter))]
public class ReverseNormals : MonoBehaviour
{
	private void Start()
	{
		MeshFilter meshFilter = GetComponent(typeof(MeshFilter)) as MeshFilter;
		if (meshFilter != null)
		{
			Mesh mesh = meshFilter.mesh;
			Vector3[] normals = mesh.normals;
			for (int i = 0; i < normals.Length; i++)
			{
				ref Vector3 reference = ref normals[i];
				reference = -normals[i];
			}
			mesh.normals = normals;
			for (int j = 0; j < mesh.subMeshCount; j++)
			{
				int[] triangles = mesh.GetTriangles(j);
				for (int k = 0; k < triangles.Length; k += 3)
				{
					int num = triangles[k];
					triangles[k] = triangles[k + 1];
					triangles[k + 1] = num;
				}
				mesh.SetTriangles(triangles, j);
			}
		}
		GetComponent<MeshCollider>().sharedMesh = meshFilter.mesh;
	}
}
[StructLayout(LayoutKind.Sequential, Size = 1)]
public struct Tags
{
	public const string Unknown = "Unknown";

	public const string Player = "Player";

	public const string Dummy = "Dummy";

	public const string Lava = "Lava";

	public const string Environment = "Environment";

	public const string Shield = "Shield";

	public const string Projectile = "Projectile";

	public const string Destructable = "Destructable";

	public const string KillPlane = "KillPlane";

	public const string Train = "Train";
}
public abstract class MonoSingleton<T> : MonoBehaviour where T : MonoSingleton<T>
{
	protected static T sm_instance;

	public static T Instance
	{
		[CompilerGenerated]
		get
		{
			return (!(sm_instance != null)) ? ((T)null) : sm_instance;
		}
	}

	protected virtual void Awake()
	{
		if (sm_instance == null || sm_instance != this)
		{
			sm_instance = this as T;
		}
	}

	protected virtual void OnDisable()
	{
		sm_instance = (T)null;
	}
}
namespace Cortopia.Scripts.Network
{
	public class BotPlayer : Photon.Realtime.Player
	{
		public BotPlayer(string nickName, int actorNumber, bool isLocal, ExitGames.Client.Photon.Hashtable playerProperties)
			: base(nickName, actorNumber, isLocal, playerProperties)
		{
		}

		public override bool SetCustomProperties(ExitGames.Client.Photon.Hashtable propertiesToSet, ExitGames.Client.Photon.Hashtable expectedValues = null, WebFlags webFlags = null)
		{
			if (propertiesToSet.IsNullOrEmpty())
			{
				return false;
			}
			ExitGames.Client.Photon.Hashtable hashtable = propertiesToSet.StripToStringKeys();
			if (hashtable.IsEmpty())
			{
				return false;
			}
			if (expectedValues != null || webFlags != null)
			{
				UnityEngine.Debug.LogError("Can't use expected values or web flags for Bot Player");
				return false;
			}
			base.CustomProperties.Merge(hashtable);
			base.CustomProperties.StripKeysWithNullValues();
			return true;
		}
	}
}
namespace Assets.Scripts.Network.Matchmaking
{
	public static class Matchmaker
	{
		private const string Matched = "Matched";

		private const string Canceled = "Canceled";

		private const string BelowLevel10 = "BelowLevel10";

		private const string Level10AndUp = "Level10AndUp";

		private const int PollDelay = 11000;

		private static bool sm_isCancelled;

		private static string sm_currentQueue;

		private static string sm_currentTicketId;

		private static Action<string> sm_onMatchFoundSuccess;

		private static Action sm_onError;

		private static global::PlayFab.MultiplayerModels.EntityKey sm_entityKey;

		private static MatchmakingPlayer sm_matchmakingPlayer;

		public static void FindMatch(Action<string> onMatchFoundSuccess, Action onError)
		{
			TryCreateEntityKey();
			Assets.Scripts.Player.Player player = GameControl.Instance.Player;
			int level = player.SaveData.LevelData.Level;
			string queueName = ((level >= 5) ? "Level10AndUp" : "BelowLevel10");
			MatchmakingPlayer matchmakingPlayer = new MatchmakingPlayer();
			matchmakingPlayer.Attributes = new MatchmakingPlayerAttributes
			{
				DataObject = new
				{
					Elo = ((player.Rating > 0) ? player.Rating : 1500),
					SeasonScore = player.SeasonScore,
					Level = level,
					Version = PhotonNetwork.GameVersion,
					PositionalTracked = (GameControl.Instance.Platform.Type.ContainsFlag(PlatformTarget.SixDoF) ? 3 : ((!GameControl.Instance.PositionalTrackingOpponentEnabled) ? 1 : 2))
				}
			};
			matchmakingPlayer.Entity = sm_entityKey;
			sm_matchmakingPlayer = matchmakingPlayer;
			sm_onMatchFoundSuccess = onMatchFoundSuccess;
			sm_onError = onError;
			CancelAllMatchmakingTickets("BelowLevel10");
			CancelAllMatchmakingTickets("Level10AndUp");
			sm_isCancelled = false;
			FindMatch(queueName);
		}

		public static void CancelMatchmaking()
		{
			TryCreateEntityKey();
			CancelAllMatchmakingTickets("BelowLevel10");
			CancelAllMatchmakingTickets("Level10AndUp");
			sm_isCancelled = true;
			sm_currentQueue = null;
		}

		private static void InvokeWithDelay(Action a, int milliseconds)
		{
			Task.Delay(milliseconds).ContinueWith(delegate
			{
				if (!sm_isCancelled)
				{
					a();
				}
			}, TaskScheduler.FromCurrentSynchronizationContext());
		}

		private static void TryCreateEntityKey()
		{
			if (sm_entityKey == null)
			{
				Assets.Scripts.Player.Player player = GameControl.Instance.Player;
				global::PlayFab.MultiplayerModels.EntityKey entityKey = new global::PlayFab.MultiplayerModels.EntityKey();
				entityKey.Id = player.PlayFabEntityKey.Id;
				entityKey.Type = player.PlayFabEntityKey.Type;
				sm_entityKey = entityKey;
			}
		}

		private static void CancelAllMatchmakingTickets(string queue)
		{
			global::Cortopia.PlayFabManager.PlayFabManager.CancelAllMatchmakingTicketsForPlayer(new CancelAllMatchmakingTicketsForPlayerRequestObject(queue, sm_entityKey), OnCancelAllMatchmakingTicketsForPlayerSuccess, OnCancelAllMatchmakingTicketsForPlayerError, QueueState.Queue);
		}

		private static void FindMatch(string queueName)
		{
			sm_currentQueue = queueName;
			global::Cortopia.PlayFabManager.PlayFabManager.CreateMatchmakingTicket(new CreateMatchmakingTicketRequestObject(sm_matchmakingPlayer, PlayFabTitleData.GetMatchmakingTicketTimeout(sm_currentQueue), sm_currentQueue), OnCreateMatchmakingTicketSuccess, OnError, QueueState.Queue);
		}

		private static void PollMatchmakingTicket()
		{
			global::Cortopia.PlayFabManager.PlayFabManager.GetMatchmakingTicket(new GetMatchmakingTicketRequestObject(escapeObject: false, sm_currentQueue, sm_currentTicketId), OnGetMatchmakingTicketSuccess, OnError, QueueState.Immediate);
		}

		private static void OnCreateMatchmakingTicketSuccess(CreateMatchmakingTicketResponseObject createMatchmakingTicketResponseObject)
		{
			sm_currentTicketId = createMatchmakingTicketResponseObject.TicketId;
			InvokeWithDelay(PollMatchmakingTicket, 11000);
		}

		private static void OnGetMatchmakingTicketSuccess(GetMatchmakingTicketResponseObject getMatchmakingTicketResponseObject)
		{
			if (!getMatchmakingTicketResponseObject.Success)
			{
				WandsLogger.LogError($"Did not get Success on GetMatchmakingTicket. Message: '{getMatchmakingTicketResponseObject.Message}'", LogColor.Matchmaking);
			}
			else if (getMatchmakingTicketResponseObject.Status == "Matched")
			{
				global::Cortopia.PlayFabManager.PlayFabManager.GetMatch(new GetMatchRequestObject(escapeObject: false, getMatchmakingTicketResponseObject.MatchId, sm_currentQueue, returnMemeberAttributes: true), OnGetMatchSuccess, OnError, QueueState.Immediate);
			}
			else if (getMatchmakingTicketResponseObject.Status == "Canceled")
			{
				CancellationReason? cancellationReason = getMatchmakingTicketResponseObject.CancellationReason;
				if (cancellationReason.HasValue)
				{
					switch (cancellationReason.Value)
					{
					case CancellationReason.Timeout:
						FindMatch("Level10AndUp");
						return;
					case CancellationReason.Internal:
						WandsLogger.LogError($"Internal error, retry finding match in {sm_currentQueue}", LogColor.Matchmaking);
						FindMatch(sm_currentQueue);
						return;
					case CancellationReason.Requested:
						return;
					}
				}
				WandsLogger.LogError($"Case not implemented: {getMatchmakingTicketResponseObject.CancellationReason}");
			}
			else
			{
				InvokeWithDelay(PollMatchmakingTicket, 11000);
			}
		}

		private static void OnGetMatchSuccess(GetMatchResponseObject getMatchResponseObject)
		{
			if (!getMatchResponseObject.Success)
			{
				WandsLogger.LogError($"Did not get Success on GetMatch. Message: '{getMatchResponseObject.Message}'", LogColor.Matchmaking);
			}
			else
			{
				sm_onMatchFoundSuccess(getMatchResponseObject.MatchId);
			}
		}

		private static void OnCancelAllMatchmakingTicketsForPlayerSuccess(CancelAllMatchmakingTicketsForPlayerResponseObject cancelAllMatchmakingTicketsForPlayerResponseObject)
		{
			if (!cancelAllMatchmakingTicketsForPlayerResponseObject.Success)
			{
				WandsLogger.LogError($"Did not get Success on CancelMatchmaking. Message: '{cancelAllMatchmakingTicketsForPlayerResponseObject.Message}'", LogColor.Matchmaking);
			}
		}

		private static void OnCancelAllMatchmakingTicketsForPlayerError(ErrorResponseObject errorResponseObject)
		{
			WandsLogger.LogError($"On Cancel All Matchmaking Tickets For Player Error: '{errorResponseObject.Error}'", LogColor.Matchmaking);
		}

		private static void OnError(ErrorResponseObject errorResponseObject)
		{
			WandsLogger.LogError($"On Error: '{errorResponseObject.Error}'", LogColor.Matchmaking);
			sm_onError();
		}
	}
}
namespace Cortopia.Scripts.Network
{
	public class NetworkCache : PunSingleton<NetworkCache>
	{
		public void CacheBundledAsset(string assetPath)
		{
			base.photonView.RPC("PunCacheBundledAsset", RpcTarget.AllBuffered, assetPath);
			PhotonNetwork.SendAllOutgoingCommands();
		}

		public void CacheLoadout(Spell[] loadout)
		{
			FastList<string> fastList = new FastList<string>(loadout.Length);
			for (int i = 0; i < loadout.Length; i++)
			{
				fastList.Add(loadout.ToString());
			}
			if (fastList.Count > 0)
			{
				base.photonView.RPC("PunCacheBundledAssets", RpcTarget.AllBuffered, new object[1] { fastList.ToArray() });
				PhotonNetwork.SendAllOutgoingCommands();
			}
		}

		[PunRPC]
		private void PunCacheBundledAsset(string assetPath)
		{
			NetworkUtils.TryCacheAsset(assetPath);
		}

		[PunRPC]
		private void PunCacheBundledAssets(string[] assetPaths)
		{
			for (int i = 0; i < assetPaths.Length; i++)
			{
				NetworkUtils.TryCacheAsset(assetPaths[i]);
			}
		}
	}
}
namespace CortopiaEvents
{
	public class NetworkEvents
	{
		public class PhotonPlayerConnectedEvent : EventBase
		{
			public Photon.Realtime.Player PhotonPlayer;
		}

		public class PhotonPlayerDisconnectedEvent : EventBase
		{
			public Photon.Realtime.Player PhotonPlayer;
		}

		public class PhotonNetworkDisconnectedEvent : EventBase
		{
		}

		public class PhotonConnectionFailedEvent : EventBase
		{
			public DisconnectCause Cause;
		}

		public class PlayerPropertiesUpdatedEvent : EventBase
		{
			public Photon.Realtime.Player TargetPlayer;

			public ExitGames.Client.Photon.Hashtable ChangedProps;
		}
	}
}
namespace Assets.Scripts.Network
{
	public sealed class NetworkManager : MonoSingleton<NetworkManager>, IConnectionCallbacks, ILobbyCallbacks, IMatchmakingCallbacks, IInRoomCallbacks
	{
		[StructLayout(LayoutKind.Sequential, Size = 1)]
		private struct Region
		{
			public const string US = "us";

			public const string China = "cn";
		}

		private const string PhotonAppID = "e1482f05-acd1-4d76-aa43-111ca44535af";

		private const float MaximumConnectionWaitingTime = 15f;

		private const float LeaveSurvivalRoomDelay = 3f;

		private const float InternetConnectionCheckWaitWhileConnectedTime = 15f;

		private const float InternetConnectionCheckWaitWhileDisconnectedTime = 5f;

		private readonly Queue<Action<bool>> m_internetCheckActions = new Queue<Action<bool>>();

		private TypedLobby m_sqlLobby = new TypedLobby("Wands_Lobby", LobbyType.SqlLobby);

		private string m_serverHost;

		private string m_networkVersionCode;

		private string m_regionCode;

		private readonly List<Photon.Realtime.Player> m_activePlayers = new List<Photon.Realtime.Player>(2);

		private string m_previousOpponent;

		private MatchType m_currentMatchType;

		private Action m_onConnectedToMaster;

		private bool m_isNetworkReachable;

		private bool m_isInternetCheckInProgress;

		private float m_timeRemainingUntilNextInternetCheck;

		private Coroutine m_connectToMatchRoomCoroutine;

		private Coroutine m_connectToMatchLobbyCoroutine;

		private Coroutine m_onFoundMatchCoroutine;

		private EventToken m_playFabLoadingEventToken;

		private EventToken m_tryFindNewMatchEventToken;

		private EventToken m_matchEndedEventToken;

		private EventToken m_playerRequestedRematchEventToken;

		private EventToken m_sceneLoadInitiatedEventToken;

		private EventToken m_sceneLoadedEventToken;

		private Coroutine m_continuousInternetCheckCoroutine;

		public MatchType CurrentMatchType
		{
			get
			{
				return (!PhotonNetwork.InRoom) ? m_currentMatchType : RoomProperty.GetMatchType();
			}
			set
			{
				m_currentMatchType = value;
			}
		}

		public NetworkState NetworkState { get; private set; }

		public bool IsCorrectNetworkVersion { get; private set; }

		public bool LatestInternetCheckWasSuccessful { get; private set; }

		private void OnEnable()
		{
			PhotonNetwork.AddCallbackTarget(this);
			NetworkState = NetworkState.Unavailable;
			m_playFabLoadingEventToken = EventHub.Subscribe<Events.PlayFabLoadingEvent>(OnPlayFabLoadingEvent);
			m_tryFindNewMatchEventToken = EventHub.Subscribe<Events.TryToFindNewMatchEvent>(OnTryFindNewMatches);
			m_matchEndedEventToken = EventHub.Subscribe<Events.MatchEndedEvent>(OnMatchEnded);
			m_playerRequestedRematchEventToken = EventHub.Subscribe<Events.PlayerRequestedRematchEvent>(OnPlayerRequestedRematch);
			m_sceneLoadInitiatedEventToken = EventHub.Subscribe<Events.SceneLoadInitiatedEvent>(OnSceneLoadInitiated);
			m_sceneLoadedEventToken = EventHub.Subscribe<Events.SceneLoadedEvent>(OnSceneLoaded);
		}

		protected override void OnDisable()
		{
			PhotonNetwork.RemoveCallbackTarget(this);
			StopAllCoroutines();
			EventHub.Unsubscribe<Events.PlayFabLoadingEvent>(m_playFabLoadingEventToken);
			EventHub.Unsubscribe<Events.TryToFindNewMatchEvent>(m_tryFindNewMatchEventToken);
			EventHub.Unsubscribe<Events.MatchEndedEvent>(m_matchEndedEventToken);
			EventHub.Unsubscribe<Events.PlayerRequestedRematchEvent>(m_playerRequestedRematchEventToken);
			EventHub.Unsubscribe<Events.SceneLoadInitiatedEvent>(m_sceneLoadInitiatedEventToken);
			EventHub.Unsubscribe<Events.SceneLoadedEvent>(m_sceneLoadedEventToken);
			base.OnDisable();
		}

		private void Start()
		{
			m_networkVersionCode = GameControl.Instance.NetworkVersion;
			m_networkVersionCode += GameControl.Instance.GetVersionSuffix((GameControl.Instance.GetConnectionType() != ConnectionType.Release) ? GameControl.Instance.ClientVersion.Revision : (-1));
			TryStartContinuousInternetCheck();
		}

		public void IsInternetReachable(Action<bool> onCheckComplete = null, bool forceCheckIfNotAlreadyInProgress = true)
		{
			if (onCheckComplete != null)
			{
				m_internetCheckActions.Enqueue(onCheckComplete);
			}
			if (forceCheckIfNotAlreadyInProgress && !m_isInternetCheckInProgress)
			{
				m_timeRemainingUntilNextInternetCheck = 0f;
			}
		}

		private IEnumerator IsNetworkReachable()
		{
			m_isNetworkReachable = UnityEngine.Application.internetReachability != NetworkReachability.NotReachable;
			yield break;
		}

		private unsafe IEnumerator GoOnline()
		{
			if (PhotonNetwork.NetworkClientState == ClientState.ConnectedToMasterServer)
			{
				if (NetworkState == NetworkState.Offline)
				{
					NetworkState = NetworkState.InProgress;
				}
			}
			else if (NetworkState != NetworkState.InProgress)
			{
				NetworkState = NetworkState.InProgress;
				PhotonNetwork.IsMessageQueueRunning = true;
				PhotonNetwork.NetworkingClient.NameServerHost = m_serverHost;
				PhotonNetwork.NetworkingClient.AppId = "e1482f05-acd1-4d76-aa43-111ca44535af";
				PhotonNetwork.NetworkingClient.AppVersion = m_networkVersionCode;
				PhotonVoiceNetwork.Instance.Client.NameServerHost = m_serverHost;
				yield return null;
				PhotonNetwork.GameVersion = m_networkVersionCode;
				PhotonNetwork.ConnectToRegion(m_regionCode);
			}
			yield return WaitForBool(new Func<bool>(null, (nint)(delegate*<bool>)(&PhotonNetwork.get_IsConnectedAndReady)), 15f);
			if (!PhotonNetwork.IsConnectedAndReady)
			{
				WandsLogger.LogError($"NetworkManager | Could not connect to Photon Server in region {m_regionCode} and with server host {m_serverHost}.");
				NetworkState = NetworkState.Offline;
			}
		}

		public void Disconnect()
		{
			StartCoroutine("GoOffline");
		}

		private IEnumerator GoOffline()
		{
			if (PhotonNetwork.NetworkClientState == ClientState.Disconnected)
			{
				NetworkState = NetworkState.Offline;
				EventHub.Publish(new NetworkEvents.PhotonNetworkDisconnectedEvent());
				yield break;
			}
			if (NetworkState == NetworkState.InProgress)
			{
				yield return WaitForBool(() => NetworkState != NetworkState.InProgress, 15f);
				if (NetworkState == NetworkState.InProgress)
				{
					WandsLogger.LogError("NetworkManager | Could not go offline properly");
					NetworkState = NetworkState.Offline;
					EventHub.Publish(new NetworkEvents.PhotonNetworkDisconnectedEvent());
					yield break;
				}
				if (NetworkState == NetworkState.Offline)
				{
					yield break;
				}
			}
			else
			{
				PhotonNetwork.SendAllOutgoingCommands();
				NetworkState = NetworkState.InProgress;
				if (PhotonNetwork.InRoom)
				{
					PlayerManager.Instance?.RemoveRemoteCharacter();
					CancelInvoke("LeaveRoom");
					LeaveRoom();
					yield return WaitForBool(() => PhotonNetwork.NetworkClientState == ClientState.ConnectedToMasterServer, 15f);
					if (PhotonNetwork.NetworkClientState != ClientState.ConnectedToMasterServer)
					{
						WandsLogger.LogError("NetworkManager | Could not leave the room properly");
						NetworkState = NetworkState.Offline;
						EventHub.Publish(new NetworkEvents.PhotonNetworkDisconnectedEvent());
						yield break;
					}
				}
			}
			SetActivePlayers();
			PhotonNetwork.Disconnect();
			yield return WaitForBool(() => PhotonNetwork.NetworkClientState == ClientState.Disconnected, 15f);
			if (PhotonNetwork.NetworkClientState != ClientState.Disconnected)
			{
				WandsLogger.LogError("NetworkManager | Could not disconnect from Photon properly.");
				NetworkState = NetworkState.Offline;
				EventHub.Publish(new NetworkEvents.PhotonNetworkDisconnectedEvent());
			}
		}

		public void LeaveRoom()
		{
			NetworkState = NetworkState.InProgress;
			PlayerManager.Instance?.RemoveRemoteCharacter();
			PhotonNetwork.LeaveRoom(becomeInactive: false);
		}

		public void LeaveAndCreateNewRoom(string roomName, RoomCreationType creationType, RoomCreationReason creationReason, Arena arena, MatchType matchType)
		{
			m_onConnectedToMaster = delegate
			{
				ConnectToMatchRoom(roomName, creationType, creationReason, arena, matchType);
			};
			LeaveRoom();
		}

		public void ConnectToMatchRoom(string roomName, RoomCreationType creationType, RoomCreationReason creationReason, Arena arena, MatchType matchType)
		{
			m_connectToMatchRoomCoroutine = StartCoroutine(OnConnectToMatchRoom(roomName, creationType, creationReason, arena, matchType));
		}

		private IEnumerator OnConnectToMatchRoom(string roomName, RoomCreationType creationType, RoomCreationReason creationReason, Arena arena, MatchType matchType)
		{
			CurrentMatchType = matchType;
			if (NetworkState == NetworkState.Unavailable)
			{
				WandsLogger.LogError("NetworkManager | Need to be logged in to the backend system.", LogColor.Photon);
				yield break;
			}
			yield return GoOnline();
			if (NetworkState == NetworkState.Offline)
			{
				WandsLogger.LogError("NetworkManager | Could not connect to Photon to join a match room.", LogColor.Photon);
				EventHub.Publish(new Events.ConnectToMatchRoomFailed());
				yield break;
			}
			while (!PhotonNetwork.IsConnectedAndReady)
			{
				yield return null;
			}
			switch (creationType)
			{
			case RoomCreationType.Create:
				CreateRoom(roomName, creationReason, arena, matchType);
				break;
			case RoomCreationType.Join:
				JoinRoom(roomName);
				break;
			case RoomCreationType.JoinOrCreate:
				JoinOrCreateRoom(roomName, creationReason, arena, matchType);
				break;
			default:
				throw new NotImplementedException($"NetworkRoomCreation Type is not implemented: {creationType}");
			}
		}

		public void ConnectToMatchLobby()
		{
			m_connectToMatchLobbyCoroutine = StartCoroutine(OnConnectToMatchLobby());
		}

		private IEnumerator OnConnectToMatchLobby()
		{
			if (NetworkState == NetworkState.Unavailable)
			{
				WandsLogger.LogError("NetworkManager | Need to be logged in to the backend system.", LogColor.Photon);
				yield break;
			}
			yield return GoOnline();
			if (NetworkState == NetworkState.Offline)
			{
				WandsLogger.LogError("NetworkManager | Could not connect to Photon to join the match lobby.", LogColor.Photon);
				EventHub.Publish(new Events.ConnectToMatchLobbyFailed());
				yield break;
			}
			PhotonNetwork.JoinLobby(m_sqlLobby);
			yield return WaitForBool(() => NetworkState == NetworkState.InLobby, 15f);
			if (NetworkState != NetworkState.InLobby)
			{
				WandsLogger.LogError("NetworkManager | Could not connect to Match Lobby.", LogColor.Photon);
				EventHub.Publish(new Events.ConnectToMatchLobbyFailed());
			}
			else
			{
				EventHub.Publish(new Events.ConnectedToMatchLobby());
			}
		}

		private void CreateRoom(string roomName, RoomCreationReason creationReason, Arena arena, MatchType matchType)
		{
			Photon.Realtime.RoomOptions roomOptions = GetRoomOptions(creationReason, arena, matchType);
			SetCustomPropertiesForLobby(ref roomOptions);
			PhotonNetwork.CreateRoom(roomName, roomOptions, m_sqlLobby);
		}

		private void JoinRoom(string roomName)
		{
			PhotonNetwork.JoinRoom(roomName);
		}

		private void JoinOrCreateRoom(string roomName, RoomCreationReason creationReason, Arena arena, MatchType matchType)
		{
			Photon.Realtime.RoomOptions roomOptions = GetRoomOptions(creationReason, arena, matchType);
			SetCustomPropertiesForLobby(ref roomOptions);
			PhotonNetwork.JoinOrCreateRoom(roomName, roomOptions, m_sqlLobby);
		}

		private void JoinRandomRoom(MatchmakingMode mode, string sqlFilter)
		{
			PhotonNetwork.JoinRandomRoom(null, 0, mode, m_sqlLobby, sqlFilter);
		}

		private Photon.Realtime.RoomOptions GetRoomOptions(RoomCreationReason creationReason, Arena arena, MatchType matchType)
		{
			if (arena == Arena.None && matchType != MatchType.Tutorial && matchType != MatchType.None)
			{
				WandsLogger.LogError(string.Format("NetworkManager.GetRoomOptions() needs to be provided with an arena to use but was called with {0}", "None"));
			}
			Photon.Realtime.RoomOptions roomOptions = new Photon.Realtime.RoomOptions();
			roomOptions.MaxPlayers = (byte)(creationReason.ContainsFlag(RoomCreationReason.SinglePlayer) ? 1u : 2u);
			roomOptions.IsOpen = true;
			roomOptions.IsVisible = !creationReason.ContainsFlag((RoomCreationReason)151);
			roomOptions.BroadcastPropsChangeToAll = !matchType.ContainsFlag(MatchType.Bot);
			ExitGames.Client.Photon.Hashtable hashtable = new ExitGames.Client.Photon.Hashtable
			{
				["C3"] = (int)matchType,
				["A5"] = (int)creationReason,
				["A1"] = (int)GameControl.Instance.Platform.Type,
				["C4"] = 1,
				["C5"] = false,
				["A2"] = arena.ToString(),
				["P1"] = string.Empty
			};
			int? num = GameControl.Instance.Player?.SaveData.LevelData.Level;
			hashtable["C1"] = ((!num.HasValue) ? 5 : num.Value);
			hashtable["C2"] = (GameControl.Instance.Platform.SupportsPositionalTracking ? 2 : (GameControl.Instance.PositionalTrackingOpponentEnabled ? 1 : 0));
			hashtable["C8"] = PhotonNetwork.LocalPlayer.NickName;
			roomOptions.CustomRoomProperties = hashtable;
			return roomOptions;
		}

		private void SetCustomPropertiesForLobby(ref Photon.Realtime.RoomOptions roomOptions)
		{
			roomOptions.CustomRoomPropertiesForLobby = new string[11]
			{
				"C3", "A5", "A1", "C4", "C5", "A2", "P1", "C1", "C2", "A6",
				"C8"
			};
		}

		private MatchType GetCurrentRoomMatchType()
		{
			if (PhotonNetwork.InRoom)
			{
				return RoomProperty.GetMatchType();
			}
			return MatchType.None;
		}

		private Arena GetCurrentRoomArena()
		{
			if (PhotonNetwork.InRoom)
			{
				return (Arena)Enum.Parse(typeof(Arena), (string)RoomProperty.GetRoomProperty("A2"), ignoreCase: true);
			}
			return Arena.None;
		}

		private RoomCreationReason GetCurrentRoomCreationReason()
		{
			if (PhotonNetwork.InRoom)
			{
				return (RoomCreationReason)RoomProperty.GetRoomProperty("A5");
			}
			return RoomCreationReason.None;
		}

		public int GetNumberOfActivePlayers()
		{
			if (m_activePlayers.IsNullOrEmpty())
			{
				SetActivePlayers();
			}
			int num = 0;
			for (int i = 0; i < m_activePlayers.Count; i++)
			{
				if (m_activePlayers[i] != null)
				{
					num++;
				}
			}
			return num;
		}

		public int GetActivePlayerIndex(Photon.Realtime.Player Owner)
		{
			if (m_activePlayers.IsNullOrEmpty())
			{
				SetActivePlayers();
			}
			int num = 0;
			for (int i = 0; i < m_activePlayers.Count; i++)
			{
				if (m_activePlayers[i] == Owner)
				{
					return (num > 1) ? 1 : num;
				}
				if (m_activePlayers[i] != null)
				{
					num++;
				}
			}
			return 0;
		}

		public List<Photon.Realtime.Player> GetActivePlayers()
		{
			if (m_activePlayers.IsNullOrEmpty())
			{
				SetActivePlayers();
			}
			string text = ((!m_activePlayers.IsNullOrEmpty()) ? m_activePlayers[0].NickName : string.Empty);
			List<Photon.Realtime.Player> list = new List<Photon.Realtime.Player>();
			for (int i = 0; i < m_activePlayers.Count; i++)
			{
				if (m_activePlayers[i] != null)
				{
					list.Add(m_activePlayers[i]);
				}
			}
			return list;
		}

		private void SetActivePlayers(Photon.Realtime.Player excludePlayer = null)
		{
			m_activePlayers.Clear();
			if (PhotonNetwork.InRoom)
			{
				Photon.Realtime.Player[] playerList = PhotonNetwork.PlayerList;
				foreach (Photon.Realtime.Player item in playerList)
				{
					m_activePlayers.Add(item);
				}
				if (m_activePlayers.Count > 1)
				{
					m_activePlayers.Sort((Photon.Realtime.Player x, Photon.Realtime.Player y) => y.IsMasterClient.CompareTo(x.IsMasterClient));
				}
			}
			else
			{
				m_activePlayers.Add(PhotonNetwork.LocalPlayer);
			}
			if (excludePlayer != null)
			{
				m_activePlayers.Remove(excludePlayer);
			}
		}

		public void AssignMasterClientToLocal()
		{
			if (!PhotonNetwork.IsMasterClient)
			{
				PhotonNetwork.SetMasterClient(PhotonNetwork.LocalPlayer);
			}
		}

		public void KickPhotonPlayer(Photon.Realtime.Player kickPlayer)
		{
			if (kickPlayer != null && PhotonNetwork.IsMasterClient)
			{
				PhotonNetwork.DestroyPlayerObjects(kickPlayer);
				PhotonNetwork.CloseConnection(kickPlayer);
				OnPlayerLeftRoom(kickPlayer);
				PhotonNetwork.SendAllOutgoingCommands();
			}
		}

		public void SetPlayerInfo(string playerName, string userId)
		{
			if (GameControl.Instance.IsExpectedConnectionType(ConnectionType.Develop))
			{
				userId = Guid.NewGuid().ToString();
			}
			PhotonNetwork.AuthValues = new AuthenticationValues(userId);
			PhotonNetwork.LocalPlayer.NickName = playerName;
			ExitGames.Client.Photon.Hashtable hashtable = new ExitGames.Client.Photon.Hashtable();
			hashtable.Add("P1", (int)GameControl.Instance.Platform.Type);
			hashtable.Add("P2", GameControl.Instance.Player.SaveData.IsDeveloper);
			hashtable.Add("P6", GameControl.Instance.Platform.SupportsPositionalTracking);
			PhotonNetwork.SetPlayerCustomProperties(hashtable);
		}

		public string GetPreviousOpponent()
		{
			return m_previousOpponent;
		}

		public void ResetPreviousOpponent()
		{
			m_previousOpponent = null;
		}

		public void FindMatch()
		{
			Matchmaker.FindMatch(OnFoundMatch, OnMatchError);
			EventHub.Publish(new Events.MatchmakingStartedEvent());
		}

		private void OnFoundMatch(string roomId)
		{
			m_onFoundMatchCoroutine = StartCoroutine(HandleMatchFound(roomId));
		}

		private IEnumerator HandleMatchFound(string roomId)
		{
			while (!PhotonNetwork.InRoom)
			{
				yield return null;
			}
			while (!PhotonNetwork.IsConnectedAndReady)
			{
				yield return null;
			}
			while (GameControl.Instance.IsCurrentLevel(Level.Workshop))
			{
				yield return null;
			}
			yield return HandleLobby();
			yield return HandleArena();
			LeaveRoom();
			while (PhotonNetwork.InRoom)
			{
				yield return null;
			}
			while (!PhotonNetwork.IsConnectedAndReady)
			{
				yield return null;
			}
			JoinOrCreateRoom(roomId, RoomCreationReason.HostRanked, ArenaUtils.GetRandomArena(), MatchType.Competitive);
			yield return WaitForOpponent();
		}

		private IEnumerator HandleLobby()
		{
			if (!GameControl.Instance.IsCurrentLevel(Level.Lobby))
			{
				yield break;
			}
			if (PunSingleton<LobbyManager>.Instance.CountdownHandler.IsCountdownActive || PunSingleton<LobbyManager>.Instance.State == LobbyState.Post)
			{
				PrepareWaitingForOpponent();
				PlayerManager.Instance.PlayerControl.ToggleInputActive(active: true);
			}
			else if (CurrentMatchType.ContainsFlag(MatchType.Bot))
			{
				while (ExpandedSingleton<FadeHandler>.Instance.IsFaded)
				{
					yield return null;
				}
				if (ExpandedSingleton<LevelLoader>.Instance.IsLoadingLevel || GameControl.Instance.IsCurrentLevel(Level.Arena))
				{
					while (PunSingleton<SceneControl>.Instance == null || !PunSingleton<SceneControl>.Instance.CountdownHandler.IsCountdownActive)
					{
						yield return null;
					}
				}
				else
				{
					PrepareWaitingForOpponent();
				}
			}
			else
			{
				PrepareWaitingForOpponent();
			}
		}

		private IEnumerator HandleArena()
		{
			if (!GameControl.Instance.IsCurrentLevel(Level.Arena))
			{
				yield break;
			}
			if (!PunSingleton<SceneControl>.Instance.MatchStarted && !PunSingleton<SceneControl>.Instance.GameOver)
			{
				while (!PunSingleton<SceneControl>.Instance.CountdownHandler.IsCountdownActive)
				{
					yield return null;
				}
			}
			PunSingleton<SceneControl>.Instance.CountdownHandler.CancelCountdown();
			if (!PunSingleton<SceneControl>.Instance.GameOver)
			{
				PunSingleton<SceneControl>.Instance.EndMatch(-1, MatchEndReasonType.FoundMatch);
			}
			while (!ExpandedSingleton<FadeHandler>.Instance.IsFaded)
			{
				yield return null;
			}
			RoomProperty.SetRoomProperty("C5", value: false);
			while (GameControl.Instance.IsCurrentLevel(Level.Arena))
			{
				yield return null;
			}
			PrepareWaitingForOpponent();
		}

		private IEnumerator WaitForOpponent()
		{
			yield return WaitForBool(() => PlayerManager.Instance == null || PlayerManager.Instance.IsGameFull, 30f);
			if (!(PlayerManager.Instance != null) || PlayerManager.Instance.IsGameFull)
			{
				yield break;
			}
			EventHub.Publish(new Events.OpponentMissingEvent());
			yield return new WaitForSeconds(3f);
			if (!(PlayerManager.Instance == null) && !PlayerManager.Instance.IsGameFull)
			{
				LeaveRoom();
				while (PhotonNetwork.InRoom)
				{
					yield return null;
				}
				while (!PhotonNetwork.IsConnectedAndReady)
				{
					yield return null;
				}
				yield return CreateRoomWhenReady();
				while (!PhotonNetwork.InRoom)
				{
					yield return null;
				}
				FindMatch();
			}
		}

		private IEnumerator CreateRoomWhenReady()
		{
			while (!PhotonNetwork.IsConnectedAndReady)
			{
				yield return null;
			}
			CreateRoom(null, RoomCreationReason.HostRanked, ArenaUtils.GetRandomArena(), MatchType.Competitive);
		}

		private void PrepareWaitingForOpponent()
		{
			EventHub.Publish(new Events.PostMatchUiSkippedEvent());
			PunSingleton<LobbyManager>.Instance.CountdownHandler.CancelCountdown();
			PlayerManager.Instance.RemoveBotControl();
			MonoSingleton<LobbyUI>.Instance.KillMonolithTween();
			PunSingleton<LobbyManager>.Instance.ChangeState(LobbyState.Pre, force: true);
			EventHub.Publish(new Events.MatchmakingFinishedEvent());
		}

		private void OnMatchError()
		{
			EventHub.Publish(new Events.MatchmakingErrorEvent());
			GameControl.Instance.LeaveGame(5f, penalizePlayer: false, quitGame: false);
		}

		private IEnumerator WaitForBool(Func<bool> func, float maxTime)
		{
			float time = 0f;
			while (!func() && time < maxTime)
			{
				time += Time.deltaTime;
				yield return null;
			}
		}

		public void ResetMatchType()
		{
			if (CurrentMatchType.ContainsFlag(MatchType.Exhibition))
			{
				RoomProperty.SetRoomProperty("C3", 1);
				Events.MatchTypeUpdatedEvent matchTypeUpdatedEvent = new Events.MatchTypeUpdatedEvent();
				matchTypeUpdatedEvent.MatchType = MatchType.Competitive;
				EventHub.Publish(matchTypeUpdatedEvent);
			}
		}

		private void CheckExhibitionCriteria(Photon.Realtime.Player opponent)
		{
			if (RoomProperty.GetMatchType() != MatchType.Competitive)
			{
				return;
			}
			if ((bool)PlayerProperty.Get("P2") || (bool)PlayerProperty.Get("P2", opponent))
			{
				UpdateMatchTypeToExhibition();
				return;
			}
			int num = 0;
			int num2 = 0;
			int num3 = 0;
			if (opponent != null)
			{
				num = (int)PlayerProperty.Get("EL", opponent);
				num3 = (int)PlayerProperty.Get("SS", opponent);
				num2 = (int)PlayerProperty.Get("PL", opponent);
			}
			else
			{
				if (!GameControl.Instance.IsExpectedConnectionType(ConnectionType.Develop) || PlayerManager.Instance.IsGameFull)
				{
					return;
				}
				num = 1500;
				num2 = 10;
			}
			if (GameControl.Instance.Player.SaveData.LevelData.Level < 5 || num2 < 5)
			{
				UpdateMatchTypeToExhibition();
				return;
			}
			int rating = GameControl.Instance.Player.Rating;
			int seasonScore = GameControl.Instance.Player.SeasonScore;
			if (EloUtils.GetEloChange(EndState.Won, new int[2]
			{
				seasonScore + 1500,
				num
			}, 10, 10)[0] < 1)
			{
				UpdateMatchTypeToExhibition();
			}
			else if (EloUtils.GetEloChange(EndState.Won, new int[2]
			{
				num3 + 1500,
				rating
			}, 10, 10)[0] < 1)
			{
				UpdateMatchTypeToExhibition();
			}
		}

		private void UpdateMatchTypeToExhibition()
		{
			RoomProperty.SetRoomProperty("C3", 8);
			Events.MatchTypeUpdatedEvent matchTypeUpdatedEvent = new Events.MatchTypeUpdatedEvent();
			matchTypeUpdatedEvent.MatchType = MatchType.Exhibition;
			EventHub.Publish(matchTypeUpdatedEvent);
		}

		public void OnConnected()
		{
		}

		public void OnConnectedToMaster()
		{
			EventHub.Publish(new Events.ConnectedToPhotonMasterEvent());
			if (m_onConnectedToMaster != null)
			{
				m_onConnectedToMaster();
			}
			m_onConnectedToMaster = null;
		}

		public void OnDisconnected(DisconnectCause cause)
		{
			switch (cause)
			{
			case DisconnectCause.ServerTimeout:
			case DisconnectCause.ClientTimeout:
			{
				NetworkEvents.PhotonConnectionFailedEvent photonConnectionFailedEvent = new NetworkEvents.PhotonConnectionFailedEvent();
				photonConnectionFailedEvent.Cause = cause;
				EventHub.Publish(photonConnectionFailedEvent);
				break;
			}
			case DisconnectCause.DisconnectByServerLogic:
			case DisconnectCause.DisconnectByServerReasonUnknown:
			case DisconnectCause.DisconnectByClientLogic:
				NetworkState = NetworkState.Offline;
				TryCancelCoroutines();
				CancelInvoke();
				EventHub.Publish(new NetworkEvents.PhotonNetworkDisconnectedEvent());
				break;
			default:
			{
				NetworkEvents.PhotonConnectionFailedEvent photonConnectionFailedEvent = new NetworkEvents.PhotonConnectionFailedEvent();
				photonConnectionFailedEvent.Cause = cause;
				EventHub.Publish(photonConnectionFailedEvent);
				break;
			}
			}
		}

		private void TryCancelCoroutines()
		{
			if (m_connectToMatchLobbyCoroutine != null)
			{
				StopCoroutine(m_connectToMatchLobbyCoroutine);
				m_connectToMatchLobbyCoroutine = null;
			}
			if (m_connectToMatchRoomCoroutine != null)
			{
				StopCoroutine(m_connectToMatchRoomCoroutine);
				m_connectToMatchRoomCoroutine = null;
			}
			if (m_onFoundMatchCoroutine != null)
			{
				StopCoroutine(m_onFoundMatchCoroutine);
				m_onFoundMatchCoroutine = null;
			}
		}

		public void OnCustomAuthenticationResponse(Dictionary<string, object> data)
		{
		}

		public void OnCustomAuthenticationFailed(string debugMessage)
		{
		}

		public void OnRegionListReceived(RegionHandler regionHandler)
		{
		}

		public void OnJoinedLobby()
		{
			NetworkState = NetworkState.InLobby;
		}

		public void OnLeftLobby()
		{
		}

		public void OnRoomListUpdate(List<RoomInfo> roomList)
		{
			Events.ReceivedRoomListUpdate receivedRoomListUpdate = new Events.ReceivedRoomListUpdate();
			receivedRoomListUpdate.Rooms = roomList.ToArray();
			EventHub.Publish(receivedRoomListUpdate);
		}

		public void OnLobbyStatisticsUpdate(List<TypedLobbyInfo> lobbyStatistics)
		{
		}

		public void OnLeftRoom()
		{
			NetworkState = NetworkState.Offline;
			SetActivePlayers();
			NetworkUtils.ClearCache();
		}

		public void OnCreateRoomFailed(short returnCode, string message)
		{
			EventHub.Publish(new Events.ConnectToMatchRoomFailed());
		}

		public void OnJoinRoomFailed(short returnCode, string message)
		{
			EventHub.Publish(new Events.ConnectToMatchRoomFailed());
		}

		public void OnCreatedRoom()
		{
		}

		public void OnJoinedRoom()
		{
			if (GameControl.Instance.GetCurrentLevel() != Level.Lobby)
			{
				PhotonNetwork.IsMessageQueueRunning = false;
			}
			NetworkState = NetworkState.InRoom;
			SetActivePlayers();
			Events.ConnectedToMatchRoom connectedToMatchRoom = new Events.ConnectedToMatchRoom();
			connectedToMatchRoom.RoomName = PhotonNetwork.CurrentRoom.Name;
			connectedToMatchRoom.CreationReason = GetCurrentRoomCreationReason();
			connectedToMatchRoom.Arena = GetCurrentRoomArena();
			connectedToMatchRoom.MatchType = GetCurrentRoomMatchType();
			EventHub.Publish(connectedToMatchRoom);
		}

		public void OnJoinRandomFailed(short returnCode, string message)
		{
			CreateRoom(null, RoomCreationReason.HostRanked, ArenaUtils.GetRandomArena(), MatchType.Competitive);
		}

		public void OnFriendListUpdate(List<Photon.Realtime.FriendInfo> friendList)
		{
		}

		public void OnPlayerEnteredRoom(Photon.Realtime.Player newPlayer)
		{
			int num = (int)RoomProperty.GetRoomProperty("C4");
			if (PhotonNetwork.IsMasterClient)
			{
				num++;
				RoomProperty.SetRoomProperty("C4", num);
			}
			if (num > 2)
			{
				WandsLogger.LogError("NetworkManager | Too many players in the room, removing room!", LogColor.Photon);
				PhotonNetwork.CurrentRoom.IsVisible = false;
				LeaveRoom();
			}
			else if (!m_activePlayers.Contains(newPlayer))
			{
				SetActivePlayers();
				if (PhotonNetwork.IsMasterClient)
				{
					CheckExhibitionCriteria(newPlayer);
				}
				NetworkEvents.PhotonPlayerConnectedEvent photonPlayerConnectedEvent = new NetworkEvents.PhotonPlayerConnectedEvent();
				photonPlayerConnectedEvent.PhotonPlayer = newPlayer;
				EventHub.Publish(photonPlayerConnectedEvent);
			}
		}

		public void OnPlayerLeftRoom(Photon.Realtime.Player otherPlayer)
		{
			if (otherPlayer.IsMasterClient)
			{
				AssignMasterClientToLocal();
			}
			int num = (int)RoomProperty.GetRoomProperty("C4");
			if (num > 1)
			{
				num--;
				RoomProperty.SetRoomProperty("C4", num);
			}
			if (num >= 2)
			{
				WandsLogger.LogError("NetworkManager | Straggler left room.", LogColor.Photon);
				return;
			}
			PlayerManager.Instance?.RemoveRemoteCharacter();
			NetworkEvents.PhotonPlayerDisconnectedEvent photonPlayerDisconnectedEvent;
			if (!m_activePlayers.Contains(otherPlayer))
			{
				WandsLogger.LogError("NetworkManager | Leaving player had not been added to active players.", LogColor.Photon);
				photonPlayerDisconnectedEvent = new NetworkEvents.PhotonPlayerDisconnectedEvent();
				photonPlayerDisconnectedEvent.PhotonPlayer = null;
				EventHub.Publish(photonPlayerDisconnectedEvent);
				return;
			}
			SetActivePlayers(otherPlayer);
			PunSingleton<PauseManager>.Instance?.ForceUnPause();
			photonPlayerDisconnectedEvent = new NetworkEvents.PhotonPlayerDisconnectedEvent();
			photonPlayerDisconnectedEvent.PhotonPlayer = otherPlayer;
			EventHub.Publish(photonPlayerDisconnectedEvent);
			if (GetCurrentRoomMatchType().ContainsFlag(MatchType.Matchmade) && PunSingleton<LobbyManager>.Instance != null && PunSingleton<LobbyManager>.Instance.State != LobbyState.Post)
			{
				ResetMatchType();
				FindMatch();
			}
		}

		public void OnRoomPropertiesUpdate(ExitGames.Client.Photon.Hashtable propertiesThatChanged)
		{
		}

		public void OnPlayerPropertiesUpdate(Photon.Realtime.Player targetPlayer, ExitGames.Client.Photon.Hashtable changedProps)
		{
			NetworkEvents.PlayerPropertiesUpdatedEvent playerPropertiesUpdatedEvent = new NetworkEvents.PlayerPropertiesUpdatedEvent();
			playerPropertiesUpdatedEvent.TargetPlayer = targetPlayer;
			playerPropertiesUpdatedEvent.ChangedProps = changedProps;
			EventHub.Publish(playerPropertiesUpdatedEvent);
		}

		public void OnMasterClientSwitched(Photon.Realtime.Player newMasterClient)
		{
		}

		private void OnPlayFabLoadingEvent(Events.PlayFabLoadingEvent eventData)
		{
			if (eventData.Success)
			{
				bool isChinaBuild = GameControl.Instance.PlatformSettings.IsChinaBuild;
				m_regionCode = ((!isChinaBuild) ? "us" : "cn");
				m_serverHost = ((!isChinaBuild) ? "ns.exitgames.com" : "ns.photonengine.cn");
				m_networkVersionCode = GameControl.Instance.NetworkVersion;
				Version clientVersion = GameControl.Instance.ClientVersion;
				m_networkVersionCode += GameControl.Instance.GetVersionSuffix((GameControl.Instance.GetConnectionType() != ConnectionType.Release) ? clientVersion.Revision : (-1));
				NetworkState = NetworkState.Offline;
			}
		}

		private void OnTryFindNewMatches(Events.TryToFindNewMatchEvent eventData)
		{
			LeaveRoom();
		}

		private void OnMatchEnded(Events.MatchEndedEvent eventData)
		{
			m_previousOpponent = PlayerManager.Instance.GetOpponent()?.NickName;
		}

		private void OnPlayerRequestedRematch(Events.PlayerRequestedRematchEvent eventData)
		{
			if (PhotonNetwork.IsMasterClient)
			{
				ResetMatchType();
				CheckExhibitionCriteria(PlayerManager.Instance.GetOpponent());
			}
		}

		private void OnSceneLoadInitiated(Events.SceneLoadInitiatedEvent eventData)
		{
			if (eventData.LevelToLoad == Level.Workshop)
			{
				Matchmaker.CancelMatchmaking();
			}
			else if (eventData.CurrentLevel == Level.Workshop)
			{
				TryStopContinuousInternetCheck();
				GC.Collect();
			}
		}

		private void OnSceneLoaded(Events.SceneLoadedEvent eventData)
		{
			if (eventData.Level == Level.Workshop)
			{
				TryStartContinuousInternetCheck();
			}
		}

		private void TryStopContinuousInternetCheck()
		{
			if (m_continuousInternetCheckCoroutine != null)
			{
				StopCoroutine(m_continuousInternetCheckCoroutine);
				m_continuousInternetCheckCoroutine = null;
			}
		}

		private void TryStartContinuousInternetCheck()
		{
			if (m_continuousInternetCheckCoroutine == null)
			{
				m_continuousInternetCheckCoroutine = StartCoroutine(ContinuousInternetCheck());
			}
		}

		private IEnumerator ContinuousInternetCheck()
		{
			m_isInternetCheckInProgress = false;
			m_timeRemainingUntilNextInternetCheck = 0f;
			bool initialCheck = true;
			while (true)
			{
				if (m_isInternetCheckInProgress)
				{
					yield return null;
				}
				if (m_timeRemainingUntilNextInternetCheck > 0f)
				{
					m_timeRemainingUntilNextInternetCheck -= Time.deltaTime;
					yield return null;
				}
				m_isInternetCheckInProgress = true;
				yield return IsNetworkReachable();
				bool previousCheck = LatestInternetCheckWasSuccessful;
				LatestInternetCheckWasSuccessful = m_isNetworkReachable;
				if (m_isNetworkReachable)
				{
					if (!previousCheck || initialCheck)
					{
						EventHub.Publish(new Events.InternetConnectionVerifiedEvent());
					}
				}
				else if (previousCheck || initialCheck)
				{
					EventHub.Publish(new Events.InternetConnectionNotAvailableEvent());
				}
				while (m_internetCheckActions.Count > 0)
				{
					m_internetCheckActions.Dequeue()?.Invoke(m_isNetworkReachable);
				}
				initialCheck = false;
				m_isInternetCheckInProgress = false;
				m_timeRemainingUntilNextInternetCheck = ((!LatestInternetCheckWasSuccessful) ? 5f : 15f);
				yield return null;
			}
		}
	}
}
namespace Cortopia.Scripts.Network
{
	[RequireComponent(typeof(PhotonView))]
	public class NetworkObjectDestroyer : MonoBehaviourPun
	{
		[SerializeField]
		private float m_lifeSpan = 4f;

		private void OnDisable()
		{
			StopAllCoroutines();
		}

		private void Start()
		{
			if (base.photonView.IsMine)
			{
				StartCoroutine(DestroyAfterTime(m_lifeSpan));
			}
		}

		private IEnumerator DestroyAfterTime(float waitTime)
		{
			yield return new WaitForSeconds(waitTime);
			NetworkUtils.DestroyObject(base.photonView);
		}
	}
}
public class NetworkUtils
{
	private static DefaultPool sm_networkPool;

	private static DefaultPool NetworkPool
	{
		[CompilerGenerated]
		get
		{
			return (sm_networkPool != null) ? sm_networkPool : (sm_networkPool = PhotonNetwork.PrefabPool as DefaultPool);
		}
	}

	public static bool ConnectedToGame
	{
		[CompilerGenerated]
		get
		{
			return PhotonNetwork.IsConnected && PhotonNetwork.InRoom;
		}
	}

	public static void ClearCache()
	{
		NetworkPool.ResourceCache.Clear();
	}

	public static void TryCacheAsset(string assetPath)
	{
		if (!NetworkPool.ResourceCache.ContainsKey(assetPath))
		{
			NetworkPool.ResourceCache.Add(assetPath, GameObjectLoader.GetGameObject(AssetBundleType.Spells, assetPath));
		}
	}

	public static GameObject Instantiate(string assetPath, Vector3 position, Quaternion rotation, byte group, object[] data)
	{
		if (ConnectedToGame)
		{
			GameObject gameObject = Resources.Load<GameObject>(assetPath);
			if (gameObject == null && !NetworkPool.ResourceCache.ContainsKey(assetPath))
			{
				PunSingleton<NetworkCache>.Instance.CacheBundledAsset(assetPath);
			}
			return PhotonNetwork.Instantiate(assetPath, position, rotation, group, data);
		}
		return UnityEngine.Object.Instantiate(GameObjectLoader.GetGameObject(AssetBundleType.Spells, assetPath), position, rotation);
	}

	public static void InstantiateAsync(string path, Vector3 position, Quaternion rotation, byte group, Action<GameObject> onLoaded, object[] data)
	{
		GameObjectLoader.GetGameObjectAsync(AssetBundleType.Spells, path, delegate(GameObject loadedObject)
		{
			OnGameObjectLoaded(path, position, rotation, group, onLoaded, data, loadedObject);
		});
	}

	private static void OnGameObjectLoaded(string path, Vector3 position, Quaternion rotation, byte group, Action<GameObject> onLoaded, object[] data, GameObject spellGameObject)
	{
		GameObject obj = Instantiate(path, position, rotation, group, data);
		onLoaded(obj);
	}

	public static void InstantiateMultipleAsync(string path, Vector3 position, Quaternion rotation, byte group, int amount, Action<GameObject[]> onLoaded, object[] data)
	{
		GameObjectLoader.GetGameObjectAsync(AssetBundleType.Spells, path, delegate(GameObject loadedObject)
		{
			OnGameObjectLoaded(path, position, rotation, group, amount, onLoaded, data, loadedObject);
		});
	}

	private static void OnGameObjectLoaded(string path, Vector3 pos, Quaternion rot, byte group, int amount, Action<GameObject[]> onLoaded, object[] data, GameObject spellGameObject)
	{
		GameObject[] array = new GameObject[amount];
		for (int i = 0; i < amount; i++)
		{
			array[i] = Instantiate(path, pos, rot, group, data);
		}
		onLoaded(array);
	}

	public static void DestroyObject(PhotonView photonView)
	{
		if (photonView == null)
		{
			WandsLogger.LogError("Tried destroying null photon view");
		}
		else if (ConnectedToGame)
		{
			if (photonView.IsMine)
			{
				PhotonNetwork.Destroy(photonView);
			}
			else
			{
				WandsLogger.LogError("Trying to network remove a view that isn't mine");
			}
		}
		else if (photonView.gameObject != null)
		{
			UnityEngine.Object.Destroy(photonView.gameObject);
		}
	}
}
public static class PhotonExtensions
{
	public static bool IsLocal(this PhotonView photonView)
	{
		return photonView.Owner == null || photonView.Owner.IsLocal;
	}

	public static void AllocateViewID(this PhotonView photonView)
	{
		PhotonNetwork.AllocateViewID(photonView);
	}
}
namespace Assets.Scripts.Network
{
	public static class PlayerProperty
	{
		public const string ID = "P0";

		public const string PLATFORM = "P1";

		public const string DEVELOPER = "P2";

		public const string AIM_INPUT = "P4";

		public const string LOADOUT = "P5";

		public const string ROOMSCALE_ENABLED = "P6";

		public const string DUAL_WIELD_ENABLED = "P7";

		public const string ELO = "EL";

		public const string PLAYER_LEVEL = "PL";

		public const string SEASON_SCORE = "SS";

		public const string PICKUPS_USED = "PU";

		public const string MANA_USED = "MA";

		public const string DAMAGE_DEALT = "DD";

		public const string END_HP = "HP";

		public const string CHARACTER = "C0";

		public const string WAND_RIGHT = "C2";

		public const string WAND_LEFT = "C4";

		public const string TITLE = "C3";

		public const string OPPONENT_INFO = "OI";

		public const string PLAYFAB_ID = "PI";

		private static object Default(string playerPropertyID)
		{
			switch (playerPropertyID)
			{
			case "P6":
			case "P2":
				return false;
			case "P0":
			case "P5":
			case "PI":
			case "C3":
				return string.Empty;
			case "P4":
				return 8;
			case "C0":
				return 0;
			case "OI":
				return "{\r\n\t\t\t\t\t\"Name\":\"Default Opponent\",\r\n\t\t\t\t\t\"Level\":" + 0 + ",\r\n\t\t\t\t\t\"SeasonScore\":" + 0 + ",\r\n\t\t\t\t\t\"Rating\":" + 0 + ",\r\n\t\t\t\t\t\"Title\":" + 1000 + "\r\n\t\t\t\t\t}";
			default:
				return 0;
			}
		}

		public static void SetLoadoutWands(WandType wandRight, WandType wandLeft)
		{
			PhotonNetwork.LocalPlayer.SetCustomProperties(new ExitGames.Client.Photon.Hashtable
			{
				{
					"C2",
					(int)wandRight
				},
				{
					"C4",
					(int)wandLeft
				}
			});
		}

		public static void SetOpponentInfo(Photon.Realtime.Player opponent)
		{
			ExitGames.Client.Photon.Hashtable customProperties = opponent.CustomProperties;
			SetOpponentInfo(opponent.NickName, customProperties["PL"], customProperties["SS"], customProperties["EL"], customProperties["C3"]);
		}

		public static void SetOpponentInfo(string name, object level, object seasonScore, object rating, object title)
		{
			string value = string.Concat("{\r\n\t\t\t\t\"Name\":\"", name, "\",\r\n\t\t\t\t\"Level\":", level, ",\r\n\t\t\t\t\"SeasonScore\":", seasonScore, ",\r\n\t\t\t\t\"Rating\":", rating, ",\r\n\t\t\t\t\"Title\":", title, "\r\n\t\t\t\t}");
			PhotonNetwork.LocalPlayer.SetCustomProperties(new ExitGames.Client.Photon.Hashtable { { "OI", value } });
		}

		public static void Set(string playerPropertyID, object value)
		{
			WandsLogger.LogError($"Used generic SET for property {playerPropertyID}.", LogColor.Photon);
			PhotonNetwork.LocalPlayer.SetCustomProperties(new ExitGames.Client.Photon.Hashtable { { playerPropertyID, value } });
		}

		public static void Set(string playerPropertyID, bool value)
		{
			PhotonNetwork.LocalPlayer.SetCustomProperties(new ExitGames.Client.Photon.Hashtable { { playerPropertyID, value } });
		}

		public static void Set(string playerPropertyID, int value)
		{
			PhotonNetwork.LocalPlayer.SetCustomProperties(new ExitGames.Client.Photon.Hashtable { { playerPropertyID, value } });
		}

		public static void Set(string playerPropertyID, float value)
		{
			PhotonNetwork.LocalPlayer.SetCustomProperties(new ExitGames.Client.Photon.Hashtable { { playerPropertyID, value } });
		}

		public static void Set(string playerPropertyID, string value)
		{
			PhotonNetwork.LocalPlayer.SetCustomProperties(new ExitGames.Client.Photon.Hashtable { { playerPropertyID, value } });
		}

		public static void Set(string playerPropertyID, object value, Photon.Realtime.Player player)
		{
			if (player == null)
			{
				WandsLogger.LogError("Can't set PlayerProperty; player is null!", LogColor.Photon);
				return;
			}
			WandsLogger.LogError($"Used generic SET for player {player} property {playerPropertyID}.", LogColor.Photon);
			player.SetCustomProperties(new ExitGames.Client.Photon.Hashtable { { playerPropertyID, value } });
		}

		public static void Set(string playerPropertyID, int value, Photon.Realtime.Player player)
		{
			if (player == null)
			{
				WandsLogger.LogError("Can't set PlayerProperty; player is null!", LogColor.Photon);
				return;
			}
			player.SetCustomProperties(new ExitGames.Client.Photon.Hashtable { { playerPropertyID, value } });
		}

		public static void Increment(string playerPropertyID, int value, Photon.Realtime.Player player)
		{
			if (player == null)
			{
				WandsLogger.LogError("Can't set PlayerProperty; player is null!", LogColor.Photon);
				return;
			}
			value += (int)Get(playerPropertyID, player);
			player.SetCustomProperties(new ExitGames.Client.Photon.Hashtable { { playerPropertyID, value } });
		}

		public static object Get(string playerPropertyID)
		{
			return Get(playerPropertyID, PhotonNetwork.LocalPlayer);
		}

		public static object Get(string playerPropertyID, Photon.Realtime.Player player)
		{
			if (player == null)
			{
				WandsLogger.LogError("Can't get PlayerProperty; player is null!", LogColor.Photon);
				return null;
			}
			if (player.CustomProperties.TryGetValue(playerPropertyID, out var value))
			{
				return value;
			}
			value = Default(playerPropertyID);
			player.SetCustomProperties(new ExitGames.Client.Photon.Hashtable { { playerPropertyID, value } });
			return value;
		}
	}
	public static class RoomProperty
	{
		public const string MATCH_RESTART = "R3";

		public const string PLAYER_NAMES = "P1";

		public const string MATCH_END_TIME = "L1";

		public const string MATCH_TIME = "L2";

		public const string ROOM_TIME = "L3";

		public const string COUNTDOWN_TIME = "L4";

		public const string FIRST_BLOOD = "G0";

		public const string DAMAGE_DEALER = "G1";

		public const string ROOM_LEVEL = "C1";

		public const string POSITIONAL_TRACKING = "C2";

		public const string MATCH_TYPE = "C3";

		public const string ACTIVE_PLAYERS = "C4";

		public const string GAME_OVER = "C5";

		public const string PLAYER_NAME = "C8";

		public const string PLATFORM = "A1";

		public const string ARENA = "A2";

		public const string REMATCH = "A3";

		public const string MATCH_ID = "A4";

		public const string CREATION_REASON = "A5";

		public const string MATCH_STARTED = "A6";

		private static object GetOfflineValue(string roomPropertyID)
		{
			switch (roomPropertyID)
			{
			case "A2":
			case "P1":
				return string.Empty;
			case "C4":
			case "G0":
			case "R3":
			case "G1":
				return -1;
			case "A1":
			case "A4":
				return 0;
			case "C5":
			case "A6":
			case "A3":
				return false;
			case "L2":
			case "L3":
			case "L4":
				return -0.1f;
			case "L1":
				return 0f;
			case "C3":
				return 128;
			case "A5":
				return 0;
			default:
				return null;
			}
		}

		public static void SetRoomProperty(string roomPropertyID, object value)
		{
			Photon.Realtime.Room currentRoom = PhotonNetwork.CurrentRoom;
			if (currentRoom == null)
			{
				WandsLogger.LogError("Room is null, couldn't set room property");
				return;
			}
			currentRoom.SetCustomProperties(new ExitGames.Client.Photon.Hashtable { { roomPropertyID, value } });
		}

		public static void SetRoomProperty(string roomPropertyID, bool value)
		{
			Photon.Realtime.Room currentRoom = PhotonNetwork.CurrentRoom;
			if (currentRoom == null)
			{
				WandsLogger.LogError("Room is null, couldn't set room property");
				return;
			}
			currentRoom.SetCustomProperties(new ExitGames.Client.Photon.Hashtable { { roomPropertyID, value } });
		}

		public static void SetRoomProperty(string roomPropertyID, int value)
		{
			Photon.Realtime.Room currentRoom = PhotonNetwork.CurrentRoom;
			if (currentRoom == null)
			{
				WandsLogger.LogError("Room is null, couldn't set room property");
				return;
			}
			currentRoom.SetCustomProperties(new ExitGames.Client.Photon.Hashtable { { roomPropertyID, value } });
		}

		public static void SetRoomProperty(string roomPropertyID, float value)
		{
			Photon.Realtime.Room currentRoom = PhotonNetwork.CurrentRoom;
			if (currentRoom == null)
			{
				WandsLogger.LogError("Room is null, couldn't set room property");
				return;
			}
			currentRoom.SetCustomProperties(new ExitGames.Client.Photon.Hashtable { { roomPropertyID, value } });
		}

		public static void SetRoomProperty(string roomPropertyID, double value)
		{
			Photon.Realtime.Room currentRoom = PhotonNetwork.CurrentRoom;
			if (currentRoom == null)
			{
				WandsLogger.LogError("Room is null, couldn't set room property");
				return;
			}
			currentRoom.SetCustomProperties(new ExitGames.Client.Photon.Hashtable { { roomPropertyID, value } });
		}

		public static void SetRoomProperty(string roomPropertyID, string value)
		{
			Photon.Realtime.Room currentRoom = PhotonNetwork.CurrentRoom;
			if (currentRoom == null)
			{
				WandsLogger.LogError("Room is null, couldn't set room property");
				return;
			}
			currentRoom.SetCustomProperties(new ExitGames.Client.Photon.Hashtable { { roomPropertyID, value } });
		}

		public static void AddRoomProperty(string roomPropertyID, int value)
		{
			Photon.Realtime.Room currentRoom = PhotonNetwork.CurrentRoom;
			if (currentRoom == null)
			{
				WandsLogger.LogError("Room is null, couldn't increment room property");
				return;
			}
			value += (int)GetRoomProperty(roomPropertyID);
			currentRoom.SetCustomProperties(new ExitGames.Client.Photon.Hashtable { { roomPropertyID, value } });
		}

		public static object GetRoomProperty(string roomPropertyID)
		{
			Photon.Realtime.Room currentRoom = PhotonNetwork.CurrentRoom;
			if (currentRoom == null)
			{
				return GetOfflineValue(roomPropertyID);
			}
			if (currentRoom.CustomProperties.TryGetValue(roomPropertyID, out var value))
			{
				return value;
			}
			value = GetOfflineValue(roomPropertyID);
			currentRoom.SetCustomProperties(new ExitGames.Client.Photon.Hashtable { { roomPropertyID, value } });
			return value;
		}

		public static MatchType GetMatchType()
		{
			return (MatchType)(int)GetRoomProperty("C3");
		}
	}
	public class ServerBridge : MonoBehaviour
	{
		public enum ServerCommand
		{
			MatchInfo
		}

		private void OnDisable()
		{
			StopAllCoroutines();
		}

		public void SendToServer(string url, string name, string data)
		{
			if (GameControl.Instance.IsExpectedConnectionType((ConnectionType)5))
			{
				StartCoroutine(SendString(url, name, data));
			}
		}

		public void SendToServer(ServerCommand cmd, string name, string data)
		{
			if (GameControl.Instance.IsExpectedConnectionType((ConnectionType)5))
			{
				StartCoroutine(SendString(GetURL(cmd), name, data));
			}
		}

		private IEnumerator SendString(string url, string name, string data)
		{
			WWWForm form = new WWWForm();
			form.AddField(name, data);
			using UnityWebRequest www = UnityWebRequest.Post(url, data);
			yield return www.SendWebRequest();
			if (www.isNetworkError || www.isHttpError)
			{
				WandsLogger.LogError($"Send {data} to server failed with error: {www.error}");
			}
		}

		public void GetTextFromServer(ServerCommand cmd, Action<string> callback)
		{
			StartCoroutine(GetText(GetURL(cmd), callback));
		}

		public void GetTextFromServer(string url, Action<string> callback)
		{
			StartCoroutine(GetText(url, callback));
		}

		private IEnumerator GetText(string url, Action<string> callback)
		{
			using UnityWebRequest www = UnityWebRequest.Get(url);
			yield return www.SendWebRequest();
			if (www.isNetworkError || www.isHttpError)
			{
				WandsLogger.LogError($"Get text from server failed with error: {www.error}");
			}
			else
			{
				callback?.Invoke(www.downloadHandler.text);
			}
		}

		private string GetURL(ServerCommand serverCommand)
		{
			if (serverCommand == ServerCommand.MatchInfo)
			{
				return "https://api.wandsgame.com/v1/matches";
			}
			throw new NotImplementedException($"{serverCommand} not recognized");
		}
	}
}
public class SpawnPoint : MonoBehaviour
{
	public Tile _tile;
}
namespace Assets.Scripts.Network
{
	public static class WandsVoip
	{
		public static bool IsPlayerEnabled
		{
			get
			{
				return UniAndroidPermission.IsPermitted(AndroidPermission.RECORD_AUDIO) && WandsSave.GetBoolPref("VE");
			}
			set
			{
				if (UniAndroidPermission.IsPermitted(AndroidPermission.RECORD_AUDIO))
				{
					WandsSave.SetPlayerPref("VE", Convert.ToInt32(value));
					PlayerManager.Instance?.LocalWielder.ToggleVoipTransmission(value);
				}
			}
		}

		public static bool IsOpponentEnabled
		{
			get
			{
				return UniAndroidPermission.IsPermitted(AndroidPermission.RECORD_AUDIO) && WandsSave.GetBoolPref("VEO", defaultValue: true);
			}
			set
			{
				if (UniAndroidPermission.IsPermitted(AndroidPermission.RECORD_AUDIO))
				{
					WandsSave.SetPlayerPref("VEO", Convert.ToInt32(value));
					PlayerManager.Instance?.GetOpponentWielder()?.ToggleVoipSpeaker(value);
				}
			}
		}
	}
}
[RequireComponent(typeof(PhotonView), typeof(AnimationNetworkRelay))]
public class Wielder : MonoBehaviourPun, IPunObservable, IPunInstantiateMagicCallback, ICursable
{
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	private struct TrackingPoint
	{
		public const int Origin = 0;

		public const int Head = 1;

		public const int LeftHand = 2;

		public const int RightHand = 3;
	}

	[SerializeField]
	private PhotonVoiceView m_photonVoiceView;

	[SerializeField]
	private AudioSource m_voipAudioSource;

	private bool m_syncHands;

	private bool m_resetRemoteCharacter;

	private bool m_shouldResetRemoteIK;

	private int? m_index;

	private float m_firstBloodTimeStamp;

	private string m_previousDebugMsg;

	private Photon.Realtime.Player m_owner;

	private bool m_hasInstantiated;

	private bool m_isAudioPermissionBlocked;

	private bool m_isChillingClutchActive;

	private EventToken m_matchResetEventToken;

	private EventToken m_playerRecenterEventToken;

	private VirtualTransform[] m_currentTrackingTransforms = new VirtualTransform[4]
	{
		new VirtualTransform(),
		new VirtualTransform(),
		new VirtualTransform(),
		new VirtualTransform()
	};

	private VirtualTransform[] m_targetTrackingTransforms = new VirtualTransform[4]
	{
		new VirtualTransform(),
		new VirtualTransform(),
		new VirtualTransform(),
		new VirtualTransform()
	};

	private List<Twin> m_twins = new List<Twin>(2);

	private RemoteCharacter m_remoteCharacterPrefab;

	private PlayerControl m_playerControl;

	private BotControl m_botControl;

	public bool IsArmorActive { get; set; }

	public StatsData HealthData { get; private set; }

	public StatsData ManaData { get; private set; }

	private float Health
	{
		get
		{
			return HealthData.Current;
		}
		set
		{
			HealthData.SetCurrent(value);
		}
	}

	private float Mana
	{
		get
		{
			return ManaData.Current;
		}
		set
		{
			ManaData.SetCurrent(value);
		}
	}

	public Tile CurrentTile
	{
		[CompilerGenerated]
		get
		{
			return CharacterControl.GetCurrentTile();
		}
	}

	public bool IsLocal
	{
		[CompilerGenerated]
		get
		{
			return CharacterControl != null;
		}
	}

	public bool IsPlayer { get; private set; }

	public bool IsBot { get; private set; }

	public AnimationNetworkRelay AnimationRelay { get; private set; }

	public Photon.Realtime.Player Owner
	{
		get
		{
			return m_owner ?? PhotonNetwork.LocalPlayer;
		}
		private set
		{
			m_owner = value;
		}
	}

	public WandManager Wand
	{
		[CompilerGenerated]
		get
		{
			return (!IsLocal) ? null : CharacterControl.Wand;
		}
	}

	public CharacterControl CharacterControl { get; private set; }

	public PlayerControl PlayerControl
	{
		[CompilerGenerated]
		get
		{
			return (!(m_playerControl != null)) ? null : m_playerControl;
		}
	}

	public BotControl BotControl
	{
		[CompilerGenerated]
		get
		{
			return (!(m_botControl != null)) ? null : m_botControl;
		}
	}

	public RemoteCharacter RemoteCharacter { get; private set; }

	public BotCharacter BotCharacter { get; private set; }

	public CharacterBase Character
	{
		[CompilerGenerated]
		get
		{
			return (!IsBot) ? ((CharacterBase)RemoteCharacter) : ((CharacterBase)BotCharacter);
		}
	}

	public int ViewID
	{
		[CompilerGenerated]
		get
		{
			return base.photonView.ViewID;
		}
	}

	public bool IsPaused { get; private set; }

	public EffectUtils EffectHandler
	{
		[CompilerGenerated]
		get
		{
			return (!IsLocal) ? RemoteCharacter.EffectHandler : CharacterControl.EffectHandler;
		}
	}

	public int GetIndex()
	{
		if (!NetworkUtils.ConnectedToGame)
		{
			int? index = m_index;
			return (!index.HasValue) ? 1 : index.Value;
		}
		if (!m_index.HasValue)
		{
			UpdateIndex();
		}
		return m_index.Value;
	}

	public void UpdateIndex()
	{
		m_index = ((!IsBot) ? Mathf.Clamp(MonoSingleton<NetworkManager>.Instance.GetActivePlayerIndex(Owner) + 1, 1, 2) : 2);
	}

	private void Awake()
	{
		m_remoteCharacterPrefab = Resources.Load<RemoteCharacter>("CharacterControllers/RemoteCharacter");
	}

	private void Start()
	{
		InitializeVoip();
	}

	private void OnEnable()
	{
		m_matchResetEventToken = EventHub.Subscribe<Events.MatchResetEvent>(OnMatchReset);
		if (base.photonView.IsLocal())
		{
			m_playerRecenterEventToken = EventHub.Subscribe<Events.OnCameraRecenteredEvent>(OnRecenter);
		}
	}

	private void OnDisable()
	{
		CancelInvoke();
		if (CharacterControl != null)
		{
			AbortContinuousHit();
		}
		PlayerManager.Instance?.RemoveWielder(this);
		EventHub.Unsubscribe<Events.MatchResetEvent>(m_matchResetEventToken);
		if (base.photonView.IsLocal())
		{
			EventHub.Unsubscribe<Events.OnCameraRecenteredEvent>(m_playerRecenterEventToken);
		}
	}

	private void OnDestroy()
	{
		CancelInvoke();
		PlayerManager.Instance?.UpdateWielderList();
	}

	private void LateUpdate()
	{
		if (IsLocal)
		{
			return;
		}
		if (m_shouldResetRemoteIK)
		{
			ResetIKUpdate();
			m_shouldResetRemoteIK = false;
			return;
		}
		if (RemoteCharacter != null)
		{
			TrySyncRemoteCharacter(m_resetRemoteCharacter);
			SyncRemoteWielderPosition();
		}
		TrySyncTwins();
	}

	private void OnMatchReset(Events.MatchResetEvent eventData)
	{
		ResetWielder();
	}

	public void OnPlayerDisconnect()
	{
		Invoke("ResetPlayer", 1f);
	}

	private void ResetPlayer()
	{
		if (CharacterControl != null)
		{
			CharacterControl.ResetPlayerStats();
			if (IsPlayer)
			{
				PlayerControl.OnPlayerDisconnected(GetLayerMask());
			}
		}
		else if (RemoteCharacter != null)
		{
			RemoteCharacter.ResetRemoteCharacter();
		}
	}

	public void ConnectPlayerController(CharacterControl characterControl)
	{
		if (characterControl is PlayerControl)
		{
			m_playerControl = characterControl as PlayerControl;
			IsPlayer = true;
		}
		else if (characterControl is BotControl)
		{
			m_botControl = characterControl as BotControl;
			IsBot = true;
		}
		else
		{
			WandsLogger.LogError("Wielder is neither Player nor Bot controlled");
		}
		UpdateIndex();
		CharacterControl = characterControl;
		CharacterControl.ResetPlayerStats();
		HealthData = CharacterControl.GetHealthData();
		ManaData = CharacterControl.GetManaData();
		characterControl.ResetPosition(RoomProperty.GetMatchType());
		PunSetRemoteCharacterTile(characterControl.GetCurrentTile().photonView.ViewID);
		PlayerManager.Instance.AddWielder(this);
	}

	public void SetBotOwner()
	{
		Owner = PlayerManager.Instance.GetOpponent();
	}

	public LayerMask GetLayerMask()
	{
		return LayerMask.NameToLayer($"Player{GetIndex()}");
	}

	public CapsuleCollider GetCollider()
	{
		return CharacterControl?.Collider ?? RemoteCharacter.Collider;
	}

	[PunRPC]
	private void PunPlayHitReponse()
	{
		PlayerManager.Instance.PlayerControl.Input.PlayHitResponse();
	}

	public void PlayHitReponse()
	{
		base.photonView.RPC("PunPlayHitReponse", RpcTarget.Others);
	}

	public void PlayerDeath(float dot)
	{
		bool? flag = PunSingleton<SceneControl>.Instance?.GameOver;
		if (!flag.HasValue || !flag.Value)
		{
			if (IsLocal)
			{
				CharacterControl.Wand.AbortSpellCasting();
			}
			Wielder opponent = null;
			if (PlayerManager.Instance.CanGetOpponentWielder(ViewID, out opponent))
			{
				PunSingleton<SceneControl>.Instance?.EndMatch(opponent.ViewID, MatchEndReasonType.Elimination);
			}
			else
			{
				PunSingleton<SceneControl>.Instance?.EndMatch(-1, MatchEndReasonType.Elimination);
			}
		}
	}

	public void SetStats(MatchEndReasonType matchEndReasonType)
	{
		MatchStatsSummary matchStatsSummary = CharacterControl.MatchStatsSummary;
		Owner.SetCustomProperties(new ExitGames.Client.Photon.Hashtable
		{
			{
				"HP",
				Mathf.FloorToInt(matchStatsSummary.EndHealth)
			},
			{
				"MA",
				Mathf.FloorToInt(matchStatsSummary.ManaUsedTotal)
			}
		});
		Wielder opponent = null;
		if (PlayerManager.Instance.CanGetOpponentWielder(ViewID, out opponent))
		{
			PlayerProperty.Set("DD", Mathf.FloorToInt(matchStatsSummary.DamageRecievedTotal), opponent.Owner);
		}
		if (!Owner.IsMasterClient || !PlayerManager.Instance.IsGameFull)
		{
			PunSingleton<SceneControl>.Instance.StatsUpdated(matchEndReasonType);
		}
	}

	public void OnPhotonInstantiate(PhotonMessageInfo info)
	{
		if (!m_hasInstantiated)
		{
			m_hasInstantiated = true;
			Owner = info.Sender;
			AnimationRelay = GetComponent<AnimationNetworkRelay>();
			AnimationRelay.Wielder = this;
			if (!info.Sender.IsLocal)
			{
				HealthData = StatsData.CreateInstance((float)base.photonView.InstantiationData[0]);
				ManaData = StatsData.CreateInstance((float)base.photonView.InstantiationData[1]);
				SpawnRemoteCharacter();
			}
		}
	}

	public void OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info)
	{
		if (stream.IsWriting)
		{
			WriteToStream(stream);
		}
		else
		{
			ReadFromStream(stream);
		}
	}

	public void SpawnLocalBotCharacter(Transform parent)
	{
		UnityEngine.Object @object = Resources.Load("CharacterControllers/BotCharacter");
		if (@object == null)
		{
			WandsLogger.LogError("Couldn't find Resource 'BotCharacter'");
			return;
		}
		BotCharacter = (UnityEngine.Object.Instantiate(@object, parent.position, Quaternion.identity, parent) as GameObject).GetComponent<BotCharacter>();
		AnimationRelay = GetComponent<AnimationNetworkRelay>();
		AnimationRelay.Wielder = this;
		PlayerManager.Instance.AddRemoteCharacter(BotCharacter);
		PlayerManager.Instance.AddWielder(this);
	}

	private void WriteToStream(PhotonStream stream)
	{
		stream.SendNext(m_currentTrackingTransforms[0].Position);
		stream.SendNext(m_currentTrackingTransforms[0].Rotation);
		stream.SendNext(m_currentTrackingTransforms[1].Position);
		stream.SendNext(m_currentTrackingTransforms[1].Rotation);
		stream.SendNext(m_syncHands);
		if (m_syncHands)
		{
			stream.SendNext(m_currentTrackingTransforms[2].Position);
			stream.SendNext(m_currentTrackingTransforms[2].Rotation);
			stream.SendNext(m_currentTrackingTransforms[3].Position);
			stream.SendNext(m_currentTrackingTransforms[3].Rotation);
		}
		stream.SendNext(Health);
		stream.SendNext(Mana);
		stream.SendNext(IsArmorActive);
		stream.SendNext(m_shouldResetRemoteIK);
		m_shouldResetRemoteIK = false;
	}

	private void ReadFromStream(PhotonStream stream)
	{
		m_targetTrackingTransforms[0].SetValues((Vector3)stream.ReceiveNext(), (Quaternion)stream.ReceiveNext());
		m_targetTrackingTransforms[1].SetValues((Vector3)stream.ReceiveNext(), (Quaternion)stream.ReceiveNext());
		bool flag = (bool)stream.ReceiveNext();
		if (flag)
		{
			m_targetTrackingTransforms[2].SetValues((Vector3)stream.ReceiveNext(), (Quaternion)stream.ReceiveNext());
			m_targetTrackingTransforms[3].SetValues((Vector3)stream.ReceiveNext(), (Quaternion)stream.ReceiveNext());
		}
		m_resetRemoteCharacter = flag != m_syncHands;
		m_syncHands = flag;
		Health = (float)stream.ReceiveNext();
		Mana = (float)stream.ReceiveNext();
		IsArmorActive = (bool)stream.ReceiveNext();
		m_shouldResetRemoteIK = (bool)stream.ReceiveNext();
	}

	private void TrySyncRemoteCharacter(bool resetRemoteCharacter)
	{
		if (resetRemoteCharacter)
		{
			RemoteCharacter.ResetRemoteCharacter();
		}
		RemoteCharacter.SetTrackingTransforms(GetInterpolatedVirtualTransform(0), GetInterpolatedVirtualTransform(1), GetInterpolatedVirtualTransform(2), GetInterpolatedVirtualTransform(3));
	}

	private void SyncRemoteWielderPosition()
	{
		Vector3 position = RemoteCharacter.Movement.HeadIk.position;
		position.y = RemoteCharacter.transform.position.y;
		base.transform.position = position;
	}

	private void TrySyncTwins()
	{
		foreach (Twin twin in m_twins)
		{
			if (twin != null)
			{
				twin.SetTrackingTransforms(GetInterpolatedVirtualTransform(0), GetInterpolatedVirtualTransform(1), GetInterpolatedVirtualTransform(2), GetInterpolatedVirtualTransform(3));
			}
		}
	}

	private void SpawnRemoteCharacter()
	{
		if (m_remoteCharacterPrefab == null)
		{
			WandsLogger.LogError("Couldn't find Resource 'RemoteCharacter'");
			return;
		}
		RemoteCharacter = UnityEngine.Object.Instantiate(m_remoteCharacterPrefab, base.transform.position, Quaternion.Euler(Vector3.forward));
		RemoteCharacter.Initialize(this, HealthData);
		PlayerManager.Instance.AddRemoteCharacter(RemoteCharacter);
		PlayerManager.Instance.AddWielder(this);
	}

	public void SetTwinsMaterial(CharacterMaterialType characterMaterialType, Color color, bool blockFlash)
	{
		foreach (Twin twin in m_twins)
		{
			if (twin != null)
			{
				twin.CharacterRenderer.SetMaterial(characterMaterialType, color, blockFlash);
			}
		}
	}

	public void SetCameraEffectActive(EffectType type, bool active)
	{
		if (IsPlayer)
		{
			PlayerControl.SetCameraEffectActive(type, active);
		}
	}

	public void TeleportRandomly(Tile[] tiles)
	{
		CharacterControl.TeleportHandler.TeleportRandomly(tiles, base.photonView);
	}

	public bool TakeDamage(DamageType damageType, float damage, Vector2 hitDirection)
	{
		return CharacterControl.TakeDamage(damageType, damage, hitDirection);
	}

	public void AddHealthPickup(float pickupAmount, WandHand pickupHand)
	{
		if (IsPlayer)
		{
			PlayerControl.AddHealthPickup(pickupAmount, pickupHand);
		}
		else
		{
			CharacterControl.ChangeHealth(pickupAmount);
		}
		if (!CharacterControl.IsCurseActive)
		{
			PlayerProperty.Increment("PU", 1, Owner);
		}
	}

	public void ChangeHealth(float changeValue)
	{
		CharacterControl.ChangeHealth(changeValue);
	}

	public void ChangeMana(float cost, bool blockManaReg = false)
	{
		CharacterControl.ChangeMana(cost, blockManaReg);
	}

	public void ChangeManaUsed(int energy)
	{
		CharacterControl.ChangeManaUsed(energy);
	}

	public void AbortContinuousHit()
	{
		CharacterControl.AbortContinuousHit();
	}

	public void TryCurseWielder(float timeFrame)
	{
		bool? flag = PlayerControl?.IsAlwaysCursed;
		if (flag.HasValue && flag.Value)
		{
			return;
		}
		ObjectPoolHandler.GrabFromPool(PoolObjectType.CurseOfTheUndeadLingering, null)?.EnableObject(CharacterControl.GetCurrentTile().transform.position, ViewID, timeFrame);
		foreach (Twin twin in m_twins)
		{
			CurseTwin(twin, timeFrame);
		}
	}

	private void TryCurseTwin(Twin twin)
	{
		if (IsLocal && CharacterControl.IsCurseActive)
		{
			CurseTwin(twin, CharacterControl.CurseTimeLeft);
		}
	}

	private void CurseTwin(Twin twin, float timeFrame)
	{
		ObjectPoolHandler.GrabFromPool(PoolObjectType.CurseOfTheUndeadLingering, null)?.EnableObject(twin.ConnectedTile.transform.position, twin.photonView.ViewID, timeFrame);
	}

	public void EnableCurse(float waitTime, CurseLingeringEffect curseLinderingEffect)
	{
		if (IsLocal)
		{
			CharacterControl.EnableCurse(waitTime, curseLinderingEffect);
		}
	}

	public void DisableCurse()
	{
		if (IsLocal)
		{
			CharacterControl.DisableCurse();
		}
	}

	public void DisableChillingClutch()
	{
		base.photonView.RPC("PunSetChillingClutchEffectActive", RpcTarget.Others, false);
		SetChillingClutchActiveOnTwins(active: false);
		m_isChillingClutchActive = false;
	}

	public void ApplyChillingClutch()
	{
		base.photonView.RPC("PunSetChillingClutchEffectActive", RpcTarget.Others, true);
		SetChillingClutchActiveOnTwins(active: true);
		m_isChillingClutchActive = true;
	}

	[PunRPC]
	private void PunSetChillingClutchEffectActive(bool active)
	{
		RemoteCharacter.EffectHandler.SetEffectActive(EffectType.ChillingClutchLingeringEffect, active, RemoteCharacter.Collider.transform);
		SetChillingClutchActiveOnTwins(active);
		m_isChillingClutchActive = active;
	}

	private void TrySetChillingClutchActiveOnTwin(Twin twin)
	{
		if (m_isChillingClutchActive)
		{
			twin.SetChillingClutchEffectActive(active: true);
		}
	}

	private void SetChillingClutchActiveOnTwins(bool active)
	{
		foreach (Twin twin in m_twins)
		{
			twin.SetChillingClutchEffectActive(active);
		}
	}

	public void SetCurrentTile(int tileId)
	{
		if (NetworkUtils.ConnectedToGame && !IsBot)
		{
			base.photonView.RPC("PunSetRemoteCharacterTile", RpcTarget.OthersBuffered, tileId);
		}
		else
		{
			PunSetRemoteCharacterTile(tileId);
		}
	}

	public void UpdateBotPosition()
	{
		base.transform.position = CharacterControl.transform.position;
	}

	public void AddTwin(Twin twin)
	{
		m_twins.Add(twin);
		TrySetChillingClutchActiveOnTwin(twin);
		TryCurseTwin(twin);
	}

	public void RemoveTwin(Twin twin)
	{
		m_twins.Remove(twin);
	}

	public void UpdateTrackingTransforms(bool isTrackingHands, VirtualTransform originTransform, VirtualTransform headTransform, VirtualTransform leftHandTransform, VirtualTransform rightHandTransform)
	{
		m_syncHands = isTrackingHands;
		Vector3 vector = originTransform.Position + originTransform.Rotation * headTransform.Position;
		base.transform.position = CharacterControl.transform.position + new Vector3(vector.x, 0f, vector.z);
		m_currentTrackingTransforms[0].SetValues(originTransform);
		m_currentTrackingTransforms[1].SetValues(headTransform);
		if (isTrackingHands)
		{
			m_currentTrackingTransforms[2].SetValues(leftHandTransform);
			m_currentTrackingTransforms[3].SetValues(rightHandTransform);
		}
	}

	private VirtualTransform GetInterpolatedVirtualTransform(int trackingPoint)
	{
		VirtualTransform virtualTransform = m_currentTrackingTransforms[trackingPoint];
		VirtualTransform virtualTransform2 = m_targetTrackingTransforms[trackingPoint];
		float t = Time.deltaTime * 10f;
		virtualTransform.Position = Vector3.Lerp(virtualTransform.Position, virtualTransform2.Position, t);
		virtualTransform.Rotation = Quaternion.Slerp(virtualTransform.Rotation, virtualTransform2.Rotation, t);
		return virtualTransform;
	}

	[PunRPC]
	protected void PunSetRemoteCharacterTile(int tileId)
	{
		PhotonView photonView = PhotonView.Find(tileId);
		if (photonView == null)
		{
			WandsLogger.LogError($"Wielder {ViewID} | Tile view not found: {tileId}");
			return;
		}
		Tile component = photonView.GetComponent<Tile>();
		if (component == null)
		{
			WandsLogger.LogError($"Wielder {ViewID} | Trying to set a null tile!");
		}
		else if (BotCharacter != null)
		{
			BotCharacter.SetConnectedTile(component);
		}
		else if (RemoteCharacter != null)
		{
			RemoteCharacter.SetConnectedTile(component);
		}
	}

	private void ResetIKUpdate()
	{
		for (int i = 0; i < m_currentTrackingTransforms.Length; i++)
		{
			m_currentTrackingTransforms[i].SetValues(m_targetTrackingTransforms[i]);
		}
		if (RemoteCharacter != null)
		{
			TrySyncRemoteCharacter(m_resetRemoteCharacter);
			SyncRemoteWielderPosition();
		}
		TrySyncTwins();
		RecenterResetIK();
	}

	public void SetFirstBlood()
	{
		base.photonView.RPC("PunSetFirstBlood", RpcTarget.MasterClient, ViewID, PunSingleton<TimeManager>.Instance.CurrentMatchTime);
	}

	[PunRPC]
	private void PunSetFirstBlood(int viewID, float timeStamp)
	{
		if (!(m_firstBloodTimeStamp > 0f) || !(timeStamp > m_firstBloodTimeStamp))
		{
			m_firstBloodTimeStamp = timeStamp;
			RoomProperty.SetRoomProperty("G0", viewID);
		}
	}

	public void SetPlayerTag(string newTag)
	{
		if (CharacterControl != null)
		{
			CharacterControl.tag = newTag;
			Collider[] componentsInChildren = CharacterControl.GetComponentsInChildren<Collider>();
			foreach (Collider collider in componentsInChildren)
			{
				collider.tag = newTag;
			}
		}
		else if (RemoteCharacter != null)
		{
			RemoteCharacter.tag = newTag;
			Collider[] componentsInChildren2 = RemoteCharacter.GetComponentsInChildren<Collider>();
			foreach (Collider collider2 in componentsInChildren2)
			{
				collider2.tag = newTag;
			}
		}
	}

	private void ResetWielder()
	{
		if (IsLocal)
		{
			PlayerProperty.Set("PU", 0, Owner);
			CharacterControl.DisableActiveEffects();
			CharacterControl.ResetPlayerStats();
			if (GameControl.Instance.IsCurrentLevel(Level.Basement) && GameControl.Instance.Player.TutorialState > TutorialState.LeftBasement)
			{
				CharacterControl.ChangeHealth(HealthData.Max * -0.5f);
			}
		}
	}

	private void OnRecenter(Events.OnCameraRecenteredEvent eventData)
	{
		RecenterResetIK();
		m_shouldResetRemoteIK = true;
	}

	private void RecenterResetIK()
	{
		RemoteCharacter?.Movement.ResetIK(resetBody: true);
		for (int i = 0; i < m_twins.Count; i++)
		{
			m_twins[i]?.Movement.ResetIK(resetBody: true);
		}
	}

	[Conditional("UNITY_EDITOR")]
	public void DebugSpawnRemoteCharacter()
	{
	}

	private void InitializeVoip()
	{
		if (MonoSingleton<NetworkManager>.Instance.CurrentMatchType.ContainsFlag(MatchType.SinglePlayer))
		{
			return;
		}
		m_isAudioPermissionBlocked = !UniAndroidPermission.IsPermitted(AndroidPermission.RECORD_AUDIO);
		if (m_isAudioPermissionBlocked)
		{
			WandsLogger.LogError("Android Permissions don't allow VoIP", LogColor.VoIP);
		}
		else if (base.photonView.IsMine)
		{
			if (!WandsVoip.IsPlayerEnabled)
			{
				ToggleVoipTransmission(value: false);
			}
		}
		else if (!WandsVoip.IsOpponentEnabled)
		{
			ToggleVoipSpeaker(value: false);
		}
	}

	public void ToggleVoipTransmission(bool value)
	{
		if (!m_isAudioPermissionBlocked)
		{
			Recorder primaryRecorder = PhotonVoiceNetwork.Instance.PrimaryRecorder;
			primaryRecorder.IsRecording = value;
			if (value && primaryRecorder.RequiresRestart)
			{
				primaryRecorder.RestartRecording();
			}
		}
	}

	public void ToggleVoipSpeaker(bool value)
	{
		if (!m_isAudioPermissionBlocked)
		{
			m_voipAudioSource.enabled = value;
		}
	}
}
namespace Assets.Scripts
{
	[RequireComponent(typeof(PhotonView))]
	public class PauseManager : PunSingleton<PauseManager>
	{
		private float m_initialPauseTime;

		private float m_opponentPauseTimeStart = -1f;

		private float m_pauseTimeRealSeconds;

		private int m_pausesLeft = 3;

		private bool m_isLobbyPaused;

		private bool m_isMatchPaused;

		private IList<int> m_pauseStack = new List<int>(2);

		private EventToken m_matchEndedEventToken;

		public bool IsGamePaused
		{
			[CompilerGenerated]
			get
			{
				return m_isLobbyPaused || m_isMatchPaused;
			}
		}

		private void OnEnable()
		{
			m_matchEndedEventToken = EventHub.Subscribe<Events.MatchEndedEvent>(OnMatchEnded);
		}

		protected override void OnDisable()
		{
			base.OnDisable();
			EventHub.Unsubscribe<Events.MatchEndedEvent>(m_matchEndedEventToken);
		}

		private void Update()
		{
			if (m_opponentPauseTimeStart == -1f || PlayerManager.Instance == null || MonoSingleton<NetworkManager>.Instance.CurrentMatchType == MatchType.Exploration)
			{
				return;
			}
			if (PunSingleton<TimeManager>.Instance.CurrentRoomTime - m_opponentPauseTimeStart < 15f)
			{
				if (PlayerManager.Instance.PlayerControl != null)
				{
					MonoSingleton<ArenaUI>.Instance.UpdateNotificationMessage("TIMER", Mathf.CeilToInt(15f - (PunSingleton<TimeManager>.Instance.CurrentRoomTime - m_opponentPauseTimeStart)).ToString(), keepActive: true);
				}
			}
			else
			{
				DeclareWinner();
			}
		}

		private void OnMatchEnded(Events.MatchEndedEvent eventData)
		{
			OnMatchEnd();
		}

		private void DeclareWinner()
		{
			if (!(PunSingleton<SceneControl>.Instance == null))
			{
				m_opponentPauseTimeStart = -1f;
				MonoSingleton<NetworkManager>.Instance.AssignMasterClientToLocal();
				PlayerManager.Instance.KickOpponentWielder();
			}
		}

		private void OnMatchEnd()
		{
			m_opponentPauseTimeStart = -1f;
			m_isMatchPaused = false;
			m_pauseStack.Clear();
		}

		public void ForceUnPause()
		{
			m_opponentPauseTimeStart = -1f;
			m_isLobbyPaused = false;
			m_isMatchPaused = false;
			m_pauseStack.Clear();
		}

		public void PauseGame(bool pause, int id)
		{
			if (GameControl.Instance.IsCurrentLevel(Level.UnpausableLevel))
			{
				m_isMatchPaused = pause;
				return;
			}
			if (!NetworkUtils.ConnectedToGame)
			{
				bool? flag = PunSingleton<SceneControl>.Instance?.GameOver;
				if (!flag.HasValue || !flag.Value)
				{
					bool? flag2 = MonoSingleton<ArenaUI>.Instance?.State.ContainsFlag(EndState.Disconnected);
					if (!flag2.HasValue || !flag2.Value)
					{
						if (GameControl.Instance.IsCurrentLevel(Level.Lobby))
						{
							PunPauseLobby(pause: false, id);
						}
						else if (PunSingleton<SceneControl>.Instance.CurrentMatchType == MatchType.Exploration)
						{
							SetWaitActive(active: false, killCountdownSfx: true);
							PunSingleton<SceneControl>.Instance.EndMatchPause(EndState.ConnectionLostClient);
						}
						else
						{
							SetWaitActive(active: false, killCountdownSfx: true);
							EndState endState = ((m_pausesLeft >= 0) ? EndState.ConnectionLostClient : EndState.ForceLost);
							PunSingleton<SceneControl>.Instance.EndMatchPause(endState);
						}
						return;
					}
				}
				MonoSingleton<ArenaUI>.Instance.UpdateEndMenuPosition();
				return;
			}
			if (GameControl.Instance.IsCurrentLevel(Level.Lobby))
			{
				base.photonView.RPC("PunPauseLobby", RpcTarget.AllBuffered, pause, id);
			}
			else if (pause)
			{
				if (PhotonNetwork.IsMasterClient && PlayerManager.Instance.GetOpponentWielder() != null && !MonoSingleton<NetworkManager>.Instance.CurrentMatchType.ContainsFlag(MatchType.Bot))
				{
					PhotonNetwork.SetMasterClient(PlayerManager.Instance.GetOpponentWielder().Owner);
				}
				m_pauseTimeRealSeconds = Time.realtimeSinceStartup;
				if (MonoSingleton<NetworkManager>.Instance.CurrentMatchType != MatchType.Exploration)
				{
					m_pausesLeft--;
				}
				if (m_pausesLeft < 0)
				{
					m_pauseStack.Add(id);
					SetWaitActive(active: false, killCountdownSfx: true);
					MonoSingleton<NetworkManager>.Instance.LeaveRoom();
					PhotonNetwork.SendAllOutgoingCommands();
					m_isMatchPaused = true;
					Events.MatchPausedEvent matchPausedEvent = new Events.MatchPausedEvent();
					matchPausedEvent.IsPaused = true;
					EventHub.Publish(matchPausedEvent);
					return;
				}
				base.photonView.RPC("PunPauseMatch", RpcTarget.AllBuffered, id, PunSingleton<TimeManager>.Instance.CurrentRoomTime);
			}
			else
			{
				if (m_pauseStack.IsNullOrEmpty())
				{
					return;
				}
				if (GetEndMatchCriteriaMet() && m_pauseStack.Contains(PhotonNetwork.LocalPlayer.ActorNumber))
				{
					SetWaitActive(active: false, killCountdownSfx: true);
					EndState endState2 = ((m_pausesLeft >= 0) ? EndState.ConnectionLostClient : EndState.ForceLost);
					PunSingleton<SceneControl>.Instance.EndMatchPause(endState2);
				}
				else
				{
					base.photonView.RPC("PunUnPauseMatch", RpcTarget.AllBuffered, id);
				}
			}
			PhotonNetwork.SendAllOutgoingCommands();
			if (UnityEngine.Application.isEditor)
			{
				PhotonNetwork.IsMessageQueueRunning = !pause;
			}
		}

		[PunRPC]
		private void PunPauseLobby(bool pause, int id)
		{
			if (pause)
			{
				if (m_pauseStack.Contains(id))
				{
					return;
				}
				m_pauseStack.Add(id);
				Events.LobbyPausedEvent lobbyPausedEvent = new Events.LobbyPausedEvent();
				lobbyPausedEvent.IsPaused = true;
				EventHub.Publish(lobbyPausedEvent);
			}
			else
			{
				if (m_pauseStack.Contains(id))
				{
					m_pauseStack.Remove(id);
				}
				if (m_pauseStack.Count > 0)
				{
					return;
				}
				Events.LobbyPausedEvent lobbyPausedEvent = new Events.LobbyPausedEvent();
				lobbyPausedEvent.IsPaused = false;
				EventHub.Publish(lobbyPausedEvent);
			}
			m_isLobbyPaused = pause;
		}

		[PunRPC]
		private void PunPauseMatch(int id, float pauseTime)
		{
			if (!m_pauseStack.Contains(id))
			{
				m_pauseStack.Add(id);
				if (PhotonNetwork.LocalPlayer.ActorNumber != id)
				{
					m_opponentPauseTimeStart = pauseTime;
					SetWaitActive(active: true);
				}
				if (m_initialPauseTime == 0f)
				{
					m_initialPauseTime = pauseTime;
				}
				WandsLogger.Log($"Pause match by {id}, current pause time: {m_initialPauseTime}, pause time: {pauseTime}, current match time {PunSingleton<TimeManager>.Instance.CurrentMatchTime}", LogType.Warning);
				m_isMatchPaused = true;
				Events.MatchPausedEvent matchPausedEvent = new Events.MatchPausedEvent();
				matchPausedEvent.IsPaused = true;
				EventHub.Publish(matchPausedEvent);
			}
		}

		[PunRPC]
		private void PunUnPauseMatch(int id)
		{
			WandsLogger.Log($"Unpause match by {id}, current time: {PunSingleton<TimeManager>.Instance.CurrentRoomTime}", LogType.Warning);
			if (m_pauseStack.Contains(id))
			{
				m_pauseStack.Remove(id);
			}
			if (PhotonNetwork.LocalPlayer.ActorNumber != id)
			{
				m_opponentPauseTimeStart = -1f;
			}
			if (m_pauseStack.Count <= 0)
			{
				StopAllCoroutines();
				if (!PunSingleton<SceneControl>.Instance.MatchStarted || PunSingleton<SceneControl>.Instance.GameOver)
				{
					ResumeMatch();
				}
				else if (!(PlayerManager.Instance.LocalWielder == null) && !(MonoSingleton<ArenaUI>.Instance == null))
				{
					MonoSingleton<ArenaUI>.Instance.DisableNotification();
					StopAllCoroutines();
					MonoSingleton<ArenaUI>.Instance.ShowNotification("HUD/Notification/CountdownResume", "TIMER", $"{3f}", 3f);
					MonoSingleton<ArenaUI>.Instance.SetPauseInfoActive(PhotonNetwork.LocalPlayer.ActorNumber == id, m_pausesLeft);
					PunSingleton<SoundManager>.Instance.PlayMusic("music_match_resumes", 1f);
					StartCoroutine(ResumeCountdown());
				}
			}
		}

		private IEnumerator ResumeCountdown()
		{
			WaitForSeconds wait = new WaitForSeconds(1f);
			for (int i = 3; i > 0; i--)
			{
				if (PlayerManager.Instance.LocalWielder != null)
				{
					MonoSingleton<ArenaUI>.Instance.UpdateNotificationMessage("TIMER", $"{i}", keepActive: true);
				}
				yield return wait;
			}
			ResumeMatch();
			MonoSingleton<ArenaUI>.Instance.DisableNotification();
		}

		private void ResumeMatch()
		{
			m_isMatchPaused = false;
			m_pauseStack.Clear();
			SetWaitActive(active: false);
			UpdateMatchTime();
			Events.MatchPausedEvent matchPausedEvent = new Events.MatchPausedEvent();
			matchPausedEvent.IsPaused = false;
			matchPausedEvent.PausesLeft = m_pausesLeft;
			EventHub.Publish(matchPausedEvent);
		}

		private void UpdateMatchTime()
		{
			m_initialPauseTime = PunSingleton<TimeManager>.Instance.CurrentRoomTime - m_initialPauseTime;
			PunSingleton<TimeManager>.Instance.UpdatePauseTime(m_initialPauseTime);
			m_initialPauseTime = 0f;
		}

		private bool GetEndMatchCriteriaMet()
		{
			if (PunSingleton<SceneControl>.Instance == null || MonoSingleton<NetworkManager>.Instance.CurrentMatchType == MatchType.Exploration)
			{
				return false;
			}
			if (m_pausesLeft < 0)
			{
				GameControl.PrintDebug("Pauses left: " + m_pausesLeft, persistant: true);
				return true;
			}
			GameControl.PrintDebug(m_pauseTimeRealSeconds + ", all good, NO? " + (Time.realtimeSinceStartup - m_pauseTimeRealSeconds), persistant: true);
			return m_pauseTimeRealSeconds > 0f && Time.realtimeSinceStartup - m_pauseTimeRealSeconds >= 15f;
		}

		private void SetWaitActive(bool active, bool killCountdownSfx = false)
		{
			if (PlayerManager.Instance == null)
			{
				return;
			}
			if (active)
			{
				StopAllCoroutines();
				StartCoroutine(SetCountDownPosition());
				return;
			}
			StopAllCoroutines();
			MonoSingleton<ArenaUI>.Instance?.DisableNotification();
			if (killCountdownSfx)
			{
				PunSingleton<SoundManager>.Instance.StopLocalSound("music_match_resumes");
			}
		}

		private IEnumerator SetCountDownPosition()
		{
			while (PlayerManager.Instance.LocalWielder.CharacterControl.IsTeleporting)
			{
				yield return null;
			}
			MonoSingleton<ArenaUI>.Instance.ShowNotification("HUD/Notification/Paused", "TIMER", 15f.ToString(), 15f);
		}
	}
}
namespace Cortopia.Scripts.Pawns
{
	public abstract class Pawn : MonoBehaviour, IPauseObject, IDamageable
	{
		private const float MinManaRegenerationSpeed = 1f;

		private const float DefaultChillingClutchPercentage = 1f;

		[SerializeField]
		private CapsuleCollider m_capsuleCollider;

		protected bool m_regenerateMana;

		protected float m_damageTakenMultiplier = 1f;

		protected EffectUtils m_effectHandler;

		protected Level m_currentLevel;

		protected StatsData m_healthData;

		protected RegeneratingStatsData m_manaData;

		protected CurseLingeringEffect m_curseEffect;

		private bool m_isChillingClutchActive;

		private EventToken m_matchPausedEventToken;

		private EventToken m_suddenDeathStartedEventToken;

		private EventToken m_sceneLoadInitiatedEventToken;

		private EventToken m_matchEndedEventToken;

		public float Health
		{
			get
			{
				return m_healthData.Current;
			}
			protected set
			{
				m_healthData.SetCurrent(value);
			}
		}

		public float Mana
		{
			get
			{
				return m_manaData.Current;
			}
			protected set
			{
				m_manaData.SetCurrent(value);
			}
		}

		public bool IsCurseActive
		{
			[CompilerGenerated]
			get
			{
				return m_curseEffect != null;
			}
		}

		public virtual float CurseTimeLeft
		{
			[CompilerGenerated]
			get
			{
				return (!(m_curseEffect != null)) ? 0f : m_curseEffect.TimeLeft;
			}
		}

		public bool IsPaused { get; set; }

		public bool ManaIsInfinite { get; private set; }

		public bool IsTeleportLocked { get; private set; }

		public Transform ColliderTransform
		{
			[CompilerGenerated]
			get
			{
				return m_capsuleCollider.transform;
			}
		}

		public CapsuleCollider Collider
		{
			[CompilerGenerated]
			get
			{
				return m_capsuleCollider;
			}
		}

		public EffectUtils EffectHandler
		{
			[CompilerGenerated]
			get
			{
				return m_effectHandler;
			}
		}

		protected virtual void OnEnable()
		{
			m_matchPausedEventToken = EventHub.Subscribe<Events.MatchPausedEvent>(OnMatchPaused);
			m_matchEndedEventToken = EventHub.Subscribe<Events.MatchEndedEvent>(OnMatchEnded);
			m_suddenDeathStartedEventToken = EventHub.Subscribe<Events.SuddenDeathStartedEvent>(OnSuddenDeathStarted);
			m_sceneLoadInitiatedEventToken = EventHub.Subscribe<Events.SceneLoadInitiatedEvent>(OnSceneLoadInitiated);
		}

		protected virtual void OnDisable()
		{
			CancelInvoke();
			StopAllCoroutines();
			EventHub.Unsubscribe<Events.MatchPausedEvent>(m_matchPausedEventToken);
			EventHub.Unsubscribe<Events.MatchEndedEvent>(m_matchEndedEventToken);
			EventHub.Unsubscribe<Events.SuddenDeathStartedEvent>(m_suddenDeathStartedEventToken);
			EventHub.Unsubscribe<Events.SceneLoadInitiatedEvent>(m_sceneLoadInitiatedEventToken);
		}

		private void OnDestroy()
		{
			CancelInvoke();
		}

		protected virtual void Awake()
		{
			UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
			SetColliderActive(active: false);
			SetEffectHandler();
		}

		public abstract void CreateHP();

		public abstract void CreateMana();

		protected abstract bool IsTeleportActive();

		private void SetEffectHandler()
		{
			m_effectHandler = new EffectUtils();
		}

		protected virtual void OnSceneLoadInitiated(Events.SceneLoadInitiatedEvent eventData)
		{
			DisableActiveEffects();
		}

		protected virtual void OnMatchEnded(Events.MatchEndedEvent eventData)
		{
			DisableActiveEffects();
		}

		private void OnSuddenDeathStarted(Events.SuddenDeathStartedEvent eventData)
		{
			OnSuddenDeath();
		}

		public void CreateRemoteHealthData()
		{
			m_healthData = ScriptableObject.CreateInstance<StatsData>();
		}

		public void CreateRemoteManaData()
		{
			m_manaData = ScriptableObject.CreateInstance<RegeneratingStatsData>();
		}

		public void SetColliderActive(bool active)
		{
			m_capsuleCollider.enabled = active;
		}

		public void ChangeColliderLayer(int layer)
		{
			m_capsuleCollider.gameObject.layer = layer;
		}

		public StatsData GetHealthData()
		{
			return m_healthData;
		}

		public StatsData GetManaData()
		{
			return m_manaData;
		}

		public virtual bool TakeDamage(DamageType damageType, float damage, Vector2 hitDirection)
		{
			if (TryHealPlayer(damage))
			{
				return true;
			}
			if (IsImmuneToDamageType(damageType))
			{
				return false;
			}
			damage *= m_damageTakenMultiplier;
			UpdateHealth(0f - damage);
			return true;
		}

		protected bool TryHealPlayer(float damage)
		{
			if (damage <= 0f)
			{
				ChangeHealth(0f - damage);
				return true;
			}
			return false;
		}

		protected bool IsImmuneToDamageType(DamageType damageType)
		{
			if (CanTakeDamage(damageType, out var _))
			{
				return false;
			}
			return true;
		}

		private bool CanTakeDamage(DamageType type, out string message)
		{
			message = string.Empty;
			if (IsPaused)
			{
				message = "Match is paused!";
			}
			else if (IsTeleportActive())
			{
				message = "Player is teleporting!";
			}
			else if (PunSingleton<SceneControl>.Instance != null)
			{
				if (PunSingleton<SceneControl>.Instance.GameOver)
				{
					message = "Game over!";
				}
				else if (PunSingleton<SceneControl>.Instance.CountdownHandler.IsCountdownActive)
				{
					message = "Counting down!";
				}
			}
			return string.IsNullOrEmpty(message);
		}

		public virtual void ChangeMana(float changeValue, bool blockManaReg = false)
		{
			if (!GameControl.Instance.IsExpectedConnectionType(ConnectionType.Trailer))
			{
				m_regenerateMana = !blockManaReg;
				UpdateMana(changeValue);
			}
		}

		protected virtual void UpdateMana(float changeValue)
		{
			float num = Mana + changeValue;
			if (num > m_manaData.Max)
			{
				num = m_manaData.Max;
			}
			else if (num < 0f)
			{
				num = 0f;
			}
			Mana = num;
		}

		public virtual void ChangeHealth(float changeValue)
		{
			if (IsCurseActive && changeValue > 0f)
			{
				TakeDamage(DamageType.OnceContinuous, changeValue, Vector2.up);
			}
			else
			{
				UpdateHealth(changeValue);
			}
		}

		protected virtual void UpdateHealth(float changeValue)
		{
			Health = Mathf.Clamp(Health + changeValue, 0f, m_healthData.Max);
		}

		public void SetTeleportActive(bool enable)
		{
			IsTeleportLocked = !enable;
		}

		public void SetManaMultiplier(float multiplier)
		{
			m_manaData.SetRegenerationMultiplier(multiplier);
		}

		public void SetDamageReceivedMultiplier(float multiplier)
		{
			m_damageTakenMultiplier = multiplier;
		}

		protected void TryDisableActiveCurse()
		{
			if (m_curseEffect != null)
			{
				m_curseEffect.DisableObject();
			}
		}

		private IEnumerator DisableChillingClutchAfterTime(float waitTime)
		{
			yield return new CustomWaitForSeconds(waitTime);
			SetChillingClutchEffectActive(isActive: false);
		}

		public abstract void EnableCurse(float curseTime, CurseLingeringEffect curse);

		public abstract void DisableCurse();

		public void ApplyChillingClutch(float chillingClutchPercent, float time)
		{
			m_manaData.SetSpellEffectMultiplier(chillingClutchPercent);
			SetChillingClutchEffectActive(isActive: true);
			StopCoroutine("DisableChillingClutchAfterTime");
			StartCoroutine("DisableChillingClutchAfterTime", time);
		}

		private void OnSuddenDeath()
		{
			m_manaData.SetRegenerationBase(m_manaData.BaseRegenerationSpeed * 1.5f);
		}

		public virtual void SetChillingClutchEffectActive(bool isActive)
		{
			if (!isActive)
			{
				m_manaData.ResetSpellEffectMultiplier();
			}
			m_isChillingClutchActive = isActive;
			Events.ChillingClutchActivationEvent chillingClutchActivationEvent = new Events.ChillingClutchActivationEvent();
			chillingClutchActivationEvent.IsActive = isActive;
			EventHub.Publish(chillingClutchActivationEvent);
		}

		public virtual void DisableActiveEffects()
		{
			if (IsCurseActive)
			{
				DisableCurse();
			}
			if (m_isChillingClutchActive)
			{
				StopCoroutine("DisableChillingClutchAfterTime");
				SetChillingClutchEffectActive(isActive: false);
			}
		}

		public virtual void ResetHealth()
		{
			m_healthData.Reset();
		}

		public virtual void ResetMana()
		{
			m_manaData.Reset();
		}

		public virtual void Pause(bool pause)
		{
			IsPaused = pause;
		}

		protected void OnMatchPaused(Events.MatchPausedEvent eventData)
		{
			Pause(eventData.IsPaused);
		}

		protected virtual void RegenerateMana()
		{
			if (m_regenerateMana && m_manaData.Regenerate(m_manaData.RegenerationSpeed * Time.deltaTime) == m_manaData.Max)
			{
				m_regenerateMana = false;
			}
		}

		public Transform GetHitTransform()
		{
			return base.transform;
		}
	}
	public class StatsData : ScriptableObject
	{
		protected float m_startValue;

		public float Max { get; protected set; }

		public float Current { get; protected set; }

		public float Fill
		{
			[CompilerGenerated]
			get
			{
				return Current / Max;
			}
		}

		public string ReadableCurrent
		{
			[CompilerGenerated]
			get
			{
				return ((int)Current).ToString();
			}
		}

		public static StatsData CreateInstance(float maxValue)
		{
			StatsData statsData = ScriptableObject.CreateInstance<StatsData>();
			statsData.m_startValue = maxValue;
			statsData.Max = maxValue;
			statsData.Current = maxValue;
			return statsData;
		}

		public void SetMax(float value)
		{
			Max = value;
			Current = Mathf.Clamp(Current, 0f, Max);
		}

		public void SetCurrent(float value)
		{
			Current = value;
		}

		public virtual void Reset()
		{
			Max = m_startValue;
			Current = m_startValue;
		}
	}
	public class RegeneratingStatsData : StatsData
	{
		private const float DefaultMultiplierValue = 1f;

		private float m_regenerationMultiplier = 1f;

		private float m_spellEffectMultiplier = 1f;

		public float BaseRegenerationSpeed { get; private set; }

		public float RegenerationSpeed { get; private set; }

		public event Action<float> OnRegenerationSpeedUpdated;

		public static RegeneratingStatsData CreateInstance(float maxValue, float baseRegenerationSpeed)
		{
			RegeneratingStatsData regeneratingStatsData = ScriptableObject.CreateInstance<RegeneratingStatsData>();
			regeneratingStatsData.m_startValue = maxValue;
			regeneratingStatsData.Max = maxValue;
			regeneratingStatsData.Current = maxValue;
			regeneratingStatsData.BaseRegenerationSpeed = baseRegenerationSpeed;
			regeneratingStatsData.RegenerationSpeed = baseRegenerationSpeed;
			return regeneratingStatsData;
		}

		public override void Reset()
		{
			base.Current = base.Max;
			ResetRegenerationMultiplier();
		}

		public float Regenerate(float changeValue)
		{
			base.Current = Mathf.Clamp(base.Current + changeValue, 0f, base.Max);
			return base.Current;
		}

		public void SetRegenerationBase(float value)
		{
			BaseRegenerationSpeed = value;
			UpdateRegenerationSpeed();
		}

		public void SetRegenerationMultiplier(float value)
		{
			m_regenerationMultiplier = value;
			UpdateRegenerationSpeed();
		}

		public void ResetRegenerationMultiplier()
		{
			m_regenerationMultiplier = 1f;
			UpdateRegenerationSpeed();
		}

		public void SetSpellEffectMultiplier(float value)
		{
			m_spellEffectMultiplier = value;
			UpdateRegenerationSpeed();
		}

		public void ResetSpellEffectMultiplier()
		{
			m_spellEffectMultiplier = 1f;
			UpdateRegenerationSpeed();
		}

		private void UpdateRegenerationSpeed()
		{
			RegenerationSpeed = BaseRegenerationSpeed * m_regenerationMultiplier * m_spellEffectMultiplier;
			if (this.OnRegenerationSpeedUpdated != null)
			{
				this.OnRegenerationSpeedUpdated(RegenerationSpeed);
			}
		}
	}
}
namespace Assets.Scripts.Pickup
{
	[RequireComponent(typeof(PhotonView), typeof(AudioSource), typeof(Collider))]
	public class PickupBase : InteractableGameObject, IPauseObject, IWandInteractable
	{
		private static readonly Vector3 sm_wandDestinationOffset = Vector3.up * -0.25f;

		[Header("Pickup")]
		[SerializeField]
		private PickupType m_pickupType;

		[SerializeField]
		private Transform m_pickupObject;

		[SerializeField]
		private AudioSource m_breakAudio;

		[SerializeField]
		private float m_initialSpawnTime;

		[SerializeField]
		private float m_respawnTime = 45f;

		[SerializeField]
		private float m_gazeTimeOneHand = 2f;

		[SerializeField]
		private float m_gazeTimeDualWield = 5f;

		[SerializeField]
		private int m_pickupAmount = 20;

		[SerializeField]
		private HapticsData m_hapticsData;

		private Tile m_connectedTile;

		private float m_gazeTime;

		private float m_currentGazeTime;

		private bool m_isGazing;

		private bool m_moveTowardsPlayer;

		private bool m_suddenDeath;

		private bool m_isDualWielding;

		private PhotonView m_photonView;

		private AudioSource m_audioSource;

		private Wielder m_occupant;

		private Vector3 m_destination;

		private CustomWaitForSeconds m_respawnWait;

		private CustomWaitForSeconds m_initialSpawnWait;

		private GameObject m_cursedEffect;

		private WandHand m_lastWandHand;

		private ISet<WandHand> m_wandHands = new HashSet<WandHand>();

		private EventToken m_wandUiToggledEventToken;

		private EventToken m_matchPausedEventToken;

		public bool Pickable
		{
			get
			{
				if (m_connectedTile == null || m_occupant == null)
				{
					return false;
				}
				if (m_occupant.IsPlayer)
				{
					bool? flag = (m_occupant.Wand.GetWandControl() as WandControlOneHand)?.UI.IsActive;
					if (flag.HasValue && flag.Value)
					{
						return false;
					}
				}
				return m_connectedTile.OccupantWielder != null && m_connectedTile.OccupantWielder == m_occupant;
			}
		}

		public Transform PickUpObject
		{
			[CompilerGenerated]
			get
			{
				return m_pickupObject;
			}
		}

		public PickupType PickUpType
		{
			[CompilerGenerated]
			get
			{
				return m_pickupType;
			}
		}

		public bool IsPaused { get; private set; }

		private void OnDisable()
		{
			StopAllCoroutines();
			if (m_connectedTile != null)
			{
				EventHub.Unsubscribe<Events.WandUiToggledEvent>(m_wandUiToggledEventToken);
				EventHub.Unsubscribe<Events.MatchPausedEvent>(m_matchPausedEventToken);
				m_connectedTile.OnTileOccupied -= OnTileOccupied;
			}
		}

		private void Awake()
		{
			m_isDualWielding = GameControl.Instance.IsDualWieldSupportedAndActive;
			m_gazeTime = ((!m_isDualWielding) ? m_gazeTimeOneHand : m_gazeTimeDualWield);
			m_hapticsData = HapticsData.Copy(m_hapticsData);
			m_hapticsData.Time = m_gazeTime;
			m_audioSource = GetComponent<AudioSource>();
			if (m_isDualWielding)
			{
				m_audioSource.pitch *= m_gazeTimeOneHand / m_gazeTimeDualWield;
			}
		}

		private void Update()
		{
			if (m_occupant == null)
			{
				return;
			}
			if (m_moveTowardsPlayer)
			{
				m_pickupObject.position = Vector3.Lerp(m_pickupObject.position, m_destination, Time.deltaTime * 15f);
				if (Vector3.Distance(m_pickupObject.position, m_destination) < 0.01f)
				{
					PickupAfterMovingToPlayer();
				}
				return;
			}
			if (m_isGazing)
			{
				if (!Pickable)
				{
					goto IL_00ef;
				}
				if (m_occupant.IsPlayer)
				{
					bool? flag = (m_occupant.Wand.GetWandControl() as WandControlOneHand)?.UI.IsActive;
					if (flag.HasValue && flag.Value)
					{
						goto IL_00ef;
					}
				}
				goto IL_00f5;
			}
			if (m_pickupObject.position != base.transform.position)
			{
				if (m_pickupObject.parent == null)
				{
					m_pickupObject.SetParent(base.transform);
				}
				m_pickupObject.position = Vector3.Lerp(m_pickupObject.position, base.transform.position, Time.deltaTime * 10f);
			}
			return;
			IL_00ef:
			LookExit();
			goto IL_00f5;
			IL_00f5:
			if (m_suddenDeath)
			{
				Pickup();
				m_isGazing = false;
				return;
			}
			m_currentGazeTime += Time.deltaTime / m_gazeTime;
			m_pickupObject.position = new Vector3(base.transform.position.x, base.transform.position.y + Mathf.PingPong(m_currentGazeTime, 0.025f) * m_currentGazeTime, base.transform.position.z);
			if (Mathf.Clamp01(m_currentGazeTime) == 1f)
			{
				Pickup();
				m_isGazing = false;
			}
		}

		public void OnMatchEnd()
		{
			StopAllCoroutines();
			PunSetPickupActive(active: false);
			m_occupant = null;
		}

		public void OnSuddenDeath()
		{
			m_suddenDeath = true;
			StopAllCoroutines();
			if (m_moveTowardsPlayer)
			{
				OnPlayerPickup();
				return;
			}
			if (m_isGazing)
			{
				LookExit();
			}
			if (!base.InteractionLocked && m_breakAudio != null)
			{
				m_breakAudio.gameObject.SetActive(value: true);
				m_breakAudio.Play();
			}
			PunSetPickupActive(active: false);
		}

		public void ResetPickup()
		{
			m_suddenDeath = false;
			StopCoroutine("RespawnPickup");
			StopCoroutine("ActivatePickup");
			if (base.gameObject.activeSelf)
			{
				StartCoroutine("ActivatePickup");
			}
		}

		private void OnTileOccupied(bool occupied)
		{
			if (occupied)
			{
				m_occupant = m_connectedTile.OccupantWielder;
				if (m_occupant != null && m_occupant.IsLocal)
				{
					m_gazeTime = ((!m_occupant.IsPlayer || !m_isDualWielding) ? m_gazeTimeOneHand : m_gazeTimeDualWield);
					LockInteraction(locked: false);
					LockLook(locked: false);
				}
				return;
			}
			if (m_moveTowardsPlayer)
			{
				PickupAfterMovingToPlayer();
			}
			else
			{
				m_isGazing = false;
			}
			if (m_occupant != null)
			{
				LookExit(m_lastWandHand);
				m_wandHands.Clear();
				m_currentGazeTime = 0f;
				m_occupant = null;
			}
			LockInteraction(locked: true);
			LockLook(locked: true);
		}

		private void OnWandUiToggled(Events.WandUiToggledEvent eventData)
		{
			if (m_isGazing)
			{
				LookExit();
			}
		}

		public void UpdatePickupCursedActiveStatus(bool setActive)
		{
			if (PickUpType != 0)
			{
				if ((object)m_cursedEffect != null)
				{
					m_cursedEffect.SetActive(value: false);
				}
				return;
			}
			if (m_cursedEffect == null)
			{
				if (!setActive)
				{
					return;
				}
				m_cursedEffect = UnityEngine.Object.Instantiate(GameObjectLoader.GetGameObject(AssetBundleType.VFX, "CursedHealthPickup"), m_pickupObject);
				m_cursedEffect.transform.localPosition = Vector3.zero;
				m_cursedEffect.transform.localRotation = Quaternion.identity;
			}
			m_cursedEffect.SetActive(setActive);
		}

		public void SetStartValues()
		{
			m_photonView = GetComponent<PhotonView>();
			m_collider = GetComponent<Collider>();
			m_initialSpawnWait = new CustomWaitForSeconds(m_initialSpawnTime);
			m_respawnWait = new CustomWaitForSeconds(m_respawnTime);
		}

		public void SetActive(Tile connectedTile)
		{
			if (m_pickupObject == null)
			{
				throw new UnityException("No pickup object defined!");
			}
			if (connectedTile == null)
			{
				throw new UnityException($"Trying to connect a null tile to pickup <{base.name}> on <{GameControl.Instance.GetCurrentLevel()}>");
			}
			m_wandUiToggledEventToken = EventHub.Subscribe<Events.WandUiToggledEvent>(OnWandUiToggled);
			m_matchPausedEventToken = EventHub.Subscribe<Events.MatchPausedEvent>(OnMatchPaused);
			m_connectedTile = connectedTile;
			m_connectedTile.OnTileOccupied += OnTileOccupied;
			OnTileOccupied(m_connectedTile.IsOccupied);
			SpawnAddOn();
			PunSetPickupActive(active: false);
			if (m_breakAudio != null)
			{
				m_breakAudio.gameObject.SetActive(value: false);
			}
		}

		[PunRPC]
		private void PunResetPickup(bool enable)
		{
			StopCoroutine("RespawnPickup");
			m_audioSource.Stop();
			m_currentGazeTime = 0f;
			PunSetPickupActive(enable);
		}

		public void SetPickupActive(bool active)
		{
			PunSetPickupActive(active);
		}

		[PunRPC]
		private void PunSetPickupActive(bool active)
		{
			if (m_pickupObject == null)
			{
				return;
			}
			m_pickupObject.gameObject.SetActive(active);
			m_collider.enabled = active;
			if (!(m_connectedTile != null))
			{
				return;
			}
			if (active)
			{
				m_connectedTile.AddPickup(this);
				bool? flag = (((object)m_occupant != null) ? new bool?(m_occupant.IsLocal) : null);
				if (flag.HasValue && flag.Value)
				{
					LockInteraction(locked: false);
					LockLook(locked: false);
				}
			}
			else
			{
				m_connectedTile.RemovePickup(this);
				LockInteraction(locked: true);
				LockLook(locked: true);
			}
		}

		[PunRPC]
		private void PunDestroyPickup()
		{
			m_pickupObject.gameObject.SetActive(value: false);
			m_collider.enabled = false;
			LockInteraction(locked: true);
			LockLook(locked: true);
			m_audioSource.Stop();
			m_currentGazeTime = 0f;
			StopCoroutine("RespawnPickup");
			StopCoroutine("ActivatePickup");
			StartCoroutine("ActivatePickup");
			LookExit();
		}

		private IEnumerator ActivatePickup()
		{
			PunResetPickup(enable: false);
			yield return m_initialSpawnWait;
			PunSetPickupActive(active: true);
		}

		private IEnumerator RespawnPickup()
		{
			yield return m_respawnWait;
			if (!m_suddenDeath)
			{
				if (NetworkUtils.ConnectedToGame)
				{
					m_photonView.RPC("PunResetPickup", RpcTarget.AllBuffered, true);
				}
				else
				{
					PunResetPickup(enable: true);
				}
			}
		}

		private void SpawnAddOn()
		{
			if (!GameControl.Instance.Platform.Type.ContainsFlag(PlatformTarget.Android) && m_pickupType != PickupType.FreeTeleport)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(GameControl.Instance.AssetHandler.LoadAsset<GameObject>(AssetBundleType.Default, "PickupAddOn"));
				gameObject.transform.SetParent(m_pickupObject.transform);
				gameObject.transform.localPosition = Vector3.zero;
			}
		}

		private void Pickup()
		{
			bool? flag = (((object)m_occupant != null) ? new bool?(m_occupant.IsLocal) : null);
			bool? flag2 = ((!flag.HasValue) ? null : new bool?(!flag.Value));
			if (flag2.HasValue && !flag2.Value)
			{
				PunSingleton<SoundManager>.Instance.PlaySoundAtPoint("pickup_get", m_pickupObject.position);
				m_pickupObject.SetParent(null);
				m_destination = m_occupant.Wand.GetWandControl(m_lastWandHand).CachedTipPoint + sm_wandDestinationOffset;
				m_moveTowardsPlayer = true;
			}
		}

		public void Interact(WandHand wandHand)
		{
		}

		public void LookEnter(WandHand wandHand)
		{
			if (m_wandHands.Add(wandHand))
			{
				m_lastWandHand = wandHand;
				LookEnter();
				TryTriggerHaptics();
			}
		}

		public void LookExit(WandHand wandHand)
		{
			if (!m_wandHands.Remove(wandHand))
			{
				return;
			}
			TryCancelHaptics(wandHand);
			if (m_wandHands.IsEmpty())
			{
				if (m_isGazing)
				{
					LookExit();
				}
			}
			else if (m_occupant != null)
			{
				m_lastWandHand = wandHand.Opposite();
				TryTriggerHaptics();
			}
		}

		public override void LookEnter()
		{
			if (m_occupant != null && m_occupant.IsPlayer)
			{
				bool? flag = (m_occupant.Wand.GetWandControl() as WandControlOneHand)?.UI.IsActive;
				if (flag.HasValue && flag.Value)
				{
					return;
				}
			}
			if (Pickable && !m_isGazing && !base.InteractionLocked && !base.LookLocked)
			{
				m_isGazing = true;
				base.LookEnter();
				m_audioSource.Play();
			}
		}

		public override void LookExit()
		{
			if (m_wandHands != null)
			{
				m_wandHands.Clear();
			}
			m_isGazing = false;
			base.LookExit();
			if (!m_moveTowardsPlayer)
			{
				m_currentGazeTime = 0f;
				if (m_audioSource != null)
				{
					m_audioSource.Stop();
				}
			}
		}

		public void DestroyPickup()
		{
			m_photonView.RPC("PunDestroyPickup", RpcTarget.AllBuffered);
		}

		private void PickupAfterMovingToPlayer()
		{
			m_pickupObject.SetParent(base.transform);
			m_moveTowardsPlayer = false;
			OnPlayerPickup();
			m_isGazing = false;
		}

		protected virtual void OnPlayerPickup()
		{
			if (!m_suddenDeath)
			{
				StartCoroutine("RespawnPickup");
			}
			m_wandHands.Clear();
			if (NetworkUtils.ConnectedToGame)
			{
				m_photonView.RPC("PunSetPickupActive", RpcTarget.AllBuffered, false);
			}
			else
			{
				PunSetPickupActive(active: false);
			}
			if (!(m_occupant == null))
			{
				Wielder occupant = m_occupant;
				switch (m_pickupType)
				{
				case PickupType.Health:
					occupant.AddHealthPickup(m_pickupAmount, m_lastWandHand);
					break;
				case PickupType.Mana:
					occupant.ChangeMana(m_pickupAmount);
					break;
				case PickupType.FreeTeleport:
					occupant.Wand.SetFreeTeleport(m_pickupAmount);
					PunSingleton<PickupManager>.Instance.PickNextSuperPickUp();
					break;
				}
			}
		}

		private void OnMatchPaused(Events.MatchPausedEvent eventData)
		{
			Pause(eventData.IsPaused);
		}

		public void Pause(bool paused)
		{
			IsPaused = paused;
			int num;
			if (!paused)
			{
				bool? flag = (((object)m_occupant != null) ? new bool?(m_occupant.IsLocal) : null);
				bool? flag2 = ((!flag.HasValue) ? null : new bool?(!flag.Value));
				num = ((!flag2.HasValue || flag2.Value) ? 1 : 0);
			}
			else
			{
				num = 1;
			}
			bool locked = (byte)num != 0;
			LockInteraction(locked);
			LockLook(locked);
		}

		private void TryTriggerHaptics()
		{
			if (!(m_occupant == null) && !(m_occupant.PlayerControl == null) && m_occupant.PlayerControl.Input != null)
			{
				m_hapticsData.Time = Mathf.Lerp(m_gazeTime, 0f, m_currentGazeTime);
				m_occupant.PlayerControl.Input.TriggerHaptics(m_hapticsData, overrideCurrent: true, m_lastWandHand);
			}
		}

		private void TryCancelHaptics(WandHand wandHand)
		{
			if (!(m_occupant == null))
			{
				m_occupant.PlayerControl?.Input?.CancelHaptics(VibrateController.Primary, wandHand);
			}
		}
	}
	[RequireComponent(typeof(PhotonView))]
	public class PickupManager : PunSingleton<PickupManager>
	{
		[SerializeField]
		private PickupBase[] m_pickUps = Array.Empty<PickupBase>();

		[SerializeField]
		private Tile[] m_pickUpTiles = Array.Empty<Tile>();

		private List<PickupBase> m_superPickUps = new List<PickupBase>();

		private List<PickupBase> m_regularPickups = new List<PickupBase>();

		private List<Tile> m_tilesForSuperPickUps = new List<Tile>();

		private Tile m_currentTile;

		private EventToken m_matchResetEventToken;

		private EventToken m_suddenDeathStartedEventToken;

		private EventToken m_curseActivationEventToken;

		private EventToken m_matchEndedEventToken;

		protected override void OnDisable()
		{
			base.OnDisable();
			EventHub.Unsubscribe<Events.MatchResetEvent>(m_matchResetEventToken);
			EventHub.Unsubscribe<Events.MatchEndedEvent>(m_matchEndedEventToken);
			EventHub.Unsubscribe<Events.SuddenDeathStartedEvent>(m_suddenDeathStartedEventToken);
			EventHub.Unsubscribe<Events.CurseActivationEvent>(m_curseActivationEventToken);
		}

		private void Start()
		{
			if (m_pickUps.Length != m_pickUpTiles.Length)
			{
				WandsLogger.Log("Number of pickups don't match number of connected tiles!", LogType.Error);
				return;
			}
			for (int i = 0; i < m_pickUps.Length; i++)
			{
				m_pickUps[i].SetStartValues();
				m_pickUps[i].SetActive(m_pickUpTiles[i]);
				if (m_pickUps[i].PickUpType == PickupType.FreeTeleport)
				{
					m_pickUps[i].StopAllCoroutines();
					m_superPickUps.Add(m_pickUps[i]);
					m_tilesForSuperPickUps.Add(m_pickUpTiles[i]);
				}
				else
				{
					m_regularPickups.Add(m_pickUps[i]);
				}
			}
			m_matchResetEventToken = EventHub.Subscribe<Events.MatchResetEvent>(OnMatchReset);
			m_matchEndedEventToken = EventHub.Subscribe<Events.MatchEndedEvent>(OnMatchEnded);
			m_suddenDeathStartedEventToken = EventHub.Subscribe<Events.SuddenDeathStartedEvent>(OnSuddenDeathStarted);
			m_curseActivationEventToken = EventHub.Subscribe<Events.CurseActivationEvent>(OnCurseActivated);
		}

		private void OnCurseActivated(Events.CurseActivationEvent eventData)
		{
			UpdatePickupsCursedActiveStatus(eventData.IsActive);
		}

		private void OnSuddenDeathStarted(Events.SuddenDeathStartedEvent eventData)
		{
			OnSuddenDeath();
		}

		private void OnSuddenDeath()
		{
			PickupBase[] pickUps = m_pickUps;
			foreach (PickupBase pickupBase in pickUps)
			{
				pickupBase.OnSuddenDeath();
			}
		}

		private void OnMatchReset(Events.MatchResetEvent eventData)
		{
			ResetPickups();
			PickNextSuperPickUp();
		}

		private void OnMatchEnded(Events.MatchEndedEvent eventData)
		{
			OnMatchEnd();
		}

		private void OnMatchEnd()
		{
			PickupBase[] pickUps = m_pickUps;
			foreach (PickupBase pickupBase in pickUps)
			{
				pickupBase.OnMatchEnd();
			}
		}

		private void ResetPickups()
		{
			foreach (PickupBase regularPickup in m_regularPickups)
			{
				regularPickup.ResetPickup();
			}
			UpdatePickupsCursedActiveStatus(GameControl.Instance.PlayerControl.IsCurseActive);
		}

		public void PickNextSuperPickUp()
		{
			if (NetworkUtils.ConnectedToGame)
			{
				base.photonView.RPC("PunPickNextSuperPickUp", RpcTarget.MasterClient);
			}
			else
			{
				PunPickNextSuperPickUp();
			}
		}

		[PunRPC]
		private void PunPickNextSuperPickUp()
		{
			if (!m_superPickUps.IsNullOrEmpty())
			{
				m_currentTile = m_tilesForSuperPickUps.GetRandomElement(m_currentTile);
				if (NetworkUtils.ConnectedToGame)
				{
					base.photonView.RPC("PunActivateSuperPickUp", RpcTarget.AllBufferedViaServer, m_tilesForSuperPickUps.IndexOf(m_currentTile));
				}
				else
				{
					PunActivateSuperPickUp(m_tilesForSuperPickUps.IndexOf(m_currentTile));
				}
			}
		}

		[PunRPC]
		private void PunActivateSuperPickUp(int randomTileIndex)
		{
			for (int i = 0; i < m_superPickUps.Count; i++)
			{
				if (i == randomTileIndex)
				{
					m_superPickUps[i].gameObject.SetActive(value: true);
					m_superPickUps[i].SetActive(m_tilesForSuperPickUps[i]);
					m_superPickUps[i].ResetPickup();
				}
				else
				{
					m_superPickUps[i].SetPickupActive(active: true);
					m_superPickUps[i].gameObject.SetActive(value: false);
				}
			}
		}

		private void UpdatePickupsCursedActiveStatus(bool setActive)
		{
			foreach (PickupBase regularPickup in m_regularPickups)
			{
				regularPickup.UpdatePickupCursedActiveStatus(setActive);
			}
		}
	}
}
namespace Assets.Scripts.Platform.Achievements
{
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	public struct Achievement
	{
		public Assets.Scripts.Enums.AchievementType Type { get; private set; }

		public string Name { get; private set; }

		public int Id { get; private set; }

		public Achievement(Assets.Scripts.Enums.AchievementType type, string name, int id)
		{
			Type = type;
			Name = name;
			Id = id;
		}
	}
	public static class AchievementRepository
	{
		private static readonly Dictionary<Assets.Scripts.Enums.AchievementType, Achievement> sm_achievementsByType;

		private static readonly Achievement[] sm_achievementsByIndex;

		private static Achievement InvalidAchievement { get; }

		static AchievementRepository()
		{
			sm_achievementsByType = new Dictionary<Assets.Scripts.Enums.AchievementType, Achievement>();
			sm_achievementsByIndex = new Achievement[11];
			InvalidAchievement = new Achievement(Assets.Scripts.Enums.AchievementType.Unknown, "Invalid", -1);
			AddAchievement(Assets.Scripts.Enums.AchievementType.TutorialComplete, "Ready for The Beyond", 0);
			AddAchievement(Assets.Scripts.Enums.AchievementType.WinFirstDuel, "Victory!", 1);
			AddAchievement(Assets.Scripts.Enums.AchievementType.WinAllArenas, "Conqueror", 2);
			AddAchievement(Assets.Scripts.Enums.AchievementType.ChangeRelicLoadout, "Keep Them Guessing", 3);
			AddAchievement(Assets.Scripts.Enums.AchievementType.ChangeTitle, "They Call Me...", 4);
			AddAchievement(Assets.Scripts.Enums.AchievementType.Deal200Damage, "Overkill", 5);
			AddAchievement(Assets.Scripts.Enums.AchievementType.Win25Duels, "25th Victory!", 6);
			AddAchievement(Assets.Scripts.Enums.AchievementType.Unlock20Relics, "Relic Master", 7);
			AddAchievement(Assets.Scripts.Enums.AchievementType.Purchase7Wands, "Collector of Wands", 8);
			AddAchievement(Assets.Scripts.Enums.AchievementType.Purchase9Characters, "Master of Disguise", 9);
			AddAchievement(Assets.Scripts.Enums.AchievementType.ReachLevel100, "Centurion", 10);
		}

		private static void AddAchievement(Assets.Scripts.Enums.AchievementType type, string name, int id)
		{
			Achievement achievement = new Achievement(type, name, id);
			sm_achievementsByType.Add(type, achievement);
			sm_achievementsByIndex[id] = achievement;
		}

		public static Achievement GetAchievement(Assets.Scripts.Enums.AchievementType type)
		{
			if (!sm_achievementsByType.ContainsKey(type))
			{
				WandsLogger.LogError($"Achievement of type [{type}] is not supported");
				return InvalidAchievement;
			}
			return sm_achievementsByType[type];
		}

		public static Achievement GetAchievement(int id)
		{
			if (id > sm_achievementsByIndex.Length)
			{
				WandsLogger.LogError($"Achievement of type [{id}] is not supported");
				return InvalidAchievement;
			}
			return sm_achievementsByIndex[id];
		}
	}
	public interface IAchievementHandler
	{
		bool HandlesIncrementalAchievements { get; }

		IPromise UnlockAchievement(Achievement achievement);

		IPromise ClearAchievement(Achievement achievement);

		IPromise<Status> GetAchievementStatus(Achievement achievement);

		IPromise IncrementAchievement(Achievement achievement, int steps);
	}
	public interface IAchievementPlatform
	{
		IAchievementHandler AchievementHandler { get; }
	}
	public enum Status
	{
		Earned,
		NotEarned
	}
}
namespace Assets.Scripts.Platform
{
	public class AssetHandler : MonoBehaviour
	{
		[StructLayout(LayoutKind.Sequential, Size = 1)]
		private struct CombinedConstants
		{
			public const string Character = "character";

			public const string Sound = "sound";

			public const string UI = "ui";
		}

		[StructLayout(LayoutKind.Sequential, Size = 1)]
		private struct PcConstants
		{
			public const string Platform = "pc_platform";

			public const string Spells = "pc_spells";

			public const string UIWorkshop = "pc_ui.workshop";

			public const string UIBasement = "pc_ui.basement";

			public const string Default = "pc";

			public const string Vanity = "pc_vanity";

			public const string Vfx = "pc_vfx";

			public static readonly string[] BaseBundles = new string[6] { "sound", "ui", "character", "pc", "pc_vanity", "pc_vfx" };
		}

		[StructLayout(LayoutKind.Sequential, Size = 1)]
		private struct PS4Constants
		{
			public const string Platform = "ps4_platform";
		}

		[StructLayout(LayoutKind.Sequential, Size = 1)]
		private struct MobileConstants
		{
			[StructLayout(LayoutKind.Sequential, Size = 1)]
			public struct HighEnd
			{
				public const string Platform = "hm_platform";

				public const string Spells = "hm_spells";
			}

			[StructLayout(LayoutKind.Sequential, Size = 1)]
			public struct LowEnd
			{
				public const string Platform = "m_platform";

				public const string Spells = "m_spells";
			}

			public const string UIWorkshop = "m_ui.workshop";

			public const string UIBasement = "m_ui.basement";

			public const string Vanity = "m_vanity";

			public const string Vfx = "m_vfx";

			public static readonly string[] BaseBundles = new string[5] { "sound", "ui", "character", "m_vanity", "m_vfx" };
		}

		private List<GameObject> m_sceneObjects = new List<GameObject>(4);

		private static AssetBundleManager sm_assetBundleManager;

		private string[] m_bundles = new string[0];

		private int m_numberOfBundlesLoaded;

		private string m_sceneBundleName;

		private List<string> m_specificSceneBundlesLoaded = new List<string>(4);

		private EventToken m_sceneLoadedEventToken;

		private EventToken m_sceneLoadInitiatedEventToken;

		private EventToken m_initiateStartupSceneLoadEventToken;

		private EventToken m_playFabLoadingEventToken;

		public bool HasLoaded { get; private set; }

		private void Awake()
		{
			UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
			if (sm_assetBundleManager == null)
			{
				sm_assetBundleManager = new AssetBundleManager();
			}
		}

		private void OnEnable()
		{
			m_sceneLoadedEventToken = EventHub.Subscribe<Events.SceneLoadedEvent>(OnSceneLoaded);
			m_sceneLoadInitiatedEventToken = EventHub.Subscribe<Events.SceneLoadInitiatedEvent>(OnSceneLoadInitiated);
			m_initiateStartupSceneLoadEventToken = EventHub.Subscribe<Events.InitiateStartupSceneLoadEvent>(OnInitiateStartupSceneLoad);
			m_playFabLoadingEventToken = EventHub.Subscribe<Events.PlayFabLoadingEvent>(OnPlayFabLoadingEvent);
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe<Events.SceneLoadedEvent>(m_sceneLoadedEventToken);
			EventHub.Unsubscribe<Events.SceneLoadInitiatedEvent>(m_sceneLoadInitiatedEventToken);
			EventHub.Unsubscribe<Events.InitiateStartupSceneLoadEvent>(m_initiateStartupSceneLoadEventToken);
			EventHub.Unsubscribe<Events.PlayFabLoadingEvent>(m_playFabLoadingEventToken);
		}

		private void OnDestroy()
		{
			StopAllCoroutines();
			AssetBundle.UnloadAllAssetBundles(unloadAllObjects: true);
		}

		private void OnInitiateStartupSceneLoad(Events.InitiateStartupSceneLoadEvent eventData)
		{
			LoadAndUnloadLevelBundles(eventData.LoadLevel, GameControl.Instance.Platform.Type);
		}

		private void OnSceneLoadInitiated(Events.SceneLoadInitiatedEvent eventData)
		{
			LoadAndUnloadLevelBundles(eventData.LevelToLoad, GameControl.Instance.Platform.Type);
		}

		private void OnSceneLoaded(Events.SceneLoadedEvent eventData)
		{
			DefineAndLoadSceneBundle(eventData.Scene, eventData.LoadSceneMode);
		}

		private List<string> GetBundlesToLoad(Level level, PlatformType platform)
		{
			bool flag = platform.ContainsFlag(PlatformTarget.PC);
			bool flag2 = platform.ContainsFlag(PlatformTarget.HighEndMobile);
			List<string> list = new List<string>(2);
			switch (level)
			{
			case Level.Lobby:
				list.Add(flag ? "pc_spells" : ((!flag2) ? "m_spells" : "hm_spells"));
				break;
			case Level.Workshop:
				list.Add((!flag) ? "m_ui.workshop" : "pc_ui.workshop");
				break;
			case Level.Basement:
				list.Add(flag ? "pc_spells" : ((!flag2) ? "m_spells" : "hm_spells"));
				list.Add((!flag) ? "m_ui.basement" : "pc_ui.basement");
				break;
			case Level.AspisPrison:
			case Level.TempleOfOphidian:
			case Level.TheCelestialHalls:
			case Level.OrtusStation:
			case Level.DeadMastersVale:
			case Level.SanctumOfSahir:
			case Level.TheCelestialHalls_AIBot:
			case Level.FountainOfTheFallen:
				list.Add(flag ? "pc_spells" : ((!flag2) ? "m_spells" : "hm_spells"));
				break;
			default:
				throw new NotImplementedException(string.Concat("Level case not implemented: ", level, ". Can't fetch bundles to load."));
			case Level.MainMenu:
				break;
			}
			return list;
		}

		public void LoadAndUnloadLevelBundles(Level level, PlatformType platform)
		{
			List<string> bundlesToLoad = GetBundlesToLoad(level, platform);
			string[] bundlesToLoad2 = bundlesToLoad.Except(m_specificSceneBundlesLoaded).ToArray();
			StartCoroutine(_ReloadBundle(bundlesToLoad2, bundlesToLoad, platform));
		}

		private IEnumerator _ReloadBundle(string[] bundlesToLoad, List<string> bundlesToHaveLoaded, PlatformType platform)
		{
			string[] bundlesToUnload = m_specificSceneBundlesLoaded.Except(bundlesToHaveLoaded).ToArray();
			yield return new WaitForSeconds(1f);
			UnloadBundles(bundlesToUnload);
			yield return _LoadBundles(platform.ContainsFlag(PlatformTarget.Android), bundlesToLoad);
		}

		private IEnumerator _LoadBundles(bool isAndroid, string[] bundlesToLoad)
		{
			foreach (string bundle in bundlesToLoad)
			{
				yield return sm_assetBundleManager.LoadAssetBundle(bundle, delegate(bool success)
				{
					if (success)
					{
						m_specificSceneBundlesLoaded.Add(bundle);
					}
					else
					{
						WandsLogger.LogError("Wasn't able to load bundle " + bundle);
					}
				}, isAndroid);
			}
			EventHub.Publish(new Events.AreaBundlesLoadedEvent());
		}

		private void UnloadBundles(string[] bundlesToUnload)
		{
			foreach (string text in bundlesToUnload)
			{
				if (sm_assetBundleManager.UnloadAssetBundle(text))
				{
					m_specificSceneBundlesLoaded.Remove(text);
				}
			}
		}

		private void DefineAndLoadSceneBundle(Scene scene, LoadSceneMode loadMode)
		{
			if (scene.name == "MainMenu")
			{
				return;
			}
			Platform platform = GameControl.Instance.Platform;
			if (!(platform == null) && !platform.Type.ContainsFlag(PlatformTarget.LowEndMobile))
			{
				if (!string.IsNullOrEmpty(m_sceneBundleName))
				{
					sm_assetBundleManager.UnloadAssetBundle(m_sceneBundleName);
				}
				if (platform.Type.ContainsFlag(PlatformTarget.PC))
				{
					m_sceneBundleName = "level." + scene.name.ToLower();
					LoadSceneBundle();
				}
				else if (scene.name == "Workshop")
				{
					m_sceneBundleName = "hm_level." + scene.name.ToLower();
					LoadSceneBundle();
				}
			}
		}

		private void OnPlayFabLoadingEvent(Events.PlayFabLoadingEvent eventData)
		{
			if (eventData.Success)
			{
				DefineGeneralAssetBundles(GameControl.Instance.Platform);
			}
		}

		public void DefineGeneralAssetBundles(Platform platform)
		{
			if (!platform)
			{
				WandsLogger.LogError("Asset Handler: Missing Dependency, no valid platform reference.");
				return;
			}
			m_numberOfBundlesLoaded = 0;
			if (platform.Type.ContainsFlag(PlatformTarget.Android))
			{
				m_bundles = MobileConstants.BaseBundles;
			}
			else if (platform.Type.ContainsFlag(PlatformTarget.PC))
			{
				m_bundles = PcConstants.BaseBundles;
			}
			else
			{
				WandsLogger.LogError("No bundles to load on platform: " + platform.PlatformName, LogColor.Bundles);
			}
			if (HasLoaded)
			{
				ChangePlatformMaterials(platform.Type);
			}
			else
			{
				LoadGeneralAssetBundles(platform.Type);
			}
		}

		private void LoadGeneralAssetBundles(PlatformType platform)
		{
			for (int i = 0; i < m_bundles.Length; i++)
			{
				string bundleName = m_bundles[i];
				AssetBundle.GetAllLoadedAssetBundles().FirstOrDefault((AssetBundle x) => x.name.Equals(bundleName))?.Unload(unloadAllLoadedObjects: true);
				sm_assetBundleManager.LoadAssetBundle(bundleName, this, delegate(bool success)
				{
					BundleLoaded(success, platform);
				}, platform.ContainsFlag(PlatformTarget.Android));
			}
		}

		public void LoadPlatformAssetBundle(PlatformType platform, Action<bool> loaded)
		{
			if (platform.ContainsFlag(PlatformTarget.LowEndMobile))
			{
				sm_assetBundleManager.LoadAssetBundle("m_platform", this, loaded, !UnityEngine.Application.isEditor);
				return;
			}
			if (platform.ContainsFlag(PlatformTarget.HighEndMobile))
			{
				sm_assetBundleManager.LoadAssetBundle("hm_platform", this, loaded, !UnityEngine.Application.isEditor);
				return;
			}
			if (platform.ContainsFlag(PlatformTarget.PlayStation))
			{
				sm_assetBundleManager.LoadAssetBundle("ps4_platform", this, loaded, loadAsync: false);
				return;
			}
			if (platform.ContainsFlag(PlatformTarget.PC))
			{
				sm_assetBundleManager.LoadAssetBundle("pc_platform", this, loaded, loadAsync: false);
				return;
			}
			throw new NotImplementedException("Platform neither Android nor PC");
		}

		private void BundleLoaded(bool result, PlatformType platform)
		{
			if (result)
			{
				m_numberOfBundlesLoaded++;
				if (m_numberOfBundlesLoaded == m_bundles.Length)
				{
					BundlesLoaded(platform);
					EventHub.Publish(new Events.AssetBundlesLoadedEvent());
				}
			}
		}

		private void BundlesLoaded(PlatformType platform)
		{
			HasLoaded = true;
			ChangePlatformMaterials(platform);
		}

		private void LoadSceneBundle()
		{
			sm_assetBundleManager.LoadAssetBundle(m_sceneBundleName, this, SceneBundleLoaded);
		}

		private void SceneBundleLoaded(bool result)
		{
			OnSceneBundlesLoaded(result);
		}

		private void ChangePlatformMaterials(PlatformType platform)
		{
			if (!platform.ContainsFlag(PlatformTarget.Android))
			{
				GameObject[] rootGameObjects = SceneManager.GetActiveScene().GetRootGameObjects();
				foreach (GameObject gameObject in rootGameObjects)
				{
					UpdateRendererMaterials(gameObject.GetComponentsInChildren<Renderer>(includeInactive: true));
				}
			}
		}

		public void UpdateRendererMaterials(Renderer[] renderers)
		{
			foreach (Renderer renderer in renderers)
			{
				Material material = LoadAsset<Material>(AssetBundleType.Default, renderer.material.name);
				if (material != null)
				{
					renderer.sharedMaterial = material;
					renderer.sharedMaterial.shader = Shader.Find(renderer.sharedMaterial.shader.name);
					continue;
				}
				material = LoadAsset<Material>(AssetBundleType.Vanity, renderer.material.name);
				if (material != null)
				{
					renderer.sharedMaterial = material;
					renderer.sharedMaterial.shader = Shader.Find(renderer.sharedMaterial.shader.name);
				}
			}
		}

		public Material ReplaceMaterial(Material material)
		{
			if (!GameControl.Instance.Platform)
			{
				WandsLogger.LogError("Asset Handler: Missing Dependency, Game Control did not provide a valid platform instance.", LogColor.Bundles);
				return null;
			}
			if (GameControl.Instance.Platform.Type.ContainsFlag(PlatformTarget.Android))
			{
				return material;
			}
			string assetName = material.name;
			Material material2 = LoadAsset<Material>(AssetBundleType.Default, assetName);
			if (material2 != null)
			{
				return material2;
			}
			material2 = LoadAsset<Material>(AssetBundleType.Vanity, assetName);
			if (material2 != null)
			{
				return material2;
			}
			return material;
		}

		public Material[] ReplaceMaterials(Material[] materials)
		{
			if (!GameControl.Instance.Platform)
			{
				WandsLogger.LogError("Asset Handler: Missing Dependency, Game Control did not provide a valid platform instance.", LogColor.Bundles);
				return null;
			}
			if (GameControl.Instance.Platform.Type.ContainsFlag(PlatformTarget.Android))
			{
				return materials;
			}
			Material[] array = new Material[materials.Length];
			for (int i = 0; i < materials.Length; i++)
			{
				string assetName = materials[i].name;
				Material material = LoadAsset<Material>(AssetBundleType.Default, assetName);
				if (material != null)
				{
					array[i] = material;
					continue;
				}
				material = LoadAsset<Material>(AssetBundleType.Vanity, assetName);
				if (material != null)
				{
					array[i] = material;
				}
				else
				{
					array[i] = materials[i];
				}
			}
			return array;
		}

		public GameObject ReplaceSpell(GameObject gameObject)
		{
			if (!GameControl.Instance.Platform)
			{
				WandsLogger.LogError("Asset Handler: Missing Dependency, Game Control did not provide a valid platform instance.", LogColor.Bundles);
				return null;
			}
			if (GameControl.Instance.Platform.Type.ContainsFlag(PlatformTarget.Android))
			{
				return gameObject;
			}
			GameObject gameObject2 = LoadAsset<GameObject>(AssetBundleType.Spells, gameObject.name);
			return gameObject2 ?? gameObject;
		}

		public T LoadAsset<T>(AssetBundleType assetBundleType, string assetName) where T : UnityEngine.Object
		{
			if (!GameControl.Instance.Platform)
			{
				WandsLogger.LogError("Asset Handler: Missing Dependency, Game Control did not provide a valid platform instance.", LogColor.Bundles);
				return (T)null;
			}
			return LoadAsset<T>(assetBundleType, assetName, GameControl.Instance.Platform.Type);
		}

		public T LoadAsset<T>(AssetBundleType assetBundleType, string assetName, PlatformType platform) where T : UnityEngine.Object
		{
			assetName = assetName.Replace(" (Instance)", string.Empty).Replace("M_", string.Empty).Replace("PC_", string.Empty)
				.Trim();
			switch (assetBundleType)
			{
			case AssetBundleType.Default:
				if (platform.ContainsFlag(PlatformTarget.PC))
				{
					string bundleName = "pc";
					assetName = "PC_" + assetName;
					return sm_assetBundleManager.LoadAsset<T>(bundleName, assetName);
				}
				return (T)null;
			case AssetBundleType.Vanity:
			{
				string bundleName;
				if (platform.ContainsFlag(PlatformTarget.PC))
				{
					bundleName = "pc_vanity";
					assetName = "PC_" + assetName;
				}
				else
				{
					bundleName = "m_vanity";
					assetName = "M_" + assetName;
				}
				return sm_assetBundleManager.LoadAsset<T>(bundleName, assetName);
			}
			case AssetBundleType.Spells:
			{
				string bundleName;
				if (platform.ContainsFlag(PlatformTarget.PC))
				{
					bundleName = "pc_spells";
					assetName = "PC_" + assetName;
					return sm_assetBundleManager.LoadAsset<T>(bundleName, assetName);
				}
				if (platform.ContainsFlag(PlatformTarget.HighEndMobile))
				{
					bundleName = "hm_spells";
					assetName = "HM_" + assetName;
					return sm_assetBundleManager.LoadAsset<T>(bundleName, assetName);
				}
				bundleName = "m_spells";
				assetName = "M_" + assetName;
				return sm_assetBundleManager.LoadAsset<T>(bundleName, assetName);
			}
			case AssetBundleType.Platform:
			{
				string bundleName = (platform.ContainsFlag(PlatformTarget.PC) ? ((!platform.ContainsFlag(PlatformTarget.PlayStation)) ? "pc_platform" : "ps4_platform") : ((!platform.ContainsFlag(PlatformTarget.HighEndMobile)) ? "m_platform" : "hm_platform"));
				return sm_assetBundleManager.LoadAsset<T>(bundleName, assetName);
			}
			case AssetBundleType.UI:
			{
				Level currentLevel = GameControl.Instance.GetCurrentLevel();
				string bundleName = ((!platform.ContainsFlag(PlatformTarget.PC)) ? ((currentLevel != Level.Workshop) ? "m_ui.basement" : "m_ui.workshop") : ((currentLevel != Level.Workshop) ? "pc_ui.basement" : "pc_ui.workshop"));
				return sm_assetBundleManager.LoadAsset<T>(bundleName, assetName);
			}
			case AssetBundleType.CombinedUI:
			{
				string bundleName = "ui";
				return sm_assetBundleManager.LoadAsset<T>(bundleName, assetName);
			}
			case AssetBundleType.VFX:
			{
				string bundleName;
				if (platform.ContainsFlag(PlatformTarget.PC))
				{
					bundleName = "pc_vfx";
					assetName = "PC_" + assetName;
				}
				else
				{
					bundleName = "m_vfx";
					assetName = "M_" + assetName;
				}
				return sm_assetBundleManager.LoadAsset<T>(bundleName, assetName);
			}
			case AssetBundleType.CombinedCharacter:
			{
				string bundleName = "character";
				return sm_assetBundleManager.LoadAsset<T>(bundleName, assetName);
			}
			default:
				throw new NotImplementedException("AssetBundleType not implemented: " + assetBundleType);
			}
		}

		public AssetBundleRequest LoadAssetAsync<T>(AssetBundleType assetBundleType, string assetName) where T : UnityEngine.Object
		{
			if (!GameControl.Instance.Platform)
			{
				WandsLogger.LogError("Asset Handler: Missing Dependency, Game Control did not provide a valid platform instance.", LogColor.Bundles);
				return null;
			}
			return LoadAssetAsync<T>(assetBundleType, assetName, GameControl.Instance.Platform.Type);
		}

		public AssetBundleRequest LoadAssetAsync<T>(AssetBundleType assetBundleType, string assetName, PlatformType platform) where T : UnityEngine.Object
		{
			assetName = assetName.Replace(" (Instance)", string.Empty).Replace("M_", string.Empty).Replace("PC_", string.Empty)
				.Trim();
			switch (assetBundleType)
			{
			case AssetBundleType.Default:
				if (platform.ContainsFlag(PlatformTarget.PC))
				{
					string bundleName = "pc";
					assetName = "PC_" + assetName;
					return sm_assetBundleManager.LoadAssetAsync<T>(bundleName, assetName);
				}
				return null;
			case AssetBundleType.Vanity:
			{
				string bundleName;
				if (platform.ContainsFlag(PlatformTarget.PC))
				{
					bundleName = "pc_vanity";
					assetName = "PC_" + assetName;
				}
				else
				{
					bundleName = "m_vanity";
					assetName = "M_" + assetName;
				}
				return sm_assetBundleManager.LoadAssetAsync<T>(bundleName, assetName);
			}
			case AssetBundleType.Spells:
			{
				string bundleName;
				if (platform.ContainsFlag(PlatformTarget.PC))
				{
					bundleName = "pc_spells";
					assetName = "PC_" + assetName;
					return sm_assetBundleManager.LoadAssetAsync<T>(bundleName, assetName);
				}
				if (platform.ContainsFlag(PlatformTarget.HighEndMobile))
				{
					bundleName = "hm_spells";
					assetName = "HM_" + assetName;
					return sm_assetBundleManager.LoadAssetAsync<T>(bundleName, assetName);
				}
				bundleName = "m_spells";
				assetName = "M_" + assetName;
				return sm_assetBundleManager.LoadAssetAsync<T>(bundleName, assetName);
			}
			case AssetBundleType.Platform:
			{
				string bundleName = (platform.ContainsFlag(PlatformTarget.PC) ? "pc_platform" : ((!platform.ContainsFlag(PlatformTarget.HighEndMobile)) ? "m_platform" : "hm_platform"));
				return sm_assetBundleManager.LoadAssetAsync<T>(bundleName, assetName);
			}
			case AssetBundleType.UI:
			{
				Level currentLevel = GameControl.Instance.GetCurrentLevel();
				string bundleName = ((!platform.ContainsFlag(PlatformTarget.PC)) ? ((currentLevel != Level.Workshop) ? "m_ui.basement" : "m_ui.workshop") : ((currentLevel != Level.Workshop) ? "pc_ui.basement" : "pc_ui.workshop"));
				return sm_assetBundleManager.LoadAssetAsync<T>(bundleName, assetName);
			}
			case AssetBundleType.CombinedUI:
			{
				string bundleName = "ui";
				return sm_assetBundleManager.LoadAssetAsync<T>(bundleName, assetName);
			}
			case AssetBundleType.VFX:
			{
				string bundleName;
				if (platform.ContainsFlag(PlatformTarget.PC))
				{
					bundleName = "pc_vfx";
					assetName = "PC_" + assetName;
				}
				else
				{
					bundleName = "m_vfx";
					assetName = "M_" + assetName;
				}
				return sm_assetBundleManager.LoadAssetAsync<T>(bundleName, assetName);
			}
			case AssetBundleType.CombinedCharacter:
			{
				string bundleName = "character";
				return sm_assetBundleManager.LoadAssetAsync<T>(bundleName, assetName);
			}
			default:
				throw new NotImplementedException("AssetBundleType not implemented: " + assetBundleType);
			}
		}

		public GameObject[] LoadSceneAssets()
		{
			return sm_assetBundleManager.LoadAssets<GameObject>(m_sceneBundleName);
		}

		private void OnSceneBundlesLoaded(bool loadedSuccessfully)
		{
			DestroyObjects();
			if (!loadedSuccessfully)
			{
				m_sceneBundleName = string.Empty;
				return;
			}
			GameObject[] array = LoadSceneAssets();
			GameObject[] array2 = array;
			foreach (GameObject original in array2)
			{
				GameObject item = UnityEngine.Object.Instantiate(original);
				m_sceneObjects.Add(item);
			}
		}

		private void DestroyObjects()
		{
			foreach (GameObject sceneObject in m_sceneObjects)
			{
				UnityEngine.Object.Destroy(sceneObject);
			}
			m_sceneObjects.Clear();
		}
	}
	public class AssetMaterialChanger : MonoBehaviour
	{
		[Tooltip("Customize what renderers to use. Setting this manually increases performance!")]
		[SerializeField]
		private Renderer[] m_renderers;

		private void Start()
		{
			ChangeMaterials();
		}

		public void ChangeMaterials()
		{
			if (!GameControl.Instance.Platform.Type.ContainsFlag(PlatformTarget.Android))
			{
				Renderer[] array = ((!m_renderers.IsNullOrEmpty()) ? m_renderers : GetComponentsInChildren<Renderer>());
				Renderer[] array2 = array;
				foreach (Renderer renderer in array2)
				{
					renderer.materials = GameControl.Instance.AssetHandler.ReplaceMaterials(renderer.materials);
				}
			}
		}
	}
}
namespace Cortopia.Scripts.Platform
{
	public interface IPlatform
	{
		bool HasInitialized { get; }

		bool SupportsPositionalTracking { get; }

		ulong UserUniqueID { get; set; }

		string SignInErrorMessage { get; }

		string AccountID { get; set; }

		string EncryptionID { get; set; }

		PlatformType Type { get; }

		string PistolGripName { get; }

		string WandGripName { get; }

		void InitializeCore();

		void FetchLoggedInUser();

		void OnSystemMenuPress(Level Level, bool applicationPaused);

		void SetPlatformPartyChatActive(bool active);

		IPlatformInput CreateInputController();

		IList<Language> GetAvailableLanguages();
	}
	public interface IHapticsPlatform : IPlatform
	{
		void TriggerHaptics(HapticsData hapticsData, bool overrideCurrent, WandHand wandHand);

		void CancelHaptics(VibrateController controller, WandHand wandHand);

		void UpdatePrimaryHand(bool primaryIsRight);
	}
}
namespace Assets.Scripts.Platform
{
	public struct LeaderboardEntry
	{
		public int Rank;

		public string Name;

		public int Score;
	}
}
namespace Assets.Scripts.Enums
{
	public enum LeaderboardType
	{
		RatingGlobal,
		RatingUser,
		RatingPlayStationGlobal,
		RatingPlayStationUser
	}
}
namespace Assets.Scripts.Platform
{
	public class MiVrPlatform : Platform
	{
		private IPlatformInput m_inputController;

		private ControlType m_controlType;

		private float m_focusRotation;

		private int m_tempNewRating;

		private int m_tempNewSeasonScore;

		private ulong m_opponentId;

		private bool m_hasInitialized;

		private bool m_gotUserInitializationCallback;

		private LoginFinishedEventArgs m_platformInitializationState;

		public override PlatformType Type
		{
			[CompilerGenerated]
			get
			{
				return PlatformType.MiVr;
			}
		}

		public override ControlType ControlType
		{
			[CompilerGenerated]
			get
			{
				return m_controlType;
			}
		}

		public override IReadOnlyList<WandInput> SupportedWandInputs
		{
			[CompilerGenerated]
			get
			{
				return Constants.DefaultAndroidWandInputs;
			}
		}

		public override bool HasInitialized
		{
			[CompilerGenerated]
			get
			{
				return m_hasInitialized;
			}
		}

		public override string SignInErrorMessage
		{
			[CompilerGenerated]
			get
			{
				return "Sign-in failed with the MiVR Platform";
			}
		}

		public override bool SupportsPositionalTracking
		{
			[CompilerGenerated]
			get
			{
				return false;
			}
		}

		public override string PlatformName
		{
			[CompilerGenerated]
			get
			{
				return PlatformTarget.OculusAndroid.ToString();
			}
		}

		public override WandGrip DefaultWandGrip
		{
			[CompilerGenerated]
			get
			{
				return WandGrip.Wand;
			}
		}

		public int DefaultCpuThrottle
		{
			[CompilerGenerated]
			get
			{
				return 0;
			}
		}

		public int DefaultGpuThrottle
		{
			[CompilerGenerated]
			get
			{
				return 0;
			}
		}

		private void OnEnable()
		{
			OVRManager.HMDMounted += OnHMDMounted;
			OVRManager.HMDUnmounted += OnHMDUnmounted;
		}

		private void OnDisable()
		{
			OVRManager.HMDMounted -= OnHMDMounted;
			OVRManager.HMDUnmounted -= OnHMDUnmounted;
		}

		private void OnApplicationQuit()
		{
			CommerceManager.Instance.LoginFinished -= GetUserCallback;
			EntitlementCheck.ReleaseEntitlementCheck();
		}

		public override void InitializeCore()
		{
			EncryptionID = string.Empty;
			CheckEntitlement();
			base.gameObject.SetActive(value: true);
		}

		public override void CheckEntitlement()
		{
			EntitlementCheck.InitAndCheckEntitlement();
		}

		private void OnHMDMounted()
		{
			CompensateRotation(rotate: true);
		}

		private void OnHMDUnmounted()
		{
			CompensateRotation(rotate: false);
		}

		public override void FetchLoggedInUser()
		{
			CommerceManager.Instance.LoginFinished += GetUserCallback;
			CommerceManager.Instance.Login();
		}

		private void GetUserCallback(object sender, LoginFinishedEventArgs e)
		{
			m_platformInitializationState = e;
			m_gotUserInitializationCallback = true;
		}

		private void Update()
		{
			if (m_gotUserInitializationCallback)
			{
				if (m_platformInitializationState.Code == MIVR.ErrorCode.Success)
				{
					AccountID = m_platformInitializationState.Account.NickName;
					EncryptionID = m_platformInitializationState.Account.OpenId;
					PlayerProperty.Set("P0", EncryptionID);
					Events.UserFetchCompletedEvent userFetchCompletedEvent = new Events.UserFetchCompletedEvent();
					userFetchCompletedEvent.AccountID = "MI_" + AccountID;
					userFetchCompletedEvent.EncryptionID = EncryptionID;
					EventHub.Publish(userFetchCompletedEvent);
					m_hasInitialized = true;
				}
				else
				{
					Events.UserFetchCompletedEvent userFetchCompletedEvent = new Events.UserFetchCompletedEvent();
					userFetchCompletedEvent.ErrorMsg = $"MiVRPlatform, fetching the MiVR user failed with error: {m_platformInitializationState.Code.ToString()}";
					EventHub.Publish(userFetchCompletedEvent);
				}
				m_gotUserInitializationCallback = false;
			}
		}

		private void CompensateRotation(bool rotate)
		{
			if (!(GameControl.Instance == null) && !(GameControl.Instance.PlayerControl == null))
			{
				if (rotate)
				{
					GameControl.Instance.PlayerControl.CameraPivot.rotation = Quaternion.Euler(0f, m_focusRotation, 0f);
				}
				else
				{
					m_focusRotation = GameControl.Instance.PlayerControl.CameraTransform.rotation.eulerAngles.y;
				}
			}
		}

		private void Start()
		{
			SetDefaultRenderLevel();
			SetThrottleLevels();
		}

		public override IPlatformInput CreateInputController()
		{
			m_controlType = ControlType.MiVrRemote;
			if (OVRInput.IsControllerConnected(OVRInput.Controller.RTrackedRemote) || OVRInput.IsControllerConnected(OVRInput.Controller.LTrackedRemote))
			{
				if (GameControl.Instance.IsCurrentLevel(Level.MainMenu) || GameControl.Instance.IsControlScheme(WandInput.Swipe))
				{
					m_inputController = new OculusRemoteInputSwipe();
				}
				else if (GameControl.Instance.IsControlScheme(WandInput.Press))
				{
					m_inputController = new OculusRemoteInputDirectional();
				}
				else
				{
					m_inputController = new OculusRemoteInputPoint();
				}
			}
			else if (OVRInput.IsControllerConnected(OVRInput.Controller.Gamepad))
			{
				m_controlType = ControlType.Gamepad;
				m_inputController = new OculusGamepadInput();
			}
			else
			{
				m_inputController = new GoTouchInput();
			}
			return m_inputController;
		}

		public override void OnSystemMenuPress(Level level, bool applicationPaused)
		{
			if (level.ContainsFlag(Level.Arena))
			{
				if (!(MonoSingleton<ArenaUI>.Instance == null))
				{
					if (MonoSingleton<ArenaUI>.Instance.IsEndMenuActive)
					{
						MonoSingleton<ArenaUI>.Instance.UpdateEndMenuPosition();
					}
					else if (!applicationPaused)
					{
						MonoSingleton<ArenaUI>.Instance.OnSystemMenuPress();
					}
				}
			}
			else if (level != Level.Lobby || !MonoSingleton<LobbyUI>.Instance.TryCloseOptions())
			{
				OVRManager.instance.ReturnToLauncher();
			}
		}

		private void SetDefaultRenderLevel()
		{
			OVRManager.fixedFoveatedRenderingLevel = OVRManager.FixedFoveatedRenderingLevel.High;
		}

		private void SetThrottleLevels()
		{
			OVRManager.cpuLevel = DefaultCpuThrottle;
			OVRManager.gpuLevel = DefaultGpuThrottle;
		}
	}
	public class OculusAndroidPlatform : OculusPlatform
	{
		private readonly IReadOnlyList<WandInput> m_gearVrWandInputs = new List<WandInput>
		{
			WandInput.Swipe,
			WandInput.Point
		};

		private float m_focusRotation;

		private PlatformType? m_type;

		public override string PlatformName
		{
			[CompilerGenerated]
			get
			{
				return PlatformTarget.OculusAndroid.ToString();
			}
		}

		public override PlatformType Type
		{
			[CompilerGenerated]
			get
			{
				return (!m_type.HasValue) ? GetPlatformType() : m_type.Value;
			}
		}

		public override bool SupportsPositionalTracking
		{
			[CompilerGenerated]
			get
			{
				return false;
			}
		}

		public override WandGrip DefaultWandGrip
		{
			[CompilerGenerated]
			get
			{
				return WandGrip.Wand;
			}
		}

		public override IReadOnlyList<WandInput> SupportedWandInputs
		{
			[CompilerGenerated]
			get
			{
				return (Type != PlatformType.GearVr) ? Constants.DefaultAndroidWandInputs : m_gearVrWandInputs;
			}
		}

		public int DefaultCpuThrottle
		{
			[CompilerGenerated]
			get
			{
				return (Type == PlatformType.GearVr) ? 2 : 0;
			}
		}

		public int DefaultGpuThrottle
		{
			[CompilerGenerated]
			get
			{
				return (Type == PlatformType.GearVr) ? 2 : 0;
			}
		}

		protected virtual void OnEnable()
		{
		}

		protected override void OnDisable()
		{
			base.OnDisable();
		}

		private void Start()
		{
			SetDefaultRenderLevel();
			SetThrottleLevels();
		}

		public override IPlatformInput CreateInputController()
		{
			if (OVRInput.IsControllerConnected(OVRInput.Controller.RTrackedRemote) || OVRInput.IsControllerConnected(OVRInput.Controller.LTrackedRemote))
			{
				CreateDefaultRemoteController();
			}
			else if (OVRInput.IsControllerConnected(OVRInput.Controller.Gamepad))
			{
				m_controlType = ControlType.Gamepad;
				m_inputController = new OculusGamepadInput();
			}
			else
			{
				CreateDefaultInputController(OVRPlugin.GetSystemHeadsetType());
			}
			return m_inputController;
		}

		public void CreateDefaultInputController(OVRPlugin.SystemHeadset systemHeadsetType)
		{
			switch (systemHeadsetType)
			{
			case OVRPlugin.SystemHeadset.Oculus_Go:
				CreateDefaultGOController();
				break;
			case OVRPlugin.SystemHeadset.Oculus_Quest:
			case OVRPlugin.SystemHeadset.Oculus_Link_Quest:
				CreateDefaultQuestController();
				break;
			case OVRPlugin.SystemHeadset.GearVR_R320:
			case OVRPlugin.SystemHeadset.GearVR_R321:
			case OVRPlugin.SystemHeadset.GearVR_R322:
			case OVRPlugin.SystemHeadset.GearVR_R323:
			case OVRPlugin.SystemHeadset.GearVR_R324:
				CreateDefaultGearVRController();
				break;
			default:
				throw new NullReferenceException($"No controller type matched {systemHeadsetType} when trying to create a default controller");
			}
		}

		protected void CreateDefaultQuestController()
		{
			bool boolPref = WandsSave.GetBoolPref("P1", defaultValue: true);
			m_controlType = ((!boolPref) ? ControlType.QuestLeft : ControlType.QuestRight);
			m_inputController = new QuestInput((!boolPref) ? OVRInput.Controller.LTouch : OVRInput.Controller.RTouch);
		}

		private void CreateDefaultRemoteController()
		{
			m_controlType = ((Type != PlatformType.Go) ? ControlType.GearVrRemote : ControlType.GoRemote);
			if (GameControl.Instance.IsCurrentLevel(Level.MainMenu))
			{
				m_inputController = new OculusRemoteInputSwipeMainMenu();
				return;
			}
			switch (GameControl.Instance.GetControlScheme())
			{
			case WandInput.Point:
				m_inputController = new OculusRemoteInputPoint();
				break;
			case WandInput.Swipe:
				m_inputController = new OculusRemoteInputSwipe();
				break;
			case WandInput.Press:
				m_inputController = new OculusRemoteInputDirectional();
				break;
			}
		}

		private void CreateDefaultGOController()
		{
			m_controlType = ControlType.GoRemote;
			m_inputController = new GoTouchInput();
		}

		private void CreateDefaultGearVRController()
		{
			m_controlType = ControlType.GearVr;
			m_inputController = new GearVrTouchInput();
		}

		private void SetDefaultRenderLevel()
		{
			switch (Type)
			{
			case PlatformType.GearVr:
				OVRManager.fixedFoveatedRenderingLevel = OVRManager.FixedFoveatedRenderingLevel.Off;
				break;
			case PlatformType.Go:
				OVRManager.fixedFoveatedRenderingLevel = OVRManager.FixedFoveatedRenderingLevel.High;
				break;
			case PlatformType.Quest:
				OVRManager.fixedFoveatedRenderingLevel = OVRManager.FixedFoveatedRenderingLevel.HighTop;
				break;
			}
		}

		private void SetThrottleLevels()
		{
			OVRManager.cpuLevel = DefaultCpuThrottle;
			OVRManager.gpuLevel = DefaultGpuThrottle;
		}

		private PlatformType GetPlatformType()
		{
			switch (OVRPlugin.GetSystemHeadsetType())
			{
			case OVRPlugin.SystemHeadset.Oculus_Go:
				m_type = PlatformType.Go;
				break;
			case OVRPlugin.SystemHeadset.Oculus_Quest:
			case OVRPlugin.SystemHeadset.Oculus_Link_Quest:
				m_type = PlatformType.Quest;
				break;
			case OVRPlugin.SystemHeadset.GearVR_R320:
			case OVRPlugin.SystemHeadset.GearVR_R321:
			case OVRPlugin.SystemHeadset.GearVR_R322:
			case OVRPlugin.SystemHeadset.GearVR_R323:
			case OVRPlugin.SystemHeadset.GearVR_R324:
			case OVRPlugin.SystemHeadset.GearVR_R325:
				m_type = PlatformType.GearVr;
				break;
			default:
				throw new NullReferenceException($"Couldn't translate {OVRPlugin.GetSystemHeadsetType()} to an Oculus Android device.");
			}
			return m_type.Value;
		}
	}
	public abstract class OculusPlatform : Platform
	{
		protected IPlatformInput m_inputController;

		protected ControlType m_controlType;

		public string OculusPlatformSpecificID { get; private set; }

		public override bool HasInitialized
		{
			[CompilerGenerated]
			get
			{
				return Core.IsInitialized();
			}
		}

		public override ControlType ControlType
		{
			[CompilerGenerated]
			get
			{
				return m_controlType;
			}
		}

		public override IReadOnlyList<WandInput> SupportedWandInputs
		{
			[CompilerGenerated]
			get
			{
				return Constants.DefaultPcWandInputs;
			}
		}

		public override string SignInErrorMessage
		{
			[CompilerGenerated]
			get
			{
				return "Sign-in fail Oculus";
			}
		}

		protected virtual void OnDisable()
		{
			StopAllCoroutines();
		}

		public override void InitializeCore()
		{
			EncryptionID = string.Empty;
			try
			{
				Core.AsyncInitialize();
				Entitlements.IsUserEntitledToApplication().OnComplete(GetEntitlementCallback);
			}
			catch (UnityException ex)
			{
				WandsLogger.LogError("Oculus Platform failed to initialize due to exception.");
				WandsLogger.LogException(ex.ToString());
				GetEntitlementCallback(null);
			}
		}

		private void GetEntitlementCallback(Message message)
		{
			if (message == null || message.IsError)
			{
				Events.WriteEntitlementFailedMessage writeEntitlementFailedMessage = new Events.WriteEntitlementFailedMessage();
				writeEntitlementFailedMessage.Message = $"{Type} | User not entitled to use app | Oculus ID: {AccountID} | User ID: {UserUniqueID} | Org. ID: {EncryptionID}";
				EventHub.Publish(writeEntitlementFailedMessage);
			}
		}

		public override void FetchLoggedInUser()
		{
			if (Core.IsInitialized())
			{
				Users.GetLoggedInUser().OnComplete(GetUserCallback);
				return;
			}
			Events.UserFetchCompletedEvent userFetchCompletedEvent = new Events.UserFetchCompletedEvent();
			userFetchCompletedEvent.ErrorMsg = $"{Type} user fetch failed";
			EventHub.Publish(userFetchCompletedEvent);
		}

		private void GetUserCallback(Message<Oculus.Platform.Models.User> userMessage)
		{
			if (userMessage.IsError)
			{
				Events.UserFetchCompletedEvent userFetchCompletedEvent = new Events.UserFetchCompletedEvent();
				userFetchCompletedEvent.ErrorMsg = $"{Type} | Couldn't fetch user id: {userMessage.GetError().Message}";
				EventHub.Publish(userFetchCompletedEvent);
			}
			else
			{
				AccountID = userMessage.Data.OculusID;
				UserUniqueID = userMessage.Data.ID;
				PlayerProperty.Set("P0", UserUniqueID.ToString());
				OculusPlatformSpecificID = UserUniqueID.ToString();
				Users.GetOrgScopedID(UserUniqueID).OnComplete(GetOrgUserCallback);
			}
		}

		private void GetOrgUserCallback(Message<OrgScopedID> orgScopeMessage)
		{
			if (orgScopeMessage.IsError)
			{
				Events.UserFetchCompletedEvent userFetchCompletedEvent = new Events.UserFetchCompletedEvent();
				userFetchCompletedEvent.ErrorMsg = $"Oculus Platform | Couldn't fetch org. id: {orgScopeMessage.GetError().Message}";
				EventHub.Publish(userFetchCompletedEvent);
			}
			else
			{
				EncryptionID = orgScopeMessage.Data.ID.ToString();
				Events.UserFetchCompletedEvent userFetchCompletedEvent = new Events.UserFetchCompletedEvent();
				userFetchCompletedEvent.AccountID = "OVR_" + AccountID;
				userFetchCompletedEvent.EncryptionID = EncryptionID;
				EventHub.Publish(userFetchCompletedEvent);
			}
		}

		public void GetUserNonce(Message<UserProof>.Callback callback)
		{
			Users.GetUserProof().OnComplete(callback);
		}

		public override void OnSystemMenuPress(Level level, bool applicationPaused)
		{
			if (level.ContainsFlag(Level.Arena))
			{
				if (!(MonoSingleton<ArenaUI>.Instance == null))
				{
					if (MonoSingleton<ArenaUI>.Instance.IsEndMenuActive)
					{
						MonoSingleton<ArenaUI>.Instance.UpdateEndMenuPosition();
					}
					else if (!applicationPaused)
					{
						MonoSingleton<ArenaUI>.Instance.DisableNotification(force: true);
						MonoSingleton<ArenaUI>.Instance.ToggleMenuActive();
					}
				}
			}
			else if (level == Level.Lobby)
			{
				MonoSingleton<LobbyUI>.Instance.TryCloseOptions();
			}
		}

		[Conditional("UNITY_EDITOR")]
		protected void CreateDefaultEditorController()
		{
		}

		public override void SetPlatformPartyChatActive(bool active)
		{
			Voip.SetSystemVoipSuppressed(!active);
		}
	}
	public abstract class OpenVRPlatform : Platform, IHapticsPlatform, IPlatform
	{
		private const uint GamepadDeviceIndex = 16u;

		private readonly StringBuilder m_inputStringBuilder = new StringBuilder(32);

		private readonly StringBuilder m_knuckleInputStringBuilder = new StringBuilder("knuckles", 32);

		private readonly StringBuilder m_touchInputStringBuilder = new StringBuilder("oculus_touch", 32);

		private readonly StringBuilder m_viveControllerInputStringBuilder = new StringBuilder("vive_controller", 32);

		private readonly StringBuilder m_cosmosInputStringBuilder = new StringBuilder("vive_cosmos_controller", 32);

		private readonly StringBuilder m_windowsMixedRealityInputStringBuilder = new StringBuilder("holographic_controller", 32);

		[SerializeField]
		private Texture m_overrideTexture;

		protected string m_userNamePrefix;

		protected bool m_isUserAllowedToPlay;

		protected bool m_hasInitialized;

		private ControlType m_controlType = ControlType.Gamepad;

		private IPlatformInput m_inputController;

		private IPlatformHaptics m_primaryHaptics;

		private IPlatformHaptics m_secondaryHaptics;

		public override string SignInErrorMessage
		{
			[CompilerGenerated]
			get
			{
				return "Sign-in fail Vive";
			}
		}

		public override bool SupportsPositionalTracking
		{
			[CompilerGenerated]
			get
			{
				return true;
			}
		}

		public override PlatformType Type
		{
			[CompilerGenerated]
			get
			{
				return PlatformType.Viveport;
			}
		}

		public override ControlType ControlType
		{
			[CompilerGenerated]
			get
			{
				return m_controlType;
			}
		}

		public override IReadOnlyList<WandInput> SupportedWandInputs
		{
			[CompilerGenerated]
			get
			{
				return Constants.DefaultPcWandInputs;
			}
		}

		public override bool HasInitialized
		{
			[CompilerGenerated]
			get
			{
				return m_hasInitialized;
			}
		}

		public override float AdjustedHeight
		{
			[CompilerGenerated]
			get
			{
				return (!XRDevice.isPresent) ? (-1.7f) : 0f;
			}
		}

		public override WandGrip DefaultWandGrip
		{
			[CompilerGenerated]
			get
			{
				return (ControlType != ControlType.ViveController) ? WandGrip.Pistol : WandGrip.Wand;
			}
		}

		public override string PistolGripName
		{
			[CompilerGenerated]
			get
			{
				return (ControlType != ControlType.ViveController) ? "Default" : "Alternate";
			}
		}

		public override string WandGripName
		{
			[CompilerGenerated]
			get
			{
				return (ControlType != ControlType.ViveController) ? "Alternate" : "Default";
			}
		}

		public override IPlatformInput CreateInputController()
		{
			bool boolPref = WandsSave.GetBoolPref("P1", defaultValue: true);
			Valve.VR.ETrackedControllerRole eTrackedControllerRole = ((!boolPref) ? Valve.VR.ETrackedControllerRole.LeftHand : Valve.VR.ETrackedControllerRole.RightHand);
			Valve.VR.ETrackedPropertyError pError = Valve.VR.ETrackedPropertyError.TrackedProp_Success;
			m_inputStringBuilder.Clear();
			SteamVR.instance.hmd.GetStringTrackedDeviceProperty(SteamVR.instance.hmd.GetTrackedDeviceIndexForControllerRole(eTrackedControllerRole), Valve.VR.ETrackedDeviceProperty.Prop_ControllerType_String, m_inputStringBuilder, 1024u, ref pError);
			if (m_inputStringBuilder.Equals(m_knuckleInputStringBuilder))
			{
				m_controlType = ControlType.ViveKnuckles;
				m_inputController = new OpenVRInput(eTrackedControllerRole, m_inputStringBuilder);
			}
			else if (m_inputStringBuilder.Equals(m_viveControllerInputStringBuilder))
			{
				m_controlType = ControlType.ViveController;
				m_inputController = new ViveControllerInput(eTrackedControllerRole, m_inputStringBuilder);
				WandsSave.IsDualWieldEnabled = true;
			}
			else if (m_inputStringBuilder.Equals(m_cosmosInputStringBuilder))
			{
				m_controlType = ControlType.ViveCosmos;
				m_inputController = new OpenVRInput(eTrackedControllerRole, m_inputStringBuilder);
			}
			else if (m_inputStringBuilder.Equals(m_touchInputStringBuilder))
			{
				m_controlType = ((!boolPref) ? ControlType.RiftTouchLeft : ControlType.RiftTouchRight);
				m_inputController = new OpenVRInput(eTrackedControllerRole, m_inputStringBuilder);
			}
			else if (m_inputStringBuilder.Equals(m_windowsMixedRealityInputStringBuilder))
			{
				m_controlType = ControlType.WindowsMixedReality;
				m_inputController = new WindowsMixedRealityInput(eTrackedControllerRole, m_inputStringBuilder);
			}
			else
			{
				m_controlType = ControlType.Gamepad;
				m_inputController = CreateDefaultInput();
			}
			CreateViveHapticsController();
			return m_inputController;
		}

		private IPlatformInput CreateDefaultInput()
		{
			if (SteamVR.instance.hmd.IsTrackedDeviceConnected(16u))
			{
				return new OpenVRGamepadInput();
			}
			WandsLogger.LogError($"<{m_inputStringBuilder.ToString()}> not recognized as input system, using default");
			return new MouseInput();
		}

		public override void OnSystemMenuPress(Level level, bool applicationPaused)
		{
			switch (level)
			{
			case Level.Unknown:
			case Level.MainMenu:
			case Level.Workshop:
			case Level.Lobby:
				return;
			}
			if (!(MonoSingleton<ArenaUI>.Instance == null))
			{
				if (MonoSingleton<ArenaUI>.Instance.IsEndMenuActive)
				{
					MonoSingleton<ArenaUI>.Instance.UpdateEndMenuPosition();
				}
				else if (!applicationPaused)
				{
					MonoSingleton<ArenaUI>.Instance.DisableNotification(force: true);
					MonoSingleton<ArenaUI>.Instance.ToggleMenuActive(enable: true);
				}
			}
		}

		protected void SetOverride()
		{
			if (m_overrideTexture == null)
			{
				return;
			}
			Valve.VR.CVRCompositor compositor = Valve.VR.OpenVR.Compositor;
			if (compositor != null)
			{
				Valve.VR.Texture_t[] array = new Valve.VR.Texture_t[6];
				for (int i = 0; i < 6; i++)
				{
					array[i].handle = ((!(m_overrideTexture != null)) ? IntPtr.Zero : m_overrideTexture.GetNativeTexturePtr());
					array[i].eType = Valve.VR.ETextureType.DirectX;
					array[i].eColorSpace = Valve.VR.EColorSpace.Auto;
				}
				if (compositor.SetSkyboxOverride(array) == Valve.VR.EVRCompositorError.None)
				{
				}
			}
		}

		protected void ClearOverride()
		{
			Valve.VR.OpenVR.Compositor?.ClearSkyboxOverride();
		}

		private void CreateViveHapticsController()
		{
			m_primaryHaptics = new ViveHapticsController();
			m_primaryHaptics.InitializeHaptics(this);
			m_secondaryHaptics = new ViveHapticsController();
			m_secondaryHaptics.InitializeHaptics(this);
		}

		public void UpdatePrimaryHand(bool primaryIsRight)
		{
			if (m_primaryHaptics != null)
			{
				m_primaryHaptics.UpdatePrimaryChannel(primaryIsRight);
			}
			if (m_secondaryHaptics != null)
			{
				m_secondaryHaptics.UpdatePrimaryChannel(!primaryIsRight);
			}
		}

		public void TriggerHaptics(HapticsData hapticsData, bool overrideCurrent, WandHand wandHand)
		{
			VibrateController vibrateController = hapticsData.Controller;
			if (vibrateController == VibrateController.Primary && wandHand == WandHand.Left)
			{
				vibrateController = VibrateController.Secondary;
			}
			switch (vibrateController)
			{
			case VibrateController.Primary:
				if (m_primaryHaptics != null)
				{
					m_primaryHaptics.StartHaptics(hapticsData, overrideCurrent, wandHand);
				}
				break;
			case VibrateController.Secondary:
				if (m_secondaryHaptics != null)
				{
					m_secondaryHaptics.StartHaptics(hapticsData, overrideCurrent, wandHand);
				}
				break;
			case VibrateController.Both:
			case VibrateController.GamePad:
				if (m_primaryHaptics != null)
				{
					m_primaryHaptics.StartHaptics(hapticsData, overrideCurrent, wandHand);
				}
				if (m_secondaryHaptics != null)
				{
					m_secondaryHaptics.StartHaptics(hapticsData, overrideCurrent, wandHand);
				}
				break;
			}
		}

		public void CancelHaptics(VibrateController controller, WandHand wandHand = WandHand.Right)
		{
			if (controller == VibrateController.Primary && wandHand == WandHand.Left)
			{
				controller = VibrateController.Secondary;
			}
			switch (controller)
			{
			case VibrateController.Primary:
				if (m_primaryHaptics != null)
				{
					m_primaryHaptics.CancelHaptics();
				}
				break;
			case VibrateController.Secondary:
				if (m_secondaryHaptics != null)
				{
					m_secondaryHaptics.CancelHaptics();
				}
				break;
			case VibrateController.Both:
			case VibrateController.GamePad:
				if (m_primaryHaptics != null)
				{
					m_primaryHaptics.CancelHaptics();
				}
				if (m_secondaryHaptics != null)
				{
					m_secondaryHaptics.CancelHaptics();
				}
				break;
			}
		}
	}
	public class PicoNeo2Platform : PicoPlatform
	{
		public override PlatformType Type
		{
			[CompilerGenerated]
			get
			{
				return PlatformType.PicoNeo2;
			}
		}

		public override bool SupportsPositionalTracking
		{
			[CompilerGenerated]
			get
			{
				return true;
			}
		}

		public override WandGrip DefaultWandGrip
		{
			[CompilerGenerated]
			get
			{
				return WandGrip.Pistol;
			}
		}

		public override IReadOnlyList<WandInput> SupportedWandInputs
		{
			[CompilerGenerated]
			get
			{
				return Constants.DefaultPcWandInputs;
			}
		}

		public override void InitializeCore()
		{
			base.InitializeCore();
			m_controlType = ControlType.PicoNeo2;
		}

		public override IPlatformInput CreateInputController()
		{
			m_inputController = new PicoNeo2Input();
			return m_inputController;
		}

		public override void OnSystemMenuPress(Level level, bool applicationPaused)
		{
			if ((level & Level.Arena) != 0)
			{
				if (!(MonoSingleton<ArenaUI>.Instance == null))
				{
					if (MonoSingleton<ArenaUI>.Instance.IsEndMenuActive)
					{
						MonoSingleton<ArenaUI>.Instance.UpdateEndMenuPosition();
					}
					else if (!applicationPaused)
					{
						MonoSingleton<ArenaUI>.Instance.DisableNotification(force: true);
						MonoSingleton<ArenaUI>.Instance.ToggleMenuActive(enable: true);
					}
				}
			}
			else if (level == Level.Lobby)
			{
				MonoSingleton<LobbyUI>.Instance.TryCloseOptions();
			}
		}
	}
	public class PicoPlatform : Platform
	{
		private static readonly IReadOnlyList<WandInput> sm_picoWandInputs = new List<WandInput> { WandInput.Point };

		protected ControlType m_controlType = ControlType.Pico;

		protected IPlatformInput m_inputController;

		private bool m_hasInitialized;

		public override PlatformType Type
		{
			[CompilerGenerated]
			get
			{
				return PlatformType.Pico;
			}
		}

		public override ControlType ControlType
		{
			[CompilerGenerated]
			get
			{
				return m_controlType;
			}
		}

		public override IReadOnlyList<WandInput> SupportedWandInputs
		{
			[CompilerGenerated]
			get
			{
				return sm_picoWandInputs;
			}
		}

		public override bool HasInitialized
		{
			[CompilerGenerated]
			get
			{
				return m_hasInitialized;
			}
		}

		public override string SignInErrorMessage
		{
			[CompilerGenerated]
			get
			{
				return "Sign-in fail Oculus";
			}
		}

		public override bool SupportsPositionalTracking
		{
			[CompilerGenerated]
			get
			{
				return false;
			}
		}

		public override WandGrip DefaultWandGrip
		{
			[CompilerGenerated]
			get
			{
				return WandGrip.Wand;
			}
		}

		protected override void OnDestroy()
		{
			WandsSave.Save();
			Callback.OnLoginCallback -= LoginUserCallback;
			Callback.OnUserInfoCallback -= UserInfoCallback;
		}

		public override void InitializeCore()
		{
			base.gameObject.SetActive(value: true);
		}

		public override void FetchLoggedInUser()
		{
			EncryptionID = SystemInfo.deviceUniqueIdentifier;
			AccountID = ("P_" + EncryptionID).Substring(0, 20);
			Callback.OnLoginCallback += LoginUserCallback;
			PicoPaymentSDK.Login();
		}

		public void LoginUserCallback(string errorMessage)
		{
			Callback.OnLoginCallback -= LoginUserCallback;
			m_hasInitialized = true;
			if (string.IsNullOrEmpty(errorMessage))
			{
				Callback.OnUserInfoCallback += UserInfoCallback;
				PicoPaymentSDK.GetUserAPI();
			}
			else
			{
				Events.UserFetchCompletedEvent userFetchCompletedEvent = new Events.UserFetchCompletedEvent();
				userFetchCompletedEvent.ErrorMsg = $"{Type} couldn't log in user {errorMessage}.";
				EventHub.Publish(userFetchCompletedEvent);
			}
		}

		public void UserInfoCallback(string username, string openid)
		{
			Callback.OnUserInfoCallback -= UserInfoCallback;
			if (string.IsNullOrEmpty(username) || string.IsNullOrEmpty(openid))
			{
				Events.UserFetchCompletedEvent userFetchCompletedEvent = new Events.UserFetchCompletedEvent();
				userFetchCompletedEvent.ErrorMsg = $"{Type} couldn't retrieve user info.";
				EventHub.Publish(userFetchCompletedEvent);
			}
			else
			{
				GetUserCallback(username, openid);
			}
		}

		public static bool IsEmail(string email)
		{
			if (email != null)
			{
				return Regex.IsMatch(email, "^(([\\w-]+\\.)+[\\w-]+|([a-zA-Z]{1}|[\\w-]{2,}))@((([0-1]?[0-9]{1,2}|25[0-5]|2[0-4][0-9])\\.([0-1]?[0-9]{1,2}|25[0-5]|2[0-4][0-9])\\.([0-1]?[0-9]{1,2}|25[0-5]|2[0-4][0-9])\\.([0-1]?[0-9]{1,2}|25[0-5]|2[0-4][0-9])){1}|([a-zA-Z]+[\\w-]+\\.)+[a-zA-Z]{2,4})$");
			}
			return false;
		}

		private void GetUserCallback(string username, string openid)
		{
			if (IsEmail(username))
			{
				int startIndex = username.IndexOf('@');
				AccountID = username.Remove(startIndex);
			}
			else
			{
				AccountID = username;
			}
			EncryptionID = openid;
			PlayerProperty.Set("P0", EncryptionID);
			Events.UserFetchCompletedEvent userFetchCompletedEvent = new Events.UserFetchCompletedEvent();
			userFetchCompletedEvent.AccountID = "P_" + AccountID;
			userFetchCompletedEvent.EncryptionID = EncryptionID;
			EventHub.Publish(userFetchCompletedEvent);
		}

		public override IPlatformInput CreateInputController()
		{
			if (GameControl.Instance.IsCurrentLevel(Level.MainMenu))
			{
				m_inputController = new GoblinInputSwipe();
			}
			else
			{
				m_inputController = new GoblinInputPoint();
			}
			return m_inputController;
		}

		public override void OnSystemMenuPress(Level level, bool applicationPaused)
		{
		}
	}
	public abstract class Platform : MonoBehaviour, IPlatform
	{
		protected IAPController m_iapController;

		public abstract bool HasInitialized { get; }

		public abstract bool SupportsPositionalTracking { get; }

		public abstract PlatformType Type { get; }

		public abstract string SignInErrorMessage { get; }

		public abstract ControlType ControlType { get; }

		public abstract IReadOnlyList<WandInput> SupportedWandInputs { get; }

		public abstract WandGrip DefaultWandGrip { get; }

		public virtual string AccountID { get; set; }

		public virtual string EncryptionID { get; set; }

		public virtual ulong UserUniqueID { get; set; }

		public virtual float AdjustedHeight
		{
			[CompilerGenerated]
			get
			{
				return -1.7f;
			}
		}

		public virtual string PistolGripName
		{
			[CompilerGenerated]
			get
			{
				return "Alternate";
			}
		}

		public virtual string WandGripName
		{
			[CompilerGenerated]
			get
			{
				return "Default";
			}
		}

		public virtual string PlatformName
		{
			[CompilerGenerated]
			get
			{
				return Type.ToString();
			}
		}

		public abstract void InitializeCore();

		public abstract void OnSystemMenuPress(Level level, bool applicationPaused);

		public abstract void FetchLoggedInUser();

		public abstract IPlatformInput CreateInputController();

		public CharacterType[] GetAllCharacters()
		{
			return GetBaseCharactersNonAlloc().Concat(GetSpecialCharactersNonAlloc()).ToArray();
		}

		public ISet<CharacterType> GetBaseCharactersNonAlloc()
		{
			return Constants.BaseCharacters;
		}

		public ISet<CharacterType> GetSpecialCharactersNonAlloc()
		{
			return Constants.SpecialCharacters;
		}

		public virtual IList<Language> GetAvailableLanguages()
		{
			return Constants.BaseLanguages;
		}

		private void OnApplicationQuit()
		{
			WandsSave.Save();
		}

		protected virtual void OnDestroy()
		{
			WandsSave.Save();
		}

		public virtual void OnHomeButtonHold()
		{
		}

		public virtual void CheckEntitlement()
		{
		}

		public virtual void SetPlatformPartyChatActive(bool active)
		{
		}

		public void CreateIAPController(Action completed)
		{
			m_iapController = null;
			completed();
		}

		public GameAccess GetGameAccess()
		{
			if (m_iapController == null || m_iapController.HasFullGameReceipt())
			{
				return GameAccess.Full;
			}
			return GameAccess.Free;
		}

		public void BuyFullGame()
		{
		}

		public string GetFullGamePrice()
		{
			return "<TEST VALUE>";
		}

		public virtual void TryPlayOnline(Action<bool> onCheckComplete, bool requireMultiplayerFeatures = true)
		{
			CheckOnlineFeatureParentalAccess(delegate(bool parentalAccess)
			{
				if (parentalAccess)
				{
					if (requireMultiplayerFeatures)
					{
						CheckMultiPlayerAccess(delegate(bool multiplayerAccess)
						{
							onCheckComplete?.Invoke(multiplayerAccess);
						});
					}
					else
					{
						onCheckComplete?.Invoke(obj: true);
					}
				}
				else
				{
					onCheckComplete?.Invoke(obj: false);
				}
			});
		}

		public virtual void FilterStrings(string[] values, Action<string[]> onComplete)
		{
			onComplete?.Invoke(values);
		}

		public virtual void FilterStrings(IList<string> values, Action<string[]> onComplete)
		{
			onComplete?.Invoke(values.ToArray());
		}

		public virtual void FilterString(string value, Action<string> onComplete)
		{
			onComplete?.Invoke(value);
		}

		public virtual void CheckOnlineServiceAccess(Action<bool> onCheckComplete)
		{
			onCheckComplete?.Invoke(obj: true);
		}

		public virtual void CheckMultiPlayerAccess(Action<bool> onCheckComplete)
		{
			onCheckComplete?.Invoke(obj: true);
		}

		public virtual void CheckOnlineFeatureParentalAccess(Action<bool> onCheckComplete)
		{
			onCheckComplete?.Invoke(obj: true);
		}

		public virtual void CheckVoiceChatAccess(Action<bool> onCheckComplete, bool displayErrorMessageOnFailure = true)
		{
			onCheckComplete?.Invoke(obj: true);
		}

		public virtual void GetAuthCode(Action<string, int> onSuccess, Action<string> onFailure)
		{
			onSuccess?.Invoke(string.Empty, 0);
		}

		private IEnumerator AfterDelay(float delay, Action action)
		{
			yield return new WaitForSeconds(delay);
			action();
		}
	}
	public class PlatformLoader : MonoBehaviour
	{
		private static WandsBuildSettings sm_buildSettings;

		private static AssetHandler sm_assetHandler;

		[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
		public static void InitPlatformLoading()
		{
			sm_buildSettings = Resources.Load<WandsBuildSettings>("WandsBuildSettings");
			PlatformLoader platformLoader = new GameObject("PlatformLoader").AddComponent<PlatformLoader>();
			sm_assetHandler = new GameObject("AssetHandler").AddComponent<AssetHandler>();
			platformLoader.LoadPlatformBundles();
		}

		public void LoadPlatformBundles()
		{
			sm_assetHandler.LoadPlatformAssetBundle(sm_buildSettings.Platform, PlatformBundleLoaded);
		}

		public void PlatformBundleLoaded(bool loadedSuccessfully)
		{
			if (!loadedSuccessfully)
			{
				throw new UnityException("Platform bundle failed to load");
			}
			InstantiateGameControl(InstantiatePlatform(sm_buildSettings.Platform));
		}

		[Conditional("UNITY_EDITOR")]
		private void TryLoadFromAnyScene()
		{
		}

		private Platform InstantiatePlatform(PlatformType type)
		{
			GameObject gameObject = sm_assetHandler.LoadAsset<GameObject>(AssetBundleType.Platform, $"{type}Platform", type);
			if (gameObject == null)
			{
				throw new ArgumentException("Platform Asset could not be found for Platform: " + type);
			}
			GameObject gameObject2 = UnityEngine.Object.Instantiate(gameObject);
			UnityEngine.Object.DontDestroyOnLoad(gameObject2);
			Platform component = gameObject2.GetComponent<Platform>();
			component.InitializeCore();
			return component;
		}

		private void InstantiateGameControl(Platform platform)
		{
			UnityEngine.Object @object = Resources.Load("_GameControl_");
			if (@object == null)
			{
				throw new NullReferenceException("GameControl Resource is missing to setup the game control properly!");
			}
			GameObject gameObject = UnityEngine.Object.Instantiate(@object, Vector3.zero, Quaternion.identity) as GameObject;
			sm_assetHandler.transform.SetParent(gameObject.transform);
			UnityEngine.Object.DontDestroyOnLoad(gameObject);
			GameControl.Instance.PlatformSettings = sm_buildSettings;
			GameControl.Instance.Platform = platform;
			GameControl.Instance.AssetHandler = sm_assetHandler;
			GameControl.Instance.SpawnPlayerControl();
		}
	}
	public class PlatformSupport
	{
		public DateTime? Date;
	}
	public static class PlatformSupportControl
	{
		private static PlatformSupport sm_platformSupport;

		public static void Initialize(PlatformSupport platformSupport)
		{
			if (sm_platformSupport != null)
			{
				throw new InvalidOperationException($"The PlatformSupport object is already set for PlatformType {GameControl.Instance.Platform.Type}; why are you trying to set it again?");
			}
			sm_platformSupport = platformSupport;
			if (sm_platformSupport == null)
			{
				throw new NotImplementedException($"PlatformType not implemented: {GameControl.Instance.Platform.Type}");
			}
		}

		public static bool HasDeprecationDate()
		{
			return sm_platformSupport.Date.HasValue;
		}

		public static DateTime GetDate()
		{
			if (sm_platformSupport == null)
			{
				throw new NullReferenceException($"The PlatformSupport object is not set for PlatformType {GameControl.Instance.Platform.Type}");
			}
			if (!sm_platformSupport.Date.HasValue)
			{
				throw new InvalidOperationException(string.Format("You are trying to get the deprecation date from a null value; please validate the value first with {0}", "HasDeprecationDate"));
			}
			return sm_platformSupport.Date.Value;
		}
	}
	public class PlayStationPlatform : Platform, IAchievementPlatform
	{
		public enum AccessStatus : byte
		{
			Unchecked,
			HasAccess,
			DoesntHaveAccess
		}

		public static class VrDeviceNames
		{
			public const string None = "None";

			public const string Unknown = "Unknown";

			public const string PlayStationVr = "PlayStationVR";
		}

		private enum HmdStatus
		{
			Off,
			On,
			Booting,
			ShuttingDown
		}

		private enum Controller
		{
			None,
			DualShock,
			Move
		}

		private static readonly List<WandInput> sm_supportedWandInputs = new List<WandInput>
		{
			WandInput.Stick,
			WandInput.Press
		};

		private const float SignInDialogShowDelay = 2f;

		private const int PsPlusFeatureNotifyInterval = 1;

		private const int Ps4InputSlots = 4;

		[SerializeField]
		private InControlManager m_inControl;

		private const float RenderScale = 1.4f;

		private float m_sinceLastPlusFeatureNotify;

		private bool m_hasInitialized;

		private Controller m_pluggedControllerType;

		private PlayStationDualShockInput m_dualShockInput;

		private PlayStationMotionControllerInput m_moveInput;

		public override bool HasInitialized
		{
			[CompilerGenerated]
			get
			{
				return m_hasInitialized;
			}
		}

		public override bool SupportsPositionalTracking
		{
			[CompilerGenerated]
			get
			{
				return true;
			}
		}

		public override PlatformType Type
		{
			[CompilerGenerated]
			get
			{
				return PlatformType.PlayStation;
			}
		}

		public override string SignInErrorMessage
		{
			[CompilerGenerated]
			get
			{
				return string.Empty;
			}
		}

		public override ControlType ControlType => m_pluggedControllerType switch
		{
			Controller.DualShock => ControlType.PlayStationDualShock, 
			Controller.Move => ControlType.PlayStationMotion, 
			_ => ControlType.PlayStationDualShock, 
		};

		public override IReadOnlyList<WandInput> SupportedWandInputs => sm_supportedWandInputs;

		public override WandGrip DefaultWandGrip => WandGrip.Wand;

		public IAchievementHandler AchievementHandler { get; private set; }

		public static bool IsControllerConnectedAndValidated { get; private set; }

		private void Start()
		{
			m_dualShockInput = new PlayStationDualShockInput();
			bool boolPref = WandsSave.GetBoolPref("P1", defaultValue: true);
			m_moveInput = new PlayStationMotionControllerInput((!boolPref) ? 1 : 0);
		}

		public override IPlatformInput CreateInputController()
		{
			if (m_pluggedControllerType == Controller.None)
			{
				if (m_dualShockInput.IsControllerPlugged)
				{
					return CreateDualShockInput();
				}
				if (m_moveInput.IsControllerPlugged)
				{
					return CreateMoveInput();
				}
				m_pluggedControllerType = Controller.DualShock;
				InputEvents.ControllerConnectionStatusChanged controllerConnectionStatusChanged = new InputEvents.ControllerConnectionStatusChanged();
				controllerConnectionStatusChanged.IsConnected = false;
				EventHub.Publish(controllerConnectionStatusChanged);
				IsControllerConnectedAndValidated = false;
			}
			else if (m_pluggedControllerType == Controller.DualShock && m_dualShockInput.IsValidated && !m_dualShockInput.IsControllerPlugged)
			{
				InputEvents.ControllerConnectionStatusChanged controllerConnectionStatusChanged = new InputEvents.ControllerConnectionStatusChanged();
				controllerConnectionStatusChanged.IsConnected = false;
				EventHub.Publish(controllerConnectionStatusChanged);
				m_dualShockInput.IsValidated = false;
				IsControllerConnectedAndValidated = false;
			}
			else if (m_pluggedControllerType == Controller.Move)
			{
				if (m_moveInput.IsValidated && !m_moveInput.IsControllerPlugged)
				{
					InputEvents.ControllerConnectionStatusChanged controllerConnectionStatusChanged = new InputEvents.ControllerConnectionStatusChanged();
					controllerConnectionStatusChanged.IsConnected = false;
					EventHub.Publish(controllerConnectionStatusChanged);
					m_moveInput.IsValidated = false;
					IsControllerConnectedAndValidated = false;
				}
				else if (IsControllerConnectedAndValidated)
				{
					CreateMoveInput();
				}
			}
			if (Input.GetKey(KeyCode.Joystick1Button0))
			{
				CreateDualShockInput();
				InputEvents.ControllerConnectionStatusChanged controllerConnectionStatusChanged = new InputEvents.ControllerConnectionStatusChanged();
				controllerConnectionStatusChanged.IsConnected = true;
				EventHub.Publish(controllerConnectionStatusChanged);
			}
			else if (PlayStationMoveHandler.GetButtonInputStateRaw(PlayStationMoveHandler.MoveInput.Cross, 0) || PlayStationMoveHandler.GetButtonInputStateRaw(PlayStationMoveHandler.MoveInput.Cross, 1))
			{
				CreateMoveInput();
				InputEvents.ControllerConnectionStatusChanged controllerConnectionStatusChanged = new InputEvents.ControllerConnectionStatusChanged();
				controllerConnectionStatusChanged.IsConnected = true;
				EventHub.Publish(controllerConnectionStatusChanged);
			}
			return m_pluggedControllerType switch
			{
				Controller.DualShock => m_dualShockInput, 
				Controller.Move => m_moveInput, 
				_ => m_dualShockInput, 
			};
		}

		private IPlatformInput CreateDualShockInput()
		{
			m_pluggedControllerType = Controller.DualShock;
			m_inControl.enabled = true;
			m_dualShockInput.IsValidated = true;
			m_moveInput.IsValidated = false;
			IsControllerConnectedAndValidated = true;
			return m_dualShockInput;
		}

		private IPlatformInput CreateMoveInput()
		{
			bool boolPref = WandsSave.GetBoolPref("P1", defaultValue: true);
			m_moveInput = new PlayStationMotionControllerInput((!boolPref) ? 1 : 0);
			m_pluggedControllerType = Controller.Move;
			m_inControl.enabled = false;
			m_dualShockInput.IsValidated = false;
			m_moveInput.IsValidated = true;
			IsControllerConnectedAndValidated = true;
			return m_moveInput;
		}

		public override void FetchLoggedInUser()
		{
		}

		public override void InitializeCore()
		{
		}

		public override void OnSystemMenuPress(Level level, bool applicationPaused)
		{
			if ((level & Level.Arena) != 0)
			{
				if (!(MonoSingleton<ArenaUI>.Instance == null))
				{
					if (MonoSingleton<ArenaUI>.Instance.IsEndMenuActive)
					{
						MonoSingleton<ArenaUI>.Instance.UpdateEndMenuPosition();
					}
					else if (!applicationPaused)
					{
						MonoSingleton<ArenaUI>.Instance.DisableNotification(force: true);
						MonoSingleton<ArenaUI>.Instance.ToggleMenuActive(enable: true);
					}
				}
			}
			else if (level == Level.Lobby)
			{
				MonoSingleton<LobbyUI>.Instance.TryCloseOptions();
			}
		}
	}
	public class QuestPlatform : OculusAndroidPlatform, IHapticsPlatform, IPlatform
	{
		private IPlatformHaptics m_primaryHaptics;

		private IPlatformHaptics m_secondaryHaptics;

		private WorkshopTile m_currentWorkshopTile;

		private EventToken m_workshopTileChangedEventToken;

		public override string PlatformName
		{
			[CompilerGenerated]
			get
			{
				return Type.ToString();
			}
		}

		public override PlatformType Type
		{
			[CompilerGenerated]
			get
			{
				return PlatformType.Quest;
			}
		}

		public override bool SupportsPositionalTracking
		{
			[CompilerGenerated]
			get
			{
				return true;
			}
		}

		public override WandGrip DefaultWandGrip
		{
			[CompilerGenerated]
			get
			{
				return WandGrip.Pistol;
			}
		}

		public override IReadOnlyList<WandInput> SupportedWandInputs
		{
			[CompilerGenerated]
			get
			{
				return Constants.DefaultPcWandInputs;
			}
		}

		protected override void OnEnable()
		{
			m_workshopTileChangedEventToken = EventHub.Subscribe<Events.WorkshopTileChangedEvent>(OnWorkshopTileChanged);
		}

		protected override void OnDisable()
		{
			base.OnDisable();
			EventHub.Unsubscribe<Events.WorkshopTileChangedEvent>(m_workshopTileChangedEventToken);
		}

		private void Update()
		{
			if (!(GameControl.Instance == null) && !(GameControl.Instance.PlayerControl == null) && OVRInput.GetControllerWasRecentered(OVRInput.Controller.Touch) && !GameControl.Instance.IsCurrentLevel(Level.Arena))
			{
				Quaternion rotation = Quaternion.identity;
				if (GameControl.Instance.IsCurrentLevel(Level.Lobby))
				{
					rotation = Quaternion.Euler(0f, 180f, 0f);
				}
				else if (GameControl.Instance.IsCurrentLevel(Level.Workshop))
				{
					rotation = m_currentWorkshopTile.transform.rotation;
				}
				GameControl.Instance.PlayerControl.CameraTransform.rotation = rotation;
				GameControl.Instance.PlayerControl.CameraRigTransform.rotation = rotation;
			}
		}

		private void OnWorkshopTileChanged(Events.WorkshopTileChangedEvent eventData)
		{
			m_currentWorkshopTile = eventData.NewTile;
		}

		public override IPlatformInput CreateInputController()
		{
			CreateTouchHapticsController();
			CreateDefaultQuestController();
			return m_inputController;
		}

		private void CreateTouchHapticsController()
		{
			m_primaryHaptics = new QuestHapticsController(0.35f, 0.7f, 1f, 0.5f);
			m_primaryHaptics.InitializeHaptics(this);
			m_secondaryHaptics = new QuestHapticsController(0.35f, 0.7f, 1f, 0.5f);
			m_secondaryHaptics.InitializeHaptics(this);
		}

		public void UpdatePrimaryHand(bool primaryIsRight)
		{
			if (m_primaryHaptics != null)
			{
				m_primaryHaptics.UpdatePrimaryChannel(primaryIsRight);
			}
			if (m_secondaryHaptics != null)
			{
				m_secondaryHaptics.UpdatePrimaryChannel(!primaryIsRight);
			}
		}

		public void TriggerHaptics(HapticsData hapticsData, bool overrideCurrent, WandHand wandHand)
		{
			VibrateController vibrateController = hapticsData.Controller;
			if (vibrateController == VibrateController.Primary && wandHand == WandHand.Left)
			{
				vibrateController = VibrateController.Secondary;
			}
			switch (vibrateController)
			{
			case VibrateController.Primary:
				if (m_primaryHaptics != null)
				{
					m_primaryHaptics.StartHaptics(hapticsData, overrideCurrent, wandHand);
				}
				break;
			case VibrateController.Secondary:
				if (m_secondaryHaptics != null)
				{
					m_secondaryHaptics.StartHaptics(hapticsData, overrideCurrent, wandHand);
				}
				break;
			case VibrateController.Both:
			case VibrateController.GamePad:
				if (m_primaryHaptics != null)
				{
					m_primaryHaptics.StartHaptics(hapticsData, overrideCurrent, wandHand);
				}
				if (m_secondaryHaptics != null)
				{
					m_secondaryHaptics.StartHaptics(hapticsData, overrideCurrent, wandHand);
				}
				break;
			}
		}

		public void CancelHaptics(VibrateController controller, WandHand wandHand = WandHand.Right)
		{
			if (controller == VibrateController.Primary && wandHand == WandHand.Left)
			{
				controller = VibrateController.Secondary;
			}
			switch (controller)
			{
			case VibrateController.Primary:
				if (m_primaryHaptics != null)
				{
					m_primaryHaptics.CancelHaptics();
				}
				break;
			case VibrateController.Secondary:
				if (m_secondaryHaptics != null)
				{
					m_secondaryHaptics.CancelHaptics();
				}
				break;
			case VibrateController.Both:
			case VibrateController.GamePad:
				if (m_primaryHaptics != null)
				{
					m_primaryHaptics.CancelHaptics();
				}
				if (m_secondaryHaptics != null)
				{
					m_secondaryHaptics.CancelHaptics();
				}
				break;
			}
		}
	}
	public class RiftPlatform : OculusPlatform, IHapticsPlatform, IPlatform
	{
		private IPlatformHaptics m_primaryHaptics;

		private IPlatformHaptics m_secondaryHaptics;

		public override PlatformType Type
		{
			[CompilerGenerated]
			get
			{
				return PlatformType.Rift;
			}
		}

		public override float AdjustedHeight
		{
			[CompilerGenerated]
			get
			{
				return (!OVRManager.isHmdPresent) ? (-1.7f) : 0f;
			}
		}

		public override bool SupportsPositionalTracking
		{
			[CompilerGenerated]
			get
			{
				return true;
			}
		}

		public override WandGrip DefaultWandGrip
		{
			[CompilerGenerated]
			get
			{
				return WandGrip.Pistol;
			}
		}

		public override IPlatformInput CreateInputController()
		{
			m_controlType = ControlType.Gamepad;
			if (OVRInput.IsControllerConnected(OVRInput.Controller.LTouch) || OVRInput.IsControllerConnected(OVRInput.Controller.RTouch))
			{
				bool boolPref = WandsSave.GetBoolPref("P1", defaultValue: true);
				m_controlType = ((!boolPref) ? ControlType.RiftTouchLeft : ControlType.RiftTouchRight);
				m_inputController = new RiftInput((!boolPref) ? OVRInput.Controller.LTouch : OVRInput.Controller.RTouch);
				CreateTouchHapticsController();
			}
			else if (OVRInput.IsControllerConnected(OVRInput.Controller.Gamepad))
			{
				m_inputController = new OculusGamepadInput();
			}
			else
			{
				m_inputController = new MouseInput();
			}
			return m_inputController;
		}

		private void CreateTouchHapticsController()
		{
			m_primaryHaptics = new OculusTouchHapticsController(32, 128, byte.MaxValue);
			m_primaryHaptics.InitializeHaptics(this);
			m_secondaryHaptics = new OculusTouchHapticsController(32, 128, byte.MaxValue);
			m_secondaryHaptics.InitializeHaptics(this);
		}

		public void UpdatePrimaryHand(bool primaryIsRight)
		{
			if (m_primaryHaptics != null)
			{
				m_primaryHaptics.UpdatePrimaryChannel(primaryIsRight);
			}
			if (m_secondaryHaptics != null)
			{
				m_secondaryHaptics.UpdatePrimaryChannel(!primaryIsRight);
			}
		}

		public void TriggerHaptics(HapticsData hapticsData, bool overrideCurrent, WandHand wandHand)
		{
			VibrateController vibrateController = hapticsData.Controller;
			if (vibrateController == VibrateController.Primary && wandHand == WandHand.Left)
			{
				vibrateController = VibrateController.Secondary;
			}
			switch (vibrateController)
			{
			case VibrateController.Primary:
				if (m_primaryHaptics != null)
				{
					m_primaryHaptics.StartHaptics(hapticsData, overrideCurrent, wandHand);
				}
				break;
			case VibrateController.Secondary:
				if (m_secondaryHaptics != null)
				{
					m_secondaryHaptics.StartHaptics(hapticsData, overrideCurrent, wandHand);
				}
				break;
			case VibrateController.Both:
			case VibrateController.GamePad:
				if (m_primaryHaptics != null)
				{
					m_primaryHaptics.StartHaptics(hapticsData, overrideCurrent, wandHand);
				}
				if (m_secondaryHaptics != null)
				{
					m_secondaryHaptics.StartHaptics(hapticsData, overrideCurrent, wandHand);
				}
				break;
			}
		}

		public void CancelHaptics(VibrateController controller, WandHand wandHand = WandHand.Right)
		{
			if (controller == VibrateController.Primary && wandHand == WandHand.Left)
			{
				controller = VibrateController.Secondary;
			}
			switch (controller)
			{
			case VibrateController.Primary:
				if (m_primaryHaptics != null)
				{
					m_primaryHaptics.CancelHaptics();
				}
				break;
			case VibrateController.Secondary:
				if (m_secondaryHaptics != null)
				{
					m_secondaryHaptics.CancelHaptics();
				}
				break;
			case VibrateController.Both:
			case VibrateController.GamePad:
				if (m_primaryHaptics != null)
				{
					m_primaryHaptics.CancelHaptics();
				}
				if (m_secondaryHaptics != null)
				{
					m_secondaryHaptics.CancelHaptics();
				}
				break;
			}
		}
	}
}
namespace Cortopia.Scripts.Platform
{
	public class SteamPlatform : OpenVRPlatform
	{
		public override void FetchLoggedInUser()
		{
		}

		public override void InitializeCore()
		{
		}
	}
	public class TrackedPlayStationDevices : MonoBehaviour
	{
		[Serializable]
		public class TrackedDevice
		{
			public int handle = -1;

			public Transform transform;

			public Renderer light;

			public Vector3 position = Vector3.zero;

			public Quaternion orientation = Quaternion.identity;
		}

		[Flags]
		public enum TrackedDevicesType
		{
			DualShock4 = 1,
			Aim = 2,
			Move = 4
		}

		public TrackedDevicesType trackedDevicesType = TrackedDevicesType.Move;

		[SerializeField]
		private TrackedDevice deviceMovePrimary;

		[SerializeField]
		private TrackedDevice deviceMoveSecondary;
	}
}
namespace Assets.Scripts.Platform
{
	public class TrailRendererAssetMaterialChanger : MonoBehaviour
	{
		private void Awake()
		{
			if (!GameControl.Instance.Platform.Type.ContainsFlag(PlatformTarget.Android))
			{
				ParticleSystem component = GetComponent<ParticleSystem>();
				ParticleSystemRenderer component2 = component.GetComponent<ParticleSystemRenderer>();
				component2.trailMaterial = GameControl.Instance.AssetHandler.ReplaceMaterial(component2.trailMaterial);
			}
		}
	}
	public class ViveportLicenseChecker : Viveport.Api.LicenseChecker
	{
		public Action<string> OnCompleted { get; }

		public ViveportLicenseChecker(Action<string> onCompleted)
		{
			OnCompleted = onCompleted;
		}

		public override void OnSuccess(long issueTime, long expirationTime, int latestVersion, bool updateRequired)
		{
			Viveport.Core.Logger.Log("[MyLicenseChecker] issueTime: " + issueTime);
			Viveport.Core.Logger.Log("[MyLicenseChecker] expirationTime: " + expirationTime);
			Viveport.Core.Logger.Log("[MyLicenseChecker] latestVersion: " + latestVersion);
			Viveport.Core.Logger.Log("[MyLicenseChecker] updateRequired: " + updateRequired);
			OnCompleted(string.Empty);
		}

		public override void OnFailure(int errorCode, string errorMessage)
		{
			Viveport.Core.Logger.Log("[MyLicenseChecker] errorCode: " + errorCode);
			Viveport.Core.Logger.Log("[MyLicenseChecker] errorMessage: " + errorMessage);
			OnCompleted(errorMessage);
		}
	}
	public class ViveportPlatform : OpenVRPlatform
	{
		private static readonly string sm_appId = "629c8dbe-93e2-4984-ba38-4db4a1337074";

		private static readonly string sm_apiKey = "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCCWECnH0ruwzrYD5nEK/1Rtwe8fYSCjihkVi0oT/uGeu6a+PrFxFRNBqod3CxyRfWEDGycssU0OaDNRCM/FIo0xtvBubKqUvG/l6j5HqLjtUP9L3DowRPi1E9svHZbI0lkS1flMUafGu54j6woqq7e9CGKp+y/25BlzY+sfYOg3QIDAQAB";

		public override PlatformType Type
		{
			[CompilerGenerated]
			get
			{
				return PlatformType.Viveport;
			}
		}

		private void OnDisable()
		{
			ClearOverride();
			Viveport.Api.Shutdown(ShutdownCompleted);
		}

		public override void InitializeCore()
		{
			base.gameObject.SetActive(value: true);
			base.gameObject.AddComponent<MainThreadDispatcher>();
			Viveport.Api.Init(CoreInitializationCompleted, sm_appId);
			SetOverride();
		}

		public override void CheckEntitlement()
		{
			Viveport.Api.GetLicense(new ViveportLicenseChecker(delegate(string errorMsg)
			{
				if (string.IsNullOrEmpty(errorMsg))
				{
					m_isUserAllowedToPlay = true;
				}
				else
				{
					m_isUserAllowedToPlay = false;
					MainThreadDispatcher.Instance().Enqueue(delegate
					{
						EventHub.Publish(new Events.WriteEntitlementFailedMessage
						{
							Message = $"{Type} | User not entitled to use app."
						});
					});
				}
			}), sm_appId, sm_apiKey);
		}

		public override void FetchLoggedInUser()
		{
			if (m_isUserAllowedToPlay)
			{
				Viveport.UserStats.IsReady(UserInitializationCompleted);
				return;
			}
			MainThreadDispatcher.Instance().Enqueue(delegate
			{
				EventHub.Publish(new Events.WriteEntitlementFailedMessage
				{
					Message = $"{Type} user fetch failed, not entitled."
				});
			});
		}

		private void CoreInitializationCompleted(int errorCode)
		{
			if (errorCode != 0)
			{
				m_hasInitialized = false;
				throw new Exception($"{Type} core failed to initialize.");
			}
			m_hasInitialized = true;
			CheckEntitlement();
		}

		private void UserInitializationCompleted(int errorCode)
		{
			MainThreadDispatcher.Instance().Enqueue(delegate
			{
				if (errorCode != 0)
				{
					AccountID = null;
					EncryptionID = null;
					EventHub.Publish(new Events.UserFetchCompletedEvent
					{
						ErrorMsg = $"{Type} user fetch failed."
					});
				}
				else
				{
					AccountID = Viveport.User.GetUserName();
					EncryptionID = Viveport.User.GetUserId();
					m_userNamePrefix = "V_";
					PlayerProperty.Set("P0", EncryptionID);
					EventHub.Publish(new Events.UserFetchCompletedEvent
					{
						AccountID = m_userNamePrefix + AccountID,
						EncryptionID = EncryptionID
					});
				}
			});
		}

		private void ShutdownCompleted(int errorCode)
		{
			if (errorCode != 0)
			{
				WandsLogger.LogError("Viveport api could not shut down successfully. Errorcode: " + errorCode);
			}
		}
	}
	public class WandsLeaderboards : MonoBehaviour
	{
		public delegate void LeaderboardLoaded(LeaderboardType leaderboardIndex);

		private Dictionary<LeaderboardType, List<LeaderboardEntry>> m_entries;

		public Dictionary<LeaderboardType, List<LeaderboardEntry>> Entries => m_entries;

		private void OnDisable()
		{
			CancelInvoke();
		}

		public void Initialize(GetLeaderboardResult result, GetLeaderboardAroundPlayerResult resultAroundPlayer)
		{
			m_entries = new Dictionary<LeaderboardType, List<LeaderboardEntry>>(2);
			OnGlobalLeaderboardLoaded(result);
			OnUserLeaderboardLoaded(resultAroundPlayer);
		}

		public void Load(ICloudManager cloudManager)
		{
			m_entries = new Dictionary<LeaderboardType, List<LeaderboardEntry>>();
			LoadGlobalLeaderboard(cloudManager);
			LoadUserLeaderboard(cloudManager);
		}

		private void OnGlobalLeaderboardLoaded(GetLeaderboardResult result)
		{
			m_entries[LeaderboardType.RatingGlobal] = ParseLeaderboardEntries(result.Leaderboard, isPlayStationLeaderboard: false);
			Events.LeadboardLoadedEvent leadboardLoadedEvent = new Events.LeadboardLoadedEvent();
			leadboardLoadedEvent.LeaderboardType = LeaderboardType.RatingGlobal;
			EventHub.Publish(leadboardLoadedEvent);
		}

		private void OnUserLeaderboardLoaded(GetLeaderboardAroundPlayerResult result)
		{
			m_entries[LeaderboardType.RatingUser] = ParseLeaderboardEntries(result.Leaderboard, isPlayStationLeaderboard: false);
			Events.LeadboardLoadedEvent leadboardLoadedEvent = new Events.LeadboardLoadedEvent();
			leadboardLoadedEvent.LeaderboardType = LeaderboardType.RatingUser;
			EventHub.Publish(leadboardLoadedEvent);
		}

		private void OnPlayStationGlobalLeaderboardLoaded(GetLeaderboardResult result)
		{
			m_entries[LeaderboardType.RatingPlayStationGlobal] = ParseLeaderboardEntries(result.Leaderboard, isPlayStationLeaderboard: true);
			Events.LeadboardLoadedEvent leadboardLoadedEvent = new Events.LeadboardLoadedEvent();
			leadboardLoadedEvent.LeaderboardType = LeaderboardType.RatingPlayStationGlobal;
			EventHub.Publish(leadboardLoadedEvent);
		}

		private void OnPlayStationUserLeaderboardLoaded(GetLeaderboardAroundPlayerResult result)
		{
			m_entries[LeaderboardType.RatingPlayStationUser] = ParseLeaderboardEntries(result.Leaderboard, isPlayStationLeaderboard: true);
			Events.LeadboardLoadedEvent leadboardLoadedEvent = new Events.LeadboardLoadedEvent();
			leadboardLoadedEvent.LeaderboardType = LeaderboardType.RatingPlayStationUser;
			EventHub.Publish(leadboardLoadedEvent);
		}

		private void LoadGlobalLeaderboard(ICloudManager cloudManager)
		{
			cloudManager.GetLeaderboard<GetLeaderboardResult>(PlayFabStatisticsField.SeasonScore, OnGlobalLeaderboardLoaded);
			if (GameControl.Instance.Platform.Type == PlatformType.PlayStation)
			{
				cloudManager.GetLeaderboard<GetLeaderboardResult>(PlayFabStatisticsField.SeasonScorePlayStation, OnPlayStationGlobalLeaderboardLoaded);
			}
		}

		private void LoadUserLeaderboard(ICloudManager cloudManager)
		{
			cloudManager.GetLeaderboardAroundPlayer<GetLeaderboardAroundPlayerResult>(PlayFabStatisticsField.SeasonScore, OnUserLeaderboardLoaded);
			if (GameControl.Instance.Platform.Type == PlatformType.PlayStation)
			{
				cloudManager.GetLeaderboardAroundPlayer<GetLeaderboardAroundPlayerResult>(PlayFabStatisticsField.SeasonScorePlayStation, OnPlayStationUserLeaderboardLoaded);
			}
		}

		public static bool IsEmail(string email)
		{
			if (email != null)
			{
				return Regex.IsMatch(email, "^(([\\w-]+\\.)+[\\w-]+|([a-zA-Z]{1}|[\\w-]{2,}))@((([0-1]?[0-9]{1,2}|25[0-5]|2[0-4][0-9])\\.([0-1]?[0-9]{1,2}|25[0-5]|2[0-4][0-9])\\.([0-1]?[0-9]{1,2}|25[0-5]|2[0-4][0-9])\\.([0-1]?[0-9]{1,2}|25[0-5]|2[0-4][0-9])){1}|([a-zA-Z]+[\\w-]+\\.)+[a-zA-Z]{2,4})$");
			}
			return false;
		}

		private static List<LeaderboardEntry> ParseLeaderboardEntries(List<PlayerLeaderboardEntry> resultLeaderboard, bool isPlayStationLeaderboard)
		{
			List<LeaderboardEntry> list = new List<LeaderboardEntry>();
			int rank = 1;
			int num = 0;
			foreach (PlayerLeaderboardEntry item2 in resultLeaderboard)
			{
				if (num != item2.StatValue)
				{
					rank = item2.Position + 1;
				}
				string text = RemovedUserNamePrefix(item2.DisplayName, isPlayStationLeaderboard);
				if (IsEmail(text))
				{
					text = text.Remove(text.IndexOf('@'));
				}
				LeaderboardEntry leaderboardEntry = default(LeaderboardEntry);
				leaderboardEntry.Rank = rank;
				leaderboardEntry.Name = text;
				leaderboardEntry.Score = item2.StatValue;
				LeaderboardEntry item = leaderboardEntry;
				list.Add(item);
				num = item2.StatValue;
				if (item2.PlayFabId.Equals(GameControl.Instance.Player.PlayFabPlayerId))
				{
					GameControl.Instance.Player.Rank = item.Rank;
					GameControl.Instance.Player.SetSeasonScore(ref item.Score);
				}
			}
			return list;
		}

		private static string RemovedUserNamePrefix(string userName, bool isPlayStationLeaderboard)
		{
			if (userName == null)
			{
				return "-";
			}
			string text = "OVR_";
			if (userName.IndexOf(text, StringComparison.Ordinal) == 0)
			{
				return userName.Substring(text.Length);
			}
			text = "OC_";
			if (userName.IndexOf(text, StringComparison.Ordinal) == 0)
			{
				return userName.Substring(text.Length);
			}
			text = "G_";
			if (userName.IndexOf(text, StringComparison.Ordinal) == 0)
			{
				return userName.Substring(text.Length);
			}
			text = "V_";
			if (userName.IndexOf(text, StringComparison.Ordinal) == 0)
			{
				return userName.Substring(text.Length);
			}
			text = "S_";
			if (userName.IndexOf(text, StringComparison.Ordinal) == 0)
			{
				return userName.Substring(text.Length);
			}
			text = "PS4_";
			if (userName.IndexOf(text, StringComparison.Ordinal) == 0)
			{
				if (isPlayStationLeaderboard)
				{
					return userName.Substring(text.Length);
				}
				return $"{userName.Substring(text.Length)} {LocalizationManager.GetTermTranslation(Constants.PlatformIdentifierNames[PlatformType.PlayStation])}";
			}
			text = "P_";
			return (userName.IndexOf(text, StringComparison.Ordinal) != 0) ? userName : userName.Substring(text.Length);
		}
	}
}
namespace Cortopia.Scripts.Player
{
	[CreateAssetMenu(fileName = "EmptyAimData", menuName = "Player/Create aim data object", order = 1)]
	public class AimData : ScriptableObject
	{
		public LayerMask AimHitMask;

		public LayerMask InteractableHitMask;

		public LayerMask DragHitMask;

		public LayerMask SnapHitMask;

		public LayerMask TeleportHitMask;

		[Range(0.05f, 1.5f)]
		public float MinAimDistance = 0.75f;

		public float MaxAimDistance = 50f;

		[Range(0.001f, 0.1f)]
		public float AimDistanceMultiplier = 0.01f;

		public Texture[] AimReticles;
	}
}
namespace Assets.Scripts.Player
{
	[RequireComponent(typeof(CharacterRenderer))]
	public class BotCharacter : CharacterBase
	{
		[SerializeField]
		private CharacterType m_characterType = CharacterType.Vindicator;

		[SerializeField]
		private CharacterHitSfxHandler m_sfxHandler;

		private BotAI m_botAI;

		public bool IsArmorActive { get; private set; }

		public CharacterType CharacterType
		{
			[CompilerGenerated]
			get
			{
				return m_characterType;
			}
		}

		public WandType WandType
		{
			[CompilerGenerated]
			get
			{
				return m_wandType;
			}
		}

		public AimInput AimInput
		{
			[CompilerGenerated]
			get
			{
				return m_aimInput;
			}
		}

		public WandHand WandHand
		{
			[CompilerGenerated]
			get
			{
				return m_wandHand;
			}
		}

		public void Initialize(Wielder wielder, StatsData healthData)
		{
			m_botAI = GetComponentInParent<BotAI>();
			base.CharacterRenderer = GetComponent<CharacterRenderer>();
			base.CharacterRenderer.Initialize(m_characterType);
			base.Collider = base.CharacterRenderer.Body.GetComponentInChildren<CapsuleCollider>();
			if (base.Collider != null)
			{
				SetColliderEnabled(shouldEnable: false);
			}
			ResetRemoteCharacter(wielder);
			if (GameControl.Instance.IsCurrentLevel(Level.Arena))
			{
				TrySpawnWandMesh(WandType.Classic, m_wandHand, isDualWielding: false);
			}
			if (m_sfxHandler != null)
			{
				m_sfxHandler.SetCorrectSoundEffects(m_characterType);
			}
			if (GameControl.Instance.IsCurrentLevel(Level.Arena) && healthData != null)
			{
				m_statsUI.transform.SetParent(base.Movement.HeadIk);
				m_statsUI.Initialize(healthData, PlayerManager.Instance.PlayerControl.CameraTransform);
			}
			else
			{
				m_statsUI.gameObject.SetActive(value: false);
			}
		}

		public void SetColliderEnabled(bool shouldEnable)
		{
			base.Collider.enabled = shouldEnable;
		}

		public void ResetRemoteCharacter(Wielder wielder)
		{
			m_aimInput = AimInput.Head;
			m_wandHand = WandHand.Right;
			SetCorrectApperence(null);
			base.Movement.MovementStartBotCharacter(wielder, m_aimInput, base.CharacterRenderer);
		}

		public LayerMask GetLayerMask()
		{
			return LayerMask.NameToLayer("Player2");
		}

		private void ResetAnimationAndPosition()
		{
			SetDead(dead: false);
			base.CharacterRenderer.Body.localPosition = Vector3.zero;
		}

		public void SetDead(bool dead)
		{
			base.Movement.SetDead(dead);
		}

		public void OnLocalHit()
		{
			if (!base.Movement.IsDead)
			{
				base.CharacterRenderer.PlayHitResponse(IsArmorActive);
				if (m_sfxHandler != null)
				{
					m_sfxHandler.PlaySound();
				}
			}
		}

		public override void DestroySelf()
		{
			if (m_botAI != null)
			{
				m_botAI.enabled = false;
			}
			base.DestroySelf();
		}

		protected override void OnMatchReset(Events.MatchResetEvent eventData)
		{
			ResetAnimationAndPosition();
		}

		public override void SetCorrectApperence(Photon.Realtime.Player photonPlayer)
		{
			base.CharacterRenderer.FetchMaterialReferences();
			if (IsArmorActive)
			{
				base.CharacterRenderer.SetMaterial(CharacterMaterialType.Rim, Colors.ArmorActiveRim);
			}
			else
			{
				base.CharacterRenderer.SetMaterial(CharacterMaterialType.Default);
			}
		}
	}
}
namespace Cortopia.Scripts.Player
{
	public class BotTeleportHandler : TeleportHandler
	{
	}
}
namespace Assets.Scripts.Player
{
	public abstract class CharacterBase : MonoBehaviour, IPauseObject
	{
		private const string LeftWandSocket = "L_socket_JNT";

		private const string RightWandSocket = "R_socket_JNT";

		[SerializeField]
		protected CharacterStatsUI m_statsUI;

		protected WandType m_wandType;

		protected AimInput m_aimInput;

		protected WandHand m_wandHand;

		private Transform[] m_wandTransforms;

		private CharacterMovement m_characterMovement;

		private EventToken m_matchPausedEventToken;

		private EventToken m_matchResetEventToken;

		public bool IsPaused { get; set; }

		public Tile ConnectedTile { get; protected set; }

		public CharacterRenderer CharacterRenderer { get; protected set; }

		public CharacterMovement Movement
		{
			[CompilerGenerated]
			get
			{
				return (!(m_characterMovement != null)) ? (m_characterMovement = GetComponent<CharacterMovement>()) : m_characterMovement;
			}
		}

		public CapsuleCollider Collider { get; protected set; }

		protected virtual void OnEnable()
		{
			m_matchPausedEventToken = EventHub.Subscribe<Events.MatchPausedEvent>(OnMatchPaused);
			m_matchResetEventToken = EventHub.Subscribe<Events.MatchResetEvent>(OnMatchReset);
		}

		protected virtual void OnDisable()
		{
			StopAllCoroutines();
			EventHub.Unsubscribe<Events.MatchPausedEvent>(m_matchPausedEventToken);
			EventHub.Unsubscribe<Events.MatchResetEvent>(m_matchResetEventToken);
		}

		public void SetTrackingTransforms(VirtualTransform trackingOrigin, VirtualTransform headTracking, VirtualTransform leftHandTracking, VirtualTransform rightHandTracking)
		{
			Movement.SetTransformFromWielder(trackingOrigin, headTracking, leftHandTracking, rightHandTracking);
		}

		protected abstract void OnMatchReset(Events.MatchResetEvent eventData);

		public abstract void SetCorrectApperence(Photon.Realtime.Player photonPlayer);

		private void OnMatchPaused(Events.MatchPausedEvent eventData)
		{
			Pause(eventData.IsPaused);
		}

		public virtual void Pause(bool pause)
		{
			IsPaused = pause;
		}

		public virtual void DestroySelf()
		{
			if (ConnectedTile != null && PunSingleton<TileManager>.Instance != null)
			{
				PunSingleton<TileManager>.Instance.OccupyTile(ConnectedTile, TileOccupyState.Unoccupied);
			}
			UnityEngine.Object.Destroy(base.gameObject);
		}

		public void SetConnectedTile(Tile newTile)
		{
			ConnectedTile = newTile;
			SetRootPosition(checkIfLobby: true);
		}

		protected void ParentStatsToBody()
		{
			m_statsUI.transform.SetParent(CharacterRenderer.Body, worldPositionStays: false);
		}

		protected void TrySpawnWands(Photon.Realtime.Player Owner)
		{
			bool flag = (bool)PlayerProperty.Get("P7", Owner);
			WandType wandType = (WandType)(int)PlayerProperty.Get("C2", Owner);
			if (flag)
			{
				TrySpawnWandMesh(wandType, WandHand.Right, isDualWielding: true);
				wandType = (WandType)(int)PlayerProperty.Get("C4", Owner);
				TrySpawnWandMesh(wandType, WandHand.Left, isDualWielding: true);
			}
			else
			{
				TrySpawnWandMesh(wandType, m_wandHand, isDualWielding: false);
			}
		}

		protected void TrySpawnWandMesh(WandType wandType, WandHand wandHand, bool isDualWielding)
		{
			m_wandType = wandType;
			Transform wandParentTransform = GetWandParentTransform(wandHand);
			if (wandParentTransform != null)
			{
				SpawnWandMesh(m_wandType, wandParentTransform, isDualWielding, wandHand);
			}
		}

		public Transform GetWandParentTransform(WandHand wandHand)
		{
			return base.transform.RetrieveChild((wandHand != WandHand.Left) ? "R_socket_JNT" : "L_socket_JNT");
		}

		public Transform GetWandMeshTransform(WandHand wandHand)
		{
			if ((int)wandHand < m_wandTransforms.Length)
			{
				return m_wandTransforms[(int)wandHand];
			}
			WandsLogger.LogError($"Couldn't get correct WandTransform from CharacterBase ({wandHand})");
			return m_wandTransforms[0];
		}

		protected void SetRootPosition(bool checkIfLobby)
		{
			if (checkIfLobby && GameControl.Instance.IsCurrentLevel(Level.Lobby))
			{
				SetRootPosition(PunSingleton<LobbyManager>.Instance.RemoteCharacterSpawnParent);
			}
			else if (ConnectedTile != null)
			{
				SetRootPosition(ConnectedTile.transform);
			}
			else
			{
				SetRootPosition(null);
			}
		}

		private void SetRootPosition(Transform rootTransform)
		{
			if (!(Movement == null) && !(CharacterRenderer == null))
			{
				if (CharacterRenderer.Body == null || CharacterRenderer.Body.Equals(null))
				{
					StopCoroutine("DelayedRootPositionSet");
					StartCoroutine("DelayedRootPositionSet", rootTransform);
					return;
				}
				Vector3 localPosition = CharacterRenderer.Body.localPosition;
				base.transform.SetParent(rootTransform);
				base.transform.localPosition = Vector3.zero;
				CharacterRenderer.Body.localPosition = localPosition;
				Movement.ResetIK();
			}
		}

		private void SpawnWandMesh(WandType wandType, Transform wandParent, bool isDualWielding, WandHand wandHand)
		{
			WandHandler wandHandler = Resources.Load<WandHandler>("Wands/" + wandType);
			if (wandHandler == null)
			{
				WandsLogger.LogError($"Wand mesh of type {wandType} not found in Resources");
				return;
			}
			wandHandler = UnityEngine.Object.Instantiate(wandHandler, wandParent);
			if (isDualWielding)
			{
				wandHandler.AdjustWandTipToDualWield(disableRelics: true);
			}
			if (m_wandTransforms == null)
			{
				m_wandTransforms = new Transform[2];
			}
			Transform transform = wandHandler.transform;
			transform.SetLocalPositionRotationAndScale(Vector3.zero, Quaternion.identity, Vector3.one * 0.8f);
			m_wandTransforms[(int)wandHand] = transform;
		}

		private IEnumerator DelayedRootPositionSet(Transform rootTransform)
		{
			while (CharacterRenderer.Body == null || CharacterRenderer.Body.Equals(null))
			{
				yield return null;
			}
			SetRootPosition(rootTransform);
		}
	}
}
namespace Cortopia.Scripts.Player
{
	public abstract class CharacterControl : Pawn
	{
		[SerializeField]
		private TeleportHandler m_teleportHandler;

		[SerializeField]
		private HurtSfxHandler m_sfxHandler;

		[SerializeField]
		protected AimData m_aimData;

		protected bool m_blockArenaEventsSubscription;

		protected bool m_checkFirstBlood;

		protected PlayerMove m_movement;

		private EventToken m_sceneLoadedEventToken;

		private EventToken m_wandControllerDespawnedEventToken;

		private EventToken m_levelInitializedEventToken;

		private EventToken m_matchResetEventToken;

		private EventToken m_finalCountdownStartedEventToken;

		private EventToken m_countdownStartedEventToken;

		private EventToken m_countdownEndedEventToken;

		public float ManaUsedTotal { get; protected set; }

		public float DamageReceivedTotal { get; protected set; }

		public bool FlawlessWin { get; private set; }

		public Wielder Wielder { get; set; }

		public HurtSfxHandler HurtSfxHandler
		{
			[CompilerGenerated]
			get
			{
				return m_sfxHandler;
			}
		}

		public TeleportHandler TeleportHandler { get; private set; }

		public MatchStatsSummary MatchStatsSummary
		{
			[CompilerGenerated]
			get
			{
				return new MatchStatsSummary(DamageReceivedTotal, ManaUsedTotal, base.Health);
			}
		}

		public WandManager Wand { get; protected set; }

		public bool IsTeleporting
		{
			[CompilerGenerated]
			get
			{
				return TeleportHandler.IsTeleporting;
			}
		}

		public bool IsAtStartTile
		{
			[CompilerGenerated]
			get
			{
				return m_movement == null || (GetCurrentTile() == m_movement.StartTile && !IsTeleporting);
			}
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			m_sceneLoadedEventToken = EventHub.Subscribe<Events.SceneLoadedEvent>(OnSceneLoaded);
			m_wandControllerDespawnedEventToken = EventHub.Subscribe<InputEvents.WandControllerDespawnedEvent>(OnWandControllerDespawned);
			m_levelInitializedEventToken = EventHub.Subscribe<Events.LevelInitializedEvent>(OnLevelInitialized);
		}

		protected override void OnDisable()
		{
			base.OnDisable();
			EventHub.Unsubscribe<Events.SceneLoadedEvent>(m_sceneLoadedEventToken);
			EventHub.Unsubscribe<InputEvents.WandControllerDespawnedEvent>(m_wandControllerDespawnedEventToken);
			EventHub.Unsubscribe<Events.LevelInitializedEvent>(m_levelInitializedEventToken);
		}

		protected override void Awake()
		{
			base.Awake();
			SetTeleportHandler();
		}

		protected void SubscribeToArenaEvents()
		{
			if (!m_blockArenaEventsSubscription)
			{
				m_blockArenaEventsSubscription = true;
				m_matchResetEventToken = EventHub.Subscribe<Events.MatchResetEvent>(OnMatchReset);
				m_finalCountdownStartedEventToken = EventHub.Subscribe<Events.FinalCountdownStartedEvent>(OnFinalCountdownStarted);
				m_countdownStartedEventToken = EventHub.Subscribe<Events.CountdownStartedEvent>(OnCountdownStarted);
				m_countdownEndedEventToken = EventHub.Subscribe<Events.CountdownEndedEvent>(OnCountdownEnded);
			}
		}

		protected void UnsubscribeFromArenaEvents()
		{
			if (m_blockArenaEventsSubscription)
			{
				m_blockArenaEventsSubscription = false;
				EventHub.Unsubscribe<Events.MatchResetEvent>(m_matchResetEventToken);
				EventHub.Unsubscribe<Events.FinalCountdownStartedEvent>(m_finalCountdownStartedEventToken);
				EventHub.Unsubscribe<Events.CountdownStartedEvent>(m_countdownStartedEventToken);
				EventHub.Unsubscribe<Events.CountdownEndedEvent>(m_countdownEndedEventToken);
			}
		}

		protected abstract void OnLevelInitialized(Events.LevelInitializedEvent eventData);

		protected abstract void OnFinalCountdownStarted(Events.FinalCountdownStartedEvent eventData);

		protected abstract void OnCountdownStarted(Events.CountdownStartedEvent eventData);

		protected abstract void OnCountdownEnded(Events.CountdownEndedEvent eventData);

		protected abstract void OnWandControllerDespawned(InputEvents.WandControllerDespawnedEvent eventData);

		protected virtual void OnMatchReset(Events.MatchResetEvent eventData)
		{
			if (eventData.MatchType != MatchType.Exploration && !IsTeleporting)
			{
				ResetPosition(eventData.MatchType);
				SetCurrentTile(m_movement.StartTile);
				PunSingleton<TileManager>.Instance.OccupyTile(m_movement.StartTile, TileOccupyState.Occupied, Wielder.photonView);
				TeleportHandler.ResetTransform(m_movement.GetCurrentTile(base.transform));
			}
		}

		protected override void OnMatchEnded(Events.MatchEndedEvent eventData)
		{
			base.OnMatchEnded(eventData);
			DestroyPlayerWand();
		}

		public abstract void InstantiatePlayerWand();

		public abstract void TryTrackTileHit(WandHand wandHand);

		public abstract void SetFreeTeleportActive(bool enable);

		protected abstract AimInput GetAimInputType();

		protected abstract void SpawnAndConnectWielder(Level level);

		public void DestroyPlayerWand()
		{
			if (Wand != null)
			{
				Wand.DestroyPlayerWands();
				Wand = null;
			}
		}

		public void SetCurrentTile(Tile newTile)
		{
			if (newTile == null)
			{
				WandsLogger.LogError("PlayerControl | Set tile is null");
			}
			else if (m_movement != null)
			{
				Tile currentTile = m_movement.GetCurrentTile(base.transform);
				if (currentTile != null && currentTile.IsElevatorTile)
				{
					ResetCharacterTransform();
				}
				SetMovementTile(newTile);
				Wielder.SetCurrentTile(newTile.photonView.ViewID);
			}
		}

		public void ResetCharacterTransform()
		{
			base.transform.SetParent(null);
			UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		}

		protected virtual void SetMovementTile(Tile newTile)
		{
			m_movement.SetCurrentTile(newTile);
		}

		protected virtual void UpdateObjectLayer(LayerMask layer)
		{
			base.gameObject.layer = layer;
			base.ColliderTransform.gameObject.layer = layer;
		}

		protected virtual void OnWielderSpawned(Wielder wielder, Level level)
		{
			Wielder = wielder;
			CreateHP();
			CreateMana();
		}

		protected override void OnSceneLoadInitiated(Events.SceneLoadInitiatedEvent eventData)
		{
			base.OnSceneLoadInitiated(eventData);
			ResetCharacterTransform();
			RemoveMovement();
			SetColliderActive(active: false);
			Pause(pause: false);
		}

		protected virtual void OnSceneLoaded(Events.SceneLoadedEvent eventData)
		{
			m_currentLevel = eventData.Level;
		}

		public virtual void SpawnWandController(Level level)
		{
			if (level == Level.Lobby)
			{
				SpawnOfflineWandController();
			}
			else
			{
				SpawnOnlineWandController(Wielder.ViewID);
			}
		}

		private void SpawnOfflineWandController()
		{
			Wand.SpawnOfflineWandControllers(base.transform, GetAimInputType());
		}

		private void SpawnOnlineWandController(int wielderViewID)
		{
			Wand.SpawnOnlineWandControllers(Wielder.ViewID, base.transform, GetAimInputType());
		}

		protected void SetTeleportHandler()
		{
			TeleportHandler = m_teleportHandler;
			TeleportHandler.SetCharacter(this);
		}

		protected override bool IsTeleportActive()
		{
			return TeleportHandler.IsTeleporting;
		}

		protected virtual void CreateMovement(Tile startTile)
		{
			if (m_movement == null)
			{
				m_movement = new PlayerMove(m_aimData.TeleportHitMask, startTile);
			}
			SetCurrentTile(startTile);
			PunSingleton<TileManager>.Instance.OccupyTile(startTile, TileOccupyState.Occupied, Wielder.photonView);
			ResetToInsideTileArea(startTile.transform.position);
		}

		protected virtual void RemoveMovement()
		{
			m_movement = null;
		}

		public virtual Vector3 GetPlayerPosition()
		{
			return base.transform.position;
		}

		public virtual void ResetPosition(MatchType matchType)
		{
			m_movement.ResetPosition(matchType, base.transform);
		}

		public Tile GetCurrentTile()
		{
			return (m_movement != null) ? m_movement.GetCurrentTile(base.transform) : null;
		}

		public virtual void ResetToInsideTileArea(Vector3 tilePosition)
		{
			base.transform.position = tilePosition;
		}

		public void AbortContinuousHit()
		{
			if (HurtSfxHandler.IsContinuousDamageActive)
			{
				HurtSfxHandler.AbortContinuousHit();
			}
		}

		public override void ChangeMana(float changeValue, bool blockManaReg = false)
		{
			base.ChangeMana(changeValue, blockManaReg);
			if (changeValue < 0f)
			{
				ChangeManaUsed(changeValue * -1f);
			}
		}

		public void ChangeManaUsed(float changeValue)
		{
			ManaUsedTotal += changeValue;
		}

		public void ResetPlayerStats()
		{
			m_healthData.Reset();
			m_manaData.Reset();
			m_regenerateMana = false;
			if (GameControl.Instance.IsCurrentLevel(Level.Lobby))
			{
				m_checkFirstBlood = false;
				return;
			}
			m_checkFirstBlood = true;
			PlayerProperty.Set("HP", (int)m_healthData.Max, Wielder.Owner);
			ManaUsedTotal = 0f;
			PlayerProperty.Set("MA", 0, Wielder.Owner);
			DamageReceivedTotal = 0f;
			PlayerProperty.Set("DD", 0, Wielder.Owner);
		}

		protected float GetDamageAfterArmorReduction(DamageType damageType, float damage)
		{
			if (Wielder.IsArmorActive)
			{
				Wand.OnArmorHit(ref damage);
			}
			return damage;
		}

		protected void Die(Vector2 hitDirection)
		{
			HurtSfxHandler.StopAllCoroutines();
			Wielder.PlayerDeath(Vector3.Dot(base.transform.forward, hitDirection));
			Wielder.AnimationRelay.SetDeadAnimationState(isDead: true);
		}

		protected virtual void TryDepleteMaxMana(float depletionMultiplier)
		{
			m_manaData.SetMax(m_manaData.Max * depletionMultiplier);
		}
	}
}
namespace Assets.Scripts.Player
{
	public class CharacterMovement : MonoBehaviour
	{
		[StructLayout(LayoutKind.Sequential, Size = 1)]
		private struct PrefabStrings
		{
			public const string HeadIKTarget = "HeadIK";

			public const string LeftArmIKTarget = "LHandIK";

			public const string RightArmIKTarget = "RHandIK";

			public const string VRIKTargetReference = "Target";

			public const string OriginTransform = "TrackingOrigin";

			public const string LeftHandSocket = "L_socket_JNT";

			public const string RightHandSocket = "R_socket_JNT";
		}

		private const float MinimumCrouchHeight = 1.6f;

		private const float MaximumCrouchHeight = 1.7f;

		private const float LocomotionDisabledTime = 1.25f;

		private static readonly VirtualTransform sm_defaultLeftSocketTransform = new VirtualTransform(new Vector3(-0.1f, -0.025f, 0f), Quaternion.Euler(0f, -90f, -90f), Vector3.one);

		private static readonly VirtualTransform sm_defaultRightSocketTransform = new VirtualTransform(new Vector3(0.1f, 0.025f, 0f), Quaternion.Euler(180f, -90f, 90f), Vector3.one);

		private bool m_isMovementSyncActive;

		private bool m_isTrackingHeadPosition;

		private bool m_isTrackingHands;

		private bool m_shouldRotateAndMoveRemoteBody;

		private bool m_hasFlippedArms;

		private VirtualTransform m_originTrackingTarget = new VirtualTransform();

		private VirtualTransform m_headTrackingTarget = new VirtualTransform();

		private VirtualTransform m_rightHandTrackingTarget = new VirtualTransform();

		private VirtualTransform m_leftHandTrackingTarget = new VirtualTransform();

		private Transform m_vrikRigOrigin;

		private Transform m_vrikRigLeftHand;

		private Transform m_vrikRigRightHand;

		private Transform m_characterRoot;

		private Transform m_leftHandSocket;

		private Transform m_rightHandSocket;

		private VRIK m_vrIK;

		private Wielder m_myWielder;

		private CustomAnimationController m_animationController;

		private Quaternion m_botCharacterTargetRotation;

		private Action m_updateMethod;

		private Coroutine m_enableLocomotion;

		public bool IsDead { get; private set; }

		public Transform HeadIk { get; private set; }

		public VirtualTransform HeadTrackingTarget
		{
			[CompilerGenerated]
			get
			{
				return m_headTrackingTarget;
			}
		}

		public Vector3 ColliderTargetPosition
		{
			[CompilerGenerated]
			get
			{
				return new Vector3(HeadIk.position.x, m_characterRoot.position.y, HeadIk.position.z);
			}
		}

		private void LateUpdate()
		{
			if (!m_isMovementSyncActive || m_vrIK == null)
			{
				return;
			}
			bool? flag = PunSingleton<SceneControl>.Instance?.GameOver;
			if (!flag.HasValue || !flag.Value)
			{
				if (m_myWielder == null || m_myWielder.IsPlayer)
				{
					SetTransformsFromPlayerControl(GameControl.Instance.PlayerControl);
				}
				m_updateMethod();
			}
		}

		public void MovementStartTwin(Wielder wielder, AimInput aimInput, CharacterRenderer renderer)
		{
			SetAnimationConfiguration(wielder, aimInput, renderer, isMirrored: false);
			m_updateMethod = AssignUpdateMethod(isBot: false, m_isTrackingHands);
		}

		public void MovementStartRemoteCharacter(Wielder wielder, AimInput aimInput, CharacterRenderer renderer)
		{
			SetAnimationConfiguration(wielder, aimInput, renderer, isMirrored: false);
			m_updateMethod = AssignUpdateMethod(isBot: false, m_isTrackingHands);
			wielder.AnimationRelay.CustomAnimationController = m_animationController;
		}

		public void MovementStartBotCharacter(Wielder wielder, AimInput aimInput, CharacterRenderer renderer)
		{
			SetAnimationConfiguration(wielder, AimInput.Head, renderer, isMirrored: false);
			wielder.AnimationRelay.CustomAnimationController = m_animationController;
			m_updateMethod = AssignUpdateMethod(isBot: true, m_isTrackingHands);
			if (GameControl.Instance.IsCurrentLevel(Level.Lobby))
			{
				m_isMovementSyncActive = false;
				return;
			}
			m_isMovementSyncActive = true;
			m_vrIK.enabled = false;
		}

		public void MovementStartDisplayCharacter(AimInput aimInput, CharacterRenderer renderer)
		{
			SetAnimationConfiguration(null, aimInput, renderer, isMirrored: true);
			m_updateMethod = AssignUpdateMethod(isBot: false, m_isTrackingHands);
		}

		private void SetAnimationConfiguration(Wielder wielder, AimInput aimInput, CharacterRenderer renderer, bool isMirrored)
		{
			m_characterRoot = renderer?.Body;
			if (m_characterRoot == null)
			{
				WandsLogger.LogError("Animation config failed due to no character present");
				return;
			}
			m_vrIK = m_characterRoot.GetComponent<VRIK>();
			if (m_characterRoot == null)
			{
				WandsLogger.LogError("Animation config failed due to no VrIK found on character root.");
				return;
			}
			m_myWielder = wielder;
			m_leftHandSocket = m_characterRoot.RetrieveChild("L_socket_JNT");
			m_rightHandSocket = m_characterRoot.RetrieveChild("R_socket_JNT");
			m_animationController = m_characterRoot.GetComponent<CustomAnimationController>();
			ConfigureTrackingSolution(aimInput, isMirrored, wielder);
			ConfigureAnimator(aimInput);
			if (GameControl.Instance.IsCurrentLevel(Level.Lobby) && m_isTrackingHands)
			{
				base.transform.localRotation = Quaternion.Euler(0f, 180f, 0f);
			}
			m_vrIK.enabled = m_isTrackingHands;
			m_characterRoot.localRotation = Quaternion.identity;
			m_isMovementSyncActive = true;
		}

		private void ConfigureTrackingSolution(AimInput aimInput, bool isMirrored, Wielder wielder)
		{
			HeadIk = base.transform.RetrieveChild("HeadIK");
			m_vrikRigOrigin = base.transform.RetrieveChild("TrackingOrigin");
			m_vrIK.solver.spine.headTarget = HeadIk.RetrieveChild("Target");
			m_isTrackingHands = aimInput.ContainsFlag(AimInput.Hand);
			m_isTrackingHeadPosition = ((m_myWielder == null) ? GameControl.Instance.Platform.SupportsPositionalTracking : (!m_myWielder.IsBot && (bool)PlayerProperty.Get("P6", m_myWielder.Owner)));
			if (m_isTrackingHands)
			{
				m_vrikRigLeftHand = base.transform.RetrieveChild("LHandIK");
				m_vrikRigRightHand = base.transform.RetrieveChild("RHandIK");
				if (!isMirrored)
				{
					m_vrIK.solver.leftArm.target = m_vrikRigLeftHand.RetrieveChild("Target");
					m_vrIK.solver.rightArm.target = m_vrikRigRightHand.RetrieveChild("Target");
				}
				else if (!m_hasFlippedArms)
				{
					m_vrIK.solver.leftArm.target = m_vrikRigRightHand.RetrieveChild("Target");
					m_vrIK.solver.rightArm.target = m_vrikRigLeftHand.RetrieveChild("Target");
					m_vrIK.solver.leftArm.target.transform.rotation *= Quaternion.Euler(180f, 0f, 0f);
					m_vrIK.solver.rightArm.target.transform.rotation *= Quaternion.Euler(180f, 0f, 0f);
					m_hasFlippedArms = true;
				}
			}
		}

		private void ConfigureAnimator(AimInput aimInput)
		{
			bool flag = GameControl.Instance.IsCurrentLevel(Level.Arena);
			m_animationController.MirrorAnimator(aimInput == AimInput.LeftHand);
			m_animationController.Animator.enabled = !m_isTrackingHands;
			m_animationController.LobbyAnimationToggle(!flag && !m_isTrackingHands);
			if (m_isTrackingHands)
			{
				m_leftHandSocket.localPosition = sm_defaultLeftSocketTransform.Position;
				m_leftHandSocket.localRotation = sm_defaultLeftSocketTransform.Rotation;
				m_rightHandSocket.localPosition = sm_defaultRightSocketTransform.Position;
				m_rightHandSocket.localRotation = sm_defaultRightSocketTransform.Rotation;
			}
		}

		private Action AssignUpdateMethod(bool isBot, bool isTrackingHands)
		{
			if (isBot)
			{
				return UpdateMovementBot;
			}
			if (isTrackingHands)
			{
				return UpdateMovementVRIK;
			}
			return UpdateMovementAnimator;
		}

		private void UpdateMovementBot()
		{
			if (GameControl.Instance.IsCurrentLevel(Level.Arena))
			{
				UpdateVRIKHeadTransform();
				HeadIk.rotation = m_headTrackingTarget.Rotation;
				m_botCharacterTargetRotation = Quaternion.Euler(m_characterRoot.eulerAngles.x, HeadIk.eulerAngles.y, m_characterRoot.eulerAngles.z);
				m_characterRoot.rotation = Quaternion.Slerp(m_characterRoot.rotation, m_botCharacterTargetRotation, Time.deltaTime * 10f);
			}
		}

		private void UpdateMovementVRIK()
		{
			UpdateVRIKHeadTransform();
			UpdateVRIKHandTransforms();
		}

		private void UpdateMovementAnimator()
		{
			if (GameControl.Instance.IsCurrentLevel(Level.Arena))
			{
				UpdateVRIKHeadTransform();
				m_characterRoot.eulerAngles = new Vector3(m_characterRoot.eulerAngles.x, HeadIk.rotation.eulerAngles.y, m_characterRoot.eulerAngles.z);
				if (m_isTrackingHeadPosition)
				{
					m_characterRoot.transform.position = new Vector3(HeadIk.position.x, m_characterRoot.transform.position.y, HeadIk.position.z);
				}
			}
		}

		public void TryTemporarilyDisableLocomotion()
		{
			if (!(m_vrIK == null) && m_vrIK.enabled)
			{
				m_vrIK.solver.locomotion.weight = 0f;
				if (m_enableLocomotion != null)
				{
					StopCoroutine(m_enableLocomotion);
				}
				m_enableLocomotion = StartCoroutine(EnableLocomotion());
			}
		}

		public void SetDead(bool dead)
		{
			if (IsDead != dead)
			{
				IsDead = dead;
				m_animationController.Animator.enabled = dead;
				m_vrIK.enabled = !dead;
				HeadIk?.gameObject.SetActive(!dead);
			}
		}

		public void ResetIK(bool resetBody = false)
		{
			if (resetBody && m_characterRoot != null)
			{
				m_characterRoot.localPosition = Vector3.zero;
			}
			if (m_vrIK != null)
			{
				m_vrIK.solver.Reset();
			}
		}

		public void SetBodyActive(bool enable)
		{
			if (!(m_characterRoot == null))
			{
				m_characterRoot.gameObject.SetActive(enable);
				if (enable)
				{
					LateUpdate();
					m_vrIK.solver.Reset();
				}
			}
		}

		public void TrySetLobbyAnimations(bool enabled)
		{
			if (!m_isTrackingHands)
			{
				m_animationController.LobbyAnimationToggle(enabled);
			}
		}

		private IEnumerator EnableLocomotion()
		{
			yield return new WaitForSeconds(1.25f);
			m_vrIK.solver.locomotion.weight = 1f;
		}

		public void SetTransformFromWielder(VirtualTransform trackingOrigin, VirtualTransform headTracking, VirtualTransform leftHandTracking, VirtualTransform rightHandTracking)
		{
			m_originTrackingTarget = trackingOrigin;
			m_headTrackingTarget = headTracking;
			m_leftHandTrackingTarget = leftHandTracking;
			m_rightHandTrackingTarget = rightHandTracking;
		}

		private void SetTransformsFromPlayerControl(PlayerControl playerControl)
		{
			m_originTrackingTarget = playerControl.OriginTrackingTarget;
			m_headTrackingTarget = playerControl.HeadTrackingTarget;
			m_leftHandTrackingTarget = playerControl.LeftHandTrackingTarget;
			m_rightHandTrackingTarget = playerControl.RightHandTrackingTarget;
		}

		public float GetHeadIKRotationThreshold()
		{
			return 0f;
		}

		private void UpdateVRIKHeadTransform()
		{
			if (HeadIk == null)
			{
				WandsLogger.LogError("Head tracker is null");
				return;
			}
			m_vrikRigOrigin.localPosition = m_originTrackingTarget.Position;
			m_vrikRigOrigin.localRotation = m_originTrackingTarget.Rotation;
			ClampVRIKHeight();
			HeadIk.localPosition = m_headTrackingTarget.Position;
			HeadIk.localRotation = m_headTrackingTarget.Rotation;
		}

		private void UpdateVRIKHandTransforms()
		{
			if (!(m_vrikRigRightHand == null) || !(m_vrikRigLeftHand == null))
			{
				if (m_vrikRigLeftHand != null)
				{
					m_vrikRigLeftHand.localPosition = m_leftHandTrackingTarget.Position;
					m_vrikRigLeftHand.localRotation = m_leftHandTrackingTarget.Rotation;
				}
				if (m_vrikRigRightHand != null)
				{
					m_vrikRigRightHand.localPosition = m_rightHandTrackingTarget.Position;
					m_vrikRigRightHand.localRotation = m_rightHandTrackingTarget.Rotation;
				}
			}
		}

		private void ClampVRIKHeight()
		{
			if (HeadIk.transform.localPosition.y - 1.6f < 0f)
			{
				m_vrikRigOrigin.transform.localPosition = new Vector3(m_originTrackingTarget.Position.x, 1.6f - HeadIk.transform.localPosition.y, m_originTrackingTarget.Position.z);
			}
		}
	}
	public class CharacterRenderer : MonoBehaviour
	{
		private CharacterType m_characterType;

		private Material m_defaultMaterial;

		private Material m_rimMaterial;

		private Coroutine m_flashRed;

		private List<ParticleSystem> m_vfxObjects;

		private List<Renderer> m_renderers;

		private static readonly Dictionary<string, GameObject> sm_preloadedAssets = new Dictionary<string, GameObject>(32);

		public Transform Body { get; private set; }

		public SkinnedMeshRenderer Renderer { get; private set; }

		private void OnDisable()
		{
			StopAllCoroutines();
		}

		private void Awake()
		{
			if (sm_preloadedAssets.Count <= 0)
			{
				PreloadRenderers();
			}
		}

		private void PreloadRenderers()
		{
			for (int i = 0; i < EnumHelper.CharacterTypeNames.Length; i++)
			{
				string text = EnumHelper.CharacterTypeNames[i];
				string text2 = EnumHelper.CharacterTypeNames[i] + "LOD1";
				if (!sm_preloadedAssets.ContainsKey(text) || sm_preloadedAssets[text] == null)
				{
					sm_preloadedAssets[text] = GameControl.Instance.AssetHandler.LoadAsset<GameObject>(AssetBundleType.CombinedCharacter, text);
				}
				if (!sm_preloadedAssets.ContainsKey(text2) || sm_preloadedAssets[text2] == null)
				{
					sm_preloadedAssets[text2] = GameControl.Instance.AssetHandler.LoadAsset<GameObject>(AssetBundleType.CombinedCharacter, text2);
				}
			}
		}

		public void Initialize(CharacterType type)
		{
			m_characterType = type;
			SpawnCharacterMesh(GameControl.Instance.GetCurrentLevel(callBeforeLevelLoaded: true).ContainsFlag(Level.Arena));
			SetRenderersEnabled(enable: true);
		}

		private void SpawnCharacterMesh(bool lod)
		{
			string text = ((!lod) ? m_characterType.ToString() : $"{m_characterType}LOD1");
			if (!sm_preloadedAssets.ContainsKey(text) || sm_preloadedAssets[text] == null)
			{
				sm_preloadedAssets[text] = GameControl.Instance.AssetHandler.LoadAsset<GameObject>(AssetBundleType.CombinedCharacter, text);
			}
			GameObject gameObject = sm_preloadedAssets[text];
			if (gameObject == null)
			{
				WandsLogger.LogError($"Couldn't load character using {text}");
				return;
			}
			Body = UnityEngine.Object.Instantiate(gameObject, base.transform, worldPositionStays: false).transform;
			Body.localRotation = Quaternion.identity;
			Renderer = Body.GetComponentInChildren<SkinnedMeshRenderer>();
			m_renderers = new List<Renderer>(GetComponentsInChildren<Renderer>());
			m_vfxObjects = new List<ParticleSystem>(Body.GetComponentsInChildren<ParticleSystem>());
		}

		public void FetchMaterialReferences()
		{
			string text = m_characterType.ToString().ToLower();
			m_defaultMaterial = GameControl.Instance.AssetHandler.LoadAsset<Material>(AssetBundleType.Vanity, text);
			m_rimMaterial = GameControl.Instance.AssetHandler.LoadAsset<Material>(AssetBundleType.Vanity, text + "_rim");
			SetMaterial(CharacterMaterialType.Default);
		}

		public void ToggleVfxActive(bool enable)
		{
			if (m_vfxObjects.IsNullOrEmpty())
			{
				return;
			}
			foreach (ParticleSystem vfxObject in m_vfxObjects)
			{
				vfxObject.gameObject.SetActive(enable);
			}
		}

		public void PlayHitResponse(bool isArmorActive)
		{
			if (m_flashRed != null)
			{
				StopCoroutine(m_flashRed);
				m_flashRed = null;
			}
			m_flashRed = StartCoroutine(FlashRed(isArmorActive));
		}

		private IEnumerator FlashRed(bool isArmorActive)
		{
			SetMaterial(CharacterMaterialType.Rim, Color.red);
			yield return new WaitForSeconds(0.5f);
			if (isArmorActive)
			{
				SetMaterial(CharacterMaterialType.Rim, Colors.ArmorActiveRim);
			}
			else
			{
				SetMaterial(CharacterMaterialType.Default);
			}
		}

		public void SetMaterial(CharacterMaterialType materialType)
		{
			SetMaterial(materialType, Color.white);
		}

		public void SetMaterial(CharacterMaterialType materialType, Color color, bool blockFlash = false)
		{
			if (Renderer == null)
			{
				WandsLogger.LogError($"Can't set material on {base.name} due to no renderer defined. Most likely caused by failed initialization!");
				return;
			}
			if (blockFlash && m_flashRed != null)
			{
				StopCoroutine(m_flashRed);
				m_flashRed = null;
			}
			switch (materialType)
			{
			case CharacterMaterialType.Default:
				Renderer.material = m_defaultMaterial;
				Renderer.material.color = color;
				break;
			case CharacterMaterialType.Rim:
				Renderer.material = m_rimMaterial;
				Renderer.material.SetColor("_RimColor", color);
				break;
			case CharacterMaterialType.Highlight:
				Renderer.material = m_defaultMaterial;
				Renderer.material.color = ((!(color == Color.white)) ? color : Color.red);
				break;
			}
		}

		public void SetRenderersEnabled(bool enable)
		{
			if (m_renderers.IsNullOrEmpty())
			{
				return;
			}
			for (int i = 0; i < m_renderers.Count; i++)
			{
				if (m_renderers[i] == null)
				{
					m_renderers.Remove(m_renderers[i]);
					i--;
				}
				else
				{
					m_renderers[i].enabled = enable;
				}
			}
		}
	}
	public class CharacterStatsUI : MonoBehaviour
	{
		[SerializeField]
		private Transform m_vitalBarParent;

		[SerializeField]
		private Image m_vitalBar;

		[SerializeField]
		private Image m_vitalSpent;

		private StatsData m_healthData;

		private Transform m_followTransform;

		private float m_previousHealth;

		private Tweener m_barValueTweener;

		private void OnEnable()
		{
			float? num = (((object)m_healthData != null) ? new float?(m_healthData.Fill) : null);
			float fillAmount = ((!num.HasValue) ? 1f : num.Value);
			m_vitalBar.fillAmount = fillAmount;
			m_vitalSpent.fillAmount = fillAmount;
		}

		private void OnDisable()
		{
			if (m_barValueTweener != null)
			{
				m_barValueTweener.Kill();
			}
		}

		private void Update()
		{
			if (m_healthData != null)
			{
				UpdateVitals();
			}
			if (m_followTransform != null)
			{
				UpdateRotation();
			}
		}

		public void Initialize(StatsData healthData, Transform followTransform)
		{
			m_healthData = healthData;
			m_followTransform = followTransform;
		}

		private void UpdateRotation()
		{
			Vector3 vector = m_vitalBarParent.position - m_followTransform.position;
			vector.y = 0f;
			m_vitalBarParent.rotation = Quaternion.LookRotation(vector.normalized);
		}

		private void UpdateVitals()
		{
			if (m_healthData.Current != m_previousHealth)
			{
				if (m_barValueTweener != null)
				{
					m_barValueTweener.Kill();
				}
				if (m_healthData.Current > m_previousHealth)
				{
					float changeValue = m_healthData.Current - m_previousHealth;
					AddFillAmount(m_healthData.Fill, changeValue);
				}
				else
				{
					float num = m_previousHealth - m_healthData.Current;
					SubtractFillAmount(m_healthData.Fill, 0f - num);
				}
				m_previousHealth = m_healthData.Current;
			}
		}

		public void AddFillAmount(float fillAmount, float changeValue)
		{
			float duration = fillAmount - m_vitalBar.fillAmount;
			m_vitalSpent.fillAmount = fillAmount;
			m_barValueTweener = m_vitalBar.DOFillAmount(fillAmount, duration).SetDelay(1f);
		}

		public void SubtractFillAmount(float fillAmount, float changeValue)
		{
			float duration = m_vitalSpent.fillAmount - fillAmount;
			m_vitalBar.fillAmount = fillAmount;
			m_barValueTweener = m_vitalSpent.DOFillAmount(fillAmount, duration).SetDelay(1f);
		}
	}
	[RequireComponent(typeof(CharacterRenderer))]
	public class DisplayCharacter : MonoBehaviour
	{
		private CharacterRenderer m_characterRenderer;

		private CharacterMovement m_characterMovement;

		private EventToken m_inputChangedEventToken;

		private EventToken m_recenterCameraEventToken;

		private void OnEnable()
		{
			m_characterRenderer = GetComponent<CharacterRenderer>();
			m_characterMovement = GetComponent<CharacterMovement>();
			m_inputChangedEventToken = EventHub.Subscribe<InputEvents.InputChangedEvent>(OnInputChanged);
			m_recenterCameraEventToken = EventHub.Subscribe<Events.OnCameraRecenteredEvent>(OnRecenter);
		}

		private void OnDisable()
		{
			if (m_inputChangedEventToken != null)
			{
				EventHub.Unsubscribe<InputEvents.InputChangedEvent>(m_inputChangedEventToken);
				EventHub.Unsubscribe<Events.OnCameraRecenteredEvent>(m_recenterCameraEventToken);
			}
		}

		public void Initialize(CharacterType type)
		{
			m_characterRenderer.Initialize(type);
			m_characterRenderer.FetchMaterialReferences();
			m_characterRenderer.SetMaterial(CharacterMaterialType.Default);
			m_characterMovement.MovementStartDisplayCharacter(GameControl.Instance.GetInputAim(), m_characterRenderer);
			base.transform.localRotation = Quaternion.identity;
		}

		public void SetActive(bool enable)
		{
			m_characterRenderer.SetRenderersEnabled(enable);
			m_characterRenderer.ToggleVfxActive(enable);
			m_characterMovement.SetBodyActive(enable);
			m_characterMovement.enabled = enable;
			m_characterMovement.TrySetLobbyAnimations(enabled: true);
		}

		private void OnInputChanged(InputEvents.InputChangedEvent eventData)
		{
			m_characterMovement.MovementStartDisplayCharacter(eventData.AimInput, m_characterRenderer);
		}

		private void OnRecenter(Events.OnCameraRecenteredEvent eventData)
		{
			m_characterMovement.ResetIK(resetBody: true);
		}
	}
}
namespace Cortopia.Scripts.Player
{
	public class HandsHandler : MonoBehaviour
	{
		[SerializeField]
		private Renderer[] m_renderers = Array.Empty<Renderer>();

		[SerializeField]
		private Material[] m_materials = Array.Empty<Material>();

		[SerializeField]
		private HandAnimator[] m_animators = Array.Empty<HandAnimator>();

		[Header("Left Hand")]
		[SerializeField]
		private Transform m_leftHandRig;

		[SerializeField]
		private Transform m_leftEquip;

		[SerializeField]
		private Transform m_leftAimPoint;

		[Header("Right Hand")]
		[SerializeField]
		private Transform m_rightHandRig;

		[SerializeField]
		private Transform m_rightEquip;

		[SerializeField]
		private Transform m_rightAimPoint;

		private EventToken m_sceneLoadedEventToken;

		private EventToken m_wandGripChangedEventToken;

		private EventToken m_inputChangedEventToken;

		private EventToken m_wandControllerSpawnedEventToken;

		public Transform LeftEquip
		{
			[CompilerGenerated]
			get
			{
				return m_leftEquip;
			}
		}

		public Transform LeftAimPoint
		{
			[CompilerGenerated]
			get
			{
				return m_leftAimPoint;
			}
		}

		public Transform RightEquip
		{
			[CompilerGenerated]
			get
			{
				return m_rightEquip;
			}
		}

		public Transform RightAimPoint
		{
			[CompilerGenerated]
			get
			{
				return m_rightAimPoint;
			}
		}

		private void OnEnable()
		{
			m_sceneLoadedEventToken = EventHub.Subscribe<Events.SceneLoadedEvent>(OnSceneLoaded);
			m_wandGripChangedEventToken = EventHub.Subscribe<InputEvents.WandGripChangedEvent>(OnWandGripChanged);
			m_inputChangedEventToken = EventHub.Subscribe<InputEvents.InputChangedEvent>(OnInputChanged);
			m_wandControllerSpawnedEventToken = EventHub.Subscribe<InputEvents.WandControllerSpawnedEvent>(OnWandControllerSpawned);
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe<Events.SceneLoadedEvent>(m_sceneLoadedEventToken);
			EventHub.Unsubscribe<InputEvents.WandGripChangedEvent>(m_wandGripChangedEventToken);
			EventHub.Unsubscribe<InputEvents.InputChangedEvent>(m_inputChangedEventToken);
			EventHub.Unsubscribe<InputEvents.WandControllerSpawnedEvent>(m_wandControllerSpawnedEventToken);
		}

		private void OnSceneLoaded(Events.SceneLoadedEvent eventData)
		{
			if (!eventData.Level.ContainsFlag(Level.Arena))
			{
				HandAnimator[] animators = m_animators;
				foreach (HandAnimator handAnimator in animators)
				{
					handAnimator.DisableWandGrip();
				}
			}
		}

		private void OnWandControllerSpawned(InputEvents.WandControllerSpawnedEvent eventData)
		{
			HandAnimator[] animators = m_animators;
			foreach (HandAnimator handAnimator in animators)
			{
				handAnimator.ChangePrimaryHand(eventData.AimInput, eventData.IsDualWieldEnabled);
				handAnimator.ChangeWandGrip(eventData.WandGrip);
			}
		}

		private void OnInputChanged(InputEvents.InputChangedEvent eventData)
		{
			HandAnimator[] animators = m_animators;
			foreach (HandAnimator handAnimator in animators)
			{
				handAnimator.ChangePrimaryHand(eventData.AimInput, eventData.IsDualWieldEnabled);
				handAnimator.ChangeWandGrip(eventData.WandGrip);
			}
		}

		private void OnWandGripChanged(InputEvents.WandGripChangedEvent eventData)
		{
			HandAnimator[] animators = m_animators;
			foreach (HandAnimator handAnimator in animators)
			{
				handAnimator.ChangeWandGrip(eventData.WandGrip);
			}
		}

		public void SetPlayerReferences(PlayerControl playerControl)
		{
			HandAnimator[] animators = m_animators;
			foreach (HandAnimator handAnimator in animators)
			{
				handAnimator.SetPlayerReference(playerControl);
			}
		}

		public void ResetCustomHands(Transform leftHandParent, Transform rightHandParent)
		{
			m_leftHandRig.SetParent(leftHandParent, worldPositionStays: false);
			m_rightHandRig.SetParent(rightHandParent, worldPositionStays: false);
		}

		public void SetHandsMaterial(HandMaterialType type)
		{
			if (!m_renderers.IsNullOrEmpty() && !m_materials.IsNullOrEmpty() && (int)type <= m_materials.Length)
			{
				Material material = m_materials[(int)type];
				Renderer[] renderers = m_renderers;
				foreach (Renderer renderer in renderers)
				{
					renderer.material = material;
				}
			}
		}

		public void SetHandsActive(bool active)
		{
			m_leftHandRig.gameObject.SetActive(active);
			m_rightHandRig.gameObject.SetActive(active);
		}
	}
}
namespace Cortopia.Scripts.Player.Input
{
	public class DualWieldInputListener : InputListener, IInputListenerTwoWands, IWandControllable, IInputListener
	{
		private const int InactiveSpellSlotValue = -1;

		private readonly bool[] m_isAutoTeleportEnabled = new bool[2];

		private int m_activeSpellSlotLeft = -1;

		private int m_activeSpellSlotRight = -1;

		private bool m_wasInteractionSuccessful;

		public WandManager WandManager { get; private set; }

		public DualWieldInputListener(PlayerInput playerInput)
			: base(playerInput)
		{
		}

		public void SetWandControl(WandManager wandManager)
		{
			WandManager = wandManager;
		}

		public void OnInteractionLeftInput(InputState inputState)
		{
			OnInteractionInput(inputState, WandHand.Left);
		}

		public override void OnInteractionInput(InputState inputState)
		{
			OnInteractionInput(inputState, WandHand.Right);
		}

		private void OnInteractionInput(InputState inputState, WandHand wandHand)
		{
			switch (inputState)
			{
			case InputState.Down:
				if (base.PlayerInput.TryInteractWithObject(wandHand, setToNull: true) || base.PlayerInput.CloseMenus())
				{
					m_wasInteractionSuccessful = true;
				}
				break;
			case InputState.Up:
				if (m_wasInteractionSuccessful)
				{
					m_wasInteractionSuccessful = false;
				}
				break;
			}
		}

		public override void OnAutoTeleportLeftInput(InputState inputState)
		{
			OnAutoTeleportInput(inputState, WandHand.Left);
		}

		public override void OnAutoTeleportRightInput(InputState inputState)
		{
			OnAutoTeleportInput(inputState, WandHand.Right);
		}

		private void OnAutoTeleportInput(InputState inputState, WandHand wandHand)
		{
			if (WandManager == null || WandManager.IsSpellCastingLocked || m_wasInteractionSuccessful)
			{
				return;
			}
			switch (inputState)
			{
			case InputState.Down:
				m_isAutoTeleportEnabled[(int)wandHand] = WandManager.TrySelectTeleport(wandHand);
				break;
			case InputState.Hold:
				if (m_isAutoTeleportEnabled[(int)wandHand])
				{
					WandManager.SpellHold(wandHand);
				}
				break;
			case InputState.Up:
				WandManager.DeselectTeleport(wandHand);
				m_isAutoTeleportEnabled[(int)wandHand] = false;
				break;
			}
		}

		public void OnSpellInput01(InputState inputState)
		{
			OnSpellInput(ref m_activeSpellSlotLeft, inputState, WandHand.Left, 1);
		}

		public void OnSpellInput02(InputState inputState)
		{
			OnSpellInput(ref m_activeSpellSlotLeft, inputState, WandHand.Left, 2);
		}

		public void OnSpellInput03(InputState inputState)
		{
			OnSpellInput(ref m_activeSpellSlotRight, inputState, WandHand.Right, 1);
		}

		public void OnSpellInput04(InputState inputState)
		{
			OnSpellInput(ref m_activeSpellSlotRight, inputState, WandHand.Right, 2);
		}

		private void OnSpellInput(ref int activeSpellSlot, InputState inputState, WandHand wandHand, int spellSlotIndex)
		{
			if (WandManager == null || WandManager.IsSpellCastingLocked || m_wasInteractionSuccessful)
			{
				return;
			}
			switch (inputState)
			{
			case InputState.Down:
				if (activeSpellSlot == -1)
				{
					activeSpellSlot = spellSlotIndex;
					WandManager.SpellPress(wandHand, spellSlotIndex);
				}
				break;
			case InputState.Hold:
				if (activeSpellSlot == spellSlotIndex)
				{
					WandManager.SpellHold(wandHand);
				}
				break;
			case InputState.Up:
				if (WandManager.SpellRelease(wandHand, spellSlotIndex))
				{
					activeSpellSlot = -1;
				}
				break;
			}
		}
	}
	public class InputListener : IInputListener
	{
		private bool m_wasSecondaryAxisInputDown;

		public PlayerInput PlayerInput { get; protected set; }

		public InputListener(PlayerInput playerInput)
		{
			PlayerInput = playerInput;
		}

		public void OnMenuInput(InputState inputState)
		{
			if (inputState == InputState.Up)
			{
				EventHub.Publish(new InputEvents.SystemMenuInputEvent());
			}
		}

		public void OnSecondaryAxisInput(InputState inputState)
		{
			if ((inputState & InputState.Down) != 0)
			{
				m_wasSecondaryAxisInputDown = true;
			}
			else if ((inputState & InputState.Up) != 0)
			{
				m_wasSecondaryAxisInputDown = false;
			}
			inputState &= InputState.AxisRight | InputState.AxisLeft | InputState.AxisDown;
			if (m_wasSecondaryAxisInputDown)
			{
				switch (inputState)
				{
				case InputState.AxisRight:
					PlayerInput.RotateTowards(RotationDirection.Right);
					break;
				case InputState.AxisLeft:
					PlayerInput.RotateTowards(RotationDirection.Left);
					break;
				case InputState.AxisDown:
					PlayerInput.RotateTowards(RotationDirection.Back);
					break;
				}
			}
		}

		public virtual void OnRecenterInput(InputState inputState)
		{
			switch (inputState)
			{
			case InputState.Hold:
				PlayerInput.TryRecenterPlayer();
				break;
			case InputState.Up:
				PlayerInput.ResetRecenterPlayer();
				break;
			}
		}

		public virtual void OnReverseInput(InputState inputState)
		{
			if (inputState == InputState.Down)
			{
				PlayerInput.RotateTowards(RotationDirection.Back);
			}
		}

		public virtual void OnPrimaryInput(InputState inputState)
		{
		}

		public virtual void OnSecondaryInput(InputState inputState)
		{
		}

		public virtual void OnTeleportInput(InputState inputState)
		{
		}

		public virtual void OnAutoTeleportLeftInput(InputState inputState)
		{
		}

		public virtual void OnAutoTeleportRightInput(InputState inputState)
		{
		}

		public virtual void OnPointTriggerInput(InputState inputState)
		{
		}

		public virtual void OnSwipeInput(InputState inputState, float speed)
		{
		}

		public virtual void OnPrimaryAxisInput(InputState inputState)
		{
		}

		public virtual void OnInteractionInput(InputState inputState)
		{
		}
	}
	public class LobbyInputListener : InputListener
	{
		public LobbyInputListener(PlayerInput playerInput)
			: base(playerInput)
		{
		}

		public override void OnPrimaryInput(InputState inputState)
		{
			if (inputState == InputState.Down)
			{
				MonoSingleton<LobbyUI>.Instance.TrySkipLobbyFlow();
				base.PlayerInput.TryInteractWithObject();
			}
		}

		public override void OnInteractionInput(InputState inputState)
		{
			if (inputState == InputState.Down)
			{
				MonoSingleton<LobbyUI>.Instance.TrySkipLobbyFlow();
				base.PlayerInput.TryInteractWithObject();
			}
		}
	}
	public class MainMenuInputListener : IInputListener
	{
		public PlayerInput PlayerInput { get; }

		public MainMenuInputListener(PlayerInput playerInput)
		{
			PlayerInput = playerInput;
		}

		public void OnPrimaryInput(InputState inputState)
		{
			if (inputState == InputState.Down)
			{
				PlayerInput.TryInteractWithObject();
			}
		}

		public void OnMenuInput(InputState inputState)
		{
		}

		public void OnPointTriggerInput(InputState inputState)
		{
		}

		public void OnPrimaryAxisInput(InputState inputState)
		{
		}

		public void OnRecenterInput(InputState inputState)
		{
		}

		public void OnSecondaryAxisInput(InputState inputState)
		{
		}

		public void OnSecondaryInput(InputState inputState)
		{
		}

		public void OnStatsInput(InputState inputState)
		{
		}

		public void OnSwipeInput(InputState inputState, float speed)
		{
		}

		public void OnTeleportInput(InputState inputState)
		{
		}

		public void OnInteractionInput(InputState inputState)
		{
		}

		public void OnAutoTeleportLeftInput(InputState inputState)
		{
		}

		public void OnAutoTeleportRightInput(InputState inputState)
		{
		}

		public void OnReverseInput(InputState inputState)
		{
		}
	}
	public class MatchInputListener : InputListener, IWandControllable
	{
		private InputState m_queuedInputState;

		private WandControlOneHand m_wandControl;

		public WandManager WandManager { get; private set; }

		public MatchInputListener(PlayerInput playerInput)
			: base(playerInput)
		{
		}

		public void SetWandControl(WandManager wandManager)
		{
			WandManager = wandManager;
			m_wandControl = wandManager.GetWandControl() as WandControlOneHand;
		}

		public override void OnPrimaryInput(InputState inputState)
		{
			if (WandManager == null || m_wandControl == null)
			{
				if (inputState == InputState.Down)
				{
					base.PlayerInput.TryInteractWithObject(setToNull: true);
				}
				return;
			}
			if (m_wandControl.WandInput.ContainsFlag(WandInput.Directional))
			{
				if (m_wandControl.Wielder.CharacterControl.IsTeleporting)
				{
					switch (inputState)
					{
					case InputState.Down:
						m_queuedInputState = InputState.Down;
						break;
					case InputState.Up:
						m_queuedInputState = InputState.None;
						break;
					}
					return;
				}
				if (m_wandControl.IsSpellTypeSelected(Spell.Spell_Teleport))
				{
					switch (inputState)
					{
					case InputState.Down:
						m_queuedInputState = InputState.Down;
						break;
					case InputState.Up:
						m_queuedInputState = InputState.None;
						break;
					}
				}
				else if (m_queuedInputState != 0)
				{
					InputState queuedInputState = m_queuedInputState;
					m_queuedInputState = InputState.None;
					OnPrimaryInput(queuedInputState);
				}
			}
			switch (inputState)
			{
			case InputState.Down:
				if (base.PlayerInput.TryInteractWithObject(setToNull: true))
				{
					m_queuedInputState = InputState.None;
					break;
				}
				if (base.PlayerInput.CloseMenus())
				{
					m_queuedInputState = InputState.None;
					break;
				}
				if (m_wandControl.UI.IsActive ^ m_wandControl.UI.IsScaling)
				{
					m_wandControl.ToggleSpellSelectionUi(active: false, selectHighlightedRadialElement: false);
				}
				WandManager.TryCastingSpell(inputState);
				break;
			case InputState.Up:
			case InputState.Hold:
				WandManager.TryCastingSpell(inputState);
				break;
			}
		}

		public override void OnSecondaryInput(InputState inputState)
		{
			bool? flag = WandManager?.IsSpellCastingLocked;
			if (!flag.HasValue || flag.Value || m_wandControl == null)
			{
				return;
			}
			switch (inputState)
			{
			case InputState.Down:
				if (m_wandControl.ToggleSpellSelectionUi(active: true))
				{
					base.PlayerInput.CloseMenus();
				}
				break;
			case InputState.Up:
				m_wandControl.ToggleSpellSelectionUi(active: false);
				break;
			}
		}

		public override void OnTeleportInput(InputState inputState)
		{
			bool? flag = WandManager?.IsSpellCastingLocked;
			if (flag.HasValue && !flag.Value)
			{
				switch (inputState)
				{
				case InputState.Down:
					m_wandControl.TrySelectTeleport();
					break;
				case InputState.Up:
					WandManager.TryCastAndDeselectTeleport();
					break;
				}
			}
		}

		public override void OnInteractionInput(InputState inputState)
		{
			if (inputState == InputState.Down && !base.PlayerInput.TryInteractWithObject(setToNull: true))
			{
				base.PlayerInput.CloseMenus();
			}
		}

		public override void OnSwipeInput(InputState inputState, float speed)
		{
			bool? flag = WandManager?.IsSpellCastingLocked;
			if (flag.HasValue && !flag.Value && !(m_wandControl == null))
			{
				inputState &= ~InputState.Axis;
				if (inputState == InputState.Up && m_wandControl.ToggleSpellSelectionUi())
				{
					base.PlayerInput.CloseMenus();
				}
			}
		}

		public override void OnPrimaryAxisInput(InputState inputState)
		{
			bool? flag = WandManager?.IsSpellCastingLocked;
			if (flag.HasValue && !flag.Value && !(m_wandControl == null))
			{
				bool selectSpell = (inputState & InputState.Down) != 0;
				switch ((inputState != InputState.Up) ? (inputState & InputState.Axis) : InputState.Up)
				{
				case InputState.Up:
					m_wandControl.HighlightSpellSlot(PrimaryAxisState.Release, selectSpell: true);
					break;
				case InputState.AxisRight:
					m_wandControl.HighlightSpellSlot(PrimaryAxisState.Right, selectSpell);
					break;
				case InputState.AxisLeft:
					m_wandControl.HighlightSpellSlot(PrimaryAxisState.Left, selectSpell);
					break;
				case InputState.AxisUp:
					m_wandControl.HighlightSpellSlot(PrimaryAxisState.Up, selectSpell);
					break;
				case InputState.AxisDown:
					m_wandControl.HighlightSpellSlot(PrimaryAxisState.Down, selectSpell);
					break;
				}
			}
		}
	}
	public class WorkshopInputListener : InputListener
	{
		private bool m_isAutoTeleportEnabled;

		public WorkshopInputListener(PlayerInput playerInput)
			: base(playerInput)
		{
			m_isAutoTeleportEnabled = playerInput.InputManager.IsAutoTeleportEnabled;
		}

		public override void OnPrimaryInput(InputState inputState)
		{
			OnInteractInput(inputState);
		}

		public override void OnPointTriggerInput(InputState inputState)
		{
			OnInteractInput(inputState);
		}

		public override void OnRecenterInput(InputState inputState)
		{
			switch (inputState)
			{
			case InputState.Hold:
				base.PlayerInput.TryRecenterPlayer();
				break;
			case InputState.Up:
				base.PlayerInput.ResetRecenterPlayer();
				break;
			}
		}

		public override void OnTeleportInput(InputState inputState)
		{
			OnInteractInput(inputState);
		}

		public override void OnAutoTeleportLeftInput(InputState inputState)
		{
			OnAutoInteract(inputState);
		}

		public override void OnAutoTeleportRightInput(InputState inputState)
		{
			OnAutoInteract(inputState);
		}

		private void OnInteractInput(InputState inputState)
		{
			switch (inputState)
			{
			case InputState.Down:
				base.PlayerInput.TryInteractWithWorkshopObject(m_isAutoTeleportEnabled);
				base.PlayerInput.EnableDrag();
				break;
			case InputState.Up:
				base.PlayerInput.DisableDrag();
				break;
			}
		}

		private void OnAutoInteract(InputState inputState)
		{
			switch (inputState)
			{
			case InputState.Down:
				base.PlayerInput.TryInteractWithWorkshopObject(m_isAutoTeleportEnabled);
				base.PlayerInput.EnableDrag();
				break;
			case InputState.Hold:
				base.PlayerInput.TryInteractWithWorkshopTile();
				break;
			case InputState.Up:
				base.PlayerInput.DisableDrag();
				break;
			}
		}
	}
}
namespace Assets.Scripts.Player
{
	public class Loadout
	{
		public bool Locked { get; set; }

		public WandType[] Wands { get; set; }

		public Spell[] Spells { get; set; }

		public Loadout(bool isLocked)
		{
			Locked = isLocked;
			Wands = Constants.DefaultWands.Take(2).ToArray();
			Spells = Constants.DefaultSpells.Take(5).ToArray();
		}

		public override string ToString()
		{
			string text = string.Empty;
			WandType[] wands = Wands;
			foreach (WandType wandType in wands)
			{
				text += wandType;
				text += ',';
			}
			text.TrimEnd(',');
			text += " | ";
			Spell[] spells = Spells;
			foreach (Spell spell in spells)
			{
				text += spell;
				text += ',';
			}
			return text.TrimEnd(',');
		}
	}
	public class Player
	{
		private readonly ISaveManager m_saveManager;

		public PlayerSaveData SaveData { get; private set; }

		public PlayerLogInObject LogInObject { get; private set; }

		public PlayerInventory Inventory { get; private set; }

		public string PlayFabPlayerId { get; set; }

		public bool NewPlayFabUser { get; set; }

		public global::PlayFab.ClientModels.EntityKey PlayFabEntityKey { get; set; }

		public RewardModifiers RewardModifiers { get; set; }

		public CharacterType Character
		{
			get
			{
				CharacterType intPref = (CharacterType)WandsSave.GetIntPref("V0");
				Assets.Scripts.Platform.Platform platform = GameControl.Instance.Platform;
				return (platform.GetBaseCharactersNonAlloc().Contains(intPref) || platform.GetSpecialCharactersNonAlloc().Contains(intPref)) ? intPref : CharacterType.Scavenger;
			}
			set
			{
				WandsSave.SetPlayerPref("V0", (int)value);
				PlayerProperty.Set("C0", (int)value);
				Events.CharacterTypeChangedEvent characterTypeChangedEvent = new Events.CharacterTypeChangedEvent();
				characterTypeChangedEvent.CharacterType = value;
				EventHub.Publish(characterTypeChangedEvent);
			}
		}

		public int ActiveLoadoutIndex { get; private set; }

		public Loadout ActiveLoadout
		{
			[CompilerGenerated]
			get
			{
				return SaveData.Loadouts[ActiveLoadoutIndex];
			}
		}

		public Title Title { get; private set; }

		public int Level
		{
			[CompilerGenerated]
			get
			{
				return SaveData.LevelData.Level;
			}
		}

		public int Rating
		{
			[CompilerGenerated]
			get
			{
				return (int)PlayerProperty.Get("EL");
			}
		}

		public int SeasonScore
		{
			[CompilerGenerated]
			get
			{
				return (int)PlayerProperty.Get("SS");
			}
		}

		public int HighestRating { get; set; }

		public int Rank { get; set; }

		public bool IsLoggedInToPlatform
		{
			[CompilerGenerated]
			get
			{
				return LogInObject.IsOnline;
			}
		}

		public bool HasUnlockedRating
		{
			[CompilerGenerated]
			get
			{
				return SaveData.LevelData.Level >= 5;
			}
		}

		public TutorialState TutorialState
		{
			get
			{
				return (TutorialState)WandsSave.GetIntPref("TU");
			}
			set
			{
				if (TutorialState != value)
				{
					WandsSave.SetPlayerPref("TU", (int)value);
					switch (value)
					{
					case TutorialState.EnteredWorkshop:
						SetCompletedTutorial(completed: false, saveToServer: true);
						WandsAnalytics.SendCustomEvent(CustomEventType.player_started_tutorial);
						break;
					case TutorialState.Completed:
						SetCompletedTutorial(completed: true, saveToServer: true);
						GameControl.Instance.UnlockAchievement(Assets.Scripts.Enums.AchievementType.TutorialComplete);
						WandsAnalytics.SendCustomEvent(CustomEventType.player_completed_tutorial);
						break;
					default:
						WandsAnalytics.SendCustomEvent(CustomEventType.player_changed_tutorial_state, new Dictionary<string, object> { 
						{
							"NewTutorialState",
							(int)value
						} });
						break;
					}
					Events.TutorialProgressedEvent tutorialProgressedEvent = new Events.TutorialProgressedEvent();
					tutorialProgressedEvent.State = value;
					EventHub.Publish(tutorialProgressedEvent);
				}
			}
		}

		public int PostTutorialTriggers
		{
			get
			{
				return WandsSave.GetIntPref("PTT");
			}
			set
			{
				WandsSave.SetPlayerPref("PTT", value);
			}
		}

		public Player(ISaveManager saveManager, PlayerLogInObject logInObject)
		{
			m_saveManager = saveManager;
			SaveData = new PlayerSaveData();
			LogInObject = logInObject;
			SetTitle((Title)WandsSave.GetIntPref("V2", 400));
			Character = Character;
			RemovePostTutorialTrigger(PostTutorialTriggerType.EnteredWorkshop);
		}

		public void SetActiveLoadoutIndex(int loadoutIndex)
		{
			ActiveLoadoutIndex = loadoutIndex;
			PlayerProperty.SetLoadoutWands(GetWand(), GetWand(WandHand.Left));
		}

		public WandType GetWand(WandHand wandHand = WandHand.Right)
		{
			return SaveData.Loadouts[ActiveLoadoutIndex].Wands[(int)wandHand];
		}

		public void SetWand(WandHand wandHand, WandType wandType)
		{
			WandType wand = GetWand(wandHand);
			SaveData.Loadouts[ActiveLoadoutIndex].Wands[(int)wandHand] = wandType;
			WandsAnalytics.SendCustomEvent(CustomEventType.player_equipped_wand, new Dictionary<string, object>
			{
				{
					"CurrentLoadoutInfo",
					$"Loadout: {ActiveLoadoutIndex} | Hand: {wandHand}"
				},
				{
					"OldWandId",
					(int)wand
				},
				{
					"NewWandId",
					(int)wandType
				}
			});
		}

		public void SetTitle(Title title)
		{
			Title = title;
			WandsSave.SetPlayerPref("V2", (int)title);
			if (GetOwnedTitles().TryGetValue(title, out var value))
			{
				PlayerProperty.Set("C3", value.DisplayName);
			}
		}

		public void SaveCustomEventRewards(SaveDataObject saveDataObject)
		{
			m_saveManager.SaveCustomEventRewards(saveDataObject);
		}

		private void SendCustomPurchasedItemEvent(int itemType, int itemId, CatalogItemWrapper data)
		{
			WandsAnalytics.SendCustomEvent(CustomEventType.player_purchased_item, new Dictionary<string, object>
			{
				{ "ItemType", itemType },
				{ "ItemId", itemId },
				{
					"VirtualCurrency",
					SaveData.VirtualCurrency + data.DustPrice
				},
				{ "ItemCost", data.DustPrice }
			});
		}

		public SaveDataObject CreateFullSaveDataObject()
		{
			SaveDataObject saveDataObject = PlayerSaveData.CreateSaveDataObject();
			saveDataObject.AddField(PlayFabSaveField.LevelData, SaveData.LevelDataSerialized);
			saveDataObject.AddField(PlayFabSaveField.VirtualCurrency, SaveData.VirtualCurrencySerialized);
			saveDataObject.AddField(PlayFabSaveField.GameAccess, SaveData.GameAccessSerialized);
			saveDataObject.AddField(PlayFabSaveField.Loadouts, SaveData.LoadoutsSerialized);
			saveDataObject.AddField(PlayFabSaveField.MatchData, SaveData.MatchDataSerialized);
			saveDataObject.AddField(PlayFabSaveField.CompletedTutorial, SaveData.CompletedTutorialSerialized);
			saveDataObject.AddField(PlayFabSaveField.AchievementData, SaveData.AchievementDataSerialized);
			return saveDataObject;
		}

		public void Initialize(GetUserInventoryResult inventory, GetUserDataResult userData, GetPlayerStatisticsResult rating)
		{
			InitializeInventory(inventory);
			InitializeDataAsync(userData, delegate
			{
				InitializeRating(rating);
			});
		}

		private void InitializeInventory(GetUserInventoryResult result)
		{
			Inventory = new PlayerInventory();
			foreach (ItemInstance item in result.Inventory)
			{
				Inventory.TryAddItem(item.ItemId);
			}
		}

		public void InitializeDataAsync(GetUserDataResult result, Action onComplete)
		{
			if (result.Data == null || result.Data.Count == 0)
			{
				GameControl.Instance.LoadNewUser();
				return;
			}
			if (result.Data.ContainsKey("IsDeveloper"))
			{
				SaveData.IsDeveloper = bool.Parse(result.Data["IsDeveloper"].Value);
			}
			bool hasException = false;
			bool hasFailure = false;
			Task.Run(delegate
			{
				foreach (IDataParser asynchronousParser in SaveData.AsynchronousParsers)
				{
					switch (asynchronousParser.Parse(result.Data))
					{
					case ParseState.Exception:
						hasException = true;
						break;
					case ParseState.Failure:
						hasFailure = true;
						break;
					}
				}
			}).ContinueWith(delegate(Task task)
			{
				if (task.IsFaulted)
				{
					WandsLogger.LogError("Data parser failed with exception: " + task.Exception);
				}
				else
				{
					foreach (IDataParser synchronousParser in SaveData.SynchronousParsers)
					{
						switch (synchronousParser.Parse(result.Data))
						{
						case ParseState.Exception:
							hasException = true;
							break;
						case ParseState.Failure:
							hasFailure = true;
							break;
						}
					}
					if (hasException)
					{
						WandsLogger.LogError("One of the data parsers failed for unknown reason.");
					}
					else if (hasFailure)
					{
						m_saveManager.SavePlayerData();
					}
					onComplete();
				}
			}, TaskScheduler.FromCurrentSynchronizationContext());
		}

		public void InitializeRating(GetPlayerStatisticsResult result)
		{
			if (result.Statistics.IsNullOrEmpty())
			{
				WandsLogger.LogError("Statistics couldn't be initialized.", LogColor.PlayerData);
				return;
			}
			foreach (StatisticValue statistic in result.Statistics)
			{
				if (!Enum.TryParse<PlayFabStatisticsField>(statistic.StatisticName, out var result2))
				{
					WandsLogger.LogError($"Statistic {statistic.StatisticName} couldn't be parsed.", LogColor.PlayerData);
					continue;
				}
				switch (result2)
				{
				case PlayFabStatisticsField.Rating:
					UpdateRating(statistic.Value, NewPlayFabUser);
					break;
				case PlayFabStatisticsField.SeasonScore:
					UpdateSeasonScore(statistic.Value, NewPlayFabUser);
					break;
				}
			}
		}

		public void HandleFirstTimeUser(Action onCompleted)
		{
			SetCompletedTutorial(completed: false);
			SetGameAccess(GameControl.Instance.Platform.GetGameAccess());
			if (HasGameAccess(GameAccess.Free))
			{
				WandsAnalytics.SendCustomEvent(CustomEventType.player_installed_free_to_play);
			}
			SavePlayerData(onCompleted);
		}

		public void SaveUserName(Action onCompleted = null)
		{
			string userName = ((!string.IsNullOrEmpty(LogInObject.UserName)) ? LogInObject.UserName : LogInObject.UserId).Truncate(25);
			m_saveManager.SaveUserName(userName, delegate
			{
				onCompleted?.Invoke();
			}, delegate
			{
				EventHub.Publish(new Events.PlayfabDataLoadedEvent
				{
					Success = false
				});
			});
		}

		private void SavePlayerData(Action onCompleted = null)
		{
			m_saveManager.SavePlayerData(delegate(ExecuteCloudScriptResult result)
			{
				OnSavePlayerDataSuccess(result, onCompleted);
			}, delegate
			{
				EventHub.Publish(new Events.PlayfabDataLoadedEvent
				{
					Success = false
				});
			});
		}

		private void OnSavePlayerDataSuccess(ExecuteCloudScriptResult result, Action onCompleted)
		{
			onCompleted?.Invoke();
		}

		private void SaveItem(CatalogVersion catalogVersion, string itemId)
		{
			SaveItems(catalogVersion, new string[1] { itemId });
		}

		private void SaveItems(CatalogVersion catalogVersion, string[] itemIds)
		{
			InventorySaveObject inventorySaveObject = new InventorySaveObject();
			inventorySaveObject.CatalogVersion = catalogVersion.ToString();
			inventorySaveObject.Items = itemIds;
			InventorySaveObject inventorySaveObject2 = inventorySaveObject;
			m_saveManager.SaveItemsToInventory(inventorySaveObject2);
		}

		public void SaveEntireInventory()
		{
		}

		public void AddVirtualCurrency(int amount, VirtualCurrencySource source, bool saveToServer = false)
		{
			if (amount != 0)
			{
				UpdateVirtualCurrency(SaveData.VirtualCurrency + amount, source, saveToServer);
			}
		}

		public void SubtractVirtualCurrency(int amount, VirtualCurrencySource source, bool saveToServer = false)
		{
			if (amount != 0)
			{
				UpdateVirtualCurrency(SaveData.VirtualCurrency - amount, source, saveToServer);
			}
		}

		private void UpdateVirtualCurrency(int newValue, VirtualCurrencySource source, bool saveToServer = false)
		{
			SaveData.VirtualCurrency = Mathf.Clamp(newValue, 0, int.MaxValue);
			if (source == VirtualCurrencySource.Dailies || source == VirtualCurrencySource.LevelUp)
			{
				WandsAnalytics.SendCustomEvent(CustomEventType.player_earned_virtual_currency, new Dictionary<string, object>
				{
					{
						"Reason",
						(int)source
					},
					{
						"Amount",
						newValue - SaveData.VirtualCurrency
					}
				});
			}
			Events.VirtualCurrencyChanged virtualCurrencyChanged = new Events.VirtualCurrencyChanged();
			virtualCurrencyChanged.Amount = SaveData.VirtualCurrency;
			EventHub.Publish(virtualCurrencyChanged);
			if (saveToServer)
			{
				SaveVirtualCurrency();
			}
		}

		private void SaveVirtualCurrency()
		{
			SaveDataObject saveDataObject = PlayerSaveData.CreateSaveDataObject();
			saveDataObject.AddField(PlayFabSaveField.VirtualCurrency, SaveData.VirtualCurrencySerialized);
			m_saveManager.SaveUnlockedData(saveDataObject, PlayFabRequestType.SaveVirtualCurrency);
		}

		public bool CanAfford(int price)
		{
			return SaveData.VirtualCurrency >= price;
		}

		public void ActivatePostTutorialTrigger(PostTutorialTriggerType type)
		{
			PostTutorialTriggers |= (int)type;
			Events.PostTutorialTriggeredEvent postTutorialTriggeredEvent = new Events.PostTutorialTriggeredEvent();
			postTutorialTriggeredEvent.Trigger = type;
			EventHub.Publish(postTutorialTriggeredEvent);
		}

		public void RemovePostTutorialTrigger(PostTutorialTriggerType type)
		{
			PostTutorialTriggers &= (int)(~type);
		}

		public bool IsPostTutorialTriggered(PostTutorialTriggerType type)
		{
			return ((uint)type & (uint)PostTutorialTriggers) != 0;
		}

		public void UnlockLoadoutsByLevel(int level)
		{
			int num = PlayerUtils.LevelToLoadouts(level);
			Loadout[] loadouts = SaveData.Loadouts;
			for (int i = 0; i < loadouts.Length; i++)
			{
				loadouts[i].Locked = i >= num;
			}
		}

		public void UpdateCurrentLoadout(Spell[] spells, bool saveToServer = false)
		{
			if (HasLoadoutChanged(spells) && SaveData.MatchData.MatchesPlayed > 0 && TutorialState == TutorialState.Completed)
			{
				GameControl.Instance.UnlockAchievement(Assets.Scripts.Enums.AchievementType.ChangeRelicLoadout);
			}
			SaveData.Loadouts[ActiveLoadoutIndex].Spells = spells;
			if (saveToServer)
			{
				SaveCurrentLoadout();
			}
		}

		public Spell[] GetCurrentLoadoutSpells()
		{
			return GetLoadoutSpells(ActiveLoadoutIndex);
		}

		public Spell[] GetLoadoutSpells(int wandIndex)
		{
			Loadout[] loadouts = SaveData.Loadouts;
			return (loadouts != null) ? loadouts[wandIndex].Spells : null;
		}

		public WandType[] GetCurrentLoadoutWands()
		{
			Loadout[] loadouts = SaveData.Loadouts;
			return (loadouts != null) ? loadouts[ActiveLoadoutIndex].Wands : null;
		}

		public WandType[] GetLoadoutWands(int wandIndex)
		{
			Loadout[] loadouts = SaveData.Loadouts;
			return (loadouts != null) ? loadouts[wandIndex].Wands : null;
		}

		public Loadout GetLoadout(int loadoutIndex)
		{
			return SaveData.Loadouts[loadoutIndex];
		}

		public Loadout[] GetUnlockedLoadouts()
		{
			return SaveData.Loadouts.Where((Loadout p) => !p.Locked).ToArray();
		}

		private void SaveCurrentLoadout()
		{
			SaveDataObject saveDataObject = PlayerSaveData.CreateSaveDataObject();
			saveDataObject.AddField(PlayFabSaveField.Loadouts, SaveData.LoadoutsSerialized);
			m_saveManager.SaveLoadouts(saveDataObject);
		}

		private bool HasLoadoutChanged(Spell[] spells)
		{
			if (spells.Length != SaveData.Loadouts[ActiveLoadoutIndex].Spells.Length)
			{
				return true;
			}
			bool result = false;
			for (int i = 0; i < spells.Length; i++)
			{
				if (!SaveData.Loadouts[ActiveLoadoutIndex].Spells.Any((Spell x) => x == spells[i]))
				{
					result = true;
					break;
				}
			}
			return result;
		}

		public void UpdateRating(int rating, bool saveToServer = false)
		{
			SetRatingScore(ref rating);
			HighestRating = Mathf.Max(HighestRating, rating);
			List<Title> list = new List<Title>(3);
			foreach (KeyValuePair<Title, int> skillLevelTitle in Constants.SkillLevelTitles)
			{
				if (HighestRating >= skillLevelTitle.Value)
				{
					list.Add(skillLevelTitle.Key);
				}
			}
			if (rating >= Constants.RatingTitles[RatingTitle.Legend])
			{
				list.Add(Title.AngelOfDeath);
			}
			if (!list.IsEmpty())
			{
				TryAddTitlesToInventory(list, saveToServer: true);
				if (saveToServer)
				{
					m_saveManager.SaveStatistics(PlayFabStatisticsField.Rating, rating);
				}
			}
		}

		public void SetRatingScore(ref int rating)
		{
			if (SaveData.IsDeveloper)
			{
				rating = -1;
			}
			else if (SaveData.LevelData.Level < 5)
			{
				rating = 0;
			}
			else if (rating == 0)
			{
				rating = 1500;
			}
			rating = Mathf.Max(rating, -1);
			PlayerProperty.Set("EL", rating);
		}

		public void UpdateSeasonScore(int seasonScore, bool saveToServer = false)
		{
			SetSeasonScore(ref seasonScore);
			if (saveToServer)
			{
				m_saveManager.SaveStatistics(PlayFabStatisticsField.SeasonScore, seasonScore);
			}
		}

		public void SetSeasonScore(ref int seasonScore)
		{
			if (SaveData.IsDeveloper)
			{
				seasonScore = -1;
			}
			else if (SaveData.LevelData.Level < 5)
			{
				seasonScore = 0;
			}
			seasonScore = Mathf.Max(seasonScore, -1);
			PlayerProperty.Set("SS", seasonScore);
		}

		public bool TryUpdateLastMatchDate()
		{
			if ((DateTime.Now - SaveData.MatchData.LastMatchDate).TotalDays >= 1.0)
			{
				SaveData.MatchData.LastMatchDate = DateTime.Now;
				SaveMatchData();
				return true;
			}
			return false;
		}

		public bool TryUpdateLastWinDate()
		{
			if ((DateTime.Now - SaveData.MatchData.LastWinDate).TotalDays >= 1.0)
			{
				SaveData.MatchData.LastWinDate = DateTime.Now;
				SaveMatchData();
				return true;
			}
			return false;
		}

		public void IncrementMatchesPlayed()
		{
			SaveData.MatchData.MatchesPlayed++;
			SaveMatchData();
		}

		public void IncrementMatchesWon()
		{
			SaveData.MatchData.MatchesWon++;
			SaveMatchData();
		}

		public void IncrementMatchesWonForArena(string arenaName)
		{
			if (SaveData.MatchData.MatchesWonPerArena == null)
			{
				SaveData.MatchData.MatchesWonPerArena = new Dictionary<string, int>();
			}
			if (!SaveData.MatchData.MatchesWonPerArena.ContainsKey(arenaName))
			{
				SaveData.MatchData.MatchesWonPerArena.Add(arenaName, 0);
			}
			SaveData.MatchData.MatchesWonPerArena[arenaName]++;
			SaveMatchData();
		}

		public bool HasWonInEveryArena()
		{
			string[] array = new string[6]
			{
				Assets.Scripts.Enums.Level.AspisPrison.ToString(),
				Assets.Scripts.Enums.Level.TempleOfOphidian.ToString(),
				Assets.Scripts.Enums.Level.TheCelestialHalls.ToString(),
				Assets.Scripts.Enums.Level.OrtusStation.ToString(),
				Assets.Scripts.Enums.Level.DeadMastersVale.ToString(),
				Assets.Scripts.Enums.Level.SanctumOfSahir.ToString()
			};
			bool result = true;
			for (int i = 0; i < array.Length; i++)
			{
				int value = 0;
				SaveData.MatchData.MatchesWonPerArena.TryGetValue(array[i], out value);
				if (value == 0)
				{
					result = false;
					break;
				}
			}
			return result;
		}

		private void SaveMatchData()
		{
			SaveDataObject saveDataObject = PlayerSaveData.CreateSaveDataObject();
			saveDataObject.AddField(PlayFabSaveField.MatchData, SaveData.MatchDataSerialized);
			m_saveManager.SaveMatchData(saveDataObject);
		}

		public bool HasGameAccess(GameAccess accessLevel)
		{
			return SaveData.GameAccess == accessLevel;
		}

		public void SetGameAccess(GameAccess access, bool saveToServer = false, Action<ExecuteCloudScriptResult> saveCompleted = null)
		{
			SaveData.GameAccess = access;
			if (saveToServer)
			{
				SaveGameAccess(saveCompleted);
			}
		}

		private void SaveGameAccess(Action<ExecuteCloudScriptResult> saveCompleted = null)
		{
			SaveDataObject saveDataObject = PlayerSaveData.CreateSaveDataObject();
			saveDataObject.AddField(PlayFabSaveField.GameAccess, SaveData.GameAccessSerialized);
			m_saveManager.SaveGameAccess(saveDataObject, saveCompleted);
		}

		public void VerifyTutorialState()
		{
			if (!SaveData.CompletedTutorial && WandsSave.GetIntPref("TU") == 100)
			{
				SetCompletedTutorial(completed: true, saveToServer: true);
			}
		}

		private void SetCompletedTutorial(bool completed, bool saveToServer = false, Action<ExecuteCloudScriptResult> saveCompleted = null)
		{
			SaveData.CompletedTutorial = completed;
			if (saveToServer)
			{
				SaveCompletedTutorial(saveCompleted);
			}
		}

		private void SaveCompletedTutorial(Action<ExecuteCloudScriptResult> saveCompleted = null)
		{
			SaveDataObject saveDataObject = PlayerSaveData.CreateSaveDataObject();
			saveDataObject.AddField(PlayFabSaveField.CompletedTutorial, SaveData.CompletedTutorialSerialized);
			m_saveManager.SaveCompletedTutorial(saveDataObject, saveCompleted);
		}

		public bool IsAchievementUnlocked(Assets.Scripts.Enums.AchievementType achievementType)
		{
			bool result = false;
			PlayerAchievementCollectionData.AchievementData achievementData = SaveData.AchievementData.Achievements.Find((PlayerAchievementCollectionData.AchievementData x) => x.Type == achievementType);
			if (achievementData != null)
			{
				result = achievementData.IsUnlocked;
			}
			return result;
		}

		public void RecordAchievementUnlocked(Assets.Scripts.Enums.AchievementType achievementType)
		{
			PlayerAchievementCollectionData.AchievementData achievementData = SaveData.AchievementData.Achievements.Find((PlayerAchievementCollectionData.AchievementData x) => x.Type == achievementType);
			if (achievementData != null)
			{
				achievementData.IsUnlocked = true;
			}
			else
			{
				achievementData = new PlayerAchievementCollectionData.AchievementData();
				achievementData.Type = achievementType;
				achievementData.IsUnlocked = true;
				SaveData.AchievementData.Achievements.Add(achievementData);
			}
			SaveAchievementData();
		}

		public int RecordAchievementIncremented(Assets.Scripts.Enums.AchievementType achievementType, int count)
		{
			PlayerAchievementCollectionData.AchievementData achievementData = SaveData.AchievementData.Achievements.Find((PlayerAchievementCollectionData.AchievementData x) => x.Type == achievementType);
			if (achievementData != null)
			{
				achievementData.Count += count;
			}
			else
			{
				achievementData = new PlayerAchievementCollectionData.AchievementData();
				achievementData.Type = achievementType;
				achievementData.IsUnlocked = false;
				achievementData.Count = count;
				SaveData.AchievementData.Achievements.Add(achievementData);
			}
			SaveAchievementData();
			return achievementData.Count;
		}

		private void SaveAchievementData()
		{
			SaveDataObject saveDataObject = PlayerSaveData.CreateSaveDataObject();
			saveDataObject.AddField(PlayFabSaveField.AchievementData, SaveData.AchievementDataSerialized);
			m_saveManager.SaveAchievementData(saveDataObject);
		}

		public void SyncAchievementsFromServer(object serverData)
		{
			List<PlayerAchievementCollectionData.AchievementData> achievementsFromServer = serverData as List<PlayerAchievementCollectionData.AchievementData>;
			for (int i = 0; i < achievementsFromServer.Count; i++)
			{
				PlayerAchievementCollectionData.AchievementData achievementData = SaveData.AchievementData.Achievements.Find((PlayerAchievementCollectionData.AchievementData x) => x.Type == achievementsFromServer[i].Type);
				if (achievementData != null)
				{
					achievementData.Count = achievementsFromServer[i].Count;
					achievementData.IsUnlocked = achievementsFromServer[i].IsUnlocked;
				}
				else
				{
					SaveData.AchievementData.Achievements.Add(achievementsFromServer[i]);
				}
			}
		}

		public void BuyCharacter(CharacterType characterType)
		{
			CatalogItemWrapper catalogItemWrapper = TryAddCharacterToInventory(characterType);
			if (catalogItemWrapper != null)
			{
				SaveItem(CatalogVersion.Characters, catalogItemWrapper.ItemId);
				SubtractVirtualCurrency(catalogItemWrapper.DustPrice, VirtualCurrencySource.PurchasedCharacter, saveToServer: true);
				SendCustomPurchasedItemEvent(2, (int)characterType, catalogItemWrapper);
			}
		}

		public CatalogItemWrapper TryAddCharacterToInventory(CharacterType characterType, bool saveToServer = false)
		{
			CatalogItemWrapper character = WandsDatabase.GetCharacter(characterType);
			if (character == null)
			{
				return null;
			}
			if (!Inventory.TryAddItem(character.ItemId))
			{
				return null;
			}
			if (saveToServer)
			{
				SaveItem(CatalogVersion.Characters, character.ItemId);
			}
			return character;
		}

		public void TryAddCharactersToInventory(List<CharacterType> characterTypes, bool saveToServer = false)
		{
			List<string> list = new List<string>(16);
			foreach (CharacterType characterType in characterTypes)
			{
				CatalogItemWrapper catalogItemWrapper = TryAddCharacterToInventory(characterType);
				if (catalogItemWrapper != null)
				{
					list.Add(catalogItemWrapper.ItemId);
				}
			}
			if (saveToServer && !list.IsEmpty())
			{
				SaveItems(CatalogVersion.Characters, list.ToArray());
			}
		}

		public bool OwnsCharacter(CharacterType characterType)
		{
			CatalogItemWrapper character = WandsDatabase.GetCharacter(characterType);
			return Inventory.ContainsItem(character.ItemId);
		}

		public Dictionary<CharacterType, CatalogItemWrapper> GetOwnedCharacters()
		{
			Dictionary<CharacterType, CatalogItemWrapper> allCharactersNonAlloc = WandsDatabase.GetAllCharactersNonAlloc();
			IEnumerable<KeyValuePair<CharacterType, CatalogItemWrapper>> source = allCharactersNonAlloc.Where((KeyValuePair<CharacterType, CatalogItemWrapper> p) => Inventory.ContainsItem(p.Value.ItemId));
			return source.ToDictionary((KeyValuePair<CharacterType, CatalogItemWrapper> k) => k.Key, (KeyValuePair<CharacterType, CatalogItemWrapper> v) => v.Value);
		}

		public int GetNumberOfOwnedCharacters()
		{
			return WandsDatabase.GetAllCharacters().Count((KeyValuePair<CharacterType, CatalogItemWrapper> p) => Inventory.ContainsItem(p.Value.ItemId));
		}

		public void TryUnlockImpossibleBotReward()
		{
			if (!GetOwnedWands().ContainsKey(WandType.Crystal))
			{
				CatalogItemWrapper catalogItemWrapper = TryAddWandToInventory(WandType.Crystal, saveToServer: true);
				if (catalogItemWrapper == null)
				{
					WandsLogger.LogError("Crystal wand couldn't be unlocked.", LogColor.Inventory);
				}
			}
		}

		public void BuyWand(WandType wandType)
		{
			CatalogItemWrapper catalogItemWrapper = TryAddWandToInventory(wandType);
			if (catalogItemWrapper != null)
			{
				SaveItem(CatalogVersion.Wands, catalogItemWrapper.ItemId);
				SubtractVirtualCurrency(catalogItemWrapper.DustPrice, VirtualCurrencySource.PurchasedWand, saveToServer: true);
				SendCustomPurchasedItemEvent(1, (int)wandType, catalogItemWrapper);
				Events.WandPurchasedEvent wandPurchasedEvent = new Events.WandPurchasedEvent();
				wandPurchasedEvent.WandType = wandType;
				EventHub.Publish(wandPurchasedEvent);
			}
		}

		public CatalogItemWrapper TryAddWandToInventory(WandType wandType, bool saveToServer = false)
		{
			CatalogItemWrapper wand = WandsDatabase.GetWand(wandType);
			if (wand == null)
			{
				return null;
			}
			if (!Inventory.TryAddItem(wand.ItemId))
			{
				return null;
			}
			if (saveToServer)
			{
				SaveItem(CatalogVersion.Wands, wand.ItemId);
			}
			return wand;
		}

		public void TryAddWandsToInventory(List<WandType> wandTypes, bool saveToServer = false)
		{
			List<string> list = new List<string>(16);
			foreach (WandType wandType in wandTypes)
			{
				CatalogItemWrapper catalogItemWrapper = TryAddWandToInventory(wandType);
				if (catalogItemWrapper != null)
				{
					list.Add(catalogItemWrapper.ItemId);
				}
			}
			if (saveToServer && !list.IsEmpty())
			{
				SaveItems(CatalogVersion.Wands, list.ToArray());
			}
		}

		public bool OwnsWand(WandType type)
		{
			CatalogItemWrapper wand = WandsDatabase.GetWand(type);
			return Inventory.ContainsItem(wand.ItemId);
		}

		public Dictionary<WandType, CatalogItemWrapper> GetOwnedWands()
		{
			Dictionary<WandType, CatalogItemWrapper> allWandsNonAlloc = WandsDatabase.GetAllWandsNonAlloc();
			IEnumerable<KeyValuePair<WandType, CatalogItemWrapper>> source = allWandsNonAlloc.Where((KeyValuePair<WandType, CatalogItemWrapper> p) => Inventory.ContainsItem(p.Value.ItemId));
			return source.ToDictionary((KeyValuePair<WandType, CatalogItemWrapper> k) => k.Key, (KeyValuePair<WandType, CatalogItemWrapper> v) => v.Value);
		}

		public int GetNumberOfOwnedWands()
		{
			Dictionary<WandType, CatalogItemWrapper> allWandsNonAlloc = WandsDatabase.GetAllWandsNonAlloc();
			int num = 0;
			foreach (CatalogItemWrapper value in allWandsNonAlloc.Values)
			{
				if (Inventory.ContainsItem(value.ItemId))
				{
					num++;
				}
			}
			return num;
		}

		public CatalogItemWrapper TryAddSpellToInventory(Spell spell, bool saveToServer = false)
		{
			CatalogItemWrapper spell2 = WandsDatabase.GetSpell(spell);
			if (spell2 == null)
			{
				return null;
			}
			if (!Inventory.TryAddItem(spell2.ItemId))
			{
				return null;
			}
			if (saveToServer)
			{
				SaveItem(CatalogVersion.Spells, spell2.ItemId);
			}
			return spell2;
		}

		public void TryAddSpellsToInventory(List<Spell> spells, bool saveToServer = false)
		{
			List<string> list = new List<string>(32);
			foreach (Spell spell in spells)
			{
				CatalogItemWrapper catalogItemWrapper = TryAddSpellToInventory(spell);
				if (catalogItemWrapper != null)
				{
					list.Add(catalogItemWrapper.ItemId);
				}
			}
			if (saveToServer && !list.IsEmpty())
			{
				SaveItems(CatalogVersion.Spells, list.ToArray());
			}
		}

		public bool OwnsSpell(Spell type)
		{
			CatalogItemWrapper spell = WandsDatabase.GetSpell(type);
			return Inventory.ContainsItem(spell.ItemId);
		}

		public Dictionary<Spell, CatalogItemWrapper> GetOwnedSpells()
		{
			Dictionary<Spell, CatalogItemWrapper> allSpellsNonAlloc = WandsDatabase.GetAllSpellsNonAlloc();
			IEnumerable<KeyValuePair<Spell, CatalogItemWrapper>> source = allSpellsNonAlloc.Where((KeyValuePair<Spell, CatalogItemWrapper> p) => Inventory.ContainsItem(p.Value.ItemId));
			return source.ToDictionary((KeyValuePair<Spell, CatalogItemWrapper> k) => k.Key, (KeyValuePair<Spell, CatalogItemWrapper> v) => v.Value);
		}

		public int GetNumberOfOwnedSpells()
		{
			Dictionary<Spell, CatalogItemWrapper> allSpellsNonAlloc = WandsDatabase.GetAllSpellsNonAlloc();
			int num = 0;
			foreach (CatalogItemWrapper value in allSpellsNonAlloc.Values)
			{
				if (Inventory.ContainsItem(value.ItemId))
				{
					num++;
				}
			}
			return num;
		}

		public int GetSpellTokens()
		{
			return Mathf.Clamp(PlayerUtils.LevelToNumberOfSpellUnlocks(SaveData.LevelData.Level) - GetNumberOfOwnedSpells(), 0, Constants.BaseSpells.Count);
		}

		public int GetSpellTokens(int level)
		{
			return Mathf.Clamp(PlayerUtils.LevelToNumberOfSpellUnlocks(level) - GetNumberOfOwnedSpells(), 0, Constants.BaseSpells.Count);
		}

		public int GetNumberOfSpellsManuallyUnlocked()
		{
			return GetNumberOfOwnedSpells() - Constants.DefaultSpells.Count;
		}

		public CatalogItemWrapper TryAddTitleToInventory(Title title, bool saveToServer = false)
		{
			CatalogItemWrapper title2 = WandsDatabase.GetTitle(title);
			if (title2 == null)
			{
				return null;
			}
			if (!Inventory.TryAddItem(title2.ItemId))
			{
				return null;
			}
			if (saveToServer)
			{
				SaveItem(CatalogVersion.Titles, title2.ItemId);
			}
			return title2;
		}

		public void TryAddTitlesToInventory(List<Title> titles, bool saveToServer = false)
		{
			if (saveToServer)
			{
				List<string> list = new List<string>(64);
				for (int i = 0; i < titles.Count; i++)
				{
					CatalogItemWrapper catalogItemWrapper = TryAddTitleToInventory(titles[i]);
					if (catalogItemWrapper != null)
					{
						list.Add(catalogItemWrapper.ItemId);
					}
				}
				if (list.Count > 0)
				{
					SaveItems(CatalogVersion.Titles, list.ToArray());
				}
			}
			else
			{
				for (int j = 0; j < titles.Count; j++)
				{
					TryAddTitleToInventory(titles[j]);
				}
			}
		}

		public bool OwnsTitle(Title title)
		{
			CatalogItemWrapper title2 = WandsDatabase.GetTitle(title);
			return Inventory.ContainsItem(title2.ItemId);
		}

		public CatalogItemWrapper GetCurrentTitleItem()
		{
			return GetOwnedTitles()[Title];
		}

		public Dictionary<Title, CatalogItemWrapper> GetOwnedTitles()
		{
			Dictionary<Title, CatalogItemWrapper> allTitlesNonAlloc = WandsDatabase.GetAllTitlesNonAlloc();
			Dictionary<Title, CatalogItemWrapper> dictionary = new Dictionary<Title, CatalogItemWrapper>();
			foreach (KeyValuePair<Title, CatalogItemWrapper> item in allTitlesNonAlloc)
			{
				if (Inventory.ContainsItem(item.Value.ItemId))
				{
					dictionary.Add(item.Key, item.Value);
				}
			}
			return dictionary;
		}

		public void AddExperience(int experience)
		{
			if (experience <= 0)
			{
				return;
			}
			int num = SaveData.LevelData.Level;
			int num2 = SaveData.LevelData.CurrentExperience;
			while (experience > 0)
			{
				int num3 = PlayerUtils.LevelToXp(num);
				int num4 = num3 - num2;
				int num5 = experience - num4;
				if (num5 >= 0)
				{
					if (CanLevelUp(num))
					{
						num++;
						num2 = 0;
						experience -= num4;
					}
					else
					{
						num2 = num3 - 1;
						experience = 0;
					}
				}
				else
				{
					num2 += experience;
					experience = 0;
				}
			}
			SaveExperienceRewards(num, num2);
		}

		public bool CanLevelUp(int currentLevel)
		{
			return SaveData.GameAccess == GameAccess.Full || currentLevel < 3;
		}

		public bool IsAtMaximumLevel()
		{
			return !CanLevelUp(SaveData.LevelData.Level) && SaveData.LevelData.CurrentExperience == PlayerUtils.LevelToXp(SaveData.LevelData.Level) - 1;
		}

		private void SaveExperienceRewards(int newLevel, int newExperience)
		{
			int level = SaveData.LevelData.Level;
			SaveDataObject saveDataObject = PlayerSaveData.CreateSaveDataObject();
			if (newLevel >= 100)
			{
				TryAddTitleToInventory(Title.Centurion, saveToServer: true);
			}
			if (TryRewardVirtualCurrency(level, newLevel))
			{
				saveDataObject.AddField(PlayFabSaveField.VirtualCurrency, SaveData.VirtualCurrencySerialized);
			}
			SaveData.LevelData.Level = newLevel;
			SaveData.LevelData.CurrentExperience = newExperience;
			saveDataObject.AddField(PlayFabSaveField.LevelData, SaveData.LevelDataSerialized);
			PlayerProperty.Set("PL", newLevel);
			TrySendLevelUpCustomEvents(level, newLevel);
			TryRewardRating(level, newLevel);
			m_saveManager.SaveExperienceRewards(saveDataObject);
		}

		private bool TryRewardVirtualCurrency(int oldLevel, int newLevel)
		{
			int num = 0;
			for (int i = oldLevel; i < newLevel; i++)
			{
				num += PlayerUtils.LevelToDustReward(i + 1);
			}
			if (num != 0)
			{
				AddVirtualCurrency(num, VirtualCurrencySource.LevelUp);
				return true;
			}
			return false;
		}

		private void TryRewardRating(int oldLevel, int newLevel)
		{
			if (newLevel >= 5 && oldLevel < 5)
			{
				UpdateRating(1500, saveToServer: true);
				UpdateSeasonScore(0, saveToServer: true);
			}
		}

		private void TrySendLevelUpCustomEvents(int oldLevel, int newLevel)
		{
			for (int i = oldLevel; i < newLevel; i++)
			{
				int num = i + 1;
				WandsAnalytics.SendCustomEvent(CustomEventType.player_leveled_up, new Dictionary<string, object>
				{
					{ "Level", num },
					{
						"MatchesPlayed",
						SaveData.MatchData.MatchesPlayed
					}
				});
				if (PlayFabTitleData.GetExperienceTableEntry(num).SpellTokenReward > 0)
				{
					WandsAnalytics.SendCustomEvent(CustomEventType.player_received_spell_token, new Dictionary<string, object> { 
					{
						"SpellTokenCount",
						GetSpellTokens(num)
					} });
				}
			}
		}
	}
	public class PlayerAchievementCollectionData
	{
		[Serializable]
		public class AchievementData
		{
			public Assets.Scripts.Enums.AchievementType Type;

			public bool IsUnlocked;

			public int Count;
		}

		public List<AchievementData> Achievements { get; set; }

		public PlayerAchievementCollectionData()
		{
			Achievements = new List<AchievementData>();
		}

		public override string ToString()
		{
			string text = "Achievements:";
			for (int i = 0; i < Achievements.Count; i++)
			{
				if (i != 0)
				{
					text += " | ";
				}
				text += $"{Achievements[i].Type} | Unlocked: {Achievements[i].IsUnlocked} | Count: {Achievements[i].Count}";
			}
			return text;
		}
	}
}
namespace Cortopia.Scripts.Player
{
	public class PlayerAim : Aim
	{
		private static readonly WaitForSeconds sm_rayUpdateWait = new WaitForSeconds(0.1f);

		private const float OriginForwardWand = 0.55f;

		private const float OriginForwardDualWand = 0.45f;

		private PlayerControl m_playerControl;

		private PlayerInput m_playerInput;

		private WandHand m_wandHand;

		private AimPivot m_aimPivot;

		private Transform m_cameraTransform;

		private Transform m_aimTransform;

		private Renderer m_aimHitRenderer;

		private Renderer m_aimRenderer;

		private Image m_recenterImage;

		private Coroutine m_fadeAimCoroutine;

		private Coroutine m_aimRaycastCoroutine;

		private bool m_showAim = true;

		private bool m_isUpdatingRayAim;

		private bool m_isAimPivotActive;

		private bool m_isInteractableLevel;

		private float m_aimOriginOffset;

		private ISnapObject[] m_allSnapObjects;

		private List<GameObject> m_allSnapGameObjects;

		public Ray RotationRay
		{
			get
			{
				if (base.AimPivot != null)
				{
					Vector3 forward = base.AimPivot.forward;
					forward.y = 0f;
					return new Ray(base.AimPivot.position, forward);
				}
				return CameraRotationRay;
			}
		}

		public Ray CameraRotationRay
		{
			get
			{
				Vector3 forward = m_cameraTransform.forward;
				forward.y = 0f;
				return new Ray(m_cameraTransform.position, forward);
			}
		}

		public Ray CameraRay
		{
			[CompilerGenerated]
			get
			{
				return new Ray(m_cameraTransform.position, m_cameraTransform.forward);
			}
		}

		private Transform AimTransform
		{
			[CompilerGenerated]
			get
			{
				return (!(m_aimTransform != null)) ? null : m_aimTransform;
			}
		}

		private bool ShouldTrackInteractableObjects
		{
			get
			{
				int result;
				if (m_isAimPivotActive)
				{
					if (!m_isInteractableLevel)
					{
						bool? flag = MonoSingleton<ArenaUI>.Instance?.GetAnyMenuOpen();
						if (!flag.HasValue || !flag.Value)
						{
							int? num = m_playerControl.GetCurrentTile()?.Pickups.Count;
							if (!num.HasValue || num.GetValueOrDefault() <= 0)
							{
								bool? flag2 = (m_playerControl.Wand.GetWandControl() as WandControlOneHand)?.UI.IsActive;
								result = ((flag2.HasValue && flag2.Value) ? 1 : 0);
								goto IL_00f7;
							}
						}
					}
					result = 1;
				}
				else
				{
					result = 0;
				}
				goto IL_00f7;
				IL_00f7:
				return (byte)result != 0;
			}
		}

		public PlayerAim(AimData data, PlayerControl playerControl, Transform cameraTransform, PlayerInput input, Transform aimPivot, Transform wandTransform, WandHand wandHand)
			: base(data)
		{
			m_playerControl = playerControl;
			m_cameraTransform = cameraTransform;
			m_playerInput = input;
			m_wandHand = wandHand;
			m_isInteractableLevel = GameControl.Instance.IsCurrentLevel(Level.InteractableLevel);
			m_aimPivot = aimPivot.GetComponent<AimPivot>();
			SetPivotTransforms(aimPivot, wandTransform);
			SetAimActive(value: true, dynamicAim: true);
		}

		public override Vector3 GetAimOrigin(float offset = 0f)
		{
			offset += m_aimOriginOffset;
			return base.AimRay.GetPoint(offset);
		}

		public void DisableAim()
		{
			DisableRaycastUpdate();
			ResetAimReticle();
			SetAimActive(value: false, dynamicAim: false);
		}

		public void FindSnapObjects()
		{
			m_allSnapGameObjects = new List<GameObject>(GameObject.FindGameObjectsWithTag("Snappable"));
			m_allSnapObjects = m_allSnapGameObjects.Select((GameObject a) => a.GetComponent<ISnapObject>()).ToArray();
		}

		public void ResetAimReticle()
		{
			SetAimReticle(ReticleType.Default);
		}

		public void SetAimReticle(ReticleType reticleType)
		{
			if (!m_aimData.AimReticles.IsEmpty() && !(m_aimRenderer == null))
			{
				int num = Mathf.Clamp((int)reticleType, 0, m_aimData.AimReticles.Length - 1);
				m_aimRenderer.material.mainTexture = m_aimData.AimReticles[num];
				if (m_playerInput.IsDualWielding)
				{
					SetReticleColor(reticleType == ReticleType.Tile);
				}
			}
		}

		private void SetReticleColor(bool isTileSpell)
		{
			Color color = ((!isTileSpell) ? Color.red : ((m_wandHand != 0) ? Colors.TileColorLeft : Colors.TileColorRight));
			m_aimRenderer.material.SetColor("_Color", color);
			if (m_aimPivot != null)
			{
				m_aimPivot.LineRenderer.startColor = ((!isTileSpell) ? Color.white : color);
			}
		}

		public void PlayHitResponse()
		{
			if (m_aimHitRenderer == null)
			{
				WandsLogger.LogError("Aim hit renderer is null, can't play hit response");
				return;
			}
			ResetHitAlpha();
			if (m_fadeAimCoroutine == null)
			{
				m_fadeAimCoroutine = m_playerControl.StartCoroutine(FadeAim());
			}
		}

		private IEnumerator FadeAim()
		{
			while (m_aimHitRenderer.material.color.a > 0f)
			{
				Color col = m_aimHitRenderer.material.color;
				col.a -= Time.deltaTime * 2f;
				m_aimHitRenderer.material.color = col;
				yield return null;
			}
			m_aimHitRenderer.gameObject.SetActive(value: false);
			m_fadeAimCoroutine = null;
		}

		private void ResetHitAlpha()
		{
			Color color = m_aimHitRenderer.material.color;
			color.a = 1f;
			m_aimHitRenderer.material.color = color;
			m_aimHitRenderer.gameObject.SetActive(value: true);
		}

		public void FillRecenterReticle(float percentage)
		{
			if (!(m_recenterImage == null))
			{
				m_recenterImage.fillAmount = percentage;
			}
		}

		public Vector3 GetForwardPoint(float minLength = 0f, float maxLength = 0f)
		{
			if (minLength <= 0f)
			{
				minLength = 1.2f;
			}
			if (maxLength <= 0f)
			{
				maxLength = 1.2f;
			}
			return CameraRotationRay.GetPoint(Mathf.Clamp(base.AimDistance, minLength, maxLength));
		}

		public void TryToggleAimPivotTransform(bool active)
		{
			m_isAimPivotActive = active;
			if (base.AimPivot != null && base.AimPivot.gameObject != null)
			{
				base.AimPivot.gameObject.SetActive(active);
			}
		}

		private void SetAimActive(bool value, bool dynamicAim)
		{
			m_showAim = dynamicAim;
			AimTransform?.gameObject.SetActive(value);
		}

		public void EnableRaycastUpdate()
		{
			if (m_playerInput.IsObjectHighlighted(m_wandHand))
			{
				m_playerInput.NullHighlightedInteractable(m_wandHand);
			}
			if (m_isUpdatingRayAim)
			{
				WandsLogger.LogError("Aim ray already updating");
				return;
			}
			m_isUpdatingRayAim = true;
			m_aimRaycastCoroutine = m_playerControl.StartCoroutine(UpdateRaycast());
		}

		private void DisableRaycastUpdate()
		{
			m_isUpdatingRayAim = false;
			if (m_aimRaycastCoroutine != null)
			{
				m_playerControl.StopCoroutine(m_aimRaycastCoroutine);
				m_aimRaycastCoroutine = null;
			}
		}

		private IEnumerator UpdateRaycast()
		{
			while (true)
			{
				if (ShouldTrackInteractableObjects)
				{
					m_playerInput.TryTrackInteractObjects(m_wandHand);
				}
				else if (m_playerInput.IsObjectHighlighted(m_wandHand))
				{
					m_playerInput.NullHighlightedInteractable(m_wandHand);
				}
				UpdateAimRaycast(m_aimData.MaxAimDistance);
				UpdateAim();
				yield return sm_rayUpdateWait;
			}
		}

		private void UpdateAim()
		{
			if (m_aimTransform == null)
			{
				return;
			}
			if (base.AimDistance - 0.05f > m_aimData.MinAimDistance)
			{
				if (!m_showAim)
				{
					SetAimActive(value: true, dynamicAim: true);
				}
				Vector3 localPosition = m_aimTransform.localPosition;
				localPosition.z = base.AimDistance - 0.05f;
				m_aimTransform.localPosition = localPosition;
				m_aimTransform.localScale = Vector3.one * (0.1f + base.AimDistance * m_aimData.AimDistanceMultiplier);
			}
			else if (m_showAim)
			{
				SetAimActive(value: false, dynamicAim: false);
			}
		}

		public void UpdateAimPivot(AimInput aimInput, Transform aimPivotTransform)
		{
			DisableRaycastUpdate();
			m_aimInput = aimInput;
			m_aimOriginOffset = ((aimInput == AimInput.Head) ? 0.75f : ((!m_playerControl.IsDualWielding) ? 0.55f : 0.45f));
			TryToggleAimPivotTransform(active: false);
			base.AimPivot = aimPivotTransform;
			RetrieveAimTransformAndRenderer();
			RetrieveHitRenderer();
			SetAimTransformPosition(Vector3.zero);
			TryToggleAimPivotTransform(active: true);
			RetrieveRecenterImage();
			EnableRaycastUpdate();
			SetAimActive(m_showAim, m_showAim);
		}

		private void RetrieveAimTransformAndRenderer()
		{
			m_aimTransform = base.AimPivot.RetrieveChild("Aim", includeInactive: true);
			m_aimRenderer = AimTransform?.GetComponent<Renderer>();
		}

		private void RetrieveRecenterImage()
		{
			if (GameControl.Instance.Platform.SupportsPositionalTracking)
			{
				m_recenterImage = m_aimTransform.RetrieveChild("Recenter", includeInactive: true)?.GetComponent<Image>();
				if (m_recenterImage == null)
				{
					WandsLogger.LogError("No Recenter image found!");
					return;
				}
				m_recenterImage.fillAmount = 0f;
				m_recenterImage.transform.parent.gameObject.SetActive(value: true);
			}
		}

		private void RetrieveHitRenderer()
		{
			m_aimHitRenderer = m_aimTransform.RetrieveChild("Hit", includeInactive: true)?.GetComponent<Renderer>();
		}

		private void SetAimTransformPosition(Vector3 position)
		{
			m_aimTransform.localPosition = position;
		}

		private void UpdateAimRaycast(float maxDistance)
		{
			if (Physics.Raycast(base.AimRay, out var hitInfo, maxDistance, base.AimHitMask))
			{
				SetAimDistance(hitInfo.point);
			}
			else
			{
				SetAimDistance(base.AimRay.GetPoint(maxDistance));
			}
		}

		public bool TryRaycastToSnapCollider(ref ISnapObject closestSnapObject)
		{
			if (Physics.Raycast(base.AimRay, out var hitInfo, 10f, m_aimData.SnapHitMask))
			{
				int num = -1;
				if (m_allSnapGameObjects.Contains(hitInfo.collider.gameObject))
				{
					num = m_allSnapGameObjects.IndexOf(hitInfo.collider.gameObject);
				}
				else
				{
					if (!m_allSnapGameObjects.Contains(hitInfo.transform.parent.gameObject))
					{
						WandsLogger.LogError($"Found collider for SnapObject but neither the object {hitInfo.collider.gameObject} nor parent {hitInfo.collider.transform.parent.gameObject} is added to the list");
						return false;
					}
					num = m_allSnapGameObjects.IndexOf(hitInfo.transform.parent.gameObject);
				}
				closestSnapObject = m_allSnapObjects[num];
				return true;
			}
			return false;
		}

		public void AdjustGrabDistance(ref float grabDistance)
		{
			if (Physics.Raycast(base.AimRay, out var hitInfo, 10f, m_aimData.DragHitMask))
			{
				grabDistance = hitInfo.distance;
			}
		}

		public void AdjustAimPivotLineRenderer(Vector3 adjustedPosition)
		{
			base.AimPivot.localPosition = adjustedPosition;
		}
	}
	public class PlayerCamera
	{
		private const float RotationDuration = 0.1f;

		private const float RotationDegreesPerFrame = 10f;

		private const float RotationStep = 45f;

		private const float DegreesFullCircle = 360f;

		private const float DegreesHalfCircle = 180f;

		private PlatformType m_platformType;

		private Transform m_cameraRig;

		private LayerMask m_originalCullingMask;

		private EventToken m_sceneLoadedEventToken;

		private EventToken m_recenterCameraEventToken;

		public PostProcessingBehaviour PostProcessing { get; private set; }

		public Transform CameraTransform { get; private set; }

		public Transform LeftHand { get; private set; }

		public Transform RightHand { get; private set; }

		public Camera Camera { get; private set; }

		public Transform CameraRig
		{
			[CompilerGenerated]
			get
			{
				return (!(m_cameraRig != null)) ? null : m_cameraRig;
			}
		}

		public PlayerCamera(Transform cameraRig, PlatformType platform)
		{
			m_cameraRig = cameraRig;
			m_platformType = platform;
		}

		public void SetCameraCullingMask(LayerMask mask)
		{
			Camera.cullingMask = mask;
		}

		private void OnSceneLoaded(Events.SceneLoadedEvent eventData)
		{
			Camera.cullingMask = m_originalCullingMask;
			if (!m_platformType.ContainsFlag(PlatformTarget.LowEndMobile))
			{
				ToggleOcclusionCulling(eventData.Level);
				ToggleCameraPostProcessing(eventData.Level != Level.MainMenu);
			}
		}

		private void SubscribeToEvents()
		{
			m_sceneLoadedEventToken = EventHub.Subscribe<Events.SceneLoadedEvent>(OnSceneLoaded);
			m_recenterCameraEventToken = EventHub.Subscribe<InputEvents.RecenterCameraEvent>(OnRecenterCamera);
		}

		public void UnsubscribeToEvents()
		{
			EventHub.Unsubscribe<Events.SceneLoadedEvent>(m_sceneLoadedEventToken);
			EventHub.Unsubscribe<InputEvents.RecenterCameraEvent>(m_recenterCameraEventToken);
		}

		public void TryInstantiateCamera()
		{
			GameObject gameObject = GameControl.Instance.AssetHandler.LoadAsset<GameObject>(AssetBundleType.Platform, $"{GameControl.Instance.Platform.PlatformName}CameraRig");
			if (gameObject == null)
			{
				throw new UnityException("Platform camera prefab is null");
			}
			InstantiateCamera(gameObject);
		}

		private void InstantiateCamera(GameObject cameraPrefab)
		{
			Transform transform = UnityEngine.Object.Instantiate(cameraPrefab).transform;
			transform.SetParent(m_cameraRig);
			transform.localPosition = Vector3.zero;
			CameraTransform = transform.RetrieveChild("CenterEyeAnchor", includeInactive: true);
			LeftHand = transform.RetrieveChild("LeftHandAnchor", includeInactive: true);
			RightHand = transform.RetrieveChild("RightHandAnchor", includeInactive: true);
			Camera = CameraTransform.GetComponent<Camera>();
			m_originalCullingMask = Camera.cullingMask;
			AdjustCameraRigPlacement();
			SetAndTogglePostProcessing();
			ExpandedSingleton<FadeHandler>.Instance.SetSphereParent(CameraTransform);
			SubscribeToEvents();
		}

		private void AdjustCameraRigPlacement()
		{
			if (!m_platformType.ContainsFlag(PlatformTarget.Android))
			{
				if (m_platformType == PlatformType.Rift && OVRManager.isHmdPresent)
				{
					OVRManager.instance.trackingOriginType = OVRManager.TrackingOrigin.FloorLevel;
				}
				Vector3 localPosition = CameraTransform.localPosition;
				localPosition.y = 0f;
				CameraTransform.localPosition = localPosition;
			}
		}

		private void SetAndTogglePostProcessing()
		{
			if (!m_platformType.ContainsFlag(PlatformTarget.Android))
			{
				PostProcessing = CameraTransform.GetComponent<PostProcessingBehaviour>();
				ToggleCameraPostProcessing(!GameControl.Instance.IsCurrentLevel(Level.MainMenu));
			}
		}

		private void ToggleOcclusionCulling(Level loadedLevel)
		{
			Camera.useOcclusionCulling = loadedLevel == Level.Lobby || loadedLevel == Level.SanctumOfSahir;
		}

		private void ToggleCameraPostProcessing(bool enable)
		{
			if (!(PostProcessing == null))
			{
				PostProcessing.enabled = enable;
			}
		}

		private void OnRecenterCamera(InputEvents.RecenterCameraEvent eventData)
		{
			RecenterCamera();
		}

		private void RecenterCamera()
		{
			Vector3 zero = Vector3.zero;
			zero = CameraTransform.position - m_cameraRig.position;
			zero.y = GameControl.Instance.Platform.AdjustedHeight;
			Vector3 position = m_cameraRig.parent.position;
			m_cameraRig.position = position - zero;
			EventHub.Publish(new Events.OnCameraRecenteredEvent());
		}

		public void FaceDirection(float yRotation)
		{
			float num = CameraTransform.localEulerAngles.y + 360f;
			num %= 360f;
			float num2 = m_cameraRig.localEulerAngles.y + 360f;
			num2 %= 360f;
			RotateCameraRig(yRotation - num - num2);
		}

		public void RotateCamera(MonoBehaviour mono, RotationDirection rotationDirection)
		{
			mono.StartCoroutine(Rotate(GetRotationAngle(rotationDirection)));
		}

		private IEnumerator Rotate(float angle)
		{
			Vector3 from = m_cameraRig.eulerAngles;
			Vector3 to = from + Vector3.up * angle;
			float t = 0f;
			while (t < 1f)
			{
				t += Time.deltaTime * 10f;
				float current = m_cameraRig.eulerAngles.y;
				float next = Vector3.Slerp(from, to, t).y;
				float angleToRotate = Mathf.DeltaAngle(current, next);
				RotateCameraRig(angleToRotate);
				yield return null;
			}
		}

		private float GetRotationAngle(RotationDirection rotationDirection)
		{
			return rotationDirection switch
			{
				RotationDirection.Left => -45f, 
				RotationDirection.Right => 45f, 
				RotationDirection.Back => 180f, 
				_ => throw new NotImplementedException("RotationDirection not implemented: " + rotationDirection), 
			};
		}

		private void RotateCameraRig(float rotationAngle)
		{
			if (GameControl.Instance.Platform.SupportsPositionalTracking)
			{
				m_cameraRig.RotateAround(CameraTransform.position, Vector3.up, rotationAngle);
			}
			else
			{
				m_cameraRig.Rotate(0f, rotationAngle, 0f, Space.Self);
			}
		}
	}
	public class PlayerCameraEffectHandler
	{
		private const float SaturationTargetInside = 1f;

		private const float SaturationTargetOutside = 0f;

		private const float ContrastTargetInside = 0.9f;

		private const float ContrastTargetOutside = 1.4f;

		private const float FrequencyInside = 1f;

		private const float FrequencyOutside = 0.1f;

		private const float FadeTimeInside = 0.4f;

		private const float FadeTimeOutside = 0.6f;

		private bool m_hasMatchEnded;

		private bool m_isInsideTileArea = true;

		private bool m_isWandPositionValid = true;

		private PlayerControl m_playerControl;

		private PostProcessingBehaviour m_postProcessingBehavior;

		private CameraSaturationHandler m_cameraSaturationHandler;

		private Coroutine m_currentCoroutine;

		private EventToken m_matchEndedEventToken;

		private EventToken m_tileAreaEnterEventToken;

		private EventToken m_tileAreaExitEventToken;

		private EventToken m_wandPositionValidationEventToken;

		public PlayerCameraEffectHandler(PlayerControl playerControl, PostProcessingBehaviour postProcessingBehavior, CameraSaturationHandler cameraSaturationHandler)
		{
			m_playerControl = playerControl;
			m_postProcessingBehavior = postProcessingBehavior;
			m_cameraSaturationHandler = cameraSaturationHandler;
			m_matchEndedEventToken = EventHub.Subscribe<Events.MatchEndedEvent>(OnMatchEnded);
			m_tileAreaEnterEventToken = EventHub.Subscribe<Events.TileAreaEnterEvent>(OnTileAreaEnter);
			m_tileAreaExitEventToken = EventHub.Subscribe<Events.TileAreaExitEvent>(OnTileAreaExit);
			m_wandPositionValidationEventToken = EventHub.Subscribe<Events.WandPositionValidationEvent>(OnWandPositionValidated);
		}

		private void OnDestroy()
		{
			if (!m_hasMatchEnded)
			{
				ResetGrayscale();
				EventHub.Unsubscribe(m_matchEndedEventToken);
				EventHub.Unsubscribe(m_tileAreaEnterEventToken);
				EventHub.Unsubscribe(m_tileAreaExitEventToken);
				EventHub.Unsubscribe(m_wandPositionValidationEventToken);
			}
		}

		private void OnMatchEnded(Events.MatchEndedEvent eventData)
		{
			m_hasMatchEnded = true;
			m_isInsideTileArea = true;
			m_isWandPositionValid = true;
			ResetGrayscale();
			EventHub.Unsubscribe(m_matchEndedEventToken);
			EventHub.Unsubscribe(m_tileAreaEnterEventToken);
			EventHub.Unsubscribe(m_tileAreaExitEventToken);
			EventHub.Unsubscribe(m_wandPositionValidationEventToken);
		}

		private void OnTileAreaEnter(Events.TileAreaEnterEvent eventData)
		{
			m_isInsideTileArea = true;
			TryDisableGrayscale();
		}

		private void OnTileAreaExit(Events.TileAreaExitEvent eventData)
		{
			m_isInsideTileArea = false;
			ActivateGrayscale();
		}

		private void OnWandPositionValidated(Events.WandPositionValidationEvent eventData)
		{
			if (eventData.IsWandPositionValid)
			{
				m_isWandPositionValid = true;
				TryDisableGrayscale();
			}
			else
			{
				m_isWandPositionValid = false;
				ActivateGrayscale();
			}
		}

		private void TryDisableGrayscale()
		{
			if (m_isInsideTileArea && m_isWandPositionValid)
			{
				DeactivateGrayscale();
			}
		}

		public void ResetGrayscale()
		{
			PlatformType type = GameControl.Instance.Platform.Type;
			if (type.ContainsFlag(PlatformTarget.LowEndMobile))
			{
				return;
			}
			if (type.ContainsFlag(PlatformTarget.HighEndMobile))
			{
				m_cameraSaturationHandler.SaturateCamera(value: false, null);
			}
			else
			{
				PostProcessingProfile profile = m_postProcessingBehavior.profile;
				if (profile == null)
				{
					WandsLogger.LogError("Trying to reset grayscale but PostProcessingBehaviour.profile is null");
					return;
				}
				SetSaturationAndContrast(profile, 1f, 0.9f);
			}
			PunSingleton<SoundManager>.Instance?.SetEquilizerFrequency(1f);
		}

		private void ActivateGrayscale()
		{
			PlatformType type = GameControl.Instance.Platform.Type;
			if (type.ContainsFlag(PlatformTarget.LowEndMobile))
			{
				return;
			}
			if (type.ContainsFlag(PlatformTarget.HighEndMobile))
			{
				m_cameraSaturationHandler.SaturateCamera(value: true, delegate
				{
					PunSingleton<SoundManager>.Instance.SetEquilizerFrequency(0.1f);
				});
				return;
			}
			PostProcessingProfile profile = m_postProcessingBehavior.profile;
			if (profile == null)
			{
				WandsLogger.LogError("Trying to activate grayscale but PostProcessingBehaviour.profile is null");
				return;
			}
			if (m_currentCoroutine != null)
			{
				m_playerControl.StopCoroutine(m_currentCoroutine);
				m_currentCoroutine = null;
			}
			m_currentCoroutine = m_playerControl.StartCoroutine(ChangeEffect(profile, 0f, 1.4f, 0.1f, 0.6f));
		}

		private void DeactivateGrayscale()
		{
			PlatformType type = GameControl.Instance.Platform.Type;
			if (type.ContainsFlag(PlatformTarget.LowEndMobile))
			{
				return;
			}
			if (type.ContainsFlag(PlatformTarget.HighEndMobile))
			{
				m_cameraSaturationHandler.SaturateCamera(value: false, delegate
				{
					PunSingleton<SoundManager>.Instance.SetEquilizerFrequency(1f);
				});
				return;
			}
			PostProcessingProfile profile = m_postProcessingBehavior.profile;
			if (profile == null)
			{
				WandsLogger.LogError("Trying to deactivate grayscale but PostProcessingBehaviour.profile is null");
				return;
			}
			if (m_currentCoroutine != null)
			{
				m_playerControl.StopCoroutine(m_currentCoroutine);
				m_currentCoroutine = null;
			}
			m_currentCoroutine = m_playerControl.StartCoroutine(ChangeEffect(profile, 1f, 0.9f, 1f, 0.4f));
		}

		private IEnumerator ChangeEffect(PostProcessingProfile profile, float saturationTarget, float contrastTarget, float frequencyTarget, float time)
		{
			ColorGradingModel.BasicSettings basicSettings = profile.colorGrading.settings.basic;
			float saturation2 = basicSettings.saturation;
			float contrast2 = basicSettings.contrast;
			float frequency2 = PunSingleton<SoundManager>.Instance.GetEqualizerFrequency();
			float startSaturation = saturation2;
			float startContrast = contrast2;
			float startFrequency = frequency2;
			float current = 0f;
			while (current < 1f)
			{
				saturation2 = Mathf.Lerp(startSaturation, saturationTarget, current);
				contrast2 = Mathf.Lerp(startContrast, contrastTarget, current);
				frequency2 = Mathf.Lerp(startFrequency, frequencyTarget, current);
				SetSaturationAndContrast(profile, saturation2, contrast2);
				PunSingleton<SoundManager>.Instance.SetEquilizerFrequency(frequency2);
				current += Time.deltaTime / time;
				yield return null;
			}
			SetSaturationAndContrast(profile, saturationTarget, contrastTarget);
			PunSingleton<SoundManager>.Instance.SetEquilizerFrequency(frequencyTarget);
		}

		private void SetSaturationAndContrast(PostProcessingProfile profile, float saturationTarget, float contrastTarget)
		{
			ColorGradingModel.Settings settings = profile.colorGrading.settings;
			settings.basic.saturation = saturationTarget;
			settings.basic.contrast = contrastTarget;
			profile.colorGrading.settings = settings;
		}
	}
	public class PlayerControl : CharacterControl, IPauseObject
	{
		[SerializeField]
		private HapticsData m_takeDamageHapticsSmall;

		[SerializeField]
		private HapticsData m_takeDamageHapticsBig;

		[SerializeField]
		private GameObject m_atmosphericEffect;

		private LobbyState? m_previousLobbyState;

		private PlayerCamera m_camera;

		private PlayerTileAreaHandler m_tileAreaHandler;

		private PlayerCameraEffectHandler m_cameraEffectHandler;

		private PlayerUI m_hud;

		private PlayerUI m_hudPrewarmed;

		private GameObject m_playerHudAsset;

		private bool m_trackTileArea;

		private bool m_updateInput;

		private float m_autoLeapTimer;

		private ActivatableValue m_tileHealTimer = default(ActivatableValue);

		private PlayerStats m_playerStats;

		private EventToken m_rotateCameraEventToken;

		private EventToken m_connectedToMatchRoomEventToken;

		public VirtualTransform OriginTrackingTarget { get; } = new VirtualTransform();


		public VirtualTransform HeadTrackingTarget { get; } = new VirtualTransform();


		public VirtualTransform LeftHandTrackingTarget { get; } = new VirtualTransform();


		public VirtualTransform RightHandTrackingTarget { get; } = new VirtualTransform();


		public PlayerInput Input { get; private set; }

		public Transform CameraTransform
		{
			[CompilerGenerated]
			get
			{
				return m_camera.CameraTransform;
			}
		}

		public Transform CameraRigTransform
		{
			[CompilerGenerated]
			get
			{
				return m_camera.CameraRig;
			}
		}

		public Transform CameraPivot
		{
			[CompilerGenerated]
			get
			{
				return m_camera.CameraTransform.parent;
			}
		}

		public PlayerUI HUD
		{
			[CompilerGenerated]
			get
			{
				return (!(m_hud != null)) ? null : m_hud;
			}
		}

		public bool IsTrackingHands { get; set; }

		public bool IsInputLocked
		{
			[CompilerGenerated]
			get
			{
				bool? flag = Input?.InputManager?.IsInputLocked;
				return !flag.HasValue || flag.Value;
			}
		}

		public bool IsDualWielding
		{
			[CompilerGenerated]
			get
			{
				bool? flag = Input?.IsDualWielding;
				return flag.HasValue && flag.Value;
			}
		}

		public bool IsAlwaysCursed
		{
			[CompilerGenerated]
			get
			{
				return m_playerStats.IsAlwaysCursed;
			}
		}

		public override float CurseTimeLeft
		{
			[CompilerGenerated]
			get
			{
				return (!IsAlwaysCursed) ? base.CurseTimeLeft : (-1f);
			}
		}

		protected override void Awake()
		{
			base.Awake();
			CreateCamera();
			SetAtmosphericEffectActive(active: false);
		}

		private void Update()
		{
			if (base.IsPaused)
			{
				return;
			}
			if (m_updateInput)
			{
				Input.UpdateInput();
			}
			if (m_trackTileArea && !base.TeleportHandler.IsTeleporting)
			{
				m_tileAreaHandler.CheckInsideTileArea();
			}
			UpdateTrackingTransforms();
			if (base.Wielder != null)
			{
				UpdateWielderTrackingTransforms();
				if (base.Wand != null)
				{
					TryActivateHealEffectOnTile();
					RegenerateMana();
					base.Wand.Update();
				}
			}
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			m_rotateCameraEventToken = EventHub.Subscribe<InputEvents.RotateCameraEvent>(OnRotateCamera);
			m_connectedToMatchRoomEventToken = EventHub.Subscribe<Events.ConnectedToMatchRoom>(OnConnectedToMatchRoom);
		}

		protected override void OnDisable()
		{
			base.OnDisable();
			if (m_camera != null)
			{
				m_camera.UnsubscribeToEvents();
			}
			Input?.UnsubscribeToEvents();
			EventHub.Unsubscribe<InputEvents.RotateCameraEvent>(m_rotateCameraEventToken);
			EventHub.Unsubscribe<Events.ConnectedToMatchRoom>(m_connectedToMatchRoomEventToken);
		}

		protected override void OnSceneLoadInitiated(Events.SceneLoadInitiatedEvent eventData)
		{
			base.OnSceneLoadInitiated(eventData);
			if (eventData.CurrentLevel.ContainsFlag(Level.Arena))
			{
				ResetHealth();
				ResetMana();
				ResetWandProperties();
			}
			Input.DisableAim();
			SetAtmosphericEffectActive(active: false);
			ToggleInputActive(active: false);
			m_previousLobbyState = null;
		}

		protected override void OnSceneLoaded(Events.SceneLoadedEvent eventData)
		{
			base.OnSceneLoaded(eventData);
			DisablePlayerHUD();
			switch (eventData.Level)
			{
			case Level.MainMenu:
				break;
			case Level.Workshop:
				if (Input == null)
				{
					CreateInputSystem();
				}
				else
				{
					UpdateInputMethod(force: true);
				}
				UnsubscribeFromArenaEvents();
				SetAtmosphericEffectActive(active: true);
				if (GameControl.Instance.Platform.Type.ContainsFlag(PlatformTarget.PlayStation))
				{
					RecenterCamera(1f, force: true);
					ExpandedSingleton<FadeHandler>.Instance.FadeIn(0.75f, 1.25f, resetAlpha: true, delegate
					{
						ToggleInputActive(active: true);
					});
				}
				else
				{
					ExpandedSingleton<FadeHandler>.Instance.FadeIn(0.75f, 0.25f, resetAlpha: true, delegate
					{
						ToggleInputActive(active: true);
					});
				}
				break;
			case Level.Basement:
			case Level.Lobby:
			case Level.AspisPrison:
			case Level.TempleOfOphidian:
			case Level.TheCelestialHalls:
			case Level.OrtusStation:
			case Level.DeadMastersVale:
			case Level.SanctumOfSahir:
			case Level.TheCelestialHalls_AIBot:
			case Level.FountainOfTheFallen:
				if (m_playerHudAsset == null)
				{
					m_playerHudAsset = GameControl.Instance.AssetHandler.LoadAsset<GameObject>(AssetBundleType.CombinedUI, "PlayerHUD");
				}
				m_effectHandler.PreloadEffects();
				SubscribeToArenaEvents();
				SetColliderActive(active: true);
				break;
			default:
				throw new NotImplementedException($"Level type <{eventData.Level}> is not recognized or valid");
			}
		}

		protected override void OnLevelInitialized(Events.LevelInitializedEvent eventData)
		{
			if (eventData.Level != Level.Workshop && eventData.Level != Level.MainMenu)
			{
				CreateStatsAndApplyWandProperties();
				SpawnAndConnectWielder(eventData.Level);
				CreateInputSystem();
				PlayerManager.Instance.PlayerSpawned(this);
				SetAtmosphericEffectActive(active: true);
				if (GameControl.Instance.IsCurrentLevel(Level.Lobby))
				{
					Tile startTile = PunSingleton<TileManager>.Instance.GetStartTile((!PhotonNetwork.IsMasterClient) ? 1 : 0);
					ResetToInsideTileArea(startTile.transform.position);
					PunSingleton<TileManager>.Instance.UpdateLobbyTile(startTile.transform);
					ExpandedSingleton<FadeHandler>.Instance.FadeIn(0.75f, 0.25f);
				}
			}
		}

		private void CreateStatsAndApplyWandProperties()
		{
			float defaultManaRegen = ((!GameControl.Instance.Platform.Type.ContainsFlag(PlatformTarget.SixDoF)) ? 17f : 13f);
			m_playerStats = new PlayerStats(defaultManaRegen);
			RewardModifiers rewardModifiers = new RewardModifiers(1f, 1f, 1f);
			WandProperty[] properties = new WandProperty[3];
			WandType[] wandTypes = GameControl.Instance.GetWandTypes();
			if (GameControl.Instance.IsDualWieldSupportedAndActive && wandTypes[0] != wandTypes[1])
			{
				for (int i = 0; i < wandTypes.Length; i++)
				{
					if (WandProperties.Get(wandTypes[i], out properties))
					{
						ApplyWandProperties(ref rewardModifiers, (WandHand)i, properties, applyDoubleEffect: false);
					}
				}
			}
			else if (WandProperties.Get(wandTypes[0], out properties))
			{
				ApplyWandProperties(ref rewardModifiers, WandHand.Right, properties, applyDoubleEffect: true);
			}
			GameControl.Instance.Player.RewardModifiers = rewardModifiers;
		}

		private void ApplyWandProperties(ref RewardModifiers rewardModifiers, WandHand wandHand, WandProperty[] wandProperties, bool applyDoubleEffect)
		{
			foreach (WandProperty wandProperty in wandProperties)
			{
				switch (wandProperty.Type)
				{
				case WandPropertyType.UserEffect:
					(wandProperty as UserEffect).Apply(ref rewardModifiers, applyDoubleEffect);
					break;
				case WandPropertyType.PlayerEffect:
					(wandProperty as PlayerEffect).Apply(ref m_playerStats, applyDoubleEffect, wandHand);
					break;
				}
			}
		}

		protected override void SpawnAndConnectWielder(Level level)
		{
			PlayerManager.Instance.SpawnWielderOnline(m_playerStats, delegate(Wielder wielder)
			{
				OnWielderSpawned(wielder, level);
			});
		}

		protected override void OnWielderSpawned(Wielder wielder, Level level)
		{
			base.OnWielderSpawned(wielder, level);
			if (level.ContainsFlag(Level.Arena))
			{
				Tile startTile = PunSingleton<TileManager>.Instance.GetStartTile(wielder.GetIndex() - 1);
				CreateMovement(startTile);
				MatchTileRotation(startTile.transform);
				wielder.ConnectPlayerController(this);
				UpdateObjectLayer(wielder.GetLayerMask());
				Input.SpawnArenaControllers(level);
				base.HurtSfxHandler.Initialize(m_healthData, wielder.AnimationRelay, belongsToPlayer: true, (CharacterType)WandsSave.GetIntPref("V0"));
				if (m_hudPrewarmed != null)
				{
					m_hudPrewarmed.FadeHudCompletely();
				}
				return;
			}
			if (level == Level.Lobby)
			{
				Tile startTile2 = PunSingleton<TileManager>.Instance.GetStartTile((!PhotonNetwork.IsMasterClient) ? 1 : 0);
				CreateMovement(startTile2);
				wielder.ConnectPlayerController(this);
				UpdateObjectLayer(wielder.GetLayerMask());
				if (m_previousLobbyState.HasValue)
				{
					LobbyState? previousLobbyState = m_previousLobbyState;
					if (previousLobbyState.GetValueOrDefault() == PunSingleton<LobbyManager>.Instance.State && previousLobbyState.HasValue)
					{
						return;
					}
				}
				m_previousLobbyState = PunSingleton<LobbyManager>.Instance.State;
				Input.SpawnLobbyController();
				base.HurtSfxHandler.Initialize(m_healthData, wielder.AnimationRelay, belongsToPlayer: true, (CharacterType)WandsSave.GetIntPref("V0"));
				ToggleInputActive(active: true);
				return;
			}
			throw new NotImplementedException($"Spawned a Wielder on unrecognized level: {level}");
		}

		protected override void UpdateObjectLayer(LayerMask layer)
		{
			base.UpdateObjectLayer(layer);
			if ((int)m_aimData.AimHitMask != ((int)m_aimData.AimHitMask | (1 << base.gameObject.layer)))
			{
				AimData aimData = m_aimData;
				aimData.AimHitMask = (int)aimData.AimHitMask | (1 << base.gameObject.layer);
			}
			AimData aimData2 = m_aimData;
			aimData2.AimHitMask = (int)aimData2.AimHitMask & ~(1 << (int)layer);
		}

		private void SetAtmosphericEffectActive(bool active)
		{
			m_atmosphericEffect.SetActive(active);
		}

		public bool TryInstantiatePlayerWand(bool isDualWielding)
		{
			if (base.Wand == null || base.Wand.WandCount > 1 != isDualWielding)
			{
				InstantiatePlayerWand();
				return true;
			}
			return false;
		}

		public override void InstantiatePlayerWand()
		{
			DestroyPlayerWand();
			base.Wand = new WandManager(this, m_healthData, m_manaData);
		}

		protected override AimInput GetAimInputType()
		{
			return Input.AimInput;
		}

		public override void SpawnWandController(Level level)
		{
			base.SpawnWandController(level);
			Input.SetWandController(base.Wand);
			InitializeHUD();
			TrySideloadWandPropertySpells();
		}

		private void InitializeHUD()
		{
			if (m_hudPrewarmed == null)
			{
				m_hudPrewarmed = UnityEngine.Object.Instantiate(m_playerHudAsset, base.transform).GetComponent<PlayerUI>();
				m_hudPrewarmed.FadeHudCompletely();
			}
			m_hudPrewarmed.InitializeHUD(Input.GetAim(), m_camera.Camera, m_healthData, m_manaData);
			PlayerUI hudPrewarmed = m_hudPrewarmed;
			Spell[] availableSpellTypes = base.Wand.AvailableSpellTypes;
			int[] spellCastCosts = base.Wand.SpellCastCosts;
			Spell? spell = base.Wand.GetActiveSpell()?.Type;
			hudPrewarmed.UpdateLoadoutIcons(availableSpellTypes, spellCastCosts, spell.HasValue ? spell.Value : Spell.None);
			m_hudPrewarmed.SetActive(active: true, base.Wielder, IsDualWielding);
		}

		public override void Pause(bool pause)
		{
			base.Pause(pause);
			if (pause)
			{
				SetSpellInputActive(active: false);
				return;
			}
			bool? flag = ((m_tileAreaHandler != null) ? new bool?(m_tileAreaHandler.IsInsideTileArea) : null);
			if (!flag.HasValue || flag.Value)
			{
				SetSpellInputActive();
			}
		}

		private void OnRotateCamera(InputEvents.RotateCameraEvent eventData)
		{
			m_camera.RotateCamera(this, eventData.RotationDirection);
		}

		protected override void OnMatchReset(Events.MatchResetEvent eventData)
		{
			base.OnMatchReset(eventData);
			if (m_tileAreaHandler != null)
			{
				m_tileAreaHandler.MarkAsInsideTileArea();
			}
		}

		protected override void OnMatchEnded(Events.MatchEndedEvent eventData)
		{
			base.Wand?.OnMatchEnded();
			base.OnMatchEnded(eventData);
			Input.ResetAimReticle();
			ToggleInputActive(active: true);
			m_trackTileArea = false;
			m_regenerateMana = false;
			ResetWandProperties();
			if (eventData.EndState == EndState.Won)
			{
				GameControl.Instance.Player.IncrementMatchesWon();
				GameControl.Instance.IncrementAchievement(Assets.Scripts.Enums.AchievementType.Win25Duels, 1, 25);
				if (GameControl.Instance.Player.SaveData.MatchData.MatchesWon >= 1)
				{
					GameControl.Instance.UnlockAchievement(Assets.Scripts.Enums.AchievementType.WinFirstDuel);
				}
				Level currentLevel = GameControl.Instance.GetCurrentLevel();
				GameControl.Instance.Player.IncrementMatchesWonForArena(currentLevel.ToString());
				if (GameControl.Instance.Player.HasWonInEveryArena())
				{
					GameControl.Instance.UnlockAchievement(Assets.Scripts.Enums.AchievementType.WinAllArenas);
				}
			}
		}

		protected override void OnFinalCountdownStarted(Events.FinalCountdownStartedEvent eventData)
		{
			bool active = GameControl.Instance.IsCurrentLevel(Level.Arena);
			ToggleInputActive(active);
		}

		protected override void OnCountdownStarted(Events.CountdownStartedEvent eventData)
		{
			ToggleInputActive(active: true);
			if (GameControl.Instance.IsCurrentLevel(Level.Arena))
			{
				SetSpellInputActive(active: false);
			}
		}

		protected override void OnCountdownEnded(Events.CountdownEndedEvent eventData)
		{
			Level currentLevel = GameControl.Instance.GetCurrentLevel();
			if (currentLevel.ContainsFlag(Level.Arena))
			{
				EnablePlayerHUD();
				if (currentLevel != Level.Basement || GameControl.Instance.Player.TutorialState > TutorialState.LeftBasement)
				{
					ToggleInputActive(active: true);
					SetSpellInputActive(active: true);
					TryResetHealTileTimer();
				}
			}
		}

		protected override void OnWandControllerDespawned(InputEvents.WandControllerDespawnedEvent eventData)
		{
		}

		private void OnConnectedToMatchRoom(Events.ConnectedToMatchRoom eventData)
		{
			if (GameControl.Instance.IsCurrentLevel(Level.Lobby))
			{
				RespawnWielder();
			}
		}

		public void RespawnWielder()
		{
			if (base.Wielder != null)
			{
				UnityEngine.Object.Destroy(base.Wielder.gameObject);
				base.Wielder = null;
			}
			if (m_movement != null)
			{
				RemoveMovement();
			}
			SpawnAndConnectWielder(Level.Lobby);
		}

		public void ToggleInputActive(bool active)
		{
			if (Input != null)
			{
				if (active)
				{
					Input.InputManager.DisableInputLock();
					return;
				}
				Input.CancelHaptics(VibrateController.Both);
				Input.InputManager.EnableInputLock();
			}
		}

		public void SetSpellInputActive()
		{
			bool? flag = PunSingleton<SceneControl>.Instance?.GetMatchStartedOrSoloExperience();
			SetSpellInputActive(flag.HasValue && flag.Value);
		}

		public void SetSpellInputActive(bool active)
		{
			SetTeleportActive(active);
			base.Wand?.SetSpellInputActive(active);
			if (!active)
			{
				Input?.CancelHaptics(VibrateController.Both);
			}
		}

		public void SetCameraCullingMask(LayerMask mask)
		{
			m_camera.SetCameraCullingMask(mask);
		}

		public void UpdateInputMethod(bool force)
		{
			if (Input != null)
			{
				if (force)
				{
					Input.InputManager.UpdateInputMethod();
				}
				else
				{
					Input.InputManager.TryUpdateInputMethod();
				}
			}
		}

		public void CreateInputSystem()
		{
			if (Input == null)
			{
				Input = new PlayerInput(this, m_aimData, base.transform, CameraTransform);
				Input.CreateInputManager();
				m_updateInput = true;
			}
		}

		public void StopCurrentInputListener()
		{
			if (Input != null)
			{
				Input.InputManager.StopCurrentListener();
			}
		}

		private void CreateCamera()
		{
			m_camera = new PlayerCamera(base.transform.RetrieveChild("CameraRig"), GameControl.Instance.Platform.Type);
			m_camera.TryInstantiateCamera();
			RecenterCamera(0.1f, force: true);
		}

		public void RecenterCamera(float delay = 0f, bool force = false)
		{
			if (force || GameControl.Instance.Platform.SupportsPositionalTracking)
			{
				StopCoroutine("RecenterCameraAfterTime");
				if (delay > 0f)
				{
					StartCoroutine("RecenterCameraAfterTime", delay);
				}
				else
				{
					EventHub.Publish(new InputEvents.RecenterCameraEvent());
				}
			}
		}

		private IEnumerator RecenterCameraAfterTime(float delay)
		{
			yield return new WaitForSeconds(delay);
			EventHub.Publish(new InputEvents.RecenterCameraEvent());
		}

		public void MatchTileRotation(Transform tileTransform)
		{
			float num = tileTransform.rotation.eulerAngles.y + 360f;
			num %= 360f;
			m_camera.FaceDirection(num);
		}

		public void OnPlayerDisconnected(int layerIndex)
		{
			UpdateObjectLayer(layerIndex);
			PunSingleton<TileManager>.Instance?.OccupyTile(GetCurrentTile(), TileOccupyState.Unoccupied);
		}

		private void EnablePlayerHUD()
		{
			m_hudPrewarmed.FadeHUD(fadeIn: true);
			m_hudPrewarmed.UpdateSelectedSpell();
			m_hudPrewarmed.ResetVitalBars();
			m_hud = m_hudPrewarmed;
		}

		private void DisablePlayerHUD()
		{
			HUD?.SetActive(active: false, null, isDualWielding: false);
		}

		public void SetCastFeedbackActive(bool active, WandHand wandHand)
		{
			HUD?.SetCastFeedbackActive(active, wandHand);
		}

		public void UpdatePlayerStatsMana(float changeValue)
		{
			base.Wand?.UpdatedPlayerStatsMana(m_manaData.Current);
			HUD?.UpdateManaBar(changeValue);
		}

		public void UpdatePlayerStatsHealth(float changeValue)
		{
			base.Wand?.UpdatedPlayerStatsHealth(m_healthData.Current);
			HUD?.UpdateHealthBar(changeValue);
		}

		protected override void UpdateMana(float changeValue)
		{
			base.UpdateMana(changeValue);
			UpdatePlayerStatsMana(changeValue);
		}

		protected override void RegenerateMana()
		{
			if (m_regenerateMana)
			{
				float changeValue = m_manaData.RegenerationSpeed * Time.deltaTime;
				if (m_manaData.Regenerate(changeValue) == m_manaData.Max)
				{
					m_regenerateMana = false;
				}
				UpdatePlayerStatsMana(changeValue);
			}
		}

		public void ResetRotation()
		{
			if (GameControl.Instance.GetCurrentLevel().ContainsFlag(Level.Arena | Level.Lobby))
			{
				m_camera.FaceDirection((Quaternion.LookRotation(Input.GetAim().AimRay.direction).eulerAngles.y + 360f) % 360f);
			}
			else
			{
				m_camera.FaceDirection(0f);
			}
		}

		public void AddHealthPickup(float pickupAmount, WandHand pickupHand)
		{
			Input.NullHighlightedInteractable();
			ChangeHealth(pickupAmount);
			if (m_playerStats.ManaRestoringPickups.IsActive && m_playerStats.ManaRestoringPickups.WandHand == pickupHand)
			{
				m_manaData.SetCurrent(m_manaData.Max);
			}
		}

		public override void ChangeHealth(float changeValue)
		{
			if (changeValue < 0f)
			{
				TryRestoreManaFromDamage(0f - changeValue);
			}
			else
			{
				if (base.IsCurseActive)
				{
					TakeDamage(DamageType.OnceContinuous, changeValue, Vector2.up);
					return;
				}
				changeValue *= m_playerStats.HealMultiplier;
			}
			UpdateHealth(changeValue);
		}

		protected override void UpdateHealth(float changeValue)
		{
			float health = base.Health;
			base.UpdateHealth(changeValue);
			base.HurtSfxHandler.CheckHeartbeatConditions(base.Health);
			UpdatePlayerStatsHealth(base.Health - health);
		}

		public override bool TakeDamage(DamageType damageType, float damage, Vector2 hitDirection)
		{
			if (TryHealPlayer(damage))
			{
				return true;
			}
			if (IsImmuneToDamageType(damageType))
			{
				return false;
			}
			if (m_checkFirstBlood)
			{
				base.Wielder.SetFirstBlood();
				m_checkFirstBlood = false;
			}
			damage *= m_damageTakenMultiplier * m_playerStats.DamageTakenMultiplier;
			damage = GetDamageAfterArmorReduction(damageType, damage);
			TriggerHaptics(damage);
			base.DamageReceivedTotal += damage;
			ChangeHealth(0f - damage);
			if (base.Health >= 1f)
			{
				bool flag = damageType != DamageType.Continuous;
				base.HurtSfxHandler.PlayHitReaction(flag, hitDirection);
				base.Wielder.PlayHitReponse();
				Events.DamageTakenEvent damageTakenEvent = new Events.DamageTakenEvent();
				damageTakenEvent.CharacterControl = this;
				damageTakenEvent.Damage = damage;
				EventHub.Publish(damageTakenEvent);
				if (flag)
				{
					TryAutoLeapImmediate();
				}
				else
				{
					TryAutoLeapContinuous();
				}
				return true;
			}
			base.Health = 0f;
			SceneControl instance = PunSingleton<SceneControl>.Instance;
			if (instance != null && instance.CurrentMatchType.ContainsFlag(MatchType.SoloExperience))
			{
				instance.ResetMatch();
			}
			else
			{
				Die(hitDirection);
			}
			return true;
		}

		private void TriggerHaptics(float damage)
		{
			if (damage > 30f)
			{
				Input.TriggerHaptics(m_takeDamageHapticsBig, overrideCurrent: true);
			}
			else
			{
				Input.TriggerHaptics(m_takeDamageHapticsSmall, overrideCurrent: true);
			}
		}

		public override void SetChillingClutchEffectActive(bool active)
		{
			base.SetChillingClutchEffectActive(active);
			m_effectHandler.SetEffectActive(EffectType.ChillingClutchLingeringEffect, active, base.ColliderTransform);
			if (!(base.Wielder == null))
			{
				if (active)
				{
					base.Wielder.ApplyChillingClutch();
				}
				else
				{
					base.Wielder.DisableChillingClutch();
				}
			}
		}

		public override void DisableActiveEffects()
		{
			base.DisableActiveEffects();
			if (m_effectHandler != null)
			{
				m_effectHandler.DestroyAllEffects();
			}
		}

		public override void ResetHealth()
		{
			base.ResetHealth();
			base.HurtSfxHandler.StopHeartBeat();
			UpdatePlayerStatsHealth(0f);
		}

		public override void ResetMana()
		{
			base.ResetMana();
			UpdatePlayerStatsMana(base.Mana);
		}

		public override void ResetToInsideTileArea(Vector3 tilePosition)
		{
			base.ResetToInsideTileArea(tilePosition);
			RecenterCamera(0.1f);
			if (m_trackTileArea)
			{
				m_tileAreaHandler.MarkAsInsideTileArea();
			}
		}

		public override void ResetPosition(MatchType matchType)
		{
			base.ResetPosition(matchType);
			m_movement.StartTile.SetTilePropsActive();
			MonoSingleton<ArenaUI>.Instance?.SetTrackPosition(m_movement.StartTile.transform.position);
		}

		protected override void RemoveMovement()
		{
			base.RemoveMovement();
			m_trackTileArea = false;
			if (m_tileAreaHandler != null)
			{
				RecenterCamera();
				m_tileAreaHandler = null;
			}
			if (m_cameraEffectHandler != null)
			{
				m_cameraEffectHandler.ResetGrayscale();
				m_cameraEffectHandler = null;
			}
		}

		protected override void CreateMovement(Tile startTile)
		{
			base.CreateMovement(startTile);
			if (GameControl.Instance.Platform.SupportsPositionalTracking)
			{
				m_tileAreaHandler = new PlayerTileAreaHandler(this, base.ColliderTransform);
				m_cameraEffectHandler = new PlayerCameraEffectHandler(this, m_camera.PostProcessing, CameraTransform.GetComponent<CameraSaturationHandler>());
				m_trackTileArea = true;
			}
		}

		protected override void SetMovementTile(Tile tile)
		{
			base.SetMovementTile(tile);
			MonoSingleton<ArenaUI>.Instance?.SetTrackPosition(tile.transform.position);
			tile.SetTilePropsActive();
			tile.SetHighlighted(enable: false);
			tile.SetTeleportActive(enable: false);
			TryResetHealTileTimer();
		}

		public override Vector3 GetPlayerPosition()
		{
			if (m_trackTileArea)
			{
				Vector3 position = CameraTransform.position;
				position.y = base.transform.position.y;
				return position;
			}
			return base.GetPlayerPosition();
		}

		public void SetCameraEffectActive(EffectType type, bool active)
		{
			m_effectHandler.SetCameraEffectActive(type, active, CameraTransform);
		}

		public override void SetFreeTeleportActive(bool enable)
		{
			SetCameraEffectActive(EffectType.OrtusPickup, enable);
			Events.FreeTeleportActivationEvent freeTeleportActivationEvent = new Events.FreeTeleportActivationEvent();
			freeTeleportActivationEvent.IsActive = enable;
			EventHub.Publish(freeTeleportActivationEvent);
		}

		public override void TryTrackTileHit(WandHand wandHand)
		{
			if (!MonoSingleton<ArenaUI>.Instance.GetAnyMenuOpen())
			{
				if (base.IsTeleporting)
				{
					base.Wand.ResetHighlightedTile(wandHand);
				}
				else
				{
					base.Wand.TrackTileHit(wandHand);
				}
			}
		}

		private void UpdateWielderTrackingTransforms()
		{
			base.Wielder.UpdateTrackingTransforms(IsTrackingHands, OriginTrackingTarget, HeadTrackingTarget, LeftHandTrackingTarget, RightHandTrackingTarget);
		}

		private void UpdateTrackingTransforms()
		{
			if (CameraTransform == null)
			{
				return;
			}
			if (GameControl.Instance.Platform.SupportsPositionalTracking)
			{
				OriginTrackingTarget.SetValues(CameraRigTransform.localPosition, CameraRigTransform.localRotation, CameraRigTransform.localScale);
				if (GameControl.Instance.Platform.Type != PlatformType.PicoNeo2)
				{
					HeadTrackingTarget.SetValues(InputTrackingGetLocalPosition(XRNode.Head), InputTrackingGetLocalRotation(XRNode.Head));
				}
				else
				{
					HeadTrackingTarget.SetValues(Pvr_UnitySDKSensor.Instance.HeadPose.Position, Pvr_UnitySDKSensor.Instance.HeadPose.Orientation);
				}
			}
			else
			{
				OriginTrackingTarget.SetValues(Vector3.zero, CameraRigTransform.localRotation, CameraRigTransform.localScale);
				HeadTrackingTarget.SetValues(new Vector3(0f, 1.65f, 0f), CameraTransform.localRotation);
			}
			if (GetCurrentTile() != null && !base.TeleportHandler.IsTeleporting)
			{
				LimitPositionsInsideTile();
			}
			if (IsTrackingHands)
			{
				if (GameControl.Instance.Platform.Type != PlatformType.PicoNeo2)
				{
					LeftHandTrackingTarget.SetValues(InputTrackingGetLocalPosition(XRNode.LeftHand), InputTrackingGetLocalRotation(XRNode.LeftHand));
					RightHandTrackingTarget.SetValues(InputTrackingGetLocalPosition(XRNode.RightHand), InputTrackingGetLocalRotation(XRNode.RightHand));
				}
				else
				{
					LeftHandTrackingTarget.SetValues(m_camera.LeftHand.localPosition, m_camera.LeftHand.localRotation);
					RightHandTrackingTarget.SetValues(m_camera.RightHand.localPosition, m_camera.RightHand.localRotation);
				}
			}
		}

		private void LimitPositionsInsideTile()
		{
			Tile currentTile = GetCurrentTile();
			Vector3 playerPosition = GetPlayerPosition();
			if (!TileAreaController.IsInsideTileArea(playerPosition, currentTile))
			{
				Vector3 positionInsideTileArea = TileAreaController.GetPositionInsideTileArea(playerPosition, currentTile.transform.position);
				Vector3 vector = positionInsideTileArea - playerPosition;
				OriginTrackingTarget.Position += vector;
			}
		}

		public override void EnableCurse(float curseTime, CurseLingeringEffect curse)
		{
			TryDisableActiveCurse();
			m_curseEffect = curse;
			Events.CurseActivationEvent curseActivationEvent = new Events.CurseActivationEvent();
			curseActivationEvent.IsActive = true;
			EventHub.Publish(curseActivationEvent);
		}

		public override void DisableCurse()
		{
			if (!m_playerStats.IsAlwaysCursed)
			{
				TryDisableActiveCurse();
				m_curseEffect = null;
				Events.CurseActivationEvent curseActivationEvent = new Events.CurseActivationEvent();
				curseActivationEvent.IsActive = false;
				EventHub.Publish(curseActivationEvent);
			}
		}

		public override void CreateHP()
		{
			m_healthData = StatsData.CreateInstance(m_playerStats.MaxHealth);
		}

		public override void CreateMana()
		{
			m_manaData = RegeneratingStatsData.CreateInstance(m_playerStats.MaxMana, m_playerStats.ManaRegen);
		}

		public static Vector3 InputTrackingGetLocalPosition(XRNode node)
		{
			return InputTracking.GetLocalPosition(node);
		}

		public static Quaternion InputTrackingGetLocalRotation(XRNode node)
		{
			return InputTracking.GetLocalRotation(node);
		}

		protected override void TryDepleteMaxMana(float depletionMultiplier)
		{
			m_manaData.SetMax(m_manaData.Max * depletionMultiplier);
			UpdatePlayerStatsMana(0f);
		}

		private void TryRestoreManaFromDamage(float damage)
		{
			if (m_playerStats.ManaRestoreOnDamageTakenMultiplier.IsActive)
			{
				UpdateMana(damage * m_playerStats.ManaRestoreOnDamageTakenMultiplier.Value);
			}
		}

		private void TryAutoLeapContinuous()
		{
			if (m_playerStats.AutoCastLeapOnHitChance.IsActive)
			{
				if (m_autoLeapTimer < 1f)
				{
					m_autoLeapTimer += Time.deltaTime;
				}
				else
				{
					TryAutoLeap();
				}
			}
		}

		private void TryAutoLeapImmediate()
		{
			if (m_playerStats.AutoCastLeapOnHitChance.IsActive)
			{
				TryAutoLeap();
			}
		}

		private void TryAutoLeap()
		{
			m_autoLeapTimer = 0f;
			if (UnityEngine.Random.value <= m_playerStats.AutoCastLeapOnHitChance.Value)
			{
				base.Wand.ChaosLeap.AutoCast(GetCurrentTile());
			}
		}

		private void TryResetHealTileTimer()
		{
			if (m_playerStats.AddHealToTileAfterSeconds.IsActive)
			{
				if (base.Wand != null && !base.Wand.IsSpellCastingLocked)
				{
					m_tileHealTimer.Value = m_playerStats.AddHealToTileAfterSeconds.Value;
					m_tileHealTimer.IsActive = true;
				}
			}
			else if (m_tileHealTimer.IsActive)
			{
				m_tileHealTimer.IsActive = false;
			}
		}

		private void TryActivateHealEffectOnTile()
		{
			if (m_tileHealTimer.IsActive)
			{
				if (m_tileHealTimer.Value > 0f)
				{
					m_tileHealTimer.Value -= Time.deltaTime;
					return;
				}
				m_tileHealTimer.IsActive = false;
				Tile currentTile = GetCurrentTile();
				ObjectPoolHandler.GrabFromPool(PoolObjectType.ValeCrystalHeal, null).EnableObject(currentTile.transform.position, currentTile.photonView.ViewID);
			}
		}

		private void TrySideloadWandPropertySpells()
		{
			if (m_playerStats.StartingArmor.IsActive)
			{
				WandHand wandHand = m_playerStats.StartingArmor.WandHand;
				base.Wand.TrySpawnArmor(wandHand, Input.GetAim(wandHand).WandPivot, m_playerStats.StartingArmor.Value);
			}
			if (m_playerStats.IsAlwaysCursed)
			{
				ActivateUnbreakableCurse();
			}
			if (m_playerStats.AutoCastLeapOnHitChance.IsActive)
			{
				base.Wand.TrySpawnLeap();
			}
			if (m_playerStats.AddHealToTileAfterSeconds.IsActive && !GameControl.Instance.IsCurrentLevel(Level.DeadMastersVale))
			{
				ObjectPoolHandler.CreateObjectPool(1, PoolObjectType.ValeCrystalHeal);
			}
		}

		private void ActivateUnbreakableCurse()
		{
			NetworkUtils.InstantiateAsync("CurseOfTheUndeadLingering", Vector3.zero, Quaternion.identity, 0, delegate(GameObject loadedObject)
			{
				CurseLingeringEffect component = loadedObject.GetComponent<CurseLingeringEffect>();
				component.EnableObject(GetCurrentTile().transform.position, base.Wielder.ViewID, -1f);
			}, null);
		}

		private void ResetWandProperties()
		{
			m_tileHealTimer.IsActive = false;
		}
	}
	public class PlayerInput
	{
		private const float RotationLockTime = 0.4f;

		private const float DragDistanceMultiplier = 0.35f;

		private const float GrabDistanceDefault = 0.25f;

		private const float GrabDistanceHead = 0.5f;

		private const string AimPivotName = "AimPivot";

		private const string WandPivotName = "Wand";

		private readonly WandHand m_defaultHand;

		private bool m_trackDragObjects;

		private float m_currentRecenterHoldTime;

		private float m_rotationLockTimer;

		private float m_grabDistance;

		private Transform m_cameraRig;

		private Transform m_cameraTransform;

		private Transform m_workshopControllerTransform;

		private IList<Transform> m_controllerTransforms = new List<Transform>(2);

		private IList<PlayerAim> m_playerAims = new List<PlayerAim>(2);

		private Transform m_rightHandTransform;

		private Transform m_leftHandTransform;

		private IDragObject m_dragObject;

		private ISnapObject m_closestSnapObject;

		private AimData m_aimData;

		private PlayerControl m_playerControl;

		private HandsHandler m_handsHandler;

		private PlayerAim m_cameraAim;

		private PlayerAim m_defaultAim;

		private IHapticsPlatform m_hapticsPlatform;

		private InputEvents.InputChangedEvent m_inputChangedEvent = new InputEvents.InputChangedEvent();

		private EventToken m_sceneLoadInitiatedEventToken;

		private EventToken m_sceneLoadedEventToken;

		private EventToken m_platformInputUpdatedEventToken;

		private EventToken m_dualWieldStateUpdatedEventToken;

		private EventToken m_wandGripChangedEventToken;

		private IDictionary<WandHand, Interactable> m_highlightedInteractables = new Dictionary<WandHand, Interactable>(2)
		{
			{
				WandHand.Right,
				null
			},
			{
				WandHand.Left,
				null
			}
		};

		public WandsInputManager InputManager { get; private set; }

		public WandSlot ClosestSlot { get; private set; }

		public bool IsDragEnabled { get; private set; }

		public bool IsDualWielding
		{
			[CompilerGenerated]
			get
			{
				return m_inputChangedEvent.IsDualWieldEnabled && InputManager.IsDualWandInputListener;
			}
		}

		public WandInput WandInput
		{
			get
			{
				return m_inputChangedEvent.WandInput;
			}
			private set
			{
				m_inputChangedEvent.WandInput = value;
			}
		}

		public AimInput AimInput
		{
			get
			{
				return m_inputChangedEvent.AimInput;
			}
			private set
			{
				m_inputChangedEvent.AimInput = value;
			}
		}

		public PlayerInput(PlayerControl playerControl, AimData aimData, Transform playerTransform, Transform cameraTransform)
		{
			m_playerControl = playerControl;
			m_aimData = aimData;
			m_cameraTransform = cameraTransform;
			m_cameraRig = cameraTransform.parent;
			m_hapticsPlatform = GameControl.Instance.Platform as IHapticsPlatform;
			m_inputChangedEvent.IsDualWieldEnabled = GameControl.Instance.IsDualWieldSupportedAndActive;
			m_inputChangedEvent.WandGrip = WandsSave.WandGrip;
			SubscribeToEvents();
		}

		public void CreateInputManager()
		{
			InputManager = new WandsInputManager();
			InputManager.UpdateInputMethod();
		}

		public void UpdateInput()
		{
			InputManager.Update();
			if (IsDragEnabled && m_dragObject.IsDraggable)
			{
				HandleDrag();
			}
		}

		private void SubscribeToEvents()
		{
			m_sceneLoadInitiatedEventToken = EventHub.Subscribe<Events.SceneLoadInitiatedEvent>(OnSceneLoadInitiated);
			m_sceneLoadedEventToken = EventHub.Subscribe<Events.SceneLoadedEvent>(OnSceneLoaded);
			m_platformInputUpdatedEventToken = EventHub.Subscribe<InputEvents.PlatformInputUpdated>(OnPlatformInputUpdated);
			m_dualWieldStateUpdatedEventToken = EventHub.Subscribe<InputEvents.DualWieldStateUpdatedEvent>(OnDualWieldStateUpdated);
			m_wandGripChangedEventToken = EventHub.Subscribe<InputEvents.WandGripChangedEvent>(OnWandGripChanged);
		}

		public void UnsubscribeToEvents()
		{
			EventHub.Unsubscribe(m_sceneLoadInitiatedEventToken);
			EventHub.Unsubscribe(m_sceneLoadedEventToken);
			EventHub.Unsubscribe(m_platformInputUpdatedEventToken);
			EventHub.Unsubscribe(m_dualWieldStateUpdatedEventToken);
			EventHub.Unsubscribe(m_wandGripChangedEventToken);
		}

		private void OnSceneLoadInitiated(Events.SceneLoadInitiatedEvent eventData)
		{
			InputManager.StopCurrentListener();
			DestroyActiveController();
			if (eventData.CurrentLevel.ContainsFlag(Level.Arena))
			{
				m_playerControl.DestroyPlayerWand();
			}
		}

		private void OnSceneLoaded(Events.SceneLoadedEvent eventData)
		{
			UpdateInputListener(eventData.Level);
			if (eventData.Level == Level.Workshop)
			{
				UpdateController(eventData.Level);
				UpdateWorkshopAimPivot();
			}
		}

		private void OnPlatformInputUpdated(InputEvents.PlatformInputUpdated eventData)
		{
			m_inputChangedEvent.IsDualWieldEnabled = eventData.IsDualWieldEnabled;
			PlatformInputUpdated(eventData.AimInput, eventData.WandInput);
			if (eventData.AimInput.ContainsFlag(AimInput.Hand))
			{
				UpdateHaptics(eventData.IsDualWieldEnabled);
			}
			PlayerProperty.Set("P7", eventData.IsDualWieldEnabled);
		}

		private void OnDualWieldStateUpdated(InputEvents.DualWieldStateUpdatedEvent eventData)
		{
			m_inputChangedEvent.IsDualWieldEnabled = eventData.IsDualWieldEnabled;
			EventHub.Publish(m_inputChangedEvent);
			if (AimInput.ContainsFlag(AimInput.Hand))
			{
				UpdateHaptics(eventData.IsDualWieldEnabled);
			}
			PlayerProperty.Set("P7", eventData.IsDualWieldEnabled);
		}

		private void OnWandGripChanged(InputEvents.WandGripChangedEvent eventData)
		{
			m_inputChangedEvent.WandGrip = eventData.WandGrip;
		}

		private void UpdateInputListener(Level currentLevel)
		{
			switch (currentLevel)
			{
			case Level.MainMenu:
				InputManager.SetInputListener(new MainMenuInputListener(this));
				break;
			case Level.Workshop:
				InputManager.SetInputListener(new WorkshopInputListener(this));
				m_trackDragObjects = true;
				break;
			case Level.Lobby:
				m_trackDragObjects = false;
				InputManager.SetInputListener(new LobbyInputListener(this));
				break;
			case Level.Basement:
			case Level.AspisPrison:
			case Level.TempleOfOphidian:
			case Level.TheCelestialHalls:
			case Level.OrtusStation:
			case Level.DeadMastersVale:
			case Level.SanctumOfSahir:
			case Level.TheCelestialHalls_AIBot:
			case Level.FountainOfTheFallen:
				m_trackDragObjects = false;
				if (GameControl.Instance.IsDualWieldSupportedAndActive)
				{
					InputManager.SetInputListener(new DualWieldInputListener(this));
				}
				else
				{
					InputManager.SetInputListener(new MatchInputListener(this));
				}
				break;
			default:
				throw new NotImplementedException($"Level '{currentLevel}' not recognized by PlayerInput");
			}
		}

		public void SpawnArenaControllers(Level level)
		{
			UpdateController(level);
			if (m_playerControl.TryInstantiatePlayerWand(IsDualWielding))
			{
				m_playerControl.SpawnWandController(level);
			}
			else
			{
				SetWandController(m_playerControl.Wand);
			}
			UpdateAimPivots();
			m_playerControl.SetSpellInputActive();
		}

		public void SpawnLobbyController()
		{
			UpdateController(Level.Lobby);
			m_playerControl.DestroyPlayerWand();
			UpdateWorkshopAimPivot();
			m_playerControl.SetSpellInputActive();
		}

		private void PlatformInputUpdated(AimInput aimInput, WandInput wandInput)
		{
			WandInput = wandInput;
			AimInput = aimInput;
			PlayerProperty.Set("P4", (int)aimInput);
			m_grabDistance = ((aimInput != AimInput.Head) ? 0.25f : 0.5f);
			Level currentLevel = GameControl.Instance.GetCurrentLevel();
			UpdateInputListener(currentLevel);
			if (m_playerControl.Wielder == null)
			{
				UpdateController(currentLevel);
				UpdateWorkshopAimPivot();
			}
			else if (currentLevel == Level.Lobby)
			{
				SpawnLobbyController();
			}
			else
			{
				SpawnArenaControllers(currentLevel);
			}
			m_playerControl.IsTrackingHands = aimInput.ContainsFlag(AimInput.Hand);
		}

		private void UpdateController(Level level)
		{
			if (AimInput == AimInput.Head)
			{
				EnableGazeControls();
				return;
			}
			switch (level)
			{
			case Level.MainMenu:
			case Level.Workshop:
				InstantiateWorkshopController();
				break;
			case Level.Lobby:
				HideActiveController();
				InstantiateWorkshopController();
				break;
			default:
				TryInstantiateControlPrefab();
				InstantiateControllers();
				break;
			}
			if (AimInput.ContainsFlag(AimInput.Hand))
			{
				InstantiateHands();
				UpdateHaptics(IsDualWielding);
			}
			UpdateHandedness();
			EventHub.Publish(m_inputChangedEvent);
		}

		private void EnableGazeControls()
		{
			DestroyActiveController();
			HideHands();
			if (m_cameraAim == null)
			{
				ClearAim();
				m_cameraAim = CreateAim(m_cameraTransform);
				m_playerAims.Add(m_cameraAim);
			}
			EventHub.Publish(m_inputChangedEvent);
		}

		private void InstantiateWorkshopController()
		{
			if (m_workshopControllerTransform != null)
			{
				m_workshopControllerTransform.gameObject.SetActive(value: true);
				return;
			}
			string assetName = $"{GameControl.Instance.Platform.PlatformName}ControllerWorkshop";
			GameObject gameObject = GameControl.Instance.AssetHandler.LoadAsset<GameObject>(AssetBundleType.Platform, assetName);
			if (gameObject == null)
			{
				WandsLogger.LogError("Platform controller prefab is null");
				return;
			}
			m_workshopControllerTransform = UnityEngine.Object.Instantiate(gameObject).transform;
			ClearAim();
			PlayerAim item = CreateAim(m_workshopControllerTransform.transform);
			m_playerAims.Add(item);
		}

		private void TryInstantiateControlPrefab()
		{
			if (m_controllerTransforms.Count > 0)
			{
				return;
			}
			string assetName = $"{GameControl.Instance.Platform.PlatformName}Controller";
			GameObject gameObject = GameControl.Instance.AssetHandler.LoadAsset<GameObject>(AssetBundleType.Platform, assetName);
			if (gameObject == null)
			{
				WandsLogger.LogError("Platform controller prefab is null");
				return;
			}
			int num = ((!AimInput.ContainsFlag(AimInput.Hand)) ? 1 : 2);
			for (int i = 0; i < num; i++)
			{
				m_controllerTransforms.Add(UnityEngine.Object.Instantiate(gameObject).transform);
			}
		}

		private void InstantiateControllers()
		{
			ClearAim();
			for (int i = 0; i < m_controllerTransforms.Count; i++)
			{
				if (IsDualWielding || AimInput.ToWandHand() == (WandHand)i)
				{
					m_controllerTransforms[i].gameObject.SetActive(value: true);
					m_playerAims.Add(CreateAim(m_controllerTransforms[i], IsDualWielding ? ((WandHand)i) : WandHand.Right));
				}
				else
				{
					m_controllerTransforms[i].gameObject.SetActive(value: false);
				}
			}
		}

		public void SetWandController(WandManager wandManager)
		{
			InputManager.SetWandManager(wandManager);
			InputEvents.WandControllerSpawnedEvent wandControllerSpawnedEvent = new InputEvents.WandControllerSpawnedEvent();
			wandControllerSpawnedEvent.AimInput = AimInput;
			wandControllerSpawnedEvent.WandGrip = m_inputChangedEvent.WandGrip;
			wandControllerSpawnedEvent.IsDualWieldEnabled = IsDualWielding;
			EventHub.Publish(wandControllerSpawnedEvent);
		}

		private void UpdateHandedness()
		{
			if (m_workshopControllerTransform != null)
			{
				Transform parent = ((!AimInput.ContainsFlag(AimInput.Hand)) ? m_cameraRig : ((AimInput != AimInput.RightHand) ? m_handsHandler.LeftAimPoint : m_handsHandler.RightAimPoint));
				m_workshopControllerTransform.SetParent(parent, worldPositionStays: false);
				m_playerAims[0].DisableAim();
			}
			else if (AimInput.ContainsFlag(AimInput.Hand))
			{
				m_controllerTransforms[0].SetParent(m_handsHandler.RightEquip, worldPositionStays: false);
				m_controllerTransforms[1].SetParent(m_handsHandler.LeftEquip, worldPositionStays: false);
			}
			else
			{
				HideHands();
				m_controllerTransforms[0].SetParent(m_cameraRig, worldPositionStays: false);
			}
		}

		private void UpdateHaptics(bool isDualWieldEnabled)
		{
			if (m_hapticsPlatform != null)
			{
				m_hapticsPlatform.UpdatePrimaryHand(isDualWieldEnabled || AimInput.ToWandHand() != WandHand.Left);
			}
		}

		private void UpdateWorkshopAimPivot()
		{
			if (AimInput == AimInput.Head)
			{
				m_cameraAim.UpdateAimPivot(AimInput.Head, m_cameraAim.AimPivot);
			}
			else if (m_workshopControllerTransform != null)
			{
				m_playerAims[0].UpdateAimPivot(AimInput, m_workshopControllerTransform.RetrieveChild("AimPivot", includeInactive: true));
			}
			else
			{
				WandsLogger.LogError("Tried updating Workshop aim pivot without a workshop controller transform");
			}
		}

		private void UpdateAimPivots()
		{
			if (AimInput == AimInput.Head)
			{
				m_cameraAim.UpdateAimPivot(AimInput.Head, m_cameraAim.AimPivot);
			}
			else if (IsDualWielding)
			{
				for (int i = 0; i < m_playerAims.Count; i++)
				{
					AimInput aimInput = ((i != 0) ? AimInput.LeftHand : AimInput.RightHand);
					m_playerAims[i].UpdateAimPivot(aimInput, m_controllerTransforms[i].RetrieveChild("AimPivot", includeInactive: true));
				}
			}
			else
			{
				m_playerAims[0].UpdateAimPivot(AimInput, m_controllerTransforms[(int)AimInput.ToWandHand()].RetrieveChild("AimPivot", includeInactive: true));
			}
		}

		private void InstantiateHands()
		{
			if (m_handsHandler != null)
			{
				m_handsHandler.SetHandsActive(active: true);
				return;
			}
			m_rightHandTransform = m_cameraRig.RetrieveChild("RightHand", includeInactive: true, includePartials: true);
			m_leftHandTransform = m_cameraRig.RetrieveChild("LeftHand", includeInactive: true, includePartials: true);
			GameObject gameObject = GameControl.Instance.AssetHandler.LoadAsset<GameObject>(AssetBundleType.Platform, string.Concat(GameControl.Instance.Platform.Type, "Hands"));
			if (gameObject == null)
			{
				WandsLogger.LogError("Hands prefab is null");
				return;
			}
			m_handsHandler = UnityEngine.Object.Instantiate(gameObject, m_cameraRig).GetComponent<HandsHandler>();
			m_handsHandler.SetPlayerReferences(m_playerControl);
			m_handsHandler.ResetCustomHands(m_leftHandTransform, m_rightHandTransform);
		}

		private void HideHands()
		{
			if ((object)m_handsHandler != null)
			{
				m_handsHandler.SetHandsActive(active: false);
			}
		}

		private void HideActiveController()
		{
			if (m_workshopControllerTransform != null)
			{
				m_workshopControllerTransform.gameObject.SetActive(value: false);
				return;
			}
			for (int i = 0; i < m_controllerTransforms.Count; i++)
			{
				m_controllerTransforms[i].gameObject.SetActive(value: false);
			}
		}

		private void DestroyActiveController()
		{
			if (m_workshopControllerTransform != null)
			{
				UnityEngine.Object.Destroy(m_workshopControllerTransform.gameObject);
				return;
			}
			for (int num = m_controllerTransforms.Count - 1; num >= 0; num--)
			{
				UnityEngine.Object.Destroy(m_controllerTransforms[num].gameObject);
			}
			m_controllerTransforms.Clear();
		}

		public bool TryInteractWithObject(bool setToNull = false)
		{
			return TryInteractWithObject(m_defaultHand, setToNull);
		}

		public bool TryInteractWithObject(WandHand wandHand, bool setToNull = false)
		{
			Interactable interactable = m_highlightedInteractables[wandHand];
			if (interactable == null || interactable.InteractionLocked)
			{
				return false;
			}
			interactable.Interact();
			if (setToNull)
			{
				interactable.LookExit();
				m_highlightedInteractables[wandHand] = null;
			}
			return true;
		}

		public void TryInteractWithWorkshopObject(bool isAutoTeleportEnabled)
		{
			Interactable interactable = m_highlightedInteractables[m_defaultHand];
			if (!(interactable == null) && !interactable.InteractionLocked && (!isAutoTeleportEnabled || !(interactable is WorkshopTile)))
			{
				interactable.Interact();
			}
		}

		public void TryInteractWithWorkshopTile()
		{
			WorkshopTile workshopTile = m_highlightedInteractables[m_defaultHand] as WorkshopTile;
			if (!(workshopTile == null) && !workshopTile.InteractionLocked)
			{
				workshopTile.Interact();
			}
		}

		public bool CloseMenus()
		{
			if (MonoSingleton<ArenaUI>.Instance != null && MonoSingleton<ArenaUI>.Instance.Menu.IsMenuActive)
			{
				MonoSingleton<ArenaUI>.Instance.ToggleMenuActive(enable: false);
				return true;
			}
			return false;
		}

		public void RotateTowards(RotationDirection rotationDirection)
		{
			if (!(m_rotationLockTimer + 0.4f > Time.time))
			{
				m_rotationLockTimer = Time.time;
				InputEvents.RotateCameraEvent rotateCameraEvent = new InputEvents.RotateCameraEvent();
				rotateCameraEvent.RotationDirection = rotationDirection;
				EventHub.Publish(rotateCameraEvent);
			}
		}

		public void ResetRecenterPlayer()
		{
			m_currentRecenterHoldTime = 0f;
			foreach (PlayerAim playerAim in m_playerAims)
			{
				playerAim.FillRecenterReticle(0f);
			}
		}

		public void TryRecenterPlayer()
		{
			m_currentRecenterHoldTime += Time.deltaTime;
			foreach (PlayerAim playerAim in m_playerAims)
			{
				playerAim.FillRecenterReticle(m_currentRecenterHoldTime / 0.5f);
			}
			if (m_currentRecenterHoldTime > 0.5f)
			{
				m_playerControl.RecenterCamera();
				m_currentRecenterHoldTime = 0f;
			}
		}

		public void TryTrackInteractObjects()
		{
			TryTrackInteractObjects(m_defaultHand);
		}

		public void TryTrackInteractObjects(WandHand wandHand)
		{
			if (m_trackDragObjects)
			{
				if (!IsDragEnabled)
				{
					TrackDragAndInteractObjects();
				}
				return;
			}
			PlayerWand playerWand = m_playerControl.Wand?.GetPlayerWand(wandHand);
			if (playerWand != null && playerWand.WandControl != null && playerWand.WandControl.IsCasting)
			{
				NullHighlightedInteractable(wandHand);
			}
			TrackInteractObjects(wandHand);
		}

		private void TrackDragAndInteractObjects()
		{
			Interactable interactable = m_highlightedInteractables[m_defaultHand];
			if (Physics.Raycast(GetAim().AimRay, out var hitInfo, 15f, m_aimData.InteractableHitMask))
			{
				Interactable interactable2 = hitInfo.collider.GetComponent<Interactable>();
				if (interactable2 == null)
				{
					interactable2 = hitInfo.collider.GetComponentInParent<Interactable>();
					if (interactable2 == null)
					{
						interactable2 = hitInfo.collider.GetComponentInChildren<Interactable>();
					}
				}
				if (interactable2 == null)
				{
					return;
				}
				if (interactable2 != interactable && interactable != null)
				{
					interactable.LookExit();
					NullDragObject();
				}
				else if (interactable2 == interactable)
				{
					if (m_dragObject == null)
					{
						IDragObject dragObject = ((IDragObject)interactable.GetComponent(typeof(IDragObject))) ?? ((IDragObject)interactable.GetComponentInParent(typeof(IDragObject)));
						if (dragObject != null && !interactable.LookLocked)
						{
							m_dragObject = dragObject;
						}
					}
					return;
				}
				GetAim().SetAimDistance(hitInfo.point);
				if (!interactable2.LookLocked)
				{
					interactable2.LookEnter();
					m_highlightedInteractables[m_defaultHand] = interactable2;
					IDragObject dragObject2 = interactable2.GetComponent<IDragObject>() ?? interactable2.GetComponentInParent<IDragObject>();
					if (dragObject2 != null && !interactable2.LookLocked)
					{
						m_dragObject = dragObject2;
					}
				}
			}
			else if (interactable != null)
			{
				interactable.LookExit();
				m_highlightedInteractables[m_defaultHand] = null;
				NullDragObject();
			}
		}

		private void TrackInteractObjects(WandHand wandHand)
		{
			Interactable interactable = m_highlightedInteractables[wandHand];
			if (Physics.Raycast(GetAim(wandHand).AimRay, out var hitInfo, 15f, m_aimData.InteractableHitMask))
			{
				Interactable componentInParent = hitInfo.collider.GetComponentInParent<Interactable>();
				if (componentInParent == null || componentInParent == interactable)
				{
					return;
				}
				if (interactable != null)
				{
					if (interactable is IWandInteractable wandInteractable)
					{
						wandInteractable.LookExit(wandHand);
					}
					else
					{
						interactable.LookExit();
					}
				}
				if (componentInParent.LookLocked)
				{
					return;
				}
				if (IsDualWielding)
				{
					Interactable interactable2 = m_highlightedInteractables[wandHand.Opposite()];
					if (interactable2 != null && !(interactable2 is IWandInteractable))
					{
						interactable2.LookExit();
					}
				}
				m_highlightedInteractables[wandHand] = componentInParent;
				if (componentInParent is IWandInteractable wandInteractable2)
				{
					wandInteractable2.LookEnter(wandHand);
				}
				else
				{
					componentInParent.LookEnter();
				}
			}
			else
			{
				if (!(interactable != null))
				{
					return;
				}
				m_highlightedInteractables[wandHand] = null;
				if (interactable is IWandInteractable wandInteractable3)
				{
					wandInteractable3.LookExit(wandHand);
				}
				else
				{
					interactable.LookExit();
				}
				if (IsDualWielding)
				{
					Interactable interactable3 = m_highlightedInteractables[wandHand.Opposite()];
					if (interactable3 != null && !(interactable3 is IWandInteractable))
					{
						interactable3.LookEnter();
					}
				}
			}
		}

		public void EnableDrag()
		{
			if (IsDragEnabled)
			{
				return;
			}
			if (m_dragObject == null)
			{
				if (m_highlightedInteractables[m_defaultHand] == null)
				{
					Events.SpellInfoUpdatedEvent spellInfoUpdatedEvent = new Events.SpellInfoUpdatedEvent();
					spellInfoUpdatedEvent.SpellSlot = null;
					EventHub.Publish(spellInfoUpdatedEvent);
				}
			}
			else if (m_dragObject.IsDraggable)
			{
				IsDragEnabled = true;
				PlayerAim aim = GetAim();
				aim.TryToggleAimPivotTransform(active: false);
				m_dragObject.BeginDrag(aim.AimRay.origin + aim.AimRay.direction * 0.35f, m_cameraTransform.position);
			}
		}

		public void DisableDrag()
		{
			if (IsDragEnabled && m_dragObject != null && m_dragObject.IsDraggable)
			{
				GetAim().TryToggleAimPivotTransform(active: true);
				IsDragEnabled = false;
				m_dragObject.EndDrag();
				ClosestSlot = null;
				m_closestSnapObject = null;
				NullDragObject();
			}
		}

		private void HandleDrag()
		{
			PlayerAim aim = GetAim();
			if (m_dragObject.IsSnappable && aim.TryRaycastToSnapCollider(ref m_closestSnapObject))
			{
				bool? flag = ((m_closestSnapObject != null) ? new bool?(m_closestSnapObject.IsSnappable) : null);
				if (flag.HasValue && flag.Value)
				{
					ClosestSlot = m_closestSnapObject as WandSlot;
					m_dragObject.SnapToObject(m_closestSnapObject);
					return;
				}
			}
			if (ClosestSlot != null)
			{
				ClosestSlot = null;
			}
			float grabDistance = m_grabDistance;
			if (m_dragObject.ShouldRaycastToDragPlane)
			{
				aim.AdjustGrabDistance(ref grabDistance);
			}
			m_dragObject.Drag(aim.AimRay.origin + aim.AimRay.direction * grabDistance, m_cameraTransform.position);
		}

		public bool IsObjectHighlighted(WandHand wandHand)
		{
			Interactable interactable = null;
			m_highlightedInteractables[wandHand] = interactable;
			return interactable;
		}

		public void NullHighlightedInteractable()
		{
			NullHighlightedInteractable(m_defaultHand);
		}

		public void NullHighlightedInteractable(WandHand wandHand)
		{
			Interactable interactable = m_highlightedInteractables[wandHand];
			if (interactable != null)
			{
				interactable.LookExit();
				m_highlightedInteractables[wandHand] = null;
			}
		}

		private void NullDragObject()
		{
			m_dragObject = null;
		}

		private PlayerAim CreateAim(Transform controllerTransform, WandHand wandHand = WandHand.Right)
		{
			return new PlayerAim(m_aimData, m_playerControl, m_cameraTransform, this, controllerTransform.RetrieveChild("AimPivot", includeInactive: true), controllerTransform.RetrieveChild("Wand", includeInactive: true), wandHand);
		}

		public PlayerAim GetAim()
		{
			return m_defaultAim ?? (m_defaultAim = m_playerAims[0]);
		}

		public PlayerAim GetAim(WandHand wandHand)
		{
			return ((int)wandHand >= m_playerAims.Count) ? null : m_playerAims[(int)wandHand];
		}

		public void ResetAimReticle()
		{
			for (int i = 0; i < m_playerAims.Count; i++)
			{
				m_playerAims[i].DisableAim();
			}
		}

		public void DisableAim()
		{
			for (int i = 0; i < m_playerAims.Count; i++)
			{
				m_playerAims[i].DisableAim();
			}
		}

		private void ClearAim()
		{
			DisableAim();
			m_playerAims.Clear();
			m_defaultAim = null;
			m_cameraAim = null;
		}

		public void PlayHitResponse()
		{
			foreach (PlayerAim playerAim in m_playerAims)
			{
				playerAim.PlayHitResponse();
			}
		}

		public void TriggerHaptics(HapticsData hapticsData, bool overrideCurrent, WandHand wandHand = WandHand.Right)
		{
			if (m_hapticsPlatform != null)
			{
				m_hapticsPlatform.TriggerHaptics(hapticsData, overrideCurrent, wandHand);
			}
		}

		public void CancelHaptics(VibrateController controller, WandHand wandHand = WandHand.Right)
		{
			if (m_hapticsPlatform != null)
			{
				m_hapticsPlatform.CancelHaptics(controller, wandHand);
			}
		}
	}
}
namespace Assets.Scripts.Player
{
	public class PlayerInventory
	{
		private HashSet<string> m_items = new HashSet<string>();

		public bool TryAddItem(string itemId)
		{
			if (m_items.Contains(itemId))
			{
				return false;
			}
			m_items.Add(itemId);
			return true;
		}

		public bool ContainsItem(string itemId)
		{
			return m_items.Contains(itemId);
		}
	}
	public class PlayerLevelData
	{
		public int Level { get; set; }

		public int CurrentExperience { get; set; }

		public override string ToString()
		{
			return "Level: " + Level + " | CurrentExperience: " + CurrentExperience;
		}
	}
	public class PlayerLogInObject
	{
		public string UserName { get; private set; }

		public string UserId { get; private set; }

		public bool IsOnline { get; private set; }

		public PlayerLogInObject(string userName, string userId, bool isOnline)
		{
			UserName = userName;
			UserId = userId;
			IsOnline = isOnline;
		}
	}
	public class PlayerMatchData
	{
		public DateTime LastMatchDate { get; set; }

		public DateTime LastWinDate { get; set; }

		public int MatchesPlayed { get; set; }

		public int MatchesWon { get; set; }

		public Dictionary<string, int> MatchesWonPerArena { get; set; }

		public override string ToString()
		{
			string text = "MatchesWonPerArena:";
			foreach (KeyValuePair<string, int> item in MatchesWonPerArena)
			{
				string text2 = text;
				text = text2 + " | " + item.Key + ": " + item.Value;
			}
			return string.Concat("[PlayerMatchData] LastMatchDate: ", LastMatchDate, " | LastWinDate: ", LastWinDate, " | MatchesPlayed: ", MatchesPlayed, " | MatchesWon: ", MatchesWon, " | ", text);
		}
	}
	public class PlayerMatchStatsData
	{
		public int RemainingHealth { get; }

		public int ManaUsed { get; }

		public int DamageDealt { get; }

		public int PickupsUsed { get; }

		public PlayerMatchStatsData(int remainingHealth, int manaUsed, int damageDealt, int pickupsUsed)
		{
			RemainingHealth = remainingHealth;
			ManaUsed = manaUsed;
			DamageDealt = damageDealt;
			PickupsUsed = pickupsUsed;
		}
	}
}
namespace Cortopia.Scripts.Player
{
	public class PlayerMove
	{
		private Tile m_currentTile;

		private LayerMask m_teleportHitMask;

		public Tile StartTile { get; private set; }

		public PlayerMove(LayerMask teleportHitMask, Tile startTile)
		{
			m_teleportHitMask = teleportHitMask;
			StartTile = startTile;
		}

		public void ResetPosition(MatchType matchType, Transform playerTransform)
		{
			if (GetCurrentTile(playerTransform) != StartTile)
			{
				PunSingleton<TileManager>.Instance?.OccupyTile(GetCurrentTile(playerTransform), TileOccupyState.Unoccupied);
			}
		}

		public Tile GetCurrentTile(Transform playerTransform)
		{
			if (m_currentTile != null)
			{
				return m_currentTile;
			}
			if (Physics.Raycast(new Ray(playerTransform.position + new Vector3(0f, 0.2f, 0f), -playerTransform.up), out var hitInfo, 1f, Tile.TileMask))
			{
				m_currentTile = hitInfo.collider.GetComponent<Tile>();
			}
			else if (Physics.Raycast(new Ray(playerTransform.position, playerTransform.up), out hitInfo, 1f, m_teleportHitMask))
			{
				m_currentTile = hitInfo.collider.GetComponentInParent<Tile>();
			}
			return m_currentTile;
		}

		public void SetCurrentTile(Tile newTile)
		{
			m_currentTile = newTile;
		}
	}
}
namespace Assets.Scripts.Player
{
	public class PlayerSaveData
	{
		public List<IDataParser> AsynchronousParsers { get; private set; }

		public List<IDataParser> SynchronousParsers { get; private set; }

		public PlayerLevelData LevelData { get; set; }

		public int VirtualCurrency { get; set; }

		public Loadout[] Loadouts { get; set; }

		public PlayerMatchData MatchData { get; set; }

		public bool IsDeveloper { get; set; }

		public GameAccess GameAccess { get; set; }

		public bool CompletedTutorial { get; set; }

		public PlayerAchievementCollectionData AchievementData { get; set; }

		public string LevelDataSerialized => LevelData.ToJson();

		public string VirtualCurrencySerialized => VirtualCurrency.ToString();

		public string LoadoutsSerialized => Loadouts.ToJson();

		public string MatchDataSerialized => MatchData.ToJson();

		public string GameAccessSerialized => GameAccess.ToString();

		public string CompletedTutorialSerialized => CompletedTutorial.ToString();

		public string AchievementDataSerialized => AchievementData.ToJson();

		public PlayerSaveData()
		{
			LevelData = new PlayerLevelData
			{
				Level = 1
			};
			Loadouts = new Loadout[3]
			{
				new Loadout(isLocked: false),
				new Loadout(isLocked: true),
				new Loadout(isLocked: true)
			};
			MatchData = new PlayerMatchData();
			GameAccess = GameAccess.Free;
			AchievementData = new PlayerAchievementCollectionData();
			AsynchronousParsers = new List<IDataParser>
			{
				new ClientVersionParser(),
				new VirtualCurrencyParser(),
				new LevelDataParser(),
				new LoadoutsParser(),
				new LootCachesParser(),
				new MatchDataParser(),
				new UnlockedDataParser(),
				new GameAccessParser(),
				new AchievementDataParser()
			};
			SynchronousParsers = new List<IDataParser>
			{
				new CompletedTutorialParser()
			};
		}

		public static SaveDataObject CreateSaveDataObject()
		{
			SaveDataObject saveDataObject = new SaveDataObject();
			saveDataObject.AddField(PlayFabSaveField.ClientVersion, GameControl.Instance.PlayfabClientVersion);
			return saveDataObject;
		}
	}
}
namespace Cortopia.Scripts.Player
{
	[Serializable]
	public struct ActivatableValue
	{
		public float Value;

		public WandHand WandHand;

		public bool IsActive;

		public ActivatableValue(float value)
		{
			Value = value;
			WandHand = WandHand.Right;
			IsActive = true;
		}

		public ActivatableValue(float value, WandHand wandHand)
		{
			Value = value;
			WandHand = wandHand;
			IsActive = true;
		}
	}
	[Serializable]
	public struct KOMultiplier
	{
		public float WinMultiplier;

		public float LoseMultiplier;
	}
	[Serializable]
	public struct RewardModifiers
	{
		public float Experience;

		public float Currency;

		public float Score;

		public KOMultiplier KOMultiplier;

		public RewardModifiers(float exp, float currency, float score)
		{
			Experience = exp;
			Currency = currency;
			Score = score;
			KOMultiplier = new KOMultiplier
			{
				WinMultiplier = 1f,
				LoseMultiplier = 1f
			};
		}
	}
	[Serializable]
	public struct PlayerStats
	{
		public float MaxMana;

		public float ManaRegen;

		public ActivatableValue ManaRestoreOnDamageTakenMultiplier;

		public float MaxHealth;

		public float DamageTakenMultiplier;

		public float HealMultiplier;

		public ActivatableValue StartingArmor;

		public bool IsAlwaysCursed;

		public ActivatableValue AutoCastLeapOnHitChance;

		public ActivatableValue AddHealToTileAfterSeconds;

		public ActivatableValue ManaRestoringPickups;

		public PlayerStats(float defaultManaRegen)
		{
			MaxMana = 100f;
			ManaRegen = defaultManaRegen;
			ManaRestoreOnDamageTakenMultiplier = default(ActivatableValue);
			MaxHealth = 100f;
			DamageTakenMultiplier = 1f;
			HealMultiplier = 1f;
			StartingArmor = default(ActivatableValue);
			IsAlwaysCursed = false;
			AutoCastLeapOnHitChance = default(ActivatableValue);
			AddHealToTileAfterSeconds = default(ActivatableValue);
			ManaRestoringPickups = default(ActivatableValue);
		}
	}
	[Serializable]
	public struct ActiveWandEffects
	{
		public ActivatableValue AcidTeleport;

		public Spell_AcidCloud Acid;

		public bool UseAlternateSpellVisuals;
	}
	public class PlayerTeleportHandler : TeleportHandler
	{
		private const float TeleportFadeTime = 0.1f;

		private const float TeleportFadeTransparency = 0.25f;

		public override void ResetTransform(Tile resetTile)
		{
			base.ResetTransform(resetTile);
			m_characterControl.ResetCharacterTransform();
		}

		protected override IEnumerator Teleport()
		{
			if (m_onTeleportStart != null)
			{
				m_onTeleportStart();
			}
			base.IsTeleporting = true;
			if (MonoSingleton<NetworkManager>.Instance.CurrentMatchType.ContainsFlag(MatchType.Bot))
			{
				m_characterControl.ChangeColliderLayer(2);
			}
			else
			{
				m_characterControl.SetColliderActive(active: false);
			}
			ExpandedSingleton<FadeHandler>.Instance.BlockScreenFlash = true;
			ExpandedSingleton<FadeHandler>.Instance.FadeOut(0.1f, 0.25f, Color.white);
			while (ExpandedSingleton<FadeHandler>.Instance.IsFading)
			{
				yield return new WaitForEndOfFrame();
			}
			m_teleportStartTime = Time.time;
			m_isTeleporting = true;
			while (base.IsTeleporting)
			{
				yield return new WaitForEndOfFrame();
			}
			if (m_onTeleportEnd != null)
			{
				m_onTeleportEnd();
			}
			ExpandedSingleton<FadeHandler>.Instance.BlockScreenFlash = false;
			if (PunSingleton<SceneControl>.Instance.GameOver)
			{
				MonoSingleton<ArenaUI>.Instance?.UpdateEndMenuPosition();
				yield break;
			}
			ExpandedSingleton<FadeHandler>.Instance.FadeIn(0.1f, 0f, resetAlpha: false);
			if (MonoSingleton<ArenaUI>.Instance != null && MonoSingleton<ArenaUI>.Instance.Menu.IsMenuActive)
			{
				MonoSingleton<ArenaUI>.Instance.UpdateMenuPosition();
			}
		}
	}
	public class PlayerTileAreaHandler
	{
		private readonly PlayerControl m_playerControl;

		private readonly Transform m_colliderTransform;

		private Vector3 m_playerPosition;

		public bool IsInsideTileArea { get; private set; } = true;


		public PlayerTileAreaHandler(PlayerControl playerControl, Transform colliderTransform)
		{
			m_playerControl = playerControl;
			m_colliderTransform = colliderTransform;
		}

		public void CheckInsideTileArea()
		{
			if (m_colliderTransform == null)
			{
				return;
			}
			m_playerPosition = m_playerControl.GetPlayerPosition();
			if (TileAreaController.IsInsideTileArea(m_playerPosition, m_playerControl.GetCurrentTile()))
			{
				m_colliderTransform.position = m_playerPosition;
				if (!IsInsideTileArea)
				{
					IsInsideTileArea = true;
					OnTileAreaEnter();
				}
			}
			else
			{
				m_colliderTransform.position = TileAreaController.GetPositionInsideTileArea(m_playerPosition, m_playerControl.GetCurrentTile().transform.position);
				if (IsInsideTileArea)
				{
					IsInsideTileArea = false;
					OnTileAreaExit();
				}
			}
		}

		public void MarkAsInsideTileArea()
		{
			IsInsideTileArea = true;
			OnTileAreaEnter();
		}

		private void OnTileAreaEnter()
		{
			m_playerControl.SetSpellInputActive();
			EventHub.Publish(new Events.TileAreaEnterEvent());
		}

		private void OnTileAreaExit()
		{
			m_playerControl.SetSpellInputActive(active: false);
			EventHub.Publish(new Events.TileAreaExitEvent());
		}
	}
	public class PlayerWand
	{
		[StructLayout(LayoutKind.Sequential, Size = 1)]
		private struct WandPath
		{
			public const string DualWield = "WandControl";

			public const string OneHanded = "WandControlOneHand";

			public const string Bot = "BotWandControl";
		}

		private const float WandMeshScaleMultiplier = 0.6f;

		private Aim m_aim;

		private WandHandler m_wandHandler;

		private Tile m_highlightedTile;

		private string m_teleportLayerName;

		private bool m_isWieldedByBot;

		public IWandControl WandControl { get; private set; }

		public Transform WandParent { get; private set; }

		public Tile HighlightedTile
		{
			get
			{
				return (!(m_highlightedTile != null)) ? null : m_highlightedTile;
			}
			set
			{
				m_highlightedTile = value;
			}
		}

		public PlayerWand(Aim aim, bool isWieldedByBot)
		{
			m_aim = aim;
			m_isWieldedByBot = isWieldedByBot;
			m_teleportLayerName = ((!isWieldedByBot) ? "Teleport" : "Ignore Collision");
		}

		public void SetWandParent(Transform wandParent)
		{
			WandParent = wandParent;
		}

		public void SpawnWandController(int wielderPhotonViewID, Transform parent, WandInput wandInput, bool isDualWielding, WandHand wandHand)
		{
			if (WandControl != null)
			{
				WandControl.SetChargeEffectsParent(WandParent);
				return;
			}
			PunSingleton<NetworkCache>.Instance.CacheLoadout(GameControl.Instance.Player.ActiveLoadout.Spells);
			string assetPath = ((!isDualWielding) ? "WandControlOneHand" : "WandControl");
			object[] data = new object[2]
			{
				wielderPhotonViewID,
				(int)wandHand
			};
			WandControl = NetworkUtils.Instantiate(assetPath, parent.position, parent.rotation, 0, data).GetComponent<IWandControl>();
			WandControl.SetAim(m_aim);
			WandControl.ResetPosition();
			WandControl.CacheWandProperties(GameControl.Instance.Player.GetWand(wandHand));
			WandControl.InstantiateSpells(wandInput, wandHand);
			WandControl.ResetActiveSpell();
		}

		public void SpawnWandControllerOffline(Transform parent, WandInput wandInput)
		{
			if (WandControl != null)
			{
				WandControl.SetChargeEffectsParent(WandParent);
				return;
			}
			WandControl = (UnityEngine.Object.Instantiate(Resources.Load("WandControlOneHand"), parent) as GameObject).GetComponent<IWandControl>();
			WandControl.photonView.AllocateViewID();
			WandControl.SetAim(m_aim);
			WandControl.ResetPosition();
		}

		public void SpawnBotWandController(int wielderPhotonViewID, Transform parent, WandInput wandInput)
		{
			if (WandControl != null)
			{
				WandControl.SetChargeEffectsParent(WandParent);
				return;
			}
			if (wielderPhotonViewID == 0)
			{
				WandControl = (UnityEngine.Object.Instantiate(Resources.Load("BotWandControl"), parent) as GameObject).GetComponent<IWandControl>();
				WandControl.photonView.AllocateViewID();
			}
			else
			{
				object[] data = new object[1] { wielderPhotonViewID };
				WandControl = NetworkUtils.Instantiate("BotWandControl", parent.position, parent.rotation, 0, data).GetComponent<IWandControl>();
			}
			WandControl.SetAim(m_aim);
			WandControl.ResetPosition();
			WandControl.InstantiateSpells(wandInput);
		}

		public void DestroyWandController()
		{
			WandControl?.DestroyWand();
			if (m_wandHandler != null)
			{
				UnityEngine.Object.Destroy(m_wandHandler.gameObject);
			}
		}

		public void TrySpawnWandMesh(AimInput aimInput)
		{
			if (m_wandHandler == null && aimInput != AimInput.Head)
			{
				SpawnWandMesh();
			}
		}

		private void SpawnWandMesh()
		{
			if (GameControl.Instance.IsCurrentLevel(Level.Lobby))
			{
				return;
			}
			string path = $"Wands/{GameControl.Instance.Player.GetWand(WandControl.WandHand)}";
			m_wandHandler = UnityEngine.Object.Instantiate(Resources.Load<WandHandler>(path), WandParent, worldPositionStays: true);
			m_wandHandler.transform.SetLocalPositionRotationAndScale(Vector3.zero, Quaternion.identity, Vector3.one * 0.6f);
			if (WandControl == null)
			{
				WandsLogger.LogError("WandControl not spawned when trying to spawn wand mesh");
				return;
			}
			m_aim.AimPivot.localPosition = m_wandHandler.AimAdjustedLocalPosition;
			WandControl.SetChargeEffectsParent(WandParent);
			if (m_wandHandler != null)
			{
				WandControl.SetWandHandler(m_wandHandler);
			}
			else
			{
				WandsLogger.LogError("No WandHandler attached to wand mesh");
			}
		}

		public void TrackTileHit()
		{
			if (m_aim.RaycastTeleportTile(out var hit))
			{
				if (HighlightedTile != null)
				{
					Transform transform = ((!m_isWieldedByBot) ? HighlightedTile.TeleportCollider.transform : HighlightedTile.BotTeleportCollider.transform);
					if (transform != hit.collider.transform)
					{
						ResetHighlightedTile();
					}
					else if (!m_isWieldedByBot && !HighlightedTile.IsHighlighted)
					{
						SetTileHighlighted(HighlightedTile);
					}
					else if (m_isWieldedByBot)
					{
						SetTileHighlighted(HighlightedTile);
					}
				}
				else
				{
					if (!hit.collider.gameObject.layer.Equals(LayerMask.NameToLayer(m_teleportLayerName)))
					{
						return;
					}
					Tile componentInParent = hit.collider.GetComponentInParent<Tile>();
					if (componentInParent != null)
					{
						if (!m_isWieldedByBot && !componentInParent.IsHighlighted)
						{
							SetTileHighlighted(componentInParent);
						}
						else if (m_isWieldedByBot)
						{
							SetTileHighlighted(componentInParent);
						}
					}
				}
			}
			else
			{
				ResetHighlightedTile();
			}
		}

		public void ResetHighlightedTile()
		{
			if (!(HighlightedTile == null))
			{
				if (WandControl.Wielder.IsBot)
				{
					HighlightedTile = null;
					return;
				}
				(WandControl.ActiveSpell as ITileSpell)?.SetHighlightTile(null);
				PunSingleton<SceneControl>.Instance?.TeleportSfx.FadeSound(null);
				HighlightedTile.SetHighlighted(enable: false);
				HighlightedTile = null;
			}
		}

		private void SetTileHighlighted(Tile newTile)
		{
			HighlightedTile = newTile;
			(WandControl.ActiveSpell as ITileSpell)?.SetHighlightTile(HighlightedTile);
			if (WandControl.Wielder.IsPlayer)
			{
				HighlightedTile.SetHighlighted(enable: true);
				PunSingleton<SceneControl>.Instance?.TeleportSfx.FadeSound(HighlightedTile.transform);
			}
		}
	}
	public class BotControl : CharacterControl, ISight, IHearing
	{
		public const Title BotTitle = Title.Vindicator;

		public const string BotName = "Machina";

		public const AimInput DefaultBotAimInput = AimInput.Head;

		private BotCharacter m_character;

		private BotAI m_botAI;

		private bool m_isInLobby;

		private bool m_wasEnabled;

		private EventToken m_connectedToMatchRoomEventToken;

		private EventToken m_photonConnectionFailedToken;

		public CharacterType CharacterType
		{
			[CompilerGenerated]
			get
			{
				return m_character.CharacterType;
			}
		}

		public WandType WandType
		{
			[CompilerGenerated]
			get
			{
				return m_character.WandType;
			}
		}

		public AimInput AimInput
		{
			[CompilerGenerated]
			get
			{
				return m_character.AimInput;
			}
		}

		public Aim Aim { get; private set; }

		public IWandControl WandControl
		{
			[CompilerGenerated]
			get
			{
				return base.Wand.GetWandControl();
			}
		}

		public Tile HighlightedTile
		{
			[CompilerGenerated]
			get
			{
				return base.Wand.GetHighlightedTile();
			}
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			m_photonConnectionFailedToken = EventHub.Subscribe<NetworkEvents.PhotonConnectionFailedEvent>(OnPhotonConnectionFailed);
		}

		protected override void OnDisable()
		{
			base.OnDisable();
			if (m_connectedToMatchRoomEventToken != null)
			{
				EventHub.Unsubscribe<Events.ConnectedToMatchRoom>(m_connectedToMatchRoomEventToken);
				m_connectedToMatchRoomEventToken = null;
			}
			UnsubscribeFromArenaEvents();
			EventHub.Unsubscribe<NetworkEvents.PhotonConnectionFailedEvent>(m_photonConnectionFailedToken);
		}

		private void OnPhotonConnectionFailed(NetworkEvents.PhotonConnectionFailedEvent obj)
		{
			UnsubscribeFromArenaEvents();
			DestroySelf();
		}

		private void Update()
		{
			if (!base.IsPaused)
			{
				RegenerateMana();
				if (base.Wielder != null)
				{
					base.Wielder.UpdateBotPosition();
				}
			}
		}

		protected override void OnSceneLoadInitiated(Events.SceneLoadInitiatedEvent eventData)
		{
			base.OnSceneLoadInitiated(eventData);
			if (!eventData.LevelToLoad.ContainsFlag(Level.Arena | Level.Lobby) && PlayerManager.Instance != null)
			{
				PlayerManager.Instance.RemoveBotControl();
			}
			if (m_character != null)
			{
				UnityEngine.Object.Destroy(m_character.gameObject);
			}
			if (eventData.LevelToLoad.ContainsFlag(Level.Arena))
			{
				SubscribeToArenaEvents();
			}
			else
			{
				UnsubscribeFromArenaEvents();
			}
		}

		protected override void OnFinalCountdownStarted(Events.FinalCountdownStartedEvent eventData)
		{
		}

		protected override void OnCountdownStarted(Events.CountdownStartedEvent eventData)
		{
		}

		protected override void OnWielderSpawned(Wielder wielder, Level level)
		{
			base.OnWielderSpawned(wielder, level);
			CreateMovement(PunSingleton<TileManager>.Instance.GetStartTile(1));
			wielder.ConnectPlayerController(this);
			UpdateObjectLayer(wielder.GetLayerMask());
			wielder.SpawnLocalBotCharacter(base.transform);
			m_character = wielder.BotCharacter;
			m_character.Initialize(wielder, m_healthData);
			InstantiatePlayerWand();
			if (!m_isInLobby)
			{
				m_botAI = GetComponent<BotAI>();
				m_botAI.Initialize(this, m_character, GetSight(), GetHearing());
				SpawnWandController(level);
				m_botAI.enabled = true;
				m_botAI.Enabled = true;
				WandControl.SetStatsData(m_healthData, m_manaData);
				Aim.SetPivotTransforms(base.transform.RetrieveChild("AimPivot"), null);
				base.HurtSfxHandler.Initialize(m_healthData, wielder.AnimationRelay, belongsToPlayer: false, CharacterType);
			}
		}

		protected override AimInput GetAimInputType()
		{
			return AimInput.Head;
		}

		public override void SpawnWandController(Level level)
		{
			int wielderViewID = ((level != Level.Lobby) ? base.Wielder.ViewID : 0);
			base.Wand.SpawnBotWandController(wielderViewID, base.transform, GetAimInputType());
		}

		public Spell[] GetRandomizedSpells()
		{
			m_botAI.RandomizeSpells();
			return m_botAI.AvailableSpells;
		}

		protected override void OnSceneLoaded(Events.SceneLoadedEvent eventData)
		{
			base.OnSceneLoaded(eventData);
			if ((eventData.Level & Level.Arena) != 0)
			{
				m_isInLobby = false;
				SetColliderActive(active: true);
				m_effectHandler.PreloadEffects();
			}
		}

		protected override void OnLevelInitialized(Events.LevelInitializedEvent eventData)
		{
			if (eventData.Level == Level.Lobby)
			{
				SpawnInLobby();
			}
		}

		private void OnConnectedToMatchRoom(Events.ConnectedToMatchRoom eventData)
		{
			SpawnAndConnect();
		}

		protected override void OnMatchReset(Events.MatchResetEvent eventData)
		{
			if (base.Wielder == null)
			{
				SpawnAndConnect();
			}
			base.OnMatchReset(eventData);
			SetTeleportActive(enable: true);
			if (m_botAI != null)
			{
				m_botAI.Enabled = false;
			}
		}

		protected override void OnCountdownEnded(Events.CountdownEndedEvent eventData)
		{
			if (m_botAI != null)
			{
				m_botAI.Enabled = true;
				m_botAI.ResetBot();
			}
		}

		protected override void OnMatchEnded(Events.MatchEndedEvent eventData)
		{
			base.OnMatchEnded(eventData);
			if (m_botAI != null)
			{
				m_botAI.Enabled = false;
			}
		}

		protected override void OnWandControllerDespawned(InputEvents.WandControllerDespawnedEvent eventData)
		{
			if (m_botAI != null)
			{
				m_botAI.Enabled = false;
			}
		}

		private void SpawnAndConnect()
		{
			SpawnAndConnectWielder(Level.Arena);
			PlayerManager.Instance.BotSpawned(this);
		}

		public void SpawnInLobby()
		{
			m_isInLobby = true;
			SpawnAndConnect();
			base.transform.SetParent(PunSingleton<LobbyManager>.Instance.RemoteCharacterSpawnParent);
			base.transform.localPosition = Vector3.zero;
			base.transform.localRotation = Quaternion.identity;
		}

		protected override void SpawnAndConnectWielder(Level level)
		{
			PlayerManager.Instance.SpawnBotWielder(delegate(Wielder wielder)
			{
				OnWielderSpawned(wielder, level);
			});
		}

		public override void InstantiatePlayerWand()
		{
			Aim = new Aim(m_aimData);
			base.Wand = new WandManager(this, m_healthData, m_manaData, m_character.GetWandParentTransform(m_character.WandHand), Aim);
		}

		public override void SetChillingClutchEffectActive(bool active)
		{
			m_effectHandler.SetEffectActive(EffectType.ChillingClutchLingeringEffect, active, base.Collider.transform);
		}

		public override void TryTrackTileHit(WandHand wandHand = WandHand.Right)
		{
			if (base.TeleportHandler.IsTeleporting)
			{
				base.Wand.ResetHighlightedTile();
			}
			else
			{
				base.Wand.TrackTileHit();
			}
		}

		public Sight GetSight()
		{
			return (!(m_character != null)) ? null : m_character.GetComponentInChildren<Sight>();
		}

		public bool TryGetSight(out Sight sight)
		{
			sight = ((!(m_character != null)) ? null : m_character.GetComponentInChildren<Sight>());
			return sight != null;
		}

		public Hearing GetHearing()
		{
			return m_character.GetComponentInChildren<Hearing>();
		}

		public Vector3 GetOpponentPosition()
		{
			return PlayerManager.Instance.PlayerControl.Collider.transform.position + PlayerManager.Instance.PlayerControl.Collider.center;
		}

		public override bool TakeDamage(DamageType damageType, float damage, Vector2 hitDirection)
		{
			if (TryHealPlayer(damage))
			{
				return true;
			}
			if (IsImmuneToDamageType(damageType))
			{
				return false;
			}
			damage *= m_damageTakenMultiplier;
			damage = GetDamageAfterArmorReduction(damageType, damage);
			base.DamageReceivedTotal += damage;
			UpdateHealth(0f - damage);
			if (base.Health >= 1f)
			{
				bool oneShot = damageType != DamageType.Continuous;
				base.HurtSfxHandler.PlayHitReaction(oneShot, hitDirection);
				PlayerManager.Instance.PlayerControl.Input.PlayHitResponse();
				Events.DamageTakenEvent damageTakenEvent = new Events.DamageTakenEvent();
				damageTakenEvent.CharacterControl = this;
				damageTakenEvent.Damage = damage;
				EventHub.Publish(damageTakenEvent);
				return true;
			}
			base.Health = 0f;
			if (m_checkFirstBlood)
			{
				base.Wielder.SetFirstBlood();
				m_checkFirstBlood = false;
			}
			Die(hitDirection);
			BotDifficultyUtils.TryUnlockReward();
			return true;
		}

		public override void Pause(bool pause)
		{
			base.Pause(pause);
			if (!(m_botAI == null))
			{
				if (pause)
				{
					m_wasEnabled = m_botAI.Enabled;
					m_botAI.Enabled = false;
				}
				else
				{
					m_botAI.Enabled = m_wasEnabled;
				}
			}
		}

		public void PauseFromNetworkDisconnection()
		{
			Pause(pause: true);
			m_wasEnabled = m_botAI.Enabled;
			m_botAI.Enabled = false;
		}

		public void DestroySelf()
		{
			base.Wand?.DestroyPlayerWands();
			UnityEngine.Object.Destroy(base.gameObject);
			UnityEngine.Object.Destroy(m_botAI);
		}

		public override void SetFreeTeleportActive(bool enable)
		{
		}

		public override void EnableCurse(float curseTime, CurseLingeringEffect curse)
		{
			TryDisableActiveCurse();
			m_curseEffect = curse;
		}

		public override void DisableCurse()
		{
			TryDisableActiveCurse();
			m_curseEffect = null;
		}

		public override void CreateHP()
		{
			m_healthData = StatsData.CreateInstance(BotDifficultyUtils.GetMaxHealth());
		}

		public override void CreateMana()
		{
			Tuple<float, float> manaStats = BotDifficultyUtils.GetManaStats();
			m_manaData = RegeneratingStatsData.CreateInstance(manaStats.Item1, manaStats.Item2);
		}
	}
}
namespace Assets.Scripts.Player
{
	[RequireComponent(typeof(CharacterRenderer))]
	public class RemoteCharacter : CharacterBase
	{
		[SerializeField]
		private CharacterHitSfxHandler m_sfxHandler;

		private Wielder m_wielder;

		public EffectUtils EffectHandler { get; private set; }

		public IWandControl Wand { get; set; }

		private void Update()
		{
			if (base.Collider != null)
			{
				base.Collider.transform.position = base.Movement.ColliderTargetPosition;
			}
		}

		public void Initialize(Wielder wielder, StatsData healthData)
		{
			if (wielder == null)
			{
				WandsLogger.LogError($"Trying to assign null wielder to {base.name}");
				return;
			}
			m_wielder = wielder;
			CharacterType characterType = (CharacterType)(int)PlayerProperty.Get("C0", m_wielder.Owner);
			base.CharacterRenderer = GetComponent<CharacterRenderer>();
			base.CharacterRenderer.Initialize(characterType);
			base.Collider = base.CharacterRenderer.Body.GetComponentInChildren<CapsuleCollider>();
			ResetRemoteCharacter();
			if (GameControl.Instance.IsCurrentLevel(Level.Arena))
			{
				TrySpawnWands(m_wielder.Owner);
			}
			if (m_sfxHandler != null)
			{
				m_sfxHandler.SetCorrectSoundEffects(characterType);
			}
			if (GameControl.Instance.IsCurrentLevel(Level.Arena) && healthData != null)
			{
				ParentStatsToBody();
				m_statsUI.Initialize(healthData, PlayerManager.Instance.PlayerControl.CameraTransform);
				EffectHandler = new EffectUtils();
				EffectHandler.PreloadEffects();
			}
			else
			{
				m_statsUI.gameObject.SetActive(value: false);
			}
		}

		public void ResetRemoteCharacter()
		{
			m_aimInput = (AimInput)(int)PlayerProperty.Get("P4", m_wielder.Owner);
			m_wandHand = m_aimInput.ToWandHand();
			SetCorrectApperence(m_wielder.Owner);
			SetRootPosition(checkIfLobby: true);
			UpdateObjectLayer();
			base.Movement.MovementStartRemoteCharacter(m_wielder, m_aimInput, base.CharacterRenderer);
		}

		private void UpdateObjectLayer()
		{
			LayerMask layerMask = m_wielder.GetLayerMask();
			base.CharacterRenderer.Renderer.gameObject.layer = layerMask;
			UpdateWandObjectLayer(layerMask, base.transform.RetrieveChild(string.Format("wand_{0}", (WandType)(int)PlayerProperty.Get("C2", m_wielder.Owner)).ToLower(), includeInactive: true));
			bool? flag = m_wielder.PlayerControl?.IsDualWielding;
			if (flag.HasValue && flag.Value)
			{
				UpdateWandObjectLayer(layerMask, base.transform.RetrieveChild(string.Format("wand_{0}", (WandType)(int)PlayerProperty.Get("C4", m_wielder.Owner)).ToLower(), includeInactive: true));
			}
		}

		private void UpdateWandObjectLayer(LayerMask layer, Transform wandTransform)
		{
			if (!(wandTransform == null))
			{
				wandTransform.gameObject.SetActive(value: true);
				wandTransform.gameObject.layer = layer;
			}
		}

		private void ResetAnimationAndPosition()
		{
			SetDead(dead: false);
			base.CharacterRenderer.Body.localPosition = Vector3.zero;
		}

		public void SetDead(bool dead)
		{
			base.Movement.SetDead(dead);
		}

		public void OnLocalHit()
		{
			if (!base.Movement.IsDead)
			{
				base.CharacterRenderer.PlayHitResponse(m_wielder.IsArmorActive);
				if (m_sfxHandler != null)
				{
					m_sfxHandler.PlaySound();
				}
			}
		}

		protected override void OnMatchReset(Events.MatchResetEvent eventData)
		{
			ResetAnimationAndPosition();
		}

		public override void SetCorrectApperence(Photon.Realtime.Player photonPlayer)
		{
			base.CharacterRenderer.FetchMaterialReferences();
			if (m_wielder.IsArmorActive)
			{
				base.CharacterRenderer.SetMaterial(CharacterMaterialType.Rim, Colors.ArmorActiveRim);
			}
			else
			{
				base.CharacterRenderer.SetMaterial(CharacterMaterialType.Default);
			}
		}
	}
	public class InventorySaveObject
	{
		public string CatalogVersion;

		public string[] Items;
	}
	public class SaveDataObject
	{
		private Dictionary<string, string> data;

		public SaveDataObject()
		{
			data = new Dictionary<string, string>(16);
		}

		public void AddField(PlayFabSaveField field, string value)
		{
			if (data.ContainsKey(field.ToString()))
			{
				throw new ArgumentException($"Key already exists: {field}");
			}
			data.Add(field.ToString(), value);
		}

		public Dictionary<string, string> GetCollection()
		{
			return new Dictionary<string, string>(data);
		}
	}
}
namespace Cortopia.Scripts.Player
{
	public struct MatchStatsSummary
	{
		public float DamageRecievedTotal;

		public float ManaUsedTotal;

		public float EndHealth;

		public MatchStatsSummary(float damageRecievedTotal, float manaUsedTotal, float endHealth)
		{
			DamageRecievedTotal = damageRecievedTotal;
			ManaUsedTotal = manaUsedTotal;
			EndHealth = endHealth;
		}
	}
	public class TeleportHandler : MonoBehaviour
	{
		public delegate void TeleportCallbacks();

		private float m_teleportDistance;

		private float m_teleportAcceleration;

		protected float m_teleportStartTime;

		private Vector3 m_teleportStartPosition = Vector3.zero;

		private Vector3 m_teleportEndPosition = Vector3.zero;

		private Tile m_newTile;

		protected CharacterControl m_characterControl;

		protected bool m_isTeleporting;

		protected TeleportCallbacks m_onTeleportStart;

		protected TeleportCallbacks m_onTeleportEnd;

		protected Transform TeleportTransform { get; set; }

		public bool IsTeleporting { get; protected set; }

		private void Update()
		{
			if (m_isTeleporting)
			{
				TeleportTransport();
			}
		}

		public virtual void SetCharacter(CharacterControl characterControl)
		{
			m_characterControl = characterControl;
			TeleportTransform = characterControl.transform;
		}

		public virtual void ResetTransform(Tile resetTile)
		{
			if (!(resetTile == null))
			{
				if (m_isTeleporting)
				{
					TeleportTransform.position = m_teleportEndPosition;
				}
				m_isTeleporting = false;
				IsTeleporting = false;
				TeleportTransform.position = resetTile.transform.position;
			}
		}

		public virtual void TeleportOwner(Tile newTile, TeleportCallbacks startCallback, TeleportCallbacks endCallback)
		{
			if (!(PunSingleton<SceneControl>.Instance != null) || !PunSingleton<SceneControl>.Instance.GameOver)
			{
				m_onTeleportStart = startCallback;
				m_onTeleportEnd = endCallback;
				SetTeleportVariables(newTile);
				StopCoroutine("Teleport");
				StartCoroutine("Teleport");
				m_characterControl.Wand.OnTeleportInitiated();
				m_characterControl.SetCurrentTile(newTile);
			}
		}

		public void TeleportRandomly(Tile[] tiles, PhotonView occupantPhotonView)
		{
			Tile randomTile = tiles.GetRandomElement();
			TeleportOwner(randomTile, delegate
			{
				PunSingleton<TileManager>.Instance.OccupyTile(randomTile, TileOccupyState.Occupied, occupantPhotonView);
			}, null);
		}

		public void PlayTeleportEffect(Tile newTile, TeleportCallbacks startCallback, TeleportCallbacks endCallback)
		{
			m_onTeleportStart = startCallback;
			m_onTeleportEnd = endCallback;
			SetTeleportVariables(newTile);
			StopCoroutine("Teleport");
			StartCoroutine("Teleport");
		}

		protected void SetTeleportVariables(Tile newTile)
		{
			if (!(newTile == null))
			{
				m_newTile = newTile;
				m_teleportStartPosition = TeleportTransform.position;
				m_teleportEndPosition = newTile.transform.position;
				m_teleportDistance = Vector3.Distance(m_teleportStartPosition, m_teleportEndPosition);
				m_teleportAcceleration = Mathf.Clamp(m_teleportDistance / 3f / 2f, 1f, m_teleportDistance);
			}
		}

		protected virtual IEnumerator Teleport()
		{
			if (m_onTeleportStart != null)
			{
				m_onTeleportStart();
			}
			IsTeleporting = true;
			if (MonoSingleton<NetworkManager>.Instance.CurrentMatchType.ContainsFlag(MatchType.Bot))
			{
				m_characterControl.ChangeColliderLayer(2);
			}
			else
			{
				m_characterControl.SetColliderActive(active: false);
			}
			m_teleportStartTime = Time.time;
			m_isTeleporting = true;
			while (IsTeleporting)
			{
				yield return new WaitForEndOfFrame();
			}
			if (m_onTeleportEnd != null)
			{
				m_onTeleportEnd();
			}
		}

		private void TeleportTransport()
		{
			if (m_isTeleporting)
			{
				if (m_newTile.IsElevatorTile)
				{
					m_teleportEndPosition = m_newTile.transform.position;
				}
				float num = (Time.time - m_teleportStartTime) * (45f * m_teleportAcceleration);
				float t = num / m_teleportDistance;
				TeleportTransform.position = Vector3.Lerp(m_teleportStartPosition, m_teleportEndPosition, t);
				if (TeleportTransform.position == m_teleportEndPosition)
				{
					ResetTeleport();
				}
			}
		}

		protected void ResetTeleport()
		{
			if (!m_isTeleporting)
			{
				return;
			}
			if (m_newTile != null)
			{
				if (m_newTile.IsElevatorTile)
				{
					TeleportTransform.SetParent(m_newTile.transform);
					TeleportTransform.localPosition = Vector3.zero;
				}
				else
				{
					TeleportTransform.position = m_newTile.transform.position;
				}
			}
			m_isTeleporting = false;
			IsTeleporting = false;
			m_teleportDistance = 0f;
			if (MonoSingleton<NetworkManager>.Instance.CurrentMatchType.ContainsFlag(MatchType.Bot))
			{
				m_characterControl.ChangeColliderLayer(LayerMask.NameToLayer((m_characterControl.Wielder.GetIndex() != 1) ? "Player2" : "Player1"));
			}
			else
			{
				m_characterControl.SetColliderActive(active: true);
			}
		}
	}
}
namespace Assets.Scripts.Player
{
	public class TrainingDummy : MonoBehaviourPun
	{
		private const float WaitTimeOnDestroyed = 5f;

		private const float AnimationHitDelay = 0.2f;

		private const float LargeHitThreshold = 30f;

		private const string AnimationHitLarge = "Hit_Large";

		private const string AnimationHitSmall = "Hit_Small";

		private const string AnimationDead = "Dead";

		private const string SfxFall = "dummy_fall";

		private const string SfxRise = "dummy_rise";

		private const string SfxHit = "dummy_hit0";

		[SerializeField]
		private TrainingDummyUI m_ui;

		[SerializeField]
		private int m_prio;

		[SerializeField]
		private float m_maxHP = 100f;

		[SerializeField]
		private CapsuleCollider m_collider;

		[SerializeField]
		private SoundHandler m_soundHandler;

		private bool m_active = true;

		private bool m_animate = true;

		private Move m_mover;

		private Animator m_animator;

		public float CurrentHP { get; private set; }

		public int Prio
		{
			[CompilerGenerated]
			get
			{
				return m_prio;
			}
		}

		public CapsuleCollider Collider
		{
			[CompilerGenerated]
			get
			{
				return m_collider;
			}
		}

		private void OnDisable()
		{
			CancelInvoke();
		}

		private void Start()
		{
			m_mover = GetComponent<Move>();
			m_animator = GetComponentInChildren<Animator>();
			ResetDummy(playSound: false);
			TrainingDummyContainer.RegisterDummy(this);
		}

		private void OnDestroy()
		{
			TrainingDummyContainer.ClearDummies();
		}

		public void TakeDamage(float dmg)
		{
			if (m_active)
			{
				CurrentHP -= dmg;
				m_ui.UpdateFillAmount(CurrentHP / m_maxHP, 0f - dmg);
				if (CurrentHP <= 0f)
				{
					DestroyDummy();
					m_soundHandler.PlaySound("dummy_fall");
				}
				else if (m_animate)
				{
					m_animate = false;
					Invoke("SetAnimateActive", 0.2f);
					SetAnimationState((!(dmg > 30f)) ? "Hit_Small" : "Hit_Large");
					m_soundHandler.PlaySound("dummy_hit0" + UnityEngine.Random.Range(1, 4));
				}
				PlayerManager.Instance.PlayerControl.Input.PlayHitResponse();
			}
		}

		private void DestroyDummy()
		{
			if (m_active)
			{
				m_active = false;
				m_collider.enabled = false;
				m_ui.SetBarActive(active: false);
				SetAnimationBool("Dead", enable: true);
				Invoke("ResetDummy", 5f);
			}
		}

		private void ResetDummy()
		{
			ResetDummy(playSound: true);
		}

		private void ResetDummy(bool playSound)
		{
			CurrentHP = ((!(m_maxHP > 0f)) ? 100f : m_maxHP);
			m_ui.UpdateFillAmount(CurrentHP / m_maxHP, m_maxHP);
			m_ui.SetBarActive(active: true);
			if (playSound)
			{
				m_soundHandler.PlaySound("dummy_rise");
				SetAnimationBool("Dead", enable: false);
			}
			m_collider.enabled = true;
			m_active = true;
		}

		private void PauseMovement()
		{
			if ((object)m_mover != null)
			{
				m_mover.PauseMovement();
			}
		}

		private void UnPauseMovement()
		{
			if ((object)m_mover != null)
			{
				m_mover.UnPauseMovement();
			}
		}

		private void SetAnimateActive()
		{
			m_animate = true;
		}

		public void SetAnimationState(string animation)
		{
			if (!(m_animator == null) && !string.IsNullOrEmpty(animation) && m_animator.HasParameterOfType(animation, AnimatorControllerParameterType.Trigger) && !m_animator.GetCurrentAnimatorStateInfo(0).IsName(animation))
			{
				PlayAnimation(animation);
			}
		}

		public void SetAnimationBool(string animation, bool enable)
		{
			if (!(m_animator == null) && !string.IsNullOrEmpty(animation) && m_animator.HasParameterOfType(animation, AnimatorControllerParameterType.Bool))
			{
				PlayAnimation(animation, enable);
			}
		}

		private void PlayAnimation(string animation)
		{
			m_animator.SetTrigger(animation);
		}

		private void PlayAnimation(string animation, bool enable)
		{
			m_animator.SetBool(animation, enable);
		}
	}
	public static class TrainingDummyContainer
	{
		private static readonly TrainingDummy[] sm_trainingDummies = new TrainingDummy[2];

		public static int Count { get; private set; }

		public static void RegisterDummy(TrainingDummy dummy)
		{
			if (Count >= sm_trainingDummies.Length)
			{
				WandsLogger.LogError("Trying to add more TrainingDummies than we've got room for. Check how many dummies are in the scene and how big the array sm_trainingDummies is.");
			}
			else
			{
				sm_trainingDummies[Count++] = dummy;
			}
		}

		public static void ClearDummies()
		{
			Count = 0;
		}

		public static TrainingDummy GetDummy(int index)
		{
			if (index >= Count || index < 0)
			{
				WandsLogger.LogError("Trying to index TrainingDummy[" + index + "], which is outside of the range (" + Count + ")");
				return null;
			}
			return sm_trainingDummies[index];
		}
	}
}
namespace Assets.Scripts
{
	public class PlayerManager : MonoBehaviour
	{
		private BotPlayer m_botPlayer;

		private CharacterBase m_opponentCharacter;

		private EventToken m_photonPlayerConnectedEventToken;

		private EventToken m_photonPlayerDisconnectedEventToken;

		private EventToken m_wielderSpawnedEventToken;

		private static PlayerManager sm_instance;

		public static PlayerManager Instance
		{
			[CompilerGenerated]
			get
			{
				return (sm_instance != null) ? sm_instance : (sm_instance = UnityEngine.Object.FindObjectOfType<PlayerManager>());
			}
		}

		public Wielder LocalWielder { get; private set; }

		public PlayerControl PlayerControl { get; private set; }

		public BotControl BotControl { get; private set; }

		public bool IsWinner { get; private set; }

		public Wielder Winner { get; private set; }

		public int HighestDamageDealerId { get; private set; }

		public List<Wielder> AllWielders { get; private set; } = new List<Wielder>();


		public bool IsGameFull
		{
			[CompilerGenerated]
			get
			{
				return MonoSingleton<NetworkManager>.Instance.GetNumberOfActivePlayers() >= ((!(BotControl == null)) ? 1 : 2);
			}
		}

		public bool IsEveryoneAvailable
		{
			[CompilerGenerated]
			get
			{
				return MonoSingleton<NetworkManager>.Instance.GetNumberOfActivePlayers() == WielderCount;
			}
		}

		public int WielderCount
		{
			[CompilerGenerated]
			get
			{
				return AllWielders.Count;
			}
		}

		public int WinnerIndex
		{
			[CompilerGenerated]
			get
			{
				return (!(Winner != null) || !AllWielders.Contains(Winner)) ? (-1) : (AllWielders.IndexOf(Winner) + 1);
			}
		}

		private void OnEnable()
		{
			m_photonPlayerConnectedEventToken = EventHub.Subscribe<NetworkEvents.PhotonPlayerConnectedEvent>(OnPhotonPlayerConnected);
			m_photonPlayerDisconnectedEventToken = EventHub.Subscribe<NetworkEvents.PhotonPlayerDisconnectedEvent>(OnPhotonPlayerDisconnected);
			m_wielderSpawnedEventToken = EventHub.Subscribe<Events.WielderSpawnedEvent>(OnWielderSpawned);
			if (!IsGameFull)
			{
				UpdateRoomProperties(force: true);
			}
		}

		protected void OnDisable()
		{
			sm_instance = null;
			StopAllCoroutines();
			EventHub.Unsubscribe<NetworkEvents.PhotonPlayerConnectedEvent>(m_photonPlayerConnectedEventToken);
			EventHub.Unsubscribe<NetworkEvents.PhotonPlayerDisconnectedEvent>(m_photonPlayerDisconnectedEventToken);
			EventHub.Unsubscribe<Events.WielderSpawnedEvent>(m_wielderSpawnedEventToken);
		}

		private void Awake()
		{
			if (sm_instance != this)
			{
				sm_instance = this;
			}
		}

		private void OnWielderSpawned(Events.WielderSpawnedEvent eventData)
		{
			if (PhotonNetwork.IsMasterClient && eventData.Wielder == LocalWielder)
			{
				UpdateRoomProperties();
			}
		}

		private void OnPhotonPlayerConnected(NetworkEvents.PhotonPlayerConnectedEvent eventData)
		{
			OnPhotonPlayerConnected(eventData.PhotonPlayer);
		}

		private void OnPhotonPlayerConnected(Photon.Realtime.Player otherPlayer)
		{
			if (PhotonNetwork.IsMasterClient)
			{
				PunSingleton<SoundManager>.Instance.PlayLocalSound("opponent_enters");
				UpdateRoomProperties();
				PlayerControl.Wand?.Twins?.ClearDuplicates();
			}
		}

		private void OnPhotonPlayerDisconnected(NetworkEvents.PhotonPlayerDisconnectedEvent eventData)
		{
			OnPhotonPlayerDisconnected(eventData.PhotonPlayer);
		}

		private void OnPhotonPlayerDisconnected(Photon.Realtime.Player otherPlayer)
		{
			if (otherPlayer != null)
			{
				foreach (Wielder allWielder in AllWielders)
				{
					allWielder?.OnPlayerDisconnect();
				}
			}
			PlayerControl?.ToggleInputActive(active: true);
			UpdateRoomProperties(force: true);
		}

		public void KickOpponentWielder()
		{
			Wielder opponentWielder = GetOpponentWielder();
			if (!(opponentWielder == null))
			{
				MonoSingleton<NetworkManager>.Instance.KickPhotonPlayer(opponentWielder.Owner);
			}
		}

		private IEnumerator OnUpdateRoomProperties()
		{
			while (LocalWielder == null || LocalWielder.gameObject == null)
			{
				yield return null;
			}
			LocalWielder.UpdateIndex();
			Photon.Realtime.Player[] wielders = PhotonNetwork.PlayerList;
			if (!wielders.IsEmpty())
			{
				if (wielders.Length == 1)
				{
					RoomProperty.SetRoomProperty("A1", (int)GameControl.Instance.Platform.Type);
					RoomProperty.SetRoomProperty("C8", PhotonNetwork.LocalPlayer.NickName);
					SetRoomProperty(wielders[0], null);
				}
				else
				{
					SetRoomProperty(wielders[0], wielders[1]);
				}
			}
		}

		private void UpdateRoomProperties(bool force = false)
		{
			if ((force || PhotonNetwork.IsMasterClient) && !PhotonNetwork.PlayerList.IsEmpty())
			{
				StartCoroutine(OnUpdateRoomProperties());
			}
		}

		private void SetRoomProperty(Photon.Realtime.Player master, Photon.Realtime.Player client)
		{
			string value = $"{master.NickName}/{((client == null) ? string.Empty : client.NickName)}";
			RoomProperty.SetRoomProperty("P1", value);
		}

		public void SpawnWielderOnline(PlayerStats playerStats, Action<Wielder> onSpawnedCallback)
		{
			if (!(LocalWielder != null))
			{
				StartCoroutine(SpawnPawnOnline(playerStats, onSpawnedCallback));
			}
		}

		private IEnumerator SpawnPawnOnline(PlayerStats playerStats, Action<Wielder> onSpawnedCallback)
		{
			WaitForSeconds wait = new WaitForSeconds(0.1f);
			yield return wait;
			while (!NetworkUtils.ConnectedToGame)
			{
				yield return wait;
			}
			if (!(LocalWielder != null))
			{
				if (PunSingleton<TileManager>.Instance == null)
				{
					WandsLogger.Log("Tile Manager is missing!", LogType.Error);
					yield break;
				}
				Transform startTileTransform = PunSingleton<TileManager>.Instance.GetStartTile((!PhotonNetwork.IsMasterClient) ? 1 : 0).transform;
				LocalWielder = NetworkUtils.Instantiate(data: new object[2] { playerStats.MaxHealth, playerStats.MaxMana }, assetPath: "Wielder", position: startTileTransform.position, rotation: Quaternion.identity, group: 0).GetComponent<Wielder>();
				onSpawnedCallback?.Invoke(LocalWielder);
			}
		}

		public void SpawnBotWielder(Action<Wielder> onSpawnedCallback)
		{
			Transform transform = PunSingleton<TileManager>.Instance.GetStartTile((!PhotonNetwork.IsMasterClient) ? 1 : 0).transform;
			Wielder component = NetworkUtils.Instantiate("Wielder", transform.position, Quaternion.identity, 0, null).GetComponent<Wielder>();
			onSpawnedCallback?.Invoke(component);
		}

		public void BotSpawned(BotControl botControl)
		{
			BotControl = botControl;
			CreateBotPlayer();
			BotControl.Wielder.SetBotOwner();
			Events.BotControlSpawnedEvent botControlSpawnedEvent = new Events.BotControlSpawnedEvent();
			botControlSpawnedEvent.BotControl = BotControl;
			EventHub.Publish(botControlSpawnedEvent);
		}

		private void CreateBotPlayer()
		{
			ExitGames.Client.Photon.Hashtable hashtable = new ExitGames.Client.Photon.Hashtable();
			hashtable.Add("P4", (int)BotControl.AimInput);
			hashtable.Add("P1", PhotonNetwork.LocalPlayer.CustomProperties["P1"]);
			hashtable.Add("P2", false);
			hashtable.Add("P6", true);
			hashtable.Add("EL", BotDifficultyUtils.Elo);
			hashtable.Add("PL", BotDifficultyUtils.Level);
			hashtable.Add("SS", BotDifficultyUtils.SeasonScore);
			hashtable.Add("C0", (int)BotControl.CharacterType);
			hashtable.Add("C2", (int)BotControl.WandType);
			hashtable.Add("C3", "Titles/Vindicator");
			ExitGames.Client.Photon.Hashtable playerProperties = hashtable;
			m_botPlayer = new BotPlayer("Machina", 2, isLocal: false, playerProperties);
		}

		public void UpdateBotDifficultyProperties()
		{
			m_botPlayer.SetCustomProperties(new ExitGames.Client.Photon.Hashtable
			{
				{
					"EL",
					BotDifficultyUtils.Elo
				},
				{
					"PL",
					BotDifficultyUtils.Level
				},
				{
					"SS",
					BotDifficultyUtils.SeasonScore
				}
			});
		}

		public void UpdateWielderMatchStatsAndVerifyWinnerID(ref int winnerViewID)
		{
			if (!IsGameFull)
			{
				if (LocalWielder != null)
				{
					winnerViewID = LocalWielder.ViewID;
					RoomProperty.SetRoomProperty("G1", winnerViewID);
				}
				return;
			}
			UpdateWielderList();
			int value = -1;
			int num = -1;
			int num2 = 0;
			int num3 = 0;
			foreach (Wielder allWielder in AllWielders)
			{
				int num4 = (int)PlayerProperty.Get("HP", allWielder.Owner);
				int num5 = (int)PlayerProperty.Get("DD", allWielder.Owner);
				if (num4 == num3)
				{
					num3 = num4;
					num = -1;
				}
				else if (num4 > num3)
				{
					num3 = num4;
					num = allWielder.ViewID;
				}
				if (num5 == num2)
				{
					num2 = num5;
					value = -1;
				}
				else if (num5 > num2)
				{
					num2 = num5;
					value = allWielder.ViewID;
				}
			}
			RoomProperty.SetRoomProperty("G1", value);
			if (num >= 0)
			{
				winnerViewID = num;
			}
		}

		public void PlayerSpawned(PlayerControl playerControl)
		{
			PlayerControl = playerControl;
			Events.PlayerControlSpawnedEvent playerControlSpawnedEvent = new Events.PlayerControlSpawnedEvent();
			playerControlSpawnedEvent.PlayerControl = PlayerControl;
			EventHub.Publish(playerControlSpawnedEvent);
		}

		public void AddWielder(Wielder w)
		{
			if (!(w == null) && !AllWielders.Contains(w))
			{
				AllWielders.Add(w);
				UpdateWielderList();
				Events.WielderSpawnedEvent wielderSpawnedEvent = new Events.WielderSpawnedEvent();
				wielderSpawnedEvent.Wielder = w;
				EventHub.Publish(wielderSpawnedEvent);
			}
		}

		public void AddRemoteCharacter(CharacterBase character)
		{
			m_opponentCharacter = character;
		}

		public void RemoveRemoteCharacter()
		{
			if (m_opponentCharacter != null)
			{
				m_opponentCharacter.DestroySelf();
				m_opponentCharacter = null;
			}
		}

		public void RemoveBotControl()
		{
			BotControl?.DestroySelf();
			BotControl = null;
			m_botPlayer = null;
		}

		public void RemoveWielder(Wielder w)
		{
			if (AllWielders.Remove(w))
			{
				UpdateWielderList();
			}
		}

		public void UpdateWielderList()
		{
			for (int num = AllWielders.Count - 1; num >= 0; num--)
			{
				if (AllWielders[num] == null)
				{
					AllWielders.RemoveAt(num);
				}
			}
			AllWielders.Sort((Wielder x, Wielder y) => y.Owner.IsMasterClient.CompareTo(x.Owner.IsMasterClient));
		}

		public Photon.Realtime.Player GetOpponent()
		{
			if (BotControl != null)
			{
				return m_botPlayer;
			}
			List<Photon.Realtime.Player> activePlayers = MonoSingleton<NetworkManager>.Instance.GetActivePlayers();
			if (activePlayers.IsNullOrEmpty() || activePlayers.Count == 1)
			{
				return null;
			}
			for (int i = 0; i < activePlayers.Count; i++)
			{
				if (!activePlayers[i].IsLocal)
				{
					return activePlayers[i];
				}
			}
			return null;
		}

		public Wielder GetOpponentWielder()
		{
			if (AllWielders.Count >= 2)
			{
				for (int i = 0; i < AllWielders.Count; i++)
				{
					if (!AllWielders[i].Owner.IsLocal)
					{
						return AllWielders[i];
					}
				}
			}
			return null;
		}

		public bool CanGetOpponentWielder(out Wielder opponent)
		{
			opponent = null;
			if (LocalWielder == null)
			{
				return false;
			}
			return CanGetOpponentWielder(LocalWielder.ViewID, out opponent);
		}

		public bool CanGetOpponentWielder(int viewID, out Wielder opponent)
		{
			foreach (Wielder allWielder in AllWielders)
			{
				if (allWielder.ViewID != viewID)
				{
					opponent = allWielder;
					return opponent != null;
				}
			}
			opponent = null;
			return false;
		}

		public void SetWinnerWielder(Wielder winner)
		{
			Winner = winner;
			IsWinner = winner == LocalWielder;
		}

		public void HighlightAll()
		{
			foreach (Wielder allWielder in AllWielders)
			{
				if (!(allWielder.RemoteCharacter == null))
				{
					allWielder.RemoteCharacter.CharacterRenderer.SetMaterial(CharacterMaterialType.Highlight, (!allWielder.IsArmorActive) ? Color.red : Color.yellow);
				}
			}
		}

		public bool CanRetrievePlayerTf(out Wielder wielder, int playerIndex)
		{
			wielder = null;
			if (playerIndex > WielderCount || playerIndex <= 0)
			{
				return false;
			}
			foreach (Wielder allWielder in AllWielders)
			{
				if (allWielder.RemoteCharacter != null && allWielder.GetIndex() == playerIndex)
				{
					wielder = allWielder;
					break;
				}
			}
			return wielder != null;
		}
	}
}
namespace Assets.Scripts.PlayFab
{
	public class CombinedBackendRepresentation
	{
		public SeasonControl.SeasonInformation SeasonInformation;

		public GetTitleDataResult TitleData;

		public List<CatalogItem>[] CatalogItems;

		public GetUserInventoryResult UserInventory;

		public GetUserDataResult UserData;

		public GetPlayerStatisticsResult Rating;

		public GetLeaderboardResult Leaderboard;

		public GetLeaderboardAroundPlayerResult LeaderboardAroundPlayer;

		public GetTitleNewsResult News;

		public PlatformSupport PlatformSupport;
	}
	public enum CustomEventType
	{
		match_started,
		match_ended,
		player_purchased_game,
		player_installed_free_to_play,
		player_unlocked_spell,
		player_leveled_up,
		player_started_survival,
		player_left_survival,
		player_entered_basement,
		player_left_basement,
		player_entered_lobby,
		player_left_lobby,
		player_login,
		player_received_spell_token,
		player_caused_error,
		player_changed_tutorial_state,
		player_started_tutorial,
		player_completed_tutorial,
		player_purchased_item,
		player_activated_subtitles,
		player_earned_virtual_currency,
		player_equipped_wand,
		player_equipped_character,
		player_reported
	}
	public class ExperienceTableObject
	{
		public readonly int XPNeeded;

		public readonly int SpellTokenReward;

		public readonly int DustReward;

		public readonly int LoadoutReward;

		public ExperienceTableObject(int xpNeeded, int spellTokenReward, int dustReward, int loadoutReward)
		{
			XPNeeded = xpNeeded;
			SpellTokenReward = spellTokenReward;
			DustReward = dustReward;
			LoadoutReward = loadoutReward;
		}

		public override string ToString()
		{
			return string.Format("{0}: {1}, {2}: {3}, {4}: {5}, {6}: {7}", "XPNeeded", XPNeeded, "SpellTokenReward", SpellTokenReward, "DustReward", DustReward, "LoadoutReward", LoadoutReward);
		}
	}
	public interface ICloudManager
	{
		void LogIn<T>(string userId, bool createAccount, Action<T> success = null, Action<string> failure = null);

		[Obsolete("GetCombinedBackendRepresentation has been deprecated in favor of method with the same name but an additional 'clientVersion' parameter.")]
		void GetCombinedBackendRepresentation<T>(string platformName, Action<T> success = null, Action<string> failure = null);

		void GetCombinedBackendRepresentation<T>(string platformName, string clientVersion, Action<T> success = null, Action<string> failure = null);

		void GetUserInventory<T>(Action<T> success = null, Action<string> failure = null);

		void GetAllCatalogItems<T>(Action<T> success = null, Action<string> failure = null);

		void GetTitleData<T>(Action<T> success = null, Action<string> failure = null);

		void GetUserData<T>(Action<T> success = null, Action<string> failure = null);

		void GetUserData<T>(List<string> keys, Action<T> success = null, Action<string> failure = null);

		void GetPlayerStatistics<T>(PlayFabStatisticsField field, Action<T> success = null, Action<string> failure = null);

		void GetLeaderboard<T>(PlayFabStatisticsField field, Action<T> success = null, Action<string> failure = null);

		void GetLeaderboardAroundPlayer<T>(PlayFabStatisticsField field, Action<T> success = null, Action<string> failure = null);

		void GetSeasonInformation<T>(Action<T> success = null, Action<string> failure = null);

		void GetMinimumVersion<T>(Action<T> success = null, Action<string> failure = null);

		void SaveAllData<T>(Dictionary<string, string> data, Action<T> success = null, Action<string> failure = null);

		void SaveExperienceRewards<T>(Dictionary<string, string> data, Action<T> success = null, Action<string> failure = null);

		void SaveItemsToInventory<T>(InventorySaveObject inventorySaveObject, Action<T> success = null, Action<string> failure = null);

		void SaveItemsToInventory<T>(InventorySaveObject[] inventorySaveObjects, Action<T> success = null, Action<string> failure = null);

		void SaveUnlockedData<T>(Dictionary<string, string> data, PlayFabRequestType requestType, Action<T> success = null, Action<string> failure = null);

		void SaveGameAccess<T>(Dictionary<string, string> data, Action<T> success = null, Action<string> failure = null);

		void SaveCompletedTutorial<T>(Dictionary<string, string> data, Action<T> success = null, Action<string> failure = null);

		void SaveLoadouts<T>(Dictionary<string, string> data, Action<T> success = null, Action<string> failure = null);

		void SaveCustomEventRewards<T>(Dictionary<string, string> data, Action<T> success = null, Action<string> failure = null);

		void SaveMatchData<T>(Dictionary<string, string> data, Action<T> success = null, Action<string> failure = null);

		void SaveAchievementData<T>(Dictionary<string, string> data, Action<T> success = null, Action<string> failure = null);

		void UpdateUserDisplayName<T>(string name, Action<T> success = null, Action<string> failure = null);

		void UpdatePlayerStatistics<T>(Dictionary<string, string> fields, PlayFabStatisticsField statisticsField, Action<T> success = null, Action<string> failure = null);

		void SendCustomEvent(CustomEventType customEventType, Dictionary<string, object> data);

		void GetTime(Action<GetTimeResult> success = null, Action<string> failure = null);
	}
	public enum LoginErrorCode
	{
		LoginFailed = 1000,
		ClientVersionBehind,
		ConnectionToDataBaseFailed
	}
	public class MatchRewardsObject
	{
		public readonly int XPReward;

		public readonly int DustReward;

		public MatchRewardsObject(int xpReward, int dustReward)
		{
			XPReward = xpReward;
			DustReward = dustReward;
		}

		public override string ToString()
		{
			return string.Format("{0}: {1}, {2}: {3}", "XPReward", XPReward, "DustReward", DustReward);
		}
	}
	public class Md5Wrapper
	{
		private const string Key = "{B06B5A39-C810-4DD1-B138-41603713DD8A}";

		public static string ConvertUserIdToMd5(string userId)
		{
			MD5 mD = MD5.Create();
			byte[] bytes = Encoding.ASCII.GetBytes("{B06B5A39-C810-4DD1-B138-41603713DD8A}" + userId);
			byte[] array = mD.ComputeHash(bytes);
			StringBuilder stringBuilder = new StringBuilder();
			byte[] array2 = array;
			foreach (byte b in array2)
			{
				stringBuilder.Append(b.ToString("x2"));
			}
			return stringBuilder.ToString();
		}
	}
	public static class NewsControl
	{
		private const string FetchFailedMessage = "Couldn't fetch news from server.";

		public static string Header { get; private set; }

		public static string Body { get; private set; }

		public static void Initialize(GetTitleNewsResult news)
		{
			if (news.News.IsNullOrEmpty())
			{
				OnNewsFetchFailed();
			}
			else
			{
				OnNewsFetchSuccess(news.News[0]);
			}
		}

		private static void OnNewsFetchSuccess(TitleNewsItem latestNews)
		{
			string arg = latestNews.Timestamp.ToString("MMM dd, yyyy", CultureInfo.CreateSpecificCulture("en-US"));
			Header = $"{latestNews.Title}\n{arg}";
			Body = latestNews.Body;
		}

		private static void OnNewsFetchFailed()
		{
			WandsLogger.LogError("NewsControl | News is empty");
			Body = "Couldn't fetch news from server.";
		}
	}
	public class PlayFabCustomEvent
	{
		public string EventName;

		public string JsonData;
	}
}
namespace Assets.Scripts.WandsExceptions
{
	public class PlayFabException : Exception
	{
		public PlayFabException(string error)
			: base(error)
		{
		}

		public PlayFabException(PlayFabError error)
			: base($"{error.HttpCode} - {error.HttpStatus} | {error.ErrorMessage}")
		{
		}

		public PlayFabException(PlayFabError error, PlayFabRequestType requestType)
			: base($"{requestType} | {error.HttpCode} - {error.HttpStatus} | {error.ErrorMessage}")
		{
		}

		public PlayFabException(PlayFabError error, PlayFabRequestType requestType, string functionName)
			: base($"{requestType} method: {functionName} | {error.HttpCode} - {error.HttpStatus} | {error.ErrorMessage}")
		{
		}

		public PlayFabException(ScriptExecutionError error, PlayFabRequestType requestType)
			: base($"{requestType} | {error.Error} | {error.Message}")
		{
		}

		public PlayFabException(ScriptExecutionError error, PlayFabRequestType requestType, string functionName)
			: base($"{requestType} method: {functionName} | {error.Message}")
		{
		}
	}
}
namespace Assets.Scripts.PlayFab
{
	public class PlayFabManager : ICloudManager
	{
		protected readonly PlayFabRequestQueue m_requestQueue = new PlayFabRequestQueue();

		public virtual void LogIn<T>(string userId, bool createAccount, Action<T> success = null, Action<string> failure = null)
		{
			LoginWithCustomIDRequest loginWithCustomIDRequest = new LoginWithCustomIDRequest();
			loginWithCustomIDRequest.CustomId = Md5Wrapper.ConvertUserIdToMd5(userId);
			loginWithCustomIDRequest.CreateAccount = createAccount;
			LoginWithCustomIDRequest request = loginWithCustomIDRequest;
			PlayFabRequestItem item = ComposeRequestItem(PlayFabRequestType.CustomLogIn, request, success, failure);
			m_requestQueue.ForceToFrontOfQueue(item);
		}

		[Obsolete("GetCombinedBackendRepresentation has been deprecated in favor of method with the same name but an additional 'clientVersion' parameter.")]
		public void GetCombinedBackendRepresentation<T>(string platformName, Action<T> success = null, Action<string> failure = null)
		{
			ExecuteCloudScriptRequest executeCloudScriptRequest = new ExecuteCloudScriptRequest();
			executeCloudScriptRequest.FunctionName = CloudScriptConverter.GetMethodName("GetCombinedBackendRepresentation");
			executeCloudScriptRequest.FunctionParameter = platformName;
			executeCloudScriptRequest.GeneratePlayStreamEvent = true;
			ExecuteCloudScriptRequest request = executeCloudScriptRequest;
			PlayFabRequestItem item = ComposeRequestItem(PlayFabRequestType.ExecuteCloudScript, request, success, failure);
			m_requestQueue.AddToQueue(item);
		}

		public void GetCombinedBackendRepresentation<T>(string platformName, string clientVersion, Action<T> success = null, Action<string> failure = null)
		{
			ExecuteCloudScriptRequest executeCloudScriptRequest = new ExecuteCloudScriptRequest();
			executeCloudScriptRequest.FunctionName = CloudScriptConverter.GetMethodName("GetCombinedBackendRepresentation");
			executeCloudScriptRequest.FunctionParameter = new Dictionary<string, string>(2)
			{
				{ "platformName", platformName },
				{ "clientVersion", clientVersion }
			};
			executeCloudScriptRequest.GeneratePlayStreamEvent = true;
			ExecuteCloudScriptRequest request = executeCloudScriptRequest;
			PlayFabRequestItem item = ComposeRequestItem(PlayFabRequestType.ExecuteCloudScript, request, success, failure);
			m_requestQueue.AddToQueue(item);
		}

		public void GetUserInventory<T>(Action<T> success = null, Action<string> failure = null)
		{
			ExecuteCloudScriptRequest executeCloudScriptRequest = new ExecuteCloudScriptRequest();
			executeCloudScriptRequest.FunctionName = CloudScriptConverter.GetMethodName("GetUserInventory");
			executeCloudScriptRequest.FunctionParameter = null;
			executeCloudScriptRequest.GeneratePlayStreamEvent = true;
			ExecuteCloudScriptRequest request = executeCloudScriptRequest;
			PlayFabRequestItem item = ComposeRequestItem(PlayFabRequestType.ExecuteCloudScript, request, success, failure);
			m_requestQueue.AddToQueue(item);
		}

		public void GetAllCatalogItems<T>(Action<T> success = null, Action<string> failure = null)
		{
			ExecuteCloudScriptRequest executeCloudScriptRequest = new ExecuteCloudScriptRequest();
			executeCloudScriptRequest.FunctionName = CloudScriptConverter.GetMethodName("GetCatalogItems");
			executeCloudScriptRequest.FunctionParameter = null;
			executeCloudScriptRequest.GeneratePlayStreamEvent = true;
			ExecuteCloudScriptRequest request = executeCloudScriptRequest;
			PlayFabRequestItem item = ComposeRequestItem(PlayFabRequestType.ExecuteCloudScript, request, success, failure);
			m_requestQueue.AddToQueue(item);
		}

		public void GetTitleData<T>(Action<T> success = null, Action<string> failure = null)
		{
			GetTitleDataRequest getTitleDataRequest = new GetTitleDataRequest();
			getTitleDataRequest.Keys = null;
			GetTitleDataRequest request = getTitleDataRequest;
			PlayFabRequestItem item = ComposeRequestItem(PlayFabRequestType.GetTitleData, request, success, failure);
			m_requestQueue.AddToQueue(item);
		}

		public void GetUserData<T>(Action<T> success = null, Action<string> failure = null)
		{
			GetUserData(null, success, failure);
		}

		public void GetUserData<T>(List<string> keys, Action<T> success = null, Action<string> failure = null)
		{
			GetUserDataRequest getUserDataRequest = new GetUserDataRequest();
			getUserDataRequest.Keys = keys;
			GetUserDataRequest request = getUserDataRequest;
			PlayFabRequestItem item = ComposeRequestItem(PlayFabRequestType.GetUserData, request, success, failure);
			m_requestQueue.AddToQueue(item);
		}

		public void GetPlayerStatistics<T>(PlayFabStatisticsField field, Action<T> success = null, Action<string> failure = null)
		{
			GetPlayerStatisticsRequest getPlayerStatisticsRequest = new GetPlayerStatisticsRequest();
			getPlayerStatisticsRequest.StatisticNames = new List<string> { field.ToString() };
			GetPlayerStatisticsRequest request = getPlayerStatisticsRequest;
			PlayFabRequestItem item = ComposeRequestItem(PlayFabRequestType.GetPlayerStatistics, request, success, failure);
			m_requestQueue.AddToQueue(item);
		}

		public void GetLeaderboard<T>(PlayFabStatisticsField field, Action<T> success = null, Action<string> failure = null)
		{
			GetLeaderboardRequest getLeaderboardRequest = new GetLeaderboardRequest();
			getLeaderboardRequest.StatisticName = field.ToString();
			getLeaderboardRequest.MaxResultsCount = 10;
			GetLeaderboardRequest request = getLeaderboardRequest;
			PlayFabRequestItem item = ComposeRequestItem(PlayFabRequestType.GetLeaderboard, request, success, failure);
			m_requestQueue.AddToQueue(item);
		}

		public void GetLeaderboardAroundPlayer<T>(PlayFabStatisticsField field, Action<T> success = null, Action<string> failure = null)
		{
			GetLeaderboardAroundPlayerRequest getLeaderboardAroundPlayerRequest = new GetLeaderboardAroundPlayerRequest();
			getLeaderboardAroundPlayerRequest.StatisticName = field.ToString();
			getLeaderboardAroundPlayerRequest.MaxResultsCount = 10;
			GetLeaderboardAroundPlayerRequest request = getLeaderboardAroundPlayerRequest;
			PlayFabRequestItem item = ComposeRequestItem(PlayFabRequestType.GetLeaderboardAroundPlayer, request, success, failure);
			m_requestQueue.AddToQueue(item);
		}

		public void GetSeasonInformation<T>(Action<T> success = null, Action<string> failure = null)
		{
			ExecuteCloudScriptRequest executeCloudScriptRequest = new ExecuteCloudScriptRequest();
			executeCloudScriptRequest.FunctionName = CloudScriptConverter.GetMethodName("GetSeasonInformation");
			executeCloudScriptRequest.FunctionParameter = null;
			executeCloudScriptRequest.GeneratePlayStreamEvent = true;
			ExecuteCloudScriptRequest request = executeCloudScriptRequest;
			PlayFabRequestItem item = ComposeRequestItem(PlayFabRequestType.ExecuteCloudScript, request, success, failure);
			m_requestQueue.AddToQueue(item);
		}

		public void GetMinimumVersion<T>(Action<T> success = null, Action<string> failure = null)
		{
			ExecuteCloudScriptRequest executeCloudScriptRequest = new ExecuteCloudScriptRequest();
			executeCloudScriptRequest.FunctionName = CloudScriptConverter.GetMethodName("GetMinimumVersion");
			executeCloudScriptRequest.FunctionParameter = null;
			executeCloudScriptRequest.GeneratePlayStreamEvent = true;
			ExecuteCloudScriptRequest request = executeCloudScriptRequest;
			PlayFabRequestItem item = ComposeRequestItem(PlayFabRequestType.ExecuteCloudScript, request, success, failure);
			m_requestQueue.AddToQueue(item);
		}

		public void SaveAllData<T>(Dictionary<string, string> data, Action<T> success = null, Action<string> failure = null)
		{
			ExecuteCloudScriptRequest executeCloudScriptRequest = new ExecuteCloudScriptRequest();
			executeCloudScriptRequest.FunctionName = CloudScriptConverter.GetMethodName("SaveAllData");
			executeCloudScriptRequest.FunctionParameter = data;
			executeCloudScriptRequest.GeneratePlayStreamEvent = true;
			ExecuteCloudScriptRequest request = executeCloudScriptRequest;
			PlayFabRequestItem item = ComposeRequestItem(PlayFabRequestType.ExecuteCloudScript, request, success, failure);
			m_requestQueue.AddToQueue(item);
		}

		public void SaveExperienceRewards<T>(Dictionary<string, string> data, Action<T> success = null, Action<string> failure = null)
		{
			ExecuteCloudScriptRequest executeCloudScriptRequest = new ExecuteCloudScriptRequest();
			executeCloudScriptRequest.FunctionName = CloudScriptConverter.GetMethodName("SaveExperienceRewards");
			executeCloudScriptRequest.FunctionParameter = data;
			executeCloudScriptRequest.GeneratePlayStreamEvent = true;
			ExecuteCloudScriptRequest request = executeCloudScriptRequest;
			PlayFabRequestItem item = ComposeRequestItem(PlayFabRequestType.ExecuteCloudScript, request, success, failure);
			m_requestQueue.AddToQueue(item);
		}

		public void SaveItemsToInventory<T>(InventorySaveObject inventorySaveObject, Action<T> success = null, Action<string> failure = null)
		{
			ExecuteCloudScriptRequest executeCloudScriptRequest = new ExecuteCloudScriptRequest();
			executeCloudScriptRequest.FunctionName = CloudScriptConverter.GetMethodName("SaveItemsToInventory");
			executeCloudScriptRequest.FunctionParameter = inventorySaveObject;
			executeCloudScriptRequest.GeneratePlayStreamEvent = true;
			ExecuteCloudScriptRequest request = executeCloudScriptRequest;
			PlayFabRequestItem item = ComposeRequestItem(PlayFabRequestType.ExecuteCloudScript, request, success, failure);
			m_requestQueue.AddToQueue(item);
		}

		public void SaveItemsToInventory<T>(InventorySaveObject[] inventorySaveObjects, Action<T> success = null, Action<string> failure = null)
		{
			ExecuteCloudScriptRequest executeCloudScriptRequest = new ExecuteCloudScriptRequest();
			executeCloudScriptRequest.FunctionName = CloudScriptConverter.GetMethodName("SaveItemsToInventory");
			executeCloudScriptRequest.FunctionParameter = inventorySaveObjects;
			executeCloudScriptRequest.GeneratePlayStreamEvent = true;
			ExecuteCloudScriptRequest request = executeCloudScriptRequest;
			PlayFabRequestItem item = ComposeRequestItem(PlayFabRequestType.ExecuteCloudScript, request, success, failure);
			m_requestQueue.AddToQueue(item);
		}

		public void SaveUnlockedData<T>(Dictionary<string, string> data, PlayFabRequestType requestType, Action<T> success = null, Action<string> failure = null)
		{
			ExecuteCloudScriptRequest executeCloudScriptRequest = new ExecuteCloudScriptRequest();
			executeCloudScriptRequest.FunctionName = CloudScriptConverter.GetMethodName(requestType.ToString());
			executeCloudScriptRequest.FunctionParameter = data;
			executeCloudScriptRequest.GeneratePlayStreamEvent = true;
			ExecuteCloudScriptRequest request = executeCloudScriptRequest;
			PlayFabRequestItem item = ComposeRequestItem(PlayFabRequestType.ExecuteCloudScript, request, success, failure);
			m_requestQueue.AddToQueue(item);
		}

		public void SaveGameAccess<T>(Dictionary<string, string> data, Action<T> success = null, Action<string> failure = null)
		{
			ExecuteCloudScriptRequest executeCloudScriptRequest = new ExecuteCloudScriptRequest();
			executeCloudScriptRequest.FunctionName = CloudScriptConverter.GetMethodName("SaveGameAccess");
			executeCloudScriptRequest.FunctionParameter = data;
			executeCloudScriptRequest.GeneratePlayStreamEvent = true;
			ExecuteCloudScriptRequest request = executeCloudScriptRequest;
			PlayFabRequestItem item = ComposeRequestItem(PlayFabRequestType.ExecuteCloudScript, request, success, failure);
			m_requestQueue.AddToQueue(item);
		}

		public void SaveCompletedTutorial<T>(Dictionary<string, string> data, Action<T> success = null, Action<string> failure = null)
		{
			ExecuteCloudScriptRequest executeCloudScriptRequest = new ExecuteCloudScriptRequest();
			executeCloudScriptRequest.FunctionName = CloudScriptConverter.GetMethodName("SaveCompletedTutorial");
			executeCloudScriptRequest.FunctionParameter = data;
			executeCloudScriptRequest.GeneratePlayStreamEvent = true;
			ExecuteCloudScriptRequest request = executeCloudScriptRequest;
			PlayFabRequestItem item = ComposeRequestItem(PlayFabRequestType.ExecuteCloudScript, request, success, failure);
			m_requestQueue.AddToQueue(item);
		}

		public void SaveLoadouts<T>(Dictionary<string, string> data, Action<T> success = null, Action<string> failure = null)
		{
			ExecuteCloudScriptRequest executeCloudScriptRequest = new ExecuteCloudScriptRequest();
			executeCloudScriptRequest.FunctionName = CloudScriptConverter.GetMethodName("SaveLoadouts");
			executeCloudScriptRequest.FunctionParameter = data;
			executeCloudScriptRequest.GeneratePlayStreamEvent = true;
			ExecuteCloudScriptRequest request = executeCloudScriptRequest;
			PlayFabRequestItem item = ComposeRequestItem(PlayFabRequestType.ExecuteCloudScript, request, success, failure);
			m_requestQueue.AddToQueue(item);
		}

		public void SaveCustomEventRewards<T>(Dictionary<string, string> data, Action<T> success = null, Action<string> failure = null)
		{
			ExecuteCloudScriptRequest executeCloudScriptRequest = new ExecuteCloudScriptRequest();
			executeCloudScriptRequest.FunctionName = CloudScriptConverter.GetMethodName("SaveCustomEventRewards");
			executeCloudScriptRequest.FunctionParameter = data;
			executeCloudScriptRequest.GeneratePlayStreamEvent = true;
			ExecuteCloudScriptRequest request = executeCloudScriptRequest;
			PlayFabRequestItem item = ComposeRequestItem(PlayFabRequestType.ExecuteCloudScript, request, success, failure);
			m_requestQueue.AddToQueue(item);
		}

		public void SaveMatchData<T>(Dictionary<string, string> data, Action<T> success = null, Action<string> failure = null)
		{
			ExecuteCloudScriptRequest executeCloudScriptRequest = new ExecuteCloudScriptRequest();
			executeCloudScriptRequest.FunctionName = CloudScriptConverter.GetMethodName("SaveMatchData");
			executeCloudScriptRequest.FunctionParameter = data;
			executeCloudScriptRequest.GeneratePlayStreamEvent = true;
			ExecuteCloudScriptRequest request = executeCloudScriptRequest;
			PlayFabRequestItem item = ComposeRequestItem(PlayFabRequestType.ExecuteCloudScript, request, success, failure);
			m_requestQueue.AddToQueue(item);
		}

		public void SaveAchievementData<T>(Dictionary<string, string> data, Action<T> success = null, Action<string> failure = null)
		{
			ExecuteCloudScriptRequest executeCloudScriptRequest = new ExecuteCloudScriptRequest();
			executeCloudScriptRequest.FunctionName = CloudScriptConverter.GetMethodName("SaveAchievementData");
			executeCloudScriptRequest.FunctionParameter = data;
			executeCloudScriptRequest.GeneratePlayStreamEvent = true;
			ExecuteCloudScriptRequest request = executeCloudScriptRequest;
			PlayFabRequestItem item = ComposeRequestItem(PlayFabRequestType.ExecuteCloudScript, request, success, failure);
			m_requestQueue.AddToQueue(item);
		}

		public void UpdateUserDisplayName<T>(string name, Action<T> success = null, Action<string> failure = null)
		{
			UpdateUserTitleDisplayNameRequest updateUserTitleDisplayNameRequest = new UpdateUserTitleDisplayNameRequest();
			updateUserTitleDisplayNameRequest.DisplayName = name;
			UpdateUserTitleDisplayNameRequest request = updateUserTitleDisplayNameRequest;
			PlayFabRequestItem item = ComposeRequestItem(PlayFabRequestType.UpdateUserDisplayName, request, success, failure);
			m_requestQueue.AddToQueue(item);
		}

		public void UpdatePlayerStatistics<T>(Dictionary<string, string> fields, PlayFabStatisticsField statisticsField, Action<T> success = null, Action<string> failure = null)
		{
			ExecuteCloudScriptRequest executeCloudScriptRequest = new ExecuteCloudScriptRequest();
			executeCloudScriptRequest.FunctionName = CloudScriptConverter.GetMethodName(statisticsField.ToString());
			executeCloudScriptRequest.FunctionParameter = fields;
			executeCloudScriptRequest.GeneratePlayStreamEvent = true;
			ExecuteCloudScriptRequest request = executeCloudScriptRequest;
			PlayFabRequestItem item = ComposeRequestItem(PlayFabRequestType.ExecuteCloudScript, request, success, failure);
			m_requestQueue.AddToQueue(item);
		}

		public void SendCustomEvent(CustomEventType customEventType, Dictionary<string, object> data)
		{
			WriteClientPlayerEventRequest writeClientPlayerEventRequest = new WriteClientPlayerEventRequest();
			writeClientPlayerEventRequest.EventName = customEventType.ToString();
			writeClientPlayerEventRequest.Body = data;
			WriteClientPlayerEventRequest request = writeClientPlayerEventRequest;
			PlayFabRequestItem item = ComposeRequestItem<WriteEventResponse>(PlayFabRequestType.SendCustomEvent, request);
			m_requestQueue.AddToQueue(item);
		}

		public void GetTime(Action<GetTimeResult> success = null, Action<string> failure = null)
		{
			PlayFabRequestItem item = ComposeRequestItem(PlayFabRequestType.GetTime, new GetTimeRequest(), success, failure);
			m_requestQueue.AddToQueue(item);
		}

		protected PlayFabRequestItem ComposeRequestItem<T>(PlayFabRequestType requestType, PlayFabRequestCommon request, Action<T> success = null, Action<string> failure = null)
		{
			PlayFabRequestItem playFabRequestItem = new PlayFabRequestItem();
			playFabRequestItem.RequestType = requestType;
			playFabRequestItem.Request = request;
			playFabRequestItem.Success = delegate(PlayFabResultCommon result)
			{
				success?.Invoke((T)Convert.ChangeType(result, typeof(T)));
			};
			playFabRequestItem.Failure = failure;
			return playFabRequestItem;
		}
	}
	public class PlayFabRequestItem
	{
		public PlayFabRequestType RequestType;

		public PlayFabRequestCommon Request;

		public Action<PlayFabResultCommon> Success;

		public Action<string> Failure;
	}
	public class PlayFabRequestQueue
	{
		private readonly LinkedList<PlayFabRequestItem> m_requests = new LinkedList<PlayFabRequestItem>();

		private readonly Stopwatch m_stopwatch = new Stopwatch();

		private bool m_lock;

		public void AddToQueue(PlayFabRequestItem item)
		{
			m_requests.AddLast(item);
			CheckRequestQueue();
		}

		public void ForceToFrontOfQueue(PlayFabRequestItem item)
		{
			m_requests.AddFirst(item);
			CheckRequestQueue();
		}

		private void CheckRequestQueue()
		{
			if (m_requests.Count <= 0 || m_lock)
			{
				return;
			}
			m_lock = true;
			m_stopwatch.Reset();
			m_stopwatch.Start();
			PlayFabRequestItem request = m_requests.First.Value;
			m_requests.RemoveFirst();
			switch (request.RequestType)
			{
			case PlayFabRequestType.CustomLogIn:
				PlayFabClientAPI.LoginWithCustomID((LoginWithCustomIDRequest)request.Request, delegate(LoginResult result)
				{
					Success(result, request);
				}, delegate(PlayFabError error)
				{
					Failure(error, request);
				});
				break;
			case PlayFabRequestType.PSNLogIn:
				PlayFabClientAPI.LoginWithPSN((LoginWithPSNRequest)request.Request, delegate(LoginResult result)
				{
					Success(result, request);
				}, delegate(PlayFabError error)
				{
					Failure(error, request);
				});
				break;
			case PlayFabRequestType.GetTitleData:
				PlayFabClientAPI.GetTitleData((GetTitleDataRequest)request.Request, delegate(GetTitleDataResult result)
				{
					Success(result, request);
				}, delegate(PlayFabError error)
				{
					Failure(error, request);
				});
				break;
			case PlayFabRequestType.GetUserData:
				PlayFabClientAPI.GetUserData((GetUserDataRequest)request.Request, delegate(GetUserDataResult result)
				{
					Success(result, request);
				}, delegate(PlayFabError error)
				{
					Failure(error, request);
				});
				break;
			case PlayFabRequestType.GetPlayerStatistics:
				PlayFabClientAPI.GetPlayerStatistics((GetPlayerStatisticsRequest)request.Request, delegate(GetPlayerStatisticsResult result)
				{
					Success(result, request);
				}, delegate(PlayFabError error)
				{
					Failure(error, request);
				});
				break;
			case PlayFabRequestType.GetLeaderboard:
				PlayFabClientAPI.GetLeaderboard((GetLeaderboardRequest)request.Request, delegate(GetLeaderboardResult result)
				{
					Success(result, request);
				}, delegate(PlayFabError error)
				{
					Failure(error, request);
				});
				break;
			case PlayFabRequestType.GetLeaderboardAroundPlayer:
				PlayFabClientAPI.GetLeaderboardAroundPlayer((GetLeaderboardAroundPlayerRequest)request.Request, delegate(GetLeaderboardAroundPlayerResult result)
				{
					Success(result, request);
				}, delegate(PlayFabError error)
				{
					Failure(error, request);
				});
				break;
			case PlayFabRequestType.UpdateUserDisplayName:
				PlayFabClientAPI.UpdateUserTitleDisplayName((UpdateUserTitleDisplayNameRequest)request.Request, delegate(UpdateUserTitleDisplayNameResult result)
				{
					Success(result, request);
				}, delegate(PlayFabError error)
				{
					Failure(error, request);
				});
				break;
			case PlayFabRequestType.UpdateMigrationFlag:
				PlayFabClientAPI.UpdateUserData((UpdateUserDataRequest)request.Request, delegate(UpdateUserDataResult result)
				{
					Success(result, request);
				}, delegate(PlayFabError error)
				{
					Failure(error, request);
				});
				break;
			case PlayFabRequestType.SendCustomEvent:
				PlayFabClientAPI.WritePlayerEvent((WriteClientPlayerEventRequest)request.Request, delegate(WriteEventResponse result)
				{
					Success(result, request);
				}, delegate(PlayFabError error)
				{
					Failure(error, request);
				});
				break;
			case PlayFabRequestType.ExecuteCloudScript:
				PlayFabClientAPI.ExecuteCloudScript((ExecuteCloudScriptRequest)request.Request, delegate(ExecuteCloudScriptResult result)
				{
					Success(result, request);
				}, delegate(PlayFabError error)
				{
					Failure(error, request);
				});
				break;
			case PlayFabRequestType.GetTime:
				PlayFabClientAPI.GetTime((GetTimeRequest)request.Request, delegate(GetTimeResult result)
				{
					Success(result, request);
				}, delegate(PlayFabError error)
				{
					Failure(error, request);
				});
				break;
			default:
				throw new NotImplementedException("RequestType not implemented: " + request.RequestType);
			}
		}

		private void Success(PlayFabResultCommon result, PlayFabRequestItem request)
		{
			if (request.RequestType != PlayFabRequestType.GetTime)
			{
			}
			m_lock = false;
			m_stopwatch.Stop();
			if (request.Success != null)
			{
				request.Success(result);
			}
			CheckRequestQueue();
		}

		private void Failure(PlayFabError error, PlayFabRequestItem request)
		{
			m_lock = false;
			m_stopwatch.Stop();
			if (error.Error == PlayFabErrorCode.NotAuthenticated)
			{
				m_requests.AddFirst(request);
				EventHub.Publish(new Events.PlayFabSessionExpiredEvent());
				return;
			}
			if (request.Failure == null)
			{
				if (request.RequestType == PlayFabRequestType.ExecuteCloudScript)
				{
					throw new Assets.Scripts.WandsExceptions.PlayFabException(error, request.RequestType, (request.Request as ExecuteCloudScriptRequest)?.FunctionName);
				}
				throw new Assets.Scripts.WandsExceptions.PlayFabException(error, request.RequestType);
			}
			request.Failure(error.ToString());
			CheckRequestQueue();
		}

		private void Success(ExecuteCloudScriptResult result, PlayFabRequestItem request)
		{
			if (result.Error != null)
			{
				Failure(result.Error, request);
				return;
			}
			m_lock = false;
			m_stopwatch.Stop();
			if (request.Success != null)
			{
				request.Success(result);
			}
			CheckRequestQueue();
		}

		private void Failure(ScriptExecutionError error, PlayFabRequestItem request)
		{
			m_lock = false;
			m_stopwatch.Stop();
			string obj = error.Error + "\n" + error.Message + "\n" + error.StackTrace;
			if (request.Failure == null)
			{
				if (request.RequestType == PlayFabRequestType.ExecuteCloudScript)
				{
					throw new Assets.Scripts.WandsExceptions.PlayFabException(error, request.RequestType, (request.Request as ExecuteCloudScriptRequest)?.FunctionName);
				}
				throw new Assets.Scripts.WandsExceptions.PlayFabException(error, request.RequestType);
			}
			request.Failure(obj);
			CheckRequestQueue();
		}
	}
	public enum PlayFabRequestType
	{
		CustomLogIn,
		PSNLogIn,
		InitialiseFirstTimeUser,
		GetCombinedBackendRepresentation,
		GetUserInventory,
		GetAllCatalogItems,
		GetCatalogItems,
		GetTitleData,
		GetUserData,
		GetPlayerStatistics,
		GetLeaderboard,
		GetLeaderboardAroundPlayer,
		GetSeasonInformation,
		GetMinimumVersion,
		SaveAllData,
		SaveExperienceRewards,
		SaveItemsToInventory,
		SaveUnlockedSpells,
		SaveUnlockedWands,
		SaveUnlockedCharacters,
		SaveUnlockedTitles,
		SaveVirtualCurrency,
		SaveGameAccess,
		SaveCompletedTutorial,
		SaveLoadouts,
		SaveCustomEventRewards,
		SaveMatchData,
		SaveAchievementData,
		UpdateUserDisplayName,
		UpdatePlayerStatistics,
		UpdateMigrationFlag,
		SendCustomEvent,
		ExecuteCloudScript,
		GetTime
	}
	public static class PlayFabTitleData
	{
		private const string ExperienceTableName = "Experience table";

		private const string MatchRewardsName = "Match rewards";

		private const string MatchmakingTicketsTimeoutsName = "MatchmakingTicketsTimeout";

		private const string BotsDisabledName = "BotsDisabledVersions";

		private const string ExperienceTable_LevelName = "Level";

		private const string ExperienceTable_ExperienceNeededName = "XPNeeded";

		private const string ExperienceTable_SpellTokenRewardName = "SpellTokenReward";

		private const string ExperienceTable_DustRewardName = "DustReward";

		private const string ExperienceTable_LoadoutRewardname = "LoadoutReward";

		private const string MatchRewards_TypeName = "Type";

		private const string MatchRewards_ExperienceRewardName = "XPReward";

		private const string MatchRewards_DustRewardName = "DustReward";

		private const string MatchmakingTicketsTimeout_QueueName = "QueueName";

		private const string MatchmakingTicketsTimeout_Timeout = "Timeout";

		private const int TimeoutDefault = 300;

		private static Dictionary<int, ExperienceTableObject> sm_experienceTable = new Dictionary<int, ExperienceTableObject>();

		private static IDictionary<MatchRewardType, MatchRewardsObject> sm_matchRewards = new Dictionary<MatchRewardType, MatchRewardsObject>();

		private static IDictionary<string, int> sm_matchmakingTicketsTimeout = new Dictionary<string, int>();

		private static ISet<string> sm_botsDisabledVersions = new HashSet<string>();

		public static void Initialize(GetTitleDataResult result)
		{
			ParseExperienceTable(result.Data["Experience table"]);
			ParseMatchRewards(result.Data["Match rewards"]);
			ParseMatchmakingTicketsTimeout(result.Data["MatchmakingTicketsTimeout"]);
			ParseBotsDisabled(result.Data["BotsDisabledVersions"]);
		}

		private static void ParseExperienceTable(string json)
		{
			JArray jArray = JArray.Parse(json);
			foreach (JObject item in jArray)
			{
				int key = item.GetValue("Level").Value<int>();
				int xpNeeded = item.GetValue("XPNeeded").Value<int>();
				int spellTokenReward = item.GetValue("SpellTokenReward").Value<int>();
				int dustReward = item.GetValue("DustReward").Value<int>();
				int loadoutReward = item.GetValue("LoadoutReward").Value<int>();
				ExperienceTableObject value = new ExperienceTableObject(xpNeeded, spellTokenReward, dustReward, loadoutReward);
				sm_experienceTable.Add(key, value);
			}
		}

		private static void ParseMatchRewards(string json)
		{
			JArray jArray = JArray.Parse(json);
			foreach (JObject item in jArray)
			{
				MatchRewardType key = (MatchRewardType)item.GetValue("Type").Value<int>();
				int xpReward = item.GetValue("XPReward").Value<int>();
				int dustReward = item.GetValue("DustReward").Value<int>();
				MatchRewardsObject value = new MatchRewardsObject(xpReward, dustReward);
				sm_matchRewards.Add(key, value);
			}
		}

		private static void ParseMatchmakingTicketsTimeout(string json)
		{
			JArray jArray = JArray.Parse(json);
			foreach (JObject item in jArray)
			{
				string key = item.GetValue("QueueName").Value<string>();
				int value = item.GetValue("Timeout").Value<int>();
				sm_matchmakingTicketsTimeout.Add(key, value);
			}
		}

		private static void ParseBotsDisabled(string json)
		{
			JArray jArray = JArray.Parse(json);
			foreach (JToken item2 in jArray)
			{
				string item = (string)item2;
				sm_botsDisabledVersions.Add(item);
			}
		}

		public static IReadOnlyDictionary<int, ExperienceTableObject> GetExperienceTable()
		{
			return sm_experienceTable;
		}

		public static ExperienceTableObject GetExperienceTableEntry(int level)
		{
			if (sm_experienceTable.IsNullOrEmpty())
			{
				WandsLogger.LogError("Could not get experience table entry");
				return null;
			}
			int key = ((!sm_experienceTable.ContainsKey(level)) ? sm_experienceTable.Max((KeyValuePair<int, ExperienceTableObject> p) => p.Key) : level);
			return sm_experienceTable[key];
		}

		public static MatchRewardsObject GetMatchRewardEntry(MatchRewardType type)
		{
			if (!sm_matchRewards.ContainsKey(type))
			{
				WandsLogger.LogError("Could not get match reward entry for type " + type);
				return null;
			}
			return sm_matchRewards[type];
		}

		public static int GetMatchmakingTicketTimeout(string queueName)
		{
			if (!sm_matchmakingTicketsTimeout.ContainsKey(queueName))
			{
				WandsLogger.LogError("Could not get matchmaking ticket timeout for queue " + queueName + ". Returning default " + 300);
				return 300;
			}
			return sm_matchmakingTicketsTimeout[queueName];
		}

		public static bool GetBotsEnabled()
		{
			return !sm_botsDisabledVersions.Contains(GameControl.Instance.PlatformSettings.ClientVersion);
		}
	}
}
public abstract class PunSingleton<T> : MonoBehaviourPun where T : PunSingleton<T>
{
	protected static T sm_instance;

	public static T Instance
	{
		[CompilerGenerated]
		get
		{
			return (!(sm_instance != null)) ? ((T)null) : sm_instance;
		}
	}

	protected virtual void Awake()
	{
		if (sm_instance == null || sm_instance != this)
		{
			sm_instance = this as T;
		}
	}

	protected virtual void OnDisable()
	{
		sm_instance = (T)null;
	}
}
namespace CompleteProject
{
	public class Purchaser : MonoBehaviour, IStoreListener
	{
		private static IStoreController m_StoreController;

		private static IExtensionProvider m_StoreExtensionProvider;

		public static string kProductIDConsumable = "consumable";

		public static string kProductIDNonConsumable = "nonconsumable";

		public static string kProductIDSubscription = "subscription";

		private static string kProductNameAppleSubscription = "com.unity3d.subscription.new";

		private static string kProductNameGooglePlaySubscription = "com.unity3d.subscription.original";

		private void Start()
		{
			if (m_StoreController == null)
			{
				InitializePurchasing();
			}
		}

		public void InitializePurchasing()
		{
			if (!IsInitialized())
			{
				ConfigurationBuilder configurationBuilder = ConfigurationBuilder.Instance(StandardPurchasingModule.Instance());
				configurationBuilder.AddProduct(kProductIDConsumable, ProductType.Consumable);
				configurationBuilder.AddProduct(kProductIDNonConsumable, ProductType.NonConsumable);
				configurationBuilder.AddProduct(kProductIDSubscription, ProductType.Subscription, new IDs
				{
					{ kProductNameAppleSubscription, "AppleAppStore" },
					{ kProductNameGooglePlaySubscription, "GooglePlay" }
				});
				UnityPurchasing.Initialize(this, configurationBuilder);
			}
		}

		private bool IsInitialized()
		{
			return m_StoreController != null && m_StoreExtensionProvider != null;
		}

		public void BuyConsumable()
		{
			BuyProductID(kProductIDConsumable);
		}

		public void BuyNonConsumable()
		{
			BuyProductID(kProductIDNonConsumable);
		}

		public void BuySubscription()
		{
			BuyProductID(kProductIDSubscription);
		}

		private void BuyProductID(string productId)
		{
			if (IsInitialized())
			{
				UnityEngine.Purchasing.Product product = m_StoreController.products.WithID(productId);
				if (product != null && product.availableToPurchase)
				{
					GameControl.PrintDebug($"Purchasing product asychronously: '{product.definition.id}'");
					m_StoreController.InitiatePurchase(product);
				}
				else
				{
					GameControl.PrintDebug("BuyProductID: FAIL. Not purchasing product, either is not found or is not available for purchase");
				}
			}
			else
			{
				GameControl.PrintDebug("BuyProductID FAIL. Not initialized.");
			}
		}

		public void RestorePurchases()
		{
			if (!IsInitialized())
			{
				GameControl.PrintDebug("RestorePurchases FAIL. Not initialized.");
			}
			else if (UnityEngine.Application.platform == RuntimePlatform.IPhonePlayer || UnityEngine.Application.platform == RuntimePlatform.OSXPlayer)
			{
				GameControl.PrintDebug("RestorePurchases started ...");
				IAppleExtensions extension = m_StoreExtensionProvider.GetExtension<IAppleExtensions>();
				extension.RestoreTransactions(delegate(bool result)
				{
					GameControl.PrintDebug("RestorePurchases continuing: " + result + ". If no further messages, no purchases available to restore.");
				});
			}
			else
			{
				GameControl.PrintDebug("RestorePurchases FAIL. Not supported on this platform. Current = " + UnityEngine.Application.platform);
			}
		}

		public void OnInitialized(IStoreController controller, IExtensionProvider extensions)
		{
			GameControl.PrintDebug("OnInitialized: PASS");
			m_StoreController = controller;
			m_StoreExtensionProvider = extensions;
		}

		public void OnInitializeFailed(InitializationFailureReason error)
		{
			GameControl.PrintDebug("OnInitializeFailed InitializationFailureReason:" + error);
		}

		public PurchaseProcessingResult ProcessPurchase(PurchaseEventArgs args)
		{
			if (string.Equals(args.purchasedProduct.definition.id, kProductIDConsumable, StringComparison.Ordinal))
			{
				GameControl.PrintDebug($"ProcessPurchase: PASS. Product: '{args.purchasedProduct.definition.id}'");
			}
			else if (string.Equals(args.purchasedProduct.definition.id, kProductIDNonConsumable, StringComparison.Ordinal))
			{
				GameControl.PrintDebug($"ProcessPurchase: PASS. Product: '{args.purchasedProduct.definition.id}'");
			}
			else if (string.Equals(args.purchasedProduct.definition.id, kProductIDSubscription, StringComparison.Ordinal))
			{
				GameControl.PrintDebug($"ProcessPurchase: PASS. Product: '{args.purchasedProduct.definition.id}'");
			}
			else
			{
				GameControl.PrintDebug($"ProcessPurchase: FAIL. Unrecognized product: '{args.purchasedProduct.definition.id}'");
			}
			return PurchaseProcessingResult.Complete;
		}

		public void OnPurchaseFailed(UnityEngine.Purchasing.Product product, PurchaseFailureReason failureReason)
		{
			GameControl.PrintDebug($"OnPurchaseFailed: FAIL. Product: '{product.definition.storeSpecificId}', PurchaseFailureReason: {failureReason}");
		}
	}
}
namespace Assets.Scripts.Relics
{
	public class LoadoutHandler : MonoBehaviour
	{
		private const float RelicFadeTime = 0.25f;

		[SerializeField]
		private GameObject m_holderObj;

		[SerializeField]
		private Transform[] m_wandSpawnTransforms = Array.Empty<Transform>();

		[Header("UI")]
		[SerializeField]
		private TMP_Text[] m_activeLoadoutTexts = Array.Empty<TMP_Text>();

		private IDictionary<WandType, WandHandler>[] m_wandHandlers;

		private IList<WandHandler> m_activeWandHandlers = new List<WandHandler>(2);

		private List<Relic> m_relics = new List<Relic>(4);

		private Sequence m_textTweenSequence;

		private EventToken m_enterPreMatchEventToken;

		private EventToken m_enterPostMatchEventToken;

		private EventToken m_finalCountdownStartedEventToken;

		private void OnEnable()
		{
			m_enterPreMatchEventToken = EventHub.Subscribe<Events.EnterPreMatchEvent>(OnEnterPreMatch);
			m_enterPostMatchEventToken = EventHub.Subscribe<Events.EnterPostMatchEvent>(OnEnterPostMatch);
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe<Events.EnterPreMatchEvent>(m_enterPreMatchEventToken);
			EventHub.Unsubscribe<Events.EnterPostMatchEvent>(m_enterPostMatchEventToken);
		}

		private void Awake()
		{
			m_textTweenSequence = DOTween.Sequence();
			int num = ((!GameControl.Instance.IsDualWieldSupportedAndActive) ? 1 : 2);
			LoadLoadoutWands(num);
			if (num == 1)
			{
				m_activeLoadoutTexts[0].alignment = TextAlignmentOptions.Center;
			}
		}

		private void LoadLoadoutWands(int wandsPerLoadout)
		{
			if (GameControl.Instance.Player == null)
			{
				return;
			}
			Loadout[] unlockedLoadouts = GameControl.Instance.Player.GetUnlockedLoadouts();
			m_wandHandlers = new IDictionary<WandType, WandHandler>[wandsPerLoadout];
			for (int i = 0; i < wandsPerLoadout; i++)
			{
				m_wandHandlers[i] = new Dictionary<WandType, WandHandler>(unlockedLoadouts.Length);
			}
			for (int j = 0; j < unlockedLoadouts.Length; j++)
			{
				WandType[] loadoutWands = GameControl.Instance.Player.GetLoadoutWands(j);
				for (int k = 0; k < wandsPerLoadout; k++)
				{
					WandType wandType = loadoutWands[k];
					IDictionary<WandType, WandHandler> dictionary = m_wandHandlers[k];
					if (dictionary.TryGetValue(wandType, out var value))
					{
						if (GameControl.Instance.Player.ActiveLoadoutIndex == j && !m_activeWandHandlers.Contains(value))
						{
							m_activeWandHandlers.Add(value);
							value.gameObject.SetActive(value: true);
						}
						continue;
					}
					value = UnityEngine.Object.Instantiate(Resources.Load<WandHandler>($"Wands/{wandType}"), m_wandSpawnTransforms[k]);
					value.InitializeInLobby();
					dictionary.Add(wandType, value);
					if (GameControl.Instance.Player.ActiveLoadoutIndex == j)
					{
						m_activeWandHandlers.Add(value);
					}
					else
					{
						value.gameObject.SetActive(value: false);
					}
				}
			}
		}

		private void InitializeWand()
		{
			if (m_activeWandHandlers.IsNullOrEmpty())
			{
				WandsLogger.LogError("Couldn't instantiate wand object.");
			}
			else
			{
				AssignRelicIcons();
			}
		}

		public void ResetPreview(int loadoutIndex)
		{
			if (GameControl.Instance.Player.ActiveLoadoutIndex != loadoutIndex)
			{
				PreviewLoadout(GameControl.Instance.Player.ActiveLoadout.Spells.Skip(1).ToArray());
			}
			EnableLoadoutText();
		}

		public void PreviewLoadout(Spell[] loadout)
		{
			EnableLoadoutText();
			if (m_activeWandHandlers.Count == 1)
			{
				if (loadout.IsNullOrEmpty() || loadout.Contains(Spell.None))
				{
					SetLoadoutText(null);
				}
				else
				{
					SetLoadoutText(loadout.Reverse().ToArray());
				}
				return;
			}
			bool flag = loadout.IsNullOrEmpty() || loadout.Contains(Spell.None);
			for (int i = 0; i < m_activeWandHandlers.Count; i++)
			{
				if (flag)
				{
					SetLoadoutText(null, i);
					continue;
				}
				Spell[] loadout2 = ((i <= 0) ? loadout.Skip(2).Reverse() : loadout.Reverse().Skip(2)).ToArray();
				SetLoadoutText(loadout2, i);
			}
		}

		private void EnableLoadoutText()
		{
			for (int i = 0; i < m_activeLoadoutTexts.Length; i++)
			{
				m_activeLoadoutTexts[i].DOKill();
				Color color = m_activeLoadoutTexts[i].color;
				color.a = 1f;
				m_activeLoadoutTexts[i].color = color;
			}
		}

		private void DisableLoadoutText()
		{
			for (int i = 0; i < m_activeLoadoutTexts.Length; i++)
			{
				m_activeLoadoutTexts[i].DOKill();
				m_textTweenSequence.Insert(0f, m_activeLoadoutTexts[i].DOFade(0f, 0.25f).SetDelay(2f));
			}
			m_textTweenSequence.Play();
		}

		public void ChangeLoadout(int loadoutIndex, Spell[] spells)
		{
			if (spells.IsNullOrEmpty() || spells.Contains(Spell.None) || GameControl.Instance.Player.ActiveLoadoutIndex == loadoutIndex)
			{
				return;
			}
			m_activeWandHandlers.Clear();
			WandType[] loadoutWands = GameControl.Instance.Player.GetLoadoutWands(loadoutIndex);
			for (int i = 0; i < m_wandHandlers.Length; i++)
			{
				WandType wandType = loadoutWands[i];
				WandHandler[] array = m_wandHandlers[i].Values.ToArray();
				foreach (WandHandler wandHandler in array)
				{
					if (wandHandler.Type == wandType)
					{
						wandHandler.gameObject.SetActive(value: true);
						m_activeWandHandlers.Add(wandHandler);
					}
					else
					{
						wandHandler.gameObject.SetActive(value: false);
					}
				}
			}
			GameControl.Instance.Player.SetActiveLoadoutIndex(loadoutIndex);
			AssignRelicIcons();
		}

		private void AssignRelicIcons()
		{
			m_relics.Clear();
			Spell[] array = (GameControl.Instance.Player?.GetCurrentLoadoutSpells() ?? Constants.DefaultSpells.ToArray()).Skip(1).ToArray();
			if (m_activeWandHandlers.Count > 1)
			{
				for (int i = 0; i < m_activeWandHandlers.Count; i++)
				{
					Spell[] array2 = ((i <= 0) ? array.Skip(2) : array.Reverse().Skip(2).Reverse()).ToArray();
					m_relics.AddRange(m_activeWandHandlers[i].UpdateLobbyLoadout(array2));
					SetLoadoutText(array2.Reverse().ToArray(), i);
				}
			}
			else
			{
				m_relics.AddRange(m_activeWandHandlers[0].UpdateLobbyLoadout(array));
				SetLoadoutText(array);
			}
			for (int j = 0; j < m_relics.Count; j++)
			{
				m_relics[j].FadeRelic(fadeIn: true, 0.25f, null);
			}
		}

		private void OnEnterPreMatch(Events.EnterPreMatchEvent eventData)
		{
			EnableWandSelection();
			EmptyLoadoutString();
			ResetPreview(GameControl.Instance.Player.ActiveLoadoutIndex);
			InitializeWand();
		}

		private void OnEnterPostMatch(Events.EnterPostMatchEvent eventData)
		{
			DisableWandSelection();
		}

		public void EnableWandSelection()
		{
			m_holderObj.SetActive(value: true);
		}

		public void DisableWandSelection()
		{
			m_holderObj.SetActive(value: false);
			EmptyLoadoutString();
		}

		private void EmptyLoadoutString()
		{
			for (int i = 0; i < m_activeLoadoutTexts.Length; i++)
			{
				m_activeLoadoutTexts[i].text = string.Empty;
			}
		}

		private void SetLoadoutText(Spell[] loadout, int index = 0)
		{
			if (loadout.IsNullOrEmpty())
			{
				m_activeLoadoutTexts[index].alignment = TextAlignmentOptions.Center;
				m_activeLoadoutTexts[index].text = ((index != 0) ? string.Empty : ScriptLocalization.Get("HUD/Lobby/WandUnlockMessage"));
			}
			else
			{
				m_activeLoadoutTexts[index].alignment = ((index != 0) ? TextAlignmentOptions.BottomLeft : TextAlignmentOptions.BottomRight);
				m_activeLoadoutTexts[index].text = GetLocalizedSpellList(loadout);
			}
		}

		private string GetLocalizedSpellList(Spell[] loadout)
		{
			string text = string.Empty;
			for (int i = 0; i < loadout.Length; i++)
			{
				Spell spell = loadout[i];
				if (spell != 0)
				{
					text += ScriptLocalization.Get($"Spells/Names/{spell.ToString().Substring(6)}");
					text += "\n";
				}
			}
			return text.TrimEnd();
		}
	}
	public class Relic : MonoBehaviour
	{
		[SerializeField]
		private ItemMaterialHandler m_materialHandler;

		[SerializeField]
		private Renderer m_renderer;

		[SerializeField]
		private SpriteRenderer m_spriteRenderer;

		private bool m_moveRelic;

		private bool m_moveLocal;

		private bool m_rotateLocal;

		private bool m_initialized;

		private float m_currentMoveTime;

		private float m_moveTime = 0.25f;

		private Vector3 m_originalPos = Vector3.zero;

		private Vector3 m_startPos;

		private Vector3 m_endPos;

		private Vector3 m_originalScale = Vector3.one;

		private Vector3 m_startScale;

		private Vector3 m_endScale;

		private Quaternion m_originalRot = Quaternion.identity;

		private Quaternion m_startRot;

		private Quaternion m_endRot;

		private Vector3 m_iconOriginalScale;

		private Vector3 m_iconOriginalPosition;

		private Quaternion m_iconOriginalRotation;

		public Transform IconTransform { get; private set; }

		public bool IsIconSpriteAssigned
		{
			[CompilerGenerated]
			get
			{
				return m_spriteRenderer.sprite != null;
			}
		}

		public bool IsFadedOut { get; private set; }

		public bool IsFadedIn { get; private set; } = true;


		private void OnDisable()
		{
			StopAllCoroutines();
		}

		private void Awake()
		{
			if (m_materialHandler != null)
			{
				m_materialHandler.AssignRenderers(new Renderer[1] { m_renderer });
			}
		}

		private void Start()
		{
			if (!m_initialized)
			{
				m_initialized = true;
				m_originalPos = base.transform.position;
				m_originalRot = base.transform.rotation;
				m_originalScale = base.transform.localScale;
			}
		}

		private void Update()
		{
			if (m_moveRelic)
			{
				MoveRelic();
			}
		}

		public void ToggleRelicRendererEnabled(bool enable)
		{
			m_renderer.enabled = enable;
		}

		private void MoveRelic()
		{
			m_currentMoveTime += Time.deltaTime;
			float num = Mathf.Clamp01(MathUtils.SmootherStep(m_currentMoveTime / m_moveTime));
			if (m_moveLocal)
			{
				base.transform.localPosition = Vector3.Lerp(m_startPos, m_endPos, num);
				base.transform.localScale = Vector3.Lerp(m_startScale, m_endScale, num);
			}
			else
			{
				base.transform.position = Vector3.Lerp(m_startPos, m_endPos, num);
				base.transform.localScale = Vector3.Lerp(m_startScale, m_endScale, num);
			}
			if (m_rotateLocal)
			{
				base.transform.localRotation = Quaternion.Lerp(m_startRot, m_endRot, num);
			}
			else
			{
				base.transform.rotation = Quaternion.Lerp(m_startRot, m_endRot, num);
			}
			if (Mathf.Approximately(num, 1f))
			{
				m_moveRelic = false;
				m_moveLocal = false;
			}
		}

		public void AssignIcon(Sprite sprite, bool enable)
		{
			if (sprite == null)
			{
				WandsLogger.LogError("Trying to assign null sprite to Relic");
				return;
			}
			if (m_spriteRenderer == null)
			{
				WandsLogger.LogError("Sprite renderer hasn't been set yet, check instantiation order for Relics");
				return;
			}
			m_spriteRenderer.sprite = sprite;
			IconTransform = m_spriteRenderer.transform;
			m_iconOriginalScale = IconTransform.localScale;
			m_iconOriginalPosition = IconTransform.localPosition;
			m_iconOriginalRotation = IconTransform.localRotation;
			SetHighlightEffectActive(enable);
		}

		public void ReturnIcon()
		{
			if (!(IconTransform == null))
			{
				IconTransform.SetParent(m_renderer.transform);
				IconTransform.localScale = m_iconOriginalScale;
				IconTransform.localPosition = m_iconOriginalPosition;
				IconTransform.localRotation = m_iconOriginalRotation;
			}
		}

		public void NullIcon()
		{
			if (!(IconTransform == null))
			{
				SetHighlightEffectActive(enable: false);
				IconTransform = null;
				NullSprite();
			}
		}

		private void NullSprite()
		{
			if (!(m_spriteRenderer == null))
			{
				m_spriteRenderer.sprite = null;
			}
		}

		public void SetIconMaterial(Material material)
		{
			if (m_spriteRenderer != null)
			{
				m_spriteRenderer.sharedMaterial = material;
			}
		}

		public void SetMaterial(ItemMaterialType type, bool highlighted = false)
		{
			if (GameControl.Instance.IsCurrentLevel(Level.Workshop) && m_materialHandler != null)
			{
				m_materialHandler.AssignMaterial(type, highlighted);
			}
		}

		public bool SetHighlightEffectActive(bool enable)
		{
			if (IconTransform == null)
			{
				return false;
			}
			IconTransform.gameObject.SetActive(enable);
			return true;
		}

		public void ResetPosition(bool hard = false)
		{
			if (hard)
			{
				m_moveRelic = false;
				base.transform.localPosition = Vector3.zero;
				base.transform.localRotation = Quaternion.identity;
				base.transform.localScale = Vector3.one;
			}
			else
			{
				if (!m_initialized)
				{
					Start();
				}
				TweakTransform(m_originalPos, m_originalRot, m_originalScale, 0.75f);
			}
		}

		public void TweakTransform(Vector3 newPos, Quaternion newRot, Vector3 newScale, float moveTime, bool local = false, bool rotLocal = false)
		{
			m_moveRelic = false;
			m_moveLocal = local;
			m_rotateLocal = rotLocal;
			if (moveTime > 0f)
			{
				m_currentMoveTime = 0f;
				m_startPos = ((!local) ? base.transform.position : base.transform.localPosition);
				m_endPos = newPos;
				m_startRot = ((!rotLocal) ? base.transform.rotation : base.transform.localRotation);
				m_endRot = newRot;
				m_startScale = base.transform.localScale;
				m_endScale = newScale;
				m_moveTime = moveTime;
				m_moveRelic = true;
			}
			else
			{
				if (local)
				{
					base.transform.localPosition = newPos;
				}
				else
				{
					base.transform.position = newPos;
				}
				if (rotLocal)
				{
					base.transform.localRotation = newRot;
				}
				else
				{
					base.transform.rotation = newRot;
				}
				base.transform.localScale = newScale;
			}
		}

		public void FadeRelic(bool fadeIn, float time, TweenCallback onComplete)
		{
			if (m_spriteRenderer == null || m_spriteRenderer.sprite == null)
			{
				return;
			}
			m_spriteRenderer.DOKill();
			float endValue = ((!fadeIn) ? 0f : 1f);
			IsFadedIn = false;
			IsFadedOut = false;
			m_spriteRenderer.material.DOFade(endValue, "_TintColor", time).OnComplete(delegate
			{
				onComplete?.Invoke();
				if (fadeIn)
				{
					IsFadedIn = true;
				}
				else
				{
					IsFadedOut = true;
				}
			});
		}
	}
	public class RelicSlotWand : MonoBehaviour
	{
		[SerializeField]
		private bool m_occupied;

		public bool IsOccupied
		{
			[CompilerGenerated]
			get
			{
				return m_occupied;
			}
		}

		public void SetOccupied(bool value)
		{
			m_occupied = value;
		}
	}
}
namespace Assets.Scripts.Reporting
{
	public struct OpponentData
	{
		public string Name;

		public string PlayFabId;

		public string PlatformId;

		public PlatformType PlatformType;

		public static OpponentData Default
		{
			[CompilerGenerated]
			get
			{
				OpponentData result = default(OpponentData);
				result.Name = "Default";
				result.PlayFabId = "-1";
				result.PlatformId = "-1";
				return result;
			}
		}
	}
	public static class OpponentHistory
	{
		private static Queue<OpponentData> m_opponents = new Queue<OpponentData>();

		public static void Register(string name, string playFabId, string platformId, PlatformType platformType)
		{
			m_opponents.Enqueue(new OpponentData
			{
				Name = name,
				PlayFabId = playFabId,
				PlatformId = platformId,
				PlatformType = platformType
			});
		}

		public static OpponentData GetLast()
		{
			return (!m_opponents.IsNullOrEmpty()) ? m_opponents.Peek() : OpponentData.Default;
		}

		public static IReadOnlyList<OpponentData> GetAllFromSession()
		{
			return m_opponents.ToList();
		}
	}
	public struct Report
	{
		[StructLayout(LayoutKind.Sequential, Size = 1)]
		private struct Constants
		{
			public const string ReportType = "Report reason";

			public const string Name = "Reported Player Name";

			public const string Id = "Reported Player Id";
		}

		public ReportType ReportType;

		public string PlayerName;

		public string PlayerId;

		public string PlatformId;

		public PlatformType PlatformType;

		public static implicit operator Dictionary<string, object>(Report report)
		{
			Dictionary<string, object> dictionary = new Dictionary<string, object>();
			dictionary.Add("Report reason", report.ReportType.ToString());
			dictionary.Add("Reported Player Name", report.PlayerName);
			dictionary.Add("Reported Player Id", report.PlayerId);
			return dictionary;
		}

		public void Dispatch()
		{
			ReportDispatcher.Dispatch(this);
		}
	}
	public class ReportDispatcher
	{
		private enum ReportState
		{
			NotReported,
			Reported
		}

		private static Dictionary<string, ReportState[]> sm_reportMap = new Dictionary<string, ReportState[]>();

		public static void Dispatch(Report report)
		{
			if (RegisterReport(report) == ReportState.NotReported)
			{
				WandsAnalytics.SendCustomEvent(CustomEventType.player_reported, report);
			}
		}

		private static ReportState RegisterReport(Report report)
		{
			if (!sm_reportMap.ContainsKey(report.PlayerId))
			{
				sm_reportMap.Add(report.PlayerId, new ReportState[Enum.GetValues(typeof(ReportType)).Length]);
			}
			if (sm_reportMap[report.PlayerId][(int)report.ReportType] == ReportState.NotReported)
			{
				sm_reportMap[report.PlayerId][(int)report.ReportType] = ReportState.Reported;
				return ReportState.NotReported;
			}
			return ReportState.Reported;
		}
	}
	public enum ReportType
	{
		Harrassment,
		Cheating,
		OffensiveName
	}
}
namespace Assets.Scripts.SaveLoad.Converters
{
	public class AchievementDataParser : IDataParser
	{
		public ParseState Parse(IDictionary<string, UserDataRecord> data)
		{
			if (data.TryGetValue("AchievementData", out var value))
			{
				try
				{
					PlayerAchievementCollectionData achievementData = JsonConvert.DeserializeObject<PlayerAchievementCollectionData>(value.Value);
					GameControl.Instance.Player.SaveData.AchievementData = achievementData;
					return ParseState.Success;
				}
				catch (Exception ex)
				{
					WandsLogger.LogError(string.Format("Exception caught while parsing {0}: {1}", "AchievementData", ex.Message));
					return ParseState.Exception;
				}
			}
			return ParseState.Failure;
		}
	}
	public class ClientVersionParser : IDataParser
	{
		public ParseState Parse(IDictionary<string, UserDataRecord> data)
		{
			if (data.TryGetValue("ClientVersion", out var value))
			{
				try
				{
					Version version = Version.Parse(GameControl.Instance.PlayfabClientVersion);
					Version obj = Version.Parse(value.Value);
					if (version.Equals(obj))
					{
						return ParseState.Success;
					}
				}
				catch (Exception ex)
				{
					WandsLogger.LogError(string.Format("Exception caught while parsing {0}: {1}", "ClientVersion", ex.Message));
					return ParseState.Exception;
				}
			}
			return ParseState.Failure;
		}
	}
	public class CompletedTutorialParser : IDataParser
	{
		public ParseState Parse(IDictionary<string, UserDataRecord> data)
		{
			if (data.TryGetValue("CompletedTutorial", out var value))
			{
				try
				{
					if (bool.Parse(value.Value))
					{
						GameControl.Instance.Player.SaveData.CompletedTutorial = true;
						GameControl.Instance.Player.TutorialState = TutorialState.Completed;
					}
					else
					{
						GameControl.Instance.Player.VerifyTutorialState();
					}
					return ParseState.Success;
				}
				catch (Exception ex)
				{
					WandsLogger.LogError(string.Format("Exception caught while parsing {0}: {1}", "CompletedTutorial", ex.Message));
					return ParseState.Exception;
				}
			}
			return ParseState.Failure;
		}
	}
	public class ConversionResult
	{
		public int Dust;

		public List<Title> Titles = new List<Title>();

		public override string ToString()
		{
			return $"DUST: {Dust} and TITLES: {Titles.ToFormattedString()}";
		}
	}
	public class GameAccessParser : IDataParser
	{
		public ParseState Parse(IDictionary<string, UserDataRecord> data)
		{
			if (data.TryGetValue("GameAccess", out var value))
			{
				try
				{
					GameAccess gameAccess = (GameAccess)Enum.Parse(typeof(GameAccess), value.Value);
					GameControl.Instance.Player.SaveData.GameAccess = gameAccess;
					return ParseState.Success;
				}
				catch (Exception ex)
				{
					WandsLogger.LogError(string.Format("Exception caught while parsing {0}: {1}", "GameAccess", ex.Message));
					return ParseState.Exception;
				}
			}
			GameControl.Instance.Player.SaveData.GameAccess = GameAccess.Full;
			return ParseState.Failure;
		}
	}
	public interface IDataParser
	{
		ParseState Parse(IDictionary<string, UserDataRecord> data);
	}
	public class LevelDataParser : IDataParser
	{
		public ParseState Parse(IDictionary<string, UserDataRecord> data)
		{
			if (data.TryGetValue("LevelData", out var value))
			{
				try
				{
					PlayerLevelData playerLevelData = JsonConvert.DeserializeObject<PlayerLevelData>(value.Value);
					GameControl.Instance.Player.SaveData.LevelData = playerLevelData;
					PlayerProperty.Set("PL", playerLevelData.Level);
					return ParseState.Success;
				}
				catch (Exception ex)
				{
					WandsLogger.LogError(string.Format("Exception caught while parsing {0}: {1}", "LevelData", ex.Message));
					return ParseState.Exception;
				}
			}
			return ParseState.Failure;
		}
	}
	public class LoadoutsParser : IDataParser
	{
		public ParseState Parse(IDictionary<string, UserDataRecord> data)
		{
			if (data.TryGetValue("Loadouts", out var value))
			{
				try
				{
					Loadout[] loadouts = JsonConvert.DeserializeObject<Loadout[]>(value.Value);
					GameControl.Instance.Player.SaveData.Loadouts = loadouts;
					GameControl.Instance.Player.SetActiveLoadoutIndex(0);
					return ParseState.Success;
				}
				catch (Exception ex)
				{
					WandsLogger.LogError(string.Format("Exception caught while parsing {0}: {1}", "Loadouts", ex.Message));
					return ParseState.Exception;
				}
			}
			return ParseState.Failure;
		}
	}
	public class LootCachesParser : IDataParser
	{
		public ParseState Parse(IDictionary<string, UserDataRecord> data)
		{
			if (data.TryGetValue("LootCaches", out var value))
			{
				try
				{
					JArray token = JArray.Parse(value.Value);
					ConversionResult conversionResult = ConvertLootCaches(token);
					GameControl.Instance.Player.AddVirtualCurrency(conversionResult.Dust, VirtualCurrencySource.Conversion);
					return ParseState.Failure;
				}
				catch (Exception ex)
				{
					WandsLogger.LogError(string.Format("Exception caught while parsing {0}: {1}", "LootCaches", ex.Message));
					return ParseState.Exception;
				}
			}
			return ParseState.Success;
		}

		private ConversionResult ConvertLootCaches(JToken token)
		{
			ConversionResult conversionResult = new ConversionResult();
			if (token != null)
			{
				List<Legacy_LootCacheType> list = token.ToObject<List<Legacy_LootCacheType>>();
				foreach (Legacy_LootCacheType item in list)
				{
					if (WandsDatabase.LegacyItems.LootCaches.ContainsKey(item))
					{
						int num = WandsDatabase.LegacyItems.LootCaches[item];
						conversionResult.Dust += num;
					}
				}
			}
			return conversionResult;
		}
	}
	public class MatchDataParser : IDataParser
	{
		public ParseState Parse(IDictionary<string, UserDataRecord> data)
		{
			if (data.TryGetValue("MatchData", out var value))
			{
				try
				{
					PlayerMatchData matchData = JsonConvert.DeserializeObject<PlayerMatchData>(value.Value);
					GameControl.Instance.Player.SaveData.MatchData = matchData;
					return ParseState.Success;
				}
				catch (Exception ex)
				{
					WandsLogger.LogError(string.Format("Exception caught while parsing {0}: {1}", "MatchData", ex.Message));
					return ParseState.Exception;
				}
			}
			return ParseState.Failure;
		}
	}
	public class UnlockedDataParser : IDataParser
	{
		public ParseState Parse(IDictionary<string, UserDataRecord> data)
		{
			UserDataRecord value2;
			if (data.TryGetValue("UnlockedData", out var value))
			{
				try
				{
					if (!data.TryGetValue("ClientVersion", out value2))
					{
						WandsLogger.LogError(string.Format("Exception caught while parsing {0}: {1} was not present in the save data.", "UnlockedData", "ClientVersion"));
						return ParseState.Exception;
					}
					JObject jObject = JObject.Parse(value.Value);
					if (Version.Parse(value2.Value) < new Version("1.4.0"))
					{
						PlayerUtils.ConvertItemsToDust(jObject);
						JToken jToken = jObject["UnlockedSpells"];
						GameControl.Instance.Player.TryAddSpellsToInventory(jToken.ToObject<List<Spell>>(), saveToServer: true);
						return ParseState.Failure;
					}
					if (Version.Parse(value2.Value) == new Version("1.4.0"))
					{
						List<CharacterType> characterTypes = jObject["UnlockedCharacters"].ToObject<List<CharacterType>>();
						GameControl.Instance.Player.TryAddCharactersToInventory(characterTypes, saveToServer: true);
						List<WandType> wandTypes = jObject["UnlockedWands"].ToObject<List<WandType>>();
						GameControl.Instance.Player.TryAddWandsToInventory(wandTypes, saveToServer: true);
						List<Title> titles = jObject["UnlockedTitles"].ToObject<List<Title>>();
						GameControl.Instance.Player.TryAddTitlesToInventory(titles, saveToServer: true);
						List<Spell> spells = jObject["UnlockedSpells"].ToObject<List<Spell>>();
						GameControl.Instance.Player.TryAddSpellsToInventory(spells, saveToServer: true);
						return ParseState.Success;
					}
					return ParseState.Success;
				}
				catch (Exception ex)
				{
					WandsLogger.LogError(string.Format("Exception caught while parsing {0}: {1}", "UnlockedData", ex.Message));
					return ParseState.Exception;
				}
			}
			if (data.TryGetValue("ClientVersion", out value2) && Version.Parse(value2.Value) > new Version("1.4.0"))
			{
				return ParseState.Success;
			}
			try
			{
				PlayerUtils.ConvertItemsToDust(data);
				JArray jArray = JArray.Parse(data["UnlockedSpells"].Value);
				GameControl.Instance.Player.TryAddSpellsToInventory(jArray.ToObject<List<Spell>>(), saveToServer: true);
				return ParseState.Failure;
			}
			catch (Exception ex2)
			{
				WandsLogger.LogError(string.Format("Exception caught while parsing {0}: {1}", "UnlockedData", ex2.Message));
				return ParseState.Exception;
			}
		}
	}
	public class VirtualCurrencyParser : IDataParser
	{
		public ParseState Parse(IDictionary<string, UserDataRecord> data)
		{
			if (data.TryGetValue("VirtualCurrency", out var value))
			{
				try
				{
					int amount = int.Parse(value.Value);
					GameControl.Instance.Player.AddVirtualCurrency(amount, VirtualCurrencySource.Conversion);
					return ParseState.Success;
				}
				catch (Exception ex)
				{
					WandsLogger.LogError(string.Format("Exception caught while parsing {0}: {1}", "VirtualCurrency", ex.Message));
					return ParseState.Exception;
				}
			}
			return ParseState.Failure;
		}
	}
}
namespace Assets.Scripts.SaveLoad
{
	public interface ISaveManager
	{
		void SavePlayerData(Action<ExecuteCloudScriptResult> success = null, Action<string> failure = null);

		void SaveExperienceRewards(SaveDataObject data, Action<ExecuteCloudScriptResult> success = null, Action<string> failure = null);

		void SaveItemsToInventory(InventorySaveObject inventorySaveObject, Action<ExecuteCloudScriptResult> success = null, Action<string> failure = null);

		void SaveUnlockedData(SaveDataObject data, PlayFabRequestType requestType, Action<ExecuteCloudScriptResult> success = null, Action<string> failure = null);

		void SaveGameAccess(SaveDataObject data, Action<ExecuteCloudScriptResult> success = null, Action<string> failure = null);

		void SaveCompletedTutorial(SaveDataObject data, Action<ExecuteCloudScriptResult> success = null, Action<string> failure = null);

		void SaveLoadouts(SaveDataObject data, Action<ExecuteCloudScriptResult> success = null, Action<string> failure = null);

		void SaveCustomEventRewards(SaveDataObject data, Action<ExecuteCloudScriptResult> success = null, Action<string> failure = null);

		void SaveMatchData(SaveDataObject data, Action<ExecuteCloudScriptResult> success = null, Action<string> failure = null);

		void SaveAchievementData(SaveDataObject data, Action<ExecuteCloudScriptResult> success = null, Action<string> failure = null);

		void SaveStatistics(PlayFabStatisticsField field, int value, Action<ExecuteCloudScriptResult> success = null, Action<string> failure = null);

		void SaveUserName(string userName, Action<UpdateUserTitleDisplayNameResult> success = null, Action<string> failure = null);

		void LoadUserInventory(Action<ExecuteCloudScriptResult> success = null, Action<string> failure = null);

		void LoadData(PlayFabSaveField saveField, Action<GetUserDataResult> success = null, Action<string> failure = null);

		void LoadPlayerStatistics(PlayFabStatisticsField field, Action<GetPlayerStatisticsResult> success = null, Action<string> failure = null);

		void LoadTitleData(Action<GetTitleDataResult> success = null, Action<string> failure = null);
	}
	public enum PlayFabSaveField
	{
		ClientVersion,
		LevelData,
		Loadouts,
		LootCaches,
		MatchData,
		UnlockedData,
		UnlockedMasks,
		UnlockedOutfits,
		UnlockedCharacters,
		UnlockedWands,
		UnlockedSpells,
		UnlockedTitles,
		VirtualCurrency,
		IsMigrated,
		IsDeveloper,
		GameAccess,
		CompletedTutorial,
		AchievementData
	}
	public enum PlayFabStatisticsField
	{
		Rating,
		HighestRating,
		SeasonScore,
		SeasonScorePlayStation
	}
	public class SaveManager : ISaveManager
	{
		private readonly ICloudManager m_cloudManager;

		public SaveManager(ICloudManager cloudmanager)
		{
			m_cloudManager = cloudmanager;
		}

		public void SavePlayerData(Action<ExecuteCloudScriptResult> success = null, Action<string> failure = null)
		{
			if (!GameControl.Instance.Player.IsLoggedInToPlatform)
			{
				WandsLogger.LogError("Player is not logged in to the platform");
				return;
			}
			SaveDataObject saveDataObject = GameControl.Instance.Player.CreateFullSaveDataObject();
			m_cloudManager.SaveAllData(saveDataObject.GetCollection(), success, failure);
		}

		public void SaveExperienceRewards(SaveDataObject data, Action<ExecuteCloudScriptResult> success = null, Action<string> failure = null)
		{
			if (!GameControl.Instance.Player.IsLoggedInToPlatform)
			{
				WandsLogger.LogError("Player is not logged in to the platform");
			}
			else
			{
				m_cloudManager.SaveExperienceRewards(data.GetCollection(), success, failure);
			}
		}

		public void SaveItemsToInventory(InventorySaveObject inventorySaveObject, Action<ExecuteCloudScriptResult> success = null, Action<string> failure = null)
		{
			if (!GameControl.Instance.Player.IsLoggedInToPlatform)
			{
				WandsLogger.LogError("Player is not logged in to the platform");
			}
			else
			{
				m_cloudManager.SaveItemsToInventory(inventorySaveObject, success, failure);
			}
		}

		public void SaveItemsToInventory(InventorySaveObject[] inventorySaveObjects, Action<ExecuteCloudScriptResult> success = null, Action<string> failure = null)
		{
			if (!GameControl.Instance.Player.IsLoggedInToPlatform)
			{
				WandsLogger.LogError("Player is not logged in to the platform");
			}
			else
			{
				m_cloudManager.SaveItemsToInventory(inventorySaveObjects, success, failure);
			}
		}

		public void SaveUnlockedData(SaveDataObject data, PlayFabRequestType requestType, Action<ExecuteCloudScriptResult> success = null, Action<string> failure = null)
		{
			if (!GameControl.Instance.Player.IsLoggedInToPlatform)
			{
				WandsLogger.LogError("Player is not logged in to the platform");
			}
			else
			{
				m_cloudManager.SaveUnlockedData(data.GetCollection(), requestType, success, failure);
			}
		}

		public void SaveGameAccess(SaveDataObject data, Action<ExecuteCloudScriptResult> success = null, Action<string> failure = null)
		{
			if (!GameControl.Instance.Player.IsLoggedInToPlatform)
			{
				WandsLogger.LogError("Player is not logged in to the platform");
			}
			else
			{
				m_cloudManager.SaveGameAccess(data.GetCollection(), success, failure);
			}
		}

		public void SaveCompletedTutorial(SaveDataObject data, Action<ExecuteCloudScriptResult> success = null, Action<string> failure = null)
		{
			if (!GameControl.Instance.Player.IsLoggedInToPlatform)
			{
				WandsLogger.LogError("Player is not logged in to the platform");
			}
			else
			{
				m_cloudManager.SaveCompletedTutorial(data.GetCollection(), success, failure);
			}
		}

		public void SaveLoadouts(SaveDataObject data, Action<ExecuteCloudScriptResult> success = null, Action<string> failure = null)
		{
			if (!GameControl.Instance.Player.IsLoggedInToPlatform)
			{
				WandsLogger.LogError("Player is not logged in to the platform");
			}
			else
			{
				m_cloudManager.SaveLoadouts(data.GetCollection(), success, failure);
			}
		}

		public void SaveCustomEventRewards(SaveDataObject data, Action<ExecuteCloudScriptResult> success = null, Action<string> failure = null)
		{
			if (!GameControl.Instance.Player.IsLoggedInToPlatform)
			{
				WandsLogger.LogError("Player is not logged in to the platform");
			}
			else
			{
				m_cloudManager.SaveCustomEventRewards(data.GetCollection(), success, failure);
			}
		}

		public void SaveMatchData(SaveDataObject data, Action<ExecuteCloudScriptResult> success = null, Action<string> failure = null)
		{
			if (!GameControl.Instance.Player.IsLoggedInToPlatform)
			{
				WandsLogger.LogError("Player is not logged in to the platform");
			}
			else
			{
				m_cloudManager.SaveMatchData(data.GetCollection(), success, failure);
			}
		}

		public void SaveAchievementData(SaveDataObject data, Action<ExecuteCloudScriptResult> success = null, Action<string> failure = null)
		{
			if (!GameControl.Instance.Player.IsLoggedInToPlatform)
			{
				WandsLogger.LogError("Player is not logged in to the platform");
			}
			else
			{
				m_cloudManager.SaveAchievementData(data.GetCollection(), success, failure);
			}
		}

		public void SaveStatistics(PlayFabStatisticsField field, int value, Action<ExecuteCloudScriptResult> success = null, Action<string> failure = null)
		{
			if (!GameControl.Instance.Player.IsLoggedInToPlatform)
			{
				WandsLogger.LogError("Player is not logged in to the platform");
				return;
			}
			switch (field)
			{
			case PlayFabStatisticsField.Rating:
			{
				Dictionary<string, string> dictionary = new Dictionary<string, string>();
				dictionary.Add("Rating", value.ToString());
				dictionary.Add("HighestRating", value.ToString());
				Dictionary<string, string> fields = dictionary;
				m_cloudManager.UpdatePlayerStatistics(fields, PlayFabStatisticsField.Rating, success, failure);
				break;
			}
			case PlayFabStatisticsField.SeasonScore:
			case PlayFabStatisticsField.SeasonScorePlayStation:
			{
				Dictionary<string, string> dictionary = new Dictionary<string, string>();
				dictionary.Add("SeasonScore", value.ToString());
				Dictionary<string, string> dictionary2 = dictionary;
				if (GameControl.Instance.Platform.Type == PlatformType.PlayStation)
				{
					dictionary2.Add("SeasonScorePlayStation", value.ToString());
				}
				m_cloudManager.UpdatePlayerStatistics(dictionary2, PlayFabStatisticsField.SeasonScore, success, failure);
				break;
			}
			default:
				throw new NotImplementedException("PlayFabStatisticsField not implemented: " + field);
			}
		}

		public void SaveUserName(string userName, Action<UpdateUserTitleDisplayNameResult> success = null, Action<string> failure = null)
		{
			if (!GameControl.Instance.Player.IsLoggedInToPlatform)
			{
				WandsLogger.LogError("Player is not logged in to the platform");
			}
			else
			{
				m_cloudManager.UpdateUserDisplayName(userName, success, failure);
			}
		}

		public void LoadData(PlayFabSaveField saveField, Action<GetUserDataResult> success = null, Action<string> failure = null)
		{
			if (!GameControl.Instance.Player.IsLoggedInToPlatform)
			{
				WandsLogger.LogError("Player is not logged in to the platform");
				return;
			}
			m_cloudManager.GetUserData(new List<string> { saveField.ToString() }, success, failure);
		}

		public void LoadUserInventory(Action<ExecuteCloudScriptResult> success = null, Action<string> failure = null)
		{
			if (!GameControl.Instance.Player.IsLoggedInToPlatform)
			{
				WandsLogger.LogError("Player is not logged in to the platform");
			}
			else
			{
				m_cloudManager.GetUserInventory(success, failure);
			}
		}

		public void LoadPlayerStatistics(PlayFabStatisticsField field, Action<GetPlayerStatisticsResult> success = null, Action<string> failure = null)
		{
			if (!GameControl.Instance.Player.IsLoggedInToPlatform)
			{
				WandsLogger.LogError("Player is not logged in to the platform");
			}
			else
			{
				m_cloudManager.GetPlayerStatistics(field, success, failure);
			}
		}

		public void LoadTitleData(Action<GetTitleDataResult> success = null, Action<string> failure = null)
		{
			if (!GameControl.Instance.Player.IsLoggedInToPlatform)
			{
				WandsLogger.LogError("Player is not logged in to the platform");
			}
			else
			{
				m_cloudManager.GetTitleData(success, failure);
			}
		}
	}
}
namespace Assets.Scripts
{
	public class SceneControl : PunSingleton<SceneControl>
	{
		private const int CountdownStartDelay = 1000;

		private const float MatchResetDelay = 1f;

		private const float BeforeCountdownFadeTime = 0.75f;

		private const float BeforeCountdownFadeWaitTime = 0.25f;

		[SerializeField]
		private CountdownHandler m_countdownHandler;

		private Coroutine m_awaitOpponentCoroutine;

		private bool m_suddenDeath;

		private bool m_matchStarted;

		private bool m_pendingGameOver;

		private bool m_gameOver;

		private bool m_resetting;

		private bool m_isRematch;

		private int m_winnerViewID;

		private TeleportShimmer m_teleportSfx;

		private MatchType? m_currentMatchType;

		private Arena m_currentLevel;

		private Transform m_relicIconParent;

		private Action m_onBeforeEnterLobby;

		private EventToken m_countdownEndedEventToken;

		private EventToken m_wielderSpawnedEventToken;

		private EventToken m_photonPlayerConnectedEventToken;

		private EventToken m_photonPlayerDisconnectedEventToken;

		public bool MatchStarted
		{
			get
			{
				if (NetworkUtils.ConnectedToGame)
				{
					return (bool)RoomProperty.GetRoomProperty("A6");
				}
				return m_matchStarted;
			}
			set
			{
				if (NetworkUtils.ConnectedToGame)
				{
					RoomProperty.SetRoomProperty("A6", value);
				}
				else
				{
					m_matchStarted = value;
				}
			}
		}

		public CountdownHandler CountdownHandler
		{
			[CompilerGenerated]
			get
			{
				return m_countdownHandler;
			}
		}

		public MatchType CurrentMatchType
		{
			get
			{
				if (!m_currentMatchType.HasValue)
				{
					m_currentMatchType = RoomProperty.GetMatchType();
				}
				return m_currentMatchType.Value;
			}
		}

		public Arena CurrentLevel
		{
			get
			{
				if (m_currentLevel == Arena.None)
				{
					Arena result;
					if (NetworkUtils.ConnectedToGame)
					{
						m_currentLevel = (Arena)Enum.Parse(typeof(Arena), (string)RoomProperty.GetRoomProperty("A2"));
					}
					else if (Enum.TryParse<Arena>(SceneManager.GetActiveScene().name, out result))
					{
						m_currentLevel = result;
					}
				}
				return m_currentLevel;
			}
		}

		public Transform RelicIconParent
		{
			[CompilerGenerated]
			get
			{
				return (!(m_relicIconParent != null)) ? (m_relicIconParent = base.transform.RetrieveChild("Relic_Icons")) : m_relicIconParent;
			}
		}

		public TeleportShimmer TeleportSfx
		{
			[CompilerGenerated]
			get
			{
				return (!(m_teleportSfx != null)) ? (m_teleportSfx = GetComponentInChildren<TeleportShimmer>()) : m_teleportSfx;
			}
		}

		public bool GameOver
		{
			[CompilerGenerated]
			get
			{
				return m_gameOver || m_pendingGameOver;
			}
		}

		private void OnEnable()
		{
			m_photonPlayerConnectedEventToken = EventHub.Subscribe<NetworkEvents.PhotonPlayerConnectedEvent>(OnPhotonPlayerConnected);
			m_photonPlayerDisconnectedEventToken = EventHub.Subscribe<NetworkEvents.PhotonPlayerDisconnectedEvent>(OnPhotonPlayerDisconnected);
			m_countdownEndedEventToken = EventHub.Subscribe<Events.CountdownEndedEvent>(OnCountdownEnded);
			m_wielderSpawnedEventToken = EventHub.Subscribe<Events.WielderSpawnedEvent>(OnWielderSpawned);
		}

		protected override void OnDisable()
		{
			base.OnDisable();
			CancelInvoke();
			StopAllCoroutines();
			EventHub.Unsubscribe<NetworkEvents.PhotonPlayerConnectedEvent>(m_photonPlayerConnectedEventToken);
			EventHub.Unsubscribe<NetworkEvents.PhotonPlayerDisconnectedEvent>(m_photonPlayerDisconnectedEventToken);
			EventHub.Unsubscribe<Events.CountdownEndedEvent>(m_countdownEndedEventToken);
			EventHub.Unsubscribe<Events.WielderSpawnedEvent>(m_wielderSpawnedEventToken);
		}

		private void OnDestroy()
		{
			if (NetworkUtils.ConnectedToGame && base.photonView != null && base.photonView.IsMine)
			{
				PhotonNetwork.RemoveRPCs(base.photonView);
			}
		}

		protected override void Awake()
		{
			base.Awake();
			GameControl.Instance.LobbyArenaControl.ToString();
		}

		private void Start()
		{
			if (!GameOver)
			{
				MonoSingleton<TileControl>.Instance?.SetAllPropsActive();
				Resources.UnloadUnusedAssets();
				Photon.Realtime.Player opponent = PlayerManager.Instance.GetOpponent();
				if (opponent != null)
				{
					PlayerProperty.SetOpponentInfo(opponent);
					m_isRematch = (bool)RoomProperty.GetRoomProperty("A3");
				}
			}
		}

		private void Update()
		{
			if (!MatchStarted || GameOver)
			{
				return;
			}
			bool? flag = PunSingleton<PauseManager>.Instance?.IsGamePaused;
			if ((flag.HasValue && flag.Value) || !PhotonNetwork.IsMasterClient || CurrentMatchType.ContainsFlag(MatchType.SoloExperience))
			{
				return;
			}
			float currentMatchTime = PunSingleton<TimeManager>.Instance.CurrentMatchTime;
			if (currentMatchTime >= PunSingleton<TimeManager>.Instance.MatchLength - 30f && !GameOver && !PunSingleton<SoundManager>.Instance.IsTickingTimerStarted)
			{
				PunSingleton<SoundManager>.Instance.StartTickingTimer();
			}
			if (currentMatchTime >= PunSingleton<TimeManager>.Instance.MatchLength)
			{
				if (!GameOver)
				{
					PunSingleton<SoundManager>.Instance.StopTickingTimer();
					EndMatch(-1, MatchEndReasonType.Time);
				}
			}
			else if (!m_suddenDeath && currentMatchTime > PunSingleton<TimeManager>.Instance.MatchLengthWithoutSudden)
			{
				SuddenDeath();
			}
		}

		public bool GetMatchStartedOrSoloExperience()
		{
			if (MonoSingleton<NetworkManager>.Instance.CurrentMatchType.ContainsFlag(MatchType.SoloExperience))
			{
				return true;
			}
			return MatchStarted;
		}

		private void OnCountdownEnded(Events.CountdownEndedEvent eventData)
		{
			EndCountdown();
		}

		private void EndCountdown()
		{
			if (CurrentMatchType.ContainsFlag(MatchType.SoloExperience))
			{
				if (Mathf.Approximately(PunSingleton<TimeManager>.Instance.CurrentMatchTime, 0f))
				{
					PunSingleton<TimeManager>.Instance.ResetMatchTime();
				}
				if (!GameControl.Instance.IsCurrentLevel(Level.Basement))
				{
					WandsAnalytics.SendCustomEvent(CustomEventType.match_started, new Dictionary<string, object>
					{
						{
							"ArenaId",
							(int)CurrentLevel
						},
						{ "Reason", 1 },
						{
							"Rating",
							GameControl.Instance.Player.Rating
						}
					});
				}
				return;
			}
			PunSingleton<TimeManager>.Instance.ResetMatchTime();
			if (PhotonNetwork.IsMasterClient)
			{
				StartMatch();
			}
			MatchStartedReasonType matchStartedReasonType;
			if (CurrentMatchType.ContainsFlag(MatchType.Bot))
			{
				matchStartedReasonType = MatchStartedReasonType.Bot;
				if (m_isRematch)
				{
					matchStartedReasonType |= MatchStartedReasonType.Rematch;
				}
			}
			else
			{
				matchStartedReasonType = ((!m_isRematch) ? MatchStartedReasonType.NormalMatch : MatchStartedReasonType.Rematch);
			}
			WandsAnalytics.SendCustomEvent(CustomEventType.match_started, new Dictionary<string, object>
			{
				{
					"ArenaId",
					(int)CurrentLevel
				},
				{
					"Reason",
					(int)matchStartedReasonType
				},
				{
					"MatchId",
					(int)RoomProperty.GetRoomProperty("A4")
				},
				{
					"Rating",
					GameControl.Instance.Player.Rating
				}
			});
		}

		private void OnWielderSpawned(Events.WielderSpawnedEvent eventData)
		{
			WielderSpawned(eventData.Wielder);
		}

		private void WielderSpawned(Wielder wielder)
		{
			if (!wielder.IsBot && PlayerManager.Instance.IsEveryoneAvailable)
			{
				StartCoroutine(DelayedResetMatch());
			}
		}

		private void OnPhotonPlayerConnected(NetworkEvents.PhotonPlayerConnectedEvent eventData)
		{
			PhotonPlayerConnected(eventData.PhotonPlayer);
		}

		private void PhotonPlayerConnected(Photon.Realtime.Player otherPlayer)
		{
			if (PhotonNetwork.IsMasterClient)
			{
				PunSingleton<SoundManager>.Instance.PlayLocalSound("opponent_enters");
				m_gameOver = false;
				m_pendingGameOver = false;
				MatchStarted = false;
				MonoSingleton<ArenaUI>.Instance.ResetHUD();
			}
		}

		private void OnPhotonPlayerDisconnected(NetworkEvents.PhotonPlayerDisconnectedEvent eventData)
		{
			PhotonPlayerDisconnected(eventData.PhotonPlayer);
		}

		private void PhotonPlayerDisconnected(Photon.Realtime.Player otherPlayer)
		{
			if (otherPlayer != null)
			{
				if (MatchStarted || CountdownHandler.IsCountdownActive)
				{
					int? num = PlayerManager.Instance.LocalWielder?.ViewID;
					EndMatch((!num.HasValue) ? (-1) : num.Value, MatchEndReasonType.OpponentDisconnect);
				}
				else
				{
					PunMasterEndMatch(MatchEndReasonType.OpponentDisconnect);
				}
			}
		}

		private IEnumerator DelayedResetMatch()
		{
			yield return new CustomWaitForSeconds(1f);
			if (PhotonNetwork.IsMasterClient)
			{
				ResetMatch();
			}
		}

		private void StartMatch()
		{
			MatchStarted = true;
		}

		private void SuddenDeath()
		{
			m_suddenDeath = true;
			if (NetworkUtils.ConnectedToGame)
			{
				base.photonView.RPC("PunSuddenDeath", RpcTarget.AllBufferedViaServer);
			}
			else
			{
				PunSuddenDeath();
			}
		}

		[PunRPC]
		private void PunSuddenDeath()
		{
			EventHub.Publish(new Events.SuddenDeathStartedEvent());
		}

		public void EndMatchPause(EndState endState)
		{
			if (GameControl.Instance.Player != null)
			{
				m_pendingGameOver = false;
				if (!GameOver)
				{
					m_gameOver = true;
					MatchStarted = false;
					CountdownHandler.StopAllCoroutines();
					GameControl.Instance.Player.IncrementMatchesPlayed();
					Events.MatchEndedEvent matchEndedEvent = new Events.MatchEndedEvent();
					matchEndedEvent.EndState = endState;
					EventHub.Publish(matchEndedEvent);
					MonoSingleton<ArenaUI>.Instance?.SetEndMenuActive(endState);
					WandsAnalytics.SendCustomEvent(CustomEventType.match_ended, new Dictionary<string, object>
					{
						{
							"ArenaId",
							(int)CurrentLevel
						},
						{
							"Result",
							(int)endState
						},
						{ "Reason", 8 },
						{
							"MatchId",
							(int)RoomProperty.GetRoomProperty("A4")
						},
						{
							"Rating",
							GameControl.Instance.Player.Rating
						}
					});
				}
			}
		}

		public void EndMatch(int winnerViewID, MatchEndReasonType matchEndReasonType)
		{
			if (m_pendingGameOver)
			{
				return;
			}
			PunSingleton<SoundManager>.Instance.StopTickingTimer();
			m_pendingGameOver = true;
			m_winnerViewID = winnerViewID;
			if (!NetworkUtils.ConnectedToGame)
			{
				PunSetWielderStats(matchEndReasonType);
				PunMasterEndMatch(matchEndReasonType);
			}
			else if (PhotonNetwork.IsMasterClient)
			{
				base.photonView.RPC("PunSetWielderStats", RpcTarget.All, matchEndReasonType);
				if (CurrentMatchType.ContainsFlag(MatchType.Bot))
				{
					PlayerManager.Instance.BotControl.Wielder.SetStats(matchEndReasonType);
				}
			}
			else
			{
				base.photonView.RPC("PunEndMatch", RpcTarget.MasterClient, winnerViewID, matchEndReasonType);
			}
		}

		[PunRPC]
		private void PunEndMatch(int winnerViewID, MatchEndReasonType matchEndReasonType)
		{
			EndMatch(winnerViewID, matchEndReasonType);
		}

		[PunRPC]
		private void PunSetWielderStats(MatchEndReasonType matchEndReasonType)
		{
			PlayerManager.Instance.LocalWielder.SetStats(matchEndReasonType);
		}

		public void StatsUpdated(MatchEndReasonType matchEndReasonType)
		{
			base.photonView.RPC("PunMasterEndMatch", RpcTarget.MasterClient, matchEndReasonType);
		}

		[PunRPC]
		private void PunMasterEndMatch(MatchEndReasonType matchEndReasonType)
		{
			if (!(bool)RoomProperty.GetRoomProperty("C5"))
			{
				PunSingleton<TimeManager>.Instance.SetMatchEndTime();
				RoomProperty.SetRoomProperty("C5", value: true);
				CountdownHandler.StopAllCoroutines();
				PlayerManager.Instance.UpdateWielderMatchStatsAndVerifyWinnerID(ref m_winnerViewID);
				if (NetworkUtils.ConnectedToGame && PlayerManager.Instance.IsGameFull)
				{
					base.photonView.RPC("PunEndMatchAll", RpcTarget.AllBufferedViaServer, m_winnerViewID, matchEndReasonType);
					PhotonNetwork.SendAllOutgoingCommands();
				}
				else
				{
					PunEndMatchAll(m_winnerViewID, matchEndReasonType);
				}
			}
		}

		[PunRPC]
		private void PunEndMatchAll(int winnerViewID, MatchEndReasonType matchEndReasonType)
		{
			m_pendingGameOver = false;
			if (GameOver && PlayerManager.Instance.PlayerControl != null)
			{
				PlayerManager.Instance.PlayerControl.ToggleInputActive(active: true);
				PlayerManager.Instance.PlayerControl.SetSpellInputActive(active: true);
				return;
			}
			m_gameOver = true;
			MatchStarted = false;
			CountdownHandler.StopAllCoroutines();
			GameControl.Instance.Player.IncrementMatchesPlayed();
			PunSingleton<TileManager>.Instance?.SetTilesUnavailable();
			if (matchEndReasonType == MatchEndReasonType.FoundMatch)
			{
				EndMatchAndDisplayMenu(EndState.FoundMatch, matchEndReasonType);
				return;
			}
			if (winnerViewID < 0)
			{
				EndMatchAndDisplayMenu(EndState.Draw, matchEndReasonType);
				return;
			}
			if (NetworkUtils.ConnectedToGame)
			{
				PlayerManager.Instance.SetWinnerWielder(PhotonView.Find(winnerViewID)?.GetComponent<Wielder>());
			}
			else if (PlayerManager.Instance.WielderCount > 1)
			{
				for (int i = 0; i < PlayerManager.Instance.WielderCount; i++)
				{
					Wielder wielder = PlayerManager.Instance.AllWielders[i];
					if (wielder.ViewID == winnerViewID)
					{
						PlayerManager.Instance.SetWinnerWielder(wielder);
						break;
					}
				}
			}
			else if (PlayerManager.Instance.LocalWielder != null && winnerViewID == PlayerManager.Instance.LocalWielder.ViewID)
			{
				PlayerManager.Instance.SetWinnerWielder(PlayerManager.Instance.LocalWielder);
			}
			EndState endState = ((!PlayerManager.Instance.IsWinner) ? EndState.Lost : EndState.Won);
			EndMatchAndDisplayMenu(endState, matchEndReasonType);
		}

		private void EndMatchAndDisplayMenu(EndState endState, MatchEndReasonType matchEndReasonType)
		{
			Events.MatchEndedEvent matchEndedEvent = new Events.MatchEndedEvent();
			matchEndedEvent.EndState = endState;
			EventHub.Publish(matchEndedEvent);
			MonoSingleton<ArenaUI>.Instance.SetEndMenuActive(endState);
			m_onBeforeEnterLobby = delegate
			{
				WandsAnalytics.SendCustomEvent(CustomEventType.match_ended, new Dictionary<string, object>
				{
					{
						"ArenaId",
						(int)CurrentLevel
					},
					{
						"Result",
						(int)endState
					},
					{
						"Reason",
						(int)matchEndReasonType
					},
					{
						"MatchId",
						(int)RoomProperty.GetRoomProperty("A4")
					},
					{
						"Rating",
						GameControl.Instance.Player.Rating
					}
				});
				ClearPlayerObjects();
			};
		}

		public void LeaveGameAndEnterLobby()
		{
			if (m_onBeforeEnterLobby != null)
			{
				m_onBeforeEnterLobby();
			}
			ExpandedSingleton<LevelLoader>.Instance.LoadLevel(Level.Lobby, 1f);
		}

		private int GetPickupsUsedTotal()
		{
			int num = 0;
			foreach (Wielder allWielder in PlayerManager.Instance.AllWielders)
			{
				if (!(allWielder == null))
				{
					num += (int)PlayerProperty.Get("PU", allWielder.Owner);
				}
			}
			return num;
		}

		private void ClearPlayerObjects()
		{
			Wielder localWielder = PlayerManager.Instance.LocalWielder;
			PhotonNetwork.RemoveRPCs(localWielder.Owner);
			PhotonNetwork.RemoveRPCs(localWielder.photonView);
			PhotonNetwork.DestroyPlayerObjects(localWielder.Owner.ActorNumber);
		}

		public void ResetMatch()
		{
			if (GameControl.Instance.Platform.Type == PlatformType.Quest)
			{
				EventHub.Publish(new InputEvents.RecenterCameraEvent());
			}
			if (!MatchStarted && !GameOver && !m_resetting && !CountdownHandler.IsCountdownActive)
			{
				RoomProperty.SetRoomProperty("G0", -1);
				PlayerManager.Instance.SetWinnerWielder(null);
				if (NetworkUtils.ConnectedToGame && CurrentMatchType.ContainsFlag(MatchType.MultiPlayer))
				{
					base.photonView.RPC("OnReset", RpcTarget.AllViaServer);
				}
				else
				{
					OnReset();
				}
			}
		}

		[PunRPC]
		private void OnReset()
		{
			if (m_resetting || CountdownHandler.IsCountdownActive)
			{
				return;
			}
			m_resetting = true;
			ResetStats();
			PunSingleton<SoundManager>.Instance.OnReset(CurrentMatchType);
			Events.MatchResetEvent matchResetEvent = new Events.MatchResetEvent();
			matchResetEvent.MatchType = CurrentMatchType;
			EventHub.Publish(matchResetEvent);
			if (CurrentMatchType.ContainsFlag(MatchType.SoloExperience))
			{
				EventHub.Publish(new Events.CountdownEndedEvent());
			}
			else
			{
				Task.Delay(1000).ContinueWith(delegate
				{
					CountdownHandler.StartCountdown();
				}, TaskScheduler.FromCurrentSynchronizationContext());
			}
			ExpandedSingleton<FadeHandler>.Instance.FadeIn(0.75f, 0.25f);
			m_resetting = false;
		}

		private void ResetStats()
		{
			m_suddenDeath = false;
			MatchStarted = false;
			m_gameOver = false;
			RoomProperty.SetRoomProperty("R3", 0);
			RoomProperty.SetRoomProperty("C5", value: false);
		}

		[Conditional("UNITY_EDITOR")]
		public void DebugStartSuddenDeath()
		{
		}
	}
}
namespace Assets.Scripts.Season
{
	public static class SeasonControl
	{
		public class SeasonInformation
		{
			public bool SeasonEnded;

			public string SeasonEndDate;

			public string NextSeasonStartDate;

			public int CurrentSeason;
		}

		public const string SeasonLocalizationParam = "SEASON";

		public static bool SeasonLocked { get; private set; }

		public static DateTime SeasonEndDate { get; private set; }

		public static DateTime? NextSeasonStartDate { get; private set; }

		public static int CurrentSeason { get; private set; }

		public static void Initialize(SeasonInformation information)
		{
			SeasonLocked = information.SeasonEnded;
			SeasonEndDate = DateTime.Parse(information.SeasonEndDate, CultureInfo.InvariantCulture);
			NextSeasonStartDate = DateTime.Parse(information.NextSeasonStartDate, CultureInfo.InvariantCulture);
			CurrentSeason = information.CurrentSeason;
		}
	}
}
namespace Cortopia.Scripts.Season
{
	public class SeasonStatsFetcher : MonoBehaviour
	{
		public class SeasonStats
		{
			public int Season;

			public bool IsThisSeason;

			public int RankedMatchCount;
		}

		private const string SeasonStatsPath = "https://wandsgame.com/wp-json/wandsapi/v1/SeasonRankedMatchCount";

		private const int StatsLockedCode = -1;

		private SeasonStats m_seasonStats;

		public bool HasFetchedSeasonStats
		{
			[CompilerGenerated]
			get
			{
				return m_seasonStats != null;
			}
		}

		public int RankedMatchCount
		{
			[CompilerGenerated]
			get
			{
				return m_seasonStats.RankedMatchCount;
			}
		}

		public string LocalizationTerm
		{
			[CompilerGenerated]
			get
			{
				return (!m_seasonStats.IsThisSeason) ? "Workshop/Mirus/DuelsLastSeason" : "Workshop/Mirus/DuelsThisSeason";
			}
		}

		public string LocalizationParam
		{
			[CompilerGenerated]
			get
			{
				return "SEASON_MATCH_COUNT";
			}
		}

		private void Start()
		{
			StartCoroutine(GetRequest());
		}

		private IEnumerator GetRequest()
		{
			using UnityWebRequest webRequest = UnityWebRequest.Get("https://wandsgame.com/wp-json/wandsapi/v1/SeasonRankedMatchCount");
			yield return webRequest.SendWebRequest();
			if (webRequest.isNetworkError)
			{
				WandsLogger.LogError($"Couldn't fetch Season stats | Error: {webRequest.error}");
			}
			else
			{
				CacheSeasonStats(JsonConvert.DeserializeObject<SeasonStats>(webRequest.downloadHandler.text));
			}
		}

		private void CacheSeasonStats(SeasonStats seasonStats)
		{
			if (seasonStats == null)
			{
				WandsLogger.LogError("Couldn't parse season stats.");
			}
			else if (!seasonStats.Season.Equals(-1) && !seasonStats.RankedMatchCount.Equals(-1))
			{
				m_seasonStats = seasonStats;
			}
		}
	}
}
namespace Assets.Scripts.Settings
{
	public class AssetBundleSettings : ScriptableObject
	{
		[Serializable]
		public class StringBoolDicionary : SerializableDictionaryBase<string, bool>
		{
		}

		private Dictionary<string, bool> m_showAssetsInBundle = new Dictionary<string, bool>();

		[SerializeField]
		private StringBoolDicionary m_bundleToggles;

		public Dictionary<string, bool> ShowAssetsInBundle => m_showAssetsInBundle;

		public StringBoolDicionary BundleToggles => m_bundleToggles;
	}
	public class WandsBuilder : ScriptableObject
	{
		public Dictionary<PlatformType, bool> Platforms { get; set; } = new Dictionary<PlatformType, bool>
		{
			{
				PlatformType.GearVr,
				false
			},
			{
				PlatformType.Pico,
				false
			},
			{
				PlatformType.Rift,
				false
			},
			{
				PlatformType.Steam,
				false
			},
			{
				PlatformType.Viveport,
				false
			},
			{
				PlatformType.PlayStation,
				false
			}
		};

	}
	public class WandsBuildSettings : ScriptableObject
	{
		public enum PlayStationRegionCode
		{
			SIEE,
			SIEA
		}

		public enum PlayStationAppCategory
		{
			Application,
			Patch,
			Remaster
		}

		[Serializable]
		public class VersionCode : SerializableDictionaryBase<PlatformType, int>
		{
		}

		public UnityEngine.Object MainManifest;

		public UnityEngine.Object OculusManifest;

		public UnityEngine.Object OculusReleaseManifest;

		public UnityEngine.Object QuestManifest;

		public UnityEngine.Object QuestReleaseManifest;

		public UnityEngine.Object PicoManifest;

		public UnityEngine.Object PicoGlobalManifest;

		public UnityEngine.Object PicoNeo2Manifest;

		public UnityEngine.Object PicoNeo2GlobalManifest;

		public UnityEngine.Object MiVrManifest;

		public PlatformType Platform;

		public ConnectionType ConnectionType = ConnectionType.Develop;

		public PlayStationRegionCode PlayStationRegion;

		public PlayStationAppCategory PlayStationBuildType;

		public string PlayStationVersionApplication;

		public string PlayStationVersionMaster;

		public string ClientVersion;

		public string NetworkVersion;

		public string PlayfabVersion;

		public bool IsChinaBuild;

		public bool HasEnabledLogging;

		public bool UseDebugInput;

		public bool UseDebugVoiceEcho;

		public bool ShowStartupOptions;

		public bool BlockPlayerDeath;

		public bool EnableScoreFromBotMatches;

		[SerializeField]
		private VersionCode m_androidBundleVersions;

		public VersionCode AndroidBundleVersions => m_androidBundleVersions;
	}
}
namespace Assets.Scripts.Sound
{
	[RequireComponent(typeof(AudioSource))]
	public class AssetBundleSfx : MonoBehaviour
	{
		[SerializeField]
		private int m_mixerGroupIndex;

		private void OnEnable()
		{
			if (PunSingleton<SoundManager>.Instance.m_assetBundleGroups != null && PunSingleton<SoundManager>.Instance.m_assetBundleGroups.Length > m_mixerGroupIndex)
			{
				GetComponent<AudioSource>().outputAudioMixerGroup = PunSingleton<SoundManager>.Instance.m_assetBundleGroups[m_mixerGroupIndex];
			}
		}
	}
	public class AudioDataLoader : MonoBehaviour
	{
		[SerializeField]
		private bool m_playOnLoad = true;

		[SerializeField]
		private AudioSource[] m_ambientAudioSources;

		private EventToken m_sceneLoadedEventToken;

		private void OnEnable()
		{
			m_sceneLoadedEventToken = EventHub.Subscribe<Events.SceneLoadedEvent>(OnSceneLoaded);
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe<Events.SceneLoadedEvent>(m_sceneLoadedEventToken);
			AudioSource[] ambientAudioSources = m_ambientAudioSources;
			foreach (AudioSource audioSource in ambientAudioSources)
			{
				audioSource.clip.UnloadAudioData();
			}
		}

		private void OnSceneLoaded(Events.SceneLoadedEvent eventData)
		{
			LoadAudioDataAndPlay();
		}

		private void LoadAudioDataAndPlay()
		{
			AudioSource[] ambientAudioSources = m_ambientAudioSources;
			foreach (AudioSource audioSource in ambientAudioSources)
			{
				audioSource.clip.LoadAudioData();
				if (m_playOnLoad)
				{
					audioSource.Play();
				}
			}
		}
	}
}
namespace Assets.Scripts.Enums
{
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	public struct AudioMixerGroupIndex
	{
		public const int Level = 0;

		public const int UI = 1;

		public const int Spells = 2;

		public const int Music = 3;
	}
}
[RequireComponent(typeof(AudioSource))]
public class BigBen : MonoBehaviour
{
	public int m_strikeInterval = 15;

	private AudioSource m_audioSource;

	private void OnDisable()
	{
		StopAllCoroutines();
	}

	private void Start()
	{
		m_strikeInterval *= 60;
		m_audioSource = GetComponent<AudioSource>();
		int num = UnityEngine.Random.Range(30, 360);
		StartCoroutine("Strike", num);
	}

	private IEnumerator Strike(float waitTime)
	{
		yield return new WaitForSeconds(waitTime);
		m_audioSource.Play();
		StartCoroutine("Strike", m_strikeInterval);
	}
}
namespace Assets.Scripts.Sound
{
	public class CharacterHitSfxHandler : MonoBehaviour
	{
		[SerializeField]
		private AudioSource m_audioSource;

		[SerializeField]
		private AudioClip[] m_hitSoundsMale;

		[SerializeField]
		private AudioClip[] m_hitSoundsFemale;

		private AudioClip[] m_hitSounds;

		public void SetCorrectSoundEffects(CharacterType type)
		{
			switch (type)
			{
			case CharacterType.Scavenger:
			case CharacterType.Collector:
			case CharacterType.General:
			case CharacterType.Vanguard:
				m_hitSounds = m_hitSoundsMale;
				break;
			case CharacterType.Widow:
			case CharacterType.Raven:
			case CharacterType.Inquisitor:
			case CharacterType.Templar:
			case CharacterType.Vindicator:
			case CharacterType.Assassin:
			case CharacterType.Komuso:
			case CharacterType.Nemesis:
				m_hitSounds = m_hitSoundsFemale;
				break;
			default:
				WandsLogger.LogError($"Character of type {type} is resorting to using default value (male) as hit sfx");
				m_hitSounds = m_hitSoundsMale;
				break;
			}
		}

		public void PlaySound()
		{
			if (!(m_audioSource == null))
			{
				m_audioSource.Stop();
				m_audioSource.clip = m_hitSounds[UnityEngine.Random.Range(0, m_hitSounds.Length)];
				m_audioSource.Play();
			}
		}
	}
	public class HurtSfxHandler : MonoBehaviour
	{
		[StructLayout(LayoutKind.Sequential, Size = 1)]
		private struct HealthThresholds
		{
			public const int Min = 5;

			public const int Danger = 65;

			public const int Critical = 25;
		}

		[SerializeField]
		private bool m_disableMoanSfx;

		[SerializeField]
		private AudioSource[] m_audioSources = Array.Empty<AudioSource>();

		[SerializeField]
		private AudioClip[] m_heartBeatSounds = Array.Empty<AudioClip>();

		[SerializeField]
		private AudioClip[] m_hitSoundsFemale = Array.Empty<AudioClip>();

		[SerializeField]
		private AudioClip[] m_hitSoundsMale = Array.Empty<AudioClip>();

		private bool m_belongsToPlayer;

		private bool m_playHeartBeatCritical;

		private bool m_playHeartBeatDanger;

		private bool m_useMaleVoice;

		private AnimationNetworkRelay m_animationRelay;

		private StatsData m_healthData;

		private EventToken m_matchResetEventToken;

		private EventToken m_matchEndedEventToken;

		private EventToken m_characterTypeChangedEventToken;

		private readonly WaitForSeconds m_hitWait = new WaitForSeconds(0.3f);

		private const float ContinuousResponseTimeMultiplier = 2.2f;

		public bool IsContinuousDamageActive { get; private set; }

		public bool IsActive
		{
			[CompilerGenerated]
			get
			{
				return m_playHeartBeatDanger || m_playHeartBeatCritical;
			}
		}

		public void Initialize(StatsData healthData, AnimationNetworkRelay animationRelay, bool belongsToPlayer, CharacterType characterType)
		{
			m_belongsToPlayer = belongsToPlayer;
			if (healthData == null)
			{
				WandsLogger.LogError("HurtSfxHandler | Wielder health data is null");
				return;
			}
			if (animationRelay == null)
			{
				WandsLogger.LogError("HurtSfxHandler | Wielder animation relay is null");
				return;
			}
			m_healthData = healthData;
			m_animationRelay = animationRelay;
			if (m_belongsToPlayer)
			{
				CheckHeartbeatConditions(m_healthData.Current);
				UpdateUseMaleVoice(characterType);
				m_audioSources[1].spatialBlend = 0f;
			}
			else
			{
				UpdateUseMaleVoice(characterType);
				m_audioSources[1].spatialBlend = 1f;
			}
		}

		private void OnEnable()
		{
			m_matchResetEventToken = EventHub.Subscribe<Events.MatchResetEvent>(OnMatchReset);
			m_matchEndedEventToken = EventHub.Subscribe<Events.MatchEndedEvent>(OnMatchEnded);
			m_characterTypeChangedEventToken = EventHub.Subscribe<Events.CharacterTypeChangedEvent>(OnCharacterTypeChanged);
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe<Events.MatchResetEvent>(m_matchResetEventToken);
			EventHub.Unsubscribe<Events.MatchEndedEvent>(m_matchEndedEventToken);
			EventHub.Unsubscribe<Events.CharacterTypeChangedEvent>(m_characterTypeChangedEventToken);
		}

		private void OnMatchReset(Events.MatchResetEvent eventData)
		{
			ResetMatch();
		}

		private void OnMatchEnded(Events.MatchEndedEvent eventData)
		{
			AbortContinuousHit();
		}

		private void OnCharacterTypeChanged(Events.CharacterTypeChangedEvent eventData)
		{
			UpdateUseMaleVoice(eventData.CharacterType);
		}

		private void UpdateUseMaleVoice(CharacterType characterType)
		{
			if (characterType == CharacterType.Scavenger || characterType == CharacterType.Collector || characterType == CharacterType.General || characterType == CharacterType.Vanguard)
			{
				m_useMaleVoice = true;
			}
			else
			{
				m_useMaleVoice = false;
			}
		}

		private void ResetMatch()
		{
			StopAllCoroutines();
			if (m_healthData != null && m_belongsToPlayer)
			{
				CheckHeartbeatConditions(m_healthData.Current);
			}
			if (m_audioSources[1] != null)
			{
				m_audioSources[1].Stop();
			}
		}

		public void StopHeartBeat()
		{
			if (m_audioSources[0].isPlaying)
			{
				m_playHeartBeatDanger = false;
				m_playHeartBeatCritical = false;
				m_audioSources[0].Stop();
			}
		}

		public void CheckHeartbeatConditions(float hp)
		{
			if (IsActive)
			{
				if (hp >= 65f)
				{
					StopHeartBeat();
				}
			}
			else if (hp < 25f)
			{
				StartHeartBeatCritical();
			}
			else if (hp < 65f)
			{
				StartHeartBeatDanger();
			}
		}

		private void Update()
		{
			if (m_healthData == null)
			{
				return;
			}
			if (m_playHeartBeatDanger)
			{
				float t = Mathf.InverseLerp(0.25f, 0.65f, m_healthData.Fill);
				m_audioSources[0].volume = Mathf.Lerp(0.55f, 0.3f, t);
				if (m_healthData.Current <= 25f)
				{
					StartHeartBeatCritical();
				}
			}
			else if (m_playHeartBeatCritical)
			{
				float t2 = Mathf.InverseLerp(0.1f, 0.25f, m_healthData.Fill);
				m_audioSources[0].volume = Mathf.Lerp(0.7f, 0.55f, t2);
				if (m_healthData.Current > 25f)
				{
					StartHeartBeatDanger();
				}
			}
			else if (m_audioSources[0].isPlaying)
			{
				StopHeartBeat();
			}
		}

		public void StartHeartBeatDanger()
		{
			m_playHeartBeatCritical = false;
			m_audioSources[0].Stop();
			m_audioSources[0].volume = 0f;
			m_audioSources[0].clip = m_heartBeatSounds[0];
			m_audioSources[0].Play();
			m_playHeartBeatDanger = true;
		}

		public void StartHeartBeatCritical()
		{
			m_playHeartBeatDanger = false;
			m_audioSources[0].Stop();
			m_audioSources[0].volume = 0.35f;
			m_audioSources[0].clip = m_heartBeatSounds[1];
			m_audioSources[0].Play();
			m_playHeartBeatCritical = true;
		}

		public void PlayHitReaction(bool oneShot, Vector2 hitDirection)
		{
			if (oneShot)
			{
				StartCoroutine("OnHit", hitDirection);
			}
			else if (!IsContinuousDamageActive)
			{
				IsContinuousDamageActive = true;
				StartCoroutine("OnContinuousHit");
			}
		}

		public void AbortContinuousHit()
		{
			StopCoroutine("OnContinuousHit");
			IsContinuousDamageActive = false;
		}

		private IEnumerator OnHit(Vector2 hitDirection)
		{
			yield return m_hitWait;
			HandleScreenFlash();
			if (m_animationRelay != null)
			{
				m_animationRelay.PlayHitAnimation(hitDirection);
			}
			PlaySound();
		}

		private IEnumerator OnContinuousHit()
		{
			while (true)
			{
				yield return m_hitWait;
				HandleScreenFlash();
				if (m_animationRelay != null)
				{
					m_animationRelay.PlayHitAnimation(Vector3.up);
				}
				PlaySound();
				if (!(m_healthData.Current > 5f) || !IsContinuousDamageActive)
				{
					break;
				}
				yield return new WaitForSeconds(2.2f * m_healthData.Fill);
			}
			IsContinuousDamageActive = false;
		}

		private void HandleScreenFlash()
		{
			if (m_belongsToPlayer)
			{
				bool? flag = PunSingleton<SceneControl>.Instance?.GameOver;
				bool? flag2 = ((!flag.HasValue) ? null : new bool?(!flag.Value));
				if (!flag2.HasValue || flag2.Value)
				{
					ExpandedSingleton<FadeHandler>.Instance.ScreenFlashAndFade(Color.red);
				}
			}
		}

		private void PlaySound()
		{
			if (!m_disableMoanSfx)
			{
				m_audioSources[1].Stop();
				if (m_useMaleVoice)
				{
					m_audioSources[1].clip = m_hitSoundsMale.GetRandomElement();
				}
				else
				{
					m_audioSources[1].clip = m_hitSoundsFemale.GetRandomElement();
				}
				m_audioSources[1].Play();
			}
		}
	}
	[RequireComponent(typeof(AudioSource))]
	public class Lava : MonoBehaviour
	{
		private void OnDisable()
		{
			CancelInvoke();
		}

		private void Start()
		{
			Invoke("StartSound", 3.5f);
		}

		private void StartSound()
		{
			GetComponent<AudioSource>().Play();
		}
	}
}
public class LoadSfx : MonoBehaviour
{
	[SerializeField]
	private AudioSource m_loadAudioSource;

	[SerializeField]
	[Range(0.1f, 1f)]
	private float m_maxVolume = 0.1f;

	[SerializeField]
	private float m_transitionTime = 0.5f;

	private void OnDisable()
	{
		if (m_loadAudioSource != null)
		{
			m_loadAudioSource.DOKill();
		}
	}

	public void SetLoadSourcePaused(bool pause)
	{
		if (!(m_loadAudioSource == null))
		{
			if (pause)
			{
				m_loadAudioSource.Pause();
			}
			else
			{
				m_loadAudioSource.UnPause();
			}
		}
	}

	public void ToggleLoadSource(bool active, float transitionTime = 0f)
	{
		if (m_loadAudioSource == null)
		{
			return;
		}
		m_loadAudioSource.DOKill();
		if (transitionTime > 0f)
		{
			m_transitionTime = transitionTime;
		}
		if (active)
		{
			m_loadAudioSource.DOFade(m_maxVolume, m_transitionTime).OnStart(delegate
			{
				m_loadAudioSource.Play();
			});
		}
		else if (m_loadAudioSource.volume > 0f)
		{
			m_loadAudioSource.DOFade(0f, m_transitionTime).OnComplete(delegate
			{
				m_loadAudioSource.Stop();
			});
		}
		else if (m_loadAudioSource.isPlaying)
		{
			m_loadAudioSource.Stop();
		}
	}
}
namespace Assets.Scripts.Sound
{
	public class SfxPlayer : MonoBehaviour
	{
		[SerializeField]
		[Range(0f, 1f)]
		private float m_customVolume = 1f;

		[SerializeField]
		[Tooltip("Negative one (-1) results in random delay")]
		private int m_startDelay = -1;

		[SerializeField]
		private int m_minInterval;

		[SerializeField]
		private int m_maxInterval;

		[SerializeField]
		private AudioClip[] m_audioClips;

		private List<AudioSource> m_audioSources;

		private AudioSource m_audioSource;

		private bool m_useRandomInterval;

		private void OnDisable()
		{
			StopAllCoroutines();
			for (int i = 0; i < m_audioClips.Length; i++)
			{
				if (m_audioClips[i] != null)
				{
					m_audioClips[i].UnloadAudioData();
				}
			}
		}

		private void Start()
		{
			m_useRandomInterval = m_minInterval != m_maxInterval;
			m_audioSources = new List<AudioSource>(GetComponentsInChildren<AudioSource>());
			if (m_audioSources.IsNullOrEmpty())
			{
				WandsLogger.Log("No AudioSources found for SfxPlayer", base.gameObject, LogType.Warning);
				return;
			}
			AudioClip[] audioClips = m_audioClips;
			foreach (AudioClip audioClip in audioClips)
			{
				audioClip.LoadAudioData();
			}
			StartWait((m_startDelay < 0) ? GetRandomWaitTime() : ((float)m_startDelay));
		}

		private void StartWait(float waitTime)
		{
			m_audioSource = m_audioSources.GetRandomElement(m_audioSource);
			StartCoroutine(PlaySfx(waitTime));
		}

		private IEnumerator PlaySfx(float waitTime)
		{
			yield return new WaitForSeconds(waitTime);
			if (CanSetAudioClip(m_audioSource))
			{
				m_audioSource.Play();
			}
			StartWait(GetRandomWaitTime());
		}

		private bool CanSetAudioClip(AudioSource source)
		{
			if (source == null || source.isPlaying)
			{
				return false;
			}
			if (!m_audioClips.IsNullOrEmpty())
			{
				source.clip = m_audioClips.GetRandomElement(source.clip);
			}
			if (m_customVolume > 0f)
			{
				source.volume = m_customVolume;
			}
			return source.clip != null;
		}

		private float GetRandomWaitTime()
		{
			return (!m_useRandomInterval) ? m_minInterval : UnityEngine.Random.Range(m_minInterval, m_maxInterval);
		}
	}
}
public class SnapshotHandler : MonoSingleton<SnapshotHandler>
{
	[SerializeField]
	private AudioMixer m_audioMixer;

	[SerializeField]
	private AudioMixerSnapshot[] m_sceneSnapChats;

	private AudioMixerSnapshot[] m_transitionSnaps;

	private int m_currentIndex = 99;

	public void TransitionTo(int snapShotIndex)
	{
		TransitionTo(snapShotIndex, 0.01f);
	}

	public void TransitionTo(int snapShotIndex, float timeToReach)
	{
		if (m_currentIndex == snapShotIndex)
		{
			return;
		}
		if (m_sceneSnapChats == null || m_sceneSnapChats.Length == 0)
		{
			WandsLogger.Log("No snapshots defined!", base.gameObject, LogType.Warning);
			return;
		}
		if (snapShotIndex > m_sceneSnapChats.Length - 1)
		{
			snapShotIndex = 0;
		}
		if (snapShotIndex < 0)
		{
			m_currentIndex = 99;
			TransitionToSnapshots(0.5f, 0.5f, snapShotIndex * -1);
		}
		else
		{
			snapShotIndex = Mathf.Clamp(snapShotIndex, 0, m_sceneSnapChats.Length);
			m_currentIndex = snapShotIndex;
			m_sceneSnapChats[snapShotIndex].TransitionTo(timeToReach);
		}
	}

	public void TransitionToSnapshots(float value1, float value2, int snapshotBlendValue)
	{
		if (!m_sceneSnapChats.IsNullOrEmpty() && m_sceneSnapChats.Length >= snapshotBlendValue + 1)
		{
			m_transitionSnaps = new AudioMixerSnapshot[2]
			{
				m_sceneSnapChats[0],
				m_sceneSnapChats[snapshotBlendValue]
			};
			m_audioMixer.TransitionToSnapshots(m_transitionSnaps, new float[2] { value1, value2 }, 0.01f);
		}
	}
}
[RequireComponent(typeof(AudioSource))]
public class Sound : MonoBehaviourPun
{
	[SerializeField]
	private bool m_local;

	private bool m_isPersistent;

	private AudioSource m_source;

	private EventToken m_sceneLoadedEventToken;

	public int ID
	{
		[CompilerGenerated]
		get
		{
			return base.photonView.ViewID;
		}
	}

	public bool IsLocal
	{
		[CompilerGenerated]
		get
		{
			return m_local;
		}
	}

	public AudioSource Source
	{
		[CompilerGenerated]
		get
		{
			return (!(m_source != null)) ? (m_source = GetComponent<AudioSource>()) : m_source;
		}
	}

	public bool IsAvailable
	{
		[CompilerGenerated]
		get
		{
			return !Source.isPlaying;
		}
	}

	public string ClipName
	{
		[CompilerGenerated]
		get
		{
			return (!IsAvailable) ? Source.clip.name : string.Empty;
		}
	}

	public void SetPaused(bool pause)
	{
		if (pause)
		{
			Source.Pause();
		}
		else
		{
			Source.UnPause();
		}
	}

	public void SetPersistent()
	{
		base.transform.SetParent(null);
		m_isPersistent = true;
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		m_sceneLoadedEventToken = EventHub.Subscribe<Events.SceneLoadedEvent>(OnSceneLoaded);
	}

	private void OnSceneLoaded(Events.SceneLoadedEvent eventData)
	{
		if (m_isPersistent)
		{
			EventHub.Unsubscribe<Events.SceneLoadedEvent>(m_sceneLoadedEventToken);
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	public void Play(AudioClip clip, Vector3 position, float volume, float spatialBlend, int groupIndex)
	{
		PlaySound(clip, position, volume, spatialBlend, groupIndex);
	}

	public void PlaySynced(int clipIndex, Vector3 pos, float volume, float spatialBlend, int groupIndex)
	{
		if (clipIndex < PunSingleton<SoundManager>.Instance.generalAudioClips.Length)
		{
			if (!m_local && NetworkUtils.ConnectedToGame)
			{
				base.photonView.RPC("PunPlaySound", RpcTarget.All, clipIndex, pos, volume, spatialBlend, groupIndex);
			}
			else
			{
				PunPlaySound(clipIndex, pos, volume, spatialBlend, groupIndex);
			}
		}
	}

	public void PlaySynced(int clipIndex, Vector3 pos, float volume, float localSpatialBlend, float remoteSpatialBlend, int groupIndex)
	{
		if (clipIndex < PunSingleton<SoundManager>.Instance.generalAudioClips.Length)
		{
			if (!m_local && NetworkUtils.ConnectedToGame)
			{
				PunPlaySound(clipIndex, pos, volume, localSpatialBlend, groupIndex);
				base.photonView.RPC("PunPlaySound", RpcTarget.Others, clipIndex, pos, volume, remoteSpatialBlend, groupIndex);
			}
			else
			{
				PunPlaySound(clipIndex, pos, volume, localSpatialBlend, groupIndex);
			}
		}
	}

	[PunRPC]
	private void PunPlaySound(int clipIndex, Vector3 position, float volume, float spatialBlend, int groupIndex)
	{
		PlaySound(PunSingleton<SoundManager>.Instance.generalAudioClips[clipIndex], position, volume, spatialBlend, groupIndex);
	}

	private void PlaySound(AudioClip clip, Vector3 position, float volume, float spatialBlend, int groupIndex)
	{
		base.transform.position = position;
		Source.clip = clip;
		Source.volume = volume;
		Source.spatialBlend = spatialBlend;
		Source.outputAudioMixerGroup = PunSingleton<SoundManager>.Instance.m_groups[groupIndex];
		Source.Play();
	}
}
[RequireComponent(typeof(AudioSource))]
public class SoundHandler : MonoBehaviour
{
	public AudioClip[] m_audioClips;

	private AudioSource m_audioSource;

	public AudioSource Source
	{
		get
		{
			if (m_audioSource == null)
			{
				m_audioSource = GetComponent<AudioSource>();
			}
			return m_audioSource;
		}
	}

	public void PlaySound(string name)
	{
		PlaySound(name, Source.volume);
	}

	public void PlaySound(string name, float volume)
	{
		PlaySound(name, volume, 0f);
	}

	public void PlaySound(string name, float volume, float destroyTime)
	{
		if (Source == null)
		{
			return;
		}
		Source.volume = volume;
		if (Source.clip != null && Source.clip.name == name)
		{
			Source.Stop();
			Source.Play();
		}
		else
		{
			AudioClip clip = GetClip(name);
			if (clip != null)
			{
				Source.Stop();
				Source.clip = clip;
				Source.Play();
			}
		}
		if (destroyTime > 0f)
		{
			Source.transform.SetParent(null);
			UnityEngine.Object.Destroy(Source.gameObject, destroyTime);
		}
	}

	private AudioClip GetClip(string name)
	{
		if (m_audioClips.IsNullOrEmpty())
		{
			return null;
		}
		AudioClip[] audioClips = m_audioClips;
		foreach (AudioClip audioClip in audioClips)
		{
			if (audioClip.name == name)
			{
				return audioClip;
			}
		}
		WandsLogger.Log("Couldn't find clip with name: " + name, base.gameObject, LogType.Warning);
		return null;
	}
}
public class SoundManager : PunSingleton<SoundManager>, IPauseObject
{
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	public struct ClipNames
	{
		public const string NoMana = "No Mana";

		public const string MatchBegin = "music_match_begins";

		public const string MatchEnd = "music_match_end";

		public const string MatchEndEastern = "music_match_end_eastern";
	}

	[SerializeField]
	protected AudioMixer m_master;

	[SerializeField]
	private AudioMixerSnapshot m_muteSnapshot;

	[SerializeField]
	private AudioMixerGroup m_voipMixerGroup;

	[Header("Audio Clip containers")]
	public AudioClip[] generalAudioClips;

	public AudioClip[] m_matchQueueClips;

	public AudioClip[] m_matchMusic;

	public AudioClip[] m_matchMusicLastMinute;

	[Header("Sources and Groups")]
	public AudioSource[] m_musicSources;

	public AudioMixerGroup[] m_groups;

	public AudioMixerGroup[] m_assetBundleGroups;

	[SerializeField]
	private GameObject m_androidSfx;

	[SerializeField]
	private AudioSource m_ambientAudioSource;

	[SerializeField]
	[HideInInspector]
	private List<Sound> m_sourcePool = new List<Sound>(8);

	[SerializeField]
	[HideInInspector]
	private List<Sound> m_localSourcePool = new List<Sound>(8);

	private IDictionary<string, AudioClip> m_matchQueueAudioClips;

	private IDictionary<string, int> m_generalQueueAudioClips;

	private bool m_fadeMusic;

	private int m_fadeMusicIndex;

	private float m_currentLerpTime;

	private float m_fadeTime = 0.5f;

	private float m_startVolume;

	private float m_endVolume;

	private float m_originalVolume;

	private TickingTimer m_tickingTimer = new TickingTimer();

	private EventToken m_matchPausedEventToken;

	private EventToken m_suddenDeathStartedEventToken;

	private EventToken m_energyDepletedEventToken;

	private EventToken m_matchEndedEventToken;

	private EventToken m_finalCountdownStartedEventToken;

	private EventToken m_countdownEndedEventToken;

	public bool IsTickingTimerStarted { get; private set; }

	public bool IsPaused { get; set; }

	public AudioMixerGroup VoipMixerGroup
	{
		[CompilerGenerated]
		get
		{
			return m_voipMixerGroup;
		}
	}

	public AudioMixerGroup UiMixerGroup
	{
		[CompilerGenerated]
		get
		{
			return m_groups[1];
		}
	}

	protected virtual void OnEnable()
	{
		m_matchPausedEventToken = EventHub.Subscribe<Events.MatchPausedEvent>(OnMatchPaused);
		m_matchEndedEventToken = EventHub.Subscribe<Events.MatchEndedEvent>(OnMatchEnded);
		m_suddenDeathStartedEventToken = EventHub.Subscribe<Events.SuddenDeathStartedEvent>(OnSuddenDeathStarted);
		m_energyDepletedEventToken = EventHub.Subscribe<Events.EnergyDepletedEvent>(OnEnergyDepleted);
		m_finalCountdownStartedEventToken = EventHub.Subscribe<Events.FinalCountdownStartedEvent>(OnFinalCountdownStarted);
		m_countdownEndedEventToken = EventHub.Subscribe<Events.CountdownEndedEvent>(OnCountdownEnded);
		PlayAmbience();
	}

	protected override void OnDisable()
	{
		base.OnDisable();
		EventHub.Unsubscribe<Events.MatchPausedEvent>(m_matchPausedEventToken);
		EventHub.Unsubscribe<Events.MatchEndedEvent>(m_matchEndedEventToken);
		EventHub.Unsubscribe<Events.SuddenDeathStartedEvent>(m_suddenDeathStartedEventToken);
		EventHub.Unsubscribe<Events.EnergyDepletedEvent>(m_energyDepletedEventToken);
		EventHub.Unsubscribe<Events.FinalCountdownStartedEvent>(m_finalCountdownStartedEventToken);
		EventHub.Unsubscribe<Events.CountdownEndedEvent>(m_countdownEndedEventToken);
		if (m_ambientAudioSource != null)
		{
			m_ambientAudioSource.Stop();
			m_ambientAudioSource.clip.UnloadAudioData();
		}
	}

	protected override void Awake()
	{
		base.Awake();
		FillMatchQueueNames();
		FillGeneralAudioClipNames();
		if (m_musicSources[0] != null)
		{
			m_originalVolume = m_musicSources[0].volume;
		}
	}

	private void Start()
	{
		SetOptionalMusicEnabled(GameControl.Instance.MusicEnabled);
		if (GameControl.Instance.Platform.Type.ContainsFlag(PlatformTarget.PC) && m_androidSfx != null)
		{
			m_androidSfx.gameObject.SetActive(value: false);
		}
	}

	private void Update()
	{
		if (m_fadeMusic && m_musicSources != null)
		{
			m_currentLerpTime += Time.deltaTime;
			float num = m_currentLerpTime / m_fadeTime;
			m_musicSources[m_fadeMusicIndex].volume = Mathf.Lerp(m_startVolume, m_endVolume, num);
			if (num == 1f)
			{
				m_fadeMusic = false;
			}
		}
	}

	private void FixedUpdate()
	{
		if (IsTickingTimerStarted)
		{
			m_tickingTimer.HandleTicking();
		}
	}

	public void StartTickingTimer()
	{
		IsTickingTimerStarted = true;
	}

	public void StopTickingTimer()
	{
		IsTickingTimerStarted = false;
	}

	public void Pause(bool pause)
	{
		AudioSource[] musicSources = m_musicSources;
		foreach (AudioSource audioSource in musicSources)
		{
			if (pause)
			{
				audioSource.Pause();
			}
			else
			{
				audioSource.UnPause();
			}
		}
		foreach (Sound item in m_sourcePool)
		{
			item.SetPaused(pause);
		}
	}

	public void OnReset(MatchType matchType)
	{
		ResetAllSfx(EndState.Close);
	}

	private void ResetAllSfx(EndState endState)
	{
		StopAllSounds();
		if (PunSingleton<TimeManager>.Instance.CurrentMatchTime > PunSingleton<TimeManager>.Instance.MatchLength)
		{
			return;
		}
		StopAllMusic();
		if (endState.ContainsFlag(EndState.MatchEnd))
		{
			if (PunSingleton<SceneControl>.Instance.CurrentLevel.ContainsFlag(Arena.EasternRealms))
			{
				ExpandedSingleton<LevelLoader>.Instance.SetLoadingSound(PlayMusic("music_match_end_eastern", 0.85f)?.Source);
			}
			else
			{
				ExpandedSingleton<LevelLoader>.Instance.SetLoadingSound(PlayMusic("music_match_end", 0.85f)?.Source);
			}
		}
	}

	public void MuteAll()
	{
		if (m_muteSnapshot != null)
		{
			m_muteSnapshot.TransitionTo(0.5f);
		}
	}

	private void FillMatchQueueNames()
	{
		m_matchQueueAudioClips = new Dictionary<string, AudioClip>(m_matchQueueClips.Length);
		for (int i = 0; i < m_matchQueueClips.Length; i++)
		{
			AudioClip audioClip = m_matchQueueClips[i];
			m_matchQueueAudioClips.Add(audioClip.name, audioClip);
		}
	}

	private void FillGeneralAudioClipNames()
	{
		m_generalQueueAudioClips = new Dictionary<string, int>(generalAudioClips.Length);
		for (int i = 0; i < generalAudioClips.Length; i++)
		{
			m_generalQueueAudioClips.Add(generalAudioClips[i].name, i);
		}
	}

	private void PreloadAudio()
	{
		for (int i = 0; i < m_matchMusic.Length; i++)
		{
			if (m_matchMusic[i].loadState == AudioDataLoadState.Unloaded)
			{
				m_matchMusic[i].LoadAudioData();
			}
		}
		for (int j = 0; j < m_matchMusicLastMinute.Length; j++)
		{
			if (m_matchMusicLastMinute[j].loadState == AudioDataLoadState.Unloaded)
			{
				m_matchMusicLastMinute[j].LoadAudioData();
			}
		}
	}

	private void PlayAmbience()
	{
		if (!(m_ambientAudioSource == null))
		{
			if (m_ambientAudioSource.clip.loadState == AudioDataLoadState.Unloaded)
			{
				m_ambientAudioSource.clip.LoadAudioData();
			}
			m_ambientAudioSource.Play();
		}
	}

	public virtual void SetOptionalMusicEnabled(bool enable)
	{
		if (!(m_master == null))
		{
			m_master.SetFloat("Music-Optional-Volume", (!enable) ? (-80f) : 0f);
			m_master.SetFloat("Music-Counter-Volume", (!enable) ? 0f : (-80f));
		}
	}

	public void SetMusicEquilizerFrequency(float value)
	{
		m_master.SetFloat("Music-EQ", Mathf.Clamp(value, 0.05f, 3f));
	}

	public void SetEquilizerFrequency(float value)
	{
		m_master.SetFloat("Frequency-EQ", Mathf.Clamp(value, 0.05f, 3f));
	}

	public float GetEqualizerFrequency()
	{
		float value = 0f;
		m_master.GetFloat("Frequency-EQ", out value);
		return value;
	}

	public bool IsMusicPlaying(int index = 0)
	{
		return m_musicSources != null && m_musicSources[index] != null && m_musicSources[index].isPlaying;
	}

	public void FadeMusic(bool fadeIn, float fadeTime, int sourceIndex = 0)
	{
		FadeMusic(fadeIn, fadeTime, (!fadeIn) ? m_originalVolume : 0f, (!fadeIn) ? 0f : m_originalVolume, sourceIndex);
	}

	public void FadeMusic(bool fadeIn, float fadeTime, float startVolume, float endVolume, int sourceIndex = 0)
	{
		m_endVolume = endVolume;
		if (m_musicSources[sourceIndex].volume != m_endVolume)
		{
			m_fadeMusicIndex = sourceIndex;
			m_startVolume = startVolume;
			m_fadeTime = fadeTime;
			m_currentLerpTime = 0f;
			m_fadeMusic = true;
		}
	}

	public Sound PlayMusic(string clipName, float volume)
	{
		if (string.IsNullOrEmpty(clipName))
		{
			return null;
		}
		Sound sound = Drop(useLocalSound: true);
		if (sound == null)
		{
			WandsLogger.Log("Audio pool exceeded, not playing sound: " + clipName, LogType.Warning);
			return null;
		}
		PlayMusicClip(clipName, volume, sound);
		return sound;
	}

	private void PlayMusicClip(string clipName, float volume, Sound sound)
	{
		if (!(sound == null))
		{
			AudioClip value = null;
			if (m_matchQueueAudioClips.TryGetValue(clipName, out value))
			{
				sound.Play(value, Vector3.zero, volume, 0f, 3);
			}
			else
			{
				WandsLogger.Log($"Desired sound: {clipName} not added to MusicClips in SoundManager and therefor couldn't be played!", LogType.Warning);
			}
		}
	}

	protected virtual void PlayMusic(MusicType musicType)
	{
		if (!m_musicSources.IsNullOrEmpty())
		{
			AudioClip musicClip = GetMusicClip(musicType);
			if (!(musicClip == null) && !m_musicSources[(int)musicType].isPlaying)
			{
				m_musicSources[(int)musicType].clip = musicClip;
				m_musicSources[(int)musicType].clip.LoadAudioData();
				m_musicSources[(int)musicType].Play();
			}
		}
	}

	private AudioClip GetMusicClip(MusicType musicType)
	{
		AudioClip[] array = ((musicType != 0) ? m_matchMusicLastMinute : m_matchMusic);
		switch (PunSingleton<SceneControl>.Instance.CurrentLevel)
		{
		case Arena.OrtusStation:
		case Arena.DeadMastersVale:
			return array[1];
		case Arena.SanctumOfSahir:
			return array[2];
		default:
			return array[0];
		}
	}

	private void PlayBattleMusic()
	{
		m_musicSources[0].clip = ((PunSingleton<SceneControl>.Instance.CurrentLevel <= (Arena)3) ? m_matchMusic[0] : m_matchMusic[1]);
		m_musicSources[0].Stop();
		FadeMusic(fadeIn: true, 0.1f, 0.25f, m_originalVolume);
		PlayMusic(MusicType.Default);
	}

	public void StopAllSounds()
	{
		StopTickingTimer();
		if (!m_matchQueueClips.IsNullOrEmpty())
		{
			for (int i = 0; i < m_matchQueueClips.Length; i++)
			{
				StopLocalSound(m_matchQueueClips[i].name);
			}
		}
	}

	public void StopAllMusic()
	{
		if (!m_musicSources.IsNullOrEmpty())
		{
			for (int i = 0; i < m_musicSources.Length; i++)
			{
				m_musicSources[i].clip.UnloadAudioData();
				m_musicSources[i].Stop();
			}
		}
	}

	public void StopMusic(MusicType musicType = MusicType.Default)
	{
		if (!m_musicSources.IsNullOrEmpty() && m_musicSources[(int)musicType].isPlaying)
		{
			m_musicSources[(int)musicType].Stop();
		}
	}

	public void StopSound(string clipName)
	{
		if (NetworkUtils.ConnectedToGame)
		{
			base.photonView.RPC("PunStopSfx", RpcTarget.AllBuffered, clipName, false);
		}
		else
		{
			PunStopSfx(clipName, isLocal: true);
		}
	}

	public void StopLocalSound(string clipName)
	{
		PunStopSfx(clipName, isLocal: true);
	}

	[PunRPC]
	private void PunStopSfx(string clipName, bool isLocal)
	{
		if (m_sourcePool.IsNullOrEmpty())
		{
			return;
		}
		List<Sound> list = ((!isLocal) ? m_sourcePool : m_localSourcePool);
		for (int i = 0; i < list.Count; i++)
		{
			Sound sound = list[i];
			if (!sound.IsAvailable && sound.ClipName == clipName)
			{
				sound.Source.Stop();
			}
		}
	}

	public void PlayLocalSound(string clipName)
	{
		PlayLocalSound(clipName, 1f, 0);
	}

	public void PlayLocalSound(string clipName, float volume)
	{
		PlayLocalSound(clipName, volume, 0);
	}

	public void PlayLocalSound(string clipName, float volume, int mixerGroup)
	{
		if (!string.IsNullOrEmpty(clipName))
		{
			Sound sound = Drop(useLocalSound: true);
			if (!(sound == null))
			{
				PlaySoundClip(clipName, volume, 0f, Vector3.zero, local: true, mixerGroup);
			}
		}
	}

	public void PlayLocalSoundAtPoint(string clipName, float volume, Vector3 point)
	{
		PlayLocalSoundAtPoint(clipName, volume, point, 0);
	}

	public void PlayLocalSoundAtPoint(string clipName, float volume, Vector3 point, int mixerGroup)
	{
		if (!string.IsNullOrEmpty(clipName))
		{
			Sound sound = Drop(useLocalSound: true);
			if (!(sound == null))
			{
				PlaySoundClip(clipName, volume, 1f, point, local: true, mixerGroup);
			}
		}
	}

	public void PlaySound(string clipName)
	{
		PlaySound(clipName, 1f, 0);
	}

	public void PlaySound(string clipName, float volume, int mixerGroup)
	{
		if (!string.IsNullOrEmpty(clipName))
		{
			Sound sound = Drop(useLocalSound: false);
			if (!(sound == null))
			{
				PlaySoundClip(clipName, volume, 0f, Vector3.zero, local: false, mixerGroup);
			}
		}
	}

	public void PlayPlayerSound(string clipName, float volume, Vector3 point, int mixerGroup)
	{
		if (string.IsNullOrEmpty(clipName))
		{
			return;
		}
		Sound sound = Drop(useLocalSound: false);
		if (!(sound == null))
		{
			int value = -1;
			if (m_generalQueueAudioClips.TryGetValue(clipName, out value))
			{
				sound.PlaySynced(value, point, volume, 0f, 1f, mixerGroup);
			}
			else
			{
				WandsLogger.LogError($"[SoundManager] Desired sound: {clipName} not added to generalAudioClips in SoundManager and therefor couldn't be played!", LogColor.Audio);
			}
		}
	}

	public void PlaySoundAtPoint(string clipName, Vector3 point)
	{
		PlaySoundAtPoint(clipName, 1f, point, 0);
	}

	public void PlaySoundAtPoint(string clipName, float volume, Vector3 point)
	{
		PlaySoundAtPoint(clipName, volume, point, 0);
	}

	public void PlaySoundAtPoint(string clipName, float volume, Vector3 point, int mixerGroup)
	{
		if (!string.IsNullOrEmpty(clipName))
		{
			Sound sound = Drop(useLocalSound: false);
			if (!(sound == null))
			{
				PlaySoundClip(clipName, volume, 1f, point, local: false, mixerGroup);
			}
		}
	}

	protected void PlaySoundClip(string clipName, float volume, float spatialBlend, Vector3 point, bool local, int groupIndex)
	{
		Sound sound = Drop(local);
		if (!(sound == null))
		{
			int value = -1;
			if (m_generalQueueAudioClips.TryGetValue(clipName, out value))
			{
				sound.PlaySynced(value, point, volume, spatialBlend, groupIndex);
			}
			else
			{
				WandsLogger.LogError($"[SoundManager] Desired sound: {clipName} not added to generalAudioClips in SoundManager and therefor couldn't be played!", LogColor.Audio);
			}
		}
	}

	protected Sound Drop(bool useLocalSound)
	{
		if (!NetworkUtils.ConnectedToGame)
		{
			useLocalSound = true;
		}
		if (useLocalSound)
		{
			return Drop(m_localSourcePool.ToArray());
		}
		return Drop(m_sourcePool.ToArray());
	}

	private Sound Drop(Sound[] pool)
	{
		foreach (Sound sound in pool)
		{
			if (sound.IsAvailable)
			{
				return sound;
			}
		}
		return null;
	}

	private void OnMatchPaused(Events.MatchPausedEvent eventData)
	{
		Pause(eventData.IsPaused);
	}

	private void OnMatchEnded(Events.MatchEndedEvent eventData)
	{
		ResetAllSfx(eventData.EndState);
	}

	private void OnSuddenDeathStarted(Events.SuddenDeathStartedEvent eventData)
	{
		if (GameControl.Instance.MusicEnabled)
		{
			FadeMusic(fadeIn: true, 1f, 0.15f, 0.25f);
			StopMusic(MusicType.LastMinute);
			PlayMusic(MusicType.LastMinute);
			SetOptionalMusicEnabled(GameControl.Instance.MusicEnabled);
		}
	}

	private void OnEnergyDepleted(Events.EnergyDepletedEvent eventData)
	{
		PlayPlayerSound("No Mana", 0.8f, eventData.WandPosition, 1);
	}

	private void OnFinalCountdownStarted(Events.FinalCountdownStartedEvent eventData)
	{
		PlayMusic("music_match_begins", 1f);
	}

	private void OnCountdownEnded(Events.CountdownEndedEvent eventData)
	{
		if (PunSingleton<SceneControl>.Instance.CurrentMatchType.ContainsFlag(~MatchType.SoloExperience))
		{
			PlayBattleMusic();
		}
	}
}
namespace Assets.Scripts.Sound
{
	public class SoundManagerLobby : SoundManager
	{
		private const string LobbyCountdownSfx = "countdown_5sec";

		private float m_musicStartVolume;

		private EventToken m_lobbyPausedEventToken;

		private EventToken m_postMatchUiSkippedEventToken;

		private EventToken m_finalCountdownStartedEventToken;

		private EventToken m_countdownCanceledEventToken;

		private AudioSource MainMusicSource => m_musicSources[0];

		protected override void OnEnable()
		{
			m_lobbyPausedEventToken = EventHub.Subscribe<Events.LobbyPausedEvent>(OnLobbyPaused);
			m_postMatchUiSkippedEventToken = EventHub.Subscribe<Events.PostMatchUiSkippedEvent>(OnPostMatchUiSkipped);
			m_finalCountdownStartedEventToken = EventHub.Subscribe<Events.FinalCountdownStartedEvent>(OnFinalCountdownStarted);
			m_countdownCanceledEventToken = EventHub.Subscribe<Events.CountdownCanceledEvent>(OnCountdownCanceled);
		}

		protected override void OnDisable()
		{
			StopAllCoroutines();
			EventHub.Unsubscribe<Events.LobbyPausedEvent>(m_lobbyPausedEventToken);
			EventHub.Unsubscribe<Events.PostMatchUiSkippedEvent>(m_postMatchUiSkippedEventToken);
			EventHub.Unsubscribe<Events.FinalCountdownStartedEvent>(m_finalCountdownStartedEventToken);
			EventHub.Unsubscribe<Events.CountdownCanceledEvent>(m_countdownCanceledEventToken);
		}

		protected override void Awake()
		{
			base.Awake();
			m_musicStartVolume = MainMusicSource.volume;
		}

		private void OnLobbyPaused(Events.LobbyPausedEvent eventData)
		{
			Pause(eventData.IsPaused);
		}

		private void OnPostMatchUiSkipped(Events.PostMatchUiSkippedEvent eventData)
		{
			StopAllSounds();
			StopAllMusic();
		}

		private void OnFinalCountdownStarted(Events.FinalCountdownStartedEvent eventData)
		{
			PlayLocalSound("countdown_5sec", 1f);
		}

		private void OnCountdownCanceled(Events.CountdownCanceledEvent eventData)
		{
			StopLocalSound("countdown_5sec");
		}

		public void PlayUiFlowComplete()
		{
			PlayLocalSound("ui_flow_end", 1f, 1);
		}

		public void PlayLobbyMusic()
		{
			StopMusic();
			MainMusicSource.clip = m_matchMusic[0];
			MainMusicSource.clip.LoadAudioData();
			MainMusicSource.volume = m_musicStartVolume;
			MainMusicSource.Play();
		}

		public void PlaySurvivalMusic()
		{
			StopMusic();
			MainMusicSource.clip = m_matchMusic[1];
			MainMusicSource.clip.LoadAudioData();
			MainMusicSource.volume = m_musicStartVolume;
			MainMusicSource.Play();
		}

		public void FadeMusic()
		{
			MainMusicSource.DOFade(0f, 0.25f).OnComplete(StopMusic);
		}

		public void StopMusic()
		{
			MainMusicSource.Stop();
		}

		public override void SetOptionalMusicEnabled(bool enable)
		{
			if (!(m_master == null))
			{
				m_master.SetFloat("Music-Counter-Volume", (!enable) ? (-80f) : 0f);
			}
		}
	}
}
public class SoundManagerWorkshop : SoundManager
{
	private void Start()
	{
		if (GameControl.Instance.Player.TutorialState == TutorialState.Completed)
		{
			PlayMusic(MusicType.Default);
		}
	}

	public void PlayPersistantLocalSound(string clipName, float volume, int groupIndex)
	{
		if (!string.IsNullOrEmpty(clipName))
		{
			Sound sound = Drop(useLocalSound: true);
			if (!(sound == null))
			{
				sound.SetPersistent();
				UnityEngine.Object.Destroy(sound.GetComponent<PhotonView>());
				PlaySoundClip(clipName, volume, 0f, Vector3.zero, local: true, groupIndex);
			}
		}
	}

	protected override void PlayMusic(MusicType musicType)
	{
		AudioSource audioSource = m_musicSources[0];
		if (!audioSource.isPlaying && GameControl.Instance.Player.TutorialState == TutorialState.Completed)
		{
			audioSource.clip.LoadAudioData();
			audioSource.Play();
		}
	}
}
namespace Assets.Scripts.Sound
{
	public class SoundPlayer : MonoBehaviour
	{
		[SerializeField]
		private AudioClip m_audioClip;

		[SerializeField]
		private float m_volume = 1f;

		[SerializeField]
		private bool m_2dSound;

		[SerializeField]
		private int m_group;

		private bool IsEnabled => base.enabled && base.gameObject.activeSelf;

		private void OnDisable()
		{
			StopAllCoroutines();
		}

		public void PlaySoundWithDelay(float delay)
		{
			if (IsEnabled)
			{
				StartCoroutine(LatentPlaySound(delay));
			}
		}

		private IEnumerator LatentPlaySound(float delay)
		{
			yield return new CustomWaitForSeconds(delay);
			if (IsEnabled)
			{
				PlaySound();
			}
		}

		public void PlaySound()
		{
			if (IsEnabled)
			{
				if (m_2dSound)
				{
					PunSingleton<SoundManager>.Instance.PlayLocalSound(m_audioClip.name, m_volume, m_group);
				}
				else
				{
					PunSingleton<SoundManager>.Instance.PlayLocalSoundAtPoint(m_audioClip.name, m_volume, base.transform.position, m_group);
				}
			}
		}
	}
	public class SplitAudioSoundPlayer : MonoBehaviour
	{
		[SerializeField]
		private AudioSource m_chargeStartAudio;

		[SerializeField]
		private AudioSource m_chargeLoopAudio;

		[Tooltip("Optional")]
		[SerializeField]
		private AudioSource m_chargeStopAudio;

		private float m_loopStartVolume;

		private TweenCallback m_tweenCallback;

		private void OnDisable()
		{
			StopAllCoroutines();
		}

		public void PlaySplitAudio(float delay = 0f, float duration = 0f)
		{
			if (m_chargeStartAudio == null)
			{
				return;
			}
			if (m_chargeLoopAudio == null || m_chargeStartAudio == m_chargeLoopAudio)
			{
				WandsLogger.LogError("Either loop audio source defined or it's the same as the start audio source");
				return;
			}
			if (m_loopStartVolume == 0f)
			{
				m_loopStartVolume = m_chargeStartAudio.volume;
			}
			m_chargeLoopAudio.volume = 0f;
			m_chargeLoopAudio.Play();
			m_chargeLoopAudio.DOFade(m_loopStartVolume, m_chargeStartAudio.clip.length).SetDelay(delay).OnStart(PlayStartSound);
			if (duration > 0f)
			{
				StartCoroutine(LatentStopAudio(delay + duration));
			}
		}

		private void PlayStartSound()
		{
			m_chargeStartAudio.Play();
		}

		private IEnumerator LatentStopAudio(float duration)
		{
			yield return new WaitForSeconds(duration);
			PlayStopSound();
		}

		public void KillSplitAudio()
		{
			StopAllCoroutines();
			if (m_chargeStartAudio != null)
			{
				m_chargeStartAudio.Stop();
			}
			if (m_chargeLoopAudio != null)
			{
				m_chargeLoopAudio.Stop();
			}
			if (m_chargeStopAudio != null)
			{
				m_chargeStopAudio.Stop();
			}
		}

		public void FadeOutLoop(float time, TweenCallback callback)
		{
			if (m_chargeLoopAudio == null)
			{
				WandsLogger.Log("No charge audio source found!", LogType.Error);
				return;
			}
			m_tweenCallback = callback;
			m_chargeLoopAudio.DOFade(0f, time).OnComplete(OnFadeOutCompleted);
		}

		private void OnFadeOutCompleted()
		{
			if (m_tweenCallback != null)
			{
				m_tweenCallback();
			}
			KillSplitAudio();
		}

		public void PlayStopSound()
		{
			KillSplitAudio();
			if (!(m_chargeStopAudio == null))
			{
				m_chargeStopAudio.volume = m_loopStartVolume;
				m_chargeStopAudio.Play();
			}
		}
	}
}
[RequireComponent(typeof(AudioSource))]
public class TeleportShimmer : MonoBehaviour
{
	private bool m_fadeSound;

	private AudioSource m_audioSrc;

	private float m_volumeStart;

	private float m_startTime;

	private float m_startVolume;

	private float m_endVolume;

	private void Start()
	{
		if (m_audioSrc == null)
		{
			m_audioSrc = GetComponent<AudioSource>();
		}
		m_volumeStart = m_audioSrc.volume;
	}

	private void Update()
	{
		if (!m_fadeSound || m_audioSrc == null)
		{
			return;
		}
		float num = Time.time - m_startTime;
		float num2 = num / 0.5f;
		m_audioSrc.volume = Mathf.Lerp(m_startVolume, m_endVolume, num2);
		if (num2 >= 1f)
		{
			m_fadeSound = false;
			if (Mathf.Approximately(m_audioSrc.volume, 0f))
			{
				m_audioSrc.Stop();
			}
		}
	}

	public void FadeSound(Transform tileTf)
	{
		if (m_audioSrc == null)
		{
			m_audioSrc = GetComponent<AudioSource>();
		}
		if (tileTf != null)
		{
			base.transform.position = tileTf.position;
			if (PunSingleton<SoundManager>.Instance != null)
			{
				PunSingleton<SoundManager>.Instance.PlayLocalSoundAtPoint("teleport_choose", 0.8f, base.transform.position);
			}
			m_startVolume = 0f;
			m_endVolume = m_volumeStart;
			m_startTime = Time.time;
			m_fadeSound = true;
			m_audioSrc.Play();
		}
		else
		{
			m_startVolume = m_volumeStart;
			m_endVolume = 0f;
			m_startTime = Time.time;
			m_fadeSound = true;
		}
	}
}
public class TickingTimer
{
	private const string TickSoundName = "timer_countdown_tick_01";

	private const string TockSoundName = "timer_countdown_tick_02";

	public const float TickTriggerTime = 30f;

	private const float FastTickTriggerTime = 10f;

	private const float FinalTickTriggerTime = 4f;

	private const float TickInterval = 1f;

	private const float SpeedUpFactor = 0.5f;

	public const float TickVolume = 0.6f;

	private const float TickVolumeDelta = 0.1f;

	private const int MaxInterations = 2;

	private float m_currentVolume = 0.6f;

	private float m_interval = 1f;

	private float m_timeLeft;

	private float m_lastTickTime;

	private int m_currentIteration;

	private bool m_tickTockVariation;

	public void HandleTicking()
	{
		m_timeLeft = PunSingleton<TimeManager>.Instance.MatchLength - PunSingleton<TimeManager>.Instance.CurrentMatchTime;
		UpdateSound();
		HandleTickSoundPlayback();
	}

	private void UpdateSound()
	{
		if (m_timeLeft < 4f && m_currentIteration == 1)
		{
			NextIteration();
		}
		else if (m_timeLeft < 10f && m_currentIteration == 0)
		{
			NextIteration();
		}
	}

	private void NextIteration()
	{
		m_currentIteration++;
		IncreaseVolume();
		UpdateInterval();
	}

	private void IncreaseVolume()
	{
		if (m_currentIteration < 2)
		{
			m_currentVolume += 0.1f;
		}
	}

	private void UpdateInterval()
	{
		m_interval = 1f * Mathf.Pow(0.5f, m_currentIteration);
	}

	private void ChangeTickTockVariation()
	{
		m_tickTockVariation = !m_tickTockVariation;
	}

	private void HandleTickSoundPlayback()
	{
		if (Time.time - m_lastTickTime >= m_interval)
		{
			m_lastTickTime = Time.time;
			PlayTickSound();
		}
	}

	private string GetCurrentSoundName()
	{
		return (!m_tickTockVariation) ? "timer_countdown_tick_02" : "timer_countdown_tick_01";
	}

	private float GetCurrentSoundVolume()
	{
		if (m_currentIteration == 2)
		{
			m_currentVolume += m_interval / 4f / 4f;
		}
		return (!m_tickTockVariation) ? m_currentVolume : (m_currentVolume - 0.1f * ((float)m_currentIteration / 1f));
	}

	private void PlayTickSound()
	{
		ChangeTickTockVariation();
		PunSingleton<SoundManager>.Instance.PlaySound(GetCurrentSoundName(), GetCurrentSoundVolume(), 0);
	}
}
namespace Assets.Scripts.Spells.Defense
{
	[RequireComponent(typeof(PhotonView))]
	public class Spell_ArmorOfTheSun : SpellBase
	{
		[Header("Armor")]
		[SerializeField]
		private float m_startDurability = 3f;

		[SerializeField]
		private float m_deflectValue = 0.8f;

		private float m_durability;

		private bool m_isArmorActive;

		private bool m_isArmorActiveAtStart;

		private EventToken m_matchResetEventToken;

		private EventToken m_matchEndedEventToken;

		public float DeflectValue
		{
			[CompilerGenerated]
			get
			{
				return 1f - m_deflectValue;
			}
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			m_matchResetEventToken = EventHub.Subscribe<Events.MatchResetEvent>(OnMatchReset);
			m_matchEndedEventToken = EventHub.Subscribe<Events.MatchEndedEvent>(OnMatchEnded);
		}

		protected override void OnDisable()
		{
			base.OnDisable();
			EventHub.Unsubscribe<Events.MatchResetEvent>(m_matchResetEventToken);
			EventHub.Unsubscribe<Events.MatchEndedEvent>(m_matchEndedEventToken);
		}

		private void Awake()
		{
			m_durability = m_startDurability;
		}

		private void OnMatchReset(Events.MatchResetEvent eventData)
		{
			if (m_isArmorActiveAtStart)
			{
				m_isArmorActiveAtStart = false;
			}
			else
			{
				AbortSpellCasting();
			}
		}

		private void OnMatchEnded(Events.MatchEndedEvent eventData)
		{
			AbortSpellCasting();
		}

		public void ActivateArmor(float customDurability)
		{
			m_durability = customDurability;
			m_isArmorActiveAtStart = true;
			SetActive(active: true, discret: true);
		}

		public void ArmorHit(float damage)
		{
			base.photonView.RPC("PunArmorHit", PhotonNetwork.LocalPlayer, base.photonView.ViewID, damage);
		}

		[PunRPC]
		private void PunArmorHit(int viewID, float damage)
		{
			if (base.photonView.ViewID == viewID)
			{
				m_durability -= damage;
				if (m_durability <= 0f)
				{
					AbortSpellCasting();
				}
			}
		}

		public override void SpellPress()
		{
			TryTriggerSpellPressHaptics();
			OnPress();
		}

		protected override void OnPress()
		{
			DrainEnergy();
			SetActive(active: true);
		}

		public override void SpellHold()
		{
		}

		public override void SpellRelease(bool forceRelease = false)
		{
			TryTriggerSpellReleaseHaptics();
			OnValidSpellCast();
		}

		protected override void OnHold()
		{
		}

		protected override void OnRelease(bool forceRelease = false)
		{
		}

		public override void AbortSpellCasting(bool discret = false, bool backButtonForce = false)
		{
			base.AbortSpellCasting(discret, backButtonForce);
			if (!backButtonForce)
			{
				StopAllCoroutines();
				m_durability = m_startDurability;
				if (m_isArmorActive)
				{
					SetActive(active: false, discret);
				}
			}
		}

		protected void SetActive(bool active, bool discret = false)
		{
			m_isArmorActive = active;
			SetWandChargeEffectActive(active);
			if (!discret)
			{
				ObjectPoolHandler.GrabFromPool((!active) ? PoolObjectType.ArmorOfTheSunEnd : PoolObjectType.ArmorOfTheSunStart).EnableObject(base.CharacterControl.GetPlayerPosition());
			}
			base.Wielder.IsArmorActive = active;
			Events.ArmorActivationEvent armorActivationEvent = new Events.ArmorActivationEvent();
			armorActivationEvent.IsActive = active;
			EventHub.Publish(armorActivationEvent);
			if (NetworkUtils.ConnectedToGame)
			{
				base.photonView.RPC("PunHighlightActive", RpcTarget.OthersBuffered, active);
			}
		}

		[PunRPC]
		private void PunHighlightActive(bool active)
		{
			base.Wielder.IsArmorActive = active;
			RemoteCharacter remoteCharacter = base.Wielder.RemoteCharacter;
			if (remoteCharacter != null)
			{
				remoteCharacter.CharacterRenderer.SetMaterial(active ? CharacterMaterialType.Rim : CharacterMaterialType.Default, (!active) ? Color.white : Colors.ArmorActiveRim, active);
			}
			base.Wielder.SetTwinsMaterial(active ? CharacterMaterialType.Rim : CharacterMaterialType.Default, (!active) ? Color.white : Colors.ArmorActiveRim, active);
		}

		public override bool CanCast()
		{
			return !m_casting && !m_isArmorActive;
		}
	}
	public class Spell_DevilsTwins : SpellBase
	{
		[Header("Devils Twin")]
		[SerializeField]
		private WandChargeEffect m_instantiationEffect;

		private List<Twin> m_clientTwins;

		private int m_tilesCheckedCount;

		private bool m_holdUntilPressed = true;

		private HashSet<Tile> m_selectedTiles;

		private EventToken m_matchResetEventToken;

		private EventToken m_matchEndedEventToken;

		private List<IPoolObject> m_activeTwins = new List<IPoolObject>();

		private List<IPoolObject> m_poolObjects;

		private object[] m_twinData;

		protected override void OnEnable()
		{
			base.OnEnable();
			m_matchResetEventToken = EventHub.Subscribe<Events.MatchResetEvent>(OnMatchReset);
			m_matchEndedEventToken = EventHub.Subscribe<Events.MatchEndedEvent>(OnMatchEnded);
		}

		protected override void OnDisable()
		{
			base.OnDisable();
			EventHub.Unsubscribe<Events.MatchResetEvent>(m_matchResetEventToken);
			EventHub.Unsubscribe<Events.MatchEndedEvent>(m_matchEndedEventToken);
		}

		protected override void Start()
		{
			base.Start();
			SetWandChargeEffectActive(enable: false);
			if (base.photonView.Owner.IsLocal)
			{
				m_twinData = new object[3]
				{
					1,
					base.Wielder.photonView.ViewID,
					base.photonView.ViewID
				};
				CreateTwinPool((CharacterType)(int)PlayerProperty.Get("C0", base.Wielder.Owner));
			}
		}

		protected override void OnDestroy()
		{
			base.OnDestroy();
			if (m_instantiationEffect != null)
			{
				UnityEngine.Object.Destroy(m_instantiationEffect.gameObject);
			}
		}

		private void OnMatchReset(Events.MatchResetEvent eventData)
		{
			AbortSpellCasting();
		}

		private void OnMatchEnded(Events.MatchEndedEvent eventData)
		{
			AbortSpellCasting();
		}

		public override void AbortSpellCasting(bool discret = false, bool backButtonForce = false)
		{
			base.AbortSpellCasting(discret, backButtonForce);
			if (!backButtonForce)
			{
				m_casting = false;
				if (!discret)
				{
					ClearDuplicates();
				}
			}
		}

		public override bool CanCast()
		{
			return base.CanCast() && PunSingleton<TileManager>.Instance.HasFreeTilesAvailable && !GameControl.Instance.IsCurrentLevel(Level.Basement);
		}

		public override void SpellPress()
		{
			TryTriggerSpellPressHaptics();
			OnPress();
		}

		protected override void OnPress()
		{
			ClearDuplicates(onSpellPress: true);
			m_tilesCheckedCount = 0;
			m_casting = true;
			m_holdUntilPressed = false;
		}

		protected override void OnHold()
		{
		}

		protected override void OnRelease(bool forceRelease = false)
		{
			if (!m_holdUntilPressed)
			{
				m_holdUntilPressed = true;
				if (m_casting)
				{
					DrainEnergy();
					InstantiateDuplicates();
					OnValidSpellCast();
				}
			}
		}

		public void ClearDuplicates(bool onSpellPress = false)
		{
			if (m_activeTwins.IsNullOrEmpty())
			{
				return;
			}
			IPoolObject[] array = m_activeTwins.ToArray();
			foreach (IPoolObject poolObject in array)
			{
				if (onSpellPress)
				{
					(poolObject as Twin).SoftResetTwin();
					ReturnToPool(poolObject);
				}
				else
				{
					poolObject.DisableObject();
				}
			}
		}

		private void InstantiateDuplicates()
		{
			if (GameControl.Instance.IsCurrentLevel(Level.Basement))
			{
				return;
			}
			PlayInstantiationEffect();
			PlaySfx();
			if (m_selectedTiles == null)
			{
				m_selectedTiles = new HashSet<Tile>();
			}
			else
			{
				m_selectedTiles.Clear();
			}
			for (int i = 0; i < base.PoolSize; i++)
			{
				Tile randomTile = PunSingleton<TileManager>.Instance.GetRandomTile(m_selectedTiles, avoidElevatorTiles: true, tryAvoidActivEffects: true);
				if (randomTile != null)
				{
					m_selectedTiles.Add(randomTile);
				}
			}
			if (m_selectedTiles.Count > 0)
			{
				GetTileAndInstantiate();
			}
			else
			{
				m_casting = false;
			}
		}

		private void GetTileAndInstantiate()
		{
			foreach (Tile selectedTile in m_selectedTiles)
			{
				PunSingleton<TileManager>.Instance.OccupyTile(selectedTile, TileOccupyState.Occupied, null, OnTileOccupiedChecked);
			}
		}

		private void OnTileOccupiedChecked(Tile tile, bool successfullyOccupied)
		{
			if (successfullyOccupied)
			{
				ObjectPoolHandler.GrabFromPool(PoolObjectType.TeleportArrive).EnableObject(tile.transform.position, base.Wielder?.IsBot);
				GrabFromPool().EnableObject(tile.transform.position, tile.photonView.ViewID);
				m_tilesCheckedCount++;
				if (m_tilesCheckedCount == Mathf.Min(m_selectedTiles.Count, base.PoolSize))
				{
					m_casting = false;
				}
			}
			else
			{
				Tile randomTile = PunSingleton<TileManager>.Instance.GetRandomTile(m_selectedTiles, avoidElevatorTiles: true, tryAvoidActivEffects: true);
				if (randomTile == null)
				{
					WandsLogger.Log("Twin could not instantiate, no free tiles.", LogType.Warning);
					m_casting = false;
				}
				else
				{
					m_selectedTiles.Add(randomTile);
					PunSingleton<TileManager>.Instance.OccupyTile(randomTile, TileOccupyState.Occupied, null, OnTileOccupiedChecked);
				}
			}
		}

		private void PlayInstantiationEffect()
		{
			if (!(m_instantiationEffect == null))
			{
				m_instantiationEffect.DisableEmitters(m_instantiationEffect.gameObject);
				SetWandChargeEffectActive(enable: true);
			}
		}

		public void AddClientTwin(Twin twin)
		{
			if (m_clientTwins == null)
			{
				m_clientTwins = new List<Twin>();
			}
			if (!m_clientTwins.Contains(twin))
			{
				m_clientTwins.Add(twin);
			}
		}

		public void SetTwinsMaterial(CharacterMaterialType materialType, Color color, bool blockFlash)
		{
			if (m_clientTwins.IsNullOrEmpty())
			{
				return;
			}
			foreach (Twin clientTwin in m_clientTwins)
			{
				if (clientTwin != null)
				{
					clientTwin.CharacterRenderer.SetMaterial(materialType, color, blockFlash);
				}
			}
		}

		public void CreateTwinPool(CharacterType type)
		{
			if (m_poolObjects.IsNullOrEmpty())
			{
				m_poolObjects = new List<IPoolObject>();
				for (int i = 0; i < base.PoolSize; i++)
				{
					m_poolObjects.Add(Spawn(type));
				}
			}
		}

		public void ReturnToPool(IPoolObject instance)
		{
			if (!m_poolObjects.Contains(instance))
			{
				if (m_activeTwins.Contains(instance))
				{
					m_activeTwins.Remove(instance);
				}
				m_poolObjects.Add(instance);
			}
		}

		public IPoolObject GrabFromPool()
		{
			if (m_poolObjects.IsNullOrEmpty())
			{
				WandsLogger.LogError("Pool objects collection is empty or null", LogColor.ObjectPooling);
				return null;
			}
			IPoolObject poolObject = m_poolObjects[0];
			m_poolObjects.Remove(poolObject);
			m_activeTwins.Add(poolObject);
			return poolObject;
		}

		private IPoolObject Spawn(CharacterType type)
		{
			return NetworkUtils.Instantiate("CharacterControllers/TwinController", Vector3.zero, Quaternion.identity, 0, m_twinData)?.GetComponent<IPoolObject>();
		}
	}
}
public class Spell_HeavenlyDome : SpellBase_Defense
{
	private const string DomeStartClipName = "heavenly_dome_start";

	private const string DomeEndClipName = "heavenly_dome_end";

	private const float DomeClipVolume = 0.8f;

	protected override void SerializeView(PhotonStream stream, PhotonMessageInfo info)
	{
		if (stream.IsWriting)
		{
			stream.SendNext(base.transform.position);
		}
		else
		{
			base.transform.position = (Vector3)stream.ReceiveNext();
		}
	}

	protected override void OnHold()
	{
		if (OutOfEnergy((0f - m_manaDrainPerSecond) * Time.deltaTime))
		{
			AbortSpellCasting();
			return;
		}
		base.Wielder.ChangeMana((0f - m_manaDrainPerSecond) * Time.deltaTime, blockManaReg: true);
		UpdatePosition();
	}

	protected override void OnRelease(bool forceRelease = false)
	{
		m_casting = false;
		AbortSpellCasting();
	}

	protected override void SetActive(bool active, bool playSound = true, bool playAnimation = true)
	{
		base.SetActive(active);
		if (playSound)
		{
			PlaySound((!active) ? "heavenly_dome_end" : "heavenly_dome_start", 0.8f);
		}
	}

	protected override void UpdatePosition()
	{
		if (base.CharacterControl != null)
		{
			base.transform.position = base.CharacterControl.GetPlayerPosition();
		}
	}
}
public class Spell_ShieldOfLight : SpellBase_Defense
{
	private const float LerpSpeed = 16f;

	private const float DistanceFromPlayerAim = 0.9f;

	private const string ShieldStartClipName = "shield_of_light_start";

	private const string ShieldEndClipName = "shield_of_light_end";

	private const float ShieldClipNameVolume = 0.7f;

	private readonly Vector3 m_headAimOffsetPosition = Vector3.up * -0.25f;

	private Vector3 m_targetPosition;

	private Quaternion m_targetRotation = Quaternion.identity;

	protected override void SerializeView(PhotonStream stream, PhotonMessageInfo info)
	{
		if (stream.IsWriting)
		{
			stream.SendNext(base.transform.position);
			stream.SendNext(base.transform.rotation);
		}
		else
		{
			m_targetPosition = (Vector3)stream.ReceiveNext();
			m_targetRotation = (Quaternion)stream.ReceiveNext();
		}
	}

	private void LateUpdate()
	{
		if (!(base.Wielder == null) && !base.Wielder.IsLocal)
		{
			float t = Time.deltaTime * 16f;
			base.transform.SetPositionAndRotation(Vector3.Lerp(base.transform.position, m_targetPosition, t), Quaternion.Lerp(base.transform.rotation, m_targetRotation, t));
		}
	}

	protected override void OnHold()
	{
		if (OutOfEnergy((0f - m_manaDrainPerSecond) * Time.deltaTime))
		{
			AbortSpellCasting();
			return;
		}
		base.Wielder.ChangeMana((0f - m_manaDrainPerSecond) * Time.deltaTime, blockManaReg: true);
		UpdatePosition();
	}

	protected override void OnRelease(bool forceRelease = false)
	{
		AbortSpellCasting();
	}

	protected override void SetActive(bool active, bool playSound = true, bool playAnimation = true)
	{
		base.SetActive(active, playSound, playAnimation);
		if (playSound)
		{
			PlaySound((!active) ? "shield_of_light_end" : "shield_of_light_start", 0.7f);
		}
	}

	[PunRPC]
	protected override void PunSetActive(bool active, Vector3 position, Quaternion rotation)
	{
		base.PunSetActive(active, position, rotation);
		m_targetRotation = rotation;
		m_targetPosition = position;
	}

	protected override void UpdatePosition()
	{
		if (base.Wielder.IsBot)
		{
			base.transform.position = m_wandControl.Aim.AimRay.GetPoint(0.9f) + m_headAimOffsetPosition;
			base.transform.rotation = m_wandControl.Aim.AimPivot.rotation;
		}
		else if (base.IsPlayerControlled)
		{
			base.transform.position = ((base.PlayerControl.Input.AimInput == AimInput.Head) ? (m_wandControl.PlayerAim.CameraRay.GetPoint(0.9f) + m_headAimOffsetPosition) : m_wandControl.Aim.AimRay.GetPoint(0.9f));
			base.transform.rotation = m_wandControl.Aim.AimPivot.rotation;
		}
	}
}
namespace Assets.Scripts.Spells.Defense
{
	[RequireComponent(typeof(PhotonView), typeof(CharacterRenderer))]
	public class Twin : CharacterBase, IDestructableObject, IPoolObject, ICursable
	{
		private PhotonView m_photonView;

		private Spell_DevilsTwins m_spell;

		private bool m_isInitialized;

		private CurseLingeringEffect m_curseLingeringEffect;

		private ParticleAudioEffect m_chillingClutchEffect;

		public bool IsSetToDisable { get; private set; }

		private Wielder Wielder { get; set; }

		public PhotonView photonView
		{
			[CompilerGenerated]
			get
			{
				return (!(m_photonView != null)) ? (m_photonView = PhotonView.Get(this)) : m_photonView;
			}
		}

		private void Awake()
		{
			if (photonView.InstantiationData.IsNullOrEmpty())
			{
				WandsLogger.LogError("Instantiation data for network instantiated TWIN is null!");
				return;
			}
			Wielder = PhotonView.Find((int)photonView.InstantiationData[1])?.GetComponent<Wielder>();
			m_spell = PhotonView.Find((int)photonView.InstantiationData[2])?.GetComponent<Spell_DevilsTwins>();
			if (m_spell == null)
			{
				throw new UnityException("No SPELL connected to Twin");
			}
			if (!photonView.Owner.IsLocal)
			{
				m_spell.AddClientTwin(this);
			}
		}

		private void Start()
		{
			if (!m_isInitialized)
			{
				if (Wielder == null)
				{
					WandsLogger.LogError("No Wielder connected to Twin.");
					return;
				}
				if (GameControl.Instance.IsCurrentLevel(Level.Basement))
				{
					PunDisableObject();
					return;
				}
				base.CharacterRenderer = GetComponent<CharacterRenderer>();
				base.CharacterRenderer.Initialize((CharacterType)(int)PlayerProperty.Get("C0", Wielder.Owner));
				base.Collider = base.CharacterRenderer.Body.GetComponentInChildren<CapsuleCollider>();
				ParentStatsToBody();
				m_statsUI.Initialize(Wielder.HealthData, PlayerManager.Instance.PlayerControl.CameraTransform);
				m_aimInput = (AimInput)(int)PlayerProperty.Get("P4", Wielder.Owner);
				m_wandHand = m_aimInput.ToWandHand();
				SetCorrectApperence(Wielder.Owner);
				TrySpawnWands(Wielder.Owner);
				SetRootPosition(checkIfLobby: false);
				base.Movement.MovementStartTwin(Wielder, m_aimInput, base.CharacterRenderer);
				PunDisableObject();
				m_isInitialized = true;
			}
		}

		private void Update()
		{
			if (!(base.Collider == null))
			{
				base.Collider.transform.position = base.Movement.ColliderTargetPosition;
			}
		}

		public void SoftResetTwin()
		{
			DisconnectTile();
			m_statsUI.gameObject.SetActive(value: false);
		}

		private void DisconnectTile()
		{
			if (!(base.ConnectedTile == null))
			{
				PunSingleton<TileManager>.Instance?.OccupyTile(base.ConnectedTile, TileOccupyState.Unoccupied);
				base.ConnectedTile = null;
			}
		}

		public void EnableObject(Vector3 position, params object[] data)
		{
			int num = (int)data[0];
			Tile tile = PhotonView.Find(num)?.GetComponent<Tile>();
			SetConnectedTile(tile);
			photonView.RPC("PunEnableObject", RpcTarget.AllViaServer, position, num);
			PunSingleton<TileManager>.Instance.OccupyTile(tile, TileOccupyState.Occupied, photonView);
		}

		[PunRPC]
		private void PunEnableObject(Vector3 position, int tileId)
		{
			base.transform.position = position;
			if (!photonView.Owner.IsLocal)
			{
				Start();
				SetConnectedTile(PhotonView.Find(tileId).GetComponent<Tile>());
			}
			m_statsUI.gameObject.SetActive(value: true);
			PunSingleton<SoundManager>.Instance.PlayLocalSoundAtPoint("devils_twins_cast", 1f, base.transform.position);
			base.Collider.enabled = true;
			base.gameObject.SetActive(value: true);
			Wielder.AddTwin(this);
			Events.DestructableSpawnedEvent destructableSpawnedEvent = new Events.DestructableSpawnedEvent();
			destructableSpawnedEvent.Destructable = this;
			EventHub.Publish(destructableSpawnedEvent);
		}

		public void DisableObject()
		{
			if (base.ConnectedTile != null)
			{
				PunSingleton<TileManager>.Instance?.OccupyTile(base.ConnectedTile, TileOccupyState.Unoccupied);
				base.ConnectedTile = null;
			}
			TryDisableChillingClutch();
			TryDisableActiveCurse();
			m_spell.ReturnToPool(this);
			photonView.RPC("PunDisableObject", RpcTarget.AllViaServer, null);
		}

		[PunRPC]
		private void PunDisableObject()
		{
			IsSetToDisable = false;
			if (base.gameObject != null)
			{
				base.gameObject.SetActive(value: false);
				if (m_spell != null)
				{
					base.transform.SetParent(m_spell.transform);
				}
			}
			Wielder.RemoveTwin(this);
		}

		public void OnHit(float dmg = 1f)
		{
			if (!IsSetToDisable && !(base.gameObject == null) && !(this == null))
			{
				IsSetToDisable = true;
				base.Collider.enabled = false;
				if (dmg > 0f)
				{
					PlayerManager.Instance.PlayerControl.Input.PlayHitResponse();
					ObjectPoolHandler.GrabFromPool(PoolObjectType.DevilsTwinDead, null)?.EnableObject(base.transform.position, null);
				}
				if (photonView.IsMine)
				{
					DisableObject();
				}
			}
		}

		protected override void OnMatchReset(Events.MatchResetEvent eventData)
		{
			if (photonView.IsMine)
			{
				m_spell.ReturnToPool(this);
			}
			PunDisableObject();
		}

		public override void SetCorrectApperence(Photon.Realtime.Player photonPlayer)
		{
			base.CharacterRenderer.FetchMaterialReferences();
			if (photonPlayer.IsLocal)
			{
				base.CharacterRenderer.SetMaterial(CharacterMaterialType.Rim, Color.cyan);
			}
			else if (Wielder.IsArmorActive)
			{
				base.CharacterRenderer.SetMaterial(CharacterMaterialType.Rim, Colors.ArmorActiveRim);
			}
			else
			{
				base.CharacterRenderer.SetMaterial(CharacterMaterialType.Default);
			}
		}

		public void SetChillingClutchEffectActive(bool active)
		{
			if (!active)
			{
				TryDisableChillingClutch();
				return;
			}
			if (m_chillingClutchEffect == null)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(Wielder.EffectHandler.LoadedEffects[5], base.transform);
				gameObject.transform.SetLocalPositionAndRotation(Vector3.zero, Quaternion.identity);
				m_chillingClutchEffect = new ParticleAudioEffect(gameObject, gameObject.GetComponent<AudioSource>(), gameObject.GetComponentsInChildren<ParticleSystem>());
			}
			else if (m_chillingClutchEffect.GameObject.activeSelf)
			{
				return;
			}
			m_chillingClutchEffect.GameObject.SetActive(value: true);
			m_chillingClutchEffect.SetEmittersActive(active);
			m_chillingClutchEffect.TrySetAudioActive(active);
		}

		private void TryDisableChillingClutch()
		{
			if (m_chillingClutchEffect != null)
			{
				m_chillingClutchEffect.GameObject.SetActive(value: false);
			}
		}

		public void EnableCurse(float waitTime, CurseLingeringEffect curseLingeringEffect)
		{
			TryDisableActiveCurse();
			m_curseLingeringEffect = curseLingeringEffect;
		}

		public void DisableCurse()
		{
			m_curseLingeringEffect = null;
		}

		private void TryDisableActiveCurse()
		{
			if (!(m_curseLingeringEffect == null))
			{
				m_curseLingeringEffect.DisableObject();
				m_curseLingeringEffect = null;
			}
		}
	}
}
namespace Assets.Scripts.Spells
{
	public class DragonsBreath : IPredictableCurver
	{
		public enum DragonState
		{
			Colliding,
			Active,
			Inactive
		}

		private static Collider[] sm_colliders = new Collider[4];

		private float m_speed;

		private float m_currentLifeTime;

		private LayerMask m_layerMask;

		private bool m_checkCollision = true;

		private const float WaitTime = 0.1f;

		public float StartSpeed { get; private set; }

		public float Radius { get; private set; }

		public float LifeTime { get; private set; }

		public AnimationCurve Curve { get; private set; }

		public Vector3 StartPosition { get; private set; }

		public Vector3 Direction { get; private set; }

		public Vector3 Position { get; private set; }

		public DragonState State { get; private set; }

		public Collider HitCollider { get; private set; }

		public DragonsBreath(Vector3 point, Vector3 direction, float speed, float radius, LayerMask layerMask, AnimationCurve speedDecay, float lifeTime)
		{
			Position = point;
			Direction = direction;
			m_speed = speed;
			Radius = radius;
			m_layerMask = layerMask;
			Curve = speedDecay;
			LifeTime = lifeTime;
			StartSpeed = speed;
			StartPosition = Position;
			if (MonoSingleton<NetworkManager>.Instance.CurrentMatchType.ContainsFlag(MatchType.Bot))
			{
				EventHub.Publish(new Events.PredictableCurverCastEvent
				{
					PredictableCurver = this
				});
			}
		}

		public void UpdateBreath()
		{
			m_currentLifeTime += Time.fixedDeltaTime;
			if (m_currentLifeTime >= LifeTime + 0.1f)
			{
				State = DragonState.Inactive;
				return;
			}
			m_speed = StartSpeed * Curve.Evaluate(m_currentLifeTime / LifeTime);
			Position += Direction * m_speed * Time.fixedDeltaTime;
			if (m_checkCollision)
			{
				int num = Physics.OverlapSphereNonAlloc(Position, Radius, sm_colliders, m_layerMask);
				if (num > 0)
				{
					HitCollider = sm_colliders[0];
					if (m_currentLifeTime < LifeTime)
					{
						m_currentLifeTime = LifeTime;
					}
					State = DragonState.Colliding;
					return;
				}
				m_checkCollision = false;
			}
			else
			{
				m_checkCollision = true;
			}
			State = DragonState.Active;
		}
	}
}
namespace Assets.Scripts.Spells.Interfaces
{
	public interface IPredictableCurver
	{
		float StartSpeed { get; }

		float Radius { get; }

		float LifeTime { get; }

		AnimationCurve Curve { get; }

		Vector3 StartPosition { get; }

		Vector3 Direction { get; }
	}
}
namespace Assets.Scripts.Spells
{
	public enum PoolObjectCreateState
	{
		Enabled = 1,
		Disabled = 2,
		AddInternal = 4
	}
	public static class ObjectPoolHandler
	{
		private static readonly Dictionary<PoolObjectType, List<IPoolObject>> sm_objectPool = new Dictionary<PoolObjectType, List<IPoolObject>>(8);

		private static readonly Dictionary<Spell, List<IPoolObject>> sm_spellPool = new Dictionary<Spell, List<IPoolObject>>(8);

		private static readonly Dictionary<PoolObjectType, string> sm_objectTypeNames = new Dictionary<PoolObjectType, string>
		{
			{
				PoolObjectType.Teleport,
				PoolObjectType.Teleport.ToString()
			},
			{
				PoolObjectType.TeleportArrive,
				PoolObjectType.TeleportArrive.ToString()
			},
			{
				PoolObjectType.ArmorOfTheSunStart,
				PoolObjectType.ArmorOfTheSunStart.ToString()
			},
			{
				PoolObjectType.ArmorOfTheSunEnd,
				PoolObjectType.ArmorOfTheSunEnd.ToString()
			},
			{
				PoolObjectType.CerberusCollarsInit,
				PoolObjectType.CerberusCollarsInit.ToString()
			},
			{
				PoolObjectType.CurseOfTheUndeadExplosion,
				PoolObjectType.CurseOfTheUndeadExplosion.ToString()
			},
			{
				PoolObjectType.OxymoraProjectileBad,
				PoolObjectType.OxymoraProjectileBad.ToString()
			},
			{
				PoolObjectType.OxymoraProjectileGood,
				PoolObjectType.OxymoraProjectileGood.ToString()
			},
			{
				PoolObjectType.SkullSpecterInit,
				PoolObjectType.SkullSpecterInit.ToString()
			},
			{
				PoolObjectType.SkullSpecterProjectile,
				PoolObjectType.SkullSpecterProjectile.ToString()
			},
			{
				PoolObjectType.StoneDemonProjectile,
				PoolObjectType.StoneDemonProjectile.ToString()
			},
			{
				PoolObjectType.ShockRifleSmall,
				PoolObjectType.ShockRifleSmall.ToString()
			},
			{
				PoolObjectType.DevilsTwinDead,
				PoolObjectType.DevilsTwinDead.ToString()
			},
			{
				PoolObjectType.TrailProjectile,
				PoolObjectType.TrailProjectile.ToString()
			},
			{
				PoolObjectType.SkeletonProjectile,
				PoolObjectType.SkeletonProjectile.ToString()
			},
			{
				PoolObjectType.ValeCrystalProjectile,
				PoolObjectType.ValeCrystalProjectile.ToString()
			},
			{
				PoolObjectType.ValeCrystalHeal,
				$"Vfx/{PoolObjectType.ValeCrystalHeal}"
			},
			{
				PoolObjectType.TrashProjectile,
				PoolObjectType.TrashProjectile.ToString()
			},
			{
				PoolObjectType.ArcerProjectile,
				PoolObjectType.ArcerProjectile.ToString()
			},
			{
				PoolObjectType.HulkLightning,
				PoolObjectType.HulkLightning.ToString()
			},
			{
				PoolObjectType.CurseOfTheUndeadLingering,
				PoolObjectType.CurseOfTheUndeadLingering.ToString()
			},
			{
				PoolObjectType.TileDamageOccupier,
				PoolObjectType.TileDamageOccupier.ToString()
			}
		};

		private static readonly Dictionary<Spell, string> sm_spellTypeNames = new Dictionary<Spell, string>
		{
			{
				Spell.Spell_Teleport,
				Spell.Spell_Teleport.ToString().Replace("Spell_", string.Empty)
			},
			{
				Spell.Spell_ShieldOfLight,
				Spell.Spell_ShieldOfLight.ToString().Replace("Spell_", string.Empty)
			},
			{
				Spell.Spell_HeavenlyDome,
				Spell.Spell_HeavenlyDome.ToString().Replace("Spell_", string.Empty)
			},
			{
				Spell.Spell_ArmorOfTheSun,
				Spell.Spell_ArmorOfTheSun.ToString().Replace("Spell_", string.Empty)
			},
			{
				Spell.Spell_LightningStrike,
				Spell.Spell_LightningStrike.ToString().Replace("Spell_", string.Empty)
			},
			{
				Spell.Spell_AcidCloud,
				Spell.Spell_AcidCloud.ToString().Replace("Spell_", string.Empty)
			},
			{
				Spell.Spell_DevilsTwins,
				Spell.Spell_DevilsTwins.ToString().Replace("Spell_", string.Empty)
			},
			{
				Spell.Spell_HailOfDeath,
				Spell.Spell_HailOfDeath.ToString().Replace("Spell_", string.Empty)
			},
			{
				Spell.Spell_DevilsSpit,
				Spell.Spell_DevilsSpit.ToString().Replace("Spell_", string.Empty)
			},
			{
				Spell.Spell_FlamingPhoenix,
				Spell.Spell_FlamingPhoenix.ToString().Replace("Spell_", string.Empty)
			},
			{
				Spell.Spell_ElectricFist,
				Spell.Spell_ElectricFist.ToString().Replace("Spell_", string.Empty)
			},
			{
				Spell.Spell_ChaosLeap,
				Spell.Spell_ChaosLeap.ToString().Replace("Spell_", string.Empty)
			},
			{
				Spell.Spell_BlazingMeteor,
				Spell.Spell_BlazingMeteor.ToString().Replace("Spell_", string.Empty)
			},
			{
				Spell.Spell_StoneDemon,
				Spell.Spell_StoneDemon.ToString().Replace("Spell_", string.Empty)
			},
			{
				Spell.Spell_SoilSpikes,
				Spell.Spell_SoilSpikes.ToString().Replace("Spell_", string.Empty)
			},
			{
				Spell.Spell_PetrifyingPrison,
				Spell.Spell_PetrifyingPrison.ToString().Replace("Spell_", string.Empty)
			},
			{
				Spell.Spell_MagicMissile,
				Spell.Spell_MagicMissile.ToString().Replace("Spell_", string.Empty)
			},
			{
				Spell.Spell_BloodBolt,
				Spell.Spell_BloodBolt.ToString().Replace("Spell_", string.Empty)
			},
			{
				Spell.Spell_CurseOfTheUndead,
				Spell.Spell_CurseOfTheUndead.ToString().Replace("Spell_", string.Empty)
			},
			{
				Spell.Spell_DragonsBreath,
				Spell.Spell_DragonsBreath.ToString().Replace("Spell_", string.Empty)
			},
			{
				Spell.Spell_Oxymora,
				Spell.Spell_Oxymora.ToString().Replace("Spell_", string.Empty)
			},
			{
				Spell.Spell_Demi,
				Spell.Spell_Demi.ToString().Replace("Spell_", string.Empty)
			},
			{
				Spell.Spell_DiscOfAntioch,
				Spell.Spell_DiscOfAntioch.ToString().Replace("Spell_", string.Empty)
			},
			{
				Spell.Spell_CerberusCollars,
				Spell.Spell_CerberusCollars.ToString().Replace("Spell_", string.Empty)
			},
			{
				Spell.Spell_ChillingClutch,
				Spell.Spell_ChillingClutch.ToString().Replace("Spell_", string.Empty)
			},
			{
				Spell.Spell_SkullSpecter,
				Spell.Spell_SkullSpecter.ToString().Replace("Spell_", string.Empty)
			}
		};

		private static GameObject sm_poolParent;

		private static int sm_lastSpellObjectHashCode = 0;

		private static List<IPoolObject> sm_objectRef;

		private static List<IPoolObject> sm_spellRef;

		public static Transform PoolParent
		{
			[CompilerGenerated]
			get
			{
				return sm_poolParent.transform;
			}
		}

		public static void Initialize()
		{
			sm_poolParent = new GameObject("Object Pool");
			UnityEngine.Object.DontDestroyOnLoad(sm_poolParent);
			EventHub.Subscribe<Events.SceneLoadInitiatedEvent>(OnSceneLoadInitiated);
		}

		private static void OnSceneLoadInitiated(Events.SceneLoadInitiatedEvent eventData)
		{
			ClearEntirePool();
		}

		public static bool GetPoolContainsObject(PoolObjectType type)
		{
			return sm_objectPool.ContainsKey(type);
		}

		public static bool GetPoolContainsSpell(Spell type)
		{
			return sm_spellPool.ContainsKey(type);
		}

		public static void ClearEntirePool()
		{
			sm_spellPool.Clear();
			sm_objectPool.Clear();
		}

		public static void DestroySpellPool()
		{
			foreach (List<IPoolObject> value in sm_spellPool.Values)
			{
				foreach (IPoolObject item in value)
				{
					NetworkUtils.DestroyObject(item.photonView);
				}
			}
			sm_spellPool.Clear();
		}

		public static void CreateObjectPool(int poolSize, PoolObjectType effectType, object[] data = null)
		{
			if (sm_objectPool.ContainsKey(effectType))
			{
				if (!MonoSingleton<NetworkManager>.Instance.CurrentMatchType.ContainsFlag(MatchType.Bot))
				{
					WandsLogger.LogError($"Object pool already contains effect of type {effectType}", LogColor.ObjectPooling);
					return;
				}
				sm_objectPool[effectType].Capacity += poolSize;
			}
			else
			{
				sm_objectPool.Add(effectType, new List<IPoolObject>(poolSize));
			}
			for (int i = 0; i < poolSize; i++)
			{
				Spawn(effectType, PoolObjectCreateState.AddInternal, data);
			}
		}

		public static void CreateObjectPoolAsync(int poolSize, PoolObjectType effectType, int[] viewID = null)
		{
			CreateObjectPoolAsync(poolSize, effectType, PoolObjectCreateState.AddInternal, viewID);
		}

		public static void CreateObjectPoolAsync(int poolSize, PoolObjectType effectType, PoolObjectCreateState createState, int[] viewID = null)
		{
			if (sm_objectPool.ContainsKey(effectType))
			{
				if (!MonoSingleton<NetworkManager>.Instance.CurrentMatchType.ContainsFlag(MatchType.Bot))
				{
					WandsLogger.LogError($"Object pool already contains effect of type {effectType}", LogColor.ObjectPooling);
					return;
				}
				sm_objectPool[effectType].Capacity += poolSize;
			}
			else
			{
				sm_objectPool.Add(effectType, new List<IPoolObject>(poolSize));
			}
			for (int i = 0; i < poolSize; i++)
			{
				SpawnAsync(effectType, createState, null, (!viewID.IsNullOrEmpty()) ? viewID[i] : 0);
			}
		}

		public static void TryReturnToPool(PoolObjectType type, IPoolObject instance)
		{
			if (sm_objectPool.TryGetValue(type, out sm_objectRef))
			{
				if (!sm_objectRef.Contains(instance))
				{
					sm_objectPool[type].Add(instance);
				}
			}
			else
			{
				NetworkUtils.DestroyObject(instance.photonView);
			}
		}

		private static void TryReturnToPoolInternal(PoolObjectType type, IPoolObject instance)
		{
			if (sm_objectPool.TryGetValue(type, out sm_objectRef))
			{
				if (!sm_objectPool[type].Contains(instance))
				{
					sm_objectPool[type].Add(instance);
				}
			}
			else
			{
				WandsLogger.LogError($"Can't return object {instance} of type {type.ToString().ToUpper()}, pool doesn't exist.", LogColor.ObjectPooling);
			}
		}

		public static IPoolObject GrabFromPool(PoolObjectType type, params object[] data)
		{
			if (!sm_objectPool.ContainsKey(type))
			{
				WandsLogger.LogError($"Object Pool doesn't contain type {type.ToString().ToUpper()}.", LogColor.ObjectPooling);
				return null;
			}
			List<IPoolObject> list = sm_objectPool[type];
			if (list.IsNullOrEmpty())
			{
				return Spawn(type, PoolObjectCreateState.Enabled, data);
			}
			IPoolObject result = list[0];
			list.RemoveAt(0);
			return result;
		}

		private static IPoolObject Spawn(PoolObjectType type, PoolObjectCreateState createState, params object[] data)
		{
			IPoolObject component = NetworkUtils.Instantiate(sm_objectTypeNames[type], Vector3.zero, Quaternion.identity, 0, data).GetComponent<IPoolObject>();
			if (component == null)
			{
				WandsLogger.LogError("No IPoolObject interface found on instantiated object", LogColor.ObjectPooling);
				return null;
			}
			if (createState.ContainsFlag(PoolObjectCreateState.Disabled))
			{
				component.DisableObject();
			}
			if (createState.ContainsFlag(PoolObjectCreateState.AddInternal))
			{
				TryReturnToPoolInternal(type, component);
			}
			return component;
		}

		private static void SpawnAsync(PoolObjectType type, PoolObjectCreateState createState, Action<IPoolObject> onLoaded, params object[] data)
		{
			NetworkUtils.InstantiateAsync(sm_objectTypeNames[type], Vector3.zero, Quaternion.identity, 0, delegate(GameObject loadedObject)
			{
				OnSpawnedObject(type, createState, onLoaded, loadedObject);
			}, data);
		}

		private static void OnSpawnedObject(PoolObjectType type, PoolObjectCreateState createState, Action<IPoolObject> onLoaded, GameObject loadedObject)
		{
			if (loadedObject == null)
			{
				WandsLogger.LogError("No IPoolObject interface found on instantiated object", LogColor.ObjectPooling);
				onLoaded?.Invoke(null);
				return;
			}
			IPoolObject component = loadedObject.GetComponent<IPoolObject>();
			if (createState.ContainsFlag(PoolObjectCreateState.Disabled))
			{
				component.DisableObject();
			}
			if (createState.ContainsFlag(PoolObjectCreateState.AddInternal))
			{
				TryReturnToPoolInternal(type, component);
			}
			onLoaded?.Invoke(component);
		}

		public static void CreateSpellPool(int poolSize, Spell spellType, int viewID = 0, PoolObjectType[] additionalObjects = null)
		{
			CreateSpellPool(poolSize, spellType, PoolObjectCreateState.AddInternal, viewID, additionalObjects);
		}

		public static void CreateSpellPool(int poolSize, Spell spellType, PoolObjectCreateState createState, int viewID = 0, PoolObjectType[] additionalObjects = null)
		{
			if (sm_spellPool.ContainsKey(spellType))
			{
				if (!MonoSingleton<NetworkManager>.Instance.CurrentMatchType.ContainsFlag(MatchType.Bot))
				{
					WandsLogger.LogError($"Object pool already contains effect of type {spellType}", LogColor.ObjectPooling);
					return;
				}
				sm_spellPool[spellType].Capacity += poolSize;
			}
			else
			{
				sm_spellPool.Add(spellType, new List<IPoolObject>(poolSize));
			}
			SpawnMultipleAsync(spellType, createState, poolSize, delegate(IPoolObject[] poolObjects)
			{
				OnLoadedSpells(createState, additionalObjects, poolObjects);
			}, viewID);
		}

		private static void OnLoadedSpells(PoolObjectCreateState createState, PoolObjectType[] additionalObjects, IPoolObject[] poolObjects)
		{
			int[] array = new int[poolObjects.Length];
			for (int i = 0; i < poolObjects.Length; i++)
			{
				array[i] = poolObjects[i].photonView.ViewID;
			}
			if (!additionalObjects.IsNullOrEmpty())
			{
				foreach (PoolObjectType effectType in additionalObjects)
				{
					CreateObjectPoolAsync(poolObjects.Length, effectType, createState, array);
				}
			}
		}

		public static void TryReturnToPool(Spell type, IPoolObject instance)
		{
			if (sm_spellPool.TryGetValue(type, out sm_spellRef))
			{
				if (!sm_spellRef.Contains(instance))
				{
					sm_spellPool[type].Add(instance);
				}
			}
			else
			{
				NetworkUtils.DestroyObject(instance.photonView);
			}
		}

		private static void TryReturnToPoolInternal(Spell type, IPoolObject instance)
		{
			if (sm_spellPool.TryGetValue(type, out sm_spellRef))
			{
				if (!sm_spellRef.Contains(instance))
				{
					sm_spellPool[type].Add(instance);
				}
			}
			else
			{
				WandsLogger.LogError($"Can't return spell {instance} of type {type.ToString().ToUpper()}, pool doesn't exist.", LogColor.ObjectPooling);
			}
		}

		public static IPoolObject GrabFromPool(Spell type, params object[] data)
		{
			if (!sm_spellPool.TryGetValue(type, out var value))
			{
				WandsLogger.LogError($"Spell Pool doesn't contain key of type {type.ToString().ToUpper()} | Make sure you create a pool before trying to grab from it", LogColor.ObjectPooling);
				return null;
			}
			if (value.IsNullOrEmpty())
			{
				return Spawn(type, PoolObjectCreateState.Enabled, data);
			}
			IPoolObject poolObject = value[0];
			value.RemoveAt(0);
			if (sm_lastSpellObjectHashCode == poolObject.GetHashCode())
			{
				return Spawn(type, PoolObjectCreateState.Enabled, data);
			}
			sm_lastSpellObjectHashCode = poolObject.GetHashCode();
			return poolObject;
		}

		private static void SpawnMultipleAsync(Spell type, PoolObjectCreateState createState, int amount, Action<IPoolObject[]> onLoaded, params object[] data)
		{
			NetworkUtils.InstantiateMultipleAsync(sm_spellTypeNames[type], Vector3.zero, Quaternion.identity, 0, amount, delegate(GameObject[] loadedObjects)
			{
				OnInstantiatedMultiple(type, createState, onLoaded, loadedObjects);
			}, data);
		}

		private static void OnInstantiatedMultiple(Spell type, PoolObjectCreateState createState, Action<IPoolObject[]> onLoaded, GameObject[] instantiatedGameObjects)
		{
			IPoolObject[] array = new IPoolObject[instantiatedGameObjects.Length];
			for (int i = 0; i < instantiatedGameObjects.Length; i++)
			{
				IPoolObject poolObject = (array[i] = instantiatedGameObjects[i].GetComponent<IPoolObject>());
				if (createState.ContainsFlag(PoolObjectCreateState.Disabled))
				{
					poolObject.DisableObject();
				}
				if (createState.ContainsFlag(PoolObjectCreateState.AddInternal))
				{
					TryReturnToPoolInternal(type, poolObject);
				}
			}
			onLoaded(array);
		}

		private static IPoolObject Spawn(Spell type, PoolObjectCreateState createState, params object[] data)
		{
			IPoolObject component = NetworkUtils.Instantiate(sm_spellTypeNames[type], Vector3.zero, Quaternion.identity, 0, data).GetComponent<IPoolObject>();
			if (component == null)
			{
				WandsLogger.LogError("No IPoolObject interface found on instantiated object", LogColor.ObjectPooling);
				return null;
			}
			if (createState.ContainsFlag(PoolObjectCreateState.Disabled))
			{
				component.DisableObject();
			}
			if (createState.ContainsFlag(PoolObjectCreateState.AddInternal))
			{
				TryReturnToPoolInternal(type, component);
			}
			return component;
		}
	}
}
namespace Assets.Scripts.Spells.Projectile
{
	[RequireComponent(typeof(SplashDamageHandler))]
	public class BlazingMeteor : ProjectileMover, IProjectileAccelerate, IProjectileSplash
	{
		[StructLayout(LayoutKind.Sequential, Size = 1)]
		private struct DefaultAccelerationParams
		{
			public const float MaxSpeed = 1.54f;

			public const float AccelerationSpeed = 0.65f;
		}

		private SplashDamageHandler m_splashDamageHandler;

		public SplashDamageHandler SplashDamageHandler
		{
			get
			{
				if (m_splashDamageHandler == null)
				{
					m_splashDamageHandler = GetComponent<SplashDamageHandler>();
				}
				return m_splashDamageHandler;
			}
		}

		public bool ShouldAccelerate { get; set; } = true;


		public float AccelerationSpeed { get; set; } = 0.65f;


		public float MaxSpeed { get; private set; } = 1.54f;


		protected override void SetStaticValues(SpellBase_Projectile spell)
		{
			base.SetStaticValues(spell);
			SplashDamageHandler.SetData(spell.SplashDamageData);
		}

		protected override void FixedUpdate()
		{
			if (base.IsPaused || m_collided || m_hasExploded)
			{
				return;
			}
			if (m_followPath)
			{
				Move();
				if (ShouldAccelerate)
				{
					Accelerate();
				}
			}
			DetectCollision();
		}

		public override void EnableObject(Vector3 startPosition, params object[] data)
		{
			base.EnableObject(startPosition, data);
		}

		public void Accelerate()
		{
			m_currentMoveSpeed += AccelerationSpeed * Time.fixedDeltaTime;
			if (m_currentMoveSpeed >= MaxSpeed)
			{
				m_currentMoveSpeed = MaxSpeed;
				ShouldAccelerate = false;
			}
		}

		protected override void OnCollision(Collider hitCollider, bool enableHitEffect)
		{
			base.OnCollision(hitCollider, enableHitEffect);
			SplashDamageHandler.DealSplashDamage(m_spellDmg, this, hitCollider, dealMinDamage: true);
		}

		[PunRPC]
		protected override void PunDisableProjectile(bool returnToPool)
		{
			ShouldAccelerate = false;
			base.PunDisableProjectile(returnToPool);
			ShouldAccelerate = true;
		}
	}
}
namespace Assets.Scripts.Spells.Utils
{
	public class BounceHandler : MonoBehaviour
	{
		[SerializeField]
		private ProjectileEffectHandler m_bounceEffectHandler;

		private int m_maxBounces = 1;

		public int CurrentBounces { get; private set; }

		public void ResetBounces(int maxBounces)
		{
			m_maxBounces = maxBounces;
			CurrentBounces = 0;
		}

		public bool TryBounce(RaycastHit hit, bool hitPlayer, Action<Vector3> bounceCallback)
		{
			if (CurrentBounces >= m_maxBounces)
			{
				return false;
			}
			CurrentBounces++;
			ActivateBounceEffects();
			bounceCallback?.Invoke(Vector3.Reflect(base.transform.forward, hit.normal));
			return true;
		}

		public void DestroyBounce()
		{
			if (m_bounceEffectHandler != null)
			{
				UnityEngine.Object.Destroy(m_bounceEffectHandler.gameObject);
			}
		}

		private void ActivateBounceEffects()
		{
			if (!(m_bounceEffectHandler == null))
			{
				m_bounceEffectHandler.DisableAndReturn(base.transform);
				m_bounceEffectHandler.EnableEffect(base.transform);
			}
		}
	}
	public class ProjectileBounceUtils
	{
		public Vector3 GetReflectedForward(Vector3 forward, Vector3 normal)
		{
			return Vector3.Reflect(forward, normal);
		}
	}
}
namespace Assets.Scripts.Spells.Projectile
{
	public class ChillingClutch : ProjectileMover
	{
		private float m_chillingClutchPercent;

		private float m_debuffDuration;

		protected override void ResetBezierAndInitialize(params object[] data)
		{
			m_chillingClutchPercent = (float)data[5];
			m_debuffDuration = (float)data[6];
			base.ResetBezierAndInitialize(data);
		}

		public override bool DealDamagePlayerObject(IDamageable damagableEntity, float dmg)
		{
			if (damagableEntity == null)
			{
				return false;
			}
			if (damagableEntity.TakeDamage(m_dmgType, dmg, GetHitDirection(damagableEntity.GetHitTransform())))
			{
				damagableEntity.ApplyChillingClutch(1f - m_chillingClutchPercent, m_debuffDuration);
				if ((object)m_spell != null)
				{
					m_spell.AddTotalDamage(dmg);
				}
			}
			return true;
		}
	}
	public class Demi : ProjectileMover
	{
		public override bool DealDamagePlayerObject(IDamageable damagableEntity, float dmg)
		{
			if (damagableEntity == null)
			{
				return false;
			}
			dmg = Mathf.FloorToInt(damagableEntity.Health / 2f);
			if (dmg < damagableEntity.Health && damagableEntity.TakeDamage(m_dmgType, dmg, GetHitDirection(damagableEntity.GetHitTransform())) && (object)m_spell != null)
			{
				m_spell.AddTotalDamage(dmg);
			}
			return true;
		}

		public override bool DealDamageTwinAndReturnToSender(Twin twin, float dmg, bool returnToSenderActive)
		{
			if (twin == null)
			{
				return false;
			}
			twin.OnHit(dmg);
			return returnToSenderActive;
		}

		public override void DealDamageTrainingDummy(Collider hitCollider, float dmg)
		{
			if (!GameControl.Instance.IsCurrentLevel(Level.Basement))
			{
				WandsLogger.Log("Called deal damage to training dummy but not in basement, something is wrongly tagged as Dummy", LogType.Warning);
				return;
			}
			TrainingDummy componentInParent = hitCollider.GetComponentInParent<TrainingDummy>();
			if (!(componentInParent == null))
			{
				dmg = Mathf.FloorToInt(componentInParent.CurrentHP / 2f);
				if (dmg < componentInParent.CurrentHP)
				{
					componentInParent.TakeDamage(dmg);
				}
			}
		}

		public override void DealDamageDestructable(Collider hitCollider, float dmg)
		{
			TurretBase componentInParent = hitCollider.GetComponentInParent<TurretBase>();
			if (componentInParent != null)
			{
				dmg = Mathf.FloorToInt(componentInParent.Durability / 2f);
				if (dmg < componentInParent.Durability)
				{
					componentInParent.OnHit(dmg);
				}
			}
			else
			{
				hitCollider.transform.SendMessageUpwards("OnHit", dmg, SendMessageOptions.DontRequireReceiver);
			}
		}
	}
	public class DevilsSpit : ProjectileMover, IProjectileAccelerate
	{
		[StructLayout(LayoutKind.Sequential, Size = 1)]
		private struct DefaultAccelerationParams
		{
			public const float MaxSpeed = 1.54f;

			public const float AccelerationSpeed = 0.65f;
		}

		public bool ShouldAccelerate { get; set; } = true;


		public float AccelerationSpeed { get; set; } = 0.65f;


		public float MaxSpeed { get; private set; } = 1.54f;


		public override void EnableObject(Vector3 startPosition, params object[] data)
		{
			base.EnableObject(startPosition, data);
		}

		protected override void FixedUpdate()
		{
			if (base.IsPaused || m_collided || m_hasExploded)
			{
				return;
			}
			if (m_followPath)
			{
				Move();
				if (ShouldAccelerate)
				{
					Accelerate();
				}
			}
			DetectCollision();
		}

		public void Accelerate()
		{
			m_currentMoveSpeed += AccelerationSpeed * Time.fixedDeltaTime;
			if (m_currentMoveSpeed >= MaxSpeed)
			{
				m_currentMoveSpeed = MaxSpeed;
				ShouldAccelerate = false;
			}
		}

		[PunRPC]
		protected override void PunDisableProjectile(bool returnToPool)
		{
			ShouldAccelerate = false;
			base.PunDisableProjectile(returnToPool);
			ShouldAccelerate = true;
		}
	}
	[RequireComponent(typeof(SplashDamageHandler), typeof(BounceHandler))]
	public class DiscOfAntioch : ProjectileMover, IProjectileSplash, IProjectileBounce
	{
		private SplashDamageHandler m_splashDamageHandler;

		private BounceHandler m_bounceHandler;

		public SplashDamageHandler SplashDamageHandler
		{
			[CompilerGenerated]
			get
			{
				return (!(m_splashDamageHandler != null)) ? (m_splashDamageHandler = GetComponent<SplashDamageHandler>()) : m_splashDamageHandler;
			}
		}

		public BounceHandler BounceHandler
		{
			[CompilerGenerated]
			get
			{
				return (!(m_bounceHandler != null)) ? (m_bounceHandler = GetComponent<BounceHandler>()) : m_bounceHandler;
			}
		}

		protected override void SetStaticValues(SpellBase_Projectile spell)
		{
			base.SetStaticValues(spell);
			SplashDamageHandler.SetData(spell.SplashDamageData);
		}

		protected override void ResetBezierAndInitialize(params object[] data)
		{
			BounceHandler.ResetBounces((int)data[5]);
			base.ResetBezierAndInitialize(data);
		}

		protected override void ReturnToSender()
		{
			if (BounceHandler.CurrentBounces != 0)
			{
				base.ReturnToSender();
			}
		}

		protected override void CollisionDetected(Assets.Scripts.Enums.TagType tagType, RaycastHit hit)
		{
			switch (tagType)
			{
			case Assets.Scripts.Enums.TagType.Lava:
				m_hitSfxType = HitSfxType.Lava;
				break;
			case Assets.Scripts.Enums.TagType.Player:
			{
				m_hitSfxType = HitSfxType.Player;
				bool flag = BounceHandler.TryBounce(hit, hitPlayer: true, base.Bounce);
				if (flag)
				{
					SplashDamageHandler.DealSplashDamage(m_spellDmg, this, hit.collider);
				}
				if (DealDamagePlayerObject(hit.transform.parent.GetComponent<IDamageable>(), m_spellDmg) && flag)
				{
					return;
				}
				if (DealDamageTwinAndReturnToSender(hit.collider.GetComponentInParent<Twin>(), m_spellDmg, returnToSenderActive: true))
				{
					ReturnToSender();
					return;
				}
				if (flag)
				{
					return;
				}
				break;
			}
			case Assets.Scripts.Enums.TagType.Dummy:
				m_hitSfxType = HitSfxType.Player;
				if (BounceHandler.TryBounce(hit, hitPlayer: true, base.Bounce))
				{
					SplashDamageHandler.DealSplashDamage(m_spellDmg, this);
					return;
				}
				DealDamageTrainingDummy(hit.collider, m_spellDmg);
				break;
			case Assets.Scripts.Enums.TagType.Destructable:
				if (BounceHandler.TryBounce(hit, hitPlayer: true, base.Bounce))
				{
					SplashDamageHandler.DealSplashDamage(m_spellDmg, this);
					return;
				}
				DealDamageDestructable(hit.collider, m_spellDmg);
				break;
			case Assets.Scripts.Enums.TagType.Environment:
			case Assets.Scripts.Enums.TagType.Train:
				if (BounceHandler.TryBounce(hit, hitPlayer: false, base.Bounce))
				{
					SplashDamageHandler.DealSplashDamage(m_spellDmg, this, hit.collider);
					return;
				}
				break;
			case Assets.Scripts.Enums.TagType.Shield:
			{
				SpellBase_Defense componentInParent = hit.collider.GetComponentInParent<SpellBase_Defense>();
				if (componentInParent == null)
				{
					break;
				}
				m_hitSfxType = HitSfxType.Shield;
				componentInParent.OnSpellHit(m_spellDmg, hit.point);
				if (componentInParent.IsReflective)
				{
					ReturnToSender();
					return;
				}
				if (BounceHandler.TryBounce(hit, hitPlayer: false, base.Bounce))
				{
					return;
				}
				if (!componentInParent.IsDeflective)
				{
					break;
				}
				if (m_spell != null && componentInParent.photonView.Owner == m_spell.photonView.Owner)
				{
					Bounce(Vector3.Reflect(base.transform.forward, hit.normal));
					return;
				}
				Vector3 normalized = (m_originalMoveVectors[0] - base.transform.position).normalized;
				Vector3 a = Vector3.Reflect(base.transform.forward, hit.normal);
				float t = Mathf.Clamp01((Vector3.Dot(hit.normal, componentInParent.transform.forward) + Vector3.Dot(normalized, componentInParent.transform.forward)) / 2f);
				Bounce(Vector3.Lerp(a, normalized, t));
				return;
			}
			case Assets.Scripts.Enums.TagType.KillPlane:
				ManualDestroy();
				break;
			}
			OnCollision(hit.collider, enableHitEffect: true);
		}

		protected override void OnCollision(Collider hitCollider, bool enableHitEffect)
		{
			base.OnCollision(hitCollider, enableHitEffect);
			SplashDamageHandler.DealSplashDamage(m_spellDmg, this);
		}

		public override void ManualDestroy()
		{
			BounceHandler.DestroyBounce();
			base.ManualDestroy();
		}
	}
	[RequireComponent(typeof(BounceHandler))]
	public class ElectricFist : ProjectileMover, IProjectileBounce
	{
		private BounceHandler m_bounceHandler;

		public BounceHandler BounceHandler
		{
			get
			{
				if (m_bounceHandler == null)
				{
					m_bounceHandler = GetComponent<BounceHandler>();
				}
				return m_bounceHandler;
			}
		}

		protected override void Initialize(float speed, float damage, int opponentID)
		{
			BounceHandler.ResetBounces(m_spell.m_maxBounces);
			base.Initialize(speed, damage, opponentID);
		}

		protected override void CollisionDetected(Assets.Scripts.Enums.TagType tagType, RaycastHit hit)
		{
			switch (tagType)
			{
			case Assets.Scripts.Enums.TagType.Lava:
				m_hitSfxType = HitSfxType.Lava;
				break;
			case Assets.Scripts.Enums.TagType.Player:
				m_hitSfxType = HitSfxType.Player;
				if (DealDamagePlayerObject(hit.transform.parent.GetComponent<IDamageable>(), m_spellDmg) || !DealDamageTwinAndReturnToSender(hit.collider.GetComponentInParent<Twin>(), m_spellDmg, returnToSenderActive: true))
				{
					break;
				}
				ReturnToSender();
				return;
			case Assets.Scripts.Enums.TagType.Dummy:
				m_hitSfxType = HitSfxType.Player;
				DealDamageTrainingDummy(hit.collider, m_spellDmg);
				break;
			case Assets.Scripts.Enums.TagType.Destructable:
				DealDamageDestructable(hit.collider, m_spellDmg);
				break;
			case Assets.Scripts.Enums.TagType.Environment:
			case Assets.Scripts.Enums.TagType.Train:
				if (BounceHandler.TryBounce(hit, hitPlayer: false, base.Bounce))
				{
					return;
				}
				break;
			case Assets.Scripts.Enums.TagType.Shield:
			{
				SpellBase_Defense componentInParent = hit.collider.GetComponentInParent<SpellBase_Defense>();
				if (componentInParent == null)
				{
					break;
				}
				m_hitSfxType = HitSfxType.Shield;
				componentInParent.OnSpellHit(m_spellDmg, hit.point);
				if (componentInParent.IsReflective)
				{
					ReturnToSender();
					return;
				}
				if (BounceHandler.TryBounce(hit, hitPlayer: false, base.Bounce))
				{
					return;
				}
				if (!componentInParent.IsDeflective)
				{
					break;
				}
				if (m_spell != null && componentInParent.photonView.Owner == m_spell.photonView.Owner)
				{
					Bounce(Vector3.Reflect(base.transform.forward, hit.normal));
					return;
				}
				Vector3 normalized = (m_originalMoveVectors[0] - base.transform.position).normalized;
				Vector3 a = Vector3.Reflect(base.transform.forward, hit.normal);
				float t = Mathf.Clamp01((Vector3.Dot(hit.normal, componentInParent.transform.forward) + Vector3.Dot(normalized, componentInParent.transform.forward)) / 2f);
				Bounce(Vector3.Lerp(a, normalized, t));
				return;
			}
			case Assets.Scripts.Enums.TagType.KillPlane:
				ManualDestroy();
				break;
			}
			OnCollision(hit.collider, enableHitEffect: true);
		}

		public override void ManualDestroy()
		{
			BounceHandler.DestroyBounce();
			base.ManualDestroy();
		}
	}
	[RequireComponent(typeof(SplashDamageHandler))]
	public class FlamingPhoenix : ProjectileMover, IPunObservable, IProjectileSplash
	{
		private const int MaxSyncIterations = 5;

		private const float MaxVolume = 0.6f;

		private const float InitialPathSpeed = 1f;

		private const float MinPathSpeedMultiplier = 0.25f;

		private const float MinCollisionRadius = 0.05f;

		private const float DamageIncreasePerSecond = 3f;

		private const float BotWarningDistanceSquared = 56.25f;

		private const float FlamingAttackDistanceSquared = 25f;

		private const float RequiredDotToTarget = 0.9f;

		private const float TargetPositionHeight = 1.6f;

		[Header("Phoenix")]
		[SerializeField]
		private Transform m_core;

		[SerializeField]
		private ProjectileEffectHandler m_boostEffect;

		[SerializeField]
		private AudioSource m_growAudioSource;

		[SerializeField]
		private int m_followSpeed = 6;

		private int m_casterViewID;

		private int m_syncIterations;

		private float m_tempDmg;

		private float m_minDamage;

		private float m_maxDmg;

		private float m_fireTime;

		private bool m_increaseSpellDamage;

		private Vector3 m_startSize;

		private Vector3 m_maxSize;

		private Vector3 m_syncPosition;

		private Vector3 m_prevSyncPosition;

		private Quaternion m_syncRotation;

		private Tweener m_followPathTween;

		private SplashDamageHandler m_splashDamageHandler;

		private bool m_hasSentChargedEvent;

		public SplashDamageHandler SplashDamageHandler
		{
			[CompilerGenerated]
			get
			{
				return (!(m_splashDamageHandler != null)) ? (m_splashDamageHandler = GetComponent<SplashDamageHandler>()) : m_splashDamageHandler;
			}
		}

		public int InitialRunwayLength { get; set; }

		private Vector3 TargetPosition
		{
			get
			{
				if (m_targetTransform == null)
				{
					return Vector3.zero;
				}
				return m_targetTransform.position + Vector3.up * 1.6f;
			}
		}

		public void OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info)
		{
			if (stream.IsWriting)
			{
				stream.SendNext(m_syncRotation);
				stream.SendNext(m_syncPosition);
				return;
			}
			m_syncRotation = (Quaternion)stream.ReceiveNext();
			m_syncPosition = (Vector3)stream.ReceiveNext();
			if (m_syncPosition != m_prevSyncPosition)
			{
				m_prevSyncPosition = m_syncPosition;
				if (m_syncIterations > 0)
				{
					m_syncIterations = 0;
				}
			}
			else if (m_syncIterations < 5)
			{
				m_syncIterations++;
			}
			else if (!m_hasExploded && !base.IsPaused)
			{
				Explode();
			}
		}

		protected override void SetStaticValues(SpellBase_Projectile spell)
		{
			base.SetStaticValues(spell);
			SplashDamageHandler.SetData(spell.SplashDamageData);
			m_minDamage = (m_spell as Spell_FlamingPhoenix).MinDamage;
			m_maxDmg = m_spell.m_spellDmg;
			m_startSize = Vector3.one * 0.5f;
			m_maxSize = Vector3.one * 1.2f;
			m_syncIterations = 0;
		}

		protected override IEnumerator WaitForNetworkSync(float fireTime, params object[] data)
		{
			while (PunSingleton<TimeManager>.Instance.CurrentRoomTime < fireTime)
			{
				yield return null;
			}
			if (!(m_spell == null))
			{
				ResetBezierAndInitialize(data);
			}
		}

		protected override void ResetBezierAndInitialize(params object[] data)
		{
			m_fireTime = (float)data[0];
			InitialRunwayLength = (int)data[5];
			m_casterViewID = (int)data[6];
			base.ResetBezierAndInitialize(data);
		}

		protected override void Initialize(float speed, float damage, int opponentID)
		{
			if (m_spell == null)
			{
				throw new UnityException($"{base.name} | No spell defined on projectile!");
			}
			base.transform.position = base.P0;
			m_syncPosition = base.P1;
			m_syncIterations = 0;
			m_hasExploded = false;
			m_collided = false;
			m_collisionRadius = 0.05f;
			m_returnToSender = false;
			m_tempDmg = m_minDamage;
			m_spellDmg = (int)m_tempDmg;
			m_increaseSpellDamage = true;
			SetTargetTransform();
			PlayInitEffect(base.P0);
			FadeLight(fadeIn: true);
			m_currentMoveSpeed = speed;
			m_collisionActive = true;
			LayerMask hitMask = base.HitMask;
			hitMask = (int)hitMask & ~((!(m_spell.CharacterControl != null)) ? (1 << LayerMask.NameToLayer("Player")) : (1 << m_spell.CharacterControl.gameObject.layer));
			if (DetectCollision(out var hit, 0.25f, hitMask))
			{
				CollisionDetected(hit);
				return;
			}
			InitiateFollowPathTween(m_fireTime);
			m_destroyCoroutine = StartCoroutine(DestroyAfterTime(m_lifeSpan, explode: true));
		}

		private void InitiateFollowPathTween(float startTime)
		{
			m_followPath = false;
			if (m_followPathTween != null)
			{
				m_followPathTween.Kill();
			}
			float duration = (1f - Mathf.Max(0.25f, PunSingleton<TimeManager>.Instance.CurrentRoomTime - startTime)) * base.BezierLength * 0.1f;
			if (base.photonView.IsMine)
			{
				m_followPathTween = base.transform.DOPath(m_originalMoveVectors, duration).SetLookAt(0.01f).SetEase(Ease.Linear)
					.OnUpdate(OnPathUpdate)
					.OnComplete(OnPathCompleted);
			}
			else
			{
				m_followPathTween = base.transform.DOPath(m_originalMoveVectors, duration).SetLookAt(0.01f).SetEase(Ease.Linear)
					.OnComplete(SetTweenToNull);
			}
		}

		[PunRPC]
		private void PunInitiateFollowPathTween(float startTime, Vector3[] bezierPoints)
		{
			m_followPath = false;
			if (m_followPathTween != null)
			{
				m_followPathTween.Kill();
			}
			SetBezierPointsAndLength(bezierPoints);
			float duration = (1f - Mathf.Max(0.25f, PunSingleton<TimeManager>.Instance.CurrentRoomTime - startTime)) * base.BezierLength * 0.1f;
			if (base.photonView.IsMine)
			{
				m_followPathTween = base.transform.DOPath(bezierPoints, duration).SetLookAt(0.01f).SetEase(Ease.Linear)
					.OnUpdate(OnPathUpdate)
					.OnComplete(OnPunPathCompleted);
			}
			else
			{
				m_followPathTween = base.transform.DOPath(bezierPoints, duration).SetLookAt(0.01f).SetEase(Ease.Linear)
					.OnComplete(OnPunPathCompleted);
			}
		}

		private void OnPathUpdate()
		{
			m_syncRotation = base.transform.rotation;
			m_syncPosition = base.transform.position;
		}

		private void OnPathCompleted()
		{
			m_followPathTween = null;
			if (DetectCollision(out var hit, 0.25f, base.HitMask))
			{
				CollisionDetected(hit);
				return;
			}
			ResetBezierCurve(base.transform.forward);
			base.photonView.RPC("PunEnableFollowPath", RpcTarget.All);
		}

		[PunRPC]
		private void PunEnableFollowPath()
		{
			m_bezierFollowTime = 0f;
			m_followPath = true;
		}

		private void OnPunPathCompleted()
		{
			m_followPathTween = null;
			TrySendSpellReleaseEvent();
			if (DetectCollision(out var hit, 0.25f, base.HitMask))
			{
				CollisionDetected(hit);
			}
			else
			{
				Explode();
			}
		}

		private void SetTweenToNull()
		{
			m_followPathTween = null;
		}

		protected override void FixedUpdate()
		{
			if (base.IsPaused || m_collided || m_hasExploded)
			{
				return;
			}
			if (m_followPath)
			{
				if (base.photonView.IsMine)
				{
					Move();
				}
				else
				{
					FollowTarget();
				}
			}
			else if (!base.photonView.IsMine)
			{
				bool? flag = ((m_followPathTween != null) ? new bool?(m_followPathTween.IsActive()) : null);
				bool? flag2 = ((!flag.HasValue) ? null : new bool?(!flag.Value));
				if (flag2.HasValue && flag2.Value)
				{
					base.transform.rotation = Quaternion.Lerp(base.transform.rotation, Quaternion.LookRotation(TargetPosition - base.transform.position), Time.deltaTime * (float)m_followSpeed);
					base.transform.position = base.transform.position + base.transform.forward * Time.deltaTime * ((float)m_followSpeed / 0.75f);
				}
			}
			if (m_increaseSpellDamage)
			{
				IncreaseSpellDamage();
			}
			DetectCollision();
		}

		protected override void Move()
		{
			if (m_targetTransform == null)
			{
				m_followPath = false;
				return;
			}
			m_syncRotation = Quaternion.Lerp(base.transform.rotation, Quaternion.LookRotation(TargetPosition - base.transform.position), Time.deltaTime * m_turnSpeed);
			m_syncPosition = base.transform.position + base.transform.forward * Time.deltaTime * m_currentMoveSpeed;
			float sqrMagnitude = (base.transform.position - TargetPosition).sqrMagnitude;
			if (MonoSingleton<NetworkManager>.Instance.CurrentMatchType.ContainsFlag(MatchType.Bot))
			{
				if (sqrMagnitude < 56.25f && Vector3.Dot(base.transform.forward, (TargetPosition - base.transform.position).normalized) > 0.9f)
				{
					TrySendSpellChargedEvent();
				}
				else if (m_hasSentChargedEvent)
				{
					TrySendSpellReleaseEvent();
				}
			}
			if (sqrMagnitude < 25f && Vector3.Dot(base.transform.forward, (TargetPosition - base.transform.position).normalized) > 0.9f)
			{
				m_followPath = false;
				ActivateFlamingAttack();
			}
			else
			{
				base.transform.rotation = m_syncRotation;
				base.transform.position = m_syncPosition;
			}
		}

		public override void FollowTarget()
		{
			base.transform.rotation = Quaternion.Lerp(base.transform.rotation, m_syncRotation, Time.deltaTime * (float)m_followSpeed);
			base.transform.position = Vector3.Lerp(base.transform.position, m_syncPosition, Time.deltaTime * (float)m_followSpeed);
		}

		private void TrySendSpellReleaseEvent()
		{
			if (m_hasSentChargedEvent)
			{
				m_hasSentChargedEvent = false;
				EventHub.Publish(new Events.InstantSpellReleasedEvent());
			}
		}

		private void TrySendSpellChargedEvent()
		{
			if (!m_hasSentChargedEvent)
			{
				float magnitude = (TargetPosition - base.transform.position).magnitude;
				float timeUntilFullyCharged = 0.75f * magnitude * 0.1f;
				Events.InstantSpellChargedEvent instantSpellChargedEvent = new Events.InstantSpellChargedEvent();
				instantSpellChargedEvent.FromPosition = base.transform.position;
				instantSpellChargedEvent.TimeUntilFullyCharged = timeUntilFullyCharged;
				EventHub.Publish(instantSpellChargedEvent);
				m_hasSentChargedEvent = true;
			}
		}

		private void IncreaseSpellDamage()
		{
			if (m_spellDmg >= m_maxDmg)
			{
				m_spellDmg = (int)m_maxDmg;
				m_core.transform.localScale = m_maxSize;
				m_increaseSpellDamage = false;
				return;
			}
			m_tempDmg += Time.fixedDeltaTime * 3f;
			m_spellDmg = (int)m_tempDmg;
			float t = m_tempDmg / m_maxDmg;
			m_core.transform.localScale = Vector3.Lerp(m_startSize, m_maxSize, t);
			m_collisionRadius = Mathf.Lerp(0.05f, m_collisionRadius, t);
			if (m_growAudioSource != null)
			{
				m_growAudioSource.volume = Mathf.Lerp(0.1f, 0.6f, t);
			}
		}

		private void SetTargetTransform()
		{
			Wielder opponent = null;
			if (PlayerManager.Instance.CanGetOpponentWielder(m_casterViewID, out opponent))
			{
				if (opponent.IsLocal)
				{
					m_targetTransform = opponent.CharacterControl.ColliderTransform;
				}
				else
				{
					m_targetTransform = opponent.RemoteCharacter.Collider.transform;
				}
				return;
			}
			if (GameControl.Instance.IsCurrentLevel(Level.Basement))
			{
				m_targetTransform = UnityEngine.Object.FindObjectsOfType<TrainingDummy>()?.GetRandomElement().transform;
			}
			if (m_targetTransform == null)
			{
				m_targetTransform = m_spell.Wielder.CharacterControl.ColliderTransform;
			}
		}

		private void ActivateFlamingAttack()
		{
			bool? flag = ((m_followPathTween != null) ? new bool?(m_followPathTween.IsPlaying()) : null);
			if (!flag.HasValue || !flag.Value)
			{
				if (m_boostEffect != null)
				{
					m_boostEffect.EnableEffect(base.transform);
				}
				Vector3[] array = new Vector3[3]
				{
					base.transform.position,
					MathUtils.GetMidPoint(base.transform.position, TargetPosition),
					TargetPosition
				};
				base.photonView.RPC("PunInitiateFollowPathTween", RpcTarget.AllViaServer, PunSingleton<TimeManager>.Instance.CurrentRoomTime, array);
			}
		}

		protected override void ReturnToSender()
		{
			SplashDamageHandler.DealSplashDamage(m_spellDmg, this, null, dealMinDamage: true);
			Explode();
		}

		protected override void CollisionDetected(RaycastHit hit)
		{
			if (m_followPathTween != null)
			{
				m_followPathTween.Kill();
			}
			m_followPathTween = null;
			TrySendSpellReleaseEvent();
			base.CollisionDetected(hit);
		}

		protected override void CollisionDetected(Assets.Scripts.Enums.TagType tagType, RaycastHit hit)
		{
			switch (tagType)
			{
			case Assets.Scripts.Enums.TagType.Lava:
				m_hitSfxType = HitSfxType.Lava;
				break;
			case Assets.Scripts.Enums.TagType.Player:
				m_hitSfxType = HitSfxType.Player;
				if (!DealDamagePlayerObject(hit.transform.parent.GetComponent<IDamageable>(), m_spellDmg))
				{
					DealDamageTwinAndReturnToSender(hit.collider.GetComponentInParent<Twin>(), m_spellDmg, returnToSenderActive: false);
				}
				break;
			case Assets.Scripts.Enums.TagType.Dummy:
				m_hitSfxType = HitSfxType.Player;
				DealDamageTrainingDummy(hit.collider, m_spellDmg);
				break;
			case Assets.Scripts.Enums.TagType.Destructable:
				DealDamageDestructable(hit.collider, m_spellDmg);
				break;
			case Assets.Scripts.Enums.TagType.Shield:
				m_hitSfxType = HitSfxType.Shield;
				hit.collider.GetComponentInParent<SpellBase_Defense>()?.OnSpellHit(m_spellDmg, hit.point);
				OnCollision(hit.collider, enableHitEffect: true);
				return;
			case Assets.Scripts.Enums.TagType.KillPlane:
				ManualDestroy();
				break;
			}
			OnCollision(hit.collider, enableHitEffect: true);
			SplashDamageHandler.DealSplashDamage(m_spellDmg, this, hit.collider, dealMinDamage: true);
		}

		protected override IEnumerator DestroyAfterTime(float waitTime, bool explode = false)
		{
			if (waitTime > 0f)
			{
				yield return new CustomWaitForSeconds(waitTime);
			}
			while (m_hitEffectHandler.gameObject.activeSelf || m_boostEffect.gameObject.activeSelf)
			{
				yield return null;
			}
			DestroyProjectile(explode);
		}

		[PunRPC]
		protected override void PunDisableProjectile(bool returnToPool)
		{
			if (m_followPathTween != null)
			{
				m_followPathTween.Kill();
			}
			m_followPathTween = null;
			m_increaseSpellDamage = false;
			base.PunDisableProjectile(returnToPool);
		}

		protected override void SetLoopingAudioActive(bool enable)
		{
			base.SetLoopingAudioActive(enable);
			if (!(m_growAudioSource == null))
			{
				if (enable)
				{
					m_growAudioSource.Play();
				}
				else
				{
					m_growAudioSource.Stop();
				}
			}
		}
	}
}
namespace Assets.Scripts.Interfaces
{
	public interface IProjectileBounce
	{
		BounceHandler BounceHandler { get; }
	}
}
namespace Assets.Scripts.Spells.Projectile
{
	[RequireComponent(typeof(LineRenderer))]
	public class LightningStrike : ProjectileMover
	{
		private LineRenderer m_lineRenderer;

		private Color m_startTint;

		private Color? m_startCore;

		protected override void OnDisable()
		{
			CancelInvoke();
			base.OnDisable();
		}

		public override void OnPhotonInstantiate(PhotonMessageInfo info)
		{
			m_lineRenderer = GetComponent<LineRenderer>();
			m_startTint = m_lineRenderer.material.GetColor("_TintColor");
			if (m_lineRenderer.material.HasProperty("_CoreColor"))
			{
				m_startCore = m_lineRenderer.material.GetColor("_CoreColor");
			}
			base.OnPhotonInstantiate(info);
		}

		protected override void Initialize(float speed, float damage, int opponentID)
		{
			PlayInitEffect(base.P0);
			m_spellDmg = damage;
			if (PlayerManager.Instance.LocalWielder.ViewID == opponentID)
			{
				base.HitMask = (int)base.HitMask | (1 << (int)m_spell.Wielder.GetLayerMask());
			}
			else
			{
				base.HitMask = (int)base.HitMask | (1 << LayerMask.NameToLayer($"Player{((m_spell.Wielder.GetIndex() != 1) ? 1 : 2)}"));
				base.HitMask = (int)base.HitMask & ~(1 << (int)m_spell.Wielder.GetLayerMask());
			}
			m_collisionRadius = m_spell.m_collisionRadius;
			m_bezierFollowTime = 0f;
			m_collisionActive = true;
			base.transform.LookAt(base.P2);
			if (speed <= 0f)
			{
				speed = Mathf.Epsilon;
			}
			Invoke("LightningHit", 1f / speed);
		}

		private void LightningHit()
		{
			if (Physics.Raycast(base.CollisionRay, out var hitInfo, float.PositiveInfinity, base.HitMask))
			{
				DrawLine(new Vector3[3]
				{
					base.P0,
					MathUtils.GetMidPoint(base.P1, hitInfo.point),
					hitInfo.point
				});
				base.transform.position = hitInfo.point;
				CollisionDetected(hitInfo);
			}
			else
			{
				DrawLine(base.Points);
				OnCollision(null, enableHitEffect: true);
			}
		}

		private void DrawLine(Vector3[] points)
		{
			for (int i = 0; i < points.Length; i++)
			{
				m_lineRenderer.SetPosition(i, points[i]);
			}
			m_lineRenderer.material.SetColor("_TintColor", m_startTint);
			if (m_startCore.HasValue)
			{
				m_lineRenderer.material.SetColor("_CoreColor", m_startCore.Value);
			}
		}

		protected override void CollisionDetected(Assets.Scripts.Enums.TagType tagType, RaycastHit hit)
		{
			switch (tagType)
			{
			case Assets.Scripts.Enums.TagType.Player:
				m_hitSfxType = HitSfxType.Player;
				if (!DealDamagePlayerObject(hit.transform.parent.GetComponent<IDamageable>(), m_spellDmg) && DealDamageTwinAndReturnToSender(hit.collider.GetComponentInParent<Twin>(), m_spellDmg, returnToSenderActive: true))
				{
					ReturnToSender();
				}
				break;
			case Assets.Scripts.Enums.TagType.Dummy:
				m_hitSfxType = HitSfxType.Player;
				DealDamageTrainingDummy(hit.collider, m_spellDmg);
				break;
			case Assets.Scripts.Enums.TagType.Destructable:
				DealDamageDestructable(hit.collider, m_spellDmg);
				break;
			case Assets.Scripts.Enums.TagType.Shield:
				m_hitSfxType = HitSfxType.Shield;
				hit.collider.GetComponentInParent<SpellBase_Defense>()?.OnSpellHit(m_spellDmg, hit.point);
				break;
			case Assets.Scripts.Enums.TagType.KillPlane:
				ManualDestroy();
				break;
			}
			OnCollision(hit.collider, enableHitEffect: true);
		}

		protected override IEnumerator DestroyAfterTime(float waitTime, bool explode = false)
		{
			if (waitTime > 0f)
			{
				yield return new CustomWaitForSeconds(waitTime);
			}
			if (waitTime == 0f)
			{
				DestroyProjectile(explode);
			}
			else
			{
				Sequence sequence = DOTween.Sequence();
				sequence.Insert(0f, m_lineRenderer.material.DOFade(0f, "_TintColor", 0.5f));
				if (m_startCore.HasValue)
				{
					sequence.Insert(0f, m_lineRenderer.material.DOFade(0f, "_CoreColor", 0.5f));
				}
				yield return sequence.WaitForCompletion();
			}
			while (m_initEffectHandler.gameObject.activeSelf || m_hitEffectHandler.gameObject.activeSelf)
			{
				yield return null;
			}
			DestroyProjectile(explode: false);
		}

		protected override void ReturnToSender()
		{
			(m_spell as Spell_LightningStrike).ReturnToSender(base.P2, base.P1, base.P0);
		}
	}
	public class ProjectileMover : BezierFollower, IPunInstantiateMagicCallback, IPauseObject, IEffectEmitter, IPoolObject
	{
		[StructLayout(LayoutKind.Sequential, Size = 1)]
		protected struct ActivationDataIndex
		{
			public const int ExpectedDataLength = 6;

			public const int FireTime = 0;

			public const int MoveVectors = 1;

			public const int Speed = 2;

			public const int Damage = 3;

			public const int OpponentViewID = 4;

			public const int CustomSpellData = 5;
		}

		private class PreviousCollider
		{
			public Collider Collider;

			public float CollisionTime;

			public PreviousCollider(Collider collider, float collisionTime)
			{
				Collider = collider;
				CollisionTime = collisionTime;
			}
		}

		protected const float DefaultCollisionRayLength = 0.25f;

		private const float MoveCollisionRayLength = 1f;

		private const float CollisionDisableTimeOnBounce = 0.25f;

		private static RaycastHit[] sm_raycastHits = new RaycastHit[8];

		[SerializeField]
		protected Spell m_spellType;

		[SerializeField]
		protected float m_turnSpeed = 2f;

		[SerializeField]
		protected float m_lifeSpan = 10f;

		[SerializeField]
		private Light m_light;

		[SerializeField]
		private AudioSource m_loopingAudioSource;

		[SerializeField]
		protected TrailRenderer m_trailRenderer;

		[Header("Init")]
		[SerializeField]
		protected ProjectileEffectHandler m_initEffectHandler;

		[Header("Hit")]
		[SerializeField]
		protected ProjectileExplosionHandler m_hitEffectHandler;

		[SerializeField]
		protected GameObject m_disableOnImpact;

		protected bool m_hasExploded;

		protected bool m_collided;

		protected bool m_followPath;

		protected bool m_returnToSender;

		protected bool m_collisionActive;

		protected float m_bezierFollowTime;

		protected float m_startMoveSpeed;

		protected float m_currentMoveSpeed;

		protected float m_collisionRadius = 0.01f;

		protected float m_spellDmg = 4f;

		protected PhotonView m_projectileView;

		protected SpellBase_Projectile m_spell;

		protected ProjectileBehaviour m_behaviour;

		protected DamageType m_dmgType;

		protected Transform m_targetTransform;

		protected Coroutine m_destroyCoroutine;

		protected HitSfxType m_hitSfxType;

		private int m_opponentId;

		private float m_defaultLightIntensity;

		private int m_threadedSfxIndex = -1;

		private Tweener m_lightFadeTweener;

		private PreviousCollider m_previousCollider = new PreviousCollider(null, -1f);

		private EventToken m_matchPausedEventToken;

		private EventToken m_matchResetEventToken;

		private EventToken m_matchEndedEventToken;

		public bool IsPaused { get; set; }

		public ParticleSystem[] Emitters { get; set; }

		public LayerMask HitMask { get; protected set; }

		public bool IsMoving
		{
			[CompilerGenerated]
			get
			{
				return !m_hasExploded && !m_collided;
			}
		}

		protected Ray CollisionRay
		{
			[CompilerGenerated]
			get
			{
				return new Ray(base.transform.position + base.transform.forward * m_collisionRadius, base.transform.forward);
			}
		}

		protected virtual void OnEnable()
		{
			m_hitSfxType = HitSfxType.Default;
			m_matchPausedEventToken = EventHub.Subscribe<Events.MatchPausedEvent>(OnMatchPaused);
			m_matchResetEventToken = EventHub.Subscribe<Events.MatchResetEvent>(OnMatchReset);
			m_matchEndedEventToken = EventHub.Subscribe<Events.MatchEndedEvent>(OnMatchEnded);
		}

		protected virtual void OnDisable()
		{
			StopAllCoroutines();
			EventHub.Unsubscribe<Events.MatchPausedEvent>(m_matchPausedEventToken);
			EventHub.Unsubscribe<Events.MatchResetEvent>(m_matchResetEventToken);
			EventHub.Unsubscribe<Events.MatchEndedEvent>(m_matchEndedEventToken);
		}

		private void OnMatchReset(Events.MatchResetEvent eventData)
		{
			ManualDestroy();
		}

		private void OnMatchEnded(Events.MatchEndedEvent eventData)
		{
			ManualDestroy();
		}

		public void Pause(bool pause)
		{
			SetEmitterState(pause ? EmitterState.Pause : EmitterState.Play, base.gameObject, refetchEmitters: true);
			IsPaused = pause;
		}

		private void OnMatchPaused(Events.MatchPausedEvent eventData)
		{
			Pause(eventData.IsPaused);
		}

		public virtual void OnPhotonInstantiate(PhotonMessageInfo info)
		{
			AssignSpell();
			PunDisableProjectile(returnToPool: false);
			base.transform.SetParent(ObjectPoolHandler.PoolParent);
		}

		protected void AssignSpell()
		{
			SpellBase_Projectile spellBase_Projectile = PhotonView.Find((int)base.photonView.InstantiationData[0])?.GetComponent<SpellBase_Projectile>();
			if (spellBase_Projectile != null)
			{
				SetStaticValues(spellBase_Projectile);
			}
			else
			{
				WandsLogger.LogError($"{base.name} | spell is null!");
			}
		}

		protected virtual void SetStaticValues(SpellBase_Projectile spell)
		{
			m_spell = spell;
			HitMask = spell.HitMask;
			m_behaviour = spell.m_projectileBehaviour;
			m_dmgType = spell.m_dmgType;
			m_projectileView = spell.photonView;
			m_collisionRadius = spell.m_collisionRadius;
		}

		public virtual void EnableObject(Vector3 startPosition, params object[] data)
		{
			if (!(this == null))
			{
				Vector3[] array = (Vector3[])data[1];
				base.transform.rotation = Quaternion.LookRotation(array[1] - array[0]);
				base.photonView.RPC("PunEnableProjectile", RpcTarget.AllViaServer, startPosition, data);
			}
		}

		[PunRPC]
		protected void PunEnableProjectile(Vector3 startPosition, params object[] data)
		{
			ClearTrail();
			base.transform.position = startPosition;
			base.gameObject.SetActive(value: true);
			StartCoroutine(WaitForNetworkSync((float)data[0], data));
		}

		protected virtual IEnumerator WaitForNetworkSync(float fireTime, params object[] data)
		{
			while (PunSingleton<TimeManager>.Instance.CurrentRoomTime < fireTime)
			{
				yield return null;
			}
			if (m_spell == null)
			{
				WandsLogger.LogError($"{m_spellType} | No spell defined for projectile!");
			}
			else
			{
				ResetBezierAndInitialize(data);
			}
		}

		protected virtual void ResetBezierAndInitialize(params object[] data)
		{
			m_originalMoveVectors = (Vector3[])data[1];
			SetBezierPointsAndLength(m_originalMoveVectors);
			base.transform.rotation = Quaternion.LookRotation(base.P1 - base.P0);
			EnableCore();
			SetLoopingAudioActive(enable: true);
			Initialize((float)data[2], (float)data[3], (int)data[4]);
			CreateAndPublishProjectileCastEvent();
		}

		private void CreateAndPublishProjectileCastEvent()
		{
			float maxSpeed = m_startMoveSpeed;
			float acceleration = 0f;
			IProjectileAccelerate component = GetComponent<IProjectileAccelerate>();
			if (component != null)
			{
				maxSpeed = component.MaxSpeed;
				acceleration = component.AccelerationSpeed;
			}
			Events.ProjectileCastEvent projectileCastEvent = new Events.ProjectileCastEvent();
			projectileCastEvent.Spell = m_spellType;
			projectileCastEvent.Speed = m_startMoveSpeed;
			projectileCastEvent.Acceleration = acceleration;
			projectileCastEvent.MaxSpeed = maxSpeed;
			projectileCastEvent.Damage = m_spellDmg;
			projectileCastEvent.DamageType = m_dmgType;
			projectileCastEvent.ProjectileRadius = m_collisionRadius;
			projectileCastEvent.MoveVectors = m_moveVectors;
			projectileCastEvent.SplashDamageRadius = m_spell.SplashDamageData.SplashDamageRadius;
			projectileCastEvent.OpponentId = m_opponentId;
			projectileCastEvent.ReturnToSender = m_returnToSender;
			projectileCastEvent.ProjectileMover = this;
			Events.ProjectileCastEvent message = projectileCastEvent;
			EventHub.Publish(message);
		}

		protected virtual void Initialize(float speed, float damage, int opponentId)
		{
			PlayInitEffect(base.P0);
			FadeLight(fadeIn: true);
			m_startMoveSpeed = speed;
			m_currentMoveSpeed = m_startMoveSpeed;
			m_spellDmg = damage;
			m_bezierFollowTime = 0f;
			m_opponentId = opponentId;
			if (m_behaviour == ProjectileBehaviour.Threaded)
			{
				m_threadedSfxIndex = opponentId;
			}
			m_collisionActive = true;
			LayerMask hitMask = HitMask;
			hitMask = ((!(m_spell != null) || !(m_spell.CharacterControl != null)) ? ((LayerMask)((int)hitMask & ~(1 << LayerMask.NameToLayer("Player")))) : ((LayerMask)((int)hitMask & ~(1 << m_spell.CharacterControl.gameObject.layer))));
			if (DetectCollision(out var hit, 0.25f, hitMask))
			{
				CollisionDetected(hit);
				return;
			}
			m_followPath = true;
			m_destroyCoroutine = StartCoroutine(DestroyAfterTime(m_lifeSpan, explode: true));
		}

		protected void PlayInitEffect(Vector3 point)
		{
			if (m_initEffectHandler != null)
			{
				m_initEffectHandler.EnableEffect(base.transform);
			}
		}

		protected virtual void FixedUpdate()
		{
			if (!IsPaused && !m_collided && !m_hasExploded)
			{
				if (m_followPath)
				{
					Move();
				}
				DetectCollision();
			}
		}

		protected virtual void Move()
		{
			m_bezierFollowTime += m_currentMoveSpeed * Time.fixedDeltaTime / (base.BezierLength * ((!m_returnToSender) ? 0.1f : (-0.1f)));
			m_bezierFollowTime = Mathf.Clamp01(m_bezierFollowTime);
			Vector3 point = GetPoint(m_bezierFollowTime);
			base.transform.LookAt(point);
			float sqrMagnitude = (((!m_returnToSender) ? base.P2 : base.P0) - point).sqrMagnitude;
			if (sqrMagnitude < 0.01f)
			{
				m_returnToSender = false;
				DetectCollision();
				ResetBezierCurve(base.transform.forward * 5f);
				m_bezierFollowTime = 0f;
			}
			base.transform.position = point;
		}

		public virtual void FollowTarget()
		{
			if (m_targetTransform == null)
			{
				m_followPath = false;
				return;
			}
			Vector3 forward = m_targetTransform.position - (base.transform.position + base.transform.forward);
			base.transform.rotation = Quaternion.Lerp(base.transform.rotation, Quaternion.LookRotation(forward), Time.deltaTime * m_turnSpeed);
			base.transform.position += base.transform.forward * Time.deltaTime * m_currentMoveSpeed;
		}

		protected void ContinueMove()
		{
			base.transform.LookAt(GetPoint(0.1f));
			m_collisionActive = true;
			m_followPath = true;
			m_collided = false;
		}

		protected void Bounce(Vector3 forward)
		{
			ResetBezierCurve(forward);
			m_bezierFollowTime = 0f;
			ContinueMove();
			DetectCollision();
			CreateAndPublishProjectileCastEvent();
		}

		protected virtual void ReturnToSender()
		{
			SetBezierPointsAndLength(m_originalMoveVectors);
			m_returnToSender = true;
			if (m_bezierFollowTime < 0.1f)
			{
				m_bezierFollowTime = 1f;
			}
			ContinueMove();
		}

		protected bool DetectCollision()
		{
			RaycastHit hit;
			if (m_collisionActive)
			{
				return DetectCollision(out hit, 1f + m_collisionRadius, HitMask, isMoving: true);
			}
			return false;
		}

		protected bool DetectCollision(out RaycastHit hit, float length, LayerMask hitMask, bool isMoving = false)
		{
			hit = default(RaycastHit);
			if (!m_collisionActive)
			{
				return false;
			}
			int num = Physics.SphereCastNonAlloc(CollisionRay, m_collisionRadius, sm_raycastHits, length, hitMask.value);
			if (num == 0)
			{
				return false;
			}
			sm_raycastHits.QuickSort(0, num - 1, (RaycastHit raycastHit) => (raycastHit.point - CollisionRay.origin).sqrMagnitude);
			for (int i = 0; i < num; i++)
			{
				hit = sm_raycastHits[i];
				if (!(hit.collider == null) && !(hit.collider.transform == base.transform) && (!(hit.collider == m_previousCollider.Collider) || !(Time.time - m_previousCollider.CollisionTime < 0.25f)))
				{
					if (isMoving)
					{
						StartCoroutine(AwaitCollisionArrival(hit));
					}
					m_collisionActive = false;
					m_previousCollider.Collider = hit.collider;
					m_previousCollider.CollisionTime = Time.time;
					return true;
				}
			}
			return false;
		}

		private IEnumerator AwaitCollisionArrival(RaycastHit hit)
		{
			float collisionRadiusSqr = m_collisionRadius * m_collisionRadius;
			while ((base.transform.position - hit.point).sqrMagnitude > collisionRadiusSqr && Vector3.Dot(base.transform.forward, hit.point - base.transform.position) > 0.1f)
			{
				yield return null;
			}
			CollisionDetected(hit);
		}

		protected virtual void CollisionDetected(RaycastHit hit)
		{
			if (!m_collided)
			{
				base.transform.position += base.transform.forward * (0f - m_collisionRadius);
				m_collided = true;
				Collider collider = hit.collider;
				Assets.Scripts.Enums.TagType type;
				if (collider == null)
				{
					OnCollision(collider, enableHitEffect: true);
				}
				else if (EnumHelper.TryParse(collider.gameObject.tag, out type))
				{
					CollisionDetected(type, hit);
				}
				else
				{
					OnCollision(collider, enableHitEffect: false);
				}
			}
		}

		protected virtual void CollisionDetected(Assets.Scripts.Enums.TagType tagType, RaycastHit hit)
		{
			switch (tagType)
			{
			case Assets.Scripts.Enums.TagType.Lava:
				m_hitSfxType = HitSfxType.Lava;
				break;
			case Assets.Scripts.Enums.TagType.Player:
				m_hitSfxType = HitSfxType.Player;
				if (DealDamagePlayerObject(hit.transform.parent.GetComponent<IDamageable>(), m_spellDmg) || !DealDamageTwinAndReturnToSender(hit.collider.GetComponentInParent<Twin>(), m_spellDmg, returnToSenderActive: true))
				{
					break;
				}
				ReturnToSender();
				return;
			case Assets.Scripts.Enums.TagType.Dummy:
				m_hitSfxType = HitSfxType.Player;
				DealDamageTrainingDummy(hit.collider, m_spellDmg);
				break;
			case Assets.Scripts.Enums.TagType.Destructable:
				DealDamageDestructable(hit.collider, m_spellDmg);
				break;
			case Assets.Scripts.Enums.TagType.Shield:
			{
				SpellBase_Defense componentInParent = hit.collider.GetComponentInParent<SpellBase_Defense>();
				if (componentInParent == null)
				{
					break;
				}
				m_hitSfxType = HitSfxType.Shield;
				componentInParent.OnSpellHit(m_spellDmg, hit.point);
				if (componentInParent.IsReflective)
				{
					ReturnToSender();
					return;
				}
				if (!componentInParent.IsDeflective)
				{
					break;
				}
				if (m_spell != null && componentInParent.Wielder == m_spell.Wielder)
				{
					Bounce(Vector3.Reflect(base.transform.forward, hit.normal));
					return;
				}
				Vector3 normalized = (m_originalMoveVectors[0] - base.transform.position).normalized;
				Vector3 a = Vector3.Reflect(base.transform.forward, hit.normal);
				float t = Mathf.Clamp01((Vector3.Dot(hit.normal, componentInParent.transform.forward) + Vector3.Dot(normalized, componentInParent.transform.forward)) / 2f);
				Bounce(Vector3.Lerp(a, normalized, t));
				return;
			}
			case Assets.Scripts.Enums.TagType.KillPlane:
				ManualDestroy();
				break;
			}
			OnCollision(hit.collider, enableHitEffect: true);
		}

		protected virtual void OnCollision(Collider hitCollider, bool enableHitEffect)
		{
			FadeLight(fadeIn: false);
			SetLoopingAudioActive(enable: false);
			DisableCore();
			m_followPath = false;
			if (enableHitEffect)
			{
				OnHit();
			}
			m_hasExploded = true;
			if (m_destroyCoroutine != null)
			{
				StopCoroutine(m_destroyCoroutine);
				m_destroyCoroutine = null;
			}
			ProjectileBehaviour behaviour = m_behaviour;
			if (behaviour == ProjectileBehaviour.Instant)
			{
				StartCoroutine(DestroyAfterTime(m_lifeSpan));
			}
			else
			{
				StartCoroutine(DestroyAfterTime(0f));
			}
		}

		public virtual bool DealDamagePlayerObject(IDamageable damagableEntity, float dmg)
		{
			if (damagableEntity == null)
			{
				return false;
			}
			if (damagableEntity.TakeDamage(m_dmgType, dmg, GetHitDirection(damagableEntity.GetHitTransform())) && (object)m_spell != null)
			{
				m_spell.AddTotalDamage(dmg);
			}
			return true;
		}

		public virtual bool DealDamageTwinAndReturnToSender(Twin twin, float dmg, bool returnToSenderActive)
		{
			if (twin == null)
			{
				return false;
			}
			twin.OnHit(Mathf.CeilToInt(dmg));
			return returnToSenderActive;
		}

		protected Vector2 GetHitDirection(Transform targetTf)
		{
			Vector3 vector = base.transform.position - targetTf.position;
			Vector3 forward = targetTf.forward;
			Vector3 vector2 = Quaternion.LookRotation(forward) * vector;
			float x = 0f - vector2.x;
			float z = vector2.z;
			return new Vector2(x, z).normalized;
		}

		public virtual void DealDamageTrainingDummy(Collider hitCollider, float dmg)
		{
			if (GameControl.Instance.IsCurrentLevel(Level.Basement))
			{
				hitCollider.GetComponentInParent<TrainingDummy>()?.TakeDamage(dmg);
			}
			else
			{
				WandsLogger.LogError("Called deal damage to training dummy but not in basement, something is wrongly tagged as Dummy");
			}
		}

		public virtual void DealDamageDestructable(Collider hitCollider, float dmg)
		{
			TurretBase componentInParent = hitCollider.GetComponentInParent<TurretBase>();
			if (componentInParent != null)
			{
				componentInParent.OnHit(dmg);
			}
			else
			{
				hitCollider.transform.SendMessageUpwards("OnHit", dmg, SendMessageOptions.DontRequireReceiver);
			}
		}

		protected virtual void OnHit()
		{
			if (m_threadedSfxIndex >= 0)
			{
				m_hitSfxType = (HitSfxType)m_threadedSfxIndex;
			}
			if (m_hitEffectHandler != null)
			{
				m_hitEffectHandler.EnableEffect(m_hitSfxType);
			}
		}

		public virtual void ManualDestroy()
		{
			if (!(base.gameObject == null) && base.gameObject.activeSelf)
			{
				m_collided = true;
				StopAllCoroutines();
				DestroyProjectile(explode: false);
				if (m_initEffectHandler != null)
				{
					UnityEngine.Object.Destroy(m_initEffectHandler.gameObject);
				}
				if (m_hitEffectHandler != null)
				{
					UnityEngine.Object.Destroy(m_hitEffectHandler.gameObject);
				}
			}
		}

		public void Explode()
		{
			if (!(base.gameObject == null) && base.gameObject.activeSelf)
			{
				m_collided = true;
				StopAllCoroutines();
				DestroyProjectile(explode: true);
			}
		}

		protected virtual IEnumerator DestroyAfterTime(float waitTime, bool explode = false)
		{
			if (waitTime > 0f)
			{
				yield return new CustomWaitForSeconds(waitTime);
			}
			while (m_hitEffectHandler != null && m_hitEffectHandler.gameObject.activeSelf)
			{
				yield return null;
			}
			DestroyProjectile(explode);
		}

		protected virtual void DestroyProjectile(bool explode)
		{
			if (PhotonNetwork.IsConnectedAndReady && m_projectileView != null && m_projectileView.IsMine)
			{
				PhotonNetwork.RemoveRPCs(m_projectileView);
			}
			if (explode)
			{
				OnCollision(null, enableHitEffect: true);
				return;
			}
			base.photonView.RPC("PunDisableProjectile", RpcTarget.AllViaServer, true);
		}

		public void DisableObject()
		{
			PunDisableProjectile(returnToPool: true);
		}

		[PunRPC]
		protected virtual void PunDisableProjectile(bool returnToPool)
		{
			if (!base.gameObject.activeSelf)
			{
				return;
			}
			base.gameObject.SetActive(value: false);
			m_collisionActive = false;
			m_followPath = false;
			m_collided = false;
			m_hasExploded = false;
			m_returnToSender = false;
			if (m_hitEffectHandler != null)
			{
				m_hitEffectHandler.DisableEffect();
			}
			if (m_initEffectHandler != null)
			{
				m_initEffectHandler.DisableAndReturn(base.transform);
			}
			if (returnToPool)
			{
				bool? flag = base.photonView?.IsMine;
				if (flag.HasValue && flag.Value)
				{
					ObjectPoolHandler.TryReturnToPool(m_spellType, this);
				}
			}
		}

		protected void FadeLight(bool fadeIn)
		{
			if (!(m_light == null))
			{
				if (m_defaultLightIntensity <= 0f)
				{
					m_defaultLightIntensity = m_light.intensity;
				}
				if (m_lightFadeTweener != null)
				{
					m_lightFadeTweener.Kill();
				}
				m_light.intensity = ((!fadeIn) ? m_light.intensity : 0f);
				if (fadeIn)
				{
					m_lightFadeTweener = m_light.DOIntensity(m_defaultLightIntensity, 0.2f).SetEase(Ease.OutBack);
				}
				else
				{
					m_lightFadeTweener = m_light.DOIntensity(0f, 0.5f).SetEase(Ease.InBack);
				}
			}
		}

		protected virtual void SetLoopingAudioActive(bool enable)
		{
			if (!(m_loopingAudioSource == null))
			{
				if (enable)
				{
					m_loopingAudioSource.Play();
				}
				else
				{
					m_loopingAudioSource.Stop();
				}
			}
		}

		protected void EnableCore()
		{
			if (m_disableOnImpact != null)
			{
				m_disableOnImpact.SetActive(value: true);
			}
			SetEmitterState(EmitterState.Play, base.gameObject);
		}

		protected void DisableCore()
		{
			if (!(m_disableOnImpact == base.gameObject))
			{
				SetEmitterState(EmitterState.Stop, base.gameObject);
				if (m_disableOnImpact != null)
				{
					m_disableOnImpact.SetActive(value: false);
				}
			}
		}

		private void ClearTrail()
		{
			if (m_trailRenderer != null)
			{
				m_trailRenderer.Clear();
			}
		}

		public void SetEmitterState(EmitterState newState, GameObject effectParent, bool refetchEmitters = false)
		{
			if (refetchEmitters || Emitters.IsNullOrEmpty())
			{
				Emitters = effectParent.GetComponentsInChildren<ParticleSystem>();
			}
			ParticleSystem[] emitters = Emitters;
			foreach (ParticleSystem particleSystem in emitters)
			{
				switch (newState)
				{
				case EmitterState.Play:
					particleSystem.Play();
					break;
				case EmitterState.Pause:
					particleSystem.Pause();
					break;
				case EmitterState.Stop:
					particleSystem.Stop();
					break;
				}
			}
		}

		PhotonView IPoolObject.get_photonView()
		{
			return base.photonView;
		}
	}
	public class ProjectileMoverEnvironment : ProjectileMoverObject
	{
		public TrailRenderer TrailRenderer
		{
			[CompilerGenerated]
			get
			{
				return m_trailRenderer;
			}
		}

		[PunRPC]
		protected override void PunDisableProjectile(bool returnToPool)
		{
			base.gameObject.SetActive(value: false);
			m_collisionActive = false;
			m_followPath = false;
			m_collided = false;
			m_hasExploded = false;
			m_returnToSender = false;
			if (m_hitEffectHandler != null)
			{
				m_hitEffectHandler.DisableEffect();
			}
			if (m_initEffectHandler != null)
			{
				m_initEffectHandler.DisableAndReturn(base.transform);
			}
		}
	}
	public class ProjectileMoverObject : ProjectileMover
	{
		[Header("Object Projectile Mover")]
		[SerializeField]
		protected PoolObjectType m_objectType = PoolObjectType.TrailProjectile;

		[SerializeField]
		protected LayerMask m_hitMask = -1;

		public override void EnableObject(Vector3 startPosition, params object[] data)
		{
			if (!(this == null))
			{
				base.photonView.RPC("PunEnableProjectile", RpcTarget.AllViaServer, startPosition, data);
			}
		}

		public override void OnPhotonInstantiate(PhotonMessageInfo info)
		{
			PrepareProjectile();
		}

		private void PrepareProjectile()
		{
			base.HitMask = m_hitMask;
			PunDisableProjectile(returnToPool: false);
			base.transform.SetParent(ObjectPoolHandler.PoolParent);
		}

		protected override IEnumerator WaitForNetworkSync(float fireTime, params object[] data)
		{
			while (PunSingleton<TimeManager>.Instance.CurrentRoomTime < fireTime)
			{
				yield return null;
			}
			ResetBezierAndInitialize(data);
		}

		protected override void ResetBezierAndInitialize(params object[] data)
		{
			m_originalMoveVectors = (Vector3[])data[3];
			SetBezierPointsAndLength(m_originalMoveVectors);
			EnableCore();
			SetLoopingAudioActive(enable: true);
			Initialize((ProjectileBehaviour)(int)data[1], (DamageType)(int)data[2], (float)data[4], (int)data[5]);
		}

		public virtual void Initialize(ProjectileBehaviour behaviour, DamageType dmgType, float speed, int damage)
		{
			PlayInitEffect(base.P0);
			m_currentMoveSpeed = speed;
			m_spellDmg = damage;
			m_behaviour = behaviour;
			m_dmgType = dmgType;
			m_bezierFollowTime = 0f;
			base.transform.LookAt(base.transform.position + GetDirection(base.transform.position, m_bezierFollowTime));
			m_collisionActive = true;
			LayerMask hitMask = base.HitMask;
			hitMask = (int)hitMask & ~(1 << (int)PlayerManager.Instance.LocalWielder.GetLayerMask());
			if (DetectCollision(out var hit, 0.25f, hitMask))
			{
				CollisionDetected(hit);
				return;
			}
			m_followPath = true;
			m_destroyCoroutine = StartCoroutine(DestroyAfterTime(m_lifeSpan, explode: true));
		}

		[PunRPC]
		protected override void PunDisableProjectile(bool returnToPool)
		{
			if (!base.gameObject.activeSelf)
			{
				return;
			}
			base.gameObject.SetActive(value: false);
			m_collisionActive = false;
			m_followPath = false;
			m_collided = false;
			m_hasExploded = false;
			m_returnToSender = false;
			if (m_hitEffectHandler != null)
			{
				m_hitEffectHandler.DisableEffect();
			}
			if (m_initEffectHandler != null)
			{
				m_initEffectHandler.DisableAndReturn(base.transform);
			}
			if (returnToPool)
			{
				bool? flag = base.photonView?.IsMine;
				if (flag.HasValue && flag.Value)
				{
					ObjectPoolHandler.TryReturnToPool(m_objectType, this);
				}
			}
		}
	}
	public class ProjectileMoverSummoned : ProjectileMover
	{
		private const int InvalidViewID = 0;

		[Header("Summoned")]
		[SerializeField]
		protected PoolObjectType m_objectType = PoolObjectType.SkullSpecterProjectile;

		protected override void OnEnable()
		{
			base.OnEnable();
			if (m_spell == null && base.photonView.InstantiationData.Length > 0)
			{
				PhotonView photonView = PhotonView.Find((int)base.photonView.InstantiationData[0]);
				if (photonView != null)
				{
					SetStaticValues(photonView.GetComponentInChildren<SpellBase_Projectile>(includeInactive: true));
				}
				else
				{
					WandsLogger.LogError("Summoned projectile mover doesn't have a spell view id.");
				}
			}
		}

		public override void OnPhotonInstantiate(PhotonMessageInfo info)
		{
			if (base.photonView.InstantiationData.Length > 0)
			{
				PhotonView photonView = PhotonView.Find((int)base.photonView.InstantiationData[0]);
				if (photonView != null)
				{
					SetStaticValues(photonView.GetComponentInChildren<SpellBase_Projectile>(includeInactive: true));
				}
				else
				{
					WandsLogger.LogError("Summoned projectile mover doesn't have a spell view id.");
				}
			}
			PunDisableProjectile(returnToPool: false);
			base.transform.SetParent(ObjectPoolHandler.PoolParent);
		}

		protected override void ResetBezierAndInitialize(params object[] data)
		{
			if (data.Length < 6)
			{
				WandsLogger.LogError("projectile parameter data length is less than expected");
				return;
			}
			PhotonView photonView = PhotonView.Find((int)data[5]);
			if (photonView != null)
			{
				m_spell = photonView.GetComponentInChildren<SpellBase_Projectile>(includeInactive: true);
			}
			base.ResetBezierAndInitialize(data);
		}

		[PunRPC]
		protected override void PunDisableProjectile(bool returnToPool)
		{
			if (!base.gameObject.activeSelf)
			{
				return;
			}
			base.gameObject.SetActive(value: false);
			m_collisionActive = false;
			m_followPath = false;
			m_collided = false;
			m_hasExploded = false;
			if (m_hitEffectHandler != null)
			{
				m_hitEffectHandler.DisableEffect();
			}
			if (m_initEffectHandler != null)
			{
				m_initEffectHandler.DisableAndReturn(base.transform);
			}
			if (returnToPool)
			{
				bool? flag = base.photonView?.IsMine;
				if (flag.HasValue && flag.Value)
				{
					ObjectPoolHandler.TryReturnToPool(m_objectType, this);
				}
			}
		}
	}
	public class Spell_ChillingClutch : SpellBase_Projectile
	{
		private static IReadOnlyDictionary<string, string> sm_spellDescriptionParams;

		[Header("Chilling Clutch")]
		[SerializeField]
		private float m_chillingClutchPercent = 0.5f;

		[SerializeField]
		private float m_debuffDuration = 5f;

		public override IReadOnlyDictionary<string, string> GetSpellDescriptionParams()
		{
			if (sm_spellDescriptionParams.IsNullOrEmpty())
			{
				Dictionary<string, string> dictionary = new Dictionary<string, string>(2);
				dictionary.Add("CHILLING_CLUTCH_PERCENTAGE", (100f * m_chillingClutchPercent).ToString());
				dictionary.Add("CHILLING_CLUTCH_DURATION", m_debuffDuration.ToString());
				sm_spellDescriptionParams = dictionary;
			}
			return sm_spellDescriptionParams;
		}

		protected override void FireProjectile(Vector3[] bezierPoints, float moveSpeed, float dmg, int opponentId, params object[] parameters)
		{
			ProjectileMover projectileMover = ObjectPoolHandler.GrabFromPool(Type, base.photonView.ViewID) as ProjectileMover;
			projectileMover.EnableObject(bezierPoints[0], base.FireTime, bezierPoints, moveSpeed, dmg, opponentId, m_chillingClutchPercent, m_debuffDuration);
		}
	}
	public class Spell_DiscOfAntioch : SpellBase_Projectile
	{
		private static IReadOnlyDictionary<string, string> sm_spellDescriptionParams;

		[Header("Disc of Antioch")]
		[SerializeField]
		private float m_timeBetweenBounceIncreases = 0.5f;

		[SerializeField]
		private int m_startBounces = 2;

		[SerializeField]
		private int m_bounceIncrease = 1;

		public override IReadOnlyDictionary<string, string> GetSpellDescriptionParams()
		{
			if (sm_spellDescriptionParams.IsNullOrEmpty())
			{
				Dictionary<string, string> dictionary = new Dictionary<string, string>(1);
				dictionary.Add("DISC_MAX_BOUNCES", m_maxBounces.ToString());
				sm_spellDescriptionParams = dictionary;
			}
			return sm_spellDescriptionParams;
		}

		protected override void OnPress()
		{
			base.OnPress();
			m_currentHoldTime = 0f;
		}

		protected override void OnHold()
		{
			base.OnHold();
			m_currentHoldTime += Time.deltaTime;
		}

		protected override void OnRelease(bool forceRelease = false)
		{
			base.OnRelease(forceRelease);
			if (forceRelease)
			{
				m_currentHoldTime = m_castTime;
			}
		}

		protected override void FireStraight(int opponentWielderID, bool forceRelease, bool drainEnergy, Vector3 point0, Vector3 point1, Vector3 point2)
		{
			if (base.photonView.Owner.IsLocal)
			{
				m_spellArcPoints[0] = point0;
				m_spellArcPoints[1] = point1;
				m_spellArcPoints[2] = point2;
				if (drainEnergy)
				{
					DrainEnergy();
				}
				int num = Mathf.Min(m_startBounces + Mathf.FloorToInt((float)m_bounceIncrease * (m_currentHoldTime / m_timeBetweenBounceIncreases)), m_maxBounces);
				FireProjectile(m_spellArcPoints, m_moveSpeed, m_spellDmg, opponentWielderID, num);
			}
		}

		protected override void FireProjectile(Vector3[] bezierPoints, float moveSpeed, float dmg, int opponentId, params object[] parameters)
		{
			ProjectileMover projectileMover = ObjectPoolHandler.GrabFromPool(Type, base.photonView.ViewID) as ProjectileMover;
			projectileMover.EnableObject(bezierPoints[0], base.FireTime, bezierPoints, moveSpeed, dmg, opponentId, parameters[0]);
		}
	}
}
namespace Cortopia.Scripts.Spells
{
	public class Spell_ElectricFist : SpellBase_Projectile
	{
		private static IReadOnlyDictionary<string, string> sm_spellDescriptionParams;

		public override IReadOnlyDictionary<string, string> GetSpellDescriptionParams()
		{
			if (sm_spellDescriptionParams.IsNullOrEmpty())
			{
				Dictionary<string, string> dictionary = new Dictionary<string, string>(1);
				dictionary.Add("ELECTRIC_FIST_AMOUNT", m_projectileCount.ToString());
				sm_spellDescriptionParams = dictionary;
			}
			return sm_spellDescriptionParams;
		}
	}
}
namespace Assets.Scripts.Spells.Projectile
{
	public class Spell_FlamingPhoenix : SpellBase_Projectile
	{
		[Header("Phoenix")]
		[SerializeField]
		private float m_minDmg = 10f;

		[SerializeField]
		[Range(2f, 5f)]
		private float m_minRunwayLength = 3f;

		[SerializeField]
		[Range(5f, 20f)]
		private float m_maxRunwayLength = 16f;

		private float m_tempRunway;

		private Vector3 m_offset;

		public float MinDamage
		{
			[CompilerGenerated]
			get
			{
				return m_minDmg;
			}
		}

		public override string SpellDamage
		{
			[CompilerGenerated]
			get
			{
				return $"{MinDamage}-{m_spellDmg}";
			}
		}

		protected override void Start()
		{
			base.Start();
			m_projectileBehaviour = ProjectileBehaviour.Homing;
		}

		protected override void OnPress()
		{
			m_offset = ((GameControl.Instance.GetInputAim() != AimInput.Head) ? Vector3.zero : (Vector3.up * -0.5f));
			base.OnPress();
		}

		public override void AbortSpellCasting(bool discret = false, bool backButtonForce = false)
		{
			base.AbortSpellCasting(discret, backButtonForce);
			Reset();
		}

		protected override void IncreaseStat()
		{
			if (m_casting)
			{
				if (base.CharacterControl == null)
				{
					WandsLogger.Log("Player is numm :)", base.gameObject, LogType.Error);
					return;
				}
				m_tempRunway += Time.deltaTime * (m_maxRunwayLength + 1f - m_minRunwayLength) / m_castTime;
				m_tempRunway = Mathf.Clamp(m_tempRunway, m_minRunwayLength, m_maxRunwayLength);
				ref Vector3 reference = ref m_spellArcPoints[0];
				reference = base.SpawnPosition;
				ref Vector3 reference2 = ref m_spellArcPoints[2];
				reference2 = m_wandControl.Aim.AimRay.GetPoint(m_tempRunway);
				ref Vector3 reference3 = ref m_spellArcPoints[1];
				reference3 = MathUtils.GetMidPoint(m_spellArcPoints[0], m_spellArcPoints[2]);
				m_wandControl.ArcHandler.CalculateProjectileCurve(m_spellArcPoints, bounceActive: false, m_offset);
			}
		}

		protected override void FireStraight(int wielderId, bool forceRelease, bool drainEnergy)
		{
			if (drainEnergy)
			{
				DrainEnergy();
			}
			if (base.CharacterControl == null)
			{
				WandsLogger.LogError("Player is numm ;)", base.gameObject);
				return;
			}
			ref Vector3 reference = ref m_spellArcPoints[0];
			reference = base.SpawnPosition;
			ref Vector3 reference2 = ref m_spellArcPoints[2];
			reference2 = m_wandControl.Aim.AimRay.GetPoint(m_tempRunway);
			ref Vector3 reference3 = ref m_spellArcPoints[1];
			reference3 = MathUtils.GetMidPoint(m_spellArcPoints[0], m_spellArcPoints[2]);
			if (PunSingleton<SceneControl>.Instance.CurrentMatchType.ContainsFlag(MatchType.SinglePlayer))
			{
				Fire(m_spellArcPoints, m_moveSpeed, m_spellDmg, base.FireTime, wielderId);
			}
			else
			{
				base.photonView.RPC("Fire", RpcTarget.Others, m_spellArcPoints, m_moveSpeed, m_spellDmg, base.FireTime, wielderId);
			}
			Reset();
		}

		[PunRPC]
		private void Fire(Vector3[] bezierPoints, float moveSpeed, float dmg, float fireTime, int opponentId)
		{
			if (m_wandControl != null)
			{
				FlamingPhoenix flamingPhoenix = ObjectPoolHandler.GrabFromPool(Type, base.photonView.ViewID) as FlamingPhoenix;
				flamingPhoenix.EnableObject(bezierPoints[0], fireTime, bezierPoints, moveSpeed, dmg, opponentId, (int)m_tempRunway, base.Wielder.ViewID);
			}
		}

		private void Reset()
		{
			m_wandControl.ArcHandler.HideDots(clearArcPositions: true);
			m_tempRunway = m_minRunwayLength;
		}
	}
	public class Spell_LightningStrike : SpellBase_Projectile
	{
		private const float AlmostChargedFactor = 0.2f;

		private static IReadOnlyDictionary<string, string> sm_spellDescriptionParams;

		[Header("Lightning Strike")]
		[SerializeField]
		private int m_chargeManaCost = 10;

		[SerializeField]
		private AudioSource m_abortSound;

		private WaitForSeconds m_almostChargedDuration;

		private bool m_isBotMatch;

		protected override void Start()
		{
			base.Start();
			m_isBotMatch = MonoSingleton<NetworkManager>.Instance.CurrentMatchType.ContainsFlag(MatchType.Bot);
		}

		public override IReadOnlyDictionary<string, string> GetSpellDescriptionParams()
		{
			if (sm_spellDescriptionParams.IsNullOrEmpty())
			{
				Dictionary<string, string> dictionary = new Dictionary<string, string>(1);
				dictionary.Add("LIGHTNING_CHARGE_COST", m_chargeManaCost.ToString());
				sm_spellDescriptionParams = dictionary;
			}
			return sm_spellDescriptionParams;
		}

		protected override void OnPress()
		{
			ResetArcPoints();
			DrainEnergy(m_chargeManaCost);
		}

		protected override IEnumerator PrepareFireDelayed()
		{
			if (!m_casting)
			{
				yield break;
			}
			if (m_isBotMatch)
			{
				if (m_remainingChargeDuration == null)
				{
					m_almostChargedDuration = new WaitForSeconds(m_castTime * 0.8f);
					m_remainingChargeDuration = new WaitForSeconds(m_castTime * 0.2f);
				}
				Events.InstantSpellInitiatedEvent instantSpellInitiatedEvent = new Events.InstantSpellInitiatedEvent();
				instantSpellInitiatedEvent.Tile = PlayerManager.Instance.PlayerControl.GetCurrentTile();
				EventHub.Publish(instantSpellInitiatedEvent);
				yield return m_almostChargedDuration;
				Events.InstantSpellChargedEvent instantSpellChargedEvent = new Events.InstantSpellChargedEvent();
				instantSpellChargedEvent.FromPosition = base.SpawnPosition;
				instantSpellChargedEvent.TimeUntilFullyCharged = m_castTime * 0.2f;
				EventHub.Publish(instantSpellChargedEvent);
			}
			else
			{
				m_remainingChargeDuration = new WaitForSeconds(m_castTime);
			}
			yield return m_remainingChargeDuration;
			if (m_casting)
			{
				PrepareFire();
			}
		}

		public override void SpellRelease(bool forceRelease = false)
		{
			if (!m_casting || base.IsCooldownActive)
			{
				return;
			}
			if (m_castTime > 0f)
			{
				if (m_blockUntilCharged && !m_readyToFire)
				{
					AbortSpellCasting();
					if (m_abortSound != null)
					{
						m_abortSound.Play();
					}
					if (m_isBotMatch)
					{
						EventHub.Publish(new Events.InstantSpellReleasedEvent());
					}
					return;
				}
				StopCoroutine("PrepareFireDelayed");
				if (m_isBotMatch)
				{
					EventHub.Publish(new Events.InstantSpellReleasedEvent());
				}
			}
			m_readyToFire = false;
			TryTriggerSpellReleaseHaptics();
			OnRelease(forceRelease);
		}

		public void ReturnToSender(Vector3 point0, Vector3 point1, Vector3 point2)
		{
			if (base.photonView.Owner.IsLocal)
			{
				FireStraight(base.Wielder.ViewID, forceRelease: false, drainEnergy: false, point0, point1, point2);
			}
		}

		protected override void FireStraight(int opponentWielderID, bool forceRelease, bool drainEnergy = true)
		{
			if (PlayerManager.Instance.CanGetOpponentWielder(out var opponent))
			{
				base.FireStraight(opponent.ViewID, forceRelease);
			}
			else
			{
				base.FireStraight(opponentWielderID, forceRelease, drainEnergy);
			}
		}
	}
	public class Tile_Projectile : SpellBase_Projectile, ITileSpell
	{
		[Header("Tile")]
		[SerializeField]
		private GameObject m_tileHighlightEffect;

		[SerializeField]
		private bool m_highlightLookAtPlayer;

		public override void OnSpellChange()
		{
			base.OnSpellChange();
			if ((object)m_tileHighlightEffect != null)
			{
				m_tileHighlightEffect.SetActive(value: false);
			}
		}

		protected override void Start()
		{
			m_projectileBehaviour = ProjectileBehaviour.Tile;
			base.Start();
		}

		protected override void Update()
		{
			base.Update();
			if (m_isSelected)
			{
				TrackTiles();
			}
		}

		public override void SpellPress()
		{
			TrackTiles();
			base.SpellPress();
		}

		public Tile GetHighlightedTile()
		{
			return base.Wielder.Wand.GetPlayerWand(base.WandHand).HighlightedTile;
		}

		public void ResetHighlightedTile()
		{
			base.Wielder.Wand.GetPlayerWand(base.WandHand).ResetHighlightedTile();
		}

		public void TrackTiles()
		{
			base.Wielder.CharacterControl.TryTrackTileHit(base.WandHand);
		}

		protected override void FireStraight(int opponentID, bool forceRelease, bool drainEnergy)
		{
			Tile highlightedTile = GetHighlightedTile();
			if (!(highlightedTile == null))
			{
				if (drainEnergy)
				{
					DrainEnergy();
				}
				ref Vector3 reference = ref m_spellArcPoints[0];
				reference = base.SpawnPosition;
				ref Vector3 reference2 = ref m_spellArcPoints[2];
				reference2 = highlightedTile.transform.position;
				ref Vector3 reference3 = ref m_spellArcPoints[1];
				reference3 = GetOffsettedMidPointUp(m_spellArcPoints[0], m_spellArcPoints[2], m_maxOffset);
				FireProjectile(m_spellArcPoints, m_moveSpeed, m_spellDmg, opponentID);
			}
		}

		public override bool CanCast()
		{
			return !m_casting && GetHighlightedTile() != null;
		}

		public void SetHighlightTile(Tile tile)
		{
			if (base.gameObject == null)
			{
				return;
			}
			if (tile == null)
			{
				if (m_tileHighlightEffect != null)
				{
					m_tileHighlightEffect.transform.SetParent(base.transform);
					m_tileHighlightEffect.SetActive(value: false);
				}
				if (m_showTrajectory)
				{
					m_wandControl.ArcHandler.HideDots();
				}
				return;
			}
			if (m_showTrajectory)
			{
				ref Vector3 reference = ref m_spellArcPoints[0];
				reference = base.SpawnPosition;
				ref Vector3 reference2 = ref m_spellArcPoints[2];
				reference2 = GetHighlightedTile().transform.position;
				ref Vector3 reference3 = ref m_spellArcPoints[1];
				reference3 = GetOffsettedMidPointUp(m_spellArcPoints[0], m_spellArcPoints[2], m_maxOffset);
				m_wandControl.ArcHandler.CalculateProjectileCurve(m_spellArcPoints, m_bounceActive);
			}
			if (m_tileHighlightEffect != null)
			{
				m_tileHighlightEffect.transform.SetParent(tile.transform);
				m_tileHighlightEffect.transform.localPosition = Vector3.zero;
				if (m_highlightLookAtPlayer)
				{
					Vector3 position = base.Wielder.PlayerControl.CameraTransform.position;
					position.y = m_tileHighlightEffect.transform.position.y;
					m_tileHighlightEffect.transform.LookAt(position);
				}
				m_tileHighlightEffect.SetActive(value: true);
			}
		}
	}
}
namespace Assets.Scripts.Spells
{
	public class Spell_DragonsBreath : SpellBase, IPunObservable
	{
		private const string EndSoundClipName = "dragons_breath_end";

		private const float EndSoundClipVolume = 0.5f;

		[Header("Dragon's Breath")]
		[SerializeField]
		private float m_maxBreathDistance = 25f;

		[SerializeField]
		private float m_minDamage = 10f;

		[SerializeField]
		private float m_maxDamage = 20f;

		[SerializeField]
		private float m_manaCostPerSecond = 5f;

		[Header("Fx")]
		[SerializeField]
		private SplitAudioSoundPlayer m_loopingSoundPlayer;

		[SerializeField]
		private ParticleSystem m_particleSystem;

		[Header("End Point")]
		[SerializeField]
		private EndPointCollisionTracker m_endPointCollisionTracker;

		[SerializeField]
		private float m_endPointFollowSpeed = 0.33f;

		[Header("Collision")]
		[SerializeField]
		private float m_speed = 20f;

		[SerializeField]
		private float m_radius = 0.25f;

		[SerializeField]
		private AnimationCurve m_speedDecay = AnimationCurve.Linear(0f, 0f, 1f, 1f);

		[SerializeField]
		private float m_lifeTime = 2.25f;

		private float m_damageDealt;

		private Vector3 m_networkPosition;

		private Quaternion m_networkRotation;

		private Wielder m_targetWielder;

		private EventToken m_matchResetEventToken;

		private EventToken m_matchEndedEventToken;

		private Coroutine m_spawnBreaths;

		private List<DragonsBreath> m_dragonsBreaths = new List<DragonsBreath>(32);

		private Vector3 SpawnPosition
		{
			[CompilerGenerated]
			get
			{
				return m_wandControl.CachedTipPoint;
			}
		}

		private Vector3 HitPosition
		{
			[CompilerGenerated]
			get
			{
				return m_wandControl.Aim.GetHitPointOrClosest(0f);
			}
		}

		public override string CastCost
		{
			[CompilerGenerated]
			get
			{
				return $"{m_manaCostPerSecond}/s";
			}
		}

		public override string SpellDamage
		{
			[CompilerGenerated]
			get
			{
				return $"{m_minDamage}-{m_maxDamage}/s";
			}
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			m_matchResetEventToken = EventHub.Subscribe<Events.MatchResetEvent>(OnMatchReset);
			m_matchEndedEventToken = EventHub.Subscribe<Events.MatchEndedEvent>(OnMatchEnded);
		}

		protected override void OnDisable()
		{
			base.OnDisable();
			StopAllCoroutines();
			EventHub.Unsubscribe<Events.MatchResetEvent>(m_matchResetEventToken);
			EventHub.Unsubscribe<Events.MatchEndedEvent>(m_matchEndedEventToken);
		}

		private void FixedUpdate()
		{
			bool flag = false;
			for (int num = m_dragonsBreaths.Count - 1; num >= 0; num--)
			{
				DragonsBreath dragonsBreath = m_dragonsBreaths[num];
				dragonsBreath.UpdateBreath();
				if (dragonsBreath.State == DragonsBreath.DragonState.Colliding && !flag)
				{
					DealDamage(dragonsBreath.HitCollider, GetDamage(Vector3.Distance(m_networkPosition, dragonsBreath.Position)) * Time.fixedDeltaTime, (dragonsBreath.Position - dragonsBreath.HitCollider.transform.position).normalized);
					m_endPointCollisionTracker.SetPosition(dragonsBreath.Position);
					if (!m_endPointCollisionTracker.IsHitEffectEnabled)
					{
						m_endPointCollisionTracker.SetHitEffectActive(enable: true, playSfx: true);
					}
					flag = true;
				}
				else if (dragonsBreath.State == DragonsBreath.DragonState.Inactive)
				{
					m_dragonsBreaths.RemoveAt(num);
				}
			}
			if (!flag)
			{
				AbortContiniousHit();
			}
			if (m_casting)
			{
				if (base.Wielder.IsLocal)
				{
					base.Wielder.ChangeMana((0f - m_manaCostPerSecond) * Time.fixedDeltaTime, blockManaReg: true);
					m_particleSystem.transform.position = (m_networkPosition = SpawnPosition);
					m_particleSystem.transform.rotation = (m_networkRotation = Quaternion.LookRotation((HitPosition - SpawnPosition).normalized));
				}
				else
				{
					SetParticleSystemTransform(lerp: true);
				}
			}
		}

		private void OnMatchReset(Events.MatchResetEvent eventData)
		{
			AbortSpellCasting();
		}

		private void OnMatchEnded(Events.MatchEndedEvent eventData)
		{
			AbortSpellCasting();
		}

		public override void AbortSpellCasting(bool discret = false, bool backButtonForce = false)
		{
			base.AbortSpellCasting(discret, backButtonForce);
			m_casting = false;
			if (m_damageDealt > 0f)
			{
				AddTotalDamage((int)m_damageDealt);
			}
			DrainEnergy(0);
			m_particleSystem.Stop(withChildren: true);
			SetAudioActive(active: false);
			base.Wielder.AnimationRelay.StopChannelingAnimation(ChannelAnimationType.Fast);
			base.photonView?.RPC("PunSetDragonsBreathActive", RpcTarget.Others, false, m_networkPosition, m_networkRotation);
			AbortContiniousHit();
			if (m_spawnBreaths != null)
			{
				StopCoroutine(m_spawnBreaths);
				m_spawnBreaths = null;
			}
		}

		protected override void OnPress()
		{
			m_casting = true;
			m_damageDealt = 0f;
			DrainEnergy(m_castCost);
			SetAudioActive(active: true);
			base.Wielder.AnimationRelay.PlayChannelingAnimation(ChannelAnimationType.Fast);
			base.photonView?.RPC("PunSetDragonsBreathActive", RpcTarget.All, true, SpawnPosition, Quaternion.LookRotation((HitPosition - SpawnPosition).normalized));
			m_particleSystem.Emit(1);
		}

		protected override void OnHold()
		{
			if (OutOfEnergy(m_manaCostPerSecond * Time.deltaTime))
			{
				AbortSpellCasting();
			}
		}

		protected override void OnRelease(bool forceRelease = false)
		{
			AbortSpellCasting();
		}

		public void OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info)
		{
			if (stream.IsWriting)
			{
				stream.SendNext(m_networkPosition);
				stream.SendNext(m_networkRotation);
			}
			else
			{
				m_networkPosition = (Vector3)stream.ReceiveNext();
				m_networkRotation = (Quaternion)stream.ReceiveNext();
			}
		}

		private IEnumerator SpawnBreaths()
		{
			while (true)
			{
				m_dragonsBreaths.Add(new DragonsBreath(m_particleSystem.transform.position, m_particleSystem.transform.forward, m_speed, m_radius, HitMask, m_speedDecay, m_lifeTime));
				yield return new CustomWaitForSeconds(m_radius / m_speed);
			}
		}

		[PunRPC]
		private void PunSetDragonsBreathActive(bool active, Vector3 position, Quaternion rotation)
		{
			m_casting = active;
			m_networkPosition = position;
			m_networkRotation = rotation;
			SetAudioActive(active);
			if (active)
			{
				m_particleSystem.Play(withChildren: true);
				SetParticleSystemTransform(lerp: false);
				m_endPointCollisionTracker.ResetTimer();
				m_spawnBreaths = StartCoroutine(SpawnBreaths());
				return;
			}
			m_particleSystem.Stop(withChildren: true);
			AbortContiniousHit();
			if (m_spawnBreaths != null)
			{
				StopCoroutine(m_spawnBreaths);
				m_spawnBreaths = null;
			}
		}

		private void SetAudioActive(bool active)
		{
			if (!(m_loopingSoundPlayer == null))
			{
				if (active)
				{
					m_loopingSoundPlayer.PlaySplitAudio();
					return;
				}
				m_loopingSoundPlayer.KillSplitAudio();
				PunSingleton<SoundManager>.Instance.PlayLocalSoundAtPoint("dragons_breath_end", 0.5f, base.Wielder.transform.position);
			}
		}

		private void SetParticleSystemTransform(bool lerp)
		{
			if (lerp)
			{
				m_particleSystem.transform.position = Vector3.Lerp(m_particleSystem.transform.position, m_networkPosition, Time.fixedDeltaTime * m_endPointFollowSpeed * 20f);
				m_particleSystem.transform.rotation = Quaternion.Lerp(m_particleSystem.transform.rotation, m_networkRotation, Time.fixedDeltaTime * m_endPointFollowSpeed * 20f);
			}
			else
			{
				m_particleSystem.transform.position = m_networkPosition;
				m_particleSystem.transform.rotation = m_networkRotation;
			}
		}

		private void DealDamage(Collider col, float dmg, Vector3 normal)
		{
			if (col.CompareTag("Shield"))
			{
				return;
			}
			if (GameControl.Instance.IsCurrentLevel(Level.Basement))
			{
				TrainingDummy componentInParent = col.GetComponentInParent<TrainingDummy>();
				if (componentInParent != null)
				{
					componentInParent.TakeDamage(dmg);
					AbortContiniousHit();
					return;
				}
			}
			if (col.CompareTag("Destructable"))
			{
				TurretBase componentInParent2 = col.GetComponentInParent<TurretBase>();
				if (componentInParent2 != null)
				{
					componentInParent2.OnHit(dmg);
				}
				else
				{
					col.transform.SendMessageUpwards("OnHit", dmg, SendMessageOptions.DontRequireReceiver);
				}
				return;
			}
			CharacterControl componentInParent3 = col.GetComponentInParent<CharacterControl>();
			if (componentInParent3 != null)
			{
				if (componentInParent3.Wielder.TakeDamage(DamageType.Continuous, dmg, normal))
				{
					m_targetWielder = componentInParent3.Wielder;
					m_damageDealt += dmg;
				}
			}
			else
			{
				AbortContiniousHit();
				col.GetComponentInParent<Twin>()?.OnHit(dmg);
			}
		}

		private void AbortContiniousHit()
		{
			if (!(m_targetWielder == null) && m_targetWielder.IsLocal)
			{
				m_targetWielder.AbortContinuousHit();
				m_targetWielder = null;
			}
		}

		private float GetDamage(float distance)
		{
			return m_minDamage + (m_maxDamage - m_minDamage) * (1f - distance / m_maxBreathDistance);
		}

		public override void ApplyDamageMultiplier(float value)
		{
			m_minDamage *= value;
			m_maxDamage *= value;
		}
	}
	[RequireComponent(typeof(PhotonView))]
	public abstract class SpellBase : MonoBehaviourPun, IPunInstantiateMagicCallback
	{
		[Header("General")]
		[SerializeField]
		private Spell m_type;

		[SerializeField]
		private ReticleType m_reticleType;

		[SerializeField]
		private RelicType m_relicType;

		[SerializeField]
		private AudioClip m_selectSound;

		[SerializeField]
		private HapticsData m_spellPressHaptics;

		[SerializeField]
		private HapticsData m_spellReleaseHaptics;

		[Header("Cost")]
		[SerializeField]
		protected CostType m_costType;

		[SerializeField]
		protected int m_castCost = 5;

		[Tooltip("Is used as a cooldown value, resetting when releasing the fire button.")]
		[SerializeField]
		[Range(0f, 2f)]
		protected float m_fireRate;

		[Header("Initialization")]
		[SerializeField]
		private CastEffectorBase m_castEffector;

		[SerializeField]
		private WandChargeEffect m_wandChargeEffect;

		public AudioSource m_initAudioSource;

		public float m_castTime;

		public bool m_blockUntilCharged;

		public bool m_autoFire = true;

		[Header("ObjectPooling")]
		[SerializeField]
		[Range(1f, 40f)]
		private int m_poolSize = 5;

		protected bool m_casting;

		protected bool m_locked;

		protected bool m_readyToFire;

		protected bool m_isChargeable;

		protected bool m_isSelected;

		protected WaitForSeconds m_remainingChargeDuration;

		protected IWandControl m_wandControl;

		private bool m_blockCooldown;

		private int m_slotIndex;

		private float m_originalInitAudioSourceVolume;

		private float m_fireRateTimer;

		private PlayerControl m_playerControl;

		private ONSPAudioSource m_initONSPAudioSource;

		private Events.SpellSelectedEvent m_spellSelectedEvent;

		public CharacterControl CharacterControl { get; private set; }

		public int TimesPicked { get; private set; }

		public int TimesUsed { get; private set; }

		public float TotalDamageDealt { get; private set; }

		public int PoolSize
		{
			[CompilerGenerated]
			get
			{
				return m_poolSize;
			}
		}

		public Wielder Wielder
		{
			[CompilerGenerated]
			get
			{
				return (m_wandControl == null) ? null : m_wandControl.Wielder;
			}
		}

		public CostType CostType
		{
			[CompilerGenerated]
			get
			{
				return m_costType;
			}
		}

		public WandInput WandInput
		{
			[CompilerGenerated]
			get
			{
				return m_wandControl.WandInput;
			}
		}

		public WandHand WandHand
		{
			[CompilerGenerated]
			get
			{
				return m_wandControl.WandHand;
			}
		}

		public string NameTerm
		{
			[CompilerGenerated]
			get
			{
				return $"Spells/Names/{Type.Trim()}";
			}
		}

		public string DescriptionTerm
		{
			[CompilerGenerated]
			get
			{
				return $"Spells/Description/{Type.Trim()}";
			}
		}

		public ReticleType ReticleType
		{
			[CompilerGenerated]
			get
			{
				return m_reticleType;
			}
		}

		public AudioClip SelectSound
		{
			[CompilerGenerated]
			get
			{
				return m_selectSound;
			}
		}

		public WandChargeEffect WandChargeEffect
		{
			[CompilerGenerated]
			get
			{
				return (!(m_wandChargeEffect != null)) ? null : m_wandChargeEffect;
			}
		}

		public virtual Spell Type
		{
			[CompilerGenerated]
			get
			{
				return m_type;
			}
		}

		public virtual LayerMask HitMask
		{
			[CompilerGenerated]
			get
			{
				return m_wandControl.HitMask;
			}
		}

		public virtual bool IsActive
		{
			[CompilerGenerated]
			get
			{
				return m_casting;
			}
		}

		public virtual bool TapHold
		{
			[CompilerGenerated]
			get
			{
				return true;
			}
		}

		public virtual string CastCost
		{
			[CompilerGenerated]
			get
			{
				return GetCastCost().ToString();
			}
		}

		public virtual string SpellDamage
		{
			[CompilerGenerated]
			get
			{
				return "N/A";
			}
		}

		protected PlayerControl PlayerControl
		{
			[CompilerGenerated]
			get
			{
				return (!(m_playerControl != null)) ? null : m_playerControl;
			}
		}

		protected bool IsPlayerControlled
		{
			[CompilerGenerated]
			get
			{
				return m_playerControl != null;
			}
		}

		protected bool IsDualWielding
		{
			[CompilerGenerated]
			get
			{
				return m_playerControl != null && m_playerControl.IsDualWielding;
			}
		}

		protected bool IsCooldownActive { get; private set; }

		protected virtual void OnEnable()
		{
		}

		protected virtual void OnDisable()
		{
			StopAllCoroutines();
		}

		protected virtual void OnDestroy()
		{
			if (NetworkUtils.ConnectedToGame && base.photonView != null && base.photonView.IsMine)
			{
				PhotonNetwork.RemoveRPCs(base.photonView);
			}
			if (m_wandChargeEffect != null)
			{
				UnityEngine.Object.Destroy(m_wandChargeEffect.gameObject);
			}
		}

		protected virtual void Start()
		{
			m_blockCooldown = Mathf.Approximately(m_fireRate, 0f);
			if (m_type == Spell.None)
			{
				WandsLogger.LogError("SpellBase | " + base.name.ToUpper() + " spell is of wrong type, set correct in inspector.");
			}
			if (m_spellPressHaptics != null)
			{
				m_spellPressHaptics.Time = m_castTime;
			}
			if (m_initAudioSource != null)
			{
				m_originalInitAudioSourceVolume = m_initAudioSource.volume;
				m_initONSPAudioSource = m_initAudioSource.GetComponent<ONSPAudioSource>();
			}
		}

		protected virtual void Update()
		{
			if (IsCooldownActive)
			{
				Cooldown();
			}
		}

		public void OnPhotonInstantiate(PhotonMessageInfo info)
		{
			PhotonView photonView = PhotonView.Find((int)base.photonView.InstantiationData[0]);
			if (photonView == null)
			{
				WandsLogger.LogError("Spell instantiated without correct view id data");
				UnityEngine.Object.Destroy(base.gameObject);
				return;
			}
			m_slotIndex = (int)base.photonView.InstantiationData[1];
			base.transform.SetParent(photonView.transform, ResetBehaviour.Position);
			IWandControl component = photonView.GetComponent<IWandControl>();
			Initialize(component);
			InitializeChargeEffects(component, info.Sender.IsLocal);
		}

		private void Initialize(IWandControl wandControl)
		{
			if (wandControl == null)
			{
				WandsLogger.LogError($"Wand Controller not found for spell <{Type}>");
				return;
			}
			m_spellSelectedEvent = new Events.SpellSelectedEvent
			{
				Spell = this
			};
			m_wandControl = wandControl;
			CharacterControl = wandControl.Wielder.CharacterControl;
			m_playerControl = CharacterControl as PlayerControl;
			m_isChargeable = Constants.ChargeableSpells.Contains(m_type);
			TimesPicked++;
		}

		private void InitializeChargeEffects(IWandControl wandControl, bool isLocal)
		{
			if (isLocal)
			{
				if (m_castEffector != null)
				{
					m_castEffector.WandControl = wandControl;
				}
				return;
			}
			CharacterBase characterBase = ((!(m_wandControl is BotWandControl)) ? ((CharacterBase)base.transform.GetComponentInParent<RemoteCharacter>()) : ((CharacterBase)base.transform.GetComponentInParent<BotCharacter>()));
			Transform transform = ((!(characterBase != null)) ? base.transform : characterBase.GetWandMeshTransform(wandControl.WandHand));
			TrySetChargeEffectParent(transform, remotely: true);
			if (m_castEffector != null)
			{
				m_castEffector.WandControl = wandControl;
				CastEffectorBall castEffectorBall = m_castEffector as CastEffectorBall;
				if (castEffectorBall != null)
				{
					castEffectorBall.SetRemoteWandTransform(transform);
				}
			}
		}

		public virtual IReadOnlyDictionary<string, string> GetSpellDescriptionParams()
		{
			return null;
		}

		public int GetCastCost()
		{
			return m_castCost;
		}

		public void SetCastCost(int castCost)
		{
			m_castCost = castCost;
		}

		public virtual void SpellPress()
		{
			m_casting = true;
			if (m_castTime > 0f)
			{
				StopCoroutine("PrepareFireDelayed");
				StartCoroutine("PrepareFireDelayed");
			}
			else
			{
				PrepareFire();
			}
			TryTriggerSpellPressHaptics();
			TryEnableCastFeedback();
			OnPress();
		}

		protected void TryEnableCastFeedback()
		{
			if (m_isChargeable && IsPlayerControlled)
			{
				m_playerControl.SetCastFeedbackActive(active: true, WandHand);
			}
		}

		public virtual void SpellHold()
		{
			if (m_casting && !IsCooldownActive)
			{
				UpdateHoldEffect();
				OnHold();
			}
		}

		public virtual void SpellRelease(bool forceRelease = false)
		{
			if (!m_casting || IsCooldownActive)
			{
				return;
			}
			if (m_castTime > 0f)
			{
				if (m_blockUntilCharged && !m_readyToFire)
				{
					AbortSpellCasting();
					return;
				}
				StopCoroutine("PrepareFireDelayed");
			}
			m_readyToFire = false;
			TryTriggerSpellReleaseHaptics();
			OnRelease(forceRelease);
		}

		protected void OnValidSpellCast()
		{
			if (!Wielder.IsBot)
			{
				if (m_isChargeable && IsPlayerControlled)
				{
					m_playerControl.SetCastFeedbackActive(active: false, WandHand);
				}
				if (GameControl.Instance.IsCurrentLevel(Level.Basement))
				{
					Events.SpellCastEvent spellCastEvent = new Events.SpellCastEvent();
					spellCastEvent.Spell = m_type;
					EventHub.Publish(spellCastEvent);
				}
			}
		}

		protected abstract void OnPress();

		protected abstract void OnHold();

		protected abstract void OnRelease(bool forceRelease = false);

		public virtual void ResetSpellEffectors()
		{
			TrySetChargeEffectParent(base.transform);
			if (m_castEffector != null)
			{
				m_castEffector.transform.SetParent(base.transform);
			}
		}

		public virtual void AbortSpellCasting(bool discret = false, bool backButtonForce = false)
		{
			if (IsPlayerControlled)
			{
				m_readyToFire = false;
				TryCancelHaptics();
				if (m_isChargeable)
				{
					m_playerControl.SetCastFeedbackActive(active: false, WandHand);
				}
			}
		}

		public virtual bool CanCast()
		{
			return !m_casting && !IsCooldownActive;
		}

		public virtual void OnSpellSelect()
		{
			m_isSelected = true;
			EventHub.Publish(m_spellSelectedEvent);
		}

		public virtual void OnSpellChange()
		{
			m_isSelected = false;
		}

		public virtual void DrainEnergy()
		{
			DrainEnergy(GetCastCost());
		}

		public virtual void DrainEnergy(int cost)
		{
			if (m_wandControl != null && (!NetworkUtils.ConnectedToGame || base.photonView.Owner.IsLocal))
			{
				switch (m_costType)
				{
				case CostType.Health:
					m_wandControl.Wielder.ChangeHealth(-cost);
					break;
				case CostType.Mana:
					m_wandControl.Wielder.ChangeMana(-cost);
					break;
				}
			}
		}

		public virtual void GainEnergy()
		{
			GainEnergy(GetCastCost());
		}

		public virtual void GainEnergy(int energy)
		{
			if (m_costType == CostType.Mana)
			{
				m_wandControl.Wielder.ChangeManaUsed(-energy);
			}
			DrainEnergy(-energy);
		}

		protected bool OutOfEnergy(float castCost)
		{
			return Wielder.Wand.OutOfEnergy(castCost, m_costType, WandHand);
		}

		protected void SetHoldEffectActive(bool enable)
		{
			if (m_wandChargeEffect != null && m_wandChargeEffect.transform.parent != base.transform && m_wandChargeEffect.IsActive != enable)
			{
				SetWandChargeEffectActive(enable);
			}
			if (m_castEffector == null || m_castEffector.gameObject.activeSelf == enable)
			{
				return;
			}
			if (enable)
			{
				switch (m_castEffector.Type)
				{
				case CastEffectorBase.CastEffectorType.Wand:
					if (m_castEffector.transform.parent != m_wandControl.Aim.AimPivot)
					{
						m_castEffector.transform.SetParent(m_wandControl.Aim.AimPivot, ResetBehaviour.Rotation);
						m_castEffector.transform.position = m_wandControl.CachedTipPoint;
					}
					break;
				case CastEffectorBase.CastEffectorType.Ground:
					m_castEffector.transform.position = CharacterControl.GetPlayerPosition();
					break;
				}
			}
			m_castEffector.transform.localRotation = Quaternion.identity;
			m_castEffector.SetActive(enable, m_castTime);
		}

		protected virtual void UpdateHoldEffect()
		{
			if (m_castEffector != null)
			{
				m_castEffector.UpdateEffect(m_castTime);
			}
		}

		protected virtual IEnumerator PrepareFireDelayed()
		{
			if (m_casting)
			{
				if (m_remainingChargeDuration == null)
				{
					m_remainingChargeDuration = new WaitForSeconds(m_castTime);
				}
				yield return m_remainingChargeDuration;
				if (m_casting)
				{
					PrepareFire();
				}
			}
		}

		protected void PrepareFire()
		{
			if (!m_casting)
			{
				return;
			}
			m_readyToFire = true;
			if (m_autoFire)
			{
				if (OutOfEnergy(GetCastCost()))
				{
					AbortSpellCasting();
				}
				else
				{
					SpellRelease(forceRelease: true);
				}
			}
		}

		protected void SetWandChargeEffectActive(bool enable, bool networkSync = true)
		{
			if (networkSync && NetworkUtils.ConnectedToGame)
			{
				base.photonView.RPC("PunSetWandChargeEffectActive", RpcTarget.All, enable);
			}
			else
			{
				PunSetWandChargeEffectActive(enable);
			}
		}

		[PunRPC]
		protected void PunSetWandChargeEffectActive(bool enable)
		{
			if (!(m_wandChargeEffect == null))
			{
				m_wandChargeEffect.SetEffectActive(enable);
			}
		}

		public void SetTotalDamage(float value)
		{
			TotalDamageDealt = value;
		}

		public virtual void AddTotalDamage(float value)
		{
			if (!(this == null) && (!NetworkUtils.ConnectedToGame || !base.photonView.Owner.IsLocal))
			{
				TotalDamageDealt += value;
			}
		}

		public void PlaySfx()
		{
			PlaySfx(m_wandControl.CachedTipPoint);
		}

		protected void PlaySfx(Vector3 position, bool playUnique = false, int generalClipIndex = -1, bool play2dLocally = false, float localVolume = 1f)
		{
			if (!Wielder.IsBot && !(m_initAudioSource == null) && !(m_initAudioSource.clip == null) && (!playUnique || !m_initAudioSource.isPlaying))
			{
				if (NetworkUtils.ConnectedToGame)
				{
					base.photonView.RPC("PunPlaySfx", RpcTarget.Others, position, generalClipIndex, 1f, m_originalInitAudioSourceVolume);
				}
				PunPlaySfx(position, generalClipIndex, (!play2dLocally) ? 1f : 0f, (!play2dLocally) ? m_originalInitAudioSourceVolume : localVolume);
			}
		}

		[PunRPC]
		protected void PunPlaySfx(Vector3 position, int generalClipIndex, float spatialBlend, float volume)
		{
			if (m_initAudioSource == null)
			{
				return;
			}
			if (generalClipIndex != -1)
			{
				m_initAudioSource.clip = PunSingleton<SoundManager>.Instance.generalAudioClips[generalClipIndex];
			}
			if (!(m_initAudioSource.clip == null))
			{
				m_initAudioSource.Stop();
				if (position == Vector3.zero)
				{
					m_initAudioSource.transform.localPosition = position;
				}
				else
				{
					m_initAudioSource.transform.position = position;
				}
				m_initAudioSource.volume = volume;
				m_initAudioSource.spatialBlend = spatialBlend;
				if (m_initONSPAudioSource != null)
				{
					m_initONSPAudioSource.EnableSpatialization = spatialBlend > 0f;
				}
				m_initAudioSource.Play();
			}
		}

		private void TrySetChargeEffectParent(Transform parent, bool remotely = false)
		{
			if (!(m_wandChargeEffect == null))
			{
				if (remotely)
				{
					m_wandChargeEffect.SetRemoteWandTransform(parent);
				}
				else
				{
					m_wandChargeEffect.SetWandParent(parent);
				}
			}
		}

		public bool IsType(Spell compareType)
		{
			return m_type == compareType;
		}

		public bool IsIndex(int compareIndex)
		{
			return m_slotIndex == compareIndex;
		}

		public string GetName()
		{
			return ScriptLocalization.Get(NameTerm);
		}

		public string GetDescription()
		{
			return ScriptLocalization.Get(DescriptionTerm);
		}

		protected void TryTriggerSpellPressHaptics()
		{
			if (IsPlayerControlled && m_spellPressHaptics != null)
			{
				m_playerControl.Input?.TriggerHaptics(m_spellPressHaptics, overrideCurrent: true, WandHand);
			}
		}

		protected void TryTriggerSpellReleaseHaptics()
		{
			if (IsPlayerControlled && m_spellReleaseHaptics != null)
			{
				m_playerControl.Input?.TriggerHaptics(m_spellReleaseHaptics, overrideCurrent: true, WandHand);
			}
		}

		protected void TryCancelHaptics()
		{
			if (IsPlayerControlled)
			{
				m_playerControl.Input?.CancelHaptics(VibrateController.Primary, WandHand);
			}
		}

		public virtual void ApplyDamageMultiplier(float value)
		{
		}

		protected void TryResetCooldown()
		{
			if (!m_blockCooldown)
			{
				m_fireRateTimer = m_fireRate;
				IsCooldownActive = true;
			}
		}

		private void Cooldown()
		{
			if (m_fireRateTimer > 0f)
			{
				m_fireRateTimer -= Time.deltaTime;
			}
			else
			{
				IsCooldownActive = false;
			}
		}
	}
	[RequireComponent(typeof(PhotonView), typeof(AudioSource))]
	public abstract class SpellBase_Defense : SpellBase, IPunObservable
	{
		private const string ShieldHitSoundClipName = "shield_of_light_hit";

		private const float ShieldHitSoundClipVolume = 1f;

		[Header("Defense")]
		[SerializeField]
		protected float m_manaDrainPerSecond = 20f;

		[SerializeField]
		protected Collider m_collider;

		[SerializeField]
		private GameObject m_effectParent;

		[SerializeField]
		private bool m_reflective;

		[SerializeField]
		private bool m_deflective;

		[SerializeField]
		private WandChargeEffect m_hitEffect;

		[Header("Light")]
		[SerializeField]
		private Light m_light;

		[SerializeField]
		private float m_maxLightIntensity;

		[SerializeField]
		[Range(0.1f, 1f)]
		private float m_lightFadeTime = 0.2f;

		[Header("Sfx")]
		[SerializeField]
		private AudioSource m_shieldAudioSource;

		[SerializeField]
		private AudioClip[] m_audioClips = Array.Empty<AudioClip>();

		protected bool m_drainMana;

		private Tweener m_lightTweener;

		public override string CastCost
		{
			[CompilerGenerated]
			get
			{
				return $"{m_manaDrainPerSecond}/s";
			}
		}

		public bool IsReflective
		{
			[CompilerGenerated]
			get
			{
				return m_reflective;
			}
		}

		public bool IsDeflective
		{
			[CompilerGenerated]
			get
			{
				return m_deflective;
			}
		}

		protected Collider Collider
		{
			[CompilerGenerated]
			get
			{
				return m_collider;
			}
		}

		protected GameObject EffectObject
		{
			[CompilerGenerated]
			get
			{
				return m_effectParent;
			}
		}

		public void OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info)
		{
			SerializeView(stream, info);
		}

		protected virtual void SerializeView(PhotonStream stream, PhotonMessageInfo info)
		{
		}

		protected override void Start()
		{
			base.Start();
			bool? flag = base.Wielder?.IsLocal;
			if (flag.HasValue && flag.Value)
			{
				SetActive(active: false, playSound: false, playAnimation: false);
			}
		}

		protected override void OnDestroy()
		{
			base.OnDestroy();
			if (m_hitEffect != null)
			{
				UnityEngine.Object.Destroy(m_hitEffect.gameObject);
			}
		}

		public override void SpellPress()
		{
			m_casting = true;
			TryTriggerSpellPressHaptics();
			TryEnableCastFeedback();
			OnPress();
		}

		public override void SpellHold()
		{
			if (m_drainMana)
			{
				OnHold();
			}
		}

		public override void SpellRelease(bool forceRelease = false)
		{
			AbortSpellCasting(m_casting);
			TryTriggerSpellReleaseHaptics();
			OnRelease(forceRelease);
			OnValidSpellCast();
		}

		public override void AbortSpellCasting(bool discret = false, bool backButtonForce = false)
		{
			base.AbortSpellCasting(discret, backButtonForce);
			m_casting = false;
			m_drainMana = false;
			DrainEnergy(0);
			if (Collider != null && Collider.enabled)
			{
				SetActive(active: false, !discret, !discret);
			}
		}

		protected override void OnPress()
		{
			m_casting = true;
			DrainEnergy();
			SetActive(active: true);
		}

		protected override void OnHold()
		{
		}

		protected override void OnRelease(bool forceRelease = false)
		{
		}

		public virtual void OnSpellHit(float dmg, Vector3 hitPoint)
		{
			if (!(base.Wielder == null))
			{
				PlaySound("shield_of_light_hit", 1f);
				if (!(m_hitEffect == null))
				{
					TryTriggerSpellReleaseHaptics();
					m_hitEffect.DisableEmitters(m_hitEffect.gameObject);
					m_hitEffect.SetEffectActive(enable: true);
				}
			}
		}

		protected virtual void SetActive(bool active, bool playSound = true, bool playAnimation = true)
		{
			m_drainMana = active;
			SetWandChargeEffectActive(active);
			if (playAnimation)
			{
				if (active)
				{
					base.Wielder.AnimationRelay.PlayChannelingAnimation(ChannelAnimationType.Default);
				}
				else
				{
					base.Wielder.AnimationRelay.StopChannelingAnimation(ChannelAnimationType.Default);
				}
			}
			UpdatePosition();
			base.photonView.RPC("PunSetActive", RpcTarget.All, active, base.transform.position, base.transform.rotation);
		}

		[PunRPC]
		protected virtual void PunSetActive(bool active, Vector3 position, Quaternion rotation)
		{
			EffectObject.SetActive(active);
			FadeLight(active);
			Collider.enabled = active;
			base.transform.position = position;
			base.transform.rotation = rotation;
		}

		[PunRPC]
		protected void PlayShieldSound(int clipIndex)
		{
			AudioClip audioClip = m_audioClips[clipIndex];
			if (!(audioClip == null))
			{
				m_shieldAudioSource.Stop();
				m_shieldAudioSource.clip = audioClip;
				m_shieldAudioSource.Play();
			}
		}

		protected void PlaySound(string name, float volume)
		{
			if (m_shieldAudioSource == null)
			{
				return;
			}
			int clipIndex = GetClipIndex(name);
			if (clipIndex >= 0)
			{
				if (NetworkUtils.ConnectedToGame)
				{
					base.photonView.RPC("PlayShieldSound", RpcTarget.AllBuffered, clipIndex);
				}
				else
				{
					PlayShieldSound(clipIndex);
				}
			}
		}

		private int GetClipIndex(string name)
		{
			if (m_audioClips.IsNullOrEmpty())
			{
				return -1;
			}
			for (int i = 0; i < m_audioClips.Length; i++)
			{
				if (m_audioClips[i].name == name)
				{
					return i;
				}
			}
			return -1;
		}

		protected void FadeLight(bool fadeIn)
		{
			if (m_light == null)
			{
				return;
			}
			if (m_maxLightIntensity <= 0f)
			{
				WandsLogger.LogError("Spellbase_Defense | Default light intensity is 0");
				return;
			}
			if (m_lightTweener != null)
			{
				m_lightTweener.Complete();
			}
			if (fadeIn)
			{
				m_lightTweener = m_light.DOIntensity(m_maxLightIntensity, m_lightFadeTime).SetEase(Ease.OutQuad);
			}
			else
			{
				m_lightTweener = m_light.DOIntensity(0f, m_lightFadeTime).SetEase(Ease.InQuad);
			}
		}

		protected virtual void UpdatePosition()
		{
		}
	}
	public class SpellBase_Projectile : SpellBase
	{
		private const float ScatteredShotDistanceFactor = 0.035f;

		private const float ScatteredShotMinSpeedFactor = 0.55f;

		private const float ScatteredShotMaxSpeedFactor = 1.25f;

		[Header("Projectile Behaviour")]
		public ProjectileBehaviour m_projectileBehaviour;

		public DamageType m_dmgType;

		[SerializeField]
		protected AttackAnimationType m_animationType;

		[SerializeField]
		protected bool m_showTrajectory;

		[SerializeField]
		private bool m_continuousFire;

		public float m_spellDmg = 40f;

		[SerializeField]
		protected int m_castCostFirst;

		[SerializeField]
		protected int m_projectileCount = 1;

		public float m_moveSpeed = 1f;

		[Range(0.03f, 0.5f)]
		public float m_collisionRadius = 0.03f;

		[SerializeField]
		[Tooltip("Cost per threaded projectile")]
		private float m_threadedProjectileCastCost;

		[Header("Offset")]
		[SerializeField]
		[Range(0f, 1f)]
		protected float m_originOffset;

		[SerializeField]
		protected float m_maxOffset = 2f;

		[SerializeField]
		protected float m_minOffset = 0.75f;

		[Header("Bounce")]
		public bool m_bounceActive;

		public int m_maxBounces;

		[Header("Splash Damage")]
		[SerializeField]
		private SplashDamageDataObject m_splashDamageData;

		protected readonly Vector3[] m_spellArcPoints = new Vector3[3]
		{
			Vector3.zero,
			Vector3.zero,
			Vector3.zero
		};

		protected float m_scatterOffset = 2f;

		protected bool m_tapHold;

		protected float m_currentHoldTime;

		private Vector3[] m_overrideArcPoints;

		private float m_nextFire;

		private bool m_firstProjectile;

		public override bool TapHold
		{
			[CompilerGenerated]
			get
			{
				return m_tapHold;
			}
		}

		public float FireTime
		{
			[CompilerGenerated]
			get
			{
				return PunSingleton<TimeManager>.Instance.CurrentRoomTime + 0.15f;
			}
		}

		public override string SpellDamage
		{
			[CompilerGenerated]
			get
			{
				return (!IsType(Spell.Spell_Demi)) ? m_spellDmg.ToString() : "50%";
			}
		}

		public bool HasSplashDamageData
		{
			[CompilerGenerated]
			get
			{
				return m_splashDamageData != null;
			}
		}

		public SplashDamageData SplashDamageData
		{
			[CompilerGenerated]
			get
			{
				return (!(m_splashDamageData != null)) ? SplashDamageData.Empty() : m_splashDamageData.Data;
			}
		}

		protected Vector3 SpawnPosition
		{
			[CompilerGenerated]
			get
			{
				return m_wandControl.GetTipPosition(m_originOffset);
			}
		}

		protected override void Start()
		{
			base.Start();
			if (m_collisionRadius <= 0f)
			{
				m_collisionRadius = 0.025f;
			}
			if (m_animationType == AttackAnimationType.Light)
			{
				m_animationType = AttackAnimationType.Heavy;
			}
		}

		protected override void OnPress()
		{
			m_firstProjectile = true;
			m_nextFire = 0f;
			ResetArcPoints();
			if (m_animationType == AttackAnimationType.Channeling)
			{
				base.Wielder.AnimationRelay.PlayChannelingAnimation(ChannelAnimationType.Fast);
			}
			switch (m_projectileBehaviour)
			{
			case ProjectileBehaviour.Arching:
			{
				ref Vector3 reference = ref m_spellArcPoints[2];
				reference = m_wandControl.GetCurrentHitPoint(m_collisionRadius);
				PlaySfx();
				break;
			}
			case ProjectileBehaviour.Straight:
			case ProjectileBehaviour.Homing:
			case ProjectileBehaviour.Instant:
			case ProjectileBehaviour.Arrow:
			case ProjectileBehaviour.Tile:
				PlaySfx();
				break;
			case ProjectileBehaviour.Threaded:
				PlaySfx();
				break;
			case ProjectileBehaviour.Scatter:
				m_currentHoldTime = 0f;
				m_scatterOffset = m_maxOffset;
				break;
			}
		}

		protected override void OnHold()
		{
			m_tapHold = !m_readyToFire;
			SetHoldEffectActive(enable: true);
			switch (m_projectileBehaviour)
			{
			case ProjectileBehaviour.Arching:
			{
				m_readyToFire = true;
				ref Vector3 reference = ref m_spellArcPoints[0];
				reference = SpawnPosition;
				ref Vector3 reference2 = ref m_spellArcPoints[1];
				reference2 = m_wandControl.GetCurrentHitPoint(m_collisionRadius);
				m_wandControl.ArcHandler.CalculateProjectileCurve(m_spellArcPoints, m_bounceActive);
				break;
			}
			case ProjectileBehaviour.Straight:
			case ProjectileBehaviour.Threaded:
			case ProjectileBehaviour.Arrow:
			case ProjectileBehaviour.Tile:
				m_readyToFire = true;
				break;
			case ProjectileBehaviour.Scatter:
			{
				m_readyToFire = true;
				m_currentHoldTime += Time.deltaTime;
				float t = m_currentHoldTime / m_castTime;
				m_scatterOffset = Mathf.Lerp(m_maxOffset, m_minOffset, t);
				break;
			}
			}
			IncreaseStat();
		}

		protected override void OnRelease(bool forceRelease = false)
		{
			m_casting = false;
			TryResetCooldown();
			if (!GameControl.Instance.IsCurrentLevel(Level.Lobby))
			{
				if (m_animationType == AttackAnimationType.Channeling)
				{
					base.Wielder.AnimationRelay.StopChannelingAnimation(ChannelAnimationType.Fast);
				}
				else
				{
					base.Wielder.AnimationRelay.PlayAttackAnimation(m_animationType);
				}
			}
			switch (m_projectileBehaviour)
			{
			case ProjectileBehaviour.Arching:
				m_wandControl.ArcHandler.HideDots();
				if (m_overrideArcPoints != null && m_overrideArcPoints.Length == 3)
				{
					ref Vector3 reference = ref m_spellArcPoints[0];
					reference = m_overrideArcPoints[0];
					ref Vector3 reference2 = ref m_spellArcPoints[1];
					reference2 = m_overrideArcPoints[1];
					ref Vector3 reference3 = ref m_spellArcPoints[2];
					reference3 = m_overrideArcPoints[2];
				}
				else if (m_spellArcPoints[0] == Vector3.zero || m_spellArcPoints[1] == Vector3.zero)
				{
					ref Vector3 reference4 = ref m_spellArcPoints[0];
					reference4 = SpawnPosition;
					ref Vector3 reference5 = ref m_spellArcPoints[1];
					reference5 = m_wandControl.GetCurrentHitPoint(m_collisionRadius);
				}
				DrainEnergy();
				FireProjectile(m_spellArcPoints, m_moveSpeed, m_spellDmg, -1);
				SetOverrideArcPoints(null);
				break;
			case ProjectileBehaviour.Straight:
			case ProjectileBehaviour.Instant:
			case ProjectileBehaviour.Tile:
				FireStraight(-1, forceRelease);
				break;
			case ProjectileBehaviour.Arrow:
				if (m_firstProjectile)
				{
					ref Vector3 reference6 = ref m_spellArcPoints[0];
					reference6 = SpawnPosition;
					ref Vector3 reference7 = ref m_spellArcPoints[2];
					reference7 = GetOffsettedEndPoint(m_wandControl.GetCurrentHitPoint(m_collisionRadius), m_wandControl.GetAimDistance());
					ref Vector3 reference8 = ref m_spellArcPoints[1];
					reference8 = GetOffsettedMidPointUp(m_spellArcPoints[0], m_spellArcPoints[2], 1f);
					FireStraight(-1, forceRelease, drainEnergy: true, m_spellArcPoints[0], m_spellArcPoints[1], m_spellArcPoints[2]);
				}
				break;
			case ProjectileBehaviour.Threaded:
				FireThreaded(-1, forceRelease);
				break;
			case ProjectileBehaviour.Homing:
			{
				Wielder opponent = null;
				if (PlayerManager.Instance.CanGetOpponentWielder(base.Wielder.ViewID, out opponent))
				{
					FireStraight(opponent.photonView.ViewID, forceRelease);
					break;
				}
				TrainingDummy[] array = UnityEngine.Object.FindObjectsOfType<TrainingDummy>();
				PhotonView photonView = null;
				if (array.Length > 0)
				{
					photonView = array.GetRandomElement().photonView;
				}
				FireStraight((!(photonView != null)) ? (-1) : photonView.ViewID, forceRelease);
				break;
			}
			case ProjectileBehaviour.Scatter:
				FireScatteredShot();
				break;
			}
			SetHoldEffectActive(enable: false);
			OnValidSpellCast();
		}

		public override void AbortSpellCasting(bool discret = false, bool backButtonForce = false)
		{
			base.AbortSpellCasting(discret, backButtonForce);
			m_casting = false;
			m_wandControl.ArcHandler.HideDots(clearArcPositions: true);
			if (m_animationType == AttackAnimationType.Channeling)
			{
				base.Wielder.AnimationRelay.StopChannelingAnimation(ChannelAnimationType.Fast);
			}
			StopCoroutine("PrepareFireDelayed");
			SetHoldEffectActive(enable: false);
		}

		public override void DrainEnergy(int cost)
		{
			if (cost <= 0)
			{
				cost = ((m_castCostFirst <= 0) ? GetCastCost() : ((!m_firstProjectile) ? GetCastCost() : m_castCostFirst));
			}
			base.DrainEnergy(cost);
			if (m_firstProjectile)
			{
				m_firstProjectile = false;
			}
		}

		protected virtual void FireStraight(int opponentWielderID, bool forceRelease, bool drainEnergy = true)
		{
			Vector3 currentHitPoint = m_wandControl.GetCurrentHitPoint(m_collisionRadius);
			FireStraight(opponentWielderID, forceRelease, drainEnergy, SpawnPosition, MathUtils.GetMidPoint(SpawnPosition, currentHitPoint), currentHitPoint);
		}

		protected virtual void FireStraight(int opponentWielderID, bool forceRelease, bool drainEnergy, Vector3 point0, Vector3 point1, Vector3 point2)
		{
			m_spellArcPoints[0] = point0;
			m_spellArcPoints[1] = point1;
			m_spellArcPoints[2] = point2;
			if (drainEnergy)
			{
				DrainEnergy();
			}
			FireProjectile(m_spellArcPoints, m_moveSpeed, m_spellDmg, opponentWielderID);
		}

		protected virtual void FireProjectile(Vector3[] bezierPoints, float moveSpeed, float dmg, int opponentId, params object[] parameters)
		{
			ProjectileMover projectileMover = ObjectPoolHandler.GrabFromPool(Type, base.photonView.ViewID) as ProjectileMover;
			Vector3[] array = bezierPoints.ToArray();
			projectileMover.EnableObject(array[0], FireTime, array, moveSpeed, dmg, opponentId);
		}

		protected void FireThreaded(int opponentWielderID, bool forceFire)
		{
			Vector3 currentHitPoint = m_wandControl.GetCurrentHitPoint(m_collisionRadius);
			FireThreaded(opponentWielderID, forceFire, SpawnPosition, MathUtils.GetMidPoint(SpawnPosition, currentHitPoint), currentHitPoint);
		}

		protected void FireThreaded(int opponentWielderID, bool forceFire, Vector3 point0, Vector3 point1, Vector3 point2)
		{
			m_spellArcPoints[0] = point0;
			m_spellArcPoints[1] = point1;
			m_spellArcPoints[2] = point2;
			if (forceFire)
			{
				StartCoroutine(FireThreadedProjectile(0.15f, first: true));
				return;
			}
			if (IsType(Spell.Spell_MagicMissile))
			{
				PunSingleton<SoundManager>.Instance.PlaySoundAtPoint("magic_missile_single_shot", 0.7f, m_spellArcPoints[0]);
			}
			DrainEnergy();
			FireProjectile(m_spellArcPoints, m_moveSpeed, m_spellDmg, 3);
		}

		protected virtual IEnumerator FireThreadedProjectile(float waitTime, bool first)
		{
			WaitForSeconds wait = new WaitForSeconds(0.01f);
			if (IsType(Spell.Spell_MagicMissile))
			{
				PunSingleton<SoundManager>.Instance.PlaySoundAtPoint("magic_missile_charge_shot", 0.7f, m_spellArcPoints[0]);
			}
			int modifiedCost = Mathf.RoundToInt(m_threadedProjectileCastCost);
			for (int i = 0; i < m_projectileCount; i++)
			{
				if (OutOfEnergy(modifiedCost))
				{
					SpellRelease();
					break;
				}
				DrainEnergy(modifiedCost);
				ref Vector3 reference = ref m_spellArcPoints[1];
				reference = ((!first) ? GetOffsettedMidpoint(i, m_spellArcPoints[0], m_spellArcPoints[2]) : MathUtils.GetMidPoint(m_spellArcPoints[0], m_spellArcPoints[2]));
				FireProjectile(m_spellArcPoints, m_moveSpeed, m_spellDmg, i);
				first = false;
				yield return wait;
			}
		}

		private void FireScatteredShot()
		{
			PlaySfx();
			DrainEnergy();
			ref Vector3 reference = ref m_spellArcPoints[0];
			reference = SpawnPosition;
			float num = m_wandControl.Aim.AimDistance * 0.035f;
			Vector3 currentHitPoint = m_wandControl.GetCurrentHitPoint(0f);
			Transform aimPivot = m_wandControl.Aim.AimPivot;
			Vector3 vector = aimPivot.up * num;
			Vector3 vector2 = aimPivot.right * num;
			for (int i = 0; i < m_projectileCount; i++)
			{
				if (i == 0)
				{
					m_spellArcPoints[2] = currentHitPoint;
				}
				else
				{
					ref Vector3 reference2 = ref m_spellArcPoints[2];
					reference2 = currentHitPoint + vector2 * ((i % 2 != 0) ? UnityEngine.Random.Range(m_minOffset, m_scatterOffset) : UnityEngine.Random.Range(0f - m_scatterOffset, m_minOffset)) + vector * UnityEngine.Random.Range(0f - m_scatterOffset, m_scatterOffset);
				}
				ref Vector3 reference3 = ref m_spellArcPoints[1];
				reference3 = MathUtils.GetMidPoint(m_spellArcPoints[0], m_spellArcPoints[2]);
				FireProjectile(m_spellArcPoints, m_moveSpeed * UnityEngine.Random.Range(0.55f, 1.25f), m_spellDmg, -1);
			}
		}

		protected virtual void IncreaseStat()
		{
			if (!m_continuousFire)
			{
				return;
			}
			if (m_nextFire < m_fireRate)
			{
				m_nextFire += Time.deltaTime;
				return;
			}
			m_nextFire = 0f;
			if (OutOfEnergy(GetCastCost()))
			{
				AbortSpellCasting();
				return;
			}
			if (m_projectileBehaviour != ProjectileBehaviour.Arrow)
			{
				FireStraight(-1, forceRelease: true);
				return;
			}
			ref Vector3 reference = ref m_spellArcPoints[0];
			reference = SpawnPosition;
			ref Vector3 reference2 = ref m_spellArcPoints[2];
			reference2 = GetOffsettedEndPoint(m_wandControl.GetCurrentHitPoint(m_collisionRadius), m_wandControl.GetAimDistance());
			ref Vector3 reference3 = ref m_spellArcPoints[1];
			reference3 = GetOffsettedMidPointUp(m_spellArcPoints[0], m_spellArcPoints[2], 1f);
			FireStraight(-1, forceRelease: true, drainEnergy: true, m_spellArcPoints[0], m_spellArcPoints[1], m_spellArcPoints[2]);
		}

		public void SetOverrideArcPoints(params Vector3[] points)
		{
			m_overrideArcPoints = points;
		}

		protected void ResetArcPoints()
		{
			ref Vector3 reference = ref m_spellArcPoints[0];
			reference = Vector3.zero;
			ref Vector3 reference2 = ref m_spellArcPoints[1];
			reference2 = Vector3.zero;
			ref Vector3 reference3 = ref m_spellArcPoints[2];
			reference3 = Vector3.zero;
		}

		protected Vector3 GetOffsettedEndPoint(Vector3 cleanEndPoint, float aimDistance)
		{
			return cleanEndPoint + m_wandControl.Aim.AimPivot.right * (UnityEngine.Random.Range(0f - m_minOffset, m_maxOffset) * aimDistance) + m_wandControl.Aim.AimPivot.up * (UnityEngine.Random.Range(0f - m_minOffset, m_maxOffset) * aimDistance);
		}

		protected Vector3 GetOffsettedMidPointUp(Vector3 startPoint, Vector3 endPoint, float offset)
		{
			return MathUtils.GetMidPoint(startPoint, endPoint) + Vector3.up * offset * (Vector3.Distance(startPoint, endPoint) * 0.1f);
		}

		protected Vector3 GetOffsettedMidpoint(int index, Vector3 startPoint, Vector3 endPoint)
		{
			Vector3 vector = endPoint;
			if (m_projectileBehaviour == ProjectileBehaviour.Threaded)
			{
				PlayerWand playerWand = base.CharacterControl.Wand.GetPlayerWand(base.WandHand);
				Vector3 vector2 = ((!(playerWand.WandParent != null)) ? base.Wielder.PlayerControl.CameraTransform.right : playerWand.WandParent.right);
				return vector + vector2 * ((index % 2 != 0) ? m_minOffset : m_maxOffset) * (Vector3.Distance(startPoint, endPoint) * 0.1f);
			}
			float num = UnityEngine.Random.Range(m_minOffset, m_maxOffset);
			vector += m_wandControl.Aim.AimPivot.right * num;
			num = UnityEngine.Random.Range(m_minOffset, m_maxOffset);
			return vector + Vector3.up * num;
		}

		public override void ApplyDamageMultiplier(float value)
		{
			m_spellDmg *= value;
		}

		public void ApplySplashDamageMultiplier(float value)
		{
			if (m_splashDamageData != null)
			{
				m_splashDamageData.Data.DamageMultiplier = value;
			}
		}
	}
	public class SpellBase_Summon : Tile_AreaEffect
	{
		[Header("Summon")]
		[SerializeField]
		private bool m_targetCaster;

		[SerializeField]
		private bool m_dualFire;

		[SerializeField]
		private int m_durability = 50;

		[SerializeField]
		private int m_projectileDamage = 10;

		private TileEffectBase m_previousEffect;

		public bool CanTargetCaster
		{
			[CompilerGenerated]
			get
			{
				return m_targetCaster;
			}
		}

		public bool CanDualFire
		{
			[CompilerGenerated]
			get
			{
				return m_dualFire;
			}
		}

		public int Durability
		{
			[CompilerGenerated]
			get
			{
				return m_durability;
			}
		}

		public int ProjectileDamage
		{
			[CompilerGenerated]
			get
			{
				return m_projectileDamage;
			}
		}

		public override string SpellDamage
		{
			[CompilerGenerated]
			get
			{
				return m_projectileDamage.ToString();
			}
		}

		protected override void OnRelease(bool forceRelease = false)
		{
			if (base.IsDualWielding || m_newTile == null || m_newTile.GetEffectEnabled(this))
			{
				AbortSpellCasting();
				if (forceRelease)
				{
					m_wandControl.DeselectSpell();
					base.PlayerControl?.HUD?.DeselectSpell(base.WandHand);
				}
			}
			else
			{
				ResetHighlightedTile();
				CastEffect();
			}
		}

		protected override void CastEffect()
		{
			base.CastEffect();
			m_previousEffect = m_activePoolObject;
			InstantiateAreaEffect();
			PunSingleton<TileManager>.Instance?.OccupyTile(m_newTile, TileOccupyState.Occupied, (((object)m_activePoolObject != null) ? m_activePoolObject.photonView : null) ?? base.photonView, OnTileOccupiedChecked);
			ResetHighlightedTile();
		}

		private void OnTileOccupiedChecked(Tile tile, bool sucessfullyOccupied)
		{
			if (!sucessfullyOccupied)
			{
				RevertSpellCast();
			}
			else if (!m_allowInfinite && m_previousTileEffects.Count > m_numberOfCopiesAllowed)
			{
				RemoveOldestActiveEffect();
			}
		}

		public void RevertSpellCast()
		{
			GainEnergy(GetCastCost());
			RemoveActiveEffect();
			m_activePoolObject = m_previousEffect;
		}

		public override bool CanCast()
		{
			if (m_casting || base.IsCooldownActive)
			{
				return false;
			}
			if (base.IsDualWielding)
			{
				return true;
			}
			Tile highlightedTile = GetHighlightedTile();
			return highlightedTile != null && highlightedTile.OccupantWielder == null;
		}

		public override void AbortSpellCasting(bool discret = false, bool backButtonForce = false)
		{
			base.AbortSpellCasting(discret, backButtonForce);
			if (!backButtonForce)
			{
				m_casting = false;
				SetHoldEffectActive(enable: false);
				m_newTile = null;
			}
		}
	}
	public abstract class SpellBase_Teleport : SpellBase_Tile
	{
		[Header("Sfx")]
		[SerializeField]
		protected AudioClip[] m_teleportSfxClips = Array.Empty<AudioClip>();

		protected int m_teleportSoundIndex;

		protected int m_teleportBlockedSoundIndex;

		protected override void Start()
		{
			base.Start();
			for (int i = 0; i < PunSingleton<SoundManager>.Instance.generalAudioClips.Length; i++)
			{
				AudioClip audioClip = PunSingleton<SoundManager>.Instance.generalAudioClips[i];
				if (audioClip.name == m_teleportSfxClips[0].name)
				{
					m_teleportSoundIndex = i;
				}
				else if (audioClip.name == m_teleportSfxClips[1].name)
				{
					m_teleportBlockedSoundIndex = i;
				}
			}
		}

		public override bool CanCast()
		{
			return base.CanCast() && !base.Wielder.CharacterControl.IsTeleporting;
		}
	}
	public abstract class SpellBase_Tile : SpellBase, ITileSpell
	{
		[Header("Tile Spell")]
		[SerializeField]
		private GameObject m_tileHighlightEffect;

		[SerializeField]
		private bool m_highlightLookAtPlayer;

		protected Tile m_newTile;

		private Tile m_movingTile;

		protected override void OnDestroy()
		{
			base.OnDestroy();
			if (m_tileHighlightEffect != null)
			{
				UnityEngine.Object.Destroy(m_tileHighlightEffect);
				m_tileHighlightEffect = null;
			}
		}

		protected override void Update()
		{
			base.Update();
			if (m_isSelected)
			{
				TrackTiles();
			}
			if (m_movingTile != null)
			{
				SetHighlightEffectPosition(m_movingTile.transform.position);
			}
		}

		public void TrackTiles()
		{
			base.Wielder.CharacterControl.TryTrackTileHit(base.WandHand);
		}

		public void SetHighlightTile(Tile tile)
		{
			m_newTile = tile;
			if (base.IsPlayerControlled && !(m_tileHighlightEffect == null))
			{
				if (tile == null)
				{
					m_movingTile = null;
					HideHighlightEffect();
					return;
				}
				m_movingTile = ((!tile.IsElevatorTile) ? null : tile);
				SetHighlightEffectPosition(tile.transform.position);
				m_tileHighlightEffect.transform.parent = null;
				ShowHighlightEffect();
			}
		}

		public Tile GetHighlightedTile()
		{
			m_newTile = base.Wielder.Wand.GetPlayerWand(base.WandHand).HighlightedTile;
			return m_newTile;
		}

		public void ResetHighlightedTile()
		{
			m_newTile = null;
			base.Wielder.Wand.GetPlayerWand(base.WandHand).ResetHighlightedTile();
		}

		private void SetHighlightEffectPosition(Vector3 position)
		{
			if (!base.Wielder.IsBot && !(m_tileHighlightEffect == null))
			{
				m_tileHighlightEffect.transform.position = position;
				if (m_highlightLookAtPlayer)
				{
					Vector3 position2 = base.Wielder.PlayerControl.CameraTransform.position;
					position2.y = position.y;
					m_tileHighlightEffect.transform.LookAt(position2);
				}
			}
		}

		public override void OnSpellChange()
		{
			base.OnSpellChange();
			if (m_tileHighlightEffect != null)
			{
				m_tileHighlightEffect.transform.parent = base.transform;
				HideHighlightEffect();
			}
		}

		protected void HideHighlightEffect()
		{
			if (m_tileHighlightEffect != null)
			{
				m_tileHighlightEffect.SetActive(value: false);
			}
		}

		protected void ShowHighlightEffect()
		{
			if (m_tileHighlightEffect != null)
			{
				m_tileHighlightEffect.SetActive(value: true);
			}
		}

		public override void SpellPress()
		{
			TrackTiles();
			if (m_castTime > 0f)
			{
				base.SpellPress();
				return;
			}
			m_casting = true;
			StopCoroutine("PrepareFireDelayed");
			StartCoroutine("PrepareFireDelayed");
			TryTriggerSpellPressHaptics();
			OnPress();
		}

		public override void SpellHold()
		{
			if (m_casting || base.IsDualWielding)
			{
				UpdateHoldEffect();
				OnHold();
			}
		}

		public override void AbortSpellCasting(bool discret = false, bool backButtonForce = false)
		{
			base.AbortSpellCasting(discret, backButtonForce);
			m_casting = false;
			SetHoldEffectActive(enable: false);
			m_newTile = null;
		}
	}
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	public struct SpellData
	{
		public float Speed { get; set; }

		public float CollisionRadius { get; private set; }

		public float Damage { get; private set; }

		public DamageType DamageType { get; private set; }

		public ProjectileBehaviour Behaviour { get; private set; }

		public int HitMask { get; private set; }

		public int ControllingPlayerLayer { get; private set; }

		public int OppoinentID { get; private set; }

		public SpellData(float speed, float damage, int opponentId)
		{
			Speed = speed;
			CollisionRadius = 0f;
			Damage = damage;
			DamageType = DamageType.Once;
			Behaviour = ProjectileBehaviour.Straight;
			HitMask = 0;
			ControllingPlayerLayer = 0;
			OppoinentID = opponentId;
		}

		public SpellData(float speed, float collisionRadius, float damage, DamageType damageType, ProjectileBehaviour behaviour, int hitMask, int controllingPlayerLayer, int opponentID)
		{
			Speed = speed;
			CollisionRadius = collisionRadius;
			Damage = damage;
			DamageType = damageType;
			Behaviour = behaviour;
			HitMask = hitMask;
			ControllingPlayerLayer = controllingPlayerLayer;
			OppoinentID = opponentID;
		}
	}
}
namespace Cortopia.Scripts.Spells.Tile
{
	public class Spell_AcidCloud : Tile_AreaEffect
	{
		public override string SpellDamage
		{
			[CompilerGenerated]
			get
			{
				return $"{m_dmgInflict}-{m_maxDamageInflict}/s";
			}
		}

		protected override void CastEffect()
		{
			base.CastEffect();
			InstantiateAreaEffect();
		}
	}
	public class Spell_PetrifyingPrison : Tile_AreaEffect
	{
		protected override void CastEffect()
		{
			base.CastEffect();
			InstantiateAreaEffect();
		}
	}
	public class Spell_SoilSpikes : Tile_AreaEffect
	{
		protected override void CastEffect()
		{
			base.CastEffect();
			InstantiateAreaEffect();
		}
	}
	public abstract class Tile_AreaEffect : SpellBase_Tile
	{
		[Header("Area of Effect")]
		[SerializeField]
		protected AreaOfEffectBehaviour m_effectBehaviour;

		[SerializeField]
		protected DamageType m_dmgType;

		[SerializeField]
		protected float m_effectActivationDelay;

		[SerializeField]
		protected float m_timeFrame = 5f;

		[SerializeField]
		protected int m_dmgInflict = 5;

		[SerializeField]
		protected int m_maxDamageInflict = 5;

		[SerializeField]
		protected TileEffectBase m_activePoolObject;

		[SerializeField]
		protected bool m_allowInfinite;

		[SerializeField]
		[Range(1f, 5f)]
		protected int m_numberOfCopiesAllowed = 1;

		protected LinkedList<TileEffectBase> m_previousTileEffects;

		public override string SpellDamage
		{
			[CompilerGenerated]
			get
			{
				return m_dmgInflict.ToString();
			}
		}

		public DamageType DmgType
		{
			[CompilerGenerated]
			get
			{
				return m_dmgType;
			}
		}

		public float EffectActivationDelay
		{
			[CompilerGenerated]
			get
			{
				return m_effectActivationDelay;
			}
		}

		public float TimeFrame
		{
			[CompilerGenerated]
			get
			{
				return m_timeFrame;
			}
		}

		public int DmgInflict
		{
			[CompilerGenerated]
			get
			{
				return m_dmgInflict;
			}
		}

		public int MaxDamageInflict
		{
			[CompilerGenerated]
			get
			{
				return m_maxDamageInflict;
			}
		}

		private void Awake()
		{
			if (!m_allowInfinite)
			{
				m_previousTileEffects = new LinkedList<TileEffectBase>();
			}
		}

		public override void OnSpellSelect()
		{
			PunSingleton<TileManager>.Instance?.SetTileMaterialColor(Colors.TileEffectColor);
			base.OnSpellSelect();
		}

		protected override void OnPress()
		{
			base.Wielder.AnimationRelay.PlayAttackAnimation(AttackAnimationType.TileEffect);
			switch (m_effectBehaviour)
			{
			case AreaOfEffectBehaviour.OneShot:
			case AreaOfEffectBehaviour.Timed:
				if (!base.IsDualWielding)
				{
					m_newTile = GetHighlightedTile();
				}
				break;
			case AreaOfEffectBehaviour.Mine:
				m_newTile = base.Wielder.CurrentTile;
				break;
			}
		}

		protected override void OnRelease(bool forceRelease = false)
		{
			ResetHighlightedTile();
			if (base.IsDualWielding && m_effectBehaviour != AreaOfEffectBehaviour.Mine)
			{
				AbortSpellCasting();
				if (forceRelease)
				{
					m_wandControl.DeselectSpell();
					base.PlayerControl?.HUD?.DeselectSpell(base.WandHand);
				}
			}
			else
			{
				CastEffect();
			}
		}

		protected override void OnHold()
		{
			if (base.IsDualWielding && m_effectBehaviour != AreaOfEffectBehaviour.Mine)
			{
				TryAutoCastTileEffect();
			}
			else if (GetHighlightedTile() == null)
			{
				AbortSpellCasting();
			}
			else
			{
				SetHoldEffectActive(enable: true);
			}
		}

		private void TryAutoCastTileEffect()
		{
			if (GetHighlightedTile() == null)
			{
				SetHoldEffectActive(enable: true);
			}
			else if (!base.IsCooldownActive && !OutOfEnergy(GetCastCost()))
			{
				CastEffect();
				ResetHighlightedTile();
				PunSingleton<TileManager>.Instance.TrySetAllTilesAvailable(this);
				SpellRelease(forceRelease: true);
			}
		}

		protected virtual void CastEffect()
		{
			TryResetCooldown();
			PlaySfx();
			DrainEnergy();
			TryCancelHaptics();
			OnValidSpellCast();
		}

		protected virtual void InstantiateAreaEffect()
		{
			if (m_newTile == null)
			{
				Assets.Scripts.Tiles.Tile highlightedTile = GetHighlightedTile();
				if (highlightedTile == null)
				{
					base.Wielder.CharacterControl.TryTrackTileHit(base.WandHand);
					highlightedTile = GetHighlightedTile();
				}
				if (highlightedTile == null)
				{
					WandsLogger.LogError($"{Type}: couldn't get highlighted tile!");
					return;
				}
				m_newTile = highlightedTile;
				InstantiateAreaEffect();
				return;
			}
			if (!m_allowInfinite && m_previousTileEffects.Count >= m_numberOfCopiesAllowed)
			{
				RemoveOldestActiveEffect();
			}
			m_activePoolObject = ObjectPoolHandler.GrabFromPool(Type) as TileEffectBase;
			m_activePoolObject.EnableObject(m_newTile.transform.position, base.photonView.ViewID, m_newTile.photonView.ViewID);
			SetHoldEffectActive(enable: false);
			m_casting = base.IsDualWielding;
			if (!m_allowInfinite)
			{
				m_previousTileEffects.AddLast(m_activePoolObject);
			}
		}

		public override bool CanCast()
		{
			switch (m_effectBehaviour)
			{
			case AreaOfEffectBehaviour.OneShot:
			case AreaOfEffectBehaviour.Timed:
			{
				int result;
				if (base.IsDualWielding)
				{
					result = (base.CanCast() ? 1 : 0);
				}
				else if (base.CanCast())
				{
					bool? flag = GetHighlightedTile()?.GetEffectActive(Type);
					bool? flag2 = ((!flag.HasValue) ? null : new bool?(!flag.Value));
					result = ((flag2.HasValue && flag2.Value) ? 1 : 0);
				}
				else
				{
					result = 0;
				}
				return (byte)result != 0;
			}
			case AreaOfEffectBehaviour.Mine:
				return base.CharacterControl.GetCurrentTile() != m_newTile && base.CanCast();
			default:
				return false;
			}
		}

		public void RemoveActiveEffect()
		{
			if (m_activePoolObject != null)
			{
				RemoveEffect(m_activePoolObject);
				m_activePoolObject = null;
			}
		}

		private void RemoveEffect(TileEffectBase tileEffect)
		{
			switch (Type)
			{
			case Spell.Spell_StoneDemon:
			case Spell.Spell_Oxymora:
			case Spell.Spell_SkullSpecter:
				(tileEffect as Summoned)?.DisableSummonedAndReturnToPool();
				return;
			case Spell.Spell_CurseOfTheUndead:
			{
				bool? flag = (tileEffect as Curse)?.IsSetToDestroy;
				if (flag.HasValue && flag.Value)
				{
					return;
				}
				break;
			}
			default:
				WandsLogger.LogError(string.Concat("Tile_AreaEffect.RemoveActiveEffect called but ", Type, " has no defined behaviour."));
				return;
			case Spell.Spell_AcidCloud:
			case Spell.Spell_SoilSpikes:
			case Spell.Spell_PetrifyingPrison:
			case Spell.Spell_CerberusCollars:
				break;
			}
			tileEffect.DisableObject();
		}

		protected void RemoveOldestActiveEffect()
		{
			if (!m_allowInfinite && m_previousTileEffects.Count != 0)
			{
				TileEffectBase value = m_previousTileEffects.First.Value;
				m_previousTileEffects.RemoveFirst();
				if (value != null)
				{
					RemoveEffect(value);
				}
			}
		}

		public void RemoveFromQueue(TileEffectBase effect)
		{
			if (!m_allowInfinite)
			{
				m_previousTileEffects.Remove(effect);
			}
		}

		public override void ApplyDamageMultiplier(float value)
		{
			m_dmgInflict = (int)((float)m_dmgInflict * value);
			m_maxDamageInflict = (int)((float)m_maxDamageInflict * value);
		}
	}
}
public class Tile_Teleport : SpellBase_Teleport
{
	private const float LocalTeleportVolume = 0.25f;

	private Tile m_previousTile;

	private Tile m_targetTile;

	private int m_initialCostOfSpell;

	public event Action<Tile, Tile> OnTeleportSuccessful;

	protected override void Start()
	{
		base.Start();
		m_initialCostOfSpell = GetCastCost();
	}

	public override void OnSpellSelect()
	{
		PunSingleton<TileManager>.Instance?.SetTileMaterialColor(Colors.TileColor);
		base.OnSpellSelect();
	}

	public override void SpellPress()
	{
		m_casting = true;
		TryTriggerSpellPressHaptics();
		OnPress();
	}

	protected override void OnPress()
	{
		DrainEnergy();
		m_targetTile = GetHighlightedTile();
		m_previousTile = m_wandControl.Wielder.CharacterControl.GetCurrentTile();
		PunSingleton<TileManager>.Instance.OccupyTile(m_previousTile, TileOccupyState.Unoccupied);
		PunSingleton<TileManager>.Instance.OccupyTile(m_targetTile, TileOccupyState.Occupied, base.Wielder.photonView, OnTileOccupiedChecked);
		m_wandControl.Wielder.CharacterControl.TeleportHandler.TeleportOwner(m_targetTile, OnStart, OnEnd);
	}

	protected override void OnHold()
	{
		if (!(GetHighlightedTile() == null) && CanCast() && !OutOfEnergy(GetCastCost()))
		{
			SpellPress();
			ResetHighlightedTile();
			SpellRelease(forceRelease: true);
		}
	}

	public override void SpellRelease(bool forceRelease = false)
	{
		if (m_casting)
		{
			TryTriggerSpellReleaseHaptics();
			OnValidSpellCast();
			if (forceRelease)
			{
				m_wandControl.DeselectTeleport();
				base.PlayerControl?.HUD?.DeselectSpell(base.WandHand);
			}
		}
	}

	protected override void OnRelease(bool forceRelease = false)
	{
	}

	private void OnTileOccupiedChecked(Tile tile, bool sucessfullyOccupied)
	{
		if (sucessfullyOccupied)
		{
			if (this.OnTeleportSuccessful != null)
			{
				this.OnTeleportSuccessful(m_previousTile, m_targetTile);
			}
		}
		else if (m_wandControl.Wielder.CurrentTile == m_targetTile)
		{
			PunSingleton<TileManager>.Instance?.OccupyTile(m_previousTile, TileOccupyState.Occupied, base.Wielder.photonView);
			m_wandControl.Wielder.CharacterControl.TeleportHandler.TeleportOwner(m_previousTile, OnStart, OnEnd);
			GainEnergy();
		}
	}

	private void SpawnStartEffect(Vector3 startPosition)
	{
		Vector3? vector = (((object)m_previousTile != null) ? new Vector3?(m_previousTile.transform.position) : null);
		Vector3 vector2 = ((!vector.HasValue) ? startPosition : vector.Value) + Vector3.up;
		Vector3? vector3 = (((object)m_targetTile != null) ? new Vector3?(m_targetTile.transform.position) : null);
		Vector3 vector4 = ((!vector3.HasValue) ? startPosition : vector3.Value) + Vector3.up;
		Vector3[] array = new Vector3[3]
		{
			vector2,
			MathUtils.GetMidPoint(vector2, vector4),
			vector4
		};
		ObjectPoolHandler.GrabFromPool(PoolObjectType.Teleport).EnableObject(startPosition, array, base.Wielder.IsBot);
	}

	private void OnStart()
	{
		SpawnStartEffect(base.CharacterControl.GetPlayerPosition());
		if (base.IsPlayerControlled)
		{
			PlaySfx(base.PlayerControl.CameraTransform.position, playUnique: false, m_teleportSoundIndex, play2dLocally: true, 0.25f);
		}
	}

	private void OnEnd()
	{
		Wielder wielder = base.Wielder;
		if (wielder != null && base.CharacterControl != null)
		{
			ObjectPoolHandler.GrabFromPool(PoolObjectType.TeleportArrive).EnableObject(base.CharacterControl.GetPlayerPosition(), wielder.IsBot);
		}
		m_casting = false;
		m_newTile = null;
		EventHub.Publish(new Events.TeleportEndedEvent());
	}

	public override bool CanCast()
	{
		if (base.CharacterControl.IsTeleporting)
		{
			return false;
		}
		if (base.CharacterControl.IsTeleportLocked)
		{
			PlaySfx(base.Wielder.transform.position, playUnique: true, m_teleportBlockedSoundIndex, play2dLocally: true, 0.25f);
			return false;
		}
		if (base.IsDualWielding)
		{
			return base.CanCast() && !IsActive && (m_newTile == null || m_newTile.IsUnoccupied);
		}
		int result;
		if (base.CanCast() && !IsActive)
		{
			bool? flag = GetHighlightedTile()?.IsUnoccupied;
			result = ((flag.HasValue && flag.Value) ? 1 : 0);
		}
		else
		{
			result = 0;
		}
		return (byte)result != 0;
	}

	public override void AbortSpellCasting(bool discret, bool backButtonForce = false)
	{
		m_casting = false;
		m_newTile = null;
		base.AbortSpellCasting(discret, backButtonForce);
	}

	public void SetFreeTeleport(float freeTimeAmount)
	{
		m_castCost = m_initialCostOfSpell;
		StopAllCoroutines();
		StartCoroutine(FreeTeleport(freeTimeAmount));
	}

	private IEnumerator FreeTeleport(float freeTimeAmount)
	{
		m_castCost = 0;
		base.Wielder.CharacterControl.SetFreeTeleportActive(enable: true);
		yield return new CustomWaitForSeconds(freeTimeAmount);
		base.Wielder.CharacterControl.SetFreeTeleportActive(enable: false);
		m_castCost = m_initialCostOfSpell;
	}
}
public class Tile_TeleportRandom : SpellBase_Teleport
{
	private const float LocalTeleportVolume = 0.25f;

	private Tile m_previousTile;

	private Tile m_randomTile;

	private EventToken m_matchResetEventToken;

	protected override void OnEnable()
	{
		base.OnDisable();
		m_matchResetEventToken = EventHub.Subscribe<Events.MatchResetEvent>(OnMatchReset);
	}

	protected override void OnDisable()
	{
		base.OnDisable();
		EventHub.Unsubscribe<Events.MatchResetEvent>(m_matchResetEventToken);
	}

	private void OnMatchReset(Events.MatchResetEvent obj)
	{
		OnReset();
	}

	public void AutoCast(Tile currentTile)
	{
		if (!CanCast() || !CanGetRandomTile(out m_randomTile))
		{
			return;
		}
		m_casting = true;
		m_previousTile = currentTile;
		PunSingleton<TileManager>.Instance.OccupyTile(m_randomTile, TileOccupyState.Occupied, base.Wielder.photonView, delegate(Tile tile, bool success)
		{
			if (base.CharacterControl.IsTeleporting)
			{
				PunSingleton<TileManager>.Instance.OccupyTile(m_randomTile, TileOccupyState.Unoccupied);
				AbortSpellCasting();
			}
			else if (success)
			{
				PunSingleton<TileManager>.Instance.OccupyTile(m_previousTile, TileOccupyState.Unoccupied);
				m_wandControl.Wielder.CharacterControl.TeleportHandler.TeleportOwner(tile, OnStart, OnEnd);
			}
			else
			{
				AbortSpellCasting();
			}
		});
	}

	protected override void OnPress()
	{
		if (!CanGetRandomTile(out m_randomTile))
		{
			AbortSpellCasting();
			return;
		}
		DrainEnergy();
		m_previousTile = m_wandControl.Wielder.CharacterControl.GetCurrentTile();
		PunSingleton<TileManager>.Instance.OccupyTile(m_previousTile, TileOccupyState.Unoccupied);
		PunSingleton<TileManager>.Instance.OccupyTile(m_randomTile, TileOccupyState.Occupied, base.Wielder.photonView, OnTileOccupiedChecked);
		m_wandControl.Wielder.CharacterControl.TeleportHandler.TeleportOwner(m_randomTile, OnStart, OnEnd);
	}

	protected override void OnHold()
	{
	}

	protected override void OnRelease(bool forceRelease = false)
	{
		m_casting = false;
		OnValidSpellCast();
	}

	private void OnReset()
	{
		m_casting = false;
	}

	private void OnTileOccupiedChecked(Tile tile, bool sucessfullyOccupied)
	{
		if (!sucessfullyOccupied)
		{
			if (CanGetRandomTile(out m_randomTile))
			{
				PunSingleton<TileManager>.Instance?.OccupyTile(m_randomTile, TileOccupyState.Occupied, base.Wielder.photonView, OnTileOccupiedChecked);
				m_wandControl.Wielder.CharacterControl.TeleportHandler.TeleportOwner(m_randomTile, OnStart, OnEnd);
			}
			else
			{
				PunSingleton<TileManager>.Instance?.OccupyTile(m_previousTile, TileOccupyState.Occupied, base.Wielder.photonView);
				m_wandControl.Wielder.CharacterControl.TeleportHandler.TeleportOwner(m_previousTile, OnStart, OnEnd);
			}
		}
	}

	private void OnStart()
	{
		IPoolObject poolObject = ObjectPoolHandler.GrabFromPool(PoolObjectType.Teleport, null);
		Vector3? vector = (((object)m_previousTile != null) ? new Vector3?(m_previousTile.transform.position) : null);
		poolObject.EnableObject((!vector.HasValue) ? (base.CharacterControl.GetPlayerPosition() + Vector3.up) : vector.Value, null);
		if (base.IsPlayerControlled)
		{
			PlaySfx(base.PlayerControl.CameraTransform.position, playUnique: false, m_teleportSoundIndex, play2dLocally: true, 0.25f);
		}
	}

	private void OnEnd()
	{
		IPoolObject poolObject = ObjectPoolHandler.GrabFromPool(PoolObjectType.TeleportArrive, null);
		Vector3? vector = (((object)m_randomTile != null) ? new Vector3?(m_randomTile.transform.position) : null);
		poolObject.EnableObject((!vector.HasValue) ? (base.CharacterControl.GetPlayerPosition() + Vector3.up) : vector.Value, null);
		m_randomTile = null;
		m_newTile = null;
		m_casting = false;
	}

	public override bool CanCast()
	{
		if (PunSingleton<TileManager>.Instance.HasFreeTilesAvailable)
		{
			return base.CanCast();
		}
		PlaySfx(base.Wielder.transform.position, playUnique: true, m_teleportBlockedSoundIndex, play2dLocally: true, 0.25f);
		return false;
	}

	private bool CanGetRandomTile(out Tile newTile)
	{
		newTile = PunSingleton<TileManager>.Instance?.GetRandomTile(new HashSet<Tile> { base.Wielder.CurrentTile }, avoidElevatorTiles: false, tryAvoidActivEffects: false);
		return newTile != null;
	}
}
namespace Assets.Scripts.Spells.TileEffects
{
	[RequireComponent(typeof(AudioSource))]
	public class Acid : TileEffectBase, ITileTimedEffect, IEffectEmitter
	{
		[Header("Acid")]
		[SerializeField]
		[Tooltip("Time between particle stop call to object disable.")]
		private float m_stopToDisableTime = 3f;

		[SerializeField]
		[Tooltip("Particles life time left time set on particle stop.")]
		private Light m_pointLight;

		[SerializeField]
		[Tooltip("Point lights target intensity during VFX")]
		private float m_lightIntensity = 9f;

		private float m_dmgDealt;

		private float m_dmg;

		private float m_maxDmg;

		public ParticleSystem[] Emitters { get; set; }

		public AudioSource LoopingAudioSource { get; private set; }

		protected override void OnDisable()
		{
			base.OnDisable();
			StopAllCoroutines();
		}

		public override void Initialize()
		{
			base.ConnectedTile.SetEffectOccupied(value: true, this);
			LoopingAudioSource = m_core.GetComponent<AudioSource>();
			Emitters = m_core.GetComponentsInChildren<ParticleSystem>();
			m_dmg = base.ConnectedSpell.DmgInflict;
			m_maxDmg = base.ConnectedSpell.MaxDamageInflict;
			StartCoroutine(LatentStart(base.ConnectedSpell.EffectActivationDelay));
			StartCoroutine(LatentDestroy(base.TimeFrame));
		}

		public IEnumerator LatentStart(float waitTime)
		{
			Events.TilePredictedUnsafeEvent tilePredictedUnsafeEvent = new Events.TilePredictedUnsafeEvent();
			tilePredictedUnsafeEvent.Tile = base.ConnectedTile;
			EventHub.Publish(tilePredictedUnsafeEvent);
			yield return new CustomWaitForSeconds(waitTime);
			base.IsActive = true;
			FadeLight(m_lightIntensity, 0.5f);
			TileOccupy();
		}

		public IEnumerator LatentDestroy(float time)
		{
			yield return new CustomWaitForSeconds(time);
			base.IsActive = false;
			TileUnoccupy();
			Events.TilePredictedSafeEvent tilePredictedSafeEvent = new Events.TilePredictedSafeEvent();
			tilePredictedSafeEvent.Tile = base.ConnectedTile;
			EventHub.Publish(tilePredictedSafeEvent);
			SetEmitterState(EmitterState.Stop, m_core);
			LoopingAudioSource.DOFade(0f, m_stopToDisableTime);
			FadeLight(0f, m_stopToDisableTime);
			if (PhotonNetwork.IsMasterClient)
			{
				yield return new CustomWaitForSeconds(m_stopToDisableTime);
				DisableObject();
			}
		}

		private void FixedUpdate()
		{
			if (!base.IsPaused && !(base.TargetWielder == null) && base.IsActive)
			{
				if (m_dmg < m_maxDmg)
				{
					m_dmg = Mathf.Min(m_dmg + Time.fixedDeltaTime, m_maxDmg);
				}
				float num = m_dmg * Time.fixedDeltaTime;
				if (base.TargetWielder.TakeDamage(DamageType.Continuous, num, Vector2.up))
				{
					m_dmgDealt += num;
				}
			}
		}

		public override void Pause(bool pause)
		{
			base.Pause(pause);
			SetEmitterState(pause ? EmitterState.Pause : EmitterState.Play, m_core);
			if (pause)
			{
				TileUnoccupy();
			}
			else
			{
				TileOccupy();
			}
		}

		protected override void TileOccupy()
		{
			if (base.IsActive && base.ConnectedTile.Occupant?.Owner != null && base.ConnectedTile.Occupant.Owner.IsLocal)
			{
				if (base.ConnectedTile.OccupantWielder != null)
				{
					base.TargetWielder = base.ConnectedTile.OccupantWielder;
				}
				else if (base.ConnectedTile.OccupantTwin != null)
				{
					base.ConnectedTile.OccupantTwin.OnHit();
				}
				m_soundHandler.PlaySound("acid_cloud_hit");
			}
		}

		protected override void TileUnoccupy()
		{
			base.TargetWielder?.AbortContinuousHit();
			base.TargetWielder = null;
			m_dmg = base.ConnectedSpell.DmgInflict;
			m_maxDmg = m_dmg;
			base.ConnectedSpell.AddTotalDamage((int)m_dmgDealt);
		}

		public void SetEmitterState(EmitterState newState, GameObject effectParent, bool refetchEmitters = false)
		{
			if (effectParent == null)
			{
				return;
			}
			if (refetchEmitters || Emitters.IsNullOrEmpty())
			{
				Emitters = effectParent.GetComponentsInChildren<ParticleSystem>();
			}
			if (Emitters.IsNullOrEmpty())
			{
				effectParent.SetActive(newState != EmitterState.Stop);
				return;
			}
			ParticleSystem[] emitters = Emitters;
			foreach (ParticleSystem particleSystem in emitters)
			{
				switch (newState)
				{
				case EmitterState.Play:
					particleSystem.Play();
					break;
				case EmitterState.Pause:
					particleSystem.Pause();
					break;
				case EmitterState.Stop:
					particleSystem.Stop(withChildren: false, ParticleSystemStopBehavior.StopEmitting);
					break;
				}
			}
		}

		private void FadeLight(float targetIntensity, float fadeTime)
		{
			if (!(m_pointLight == null))
			{
				m_pointLight.DOIntensity(targetIntensity, fadeTime);
			}
		}

		[PunRPC]
		protected override void PunDisableObject()
		{
			if (base.TargetWielder != null)
			{
				base.TargetWielder.AbortContinuousHit();
				base.TargetWielder = null;
			}
			base.PunDisableObject();
		}
	}
	public class CerberusCollars : TileEffectBase, ITileTrap, ITileTimedEffect
	{
		private Animator m_animator;

		private DamageType m_dmgType;

		private float m_dmg;

		private const string EndAudioClipName = "cerberus_end";

		private const string EndTriggerName = "EndTangle";

		private const float TrapWielderWaitTime = 0.1f;

		public bool IsArmed { get; set; }

		public bool HasDeployed { get; set; }

		public AudioSource LoopingAudioSource { get; private set; }

		protected override void OnDisable()
		{
			base.OnDisable();
			StopAllCoroutines();
		}

		public override void Initialize()
		{
			LoopingAudioSource = base.transform.GetChild(0).GetComponent<AudioSource>();
			m_animator = GetComponentInChildren<Animator>();
			base.ConnectedTile.SetEffectOccupied(value: true, this);
			m_dmgType = base.ConnectedSpell.DmgType;
			m_dmg = base.ConnectedSpell.DmgInflict;
			StartCoroutine(ArmTrap(base.ConnectedSpell.EffectActivationDelay));
		}

		protected override void TileOccupy()
		{
			if (IsArmed)
			{
				base.TargetWielder = base.ConnectedTile.OccupantWielder;
				if (!base.IsSetToDestroy)
				{
					StartCoroutine(LatentDestroy(base.ConnectedSpell.TimeFrame));
				}
			}
		}

		protected override void TileUnoccupy()
		{
			if (!(base.TargetWielder == null) && base.TargetWielder.IsLocal && IsArmed && !HasDeployed)
			{
				HasDeployed = true;
				StopAllCoroutines();
				DeployTrap();
			}
		}

		public IEnumerator LatentStart(float waitTime)
		{
			yield break;
		}

		public IEnumerator ArmTrap(float armTime)
		{
			Events.TilePredictedUnsafeEvent tilePredictedUnsafeEvent = new Events.TilePredictedUnsafeEvent();
			tilePredictedUnsafeEvent.Tile = base.ConnectedTile;
			EventHub.Publish(tilePredictedUnsafeEvent);
			yield return new CustomWaitForSeconds(armTime);
			IsArmed = true;
			TileOccupy();
			Events.CollarsActivatedEvent collarsActivatedEvent = new Events.CollarsActivatedEvent();
			collarsActivatedEvent.Tile = base.ConnectedTile;
			EventHub.Publish(collarsActivatedEvent);
		}

		public IEnumerator LatentDestroy(float armTime)
		{
			base.IsSetToDestroy = true;
			yield return new CustomWaitForSeconds(armTime);
			IsArmed = false;
			LoopingAudioSource?.Stop();
			m_animator.SetTrigger("EndTangle");
			m_soundHandler.PlaySound("cerberus_end");
			Events.TilePredictedSafeEvent tilePredictedSafeEvent = new Events.TilePredictedSafeEvent();
			tilePredictedSafeEvent.Tile = base.ConnectedTile;
			EventHub.Publish(tilePredictedSafeEvent);
			Events.CollarsDeactivatedEvent collarsDeactivatedEvent = new Events.CollarsDeactivatedEvent();
			collarsDeactivatedEvent.Tile = base.ConnectedTile;
			EventHub.Publish(collarsDeactivatedEvent);
			yield return new CustomWaitForSeconds(m_soundHandler.Source.clip.length);
			DisableObject();
		}

		[PunRPC]
		protected override void PunDisableObject()
		{
			IsArmed = false;
			HasDeployed = false;
			base.PunDisableObject();
		}

		public void DeployTrap()
		{
			StartCoroutine(TrapWielder());
		}

		private IEnumerator TrapWielder()
		{
			SetTeleportActive(enable: false);
			if (m_soundHandler != null)
			{
				m_soundHandler.PlaySound("cerberus_end");
			}
			SetTeleportActive(enable: true);
			yield return new CustomWaitForSeconds(0.1f);
			while (base.TargetWielder != null && base.TargetWielder.CharacterControl != null && base.TargetWielder.CharacterControl.IsTeleporting)
			{
				yield return null;
			}
			if (base.TargetWielder != null && base.TargetWielder.TakeDamage(m_dmgType, m_dmg, Vector3.up))
			{
				base.ConnectedSpell.AddTotalDamage((int)m_dmg);
			}
			yield return new CustomWaitForSeconds(0.1f);
			DisableObject();
		}
	}
	public class Curse : TileEffectBase, ITileTimedEffect, IEffectEmitter
	{
		[Header("Curse of the Undead")]
		[SerializeField]
		private GameObject m_effectObject;

		[SerializeField]
		private GameObject m_disableOnDeploy;

		public ParticleSystem[] Emitters { get; set; }

		public AudioSource LoopingAudioSource { get; private set; }

		protected override void OnDisable()
		{
			base.OnDisable();
			StopAllCoroutines();
		}

		public override void Pause(bool pause)
		{
			base.IsPaused = pause;
			if (m_effectObject.activeSelf)
			{
				SetEmitterState(pause ? EmitterState.Pause : EmitterState.Play, m_effectObject, refetchEmitters: true);
			}
		}

		public override void Initialize()
		{
			base.IsSetToDestroy = false;
			base.ConnectedTile.SetEffectOccupied(value: true, this);
			LoopingAudioSource = GetComponent<AudioSource>();
			Emitters = m_effectObject.GetComponentsInChildren<ParticleSystem>();
			StartCoroutine(LatentStart(base.ConnectedSpell.EffectActivationDelay));
		}

		protected override void TileOccupy()
		{
			if (!base.IsActive || base.ConnectedTile.Occupant?.Owner == null || base.IsSetToDestroy || !base.ConnectedTile.Occupant.Owner.IsLocal)
			{
				return;
			}
			if (base.ConnectedTile.OccupantWielder != null)
			{
				base.TargetWielder = base.ConnectedTile.OccupantWielder;
				StartCoroutine(CurseWielder());
				return;
			}
			if (base.ConnectedTile.Occupant != null)
			{
				base.IsSetToDestroy = true;
				base.ConnectedTile.OccupantTwin?.OnHit();
				ObjectPoolHandler.GrabFromPool(PoolObjectType.CurseOfTheUndeadExplosion)?.EnableObject(base.ConnectedTile.transform.position);
				DisableObject();
				return;
			}
			throw new UnityException("Curse of the Undead | Tile is counted as occupied without and occupant!");
		}

		protected override void TileUnoccupy()
		{
		}

		public IEnumerator LatentStart(float waitTime)
		{
			m_soundHandler.PlaySound("soil_spikes_incoming");
			yield return new CustomWaitForSeconds(waitTime);
			base.IsActive = true;
			TileOccupy();
		}

		private IEnumerator CurseWielder()
		{
			SetTeleportActive(enable: false);
			yield return new CustomWaitForSeconds(0.1f);
			ObjectPoolHandler.GrabFromPool(PoolObjectType.CurseOfTheUndeadExplosion)?.EnableObject(base.ConnectedTile.transform.position);
			base.TargetWielder.TryCurseWielder(base.ConnectedSpell.TimeFrame);
			SetTeleportActive(enable: true);
			DisableObject();
		}

		[PunRPC]
		private void PunDisableCurse()
		{
			CutConnectedTile();
			SetEmitterState(EmitterState.Stop, m_effectObject, refetchEmitters: true);
			LoopingAudioSource.Stop();
			base.TargetWielder = null;
			if (m_disableOnDeploy != null)
			{
				m_disableOnDeploy.SetActive(value: false);
			}
		}

		public IEnumerator LatentDestroy(float waitTime)
		{
			yield break;
		}

		public void SetEmitterState(EmitterState newState, GameObject effectParent, bool refetchEmitters = false)
		{
			if (effectParent == null)
			{
				return;
			}
			if (refetchEmitters || Emitters.IsNullOrEmpty())
			{
				Emitters = effectParent.GetComponentsInChildren<ParticleSystem>();
			}
			if (Emitters.IsNullOrEmpty())
			{
				effectParent.SetActive(newState != EmitterState.Stop);
				return;
			}
			ParticleSystem[] emitters = Emitters;
			foreach (ParticleSystem particleSystem in emitters)
			{
				switch (newState)
				{
				case EmitterState.Play:
					particleSystem.Play();
					break;
				case EmitterState.Pause:
					particleSystem.Pause();
					break;
				case EmitterState.Stop:
					particleSystem.Stop();
					break;
				}
			}
		}
	}
	public class Oxymora : Summoned
	{
		private Quaternion m_networkRotation;

		private Quaternion m_targetRotation;

		private void Update()
		{
			if (!base.IsPaused)
			{
				Rotate();
			}
		}

		protected override void WriteAdditional(PhotonStream stream)
		{
			if (m_effectObject != null)
			{
				stream.SendNext(m_networkRotation);
			}
		}

		protected override void ReadAdditional(PhotonStream stream)
		{
			if (m_effectObject != null)
			{
				m_networkRotation = (Quaternion)stream.ReceiveNext();
			}
		}

		protected override void ShowHead(bool show)
		{
			if (m_dissolveRenderers.IsNullOrEmpty())
			{
				WandsLogger.Log("No dissolve renderers defined", LogType.Warning);
				return;
			}
			if (!show)
			{
				PunSingleton<SoundManager>.Instance.PlaySoundAtPoint("oxymora_destroy", 1f, base.transform.position, 2);
			}
			float value = ((!show) ? 1f : (-0.5f));
			float endValue = ((!show) ? (-0.5f) : 1f);
			Renderer[] dissolveRenderers = m_dissolveRenderers;
			foreach (Renderer renderer in dissolveRenderers)
			{
				if (!(renderer == null))
				{
					renderer.material.DOKill();
					renderer.material.SetFloat("_DissolvePower", value);
					renderer.material.DOFloat(endValue, "_DissolvePower", m_dissolveTime);
				}
			}
		}

		protected override void SetTemporarilyDisabled(bool disabled, float timeDisabled = 0f)
		{
			base.SetTemporarilyDisabled(disabled, timeDisabled);
			if (disabled)
			{
				m_turret.AllowFire = false;
			}
			else if (base.gameObject.activeSelf)
			{
				StartCoroutine(SetEffectActive(base.ConnectedSpell, enable: true));
			}
		}

		public override void Initialize()
		{
			m_targetRotation = m_effectObject.transform.localRotation;
			base.Initialize();
			Spell_Oxymora spell_Oxymora = base.ConnectedSpell as Spell_Oxymora;
			TurretOxymora turretOxymora = m_turret as TurretOxymora;
			if (spell_Oxymora == null || turretOxymora == null)
			{
				WandsLogger.LogError("Oxymora | connected spell or turret not castable as Oxymora specific");
				return;
			}
			turretOxymora.ProjectileHeal = spell_Oxymora.ProjectileHeal;
			m_soundHandler.PlaySound("oxymora_cast");
			StartCoroutine(SetEffectActive(base.ConnectedSpell, enable: true));
		}

		protected override void Rotate()
		{
			if (m_turret == null || !base.IsRotationActive)
			{
				return;
			}
			if (NetworkUtils.ConnectedToGame && !base.photonView.Owner.IsLocal)
			{
				m_turret.RotationPivot.rotation = Quaternion.Lerp(m_turret.RotationPivot.rotation, m_networkTurretRotation, Time.deltaTime * 6f);
				if (m_effectObject != null)
				{
					m_effectObject.transform.localRotation = Quaternion.Lerp(m_effectObject.transform.rotation, m_networkRotation, Time.deltaTime * 12f);
				}
				return;
			}
			m_turret.RotationPivot.Rotate(Vector3.up, Time.deltaTime * m_rotationSpeed, Space.Self);
			if (Quaternion.Dot(m_effectObject.transform.localRotation, m_targetRotation) < 0.95f)
			{
				m_effectObject.transform.localRotation = Quaternion.Lerp(m_effectObject.transform.localRotation, m_targetRotation, Time.deltaTime * m_rotationSpeed);
			}
			m_networkTurretRotation = m_turret.RotationPivot.rotation;
			if (m_effectObject != null)
			{
				m_networkRotation = m_effectObject.transform.localRotation;
			}
		}
	}
	public class Prison : TileEffectBase, ITileTimedEffect
	{
		private PrisonDissolver m_prison;

		private Summoned m_targetSummoned;

		public AudioSource LoopingAudioSource { get; }

		protected override void OnDisable()
		{
			StopAllCoroutines();
			base.OnDisable();
		}

		public override void Initialize()
		{
			m_prison = GetComponentInChildren<PrisonDissolver>();
			base.ConnectedTile.SetEffectOccupied(value: true, this);
			StartCoroutine(LatentStart(base.ConnectedSpell.EffectActivationDelay));
			StartCoroutine(LatentDestroy(base.TimeFrame));
			if (base.ConnectedTile.IsOccupied)
			{
				TileOccupy();
			}
		}

		public IEnumerator LatentStart(float waitTime)
		{
			m_soundHandler.PlaySound("prison_place");
			yield return new CustomWaitForSeconds(waitTime);
			m_prison.EnablePrisonBars();
		}

		public IEnumerator LatentDestroy(float time)
		{
			yield return new CustomWaitForSeconds(time);
			TileUnoccupy();
			m_soundHandler.PlaySound("prison_remove");
			m_prison.DisablePrisonBars();
			yield return new WaitForSeconds(m_prison.DissolveTime);
			DisableObject();
		}

		protected override void CutConnectedTile()
		{
			Tile connectedTile = base.ConnectedTile;
			base.CutConnectedTile();
			if (connectedTile != null && !connectedTile.GetEffectActive(Spell.Spell_PetrifyingPrison))
			{
				TileUnoccupy();
			}
		}

		protected override void TileOccupy()
		{
			if (base.ConnectedTile.OccupantWielder != null)
			{
				base.TargetWielder = base.ConnectedTile.OccupantWielder;
				SetTeleportActive(enable: false);
			}
			else if (base.ConnectedTile.IsTileOccupiedBySummoned())
			{
				m_targetSummoned = base.ConnectedTile.ActiveEffectHandlers.Find((TileEffectBase aoe) => aoe is Summoned) as Summoned;
				if (m_targetSummoned != null)
				{
					m_targetSummoned.SetRotationActive(active: false);
				}
			}
		}

		protected override void TileUnoccupy()
		{
			SetTeleportActive(enable: true);
			if (m_targetSummoned != null)
			{
				m_targetSummoned.SetRotationActive(active: true);
				m_targetSummoned = null;
			}
		}

		protected override void SetTeleportActive(bool enable)
		{
			if (!PunSingleton<SceneControl>.Instance.CountdownHandler.IsCountdownActive && !(base.TargetWielder == null) && !(base.TargetWielder.CharacterControl == null))
			{
				base.TargetWielder.CharacterControl.SetTeleportActive(enable);
			}
		}
	}
	public class RotatingPoolObject : PoolObject
	{
		[PunRPC]
		public override void PunEnableObject(Vector3 position, params object[] data)
		{
			base.gameObject.SetActive(value: true);
			if (m_core != null)
			{
				m_core.SetActive(value: true);
			}
			base.gameObject.transform.position = position;
			if (data.IsNullOrEmpty())
			{
				WandsLogger.Log("You are either sending no rotation data or sending the wrong data. Use PoolObject if no rotation data is needed", LogType.Warning);
				return;
			}
			base.gameObject.transform.rotation = (Quaternion)data[0];
			if (base.photonView.IsMine && m_lifeTime > 0f)
			{
				StartCoroutine(DisableAfterTime());
			}
		}
	}
	public class SkullSpecter : Summoned
	{
		private const float RotationTime = 0.35f;

		private const float DisableWaitTime = 0.5f;

		protected override void ShowHead(bool show)
		{
			if (show)
			{
				StopCoroutine("TurnAndFire");
				StartCoroutine("TurnAndFire");
			}
			else
			{
				StopCoroutine("TurnAndFire");
				m_effectObject.SetActive(value: false);
			}
		}

		protected override void Awake()
		{
		}

		private IEnumerator TurnAndFire()
		{
			TurretSkullSpecter turret = m_turret as TurretSkullSpecter;
			yield return new CustomWaitForSeconds(base.ConnectedSpell.EffectActivationDelay);
			m_effectObject.SetActive(value: true);
			if (base.photonView.IsMine)
			{
				if (!turret.TryGetTargetPoint(out var targetPoint))
				{
					(base.ConnectedSpell as SpellBase_Summon).RevertSpellCast();
					yield break;
				}
				RotateTowardsOpponent(Quaternion.LookRotation(targetPoint - base.transform.position));
				yield return new CustomWaitForSeconds(0.35f);
				turret.Fire(targetPoint);
				yield return new CustomWaitForSeconds(0.5f);
				DisableObject();
			}
		}

		public void RotateTowardsOpponent(Quaternion rotation)
		{
			base.photonView.RPC("PunRotateTowardsOpponent", RpcTarget.All, rotation);
		}

		[PunRPC]
		private void PunRotateTowardsOpponent(Quaternion rotation)
		{
			base.transform.DOLocalRotateQuaternion(rotation, 0.35f);
		}

		[PunRPC]
		protected override void PunDisableObject()
		{
			base.PunDisableObject();
			m_effectObject.SetActive(value: false);
		}
	}
	public class Spell_CerberusCollars : Tile_AreaEffect
	{
		private static IReadOnlyDictionary<string, string> sm_spellDescriptionParams;

		public override IReadOnlyDictionary<string, string> GetSpellDescriptionParams()
		{
			if (sm_spellDescriptionParams.IsNullOrEmpty())
			{
				Dictionary<string, string> dictionary = new Dictionary<string, string>(1);
				dictionary.Add("CERBERUS_COLLARS_DURATION", m_timeFrame.ToString());
				sm_spellDescriptionParams = dictionary;
			}
			return sm_spellDescriptionParams;
		}

		protected override void CastEffect()
		{
			base.CastEffect();
			InstantiateAreaEffect();
		}

		protected override void InstantiateAreaEffect()
		{
			base.InstantiateAreaEffect();
			ObjectPoolHandler.GrabFromPool(PoolObjectType.CerberusCollarsInit, null).EnableObject(m_wandControl.CachedTipPoint, Quaternion.LookRotation(m_wandControl.Aim.AimRay.direction));
		}
	}
	public class Spell_CurseOfTheUndead : Tile_AreaEffect
	{
		protected override void CastEffect()
		{
			base.CastEffect();
			InstantiateAreaEffect();
		}
	}
	public class Spell_Oxymora : SpellBase_Summon
	{
		private static IReadOnlyDictionary<string, string> sm_spellDescriptionParams;

		[Header("Oxymora")]
		[SerializeField]
		private int m_projectileHeal = 2;

		public int ProjectileHeal
		{
			[CompilerGenerated]
			get
			{
				return m_projectileHeal;
			}
		}

		public override IReadOnlyDictionary<string, string> GetSpellDescriptionParams()
		{
			if (sm_spellDescriptionParams.IsNullOrEmpty())
			{
				Dictionary<string, string> dictionary = new Dictionary<string, string>(1);
				dictionary.Add("OXYMORA_HEAL", m_projectileHeal.ToString());
				sm_spellDescriptionParams = dictionary;
			}
			return sm_spellDescriptionParams;
		}
	}
	public class Spell_SkullSpecter : SpellBase_Summon
	{
		protected override void InstantiateAreaEffect()
		{
			base.InstantiateAreaEffect();
			object[] data = new object[1] { Quaternion.LookRotation(m_wandControl.Aim.AimRay.direction) };
			ObjectPoolHandler.GrabFromPool(PoolObjectType.SkullSpecterInit).EnableObject(m_wandControl.CachedTipPoint, data);
		}
	}
	public class Spikes : TileEffectBase, ITileTrap
	{
		[SerializeField]
		private ParticleSystem m_explosionParticles;

		private SpikeActivator[] m_spikes;

		private DamageType m_dmgType;

		private float m_dmg;

		public bool IsArmed { get; set; }

		public bool HasDeployed { get; set; }

		protected override void OnDisable()
		{
			base.OnDisable();
			StopAllCoroutines();
		}

		public override void Initialize()
		{
			base.ConnectedTile.SetEffectOccupied(value: true, this);
			m_spikes = GetComponentsInChildren<SpikeActivator>();
			m_dmgType = base.ConnectedSpell.DmgType;
			m_dmg = base.ConnectedSpell.DmgInflict;
			PunSetSpikesActive(enable: false);
			StartCoroutine(ArmTrap(base.ConnectedSpell.EffectActivationDelay));
		}

		protected override void TileOccupy()
		{
			DeployTrap();
		}

		protected override void TileUnoccupy()
		{
			SetTeleportActive(enable: true);
		}

		public IEnumerator ArmTrap(float armTime)
		{
			Events.TilePredictedUnsafeEvent tilePredictedUnsafeEvent = new Events.TilePredictedUnsafeEvent();
			tilePredictedUnsafeEvent.Tile = base.ConnectedTile;
			EventHub.Publish(tilePredictedUnsafeEvent);
			m_soundHandler.PlaySound("soil_spikes_incoming");
			yield return new CustomWaitForSeconds(armTime);
			IsArmed = true;
			DeployTrap();
		}

		public void DeployTrap()
		{
			if (!IsArmed || base.ConnectedTile.Occupant?.Owner == null || HasDeployed || !base.ConnectedTile.Occupant.Owner.IsLocal)
			{
				return;
			}
			Events.TilePredictedSafeEvent tilePredictedSafeEvent = new Events.TilePredictedSafeEvent();
			tilePredictedSafeEvent.Tile = base.ConnectedTile;
			EventHub.Publish(tilePredictedSafeEvent);
			if (base.ConnectedTile.OccupantWielder != null)
			{
				base.TargetWielder = base.ConnectedTile.OccupantWielder;
				StartCoroutine(TrapWielder());
				return;
			}
			if (base.ConnectedTile.Occupant != null)
			{
				StartCoroutine(TrapObject());
				return;
			}
			throw new UnityException("Soil Spikes | Tile is counted as occupied without and occupant!");
		}

		private IEnumerator TrapWielder()
		{
			SetTeleportActive(enable: false);
			yield return new CustomWaitForSeconds(0.1f);
			while (base.TargetWielder.CharacterControl.IsTeleporting)
			{
				yield return null;
			}
			SetSpikesActive(enable: true);
			DealDamageToWielder();
			if (m_soundHandler.Source != null)
			{
				yield return new CustomWaitForSeconds(m_soundHandler.Source.clip.length);
			}
			yield return LowerSpikes();
		}

		private IEnumerator TrapObject()
		{
			SetSpikesActive(enable: true);
			DealDamageToObject(base.ConnectedTile.Occupant);
			if (m_soundHandler.Source != null)
			{
				yield return new CustomWaitForSeconds(m_soundHandler.Source.clip.length);
			}
			yield return LowerSpikes();
		}

		private void SetSpikesActive(bool enable)
		{
			base.photonView.RPC("PunSetSpikesActive", RpcTarget.All, enable);
		}

		[PunRPC]
		private void PunSetSpikesActive(bool enable)
		{
			if (m_spikes.IsNullOrEmpty())
			{
				WandsLogger.Log("No Spikes set on SoilSpikes", LogType.Error);
				return;
			}
			HasDeployed = enable;
			base.IsSetToDestroy = enable;
			if (enable)
			{
				if (m_explosionParticles != null)
				{
					m_explosionParticles.Play(withChildren: true);
				}
				m_soundHandler.PlaySound("soil_spikes_up");
			}
			SpikeActivator[] spikes = m_spikes;
			foreach (SpikeActivator spikeActivator in spikes)
			{
				spikeActivator.ActivateSpike(enable);
			}
		}

		[PunRPC]
		protected override void PunDisableObject()
		{
			IsArmed = false;
			base.PunDisableObject();
		}

		private void DealDamageToWielder()
		{
			if (base.TargetWielder.TakeDamage(m_dmgType, m_dmg, Vector2.up))
			{
				base.ConnectedSpell.AddTotalDamage((int)m_dmg);
			}
		}

		private void DealDamageToObject(PhotonView occupant)
		{
			if (NetworkUtils.ConnectedToGame)
			{
				bool? flag = occupant?.Owner.IsLocal;
				bool? flag2 = ((!flag.HasValue) ? null : new bool?(!flag.Value));
				if (!flag2.HasValue || flag2.Value)
				{
					return;
				}
			}
			if (base.ConnectedTile.OccupantTwin != null)
			{
				base.ConnectedTile.OccupantTwin.OnHit(m_dmg);
			}
			else if (occupant.CompareTag("Destructable"))
			{
				Summoned component = occupant.GetComponent<Summoned>();
				if (component != null)
				{
					component.Turret.OnHit(m_dmg);
				}
				else
				{
					occupant.SendMessage("OnHit", m_dmg, SendMessageOptions.DontRequireReceiver);
				}
			}
		}

		private IEnumerator LowerSpikes()
		{
			SetSpikesActive(enable: false);
			PunSingleton<SoundManager>.Instance.PlaySoundAtPoint("soil_spikes_down", 1f, base.transform.position, 2);
			SetTeleportActive(enable: true);
			yield return new CustomWaitForSeconds(0.1f);
			DisableObject();
		}
	}
	public class StoneDemon : Summoned
	{
		[Header("Stone Demon")]
		[SerializeField]
		private Collider m_collider;

		private Vector3 m_localStartPos;

		private float m_animSpeed = 0.85f;

		private TurretDemon m_turretDemon;

		private EventToken m_tilesUpdatedEventToken;

		public Collider Collider => m_collider;

		protected override void Awake()
		{
			base.Awake();
			m_turretDemon = m_turret as TurretDemon;
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			PunSingleton<TileManager>.Instance.OnTileOccupied += OnTileOccupied;
		}

		protected override void OnDisable()
		{
			base.OnDisable();
			if (PunSingleton<TileManager>.Instance != null)
			{
				PunSingleton<TileManager>.Instance.OnTileOccupied -= OnTileOccupied;
			}
		}

		protected void Update()
		{
			if (!base.IsPaused && !m_isDestroying)
			{
				Animate();
				Rotate();
			}
		}

		private void OnTileOccupied(Tile tile)
		{
			m_turretDemon.UpdateTarget();
		}

		public override void Initialize()
		{
			m_soundHandler.PlaySound("stone_demon_place");
			if (!(m_rigidBody == null))
			{
				bool? flag = base.ConnectedTile?.IsElevatorTile;
				if (!flag.HasValue || !flag.Value)
				{
					m_localStartPos = m_turret.transform.position;
					goto IL_0093;
				}
			}
			m_localStartPos = m_turret.transform.localPosition;
			goto IL_0093;
			IL_0093:
			base.Initialize();
			if (base.ConnectedSpell is SpellBase_Summon)
			{
				m_turret.m_spellDmg = (base.ConnectedSpell as SpellBase_Summon).ProjectileDamage;
				m_turretDemon.SetSpellVariables();
				StartCoroutine(SetEffectActive(base.ConnectedSpell, enable: true));
			}
			else
			{
				WandsLogger.Log("Connected spell is not of type Summoned even though the effect is.", LogType.Error);
			}
		}

		protected override void ShowHead(bool show)
		{
			if (m_dissolveRenderers.IsNullOrEmpty())
			{
				WandsLogger.Log("No dissolve renderers defined", LogType.Warning);
				return;
			}
			if (!show)
			{
				PunSingleton<SoundManager>.Instance.PlaySoundAtPoint("stone_demon_remove", 1f, base.transform.position, 2);
			}
			float value = ((!show) ? 1f : (-0.5f));
			float endValue = ((!show) ? (-0.5f) : 1f);
			if (show)
			{
				m_dissolveRenderers[0].material.DOKill();
				m_dissolveRenderers[0].material.SetFloat("_DissolvePower", value);
				m_dissolveRenderers[0].material.DOFloat(endValue, "_DissolvePower", m_dissolveTime);
				return;
			}
			Renderer[] dissolveRenderers = m_dissolveRenderers;
			foreach (Renderer renderer in dissolveRenderers)
			{
				if (!(renderer == null))
				{
					renderer.material.DOKill();
					renderer.material.SetFloat("_DissolvePower", value);
					renderer.material.DOFloat(endValue, "_DissolvePower", m_dissolveTime);
				}
			}
		}

		protected override void Rotate()
		{
			if (!NetworkUtils.ConnectedToGame || base.photonView.Owner.IsLocal)
			{
				if (base.IsTemporarilyDisabled)
				{
					m_turret.transform.Rotate(Vector3.up, Time.deltaTime * m_rotationSpeed, Space.Self);
				}
				else if (base.IsRotationActive)
				{
					RotateTowardTarget();
				}
				m_networkTurretRotation = m_turret.transform.rotation;
			}
			else if (m_turret != null)
			{
				m_turret.transform.rotation = Quaternion.Lerp(m_turret.transform.rotation, m_networkTurretRotation, Time.deltaTime * 12f);
			}
		}

		private void RotateTowardTarget()
		{
			CapsuleCollider targetCollider = (m_turret as TurretDemon).TargetCollider;
			if (!(targetCollider == null))
			{
				Vector3 forward = targetCollider.transform.position - base.transform.position;
				forward.y = 0f;
				if (m_rigidBody != null && !base.ConnectedTile.IsElevatorTile)
				{
					m_rigidBody.rotation = Quaternion.RotateTowards(m_rigidBody.rotation, Quaternion.LookRotation(forward, Vector3.up), Time.deltaTime * m_rotationSpeed);
				}
				else if (m_turret != null)
				{
					m_turret.transform.rotation = Quaternion.RotateTowards(m_turret.transform.rotation, Quaternion.LookRotation(forward, base.ConnectedTile.transform.up), Time.deltaTime * m_rotationSpeed);
				}
			}
		}

		private void Animate()
		{
			if (!(base.gameObject == null) && !(this == null))
			{
				float y = Mathf.Sin(Time.time * m_animSpeed) * 0.05f;
				if (m_rigidBody != null && base.ConnectedTile != null && !base.ConnectedTile.IsElevatorTile)
				{
					m_rigidBody.MovePosition(m_localStartPos + new Vector3(0f, y, 0f));
				}
				else
				{
					m_turret.transform.localPosition = m_localStartPos + new Vector3(0f, y, 0f);
				}
			}
		}
	}
	public abstract class Summoned : TileEffectBase, IPunObservable
	{
		[Header("Summoned")]
		[SerializeField]
		protected GameObject m_effectObject;

		[SerializeField]
		protected TurretBase m_turret;

		[SerializeField]
		protected CharacterStatsUI m_statsUI;

		[SerializeField]
		protected float m_rotationSpeed = 6f;

		[SerializeField]
		protected float m_dissolveTime = 0.5f;

		[SerializeField]
		protected Renderer[] m_dissolveRenderers = Array.Empty<Renderer>();

		protected bool m_isDestroying;

		protected Rigidbody m_rigidBody;

		protected Quaternion m_networkTurretRotation;

		private float m_startDurability;

		private float m_damageToTakeWhenInitialized;

		private Coroutine m_disabledResetCoroutine;

		private StatsData m_healthData;

		public bool IsInitialized { get; private set; }

		public bool IsTemporarilyDisabled { get; protected set; }

		public float Durability
		{
			[CompilerGenerated]
			get
			{
				return m_healthData.Current;
			}
		}

		public TurretBase Turret
		{
			[CompilerGenerated]
			get
			{
				return m_turret;
			}
		}

		protected bool IsRotationActive { get; private set; } = true;


		protected override void OnEnable()
		{
			base.OnEnable();
			Events.DestructableSpawnedEvent destructableSpawnedEvent = new Events.DestructableSpawnedEvent();
			destructableSpawnedEvent.Destructable = Turret;
			EventHub.Publish(destructableSpawnedEvent);
		}

		protected override void OnDisable()
		{
			base.OnDisable();
			StopAllCoroutines();
		}

		protected virtual void Awake()
		{
		}

		public override void OnPhotonInstantiate(PhotonMessageInfo info)
		{
			base.OnPhotonInstantiate(info);
			m_rigidBody = ((!(m_turret != null)) ? GetComponentInChildren<Rigidbody>() : m_turret.GetComponent<Rigidbody>());
		}

		public void OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info)
		{
			if (!IsInitialized)
			{
				return;
			}
			if (stream.IsWriting)
			{
				stream.SendNext(m_networkTurretRotation);
				stream.SendNext(m_healthData.Current);
				if (m_dissolveRenderers != null && m_dissolveRenderers.Length > 1)
				{
					stream.SendNext(m_dissolveRenderers[1].material.GetFloat("_DissolvePower"));
				}
				WriteAdditional(stream);
			}
			else
			{
				m_networkTurretRotation = (Quaternion)stream.ReceiveNext();
				m_healthData.SetCurrent((float)stream.ReceiveNext());
				if (m_dissolveRenderers != null && m_dissolveRenderers.Length > 1)
				{
					m_dissolveRenderers[1].material.SetFloat("_DissolvePower", (float)stream.ReceiveNext());
				}
				ReadAdditional(stream);
			}
		}

		protected virtual void WriteAdditional(PhotonStream stream)
		{
		}

		protected virtual void ReadAdditional(PhotonStream stream)
		{
		}

		public override void Initialize()
		{
			SpellBase_Summon spellBase_Summon = base.ConnectedSpell as SpellBase_Summon;
			m_isDestroying = false;
			m_turret.m_spellDmg = spellBase_Summon.ProjectileDamage;
			m_healthData = StatsData.CreateInstance(spellBase_Summon.Durability);
			if (m_statsUI != null)
			{
				m_statsUI.Initialize(m_healthData, PlayerManager.Instance.PlayerControl.CameraTransform);
				m_statsUI.gameObject.SetActive(value: true);
			}
			base.ConnectedTile.SetEffectOccupied(value: true, this);
			ShowHead(show: true);
			IsInitialized = true;
			if (base.photonView.IsMine && m_damageToTakeWhenInitialized > 0f)
			{
				OnHit(m_damageToTakeWhenInitialized);
				m_damageToTakeWhenInitialized = 0f;
			}
		}

		protected override void TileOccupy()
		{
		}

		protected override void TileUnoccupy()
		{
		}

		protected virtual void Rotate()
		{
		}

		protected abstract void ShowHead(bool show);

		protected IEnumerator SetEffectActive(Tile_AreaEffect creator, bool enable)
		{
			yield return new CustomWaitForSeconds(creator.EffectActivationDelay);
			if (m_effectObject != null)
			{
				m_effectObject.SetActive(enable);
			}
			if (m_turret != null)
			{
				m_turret.AllowFire = true;
			}
		}

		public void DisableSummonedAndReturnToPool()
		{
			if ((object)m_healthData != null)
			{
				m_healthData.SetCurrent(0f);
			}
			CheckDestroyCondition();
		}

		public void OnHit(float damage)
		{
			if (!m_isDestroying)
			{
				if (!IsInitialized || !base.gameObject.activeSelf)
				{
					m_damageToTakeWhenInitialized += damage;
					return;
				}
				base.photonView.RPC("PunSummonedHit", base.photonView.Owner, damage);
			}
		}

		[PunRPC]
		protected void PunSummonedHit(float damage)
		{
			if (!m_isDestroying)
			{
				if ((object)m_healthData != null)
				{
					m_healthData.SetCurrent(m_healthData.Current - damage);
				}
				CheckDestroyCondition();
			}
		}

		private void CheckDestroyCondition()
		{
			if (!m_isDestroying && (!(m_healthData != null) || !(m_healthData.Current > 0f)))
			{
				m_isDestroying = true;
				if ((object)m_statsUI != null)
				{
					m_statsUI.gameObject.SetActive(value: false);
				}
				StopAllCoroutines();
				base.photonView.RPC("PunDisableSummoned", RpcTarget.AllViaServer);
			}
		}

		[PunRPC]
		protected void PunDisableSummoned()
		{
			m_turret.StopAllCoroutines();
			m_turret.AllowFire = false;
			ShowHead(show: false);
			if (base.gameObject != null && base.gameObject.activeSelf)
			{
				StartCoroutine(DestroyAfterTime(m_dissolveTime));
				return;
			}
			if (m_core != null)
			{
				m_core.SetActive(value: false);
			}
			if (base.photonView.IsMine)
			{
				DisableObject();
			}
		}

		protected IEnumerator DestroyAfterTime(float waitTime)
		{
			yield return new CustomWaitForSeconds(waitTime);
			if (m_core != null)
			{
				m_core.SetActive(value: false);
			}
			yield return new CustomWaitForSeconds(waitTime);
			if (base.photonView.IsMine)
			{
				DisableObject();
			}
		}

		public override void DisableObject()
		{
			if (base.ConnectedTile != null && base.ConnectedTile.Occupant == base.photonView)
			{
				PunSingleton<TileManager>.Instance?.OccupyTile(base.ConnectedTile, TileOccupyState.Unoccupied);
			}
			base.DisableObject();
		}

		[PunRPC]
		protected override void PunDisableObject()
		{
			m_isDestroying = false;
			m_turret.AllowFire = false;
			base.PunDisableObject();
			SetTemporarilyDisabled(disabled: false);
		}

		public virtual void SetRotationActive(bool active)
		{
			IsRotationActive = active;
		}

		protected virtual void SetTemporarilyDisabled(bool disabled, float timeDisabled = 0f)
		{
			IsTemporarilyDisabled = disabled;
			if (m_disabledResetCoroutine != null)
			{
				StopCoroutine(m_disabledResetCoroutine);
				m_disabledResetCoroutine = null;
			}
			if (timeDisabled > 0f)
			{
				m_disabledResetCoroutine = StartCoroutine(SetTemporarilyDisabledAfterDelay(!disabled, timeDisabled));
			}
		}

		private IEnumerator SetTemporarilyDisabledAfterDelay(bool disabled, float timeUntilSet)
		{
			yield return new CustomWaitForSeconds(timeUntilSet);
			SetTemporarilyDisabled(disabled);
		}

		public void SetDissolveRenderer(int index, float value)
		{
			if (m_dissolveRenderers != null && m_dissolveRenderers.Length > index)
			{
				m_dissolveRenderers[index].material.SetFloat("_DissolvePower", value);
			}
		}
	}
	[RequireComponent(typeof(PhotonView), typeof(SoundHandler))]
	public abstract class TileEffectBase : MonoBehaviourPun, IPunInstantiateMagicCallback, IPauseObject, IPoolObject
	{
		[SerializeField]
		protected Spell m_spellType;

		[SerializeField]
		protected GameObject m_core;

		[SerializeField]
		protected SoundHandler m_soundHandler;

		private EventToken m_matchPausedEventToken;

		private EventToken m_matchResetEventToken;

		private EventToken m_matchEndedEventToken;

		public SoundHandler SoundHandler
		{
			[CompilerGenerated]
			get
			{
				return m_soundHandler;
			}
		}

		public Tile_AreaEffect ConnectedSpell { get; private set; }

		public bool IsSetToDestroy { get; protected set; }

		public bool IsPaused { get; set; }

		protected Tile ConnectedTile { get; private set; }

		protected Wielder TargetWielder { get; set; }

		protected bool IsActive { get; set; }

		protected float TimeFrame { get; set; }

		public abstract void Initialize();

		protected abstract void TileOccupy();

		protected abstract void TileUnoccupy();

		protected virtual void OnEnable()
		{
			m_matchPausedEventToken = EventHub.Subscribe<Events.MatchPausedEvent>(OnMatchPaused);
			m_matchEndedEventToken = EventHub.Subscribe<Events.MatchEndedEvent>(OnMatchEnded);
			m_matchResetEventToken = EventHub.Subscribe<Events.MatchResetEvent>(OnMatchReset);
		}

		protected virtual void OnDisable()
		{
			EventHub.Unsubscribe<Events.MatchPausedEvent>(m_matchPausedEventToken);
			EventHub.Unsubscribe<Events.MatchEndedEvent>(m_matchEndedEventToken);
			EventHub.Unsubscribe<Events.MatchResetEvent>(m_matchResetEventToken);
		}

		public virtual void OnPhotonInstantiate(PhotonMessageInfo info)
		{
			PunDisableObject();
			base.transform.SetParent(ObjectPoolHandler.PoolParent);
		}

		public virtual void Pause(bool pause)
		{
			IsPaused = pause;
		}

		private void OnMatchPaused(Events.MatchPausedEvent eventData)
		{
			Pause(eventData.IsPaused);
		}

		protected virtual void CutConnectedTile()
		{
			IsSetToDestroy = true;
			if (!(ConnectedTile == null))
			{
				ConnectedTile.SetEffectOccupied(value: false, this);
				ConnectedTile.OnTileOccupied -= OnTileOccupied;
				ConnectedTile = null;
			}
		}

		private void OnMatchReset(Events.MatchResetEvent eventData)
		{
			DisableObject();
		}

		private void OnMatchEnded(Events.MatchEndedEvent eventData)
		{
			DisableObject();
		}

		public void EnableObject(Vector3 position, params object[] data)
		{
			base.photonView.RPC("PunEnableObject", RpcTarget.All, position, PhotonNetwork.Time, data);
		}

		[PunRPC]
		public void PunEnableObject(Vector3 position, double sentTime, params object[] data)
		{
			base.transform.position = position;
			base.gameObject.SetActive(value: true);
			if (m_core != null)
			{
				m_core.SetActive(value: true);
			}
			if (data.IsNullOrEmpty())
			{
				WandsLogger.LogFormat(LogType.Warning, "No instantiation data for spell {0} | Ignore this if just loaded scene.", base.gameObject.name);
				return;
			}
			ConnectedSpell = PhotonView.Find((int)data[0]).GetComponent<Tile_AreaEffect>();
			ConnectedTile = PhotonView.Find((int)data[1]).GetComponent<Tile>();
			ConnectedTile.OnTileOccupied += OnTileOccupied;
			if (ConnectedTile.IsElevatorTile)
			{
				base.transform.SetParent(ConnectedTile.transform);
				base.transform.localPosition = Vector3.zero;
			}
			TimeFrame = ((data.Length <= 2) ? ConnectedSpell.TimeFrame : ((float)data[2])) - (float)(PhotonNetwork.Time - sentTime);
			Initialize();
		}

		private void OnTileOccupied(bool occupy)
		{
			if (occupy)
			{
				TileOccupy();
			}
			else
			{
				TileUnoccupy();
			}
		}

		public virtual void DisableObject()
		{
			base.photonView.RPC("PunDisableObject", RpcTarget.AllViaServer);
			if (ConnectedSpell != null)
			{
				ConnectedSpell.RemoveFromQueue(this);
			}
		}

		[PunRPC]
		protected virtual void PunDisableObject()
		{
			if (ConnectedSpell != null && ConnectedSpell.photonView != null && ConnectedSpell.photonView.IsMine)
			{
				ObjectPoolHandler.TryReturnToPool(m_spellType, this);
			}
			SetTeleportActive(enable: true);
			if (ConnectedTile != null && ConnectedTile.IsElevatorTile)
			{
				base.transform.SetParent(ObjectPoolHandler.PoolParent);
			}
			CutConnectedTile();
			IsSetToDestroy = false;
			if (base.gameObject != null)
			{
				base.gameObject.SetActive(value: false);
			}
			if (m_core != null)
			{
				m_core.SetActive(value: false);
			}
		}

		protected virtual void SetTeleportActive(bool enable)
		{
		}

		PhotonView IPoolObject.get_photonView()
		{
			return base.photonView;
		}
	}
}
namespace Assets.Scripts.Spells.Turret
{
	public class TurretBase : SpellBase_Projectile, IDestructableObject, IPauseObject
	{
		[Header("Turret")]
		[SerializeField]
		protected LayerMask m_sightMask = -1;

		[SerializeField]
		private Transform m_rotationPivot;

		[SerializeField]
		private Transform[] m_firePositionTfs = Array.Empty<Transform>();

		[SerializeField]
		protected Summoned m_summoned;

		private static LayerMask? sm_hitMask;

		private EventToken m_matchPausedEventToken;

		public bool AllowFire { get; set; }

		public bool IsPaused { get; set; }

		public Transform RotationPivot
		{
			[CompilerGenerated]
			get
			{
				return m_rotationPivot;
			}
		}

		public float Durability
		{
			[CompilerGenerated]
			get
			{
				return m_summoned.Durability;
			}
		}

		public override LayerMask HitMask
		{
			[CompilerGenerated]
			get
			{
				return GetHitMask();
			}
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			m_matchPausedEventToken = EventHub.Subscribe<Events.MatchPausedEvent>(OnMatchPaused);
			ResetTurret();
		}

		protected override void OnDisable()
		{
			base.OnDisable();
			EventHub.Unsubscribe<Events.MatchPausedEvent>(m_matchPausedEventToken);
		}

		protected override void Start()
		{
			if (m_collisionRadius <= 0f)
			{
				WandsLogger.LogError("Collision radius not set for Turret");
				m_collisionRadius = 0.025f;
			}
		}

		public void Pause(bool pause)
		{
			IsPaused = pause;
		}

		private void OnMatchPaused(Events.MatchPausedEvent eventData)
		{
			Pause(eventData.IsPaused);
		}

		protected virtual void ResetTurret()
		{
		}

		protected Vector3 GetFirePos(int index = 0)
		{
			if (m_firePositionTfs == null || m_firePositionTfs.Length <= index)
			{
				return base.transform.position;
			}
			return m_firePositionTfs[index].position;
		}

		protected Vector3 GetFireDirection(int index = 0)
		{
			if (m_firePositionTfs == null || m_firePositionTfs.Length <= index)
			{
				return base.transform.position;
			}
			return m_firePositionTfs[index].forward;
		}

		public virtual void OnHit(float damage)
		{
			if (!NetworkUtils.ConnectedToGame || base.photonView.Owner.IsLocal)
			{
				m_summoned.OnHit(damage);
			}
		}

		private LayerMask GetHitMask()
		{
			if (!sm_hitMask.HasValue)
			{
				sm_hitMask = (1 << LayerMask.NameToLayer("Environment")) | (1 << LayerMask.NameToLayer("Default")) | (1 << LayerMask.NameToLayer("Shield")) | (1 << LayerMask.NameToLayer("Player")) | (1 << LayerMask.NameToLayer("Turret")) | (1 << LayerMask.NameToLayer("Player1")) | (1 << LayerMask.NameToLayer("Player2"));
			}
			return sm_hitMask.Value;
		}
	}
	public class TurretDemon : TurretBase
	{
		private float m_fireRateActual;

		private float m_nextFireTime;

		private float m_currentChargeTime;

		private bool m_isDestroying;

		private bool m_isSightClear;

		private bool m_shouldTargetCaster;

		private EventToken m_destructableSpawnedEventToken;

		private CapsuleCollider[] m_targetColliders = new CapsuleCollider[16];

		public CapsuleCollider TargetCollider { get; private set; }

		public new Wielder Wielder
		{
			[CompilerGenerated]
			get
			{
				return m_summoned.ConnectedSpell.Wielder;
			}
		}

		public override Spell Type
		{
			[CompilerGenerated]
			get
			{
				return Spell.Spell_StoneDemon;
			}
		}

		private Vector3 TargetPoint
		{
			[CompilerGenerated]
			get
			{
				return TargetCollider.transform.position + TargetCollider.center;
			}
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			m_destructableSpawnedEventToken = EventHub.Subscribe<Events.DestructableSpawnedEvent>(OnDestructableSpawned);
		}

		protected override void OnDisable()
		{
			base.OnDisable();
			StopAllCoroutines();
			EventHub.Unsubscribe<Events.DestructableSpawnedEvent>(m_destructableSpawnedEventToken);
		}

		protected override void Update()
		{
			base.Update();
			if (base.IsPaused || (NetworkUtils.ConnectedToGame && !base.photonView.Owner.IsLocal) || m_isDestroying)
			{
				return;
			}
			if (TargetCollider == null)
			{
				UpdateTarget();
			}
			else if (!m_summoned.IsTemporarilyDisabled)
			{
				Vector3 position = TargetCollider.transform.position;
				position.y = base.transform.position.y;
				if (Vector3.Dot(base.transform.forward, Vector3.Normalize(position - base.transform.position)) > 0.95f && m_isSightClear)
				{
					WaitForFire(TargetPoint);
					m_nextFireTime += Time.deltaTime;
				}
			}
		}

		public override void AddTotalDamage(float value)
		{
			if (m_summoned.ConnectedSpell == null)
			{
				WandsLogger.Log("No connected spell!", LogType.Error);
			}
			else
			{
				m_summoned.ConnectedSpell.AddTotalDamage(value);
			}
		}

		public override void OnHit(float damage)
		{
			if (!m_isDestroying)
			{
				base.OnHit(damage);
			}
		}

		protected override void ResetTurret()
		{
			TargetCollider = null;
			m_isDestroying = false;
			m_isSightClear = false;
			m_shouldTargetCaster = false;
			m_fireRateActual = m_fireRate - 1f;
			m_nextFireTime = m_fireRateActual / 2f;
			if (base.photonView.IsMine)
			{
				StopCoroutine("UpdateRaycasts");
				StartCoroutine("UpdateRaycasts");
			}
		}

		protected override void FireProjectile(Vector3[] bezierPoints, float moveSpeed, float dmg, int opponentId, params object[] parameters)
		{
			ProjectileMoverSummoned projectileMoverSummoned = ObjectPoolHandler.GrabFromPool(PoolObjectType.StoneDemonProjectile, base.photonView.ViewID) as ProjectileMoverSummoned;
			projectileMoverSummoned.EnableObject(bezierPoints[0], base.FireTime, bezierPoints, moveSpeed, dmg, opponentId, base.photonView.ViewID);
		}

		public void SetSpellVariables()
		{
			SpellBase_Summon spellBase_Summon = m_summoned.ConnectedSpell as SpellBase_Summon;
			m_shouldTargetCaster = spellBase_Summon.CanTargetCaster;
		}

		public void UpdateTarget()
		{
			if (m_isDestroying || (NetworkUtils.ConnectedToGame && !base.photonView.Owner.IsLocal))
			{
				return;
			}
			if (GameControl.Instance.IsCurrentLevel(Level.Basement))
			{
				int count = TrainingDummyContainer.Count;
				if (count > 0)
				{
					int index = UnityEngine.Random.Range(0, count);
					TargetCollider = TrainingDummyContainer.GetDummy(index).Collider;
				}
				return;
			}
			int targetColliders = GetTargetColliders(m_targetColliders);
			switch (targetColliders)
			{
			case 0:
				if (m_shouldTargetCaster)
				{
					TargetCollider = ((!Wielder.IsBot) ? PlayerManager.Instance.PlayerControl.Collider : PlayerManager.Instance.BotControl.Collider);
				}
				break;
			case 1:
				TargetCollider = m_targetColliders[0];
				break;
			default:
				TargetCollider = GetBestTarget(m_targetColliders, targetColliders);
				break;
			}
		}

		private void OnDestructableSpawned(Events.DestructableSpawnedEvent eventData)
		{
			DestructableSpawned(eventData.Destructable as MonoBehaviour);
		}

		private void DestructableSpawned(MonoBehaviour destructable)
		{
			if (!(destructable == null))
			{
				UpdateTarget();
			}
		}

		private int GetTargetColliders(CapsuleCollider[] colliders)
		{
			int result = 0;
			foreach (Tile allTile in PunSingleton<TileManager>.Instance.AllTiles)
			{
				if (!allTile.IsOccupied)
				{
					continue;
				}
				if (allTile.OccupantTwin != null)
				{
					colliders[result++] = allTile.OccupantTwin.Collider;
				}
				else if (allTile.OccupantWielder != null)
				{
					if (Wielder.IsBot)
					{
						if (!allTile.OccupantWielder.IsBot)
						{
							colliders[result++] = allTile.OccupantWielder.GetCollider();
						}
					}
					else if (!allTile.OccupantWielder.IsLocal || allTile.OccupantWielder.IsBot)
					{
						colliders[result++] = allTile.OccupantWielder.GetCollider();
					}
				}
				else if (allTile.IsTileOccupiedBySummoned())
				{
					Oxymora component = allTile.Occupant.gameObject.GetComponent<Oxymora>();
					if (component != null)
					{
						colliders[result++] = component.GetComponentInChildren<CapsuleCollider>();
					}
				}
			}
			return result;
		}

		private CapsuleCollider GetBestTarget(CapsuleCollider[] targetColliders, int amountOfTargets)
		{
			float num = float.MaxValue;
			CapsuleCollider result = null;
			for (int i = 0; i < amountOfTargets; i++)
			{
				CapsuleCollider capsuleCollider = targetColliders[i];
				if (!(capsuleCollider == null))
				{
					float num2 = MathUtils.Distance2D(base.transform.position, capsuleCollider.transform.position);
					Vector3 vector = capsuleCollider.transform.position + capsuleCollider.center;
					Ray ray = new Ray(vector, (GetFirePos() - vector).normalized);
					if (SightClear(ray) && num2 < num)
					{
						num = num2;
						result = capsuleCollider;
					}
				}
			}
			return result;
		}

		private void WaitForFire(Vector3 targetPoint)
		{
			if (base.AllowFire && !(m_nextFireTime < m_fireRateActual))
			{
				m_nextFireTime = 0f;
				StopCoroutine("Fire");
				StartCoroutine("Fire", targetPoint);
			}
		}

		private IEnumerator Fire(Vector3 targetPoint)
		{
			m_currentChargeTime = 0f;
			float t2 = 0f;
			while (t2 < 1f)
			{
				m_currentChargeTime += Time.deltaTime;
				t2 = ((!m_summoned.IsTemporarilyDisabled) ? (m_currentChargeTime / 1f) : 0f);
				m_summoned.SetDissolveRenderer(1, Mathf.Lerp(0f, 1f, t2));
				if (m_summoned.IsTemporarilyDisabled)
				{
					yield break;
				}
				yield return null;
			}
			m_summoned.SoundHandler.PlaySound("stone_demon_shoot");
			m_summoned.OnHit(m_castCostFirst);
			FireStraight(-1, forceRelease: false, drainEnergy: false, GetFirePos(), MathUtils.GetMidPoint(GetFirePos(), targetPoint), targetPoint);
			UpdateTarget();
			m_currentChargeTime = 0f;
			t2 = 0f;
			while (t2 < 1f)
			{
				m_currentChargeTime += Time.deltaTime;
				t2 = m_currentChargeTime / 0.25f;
				m_summoned.SetDissolveRenderer(1, Mathf.Lerp(1f, 0f, t2));
				yield return null;
			}
		}

		private IEnumerator UpdateRaycasts()
		{
			while (true)
			{
				Ray ray = ((!(TargetCollider != null)) ? new Ray(base.transform.position, base.transform.forward) : new Ray(TargetPoint, (GetFirePos() - TargetPoint).normalized));
				m_isSightClear = SightClear(ray);
				yield return new CustomWaitForSeconds(0.1f);
			}
		}

		private bool SightClear(Ray ray)
		{
			if (Physics.Raycast(ray, out var hitInfo, 50f, m_sightMask) && hitInfo.transform == base.transform)
			{
				return true;
			}
			return false;
		}
	}
	public class TurretOxymora : TurretBase
	{
		private bool[] m_fire = new bool[2];

		private WaitForSeconds m_fireRateWait;

		private List<Collider> m_targetColliders = new List<Collider>();

		private EventToken m_destructableSpawnedEventToken;

		public int ProjectileHeal { get; set; }

		public override Spell Type => Spell.Spell_Oxymora;

		protected override void OnEnable()
		{
			base.OnEnable();
			UpdateTargets();
			m_destructableSpawnedEventToken = EventHub.Subscribe<Events.DestructableSpawnedEvent>(OnDestructableSpawned);
		}

		protected override void OnDisable()
		{
			base.OnDisable();
			EventHub.Unsubscribe<Events.DestructableSpawnedEvent>(m_destructableSpawnedEventToken);
			StopAllCoroutines();
		}

		private void OnDestructableSpawned(Events.DestructableSpawnedEvent eventData)
		{
			DestructableSpawned(eventData.Destructable as MonoBehaviour);
		}

		private void DestructableSpawned(MonoBehaviour destructable)
		{
			if (destructable != null)
			{
				UpdateTargets();
			}
		}

		protected override void ResetTurret()
		{
			m_fire[0] = false;
			m_fire[1] = false;
			m_fireRateWait = new WaitForSeconds(m_fireRate);
			if (base.photonView.IsMine)
			{
				StopCoroutine("RaycastTarget");
				StartCoroutine("RaycastTarget");
			}
		}

		public void UpdateTargets()
		{
			if (NetworkUtils.ConnectedToGame && !base.photonView.Owner.IsLocal)
			{
				return;
			}
			m_targetColliders.Clear();
			if (PlayerManager.Instance.PlayerControl != null)
			{
				m_targetColliders.Add(PlayerManager.Instance.PlayerControl.Collider);
			}
			if (PlayerManager.Instance.BotControl != null)
			{
				m_targetColliders.Add(PlayerManager.Instance.BotControl.Collider);
			}
			if (GameControl.Instance.IsCurrentLevel(Level.Basement))
			{
				for (int i = 0; i < TrainingDummyContainer.Count; i++)
				{
					TrainingDummy dummy = TrainingDummyContainer.GetDummy(i);
					m_targetColliders.Add(dummy.Collider);
				}
			}
			else
			{
				m_targetColliders.AddRange(from x in UnityEngine.Object.FindObjectsOfType<CharacterBase>()
					select x.Collider);
				m_targetColliders.AddRange(from x in UnityEngine.Object.FindObjectsOfType<Assets.Scripts.Spells.TileEffects.StoneDemon>()
					select x.Collider);
			}
		}

		private IEnumerator RaycastTarget()
		{
			while (true)
			{
				if (m_targetColliders.IsNullOrEmpty())
				{
					UpdateTargets();
				}
				while (!base.AllowFire)
				{
					yield return null;
				}
				for (int i = 0; i < 2; i++)
				{
					if (!m_fire[i])
					{
						Ray ray = new Ray(GetFirePos(i), GetFireDirection(i));
						if (ShouldFire(ray, out var hit))
						{
							m_fire[i] = true;
							StartCoroutine(Fire(i, hit.point));
						}
					}
					yield return new CustomWaitForSeconds(0.1f);
				}
				yield return null;
			}
		}

		private bool ShouldFire(Ray ray, out RaycastHit hit)
		{
			hit = default(RaycastHit);
			if (NetworkUtils.ConnectedToGame && !base.photonView.Owner.IsLocal)
			{
				return false;
			}
			for (int i = 0; i < m_targetColliders.Count; i++)
			{
				if (m_targetColliders[i] == null)
				{
					m_targetColliders.RemoveAt(i);
					continue;
				}
				Vector3 center = m_targetColliders[i].bounds.center;
				center.y = base.transform.position.y;
				if (Vector3.Dot(ray.direction, Vector3.Normalize(center - base.transform.position)) > 0.9f)
				{
					Vector3 center2 = m_targetColliders[i].bounds.center;
					ray = new Ray(ray.origin, (center2 - ray.origin).normalized);
					if (Physics.Raycast(ray, out hit, 50f, m_sightMask))
					{
						return m_targetColliders.Contains(hit.collider);
					}
				}
			}
			return false;
		}

		private IEnumerator Fire(int index, Vector3 targetPoint)
		{
			FireStraight(index, forceRelease: false, drainEnergy: false, GetFirePos(index), MathUtils.GetMidPoint(GetFirePos(index), targetPoint), targetPoint);
			yield return m_fireRateWait;
			m_fire[index] = false;
		}

		protected override void FireProjectile(Vector3[] bezierPoints, float moveSpeed, float dmg, int opponentId, params object[] parameters)
		{
			bool flag = opponentId == 0;
			ProjectileMover projectileMover = ObjectPoolHandler.GrabFromPool((!flag) ? PoolObjectType.OxymoraProjectileGood : PoolObjectType.OxymoraProjectileBad, base.photonView.ViewID) as ProjectileMover;
			projectileMover.EnableObject(bezierPoints[0], base.FireTime, bezierPoints, moveSpeed, (!flag) ? ((float)(-ProjectileHeal)) : dmg, opponentId, base.photonView.ViewID);
			if (base.photonView.Owner.IsLocal)
			{
				m_summoned.OnHit(dmg * 0.5f);
			}
		}
	}
	public class TurretSkullSpecter : TurretBase
	{
		private static CapsuleCollider[] sm_targetColliders = new CapsuleCollider[16];

		protected override void OnDisable()
		{
			base.OnDisable();
			StopAllCoroutines();
		}

		public bool TryGetTargetPoint(out Vector3 target)
		{
			Vector3 firePos = GetFirePos();
			RaycastHit hitInfo;
			if (GameControl.Instance.IsCurrentLevel(Level.Basement))
			{
				float num = float.MaxValue;
				TrainingDummy trainingDummy = null;
				Vector3? vector = null;
				for (int i = 0; i < TrainingDummyContainer.Count; i++)
				{
					TrainingDummy dummy = TrainingDummyContainer.GetDummy(i);
					Vector3 vector2 = dummy.Collider.transform.position + dummy.Collider.center;
					Ray ray = new Ray(firePos, vector2 - firePos);
					float sqrMagnitude = (base.transform.position - dummy.transform.position).sqrMagnitude;
					if (trainingDummy == null || sqrMagnitude < (base.transform.position - trainingDummy.transform.position).sqrMagnitude)
					{
						trainingDummy = dummy;
					}
					if (Physics.Raycast(ray, out hitInfo, 50f, m_sightMask) && hitInfo.collider == dummy.Collider && sqrMagnitude < num)
					{
						vector = vector2;
						num = sqrMagnitude;
					}
				}
				if (vector.HasValue)
				{
					target = vector.Value;
					return true;
				}
				target = trainingDummy.Collider.transform.position + trainingDummy.Collider.center;
				return true;
			}
			int num2 = 0;
			foreach (Tile allTile in PunSingleton<TileManager>.Instance.AllTiles)
			{
				if (allTile.IsOccupied)
				{
					if (allTile.OccupantTwin != null)
					{
						sm_targetColliders[num2++] = allTile.OccupantTwin.Collider;
					}
					else if (GetIsOccupiedByOpponentWielder(allTile))
					{
						sm_targetColliders[num2++] = allTile.OccupantWielder.GetCollider();
					}
				}
			}
			switch (num2)
			{
			case 0:
			{
				if ((MonoSingleton<NetworkManager>.Instance.CurrentMatchType & MatchType.Exploration) == 0)
				{
					target = Vector3.zero;
					return false;
				}
				CapsuleCollider collider = PlayerManager.Instance.PlayerControl.Collider;
				target = collider.transform.position + collider.center;
				return true;
			}
			case 1:
			{
				CapsuleCollider capsuleCollider4 = sm_targetColliders[0];
				target = capsuleCollider4.transform.position + capsuleCollider4.center;
				return true;
			}
			default:
			{
				sm_targetColliders.QuickSort(0, num2 - 1, (CapsuleCollider capsuleCollider) => (base.transform.position - (capsuleCollider.transform.position + capsuleCollider.center)).sqrMagnitude);
				for (int j = 0; j < num2; j++)
				{
					CapsuleCollider capsuleCollider2 = sm_targetColliders[j];
					Vector3 vector3 = capsuleCollider2.transform.position + capsuleCollider2.center;
					Ray ray2 = new Ray(firePos, vector3 - firePos);
					if (Physics.Raycast(ray2, out hitInfo, 50f, m_sightMask) && hitInfo.collider == capsuleCollider2)
					{
						target = vector3;
						return true;
					}
				}
				CapsuleCollider capsuleCollider3 = sm_targetColliders[0];
				target = capsuleCollider3.transform.position + capsuleCollider3.center;
				return true;
			}
			}
		}

		public void Fire(Vector3 targetPoint)
		{
			FireStraight(-1, forceRelease: false, drainEnergy: false, GetFirePos(), MathUtils.GetMidPoint(GetFirePos(), targetPoint), targetPoint);
		}

		protected override void FireProjectile(Vector3[] bezierPoints, float moveSpeed, float dmg, int opponentId, params object[] parameters)
		{
			ProjectileMover projectileMover = ObjectPoolHandler.GrabFromPool(PoolObjectType.SkullSpecterProjectile, base.photonView.ViewID) as ProjectileMover;
			projectileMover.EnableObject(bezierPoints[0], base.FireTime, bezierPoints, moveSpeed, dmg, opponentId, base.photonView.ViewID);
		}

		private bool GetIsOccupiedByOpponentWielder(Tile tile)
		{
			return tile.OccupantWielder != null && (tile.OccupantWielder.RemoteCharacter != null || tile.OccupantWielder.IsBot != m_summoned.ConnectedSpell.Wielder.IsBot);
		}
	}
}
public class CastEffectorBall : CastEffectorBase
{
	[SerializeField]
	[Range(0.1f, 1f)]
	private float m_positionAdjuster = 0.5f;

	private Transform m_wandTransform;

	private void Update()
	{
		if (!(m_wandTransform == null))
		{
			base.transform.rotation = m_wandTransform.rotation;
			base.transform.position = m_wandTransform.position;
			Vector3 vector = m_wandTransform.rotation * new Vector3(0f, 0f, m_positionAdjuster * 1.3f);
			base.transform.position += vector;
		}
	}

	public void SetRemoteWandTransform(Transform wandTransform)
	{
		m_wandTransform = wandTransform;
	}

	public override void SetActive(bool enable, float chargeTime)
	{
		if (enable)
		{
			m_currentTime = 0f;
			base.transform.localScale = m_startScale;
		}
		base.SetActive(enable, chargeTime);
	}

	public override void UpdateEffect(float chargeTime)
	{
		m_currentTime += Time.deltaTime;
		float t = Mathf.Clamp01(m_currentTime / chargeTime);
		base.transform.localScale = Vector3.Lerp(m_startScale, Vector3.one, t);
		base.UpdateEffect(chargeTime);
	}
}
[RequireComponent(typeof(PhotonView))]
public class CastEffectorBase : MonoBehaviourPun, IPunObservable
{
	public enum CastEffectorType
	{
		Wand,
		Ground,
		Tile
	}

	[SerializeField]
	private CastEffectorBase m_childEffector;

	[SerializeField]
	private SplitAudioSoundPlayer m_sfxPlayer;

	protected float m_currentTime;

	protected Vector3 m_startScale = new Vector3(0.25f, 0.25f, 0.25f);

	public IWandControl WandControl { get; set; }

	public virtual CastEffectorType Type
	{
		[CompilerGenerated]
		get
		{
			return CastEffectorType.Wand;
		}
	}

	public void OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info)
	{
		SerializeView(stream, info);
	}

	protected virtual void SerializeView(PhotonStream stream, PhotonMessageInfo info)
	{
		if (m_childEffector != null)
		{
			m_childEffector.SerializeView(stream, info);
		}
	}

	protected virtual void Start()
	{
		SetActive(enable: false, 0f);
		if (m_childEffector != null)
		{
			m_childEffector.gameObject.SetActive(value: true);
			m_childEffector.gameObject.SetActive(value: false);
		}
	}

	public virtual void UpdateEffect(float chargeTime)
	{
		if (m_childEffector != null)
		{
			m_childEffector.UpdateEffect(chargeTime);
		}
	}

	public virtual void SetActive(bool enable, float chargeTime)
	{
		if (NetworkUtils.ConnectedToGame)
		{
			base.photonView.RPC("PunSetActive", RpcTarget.All, enable);
		}
		else
		{
			PunSetActive(enable);
		}
		if (m_childEffector != null)
		{
			m_childEffector.SetActive(enable, chargeTime);
		}
	}

	[PunRPC]
	public void PunSetActive(bool enable)
	{
		base.gameObject.SetActive(enable);
		if (m_sfxPlayer != null)
		{
			if (enable)
			{
				m_sfxPlayer.PlaySplitAudio();
			}
			else
			{
				m_sfxPlayer.KillSplitAudio();
			}
		}
	}
}
public class CastEffectorGround : CastEffectorBase
{
	[SerializeField]
	private FX_Rotation[] m_rotators = Array.Empty<FX_Rotation>();

	public override CastEffectorType Type
	{
		[CompilerGenerated]
		get
		{
			return CastEffectorType.Ground;
		}
	}

	protected override void SerializeView(PhotonStream stream, PhotonMessageInfo info)
	{
		base.SerializeView(stream, info);
		if (stream.IsWriting)
		{
			stream.SendNext(base.transform.position);
			stream.SendNext(base.transform.rotation);
		}
		else
		{
			base.transform.position = (Vector3)stream.ReceiveNext();
			base.transform.rotation = (Quaternion)stream.ReceiveNext();
		}
	}

	public override void SetActive(bool enable, float chargeTime)
	{
		if (enable)
		{
			m_currentTime = 0f;
			base.transform.localScale = Vector3.one;
			base.transform.localRotation = Quaternion.LookRotation(base.WandControl.PlayerAim.RotationRay.direction);
		}
		ToggleRotators(enable);
		base.SetActive(enable, chargeTime);
	}

	private void ToggleRotators(bool enable)
	{
		if (!m_rotators.IsNullOrEmpty())
		{
			FX_Rotation[] rotators = m_rotators;
			foreach (FX_Rotation fX_Rotation in rotators)
			{
				fX_Rotation.transform.localRotation = Quaternion.identity;
				fX_Rotation.enabled = enable;
			}
		}
	}
}
namespace Assets.Scripts.Spells.Utils
{
	public class CastEffectorTile : CastEffectorBase
	{
		public override CastEffectorType Type
		{
			[CompilerGenerated]
			get
			{
				return CastEffectorType.Tile;
			}
		}

		public override void SetActive(bool enable, float chargeTime)
		{
			if (enable)
			{
				Tile highlightedTile = base.WandControl.Wielder.Wand.GetHighlightedTile(base.WandControl.WandHand);
				if (highlightedTile == null)
				{
					WandsLogger.Log("Highlighted tile is null", LogType.Warning);
					return;
				}
				m_currentTime = 0f;
				base.transform.position = highlightedTile.transform.position;
			}
			base.SetActive(enable, chargeTime);
		}
	}
}
namespace Assets.Scripts.Spells.TileEffects
{
	public class CurseLingeringEffect : MonoBehaviourPun, IPunInstantiateMagicCallback, IPauseObject, IEffectEmitter, IPoolObject
	{
		[SerializeField]
		private AudioSource m_loopingAudioSource;

		[SerializeField]
		private CurseMaterialHandler m_dissolveHandler;

		private float m_startVolume;

		private EventToken m_matchPausedEventToken;

		private ICursable m_cursable;

		public bool IsPaused { get; set; }

		public float TimeLeft { get; private set; }

		public ParticleSystem[] Emitters { get; set; }

		private void OnEnable()
		{
			m_matchPausedEventToken = EventHub.Subscribe<Events.MatchPausedEvent>(OnMatchPaused);
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe<Events.MatchPausedEvent>(m_matchPausedEventToken);
			CancelInvoke();
		}

		public void Pause(bool pause)
		{
			IsPaused = pause;
			SetEmitterState(pause ? EmitterState.Pause : EmitterState.Play, m_loopingAudioSource.gameObject, refetchEmitters: true);
		}

		private void OnMatchPaused(Events.MatchPausedEvent eventData)
		{
			Pause(eventData.IsPaused);
		}

		public void OnPhotonInstantiate(PhotonMessageInfo info)
		{
			m_startVolume = m_loopingAudioSource.volume;
			m_dissolveHandler.CreateMaterial();
		}

		public void EnableObject(Vector3 position, params object[] data)
		{
			base.photonView.RPC("PunEnableEffect", RpcTarget.AllViaServer, data);
		}

		[PunRPC]
		private void PunEnableEffect(params object[] data)
		{
			StopAllCoroutines();
			PhotonView photonView = PhotonView.Find((int)data[0]);
			if (photonView == null)
			{
				WandsLogger.LogError("PhotonView is null for lingering curse effect.", LogColor.ObjectPooling);
				return;
			}
			base.transform.SetParent(photonView.transform, ResetBehaviour.Position);
			base.gameObject.SetActive(value: true);
			float num = (float)data[1];
			m_cursable = photonView.GetComponent<ICursable>();
			if (m_cursable == null)
			{
				WandsLogger.LogError("Cursable is null for lingering curse effect.", LogColor.ObjectPooling);
			}
			else if (num >= 0f)
			{
				StartCoroutine(LatentDisableLingeringCurse(num - 1f));
				m_cursable.EnableCurse(num, this);
			}
			else
			{
				m_dissolveHandler.FadeInMaterial();
				m_cursable.EnableCurse(-1f, this);
			}
		}

		private IEnumerator LatentDisableLingeringCurse(float disableAfterTime)
		{
			TimeLeft = disableAfterTime;
			m_dissolveHandler.FadeInMaterial();
			while (TimeLeft > 0f)
			{
				while (IsPaused)
				{
					yield return null;
				}
				TimeLeft -= Time.deltaTime;
				yield return null;
			}
			m_cursable.DisableCurse();
			m_dissolveHandler.FadeOutMaterial();
			base.transform.SetParent(null);
			SetEmitterState(EmitterState.Stop, m_loopingAudioSource.gameObject);
			yield return m_loopingAudioSource.DOFade(0f, 1f).WaitForCompletion();
			DisableObject();
		}

		public void DisableObject()
		{
			StopAllCoroutines();
			ObjectPoolHandler.TryReturnToPool(PoolObjectType.CurseOfTheUndeadLingering, this);
			base.photonView.RPC("PunDisableLingeringCurse", RpcTarget.AllViaServer);
		}

		[PunRPC]
		private void PunDisableLingeringCurse()
		{
			base.gameObject.SetActive(value: false);
			base.transform.SetParent(ObjectPoolHandler.PoolParent);
			m_loopingAudioSource.volume = m_startVolume;
		}

		public void SetEmitterState(EmitterState newState, GameObject effectParent, bool refetchEmitters = false)
		{
			if (effectParent == null)
			{
				return;
			}
			if (refetchEmitters || Emitters.IsNullOrEmpty())
			{
				Emitters = effectParent.GetComponentsInChildren<ParticleSystem>();
			}
			if (Emitters.IsNullOrEmpty())
			{
				effectParent.SetActive(newState != EmitterState.Stop);
				return;
			}
			ParticleSystem[] emitters = Emitters;
			foreach (ParticleSystem particleSystem in emitters)
			{
				switch (newState)
				{
				case EmitterState.Play:
					particleSystem.Play();
					break;
				case EmitterState.Pause:
					particleSystem.Pause();
					break;
				case EmitterState.Stop:
					particleSystem.Stop();
					break;
				}
			}
		}

		PhotonView IPoolObject.get_photonView()
		{
			return base.photonView;
		}
	}
}
namespace Assets.Scripts.Spells.Utils
{
	public class CurseMaterialHandler : MonoBehaviour
	{
		[SerializeField]
		private Material m_originalSkullMaterial;

		[SerializeField]
		private Renderer[] m_skullRenderers;

		private Material m_material;

		private Tweener m_dissolveTween;

		public void CreateMaterial()
		{
			m_material = new Material(m_originalSkullMaterial);
			m_material.SetFloat("_DissolvePower", 0f);
			Renderer[] skullRenderers = m_skullRenderers;
			foreach (Renderer renderer in skullRenderers)
			{
				renderer.material = m_material;
			}
		}

		public void FadeInMaterial()
		{
			m_dissolveTween.Kill();
			m_material.SetFloat("_DissolvePower", 0f);
			m_dissolveTween = m_material.DOFloat(1f, "_DissolvePower", 1f);
		}

		public void FadeOutMaterial()
		{
			m_dissolveTween.Kill();
			m_dissolveTween = m_material.DOFloat(0f, "_DissolvePower", 1f);
		}
	}
	public class DissolveOverTime : MonoBehaviour
	{
		[SerializeField]
		private Material m_material;

		private Tweener m_dissolveTween;

		private void Start()
		{
			m_material.SetFloat("_DissolvePower", 0f);
		}

		public void FadeInMaterial()
		{
			m_dissolveTween.Kill();
			m_dissolveTween = m_material.DOFloat(1f, "_DissolvePower", 1f);
		}

		public void FadeOutMaterial()
		{
			m_dissolveTween.Kill();
			m_dissolveTween = m_material.DOFloat(0f, "_DissolvePower", 1f);
		}
	}
	public class EndPointCollisionTracker : MonoBehaviour, IPunObservable
	{
		[SerializeField]
		private ParticleSystem m_hitEffect;

		[SerializeField]
		private AudioSource m_hitSfx;

		[SerializeField]
		private float m_endPointLifeTime = 0.5f;

		private float m_timeRemaining;

		public bool IsHitEffectEnabled { get; private set; }

		public void SetPosition(Vector3 newPosition)
		{
			base.transform.position = newPosition;
			ResetTimer();
		}

		public void ResetTimer()
		{
			m_timeRemaining = m_endPointLifeTime;
		}

		private void Update()
		{
			if (IsHitEffectEnabled)
			{
				m_timeRemaining -= Time.deltaTime;
				if (m_timeRemaining <= 0f)
				{
					SetHitEffectActive(enable: false);
				}
			}
		}

		public void OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info)
		{
			if (stream.IsWriting)
			{
				stream.SendNext(base.transform.position);
				stream.SendNext(base.transform.rotation);
			}
			else
			{
				base.transform.position = (Vector3)stream.ReceiveNext();
				base.transform.rotation = (Quaternion)stream.ReceiveNext();
			}
		}

		public void SetHitEffectActive(bool enable, bool playSfx = false)
		{
			if (m_hitEffect == null || m_hitSfx == null)
			{
				return;
			}
			IsHitEffectEnabled = enable;
			if (enable)
			{
				m_hitEffect.Play(withChildren: true);
				if (playSfx)
				{
					PlaySfx(enable: true);
				}
			}
			else
			{
				m_hitEffect.Stop(withChildren: true);
				PlaySfx(enable: false);
			}
		}

		public void PlaySfx(bool enable)
		{
			if (!(m_hitSfx == null))
			{
				if (enable)
				{
					m_hitSfx.Play();
				}
				else
				{
					m_hitSfx.Stop();
				}
			}
		}
	}
	[RequireComponent(typeof(Light))]
	public class FlickeringSpellHandler : MonoBehaviour
	{
		[SerializeField]
		private Light m_pointLight;

		[SerializeField]
		private int m_lightDifference;

		[SerializeField]
		private float m_lightFrequency;

		[SerializeField]
		private float m_minValue = 1f;

		[SerializeField]
		private float m_maxValue = 1.5f;

		private float m_startIntensity;

		private float m_endIntensity;

		private float m_timeValue;

		private float m_timeMaxvalue;

		private bool m_pulsate;

		private void Start()
		{
			if (m_pointLight != null)
			{
				SetStartValues();
				SetPulsate(enable: false);
			}
		}

		private void Update()
		{
			if (m_pointLight != null && m_pulsate)
			{
				PulsateLight();
			}
		}

		public void SetPulsate(bool enable)
		{
			m_pulsate = enable;
			m_pointLight.enabled = enable;
		}

		private void PulsateLight()
		{
			m_timeValue += Time.deltaTime;
			float num = m_timeValue * m_lightFrequency;
			m_pointLight.intensity = Mathf.Lerp(m_startIntensity, m_endIntensity, num);
			if (num >= m_timeMaxvalue)
			{
				ResetValues(m_startIntensity, m_endIntensity);
			}
		}

		private void SetStartValues()
		{
			m_startIntensity = (float)(-m_lightDifference) + m_pointLight.intensity;
			m_endIntensity = (float)m_lightDifference + m_pointLight.intensity;
			m_timeMaxvalue = UnityEngine.Random.Range(m_minValue, m_maxValue);
		}

		private void ResetValues(float start, float end)
		{
			m_timeValue = 0f;
			m_timeMaxvalue = UnityEngine.Random.Range(m_minValue, m_maxValue);
			m_startIntensity = end;
			m_endIntensity = start;
		}
	}
	[RequireComponent(typeof(Light))]
	public class LightEffectHandler : MonoBehaviour
	{
		[SerializeField]
		private bool m_automatic;

		[SerializeField]
		private Light m_light;

		[SerializeField]
		private float m_fadeTime = 0.5f;

		[SerializeField]
		private float m_maxLightIntensity = 5f;

		[SerializeField]
		private float m_toggleOffDelay;

		private Tweener m_lightTween;

		private void OnEnable()
		{
			if (m_automatic)
			{
				ToggleLight(enable: true);
			}
		}

		public void ToggleLight(bool enable, float delay = 0f)
		{
			if (m_light == null)
			{
				m_light = GetComponent<Light>();
			}
			if (m_lightTween != null)
			{
				m_lightTween.Kill();
			}
			m_light.enabled = true;
			m_lightTween = m_light.DOIntensity((!enable) ? 0f : m_maxLightIntensity, m_fadeTime).SetDelay(delay).OnComplete(FadeLightComplete);
		}

		private void FadeLightComplete()
		{
			if (Mathf.Approximately(m_light.intensity, 0f))
			{
				m_light.enabled = false;
			}
			else if (m_automatic)
			{
				ToggleLight(enable: false, m_toggleOffDelay);
			}
		}
	}
	public class PrisonDissolver : MonoBehaviour
	{
		[SerializeField]
		private Renderer m_barsRenderer;

		[SerializeField]
		private float m_dissolveTime = 1f;

		[SerializeField]
		[Tooltip("Adjust this to match material min Dissolve value")]
		[Range(-0.5f, 1f)]
		private float m_dissolveMin;

		public float DissolveTime => m_dissolveTime;

		public void EnablePrisonBars()
		{
			if (m_barsRenderer == null)
			{
				WandsLogger.Log("Can't dissolve prison, no renderer defined!", LogType.Error);
			}
			else
			{
				m_barsRenderer.material.DOFloat(1f, "_DissolvePower", m_dissolveTime);
			}
		}

		public void DisablePrisonBars()
		{
			m_barsRenderer.material.DOFloat(m_dissolveMin, "_DissolvePower", m_dissolveTime);
		}
	}
	[RequireComponent(typeof(AudioSource))]
	public class ProjectileEffectHandler : MonoBehaviour
	{
		[SerializeField]
		private AudioSource m_audioSource;

		[SerializeField]
		private AudioClip[] m_audioClips = Array.Empty<AudioClip>();

		private void OnDisable()
		{
			StopAllCoroutines();
		}

		public void EnableEffect(Transform parent)
		{
			if (base.transform.parent != parent)
			{
				base.transform.SetParent(parent);
			}
			base.transform.localPosition = Vector3.zero;
			base.transform.SetParent(null);
			base.transform.rotation = Quaternion.LookRotation(parent.forward);
			SetAudioClip();
			base.gameObject.SetActive(value: true);
			StartCoroutine(LatentDisableEffect(parent));
		}

		private IEnumerator LatentDisableEffect(Transform parent)
		{
			yield return new CustomWaitForSeconds(3f);
			DisableAndReturn(parent);
		}

		public void DisableAndReturn(Transform parent)
		{
			base.transform.SetParent(parent);
			base.gameObject.SetActive(value: false);
		}

		private void SetAudioClip()
		{
			if (!m_audioClips.IsNullOrEmpty())
			{
				m_audioSource.clip = m_audioClips.GetRandomElement();
			}
		}
	}
	[RequireComponent(typeof(AudioSource))]
	public class ProjectileExplosionHandler : MonoBehaviour
	{
		[SerializeField]
		private AudioSource m_audioSource;

		[SerializeField]
		private bool m_matchSoundWithType;

		[SerializeField]
		private AudioClip[] m_audioClips;

		[SerializeField]
		private AudioClip[] m_audioClipsPlayer;

		private void Awake()
		{
			if (m_audioSource == null)
			{
				m_audioSource = GetComponent<AudioSource>();
			}
		}

		private void OnDisable()
		{
			StopAllCoroutines();
		}

		public void EnableEffect(HitSfxType sfxType)
		{
			SetAudioClip(sfxType);
			base.gameObject.SetActive(value: true);
			StartCoroutine(LatentDisableEffect());
		}

		public void DisableEffect()
		{
			StopAllCoroutines();
			base.gameObject.SetActive(value: false);
		}

		private IEnumerator LatentDisableEffect()
		{
			yield return new CustomWaitForSeconds(5f);
			DisableEffect();
		}

		private void SetAudioClip(HitSfxType sfxType)
		{
			if (m_audioClips.IsNullOrEmpty())
			{
				if (m_audioSource.clip == null)
				{
					WandsLogger.Log($"{base.name} no clip defined", LogType.Warning);
				}
			}
			else if (sfxType == HitSfxType.Player && !m_audioClipsPlayer.IsNullOrEmpty())
			{
				m_audioSource.clip = m_audioClipsPlayer.GetRandomElement();
			}
			else if (m_matchSoundWithType)
			{
				if ((int)sfxType > m_audioClips.Length)
				{
					sfxType = HitSfxType.Default;
				}
				m_audioSource.clip = m_audioClips[(int)sfxType];
			}
			else
			{
				m_audioSource.clip = m_audioClips.GetRandomElement();
			}
		}
	}
	public class SpikeActivator : MonoBehaviour
	{
		private Transform m_spikeTf;

		private void OnDisable()
		{
			StopAllCoroutines();
		}

		private void OnDestroy()
		{
			StopAllCoroutines();
		}

		public void ActivateSpike(bool enable)
		{
			if (!(this == null) && !(base.transform == null))
			{
				if (m_spikeTf == null)
				{
					m_spikeTf = base.transform.GetChild(0);
				}
				base.enabled = true;
				if (!(m_spikeTf == null) && m_spikeTf.gameObject.activeInHierarchy)
				{
					StopAllCoroutines();
					StartCoroutine(SetSpikeActive(enable));
				}
			}
		}

		private IEnumerator SetSpikeActive(bool enable)
		{
			Vector3 startScale = m_spikeTf.localScale;
			Vector3 endScale = ((!enable) ? (Vector3.one * 0.2f) : Vector3.one);
			float currentTime = 0f;
			float t = 0f;
			while (t < 1f)
			{
				currentTime += Time.deltaTime;
				t = currentTime / 0.15f;
				m_spikeTf.localScale = Vector3.Lerp(startScale, endScale, t);
				yield return null;
			}
			if (!enable)
			{
				base.enabled = false;
			}
		}
	}
}
namespace Cortopia.Scripts.Spells.Utils
{
	[Serializable]
	public class SplashDamageData
	{
		public LayerMask HitMask;

		public float MinSplashDamage;

		public float SplashDamageRadius;

		private static bool sm_isDefaultCreated;

		private static SplashDamageData sm_splash;

		public float DamageMultiplier { get; set; } = 1f;


		public static SplashDamageData Empty()
		{
			if (!sm_isDefaultCreated)
			{
				sm_splash = new SplashDamageData();
				sm_isDefaultCreated = true;
			}
			return sm_splash;
		}
	}
	[CreateAssetMenu(fileName = "NewSplashDamageData", menuName = "Spells/Create new splash damage data", order = 2)]
	public class SplashDamageDataObject : ScriptableObject
	{
		public SplashDamageData Data;

		public static SplashDamageDataObject CreateInstance(SplashDamageData data)
		{
			SplashDamageDataObject splashDamageDataObject = ScriptableObject.CreateInstance<SplashDamageDataObject>();
			splashDamageDataObject.Data = data;
			return splashDamageDataObject;
		}
	}
	public class SplashDamageHandler : MonoBehaviour
	{
		private SplashDamageData m_splashDamageData;

		private Assets.Scripts.Enums.TagType m_tag;

		private static Collider[] sm_overlapColliders = new Collider[8];

		public float SplashDamageRadius
		{
			[CompilerGenerated]
			get
			{
				return m_splashDamageData.SplashDamageRadius;
			}
		}

		private float MinSplashDamage
		{
			[CompilerGenerated]
			get
			{
				return m_splashDamageData.MinSplashDamage;
			}
		}

		public void SetData(SplashDamageData splashDamageData)
		{
			m_splashDamageData = splashDamageData;
		}

		public void DealSplashDamage(float spellDamage, ProjectileMover projectileMover, Collider excludeCollider = null, bool dealMinDamage = false)
		{
			int num = Physics.OverlapSphereNonAlloc(base.transform.position, SplashDamageRadius, sm_overlapColliders, m_splashDamageData.HitMask);
			for (int i = 0; i < num; i++)
			{
				Collider collider = sm_overlapColliders[i];
				if (collider == excludeCollider || !EnumHelper.TryParse(collider.tag, out m_tag) || GetVisionObstructed(collider.bounds.center, projectileMover.HitMask))
				{
					continue;
				}
				float num2 = GetDamage(dealMinDamage, spellDamage, collider.transform.position) * m_splashDamageData.DamageMultiplier;
				switch (m_tag)
				{
				case Assets.Scripts.Enums.TagType.Player:
					if (!projectileMover.DealDamagePlayerObject(collider.GetComponentInParent<IDamageable>(), num2))
					{
						projectileMover.DealDamageTwinAndReturnToSender(collider.GetComponentInParent<Twin>(), num2, returnToSenderActive: false);
					}
					break;
				case Assets.Scripts.Enums.TagType.Dummy:
					projectileMover.DealDamageTrainingDummy(collider, num2);
					break;
				case Assets.Scripts.Enums.TagType.Destructable:
					projectileMover.DealDamageDestructable(collider, num2 / (float)num);
					break;
				}
			}
		}

		private bool GetVisionObstructed(Vector3 colliderCenter, LayerMask projectileHitMask)
		{
			if (Physics.Raycast(base.transform.position, (colliderCenter - base.transform.position).normalized, out var hitInfo, SplashDamageRadius, projectileHitMask))
			{
				return hitInfo.collider.CompareTag("Shield") || hitInfo.collider.CompareTag("Environment");
			}
			return true;
		}

		private float GetDamage(bool dealMinDamage, float spellDamage, Vector3 colliderPosition)
		{
			return (!dealMinDamage) ? ((float)(int)Mathf.Lerp(spellDamage, MinSplashDamage, Vector3.Distance(colliderPosition, base.transform.position) / SplashDamageRadius)) : MinSplashDamage;
		}
	}
}
namespace Assets.Scripts.Spells.Utils
{
	public class TeleportEffect : PoolObject
	{
		[PunRPC]
		public override void PunEnableObject(Vector3 position, params object[] data)
		{
			base.PunEnableObject(position, data);
			bool flag = !data.IsNullOrEmpty() && (bool)data[0];
			if (GameControl.Instance.IsCurrentLevel(Level.Arena) && (!base.photonView.Owner.IsLocal || flag))
			{
				Wielder opponent = null;
				if (PlayerManager.Instance.CanGetOpponentWielder(out opponent))
				{
					opponent.Character.CharacterRenderer.SetRenderersEnabled(enable: true);
				}
			}
		}
	}
	public class TeleportEffectTransporter : BezierFollower, IPunInstantiateMagicCallback, IPoolObject
	{
		[SerializeField]
		private PoolObjectType m_poolObjectType;

		[SerializeField]
		private GameObject m_core;

		[SerializeField]
		private Transform m_trailEffectTf;

		[SerializeField]
		private float m_lifeTime;

		[SerializeField]
		private float m_moveSpeed = 0.2f;

		private float m_bezierFollowTime;

		private bool m_isMoving;

		private void OnDisable()
		{
			StopAllCoroutines();
		}

		public void OnPhotonInstantiate(PhotonMessageInfo info)
		{
			PunDisableObject();
			base.transform.SetParent(ObjectPoolHandler.PoolParent);
		}

		private void FixedUpdate()
		{
			if (m_isMoving && !Mathf.Approximately(base.BezierLength, 0f))
			{
				m_bezierFollowTime += Time.deltaTime / m_moveSpeed / (base.BezierLength * 0.1f);
				m_bezierFollowTime = Mathf.Clamp01(m_bezierFollowTime);
				m_trailEffectTf.LookAt(base.transform.position + GetDirection(base.transform.position, m_bezierFollowTime));
				m_trailEffectTf.position = Bezier.GetPoint(base.P0, base.P1, base.P2, m_bezierFollowTime);
				if (Mathf.Approximately(m_bezierFollowTime, 1f))
				{
					m_isMoving = false;
				}
			}
		}

		public void EnableObject(Vector3 position, params object[] data)
		{
			base.photonView.RPC("PunEnableObject", RpcTarget.All, position, data);
		}

		[PunRPC]
		private void PunEnableObject(Vector3 position, params object[] data)
		{
			bool flag = data != null && data.Length > 1 && (bool)data[1];
			base.transform.position = position;
			if (base.photonView.Owner.IsLocal && !flag)
			{
				base.gameObject.SetActive(value: true);
				SetCoreActive(active: true);
				StartCoroutine(DisableAfterTime());
				return;
			}
			Wielder opponent = null;
			if (PlayerManager.Instance.CanGetOpponentWielder(out opponent))
			{
				opponent.Character.CharacterRenderer.SetRenderersEnabled(enable: false);
			}
			if (data.IsNullOrEmpty())
			{
				base.gameObject.SetActive(value: true);
				SetCoreActive(active: true);
				return;
			}
			SetBezierPointsAndLength((Vector3[])data[0]);
			m_bezierFollowTime = 0f;
			m_trailEffectTf.gameObject.SetActive(value: true);
			m_trailEffectTf.localPosition = Vector3.zero;
			m_trailEffectTf.LookAt(base.transform.position + GetDirection(base.transform.position, m_bezierFollowTime));
			base.gameObject.SetActive(value: true);
			SetCoreActive(active: true);
			m_isMoving = true;
		}

		private IEnumerator DisableAfterTime()
		{
			yield return new WaitForSeconds(m_lifeTime);
			DisableObject();
		}

		public void DisableObject()
		{
			ObjectPoolHandler.TryReturnToPool(m_poolObjectType, this);
			base.photonView.RPC("PunDisableObject", RpcTarget.All);
		}

		[PunRPC]
		private void PunDisableObject()
		{
			m_isMoving = false;
			SetCoreActive(active: false);
			m_trailEffectTf.gameObject.SetActive(value: false);
			base.gameObject.SetActive(value: false);
		}

		private void SetCoreActive(bool active)
		{
			if (m_core != null)
			{
				m_core.SetActive(active);
			}
		}

		PhotonView IPoolObject.get_photonView()
		{
			return base.photonView;
		}
	}
	public class WandChargeEffect : MonoBehaviour, IEffectEmitter
	{
		private const float RemoteCharacterOffsetMultipler = 1.3f;

		[SerializeField]
		[Range(0.1f, 1f)]
		private float m_positionAdjuster = 0.4f;

		[SerializeField]
		private FlickeringSpellHandler m_flickeringSpellHandler;

		[SerializeField]
		private AudioSource m_chargeSound;

		private bool m_isLocal = true;

		private Transform m_wandTransform;

		public ParticleSystem[] Emitters { get; set; }

		public bool IsActive { get; private set; }

		private void Awake()
		{
			base.transform.localPosition = new Vector3(0f, 0f, m_positionAdjuster);
			SetSoundActive(play: false);
		}

		private void Start()
		{
			if (IsActive)
			{
				SetEffectActive(enable: true);
			}
		}

		private void Update()
		{
			if (!m_isLocal && !(m_wandTransform == null))
			{
				base.transform.rotation = m_wandTransform.rotation;
				base.transform.position = m_wandTransform.position;
				Vector3 vector = m_wandTransform.rotation * new Vector3(0f, 0f, m_positionAdjuster);
				base.transform.position += vector;
			}
		}

		public void SetRemoteWandTransform(Transform wandTransform)
		{
			SetWandParent(null);
			m_wandTransform = wandTransform;
			m_positionAdjuster *= 1.3f;
			m_isLocal = false;
		}

		public void SetEffectActive(bool enable)
		{
			base.transform.localPosition = new Vector3(0f, 0f, m_positionAdjuster);
			IsActive = enable;
			SetEmitterState((!enable) ? EmitterState.Stop : EmitterState.Play, base.gameObject);
			SetSoundActive(enable);
			if (m_flickeringSpellHandler != null)
			{
				m_flickeringSpellHandler.SetPulsate(enable);
			}
		}

		public void SetWandParent(Transform parent)
		{
			base.transform.SetParent(parent, ResetBehaviour.Rotation);
		}

		private void SetSoundActive(bool play)
		{
			if (!(m_chargeSound == null))
			{
				if (play)
				{
					m_chargeSound.volume = 0f;
					m_chargeSound.Play();
					m_chargeSound.DOFade(1f, 0.15f);
				}
				else
				{
					m_chargeSound.DOFade(0f, 0.15f).OnComplete(KillSound);
				}
			}
		}

		private void KillSound()
		{
			m_chargeSound.Stop();
		}

		public void DisableEmitters(GameObject effectParent, bool refetchEmitters = false)
		{
			SetEmitterState(EmitterState.Stop, effectParent, refetchEmitters);
		}

		public void SetEmitterState(EmitterState newState, GameObject effectParent, bool refetchEmitters = false)
		{
			if (refetchEmitters || Emitters.IsNullOrEmpty())
			{
				Emitters = effectParent.GetComponentsInChildren<ParticleSystem>();
			}
			if (Emitters.IsNullOrEmpty())
			{
				effectParent.SetActive(newState != EmitterState.Stop);
				return;
			}
			ParticleSystem[] emitters = Emitters;
			foreach (ParticleSystem particleSystem in emitters)
			{
				switch (newState)
				{
				case EmitterState.Play:
					particleSystem.Play();
					break;
				case EmitterState.Pause:
					particleSystem.Pause();
					break;
				case EmitterState.Stop:
					particleSystem.Stop();
					break;
				}
			}
		}
	}
}
namespace Cortopia.Scripts.Tiles
{
	[RequireComponent(typeof(Tile))]
	public class BotTileBlocker : MonoBehaviour
	{
		private void Start()
		{
			Events.TilePredictedUnsafeEvent tilePredictedUnsafeEvent = new Events.TilePredictedUnsafeEvent();
			tilePredictedUnsafeEvent.Tile = GetComponent<Tile>();
			EventHub.Publish(tilePredictedUnsafeEvent);
		}
	}
}
namespace Assets.Scripts.Tiles
{
	[RequireComponent(typeof(PhotonView))]
	public class Tile : MonoBehaviourPun
	{
		private const int ParticleSystemsPerTile = 2;

		private const int ParticlesPerParticleSystem = 6;

		[HideInInspector]
		public List<TileEffectBase> ActiveEffectHandlers = new List<TileEffectBase>(3);

		[SerializeField]
		private bool m_isElevatorTile;

		[SerializeField]
		private int m_audioSnapShotIndex;

		[SerializeField]
		private List<PickupBase> m_pickups = new List<PickupBase>();

		[SerializeField]
		private GameObject m_displayEffect;

		[SerializeField]
		private ParticleSystem m_outsideTileAreaEffect;

		[SerializeField]
		private ParticleSystem[] m_particleSystems = Array.Empty<ParticleSystem>();

		[Header("Colliders")]
		[SerializeField]
		private Collider m_teleportCollider;

		[SerializeField]
		private Collider m_botTeleportCollider;

		private TileOccupyState m_occupyState;

		private bool m_hasCalledStart;

		private EventToken m_matchResetEventToken;

		private EventToken m_matchEndedEventToken;

		private ParticleSystem.Particle[][] m_particles = new ParticleSystem.Particle[2][];

		private int[] m_numberOfActiveParticles = new int[2];

		private Material[] m_tileMaterials;

		private ISet<WandHand> m_highlightHands = new HashSet<WandHand>();

		private Color m_fxColor;

		public static LayerMask TileMask
		{
			[CompilerGenerated]
			get
			{
				return 1 << LayerMask.NameToLayer("Tile");
			}
		}

		public PhotonView Occupant { get; private set; }

		public Wielder OccupantWielder { get; private set; }

		public Twin OccupantTwin { get; private set; }

		public float TimeOccupied { get; private set; }

		public int TimesUsed { get; private set; }

		public bool IsHighlighted { get; private set; }

		public bool IsElevatorTile
		{
			[CompilerGenerated]
			get
			{
				return m_isElevatorTile;
			}
		}

		public bool IsUnoccupied
		{
			[CompilerGenerated]
			get
			{
				return m_occupyState == TileOccupyState.Unoccupied;
			}
		}

		public bool IsOccupied
		{
			[CompilerGenerated]
			get
			{
				return m_occupyState == TileOccupyState.Occupied;
			}
		}

		public bool IsLocked
		{
			[CompilerGenerated]
			get
			{
				return m_occupyState == TileOccupyState.Locked;
			}
		}

		public bool IsEffectActive
		{
			[CompilerGenerated]
			get
			{
				return !ActiveEffectHandlers.IsNullOrEmpty();
			}
		}

		public IReadOnlyList<PickupBase> Pickups
		{
			[CompilerGenerated]
			get
			{
				return m_pickups;
			}
		}

		public GameObject DisplayEffect
		{
			[CompilerGenerated]
			get
			{
				return (!(m_displayEffect != null)) ? null : m_displayEffect;
			}
		}

		public Collider TeleportCollider
		{
			[CompilerGenerated]
			get
			{
				return (!(m_teleportCollider != null)) ? null : m_teleportCollider;
			}
		}

		public Collider BotTeleportCollider
		{
			[CompilerGenerated]
			get
			{
				return (!(m_botTeleportCollider != null)) ? null : m_botTeleportCollider;
			}
		}

		public ValeHealEffect ActiveHealEffect { get; set; }

		public event Action<bool> OnTileOccupied;

		private void OnEnable()
		{
			m_matchResetEventToken = EventHub.Subscribe<Events.MatchResetEvent>(OnMatchReset);
			if (m_hasCalledStart)
			{
				m_matchEndedEventToken = EventHub.Subscribe<Events.MatchEndedEvent>(OnMatchEnded);
			}
		}

		private void OnDisable()
		{
			CancelInvoke();
			EventHub.Unsubscribe<Events.MatchResetEvent>(m_matchResetEventToken);
			if (m_hasCalledStart && m_matchEndedEventToken != null)
			{
				EventHub.Unsubscribe<Events.MatchEndedEvent>(m_matchEndedEventToken);
				m_matchEndedEventToken = null;
			}
		}

		private void Start()
		{
			m_hasCalledStart = true;
			TimesUsed = 0;
			m_displayEffect.SetActive(value: true);
			for (int i = 0; i < m_particleSystems.Length; i++)
			{
				ParticleSystem.MainModule main = m_particleSystems[i].main;
				main.prewarm = true;
				m_particleSystems[i].gameObject.SetActive(value: true);
				m_particleSystems[i].Play();
				m_particles[i] = new ParticleSystem.Particle[6];
				m_numberOfActiveParticles[i] = m_particleSystems[i].GetParticles(m_particles[i]);
				main.prewarm = false;
			}
			TryGetTileMaterials();
			SetHighlighted(enable: false);
			SetTeleportActive(enable: false);
		}

		private void TryGetTileMaterials()
		{
			if (GameControl.Instance.IsDualWieldSupportedAndActive)
			{
				Renderer[] componentsInChildren = DisplayEffect.GetComponentsInChildren<Renderer>(includeInactive: true);
				m_tileMaterials = new Material[componentsInChildren.Length];
				for (int i = 0; i < componentsInChildren.Length; i++)
				{
					m_tileMaterials[i] = componentsInChildren[i].material;
				}
			}
		}

		private void OnMatchReset(Events.MatchResetEvent eventData)
		{
			ResetTile();
		}

		private void OnMatchEnded(Events.MatchEndedEvent eventData)
		{
			ResetTile();
		}

		private void OnTileAreaEnter(Events.TileAreaEnterEvent eventData)
		{
			SetTileAreaEffectActive(enable: false);
		}

		private void OnTileAreaExit(Events.TileAreaExitEvent eventData)
		{
			SetTileAreaEffectActive(enable: true);
		}

		private void ResetTile()
		{
			TimesUsed = 0;
			ActiveEffectHandlers.Clear();
		}

		public void AddTeleportActive(WandHand wandHand)
		{
			if (!m_highlightHands.Add(wandHand))
			{
				return;
			}
			if (GameControl.Instance.IsDualWieldSupportedAndActive)
			{
				if (m_highlightHands.Count == 1)
				{
					m_fxColor = ((wandHand != 0) ? Colors.TileColorLeft : Colors.TileColorRight);
				}
				else
				{
					m_fxColor += ((wandHand != 0) ? Colors.TileColorLeft : Colors.TileColorRight);
					m_fxColor /= 2f;
				}
				SetTileMaterialColor(m_fxColor);
			}
			TeleportCollider.enabled = true;
			SetVFXActive(enable: true);
		}

		public void RemoveTeleportActive(WandHand wandHand)
		{
			m_highlightHands.Remove(wandHand);
			if (m_highlightHands.Count == 1)
			{
				m_fxColor = ((wandHand != 0) ? Colors.TileColorRight : Colors.TileColorLeft);
				SetTileMaterialColor(m_fxColor);
			}
			else
			{
				TeleportCollider.enabled = false;
				SetVFXActive(enable: false);
			}
		}

		public void SetTeleportActive(bool enable)
		{
			TeleportCollider.enabled = enable;
			SetVFXActive(enable);
		}

		public void SetHighlighted(bool enable)
		{
			if (IsHighlighted != enable)
			{
				IsHighlighted = enable;
			}
		}

		public void Occupy(TileOccupyState state, PhotonView occupant, float timeOccupied)
		{
			if (IsLocked)
			{
				state = TileOccupyState.Locked;
			}
			m_occupyState = state;
			TimesUsed++;
			TimeOccupied = timeOccupied;
			Occupant = occupant;
			if (occupant != null)
			{
				OccupantWielder = occupant.GetComponent<Wielder>();
				if (OccupantWielder != null)
				{
					MonoSingleton<SnapshotHandler>.Instance?.TransitionTo(m_audioSnapShotIndex);
					SetTileAreaEffectActive(OccupantWielder.IsPlayer && GameControl.Instance.Platform.SupportsPositionalTracking);
				}
				else
				{
					OccupantTwin = occupant.GetComponent<Twin>();
				}
			}
			if (this.OnTileOccupied != null)
			{
				this.OnTileOccupied(obj: true);
			}
			PunSingleton<TileManager>.Instance.TrySetTileAvailable(this);
		}

		public void Unoccupy(bool forced)
		{
			if (IsOccupied || forced)
			{
				m_occupyState = TileOccupyState.Unoccupied;
			}
			Occupant = null;
			OccupantWielder = null;
			OccupantTwin = null;
			SetTileAreaEffectActive(enable: false);
			if (this.OnTileOccupied != null)
			{
				this.OnTileOccupied(obj: false);
			}
			PunSingleton<TileManager>.Instance.TrySetTileAvailable(this);
		}

		public bool IsTileOccupiedBySummoned()
		{
			if (ActiveEffectHandlers.IsNullOrEmpty())
			{
				return false;
			}
			foreach (TileEffectBase activeEffectHandler in ActiveEffectHandlers)
			{
				if (activeEffectHandler == null || activeEffectHandler.ConnectedSpell == null)
				{
					WandsLogger.LogError("Area effect not cleared or missing connected spell");
				}
				else if (activeEffectHandler.ConnectedSpell.IsType(Spell.Spell_DevilsTwins) || activeEffectHandler.ConnectedSpell is SpellBase_Summon)
				{
					return true;
				}
			}
			return false;
		}

		public void RemoveActiveTraps()
		{
			if (IsEffectActive && !IsTileOccupiedBySummoned())
			{
				for (int num = ActiveEffectHandlers.Count - 1; num >= 0; num--)
				{
					ActiveEffectHandlers[num]?.DisableObject();
				}
			}
		}

		public void SetEffectOccupied(bool value, TileEffectBase effectHandler)
		{
			if (value)
			{
				AddActiveEffect(effectHandler);
			}
			else
			{
				RemoveActiveEffect(effectHandler);
			}
		}

		private void AddActiveEffect(TileEffectBase effectHandler)
		{
			if (effectHandler == null)
			{
				WandsLogger.LogError("Trying to add null effect to tile effect list.");
			}
			else if (!ActiveEffectHandlers.Contains(effectHandler))
			{
				ActiveEffectHandlers.Add(effectHandler);
				PunSingleton<TileManager>.Instance.TrySetTileAvailable(this);
			}
		}

		private void RemoveActiveEffect(TileEffectBase effectHandler)
		{
			if (ActiveEffectHandlers.IsNullOrEmpty())
			{
				return;
			}
			if (effectHandler != null)
			{
				if (ActiveEffectHandlers.Contains(effectHandler))
				{
					ActiveEffectHandlers.Remove(effectHandler);
				}
			}
			else if (ActiveEffectHandlers.Count == 1)
			{
				if (ActiveEffectHandlers[0] == null)
				{
					ActiveEffectHandlers.Clear();
				}
			}
			else if (ActiveEffectHandlers.Count > 1)
			{
				for (int i = 0; i < ActiveEffectHandlers.Count; i++)
				{
					if (ActiveEffectHandlers[i] == null)
					{
						ActiveEffectHandlers.RemoveAt(i);
					}
				}
			}
			PunSingleton<TileManager>.Instance.TrySetTileAvailable(this);
		}

		public bool GetEffectActive(Spell effectType)
		{
			if (Occupant != null && Occupant.Owner == null)
			{
				return true;
			}
			if (ActiveEffectHandlers.IsNullOrEmpty())
			{
				return false;
			}
			if (ActiveEffectHandlers.Count == 1)
			{
				return ActiveEffectHandlers[0].ConnectedSpell.IsType(effectType);
			}
			foreach (TileEffectBase activeEffectHandler in ActiveEffectHandlers)
			{
				if (activeEffectHandler.ConnectedSpell.IsType(effectType))
				{
					return true;
				}
			}
			return false;
		}

		public bool GetEffectEnabled(Tile_AreaEffect effect)
		{
			if (Occupant != null && Occupant.Owner == null)
			{
				return true;
			}
			if (ActiveEffectHandlers.Count == 1)
			{
				TileEffectBase tileEffectBase = ActiveEffectHandlers[0];
				if (tileEffectBase.ConnectedSpell != null)
				{
					switch (tileEffectBase.ConnectedSpell.Type)
					{
					case Spell.Spell_AcidCloud:
					case Spell.Spell_CurseOfTheUndead:
					case Spell.Spell_CerberusCollars:
					case Spell.Spell_SkullSpecter:
						return true;
					case Spell.Spell_StoneDemon:
					case Spell.Spell_Oxymora:
						return !effect.IsType(Spell.Spell_SoilSpikes) && !effect.IsType(Spell.Spell_PetrifyingPrison);
					case Spell.Spell_SoilSpikes:
					case Spell.Spell_PetrifyingPrison:
						return !effect.IsType(Spell.Spell_StoneDemon) && !effect.IsType(Spell.Spell_Oxymora);
					}
				}
				else if (tileEffectBase.IsSetToDestroy)
				{
					ActiveEffectHandlers.Clear();
					return false;
				}
			}
			else if (ActiveEffectHandlers.Count > 1)
			{
				return true;
			}
			return false;
		}

		public void SetTileMaterialColor(Color color)
		{
			Material[] tileMaterials = m_tileMaterials;
			foreach (Material material in tileMaterials)
			{
				material.SetColor("_Color", color);
			}
		}

		public void DestroyPickups()
		{
			if (!m_pickups.IsNullOrEmpty())
			{
				PickupBase[] array = m_pickups.ToArray();
				PickupBase[] array2 = array;
				foreach (PickupBase pickupBase in array2)
				{
					pickupBase.DestroyPickup();
				}
			}
		}

		public void AddPickup(PickupBase pickup)
		{
			if (!m_pickups.Contains(pickup))
			{
				m_pickups.Add(pickup);
			}
		}

		public void RemovePickup(PickupBase pickup)
		{
			if (m_pickups.Contains(pickup))
			{
				m_pickups.Remove(pickup);
			}
		}

		private void SetVFXActive(bool enable)
		{
			if (m_displayEffect.activeSelf == enable)
			{
				return;
			}
			m_displayEffect.SetActive(enable);
			if (enable)
			{
				for (int i = 0; i < m_particleSystems.Length; i++)
				{
					m_particleSystems[i].SetParticles(m_particles[i], m_numberOfActiveParticles[i]);
				}
			}
		}

		public void SetTileAreaEffectActive(bool enable)
		{
			if (m_outsideTileAreaEffect == null)
			{
				WandsLogger.LogError("Tile does not have outSideTileAreaEffect variable set");
			}
			else if (enable)
			{
				m_outsideTileAreaEffect.Play(withChildren: true);
			}
			else
			{
				m_outsideTileAreaEffect.Stop(withChildren: true);
			}
		}

		public void SetTilePropsActive()
		{
			if ((GameControl.Instance.Platform.Type & (PlatformType.Rift | PlatformType.Steam | PlatformType.Viveport | PlatformType.PlayStation)) == 0 && GameControl.Instance.PlatformSettings.ConnectionType != ConnectionType.Trailer)
			{
				MonoSingleton<TileControl>.Instance?.SetTilePropsActive(this);
			}
		}
	}
	[Serializable]
	public class DetailObjects
	{
		[SerializeField]
		public Transform m_detailTf;

		[SerializeField]
		public bool m_active;
	}
	public static class TileAreaController
	{
		private const float TileSize = 3f;

		private const float HalfTileSize = 1.5f;

		private const float HalfTileSizeSqr = 2.25f;

		public static bool IsInsideTileArea(Vector3 currentPosition, Tile currentTile)
		{
			Vector3 vector = currentPosition - currentTile.transform.position;
			vector.y = 0f;
			return vector.sqrMagnitude <= 2.25f;
		}

		public static Vector3 GetPositionInsideTileArea(Vector3 currentPosition, Vector3 tileCenter)
		{
			Vector3 result = currentPosition - tileCenter;
			result.y = 0f;
			result.Normalize();
			result *= 1.5f;
			result += tileCenter;
			result.y = currentPosition.y;
			return result;
		}
	}
	public class TileControl : MonoSingleton<TileControl>
	{
		[Serializable]
		public class TileTemplate
		{
			[SerializeField]
			public Tile m_tile;

			[SerializeField]
			public bool[] m_displayValues;
		}

		[HideInInspector]
		[SerializeField]
		public List<bool> m_detailObjectsToggle = new List<bool>();

		[HideInInspector]
		[SerializeField]
		public List<Transform> m_detailObjects = new List<Transform>();

		[SerializeField]
		public List<TileTemplate> m_tileTemplates = new List<TileTemplate>();

		public void SetAllPropsActive()
		{
			for (int i = 0; i < m_detailObjects.Count; i++)
			{
				if (m_detailObjects[i] != null)
				{
					m_detailObjects[i].gameObject.SetActive(value: true);
				}
			}
		}

		public void SetTilePropsActive(Tile tile)
		{
			if (m_detailObjects.IsNullOrEmpty() || m_tileTemplates.IsNullOrEmpty())
			{
				return;
			}
			bool[] values = new bool[m_detailObjects.Count];
			if (!CanGetDisplayValues(out values, tile))
			{
				return;
			}
			for (int i = 0; i < m_detailObjects.Count; i++)
			{
				if (!(m_detailObjects[i] == null))
				{
					m_detailObjects[i].gameObject.SetActive(values[i]);
				}
			}
		}

		private bool CanGetDisplayValues(out bool[] values, Tile tile)
		{
			values = new bool[m_detailObjects.Count];
			for (int i = 0; i < m_tileTemplates.Count; i++)
			{
				if (!(m_tileTemplates[i].m_tile != tile))
				{
					values = m_tileTemplates[i].m_displayValues;
					break;
				}
			}
			return values != null && values.Length > 0;
		}
	}
	[RequireComponent(typeof(PhotonView))]
	public class TileManager : PunSingleton<TileManager>
	{
		private const float TileRotationWaitTime = 0.25f;

		[SerializeField]
		private List<Tile> m_allTiles = new List<Tile>(16);

		private PlayerControl m_playerControl;

		private Material m_tileMaterial;

		private Transform m_tileParent;

		private EventToken m_matchEndedEventToken;

		private EventToken m_spellSelectedEventToken;

		private EventToken m_playerControlSpawnedEventToken;

		private EventToken m_photonPlayerConnectedEventToken;

		private EventToken m_countdownEndedEventToken;

		private EventToken m_photonPlayerDisconnectedEventToken;

		private Dictionary<int, Action<Tile, bool>> m_tileActionCallbacks = new Dictionary<int, Action<Tile, bool>>();

		private List<Tile> m_randomTileList = new List<Tile>(32);

		public IReadOnlyList<Tile> AllTiles
		{
			[CompilerGenerated]
			get
			{
				return m_allTiles;
			}
		}

		public bool HasFreeTilesAvailable
		{
			[CompilerGenerated]
			get
			{
				return AllTiles.Any((Tile x) => x.IsUnoccupied);
			}
		}

		public Transform TileParent
		{
			[CompilerGenerated]
			get
			{
				return (!(m_tileParent == null)) ? m_tileParent : (m_tileParent = MonoSingleton<TileControl>.Instance?.transform);
			}
		}

		public event Action<Tile> OnTileOccupied;

		private void OnEnable()
		{
			m_photonPlayerConnectedEventToken = EventHub.Subscribe<NetworkEvents.PhotonPlayerConnectedEvent>(OnPhotonPlayerConnected);
			m_countdownEndedEventToken = EventHub.Subscribe<Events.CountdownEndedEvent>(OnCountdownEnded);
			m_matchEndedEventToken = EventHub.Subscribe<Events.MatchEndedEvent>(OnMatchEnded);
			m_spellSelectedEventToken = EventHub.Subscribe<Events.SpellSelectedEvent>(OnSpellSelected);
			m_photonPlayerDisconnectedEventToken = EventHub.Subscribe<NetworkEvents.PhotonPlayerDisconnectedEvent>(OnPhotonPlayerDisconnected);
			m_playerControlSpawnedEventToken = EventHub.Subscribe<Events.PlayerControlSpawnedEvent>(OnPlayerControlSpawned);
		}

		protected override void OnDisable()
		{
			base.OnDisable();
			StopAllCoroutines();
			SetTileMaterialColor(Colors.TileColor);
			EventHub.Unsubscribe<NetworkEvents.PhotonPlayerConnectedEvent>(m_photonPlayerConnectedEventToken);
			EventHub.Unsubscribe<Events.CountdownEndedEvent>(m_countdownEndedEventToken);
			EventHub.Unsubscribe<Events.MatchEndedEvent>(m_matchEndedEventToken);
			EventHub.Unsubscribe<Events.SpellSelectedEvent>(m_spellSelectedEventToken);
			EventHub.Unsubscribe<NetworkEvents.PhotonPlayerDisconnectedEvent>(m_photonPlayerDisconnectedEventToken);
			EventHub.Unsubscribe<Events.PlayerControlSpawnedEvent>(m_playerControlSpawnedEventToken);
		}

		private void Start()
		{
			m_tileMaterial = AllTiles[0].DisplayEffect.transform.GetChild(0).GetComponent<Renderer>().sharedMaterial;
		}

		private void OnPlayerControlSpawned(Events.PlayerControlSpawnedEvent eventData)
		{
			m_playerControl = GameControl.Instance.PlayerControl;
		}

		private void OnCountdownEnded(Events.CountdownEndedEvent eventData)
		{
			OnMatchStarted();
		}

		private void OnMatchEnded(Events.MatchEndedEvent eventData)
		{
			UploadTileStatistics();
		}

		private void OnSpellSelected(Events.SpellSelectedEvent eventData)
		{
			TrySetAllTilesAvailable(eventData.Spell);
		}

		private void OnPhotonPlayerConnected(NetworkEvents.PhotonPlayerConnectedEvent eventData)
		{
			StartCoroutine(PhotonPlayerConnected());
		}

		private IEnumerator PhotonPlayerConnected()
		{
			if (!PhotonNetwork.IsMasterClient)
			{
				yield break;
			}
			Tile startTile = GetStartTile(1);
			if (startTile.IsOccupied)
			{
				if (startTile.OccupantWielder != null || m_playerControl.GetCurrentTile() == startTile)
				{
					m_playerControl.ResetPosition(PunSingleton<SceneControl>.Instance.CurrentMatchType);
				}
				else if (startTile.ActiveEffectHandlers.Count > 0)
				{
					for (int i = 0; i < startTile.ActiveEffectHandlers.Count; i++)
					{
						startTile.ActiveEffectHandlers[i].DisableObject();
					}
				}
			}
			Wielder opponent = null;
			bool? flag = PlayerManager.Instance?.CanGetOpponentWielder(out opponent);
			if (flag.HasValue && flag.Value)
			{
				OccupyTile(startTile, TileOccupyState.Occupied, opponent.photonView);
			}
			else
			{
				OccupyTile(startTile, TileOccupyState.Occupied);
			}
			if (m_playerControl != null)
			{
				while (m_playerControl.Wielder == null)
				{
					yield return null;
				}
				OccupyTile(m_playerControl.GetCurrentTile(), TileOccupyState.Occupied, m_playerControl.Wielder.photonView, null, buffered: true);
			}
		}

		private void OnPhotonPlayerDisconnected(NetworkEvents.PhotonPlayerDisconnectedEvent eventData)
		{
			PhotonPlayerDisconnected(eventData.PhotonPlayer);
		}

		private void PhotonPlayerDisconnected(Photon.Realtime.Player otherPlayer)
		{
			if (otherPlayer != null && GameControl.Instance.IsCurrentLevel(Level.Lobby))
			{
				UpdateLobbyTile(GetStartTile(0));
			}
		}

		private void UploadTileStatistics()
		{
			if (AllTiles.IsNullOrEmpty())
			{
				return;
			}
			Dictionary<string, object> dictionary = new Dictionary<string, object>();
			for (int i = 0; i < AllTiles.Count; i++)
			{
				Tile tile = AllTiles[i];
				if (!dictionary.ContainsKey(tile.ToString()))
				{
					dictionary.Add(tile.ToString(), tile.TimesUsed);
				}
			}
		}

		public void HideTeleportBeacons()
		{
			if (AllTiles.IsNullOrEmpty() || ExpandedSingleton<LevelLoader>.Instance.IsLoadingLevel)
			{
				return;
			}
			for (int i = 0; i < AllTiles.Count; i++)
			{
				Tile tile = AllTiles[i];
				if (tile != null)
				{
					tile.SetTeleportActive(enable: false);
				}
			}
		}

		public void SetTileMaterialColor(Color color)
		{
			if (m_tileMaterial != null)
			{
				m_tileMaterial.SetColor("_Color", color);
			}
		}

		public Tile GetRandomTile(HashSet<Tile> excludeTiles, bool avoidElevatorTiles, bool tryAvoidActivEffects)
		{
			return (!HasFreeTilesAvailable) ? null : GetRandomTileInternal(excludeTiles, avoidElevatorTiles, tryAvoidActivEffects);
		}

		private Tile GetRandomTileInternal(HashSet<Tile> excludeTiles, bool avoidElevatorTiles, bool tryAvoidActiveEffects)
		{
			m_randomTileList.Clear();
			Tile tile = null;
			for (int i = 0; i < AllTiles.Count; i++)
			{
				Tile tile2 = AllTiles[i];
				if (tile2.IsUnoccupied && (excludeTiles == null || !excludeTiles.Contains(tile2)) && (!avoidElevatorTiles || !tile2.IsElevatorTile))
				{
					tile = tile2;
					if (!tryAvoidActiveEffects || !tile2.IsEffectActive)
					{
						m_randomTileList.Add(tile2);
					}
				}
			}
			return (m_randomTileList.Count <= 0) ? tile : m_randomTileList.GetRandomElement();
		}

		private void VerifyTileConnections()
		{
			bool? flag = PlayerManager.Instance?.AllWielders.IsNullOrEmpty();
			if (!flag.HasValue || flag.Value)
			{
				return;
			}
			for (int i = 0; i < PlayerManager.Instance.AllWielders.Count; i++)
			{
				Wielder wielder = PlayerManager.Instance.AllWielders[i];
				if (!(wielder == null))
				{
					wielder.CurrentTile?.Occupy(TileOccupyState.Occupied, wielder.photonView, PunSingleton<TimeManager>.Instance.CurrentRoomTime);
				}
			}
		}

		public Tile GetStartTile(int index)
		{
			index = Mathf.Clamp(index, 0, 1);
			return AllTiles[index];
		}

		public bool CompareStartTile(Tile tile)
		{
			return AllTiles[0] == tile || AllTiles[1] == tile;
		}

		public void OnMatchStarted()
		{
			if (m_playerControl == null || m_playerControl.Wand == null)
			{
				return;
			}
			for (int i = 0; i < m_playerControl.Wand.WandCount; i++)
			{
				WandHand wandHand = (WandHand)i;
				SpellBase activeSpell = m_playerControl.Wand.GetWandControl().ActiveSpell;
				for (int j = 0; j < AllTiles.Count; j++)
				{
					SetTileAvailable(AllTiles[j], activeSpell, wandHand);
				}
			}
		}

		public void TrySetAllTilesAvailable(SpellBase spell)
		{
			if (spell == null)
			{
				WandsLogger.LogError("Tried updating available tiles with null spell.");
			}
			else if (AllTiles.IsNullOrEmpty())
			{
				WandsLogger.LogError("TileManager doesn't have any connected tiles.");
			}
			else
			{
				if (m_playerControl == null || m_playerControl.Wand == null || m_playerControl.IsInputLocked)
				{
					return;
				}
				bool? flag = PunSingleton<SceneControl>.Instance?.GameOver;
				if (flag.HasValue && !flag.Value)
				{
					for (int i = 0; i < AllTiles.Count; i++)
					{
						SetTileAvailable(AllTiles[i], spell, spell.WandHand);
					}
				}
			}
		}

		public void TrySetTileAvailable(Tile tile)
		{
			if (m_playerControl == null || m_playerControl.Wand == null || m_playerControl.IsInputLocked)
			{
				return;
			}
			bool? flag = PunSingleton<SceneControl>.Instance?.GameOver;
			if (flag.HasValue && !flag.Value)
			{
				SetTileAvailable(tile, m_playerControl.Wand.GetActiveSpell(WandHand.Right), WandHand.Right);
				if (m_playerControl.IsDualWielding)
				{
					SetTileAvailable(tile, m_playerControl.Wand.GetActiveSpell(WandHand.Left), WandHand.Left);
				}
			}
		}

		private void SetTileAvailable(Tile tile, SpellBase spell, WandHand wandHand)
		{
			if (!m_playerControl.IsDualWielding)
			{
				bool flag = ShouldToggle(tile, m_playerControl.Wand.GetActiveSpell());
				tile.SetHighlighted(flag && m_playerControl.Wand.IsTileHighlighted(wandHand, tile));
				tile.SetTeleportActive(flag);
				return;
			}
			tile.SetHighlighted(m_playerControl.Wand.IsTileHighlighted(wandHand, tile));
			if (ShouldToggle(tile, spell))
			{
				tile.AddTeleportActive(wandHand);
			}
			else
			{
				tile.RemoveTeleportActive(wandHand);
			}
		}

		private bool ShouldToggle(Tile tile, SpellBase spell)
		{
			if (spell == null)
			{
				return false;
			}
			if (spell.IsType(Spell.Spell_Teleport))
			{
				return tile.IsUnoccupied;
			}
			if (m_playerControl.GetCurrentTile() == tile)
			{
				return false;
			}
			if (spell is SpellBase_Summon)
			{
				return tile.IsUnoccupied && !tile.GetEffectEnabled(spell as Tile_AreaEffect);
			}
			if (spell is Tile_AreaEffect)
			{
				return !tile.GetEffectEnabled(spell as Tile_AreaEffect);
			}
			if (spell is ITileSpell)
			{
				return !spell.IsType(Spell.Spell_ChaosLeap);
			}
			return false;
		}

		public void SetTilesUnavailable()
		{
			if (!AllTiles.IsNullOrEmpty())
			{
				for (int i = 0; i < AllTiles.Count; i++)
				{
					Tile tile = AllTiles[i];
					tile.SetHighlighted(enable: false);
					tile.SetTeleportActive(enable: false);
				}
			}
		}

		public void SetTilesUnavailable(WandHand wandHand)
		{
			if (!AllTiles.IsNullOrEmpty())
			{
				for (int i = 0; i < AllTiles.Count; i++)
				{
					Tile tile = AllTiles[i];
					tile.SetHighlighted(enable: false);
					tile.RemoveTeleportActive(wandHand);
				}
			}
		}

		public void OccupyTile(Tile tile, TileOccupyState occupyState, PhotonView occupant = null, Action<Tile, bool> onOccupyDone = null, bool buffered = false, bool forced = false)
		{
			if (tile == null)
			{
				WandsLogger.LogError("Trying to occupy tile null");
				return;
			}
			int i = tile.photonView.ViewID;
			if (occupyState != 0 && onOccupyDone != null)
			{
				for (; m_tileActionCallbacks.ContainsKey(i); i += 10000)
				{
				}
				m_tileActionCallbacks.Add(i, onOccupyDone);
			}
			float num = 0f;
			if (PunSingleton<TimeManager>.Instance != null)
			{
				num = PunSingleton<TimeManager>.Instance.CurrentRoomTime;
			}
			switch (occupyState)
			{
			case TileOccupyState.Unoccupied:
				tile.Unoccupy(forced);
				break;
			case TileOccupyState.Occupied:
				if (forced)
				{
					forced = tile.Occupant.Owner == occupant.Owner;
				}
				tile.Occupy(occupyState, occupant, num);
				break;
			case TileOccupyState.Locked:
				tile.Occupy(occupyState, occupant, num);
				break;
			}
			if (NetworkUtils.ConnectedToGame && PlayerManager.Instance.IsGameFull && MonoSingleton<NetworkManager>.Instance.CurrentMatchType.ContainsFlag(MatchType.MultiPlayer))
			{
				RpcTarget target = ((!buffered) ? RpcTarget.Others : RpcTarget.OthersBuffered);
				PhotonView obj = base.photonView;
				object[] obj2 = new object[5]
				{
					i,
					(int)occupyState,
					num,
					null,
					null
				};
				int? num2 = occupant?.ViewID;
				obj2[3] = ((!num2.HasValue) ? (-1) : num2.Value);
				obj2[4] = forced;
				obj.RPC("PunOccupyTile", target, obj2);
			}
			else
			{
				int tileView = i;
				float timeOccupied = num;
				int? num3 = occupant?.ViewID;
				PunOccupyTileResponse(tileView, successfullyOccupied: true, (int)occupyState, timeOccupied, (!num3.HasValue) ? (-1) : num3.Value);
			}
		}

		[PunRPC]
		private void PunOccupyTile(int tileView, int occupyStateIndex, float timeOccupied, int occupantView, bool forced)
		{
			Tile tile = PhotonView.Find(tileView % 10000)?.GetComponent<Tile>();
			if (tile == null)
			{
				WandsLogger.LogError("PunOccupyTile | tile is null");
				return;
			}
			if (m_playerControl != null && !forced && !tile.IsUnoccupied && occupyStateIndex != 0)
			{
				bool flag = tile.TimeOccupied.AlmostEquals(timeOccupied, 0.016f);
				if ((flag && !m_playerControl.Wielder.photonView.Owner.IsMasterClient) || (!flag && tile.TimeOccupied > timeOccupied))
				{
					PhotonView obj = base.photonView;
					object[] obj2 = new object[5] { tileView, false, occupyStateIndex, timeOccupied, null };
					int? num = tile.Occupant?.ViewID;
					obj2[4] = ((!num.HasValue) ? (-1) : num.Value);
					obj.RPC("PunOccupyTileResponse", RpcTarget.Others, obj2);
					return;
				}
			}
			if (occupyStateIndex == 0)
			{
				tile.Unoccupy(forced);
			}
			else
			{
				tile.Occupy((TileOccupyState)occupyStateIndex, PhotonView.Find(occupantView), timeOccupied);
				if (this.OnTileOccupied != null)
				{
					this.OnTileOccupied(tile);
				}
			}
			base.photonView.RPC("PunOccupyTileResponse", RpcTarget.Others, tileView, true, occupyStateIndex, timeOccupied, occupantView);
		}

		[PunRPC]
		private void PunOccupyTileResponse(int tileView, bool successfullyOccupied, int occupyStateIndex, float timeOccupied, int occupantView)
		{
			Tile tile = PhotonView.Find(tileView % 10000)?.GetComponent<Tile>();
			if (tile == null)
			{
				WandsLogger.LogError("PunOccupyTileResponse | tile is null");
				return;
			}
			if (this.OnTileOccupied != null && successfullyOccupied)
			{
				this.OnTileOccupied(tile);
			}
			if (m_tileActionCallbacks.ContainsKey(tileView))
			{
				Action<Tile, bool> action = m_tileActionCallbacks[tileView];
				m_tileActionCallbacks.Remove(tileView);
				if (occupyStateIndex != 0 && !successfullyOccupied)
				{
					tile.Occupy((TileOccupyState)occupyStateIndex, PhotonView.Find(occupantView), timeOccupied);
					action?.Invoke(tile, arg2: false);
				}
				else
				{
					action?.Invoke(tile, successfullyOccupied);
				}
			}
		}

		public void UpdateLobbyTile(Tile tile)
		{
			if (!(m_playerControl == null) && !(m_playerControl.GetCurrentTile() == tile))
			{
				m_playerControl.SetCurrentTile(tile);
				OccupyTile(tile, TileOccupyState.Occupied, m_playerControl.Wielder.photonView);
				UpdateLobbyTile(tile.transform);
			}
		}

		public void UpdateLobbyTile(Transform tileTransform)
		{
			if (ExpandedSingleton<FadeHandler>.Instance.IsFaded)
			{
				m_playerControl.MatchTileRotation(tileTransform);
			}
			else
			{
				StartCoroutine(MatchPlayerToTileRotation(tileTransform));
			}
		}

		private IEnumerator MatchPlayerToTileRotation(Transform tileTransform)
		{
			m_playerControl.ToggleInputActive(active: false);
			yield return ExpandedSingleton<FadeHandler>.Instance.FadeOutWithReturn(0.25f, Color.black, forceFade: false).WaitForCompletion();
			m_playerControl.MatchTileRotation(tileTransform);
			yield return ExpandedSingleton<FadeHandler>.Instance.FadeInWithReturn(0.25f).WaitForCompletion();
			m_playerControl.ToggleInputActive(active: true);
		}
	}
}
namespace Assets.Scripts
{
	[RequireComponent(typeof(PhotonView))]
	public class TimeManager : PunSingleton<TimeManager>
	{
		private const float MinTimeThreashold = 0.0001f;

		private double? m_roomStartTime;

		private double? m_matchStartTime;

		private float? m_offlineMatchStartTime;

		private float m_accumulatedPauseTime;

		public float MatchLength { get; private set; }

		public float MatchLengthWithoutSudden { get; private set; }

		public float CurrentRoomTime
		{
			[CompilerGenerated]
			get
			{
				return (!PhotonNetwork.InRoom || !m_roomStartTime.HasValue) ? Time.time : ((float)(PhotonNetwork.Time - m_roomStartTime.Value));
			}
		}

		public float CurrentMatchTime
		{
			get
			{
				if (PhotonNetwork.InRoom && m_matchStartTime.HasValue)
				{
					return (float)(PhotonNetwork.Time - m_matchStartTime.Value) - m_accumulatedPauseTime;
				}
				if (m_offlineMatchStartTime.HasValue)
				{
					return Time.time - m_offlineMatchStartTime.Value - m_accumulatedPauseTime;
				}
				return 0f;
			}
		}

		public double CurrentMatchTimeRaw
		{
			[CompilerGenerated]
			get
			{
				return (!PhotonNetwork.InRoom || !m_matchStartTime.HasValue) ? 0.0 : (PhotonNetwork.Time - m_matchStartTime.Value);
			}
		}

		public bool IsRoomTimeSet
		{
			[CompilerGenerated]
			get
			{
				return m_roomStartTime.HasValue;
			}
		}

		protected override void OnDisable()
		{
			base.OnDisable();
			StopAllCoroutines();
		}

		private void Start()
		{
			Level currentLevel = GameControl.Instance.GetCurrentLevel(callBeforeLevelLoaded: true);
			if (currentLevel != 0 && currentLevel != Level.MainMenu && currentLevel != Level.Workshop)
			{
				MatchLength = 210f;
				MatchLengthWithoutSudden = MatchLength - 60f;
				ResetRoomTime();
			}
		}

		public float GetMatchEndTime()
		{
			return (float)RoomProperty.GetRoomProperty("L1");
		}

		public void SetMatchEndTime()
		{
			RoomProperty.SetRoomProperty("L1", CurrentMatchTime);
			RoomProperty.SetRoomProperty("L2", double.MinValue);
			m_matchStartTime = null;
		}

		private void ResetRoomTime()
		{
			StopAllCoroutines();
			if (PhotonNetwork.InRoom && PhotonNetwork.CurrentRoom.CustomProperties.ContainsKey("L3"))
			{
				m_roomStartTime = (double)PhotonNetwork.CurrentRoom.CustomProperties["L3"];
			}
			else if (PhotonNetwork.IsMasterClient)
			{
				StartCoroutine(ResetRoomTimeMaster());
			}
			else
			{
				StartCoroutine(ResetRoomTimeClient());
			}
		}

		private IEnumerator ResetRoomTimeMaster()
		{
			while (!PhotonNetwork.InRoom)
			{
				yield return null;
			}
			if (PhotonNetwork.Time > 9.999999747378752E-05)
			{
				m_roomStartTime = PhotonNetwork.Time;
				ExitGames.Client.Photon.Hashtable hashtable = new ExitGames.Client.Photon.Hashtable();
				hashtable.Add("L3", m_roomStartTime);
				ExitGames.Client.Photon.Hashtable propertiesToSet = hashtable;
				PhotonNetwork.CurrentRoom.SetCustomProperties(propertiesToSet);
			}
		}

		private IEnumerator ResetRoomTimeClient()
		{
			while (!PhotonNetwork.InRoom || !PhotonNetwork.CurrentRoom.CustomProperties.ContainsKey("L3"))
			{
				yield return null;
			}
			m_roomStartTime = (double)PhotonNetwork.CurrentRoom.CustomProperties["L3"];
		}

		public void ResetMatchTime()
		{
			m_accumulatedPauseTime = 0f;
			m_offlineMatchStartTime = Time.time;
			if (NetworkUtils.ConnectedToGame && PhotonNetwork.IsMasterClient)
			{
				m_matchStartTime = PhotonNetwork.Time;
				RoomProperty.SetRoomProperty("L2", m_matchStartTime);
				base.photonView.RPC("PunSyncMatchTime", RpcTarget.OthersBuffered, m_matchStartTime);
			}
		}

		[PunRPC]
		private void PunSyncMatchTime(double matchStartTime)
		{
			m_matchStartTime = matchStartTime;
		}

		public void UpdatePauseTime(float pauseTime)
		{
			m_accumulatedPauseTime = Mathf.Max(m_accumulatedPauseTime + pauseTime, 0f);
			CurrentMatchTime.ToString();
		}
	}
}
namespace Assets.Scripts.UI
{
	public class ArenaMenu : MonoBehaviour
	{
		[SerializeField]
		private GameObject m_menuParent;

		[SerializeField]
		private GameObject m_optionsParent;

		[SerializeField]
		private GameObject m_reportMenuParent;

		[SerializeField]
		private GameObject m_reportButtonParent;

		[SerializeField]
		private GameObject m_rotatingRingsParent;

		[SerializeField]
		private InteractableButton m_resumeBtn;

		[SerializeField]
		private GameObject m_opponentNameContainer;

		[SerializeField]
		private TextMeshPro m_opponentNameText;

		private bool m_hasValidOpponentToDisplayName;

		private EventToken m_matchEndedEventToken;

		public bool IsMenuActive
		{
			[CompilerGenerated]
			get
			{
				return m_menuParent.activeSelf || m_optionsParent.activeSelf || m_reportMenuParent.activeSelf;
			}
		}

		public bool IsOptionsActive
		{
			[CompilerGenerated]
			get
			{
				return m_optionsParent.gameObject.activeSelf;
			}
		}

		public bool IsReportMenuActive
		{
			[CompilerGenerated]
			get
			{
				return m_reportMenuParent.activeSelf;
			}
		}

		private void Start()
		{
			m_hasValidOpponentToDisplayName = false;
			m_opponentNameContainer.SetActive(value: false);
			m_opponentNameText.text = string.Empty;
			if (!MonoSingleton<NetworkManager>.Instance.CurrentMatchType.ContainsFlag(MatchType.Matchmade | MatchType.Public))
			{
				m_reportButtonParent.SetActive(value: false);
			}
			ToggleMenu(enable: false);
		}

		private void OnEnable()
		{
			m_matchEndedEventToken = EventHub.Subscribe<Events.MatchEndedEvent>(OnMatchEnded);
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe<Events.MatchEndedEvent>(m_matchEndedEventToken);
		}

		private void OnMatchEnded(Events.MatchEndedEvent eventData)
		{
			OnMatchEnd();
		}

		private void OnMatchEnd()
		{
			m_resumeBtn.LockInteraction(locked: false);
		}

		public void ResetPosition()
		{
			if (!PlayerManager.Instance.PlayerControl.IsTeleporting)
			{
				PlayerAim aim = PlayerManager.Instance.PlayerControl.Input.GetAim();
				if (aim != null)
				{
					base.transform.SetPositionAndRotation(aim.GetForwardPoint(), Quaternion.LookRotation(aim.CameraRotationRay.direction));
				}
			}
		}

		private void UpdatePositionAndRotation(Vector3 position, Quaternion rotation)
		{
			base.transform.position = position;
			base.transform.rotation = rotation;
		}

		public void ToggleMenu(bool enable)
		{
			m_menuParent.SetActive(enable);
			m_optionsParent.SetActive(value: false);
			m_reportMenuParent.SetActive(value: false);
			m_rotatingRingsParent.SetActive(enable);
			if (m_hasValidOpponentToDisplayName)
			{
				m_opponentNameContainer.SetActive(enable);
			}
			Canvas.ForceUpdateCanvases();
			if (enable)
			{
				ResetPosition();
			}
		}

		public void ToggleOptions(bool active)
		{
			m_menuParent.SetActive(!active);
			m_optionsParent.SetActive(active);
			if (active)
			{
				m_rotatingRingsParent.SetActive(value: true);
			}
		}

		public void ToggleReporting(bool active)
		{
			m_menuParent.SetActive(!active);
			m_reportMenuParent.SetActive(active);
			if (active)
			{
				m_rotatingRingsParent.SetActive(value: true);
			}
		}
	}
	public class ArenaUI : MonoSingleton<ArenaUI>
	{
		[SerializeField]
		private Color m_hudColor = Color.white;

		[SerializeField]
		private ArenaMenu m_menu;

		[Header("Notification")]
		[SerializeField]
		private Transform m_notificationParent;

		[SerializeField]
		private Localize m_notificationLocalize;

		[SerializeField]
		private LocalizationParamsManager m_notificationParams;

		[SerializeField]
		private LocalizationParamsManager m_pauseParams;

		private bool m_isUpdateBlocked;

		private PlayerControl m_playerControl;

		private Quaternion m_startRotation;

		private Vector3 m_trackPosition;

		private Coroutine m_notificationCoroutine;

		private List<TextMeshPro> m_textComponents;

		private EventToken m_playerControlSpawnedEventToken;

		private EventToken m_matchEndedEventToken;

		private EventToken m_matchResetEventToken;

		private EventToken m_countdownEndedEventToken;

		private EventToken m_countdownStartedEventToken;

		private EventToken m_countdownTimeUpdatedEventToken;

		private EventToken m_matchPausedEventToken;

		private const float ReturnToLobbyDelay = 3f;

		private const float ReturnToWorkshopDelay = 5f;

		private const string ConnectionClientTerm = "HUD/EndState/ConnectionClientMsg";

		private const string ConnectionServerTerm = "HUD/EndState/ConnectionServerMsg";

		private const string ReturnToWorkshopTerm = "HUD/Notification/Status/Leaving";

		private const string PauseLostTerm = "HUD/EndState/Pause";

		private const string LostTerm = "HUD/EndState/Lost";

		private const string WinTerm = "HUD/EndState/Won";

		private const string WinLoseTerm = "HUD/EndState/WinLoseMsg";

		private const string DrawTerm = "HUD/EndState/DrawMsg";

		private const string OpponentFoundTerm = "HUD/EndState/OpponentFound";

		private const string MatchStartsInTerm = "HUD/Notification/CountdownEnd";

		public bool IsEndMenuActive { get; private set; }

		public bool IsNotificationActive
		{
			[CompilerGenerated]
			get
			{
				return m_notificationParent.gameObject.activeSelf && !IsEndMenuActive;
			}
		}

		public EndState State { get; private set; } = EndState.Close;


		public ArenaMenu Menu
		{
			[CompilerGenerated]
			get
			{
				return (!(m_menu != null)) ? (m_menu = GetComponentInChildren<ArenaMenu>()) : m_menu;
			}
		}

		public bool GetAnyMenuOpen()
		{
			return Menu.IsMenuActive || IsEndMenuActive;
		}

		private void OnEnable()
		{
			m_playerControlSpawnedEventToken = EventHub.Subscribe<Events.PlayerControlSpawnedEvent>(OnPlayerControlSpawned);
			m_countdownEndedEventToken = EventHub.Subscribe<Events.CountdownEndedEvent>(OnCountdownEnded);
			m_countdownStartedEventToken = EventHub.Subscribe<Events.CountdownStartedEvent>(OnCountdownStarted);
			m_countdownTimeUpdatedEventToken = EventHub.Subscribe<Events.CountdownTimeUpdatedEvent>(OnCountdownTimeUpdated);
			m_matchPausedEventToken = EventHub.Subscribe<Events.MatchPausedEvent>(OnMatchPaused);
		}

		protected override void OnDisable()
		{
			base.OnDisable();
			StopAllCoroutines();
			if (m_playerControlSpawnedEventToken != null)
			{
				EventHub.Unsubscribe<Events.PlayerControlSpawnedEvent>(m_playerControlSpawnedEventToken);
			}
			if (m_countdownEndedEventToken != null)
			{
				EventHub.Unsubscribe<Events.CountdownEndedEvent>(m_countdownEndedEventToken);
			}
			EventHub.Unsubscribe<Events.CountdownStartedEvent>(m_countdownStartedEventToken);
			EventHub.Unsubscribe<Events.CountdownTimeUpdatedEvent>(m_countdownTimeUpdatedEventToken);
			EventHub.Unsubscribe<Events.MatchPausedEvent>(m_matchPausedEventToken);
		}

		private void OnDestroy()
		{
			EventHub.Unsubscribe<Events.MatchEndedEvent>(m_matchEndedEventToken);
			EventHub.Unsubscribe<Events.MatchResetEvent>(m_matchResetEventToken);
		}

		protected override void Awake()
		{
			base.Awake();
			m_trackPosition = base.transform.position;
			m_startRotation = base.transform.rotation;
			m_notificationParent.gameObject.SetActive(value: false);
		}

		private void Start()
		{
			m_matchEndedEventToken = EventHub.Subscribe<Events.MatchEndedEvent>(OnMatchEnded);
			m_matchResetEventToken = EventHub.Subscribe<Events.MatchResetEvent>(OnMatchReset);
			SetEndMenuActive(enable: false);
			ResetColor();
		}

		private void LateUpdate()
		{
			if (!m_isUpdateBlocked)
			{
				bool? flag = m_playerControl.GetCurrentTile()?.IsElevatorTile;
				if (flag.HasValue && flag.Value)
				{
					SetTrackPosition(m_playerControl.GetCurrentTile().transform.position);
				}
				base.transform.position = m_trackPosition;
				base.transform.rotation = m_startRotation;
			}
		}

		private void OnPlayerControlSpawned(Events.PlayerControlSpawnedEvent eventData)
		{
			PlayerControlSpawned(eventData.PlayerControl);
		}

		private void OnMatchReset(Events.MatchResetEvent eventData)
		{
			m_isUpdateBlocked = false;
		}

		private void OnMatchEnded(Events.MatchEndedEvent eventData)
		{
			m_isUpdateBlocked = true;
			ResetHUD();
		}

		private void OnCountdownEnded(Events.CountdownEndedEvent eventData)
		{
			CountdownEnded();
		}

		private void OnCountdownStarted(Events.CountdownStartedEvent eventData)
		{
			m_notificationParams.SetParameterValue("TIMER", Mathf.RoundToInt(5f).ToString());
			DisplayCountdown();
		}

		private void OnCountdownTimeUpdated(Events.CountdownTimeUpdatedEvent eventData)
		{
			m_notificationParams.SetParameterValue("TIMER", Mathf.RoundToInt(eventData.Time).ToString());
		}

		private void OnMatchPaused(Events.MatchPausedEvent eventData)
		{
			if (!eventData.IsPaused && !PunSingleton<SceneControl>.Instance.GetMatchStartedOrSoloExperience())
			{
				DisplayCountdown();
				SetPauseInfoActive(active: true, eventData.PausesLeft);
			}
		}

		private void DisplayCountdown()
		{
			ResetHUD();
			ResetNotification();
			SetNotificationActive("HUD/Notification/CountdownEnd");
		}

		private void PlayerControlSpawned(PlayerControl playerControl)
		{
			m_playerControl = playerControl;
			EventHub.Unsubscribe<Events.PlayerControlSpawnedEvent>(m_playerControlSpawnedEventToken);
			m_playerControlSpawnedEventToken = null;
		}

		private void CountdownEnded()
		{
			DisableNotification(force: true);
			EventHub.Unsubscribe<Events.CountdownEndedEvent>(m_countdownEndedEventToken);
			m_countdownEndedEventToken = null;
		}

		public string GetNotificationTerm()
		{
			return m_notificationLocalize.Term;
		}

		public void ResetColor()
		{
			if (m_textComponents.IsNullOrEmpty())
			{
				m_textComponents = new List<TextMeshPro>();
				m_textComponents.AddRange(GetComponentsInChildren<TextMeshPro>());
			}
			foreach (TextMeshPro textComponent in m_textComponents)
			{
				textComponent.color = m_hudColor;
			}
		}

		public void SetTrackPosition(Vector3 position)
		{
			m_trackPosition = position;
		}

		public void ResetHUD()
		{
			ToggleMenuActive(enable: false);
			SetEndMenuActive(enable: false);
		}

		public void SetPauseInfoActive(bool active, int pauseCount = 0)
		{
			if (!(m_pauseParams == null))
			{
				if (active)
				{
					m_pauseParams.SetParameterValue("PAUSE_COUNT", pauseCount.ToString());
				}
				m_pauseParams.gameObject.SetActive(active);
			}
		}

		public void DisableNotification(bool force = false)
		{
			if ((!PunSingleton<SceneControl>.Instance.CountdownHandler.IsCountdownActive && !(bool)RoomProperty.GetRoomProperty("C5")) || force)
			{
				if (m_notificationCoroutine != null)
				{
					StopCoroutine(m_notificationCoroutine);
					m_notificationCoroutine = null;
				}
				ResetNotification();
			}
		}

		public void ShowNotification(string term, string paramName, string paramValue, float time, float delay = 0.01f)
		{
			if (!IsEndMenuActive)
			{
				if (m_notificationCoroutine != null)
				{
					StopCoroutine(m_notificationCoroutine);
					m_notificationCoroutine = null;
				}
				if (!string.IsNullOrEmpty(paramName))
				{
					m_notificationParams.SetParameterValue(paramName, paramValue);
				}
				SetNotificationTerm(null);
				ToggleMenuActive(enable: false);
				if (time >= 0f)
				{
					m_notificationCoroutine = StartCoroutine(ActivateNotification(term, time, delay));
				}
				else
				{
					SetNotificationActive(term);
				}
			}
		}

		public void SetNotificationTerm(string term)
		{
			m_notificationLocalize.SetTerm(term);
		}

		public void UpdateNotificationMessage(string paramsName, string parameter, bool keepActive)
		{
			if (!IsEndMenuActive)
			{
				m_notificationParams.SetParameterValue(paramsName, parameter);
				if (keepActive)
				{
					SetNotificationActive(enable: true);
				}
			}
		}

		public void UpdateNotificationTransform(PlayerControl playerControl)
		{
			Vector3 forwardPoint = playerControl.Input.GetAim().GetForwardPoint(1.2f, 1.5f);
			Quaternion rot = Quaternion.LookRotation(forwardPoint - playerControl.CameraTransform.position);
			UpdateNotificationTransform(forwardPoint, rot);
		}

		public void UpdateNotificationTransform(Vector3 pos, Quaternion rot)
		{
			m_notificationParent.position = pos;
			m_notificationParent.rotation = rot;
		}

		private IEnumerator ActivateNotification(string term, float time, float delay)
		{
			yield return new WaitForSeconds(delay);
			SetNotificationActive(term);
			yield return new WaitForSeconds(time);
			ResetNotification();
			m_notificationCoroutine = null;
		}

		private void SetNotificationActive(string term)
		{
			SetNotificationActive(enable: true);
			SetNotificationTerm(term);
			Vector3 forwardPoint = m_playerControl.Input.GetAim().GetForwardPoint(1.2f, 1.5f);
			Quaternion quaternion = Quaternion.LookRotation(forwardPoint - m_playerControl.CameraTransform.position);
			m_notificationParent.position = forwardPoint;
			m_notificationParent.rotation = quaternion;
			UpdateNotificationTransform(forwardPoint, quaternion);
		}

		public void SetNotificationActive(bool enable)
		{
			m_notificationParent.gameObject.SetActive(enable);
		}

		private void ResetNotification()
		{
			SetNotificationActive(enable: false);
			SetNotificationTerm(null);
			SetPauseInfoActive(active: false);
		}

		public Transform GetMenuTransform()
		{
			return m_menu.transform;
		}

		public void EnableAwaitOpponent()
		{
			ShowNotification("HUD/Notification/Waiting", string.Empty, string.Empty, 5f, 0.5f);
		}

		private IEnumerator ReturnToLobby()
		{
			yield return new WaitForSeconds(3f);
			if (PlayerManager.Instance.CanGetOpponentWielder(out var wielder))
			{
				while (wielder != null && wielder.Wand != null && wielder.Wand.GetWandControl() != null)
				{
					yield return null;
				}
			}
			PunSingleton<SceneControl>.Instance.LeaveGameAndEnterLobby();
		}

		private IEnumerator ReturnToWorkshop()
		{
			WaitForSeconds wait = new WaitForSeconds(5f);
			yield return wait;
			m_notificationLocalize.SetTerm("HUD/Notification/Status/Leaving");
			yield return wait;
			LeaveArena(quitGame: false);
		}

		public void OnSystemMenuPress()
		{
			DisableNotification(force: true);
			if (Menu.IsOptionsActive)
			{
				ToggleOptionsActive(enable: false);
			}
			else if (Menu.IsReportMenuActive)
			{
				Menu.ToggleReporting(active: false);
			}
			else
			{
				ToggleMenuActive(!Menu.IsMenuActive);
			}
		}

		public void ToggleMenuActive()
		{
			ToggleMenuActive(!m_menu.IsMenuActive);
		}

		public void ToggleMenuActive(bool enable)
		{
			if (!PunSingleton<SceneControl>.Instance.CountdownHandler.IsCountdownActive)
			{
				ResetNotification();
			}
			m_menu.ToggleMenu(enable);
			if (enable)
			{
				m_playerControl.SetSpellInputActive(active: false);
			}
			else
			{
				m_playerControl.SetSpellInputActive(!PunSingleton<SceneControl>.Instance.CountdownHandler.IsCountdownActive);
			}
		}

		public void ToggleOptionsActive(bool enable)
		{
			m_menu.ToggleOptions(enable);
		}

		public void UpdateMenuPosition()
		{
			m_menu.ResetPosition();
		}

		private void SetEndMenuActive(bool enable, Vector3 pos = default(Vector3), Quaternion rot = default(Quaternion))
		{
			IsEndMenuActive = enable;
			m_notificationParent.gameObject.SetActive(enable);
			if (enable)
			{
				m_notificationParent.position = pos;
				m_notificationParent.rotation = rot;
			}
		}

		public void SetEndMenuActive(EndState endState)
		{
			StopAllCoroutines();
			ToggleMenuActive(enable: false);
			ResetNotification();
			State = endState;
			switch (endState)
			{
			case EndState.ConnectionLostClient:
			case EndState.ConnectionLostServer:
			{
				ExpandedSingleton<FadeHandler>.Instance.FadeOut(0.2f, 0.6f, Color.black, forceFade: true);
				DisableNotification();
				string term = ((endState != EndState.ConnectionLostClient) ? "HUD/EndState/ConnectionServerMsg" : "HUD/EndState/ConnectionClientMsg");
				m_notificationLocalize.SetTerm(term);
				StartCoroutine(ReturnToWorkshop());
				break;
			}
			case EndState.Won:
				ExpandedSingleton<FadeHandler>.Instance.FadeOut(0.2f, 0.6f, Color.black, forceFade: true);
				DisableNotification();
				m_notificationParams.SetParameterValue("END_STATE", ScriptLocalization.Get("HUD/EndState/Won"));
				m_notificationLocalize.SetTerm("HUD/EndState/WinLoseMsg");
				StartCoroutine(ReturnToLobby());
				break;
			case EndState.Draw:
				ExpandedSingleton<FadeHandler>.Instance.FadeOut(0.2f, 0.6f, Color.black, forceFade: true);
				DisableNotification();
				m_notificationLocalize.SetTerm("HUD/EndState/DrawMsg");
				StartCoroutine(ReturnToLobby());
				break;
			case EndState.Lost:
				ExpandedSingleton<FadeHandler>.Instance.FadeOut(0.2f, 0.6f, Color.black, forceFade: true);
				DisableNotification();
				m_notificationParams.SetParameterValue("END_STATE", ScriptLocalization.Get("HUD/EndState/Lost"));
				m_notificationLocalize.SetTerm("HUD/EndState/WinLoseMsg");
				StartCoroutine(ReturnToLobby());
				break;
			case EndState.ForceLost:
				ExpandedSingleton<FadeHandler>.Instance.FadeOut(0.2f, 0.6f, Color.black, forceFade: true);
				DisableNotification();
				m_notificationLocalize.SetTerm("HUD/EndState/Pause");
				StartCoroutine(ReturnToWorkshop());
				break;
			case EndState.Close:
				DisableNotification();
				break;
			case EndState.FoundMatch:
				ExpandedSingleton<FadeHandler>.Instance.FadeOut(0.2f, 0.6f, Color.black, forceFade: true);
				DisableNotification();
				m_notificationLocalize.SetTerm("HUD/EndState/OpponentFound");
				StartCoroutine(ReturnToLobby());
				break;
			default:
				throw new UnityException("Unhandled EndState in ArenaUI.SetEndMenuActive: " + endState);
			}
			InteractObject.SetIObjsActive(typeof(ControlsImg), enable: false);
			UpdateEndMenuPosition();
			if (m_playerControl != null && m_playerControl.TeleportHandler.IsTeleporting)
			{
				(m_playerControl.Wand?.GetWandControl() as WandControlOneHand)?.UI.TryHideUI();
			}
		}

		public void UpdateEndMenuPosition()
		{
			Vector3 forwardPoint = m_playerControl.Input.GetAim().GetForwardPoint(1.2f, 1.5f);
			Quaternion rot = Quaternion.LookRotation((forwardPoint - m_playerControl.CameraTransform.position).normalized);
			SetEndMenuActive(enable: true, forwardPoint, rot);
		}

		private void LeaveArena(bool quitGame)
		{
			if (PunSingleton<SceneControl>.Instance == null)
			{
				WandsLogger.Log("HUD | Can't leave room due to no SceneControl present in the scene.", base.gameObject, LogType.Error);
				return;
			}
			if (PunSingleton<SceneControl>.Instance.MatchStarted)
			{
				WandsAnalytics.SendCustomEvent(CustomEventType.match_ended, new Dictionary<string, object>
				{
					{
						"ArenaId",
						(int)PunSingleton<SceneControl>.Instance.CurrentLevel
					},
					{ "Result", 4 },
					{ "Reason", 4 },
					{
						"MatchId",
						(int)RoomProperty.GetRoomProperty("A4")
					},
					{
						"Rating",
						GameControl.Instance.Player.Rating
					}
				});
			}
			ToggleMenuActive(enable: false);
			ResetHUD();
			bool penalizePlayer = PunSingleton<SceneControl>.Instance.MatchStarted && !PunSingleton<SceneControl>.Instance.GameOver;
			GameControl.Instance.LeaveGame(0f, penalizePlayer, quitGame);
		}

		public void ReceiverLeaveArena(bool quitGame)
		{
			LeaveArena(quitGame);
		}
	}
}
namespace Assets.Scripts.UI.Basement
{
	public class BasementUI : MonoSingleton<BasementUI>
	{
		private enum TutorialType
		{
			Unsupported,
			GearVrTouchpad,
			Remote,
			Rift,
			Gamepad,
			ViveController,
			ViveTouch,
			Quest,
			PlayStationDualShock,
			PlayStationMove,
			ViveCosmos,
			ViveKnuckles,
			WindowsMixedReality,
			RiftOneHand,
			QuestOneHand,
			ViveControllerOneHand,
			ViveTouchOneHand,
			ViveCosmosOneHand,
			ViveKnucklesOneHand,
			WindowsMixedRealityOneHand,
			PicoNeo2,
			PicoNeo2OneHand
		}

		[Header("Blackboard")]
		[SerializeField]
		private CanvasGroup m_mainCanvasGroup;

		[SerializeField]
		private Image m_mainImg;

		[SerializeField]
		private GameObject m_gamepadRecenter;

		[SerializeField]
		private Image m_swipeImg;

		[SerializeField]
		private GameObject[] m_tutorialTextObjs = Array.Empty<GameObject>();

		[SerializeField]
		private TextMeshProUGUI[] m_remoteTextComponents = Array.Empty<TextMeshProUGUI>();

		private EventToken m_inputChangedEventToken;

		private EventToken m_controllerStatusChangedEventToken;

		private void OnEnable()
		{
			m_inputChangedEventToken = EventHub.Subscribe<InputEvents.InputChangedEvent>(OnInputChanged);
			m_controllerStatusChangedEventToken = EventHub.Subscribe<InputEvents.ControllerConnectionStatusChanged>(OnControllerConnectionStatusChanged);
		}

		protected override void OnDisable()
		{
			base.OnDisable();
			EventHub.Unsubscribe<InputEvents.InputChangedEvent>(m_inputChangedEventToken);
			EventHub.Unsubscribe<InputEvents.ControllerConnectionStatusChanged>(m_controllerStatusChangedEventToken);
		}

		private void OnControllerConnectionStatusChanged(InputEvents.ControllerConnectionStatusChanged eventData)
		{
			PlayerInput playerInput = PlayerManager.Instance?.PlayerControl?.Input;
			if (playerInput != null)
			{
				ChangeInput(playerInput.AimInput, playerInput.WandInput);
			}
		}

		private void OnInputChanged(InputEvents.InputChangedEvent eventData)
		{
			ChangeInput(eventData.AimInput, eventData.WandInput);
		}

		private void ChangeInput(AimInput aimInput, WandInput wandInput)
		{
			if (wandInput == WandInput.None)
			{
				SetCanvasGroupAlpha(0f);
				SetTutorialTextActive(TutorialType.Unsupported);
			}
			else
			{
				UpdateSpritesAndText(wandInput);
			}
		}

		private void UpdateSpritesAndText(WandInput wandInput)
		{
			Assets.Scripts.Platform.Platform platform = GameControl.Instance.Platform;
			AssetBundleType assetBundleType = AssetBundleType.UI;
			TutorialType tutorialTextActive = TutorialType.Unsupported;
			bool isDualWieldSupportedAndActive = GameControl.Instance.IsDualWieldSupportedAndActive;
			string assetName = ((!isDualWieldSupportedAndActive) ? $"Blackboard_{platform.ControlType}_OneHand" : $"Blackboard_{platform.ControlType}");
			switch (platform.ControlType)
			{
			case ControlType.Gamepad:
				tutorialTextActive = TutorialType.Gamepad;
				m_gamepadRecenter.SetActive(platform.Type.ContainsFlag(PlatformTarget.PC));
				assetName = "Blackboard_Gamepad";
				assetBundleType = AssetBundleType.CombinedUI;
				break;
			case ControlType.GearVr:
				tutorialTextActive = TutorialType.GearVrTouchpad;
				assetName = "Blackboard_GearVr";
				UpdateAndroidSwipeSprite(wandInput, platform.ControlType);
				break;
			case ControlType.GearVrRemote:
			case ControlType.GoRemote:
			case ControlType.MiVrRemote:
			{
				tutorialTextActive = TutorialType.Remote;
				assetName = $"Blackboard_{platform.ControlType}";
				UpdateAndroidSwipeSprite(wandInput, platform.ControlType);
				for (int i = 0; i < m_remoteTextComponents.Length; i++)
				{
					m_remoteTextComponents[i].text = ControlsTextHandler.GetGearVrRemoteInstruction(wandInput, i);
				}
				break;
			}
			case ControlType.Pico:
			{
				tutorialTextActive = TutorialType.Remote;
				assetName = "Blackboard_Pico";
				UpdateAndroidSwipeSprite(wandInput, platform.ControlType);
				for (int j = 0; j < m_remoteTextComponents.Length; j++)
				{
					m_remoteTextComponents[j].text = ControlsTextHandler.GetPicoInstruction(wandInput, j);
				}
				break;
			}
			case ControlType.PicoNeo2:
				tutorialTextActive = ((!isDualWieldSupportedAndActive) ? TutorialType.PicoNeo2OneHand : TutorialType.PicoNeo2);
				assetName = ((!isDualWieldSupportedAndActive) ? "Blackboard_PicoNeo2_OneHand" : "Blackboard_PicoNeo2");
				break;
			case ControlType.RiftTouchRight:
			case ControlType.RiftTouchLeft:
			{
				bool flag = platform.Type == PlatformType.Rift;
				if (isDualWieldSupportedAndActive)
				{
					tutorialTextActive = ((!flag) ? TutorialType.ViveTouch : TutorialType.Rift);
					assetName = ((!flag) ? "Blackboard_ViveTouch" : "Blackboard_Rift");
				}
				else
				{
					tutorialTextActive = ((!flag) ? TutorialType.ViveTouchOneHand : TutorialType.RiftOneHand);
					assetName = ((!flag) ? "Blackboard_ViveTouch_OneHand" : "Blackboard_Rift_OneHand");
				}
				break;
			}
			case ControlType.QuestRight:
			case ControlType.QuestLeft:
				tutorialTextActive = ((!isDualWieldSupportedAndActive) ? TutorialType.QuestOneHand : TutorialType.Quest);
				assetName = ((!isDualWieldSupportedAndActive) ? "Blackboard_Quest_OneHand" : "Blackboard_Quest");
				break;
			case ControlType.ViveController:
				tutorialTextActive = ((!isDualWieldSupportedAndActive) ? TutorialType.ViveControllerOneHand : TutorialType.ViveController);
				break;
			case ControlType.ViveKnuckles:
				tutorialTextActive = ((!isDualWieldSupportedAndActive) ? TutorialType.ViveKnucklesOneHand : TutorialType.ViveKnuckles);
				break;
			case ControlType.ViveCosmos:
				tutorialTextActive = ((!isDualWieldSupportedAndActive) ? TutorialType.ViveCosmosOneHand : TutorialType.ViveCosmos);
				break;
			case ControlType.WindowsMixedReality:
				tutorialTextActive = ((!isDualWieldSupportedAndActive) ? TutorialType.WindowsMixedRealityOneHand : TutorialType.WindowsMixedReality);
				break;
			case ControlType.PlayStationDualShock:
				tutorialTextActive = TutorialType.PlayStationDualShock;
				assetName = $"Blackboard_{platform.ControlType}";
				break;
			case ControlType.PlayStationMotion:
				tutorialTextActive = TutorialType.PlayStationMove;
				assetName = $"Blackboard_{platform.ControlType}";
				break;
			default:
				throw new NotImplementedException($"BasementUI | {platform.ControlType} not recognized");
			case ControlType.Daydream:
				break;
			}
			SetMainImage(GameControl.Instance.AssetHandler.LoadAsset<Sprite>(assetBundleType, assetName));
			SetTutorialTextActive(tutorialTextActive);
		}

		private void UpdateAndroidSwipeSprite(WandInput wandInput, ControlType controlType)
		{
			if (wandInput != WandInput.Point)
			{
				string assetName = $"Blackboard_{controlType}{wandInput}";
				SetSwipeImage(GameControl.Instance.AssetHandler.LoadAsset<Sprite>(AssetBundleType.UI, assetName));
			}
			else
			{
				SetSwipeImage(null);
			}
		}

		private void SetTutorialTextActive(TutorialType tutorialType)
		{
			if (m_tutorialTextObjs.IsNullOrEmpty())
			{
				WandsLogger.LogError("Basement tutorial texts not found!");
				return;
			}
			for (int i = 0; i < m_tutorialTextObjs.Length; i++)
			{
				m_tutorialTextObjs[i].SetActive(i == (int)tutorialType);
			}
		}

		private void SetMainImage(Sprite sprite)
		{
			if (!(m_mainImg == null))
			{
				if (sprite == null)
				{
					m_mainImg.gameObject.SetActive(value: false);
					return;
				}
				SetCanvasGroupAlpha(1f);
				m_mainImg.sprite = sprite;
				m_mainImg.gameObject.SetActive(value: true);
			}
		}

		private void SetCanvasGroupAlpha(float alpha)
		{
			if (m_mainCanvasGroup != null)
			{
				m_mainCanvasGroup.alpha = alpha;
			}
		}

		private void SetSwipeImage(Sprite sprite)
		{
			if (!(m_swipeImg == null))
			{
				if (sprite == null)
				{
					m_swipeImg.gameObject.SetActive(value: false);
					return;
				}
				m_swipeImg.sprite = sprite;
				m_swipeImg.gameObject.SetActive(value: true);
			}
		}
	}
	public class ControlsTextHandler
	{
		private static IReadOnlyList<string> sm_gearVrRemotePress = new List<string>
		{
			$"1.\t{SelectSpell} ({Touch})",
			$"1.\t{UseSpell} ({Press}/{Hold})",
			$"2.\t{Teleport} ({Hold})",
			$"3.\t{Menu} ({Press})",
			$"4.\t{Recenter} ({Hold})"
		};

		private static IReadOnlyList<string> sm_gearVrRemoteSwipe = new List<string>
		{
			$"1.\t{ChangeSpell} ({Swipe})",
			$"1.\t{Teleport} ({Hold})",
			$"2.\t{UseSpell} ({Press}/{Hold})",
			$"3.\t{Menu} ({Press})",
			$"4.\t{Recenter} ({Hold})"
		};

		private static IReadOnlyList<string> sm_gearVrRemotePoint = new List<string>
		{
			$"1.\t{SelectSpell} ({Hold})",
			$"2.\t{UseSpell} ({Press}/{Hold})",
			$"3.\t{Menu} ({Press})",
			$"4.\t{Recenter} ({Hold})",
			string.Empty
		};

		private static IReadOnlyList<string> sm_daydreamRemotePress = new List<string>
		{
			$"1.\t{ChangeSpell} ({Touch})",
			$"1.\t{UseSpell} ({Press}/{Hold})",
			$"2.\t{Teleport} ({Hold})",
			$"1 & 2.\t{Menu} ({Press})",
			$"3.\t{Recenter} ({Hold})"
		};

		private static IReadOnlyList<string> sm_daydreamRemoteSwipe = new List<string>
		{
			$"1.\t{ChangeSpell} ({Swipe})",
			$"1.\t{UseSpell} ({Press}/{Hold})",
			$"2.\t{Teleport} ({Hold})",
			$"1 & 2.\t{Menu} ({Press})",
			$"3.\t{Recenter} ({Hold})"
		};

		private static IReadOnlyList<string> sm_daydreamRemotePoint = new List<string>
		{
			$"1.\t{UseSpell} ({Press}/{Hold})",
			$"2.\t{SelectSpell} ({Hold})",
			$"3.\t{Recenter} ({Hold})",
			string.Empty,
			string.Empty
		};

		private static IReadOnlyList<string> sm_picoRemoteSwipe = new List<string>
		{
			$"1.\t{ChangeSpell} ({Swipe})",
			$"2.\t{UseSpell} ({Press}/{Hold})",
			$"2.\t{Teleport} ({Hold})",
			$"1 & 2.\t{Menu} ({Press})",
			$"3.\t{Recenter} ({Hold})"
		};

		private static IReadOnlyList<string> sm_picoRemotePoint = new List<string>
		{
			$"1.\t{SelectSpell} ({Hold})",
			$"2.\t{UseSpell} ({Press}/{Hold})",
			$"3.\t{Recenter} ({Hold})",
			string.Empty,
			string.Empty
		};

		private static string Swipe => ScriptLocalization.Get("HUD/Controls/Swipe");

		private static string Point => ScriptLocalization.Get("HUD/Controls/Point");

		private static string Press => ScriptLocalization.Get("Basement/Blackboard/Press");

		private static string Touch => ScriptLocalization.Get("Basement/Blackboard/Touch");

		private static string Hold => ScriptLocalization.Get("Basement/Blackboard/Hold");

		private static string SelectSpell => ScriptLocalization.Get("Basement/Blackboard/SelectSpell");

		private static string ChangeSpell => ScriptLocalization.Get("Basement/Blackboard/ChangeSpell");

		private static string Teleport => ScriptLocalization.Get("Basement/Blackboard/Teleport");

		private static string UseSpell => ScriptLocalization.Get("Basement/Blackboard/UseSpell");

		private static string Recenter => ScriptLocalization.Get("Basement/Blackboard/Recenter");

		private static string Menu => ScriptLocalization.Get("Basement/Blackboard/Menu");

		public static string GetGearVrRemoteInstruction(WandInput wandInput, int index)
		{
			return wandInput switch
			{
				WandInput.Point => sm_gearVrRemotePoint[index], 
				WandInput.Swipe => sm_gearVrRemoteSwipe[index], 
				WandInput.Press => sm_gearVrRemotePress[index], 
				_ => throw new NotImplementedException($"ControlsTextHandler | {wandInput} not recognized as a valid input for GearVr, Go or MiVR"), 
			};
		}

		public static string GetDaydreamInstruction(WandInput wandInput, int index)
		{
			return wandInput switch
			{
				WandInput.Point => sm_daydreamRemotePoint[index], 
				WandInput.Swipe => sm_daydreamRemoteSwipe[index], 
				WandInput.Press => sm_daydreamRemotePress[index], 
				_ => throw new NotImplementedException($"ControlsTextHandler | {wandInput} not recognized as a valid input for Daydream or Polaris"), 
			};
		}

		public static string GetPicoInstruction(WandInput wandInput, int index)
		{
			return wandInput switch
			{
				WandInput.Point => sm_picoRemotePoint[index], 
				WandInput.Swipe => sm_picoRemoteSwipe[index], 
				_ => throw new NotImplementedException($"ControlsTextHandler | {wandInput} not recognized as a valid input for Pico Goblin"), 
			};
		}
	}
	public class TrainingDummyUI : MonoBehaviour
	{
		[SerializeField]
		private CanvasGroup m_hpCanvasGroup;

		[SerializeField]
		private Image m_vitalBar;

		[SerializeField]
		private Image m_vitalSpent;

		public void SetBarActive(bool active)
		{
			m_hpCanvasGroup.alpha = ((!active) ? 0f : 1f);
		}

		public void UpdateFillAmount(float fillAmount, float changeValue)
		{
			float duration = m_vitalSpent.fillAmount - fillAmount;
			m_vitalBar.fillAmount = fillAmount;
			m_vitalSpent.DOFillAmount(fillAmount, duration).SetDelay(1f);
		}
	}
}
namespace Assets.Scripts.UI
{
	[RequireComponent(typeof(InteractableButton))]
	public class BtnOptions : MonoBehaviour, IVisibilityToggleable
	{
		private static readonly string[] sm_toolTipTerms = new string[2] { "Options/Enabled", "Options/Disabled" };

		[SerializeField]
		private TMP_Text m_toolTip;

		[SerializeField]
		private Localize m_toolTipLocalize;

		[Header("Options")]
		[SerializeField]
		private BtnOptionsTypes m_btnOptionsType;

		private AimInput m_aimInput = AimInput.Head;

		public bool ShouldBeEnabled
		{
			get
			{
				switch (m_btnOptionsType)
				{
				case BtnOptionsTypes.Sfx:
				case BtnOptionsTypes.PlayerVoIP:
				case BtnOptionsTypes.ResetTutorial:
				case BtnOptionsTypes.Subtitle:
					return true;
				case BtnOptionsTypes.Aim:
					return false;
				case BtnOptionsTypes.Grip:
					return ButtonUtils.GetShouldOptionBeEnabled(Option.Grip);
				case BtnOptionsTypes.Hand:
					return GameControl.Instance.Platform.Type.ContainsFlag(PlatformTarget.SixDoF);
				case BtnOptionsTypes.Language:
					return GameControl.Instance.Platform.GetAvailableLanguages().Count != 0;
				case BtnOptionsTypes.PositionalTrackingOpponent:
					return !GameControl.Instance.Platform.SupportsPositionalTracking;
				case BtnOptionsTypes.ControlSchemeWandInput:
					return ButtonUtils.GetShouldOptionBeEnabled(Option.ControlSchemeWandInput);
				case BtnOptionsTypes.ControlSchemeDualWield:
					return ButtonUtils.GetShouldOptionBeEnabled(Option.ControlSchemeDualWield);
				default:
					return false;
				}
			}
		}

		protected virtual void Start()
		{
			if (!ShouldBeEnabled)
			{
				base.gameObject.SetActive(value: false);
				return;
			}
			switch (m_btnOptionsType)
			{
			case BtnOptionsTypes.Sfx:
				ToggleMusic(GameControl.Instance.MusicEnabled);
				break;
			case BtnOptionsTypes.Hand:
				SetTooltipTerm("Options/" + ((GameControl.Instance.GetInputAim() != AimInput.LeftHand) ? "Right" : "Left"));
				break;
			case BtnOptionsTypes.PositionalTrackingOpponent:
				TogglePositionalTrackingOpponent(GameControl.Instance.PositionalTrackingOpponentEnabled);
				break;
			case BtnOptionsTypes.Grip:
				SetTooltipTerm("Options/" + GetGripName(WandsSave.WandGrip));
				break;
			case BtnOptionsTypes.PlayerVoIP:
				SetTooltipTerm(WandsVoip.IsPlayerEnabled);
				break;
			case BtnOptionsTypes.Language:
				ToggleLanguage(LocalizationManager.CurrentLanguage);
				break;
			case BtnOptionsTypes.ControlSchemeWandInput:
				break;
			case BtnOptionsTypes.Subtitle:
				SetTooltipTerm(WandsSave.GetBoolPref("SE"));
				break;
			case BtnOptionsTypes.ControlSchemeDualWield:
				SetTooltipTerm(WandsSave.IsDualWieldEnabled);
				break;
			case BtnOptionsTypes.Aim:
			case BtnOptionsTypes.OpponentVoIP:
			case BtnOptionsTypes.ResetTutorial:
				break;
			}
		}

		public virtual void Interact()
		{
			switch (m_btnOptionsType)
			{
			case BtnOptionsTypes.Sfx:
				ToggleMusic(!GameControl.Instance.MusicEnabled);
				break;
			case BtnOptionsTypes.Aim:
				ToggleInput();
				break;
			case BtnOptionsTypes.Hand:
				TogglePrimaryHand();
				break;
			case BtnOptionsTypes.PositionalTrackingOpponent:
				TogglePositionalTrackingOpponent(!GameControl.Instance.PositionalTrackingOpponentEnabled);
				break;
			case BtnOptionsTypes.Grip:
				ToggleWandGrip();
				break;
			case BtnOptionsTypes.PlayerVoIP:
				if (WandsVoip.IsPlayerEnabled)
				{
					ToggleVoip(enabled: false);
				}
				else
				{
					if (!UniAndroidPermission.IsPermitted(AndroidPermission.RECORD_AUDIO))
					{
						break;
					}
					MonoSingleton<NetworkManager>.Instance.IsInternetReachable(delegate(bool hasInternet)
					{
						if (hasInternet)
						{
							GameControl.Instance.Platform.CheckVoiceChatAccess(delegate(bool hasAccess)
							{
								if (hasAccess)
								{
									ToggleVoip(enabled: true);
								}
							});
						}
						else
						{
							UnityEngine.Debug.LogError("Internet is not reachable.");
							EventHub.Publish(new Events.InternetRequiredButNotAvailableEvent());
						}
					});
				}
				break;
			case BtnOptionsTypes.Language:
				ToggleLanguage(GameControl.Instance.GetNextLanguage(setLanguage: true));
				break;
			case BtnOptionsTypes.ControlSchemeWandInput:
				break;
			case BtnOptionsTypes.ResetTutorial:
				WandsSave.SetPlayerPref("TU", 0);
				WandsSave.SetPlayerPref("PTT", 0);
				ExpandedSingleton<LevelLoader>.Instance.LoadLevel(Level.Workshop, 0f, forceIfSameScene: true);
				break;
			case BtnOptionsTypes.Subtitle:
				ToggleSubtitles();
				break;
			case BtnOptionsTypes.ControlSchemeDualWield:
				ToggleDualWield();
				break;
			case BtnOptionsTypes.OpponentVoIP:
				break;
			}
		}

		private void ToggleLanguage(string language)
		{
			if (!(m_toolTip == null))
			{
				m_toolTip.text = language;
			}
		}

		protected void SetTooltipTerm(bool enabled)
		{
			SetTooltipTerm(sm_toolTipTerms[(!enabled) ? 1u : 0u]);
		}

		protected void SetTooltipTerm(string newTerm)
		{
			if (!(m_toolTipLocalize == null))
			{
				m_toolTipLocalize.SetTerm(newTerm);
			}
		}

		private void ToggleSubtitles()
		{
			bool boolPref = WandsSave.GetBoolPref("SE");
			WandsSave.SetPlayerPref("SE", !boolPref);
			boolPref = !boolPref;
			SetTooltipTerm(sm_toolTipTerms[(!boolPref) ? 1u : 0u]);
			if (boolPref)
			{
				WandsAnalytics.SendCustomEvent(CustomEventType.player_activated_subtitles, new Dictionary<string, object>
				{
					{
						"Language",
						GameControl.Instance.GetCurrentLanguage()
					},
					{ "Reason", 0 }
				});
			}
		}

		private void ToggleDualWield()
		{
			WandsSave.IsDualWieldEnabled = !WandsSave.IsDualWieldEnabled;
			SetTooltipTerm(WandsSave.IsDualWieldEnabled);
			InputEvents.DualWieldStateUpdatedEvent dualWieldStateUpdatedEvent = new InputEvents.DualWieldStateUpdatedEvent();
			dualWieldStateUpdatedEvent.IsDualWieldEnabled = GameControl.Instance.IsDualWieldSupportedAndActive;
			EventHub.Publish(dualWieldStateUpdatedEvent);
		}

		private void ToggleWandGrip()
		{
			WandGrip wandGrip = GameControl.Instance.ToggleWandGrip();
			GameControl.Instance.PlayerControl.Input.NullHighlightedInteractable();
			SetTooltipTerm($"Options/{GetGripName(wandGrip)}");
		}

		private static string GetGripName(WandGrip wandGrip)
		{
			switch (wandGrip)
			{
			case WandGrip.Pistol:
				return GameControl.Instance.Platform.PistolGripName;
			case WandGrip.Wand:
				return GameControl.Instance.Platform.WandGripName;
			default:
				WandsLogger.LogError($"Wandgrip type: {wandGrip} is not handled");
				return GameControl.Instance.Platform.PistolGripName;
			}
		}

		private void TogglePrimaryHand()
		{
			GameControl.Instance.TogglePrimaryHand();
			SetTooltipTerm(string.Format("Options/{0}", (GameControl.Instance.GetInputAim() != AimInput.LeftHand) ? "Right" : "Left"));
		}

		private void ToggleMusic(bool enable)
		{
			if (PunSingleton<SoundManager>.Instance != null)
			{
				PunSingleton<SoundManager>.Instance.SetOptionalMusicEnabled(enable);
			}
			GameControl.Instance.ToggleMusic(enable);
			SetTooltipTerm(sm_toolTipTerms[(!enable) ? 1u : 0u]);
		}

		private void ToggleInputText()
		{
			SetTooltipTerm($"Options/{GameControl.Instance.GetInputAim().ToString().TrimStart('L', 'R')}");
		}

		private void ToggleInput()
		{
			SetTooltipTerm($"Options/{m_aimInput.ToString()}");
		}

		private void TogglePositionalTrackingOpponent(bool enable)
		{
			GameControl.Instance.TogglePositionalTrackingOpponent(enable);
			SetTooltipTerm(string.Format("Options/{0}", (!enable) ? "Disabled" : "Enabled"));
		}

		private void ToggleVoip(bool enabled)
		{
			WandsVoip.IsPlayerEnabled = enabled;
			SetTooltipTerm(string.Format("Options/{0}", (!enabled) ? "Disabled" : "Enabled"));
		}
	}
	public class BtnOptionsControlScheme : BtnOptions
	{
		[SerializeField]
		private TMP_Text m_tooltipText;

		private WandInput m_currentScheme = WandInput.Press;

		protected override void Start()
		{
			if (base.ShouldBeEnabled)
			{
				SetControlScheme(GameControl.Instance.GetControlScheme());
			}
			else
			{
				base.gameObject.SetActive(value: false);
			}
		}

		public override void Interact()
		{
			SetControlScheme(ButtonUtils.GetNextWandInputValue());
		}

		public void UpdateDisplayText()
		{
			SetTooltipText();
		}

		private void SetControlScheme(WandInput scheme)
		{
			GameControl.Instance.SetControlScheme(scheme);
			m_currentScheme = scheme;
			UpdateDisplayText();
		}

		private void SetTooltipText()
		{
			if (!(m_tooltipText == null))
			{
				m_tooltipText.text = GetLocalizedString();
			}
		}

		private string GetLocalizedString()
		{
			switch (m_currentScheme)
			{
			case WandInput.Point:
			case WandInput.Move:
			case WandInput.Press:
			case WandInput.Swipe:
				return $"{ScriptLocalization.Get($"HUD/Controls/{m_currentScheme}")} - {ScriptLocalization.Get($"Workshop/Blackboard/ControlSchemeInfo{m_currentScheme}")}";
			case WandInput.Stick:
				WandsLogger.LogError("BtnOptionsControlScheme | Trying to retrieve localized string using WandInput Stick, using Swipe as fall back.");
				return $"{ScriptLocalization.Get($"HUD/Controls/{WandInput.Swipe}")} - {ScriptLocalization.Get($"Workshop/Blackboard/ControlSchemeInfo{WandInput.Swipe}")}";
			default:
				throw new NotImplementedException($"BtnOptionsControlScheme | Using faulty WandInput - {m_currentScheme} - for blackboard info localization.");
			}
		}
	}
}
namespace Assets.Scripts.UI.Button
{
	public class AIDifficultyButtonToggler : MonoBehaviour
	{
		[SerializeField]
		private AIOptions m_aIOptions;

		[SerializeField]
		private BotDifficultyLevel m_difficultyLevel = BotDifficultyLevel.VeryEasy;

		[SerializeField]
		private Collider m_buttonCollider;

		[SerializeField]
		protected TextMeshPro m_toolTip;

		[SerializeField]
		protected BotButtonTextColorer m_number;

		[SerializeField]
		protected Image m_iconImg;

		protected bool m_selected;

		private void OnEnable()
		{
			ToggleButtonEnabled(enable: true);
		}

		private void Start()
		{
			m_aIOptions.AddButton(this);
			if (BotDifficultyUtils.IsSelected(m_difficultyLevel))
			{
				Select();
			}
		}

		private void ToggleButtonEnabled(bool enable)
		{
			m_iconImg.transform.parent?.gameObject.SetActive(enable);
			if (m_buttonCollider != null)
			{
				m_buttonCollider.enabled = enable;
			}
		}

		public void Select()
		{
			m_aIOptions.SelectAIDifficulty(m_difficultyLevel);
			m_selected = true;
			m_number.Select();
			UpdateTooltip();
			BotDifficultyUtils.SetSelectedTooltip(m_toolTip.gameObject);
		}

		public void Deselect()
		{
			m_selected = false;
			m_number.Deselect();
			m_toolTip.gameObject.SetActive(value: false);
		}

		private void UpdateTooltip()
		{
			if (!(m_toolTip == null))
			{
				m_toolTip.gameObject.SetActive(m_selected);
			}
		}
	}
	[RequireComponent(typeof(TMP_Text))]
	public class BotButtonTextColorer : WandsButtonHighlighter
	{
		[SerializeField]
		private Color m_highlightColor = Color.white;

		[SerializeField]
		public Color m_defaultColor = Colors.GetColor(35f, 35f, 35f, 255f);

		private bool m_isSelected;

		private TMP_Text m_text;

		public override void LookEnter()
		{
			if (!m_isSelected)
			{
				ChangeTextColor(m_highlightColor);
			}
		}

		public override void LookExit()
		{
			if (!m_isSelected)
			{
				ChangeTextColor(m_defaultColor);
			}
		}

		public void ChangeTextColor(Color newColor)
		{
			if (m_text == null)
			{
				m_text = GetComponent<TMP_Text>();
			}
			m_text.color = newColor;
		}

		public void Select()
		{
			m_isSelected = true;
			ChangeTextColor(m_highlightColor);
		}

		public void Deselect()
		{
			if (m_isSelected)
			{
				ChangeTextColor(m_defaultColor);
			}
			m_isSelected = false;
		}
	}
	public class BotSelectedTooltipToggler : WandsButtonHighlighter
	{
		public override void LookEnter()
		{
			BotDifficultyUtils.LookEnter();
			base.gameObject.SetActive(value: true);
		}

		public override void LookExit()
		{
			base.gameObject.SetActive(value: false);
			BotDifficultyUtils.LookExit();
		}
	}
	public class ButtonGameObjectToggler : WandsButtonHighlighter
	{
		public override void LookEnter()
		{
			base.gameObject.SetActive(value: true);
		}

		public override void LookExit()
		{
			base.gameObject.SetActive(value: false);
		}
	}
	public class ButtonHighlightHandler : MonoBehaviour
	{
		[SerializeField]
		private Interactable m_interactable;

		[SerializeField]
		private UnityEvent m_onLookEnter;

		[SerializeField]
		private UnityEvent m_onLookExit;

		private Action<Interactable> m_onLookEnterAction;

		private Action<Interactable> m_onLookExitAction;

		private void Awake()
		{
			if (m_onLookEnter != null)
			{
				m_onLookEnterAction = delegate
				{
					LookEnter();
				};
			}
			if (m_onLookExit != null)
			{
				m_onLookExitAction = delegate
				{
					LookExit();
				};
			}
		}

		private void OnEnable()
		{
			if (m_onLookEnter != null)
			{
				m_interactable.OnLookEnterListeners.Add(m_onLookEnterAction);
			}
			if (m_onLookExit != null)
			{
				m_interactable.OnLookExitListeners.Add(m_onLookExitAction);
			}
		}

		private void OnDisable()
		{
			if (m_onLookEnter != null)
			{
				m_interactable.OnLookEnterListeners.Remove(m_onLookEnterAction);
			}
			if (m_onLookExit != null)
			{
				m_interactable.OnLookExitListeners.Remove(m_onLookExitAction);
			}
		}

		private void LookEnter()
		{
			m_onLookEnter.Invoke();
		}

		private void LookExit()
		{
			m_onLookExit.Invoke();
		}
	}
	[RequireComponent(typeof(Image))]
	public class ButtonImageColorer : WandsButtonHighlighter
	{
		[SerializeField]
		private Color m_highlightColor = Colors.RadialHighlight;

		[SerializeField]
		private Color m_defaultColor = Colors.RadialDefault;

		private Image m_image;

		public override void LookEnter()
		{
			ChangeColor(highlight: true);
		}

		public override void LookExit()
		{
			ChangeColor(highlight: false);
		}

		private void ChangeColor(bool highlight)
		{
			if (m_image == null)
			{
				m_image = GetComponent<Image>();
			}
			m_image.color = ((!highlight) ? m_defaultColor : m_highlightColor);
		}
	}
	public class ButtonScaler : WandsButtonHighlighter
	{
		[SerializeField]
		private float m_highlightScale = 1.3f;

		[SerializeField]
		private float m_defaultScale = 1f;

		private Tweener m_scaleTweener;

		private const float TweenTime = 0.5f;

		public override void LookEnter()
		{
			ScaleComponent(m_highlightScale);
		}

		public override void LookExit()
		{
			ScaleComponent(m_defaultScale);
		}

		public void ScaleComponent(float scaleMultiplier)
		{
			if (m_scaleTweener != null)
			{
				m_scaleTweener.Complete();
			}
			m_scaleTweener = base.transform.DOScale(Vector3.one * scaleMultiplier, 0.5f).SetEase(Ease.OutBack);
		}
	}
	public class ButtonSoundPlayer : WandsButtonHighlighter
	{
		[SerializeField]
		private string m_clipName;

		[SerializeField]
		private float m_volume = 1f;

		public override void LookEnter()
		{
			PunSingleton<SoundManager>.Instance.PlayLocalSoundAtPoint(m_clipName, m_volume, base.transform.position);
		}

		public override void LookExit()
		{
		}
	}
	[RequireComponent(typeof(TMP_Text))]
	public class ButtonTextColorer : WandsButtonHighlighter
	{
		[SerializeField]
		private Color m_highlightColor = Color.white;

		[SerializeField]
		public Color m_defaultColor = Colors.GetColor(35f, 35f, 35f, 255f);

		private TMP_Text m_text;

		public override void LookEnter()
		{
			ChangeTextColor(m_highlightColor);
		}

		public override void LookExit()
		{
			ChangeTextColor(m_defaultColor);
		}

		public void ChangeTextColor(Color newColor)
		{
			if (m_text == null)
			{
				m_text = GetComponent<TMP_Text>();
			}
			m_text.color = newColor;
		}
	}
	public class ButtonToggler : MonoBehaviour
	{
		[SerializeField]
		protected Option m_option;

		[SerializeField]
		protected TextMeshPro m_toolTip;

		[SerializeField]
		protected Image m_iconImg;

		protected bool m_enabled;

		protected virtual void Start()
		{
			base.gameObject.SetActive(ButtonUtils.GetShouldOptionBeEnabled(m_option));
			m_enabled = ButtonUtils.GetOptionValue(m_option);
			UpdateGraphics();
		}

		public virtual void ToggleOption()
		{
			if (ButtonUtils.CanToggle(m_option))
			{
				ToggleOption(!m_enabled);
			}
		}

		protected virtual void ToggleOption(bool enable)
		{
			m_enabled = enable;
			ButtonUtils.SetOptionValue(m_option, m_enabled);
			UpdateGraphics();
		}

		protected virtual void UpdateGraphics()
		{
			UpdateIcon();
			UpdateTooltip();
		}

		protected virtual void UpdateIcon()
		{
			if (!(m_iconImg == null))
			{
				m_iconImg.sprite = IconAtlasHandler.GetMenuSprite(ButtonUtils.GetSpriteName(m_option, m_enabled));
			}
		}

		private void UpdateTooltip()
		{
			if (!(m_toolTip == null))
			{
				m_toolTip.text = ButtonUtils.GetTooltip(m_option, m_enabled);
			}
		}
	}
	public class DynamicButtonToggler : ButtonToggler
	{
		[SerializeField]
		private Collider m_buttonCollider;

		[SerializeField]
		private bool m_disableTooltipOnToggle = true;

		private void OnEnable()
		{
			ToggleButtonEnabled(ButtonUtils.GetShouldOptionBeEnabled(m_option));
		}

		protected override void Start()
		{
			m_enabled = ButtonUtils.GetOptionValue(m_option);
			UpdateGraphics();
		}

		private void ToggleButtonEnabled(bool enable)
		{
			m_iconImg.transform.parent?.gameObject.SetActive(enable);
			if (m_buttonCollider != null)
			{
				m_buttonCollider.enabled = enable;
			}
		}

		protected override void ToggleOption(bool enable)
		{
			base.ToggleOption(enable);
			if (m_disableTooltipOnToggle && m_toolTip != null)
			{
				m_toolTip.gameObject.SetActive(value: false);
			}
		}
	}
	public class LobbyLoadoutButton : InteractableButton
	{
		[SerializeField]
		private int m_loadoutIndex;

		[SerializeField]
		private LoadoutHandler m_loadoutHandler;

		[SerializeField]
		private GameObject m_text;

		private Spell[] m_loadout;

		private Spell[] Loadout
		{
			get
			{
				if (m_loadout.IsNullOrEmpty() || m_loadout.Contains(Spell.None))
				{
					m_loadout = GetUpdatedLoadout();
				}
				return m_loadout;
			}
		}

		public Spell[] GetUpdatedLoadout()
		{
			if (GameControl.Instance.Player == null)
			{
				return null;
			}
			Loadout loadout = GameControl.Instance.Player.GetLoadout(m_loadoutIndex);
			m_loadout = loadout.Spells.Skip(1).ToArray();
			if (loadout.Locked)
			{
				LockLoadoutButton();
			}
			else
			{
				UnlockLoadoutButton();
			}
			return m_loadout;
		}

		private void Start()
		{
			GetUpdatedLoadout();
			int? num = GameControl.Instance.Player?.ActiveLoadoutIndex;
			if (num.GetValueOrDefault() == m_loadoutIndex && num.HasValue)
			{
				base.LookEnter();
			}
		}

		private void LockLoadoutButton()
		{
			LockInteraction(locked: true);
			m_text.SetActive(value: false);
			ToggleParticleEffects(active: true);
		}

		private void UnlockLoadoutButton()
		{
			LockInteraction(locked: false);
			m_text.SetActive(value: true);
			ToggleParticleEffects(active: false);
		}

		public override void LookEnter()
		{
			if (!base.LookLocked)
			{
				base.LookEnter();
				m_loadoutHandler.PreviewLoadout(Loadout);
				PunSingleton<SoundManager>.Instance.PlayLocalSoundAtPoint("menu_click02", 1f, base.transform.position, 1);
			}
		}

		public override void LookExit()
		{
			if (!base.LookLocked && GameControl.Instance.Player.ActiveLoadoutIndex != m_loadoutIndex)
			{
				base.LookExit();
				m_loadoutHandler.ResetPreview(m_loadoutIndex);
			}
		}

		public override void Interact()
		{
			if (!base.InteractionLocked)
			{
				m_loadoutHandler.ChangeLoadout(m_loadoutIndex, Loadout);
				base.Interact();
			}
		}
	}
	public class PortalBackButton : InteractableButton
	{
		public override void LookEnter()
		{
			if (!base.LookLocked)
			{
				base.LookEnter();
				PunSingleton<SoundManager>.Instance.PlayLocalSound("portal_ui_button_hover", 1f, 1);
			}
		}

		public override void Interact()
		{
			base.Interact();
			if (!base.InteractionLocked)
			{
				PunSingleton<SoundManager>.Instance.PlayLocalSound("portal_ui_button_press", 1f, 1);
			}
		}
	}
	public class ReportButton : MonoBehaviour
	{
		[SerializeField]
		private ReportType m_reportType;

		public void Report()
		{
			OpponentData last = OpponentHistory.GetLast();
			Report report = default(Report);
			report.ReportType = m_reportType;
			report.PlayerId = last.PlayFabId;
			report.PlayerName = last.Name;
			report.PlatformId = last.PlatformId;
			report.PlatformType = last.PlatformType;
			Report report2 = report;
			report2.Dispatch();
		}
	}
}
namespace Assets.Scripts.UI.Workshop
{
	public class SelectableStartupOptionButton : Interactable
	{
		[SerializeField]
		private UnityEvent m_onInteract;

		private bool m_isSelected;

		public override void LookEnter()
		{
			if (!base.LookLocked && !m_isSelected)
			{
				base.LookEnter();
			}
		}

		public override void LookExit()
		{
			if (!base.LookLocked && !m_isSelected)
			{
				base.LookExit();
			}
		}

		public void DeSelectOption()
		{
			m_isSelected = false;
			LookExit();
		}

		public override void Interact()
		{
			if (!base.InteractionLocked)
			{
				base.Interact();
				m_isSelected = true;
				if (m_onInteract != null)
				{
					m_onInteract.Invoke();
				}
			}
		}
	}
	public class StartupOptionButton : InteractableText
	{
		[SerializeField]
		private Image m_image;

		[SerializeField]
		private bool m_startDisabled;

		[SerializeField]
		private UnityEvent m_onInteract;

		private void Start()
		{
			SetActive(!m_startDisabled);
		}

		public override void Interact()
		{
			if (!base.InteractionLocked)
			{
				base.Interact();
				if (m_onInteract != null)
				{
					m_onInteract.Invoke();
				}
			}
		}

		public void SetActive(bool active)
		{
			LockInteraction(!active);
			LockLook(!active);
			m_image.color = ((!active) ? Color.gray : Color.white);
		}
	}
}
namespace Assets.Scripts.UI.Button
{
	public abstract class WandsButtonHighlighter : MonoBehaviour
	{
		public abstract void LookEnter();

		public abstract void LookExit();
	}
	public class WandStationWorkshopButton : WorkshopButton
	{
		[Header("Wand Station Button")]
		[SerializeField]
		private ButtonState m_buttonState;

		[SerializeField]
		private WandHand m_wandHand;

		private WandType m_wandType;

		public void UpdateButton(ButtonState newState, WandType newType)
		{
			m_buttonState = newState;
			m_wandType = newType;
			switch (newState)
			{
			case ButtonState.Equip:
				Lock(locked: false);
				if (GameControl.Instance.IsDualWieldSupportedAndActive)
				{
					m_localize.SetTerm($"Workshop/Mirus/Equip{m_wandHand}");
				}
				else
				{
					m_localize.SetTerm("Workshop/Mirus/Equip");
				}
				break;
			case ButtonState.Equipped:
				Lock(locked: true);
				m_localize.SetTerm("Workshop/Mirus/Equipped");
				break;
			case ButtonState.Unlock:
				Lock(locked: false);
				m_localize.SetTerm("Workshop/Projector/Unlock");
				break;
			case ButtonState.Locked:
				Lock(locked: true);
				m_localize.SetTerm("Workshop/Projector/Locked");
				break;
			}
		}

		public override void Interact()
		{
			if (!base.InteractionLocked)
			{
				LookExit();
				switch (m_buttonState)
				{
				case ButtonState.Equip:
					EquipWand();
					break;
				case ButtonState.Equipped:
				case ButtonState.Locked:
					break;
				case ButtonState.Unlock:
					base.Interact();
					break;
				default:
					throw new NotImplementedException($"{m_buttonState} not recognized!");
				}
			}
		}

		private void EquipWand()
		{
			PunSingleton<SoundManager>.Instance.PlayLocalSoundAtPoint("wand_equip", 1f, base.transform.position, 1);
			Events.WandTypeChangedEvent wandTypeChangedEvent = new Events.WandTypeChangedEvent();
			wandTypeChangedEvent.WandType = m_wandType;
			wandTypeChangedEvent.WandHand = m_wandHand;
			EventHub.Publish(wandTypeChangedEvent);
		}
	}
	public class WorkshopButton : Interactable
	{
		[SerializeField]
		private GameObject m_background;

		[SerializeField]
		private GameObject m_hoverBackground;

		[SerializeField]
		private TMP_Text m_text;

		[SerializeField]
		private Color m_highlightColor;

		[SerializeField]
		private float m_distance = 0.006f;

		[SerializeField]
		private UnityEvent m_onInteract;

		private Color m_defaultTextColor;

		private Color m_defaultBackgroundColor;

		private Image m_backgroundImage;

		private Image m_hoverBackgroundImage;

		protected Localize m_localize;

		private void Start()
		{
			m_localize = m_text.GetComponent<Localize>();
			m_defaultTextColor = m_text.color;
			m_backgroundImage = m_background.GetComponent<Image>();
			m_hoverBackgroundImage = m_hoverBackground.GetComponent<Image>();
		}

		public void Lock(bool locked)
		{
			if (m_backgroundImage == null)
			{
				Start();
			}
			if (locked)
			{
				m_backgroundImage.color = m_hoverBackgroundImage.color;
			}
			else
			{
				m_backgroundImage.color = Color.black;
			}
			LockLook(locked);
			LockInteraction(locked);
		}

		public override void LookEnter()
		{
			if (!base.LookLocked)
			{
				base.LookEnter();
				m_background.transform.DOKill();
				m_hoverBackground.transform.DOKill();
				m_background.transform.DOLocalMove(new Vector3(0f - m_distance, m_distance, 0f), 0.05f);
				m_hoverBackground.transform.DOLocalMove(new Vector3(m_distance, 0f - m_distance, 0.001f), 0.05f);
				m_text.color = m_highlightColor;
			}
		}

		public override void LookExit()
		{
			if (!base.LookLocked)
			{
				base.LookExit();
				m_background.transform.DOKill();
				m_hoverBackground.transform.DOKill();
				m_background.transform.DOLocalMove(new Vector3(0f, 0f, 0f), 0.05f);
				m_hoverBackground.transform.DOLocalMove(new Vector3(0f, 0f, 0.001f), 0.05f);
				m_text.color = m_defaultTextColor;
			}
		}

		public override void Interact()
		{
			if (!base.InteractionLocked)
			{
				base.Interact();
				LookExit();
				if (m_onInteract != null)
				{
					m_onInteract.Invoke();
				}
			}
		}
	}
}
namespace Assets.Scripts.UI
{
	public class ButtonSorter : MonoBehaviour
	{
		private enum ButtonSortType
		{
			TopDown,
			Center,
			Scaled,
			BottomUp
		}

		[SerializeField]
		private bool m_sortAtStart;

		[SerializeField]
		private MonoBehaviour[] m_buttons;

		[SerializeField]
		private ButtonSortType m_buttonSortType;

		[SerializeField]
		private Transform m_topPosition;

		[SerializeField]
		private Transform m_bottomPosition;

		[SerializeField]
		private float m_spacing;

		private void Start()
		{
			if (m_sortAtStart)
			{
				Sort(m_buttons);
			}
		}

		public void Sort<T>(T[] buttons) where T : MonoBehaviour
		{
			if (buttons.IsNullOrEmpty())
			{
				WandsLogger.Log("ButtonSorter | Trying to sort null or 0 buttons", LogType.Warning);
				return;
			}
			List<T> list = new List<T>();
			foreach (T val in buttons)
			{
				if (((IVisibilityToggleable)val).ShouldBeEnabled)
				{
					list.Add(val);
				}
			}
			if (list.Count == 0)
			{
				WandsLogger.Log("ButtonSorter | After removing buttons that should not be enabled, 0 elements were left", LogType.Warning);
				return;
			}
			if (m_buttonSortType == ButtonSortType.Scaled)
			{
				m_spacing = Mathf.Abs(m_bottomPosition.localPosition.y - m_topPosition.localPosition.y) / (float)((list.Count <= 1) ? 1 : (list.Count - 1));
			}
			switch (m_buttonSortType)
			{
			case ButtonSortType.TopDown:
			case ButtonSortType.Scaled:
				Sort(m_topPosition.localPosition.y, list, up: false);
				break;
			case ButtonSortType.Center:
				CenterSort(m_bottomPosition.localPosition.y, m_topPosition.localPosition.y, list);
				break;
			case ButtonSortType.BottomUp:
				Sort(m_bottomPosition.localPosition.y, list, up: true);
				break;
			}
		}

		private void Sort<T>(float position, List<T> buttons, bool up) where T : MonoBehaviour
		{
			if (up)
			{
				buttons.Reverse();
			}
			short num = -1;
			foreach (T button in buttons)
			{
				T current = button;
				current.gameObject.SetActive(value: true);
				current.transform.localPosition = new Vector3(0f, position + (float)(++num) * m_spacing * (float)(up ? 1 : (-1)), 0f);
			}
		}

		private void CenterSort<T>(float bottomPosition, float topPosition, List<T> buttons) where T : MonoBehaviour
		{
			float num = Mathf.Lerp(bottomPosition, topPosition, 0.5f);
			float position = num + m_spacing * (float)(buttons.Count - 1) * 0.5f;
			Sort(position, buttons, up: false);
		}
	}
	[RequireComponent(typeof(RawImage))]
	public class Checkbox : InteractableButton
	{
		[SerializeField]
		private Texture m_checkedTexture;

		[SerializeField]
		private Texture m_hoverTexture;

		private Texture m_uncheckedTexture;

		private RawImage m_rawImage;

		public bool Checked { get; private set; }

		private void Start()
		{
			m_rawImage = GetComponent<RawImage>();
			m_uncheckedTexture = m_rawImage.texture;
		}

		public override void LookEnter()
		{
			if (!Checked)
			{
				m_rawImage.texture = m_hoverTexture;
			}
			base.LookEnter();
		}

		public override void LookExit()
		{
			if (!Checked)
			{
				m_rawImage.texture = m_uncheckedTexture;
			}
			base.LookExit();
		}

		public override void Interact()
		{
			Checked = !Checked;
			m_rawImage.texture = ((!Checked) ? m_hoverTexture : m_checkedTexture);
			base.Interact();
		}
	}
}
public class FadeHandler : ExpandedSingleton<FadeHandler>
{
	[SerializeField]
	private Transform m_fadeSphere;

	private Material m_fadeMaterial;

	private Tweener m_tweenerInProgress;

	private EventToken m_matchResetEventToken;

	private EventToken m_energyDepletedEventToken;

	public bool BlockScreenFlash { get; set; }

	public bool IsFading
	{
		[CompilerGenerated]
		get
		{
			bool? flag = ((m_tweenerInProgress != null) ? new bool?(m_tweenerInProgress.IsActive()) : null);
			return flag.HasValue && flag.Value;
		}
	}

	public bool IsFaded
	{
		[CompilerGenerated]
		get
		{
			return m_fadeMaterial.color.a == 1f;
		}
	}

	protected override void Awake()
	{
		base.Awake();
		if (m_fadeSphere == null)
		{
			m_fadeSphere = base.transform.RetrieveChild("FadeSphere", includeInactive: true, includePartials: true);
			if (m_fadeSphere == null)
			{
				WandsLogger.LogError("FadeHandler | Fade sphere missing");
				return;
			}
		}
		m_fadeMaterial = m_fadeSphere.GetComponent<Renderer>().material;
		FadeIn(1.25f);
	}

	private void OnEnable()
	{
		m_matchResetEventToken = EventHub.Subscribe<Events.MatchResetEvent>(OnMatchReset);
		m_energyDepletedEventToken = EventHub.Subscribe<Events.EnergyDepletedEvent>(OnEnergyDepleted);
	}

	private void OnDestroy()
	{
		EventHub.Unsubscribe<Events.MatchResetEvent>(m_matchResetEventToken);
		EventHub.Unsubscribe<Events.EnergyDepletedEvent>(m_energyDepletedEventToken);
	}

	private void OnMatchReset(Events.MatchResetEvent eventData)
	{
		OnMatchReset();
	}

	private void OnEnergyDepleted(Events.EnergyDepletedEvent eventData)
	{
		ScreenFlashAndFade((eventData.CostType != 0) ? Color.red : Color.blue);
	}

	private void OnMatchReset()
	{
		if (PunSingleton<SceneControl>.Instance.GameOver)
		{
			FadeIn(0.2f);
		}
	}

	public void SetMaterialRenderQueue(int queue)
	{
		if (m_fadeMaterial != null)
		{
			m_fadeMaterial.renderQueue = queue;
		}
	}

	public void SetSphereParent(Transform parent)
	{
		if (m_fadeSphere != null)
		{
			m_fadeSphere.SetParent(parent, ResetBehaviour.Position);
		}
	}

	public void ScreenFlashAndFade(Color fadeColor)
	{
		if (m_fadeMaterial == null)
		{
			WandsLogger.LogError("FadeHandler | Fade material is missing, can't flash screen.");
		}
		else if (!GameControl.Instance.IsExpectedConnectionType(ConnectionType.Trailer) && !BlockScreenFlash)
		{
			fadeColor.a = 0f;
			m_fadeMaterial.color = fadeColor;
			m_fadeSphere.gameObject.SetActive(value: true);
			if (m_tweenerInProgress != null)
			{
				m_tweenerInProgress.Kill();
			}
			m_tweenerInProgress = m_fadeMaterial.DOFade(0.55f, 0.1f).OnComplete(FadeIn);
		}
	}

	private void DisableFadeSphere()
	{
		m_tweenerInProgress = null;
		m_fadeSphere.gameObject.SetActive(value: false);
	}

	private void FadeIn()
	{
		if (m_tweenerInProgress != null)
		{
			m_tweenerInProgress.Kill();
		}
		m_tweenerInProgress = m_fadeMaterial.DOFade(0f, 0.5f).OnComplete(DisableFadeSphere);
	}

	public void FadeIn(float fadeTime, float delay = 0f, bool resetAlpha = true, Action onCompleted = null)
	{
		if (m_fadeMaterial == null)
		{
			WandsLogger.LogError("FadeHandler | Fade material is missing, can't fade in.");
		}
		else if (m_fadeMaterial.color.a > 0f)
		{
			FadeInSphere(fadeTime, delay, resetAlpha, m_fadeMaterial.color, onCompleted);
		}
	}

	private void FadeInSphere(float fadeTime, float delay, bool resetAlpha, Color fadeColor, Action onCompleted)
	{
		Color color = fadeColor;
		color.a = ((!resetAlpha) ? m_fadeMaterial.color.a : 1f);
		m_fadeMaterial.color = color;
		m_fadeSphere.gameObject.SetActive(value: true);
		if (m_tweenerInProgress != null)
		{
			m_tweenerInProgress.Kill();
		}
		m_tweenerInProgress = m_fadeMaterial.DOFade(0f, fadeTime).SetDelay(delay).OnComplete(delegate
		{
			DisableFadeSphere();
			onCompleted?.Invoke();
		});
	}

	public Tweener FadeInWithReturn(float fadeTime, float delay = 0f, bool resetAlpha = true)
	{
		return InternalFadeIn(fadeTime, delay, resetAlpha, m_fadeMaterial.color);
	}

	private Tweener InternalFadeIn(float fadeTime, float delay, bool resetAlpha, Color fadeColor)
	{
		Color color = fadeColor;
		color.a = ((!resetAlpha) ? m_fadeMaterial.color.a : 1f);
		m_fadeMaterial.color = color;
		m_fadeSphere.gameObject.SetActive(value: true);
		if (m_tweenerInProgress != null)
		{
			m_tweenerInProgress.Kill();
		}
		m_tweenerInProgress = m_fadeMaterial.DOFade(0f, fadeTime).SetDelay(delay).OnComplete(DisableFadeSphere);
		return m_tweenerInProgress;
	}

	public void FadeOut(float fadeTime)
	{
		if (m_fadeMaterial == null)
		{
			WandsLogger.LogError("FadeHandler | Fade material is missing, can't fade out.");
		}
		else
		{
			FadeOutSphere(fadeTime, 1f, m_fadeMaterial.color);
		}
	}

	public void FadeOut(float fadeTime, float endAlpha)
	{
		if (m_fadeMaterial == null)
		{
			WandsLogger.LogError("FadeHandler | Fade material is missing, can't fade out.");
		}
		else
		{
			FadeOutSphere(fadeTime, endAlpha, m_fadeMaterial.color);
		}
	}

	public void FadeOut(float fadeTime, Color fadeColor)
	{
		if (m_fadeMaterial == null)
		{
			WandsLogger.LogError("FadeHandler | Fade material is missing, can't fade out.");
		}
		else
		{
			FadeOutSphere(fadeTime, 1f, fadeColor);
		}
	}

	public void FadeOut(float fadeTime, float endAlpha, Color fadeColor, bool forceFade = false)
	{
		if (m_fadeMaterial == null)
		{
			WandsLogger.LogError("FadeHandler | Fade material is missing, can't fade out.");
		}
		else
		{
			FadeOutSphere(fadeTime, endAlpha, fadeColor, forceFade);
		}
	}

	private Tweener FadeOutSphere(float fadeTime, float endAlpha, Color fadeColor, bool forceFade = false)
	{
		if (!forceFade && m_fadeMaterial.color.a.Equals(endAlpha))
		{
			return null;
		}
		fadeColor.a = 0f;
		m_fadeMaterial.color = fadeColor;
		m_fadeSphere.gameObject.SetActive(value: true);
		if (m_tweenerInProgress != null)
		{
			m_tweenerInProgress.Kill();
		}
		m_tweenerInProgress = m_fadeMaterial.DOFade(endAlpha, fadeTime).OnComplete(SetTweenerToNull);
		return m_tweenerInProgress;
	}

	public Tweener FadeOutWithReturn(float fadeTime, Color fadeColor, bool forceFade)
	{
		return (!forceFade) ? InternalFadeOut(fadeTime, 1f, fadeColor) : InternalForceFadeOut(fadeTime, 1f, fadeColor);
	}

	private Tweener InternalFadeOut(float fadeTime, float endAlpha, Color fadeColor)
	{
		if (m_fadeMaterial.color.a.Equals(endAlpha))
		{
			return null;
		}
		fadeColor.a = 0f;
		m_fadeMaterial.color = fadeColor;
		m_fadeSphere.gameObject.SetActive(value: true);
		if (m_tweenerInProgress != null)
		{
			m_tweenerInProgress.Kill();
		}
		m_tweenerInProgress = m_fadeMaterial.DOFade(endAlpha, fadeTime).OnComplete(SetTweenerToNull);
		return m_tweenerInProgress;
	}

	private Tweener InternalForceFadeOut(float fadeTime, float endAlpha, Color fadeColor)
	{
		fadeColor.a = 0f;
		m_fadeMaterial.color = fadeColor;
		m_fadeSphere.gameObject.SetActive(value: true);
		if (m_tweenerInProgress != null)
		{
			m_tweenerInProgress.Kill();
		}
		m_tweenerInProgress = m_fadeMaterial.DOFade(endAlpha, fadeTime).OnComplete(SetTweenerToNull);
		return m_tweenerInProgress;
	}

	private void SetTweenerToNull()
	{
		m_tweenerInProgress = null;
	}
}
namespace Cortopia.Scripts.UI.HUD
{
	public class ControllerInfoHandler : MonoBehaviour
	{
		[SerializeField]
		private Localize m_localize;

		[SerializeField]
		private SpriteRenderer m_background;

		[SerializeField]
		private SpriteRenderer m_button;

		private EventToken m_controllerDisconnectedToken;

		private EventToken m_subtitlesEventToken;

		private Vector3 m_backgroundRatio;

		private Transform m_cameraTransform;

		private LayerMask m_hitMask;

		private bool m_enabled;

		private TMP_Text m_text;

		private float m_fontRatio;

		private float m_widthRatio;

		private TextContainer m_textContainer;

		private const float ForwardOffset = 3f;

		private const float LerpSpeed = 0.5f;

		private const float OutlineWidth = 0.15f;

		private const float CameraForwardScale = 0.1f;

		private void OnDestroy()
		{
			EventHub.Unsubscribe<InputEvents.ControllerConnectionStatusChanged>(m_controllerDisconnectedToken);
			EventHub.Unsubscribe<Events.OnSubtitlesShowEvent>(m_subtitlesEventToken);
		}

		private void Awake()
		{
			m_controllerDisconnectedToken = EventHub.Subscribe<InputEvents.ControllerConnectionStatusChanged>(OnControllerConnectionStatusChanged);
			m_subtitlesEventToken = EventHub.Subscribe<Events.OnSubtitlesShowEvent>(OnSubtitlesEvent);
			m_background.enabled = false;
			m_button.enabled = false;
			m_text = m_localize.mTarget as TMP_Text;
			m_localize.mTerm = (m_localize.FinalTerm = null);
			m_text.text = string.Empty;
			m_text.outlineWidth = 0.15f;
		}

		private void Start()
		{
			m_fontRatio = m_text.fontSize / 3f;
			m_widthRatio = m_text.rectTransform.rect.width / 3f;
			m_backgroundRatio = m_background.transform.localScale / 3f;
			m_textContainer = m_text.GetComponent<TextContainer>();
			base.transform.localPosition = Vector3.zero;
			base.transform.localRotation = Quaternion.identity;
			m_cameraTransform = GameControl.Instance.PlayerControl.CameraTransform;
			m_text.outlineWidth = 0.15f;
		}

		private void Update()
		{
			if (!m_enabled || m_cameraTransform == null)
			{
				return;
			}
			if (TutorialSubtitleManager.AreSubtitlesCurrentlyDisplayed)
			{
				m_background.enabled = false;
				m_button.enabled = false;
				m_text.text = string.Empty;
				return;
			}
			if (GameControl.Instance.PlayerControl.Input.GetAim() != null)
			{
				m_hitMask = GameControl.Instance.PlayerControl.Input.GetAim().AimHitMask;
			}
			float t = Time.deltaTime * 0.5f * Quaternion.Angle(base.transform.rotation, m_cameraTransform.rotation);
			if (Physics.Raycast(new Ray(m_cameraTransform.position, m_cameraTransform.forward), out var hitInfo, 3f, m_hitMask))
			{
				base.transform.position = Vector3.Lerp(base.transform.position, hitInfo.point - m_cameraTransform.forward * 0.1f, t);
				m_text.fontSize = Mathf.Lerp(m_text.fontSize, hitInfo.distance * m_fontRatio, t);
				m_textContainer.width = Mathf.Lerp(m_textContainer.width, hitInfo.distance * m_widthRatio, t);
				m_background.transform.localScale = Vector3.Lerp(m_background.transform.localScale, hitInfo.distance * m_backgroundRatio, t);
			}
			else
			{
				base.transform.position = Vector3.Lerp(base.transform.position, m_cameraTransform.position + m_cameraTransform.forward * 3f, t);
				m_text.fontSize = Mathf.Lerp(m_text.fontSize, 3f * m_fontRatio, t);
				m_textContainer.width = Mathf.Lerp(m_textContainer.width, 3f * m_widthRatio, t);
				m_background.transform.localScale = Vector3.Lerp(m_background.transform.localScale, 3f * m_backgroundRatio, t);
			}
			base.transform.rotation = Quaternion.Slerp(base.transform.rotation, m_cameraTransform.rotation, t);
		}

		private void OnSubtitlesEvent(Events.OnSubtitlesShowEvent obj)
		{
			if (m_enabled)
			{
				m_button.enabled = true;
				m_background.enabled = true;
				SetStatusInfo();
			}
		}

		private void EnableInfo()
		{
			m_enabled = true;
			m_button.enabled = true;
			m_background.enabled = true;
			SetStatusInfo();
		}

		private void SetStatusInfo()
		{
			m_localize.SetTerm("HUD/StatusInfo");
		}

		private void DisableInfo()
		{
			if (m_enabled)
			{
				m_enabled = false;
				m_background.enabled = false;
				m_button.enabled = false;
				m_localize.mTerm = (m_localize.FinalTerm = null);
				m_text.text = string.Empty;
			}
		}

		private void OnControllerConnectionStatusChanged(InputEvents.ControllerConnectionStatusChanged eventData)
		{
			if (eventData.IsConnected)
			{
				DisableInfo();
			}
			else
			{
				EnableInfo();
			}
		}
	}
}
namespace Assets.Scripts.UI.HUD
{
	public class HUDEndScreen : MonoBehaviourPun
	{
		[Header("Player 1")]
		[SerializeField]
		private TMP_Text m_player1Name;

		[SerializeField]
		private TMP_Text m_player1Health;

		[SerializeField]
		private TMP_Text m_player1ManaUsed;

		[SerializeField]
		private TMP_Text m_player1DamageInflicted;

		[SerializeField]
		private TMP_Text m_player1PickupsUsed;

		[Header("Player 2")]
		[SerializeField]
		private TMP_Text m_player2Name;

		[SerializeField]
		private TMP_Text m_player2Health;

		[SerializeField]
		private TMP_Text m_player2ManaUsed;

		[SerializeField]
		private TMP_Text m_player2DamageInflicted;

		[SerializeField]
		private TMP_Text m_player2PickupsUsed;

		[Header("Middle")]
		[SerializeField]
		private LocalizationParamsManager m_matchTime;

		[SerializeField]
		private LocalizationParamsManager m_timeLeft;

		[SerializeField]
		private Localize[] m_badges = Array.Empty<Localize>();

		[SerializeField]
		private Color m_opponentBadgeColor = Color.white;

		[Space]
		[SerializeField]
		private InteractableButton m_leaveButton;

		[SerializeField]
		private int m_secondsBeforeAutoLeave = 3;

		private int m_currentBadge;

		private Dictionary<MatchRewardType, string> m_terms = new Dictionary<MatchRewardType, string>
		{
			{
				MatchRewardType.FirstBlood,
				"XP/FirstBlood"
			},
			{
				MatchRewardType.FirstMatchOfTheDay,
				"XP/FirstMatch"
			},
			{
				MatchRewardType.FirstWinOfTheDay,
				"XP/FirstWin"
			},
			{
				MatchRewardType.HighestDamage,
				"XP/HighestDamage"
			},
			{
				MatchRewardType.FlawlessVictory,
				"XP/WinFlawless"
			},
			{
				MatchRewardType.WinWithoutPickups,
				"XP/WinWithoutPickup"
			}
		};

		private IEnumerator ContinueToLobby(int totalSeconds)
		{
			WaitForSeconds wait = new WaitForSeconds(1f);
			while (totalSeconds > 0)
			{
				int minutes = totalSeconds / 60;
				int seconds = totalSeconds % 60;
				m_timeLeft.SetParameterValue("MINUTES", minutes.ToString());
				m_timeLeft.SetParameterValue("SECONDS", seconds.ToString().PadLeft(2, '0'));
				yield return wait;
				totalSeconds--;
			}
			m_leaveButton.Interact();
		}

		public void SetInfo(EndState endState)
		{
			float matchEndTime = PunSingleton<TimeManager>.Instance.GetMatchEndTime();
			int num = Mathf.FloorToInt(matchEndTime / 60f);
			int num2 = Mathf.FloorToInt(matchEndTime % 60f);
			m_matchTime.SetParameterValue("MINUTES", num.ToString());
			m_matchTime.SetParameterValue("SECONDS", num2.ToString().PadLeft(2, '0'));
			m_player1Name.text = $"{PhotonNetwork.LocalPlayer.NickName} - {endState}";
			m_player1Health.text = Convert.ToString((int)PlayerProperty.Get("HP"));
			m_player1ManaUsed.text = Convert.ToString((int)PlayerProperty.Get("MA"));
			m_player1DamageInflicted.text = Convert.ToString((int)PlayerProperty.Get("DD"));
			m_player1PickupsUsed.text = Convert.ToString((int)PlayerProperty.Get("PU"));
			Photon.Realtime.Player opponent = PlayerManager.Instance.GetOpponent();
			if (opponent == null)
			{
				JObject jObject = JObject.Parse((string)PlayerProperty.Get("OI"));
				m_player2Name.text = (string)jObject["Name"] + " - " + endState switch
				{
					EndState.Lost => EndState.Won, 
					EndState.Won => EndState.Lost, 
					_ => endState, 
				};
				m_player2Health.text = string.Empty;
				m_player2ManaUsed.text = string.Empty;
				m_player2DamageInflicted.text = string.Empty;
				m_player2PickupsUsed.text = string.Empty;
			}
			else
			{
				m_player2Name.text = opponent.NickName + " - " + endState switch
				{
					EndState.Lost => EndState.Won, 
					EndState.Won => EndState.Lost, 
					_ => endState, 
				};
				m_player2Health.text = Convert.ToString((int)PlayerProperty.Get("HP", opponent));
				m_player2ManaUsed.text = Convert.ToString((int)PlayerProperty.Get("MA", opponent));
				m_player2DamageInflicted.text = Convert.ToString((int)PlayerProperty.Get("DD", opponent));
				m_player2PickupsUsed.text = Convert.ToString((int)PlayerProperty.Get("PU", opponent));
			}
			BadgeUtils.CheckBadgesEarned(endState, PlayerManager.Instance.LocalWielder, PlayerManager.Instance.GetOpponentWielder(), OnPlayerBadgeEarned, OnOpponentBadgeEarned);
			StopAllCoroutines();
			StartCoroutine(ContinueToLobby(m_secondsBeforeAutoLeave));
		}

		private void OnPlayerBadgeEarned(MatchRewardType type)
		{
			if (m_terms.ContainsKey(type))
			{
				m_badges[m_currentBadge++].SetTerm(m_terms[type]);
			}
		}

		private void OnOpponentBadgeEarned(MatchRewardType type)
		{
			if (m_terms.ContainsKey(type))
			{
				m_badges[m_currentBadge].SetTerm(m_terms[type]);
				(m_badges[m_currentBadge++].mTarget as TMP_Text).color = m_opponentBadgeColor;
			}
		}
	}
}
namespace Cortopia.Scripts.UI.HUD
{
	public class PlayerUI : MonoBehaviour
	{
		[SerializeField]
		private PlayerUISpells m_iconHandler;

		[SerializeField]
		private PlayerUIHealthBar m_healthBar;

		[SerializeField]
		private PlayerUIManaBar m_manaBar;

		[SerializeField]
		private Canvas m_canvas;

		[SerializeField]
		private CanvasGroup m_mainCanvasGroup;

		[Header("Feedback")]
		[SerializeField]
		private HapticsData m_canCastHapticsData;

		[SerializeField]
		private AudioSource m_audioSource;

		[SerializeField]
		private AudioClip[] m_manaSounds = new AudioClip[2];

		[Header("Movement")]
		[SerializeField]
		private Transform m_moveTransform;

		[SerializeField]
		private Vector3 m_hudPositionOffset = Vector3.zero;

		[SerializeField]
		private float m_moveLerpSpeed = 6f;

		private bool m_isUpdatingPosition;

		private bool m_canCastSpell;

		private bool m_isDualWielding;

		private int m_currentCastCost;

		private Spell m_previouslySelectedSpell;

		private Transform m_cameraTransform;

		private PlayerAim m_aim;

		private Wielder m_wielder;

		private StatsData m_healthData;

		private StatsData m_manaData;

		private EventToken m_spellSelectedEventToken;

		private EventToken m_energyDepletedEventToken;

		private EventToken m_suddenDeathStartedEventToken;

		private EventToken m_armorActivationEventToken;

		private void OnEnable()
		{
			m_spellSelectedEventToken = EventHub.Subscribe<Events.SpellSelectedEvent>(OnSpellSelected);
			m_energyDepletedEventToken = EventHub.Subscribe<Events.EnergyDepletedEvent>(OnEnergyDepleted);
			m_suddenDeathStartedEventToken = EventHub.Subscribe<Events.SuddenDeathStartedEvent>(OnSuddenDeathStarted);
			m_armorActivationEventToken = EventHub.Subscribe<Events.ArmorActivationEvent>(OnArmorActivated);
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe<Events.SpellSelectedEvent>(m_spellSelectedEventToken);
			EventHub.Unsubscribe<Events.EnergyDepletedEvent>(m_energyDepletedEventToken);
			EventHub.Unsubscribe<Events.SuddenDeathStartedEvent>(m_suddenDeathStartedEventToken);
			EventHub.Unsubscribe<Events.ArmorActivationEvent>(m_armorActivationEventToken);
		}

		private void OnSpellSelected(Events.SpellSelectedEvent eventData)
		{
			SelectSpell(eventData.Spell);
		}

		private void OnEnergyDepleted(Events.EnergyDepletedEvent eventData)
		{
			m_iconHandler.OnEnergyDepleted(eventData.WandHand);
		}

		private void OnSuddenDeathStarted(Events.SuddenDeathStartedEvent eventData)
		{
			m_manaBar.SetSuddenDeathActive(active: true);
		}

		private void OnArmorActivated(Events.ArmorActivationEvent eventData)
		{
			m_healthBar.SetArmorActive(eventData.IsActive);
		}

		private void LateUpdate()
		{
			if (m_isUpdatingPosition)
			{
				UpdatePosition();
				m_healthBar.UpdateChangeValue();
				m_manaBar.UpdateManaTotal(m_manaData.Fill, m_manaData.Max);
				if (m_iconHandler.IsFadeSystemEnabled && m_iconHandler.IsFadeActive)
				{
					m_iconHandler.UpdateCanvasFade();
				}
			}
		}

		public void InitializeHUD(PlayerAim aim, Camera camera, StatsData healthData, StatsData manaData)
		{
			m_aim = aim;
			m_canvas.worldCamera = camera;
			m_cameraTransform = camera.transform;
			m_healthData = healthData;
			m_manaData = manaData;
			m_audioSource.outputAudioMixerGroup = PunSingleton<SoundManager>.Instance.UiMixerGroup;
			m_healthBar.AssignStatsData(healthData);
			m_manaBar.AssignStatsData(manaData);
			int correctIconSetup = ((!GameControl.Instance.IsDualWieldSupportedAndActive) ? 2 : ((!GameControl.Instance.Platform.ControlType.ContainsFlag(ControlType.DualWieldButtons)) ? 1 : 0));
			m_iconHandler.SetCorrectIconSetup(correctIconSetup);
		}

		public void SetActive(bool active, Wielder wielder, bool isDualWielding)
		{
			m_wielder = wielder;
			m_isDualWielding = isDualWielding;
			m_previouslySelectedSpell = Spell.None;
			m_moveTransform.position = GetTargetPosition();
			m_moveTransform.LookAt(m_cameraTransform);
			m_isUpdatingPosition = active;
			ResetVitalBars();
			base.gameObject.SetActive(active);
		}

		public void UpdateLoadoutIcons(Spell[] spellTypes, int[] castCosts, Spell activeSpell)
		{
			if (spellTypes.IsNullOrEmpty())
			{
				WandsLogger.LogError("Trying to update player HUD loadout icons with an empty spell type array.");
			}
			else
			{
				m_iconHandler.UpdateLoadoutIcons(spellTypes, castCosts, activeSpell);
			}
		}

		public void UpdateSelectedSpell()
		{
			m_iconHandler.SetSpellSelectActive(active: false);
		}

		public void ResetVitals()
		{
			m_healthBar.ResetVitals();
			m_manaBar.ResetVitals();
		}

		public void ResetVitalBars()
		{
			m_healthBar.ResetVitalBar();
			m_manaBar.ResetVitalBar();
		}

		public void FadeHUD(bool fadeIn)
		{
			m_mainCanvasGroup.alpha = ((!fadeIn) ? 0.2f : 1f);
		}

		public void FadeHudCompletely()
		{
			m_mainCanvasGroup.alpha = 0f;
		}

		public void UpdateHealthBar(float changeValue)
		{
			m_healthBar.UpdateHealthHighlight();
			m_healthBar.UpdateVitals(changeValue);
			if (m_iconHandler.IsBloodSpellAvailable)
			{
				m_iconHandler.UpdateIconAvailabilityHealth(m_healthData.Current);
			}
		}

		public void UpdateManaBar(float changeValue)
		{
			m_manaBar.UpdateVitals(changeValue);
			m_iconHandler.UpdateIconAvailabilityMana(m_manaData.Current);
			if (m_isDualWielding)
			{
				return;
			}
			if ((float)m_currentCastCost > m_manaData.Current)
			{
				if (m_canCastSpell)
				{
					m_canCastSpell = false;
					m_manaBar.SetCastCostIndicatorActive(active: false);
					PlaySfx(0);
				}
			}
			else if (!m_canCastSpell)
			{
				m_canCastSpell = true;
				m_manaBar.SetCastCostIndicatorActive(active: true);
				m_wielder.PlayerControl?.Input?.TriggerHaptics(m_canCastHapticsData, overrideCurrent: false);
				PlaySfx(1);
			}
		}

		public void SetCastFeedbackActive(bool active, WandHand wandHand)
		{
			if (active)
			{
				m_iconHandler.PlayCastFeedback(wandHand);
			}
			else
			{
				m_iconHandler.DisableChannelEffect(wandHand);
			}
		}

		private void UpdatePosition()
		{
			m_moveTransform.position = Vector3.Lerp(m_moveTransform.position, GetTargetPosition(), Time.deltaTime * m_moveLerpSpeed);
			m_moveTransform.LookAt(m_cameraTransform);
		}

		private Vector3 GetTargetPosition()
		{
			return m_aim.CameraRay.GetPoint(1f) + m_hudPositionOffset;
		}

		public void DeselectSpell(WandHand wandHand)
		{
			m_iconHandler.DeselectSpell(wandHand);
			m_previouslySelectedSpell = Spell.None;
		}

		private void SelectSpell(SpellBase spell)
		{
			if (spell.IsType(Spell.Spell_Teleport))
			{
				m_iconHandler.OnSpellSelected(spell.Type, spell.WandHand, isPreviewSelection: true, forceSelect: false, m_isDualWielding || spell.WandInput.ContainsFlag(WandInput.Point));
				m_previouslySelectedSpell = Spell.Spell_Teleport;
				TryUpdateCastCostIndicators(spell.GetCastCost(), spell.CostType);
			}
			else if (m_previouslySelectedSpell != spell.Type)
			{
				bool forceSelect = m_isDualWielding || m_previouslySelectedSpell == Spell.Spell_Teleport;
				m_previouslySelectedSpell = spell.Type;
				m_iconHandler.OnSpellSelected(spell.Type, spell.WandHand, isPreviewSelection: false, forceSelect);
				TryUpdateCastCostIndicators(spell.GetCastCost(), spell.CostType);
			}
		}

		private void TryUpdateCastCostIndicators(int castCost, CostType costType)
		{
			if (!m_isDualWielding)
			{
				m_currentCastCost = castCost;
				UpdateCastCostIndicators(costType);
			}
		}

		private void UpdateCastCostIndicators(CostType costType)
		{
			if (costType == CostType.Mana)
			{
				m_manaBar.OnSpellSelected(m_currentCastCost, tryEnable: true);
				if (m_healthBar.IsDisplayingCastCost)
				{
					m_healthBar.SetCastCostIndicatorActive(active: false);
				}
			}
			else
			{
				m_healthBar.OnSpellSelected(m_currentCastCost, tryEnable: true);
				if (m_manaBar.IsDisplayingCastCost)
				{
					m_manaBar.SetCastCostIndicatorActive(active: false);
				}
			}
		}

		private void PlaySfx(int clipIndex)
		{
			if (!(m_audioSource == null))
			{
				if (m_audioSource.isPlaying && m_audioSource.clip != m_manaSounds[clipIndex])
				{
					m_audioSource.Stop();
				}
				m_audioSource.clip = m_manaSounds[clipIndex];
				m_audioSource.Play();
			}
		}
	}
	public class PlayerUIHealthBar : PlayerUIVitalBarBase
	{
		public void SetArmorActive(bool active)
		{
			m_vitalBar.color = ((!active) ? Colors.HealthDefault : Colors.HealthArmorActive);
		}

		public override void ResetVitals()
		{
			ResetVitalBar();
			SetArmorActive(active: false);
			SetCastCostIndicatorActive(active: false);
		}

		public void UpdateHealthHighlight()
		{
			if (m_castCostHighlightTransform.gameObject.activeSelf)
			{
				m_castCostHighlightTransform.anchoredPosition = GetHighlightPosition(m_statsData.Fill - (float)m_currentCastCost / m_statsData.Max);
			}
		}

		public override void OnSpellSelected(int currentCastCost, bool tryEnable)
		{
			base.OnSpellSelected(currentCastCost, tryEnable);
			SetCastCostIndicatorActive(tryEnable);
			UpdateHealthHighlight();
		}

		public override void UpdateVitals(float changeValue)
		{
			if (changeValue == 0f)
			{
				m_barTotalHighlightTransform.anchoredPosition = GetHighlightPosition(m_statsData.Fill);
				m_vitalBar.fillAmount = m_statsData.Fill;
				m_vitalSpent.fillAmount = m_statsData.Fill;
				if (m_isScalingVitalBar)
				{
					HideVitalBar();
				}
				return;
			}
			UpdateCurrentValueText();
			m_changeMainFillAmount = false;
			m_changeSpentFillAmount = false;
			m_fillPercentage = 0f;
			m_fillUpdateHoldTime = 0f;
			if (changeValue > 0f)
			{
				AddFillAmount(m_statsData.Fill, changeValue);
			}
			else if (changeValue < 0f)
			{
				SubtractFillAmount(m_statsData.Fill, 0f - changeValue);
			}
			if (m_showChangeValue)
			{
				UpdateChangeValueText(changeValue);
			}
			HighlightVitalBar();
			m_previousVitalsValue = m_statsData.Current;
		}

		protected override void AddFillAmount(float fillAmount, float changeValue)
		{
			m_vitalSpent.fillAmount = fillAmount;
			m_barTotalHighlightTransform.anchoredPosition = GetHighlightPosition(fillAmount);
			m_startFillAmount = m_vitalBar.fillAmount;
			m_currentFillTime = (fillAmount - m_startFillAmount / 1f) / 3f;
			m_targetFillAmount = fillAmount;
			m_changeMainFillAmount = true;
		}

		protected override void SubtractFillAmount(float fillAmount, float changeValue)
		{
			m_vitalBar.fillAmount = fillAmount;
			m_barTotalHighlightTransform.anchoredPosition = GetHighlightPosition(m_statsData.Fill);
			m_currentSpentValue = m_vitalSpent.fillAmount;
			m_currentFillTime = (m_currentSpentValue - fillAmount) / 3f;
			m_targetSpentValue = fillAmount;
			m_currentHighlightPos = m_barTotalHighlightTransform.anchoredPosition;
			m_targetHighlightPos = GetHighlightPosition(fillAmount);
			m_changeSpentFillAmount = true;
		}
	}
	public class PlayerUIIcon : MonoBehaviour
	{
		[SerializeField]
		private float m_channelFadeTime = 0.1f;

		[SerializeField]
		private RadialElement_Rotate m_uiRotate;

		[Header("UI Components")]
		[SerializeField]
		private Image m_background;

		[SerializeField]
		private Mask m_backgroundMask;

		[SerializeField]
		private Image m_icon;

		[SerializeField]
		private Image m_channelEffect;

		[SerializeField]
		private RectTransform m_flare;

		[SerializeField]
		private Image m_selectMarker;

		[SerializeField]
		private Vector3 m_stickPosition = Vector3.zero;

		[SerializeField]
		private Vector3 m_movePosition = Vector3.zero;

		private bool m_isChargeable;

		private IconState m_currentState;

		private RectTransform m_selectMarkerTransform;

		private Tweener m_selectMarkerPulseTweener;

		private Tweener m_iconPulseTweener;

		private EventToken m_inputChangedEventToken;

		public int Index { get; private set; }

		public int SpellCastCost { get; private set; }

		public string SpellName { get; private set; }

		public bool BlockCastFeedback { get; private set; }

		public bool IsChanneling
		{
			[CompilerGenerated]
			get
			{
				return m_currentState == IconState.Channeling;
			}
		}

		public bool IsSelected
		{
			[CompilerGenerated]
			get
			{
				return m_currentState == IconState.Selected;
			}
		}

		public bool IsDisabled
		{
			[CompilerGenerated]
			get
			{
				return m_currentState == IconState.Disabled;
			}
		}

		private void Awake()
		{
			m_flare.localPosition = new Vector3(-1f, 0f, 0f);
			m_flare.gameObject.SetActive(value: false);
			m_backgroundMask.enabled = false;
			DisableChannelEffect();
			m_selectMarkerTransform = m_selectMarker.rectTransform;
		}

		private void OnEnable()
		{
			m_inputChangedEventToken = EventHub.Subscribe<InputEvents.InputChangedEvent>(OnInputChanged);
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe<InputEvents.InputChangedEvent>(m_inputChangedEventToken);
		}

		private void OnInputChanged(InputEvents.InputChangedEvent eventData)
		{
			SetIconPosition(eventData.WandInput);
		}

		public void EnableIcon()
		{
			base.gameObject.SetActive(value: true);
		}

		public void DisableIcon()
		{
			m_currentState = IconState.Disabled;
			m_selectMarker.gameObject.SetActive(value: false);
			base.gameObject.SetActive(value: false);
		}

		public void SetValues(int index, Sprite spellIcon, string spellName, int spellCastCost, bool isChargeable)
		{
			Index = index;
			m_icon.sprite = spellIcon;
			SpellName = spellName;
			SpellCastCost = spellCastCost;
			m_isChargeable = isChargeable;
		}

		public void ResetIconState(bool useFadedAlpha)
		{
			m_icon.DOKill();
			m_icon.color = Colors.IconEnabled;
			Color color = ((!useFadedAlpha) ? Color.black : Colors.IconBackgroundColor);
			m_background.color = color;
		}

		public void UpdateIconState(float currentValue, float iconFadeTime, float flareMoveSpeed)
		{
			UpdateIconState(currentValue < (float)SpellCastCost, iconFadeTime, flareMoveSpeed);
		}

		public void UpdateIconState(bool tryDisable, float iconFadeTime, float flareMoveSpeed)
		{
			if (tryDisable)
			{
				if (m_icon.color == Colors.IconEnabled)
				{
					m_icon.DOColor(Colors.IconDisabled, iconFadeTime);
				}
			}
			else
			{
				if (!(m_icon.color == Colors.IconDisabled))
				{
					return;
				}
				m_icon.DOColor(Colors.IconEnabled, iconFadeTime).SetEase(Ease.OutBack).OnComplete(delegate
				{
					m_backgroundMask.enabled = true;
					m_flare.gameObject.SetActive(value: true);
					m_flare.localPosition = new Vector3(-1f, 0f, 0f);
					m_flare.DOLocalMoveX(1f, flareMoveSpeed).OnComplete(delegate
					{
						m_flare.gameObject.SetActive(value: false);
						m_backgroundMask.enabled = false;
					});
				});
			}
		}

		public void PlayEnergyDepletedFeedback()
		{
			PulseIconMarker(null);
		}

		public void PlayCastFeedback(float tweenTime, Vector3 selectScale, Vector3 iconScale)
		{
			BlockCastFeedback = true;
			if (m_isChargeable)
			{
				m_currentState = IconState.Channeling;
			}
			m_selectMarkerTransform.DOScale(selectScale, tweenTime).SetLoops(2, LoopType.Yoyo);
			m_icon.rectTransform.DOScale(iconScale, tweenTime).SetLoops(2, LoopType.Yoyo).OnComplete(delegate
			{
				BlockCastFeedback = false;
				if (IsChanneling)
				{
					m_uiRotate.enabled = true;
					m_channelEffect.enabled = true;
					m_channelEffect.DOFade(0.5f, m_channelFadeTime);
				}
			});
		}

		public void DisableChannelEffect()
		{
			m_currentState = IconState.Selected;
			m_uiRotate.Reset();
			m_channelEffect.DOKill();
			m_channelEffect.color = Colors.ClearWhite;
			m_channelEffect.enabled = false;
		}

		public void SelectImage(bool isPreviewSelection)
		{
			m_currentState = (isPreviewSelection ? IconState.Deselected : IconState.Selected);
			m_selectMarker.color = ((!isPreviewSelection) ? Colors.IconSelected : Colors.IconSelectedDiscrete);
			m_selectMarker.gameObject.SetActive(value: true);
			PulseSelectMarker();
		}

		public void DeselectImage(bool disableGameObject)
		{
			m_currentState = IconState.Deselected;
			if (disableGameObject)
			{
				m_selectMarker.gameObject.SetActive(value: false);
				m_selectMarkerTransform.localScale = Vector3.one;
			}
			else
			{
				m_selectMarker.color = Colors.IconSelectedDiscrete;
				PulseSelectMarker();
			}
		}

		public void SetIconPosition(WandInput input)
		{
			RectTransform component = GetComponent<RectTransform>();
			component.anchoredPosition3D = ((input != WandInput.Move) ? m_stickPosition : m_movePosition);
		}

		private void PulseIconMarker(TweenCallback onTweenCompleted)
		{
			if (m_iconPulseTweener != null)
			{
				m_iconPulseTweener.Complete();
			}
			if (onTweenCompleted == null)
			{
				m_iconPulseTweener = m_icon.rectTransform.DOScale(Constants.IconHighlightScale, 0.1f).SetLoops(2, LoopType.Yoyo);
			}
			else
			{
				m_iconPulseTweener = m_icon.rectTransform.DOScale(Constants.IconHighlightScale, 0.1f).SetLoops(2, LoopType.Yoyo).OnComplete(onTweenCompleted);
			}
		}

		private void PulseSelectMarker()
		{
			if (m_selectMarkerPulseTweener != null)
			{
				m_selectMarkerPulseTweener.Complete();
			}
			m_selectMarkerPulseTweener = m_selectMarkerTransform.DOScale(Constants.SelectMarkerHighlightScale, 0.1f).SetLoops(2, LoopType.Yoyo);
		}
	}
	public class PlayerUILingeringEffects : MonoBehaviour
	{
		private const float IconFadeTime = 0.15f;

		[SerializeField]
		private Image[] m_iconImages = Array.Empty<Image>();

		private Dictionary<Spell, CanvasGroup> m_imageEffectPairs = new Dictionary<Spell, CanvasGroup>();

		private EventToken m_armorActivationEventToken;

		private EventToken m_curseActivationEventToken;

		private EventToken m_chillingClutchActivationEventToken;

		private EventToken m_freeTeleportActivationEventToken;

		private void OnEnable()
		{
			m_armorActivationEventToken = EventHub.Subscribe<Events.ArmorActivationEvent>(OnArmorActivated);
			m_curseActivationEventToken = EventHub.Subscribe<Events.CurseActivationEvent>(OnCurseActivated);
			m_chillingClutchActivationEventToken = EventHub.Subscribe<Events.ChillingClutchActivationEvent>(OnChillingClutchActivated);
			m_freeTeleportActivationEventToken = EventHub.Subscribe<Events.FreeTeleportActivationEvent>(OnFreeTeleportActivated);
		}

		private void OnDisable()
		{
			TryDisableEffects();
			EventHub.Unsubscribe<Events.ArmorActivationEvent>(m_armorActivationEventToken);
			EventHub.Unsubscribe<Events.CurseActivationEvent>(m_curseActivationEventToken);
			EventHub.Unsubscribe<Events.ChillingClutchActivationEvent>(m_chillingClutchActivationEventToken);
			EventHub.Unsubscribe<Events.FreeTeleportActivationEvent>(m_freeTeleportActivationEventToken);
		}

		private void Awake()
		{
			Image[] iconImages = m_iconImages;
			foreach (Image image in iconImages)
			{
				image.transform.parent.gameObject.SetActive(value: false);
			}
		}

		private void TryDisableEffects()
		{
			if (m_imageEffectPairs.IsNullOrEmpty())
			{
				return;
			}
			foreach (KeyValuePair<Spell, CanvasGroup> imageEffectPair in m_imageEffectPairs)
			{
				CanvasGroup value = imageEffectPair.Value;
				if (value.alpha > 0f)
				{
					ResetCanvasGroup(value);
				}
			}
		}

		private void OnArmorActivated(Events.ArmorActivationEvent eventData)
		{
			SetEffectActive(eventData.IsActive, Spell.Spell_ArmorOfTheSun);
		}

		private void OnCurseActivated(Events.CurseActivationEvent eventData)
		{
			SetEffectActive(eventData.IsActive, Spell.Spell_CurseOfTheUndead);
		}

		private void OnChillingClutchActivated(Events.ChillingClutchActivationEvent eventData)
		{
			SetEffectActive(eventData.IsActive, Spell.Spell_ChillingClutch);
		}

		private void OnFreeTeleportActivated(Events.FreeTeleportActivationEvent eventData)
		{
			SetEffectActive(eventData.IsActive, Spell.Spell_Teleport);
		}

		public void SetEffectActive(bool active, Spell spellType)
		{
			if (active)
			{
				EnableEffect(spellType);
			}
			else
			{
				DisableEffect(spellType);
			}
		}

		private void EnableEffect(Spell spellType)
		{
			if (!m_imageEffectPairs.ContainsKey(spellType))
			{
				AssignAndAddImageSprite(spellType, m_iconImages[m_imageEffectPairs.Count]);
			}
			CanvasGroup canvasGroup = m_imageEffectPairs[spellType];
			if (!canvasGroup.gameObject.activeSelf)
			{
				canvasGroup.DOFade(1f, 0.15f).OnStart(delegate
				{
					canvasGroup.gameObject.SetActive(value: true);
				});
			}
		}

		private void DisableEffect(Spell spellType)
		{
			if (!m_imageEffectPairs.ContainsKey(spellType))
			{
				return;
			}
			CanvasGroup canvasGroup = m_imageEffectPairs[spellType];
			if (canvasGroup.gameObject.activeSelf)
			{
				canvasGroup.DOFade(0f, 0.15f).OnComplete(delegate
				{
					canvasGroup.gameObject.SetActive(value: false);
				});
			}
		}

		private void ResetCanvasGroup(CanvasGroup canvasGroup)
		{
			canvasGroup.alpha = 0f;
			canvasGroup.gameObject.SetActive(value: false);
		}

		private void AssignAndAddImageSprite(Spell spellType, Image image)
		{
			if (!Colors.LingeringEffectColors.ContainsKey(spellType))
			{
				WandsLogger.LogError($"Trying to assign a lingering effect icon for spell {spellType} which is not supported.");
				return;
			}
			image.sprite = IconAtlasHandler.GetSpellSprite(spellType);
			image.color = Colors.LingeringEffectColors[spellType];
			m_imageEffectPairs.Add(spellType, image.transform.parent.GetComponent<CanvasGroup>());
		}
	}
	public class PlayerUIManaBar : PlayerUIVitalBarBase
	{
		[Header("Mana")]
		[SerializeField]
		private TMP_Text m_manaRegenValue;

		private RegeneratingStatsData ManaData
		{
			[CompilerGenerated]
			get
			{
				return m_statsData as RegeneratingStatsData;
			}
		}

		private void OnDisable()
		{
			if (GameControl.Instance.IsDevelopmentBuild)
			{
				ManaData.OnRegenerationSpeedUpdated -= OnRegenerationSpeedUpdated;
			}
		}

		public override void AssignStatsData(StatsData vitalData)
		{
			base.AssignStatsData(vitalData);
			if (GameControl.Instance.IsDevelopmentBuild)
			{
				OnRegenerationSpeedUpdated(ManaData.RegenerationSpeed);
				ManaData.OnRegenerationSpeedUpdated += OnRegenerationSpeedUpdated;
			}
			else
			{
				m_manaRegenValue.gameObject.SetActive(value: false);
			}
		}

		public void SetSuddenDeathActive(bool active)
		{
			m_vitalBar.color = ((!active) ? Colors.ManaDefault : Colors.ManaSuddenDeath);
		}

		public override void ResetVitals()
		{
			ResetVitalBar();
			SetSuddenDeathActive(active: false);
			SetCastCostIndicatorActive(active: false);
		}

		public void UpdateManaTotal(float fillAmount, float maxAmount)
		{
			UpdateChangeValue();
			m_vitalBar.fillAmount = fillAmount;
			Vector2 highlightPosition = GetHighlightPosition(fillAmount, reversed: true);
			m_barTotalHighlightTransform.anchoredPosition = highlightPosition;
			if (base.IsDisplayingCastCost)
			{
				m_castCostHighlightTransform.anchoredPosition = GetHighlightPosition(fillAmount - (float)m_currentCastCost / maxAmount, reversed: true);
			}
			else
			{
				m_castCostHighlightTransform.anchoredPosition = highlightPosition;
			}
			if (!m_changeSpentFillAmount)
			{
				m_vitalSpent.fillAmount = fillAmount;
			}
		}

		public override void UpdateVitals(float changeValue)
		{
			UpdateCurrentValueText();
			if (!(changeValue >= 0f))
			{
				m_changeMainFillAmount = false;
				m_changeSpentFillAmount = false;
				m_fillPercentage = 0f;
				m_fillUpdateHoldTime = 0f;
				if (m_showChangeValue)
				{
					UpdateChangeValueText(changeValue);
				}
				HighlightVitalBar();
				SubtractFillAmount(m_statsData.Fill, 0f - changeValue);
			}
		}

		public override void OnSpellSelected(int currentCastCost, bool tryEnable)
		{
			m_currentCastCost = currentCastCost;
			SetCastCostIndicatorActive(tryEnable && m_statsData.Current >= (float)currentCastCost);
		}

		protected override void AddFillAmount(float fillAmount, float changeValue)
		{
		}

		protected override void SubtractFillAmount(float fillAmount, float changeValue)
		{
			m_currentSpentValue = m_vitalSpent.fillAmount;
			m_currentFillTime = (m_currentSpentValue - fillAmount) / 3f;
			m_targetSpentValue = fillAmount;
			m_changeSpentFillAmount = true;
		}

		private void OnRegenerationSpeedUpdated(float regenerationSpeed)
		{
			m_manaRegenValue.text = $"(+{regenerationSpeed})";
		}
	}
	public class PlayerUISpells : MonoBehaviour
	{
		[SerializeField]
		private float m_iconFadeTime = 0.15f;

		[SerializeField]
		private float m_flareTweenSpeed = 0.2f;

		[SerializeField]
		private float m_feedbackTweenTime = 0.1f;

		[SerializeField]
		private float m_canvasFadeDelay = 1f;

		[SerializeField]
		private CanvasGroup m_mainCanvasgroup;

		[SerializeField]
		private TMP_Text m_spellTooltip;

		[SerializeField]
		private GameObject[] m_iconHandlerParents = Array.Empty<GameObject>();

		private string m_localizedTeleport;

		private bool m_isSpellSelectActive;

		private bool m_isPersistantNameActive;

		private float m_currentFadeDelay;

		private PlayerUIIcon[] m_iconHandlers = new PlayerUIIcon[4];

		private PlayerUIIcon[] m_selectedIcons = new PlayerUIIcon[2];

		private Dictionary<Spell, PlayerUIIcon> m_spellData = new Dictionary<Spell, PlayerUIIcon>(4);

		private PlayerUIIcon[] m_manaIcons;

		private EventToken m_spellSelectActivatedEventToken;

		private EventToken m_matchResetEventToken;

		private readonly Vector3 m_iconScale = Vector3.one * 0.9f;

		private readonly Vector3 m_selectMarkScale = Vector3.one * 1.1f;

		private const float IconTransitionTime = 0.25f;

		private const float HighlightTransitionTime = 0.15f;

		public bool IsFadeActive { get; private set; }

		public bool IsFadeSystemEnabled { get; private set; } = true;


		public bool IsBloodSpellAvailable
		{
			[CompilerGenerated]
			get
			{
				return m_spellData.ContainsKey(Spell.Spell_BloodBolt);
			}
		}

		private void OnEnable()
		{
			m_spellSelectActivatedEventToken = EventHub.Subscribe<Events.SpellSelectActivatedEvent>(OnSpellSelectActivated);
			m_matchResetEventToken = EventHub.Subscribe<Events.MatchResetEvent>(OnMatchReset);
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe<Events.SpellSelectActivatedEvent>(m_spellSelectActivatedEventToken);
			EventHub.Unsubscribe<Events.MatchResetEvent>(m_matchResetEventToken);
		}

		public void SetCorrectIconSetup(int hudIndex)
		{
			for (int i = 0; i < m_iconHandlerParents.Length; i++)
			{
				GameObject gameObject = m_iconHandlerParents[i];
				if (i == hudIndex)
				{
					m_iconHandlers = gameObject.GetComponentsInChildren<PlayerUIIcon>();
					gameObject.SetActive(value: true);
				}
				else
				{
					gameObject.SetActive(value: false);
				}
			}
			int num = 4;
			for (int j = 0; j < m_iconHandlers.Length; j++)
			{
				m_iconHandlers[j].SetIconPosition(GameControl.Instance.PlayerControl.Input.WandInput);
			}
		}

		public void UpdateCanvasFade()
		{
			if (m_currentFadeDelay < m_canvasFadeDelay)
			{
				m_currentFadeDelay += Time.deltaTime;
			}
			else if (m_mainCanvasgroup.alpha > 0.2f)
			{
				m_mainCanvasgroup.alpha -= Time.deltaTime / 0.25f;
			}
			else
			{
				IsFadeActive = false;
			}
		}

		private void OnSpellSelectActivated(Events.SpellSelectActivatedEvent eventData)
		{
			SetSpellSelectActive(eventData.Active);
		}

		private void OnMatchReset(Events.MatchResetEvent eventData)
		{
			PlayerUIIcon[] iconHandlers = m_iconHandlers;
			foreach (PlayerUIIcon playerUIIcon in iconHandlers)
			{
				playerUIIcon.ResetIconState(IsFadeSystemEnabled);
			}
		}

		public void DeselectSpell(WandHand wandHand)
		{
			m_selectedIcons[(int)wandHand]?.DeselectImage(disableGameObject: true);
			m_isPersistantNameActive = false;
			SetSpellTooltipActive(active: false);
		}

		public void OnSpellSelected(Spell spellType, WandHand wandHand, bool isPreviewSelection, bool forceSelect, bool disableSelectObject = false)
		{
			if (m_spellData.IsNullOrEmpty())
			{
				return;
			}
			PlayerUIIcon playerUIIcon = m_selectedIcons[(int)wandHand];
			if (spellType == Spell.Spell_Teleport)
			{
				playerUIIcon?.DeselectImage(disableSelectObject);
				UpdateSpellName(m_localizedTeleport);
				SetSpellTooltipActive(active: true);
				m_isPersistantNameActive = true;
				return;
			}
			if (forceSelect)
			{
				m_isPersistantNameActive = false;
				SetSpellTooltipActive(m_isSpellSelectActive);
			}
			else if (m_spellData[spellType] == playerUIIcon)
			{
				return;
			}
			playerUIIcon?.DeselectImage(disableGameObject: true);
			SelectImage(m_spellData[spellType], isPreviewSelection, wandHand);
			if (!isPreviewSelection)
			{
				UpdateSpellName(m_spellData[spellType].SpellName);
			}
		}

		public void OnEnergyDepleted(WandHand wandHand)
		{
			PlayerUIIcon playerUIIcon = m_selectedIcons[(int)wandHand];
			if (playerUIIcon != null)
			{
				playerUIIcon.PlayEnergyDepletedFeedback();
			}
		}

		public void UpdateIconAvailabilityMana(float currentMana)
		{
			for (int i = 0; i < m_manaIcons.Length; i++)
			{
				m_manaIcons[i].UpdateIconState(currentMana, m_iconFadeTime, m_flareTweenSpeed);
			}
		}

		public void UpdateIconAvailabilityHealth(float currentHealth)
		{
			if (m_spellData.TryGetValue(Spell.Spell_BloodBolt, out var value))
			{
				bool tryDisable = currentHealth - (float)value.SpellCastCost <= 5f;
				value.UpdateIconState(tryDisable, m_iconFadeTime, m_flareTweenSpeed);
			}
		}

		public void UpdateLoadoutIcons(Spell[] spellTypes, int[] castCosts, Spell activeSpell)
		{
			m_spellData.Clear();
			for (int i = 1; i < 5; i++)
			{
				int num = i - 1;
				PlayerUIIcon playerUIIcon = m_iconHandlers[num];
				if (spellTypes.Length <= i)
				{
					playerUIIcon.DisableIcon();
					continue;
				}
				if (playerUIIcon.IsDisabled)
				{
					playerUIIcon.EnableIcon();
				}
				Spell spell = spellTypes[i];
				string spellName = ScriptLocalization.Get($"Spells/Names/{spell.Trim()}");
				playerUIIcon.SetValues(num, IconAtlasHandler.GetSpellSprite(spell), spellName, castCosts[i], Constants.ChargeableSpells.Contains(spell));
				m_spellData.Add(spell, playerUIIcon);
				if (spell == activeSpell)
				{
					SelectImage(playerUIIcon, isPreviewSelection: false, WandHand.Right);
					UpdateSpellName(spellName);
				}
				else if (playerUIIcon != null)
				{
					playerUIIcon.DeselectImage(disableGameObject: true);
				}
			}
			m_localizedTeleport = ScriptLocalization.Get("Spells/Names/Teleport");
			RefreshManaIcons();
			SetSpellSelectActive(active: false);
		}

		private void RefreshManaIcons()
		{
			m_manaIcons = new PlayerUIIcon[(!m_spellData.ContainsKey(Spell.Spell_BloodBolt)) ? m_spellData.Count : (m_spellData.Count - 1)];
			int num = 0;
			foreach (KeyValuePair<Spell, PlayerUIIcon> spellDatum in m_spellData)
			{
				if (spellDatum.Key != Spell.Spell_BloodBolt)
				{
					m_manaIcons[num++] = spellDatum.Value;
				}
			}
		}

		public void PlayCastFeedback(WandHand wandHand)
		{
			PlayerUIIcon playerUIIcon = m_selectedIcons[(int)wandHand];
			if (!(playerUIIcon == null) && !playerUIIcon.BlockCastFeedback && playerUIIcon.IsSelected)
			{
				if (IsFadeSystemEnabled)
				{
					DisplaySpellsCanvas(activateFade: true);
				}
				playerUIIcon.PlayCastFeedback(m_feedbackTweenTime, m_selectMarkScale, m_iconScale);
			}
		}

		public void DisableChannelEffect(WandHand wandHand)
		{
			PlayerUIIcon playerUIIcon = m_selectedIcons[(int)wandHand];
			if (playerUIIcon != null && playerUIIcon.IsChanneling)
			{
				playerUIIcon.DisableChannelEffect();
			}
		}

		public void SetSpellSelectActive(bool active)
		{
			m_isSpellSelectActive = active;
			SetSpellTooltipActive(active);
			if (IsFadeSystemEnabled)
			{
				DisplaySpellsCanvas(!active);
			}
		}

		private void DisplaySpellsCanvas(bool activateFade)
		{
			m_currentFadeDelay = 0f;
			m_mainCanvasgroup.alpha = 1f;
			IsFadeActive = activateFade;
		}

		private void SetSpellTooltipActive(bool active)
		{
			if (!m_isPersistantNameActive)
			{
				m_spellTooltip.gameObject.SetActive(active);
			}
		}

		private void UpdateSpellName(string name)
		{
			m_spellTooltip.text = name;
		}

		private void SelectImage(PlayerUIIcon iconHandler, bool isPreviewSelection, WandHand wandHand)
		{
			iconHandler.SelectImage(isPreviewSelection);
			m_selectedIcons[(int)wandHand] = iconHandler;
		}
	}
	public abstract class PlayerUIVitalBarBase : MonoBehaviour
	{
		[SerializeField]
		protected bool m_showChangeValue = true;

		[SerializeField]
		protected RectTransform m_barTotalHighlightTransform;

		[SerializeField]
		protected RectTransform m_castCostHighlightTransform;

		[SerializeField]
		protected Image m_vitalBar;

		[SerializeField]
		protected Image m_vitalSpent;

		[SerializeField]
		private Transform m_vitalBarParent;

		[SerializeField]
		private TMP_Text m_currentValueText;

		[SerializeField]
		private TMP_Text m_changeValueText;

		protected bool m_changeMainFillAmount;

		protected bool m_changeSpentFillAmount;

		protected bool m_isScalingVitalBar;

		protected int m_currentCastCost;

		protected float m_previousVitalsValue;

		protected float m_currentFillTime;

		protected float m_fillPercentage = 1f;

		protected float m_currentSpentValue;

		protected float m_targetSpentValue;

		protected float m_fillUpdateHoldTime;

		protected float m_startFillAmount;

		protected float m_targetFillAmount;

		protected Vector2 m_currentHighlightPos;

		protected Vector2 m_targetHighlightPos;

		protected StatsData m_statsData;

		private float m_combinedChangeValue;

		private float m_scalePercentage = 1f;

		private Vector3 m_originalScale;

		private readonly Vector2 m_highlightMinPosition = new Vector2(-0.95f, 0f);

		private readonly Vector2 m_highlightMaxPosition = new Vector2(0.95f, 0f);

		private readonly Vector3 m_highlightScale = new Vector3(1f, 2f, 1f);

		protected const float FillSpeed = 3f;

		private const float ScaleSpeed = 0.1f;

		private const float FillUpdateDelay = 1f;

		public bool IsDisplayingCastCost
		{
			[CompilerGenerated]
			get
			{
				return m_castCostHighlightTransform.gameObject.activeSelf;
			}
		}

		private void Awake()
		{
			m_originalScale = m_vitalBarParent.localScale;
			m_changeValueText.enabled = false;
			m_changeValueText.text = string.Empty;
		}

		public abstract void UpdateVitals(float changeValue);

		public virtual void AssignStatsData(StatsData vitalData)
		{
			m_statsData = vitalData;
			m_previousVitalsValue = vitalData.Current;
			UpdateCurrentValueText();
			ResetVitals();
		}

		public void HideVitalBar(float scalePercentage = 0f)
		{
			m_changeMainFillAmount = false;
			m_changeSpentFillAmount = false;
			m_isScalingVitalBar = false;
			m_scalePercentage = scalePercentage;
		}

		public abstract void ResetVitals();

		public void ResetVitalBar()
		{
			m_changeValueText.alpha = 0f;
			m_changeValueText.enabled = false;
			m_vitalBar.fillAmount = m_statsData.Fill;
			m_barTotalHighlightTransform.anchoredPosition = GetHighlightPosition(m_statsData.Fill);
			m_vitalSpent.fillAmount = m_statsData.Fill;
			UpdateCurrentValueText();
			HideVitalBar(0.99f);
		}

		public virtual void OnSpellSelected(int currentCastCost, bool tryEnable)
		{
			m_currentCastCost = currentCastCost;
		}

		public void SetCastCostIndicatorActive(bool active)
		{
			m_castCostHighlightTransform.gameObject.SetActive(active);
		}

		public void UpdateChangeValue()
		{
			if (m_changeMainFillAmount)
			{
				UpdateMainBarFillAmount();
			}
			else if (m_changeSpentFillAmount)
			{
				UpdateSpentBarFillAmount();
			}
			if (m_isScalingVitalBar)
			{
				ScaleUp();
			}
			else if (m_scalePercentage < 1f)
			{
				ScaleDown();
				FadeOutChangeValue();
			}
		}

		protected abstract void AddFillAmount(float fillAmount, float changeValue);

		protected abstract void SubtractFillAmount(float fillAmount, float changeValue);

		protected void HighlightVitalBar()
		{
			if (!m_isScalingVitalBar)
			{
				m_scalePercentage = 0f;
				m_isScalingVitalBar = true;
			}
		}

		private void ScaleUp()
		{
			if (!(m_scalePercentage >= 1f))
			{
				m_scalePercentage += Time.deltaTime / 0.1f;
				m_vitalBarParent.localScale = Vector3.Lerp(m_originalScale, m_highlightScale, m_scalePercentage);
			}
		}

		private void ScaleDown()
		{
			m_scalePercentage += Time.deltaTime / 0.1f;
			m_vitalBarParent.localScale = Vector3.Lerp(m_highlightScale, m_originalScale, m_scalePercentage);
		}

		private void UpdateMainBarFillAmount()
		{
			if (m_fillUpdateHoldTime < 1f)
			{
				m_fillUpdateHoldTime += Time.deltaTime;
			}
			else if (m_fillPercentage < 1f)
			{
				m_fillPercentage += Time.deltaTime / m_currentFillTime;
				m_vitalBar.fillAmount = Mathf.Lerp(m_startFillAmount, m_targetFillAmount, m_fillPercentage);
			}
			else
			{
				HideVitalBar();
			}
		}

		private void UpdateSpentBarFillAmount()
		{
			if (m_fillUpdateHoldTime < 1f)
			{
				m_fillUpdateHoldTime += Time.deltaTime;
			}
			else if (m_fillPercentage < 1f)
			{
				m_fillPercentage += Time.deltaTime / m_currentFillTime;
				m_vitalSpent.fillAmount = Mathf.Lerp(m_currentSpentValue, m_targetSpentValue, m_fillPercentage);
				m_barTotalHighlightTransform.anchoredPosition = Vector2.Lerp(m_currentHighlightPos, m_targetHighlightPos, m_fillPercentage);
			}
			else
			{
				HideVitalBar();
			}
		}

		protected void UpdateCurrentValueText()
		{
			m_currentValueText.text = m_statsData.ReadableCurrent;
		}

		protected void UpdateChangeValueText(float changeValue)
		{
			m_combinedChangeValue += changeValue;
			m_changeValueText.enabled = true;
			m_changeValueText.text = GetChangeValueString();
			m_changeValueText.alpha = 1f;
		}

		protected Vector2 GetHighlightPosition(float t, bool reversed = false)
		{
			if (reversed)
			{
				return Vector2.Lerp(m_highlightMaxPosition, m_highlightMinPosition, t);
			}
			return Vector2.Lerp(m_highlightMinPosition, m_highlightMaxPosition, t);
		}

		private void FadeOutChangeValue()
		{
			m_changeValueText.enabled = true;
			m_changeValueText.alpha = Mathf.Lerp(1f, 0f, m_scalePercentage);
			if (m_scalePercentage >= 1f)
			{
				m_combinedChangeValue = 0f;
				m_changeValueText.enabled = false;
			}
		}

		private string GetChangeValueString()
		{
			if (m_combinedChangeValue > 0f)
			{
				return $"+{m_combinedChangeValue.RoundToDecimal(1)}";
			}
			if (m_combinedChangeValue < 0f)
			{
				return m_combinedChangeValue.RoundToDecimal(1).ToString();
			}
			return string.Empty;
		}
	}
}
namespace Assets.Scripts.UI.HUD
{
	[RequireComponent(typeof(AudioSource))]
	public class WandMeshStatsHandler : MonoBehaviour
	{
		[SerializeField]
		private AudioClip[] m_manaSounds = new AudioClip[2];

		[SerializeField]
		private HapticsData m_canCastHapticsData;

		[SerializeField]
		private float m_lerpSpeed = 0.5f;

		[SerializeField]
		private Color m_insufficientManaColor = Color.yellow;

		[SerializeField]
		private Color m_armorHealthColor = Color.yellow;

		[SerializeField]
		private Renderer m_totalMana;

		[SerializeField]
		private Renderer m_manaSpent;

		[SerializeField]
		private Renderer m_manaCost;

		[SerializeField]
		private Renderer m_healthTotal;

		[SerializeField]
		private Renderer m_healthSpent;

		private StatsData m_healthData;

		private StatsData m_manaData;

		private Wielder m_wielder;

		private Renderer m_aimRenderer;

		private AudioSource m_audioSource;

		private Color m_manaColorStart;

		private Color m_healthNoiseColorStart;

		private EventToken m_armorActivationEventToken;

		private WandControlOneHand Wand
		{
			[CompilerGenerated]
			get
			{
				return m_wielder.Wand.GetWandControl() as WandControlOneHand;
			}
		}

		private void OnEnable()
		{
			m_armorActivationEventToken = EventHub.Subscribe<Events.ArmorActivationEvent>(OnArmorActivated);
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe<Events.ArmorActivationEvent>(m_armorActivationEventToken);
		}

		public void SetReferences(StatsData healthData, StatsData manaData)
		{
			m_healthData = healthData;
			m_manaData = manaData;
			m_wielder = PlayerManager.Instance.LocalWielder;
			m_manaColorStart = m_totalMana.material.color;
			m_healthNoiseColorStart = m_healthTotal.material.GetColor("_NoiseColor");
			m_audioSource = GetComponent<AudioSource>();
		}

		private void Update()
		{
			if (base.gameObject.activeSelf)
			{
				bool? flag = PunSingleton<SceneControl>.Instance?.GameOver;
				if ((!flag.HasValue || !flag.Value) && !(m_wielder == null))
				{
					UpdateHealth();
					UpdateMana();
				}
			}
		}

		private void OnArmorActivated(Events.ArmorActivationEvent eventData)
		{
			SetArmorActive(eventData.IsActive);
		}

		private void SetArmorActive(bool active)
		{
			m_healthTotal.material.SetColor("_NoiseColor", (!active) ? m_healthNoiseColorStart : m_armorHealthColor);
		}

		private void UpdateHealth()
		{
			m_healthTotal.material.SetFloat("_MaxValue", m_healthData.Fill);
			if (m_healthSpent.material.GetFloat("_MaxValue") > m_healthData.Fill)
			{
				m_healthSpent.material.SetFloat("_MaxValue", m_healthSpent.material.GetFloat("_MaxValue") - Time.deltaTime * m_lerpSpeed);
			}
			else
			{
				m_healthSpent.material.SetFloat("_MaxValue", m_healthData.Fill);
			}
			m_healthSpent.material.SetFloat("_LowValue", m_healthData.Fill);
		}

		private void UpdateMana()
		{
			if (Wand == null)
			{
				return;
			}
			m_totalMana.material.SetFloat("_MaxValue", m_manaData.Fill);
			if (m_manaSpent.material.GetFloat("_MaxValue") > m_manaData.Fill)
			{
				m_manaSpent.material.SetFloat("_MaxValue", m_manaSpent.material.GetFloat("_MaxValue") - Time.deltaTime * m_lerpSpeed);
			}
			else
			{
				m_manaSpent.material.SetFloat("_MaxValue", m_manaData.Fill);
			}
			m_manaSpent.material.SetFloat("_LowValue", m_manaData.Fill);
			if ((float)Wand.ActiveSpell.GetCastCost() / m_manaData.Max > m_manaData.Fill)
			{
				if (m_totalMana.material.color != m_insufficientManaColor)
				{
					m_totalMana.material.color = m_insufficientManaColor;
					PlaySfx(0);
				}
			}
			else if (m_totalMana.material.color != m_manaColorStart)
			{
				m_totalMana.material.color = m_manaColorStart;
				m_wielder.PlayerControl?.Input?.TriggerHaptics(m_canCastHapticsData, overrideCurrent: false);
				PlaySfx(1);
			}
			m_manaCost.material.SetFloat("_MaxValue", m_manaData.Fill);
			if (Wand.ActiveSpell.CostType == CostType.Mana)
			{
				m_manaCost.material.SetFloat("_LowValue", m_manaData.Fill - (float)Wand.ActiveSpell.GetCastCost() / m_manaData.Max);
			}
			else
			{
				m_manaCost.material.SetFloat("_LowValue", m_manaData.Fill);
			}
		}

		private void PlaySfx(int clipIndex)
		{
			if (!(m_audioSource == null))
			{
				if (m_audioSource.isPlaying && m_audioSource.clip != m_manaSounds[clipIndex])
				{
					m_audioSource.Stop();
				}
				m_audioSource.clip = m_manaSounds[clipIndex];
				m_audioSource.Play();
			}
		}
	}
}
namespace Assets.Scripts.UI
{
	public class IconAtlasHandler
	{
		private static SpriteAtlas m_menuAtlas;

		private static SpriteAtlas m_spellAtlas;

		private static void LoadMenuAtlas()
		{
			m_menuAtlas = GameControl.Instance.AssetHandler.LoadAsset<SpriteAtlas>(AssetBundleType.CombinedUI, "GameIconAtlas");
		}

		private static void LoadSpellAtlas()
		{
			m_spellAtlas = GameControl.Instance.AssetHandler.LoadAsset<SpriteAtlas>(AssetBundleType.CombinedUI, "SpellIconAtlas");
		}

		public static Sprite GetMenuSprite(string spriteName)
		{
			if (m_menuAtlas == null)
			{
				LoadMenuAtlas();
			}
			return m_menuAtlas.GetSprite(spriteName);
		}

		public static Sprite GetSpellSprite(Spell spellType)
		{
			if (m_spellAtlas == null)
			{
				LoadSpellAtlas();
			}
			return m_spellAtlas.GetSprite(spellType.ToString().Replace("Spell_", "Icon_"));
		}
	}
	public class InteractBtn : InteractObject
	{
		[Header("Button")]
		[SerializeField]
		protected TextMeshProUGUI m_text;

		[SerializeField]
		protected TextMeshProUGUI m_toolTip;

		[SerializeField]
		protected Localize m_toolTipLocalize;

		protected Color[] m_textColors;

		protected bool m_enabled = true;

		public override void Start()
		{
			base.gameObject.layer = LayerMask.NameToLayer("InteractObj");
			SetTextColors();
			ToggleTooltip(active: false);
		}

		protected virtual void SetTextColors()
		{
			m_textColors = new Color[3]
			{
				Colors.TextGold,
				Colors.TextHighlight,
				Colors.TextInactive
			};
		}

		protected override void Interact()
		{
			PunSingleton<SoundManager>.Instance.PlayLocalSoundAtPoint("menu_click01", 1f, base.transform.position, 1);
		}

		protected override void Interact(InputButtons inputBtn)
		{
			PunSingleton<SoundManager>.Instance.PlayLocalSoundAtPoint("menu_click01", 1f, base.transform.position, 1);
		}

		protected override void LookEnter()
		{
			if (m_enabled && m_textColors != null && m_textColors.Length >= 3 && !_isHighlighted)
			{
				_isHighlighted = true;
				PunSingleton<SoundManager>.Instance.PlayLocalSoundAtPoint("menu_click02", 1f, base.transform.position, 1);
				SetColor(m_textColors[1]);
				ToggleTooltip(active: true);
			}
		}

		protected override void LookExit()
		{
			if (m_enabled && m_textColors != null && m_textColors.Length >= 3)
			{
				_isHighlighted = false;
				SetColor(m_textColors[0]);
				ToggleTooltip(active: false);
			}
		}

		public virtual void SetActive(bool enable)
		{
			if (m_textColors != null && m_textColors.Length >= 3)
			{
				m_enabled = enable;
				SetColor(m_textColors[(!enable) ? 2 : 0]);
			}
		}

		protected virtual void ToggleTooltip(bool active)
		{
			if (m_toolTip != null)
			{
				m_toolTip.gameObject.SetActive(active);
			}
			else if (m_toolTipLocalize != null)
			{
				m_toolTipLocalize.gameObject.SetActive(active);
			}
		}

		public void SetTooltip(string newTooltip, bool enableTooltip = false)
		{
			if (!(m_toolTip == null))
			{
				m_toolTip.text = newTooltip;
				if (enableTooltip)
				{
					ToggleTooltip(active: true);
				}
			}
		}

		public void SetTooltipTerm(string newTerm, bool enableTooltip = false)
		{
			if (!(m_toolTipLocalize == null))
			{
				m_toolTipLocalize.SetTerm(newTerm);
				if (enableTooltip)
				{
					ToggleTooltip(active: true);
				}
			}
		}

		public void SetText(string newText)
		{
			if (!(m_text == null))
			{
				m_text.text = newText;
			}
		}

		public Color GetColor()
		{
			if (m_text == null)
			{
				return Color.white;
			}
			return m_text.color;
		}

		public virtual void SetColor(Color newColor)
		{
			if (!(m_text == null))
			{
				m_text.color = newColor;
			}
		}
	}
}
namespace Assets.Scripts.UI.Lobby
{
	public class AIOptions : MonoBehaviour
	{
		private const int DefaultPlayerLevel = 10;

		private const int DefaultBotDifficultyLevel = 3;

		[SerializeField]
		private Transform m_menusParent;

		[SerializeField]
		private GameObject m_menuGo;

		private List<AIDifficultyButtonToggler> m_buttons = new List<AIDifficultyButtonToggler>(5);

		private void OnEnable()
		{
			if (BotDifficultyUtils.DifficultyLevel == BotDifficultyLevel.NotSelected)
			{
				int difficultyLevel = (int)Mathf.Lerp(1f, 3f, Mathf.Min(GameControl.Instance.Player.Level, 10) / 10);
				BotDifficultyUtils.DifficultyLevel = (BotDifficultyLevel)difficultyLevel;
			}
		}

		public void AddButton(AIDifficultyButtonToggler button)
		{
			m_buttons.Add(button);
		}

		public void SelectAIDifficulty(BotDifficultyLevel level)
		{
			foreach (AIDifficultyButtonToggler button in m_buttons)
			{
				button.Deselect();
			}
			BotDifficultyUtils.DifficultyLevel = level;
			PlayerManager.Instance.UpdateBotDifficultyProperties();
			Events.BotDifficultySelectedEvent botDifficultySelectedEvent = new Events.BotDifficultySelectedEvent();
			botDifficultySelectedEvent.DifficultyLevel = level;
			EventHub.Publish(botDifficultySelectedEvent);
		}
	}
	public class Banner : MonoBehaviour
	{
		[SerializeField]
		private Texture[] m_flagTextures = Array.Empty<Texture>();

		[SerializeField]
		private GameObject m_playerBanner;

		[SerializeField]
		private GameObject m_playerFlag;

		[SerializeField]
		private GameObject m_playerOrnament;

		[SerializeField]
		private GameObject m_playerWing;

		[SerializeField]
		private Localize m_playerTitle;

		[SerializeField]
		private GameObject m_opponentBanner;

		[SerializeField]
		private GameObject m_opponentFlag;

		[SerializeField]
		private GameObject m_opponentOrnament;

		[SerializeField]
		private GameObject m_opponentWing;

		[SerializeField]
		private Localize m_opponentTitle;

		private EventToken m_wielderSpawnedEventToken;

		private EventToken m_photonPlayerDisconnectedEventToken;

		private EventToken m_postMatchUiSkippedEventToken;

		private MeshRenderer m_playerFlagRenderer;

		private MeshRenderer m_opponentFlagRenderer;

		private RatingTitle m_newPlayerTitle;

		private RatingTitle m_previousPlayerTitle;

		private Coroutine m_flagBurnCoroutine;

		private void Awake()
		{
			m_playerFlagRenderer = m_playerFlag.GetComponent<MeshRenderer>();
			m_opponentFlagRenderer = m_opponentFlag.GetComponent<MeshRenderer>();
			DisablePlayerBanner();
			DisableOpponentBanner();
		}

		private void OnEnable()
		{
			m_wielderSpawnedEventToken = EventHub.Subscribe<Events.WielderSpawnedEvent>(OnWielderSpawned);
			m_photonPlayerDisconnectedEventToken = EventHub.Subscribe<NetworkEvents.PhotonPlayerDisconnectedEvent>(PhotonPlayerDisconnected);
			m_postMatchUiSkippedEventToken = EventHub.Subscribe<Events.PostMatchUiSkippedEvent>(PostMatchUiSkipped);
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe<Events.WielderSpawnedEvent>(m_wielderSpawnedEventToken);
			EventHub.Unsubscribe<NetworkEvents.PhotonPlayerDisconnectedEvent>(m_photonPlayerDisconnectedEventToken);
			EventHub.Unsubscribe<Events.PostMatchUiSkippedEvent>(m_postMatchUiSkippedEventToken);
		}

		private void OnWielderSpawned(Events.WielderSpawnedEvent eventData)
		{
			bool isGameFull = PlayerManager.Instance.IsGameFull;
			EnablePlayerBanner();
			if (isGameFull)
			{
				EnableOpponentBanner();
			}
			else if (GameControl.Instance.GetPreviousLevel().ContainsFlag(Level.Arena) && !PhotonNetwork.InRoom)
			{
				EnableOpponentPostBanner();
			}
		}

		private void PhotonPlayerDisconnected(NetworkEvents.PhotonPlayerDisconnectedEvent eventData)
		{
			DisableOpponentBanner();
		}

		private void PostMatchUiSkipped(Events.PostMatchUiSkippedEvent eventData)
		{
			if (m_flagBurnCoroutine != null)
			{
				StopCoroutine(m_flagBurnCoroutine);
				m_flagBurnCoroutine = null;
			}
			EnablePlayerBanner(skipped: true);
			if (PlayerManager.Instance.IsGameFull)
			{
				EnableOpponentBanner();
			}
		}

		private void DisablePlayerBanner()
		{
			m_playerBanner.SetActive(value: false);
		}

		public void DisableOpponentBanner()
		{
			m_opponentBanner.SetActive(value: false);
		}

		private void EnablePlayerBanner(bool skipped = false)
		{
			m_playerBanner.SetActive(value: true);
			int? prevSeasonScore = GameControl.Instance.LobbyArenaControl.PrevSeasonScore;
			int num = ((!prevSeasonScore.HasValue) ? GameControl.Instance.Player.SeasonScore : prevSeasonScore.Value);
			int? updatedSeasonScore = GameControl.Instance.LobbyArenaControl.UpdatedSeasonScore;
			int num2 = ((!updatedSeasonScore.HasValue) ? GameControl.Instance.Player.SeasonScore : updatedSeasonScore.Value);
			if (GameControl.Instance.Player.HasUnlockedRating)
			{
				if (num2 >= 0)
				{
					num2 += 1500;
				}
				if (num >= 0)
				{
					num += 1500;
				}
			}
			m_previousPlayerTitle = PlayerUtils.RatingToTitle(num);
			m_newPlayerTitle = PlayerUtils.RatingToTitle(num2);
			SetCorrectPlayerFlag((!skipped) ? m_previousPlayerTitle : m_newPlayerTitle);
			SetCorrectPlayerTitle((!skipped) ? m_previousPlayerTitle : m_newPlayerTitle);
			SetCorrectSignLook(isPlayer: true, (!skipped) ? m_previousPlayerTitle : m_newPlayerTitle);
		}

		private void EnableOpponentBanner()
		{
			m_opponentBanner.SetActive(value: true);
			Photon.Realtime.Player opponent = PlayerManager.Instance.GetOpponent();
			int num = ((opponent != null) ? ((int)PlayerProperty.Get("SS", opponent)) : 0);
			int num2 = ((opponent != null) ? ((int)PlayerProperty.Get("PL", opponent)) : 0);
			if (num2 >= 5 && num >= 0)
			{
				num += 1500;
			}
			RatingTitle opponentRatingTitle = GetOpponentRatingTitle(num);
			SetCorrectOpponentFlag(opponentRatingTitle);
			SetCorrectOpponentTitle(opponentRatingTitle);
			SetCorrectSignLook(isPlayer: false, opponentRatingTitle);
		}

		private void EnableOpponentPostBanner()
		{
			m_opponentBanner.SetActive(value: true);
			JObject jObject = JObject.Parse((string)PlayerProperty.Get("OI"));
			int num = (int)jObject["SeasonScore"];
			int num2 = (int)jObject["Level"];
			if (num2 >= 5 && num >= 0)
			{
				num += 1500;
			}
			RatingTitle opponentRatingTitle = GetOpponentRatingTitle(num);
			SetCorrectOpponentFlag(opponentRatingTitle);
			SetCorrectOpponentTitle(opponentRatingTitle);
			SetCorrectSignLook(isPlayer: false, opponentRatingTitle);
		}

		private static RatingTitle GetOpponentRatingTitle(int score)
		{
			return (!MonoSingleton<NetworkManager>.Instance.CurrentMatchType.ContainsFlag(MatchType.Bot)) ? PlayerUtils.RatingToTitle(score) : RatingTitle.Bot;
		}

		private void SetCorrectPlayerFlag(RatingTitle title)
		{
			m_playerFlagRenderer.material.mainTexture = m_flagTextures[Mathf.Clamp((int)title, 0, m_flagTextures.Length - 1)];
		}

		private void SetCorrectOpponentFlag(RatingTitle title)
		{
			m_opponentFlagRenderer.material.mainTexture = m_flagTextures[Mathf.Clamp((int)title, 0, m_flagTextures.Length - 1)];
		}

		private void SetCorrectPlayerTitle(RatingTitle title)
		{
			m_playerTitle.SetTerm($"Titles/{title}");
		}

		private void SetCorrectOpponentTitle(RatingTitle title)
		{
			m_opponentTitle.SetTerm($"Titles/{title}");
		}

		private void SetCorrectSignLook(bool isPlayer, RatingTitle title)
		{
			GameObject gameObject = ((!isPlayer) ? m_opponentOrnament : m_playerOrnament);
			GameObject gameObject2 = ((!isPlayer) ? m_opponentWing : m_playerWing);
			switch (title)
			{
			case RatingTitle.GoatHerder:
			case RatingTitle.DustCollector:
			case RatingTitle.RelicChaser:
			case RatingTitle.Beyonder:
				gameObject.SetActive(value: false);
				gameObject2.SetActive(value: false);
				break;
			case RatingTitle.Wandsmith:
			case RatingTitle.Outlaw:
			case RatingTitle.Wielder:
			case RatingTitle.Bot:
				gameObject.SetActive(value: true);
				gameObject2.SetActive(value: false);
				break;
			case RatingTitle.Aspirant:
			case RatingTitle.Duelist:
			case RatingTitle.Tactician:
			case RatingTitle.Veteran:
			case RatingTitle.Champion:
			case RatingTitle.GrandMaster:
			case RatingTitle.Legend:
			case RatingTitle.Developer:
				gameObject.SetActive(value: true);
				gameObject2.SetActive(value: true);
				break;
			default:
				throw new NotImplementedException($"{title} not recognized, can't set correct banner ornaments.");
			}
		}

		public void StartPotentialFlagChange(Action callback)
		{
			if (m_previousPlayerTitle != m_newPlayerTitle)
			{
				m_flagBurnCoroutine = StartCoroutine(ChangeFlag(2f, 0.75f, callback));
			}
			else
			{
				callback?.Invoke();
			}
		}

		private IEnumerator ChangeFlag(float burnTime, float delayBetweenBurns, Action callback)
		{
			yield return BurnPlayerFlag(burnTime);
			yield return new WaitForSeconds(delayBetweenBurns);
			yield return ShowPlayerFlag(burnTime);
			callback?.Invoke();
			m_flagBurnCoroutine = null;
		}

		private IEnumerator BurnPlayerFlag(float burnTime)
		{
			float value = 1f;
			while (value > 0f)
			{
				value -= Time.deltaTime / burnTime;
				m_playerFlagRenderer.material.SetFloat("_DissolveValue", Mathf.Clamp01(value));
				yield return null;
			}
		}

		private IEnumerator ShowPlayerFlag(float burnTime)
		{
			SetCorrectPlayerFlag(m_newPlayerTitle);
			SetCorrectSignLook(isPlayer: true, m_newPlayerTitle);
			SetCorrectPlayerTitle(m_newPlayerTitle);
			float value = 0f;
			while (value < 1f)
			{
				value += Time.deltaTime / burnTime;
				m_playerFlagRenderer.material.SetFloat("_DissolveValue", Mathf.Clamp01(value));
				yield return null;
			}
		}
	}
	public class ExperienceHandler : MonoBehaviour
	{
		[SerializeField]
		private Renderer m_currentXpBar;

		[SerializeField]
		private Renderer m_gainXpBar;

		[SerializeField]
		private AudioSource m_audioSource;

		[SerializeField]
		private GameObject m_badgeParent;

		[SerializeField]
		private WandsTweener[] m_badges = Array.Empty<WandsTweener>();

		[SerializeField]
		private TextMeshPro m_levelText;

		[SerializeField]
		private TextMeshPro m_nextLevelText;

		[SerializeField]
		private TextMeshPro m_dustGainText;

		[SerializeField]
		private float m_speed = 1f;

		[SerializeField]
		private float m_delay = 1f;

		[Header("Debug")]
		[SerializeField]
		private TextMeshPro m_debugExperienceGain;

		[SerializeField]
		private TextMeshPro m_debugDustGain;

		private int m_level;

		private int m_currentXp;

		private int m_diff;

		private int m_dustGain;

		private bool m_hasCompletedCalculations;

		private bool m_hasUpdatedEarnedBadges;

		private string m_pendingBagdeName;

		private LobbyArenaControl m_arenaControl;

		private Tweener m_activeTweener;

		private EventToken m_postMatchUiSkippedEventToken;

		public int NextLevel
		{
			[CompilerGenerated]
			get
			{
				return int.Parse(m_nextLevelText.text);
			}
		}

		public event Action<int> PlayerLevelUp;

		private void OnEnable()
		{
			m_postMatchUiSkippedEventToken = EventHub.Subscribe<Events.PostMatchUiSkippedEvent>(OnPostMatchUiSkipped);
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe<Events.PostMatchUiSkippedEvent>(m_postMatchUiSkippedEventToken);
		}

		private void Awake()
		{
			ResetExperienceHUD();
			ResetDebugText(disable: false);
		}

		private void OnPostMatchUiSkipped(Events.PostMatchUiSkippedEvent eventData)
		{
			PostMatchUiSkipped();
		}

		public void SetHasCompletedCalculations(bool value)
		{
			m_hasCompletedCalculations = value;
		}

		private void SetPlayerStatsActual()
		{
			int level = GameControl.Instance.Player.SaveData.LevelData.Level;
			SetPlayerLevels(level);
			m_currentXpBar.material.SetFloat("_MaxValue", (float)GameControl.Instance.Player.SaveData.LevelData.CurrentExperience / (float)PlayerUtils.LevelToXp(level));
		}

		public void PostMatchUiSkipped()
		{
			if (m_hasCompletedCalculations)
			{
				return;
			}
			m_hasCompletedCalculations = true;
			if (m_activeTweener != null)
			{
				m_activeTweener.Kill();
			}
			m_audioSource.Stop();
			int num = int.Parse(m_levelText.text);
			int level = GameControl.Instance.Player.SaveData.LevelData.Level;
			SetPlayerLevels(level);
			if (GameControl.Instance.Player.IsAtMaximumLevel())
			{
				MonoSingleton<LobbyUI>.Instance?.ShowFreeToPlayText();
			}
			else
			{
				UpdateAvailableBadges();
				ShowAllEarnedBadges();
				if (num < level)
				{
					if (level >= 100)
					{
						GameControl.Instance.UnlockAchievement(Assets.Scripts.Enums.AchievementType.ReachLevel100);
					}
					SetCurrentXp(0f);
					if (this.PlayerLevelUp != null)
					{
						this.PlayerLevelUp(level);
					}
				}
				m_gainXpBar.material.SetFloat("_MaxValue", (float)GameControl.Instance.Player.SaveData.LevelData.CurrentExperience / (float)PlayerUtils.LevelToXp(level));
				m_dustGainText.text = $"Dust: {m_arenaControl.TotalDustGain}";
			}
			MonoSingleton<LobbyUI>.Instance?.PostFlowCompleted();
		}

		public void ResetExperienceHUD()
		{
			m_arenaControl = GameControl.Instance.LobbyArenaControl;
			m_badgeParent.SetActive(value: false);
			SetPlayerLevels(m_arenaControl.PlayerLevel);
			float num = (float)m_arenaControl.PlayerExperience / (float)PlayerUtils.LevelToXp(m_arenaControl.PlayerLevel);
			SetCurrentXp(num);
			SetGainedXp(num);
		}

		private void SetCurrentXp(float xpFill)
		{
			m_currentXpBar.material.SetFloat("_MaxValue", xpFill);
		}

		private void SetGainedXp(float xpFill)
		{
			m_gainXpBar.material.SetFloat("_LowValue", xpFill);
			m_gainXpBar.material.SetFloat("_MaxValue", xpFill);
		}

		public void CalculateExperienceGain()
		{
			if (!m_hasCompletedCalculations)
			{
				UpdateAvailableBadges();
				m_level = m_arenaControl.PlayerLevel;
				m_currentXp = m_arenaControl.PlayerExperience;
				m_gainXpBar.material.SetFloat("_MaxValue", (float)m_currentXp / (float)PlayerUtils.LevelToXp(m_level));
				if (!base.gameObject.activeSelf)
				{
					base.gameObject.SetActive(value: true);
				}
				ShowExperienceGain();
			}
		}

		private void ShowExperienceGain()
		{
			if (m_hasCompletedCalculations)
			{
				return;
			}
			if (GameControl.Instance.Player.IsAtMaximumLevel() && m_gainXpBar.material.GetFloat("_MaxValue") == 1f)
			{
				m_hasCompletedCalculations = true;
				m_audioSource.Stop();
				MonoSingleton<LobbyUI>.Instance?.ShowFreeToPlayText();
				MonoSingleton<LobbyUI>.Instance?.PostFlowCompleted();
				return;
			}
			m_audioSource.Stop();
			if (!m_arenaControl.DequeuePlayerBadge(out var matchReward))
			{
				m_hasCompletedCalculations = true;
				MonoSingleton<LobbyUI>.Instance?.PostFlowCompleted();
				return;
			}
			m_pendingBagdeName = matchReward.Type.ToString();
			int num = (int)(matchReward.ExperienceGain * matchReward.ExperienceMultiplier);
			int num2 = (int)(matchReward.DustGain * matchReward.DustMultiplier);
			if (GameControl.Instance.IsDevelopmentBuild)
			{
				SetDebugText(matchReward);
			}
			else
			{
				ResetDebugText(disable: true);
			}
			if (num2 > 0)
			{
				StartCoroutine(StartDustCounter(num2));
			}
			int num3 = m_currentXp + num;
			int num4 = PlayerUtils.LevelToXp(m_level + 1);
			int num5 = num3 - num4;
			if (num5 < 0)
			{
				m_diff = 0;
				float endValue = (float)num3 / (float)num4;
				m_activeTweener = m_gainXpBar.material.DOFloat(endValue, "_MaxValue", m_speed).SetDelay(m_delay).OnStart(OnTweenStart)
					.OnComplete(ShowExperienceGain)
					.SetEase(Ease.Linear);
				m_currentXp += num;
				return;
			}
			m_diff = num5;
			if (GameControl.Instance.Player.CanLevelUp(m_level))
			{
				m_activeTweener = m_gainXpBar.material.DOFloat(1f, "_MaxValue", m_speed * (1f - m_gainXpBar.material.GetFloat("_MaxValue"))).OnStart(OnTweenStart).OnComplete(LevelUp)
					.SetEase(Ease.Linear);
				return;
			}
			m_activeTweener = m_gainXpBar.material.DOFloat(1f, "_MaxValue", m_speed).SetDelay(m_delay).OnStart(OnTweenStart)
				.OnComplete(ShowExperienceGain)
				.SetEase(Ease.Linear);
			m_currentXp += num;
		}

		private IEnumerator StartDustCounter(int amount)
		{
			float steps = (float)amount / m_delay;
			WaitForSeconds waitForSeconds = new WaitForSeconds(m_delay / (float)amount);
			for (int i = 0; (float)i < steps; i++)
			{
				yield return waitForSeconds;
				m_dustGainText.text = $"Dust: {m_dustGain++}";
			}
		}

		private void OnTweenStart()
		{
			UpdateEarnedBadges(m_pendingBagdeName);
			PlayAudioSource();
		}

		private void PlayAudioSource()
		{
			m_audioSource.Play();
		}

		private void LevelUp()
		{
			if (!m_hasCompletedCalculations)
			{
				m_audioSource.Stop();
				SetCurrentXp(0f);
				SetGainedXp(0f);
				m_level++;
				SetPlayerLevels(m_level);
				if (this.PlayerLevelUp != null)
				{
					this.PlayerLevelUp(m_level);
				}
				if (m_level >= 100)
				{
					GameControl.Instance.UnlockAchievement(Assets.Scripts.Enums.AchievementType.ReachLevel100);
				}
				m_currentXp = 0;
				int num = PlayerUtils.LevelToXp(m_level);
				int diff = m_diff;
				int num2 = m_currentXp + diff;
				int num3 = num2 - num;
				if (num3 < 0)
				{
					m_diff = 0;
					float endValue = (float)num2 / (float)num;
					m_activeTweener = m_gainXpBar.material.DOFloat(endValue, "_MaxValue", m_speed).SetDelay(m_delay).OnStart(PlayAudioSource)
						.OnComplete(ShowExperienceGain)
						.SetEase(Ease.Linear);
					m_currentXp += diff;
				}
				else if (GameControl.Instance.Player.CanLevelUp(m_level))
				{
					m_activeTweener = m_gainXpBar.material.DOFloat(1f, "_MaxValue", m_speed * (1f - m_gainXpBar.material.GetFloat("_MaxValue"))).OnStart(OnTweenStart).OnComplete(LevelUp)
						.SetEase(Ease.Linear);
				}
				else
				{
					float endValue2 = (float)(num - 1) / (float)num;
					m_activeTweener = m_gainXpBar.material.DOFloat(endValue2, "_MaxValue", m_speed).SetDelay(m_delay).OnStart(OnTweenStart)
						.OnComplete(ShowExperienceGain)
						.SetEase(Ease.Linear);
					m_currentXp += diff;
				}
			}
		}

		private void ShowAllEarnedBadges()
		{
			if (m_badges.IsNullOrEmpty())
			{
				return;
			}
			WandsTweener[] badges = m_badges;
			foreach (WandsTweener wandsTweener in badges)
			{
				if (m_arenaControl.GetPlayerBadgeEarned(wandsTweener.name))
				{
					wandsTweener.Initiate(null);
				}
			}
		}

		private void UpdateAvailableBadges()
		{
			if (!m_hasUpdatedEarnedBadges && !m_badges.IsNullOrEmpty())
			{
				WandsTweener[] badges = m_badges;
				foreach (WandsTweener wandsTweener in badges)
				{
					wandsTweener.ResetTween();
					wandsTweener.gameObject.SetActive(m_arenaControl.GetBadgeEarned(wandsTweener.name));
				}
				m_hasUpdatedEarnedBadges = true;
				m_badgeParent.SetActive(value: true);
			}
		}

		private void UpdateEarnedBadges(string badgeName)
		{
			if (m_badges.IsNullOrEmpty() || string.IsNullOrEmpty(m_pendingBagdeName))
			{
				return;
			}
			WandsTweener[] badges = m_badges;
			foreach (WandsTweener wandsTweener in badges)
			{
				if (wandsTweener.gameObject.name.Equals(badgeName))
				{
					ShowBadge(wandsTweener);
					break;
				}
			}
		}

		private void ShowBadge(WandsTweener badge)
		{
			PunSingleton<SoundManager>.Instance.PlayLocalSoundAtPoint("ui_badge", 1f, badge.transform.position, 1);
			badge.Initiate(null);
		}

		private void SetPlayerLevels(int currentLevel)
		{
			m_levelText.text = currentLevel.ToString();
			m_nextLevelText.text = (currentLevel + 1).ToString();
		}

		public bool IsExperienceBarFull()
		{
			return m_arenaControl.PlayerExperience == PlayerUtils.LevelToXp(m_arenaControl.PlayerLevel) - 1;
		}

		private void SetDebugText(MatchReward matchReward)
		{
			m_debugExperienceGain.text = $"(exp: {matchReward.ExperienceGain} * {matchReward.ExperienceMultiplier})";
			m_debugDustGain.text = $"(dust: {matchReward.DustGain} * {matchReward.DustMultiplier})";
		}

		private void ResetDebugText(bool disable)
		{
			if (disable)
			{
				m_debugExperienceGain.gameObject.SetActive(value: false);
				m_debugDustGain.gameObject.SetActive(value: false);
			}
			else
			{
				m_debugExperienceGain.text = string.Empty;
				m_debugDustGain.text = string.Empty;
			}
		}
	}
	public class LobbyIconHandler : MonoBehaviour
	{
		private enum IconType
		{
			Token,
			Dust
		}

		[SerializeField]
		private RectTransform[] m_icons;

		[SerializeField]
		private ExperienceHandler m_experienceHandler;

		private int[] m_rewards = new int[2];

		private void OnEnable()
		{
			m_experienceHandler.PlayerLevelUp += OnLeveledUp;
			DisplayCorrectIcons(m_experienceHandler.NextLevel);
		}

		private void OnDisable()
		{
			m_experienceHandler.PlayerLevelUp -= OnLeveledUp;
		}

		private void OnLeveledUp(int newLevel)
		{
			DisplayCorrectIcons(newLevel + 1);
		}

		private void DisplayCorrectIcons(int level)
		{
			m_rewards[0] = PlayerUtils.LevelToSpellUnlocks(level);
			m_rewards[1] = PlayerUtils.LevelToDustReward(level);
			int num = 0;
			for (int i = 0; i < m_icons.Length; i++)
			{
				bool flag = m_rewards[i] > 0;
				m_icons[i].gameObject.SetActive(flag);
				m_icons[i].localPosition = m_icons[0].localPosition + new Vector3((float)num * m_icons[i].sizeDelta.x, 0f, 0f);
				if (flag)
				{
					num++;
				}
			}
		}
	}
	public class LobbyOptions : MonoBehaviour
	{
		[SerializeField]
		private Transform m_menusParent;

		[SerializeField]
		private GameObject m_menuGo;

		[SerializeField]
		private GameObject m_optionGo;

		public void DisableMenus()
		{
			Interactable.LockAllInteraction = true;
			m_menusParent.DOKill(complete: true);
			m_menusParent.DOScale(0f, 0.25f);
		}

		public bool TryCloseOptions()
		{
			if (!m_optionGo.activeSelf)
			{
				return false;
			}
			ToggleOptionsActive(optionsActive: false);
			return true;
		}

		public void ToggleOptionsActive(bool optionsActive)
		{
			Interactable.LockAllInteraction = true;
			m_menusParent.DOKill(complete: true);
			if (optionsActive)
			{
				m_menusParent.DOScale(0f, 0.25f).OnComplete(EnableOptions);
			}
			else
			{
				m_menusParent.DOScale(0f, 0.25f).OnComplete(EnableMenu);
			}
		}

		private void EnableOptions()
		{
			m_menuGo.SetActive(value: false);
			m_optionGo.SetActive(value: true);
			ScaleUp();
		}

		private void EnableMenu()
		{
			m_menuGo.SetActive(value: true);
			m_optionGo.SetActive(value: false);
			ScaleUp();
		}

		private void ScaleUp()
		{
			m_menusParent.DOScale(300f, 0.25f).OnComplete(EnableControls);
		}

		private void EnableControls()
		{
			Interactable.LockAllInteraction = false;
		}
	}
	public class LobbyUI : MonoSingleton<LobbyUI>
	{
		private enum InfoType
		{
			Waiting,
			Paused,
			Close,
			Matchmaking,
			OpponentMissing,
			MatchmakingError,
			OpponentFound
		}

		private const string WinLoseMessage = "WinLoseMsg";

		private const string DrawMessage = "DrawMsg";

		private const string HudEndState = "HUD/EndState/";

		private const string RematchTerm = "Options/Rematch";

		private const string AcceptRematchTerm = "Options/AcceptRematch";

		private readonly string[] m_beaconSounds = new string[3] { "ui_ready_off", "ui_ready_player", "ui_ready_opponent" };

		[SerializeField]
		private GameObject m_lobbyParent;

		[SerializeField]
		private GameObject m_preMatchGo;

		[SerializeField]
		private GameObject m_postMatchGo;

		[SerializeField]
		private GameObject m_connectionLost;

		[SerializeField]
		private GameObject m_scoreText;

		[SerializeField]
		private Banner m_banners;

		[SerializeField]
		private GameObject m_survivalWand;

		[SerializeField]
		private AIOptions m_aiOptions;

		[Header("Tweens")]
		[SerializeField]
		private WandsTweener m_frameTweener;

		[SerializeField]
		private WandsTweenerController m_infoTweenControl;

		[SerializeField]
		private WandsTweenerController m_preTweenControl;

		[SerializeField]
		private WandsTweenerController m_postTweenControl;

		[SerializeField]
		private WandsTweener m_postLineTweener;

		[SerializeField]
		private WandsTweenerController m_ratingTweenControl;

		[SerializeField]
		private WandsTweenerController m_statsTweenControl;

		[SerializeField]
		private WandsTweener m_playerReadyRematchTweener;

		[SerializeField]
		private WandsTweener m_opponentReadyRematchTweener;

		[SerializeField]
		private WandsTweener m_playerRematchRunesTweener;

		[SerializeField]
		private WandsTweener m_opponentRematchRunesTweener;

		[SerializeField]
		private WandsTweener m_playerRematchTextTweener;

		[SerializeField]
		private WandsTweener m_opponentRematchTextTweener;

		[Header("Menus")]
		[SerializeField]
		private LobbyOptions m_lobbyOptions;

		[SerializeField]
		private ReportMenu m_reportMenu;

		[Header("Pre")]
		[SerializeField]
		private TextMeshPro m_timerText;

		[SerializeField]
		private GameObject m_nextArena;

		[SerializeField]
		private TextMeshPro m_arenaName;

		[SerializeField]
		private TextMeshPro m_arenaDescription;

		[SerializeField]
		private GameObject[] m_preGameInfo = Array.Empty<GameObject>();

		[SerializeField]
		private GameObject m_exhibitionMessageGo;

		[SerializeField]
		private GameObject m_developerMessageGo;

		[Header("Post")]
		[SerializeField]
		private RatingHandler m_ratingHandler;

		[SerializeField]
		private ExperienceHandler m_experienceHandler;

		[SerializeField]
		private Localize m_endStateLocalize;

		[SerializeField]
		private LocalizationParamsManager m_endStateParams;

		[SerializeField]
		private LocalizationParamsManager m_matchTimeParams;

		[SerializeField]
		private TextMeshPro m_rematchText;

		[SerializeField]
		private GameObject m_freeToPlayTextObject;

		[SerializeField]
		private WandsTweener m_freeToPlayTextTweener1;

		[SerializeField]
		private WandsTweener m_freeToPlayTextTweener2;

		[SerializeField]
		private GameObject m_badgeObject;

		[Header("Buttons")]
		[SerializeField]
		private GameObject m_centerRematchButton;

		[SerializeField]
		private GameObject m_centerFindNewOpponentButton;

		[SerializeField]
		private GameObject m_centerContinueHostingButton;

		[SerializeField]
		private GameObject m_centerReadyButton;

		[SerializeField]
		private GameObject m_playerVoipButton;

		[SerializeField]
		private GameObject m_opponentVoipButton;

		[SerializeField]
		private Localize m_rematchLocalize;

		private bool m_lobbyFlowCompleted;

		private bool m_isPaused;

		private EventToken m_lobbyPausedEventToken;

		private EventToken m_matchTypeEventToken;

		private EventToken m_countdownStartedEventToken;

		private EventToken m_countdownCanceledEventToken;

		private EventToken m_countdownTimeUpdatedEventToken;

		private EventToken m_finalCountdownStartedEventToken;

		private EventToken m_enterPreMatchEventToken;

		private EventToken m_enterPostMatchEventToken;

		private EventToken m_playerControlSpawnedEventToken;

		private EventToken m_botControlSpawnedEventToken;

		private EventToken m_connectedToMatchLobbyEventToken;

		private EventToken m_connectedToMatchRoomEventToken;

		private EventToken m_connectedToPhotonMasterEventToken;

		private EventToken m_playerReadyEventToken;

		private EventToken m_playerRequestedRematchEventToken;

		private EventToken m_opponentMissingEventToken;

		private EventToken m_matchmakingErrorEventToken;

		private EventToken m_matchmakingStartedEventToken;

		private EventToken m_matchmakingFinishedEventToken;

		private string[] m_rematchInfoText = new string[3] { "HUD/EndState/RematchRequested", "HUD/Notification/Status/OpponentDisconnected", "HUD/Notification/Status/OpponentLeft" };

		private void OnEnable()
		{
			m_enterPreMatchEventToken = EventHub.Subscribe<Events.EnterPreMatchEvent>(OnEnterPreMatch);
			m_enterPostMatchEventToken = EventHub.Subscribe<Events.EnterPostMatchEvent>(OnEnterPostMatch);
			m_matchTypeEventToken = EventHub.Subscribe<Events.MatchTypeUpdatedEvent>(OnMatchTypeUpdated);
			m_playerControlSpawnedEventToken = EventHub.Subscribe<Events.PlayerControlSpawnedEvent>(OnPlayerControlSpawned);
			m_botControlSpawnedEventToken = EventHub.Subscribe<Events.BotControlSpawnedEvent>(OnBotControlSpawned);
			m_lobbyPausedEventToken = EventHub.Subscribe<Events.LobbyPausedEvent>(OnPauseLobby);
			m_countdownStartedEventToken = EventHub.Subscribe<Events.CountdownStartedEvent>(OnCountdownStarted);
			m_countdownCanceledEventToken = EventHub.Subscribe<Events.CountdownCanceledEvent>(OnCountdownCanceled);
			m_countdownTimeUpdatedEventToken = EventHub.Subscribe<Events.CountdownTimeUpdatedEvent>(OnCountdownTimeUpdated);
			m_finalCountdownStartedEventToken = EventHub.Subscribe<Events.FinalCountdownStartedEvent>(OnFinalCountdownStarted);
			m_playerReadyEventToken = EventHub.Subscribe<Events.PlayerReadyEvent>(OnPlayerReady);
			m_playerRequestedRematchEventToken = EventHub.Subscribe<Events.PlayerRequestedRematchEvent>(OnPlayerRequestedRematch);
			m_opponentMissingEventToken = EventHub.Subscribe<Events.OpponentMissingEvent>(OnOpponentMissing);
			m_matchmakingErrorEventToken = EventHub.Subscribe<Events.MatchmakingErrorEvent>(OnMatchmakingError);
			m_matchmakingStartedEventToken = EventHub.Subscribe<Events.MatchmakingStartedEvent>(OnMatchmakingStarted);
			m_matchmakingFinishedEventToken = EventHub.Subscribe<Events.MatchmakingFinishedEvent>(OnMatchmakingFinished);
		}

		protected override void OnDisable()
		{
			base.OnDisable();
			CancelInvoke();
			EventHub.Unsubscribe<Events.EnterPreMatchEvent>(m_enterPreMatchEventToken);
			EventHub.Unsubscribe<Events.EnterPostMatchEvent>(m_enterPostMatchEventToken);
			EventHub.Unsubscribe<Events.MatchTypeUpdatedEvent>(m_matchTypeEventToken);
			EventHub.Unsubscribe<Events.PlayerControlSpawnedEvent>(m_playerControlSpawnedEventToken);
			EventHub.Unsubscribe<Events.BotControlSpawnedEvent>(m_botControlSpawnedEventToken);
			EventHub.Unsubscribe<Events.LobbyPausedEvent>(m_lobbyPausedEventToken);
			EventHub.Unsubscribe<Events.CountdownStartedEvent>(m_countdownStartedEventToken);
			EventHub.Unsubscribe<Events.CountdownCanceledEvent>(m_countdownCanceledEventToken);
			EventHub.Unsubscribe<Events.CountdownTimeUpdatedEvent>(m_countdownTimeUpdatedEventToken);
			EventHub.Unsubscribe<Events.FinalCountdownStartedEvent>(m_finalCountdownStartedEventToken);
			EventHub.Unsubscribe<Events.PlayerReadyEvent>(m_playerReadyEventToken);
			EventHub.Unsubscribe<Events.PlayerRequestedRematchEvent>(m_playerRequestedRematchEventToken);
			EventHub.Unsubscribe<Events.OpponentMissingEvent>(m_opponentMissingEventToken);
			EventHub.Unsubscribe<Events.MatchmakingErrorEvent>(m_matchmakingErrorEventToken);
			EventHub.Unsubscribe<Events.MatchmakingStartedEvent>(m_matchmakingStartedEventToken);
			EventHub.Unsubscribe<Events.MatchmakingFinishedEvent>(m_matchmakingFinishedEventToken);
			if (m_connectedToMatchLobbyEventToken != null)
			{
				EventHub.Unsubscribe<Events.ConnectedToMatchLobby>(m_connectedToMatchLobbyEventToken);
			}
			if (m_connectedToMatchRoomEventToken != null)
			{
				EventHub.Unsubscribe<Events.ConnectedToMatchRoom>(m_connectedToMatchRoomEventToken);
			}
			if (m_connectedToPhotonMasterEventToken != null)
			{
				EventHub.Unsubscribe<Events.ConnectedToPhotonMasterEvent>(m_connectedToPhotonMasterEventToken);
			}
		}

		protected override void Awake()
		{
			base.Awake();
			ChangeToPreState();
			ResetMonolith();
			DisableHolderObjects();
			m_connectionLost.SetActive(value: false);
			ToggleCenterButtons(rematchActive: false, findNewOpponentActive: false, continueHostingActive: false, readyActive: false);
			m_nextArena.SetActive(value: false);
		}

		private void Start()
		{
			ToggleOptionsActive(optionsActive: false);
			SetReportMenuActive(active: false);
			SetPlayerBeaconActive(active: false);
			SetOpponentBeaconActive(active: false);
			SetPlayerRematchRunesActive(active: false);
			SetOpponentRematchRunesActive(active: false);
		}

		private void OnEnterPreMatch(Events.EnterPreMatchEvent eventData)
		{
			EnteredPreMatch();
		}

		private void OnEnterPostMatch(Events.EnterPostMatchEvent eventData)
		{
			EnteredPostMatch();
		}

		private void OnMatchTypeUpdated(Events.MatchTypeUpdatedEvent eventData)
		{
			ToggleExhibitionMatch(eventData.MatchType);
		}

		private void OnPlayerControlSpawned(Events.PlayerControlSpawnedEvent eventData)
		{
			PlayerControlSpawned();
		}

		private void OnBotControlSpawned(Events.BotControlSpawnedEvent eventData)
		{
			BotControlSpawned();
		}

		private void OnCountdownStarted(Events.CountdownStartedEvent eventData)
		{
			CountdownStarted(eventData.Time);
		}

		private void OnCountdownCanceled(Events.CountdownCanceledEvent eventData)
		{
			CountdownCanceled();
		}

		private void OnCountdownTimeUpdated(Events.CountdownTimeUpdatedEvent eventData)
		{
			UpdateTimer(eventData.Time);
		}

		private void OnFinalCountdownStarted(Events.FinalCountdownStartedEvent eventData)
		{
			FinalCountdownStarted();
		}

		private void OnPlayerRequestedRematch(Events.PlayerRequestedRematchEvent eventData)
		{
			UpdateRematchMessage(0, eventData.IsLocalPlayer);
			if (!eventData.IsLocalPlayer)
			{
				m_rematchLocalize.SetTerm("Options/AcceptRematch");
			}
			SetBeaconActive(eventData.IsLocalPlayer, active: true);
			SetRematchRunesActive(eventData.IsLocalPlayer, active: true);
		}

		private void OnPlayerReady(Events.PlayerReadyEvent eventData)
		{
			SetBeaconActive(eventData.IsLocalPlayer, eventData.IsReady);
		}

		private void OnOpponentMissing(Events.OpponentMissingEvent eventData)
		{
			TogglePreInfo(InfoType.OpponentMissing);
			m_nextArena.SetActive(value: false);
		}

		private void OnMatchmakingError(Events.MatchmakingErrorEvent eventData)
		{
			TogglePreInfo(InfoType.MatchmakingError);
			ToggleSurvivalButton(active: true);
		}

		private void OnMatchmakingStarted(Events.MatchmakingStartedEvent eventData)
		{
			TogglePreInfo(InfoType.Matchmaking);
			ToggleSurvivalButton(active: true);
		}

		private void OnMatchmakingFinished(Events.MatchmakingFinishedEvent eventData)
		{
			TogglePreInfo(InfoType.OpponentFound);
			m_nextArena.SetActive(value: false);
			ToggleSurvivalButton(active: false);
			DisableAIOptions();
		}

		private int GetNumberOfInfoTypes()
		{
			return Enum.GetValues(typeof(InfoType)).Length;
		}

		private string[] GetInfoTypeNames()
		{
			return Enum.GetNames(typeof(InfoType));
		}

		public void OnConnectionLost()
		{
			StartCoroutine(OnConnectionLostAsync());
		}

		private IEnumerator OnConnectionLostAsync()
		{
			yield return null;
			DisableHolderObjects();
			yield return null;
			m_lobbyOptions.DisableMenus();
			yield return null;
			m_survivalWand.SetActive(value: false);
			yield return null;
			m_connectionLost.SetActive(value: true);
		}

		public void TrySkipLobbyFlow()
		{
			if (PunSingleton<LobbyManager>.Instance.State == LobbyState.Post && m_postMatchGo.activeSelf && !m_lobbyFlowCompleted)
			{
				m_lobbyFlowCompleted = true;
				SkipLobbyFlow();
			}
		}

		private void SkipLobbyFlow()
		{
			EventHub.Publish(new Events.PostMatchUiSkippedEvent());
		}

		public void PlayerConnected()
		{
			UpdatePregameInfo();
			ToggleSurvivalButton(active: false);
			DisableAIOptions();
			m_playerVoipButton.SetActive(value: true);
			m_opponentVoipButton.SetActive(value: true);
			UpdateNextLevelInfo();
		}

		public void PlayerDisconnected(bool isPreMatch)
		{
			ResetMatchScore();
			if (isPreMatch)
			{
				UpdatePregameInfo();
			}
			ToggleSurvivalButton(isPreMatch);
			MatchType currentMatchType = MonoSingleton<NetworkManager>.Instance.CurrentMatchType;
			bool findNewOpponentActive = !isPreMatch && currentMatchType.ContainsFlag(MatchType.Matchmade);
			bool continueHostingActive = !isPreMatch && currentMatchType.ContainsFlag(MatchType.Casual);
			ToggleCenterButtons(rematchActive: false, findNewOpponentActive, continueHostingActive, readyActive: false);
			SetOpponentBeaconActive(active: false);
			SetOpponentRematchRunesActive(active: false);
			if (isPreMatch)
			{
				SetReportMenuActive(active: false, hideButton: true);
			}
			UpdateRematchMessage((!isPreMatch) ? 2 : (-1));
			if (currentMatchType.ContainsFlag(MatchType.Matchmade))
			{
				m_nextArena.SetActive(value: false);
			}
		}

		private void CountdownStarted(float time)
		{
			ToggleCenterButtons(rematchActive: false, findNewOpponentActive: false, continueHostingActive: false, time > 5f);
			ToggleSurvivalButton(active: false);
		}

		private void CountdownCanceled()
		{
			SetBeaconActive(playerBeacon: false, active: false);
			SetBeaconActive(playerBeacon: true, active: false);
			SetReportMenuActive(active: false);
			ToggleOptionsActive(optionsActive: false);
		}

		private void FinalCountdownStarted()
		{
			ToggleCenterButtons(rematchActive: false, findNewOpponentActive: false, continueHostingActive: false, readyActive: false);
			SetPlayerBeaconActive(active: true);
			SetOpponentBeaconActive(active: true);
			m_lobbyOptions.DisableMenus();
		}

		private void PlayerControlSpawned()
		{
			if (PunSingleton<LobbyManager>.Instance.State != LobbyState.Post)
			{
				ToggleAIOptions(MonoSingleton<NetworkManager>.Instance.CurrentMatchType);
				UpdatePregameInfo();
				ToggleExhibitionMatch(MonoSingleton<NetworkManager>.Instance.CurrentMatchType);
				ActivateMonolith(preLobby: true);
			}
		}

		private void BotControlSpawned()
		{
			if (PunSingleton<LobbyManager>.Instance.State != LobbyState.Post)
			{
				UpdatePregameInfo();
				ToggleExhibitionMatch(MonoSingleton<NetworkManager>.Instance.CurrentMatchType);
				ActivateMonolith(preLobby: true);
			}
		}

		private void ChangeToPreState()
		{
			m_lobbyParent.SetActive(value: true);
		}

		private void EnteredPreMatch()
		{
			if (m_postMatchGo.activeSelf || !m_preMatchGo.activeSelf)
			{
				m_postMatchGo.SetActive(value: false);
				m_preMatchGo.SetActive(value: true);
			}
			UpdateRematchMessage(-1);
			UpdatePregameInfo();
			ToggleExhibitionMatch(MonoSingleton<NetworkManager>.Instance.CurrentMatchType);
			if (MonoSingleton<NetworkManager>.Instance.CurrentMatchType.ContainsFlag(MatchType.Casual) || PlayerManager.Instance.IsEveryoneAvailable)
			{
				UpdateNextLevelInfo();
			}
			SetPlayerBeaconActive(active: false);
			SetOpponentBeaconActive(active: false);
			SetPlayerRematchRunesActive(active: false);
			SetOpponentRematchRunesActive(active: false);
			ToggleCenterButtons(rematchActive: false, findNewOpponentActive: false, continueHostingActive: false, readyActive: false);
			ToggleOptionsActive(optionsActive: false);
			SetReportMenuActive(active: false);
			if (!PlayerManager.Instance.IsGameFull)
			{
				ToggleSurvivalButton(active: true);
			}
		}

		private void EnteredPostMatch()
		{
			ActivateMonolith(preLobby: false);
			UpdateMatchScore();
			m_preMatchGo.SetActive(value: false);
			ToggleSurvivalButton(active: false);
			MatchType currentMatchType = MonoSingleton<NetworkManager>.Instance.CurrentMatchType;
			bool findNewOpponentActive = currentMatchType.ContainsFlag(MatchType.Matchmade);
			if (PlayerManager.Instance.IsGameFull)
			{
				ToggleCenterButtons(rematchActive: true, findNewOpponentActive, continueHostingActive: false, readyActive: false);
			}
			else
			{
				bool continueHostingActive = currentMatchType.ContainsFlag(MatchType.Casual);
				ToggleCenterButtons(rematchActive: false, findNewOpponentActive, continueHostingActive, readyActive: false);
			}
			ShowMatchTime();
			DisplayEndStateMessage(GameControl.Instance.LobbyArenaControl.MatchEndState);
		}

		public void ShowFreeToPlayText()
		{
			if (!m_freeToPlayTextObject.activeInHierarchy)
			{
				m_badgeObject.SetActive(value: false);
				m_freeToPlayTextObject.SetActive(value: true);
				m_freeToPlayTextTweener1.Initiate(null);
				m_freeToPlayTextTweener2.Initiate(null);
			}
		}

		private void ResetMonolith()
		{
			m_frameTweener.ResetTween();
		}

		public void KillMonolithTween()
		{
			m_frameTweener.Initiate(null);
			m_frameTweener.SkipTweener();
		}

		private void ActivateMonolith(bool preLobby)
		{
			PunSingleton<SoundManager>.Instance.PlayLocalSoundAtPoint("ui_frame_appear", 1f, m_frameTweener.transform.position, 1);
			m_frameTweener.Initiate(delegate
			{
				if (preLobby)
				{
					m_preMatchGo.SetActive(value: true);
					OnInfoTweenerCompleted();
				}
				else
				{
					m_postMatchGo.SetActive(value: true);
					m_postLineTweener.Initiate(null);
					m_infoTweenControl.StartTweeners();
					PunSingleton<SoundManager>.Instance.PlayMusic($"ui_match_{GameControl.Instance.LobbyArenaControl.MatchEndState.ToString().ToLower()}", 1f);
				}
			});
		}

		private void DisableHolderObjects()
		{
			m_preMatchGo.SetActive(value: false);
			m_postMatchGo.SetActive(value: false);
		}

		private void ToggleCenterButtons(bool rematchActive, bool findNewOpponentActive, bool continueHostingActive, bool readyActive)
		{
			m_centerRematchButton.SetActive(rematchActive);
			if (rematchActive)
			{
				m_rematchLocalize.SetTerm("Options/Rematch");
			}
			m_centerFindNewOpponentButton.SetActive(findNewOpponentActive);
			m_centerContinueHostingButton.SetActive(continueHostingActive);
			m_centerReadyButton.SetActive(readyActive);
		}

		private void ToggleSurvivalButton(bool active)
		{
			m_survivalWand.SetActive(active);
		}

		private void ToggleExhibitionMatch(MatchType matchType)
		{
			if (PunSingleton<LobbyManager>.Instance.State == LobbyState.Post || matchType != MatchType.Exhibition || PlayerManager.Instance.GetOpponent() == null)
			{
				m_exhibitionMessageGo.SetActive(value: false);
				m_developerMessageGo.SetActive(value: false);
			}
			else
			{
				m_exhibitionMessageGo.SetActive(value: true);
				m_developerMessageGo.SetActive((bool)PlayerProperty.Get("P2", PlayerManager.Instance.GetOpponent()));
			}
		}

		private void ToggleAIOptions(MatchType matchType)
		{
			if (matchType.ContainsFlag(MatchType.Bot))
			{
				m_survivalWand.SetActive(value: false);
				m_aiOptions.gameObject.SetActive(value: true);
			}
			else
			{
				m_survivalWand.SetActive(value: true);
				m_aiOptions.gameObject.SetActive(value: false);
			}
		}

		private void DisableAIOptions()
		{
			m_aiOptions.gameObject.SetActive(value: false);
		}

		private void UpdateNextLevelInfo()
		{
			string text = (string)RoomProperty.GetRoomProperty("A2");
			if (text != string.Empty)
			{
				m_nextArena.SetActive(value: true);
			}
			m_arenaName.text = ScriptLocalization.Get("Levels/" + text);
			m_arenaDescription.text = ScriptLocalization.Get("Levels/Description/" + text);
		}

		public void UpdateTimer(float time)
		{
			if (time < 0f)
			{
				m_timerText.gameObject.SetActive(value: false);
				return;
			}
			if (!m_timerText.gameObject.activeSelf)
			{
				m_timerText.gameObject.SetActive(value: true);
			}
			m_timerText.text = Mathf.RoundToInt(time).ToString();
		}

		public void UpdateRematchMessage(int messageIndex, bool localRequest = false)
		{
			if (m_rematchText == null)
			{
				return;
			}
			if (messageIndex < 0)
			{
				m_rematchText.gameObject.SetActive(value: false);
				return;
			}
			messageIndex = Mathf.Clamp(messageIndex, 0, m_rematchInfoText.Length - 1);
			if (!localRequest)
			{
				m_rematchText.text = ((messageIndex >= m_rematchInfoText.Length) ? string.Empty : ScriptLocalization.Get(m_rematchInfoText[messageIndex]));
				m_rematchText.gameObject.SetActive(value: true);
			}
		}

		private void ResetMatchScore()
		{
			GameControl.Instance.LobbyArenaControl.ResetMatchScores();
			UpdateMatchScore();
		}

		private void UpdateMatchScore()
		{
			if (!(m_scoreText == null))
			{
				int[] matchScores = GameControl.Instance.LobbyArenaControl.MatchScores;
				m_scoreText.GetComponent<LocalizationParamsManager>().SetParameterValue("SCORE", $"{matchScores[0]} - {matchScores[1]}");
			}
		}

		private void ShowMatchTime()
		{
			if (!(m_matchTimeParams == null))
			{
				float matchEndTime = PunSingleton<TimeManager>.Instance.GetMatchEndTime();
				int num = Mathf.FloorToInt(matchEndTime / 60f);
				int num2 = Mathf.FloorToInt(matchEndTime % 60f);
				m_matchTimeParams.SetParameterValue("MATCH_TIME_MIN", num.ToString());
				m_matchTimeParams.SetParameterValue("MATCH_TIME_SEC", num2.ToString());
			}
		}

		private void DisplayEndStateMessage(EndState endState)
		{
			ShowMatchTime();
			string text = string.Empty;
			switch (endState)
			{
			case EndState.Draw:
				text = "DrawMsg";
				break;
			case EndState.Won:
			case EndState.Lost:
				if (m_endStateParams != null)
				{
					m_endStateParams.SetParameterValue("END_STATE", ScriptLocalization.Get("HUD/EndState/" + endState));
				}
				text = "WinLoseMsg";
				break;
			}
			if (m_endStateLocalize == null)
			{
				WandsLogger.LogError("Can't localize End state without localize object!");
			}
			else
			{
				m_endStateLocalize.SetTerm("HUD/EndState/" + text);
			}
		}

		public void PostFlowCompleted()
		{
			m_lobbyFlowCompleted = true;
			(PunSingleton<SoundManager>.Instance as SoundManagerLobby)?.PlayUiFlowComplete();
		}

		public void OnLobbyPaused(bool isPaused)
		{
			m_isPaused = isPaused;
			UpdatePregameInfo();
		}

		private void OnPauseLobby(Events.LobbyPausedEvent eventData)
		{
			OnLobbyPaused(eventData.IsPaused);
		}

		public void ClosePregameInfo()
		{
			TogglePreInfo(InfoType.Close);
		}

		private void UpdatePregameInfo()
		{
			if (!PlayerManager.Instance.IsGameFull)
			{
				if (MonoSingleton<NetworkManager>.Instance.CurrentMatchType.ContainsFlag(MatchType.Matchmade))
				{
					TogglePreInfo(InfoType.Matchmaking);
				}
				else
				{
					TogglePreInfo(InfoType.Waiting);
				}
			}
			else if (m_isPaused)
			{
				TogglePreInfo(InfoType.Paused);
			}
			else
			{
				ClosePregameInfo();
			}
		}

		private void TogglePreInfo(InfoType type)
		{
			if (!m_preGameInfo.IsNullOrEmpty())
			{
				for (int i = 0; i < m_preGameInfo.Length; i++)
				{
					m_preGameInfo[i].SetActive(i == (int)type);
				}
				m_preTweenControl.ResetTweeners();
				m_preTweenControl.StartTweeners();
			}
		}

		public void SetRematchRunesActive(bool playerRunes, bool active)
		{
			if (playerRunes)
			{
				SetPlayerRematchRunesActive(active);
			}
			else
			{
				SetOpponentRematchRunesActive(active);
			}
		}

		private void SetPlayerRematchRunesActive(bool active)
		{
			if (!(m_playerRematchRunesTweener == null) && !(m_playerRematchRunesTweener == null))
			{
				if (active)
				{
					m_playerRematchRunesTweener.Initiate(null);
					m_playerRematchTextTweener.Initiate(null);
				}
				else
				{
					m_playerRematchRunesTweener.ResetTween();
					m_playerRematchTextTweener.ResetTween();
				}
			}
		}

		private void SetOpponentRematchRunesActive(bool active)
		{
			if (!(m_opponentRematchRunesTweener == null) && !(m_opponentRematchTextTweener == null))
			{
				if (active)
				{
					m_opponentRematchRunesTweener.Initiate(null);
					m_opponentRematchTextTweener.Initiate(null);
				}
				else
				{
					m_opponentRematchRunesTweener.ResetTween();
					m_opponentRematchTextTweener.ResetTween();
				}
			}
		}

		public void SetBeaconActive(bool playerBeacon, bool active)
		{
			if (playerBeacon)
			{
				SetPlayerBeaconActive(active);
			}
			else
			{
				SetOpponentBeaconActive(active);
			}
		}

		private void SetPlayerBeaconActive(bool active)
		{
			if (!(m_playerReadyRematchTweener == null))
			{
				PunSingleton<SoundManager>.Instance.PlayLocalSoundAtPoint(m_beaconSounds[active ? 1 : 0], 1f, m_playerReadyRematchTweener.transform.position, 1);
				if (active)
				{
					m_playerReadyRematchTweener.Initiate(null);
				}
				else
				{
					m_playerReadyRematchTweener.ResetTween();
				}
			}
		}

		private void SetOpponentBeaconActive(bool active)
		{
			if (!(m_opponentReadyRematchTweener == null))
			{
				PunSingleton<SoundManager>.Instance.PlayLocalSoundAtPoint(m_beaconSounds[active ? 2 : 0], 1f, m_playerReadyRematchTweener.transform.position, 1);
				if (active)
				{
					m_opponentReadyRematchTweener.Initiate(null);
				}
				else
				{
					m_opponentReadyRematchTweener.ResetTween();
				}
			}
		}

		public void ReceiverPostMatchRematch()
		{
			PunSingleton<LobbyManager>.Instance.RequestRematch();
		}

		public void ReceiverPostMatchFindNewOpponent()
		{
			m_connectedToPhotonMasterEventToken = EventHub.Subscribe<Events.ConnectedToPhotonMasterEvent>(OnConnectedToPhotonMaster);
			MonoSingleton<NetworkManager>.Instance.LeaveRoom();
			m_banners.DisableOpponentBanner();
			ToggleCenterButtons(rematchActive: false, findNewOpponentActive: false, continueHostingActive: false, readyActive: false);
			SetReportMenuActive(active: false, hideButton: true);
		}

		public void ReceiverPostMatchContinueHosting()
		{
			TileManager instance = PunSingleton<TileManager>.Instance;
			if (instance != null)
			{
				instance.UpdateLobbyTile(instance.GetStartTile(0));
				instance.GetStartTile(1).Unoccupy(forced: true);
			}
			PunSingleton<LobbyManager>.Instance.ShowLobbyScenery();
			m_preTweenControl.StartTweeners();
			if (MonoSingleton<NetworkManager>.Instance.CurrentMatchType.ContainsFlag(MatchType.Bot))
			{
				PlayerConnected();
				PunSingleton<LobbyManager>.Instance.StartWaitForOpponent();
			}
			if (MonoSingleton<NetworkManager>.Instance.CurrentMatchType.ContainsFlag(MatchType.Casual))
			{
				PlayerConnected();
			}
			ToggleCenterButtons(rematchActive: false, findNewOpponentActive: false, continueHostingActive: false, readyActive: false);
			SetReportMenuActive(active: false, hideButton: true);
		}

		private void OnConnectedToPhotonMaster(Events.ConnectedToPhotonMasterEvent eventData)
		{
			EventHub.Unsubscribe<Events.ConnectedToPhotonMasterEvent>(m_connectedToPhotonMasterEventToken);
			m_connectedToPhotonMasterEventToken = null;
			m_connectedToMatchLobbyEventToken = EventHub.Subscribe<Events.ConnectedToMatchLobby>(OnConnectedToMatchLobby);
			MonoSingleton<NetworkManager>.Instance.ConnectToMatchLobby();
		}

		private void OnConnectedToMatchLobby(Events.ConnectedToMatchLobby eventData)
		{
			EventHub.Unsubscribe<Events.ConnectedToMatchLobby>(m_connectedToMatchLobbyEventToken);
			m_connectedToMatchLobbyEventToken = null;
			m_connectedToMatchRoomEventToken = EventHub.Subscribe<Events.ConnectedToMatchRoom>(OnConnectedToMatchRoom);
			MonoSingleton<NetworkManager>.Instance.ConnectToMatchRoom(null, RoomCreationType.Create, RoomCreationReason.HostRanked, ArenaUtils.GetRandomArena(GameControl.Instance.GetPreviousLevel().ToArena()), MatchType.Competitive);
		}

		private void OnConnectedToMatchRoom(Events.ConnectedToMatchRoom eventData)
		{
			EventHub.Unsubscribe<Events.ConnectedToMatchRoom>(m_connectedToMatchRoomEventToken);
			m_connectedToMatchRoomEventToken = null;
			PunSingleton<LobbyManager>.Instance.ShowLobbyScenery();
			MonoSingleton<NetworkManager>.Instance.FindMatch();
		}

		public void LeaveRoom(bool quitGame)
		{
			Matchmaker.CancelMatchmaking();
			if (quitGame)
			{
				GameControl.Instance.QuitGame();
				return;
			}
			WandsAnalytics.SendCustomEvent(CustomEventType.player_left_lobby, new Dictionary<string, object> { { "Reason", 4 } });
			GameControl.Instance.LeaveGame(0.1f, penalizePlayer: false, quitGame);
		}

		public bool TryCloseOptions()
		{
			int num = 0;
			if (m_lobbyOptions != null && m_lobbyOptions.TryCloseOptions())
			{
				num++;
			}
			if (m_reportMenu != null && m_reportMenu.TryClose())
			{
				num++;
			}
			return num > 0;
		}

		public void ToggleOptionsActive(bool optionsActive)
		{
			if (m_lobbyOptions != null)
			{
				m_lobbyOptions.ToggleOptionsActive(optionsActive);
			}
		}

		public void SetReportMenuActive(bool active)
		{
			SetReportMenuActive(active, hideButton: false);
		}

		private void SetReportMenuActive(bool active, bool hideButton)
		{
			if (m_reportMenu != null)
			{
				m_reportMenu.SetMenuActive(active);
				if (hideButton)
				{
					m_reportMenu.EnableReporting(enable: false);
				}
			}
		}

		public void OnInfoTweenerCompleted()
		{
			if (m_postTweenControl == null || m_preTweenControl == null)
			{
				WandsLogger.LogError("Post or Pre tweener controller is not defined!");
			}
			else if (PunSingleton<LobbyManager>.Instance.State == LobbyState.Post)
			{
				m_postTweenControl.StartTweeners();
			}
			else
			{
				m_preTweenControl.StartTweeners();
			}
		}

		public void OnPlayerTweenerCompleted()
		{
			if (PunSingleton<LobbyManager>.Instance.State != LobbyState.Post)
			{
				return;
			}
			if (m_ratingHandler == null || m_ratingTweenControl == null)
			{
				OnRatingTweenerCompleted();
				return;
			}
			m_ratingHandler.CalculateRatings();
			if (SeasonControl.SeasonLocked || RoomProperty.GetMatchType() != MatchType.Competitive)
			{
				m_ratingTweenControl.PostMatchUiSkipped();
				OnRatingTweenerCompleted();
			}
			else
			{
				m_ratingTweenControl.StartTweeners();
				m_ratingHandler.StartTweeners(GameControl.Instance.LobbyArenaControl.PrevSeasonScore.Value, GameControl.Instance.LobbyArenaControl.UpdatedSeasonScore.Value);
			}
		}

		public void OnRatingTweenerCompleted()
		{
			if (PunSingleton<LobbyManager>.Instance.State == LobbyState.Post)
			{
				m_banners.StartPotentialFlagChange(OnFlagChangeCompleted);
			}
		}

		public void OnFlagChangeCompleted()
		{
			if (m_statsTweenControl == null)
			{
				WandsLogger.LogError("Stats tweener controller is not defined!");
			}
			else if (!m_statsTweenControl.gameObject.activeSelf)
			{
				OnStatsTweenerCompleted();
			}
			else
			{
				m_statsTweenControl.StartTweeners();
			}
		}

		public void OnStatsTweenerCompleted()
		{
			if (PunSingleton<LobbyManager>.Instance.State == LobbyState.Post)
			{
				if (m_experienceHandler == null)
				{
					WandsLogger.LogError("Experience handler is not defined!");
				}
				else
				{
					m_experienceHandler.CalculateExperienceGain();
				}
			}
		}
	}
	public class PlayerInfoUI : MonoBehaviour
	{
		[Header("Pre Player")]
		[SerializeField]
		private TextMeshPro m_prePlayerName;

		[SerializeField]
		private Localize m_prePlayerTitle;

		[SerializeField]
		private LocalizationParamsManager m_prePlayerTitleParams;

		[Header("Post Player")]
		[SerializeField]
		private TextMeshPro m_postPlayerName;

		[SerializeField]
		private Localize m_postPlayerTitle;

		[SerializeField]
		private LocalizationParamsManager m_postPlayerTitleParams;

		[Header("Pre Opponent")]
		[SerializeField]
		private TextMeshPro m_preOpponentName;

		[SerializeField]
		private Localize m_preOpponentTitle;

		[SerializeField]
		private LocalizationParamsManager m_preOpponentTitleParams;

		[Header("Post Opponent")]
		[SerializeField]
		private TextMeshPro m_postOpponentName;

		[SerializeField]
		private Localize m_postOpponentTitle;

		[SerializeField]
		private LocalizationParamsManager m_postOpponentTitleParams;

		[Header("Post")]
		[SerializeField]
		private TextMeshPro m_playerHealth;

		[SerializeField]
		private TextMeshPro m_opponentHealth;

		[SerializeField]
		private TextMeshPro m_playerMana;

		[SerializeField]
		private TextMeshPro m_opponentMana;

		[SerializeField]
		private TextMeshPro m_playerDamage;

		[SerializeField]
		private TextMeshPro m_opponentDamage;

		[SerializeField]
		private TextMeshPro m_playerPickups;

		[SerializeField]
		private TextMeshPro m_opponentPickups;

		private EventToken m_photonPlayerDisconnectedEventToken;

		private EventToken m_wielderSpawnedEventToken;

		private EventToken m_botControlSpawnedEvent;

		private EventToken m_enterPostMatchEventToken;

		private void OnEnable()
		{
			m_photonPlayerDisconnectedEventToken = EventHub.Subscribe<NetworkEvents.PhotonPlayerDisconnectedEvent>(OnPhotonPlayerDisconnected);
			m_wielderSpawnedEventToken = EventHub.Subscribe<Events.WielderSpawnedEvent>(OnWielderSpawned);
			m_botControlSpawnedEvent = EventHub.Subscribe<Events.BotControlSpawnedEvent>(OnBotControlSpawned);
			m_enterPostMatchEventToken = EventHub.Subscribe<Events.EnterPostMatchEvent>(OnEnterPostMatch);
			if (PlayerManager.Instance.IsGameFull)
			{
				Photon.Realtime.Player opponent = PlayerManager.Instance.GetOpponent();
				if (opponent != null)
				{
					UpdateOpponentInfo(opponent);
				}
			}
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe<NetworkEvents.PhotonPlayerDisconnectedEvent>(m_photonPlayerDisconnectedEventToken);
			EventHub.Unsubscribe<Events.WielderSpawnedEvent>(m_wielderSpawnedEventToken);
			EventHub.Unsubscribe<Events.BotControlSpawnedEvent>(m_botControlSpawnedEvent);
			EventHub.Unsubscribe<Events.EnterPostMatchEvent>(m_enterPostMatchEventToken);
		}

		private void Awake()
		{
			EmptyAllFields();
			EmptyOpponentGameStats();
		}

		private void OnPhotonPlayerDisconnected(NetworkEvents.PhotonPlayerDisconnectedEvent eventData)
		{
			OnPhotonPlayerDisconnected(eventData.PhotonPlayer);
		}

		private void OnPhotonPlayerDisconnected(Photon.Realtime.Player otherPlayer)
		{
			if (otherPlayer != null)
			{
				EmptyAllFields();
				UpdatePlayerInfo(PhotonNetwork.LocalPlayer);
			}
		}

		private void OnWielderSpawned(Events.WielderSpawnedEvent eventData)
		{
			Photon.Realtime.Player owner = eventData.Wielder.Owner;
			if (owner.IsLocal)
			{
				UpdatePlayerInfo(owner);
				if (GameControl.Instance.GetPreviousLevel().ContainsFlag(Level.Arena) && !PhotonNetwork.InRoom)
				{
					UpdateOpponentPostInfo();
				}
			}
			else
			{
				UpdateOpponentInfo(owner);
			}
		}

		private void OnBotControlSpawned(Events.BotControlSpawnedEvent eventData)
		{
			UpdateOpponentInfo(eventData.BotControl.Wielder.Owner);
		}

		private void OnEnterPostMatch(Events.EnterPostMatchEvent eventData)
		{
			UpdatePostMatchInfo();
		}

		private void EmptyAllFields()
		{
			m_prePlayerName.text = string.Empty;
			m_preOpponentName.text = string.Empty;
			m_postPlayerName.text = string.Empty;
			m_postOpponentName.text = string.Empty;
			m_prePlayerTitle.EmptyTerm();
			m_preOpponentTitle.EmptyTerm();
			m_postPlayerTitle.EmptyTerm();
			m_postOpponentTitle.EmptyTerm();
		}

		private void EmptyOpponentGameStats()
		{
			m_opponentHealth.text = string.Empty;
			m_opponentMana.text = string.Empty;
			m_opponentDamage.text = string.Empty;
			m_opponentPickups.text = string.Empty;
		}

		private void UpdatePostMatchInfo()
		{
			if (PunSingleton<LobbyManager>.Instance.State != LobbyState.Post)
			{
				return;
			}
			PlayerMatchStatsData playerData = GameControl.Instance.LobbyArenaControl.PlayerData;
			if (playerData == null)
			{
				WandsLogger.LogError("PlayerInfoUI | No match stats data found for player");
				return;
			}
			m_playerHealth.text = $"{playerData.RemainingHealth}";
			m_playerMana.text = $"{playerData.ManaUsed}";
			m_playerDamage.text = $"{playerData.DamageDealt}";
			m_playerPickups.text = $"{playerData.PickupsUsed}";
			playerData = GameControl.Instance.LobbyArenaControl.OpponentData;
			if (playerData != null)
			{
				m_opponentHealth.text = $"{playerData.RemainingHealth}";
				m_opponentMana.text = $"{playerData.ManaUsed}";
				m_opponentDamage.text = $"{playerData.DamageDealt}";
				m_opponentPickups.text = $"{playerData.PickupsUsed}";
			}
		}

		private void UpdatePlayerInfo(Photon.Realtime.Player Owner)
		{
			string text = ((!string.IsNullOrEmpty(Owner.NickName)) ? Owner.NickName : "Unknown");
			m_prePlayerName.text = text;
			m_postPlayerName.text = text;
			string text2 = (string)PlayerProperty.Get("C3");
			string text3 = text2.ToNumbers();
			string term = text2.TrimEnd(text3.ToCharArray());
			m_prePlayerTitleParams.SetParameterValue("SEASON", text3);
			m_prePlayerTitle.SetTerm(term);
			m_postPlayerTitleParams.SetParameterValue("SEASON", text3);
			m_postPlayerTitle.SetTerm(term);
		}

		private void UpdateOpponentInfo(Photon.Realtime.Player Owner)
		{
			ActuallyUpdateOpponentInfo(Owner);
		}

		private void ActuallyUpdateOpponentInfo(Photon.Realtime.Player Owner)
		{
			string text = ((!string.IsNullOrEmpty(Owner.NickName)) ? Owner.NickName : "Unknown");
			m_preOpponentName.text = text;
			m_postOpponentName.text = text;
			string text2 = (string)PlayerProperty.Get("C3", Owner);
			string text3 = text2.ToNumbers();
			string term = text2.TrimEnd(text3.ToCharArray());
			m_preOpponentTitleParams.SetParameterValue("SEASON", text3);
			m_preOpponentTitle.SetTerm(term);
			m_postOpponentTitleParams.SetParameterValue("SEASON", text3);
			m_postOpponentTitle.SetTerm(term);
		}

		private void UpdateOpponentPostInfo()
		{
			JObject jObject = JObject.Parse((string)PlayerProperty.Get("OI"));
			m_postOpponentName.text = (string)jObject["Name"];
			string text = (string)jObject["Title"];
			string text2 = text.ToNumbers();
			m_postOpponentTitleParams.SetParameterValue("SEASON", text2);
			m_postOpponentTitle.SetTerm(text.TrimEnd(text2.ToCharArray()));
		}

		public static string GetOpponentPlatformName(Photon.Realtime.Player player)
		{
			if (player == null)
			{
				return string.Empty;
			}
			if (PlayerManager.Instance.BotControl != null)
			{
				return string.Empty;
			}
			PlatformType key = (PlatformType)PlayerProperty.Get("P1", player);
			return LocalizationManager.GetTermTranslation(Constants.PlatformIdentifierNames[key]);
		}
	}
	public class RatingHandler : MonoBehaviour
	{
		[SerializeField]
		private AudioSource m_ratingTickSource;

		[Header("Player")]
		[SerializeField]
		private TextMeshPro m_playerRating;

		[SerializeField]
		private TextMeshPro m_playerRatingAddOn;

		[SerializeField]
		private TextMeshPro m_playerRatingParanthesis;

		[SerializeField]
		private TextMeshPro m_debugRating;

		private float m_counterDelay = 1f;

		private float m_counterSpeed = 1f;

		private Tweener m_ratingTweener;

		private Tweener m_addOnTweener;

		private EventToken m_postMatchUiSkippedEventToken;

		private void OnEnable()
		{
			m_postMatchUiSkippedEventToken = EventHub.Subscribe<Events.PostMatchUiSkippedEvent>(OnPostMatchUiSkipped);
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe<Events.PostMatchUiSkippedEvent>(m_postMatchUiSkippedEventToken);
		}

		private void OnPostMatchUiSkipped(Events.PostMatchUiSkippedEvent eventData)
		{
			PostMatchUiSkipped();
		}

		public void CalculateRatings(bool skipped = false)
		{
			int value = GameControl.Instance.LobbyArenaControl.PrevSeasonScore.Value;
			int value2 = GameControl.Instance.LobbyArenaControl.UpdatedSeasonScore.Value;
			if (!GameControl.Instance.Player.HasUnlockedRating)
			{
				EmptyRating();
				return;
			}
			int num = Mathf.Clamp(value2 - value, -32, 32);
			m_playerRating.text = $"{((!skipped) ? value : value2)}";
			m_playerRatingAddOn.text = $"{num}";
			m_playerRatingParanthesis.text = $"({num})";
			if (GameControl.Instance.IsDevelopmentBuild)
			{
				SetDebugRating();
			}
			else
			{
				m_debugRating.gameObject.SetActive(value: false);
			}
		}

		public void StartTweeners(int prevScore, int score)
		{
			if (GameControl.Instance.Player.HasUnlockedRating)
			{
				int diff = Mathf.Clamp(score - prevScore, -32, 32);
				StartPlayerRatingCounter(prevScore, score, diff);
			}
		}

		private void EmptyRating()
		{
			m_playerRating.text = string.Empty;
			m_playerRatingAddOn.text = string.Empty;
			m_playerRatingParanthesis.text = string.Empty;
		}

		private void PostMatchUiSkipped()
		{
			if (m_ratingTweener != null)
			{
				m_ratingTweener.Complete();
			}
			if (m_addOnTweener != null)
			{
				m_addOnTweener.Complete();
			}
			m_ratingTickSource.Stop();
			CalculateRatings(skipped: true);
			EmptyAddOns();
		}

		private void EmptyAddOns()
		{
			m_playerRatingAddOn.text = string.Empty;
		}

		private void OnRatingTickComplete()
		{
			m_ratingTickSource.Stop();
		}

		private void OnRatingTickStart()
		{
			m_ratingTickSource.Play();
		}

		private void StartPlayerRatingCounter(int startValue, int endValue, int diff)
		{
			m_ratingTweener = DOTween.To(SetRatingFloat, startValue, endValue, m_counterSpeed).SetDelay(m_counterDelay).OnStart(OnRatingTickStart)
				.OnComplete(OnRatingTickComplete);
			m_addOnTweener = DOTween.To(SetAddOnFloat, diff, 0f, m_counterSpeed).SetDelay(m_counterDelay);
		}

		private void SetRatingFloat(float value)
		{
			m_playerRating.text = ((int)value).ToString();
		}

		private void SetAddOnFloat(float value)
		{
			m_playerRatingAddOn.text = ((!(value <= 0f)) ? ((int)value).ToString() : string.Empty);
		}

		private void SetDebugRating()
		{
			StringBuilder stringBuilder = new StringBuilder(7);
			stringBuilder.AppendLine("Skill rating previous: " + EloDebugger.SkillRatingPrevious);
			stringBuilder.AppendLine("Skill rating: " + EloDebugger.SkillRating);
			stringBuilder.AppendLine("Skill change base: " + EloDebugger.SkillRatingChangeBase);
			stringBuilder.AppendLine("Skill change: " + EloDebugger.SkillRatingChange);
			stringBuilder.AppendLine("Season score previous: " + EloDebugger.SeasonScorePrevious);
			stringBuilder.AppendLine("Season change base: " + EloDebugger.SeasonScoreChangeBase);
			stringBuilder.AppendLine("Season change: " + EloDebugger.SeasonScoreChange);
			m_debugRating.text = stringBuilder.ToString();
		}
	}
	public class ReportMenu : MonoBehaviour
	{
		[SerializeField]
		private Transform m_menusParent;

		[SerializeField]
		private GameObject m_parentMenu;

		[SerializeField]
		private GameObject m_reportMenu;

		[SerializeField]
		private GameObject m_reportButton;

		private EventToken m_wielderSpawnedToken;

		private EventToken m_levelInitializedToken;

		public bool IsReportMenuActive
		{
			[CompilerGenerated]
			get
			{
				return m_reportMenu.activeSelf;
			}
		}

		private void Awake()
		{
			EnableReporting(enable: false);
			if (!MonoSingleton<NetworkManager>.Instance.CurrentMatchType.ContainsFlag(MatchType.Bot))
			{
				m_levelInitializedToken = EventHub.Subscribe<Events.LevelInitializedEvent>(OnLateEnable);
			}
		}

		private void OnLateEnable(Events.LevelInitializedEvent msg)
		{
			if (PunSingleton<LobbyManager>.Instance.State == LobbyState.Post)
			{
				EnableReporting(enable: true);
			}
			else
			{
				m_wielderSpawnedToken = EventHub.Subscribe<Events.WielderSpawnedEvent>(OnWielderSpawned);
			}
		}

		private void OnDestroy()
		{
			if (m_wielderSpawnedToken != null)
			{
				EventHub.Unsubscribe<Events.WielderSpawnedEvent>(m_wielderSpawnedToken);
			}
			if (m_levelInitializedToken != null)
			{
				EventHub.Unsubscribe<Events.LevelInitializedEvent>(m_levelInitializedToken);
			}
		}

		public void EnableReporting(bool enable)
		{
			m_reportButton.SetActive(enable);
		}

		private void OnWielderSpawned(Events.WielderSpawnedEvent msg)
		{
			if (PlayerManager.Instance.IsGameFull)
			{
				OnOpponentSpawned();
			}
		}

		private void OnOpponentSpawned()
		{
			RegisterOpponent();
			EnableReporting(enable: true);
		}

		private static void RegisterOpponent()
		{
			Photon.Realtime.Player opponent = PlayerManager.Instance.GetOpponent();
			string text = PlayerProperty.Get("PI", opponent) as string;
			string platformId = PlayerProperty.Get("P0", opponent) as string;
			PlatformType platformType = (PlatformType)PlayerProperty.Get("P1", opponent);
			if (!text.IsNullOrEmpty() && text != OpponentHistory.GetLast().PlayFabId)
			{
				OpponentHistory.Register(opponent.NickName, text, platformId, platformType);
			}
		}

		public bool TryClose()
		{
			if (!m_reportMenu.activeSelf)
			{
				return false;
			}
			SetMenuActive(active: false);
			return true;
		}

		public void SetMenuActive(bool active)
		{
			Interactable.LockAllInteraction = true;
			m_menusParent.DOKill(complete: true);
			if (active)
			{
				m_menusParent.DOScale(0f, 0.25f).OnComplete(delegate
				{
					EnableReportMenu(enable: true);
				});
			}
			else
			{
				m_menusParent.DOScale(0f, 0.25f).OnComplete(delegate
				{
					EnableReportMenu(enable: false);
				});
			}
		}

		private void EnableReportMenu(bool enable)
		{
			m_parentMenu.SetActive(!enable);
			m_reportMenu.SetActive(enable);
			ScaleUp();
		}

		private void ScaleUp()
		{
			m_menusParent.DOScale(300f, 0.25f).OnComplete(EnableControls);
		}

		public void DisableMenus()
		{
			Interactable.LockAllInteraction = true;
			m_menusParent.DOKill(complete: true);
			m_menusParent.DOScale(0f, 0.25f);
		}

		private void EnableControls()
		{
			Interactable.LockAllInteraction = false;
		}
	}
	public class SkillBar : MonoBehaviour
	{
		[SerializeField]
		private RectTransform m_gap;

		[SerializeField]
		private GameObject m_playerArrow;

		[SerializeField]
		private GameObject m_opponentArrow;

		[SerializeField]
		private TextMeshPro m_playerName;

		[SerializeField]
		private TextMeshPro m_opponentName;

		[SerializeField]
		private float m_leftPosition;

		[SerializeField]
		private float m_rightPosition;

		[Header("Debug")]
		[SerializeField]
		private int m_debugPlayerRating = -1;

		[SerializeField]
		private int m_debugOpponentRating = -1;

		[SerializeField]
		private string m_debugPlayerName;

		[SerializeField]
		private string m_debugOpponentName;

		private EventToken m_onPhotonPlayerDisconnectedEventToken;

		private EventToken m_onWielderSpawnedEventToken;

		private EventToken m_playerNameUpdatedEventToken;

		private EventToken m_botDifficultySelectedEventToken;

		private void Start()
		{
			EnablePlayerInfo();
			if (PlayerManager.Instance.IsGameFull)
			{
				EnableOpponentInfo();
			}
			else
			{
				DisableOpponentInfo();
			}
		}

		private void OnEnable()
		{
			m_onPhotonPlayerDisconnectedEventToken = EventHub.Subscribe<NetworkEvents.PhotonPlayerDisconnectedEvent>(OnPhotonPlayerDisconnect);
			m_onWielderSpawnedEventToken = EventHub.Subscribe<Events.WielderSpawnedEvent>(OnWielderSpawned);
			m_playerNameUpdatedEventToken = EventHub.Subscribe<Events.PlayerNameUpdated>(OnPlayerNameUpdated);
			m_botDifficultySelectedEventToken = EventHub.Subscribe<Events.BotDifficultySelectedEvent>(OnBotDifficultyUpdated);
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe<NetworkEvents.PhotonPlayerDisconnectedEvent>(m_onPhotonPlayerDisconnectedEventToken);
			EventHub.Unsubscribe<Events.WielderSpawnedEvent>(m_onWielderSpawnedEventToken);
			EventHub.Unsubscribe<Events.PlayerNameUpdated>(m_playerNameUpdatedEventToken);
			EventHub.Unsubscribe<Events.BotDifficultySelectedEvent>(m_botDifficultySelectedEventToken);
		}

		private void OnPlayerNameUpdated(Events.PlayerNameUpdated @event)
		{
			EnableOpponentInfo();
		}

		private void OnBotDifficultyUpdated(Events.BotDifficultySelectedEvent eventData)
		{
			EnableOpponentInfo();
		}

		private void OnWielderSpawned(Events.WielderSpawnedEvent eventData)
		{
			Wielder wielder = eventData.Wielder;
			if (!wielder.IsLocal)
			{
				EnableOpponentInfo();
			}
			else
			{
				EnablePlayerInfo();
			}
		}

		private void OnPhotonPlayerDisconnect(NetworkEvents.PhotonPlayerDisconnectedEvent eventData)
		{
			DisableOpponentInfo();
		}

		private void EnablePlayerInfo()
		{
			m_playerArrow.SetActive(value: true);
			m_playerName.gameObject.SetActive(value: true);
			int rating = GameControl.Instance.Player.Rating;
			string nickName = PhotonNetwork.LocalPlayer.NickName;
			float arrowPosition = GetArrowPosition(rating);
			m_playerArrow.transform.localPosition = new Vector3(arrowPosition, m_playerArrow.transform.localPosition.y, m_playerArrow.transform.localPosition.z);
			m_playerName.text = nickName;
			SetCorrectTextPosition(m_playerName, arrowPosition);
			SetCorrectGap();
		}

		private void EnableOpponentInfo()
		{
			Photon.Realtime.Player opponent = PlayerManager.Instance.GetOpponent();
			m_opponentArrow.SetActive(value: true);
			m_opponentName.gameObject.SetActive(value: true);
			int rating = (int)PlayerProperty.Get("EL", opponent);
			string text = ((opponent == null) ? "Unknown" : ((!string.IsNullOrEmpty(opponent.NickName)) ? opponent.NickName : string.Empty));
			float arrowPosition = GetArrowPosition(rating);
			m_opponentArrow.transform.localPosition = new Vector3(arrowPosition, m_opponentArrow.transform.localPosition.y, m_opponentArrow.transform.localPosition.z);
			m_opponentName.text = text;
			SetCorrectTextPosition(m_opponentName, arrowPosition);
			SetCorrectGap();
		}

		private void DisablePlayerInfo()
		{
			m_playerArrow.SetActive(value: false);
			m_playerName.gameObject.SetActive(value: false);
			DisableGap();
		}

		private void DisableOpponentInfo()
		{
			m_opponentArrow.SetActive(value: false);
			m_opponentName.gameObject.SetActive(value: false);
			DisableGap();
		}

		private float GetArrowPosition(int rating)
		{
			if (rating <= 0)
			{
				return m_leftPosition;
			}
			int[] array = Constants.SkillLevelTitles.Values.ToArray();
			int num = -1;
			int num2 = -1;
			int num3 = -1;
			int[] array2 = array;
			foreach (int num4 in array2)
			{
				if (num4 <= rating)
				{
					num++;
					num2 = num4;
					num3 = num4;
					continue;
				}
				num3 = num4;
				break;
			}
			int num5 = array.Length - 1;
			float num6 = (m_rightPosition - m_leftPosition) / (float)num5;
			float num7 = m_leftPosition + num6 * (float)num;
			float num8 = Mathf.Clamp(Mathf.InverseLerp(num2, num3, rating), 0f, 1f);
			return num7 + num6 * num8;
		}

		private void SetCorrectTextPosition(TextMeshPro text, float arrowPosition)
		{
			Vector3 localPosition = text.transform.localPosition;
			float num = text.GetPreferredValues().x / 2f;
			if (arrowPosition - num < m_leftPosition)
			{
				arrowPosition = m_leftPosition + num;
			}
			else if (arrowPosition + num > m_rightPosition)
			{
				arrowPosition = m_rightPosition - num;
			}
			localPosition.x = arrowPosition;
			text.transform.localPosition = localPosition;
		}

		private void SetCorrectGap()
		{
			float x = m_playerArrow.transform.localPosition.x;
			float x2 = m_opponentArrow.transform.localPosition.x;
			float num = Mathf.Min(x, x2);
			float num2 = Mathf.Max(x, x2);
			float num3 = num2 - num;
			m_gap.sizeDelta = new Vector2(num3, m_gap.sizeDelta.y);
			m_gap.localPosition = new Vector3(num + num3 / 2f, m_gap.transform.localPosition.y, m_gap.transform.localPosition.z);
		}

		private void DisableGap()
		{
			m_gap.sizeDelta = new Vector3(0f, m_gap.sizeDelta.y);
		}
	}
}
public class LocalizationMirusError : MonoBehaviour
{
	public void OnModifyLocalization()
	{
		if (!string.IsNullOrEmpty(Localize.CallBackTerm) && Localize.CallBackTerm.Contains("{NETWORK_VERSION}"))
		{
			Localize.CallBackTerm = Localize.CallBackTerm.Replace("{NETWORK_VERSION}", GameControl.Instance.NetworkVersion);
		}
	}
}
namespace Assets.Scripts.UI
{
	public class MessageSwitcher : MonoBehaviour
	{
		private enum MessageType
		{
			Matchmaking,
			Tips
		}

		[SerializeField]
		private MessageType m_messageType;

		[SerializeField]
		private bool m_randomizeTerm;

		[SerializeField]
		private Localize m_localize;

		[SerializeField]
		private TMP_Text m_text;

		[SerializeField]
		private List<string> m_terms;

		[SerializeField]
		private int[] m_upcomingIndices;

		private int m_currentIndex;

		private const string TipsCategory = "HUD/Notification/Tips";

		private const string MatchmakingCategory = "HUD/Notification/MatchmakingDescriptions";

		private const float TimeBetweenSwitches = 10f;

		private const float FadeTime = 0.5f;

		private const string I2LanguagesPath = "I2Languages";

		private void OnEnable()
		{
			if (m_randomizeTerm)
			{
				m_upcomingIndices.Shuffle();
			}
			m_text.DOFade(1f, 0f);
			m_localize.SetTerm(m_terms[m_upcomingIndices[m_currentIndex]]);
			m_currentIndex = (m_currentIndex + 1) % m_terms.Count;
			StartMessageSwitch();
		}

		private void OnDisable()
		{
			m_text.DOKill();
		}

		private void StartMessageSwitch()
		{
			m_text.DOFade(0f, 0.5f).SetDelay(10f).OnComplete(delegate
			{
				m_localize.SetTerm(m_terms[m_upcomingIndices[m_currentIndex]]);
				m_currentIndex = (m_currentIndex + 1) % m_terms.Count;
				m_text.DOFade(1f, 0.5f).OnComplete(StartMessageSwitch);
			});
		}
	}
	public class PlatformSupportInformation : MonoBehaviour
	{
		[SerializeField]
		private Localize m_text;

		[SerializeField]
		private LocalizationParamsManager m_params;

		public void Start()
		{
			DateTime date = PlatformSupportControl.GetDate();
			if (date <= DateTime.Today)
			{
				m_text.SetTerm("Info/PlatformDeprecated");
				return;
			}
			m_text.SetTerm("Info/PlatformDeprecatedFuture");
			m_params.SetParameterValue("DATE", date.ToString("MMMM dd, yyyy"));
		}
	}
	public class RectTransformSorter : MonoBehaviour
	{
		private enum ButtonSortType
		{
			TopDown,
			Center,
			Scaled,
			BottomUp
		}

		[SerializeField]
		private ButtonSortType m_buttonSortType;

		[SerializeField]
		private List<RectTransform> m_rectTransforms;

		private float m_spacing;

		private void Start()
		{
			if (m_rectTransforms.IsNullOrEmpty())
			{
				WandsLogger.Log("ButtonSorter | Trying to sort null or 0 buttons", LogType.Warning);
				return;
			}
			float y = m_rectTransforms.First().localPosition.y;
			float y2 = m_rectTransforms.Last().localPosition.y;
			int num = m_rectTransforms.Count;
			if (m_buttonSortType == ButtonSortType.Scaled)
			{
				num = m_rectTransforms.Where((RectTransform a) => a.gameObject.activeInHierarchy).Count();
				if (num == 0)
				{
					WandsLogger.Log("ButtonSorter | After removing buttons that should not be enabled, 0 elements were left", LogType.Warning);
					return;
				}
			}
			m_spacing = Mathf.Abs(y2 - y) / (float)((num <= 1) ? 1 : (num - 1));
			List<RectTransform> rectTfs = m_rectTransforms.Where((RectTransform a) => a.gameObject.activeInHierarchy).ToList();
			switch (m_buttonSortType)
			{
			case ButtonSortType.TopDown:
			case ButtonSortType.Scaled:
				Sort(y, rectTfs, up: false);
				break;
			case ButtonSortType.Center:
				CenterSort(y2, y, rectTfs);
				break;
			case ButtonSortType.BottomUp:
				Sort(y2, rectTfs, up: true);
				break;
			}
		}

		private void Sort(float position, List<RectTransform> rectTfs, bool up)
		{
			if (up)
			{
				rectTfs.Reverse();
			}
			short num = -1;
			foreach (RectTransform rectTf in rectTfs)
			{
				rectTf.gameObject.SetActive(value: true);
				rectTf.localPosition = new Vector3(0f, position + (float)(++num) * m_spacing * (float)(up ? 1 : (-1)), 0f);
			}
		}

		private void CenterSort(float bottomPosition, float topPosition, List<RectTransform> rectTfs)
		{
			float num = Mathf.Lerp(bottomPosition, topPosition, 0.5f);
			float position = num + m_spacing * (float)(rectTfs.Count - 1) * 0.5f;
			Sort(position, rectTfs, up: false);
		}
	}
}
public class Scroll : MonoBehaviour
{
	private Renderer m_renderer;

	private const string CUT_OFF = "_Cutoff";

	private Renderer Renderer
	{
		get
		{
			if (m_renderer == null)
			{
				m_renderer = GetComponent<Renderer>();
			}
			return m_renderer;
		}
	}

	public bool IsAnimating { get; private set; }

	public bool IsVisible => Renderer.material.GetFloat("_Cutoff") <= 0.015f;

	private void Start()
	{
		SetScrollVisible(enable: false);
		Renderer.material.renderQueue = 2500;
	}

	public void SetScrollVisible(bool enable)
	{
		SetScrollVisible(enable, 0f, Vector3.zero, Quaternion.identity);
	}

	public void SetScrollVisible(bool enable, float delay, Vector3 pos, Quaternion rotation)
	{
		if (enable)
		{
			if (pos != Vector3.zero)
			{
				base.transform.parent.position = pos;
			}
			if (rotation != Quaternion.identity)
			{
				base.transform.parent.rotation = rotation;
			}
			StopAllCoroutines();
			StartCoroutine("ShowScroll", delay);
		}
		else
		{
			StopAllCoroutines();
			StartCoroutine("HideScroll", delay);
		}
	}

	private IEnumerator ShowScroll(float delay)
	{
		IsAnimating = true;
		yield return new WaitForSeconds(delay);
		float currentValue = 0f;
		while (Renderer.material.GetFloat("_Cutoff") > 0.015f)
		{
			currentValue += Time.deltaTime;
			float t = currentValue / 0.5f;
			Renderer.material.SetFloat("_Cutoff", Mathf.Lerp(1f, 0.015f, t));
			yield return null;
		}
		IsAnimating = false;
	}

	private IEnumerator HideScroll(float delay)
	{
		IsAnimating = true;
		yield return new WaitForSeconds(delay);
		float currentValue = 0f;
		while (Renderer.material.GetFloat("_Cutoff") < 1f)
		{
			currentValue += Time.deltaTime;
			float t = currentValue / 0.5f;
			Renderer.material.SetFloat("_Cutoff", Mathf.Lerp(0.015f, 1f, t));
			yield return null;
		}
		IsAnimating = false;
	}
}
namespace Assets.Scripts.UI.SpellSelection
{
	public abstract class RadialElement : Interactable
	{
		protected const float ICON_SCALE_VALUE = 5.5f;

		[Header("Radial")]
		public Transform m_radialParent;

		[SerializeField]
		private float m_maxScaleMultiplier = 1.25f;

		[SerializeField]
		private TextMeshPro m_tooltipComp;

		protected string m_tooltip;

		protected string m_altTooltip;

		private Vector3 m_maxScale = Vector3.one;

		private Vector3 m_startScale;

		private Vector3 m_endScale;

		private bool m_scale;

		private bool m_elementEnabled = true;

		private float m_time;

		private float m_scaleTime = 0.1f;

		private WandControlOneHand m_wand;

		public bool IsEnabled
		{
			[CompilerGenerated]
			get
			{
				bool? flag = (((object)m_radialParent == null) ? null : m_radialParent.gameObject?.activeSelf);
				return flag.HasValue && flag.Value;
			}
		}

		protected string Tooltip
		{
			[CompilerGenerated]
			get
			{
				return (!m_elementEnabled) ? m_altTooltip : m_tooltip;
			}
		}

		protected WandControlOneHand Wand => (!(m_wand != null)) ? (m_wand = GetComponentInParent<WandControlOneHand>()) : m_wand;

		protected virtual void Start()
		{
			m_maxScale = Vector3.one * m_maxScaleMultiplier;
			if (m_radialParent == null)
			{
				SetElementActive(active: false);
			}
		}

		protected virtual void Update()
		{
			if (m_scale)
			{
				m_time += Time.deltaTime / m_scaleTime;
				m_radialParent.localScale = Vector3.Lerp(m_startScale, m_endScale, m_time);
				if (Mathf.Approximately(m_time, 1f))
				{
					m_scale = false;
					m_time = 0f;
					m_radialParent.localScale = m_endScale;
				}
			}
		}

		public virtual void SetElementActive(bool active)
		{
			LockInteraction(!active);
			LockLook(!active);
			if (m_radialParent != null)
			{
				m_radialParent.gameObject.SetActive(active);
			}
		}

		public void ScaleElement(bool enable)
		{
			if (!(m_radialParent == null))
			{
				m_scale = false;
				m_time = 0f;
				m_startScale = m_radialParent.localScale;
				m_endScale = ((!enable) ? Vector3.one : m_maxScale);
				m_scale = true;
			}
		}

		public void SetTooltip(string s, bool alt = false, bool writeTooltip = false)
		{
			if (!(Wand != null) || Wand.UI.ShowTooltip)
			{
				if (alt)
				{
					m_altTooltip = s;
				}
				else
				{
					m_tooltip = s;
				}
				if (writeTooltip)
				{
					WriteTooltip(Tooltip);
				}
			}
		}

		public void WriteTooltip()
		{
			WriteTooltip(Tooltip);
		}

		protected void WriteTooltip(string s)
		{
			if (!(m_tooltipComp == null) && !(m_tooltipComp.text == s))
			{
				m_tooltipComp.text = s;
			}
		}

		public override void LookEnter()
		{
			if (!base.LookLocked)
			{
				PunSingleton<SoundManager>.Instance.PlaySoundAtPoint("ui_choose", 0.5f, base.transform.position, 1);
				WriteTooltip(Tooltip);
				ScaleElement(enable: true);
			}
			base.LookEnter();
		}

		public override void LookExit()
		{
			WriteTooltip(string.Empty);
			ScaleElement(enable: false);
			base.LookExit();
		}
	}
	public class RadialElement_Option : RadialElement
	{
		[Header("Option")]
		public Option m_option;

		private Image[] m_icons;

		private void OnEnable()
		{
			if (!(PunSingleton<SceneControl>.Instance == null) && m_option == Option.Grip)
			{
				SetElementActive(GameControl.Instance.GetInputAim().ContainsFlag(AimInput.Hand));
			}
		}

		protected override void Start()
		{
			base.Start();
			SetTooltip(ScriptLocalization.Get($"Options/{m_option}"));
			SetTooltip(m_tooltip + " (Locked)", alt: true);
			switch (m_option)
			{
			case Option.None:
				SetElementActive(active: false);
				break;
			case Option.Menu:
				if (MonoSingleton<ArenaUI>.Instance == null)
				{
					SetElementActive(active: false);
					break;
				}
				LockInteraction(locked: true);
				LockLook(locked: true);
				break;
			case Option.Options:
				MonoSingleton<ArenaUI>.Instance?.ToggleOptionsActive(enable: false);
				break;
			case Option.Music:
				ToggleMusic(GameControl.Instance.MusicEnabled);
				break;
			case Option.Grip:
				SetWandGrip(WandsSave.WandGrip);
				SetElementActive(GameControl.Instance.GetInputAim().ContainsFlag(AimInput.Hand));
				break;
			case Option.Quit:
			case Option.PlayerVoIP:
			case Option.OpponentVoIP:
				break;
			}
		}

		public override void Interact()
		{
			base.Interact();
			if (MonoSingleton<ArenaUI>.Instance == null)
			{
				WandsLogger.Log("Radial Option Interact | No HUD instance found!", base.gameObject, LogType.Error);
				return;
			}
			switch (m_option)
			{
			case Option.None:
				break;
			case Option.Menu:
				if (base.Wand == null)
				{
					MonoSingleton<ArenaUI>.Instance?.ToggleMenuActive(enable: false);
					break;
				}
				base.Wand.UI.HighlightedRelic = this;
				base.Wand.UI.ToggleUI(active: false);
				break;
			case Option.Options:
				MonoSingleton<ArenaUI>.Instance.ToggleOptionsActive(enable: true);
				break;
			case Option.Music:
				ToggleMusic(!GameControl.Instance.MusicEnabled);
				break;
			case Option.Grip:
				ToggleWandGrip();
				LookExit();
				break;
			case Option.PlayerVoIP:
				WandsVoip.IsPlayerEnabled = !WandsVoip.IsPlayerEnabled;
				break;
			case Option.OpponentVoIP:
				WandsVoip.IsOpponentEnabled = !WandsVoip.IsOpponentEnabled;
				break;
			case Option.Quit:
				break;
			}
		}

		public override void LookEnter()
		{
			if (m_option == Option.Menu && base.Wand != null)
			{
				base.Wand.UI.HighlightedRelic = this;
			}
			base.LookEnter();
		}

		public override void LookExit()
		{
			if (m_option == Option.Menu && base.Wand?.UI.HighlightedRelic == this)
			{
				base.Wand.UI.HighlightedRelic = null;
				WriteTooltip(string.Empty);
			}
			base.LookExit();
		}

		private void ToggleMusic(bool enable)
		{
			if (PunSingleton<SoundManager>.Instance != null)
			{
				PunSingleton<SoundManager>.Instance.SetOptionalMusicEnabled(enable);
			}
			GameControl.Instance.ToggleMusic(enable);
			SetTooltip($"{ScriptLocalization.Options.Music}:\n{((!enable) ? ScriptLocalization.Options.MusicToggle : ScriptLocalization.Options.Enabled)}");
			ToggleIcons(enable);
		}

		private void ToggleWandGrip()
		{
			SetWandGrip(GameControl.Instance.ToggleWandGrip());
		}

		private void SetWandGrip(WandGrip wandGrip)
		{
			SetTooltip(string.Format("{0}:\n{1}", ScriptLocalization.Get("Options/Aim"), ScriptLocalization.Get($"Options/{wandGrip}")));
			ToggleIcons(wandGrip == WandGrip.Wand);
		}

		private void ToggleIcons(bool enable)
		{
			if (m_icons == null || m_icons.Length == 0)
			{
				m_icons = m_radialParent.RetrieveChild("icon").GetComponentsInChildren<Image>();
			}
			for (int i = 0; i < m_icons.Length; i++)
			{
				m_icons[i].gameObject.SetActive(i == ((!enable) ? 1 : 0));
			}
		}
	}
	public class RadialElement_Rotate : MonoBehaviour
	{
		[SerializeField]
		private Vector3 m_degreesPerSecond = new Vector3(0f, 90f, 0f);

		private void Update()
		{
			base.transform.Rotate(m_degreesPerSecond * Time.deltaTime);
		}

		public void Reset()
		{
			base.transform.localRotation = Quaternion.identity;
			base.enabled = false;
		}
	}
	public class RadialElement_Spell : RadialElement
	{
		[Header("Spell element")]
		[SerializeField]
		private SpriteRenderer m_iconRenderer;

		[SerializeField]
		private Color m_highlightColor;

		[SerializeField]
		private Color m_originalColor;

		[SerializeField]
		private float m_speed = 1f;

		private float m_timeValue;

		private bool m_hasInitialized;

		private bool m_rotateRing;

		private Vector3 m_originalScale;

		private Vector3 m_originalPosition;

		private Quaternion m_originalRotation;

		private Quaternion m_startRot;

		private Quaternion m_endRot;

		private Transform m_ring;

		private Transform m_parent;

		private Transform m_iconTransform;

		private Tweener m_moveTweener;

		private Tweener m_scaleTweener;

		public SpellBase Spell { get; private set; }

		private void OnEnable()
		{
			if (base.Wand.WandInput != WandInput.Point)
			{
				m_moveTweener.Kill();
				m_scaleTweener.Kill();
				ResetParent();
			}
		}

		private void OnDisable()
		{
			ResetRotationValues();
		}

		protected override void Start()
		{
			base.Start();
			LockInteraction(locked: true);
			LockLook(locked: true);
			if (m_iconRenderer == null)
			{
				WandsLogger.LogError(base.name + ", icon renderer not defined for radial element, shutting off");
				SetElementActive(active: false);
				return;
			}
			m_iconTransform = m_iconRenderer.transform;
			m_originalScale = m_iconTransform.localScale;
			m_originalPosition = m_iconTransform.localPosition;
			m_originalRotation = m_iconTransform.localRotation;
		}

		protected override void Update()
		{
			base.Update();
			if (!Mathf.Approximately(m_timeValue, 0f))
			{
				m_timeValue += Time.deltaTime;
				float num = m_timeValue / m_speed;
				SetRingLocalRotation(Quaternion.Lerp(m_startRot, m_endRot, num));
				if (num >= 1f)
				{
					SetEndValue();
				}
			}
		}

		public void Initialize(WandControlOneHand wand, SpellBase spell, Sprite iconSprite)
		{
			if (spell == null)
			{
				WandsLogger.LogError(base.name + ", trying to initialize radial element with null spell, shutting off");
				SetElementActive(active: false);
			}
			else if (!m_hasInitialized)
			{
				m_hasInitialized = true;
				Spell = spell;
				SetTooltip(Spell.GetName());
				if (wand.WandInput == WandInput.Point || spell.Type != Assets.Scripts.Enums.Spell.Spell_Teleport)
				{
					AssignIcon(iconSprite);
				}
				else
				{
					SetElementActive(active: false);
				}
			}
		}

		private void AssignIcon(Sprite sprite)
		{
			m_iconRenderer.sprite = sprite;
			m_parent = m_radialParent;
			m_ring = m_radialParent.GetChild(1);
			SetElementActive(active: true);
		}

		private void SetElementSelected(bool value)
		{
			m_radialParent.GetComponent<Renderer>().material.SetColor("_TintColor", (!value) ? m_originalColor : m_highlightColor);
		}

		public void SelectSpell()
		{
			if (base.Wand.WandInput != WandInput.Point)
			{
				m_iconTransform.SetParent(null);
				m_moveTweener = m_iconTransform.DOMove(base.transform.parent.position, 0.5f);
				m_scaleTweener = m_iconTransform.DOScale(Vector3.zero, 0.5f).OnComplete(ResetParent);
			}
		}

		private void ResetParent()
		{
			if (!(m_parent == null) && !(m_iconTransform == null))
			{
				m_iconTransform.SetParent(m_parent);
				m_iconTransform.localScale = m_originalScale;
				m_iconTransform.localPosition = m_originalPosition;
				m_iconTransform.localRotation = m_originalRotation;
			}
		}

		public override void Interact()
		{
			base.Wand.UI.ToggleUI(active: false);
			base.Interact();
		}

		public override void LookEnter()
		{
			if (base.Wand != null)
			{
				base.Wand.UI.HighlightedRelic = this;
			}
			base.LookEnter();
			StartRotateIcon();
		}

		public override void LookExit()
		{
			if (base.Wand.UI.HighlightedRelic == this)
			{
				base.Wand.UI.HighlightedRelic = null;
				WriteTooltip(string.Empty);
			}
			base.LookExit();
			StopRotateIcon();
		}

		public void DeSelectElement()
		{
			StopRotateIcon();
			ScaleElement(enable: false);
		}

		private void StartRotateIcon()
		{
			if (base.Wand.WandInput != WandInput.Point)
			{
				m_rotateRing = true;
				SetEndValue();
			}
		}

		public void StopRotateIcon()
		{
			if (base.Wand.WandInput != WandInput.Point)
			{
				m_rotateRing = false;
			}
		}

		private void ResetRotationValues()
		{
			m_rotateRing = false;
			m_timeValue = 0f;
			SetRingLocalRotation(Quaternion.identity);
		}

		private void SetRingLocalRotation(Quaternion rotation)
		{
			if (m_ring != null)
			{
				m_ring.localRotation = rotation;
			}
		}

		private void SetEndValue()
		{
			if (m_rotateRing)
			{
				m_startRot = ((!(m_ring.localRotation.eulerAngles == Vector3.zero)) ? Quaternion.identity : Quaternion.Euler(0f, 180f, 0f));
				m_endRot = ((!(m_startRot == Quaternion.identity)) ? Quaternion.identity : Quaternion.Euler(0f, 180f, 0f));
				m_timeValue = 0.001f;
			}
		}
	}
	public class RadialElementRenderer : MonoBehaviour
	{
		[SerializeField]
		private Color m_defaultColor;

		private Renderer m_renderer;

		private Tweener m_scaleTweener;

		private Tweener m_fadeTweener;

		private Renderer Renderer
		{
			get
			{
				if (m_renderer == null)
				{
					m_renderer = GetComponent<Renderer>();
				}
				return m_renderer;
			}
		}

		public void ScaleUp()
		{
			if (m_scaleTweener != null)
			{
				m_scaleTweener.Kill();
			}
			m_scaleTweener = base.transform.DOScale(Vector3.one * 1.3f, 0.25f);
		}

		public void ResetScale()
		{
			if (m_scaleTweener != null)
			{
				m_scaleTweener.Kill();
			}
			m_scaleTweener = base.transform.DOScale(Vector3.one, 0.25f);
		}

		public void SetColor(Color color)
		{
			Renderer.material.SetColor("_TintColor", color);
		}

		public void FadeIn(float fadeTime, float fadeWait, TweenCallback callback)
		{
			if (m_fadeTweener != null)
			{
				m_fadeTweener.Kill();
			}
			Renderer.enabled = true;
			m_fadeTweener = Renderer.material.DOColor(m_defaultColor, "_TintColor", fadeTime).SetDelay(fadeWait).OnComplete(callback);
		}

		public void FadeOut(float fadeTime)
		{
			if (m_fadeTweener != null)
			{
				m_fadeTweener.Kill();
			}
			m_fadeTweener = Renderer.material.DOFade(0f, "_TintColor", fadeTime).OnComplete(delegate
			{
				Renderer.enabled = false;
			});
		}
	}
	[RequireComponent(typeof(InteractableGameObject))]
	public class SpellSlot : MonoBehaviour, IDragObject, IUnlockable
	{
		private static readonly Vector3 sm_originalScale;

		[Header("Spell Slot")]
		public SlotState m_behaviourState = SlotState.Enabled;

		public SpellBase m_spell;

		[SerializeField]
		private Relic m_relic;

		[SerializeField]
		private Collider m_collider;

		private bool m_isSelected;

		private bool m_isHighlighted;

		private bool m_rotateSlot;

		private bool m_rotateLocal;

		private bool m_scaleSlot;

		private Vector3 m_endPosition;

		private Vector3 m_endScale;

		private Quaternion m_endRotation;

		private Transform m_tableParent;

		private WandSlot m_wandSlot;

		private WandSlot m_snapSlot;

		private Interactable m_interactable;

		private static Action<Interactable> sm_lookEnterAction;

		private static Action<Interactable> sm_lookExitAction;

		private static Action<Interactable> sm_interactAction;

		private static EventToken sm_spellSlotSelectedEventToken;

		private static EventToken sm_spellSlotDeselectedEventToken;

		private static EventToken sm_spellInfoUpdatedEventToken;

		private static readonly List<SpellSlot> sm_activeSpellSlots;

		public WandSlot PrevSelectedWandSlot { get; private set; }

		public bool IsMoving { get; private set; }

		public Relic Relic
		{
			get
			{
				if (m_relic == null)
				{
					m_relic = base.transform.GetChild(0).GetComponent<Relic>();
				}
				return m_relic;
			}
		}

		public bool IsBeingDragged { get; private set; }

		public bool IsDraggable
		{
			[CompilerGenerated]
			get
			{
				return (IsBeingDragged || !m_interactable.InteractionLocked) && (m_wandSlot == null || MonoSingleton<SpellSelectUI>.Instance.IsSpellSelectActive);
			}
		}

		public bool IsSnappable
		{
			[CompilerGenerated]
			get
			{
				return m_behaviourState != SlotState.Locked;
			}
		}

		public bool ShouldRaycastToDragPlane
		{
			[CompilerGenerated]
			get
			{
				return true;
			}
		}

		public float DragTime { get; private set; }

		public Vector3 StartingPosition { get; private set; }

		public Quaternion StartingRotation { get; private set; }

		public Collider Collider
		{
			[CompilerGenerated]
			get
			{
				return m_collider;
			}
		}

		public event DragBeginDelegate OnDragBegin;

		public event DragEndDelegate OnDragEnd;

		static SpellSlot()
		{
			sm_originalScale = Vector3.one * 1.5f;
			sm_activeSpellSlots = new List<SpellSlot>();
			sm_lookEnterAction = delegate(Interactable interactable)
			{
				for (int k = 0; k < sm_activeSpellSlots.Count; k++)
				{
					SpellSlot spellSlot3 = sm_activeSpellSlots[k];
					if (spellSlot3.m_interactable == interactable)
					{
						spellSlot3.LookEnter();
					}
				}
			};
			sm_lookExitAction = delegate(Interactable interactable)
			{
				for (int j = 0; j < sm_activeSpellSlots.Count; j++)
				{
					SpellSlot spellSlot2 = sm_activeSpellSlots[j];
					if (spellSlot2.m_interactable == interactable)
					{
						spellSlot2.LookExit();
					}
				}
			};
			sm_interactAction = delegate(Interactable interactable)
			{
				for (int i = 0; i < sm_activeSpellSlots.Count; i++)
				{
					SpellSlot spellSlot = sm_activeSpellSlots[i];
					if (spellSlot.m_interactable == interactable)
					{
						spellSlot.Interact();
					}
				}
			};
		}

		private static void AddSpellSlot(SpellSlot spellSlot)
		{
			if (sm_activeSpellSlots.Count == 0)
			{
				sm_spellInfoUpdatedEventToken = EventHub.Subscribe<Events.SpellInfoUpdatedEvent>(OnSpellInfoUpdated);
				sm_spellSlotSelectedEventToken = EventHub.Subscribe<Events.SpellSlotSelectedEvent>(OnSpellSlotSelected);
				sm_spellSlotDeselectedEventToken = EventHub.Subscribe<Events.SpellSlotDeselectedEvent>(OnSpellSlotDeselected);
			}
			sm_activeSpellSlots.Add(spellSlot);
		}

		private static void RemoveSpellSlot(SpellSlot spellSlot)
		{
			sm_activeSpellSlots.Remove(spellSlot);
			if (sm_activeSpellSlots.Count == 0)
			{
				EventHub.Unsubscribe<Events.SpellInfoUpdatedEvent>(sm_spellInfoUpdatedEventToken);
				EventHub.Unsubscribe<Events.SpellSlotSelectedEvent>(sm_spellSlotSelectedEventToken);
				EventHub.Unsubscribe<Events.SpellSlotDeselectedEvent>(sm_spellSlotDeselectedEventToken);
			}
		}

		private static void OnSpellSlotDeselected(Events.SpellSlotDeselectedEvent eventData)
		{
			for (int i = 0; i < sm_activeSpellSlots.Count; i++)
			{
				sm_activeSpellSlots[i].SpellSlotDeselected(eventData);
			}
		}

		private static void OnSpellSlotSelected(Events.SpellSlotSelectedEvent eventData)
		{
			for (int i = 0; i < sm_activeSpellSlots.Count; i++)
			{
				sm_activeSpellSlots[i].SpellSlotSelected(eventData);
			}
		}

		private static void OnSpellInfoUpdated(Events.SpellInfoUpdatedEvent eventData)
		{
			for (int i = 0; i < sm_activeSpellSlots.Count; i++)
			{
				sm_activeSpellSlots[i].SpellInfoUpdated(eventData);
			}
		}

		private void OnEnable()
		{
			if (m_spell == null)
			{
				base.gameObject.SetActive(value: false);
				return;
			}
			if (GameControl.Instance.IsExpectedConnectionType(ConnectionType.Release) && (!Constants.BaseSpells.Contains(m_spell.Type) || string.IsNullOrEmpty(m_spell.GetName())))
			{
				base.gameObject.SetActive(value: false);
				return;
			}
			AddSpellSlot(this);
			m_interactable.OnLookEnterListeners.Add(sm_lookEnterAction);
			m_interactable.OnLookExitListeners.Add(sm_lookExitAction);
			m_interactable.OnInteractListeners.Add(sm_interactAction);
		}

		private void OnDisable()
		{
			if (!(m_spell == null))
			{
				RemoveSpellSlot(this);
				m_interactable.OnLookEnterListeners.Remove(sm_lookEnterAction);
				m_interactable.OnLookExitListeners.Remove(sm_lookExitAction);
				m_interactable.OnInteractListeners.Remove(sm_interactAction);
			}
		}

		private void Awake()
		{
			m_interactable = GetComponent<Interactable>();
			if (m_spell == null || m_spell.IsType(Spell.Spell_Teleport) || m_spell.IsType(Spell.None))
			{
				return;
			}
			if (!Constants.BaseSpells.Contains(m_spell.Type))
			{
				m_spell = null;
				return;
			}
			m_tableParent = base.transform.parent;
			StartingPosition = m_tableParent.position;
			StartingRotation = base.transform.rotation;
			if (!(m_spell == null))
			{
				if (m_spell.IsType(Spell.Spell_Teleport))
				{
					ToggleParticleEffects(enable: false);
				}
				else
				{
					Relic.AssignIcon(IconAtlasHandler.GetSpellSprite(m_spell.Type), enable: true);
				}
				UpdateStatus();
			}
		}

		private void Update()
		{
			if (IsMoving)
			{
				base.transform.position = Vector3.Lerp(base.transform.position, m_endPosition, Time.deltaTime * 8f);
				if (Vector3.Distance(base.transform.position, m_endPosition) < 0.001f)
				{
					base.transform.position = m_endPosition;
					IsMoving = false;
				}
			}
			if (m_scaleSlot)
			{
				base.transform.localScale = Vector3.Lerp(base.transform.localScale, m_endScale, Time.deltaTime * 8f);
				if (Vector3.Distance(base.transform.localScale, m_endScale) < 0.001f)
				{
					base.transform.localScale = m_endScale;
					m_scaleSlot = false;
				}
			}
			if (!m_rotateSlot)
			{
				return;
			}
			if (m_rotateLocal)
			{
				base.transform.localRotation = Quaternion.Lerp(base.transform.localRotation, m_endRotation, Time.deltaTime * 8f);
				if (Quaternion.Angle(base.transform.localRotation, m_endRotation) < 1f)
				{
					base.transform.localRotation = m_endRotation;
					m_rotateLocal = false;
					m_rotateSlot = false;
				}
			}
			else
			{
				base.transform.rotation = Quaternion.Lerp(base.transform.rotation, m_endRotation, Time.deltaTime * 8f);
				if (Quaternion.Angle(base.transform.rotation, m_endRotation) < 1f)
				{
					base.transform.rotation = m_endRotation;
					m_rotateSlot = false;
				}
			}
		}

		private void UpdateStatus()
		{
			if (m_spell == null)
			{
				base.gameObject.SetActive(value: false);
				return;
			}
			Enable(enable: false);
			if (GameControl.Instance.Player.OwnsSpell(m_spell.Type))
			{
				Relic.SetMaterial(ItemMaterialType.Default);
				return;
			}
			m_behaviourState = SlotState.Locked;
			Relic.SetMaterial(ItemMaterialType.Locked);
		}

		public void StopMovement()
		{
			IsMoving = false;
			m_rotateSlot = false;
			m_scaleSlot = false;
		}

		public void ResetSlot()
		{
			MoveAndRotate(StartingPosition, StartingRotation);
			Scale(sm_originalScale);
		}

		public void ResetSlot(WandSlot slot)
		{
			MoveAndRotate(slot.transform.position, slot.transform.rotation);
		}

		private void ResetSnapSlot()
		{
			if (!(m_snapSlot == null))
			{
				m_snapSlot.ScaleRadialElement(scaleUp: false);
				m_snapSlot = null;
			}
		}

		public void SnapToObject(ISnapObject snapObject)
		{
			DragTime += Time.deltaTime;
			if (!(base.transform.position == snapObject.SnapPoint) && (!(m_endPosition == snapObject.SnapPoint) || !IsMoving))
			{
				ResetSnapSlot();
				if (snapObject is WandSlot)
				{
					m_snapSlot = snapObject as WandSlot;
					m_snapSlot.ScaleRadialElement(scaleUp: true);
					PunSingleton<SoundManager>.Instance.PlayLocalSoundAtPoint("relic_back_02", 0.25f, base.transform.position, 1);
					MoveAndRotate(snapObject.SnapPoint, snapObject.SnapRotation);
				}
				else if (snapObject is SpellTableWandSnappable)
				{
					MonoSingleton<SpellSelectUI>.Instance.WorkshopWand.Interact();
				}
			}
		}

		public void MoveAndRotate(Vector3 endPos, Quaternion endRot)
		{
			Move(endPos);
			Rotate(endRot);
		}

		public void Unlock(GameObject vfx)
		{
			StartCoroutine(PlayUnlockVfx(vfx, vfx.transform.RetrieveChild("Relic_Icon")));
		}

		public void Unlock(GameObject vfx, Transform relicParent)
		{
			StartCoroutine(PlayUnlockVfx(vfx, relicParent));
		}

		private IEnumerator PlayUnlockVfx(GameObject vfx, Transform relicParent)
		{
			Interactable.LockAllInteraction = true;
			Interactable.LockAllLook = true;
			yield return MoveToUnlock(vfx.transform.parent, 1f).WaitForCompletion();
			PunSingleton<SoundManager>.Instance.PlayLocalSoundAtPoint("unlock_effect", 1f, vfx.transform.position, 2);
			Relic.ToggleRelicRendererEnabled(enable: false);
			Relic.IconTransform.SetParent(relicParent, ResetBehaviour.Position);
			vfx.SetActive(value: true);
			yield return new WaitForSeconds(3.5f);
			SetEnabled();
			yield return new WaitForSeconds(1.5f);
			Relic.SetMaterial(ItemMaterialType.Default, highlighted: true);
			Relic.ReturnIcon();
			Relic.ToggleRelicRendererEnabled(enable: true);
			vfx.SetActive(value: false);
			yield return ReturnToSlot(1f).WaitForCompletion();
			EventHub.Publish(new Events.SpellUnlockedEvent());
			Interactable.LockAllInteraction = false;
			Interactable.LockAllLook = false;
		}

		public Sequence MoveToUnlock(Transform parent, float time)
		{
			Sequence sequence = DOTween.Sequence();
			sequence.Insert(0f, base.transform.DOMove(parent.position, time));
			sequence.Insert(0f, base.transform.DORotate(parent.eulerAngles, time));
			return sequence;
		}

		public Sequence ReturnToSlot(float time)
		{
			Sequence sequence = DOTween.Sequence();
			sequence.Insert(0f, base.transform.DOMove(StartingPosition, time));
			sequence.Insert(0f, base.transform.DORotate(StartingRotation.eulerAngles, time));
			return sequence;
		}

		public void Scale(Vector3 endScale)
		{
			if (!(base.transform.localScale == endScale) && (!(m_endScale == endScale) || !m_scaleSlot))
			{
				m_endScale = endScale;
				m_scaleSlot = true;
			}
		}

		public void Move(Vector3 endPos)
		{
			if (!(m_endPosition == endPos) || !IsMoving)
			{
				m_endPosition = endPos;
				IsMoving = true;
			}
		}

		public void Rotate(Quaternion endRot, bool local = false)
		{
			if (!(m_endRotation == endRot) || !m_rotateSlot)
			{
				m_endRotation = endRot;
				m_rotateLocal = local;
				m_rotateSlot = true;
			}
		}

		public void OnWandClose(Transform targetTf)
		{
			Move(targetTf.position);
			Rotate(Quaternion.Euler(0f, 90f, 0f), local: true);
			Scale(Vector3.one);
			Relic.ResetPosition(hard: true);
		}

		public void OnWandOpen(Transform targetTf)
		{
			MoveAndRotate(targetTf.position, targetTf.rotation);
			Scale(sm_originalScale);
		}

		public void TurnRelic(float degrees)
		{
			Transform transform = Relic.transform;
			Relic.TweakTransform(transform.position, Quaternion.Euler(transform.localRotation.eulerAngles + new Vector3(0f, 0f, degrees)), transform.localScale, 0.2f, local: false, rotLocal: true);
		}

		public void SetEnabled()
		{
			m_behaviourState = SlotState.Enabled;
			Relic.SetMaterial(ItemMaterialType.Default);
			MonoSingleton<SpellSelectUI>.Instance.RelicHandler?.SetRelicIconSharedMaterial(this, MonoSingleton<SpellSelectUI>.Instance.IsSpellSelectActive);
		}

		private void SpellSlotSelected(Events.SpellSlotSelectedEvent eventData)
		{
			SpellSlot spellSlot = eventData.SpellSlot;
			WandSlot wandSlot = eventData.WandSlot;
			if (spellSlot != this)
			{
				PrevSelectedWandSlot = null;
				return;
			}
			m_wandSlot = wandSlot;
			m_behaviourState = SlotState.Occupied;
			Transform wandSlotTf;
			if (MonoSingleton<SpellSelectUI>.Instance.IsSpellSelectActive)
			{
				OnWandOpen(wandSlot.transform);
			}
			else if (MonoSingleton<SpellSelectUI>.Instance.CanGetWandSlot(wandSlot, out wandSlotTf))
			{
				OnWandClose(wandSlotTf);
			}
		}

		public void DeselectSpellSlot(SpellSlot spellSlot, WandSlot connectedSlot)
		{
			if (!(spellSlot != this))
			{
				PrevSelectedWandSlot = connectedSlot;
				m_wandSlot = null;
				m_behaviourState = SlotState.Enabled;
				ResetSlot();
				if (!MonoSingleton<SpellSelectUI>.Instance.IsSpellSelectActive)
				{
					Relic.ResetPosition(hard: true);
				}
			}
		}

		private void SpellSlotDeselected(Events.SpellSlotDeselectedEvent eventData)
		{
			DeselectSpellSlot(eventData.SpellSlot, null);
		}

		private void SpellInfoUpdated(Events.SpellInfoUpdatedEvent eventData)
		{
			ShowSpellInfo(eventData.SpellSlot);
		}

		private void ShowSpellInfo(SpellSlot spellSlot)
		{
			m_isSelected = spellSlot == this;
			if (!m_isSelected)
			{
				m_interactable.LookExit();
			}
			switch (m_behaviourState)
			{
			case SlotState.Enabled:
				Relic.SetMaterial(ItemMaterialType.Default, m_isSelected);
				break;
			case SlotState.Occupied:
				if (spellSlot != null)
				{
					Relic.SetMaterial(ItemMaterialType.Default, m_isSelected);
				}
				break;
			case SlotState.Locked:
				if (m_spell.IsType(Spell.Spell_Teleport))
				{
					ToggleParticleEffects(m_isSelected);
				}
				else
				{
					Relic.SetMaterial(ItemMaterialType.Locked, m_isSelected);
				}
				break;
			}
		}

		private void Interact()
		{
			if (IsDraggable)
			{
				MonoSingleton<SpellSelectUI>.Instance.ShowInfo(this, m_wandSlot);
			}
		}

		public void BeginDrag(Vector3 dragPoint, Vector3 cameraPoint)
		{
			PunSingleton<SoundManager>.Instance.PlayLocalSoundAtPoint("relic_grab_01", 0.55f, base.transform.position, 1);
			DragTime = 0f;
			if (this.OnDragBegin != null)
			{
				this.OnDragBegin();
			}
			Quaternion endRot = Quaternion.Euler(Quaternion.LookRotation(dragPoint - cameraPoint).eulerAngles + new Vector3(270f, 0f, 0f));
			IsBeingDragged = true;
			LookEnter();
			MonoSingleton<SpellSelectUI>.Instance.BeginDrag(this, m_wandSlot);
			MonoSingleton<SpellSelectUI>.Instance.ShowInfo(this, null);
			switch (m_behaviourState)
			{
			case SlotState.Enabled:
				MoveAndRotate(dragPoint, endRot);
				break;
			case SlotState.Occupied:
				if (m_wandSlot != null)
				{
					MoveAndRotate(m_wandSlot.SnapPoint, m_wandSlot.SnapRotation);
				}
				break;
			}
			if (m_behaviourState.ContainsFlag(SlotState.Undraggable))
			{
				Relic.SetMaterial(ItemMaterialType.Locked);
			}
			else
			{
				Relic.SetMaterial(ItemMaterialType.Default);
			}
		}

		public void Drag(Vector3 dragPoint, Vector3 cameraPoint)
		{
			DragTime += Time.deltaTime;
			Quaternion endRot = Quaternion.Euler(Quaternion.LookRotation(dragPoint - cameraPoint).eulerAngles + new Vector3(270f, 0f, 0f));
			ResetSnapSlot();
			IsMoving = false;
			base.transform.position = ((!((dragPoint - base.transform.position).magnitude > 0.01f)) ? dragPoint : Vector3.Lerp(base.transform.position, dragPoint, Time.deltaTime * 8f));
			Rotate(endRot);
		}

		public void EndDrag()
		{
			if (m_behaviourState.ContainsFlag(SlotState.Undraggable))
			{
				Relic.SetMaterial(ItemMaterialType.Locked, highlighted: true);
			}
			else
			{
				Relic.SetMaterial(ItemMaterialType.Default, highlighted: true);
			}
			if (this.OnDragEnd != null)
			{
				this.OnDragEnd();
			}
			IsBeingDragged = false;
			if (GameControl.Instance.PlayerControl.Input.ClosestSlot != null)
			{
				if (m_behaviourState == SlotState.Occupied)
				{
					MonoSingleton<SpellSelectUI>.Instance.DeSelectSlot(this, m_wandSlot);
				}
				PunSingleton<SoundManager>.Instance.PlayLocalSoundAtPoint("relic_pick", 0.55f, base.transform.position, 1);
				MonoSingleton<SpellSelectUI>.Instance.SelectSlot(this, GameControl.Instance.PlayerControl.Input.ClosestSlot);
			}
			else if (PrevSelectedWandSlot != null)
			{
				PunSingleton<SoundManager>.Instance.PlayLocalSoundAtPoint("relic_pick", 0.55f, base.transform.position, 1);
				MonoSingleton<SpellSelectUI>.Instance.SelectSlot(this, PrevSelectedWandSlot);
			}
			else
			{
				MonoSingleton<SpellSelectUI>.Instance.EndDrag(this, null);
				SlotState behaviourState = m_behaviourState;
				if (behaviourState == SlotState.Occupied)
				{
					MonoSingleton<SpellSelectUI>.Instance.DeSelectSlot(this, m_wandSlot);
				}
				else
				{
					ResetSlot();
				}
			}
			PrevSelectedWandSlot = null;
		}

		public void LookEnter()
		{
			if (!IsDraggable)
			{
				return;
			}
			if (m_behaviourState.ContainsFlag(SlotState.Undraggable))
			{
				Relic.SetMaterial(ItemMaterialType.Locked, highlighted: true);
				return;
			}
			m_isHighlighted = true;
			Relic.SetMaterial(ItemMaterialType.Default, highlighted: true);
			if (!IsMoving)
			{
				if (m_wandSlot != null)
				{
					m_wandSlot.ScaleRadialElement(scaleUp: true);
				}
				else
				{
					Move(base.transform.position + (GameControl.Instance.PlayerControl.CameraTransform.position - base.transform.position).normalized * 0.1f);
				}
			}
		}

		public void LookExit()
		{
			if (!IsDraggable)
			{
				return;
			}
			if (m_behaviourState.ContainsFlag(SlotState.Undraggable))
			{
				if (!m_isSelected)
				{
					Relic.SetMaterial(ItemMaterialType.Locked);
				}
				return;
			}
			if (!IsBeingDragged && m_isHighlighted)
			{
				if (m_wandSlot == null)
				{
					ResetSlot();
				}
				else
				{
					ResetSlot(m_wandSlot);
				}
			}
			m_isHighlighted = false;
			if ((object)m_wandSlot != null)
			{
				m_wandSlot.ScaleRadialElement(scaleUp: false);
			}
			if (!m_isSelected)
			{
				Relic.SetMaterial(ItemMaterialType.Default);
			}
		}

		public void Enable(bool enable, bool wait = true)
		{
			m_interactable.LockInteraction(!enable);
			m_interactable.LockLook(!enable);
		}

		public void ToggleParticleEffects(bool enable)
		{
			m_interactable.ToggleParticleEffects(enable);
		}
	}
	[RequireComponent(typeof(InteractableGameObject))]
	public class WandSlot : MonoBehaviour, ISnapObject
	{
		[Header("Wand Slot")]
		public SlotState m_behaviourState;

		public SpellSlot m_spellSlot;

		public RadialElementRenderer m_radialElementRenderer;

		[SerializeField]
		private Collider m_snappableCollider;

		[Header("Wand Input")]
		[SerializeField]
		private Vector3 m_pointPosition = Vector3.zero;

		[SerializeField]
		private Vector3 m_stickPosition = Vector3.zero;

		[SerializeField]
		private Vector3 m_dualWieldPointPosition = Vector3.zero;

		[SerializeField]
		private Vector3 m_dualWieldStickPosition = Vector3.zero;

		private Interactable m_interactable;

		private Collider m_collider;

		private WandSlotPulseHandler m_slotPulseHandler;

		private EventToken m_spellSlotDragBeginEventToken;

		private EventToken m_spellSlotDragEndEventToken;

		private EventToken m_spellSlotSelectedEventToken;

		private EventToken m_spellSelectActivatedEventToken;

		public bool IsAvailable
		{
			[CompilerGenerated]
			get
			{
				return m_behaviourState == SlotState.Enabled;
			}
		}

		public bool IsSnappable
		{
			[CompilerGenerated]
			get
			{
				return !m_interactable.InteractionLocked && m_behaviourState != SlotState.Locked;
			}
		}

		public Vector3 SnapPoint { get; private set; }

		public Quaternion SnapRotation
		{
			[CompilerGenerated]
			get
			{
				return base.transform.rotation;
			}
		}

		private void OnEnable()
		{
			m_spellSlotDragBeginEventToken = EventHub.Subscribe<Events.SpellSlotDragBeginEvent>(OnSpellSlotDragBegin);
			m_spellSlotDragEndEventToken = EventHub.Subscribe<Events.SpellSlotDragEndEvent>(OnSpellSlotDragEnd);
			m_spellSlotSelectedEventToken = EventHub.Subscribe<Events.SpellSlotSelectedEvent>(OnSpellSlotSelected);
			m_spellSelectActivatedEventToken = EventHub.Subscribe<Events.SpellSelectActivatedEvent>(OnSpellSelectActivated);
			m_interactable.OnInteract += Interact;
			m_interactable.OnLookEnter += LookEnter;
			m_interactable.OnLookExit += LookExit;
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe<Events.SpellSlotDragBeginEvent>(m_spellSlotDragBeginEventToken);
			EventHub.Unsubscribe<Events.SpellSlotDragEndEvent>(m_spellSlotDragEndEventToken);
			EventHub.Unsubscribe<Events.SpellSlotSelectedEvent>(m_spellSlotSelectedEventToken);
			EventHub.Unsubscribe<Events.SpellSelectActivatedEvent>(m_spellSelectActivatedEventToken);
			m_interactable.OnInteract -= Interact;
			m_interactable.OnLookEnter -= LookEnter;
			m_interactable.OnLookExit -= LookExit;
		}

		private void Awake()
		{
			m_interactable = GetComponent<Interactable>();
			m_collider = GetComponent<Collider>();
		}

		private void Start()
		{
			m_interactable.ToggleParticleEffects(active: false);
		}

		public void SetPosition(bool isPoint, bool isDualWielding)
		{
			if (m_spellSlot == null || !m_spellSlot.m_spell.IsType(Spell.Spell_Teleport))
			{
				Vector3 localPosition = (isDualWielding ? ((!isPoint) ? m_dualWieldStickPosition : m_dualWieldPointPosition) : ((!isPoint) ? m_stickPosition : m_pointPosition));
				base.transform.localPosition = localPosition;
				UpdateDragPlanePoint();
				if (MonoSingleton<SpellSelectUI>.Instance.IsSpellSelectActive && (object)m_spellSlot != null)
				{
					m_spellSlot.ResetSlot(this);
				}
				return;
			}
			UpdateDragPlanePoint();
			m_behaviourState = ((!isPoint) ? SlotState.Disabled : SlotState.Locked);
			m_collider.enabled = isPoint;
			m_spellSlot.m_behaviourState = m_behaviourState;
			if (isDualWielding)
			{
				base.gameObject.SetActive(value: false);
			}
			else if (MonoSingleton<SpellSelectUI>.Instance.IsSpellSelectActive)
			{
				m_spellSlot.Collider.enabled = isPoint;
				if (isPoint)
				{
					m_spellSlot.Relic.ResetPosition();
				}
				else
				{
					MonoSingleton<SpellSelectUI>.Instance.MoveTeleportRelic(m_spellSlot.Relic);
				}
			}
		}

		private void OnSpellSelectActivated(Events.SpellSelectActivatedEvent eventData)
		{
			m_snappableCollider.enabled = eventData.Active;
		}

		public void UpdateDragPlanePoint()
		{
			SnapPoint = base.transform.RetrieveChild("DragPoint").position;
		}

		private void OnSpellSlotDragEnd(Events.SpellSlotDragEndEvent eventData)
		{
			EndDragSpellSlot(eventData.SpellSlot, eventData.WandSlot);
		}

		private void OnSpellSlotSelected(Events.SpellSlotSelectedEvent eventData)
		{
			EndDragSpellSlot(eventData.SpellSlot, eventData.WandSlot);
		}

		private void EndDragSpellSlot(SpellSlot spellSlot, WandSlot wandSlot)
		{
			switch (m_behaviourState)
			{
			case SlotState.Enabled:
				m_collider.enabled = wandSlot != this;
				if (wandSlot == this)
				{
					SetOccupied(occupy: true, spellSlot);
				}
				break;
			case SlotState.Occupied:
				m_collider.enabled = false;
				if (wandSlot == this && spellSlot != m_spellSlot)
				{
					SetOccupied(occupy: true, spellSlot);
				}
				else if (m_spellSlot == spellSlot)
				{
					SetOccupied(occupy: false, spellSlot);
				}
				break;
			}
		}

		private void OnSpellSlotDragBegin(Events.SpellSlotDragBeginEvent eventData)
		{
			BeginDragSpellSlot(eventData.SpellSlot, eventData.WandSlot);
		}

		private void BeginDragSpellSlot(SpellSlot spellSlot, WandSlot wandSlot)
		{
			if (wandSlot == this)
			{
				if ((object)m_spellSlot != null)
				{
					m_spellSlot.DeselectSpellSlot(m_spellSlot, this);
				}
				SetOccupied(occupy: false, null);
			}
			if (m_behaviourState != SlotState.Locked)
			{
				m_collider.enabled = true;
			}
		}

		public void SetOccupied(bool occupy, SpellSlot spellSlot)
		{
			if (occupy)
			{
				if (m_spellSlot != null && m_spellSlot != spellSlot)
				{
					if (spellSlot.PrevSelectedWandSlot != null)
					{
						MonoSingleton<SpellSelectUI>.Instance.SelectSlot(m_spellSlot, spellSlot.PrevSelectedWandSlot);
					}
					else
					{
						m_spellSlot.DeselectSpellSlot(m_spellSlot, null);
					}
				}
			}
			else
			{
				ScaleRadialElement(scaleUp: false);
			}
			m_behaviourState = ((!occupy) ? SlotState.Enabled : SlotState.Occupied);
			m_spellSlot = ((!occupy) ? null : spellSlot);
			ConfirmPulseCondition();
		}

		private void ConfirmPulseCondition()
		{
			if (m_slotPulseHandler == null)
			{
				m_slotPulseHandler = GetComponentInParent<WandSlotPulseHandler>();
			}
			if (MonoSingleton<SpellSelectUI>.Instance.IsSpellSelectActive && m_behaviourState == SlotState.Enabled)
			{
				m_slotPulseHandler.AddSlotToPulsate(this);
			}
			else
			{
				m_slotPulseHandler.RemoveSlotToPulsate(this);
			}
		}

		private void Interact()
		{
			if (m_behaviourState == SlotState.Locked && m_spellSlot != null)
			{
				MonoSingleton<SpellSelectUI>.Instance.ShowInfo(m_spellSlot, this);
			}
		}

		private void LookEnter()
		{
			if (m_behaviourState != SlotState.Enabled && !(m_spellSlot == null))
			{
				m_spellSlot.LookEnter();
			}
		}

		private void LookExit()
		{
			if (m_behaviourState != SlotState.Enabled && !(m_spellSlot == null))
			{
				m_spellSlot.LookExit();
			}
		}

		public void SetInteractable(bool enable)
		{
			if (enable)
			{
				enable = m_behaviourState == SlotState.Enabled || m_behaviourState == SlotState.Occupied;
			}
			m_interactable.InteractionLocked = !enable;
			m_interactable.LookLocked = !enable;
			if (m_behaviourState != SlotState.Locked && m_collider != null)
			{
				m_collider.enabled = m_behaviourState == SlotState.Enabled;
			}
			if (!enable)
			{
				LookExit();
			}
		}

		public void SetRadialElementColor(Color color)
		{
			if (m_radialElementRenderer != null)
			{
				m_radialElementRenderer.SetColor(color);
			}
		}

		public void ScaleRadialElement(bool scaleUp)
		{
			if (!(m_radialElementRenderer == null))
			{
				if (scaleUp)
				{
					m_radialElementRenderer.ScaleUp();
				}
				else
				{
					m_radialElementRenderer.ResetScale();
				}
			}
		}

		public void FadeRadialElement(bool fadeIn, float fadeTime, float fadeWait)
		{
			if (!(m_radialElementRenderer == null))
			{
				if (fadeIn)
				{
					m_radialElementRenderer.FadeIn(fadeTime, fadeWait, ConfirmPulseCondition);
				}
				else
				{
					m_radialElementRenderer.FadeOut(fadeTime);
				}
			}
		}
	}
	public class WandSlotPulseHandler : MonoBehaviour
	{
		[SerializeField]
		private Color m_defaultColor;

		[SerializeField]
		private Color m_pulseColor;

		[SerializeField]
		private float m_pulseTime = 1f;

		private Color m_currentPulseColor;

		private List<WandSlot> m_pulseSlots = new List<WandSlot>();

		private bool m_pulsate;

		private void Update()
		{
			if (m_pulsate)
			{
				m_currentPulseColor = Color.Lerp(m_defaultColor, m_pulseColor, Mathf.PingPong(Time.time, m_pulseTime));
				for (int i = 0; i < m_pulseSlots.Count; i++)
				{
					WandSlot wandSlot = m_pulseSlots[i];
					wandSlot.SetRadialElementColor(m_currentPulseColor);
				}
			}
		}

		public void AddSlotToPulsate(WandSlot slot)
		{
			if (!m_pulseSlots.Contains(slot))
			{
				m_pulseSlots.Add(slot);
				m_pulsate = true;
			}
		}

		public void RemoveSlotToPulsate(WandSlot slot)
		{
			if (m_pulseSlots.Contains(slot))
			{
				m_pulseSlots.Remove(slot);
				slot.SetRadialElementColor(m_defaultColor);
				if (m_pulseSlots.IsEmpty())
				{
					m_pulsate = false;
				}
			}
		}
	}
}
public class SpellSelectUI : MonoSingleton<SpellSelectUI>, IWorkshopTileListener
{
	private readonly WaitForSeconds m_shortWait = new WaitForSeconds(0.1f);

	private readonly WaitForSeconds m_wait = new WaitForSeconds(0.5f);

	private readonly WaitForSeconds m_wait0_05 = new WaitForSeconds(0.05f);

	private readonly Vector3 m_defaultRelicScaleOpen = Vector3.one * 1.5f;

	private readonly Vector3 m_defaultRelicScaleClosed = Vector3.one;

	private readonly Quaternion m_defaultRelicRotationClosed = Quaternion.Euler(0f, 90f, 0f);

	[SerializeField]
	private WorkshopTile m_spellSelectTile;

	[SerializeField]
	private SpellSelectUIRelicHandler m_relicHandler;

	[SerializeField]
	private float m_circleFadeTime = 0.35f;

	[SerializeField]
	private float m_circleFadeWait = 0.55f;

	[SerializeField]
	private GameObject m_unlockVfx;

	[SerializeField]
	private Transform m_unlockRelicIconParent;

	[SerializeField]
	private WandSlot[] m_wandSlots = Array.Empty<WandSlot>();

	[SerializeField]
	private RadialElementRenderer[] m_wandSlotCircles = Array.Empty<RadialElementRenderer>();

	[SerializeField]
	private WorkshopWand m_workshopWand;

	[SerializeField]
	private GameObject m_wandParentDualWield;

	[SerializeField]
	private RelicSlotWand[] m_relicWandSlotsOneHand = Array.Empty<RelicSlotWand>();

	[SerializeField]
	private RelicSlotWand[] m_relicWandSlotsDualWield = Array.Empty<RelicSlotWand>();

	[SerializeField]
	private SpellSlot[] m_allSpellSlots = Array.Empty<SpellSlot>();

	private RelicSlotWand[] m_wandRelicSlots;

	private List<Interactable> m_tableInteractables;

	private Events.SpellSelectActivatedEvent m_spellSelectActiveEvent = new Events.SpellSelectActivatedEvent();

	private EventToken m_inputChangedEventToken;

	private EventToken m_workshopWandOpenedEventToken;

	private EventToken m_workshopWandClosedEventToken;

	private WandInput m_wandInput;

	private bool m_isInteractionActive = true;

	private bool m_holdHoldSwitchWandFlow;

	private VirtualTransform[] m_spellSlotTargetTransforms = new VirtualTransform[4]
	{
		new VirtualTransform(),
		new VirtualTransform(),
		new VirtualTransform(),
		new VirtualTransform()
	};

	public bool IsSpellSelectActive
	{
		get
		{
			return m_spellSelectActiveEvent.Active;
		}
		set
		{
			m_spellSelectActiveEvent.Active = value;
		}
	}

	public SpellSelectUIRelicHandler RelicHandler
	{
		[CompilerGenerated]
		get
		{
			return (!(m_relicHandler != null)) ? null : m_relicHandler;
		}
	}

	public WorkshopWand WorkshopWand
	{
		[CompilerGenerated]
		get
		{
			return (!(m_workshopWand != null)) ? null : m_workshopWand;
		}
	}

	public WandSlot[] WandSlots
	{
		[CompilerGenerated]
		get
		{
			return m_wandSlots;
		}
	}

	public SpellSlot[] AllSpellSlots
	{
		[CompilerGenerated]
		get
		{
			return m_allSpellSlots;
		}
	}

	private bool IsDualWieldEnabled
	{
		[CompilerGenerated]
		get
		{
			return GameControl.Instance.IsDualWieldSupportedAndActive;
		}
	}

	protected override void Awake()
	{
		base.Awake();
		m_tableInteractables = new List<Interactable>(base.transform.parent.RetrieveChild("SpellTableLoadout").GetComponentsInChildren<Interactable>());
		m_tableInteractables.AddRange(base.transform.parent.RetrieveChild("Graphics").GetComponentsInChildren<Interactable>());
		m_wandRelicSlots = m_relicWandSlotsDualWield;
		UpdateRelicSlots();
		LoadSpellSelection();
	}

	private void Start()
	{
		PlayerInput input = GameControl.Instance.PlayerControl.Input;
		m_unlockVfx.gameObject.SetActive(value: false);
		if (!IsDualWieldEnabled)
		{
			WorkshopWand.LockInteraction(locked: false);
			WorkshopWand.LockLook(locked: false);
			SpellSlot spellSlot = m_wandSlots[0].m_spellSlot;
			Transform parent = WorkshopWand.CurrentWand.transform.RetrieveChild("relic_teleport", includeInactive: false, includePartials: true);
			spellSlot.Relic.ResetPosition();
			spellSlot.Relic.transform.SetParent(parent, worldPositionStays: true);
			spellSlot.Relic.TweakTransform(Vector3.zero, Quaternion.identity, Vector3.one, 0.75f, local: true, rotLocal: true);
			SetSpellSelectionActive(enable: false, playSound: false, saveSelection: false);
		}
	}

	private void OnEnable()
	{
		m_inputChangedEventToken = EventHub.Subscribe<InputEvents.InputChangedEvent>(OnInputChanged);
		m_workshopWandOpenedEventToken = EventHub.Subscribe<Events.WorkshopWandOpenedEvent>(OnWorkshopWandOpened);
		m_workshopWandClosedEventToken = EventHub.Subscribe<Events.WorkshopWandClosedEvent>(OnWorkshopWandClosed);
	}

	protected override void OnDisable()
	{
		base.OnDisable();
		EventHub.Unsubscribe<InputEvents.InputChangedEvent>(m_inputChangedEventToken);
		EventHub.Unsubscribe<Events.WorkshopWandOpenedEvent>(m_workshopWandOpenedEventToken);
		EventHub.Unsubscribe<Events.WorkshopWandClosedEvent>(m_workshopWandClosedEventToken);
	}

	private void OnApplicationQuit()
	{
		SaveSpellSelection(saveToPlayfab: true);
	}

	public void BeginDrag(SpellSlot spellSlot, WandSlot wandSlot)
	{
		Events.SpellSlotDragBeginEvent spellSlotDragBeginEvent = new Events.SpellSlotDragBeginEvent();
		spellSlotDragBeginEvent.SpellSlot = spellSlot;
		spellSlotDragBeginEvent.WandSlot = wandSlot;
		EventHub.Publish(spellSlotDragBeginEvent);
	}

	public void EndDrag(SpellSlot spellSlot, WandSlot wandSlot)
	{
		Events.SpellSlotDragEndEvent spellSlotDragEndEvent = new Events.SpellSlotDragEndEvent();
		spellSlotDragEndEvent.SpellSlot = spellSlot;
		spellSlotDragEndEvent.WandSlot = wandSlot;
		EventHub.Publish(spellSlotDragEndEvent);
	}

	public void ShowInfo(SpellSlot spellSlot, WandSlot wandSlot)
	{
		Events.SpellInfoUpdatedEvent spellInfoUpdatedEvent = new Events.SpellInfoUpdatedEvent();
		spellInfoUpdatedEvent.SpellSlot = spellSlot;
		EventHub.Publish(spellInfoUpdatedEvent);
	}

	public void SelectSlot(SpellSlot spellSlot, WandSlot wandSlot)
	{
		Events.SpellSlotSelectedEvent spellSlotSelectedEvent = new Events.SpellSlotSelectedEvent();
		spellSlotSelectedEvent.SpellSlot = spellSlot;
		spellSlotSelectedEvent.WandSlot = wandSlot;
		EventHub.Publish(spellSlotSelectedEvent);
	}

	public void DeSelectSlot(SpellSlot spellSlot, WandSlot wandSlot)
	{
		Events.SpellSlotDeselectedEvent spellSlotDeselectedEvent = new Events.SpellSlotDeselectedEvent();
		spellSlotDeselectedEvent.SpellSlot = spellSlot;
		EventHub.Publish(spellSlotDeselectedEvent);
	}

	public void UnlockSpell(Spell spell)
	{
		SpellSlot spellSlot = null;
		SpellSlot[] allSpellSlots = m_allSpellSlots;
		foreach (SpellSlot spellSlot2 in allSpellSlots)
		{
			if (spellSlot2.m_behaviourState == SlotState.Locked && spellSlot2.m_spell.IsType(spell))
			{
				spellSlot = spellSlot2;
				break;
			}
		}
		if (spellSlot == null)
		{
			WandsLogger.LogError($"Could not unlock spell {spell}, unlock slot not found.");
		}
		else
		{
			spellSlot.Unlock(m_unlockVfx, m_unlockRelicIconParent);
		}
	}

	private void OnInputChanged(InputEvents.InputChangedEvent eventData)
	{
		ChangeInput(eventData.WandInput, eventData.IsDualWieldEnabled);
		GameControl.Instance.PlayerControl.Input.GetAim().FindSnapObjects();
		m_relicHandler.UpdateRelicIconSharedMaterials(m_allSpellSlots, IsSpellSelectActive);
	}

	private void ChangeInput(WandInput wandInput, bool isDualWielding)
	{
		m_wandInput = wandInput;
		UpdateRelicSlots();
		m_wandParentDualWield.SetActive(isDualWielding);
		WorkshopWand.gameObject.SetActive(!isDualWielding);
		if (WandSlots.IsNullOrEmpty())
		{
			WandsLogger.LogError("No WandSlots found");
			return;
		}
		bool isPoint = wandInput.ContainsFlag(WandInput.Pointing) || GameControl.Instance.Platform.ControlType.ContainsFlag(ControlType.DualWieldTouchpad);
		WandSlot[] wandSlots = WandSlots;
		foreach (WandSlot wandSlot in wandSlots)
		{
			wandSlot.SetPosition(isPoint, isDualWielding);
		}
		ToggleInteractionActive(m_spellSelectTile.IsOccupied);
	}

	private void UpdateRelicSlots()
	{
		for (int i = 0; i < m_wandRelicSlots.Length; i++)
		{
			m_wandRelicSlots[i].gameObject.SetActive(value: false);
		}
		m_wandRelicSlots = ((!IsDualWieldEnabled) ? m_relicWandSlotsOneHand : m_relicWandSlotsDualWield);
		for (int j = 0; j < m_wandRelicSlots.Length; j++)
		{
			m_wandRelicSlots[j].gameObject.SetActive(value: true);
		}
	}

	public void EnableSpellSlots(bool enable)
	{
		if (m_allSpellSlots.IsNullOrEmpty())
		{
			WandsLogger.LogError("No spell slots defined for spell select UI");
			return;
		}
		SpellSlot[] allSpellSlots = m_allSpellSlots;
		foreach (SpellSlot spellSlot in allSpellSlots)
		{
			spellSlot.Enable(enable);
		}
	}

	public void TryChangeWand(int loadoutIndex)
	{
		if (IsSpellSelectActive)
		{
			if (HasCurrentLoadoutEmptySlots())
			{
				CloseWandFailed();
				return;
			}
			if (!IsDualWieldEnabled)
			{
				SetSpellSelectionActive(enable: false, playSound: true, saveSelection: true);
			}
			ChangeWand(loadoutIndex, activeAtStart: true);
		}
		else
		{
			ChangeWand(loadoutIndex, activeAtStart: false);
		}
		MonoSingleton<ProjectorScreenUI>.Instance.ClearInformation();
		Events.LoadoutSelectedEvent loadoutSelectedEvent = new Events.LoadoutSelectedEvent();
		loadoutSelectedEvent.WandIndex = loadoutIndex;
		EventHub.Publish(loadoutSelectedEvent);
	}

	public bool TryCloseWand()
	{
		if (!IsSpellSelectActive)
		{
			return true;
		}
		if (HasCurrentLoadoutEmptySlots())
		{
			CloseWandFailed();
			return false;
		}
		SetSpellSelectionActive(enable: false, playSound: true, saveSelection: true);
		return true;
	}

	private bool HasCurrentLoadoutEmptySlots()
	{
		for (int i = 1; i < WandSlots.Length; i++)
		{
			if (WandSlots[i].m_behaviourState != SlotState.Occupied)
			{
				return true;
			}
		}
		return false;
	}

	public bool TryDisableSpellSelection()
	{
		SaveSpellSelection(saveToPlayfab: false);
		for (int i = 1; i < WandSlots.Length; i++)
		{
			if (WandSlots[i].m_behaviourState != SlotState.Occupied)
			{
				CloseWandFailed();
				return false;
			}
		}
		if (SwitchWandToUncompleted())
		{
			return false;
		}
		SetSpellSelectionActive(enable: false, IsSpellSelectActive, saveSelection: true);
		return true;
	}

	private void CloseWandFailed()
	{
		MonoSingleton<ProjectorScreenUI>.Instance.SetInstructionsActive(InfoType.LoadoutIncomplete);
		WorkshopWand.FailMoveWandHandle(OnFailMoveStepComplete);
		WandSlot[] wandSlots = WandSlots;
		foreach (WandSlot wandSlot in wandSlots)
		{
			if (wandSlot.m_behaviourState == SlotState.Enabled)
			{
				wandSlot.ScaleRadialElement(scaleUp: true);
			}
		}
	}

	private void OnFailMoveStepComplete()
	{
		WandSlot[] wandSlots = WandSlots;
		foreach (WandSlot wandSlot in wandSlots)
		{
			if (wandSlot.m_behaviourState == SlotState.Enabled)
			{
				wandSlot.ScaleRadialElement(scaleUp: false);
			}
		}
	}

	private bool SwitchWandToUncompleted()
	{
		Loadout[] unlockedLoadouts = GameControl.Instance.Player.GetUnlockedLoadouts();
		for (int i = 0; i < unlockedLoadouts.Length; i++)
		{
			Loadout loadout = unlockedLoadouts[i];
			if (loadout.Spells.Contains(Spell.None))
			{
				if (IsSpellSelectActive)
				{
					SetSpellSelectionActive(enable: false, playSound: true, saveSelection: false);
				}
				ChangeWand(i, activeAtStart: true);
				MonoSingleton<ProjectorScreenUI>.Instance.SetInstructionsActive(InfoType.LoadoutIncomplete);
				return true;
			}
		}
		return false;
	}

	public void SetSpellSelectionActive(bool enable, bool playSound, bool saveSelection)
	{
		ShowInfo(null, null);
		MoveSpellSlots(enable);
		WandSlot[] wandSlots = WandSlots;
		foreach (WandSlot wandSlot in wandSlots)
		{
			wandSlot.SetInteractable(enable);
			wandSlot.FadeRadialElement(enable, m_circleFadeTime, m_circleFadeWait);
			if (wandSlot.m_behaviourState != SlotState.Disabled && wandSlot.m_behaviourState != SlotState.Locked && !wandSlot.IsAvailable && !enable)
			{
				wandSlot.m_spellSlot.Relic.ResetPosition();
				wandSlot.m_spellSlot.Relic.TweakTransform(Vector3.zero, Quaternion.identity, Vector3.one, 0.75f, local: true, rotLocal: true);
			}
		}
		int num = (GameControl.Instance.IsDualWieldSupportedAndActive ? (GameControl.Instance.Platform.ControlType.ContainsFlag(ControlType.DualWieldTouchpad) ? 1 : (-1)) : 0);
		for (int j = 0; j < m_wandSlotCircles.Length; j++)
		{
			if (num < j)
			{
				m_wandSlotCircles[j].gameObject.SetActive(value: false);
				continue;
			}
			m_wandSlotCircles[j].gameObject.SetActive(value: false);
			if (enable)
			{
				m_wandSlotCircles[j].FadeIn(m_circleFadeTime, m_circleFadeWait, null);
			}
			else
			{
				m_wandSlotCircles[j].FadeOut(m_circleFadeTime);
			}
		}
		if (!enable)
		{
			WorkshopWand.ForceCloseWand();
			if (saveSelection)
			{
				SaveSpellSelection(saveToPlayfab: true);
			}
		}
		if (playSound)
		{
			PunSingleton<SoundManager>.Instance.PlayLocalSoundAtPoint(string.Format("wand_{0}", (!enable) ? "close" : "open"), 0.75f, base.transform.position, 2);
		}
		MonoSingleton<ProjectorScreenUI>.Instance.ClearInformation();
		IsSpellSelectActive = enable;
		EventHub.Publish(m_spellSelectActiveEvent);
	}

	public void MoveTeleportRelic(Relic relic)
	{
		if (relic == null)
		{
			relic = WandSlots.ElementAt(0).m_spellSlot.Relic;
		}
		Transform transform = WorkshopWand.CurrentWand.transform.RetrieveChild("relic_teleport", includeInactive: false, includePartials: true);
		if (transform != null)
		{
			relic.TweakTransform(transform.position + ((!IsSpellSelectActive) ? Vector3.zero : new Vector3(0f, 0f, 0.2f)), transform.rotation, transform.localScale * 2f, 0.75f);
		}
		else
		{
			relic.TweakTransform(new Vector3(-0.625f, 0.924f, -1.3f), WorkshopWand.WandTipTransform.rotation, Vector3.one * 0.45f, 0.75f);
		}
	}

	public bool CanGetWandSlot(WandSlot slot, out Transform wandSlotTf)
	{
		wandSlotTf = null;
		for (int i = 0; i < WandSlots.Length; i++)
		{
			if (WandSlots[i] == slot)
			{
				wandSlotTf = m_wandRelicSlots[i - 1].transform;
				break;
			}
		}
		return wandSlotTf != null;
	}

	private bool CanGetRelicSlot(Spell spell, out SpellSlot slot)
	{
		SpellSlot[] allSpellSlots = m_allSpellSlots;
		foreach (SpellSlot spellSlot in allSpellSlots)
		{
			if (!(spellSlot.m_spell == null) && spellSlot.m_spell.IsType(spell))
			{
				slot = spellSlot;
				return true;
			}
		}
		slot = null;
		return false;
	}

	public void ChangeWand(int loadoutIndex, bool activeAtStart)
	{
		if (GameControl.Instance.Player.ActiveLoadoutIndex != loadoutIndex)
		{
			if (IsDualWieldEnabled)
			{
				SaveSpellSelection(saveToPlayfab: false);
			}
			GameControl.Instance.Player.SetActiveLoadoutIndex(loadoutIndex);
			StartCoroutine(SwitchWand(activeAtStart));
		}
	}

	private IEnumerator SwitchWand(bool activateWhenFinished)
	{
		Spell[] currentLoadoutSpells = GameControl.Instance.Player.GetCurrentLoadoutSpells();
		bool moveWandHandles = activateWhenFinished && !IsDualWieldEnabled;
		Interactable.LockAllInteraction = true;
		Interactable.LockAllLook = true;
		if (activateWhenFinished)
		{
			MonoSingleton<ProjectorScreenUI>.Instance.ClearInformation();
		}
		if (moveWandHandles)
		{
			WorkshopWand.ForceCloseWand();
			while (WorkshopWand.IsMoving)
			{
				yield return null;
			}
			PunSingleton<SoundManager>.Instance.PlayLocalSoundAtPoint("wand_loadout_turn", 1f, WorkshopWand.transform.position);
			yield return TurnRelics();
		}
		EventHub.Publish(new Events.WandLoadoutSwitchedEvent());
		yield return RearrangeRelics(moveWandHandles);
		if (m_holdHoldSwitchWandFlow)
		{
			yield return m_wait;
			m_holdHoldSwitchWandFlow = false;
		}
		SpellSlot teleport = WandSlots[0].m_spellSlot;
		Transform teleportSlot = WorkshopWand.CurrentWand.transform.RetrieveChild("relic_teleport", includeInactive: false, includePartials: true);
		teleport.Relic.ResetPosition();
		teleport.Relic.transform.SetParent(teleportSlot, worldPositionStays: true);
		teleport.Relic.TweakTransform(Vector3.zero, Quaternion.identity, Vector3.one, 0.75f, local: true, rotLocal: true);
		for (int i = 0; i < 5; i++)
		{
			WandSlot wandSlot = WandSlots[i];
			if (wandSlot.m_behaviourState == SlotState.Disabled || i == 0)
			{
				continue;
			}
			if (i > 1)
			{
				yield return m_shortWait;
			}
			Spell spell = currentLoadoutSpells[i];
			if (spell == Spell.None)
			{
				continue;
			}
			if (!GameControl.Instance.Player.OwnsSpell(spell))
			{
				currentLoadoutSpells[i] = Spell.None;
				GameControl.Instance.Player.UpdateCurrentLoadout(currentLoadoutSpells);
			}
			else
			{
				if (!CanGetRelicSlot(spell, out var spellSlot))
				{
					continue;
				}
				SelectSlot(spellSlot, wandSlot);
				if (spellSlot == null)
				{
					WandsLogger.LogError("Spell slot is null");
					continue;
				}
				if (moveWandHandles)
				{
					spellSlot.Relic.transform.localRotation = Quaternion.Euler(0f, 0f, 35f);
				}
				m_relicHandler.SetRelicIconSharedMaterial(spellSlot, active: true);
				m_holdHoldSwitchWandFlow = true;
			}
		}
		if (moveWandHandles)
		{
			if (m_holdHoldSwitchWandFlow)
			{
				yield return m_wait;
				PunSingleton<SoundManager>.Instance.PlayLocalSoundAtPoint("wand_loadout_turn", 1f, WorkshopWand.transform.position);
				m_holdHoldSwitchWandFlow = false;
			}
			yield return TurnRelics();
		}
		yield return m_wait;
		if (moveWandHandles && activateWhenFinished)
		{
			WorkshopWand.TryOpenWand();
			SetSpellSelectionActive(enable: true, playSound: true, saveSelection: false);
			while (WorkshopWand.IsMoving)
			{
				yield return null;
			}
		}
		Interactable.LockAllInteraction = false;
		Interactable.LockAllLook = false;
		GameControl.Instance.PlayerControl.Input.NullHighlightedInteractable();
	}

	private IEnumerator TurnRelics()
	{
		for (int i = 1; i < WandSlots.Length; i++)
		{
			WandSlot wandSlot = WandSlots[i];
			if (wandSlot.m_behaviourState == SlotState.Occupied && !(wandSlot.m_spellSlot == null))
			{
				wandSlot.m_spellSlot.TurnRelic(-35f);
				yield return m_shortWait;
			}
		}
	}

	private IEnumerator RearrangeRelics(bool isMovingHandles)
	{
		for (int i = 1; i < WandSlots.Length; i++)
		{
			WandSlot wandSlot = WandSlots[i];
			if (!CollectionExtensions.Contains(item: (wandSlot.m_spellSlot != null) ? wandSlot.m_spellSlot.m_spell.Type : Spell.None, array: GameControl.Instance.Player.GetCurrentLoadoutSpells()))
			{
				if (isMovingHandles)
				{
					m_relicHandler.SetRelicIconSharedMaterial(wandSlot.m_spellSlot, active: false);
				}
				DeSelectSlot(wandSlot.m_spellSlot, wandSlot);
				m_holdHoldSwitchWandFlow = true;
			}
			wandSlot.SetOccupied(occupy: false, null);
			yield return m_wait0_05;
		}
	}

	private void MoveSpellSlots(bool open)
	{
		for (int i = 0; i < m_spellSlotTargetTransforms.Length; i++)
		{
			if (open)
			{
				m_spellSlotTargetTransforms[i] = (VirtualTransform)WandSlots[i + 1].transform;
				m_spellSlotTargetTransforms[i].Scale = m_defaultRelicScaleOpen;
			}
			else
			{
				m_spellSlotTargetTransforms[i].Position = m_wandRelicSlots[i].transform.position;
				m_spellSlotTargetTransforms[i].Scale = m_defaultRelicScaleClosed;
				m_spellSlotTargetTransforms[i].Rotation = ((!GameControl.Instance.IsDualWieldSupportedAndActive) ? m_defaultRelicRotationClosed : ((i <= 1) ? m_defaultRelicRotationClosed : Quaternion.Euler(0f, 270f, 0f)));
			}
		}
		StartCoroutine(ControlledSpellSlotMovement((from x in WandSlots.Skip(1)
			select x.m_spellSlot).ToArray(), !open));
		SpellSlot spellSlot = WandSlots[0].m_spellSlot;
		if (!open)
		{
			Transform parent = WorkshopWand.CurrentWand.transform.RetrieveChild("relic_teleport", includeInactive: false, includePartials: true);
			spellSlot.Relic.transform.SetParent(parent, worldPositionStays: true);
			spellSlot.Relic.TweakTransform(Vector3.zero, Quaternion.identity, Vector3.one, 0.75f, local: true, rotLocal: true);
		}
		else if (m_wandInput.ContainsFlag(WandInput.Point))
		{
			spellSlot.Relic.transform.SetParent(WandSlots[0].transform, worldPositionStays: true);
			spellSlot.Relic.ResetPosition();
		}
	}

	private IEnumerator ControlledSpellSlotMovement(SpellSlot[] slots, bool useLocalRotation)
	{
		VirtualTransform[] startTransforms = new VirtualTransform[slots.Length];
		for (int i = 0; i < slots.Length; i++)
		{
			if (!(slots[i] == null))
			{
				startTransforms[i] = (VirtualTransform)slots[i].transform;
				if (useLocalRotation)
				{
					startTransforms[i].Rotation = slots[i].transform.localRotation;
				}
			}
		}
		float currentMoveTime = 0f;
		float t = 0f;
		while (t < 1f)
		{
			currentMoveTime += Time.deltaTime;
			t = Mathf.Clamp01(MathUtils.SmootherStep(currentMoveTime / 0.75f));
			for (int j = 0; j < slots.Length; j++)
			{
				if (!(slots[j] == null) && slots[j].m_behaviourState != SlotState.Enabled)
				{
					slots[j].StopMovement();
					Transform transform = slots[j].transform;
					transform.position = Vector3.Lerp(startTransforms[j].Position, m_spellSlotTargetTransforms[j].Position, t);
					transform.localScale = Vector3.Lerp(startTransforms[j].Scale, m_spellSlotTargetTransforms[j].Scale, t);
					if (useLocalRotation)
					{
						transform.localRotation = Quaternion.Lerp(startTransforms[j].Rotation, m_spellSlotTargetTransforms[j].Rotation, t);
					}
					else
					{
						transform.rotation = Quaternion.Lerp(startTransforms[j].Rotation, m_spellSlotTargetTransforms[j].Rotation, t);
					}
				}
			}
			yield return null;
		}
		GameControl.Instance.PlayerControl.Input.NullHighlightedInteractable();
	}

	private void SaveSpellSelection(bool saveToPlayfab)
	{
		if (WandSlots.IsNullOrEmpty())
		{
			return;
		}
		Spell[] array = new Spell[5];
		for (int i = 0; i < 5; i++)
		{
			WandSlot wandSlot = WandSlots[i];
			if (!(wandSlot.m_spellSlot == null))
			{
				array[i] = wandSlot.m_spellSlot.m_spell.Type;
			}
		}
		GameControl.Instance.Player.UpdateCurrentLoadout(array, saveToPlayfab);
	}

	public void LoadSpellSelection()
	{
		Assets.Scripts.Player.Player player = GameControl.Instance.Player;
		Spell[] loadout = player.GetCurrentLoadoutSpells();
		for (int i = 1; i < 5; i++)
		{
			Spell spell = loadout[i];
			if (spell == Spell.None)
			{
				continue;
			}
			if (!player.OwnsSpell(spell))
			{
				loadout[i] = Constants.DefaultSpells.First((Spell s) => s != Spell.Spell_Teleport && !loadout.Contains(s));
				player.UpdateCurrentLoadout(loadout);
				continue;
			}
			SpellSlot slot = null;
			if (CanGetRelicSlot(spell, out slot))
			{
				WandSlot wandSlot = WandSlots[i];
				if (slot.gameObject.activeSelf)
				{
					SelectSlot(slot, wandSlot);
				}
				else
				{
					slot.gameObject.SetActive(value: true);
					SelectSlot(slot, wandSlot);
					slot.gameObject.SetActive(value: false);
				}
				m_relicHandler.SetRelicIconSharedMaterial(slot, active: true);
			}
		}
	}

	public void ToggleInteractionActive(bool active)
	{
		if (m_isInteractionActive == active)
		{
			return;
		}
		m_isInteractionActive = active;
		EnableSpellSlots(active);
		if (GameControl.Instance.IsDualWieldSupportedAndActive)
		{
			SetSpellSelectionActive(active, playSound: false, !active);
			m_relicHandler.UpdateRelicIconSharedMaterials(m_allSpellSlots, active);
		}
		else if (active)
		{
			WorkshopWand.LockWandHandles(locked: false);
		}
		else
		{
			WorkshopWand.TryCloseWand();
			WorkshopWand.LockWandHandles(locked: true);
		}
		foreach (Interactable tableInteractable in m_tableInteractables)
		{
			tableInteractable.LockInteraction(!active);
			tableInteractable.LockLook(!active);
		}
		WandSlot[] wandSlots = WandSlots;
		foreach (WandSlot wandSlot in wandSlots)
		{
			wandSlot.SetInteractable(active);
		}
	}

	public void ToggleActive(bool active)
	{
		if (active)
		{
			MonoSingleton<ProjectorScreenUI>.Instance.ClearInformation();
		}
		else
		{
			MonoSingleton<ProjectorScreenUI>.Instance.SetInstructionsActive(InfoType.Empty);
		}
		for (int i = 0; i < m_allSpellSlots.Length; i++)
		{
			m_allSpellSlots[i].gameObject.SetActive(active);
		}
	}

	private void OnWorkshopWandOpened(Events.WorkshopWandOpenedEvent eventData)
	{
		StartCoroutine(BlockInteractionOnWandMovement(endState: true));
	}

	private void OnWorkshopWandClosed(Events.WorkshopWandClosedEvent eventData)
	{
		StartCoroutine(BlockInteractionOnWandMovement(m_isInteractionActive));
	}

	private IEnumerator BlockInteractionOnWandMovement(bool endState)
	{
		EnableSpellSlots(enable: false);
		yield return new WaitForSeconds(0.75f);
		EnableSpellSlots(endState);
	}
}
namespace Cortopia.Scripts.UI
{
	public class SpellSelectUIRelicHandler : MonoBehaviour
	{
		[SerializeField]
		private Material m_iconActiveMaterial;

		[SerializeField]
		private Material m_iconInactiveMaterial;

		[SerializeField]
		private Material m_iconLockedMaterial;

		private void Awake()
		{
			m_iconActiveMaterial = GameControl.Instance.AssetHandler.ReplaceMaterial(m_iconActiveMaterial);
			m_iconInactiveMaterial = GameControl.Instance.AssetHandler.ReplaceMaterial(m_iconInactiveMaterial);
			m_iconLockedMaterial = GameControl.Instance.AssetHandler.ReplaceMaterial(m_iconLockedMaterial);
		}

		public void SetRelicIconSharedMaterial(SpellSlot spellSlot, bool active)
		{
			if (!spellSlot.m_spell.IsType(Spell.Spell_Teleport))
			{
				spellSlot.Relic.SetIconMaterial((!active) ? m_iconInactiveMaterial : m_iconActiveMaterial);
			}
		}

		public void UpdateRelicIconSharedMaterials(SpellSlot[] allSpellSlots, bool tryEnable)
		{
			for (int i = 0; i < allSpellSlots.Length; i++)
			{
				UpdateRelicIconSharedMaterial(allSpellSlots[i], tryEnable);
			}
		}

		private void UpdateRelicIconSharedMaterial(SpellSlot spellSlot, bool tryEnable)
		{
			if (!(spellSlot == null) && !(spellSlot.m_spell == null) && spellSlot.gameObject.activeSelf && !spellSlot.m_spell.IsType(Spell.Spell_Teleport) && spellSlot.Relic != null && spellSlot.Relic.IsIconSpriteAssigned)
			{
				if (spellSlot.m_behaviourState == SlotState.Locked)
				{
					spellSlot.Relic.SetIconMaterial(m_iconLockedMaterial);
				}
				else if (spellSlot.m_behaviourState == SlotState.Occupied)
				{
					spellSlot.Relic.SetIconMaterial(m_iconActiveMaterial);
				}
				else
				{
					spellSlot.Relic.SetIconMaterial((!tryEnable) ? m_iconInactiveMaterial : m_iconActiveMaterial);
				}
			}
		}
	}
}
namespace Assets.Scripts.UI
{
	public class StartupOption : MonoBehaviour
	{
		[SerializeField]
		private StartupOptionType m_startupOptionType;

		private CanvasGroup m_canvasGroup;

		private CanvasGroup CanvasGroup
		{
			get
			{
				if (m_canvasGroup == null)
				{
					m_canvasGroup = GetComponent<CanvasGroup>();
				}
				return m_canvasGroup;
			}
		}

		public StartupOptionType Type => m_startupOptionType;

		public void Show()
		{
			base.gameObject.SetActive(value: true);
			CanvasGroup.DOFade(1f, 0.5f).OnComplete(delegate
			{
				Interactable.LockAllInteraction = false;
			});
		}

		public void Hide()
		{
			CanvasGroup.alpha = 0f;
			base.gameObject.SetActive(value: false);
		}
	}
	public class StartupOptionsHandler : MonoBehaviour
	{
		[SerializeField]
		private StartupOption[] m_options;

		[SerializeField]
		private TMP_Text m_languageText;

		[SerializeField]
		private Localize m_subtitleLocalize;

		[SerializeField]
		private Localize m_voipLocalize;

		private int m_optionIndex = -1;

		private int m_prevOptionIndex;

		private bool m_hasSeenOptions;

		private void OnEnable()
		{
			m_hasSeenOptions = WandsSave.GetBoolPref("PT") && !GameControl.Instance.PlatformSettings.ShowStartupOptions;
			DisableOptions();
			Reset();
		}

		public void Reset()
		{
			m_optionIndex = -1;
			DisableLoadingElements();
			EnableControls();
			SetupOptions();
			ProceedOneStep();
		}

		private void DisableLoadingElements()
		{
			GameObject[] array = GameObject.FindGameObjectsWithTag("LoadingElements");
			foreach (GameObject gameObject in array)
			{
				gameObject.gameObject.SetActive(value: false);
			}
		}

		private void EnableControls()
		{
			GameControl.Instance.PlayerControl.CreateInputSystem();
			GameControl.Instance.ToggleLoadSource(active: false);
			ExpandedSingleton<FadeHandler>.Instance.FadeIn(0.25f);
		}

		private void SetupOptions()
		{
			SetLanguageText(GameControl.Instance.GetCurrentLanguage().ToString());
			SetVoipLocalization(WandsVoip.IsPlayerEnabled);
			SetSubtitlesEnabled(WandsSave.GetBoolPref("SE"));
		}

		private void DisableOptions()
		{
			StartupOption[] options = m_options;
			foreach (StartupOption startupOption in options)
			{
				startupOption.Hide();
			}
		}

		private void ProceedOneStep()
		{
			m_optionIndex++;
			if (m_optionIndex >= m_options.Length)
			{
				FinishPreTutorial();
				return;
			}
			if (m_options[m_optionIndex].Type == StartupOptionType.PlatformSupport)
			{
				if (!PlatformSupportControl.HasDeprecationDate())
				{
					ProceedOneStep();
					return;
				}
			}
			else
			{
				if (m_hasSeenOptions)
				{
					ProceedOneStep();
					return;
				}
				if (m_options[m_optionIndex].Type == StartupOptionType.Grip)
				{
					if (!GameControl.Instance.GetInputAim().ContainsFlag(AimInput.Hand))
					{
						ProceedOneStep();
						return;
					}
				}
				else if (m_options[m_optionIndex].Type == StartupOptionType.VoIP)
				{
					if (!UniAndroidPermission.IsPermitted(AndroidPermission.RECORD_AUDIO))
					{
						ProceedOneStep();
						return;
					}
					GameControl.Instance.Platform.CheckVoiceChatAccess(delegate(bool hasAccess)
					{
						if (!hasAccess)
						{
							ProceedOneStep();
						}
						else
						{
							SetPanelActive(m_optionIndex);
						}
					}, displayErrorMessageOnFailure: false);
					return;
				}
			}
			SetPanelActive(m_optionIndex);
		}

		private void FinishPreTutorial()
		{
			m_options[m_prevOptionIndex].Hide();
			GameControl.Instance.PlayerControl.StopCurrentInputListener();
			WandsSave.SetPlayerPref("PT", value: true);
			if (WandsSave.GetBoolPref("SE"))
			{
				WandsAnalytics.SendCustomEvent(CustomEventType.player_activated_subtitles, new Dictionary<string, object>
				{
					{
						"Language",
						GameControl.Instance.GetCurrentLanguage()
					},
					{ "Reason", 1 }
				});
			}
			Events.InitiateStartupSceneLoadEvent initiateStartupSceneLoadEvent = new Events.InitiateStartupSceneLoadEvent();
			initiateStartupSceneLoadEvent.LoadLevel = Level.Workshop;
			EventHub.Publish(initiateStartupSceneLoadEvent);
			UnityEngine.Object.Destroy(base.gameObject);
		}

		private void SetPanelActive(int index)
		{
			Interactable.LockAllInteraction = true;
			if (m_prevOptionIndex >= 0)
			{
				m_options[m_prevOptionIndex].Hide();
			}
			m_prevOptionIndex = index;
			StartupOption startupOption = m_options[index];
			startupOption.Show();
			Interactable.LockAllInteraction = false;
		}

		private void SetPrimaryHand(bool rightHand)
		{
			WandsSave.SetPlayerPref("P1", rightHand);
			GameControl.Instance.PlayerControl.UpdateInputMethod(force: true);
		}

		private void BumpLanguage()
		{
			SetLanguageText(GameControl.Instance.GetNextLanguage(setLanguage: true));
		}

		private void SetLanguageText(string text)
		{
			m_languageText.text = text;
		}

		private void ToggleSubtitlesEnabled()
		{
			SetSubtitlesEnabled(!WandsSave.GetBoolPref("SE"));
		}

		private void SetSubtitlesEnabled(bool enabled)
		{
			WandsSave.SetPlayerPref("SE", enabled);
			m_subtitleLocalize.SetTerm("Options/" + ((!enabled) ? "Disabled" : "Enabled"));
		}

		private void SetVoipLocalization(bool enabled)
		{
			m_voipLocalize.SetTerm("Options/" + ((!enabled) ? "Disabled" : "Enabled"));
		}

		public void ReceiverProceedOneStep()
		{
			ProceedOneStep();
		}

		public void ReceiverSetPrimaryHand(bool rightHand)
		{
			SetPrimaryHand(rightHand);
		}

		public void ReceiverBumpLanguage()
		{
			BumpLanguage();
		}

		public void ReceiverToggleSubtitlesEnabled()
		{
			ToggleSubtitlesEnabled();
		}

		public void ReceiverToggleVoip()
		{
			if (!WandsVoip.IsPlayerEnabled)
			{
				GameControl.Instance.Platform.CheckVoiceChatAccess(delegate(bool hasAccess)
				{
					if (hasAccess)
					{
						SetVoipValue(enableVoip: true);
					}
				});
			}
			else
			{
				SetVoipValue(enableVoip: false);
			}
		}

		private void SetVoipValue(bool enableVoip)
		{
			WandsVoip.IsPlayerEnabled = enableVoip;
			SetVoipLocalization(WandsVoip.IsPlayerEnabled);
		}
	}
	public enum StartupOptionType
	{
		Language,
		Grip,
		VoIP,
		FinishUp,
		PlatformSupport
	}
	public class UI_ExpHandler : MonoBehaviour
	{
		[SerializeField]
		private TextMeshProUGUI m_level;

		[SerializeField]
		private TextMeshProUGUI m_nextLevel;

		[SerializeField]
		private TextMeshProUGUI m_levelLockText;

		[SerializeField]
		private Image m_xpBar;

		[SerializeField]
		private Image m_xpReward;

		[SerializeField]
		private TextMeshProUGUI m_xpRewardName;

		[SerializeField]
		private LocalizationParamsManager m_levelProgress;

		[SerializeField]
		private Sprite[] m_xpRewardIcons;

		private EventToken m_purchasedFullGameEventToken;

		private void OnEnable()
		{
			m_purchasedFullGameEventToken = EventHub.Subscribe<Events.PurchasedFullGameEvent>(OnPurchasedFullGame);
			UpdateUI();
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe<Events.PurchasedFullGameEvent>(m_purchasedFullGameEventToken);
			StopAllCoroutines();
		}

		public void UpdateUI(float customFillAmount = 0f)
		{
			if (GameControl.Instance.Player != null)
			{
				int level = GameControl.Instance.Player.SaveData.LevelData.Level;
				m_level.text = level.ToString();
				m_nextLevel.gameObject.SetActive(value: true);
				m_xpReward.gameObject.SetActive(value: true);
				m_nextLevel.text = (level + 1).ToString();
				m_levelLockText.gameObject.SetActive(GameControl.Instance.Player.HasGameAccess(GameAccess.Free));
				float num = GameControl.Instance.Player.SaveData.LevelData.CurrentExperience;
				int num2 = PlayerUtils.LevelToXp(level);
				m_xpBar.fillAmount = ((!(customFillAmount > 0f)) ? (num / (float)num2) : customFillAmount);
				m_levelProgress.SetParameterValue("LEVEL_PROGRESS", $"{num} / {num2}");
				if (!(m_xpReward == null) && !m_xpRewardIcons.IsNullOrEmpty())
				{
					Sprite sprite = m_xpReward.sprite;
					RewardType rewardType = PlayerUtils.LevelToReward(level + 1);
					m_xpReward.sprite = m_xpRewardIcons[(int)rewardType];
					m_xpRewardName.text = ScriptLocalization.Get(rewardType.ToString());
				}
			}
		}

		public void UpdateExperience(int gainedXp, int currentXp, int playerLevel)
		{
			if (!(m_xpBar == null))
			{
				float startValue = (float)currentXp / (float)PlayerUtils.LevelToXp(playerLevel);
				int num = PlayerUtils.LevelToXp(playerLevel);
				int num2 = currentXp + gainedXp;
				int gainedXp2 = num2 - num;
				StartCoroutine(UpdateFillAmount(startValue, (float)num2 / (float)num, gainedXp2, playerLevel));
			}
		}

		private IEnumerator UpdateFillAmount(float startValue, float endValue, int gainedXp, int playerLevel)
		{
			float t = 0f;
			float endFill = Mathf.Clamp01(endValue);
			while (t < 1f)
			{
				t += Time.deltaTime / 2f;
				m_xpBar.fillAmount = Mathf.Lerp(startValue, endFill, t);
				yield return null;
			}
			if (endValue > 1f)
			{
				PunSingleton<SoundManager>.Instance.PlayLocalSound("level_up");
				UpdateExperience(gainedXp, 0, playerLevel + 1);
				if (m_xpReward != null)
				{
					StartCoroutine(PingPongColor());
				}
			}
		}

		private IEnumerator PingPongColor()
		{
			while (true)
			{
				m_xpReward.color = Color.Lerp(Colors.RadialDefault, Colors.RadialHighlight, Mathf.PingPong(Time.time * 2f, 1f));
				yield return null;
			}
		}

		public void OnPurchasedFullGame(Events.PurchasedFullGameEvent eventData)
		{
			UpdateUI();
		}
	}
}
namespace Cortopia.Scripts.UI
{
	public class WandsLanguageController : MonoBehaviour, ILocalizationParamsManager
	{
		private static readonly Dictionary<Language, string> sm_languages = new Dictionary<Language, string>
		{
			{
				Language.English,
				"English"
			},
			{
				Language.Chinese,
				"Chinese"
			},
			{
				Language.French,
				"French"
			},
			{
				Language.German,
				"German"
			},
			{
				Language.Hindi,
				"Hindi"
			},
			{
				Language.Japanese,
				"Japanese"
			},
			{
				Language.Korean,
				"Korean"
			},
			{
				Language.Spanish,
				"Spanish"
			}
		};

		private static Language sm_currentLanguage = Language.English;

		private void OnEnable()
		{
			if (!LocalizationManager.ParamManagers.Contains(this))
			{
				LocalizationManager.ParamManagers.Add(this);
			}
		}

		private void OnDisable()
		{
			if (LocalizationManager.ParamManagers.Contains(this))
			{
				LocalizationManager.ParamManagers.Remove(this);
			}
		}

		public void SetStartLanguage(IPlatform platform)
		{
			IList<Language> availableLanguages = platform.GetAvailableLanguages();
			string @string = PlayerPrefs.GetString("I2 Language", string.Empty);
			if (!string.IsNullOrEmpty(@string) && Enum.TryParse<Language>(@string, out var result) && availableLanguages.Contains(result))
			{
				SetLanguage(result);
				return;
			}
			Language language = Language.English;
			SetLanguage(availableLanguages.Contains(language) ? language : Language.English);
		}

		public Language GetLanguage()
		{
			return sm_currentLanguage;
		}

		public void SetLanguage(Language newLanguage)
		{
			sm_currentLanguage = newLanguage;
			LocalizationManager.CurrentLanguage = sm_languages[newLanguage];
		}

		public string GetNextLanguage(bool setLanguage)
		{
			IList<Language> availableLanguages = GameControl.Instance.Platform.GetAvailableLanguages();
			int num = availableLanguages.IndexOf(sm_currentLanguage);
			num++;
			if (num > availableLanguages.Count - 1)
			{
				num = 0;
			}
			Language language = availableLanguages[num];
			if (setLanguage)
			{
				SetLanguage(language);
			}
			return sm_languages[language];
		}

		public virtual string GetParameterValue(string paramName)
		{
			switch (paramName)
			{
			case "ACCOUNT_ID":
				return (!(GameControl.Instance.Platform != null)) ? "Unknown" : GameControl.Instance.Platform.AccountID;
			case "GAME_VERSION":
				return GameControl.Instance.GetClientVersionString();
			case "LEADERBOARD_SEASON":
				return SeasonControl.CurrentSeason.ToString();
			case "NETWORK_VERSION":
				return GameControl.Instance.NetworkVersion;
			case "NETWORK_VERSION_LATEST":
				return GameControl.Instance.NetworkVersion;
			case "CURRENT_LVL":
				return (!PhotonNetwork.InRoom) ? string.Empty : ScriptLocalization.Get("Levels/" + (string)PhotonNetwork.CurrentRoom.CustomProperties["A2"]);
			case "TOKEN_COUNT":
				if (GameControl.Instance.Player == null)
				{
					break;
				}
				return GameControl.Instance.Player.GetSpellTokens().ToString();
			case "LOADOUT_COUNT":
				if (GameControl.Instance.Player == null)
				{
					break;
				}
				return GameControl.Instance.Player.GetUnlockedLoadouts().ToString();
			case "SEASON_STARTDATE":
				if (!SeasonControl.NextSeasonStartDate.HasValue)
				{
					break;
				}
				return ScriptLocalization.Get(string.Format("Workshop/Blackboard/{0}", SeasonControl.NextSeasonStartDate.Value.ToString("MMMM", CultureInfo.InvariantCulture))) + SeasonControl.NextSeasonStartDate.Value.ToString(" dd, yyyy");
			case "PLAYER_RATING":
				if (GameControl.Instance.Player == null)
				{
					break;
				}
				return GameControl.Instance.Player.SeasonScore.ToString();
			case "PLAYER_RANK":
				if (GameControl.Instance.Player == null)
				{
					break;
				}
				return GameControl.Instance.Player.Rank.ToString();
			case "RATING_UNLOCK_LEVEL":
				return 5.ToString();
			case "TIME":
			case "SEASON":
				return string.Empty;
			default:
				throw new NotImplementedException($"String not implemented: {paramName}");
			}
			return string.Empty;
		}
	}
}
namespace Assets.Scripts.UI.Workshop
{
	public class Blackboard : MonoBehaviour, IWorkshopTileListener
	{
		[SerializeField]
		protected BlackboardMenu[] m_blackboardMenus;

		[SerializeField]
		private GameObject m_blackboardButtonParent;

		[SerializeField]
		private Transform m_chalkLine;

		private BlackboardButton[] m_blackboardButtons;

		public BlackboardButton[] BlackboardButtons
		{
			get
			{
				if (m_blackboardButtons.IsNullOrEmpty())
				{
					m_blackboardButtons = m_blackboardButtonParent.GetComponentsInChildren<BlackboardButton>();
				}
				return m_blackboardButtons;
			}
		}

		public virtual void ToggleBlackboard(BlackboardState newState)
		{
			for (int i = 0; i < m_blackboardMenus.Length; i++)
			{
				BlackboardMenu blackboardMenu = m_blackboardMenus[i];
				blackboardMenu.GameObject.SetActive(value: false);
				if (blackboardMenu.BlackboardState == newState)
				{
					blackboardMenu.GameObject.SetActive(value: true);
				}
			}
			UpdateButtonSelection(newState);
		}

		private void UpdateButtonSelection(BlackboardState state)
		{
			BlackboardButton[] blackboardButtons = BlackboardButtons;
			foreach (BlackboardButton blackboardButton in blackboardButtons)
			{
				if (blackboardButton.UpdateSelection(state))
				{
					m_chalkLine.transform.SetParent(blackboardButton.transform, worldPositionStays: true);
					m_chalkLine.transform.localPosition = new Vector3(0f, -15f, 0f);
				}
			}
		}

		public virtual void ToggleInteractionActive(bool active)
		{
			BlackboardButton[] blackboardButtons = BlackboardButtons;
			foreach (BlackboardButton blackboardButton in blackboardButtons)
			{
				blackboardButton.LockInteraction(!active);
				blackboardButton.LockLook(!active);
			}
		}

		public virtual void ToggleActive(bool active)
		{
			BlackboardButton[] blackboardButtons = BlackboardButtons;
			foreach (BlackboardButton blackboardButton in blackboardButtons)
			{
				blackboardButton.gameObject.SetActive(active);
			}
		}
	}
	public class BlackboardButton : InteractableButton
	{
		[SerializeField]
		private Blackboard m_blackboardUI;

		[SerializeField]
		private BlackboardState m_btnType;

		[SerializeField]
		private Color m_selectColor;

		[SerializeField]
		private GameObject m_chalkEffect;

		private void Start()
		{
			m_chalkEffect.SetActive(value: false);
		}

		private void OnEnable()
		{
			AddClickListener(OnClick);
		}

		protected override void OnDisable()
		{
			base.OnDisable();
			RemoveClickListener(OnClick);
		}

		public override void Interact()
		{
			if (!base.InteractionLocked)
			{
				base.Interact();
				PunSingleton<SoundManager>.Instance.PlayLocalSoundAtPoint("chalk_press", 1f, base.transform.position, 1);
				m_chalkEffect.SetActive(value: false);
			}
		}

		private void OnClick()
		{
			m_blackboardUI.ToggleBlackboard(m_btnType);
		}

		public override void LookEnter()
		{
			if (!base.LookLocked)
			{
				base.LookEnter();
				PunSingleton<SoundManager>.Instance.PlayLocalSoundAtPoint("chalk_hover", 1f, base.transform.position, 1);
				m_chalkEffect.SetActive(value: true);
			}
		}

		public override void LookExit()
		{
			if (!base.LookLocked)
			{
				base.LookExit();
				m_chalkEffect.SetActive(value: false);
			}
		}

		public bool UpdateSelection(BlackboardState state)
		{
			bool flag2 = (base.InteractionLocked = m_btnType == state);
			base.LookLocked = flag2;
			WandsButtonHighlighter[] buttonHighlighters = m_buttonHighlighters;
			foreach (WandsButtonHighlighter wandsButtonHighlighter in buttonHighlighters)
			{
				if (wandsButtonHighlighter is ButtonTextColorer)
				{
					ButtonTextColorer buttonTextColorer = wandsButtonHighlighter as ButtonTextColorer;
					buttonTextColorer.ChangeTextColor((!flag2) ? buttonTextColorer.m_defaultColor : m_selectColor);
				}
				else
				{
					wandsButtonHighlighter.LookExit();
				}
			}
			return flag2;
		}
	}
	[Serializable]
	public class BlackboardMenu
	{
		public BlackboardState BlackboardState;

		public GameObject GameObject;
	}
	public class BlackboardTitleController : MonoBehaviour
	{
		[Header("Buttons")]
		[SerializeField]
		private TitleSelectButton m_titlePrefab;

		[SerializeField]
		private Transform m_titleContainer;

		[SerializeField]
		private TitleScroller m_scroller;

		[SerializeField]
		private BlackboardTitleInformation m_blackboardTitleInformation;

		[SerializeField]
		private float m_speed = 25f;

		[SerializeField]
		private float m_distance = 0.625f;

		private TitleSelectButton m_activeTitleButton;

		private Dictionary<int, List<TitleSelectButton>> m_buttons = new Dictionary<int, List<TitleSelectButton>>();

		private float m_canvasScale = 0.00125f;

		private float m_titleHeight = 100f;

		private int m_page;

		private int m_maxIndexPage;

		private bool m_scrolling;

		private int m_pageSize = 5;

		private void Awake()
		{
			InitializeButton();
			ToggleColliders(m_page, active: true);
		}

		private void InitializeButton()
		{
			Dictionary<Title, CatalogItemWrapper> ownedTitles = GameControl.Instance.Player.GetOwnedTitles();
			int num = Mathf.CeilToInt((float)ownedTitles.Count / (float)m_pageSize);
			m_maxIndexPage = num - 1;
			InitialiseButtonDictionary(num);
			for (int i = 0; i < ownedTitles.Count; i++)
			{
				KeyValuePair<Title, CatalogItemWrapper> keyValuePair = ownedTitles.ElementAt(i);
				Title key = keyValuePair.Key;
				CatalogItemWrapper value = keyValuePair.Value;
				TitleSelectButton titleSelectButton = UnityEngine.Object.Instantiate(m_titlePrefab, m_titlePrefab.transform.position - Vector3.up * m_titleHeight * i * m_canvasScale, m_titlePrefab.transform.rotation, m_titleContainer);
				titleSelectButton.SetTitle(key, value.DisplayName);
				int key2 = i / m_pageSize;
				m_buttons[key2].Add(titleSelectButton);
				if (GameControl.Instance.Player.Title == key)
				{
					OnTitleClick(titleSelectButton);
				}
			}
			UnityEngine.Object.Destroy(m_titlePrefab.gameObject);
		}

		private void InitialiseButtonDictionary(int numberOfPages)
		{
			for (int i = 0; i < numberOfPages; i++)
			{
				m_buttons.Add(i, new List<TitleSelectButton>());
			}
		}

		private void DisplayTitleInformation()
		{
			m_blackboardTitleInformation.UpdateInformation(m_activeTitleButton);
		}

		private void ToggleColliders(int page, bool active)
		{
			foreach (TitleSelectButton item in m_buttons[page])
			{
				item.ToggleCollider(active);
			}
		}

		private void Scroll(int pageDiff)
		{
			if (!m_scrolling)
			{
				ToggleColliders(m_page, active: false);
				m_page += pageDiff;
				m_scrolling = true;
				m_scroller.ScrollTo(Vector3.up * m_distance * pageDiff, m_speed, delegate
				{
					ToggleColliders(m_page, active: true);
					m_scrolling = false;
				});
			}
		}

		public void OnTitleClick(TitleSelectButton titleSelectButton)
		{
			if (m_activeTitleButton != null)
			{
				m_activeTitleButton.Clear();
			}
			m_activeTitleButton = titleSelectButton;
			m_activeTitleButton.OnClick();
			DisplayTitleInformation();
			if (GameControl.Instance.Player.Title != m_activeTitleButton.Title && GameControl.Instance.Player.TutorialState == TutorialState.Completed)
			{
				GameControl.Instance.UnlockAchievement(Assets.Scripts.Enums.AchievementType.ChangeTitle);
			}
			GameControl.Instance.Player.SetTitle(m_activeTitleButton.Title);
		}

		public void ScrollUp()
		{
			if (m_page > 0)
			{
				Scroll(-1);
			}
		}

		public void ScrollDown()
		{
			if (m_page < m_maxIndexPage)
			{
				Scroll(1);
			}
		}
	}
	public class BlackboardTitleInformation : MonoBehaviour
	{
		[SerializeField]
		private TMP_Text m_titleText;

		[SerializeField]
		private Localize m_title;

		[SerializeField]
		private TMP_Text m_descriptionText;

		[SerializeField]
		private Localize m_description;

		[SerializeField]
		private LocalizationParamsManager[] m_seasonParams;

		public void UpdateInformation(TitleSelectButton titleSelectButton)
		{
			Localize title = m_title;
			string text = null;
			m_title.Term = text;
			title.FinalTerm = text;
			Localize description = m_description;
			text = null;
			m_description.Term = text;
			description.FinalTerm = text;
			m_titleText.text = string.Empty;
			m_descriptionText.text = string.Empty;
			if (titleSelectButton != null)
			{
				CatalogItemWrapper title2 = WandsDatabase.GetTitle(titleSelectButton.Title);
				string displayName = title2.DisplayName;
				string text2 = displayName.ToNumbers();
				m_title.SetTerm(displayName.TrimEnd(text2.ToCharArray()));
				m_description.SetTerm(title2.Description);
				for (int i = 0; i < m_seasonParams.Length; i++)
				{
					m_seasonParams[i].SetParameterValue("SEASON", text2);
				}
			}
		}
	}
	public class BlackboardUI : MonoSingleton<BlackboardUI>
	{
		[SerializeField]
		private GameObject[] m_blackboardMenus;

		[SerializeField]
		private Renderer m_blackboard;

		[SerializeField]
		private Texture[] m_textures;

		[SerializeField]
		private GameObject m_f2PTextObject;

		[Header("Leaderboards")]
		[SerializeField]
		private GameObject m_userLockedDisplay;

		[SerializeField]
		private GameObject[] m_holders;

		[SerializeField]
		private Transform[] m_lineParents;

		[SerializeField]
		private GameObject[] m_enableOnSeasonLock;

		[SerializeField]
		private GameObject[] m_disableOnSeasonLock;

		[SerializeField]
		private GameObject[] m_enableOnSeasonLockIfHasRating;

		[SerializeField]
		private Localize m_globalLeaderboard;

		[SerializeField]
		private Renderer m_userLeaderboard;

		private BlackboardButton[] m_blackboardButtons;

		private List<TextMeshPro[]> m_global = new List<TextMeshPro[]>();

		private List<TextMeshPro[]> m_user = new List<TextMeshPro[]>();

		private EventToken m_sceneLoadedEventToken;

		private EventToken m_leaderboardLoadedEventToken;

		private EventToken m_purchasedFullGameEventToken;

		public BlackboardState CurrentState { get; private set; }

		private void OnEnable()
		{
			m_sceneLoadedEventToken = EventHub.Subscribe<Events.SceneLoadedEvent>(OnSceneLoaded);
			m_leaderboardLoadedEventToken = EventHub.Subscribe<Events.LeadboardLoadedEvent>(OnLeaderboardLoaded);
			m_purchasedFullGameEventToken = EventHub.Subscribe<Events.PurchasedFullGameEvent>(OnPurchasedFullGame);
		}

		protected override void OnDisable()
		{
			base.OnDisable();
			EventHub.Unsubscribe<Events.SceneLoadedEvent>(m_sceneLoadedEventToken);
			EventHub.Unsubscribe<Events.LeadboardLoadedEvent>(m_leaderboardLoadedEventToken);
			EventHub.Unsubscribe<Events.PurchasedFullGameEvent>(m_purchasedFullGameEventToken);
		}

		private void OnLeaderboardLoaded(Events.LeadboardLoadedEvent eventData)
		{
			LeaderboardLoaded(eventData.LeaderboardType);
		}

		private void LeaderboardLoaded(LeaderboardType leaderboardType)
		{
			List<Assets.Scripts.Platform.LeaderboardEntry> list = GameControl.Instance.Leaderboards.Entries[leaderboardType];
			if (!list.IsNullOrEmpty())
			{
				WriteToBoard(leaderboardType, list);
			}
		}

		private void OnPurchasedFullGame(Events.PurchasedFullGameEvent eventData)
		{
			ToggleBlackboard(BlackboardState.Tutorial);
		}

		private void OnSceneLoaded(Events.SceneLoadedEvent eventData)
		{
			SceneLoaded(eventData.Scene, eventData.LoadSceneMode);
		}

		private void SceneLoaded(Scene scene, LoadSceneMode loadMode)
		{
			RetrieveTextComponents();
			ClearLeaderboards();
			if (GameControl.Instance.Leaderboards.Entries == null)
			{
				return;
			}
			foreach (LeaderboardType key in GameControl.Instance.Leaderboards.Entries.Keys)
			{
				LeaderboardLoaded(key);
			}
		}

		public void ToggleBlackboard(string newState)
		{
			object obj = Enum.Parse(typeof(BlackboardState), newState, ignoreCase: true);
			if (obj == null)
			{
				WandsLogger.Log("Cannot toggle blackboard to " + newState + ", parsing failed", LogType.Error);
			}
			else
			{
				ToggleBlackboard((BlackboardState)obj);
			}
		}

		public void ToggleBlackboard(BlackboardState newState)
		{
			m_f2PTextObject.SetActive(value: false);
			CurrentState = newState;
			switch (newState)
			{
			case BlackboardState.Options:
				ChangeTexture(1);
				break;
			case BlackboardState.Tutorial:
				if (GameControl.Instance.Player.HasGameAccess(GameAccess.Full))
				{
					ChangeTexture(2);
					m_f2PTextObject.SetActive(value: false);
				}
				else
				{
					ChangeTexture(3);
					m_f2PTextObject.SetActive(value: true);
				}
				break;
			default:
				ChangeTexture(0);
				break;
			}
			GameObject[] blackboardMenus = m_blackboardMenus;
			foreach (GameObject gameObject in blackboardMenus)
			{
				gameObject.SetActive(value: false);
			}
			m_blackboardMenus[(int)newState].SetActive(value: true);
			UpdateButtonSelection(newState);
			if (newState == BlackboardState.Leaderboards)
			{
				WriteToBoard(LeaderboardType.RatingUser, null);
			}
		}

		private void UpdateButtonSelection(BlackboardState state)
		{
			if (m_blackboardButtons.IsNullOrEmpty())
			{
				m_blackboardButtons = base.transform.parent.RetrieveChild("UI_Canvas").GetComponentsInChildren<BlackboardButton>();
			}
			BlackboardButton[] blackboardButtons = m_blackboardButtons;
			foreach (BlackboardButton blackboardButton in blackboardButtons)
			{
				blackboardButton.UpdateSelection(state);
			}
		}

		private void RetrieveTextComponents()
		{
			if (m_global.Count != 0 && m_user.Count != 0)
			{
				return;
			}
			for (int i = 0; i < m_holders.Length; i++)
			{
				TextMeshPro[] componentsInChildren = m_holders[i].GetComponentsInChildren<TextMeshPro>();
				List<TextMeshPro[]> list = new List<TextMeshPro[]>();
				for (int j = 0; j < 10; j++)
				{
					TextMeshPro textMeshPro = componentsInChildren[j + j];
					TextMeshPro textMeshPro2 = componentsInChildren[j + 1 + j];
					list.Add(new TextMeshPro[2] { textMeshPro, textMeshPro2 });
				}
				switch (i)
				{
				case 0:
					m_global.AddRange(list);
					break;
				case 1:
					m_user.AddRange(list);
					break;
				}
			}
		}

		private void ChangeTexture(int txtIndex)
		{
			if (!(m_blackboard == null) && m_textures != null)
			{
				txtIndex = Mathf.Clamp(txtIndex, 0, m_textures.Length - 1);
				m_blackboard.material.mainTexture = m_textures[txtIndex];
			}
		}

		public void WriteToBoard(LeaderboardType leaderboardType, List<Assets.Scripts.Platform.LeaderboardEntry> entries)
		{
			if (SeasonControl.SeasonLocked)
			{
				m_globalLeaderboard.SetTerm("Workshop/Blackboard/SeasonWinners");
				m_userLeaderboard.enabled = false;
				GameObject[] enableOnSeasonLock = m_enableOnSeasonLock;
				foreach (GameObject gameObject in enableOnSeasonLock)
				{
					gameObject.SetActive(value: true);
				}
				GameObject[] disableOnSeasonLock = m_disableOnSeasonLock;
				foreach (GameObject gameObject2 in disableOnSeasonLock)
				{
					gameObject2.SetActive(value: false);
				}
				if (GameControl.Instance.Player.HasUnlockedRating)
				{
					GameObject[] enableOnSeasonLockIfHasRating = m_enableOnSeasonLockIfHasRating;
					foreach (GameObject gameObject3 in enableOnSeasonLockIfHasRating)
					{
						gameObject3.SetActive(value: true);
					}
				}
				if (leaderboardType == LeaderboardType.RatingUser)
				{
					return;
				}
			}
			if (entries == null || entries.Count == 0)
			{
				return;
			}
			List<TextMeshPro[]> list = new List<TextMeshPro[]>();
			switch (leaderboardType)
			{
			case LeaderboardType.RatingGlobal:
				list.AddRange(m_global);
				break;
			case LeaderboardType.RatingUser:
				if (GameControl.Instance.Player.HasUnlockedRating)
				{
					list.AddRange(m_user);
					if (m_userLockedDisplay != null)
					{
						m_userLockedDisplay.gameObject.SetActive(value: false);
					}
				}
				else if (!SeasonControl.SeasonLocked && m_userLockedDisplay != null)
				{
					m_userLockedDisplay.gameObject.SetActive(value: true);
					return;
				}
				break;
			}
			if (list.Count == 0)
			{
				return;
			}
			m_lineParents[(int)leaderboardType].gameObject.SetActive(value: false);
			for (int l = 0; l < entries.Count; l++)
			{
				TextMeshPro[] array = list[l];
				if (array != null && array.Length != 0)
				{
					TextMeshPro textMeshPro = list[l][0];
					string text = entries[l].Name;
					int score = entries[l].Score;
					int rank = entries[l].Rank;
					bool flag = score > 0;
					if (text == GameControl.Instance.Platform.AccountID && rank == GameControl.Instance.Player.Rank)
					{
						m_lineParents[(int)leaderboardType].localPosition = textMeshPro.transform.parent.localPosition;
						m_lineParents[(int)leaderboardType].gameObject.SetActive(value: true);
						flag = GameControl.Instance.Player.HasUnlockedRating;
					}
					string text2 = ((string.IsNullOrEmpty(text) || rank < 0) ? string.Empty : $"{rank}. {text}");
					textMeshPro.text = text2;
					list[l][1].text = ((!flag) ? string.Empty : score.ToString());
					list[l][1].transform.GetChild(0).gameObject.SetActive(!flag);
				}
			}
		}

		private void ClearLeaderboards()
		{
			for (int i = 0; i < m_global.Count; i++)
			{
				for (int j = 0; j < m_global[i].Length; j++)
				{
					m_global[i][j].text = string.Empty;
					if (j == 1)
					{
						m_global[i][j].transform.GetChild(0).gameObject.SetActive(value: false);
					}
				}
			}
			for (int k = 0; k < m_user.Count; k++)
			{
				for (int l = 0; l < m_user[k].Length; l++)
				{
					m_user[k][l].text = string.Empty;
					if (l == 1)
					{
						m_user[k][l].transform.GetChild(0).gameObject.SetActive(value: false);
					}
				}
			}
			for (int m = 0; m < m_lineParents.Length; m++)
			{
				m_lineParents[m].gameObject.SetActive(value: false);
			}
		}
	}
	public class ButtonTextColorPulser : MonoBehaviour
	{
		private TMP_Text m_text;

		[SerializeField]
		private Color m_color1;

		[SerializeField]
		private Color m_color2;

		[SerializeField]
		private float m_fadeTime;

		private float m_currentTime;

		private int m_maxLoops;

		public bool IsPulsing { get; private set; }

		public bool IsPaused { get; private set; }

		private TMP_Text Text
		{
			get
			{
				if (m_text == null)
				{
					m_text = GetComponent<TextMeshPro>();
					if (m_text == null)
					{
						m_text = GetComponent<TextMeshProUGUI>();
						if (!(m_text == null))
						{
						}
					}
				}
				return m_text;
			}
		}

		public void StartPulse()
		{
			StartPulse(0);
		}

		public void StartPulse(int loops)
		{
			IsPulsing = true;
			IsPaused = false;
			m_currentTime = 0f;
			m_maxLoops = loops;
		}

		public void StopPulse()
		{
			StopPulse(m_color1);
		}

		public void StopPulse(Color endColor)
		{
			IsPulsing = false;
			Text.color = endColor;
			IsPaused = false;
		}

		public void PausePulse()
		{
			if (IsPulsing)
			{
				IsPaused = true;
				IsPulsing = false;
			}
		}

		private void Update()
		{
			if (IsPulsing)
			{
				m_currentTime += Time.deltaTime;
				if (m_maxLoops > 0 && m_currentTime >= (float)m_maxLoops * m_fadeTime * 2f)
				{
					StopPulse();
				}
				else
				{
					Text.color = Color.Lerp(m_color1, m_color2, 1f / m_fadeTime * Mathf.PingPong(m_currentTime, m_fadeTime));
				}
			}
		}
	}
}
namespace Assets.Scripts.UI.Workshop.CharacterSelection
{
	public class CharacterMirror : MonoBehaviour, IWorkshopTileListener
	{
		[SerializeField]
		private GameObject m_characterBase;

		[SerializeField]
		private CharacterPortraitStand m_portraitStand;

		[SerializeField]
		private PortraitFxHandler m_portraitFxHandler;

		[SerializeField]
		private CharacterMirrorUI m_mirrorUI;

		[SerializeField]
		private CharacterPortrait[] m_characterPortraits = Array.Empty<CharacterPortrait>();

		private Dictionary<CharacterType, DisplayCharacter> m_characters;

		private EventToken m_rewardClaimedEventToken;

		public CharacterType CurrentCharacterType { get; private set; }

		public CharacterMirrorUI MirrorUI
		{
			[CompilerGenerated]
			get
			{
				return m_mirrorUI;
			}
		}

		public CharacterPortraitStand PortraitStand
		{
			[CompilerGenerated]
			get
			{
				return m_portraitStand;
			}
		}

		public PortraitFxHandler PortraitFxHandler
		{
			[CompilerGenerated]
			get
			{
				return m_portraitFxHandler;
			}
		}

		private void OnEnable()
		{
			m_rewardClaimedEventToken = EventHub.Subscribe<Events.EventRewardClaimedEvent>(OnRewardClaimed);
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe(m_rewardClaimedEventToken);
		}

		private void Awake()
		{
			m_portraitFxHandler.gameObject.SetActive(value: false);
			SpawnCharacters(GameControl.Instance.Platform.GetAllCharacters());
		}

		private void SpawnCharacters(CharacterType[] availableCharacters)
		{
			Transform parent = m_characterBase.transform.Find("Base").transform;
			GameObject gameObject = Resources.Load("CharacterControllers/DisplayCharacter") as GameObject;
			if (gameObject == null)
			{
				WandsLogger.LogError("No DisplayCharacter could be loaded from Resources, can't spawn mirror characters");
				return;
			}
			m_characters = new Dictionary<CharacterType, DisplayCharacter>(availableCharacters.Length);
			foreach (CharacterType characterType in availableCharacters)
			{
				DisplayCharacter component = UnityEngine.Object.Instantiate(gameObject, parent).GetComponent<DisplayCharacter>();
				component.Initialize(characterType);
				m_characters.Add(characterType, component);
				component.SetActive(enable: false);
			}
		}

		public void SwitchCharacter(CharacterType type)
		{
			if (CurrentCharacterType != type)
			{
				SetCharacter(type);
			}
		}

		private void SetCharacter(CharacterType type)
		{
			m_characters[CurrentCharacterType].SetActive(enable: false);
			CurrentCharacterType = type;
			m_characters[CurrentCharacterType].SetActive(enable: true);
		}

		public void ToggleInteractionActive(bool active)
		{
		}

		public void ToggleActive(bool active)
		{
			m_mirrorUI.ToggleActive(active);
			PortraitStand.ToggleActive(active);
			if (active)
			{
				SetCharacter(GameControl.Instance.Player.Character);
				return;
			}
			foreach (KeyValuePair<CharacterType, DisplayCharacter> character in m_characters)
			{
				character.Value.SetActive(enable: false);
			}
		}

		private void OnRewardClaimed(Events.EventRewardClaimedEvent eventData)
		{
			CheckRewardForCharacterUnlocks(eventData.CustomEvent.Rewards);
		}

		private void CheckRewardForCharacterUnlocks(List<CustomEventReward> rewards)
		{
			foreach (CustomEventReward reward in rewards)
			{
				if (!reward.IsCharacter)
				{
					continue;
				}
				CharacterPortrait[] characterPortraits = m_characterPortraits;
				foreach (CharacterPortrait characterPortrait in characterPortraits)
				{
					if (characterPortrait.CharacterType == reward.CharacterType)
					{
						characterPortrait.AssignMaterial(ItemMaterialType.Default, highlighted: false);
						break;
					}
				}
			}
		}
	}
	public class CharacterMirrorBuyButton : InteractableText
	{
		[SerializeField]
		private CharacterMirrorUI m_characterMirrorUI;

		public override void Interact()
		{
			base.Interact();
			if (TryBuyCharacter())
			{
				m_characterMirrorUI.SwitchState(CharacterMirrorState.Buying);
			}
		}

		private bool TryBuyCharacter()
		{
			CharacterType currentCharacterType = m_characterMirrorUI.CharacterMirror.CurrentCharacterType;
			CatalogItemWrapper character = WandsDatabase.GetCharacter(currentCharacterType);
			if (GameControl.Instance.Player.CanAfford(character.DustPrice))
			{
				GameControl.Instance.BuyCharacter(currentCharacterType);
				return true;
			}
			return false;
		}
	}
	public class CharacterMirrorEquipButton : InteractableText
	{
		[SerializeField]
		private CharacterMirrorUI m_characterMirrorUI;

		public override void Interact()
		{
			base.Interact();
			m_characterMirrorUI.EquipSelectedCharacter(CharacterEquipSource.Equip);
		}
	}
	public class CharacterMirrorUI : MonoBehaviour, IWorkshopTileListener
	{
		[Header("UI Fade")]
		[SerializeField]
		private CanvasGroup m_canvasGroup;

		[SerializeField]
		private float m_uiFadeInTime = 0.25f;

		[SerializeField]
		private float m_uiFadeInDelay = 0.25f;

		[Header("Mirror UI Elements")]
		[SerializeField]
		private TMP_Text m_selectedCharacterText;

		[SerializeField]
		private TMP_Text m_costText;

		[SerializeField]
		private TMP_Text m_equippedText;

		[SerializeField]
		private TMP_Text m_characterUnlockedText;

		[SerializeField]
		private TMP_Text m_currentDustText;

		[SerializeField]
		private TMP_Text m_eventPrizeText;

		[SerializeField]
		private CharacterMirrorEquipButton m_equipButton;

		[SerializeField]
		private CharacterMirrorBuyButton m_buyButton;

		[Header("Character Mirror")]
		[SerializeField]
		private CharacterMirror m_characterMirror;

		private EventToken m_virtualCurrencyChangedEventToken;

		private Dictionary<CharacterMirrorState, MirrorState> m_mirrorStates;

		private MirrorState m_currentState;

		private Coroutine m_latentSwitchState;

		private CharacterPortrait m_currentPortrait;

		public CharacterMirror CharacterMirror
		{
			[CompilerGenerated]
			get
			{
				return m_characterMirror;
			}
		}

		private void OnDisable()
		{
			StopAllCoroutines();
		}

		private void Awake()
		{
			m_mirrorStates = new Dictionary<CharacterMirrorState, MirrorState>
			{
				{
					CharacterMirrorState.Buy,
					new MirrorStateBuy(this, m_currentDustText, m_selectedCharacterText, m_costText, m_buyButton)
				},
				{
					CharacterMirrorState.Buying,
					new MirrorStateBuying(this, m_currentDustText, m_selectedCharacterText, m_characterUnlockedText)
				},
				{
					CharacterMirrorState.Equip,
					new MirrorStateEquip(this, m_currentDustText, m_selectedCharacterText, m_equipButton)
				},
				{
					CharacterMirrorState.Equipped,
					new MirrorStateEquipped(this, m_currentDustText, m_selectedCharacterText, m_equippedText)
				},
				{
					CharacterMirrorState.Special,
					new MirrorStateSpecial(this, m_currentDustText, m_selectedCharacterText, m_costText, m_eventPrizeText)
				}
			};
			foreach (MirrorState value in m_mirrorStates.Values)
			{
				value.Disable();
			}
			m_currentState = m_mirrorStates[CharacterMirrorState.Equipped];
		}

		private void Start()
		{
			UpdateCurrentDust(GameControl.Instance.Player.SaveData.VirtualCurrency);
		}

		private void OnCurrencyChanged(Events.VirtualCurrencyChanged eventData)
		{
			UpdateCurrentDust(eventData.Amount);
		}

		private void UpdateCurrentDust(int amount)
		{
			if (m_currentDustText != null)
			{
				m_currentDustText.text = amount.ToString();
			}
		}

		public void UnlockPortrait()
		{
			m_currentPortrait.Unlock(CharacterMirror.PortraitFxHandler.gameObject);
		}

		public void SwitchCharacter(CharacterPortrait characterPortrait)
		{
			if ((object)m_currentPortrait != null)
			{
				m_currentPortrait.DeselectPortrait();
			}
			m_currentPortrait = characterPortrait;
			CharacterMirror.SwitchCharacter(characterPortrait.CharacterType);
			if (GameControl.Instance.Player.Character.Equals(characterPortrait.CharacterType))
			{
				SwitchState(CharacterMirrorState.Equipped);
			}
			else if (characterPortrait.IsUnlocked)
			{
				SwitchState(CharacterMirrorState.Equip);
			}
			else if (Constants.SpecialCharacters.Contains(characterPortrait.CharacterType))
			{
				SwitchState(CharacterMirrorState.Special);
			}
			else
			{
				SwitchState(CharacterMirrorState.Buy);
			}
		}

		public void EquipSelectedCharacter(CharacterEquipSource source, bool playSfx = true)
		{
			CharacterType currentCharacterType = CharacterMirror.CurrentCharacterType;
			CharacterType character = GameControl.Instance.Player.Character;
			CharacterMirror.PortraitStand.SetPortrait(currentCharacterType);
			SwitchState(CharacterMirrorState.Equipped);
			if (playSfx)
			{
				PunSingleton<SoundManager>.Instance.PlayLocalSoundAtPoint("painting_equip", 1f, base.transform.position, 1);
			}
			if (character != currentCharacterType)
			{
				GameControl.Instance.Player.Character = currentCharacterType;
				if (source == CharacterEquipSource.Drag || source == CharacterEquipSource.Equip)
				{
					WandsAnalytics.SendCustomEvent(CustomEventType.player_equipped_character, new Dictionary<string, object>
					{
						{
							"OldCharacterId",
							(int)character
						},
						{
							"NewCharacterId",
							(int)currentCharacterType
						}
					});
				}
			}
		}

		public void SwitchState(CharacterMirrorState newState)
		{
			if (!m_mirrorStates.IsNullOrEmpty())
			{
				m_currentState.Disable();
				m_currentState = m_mirrorStates[newState];
				m_currentState.Enable();
			}
		}

		public void StopDelayedStateSwitch()
		{
			if (m_latentSwitchState != null)
			{
				StopCoroutine(m_latentSwitchState);
				m_latentSwitchState = null;
			}
		}

		public void SwitchStateAfterDelay(CharacterMirrorState newState, float delay)
		{
			StopDelayedStateSwitch();
			m_latentSwitchState = StartCoroutine(LatentSwitchState(newState, delay));
		}

		private IEnumerator LatentSwitchState(CharacterMirrorState newState, float delay)
		{
			yield return new WaitForSeconds(delay);
			SwitchState(newState);
		}

		public void ToggleInteractionActive(bool active)
		{
		}

		public void ToggleActive(bool active)
		{
			if (active)
			{
				m_currentState.Enable();
				m_canvasGroup.DOFade(1f, m_uiFadeInTime).SetDelay(m_uiFadeInDelay);
				if (m_virtualCurrencyChangedEventToken != null)
				{
					EventHub.Unsubscribe<Events.VirtualCurrencyChanged>(m_virtualCurrencyChangedEventToken);
				}
			}
			else
			{
				m_currentState.Disable();
				m_canvasGroup.alpha = 0f;
				m_virtualCurrencyChangedEventToken = EventHub.Subscribe<Events.VirtualCurrencyChanged>(OnCurrencyChanged);
			}
		}
	}
	public class CharacterPortrait : VanityUnlockable, IDragObject
	{
		[Header("Portrait")]
		[SerializeField]
		private CharacterType m_characterType;

		[SerializeField]
		private CharacterMirror m_characterMirror;

		[SerializeField]
		private MeshRenderer[] m_meshRenderers = Array.Empty<MeshRenderer>();

		private Vector3 m_targetPoint;

		private Vector3 m_snapPoint;

		private Quaternion m_targetRotation;

		private Quaternion m_snapRotation;

		private bool m_isMoving;

		private bool m_isRotating;

		private CharacterPortraitStand m_portraitStand;

		protected override bool IsHighlightToggleActive
		{
			[CompilerGenerated]
			get
			{
				return CharacterType != m_characterMirror.CurrentCharacterType || IsBeingDragged;
			}
		}

		public float DragTime { get; private set; }

		public bool IsBeingDragged { get; private set; }

		public bool IsDraggable
		{
			[CompilerGenerated]
			get
			{
				return !base.InteractionLocked;
			}
		}

		public bool IsUnlocked
		{
			[CompilerGenerated]
			get
			{
				return GameControl.Instance.Player.OwnsCharacter(m_characterType);
			}
		}

		public bool IsSnappable
		{
			[CompilerGenerated]
			get
			{
				return IsUnlocked;
			}
		}

		public bool ShouldRaycastToDragPlane
		{
			[CompilerGenerated]
			get
			{
				return false;
			}
		}

		public CharacterType CharacterType
		{
			[CompilerGenerated]
			get
			{
				return m_characterType;
			}
		}

		public event DragBeginDelegate OnDragBegin;

		public event DragEndDelegate OnDragEnd;

		private void OnDisable()
		{
			StopAllCoroutines();
		}

		private void Awake()
		{
			base.StartingPosition = base.transform.position;
			base.StartingRotation = base.transform.rotation;
		}

		protected override void Start()
		{
			foreach (UnlockableRendererMaterialPair meshMaterial in m_meshMaterials)
			{
				meshMaterial.ReplaceMaterial((!IsUnlocked) ? ItemMaterialType.Locked : ItemMaterialType.Default);
				if (CharacterType == m_characterMirror.CurrentCharacterType)
				{
					meshMaterial.SetHighlighted();
				}
			}
		}

		private void Update()
		{
			if (m_isMoving)
			{
				MoveTowardsTarget();
			}
			if (m_isRotating)
			{
				RotateTowardsTarget();
			}
		}

		public void DeselectPortrait()
		{
			AssignMaterial((!IsUnlocked) ? ItemMaterialType.Locked : ItemMaterialType.Default, highlighted: false);
		}

		public override void Unlock(GameObject vfx)
		{
			vfx.GetComponent<PortraitFxHandler>().AssignCorrectPortrait(CharacterType);
			StartCoroutine(PlayUnlockVfx(vfx));
		}

		private IEnumerator PlayUnlockVfx(GameObject vfx)
		{
			Interactable.LockAllInteraction = true;
			Interactable.LockAllLook = true;
			yield return MoveToUnlock(vfx.transform.parent, 1f).WaitForCompletion();
			PunSingleton<SoundManager>.Instance.PlayLocalSoundAtPoint("unlock_effect", 1f, vfx.transform.position, 2);
			vfx.SetActive(value: true);
			SetMeshRenderersActive(active: false);
			yield return new WaitForSeconds(5f);
			AssignMaterial(ItemMaterialType.Default, highlighted: true);
			SetMeshRenderersActive(active: true);
			vfx.SetActive(value: false);
			yield return ReturnToSlot(1f);
			Interactable.LockAllInteraction = false;
			Interactable.LockAllLook = false;
		}

		public override void Interact()
		{
			if (!base.InteractionLocked && CharacterType != m_characterMirror.CurrentCharacterType)
			{
				base.Interact();
				PunSingleton<SoundManager>.Instance.PlayLocalSoundAtPoint("painting_pick", 1f, base.transform.position, 1);
				m_characterMirror.MirrorUI.SwitchCharacter(this);
			}
		}

		public override void LookEnter()
		{
			if (!base.LookLocked)
			{
				base.LookEnter();
				if (!IsBeingDragged)
				{
					Vector3 vector = ((GameControl.Instance.Player.Character != m_characterType) ? base.StartingPosition : m_snapPoint);
					m_targetPoint = vector + (GameControl.Instance.PlayerControl.Input.GetAim().AimRay.origin - vector).normalized * 0.1f;
					m_isMoving = true;
				}
			}
		}

		public override void LookExit()
		{
			if (!base.LookLocked)
			{
				base.LookExit();
				if (!IsBeingDragged)
				{
					m_targetPoint = ((GameControl.Instance.Player.Character != m_characterType) ? base.StartingPosition : m_snapPoint);
					m_isMoving = true;
				}
			}
		}

		public void BeginDrag(Vector3 dragPoint, Vector3 cameraPoint)
		{
			DragTime = 0f;
			if (this.OnDragBegin != null)
			{
				this.OnDragBegin();
			}
			Vector3 euler = Quaternion.LookRotation(dragPoint - cameraPoint).eulerAngles + new Vector3(0f, 180f, 0f);
			euler.x *= -1f;
			MoveAndRotate(dragPoint, Quaternion.Euler(euler));
			m_portraitStand = null;
			IsBeingDragged = true;
			SetHighlighted(highlighted: false);
		}

		public void Drag(Vector3 dragPoint, Vector3 cameraPoint)
		{
			DragTime += Time.deltaTime;
			Vector3 euler = Quaternion.LookRotation(dragPoint - cameraPoint).eulerAngles + new Vector3(0f, 180f, 0f);
			euler.x *= -1f;
			MoveAndRotate(dragPoint, Quaternion.Euler(euler));
			m_portraitStand = null;
		}

		public void EndDrag()
		{
			if (this.OnDragEnd != null)
			{
				this.OnDragEnd();
			}
			SetHighlighted(highlighted: true);
			IsBeingDragged = false;
			if (m_portraitStand != null)
			{
				m_characterMirror.MirrorUI.SwitchCharacter(this);
				m_characterMirror.MirrorUI.EquipSelectedCharacter(CharacterEquipSource.Drag, !GameControl.Instance.Player.Character.Equals(CharacterType));
				return;
			}
			PunSingleton<SoundManager>.Instance.PlayLocalSoundAtPoint("painting_drop", 0.55f, base.transform.position, 1);
			if (GameControl.Instance.Player.Character == m_characterType)
			{
				MoveAndRotate(m_snapPoint, m_snapRotation);
			}
			else
			{
				MoveAndRotate(base.StartingPosition, base.StartingRotation);
			}
		}

		public void SnapToObject(ISnapObject snapObject)
		{
			DragTime += Time.deltaTime;
			if (m_portraitStand == null)
			{
				PunSingleton<SoundManager>.Instance.PlayLocalSoundAtPoint("painting_drop", 0.55f, base.transform.position, 1);
			}
			m_portraitStand = snapObject as CharacterPortraitStand;
			m_snapPoint = snapObject.SnapPoint;
			m_snapRotation = snapObject.SnapRotation;
			MoveAndRotate(snapObject.SnapPoint + m_portraitStand.SnapTransform.forward * 0.1f, snapObject.SnapRotation);
		}

		public void MoveToStartPoint()
		{
			AssignMaterial(ItemMaterialType.Default, highlighted: false);
			MoveAndRotate(base.StartingPosition, base.StartingRotation);
		}

		public void EquipPortrait()
		{
			m_characterMirror.MirrorUI.SwitchCharacter(this);
			m_characterMirror.MirrorUI.EquipSelectedCharacter(CharacterEquipSource.Teleport, playSfx: false);
		}

		private void MoveAndRotate(Vector3 targetPoint, Quaternion targetRotation)
		{
			m_targetPoint = targetPoint;
			m_targetRotation = targetRotation;
			m_isMoving = true;
			m_isRotating = true;
		}

		private void MoveTowardsTarget()
		{
			base.transform.position = Vector3.Lerp(base.transform.position, m_targetPoint, Time.deltaTime * 8f);
			if ((base.transform.position - m_targetPoint).sqrMagnitude < 0.0001f)
			{
				base.transform.position = m_targetPoint;
				m_isMoving = false;
			}
		}

		private void RotateTowardsTarget()
		{
			base.transform.rotation = Quaternion.Lerp(base.transform.rotation, m_targetRotation, Time.deltaTime * 8f);
			if (Quaternion.Angle(base.transform.rotation, m_targetRotation) < 1f)
			{
				base.transform.rotation = m_targetRotation;
				m_isRotating = false;
			}
		}

		private void SetMeshRenderersActive(bool active)
		{
			MeshRenderer[] meshRenderers = m_meshRenderers;
			foreach (MeshRenderer meshRenderer in meshRenderers)
			{
				meshRenderer.enabled = active;
			}
		}
	}
	public class CharacterPortraitStand : MonoBehaviour, ISnapObject, IWorkshopTileListener
	{
		[SerializeField]
		private Transform m_snapTransform;

		private Dictionary<CharacterType, CharacterPortrait> m_portraits;

		private CharacterPortrait[] m_allPortraits;

		public Transform SnapTransform => m_snapTransform;

		public Vector3 SnapPoint => m_snapTransform.position;

		public Quaternion SnapRotation => m_snapTransform.rotation;

		public bool IsSnappable { get; private set; }

		public CharacterPortrait CurrentPortrait { get; set; }

		private void Awake()
		{
			Transform transform = base.transform.parent.RetrieveChild("Portraits");
			m_allPortraits = transform.GetComponentsInChildren<CharacterPortrait>();
			m_portraits = new Dictionary<CharacterType, CharacterPortrait>(m_allPortraits.Length);
			CharacterPortrait[] allPortraits = m_allPortraits;
			foreach (CharacterPortrait characterPortrait in allPortraits)
			{
				if (m_portraits.ContainsKey(characterPortrait.CharacterType))
				{
					WandsLogger.LogError(string.Concat("Multiple portraits of type ", characterPortrait.CharacterType, " found."));
					break;
				}
				m_portraits.Add(characterPortrait.CharacterType, characterPortrait);
			}
		}

		private void Start()
		{
			CharacterPortrait[] allPortraits = m_allPortraits;
			foreach (CharacterPortrait characterPortrait in allPortraits)
			{
				if (GameControl.Instance.Player.Character == characterPortrait.CharacterType)
				{
					SetPortrait(characterPortrait.CharacterType);
					characterPortrait.EndDrag();
				}
			}
		}

		public void SetPortrait(CharacterType characterType)
		{
			CurrentPortrait?.MoveToStartPoint();
			CurrentPortrait = m_portraits[characterType];
			CurrentPortrait.SnapToObject(this);
			CurrentPortrait.AssignMaterial(ItemMaterialType.Default, highlighted: true);
		}

		public void ToggleInteractionActive(bool active)
		{
		}

		public void ToggleActive(bool active)
		{
			IsSnappable = active;
			CharacterType character = GameControl.Instance.Player.Character;
			CharacterPortrait[] allPortraits = m_allPortraits;
			foreach (CharacterPortrait characterPortrait in allPortraits)
			{
				characterPortrait.InteractionLocked = !active;
				characterPortrait.LookLocked = !active;
				if (active && character == characterPortrait.CharacterType)
				{
					SetPortrait(characterPortrait.CharacterType);
					characterPortrait.EquipPortrait();
				}
			}
		}
	}
}
namespace Assets.Scripts.UI.Workshop.CharacterSelection.MirrorStates
{
	public class MirrorState
	{
		protected CharacterMirrorUI m_characterMirrorUI;

		protected TMP_Text m_currency;

		protected TMP_Text m_selectedCharacter;

		public MirrorState(CharacterMirrorUI mirrorUI, TMP_Text currency, TMP_Text selectedOutfit)
		{
			m_characterMirrorUI = mirrorUI;
			m_currency = currency;
			m_selectedCharacter = selectedOutfit;
		}

		public virtual void Enable()
		{
			EnableCurrency();
			EnableSelectedCharacter();
		}

		public virtual void Disable()
		{
			m_currency.gameObject.SetActive(value: false);
			m_selectedCharacter.gameObject.SetActive(value: false);
		}

		protected void EnableCurrency()
		{
			m_currency.text = GameControl.Instance.Player.SaveData.VirtualCurrency.ToString();
			m_currency.gameObject.SetActive(value: true);
		}

		protected void EnableSelectedCharacter()
		{
			CatalogItemWrapper character = WandsDatabase.GetCharacter(m_characterMirrorUI.CharacterMirror.CurrentCharacterType);
			m_selectedCharacter.text = ScriptLocalization.Get(character.DisplayName);
			m_selectedCharacter.gameObject.SetActive(value: true);
		}
	}
	public class MirrorStateBuy : MirrorState
	{
		private TMP_Text m_cost;

		private CharacterMirrorBuyButton m_buyButton;

		public MirrorStateBuy(CharacterMirrorUI mirrorUI, TMP_Text currency, TMP_Text selectedOutfit, TMP_Text cost, CharacterMirrorBuyButton buyButton)
			: base(mirrorUI, currency, selectedOutfit)
		{
			m_cost = cost;
			m_buyButton = buyButton;
		}

		public override void Enable()
		{
			base.Enable();
			m_cost.gameObject.SetActive(value: true);
			CatalogItemWrapper character = WandsDatabase.GetCharacter(m_characterMirrorUI.CharacterMirror.CurrentCharacterType);
			m_cost.text = character.DustPrice.ToString();
			m_buyButton.gameObject.SetActive(value: true);
		}

		public override void Disable()
		{
			base.Disable();
			m_cost.gameObject.SetActive(value: false);
			m_buyButton.gameObject.SetActive(value: false);
		}
	}
	public class MirrorStateBuying : MirrorState
	{
		private TMP_Text m_outfitUnlocked;

		public MirrorStateBuying(CharacterMirrorUI mirrorUI, TMP_Text currency, TMP_Text selectedOutfit, TMP_Text outfitUnlocked)
			: base(mirrorUI, currency, selectedOutfit)
		{
			m_outfitUnlocked = outfitUnlocked;
		}

		public override void Enable()
		{
			m_outfitUnlocked.gameObject.SetActive(value: true);
			m_outfitUnlocked.alpha = 0f;
			m_characterMirrorUI.UnlockPortrait();
			m_outfitUnlocked.DOFade(1f, 0.4f).SetDelay(5f).OnComplete(delegate
			{
				m_outfitUnlocked.DOFade(0f, 0.4f).SetDelay(1f);
			});
			m_characterMirrorUI.SwitchStateAfterDelay(CharacterMirrorState.Equip, 6.5f);
			DOTween.To(SetCurrency, int.Parse(m_currency.text), GameControl.Instance.Player.SaveData.VirtualCurrency, 1.5f).SetEase(Ease.Linear).SetDelay(5f);
			CatalogItemWrapper character = WandsDatabase.GetCharacter(m_characterMirrorUI.CharacterMirror.CurrentCharacterType);
			m_selectedCharacter.text = ScriptLocalization.Get(character.DisplayName);
			m_selectedCharacter.gameObject.SetActive(value: true);
			m_currency.gameObject.SetActive(value: true);
		}

		private void SetCurrency(float f)
		{
			m_currency.text = Mathf.FloorToInt(f).ToString();
		}

		public override void Disable()
		{
			base.Disable();
			m_characterMirrorUI.StopDelayedStateSwitch();
			m_outfitUnlocked.DOKill();
			m_outfitUnlocked.gameObject.SetActive(value: false);
		}
	}
	public class MirrorStateEquip : MirrorState
	{
		private CharacterMirrorEquipButton m_equipButton;

		public MirrorStateEquip(CharacterMirrorUI mirrorUI, TMP_Text currency, TMP_Text selectedOutfit, CharacterMirrorEquipButton equipButton)
			: base(mirrorUI, currency, selectedOutfit)
		{
			m_equipButton = equipButton;
		}

		public override void Enable()
		{
			base.Enable();
			m_equipButton.gameObject.SetActive(value: true);
		}

		public override void Disable()
		{
			base.Disable();
			m_equipButton.gameObject.SetActive(value: false);
		}
	}
	public class MirrorStateEquipped : MirrorState
	{
		private TMP_Text m_equipped;

		public MirrorStateEquipped(CharacterMirrorUI mirrorUI, TMP_Text currency, TMP_Text selectedOutfit, TMP_Text equipped)
			: base(mirrorUI, currency, selectedOutfit)
		{
			m_equipped = equipped;
		}

		public override void Enable()
		{
			base.Enable();
			m_equipped.gameObject.SetActive(value: true);
		}

		public override void Disable()
		{
			base.Disable();
			m_equipped.gameObject.SetActive(value: false);
		}
	}
	public class MirrorStateSpecial : MirrorState
	{
		private TMP_Text m_cost;

		private TMP_Text m_eventPrize;

		public MirrorStateSpecial(CharacterMirrorUI mirrorUI, TMP_Text currency, TMP_Text selectedOutfit, TMP_Text cost, TMP_Text eventPrize)
			: base(mirrorUI, currency, selectedOutfit)
		{
			m_cost = cost;
			m_eventPrize = eventPrize;
		}

		public override void Enable()
		{
			m_currency.transform.parent.gameObject.SetActive(value: false);
			EnableSelectedCharacter();
			m_eventPrize.gameObject.SetActive(value: true);
		}

		public override void Disable()
		{
			base.Disable();
			m_currency.transform.parent.gameObject.SetActive(value: true);
			m_cost.gameObject.SetActive(value: false);
			m_eventPrize.gameObject.SetActive(value: false);
		}
	}
}
namespace Assets.Scripts.UI.Workshop.CharacterSelection
{
	public class PortraitFxHandler : MonoBehaviour
	{
		[SerializeField]
		private Renderer m_paintingRenderer;

		[SerializeField]
		private Renderer m_lockedPaintingRenderer;

		public void AssignCorrectPortrait(CharacterType characterType)
		{
			string text = $"portrait_{characterType}".ToLower();
			string assetName = $"{text}_Locked";
			m_paintingRenderer.material = GameControl.Instance.AssetHandler.LoadAsset<Material>(AssetBundleType.Vanity, text);
			m_lockedPaintingRenderer.material = GameControl.Instance.AssetHandler.LoadAsset<Material>(AssetBundleType.Vanity, assetName);
		}
	}
}
namespace Assets.Scripts.UI.Workshop
{
	public class GameBlackboard : Blackboard
	{
		[Header("Leaderboards")]
		[SerializeField]
		private GameObject[] m_userLockedDisplays;

		[SerializeField]
		private GameObject[] m_holders;

		[SerializeField]
		private Transform[] m_lineParents;

		[SerializeField]
		private GameObject[] m_enableOnSeasonLock;

		[SerializeField]
		private GameObject[] m_disableOnSeasonLock;

		[SerializeField]
		private GameObject[] m_enableOnSeasonLockIfHasRating;

		[SerializeField]
		private Localize[] m_globalLeaderboards;

		[SerializeField]
		private Renderer[] m_userLeaderboards;

		private List<TextMeshPro[]> m_global = new List<TextMeshPro[]>(10);

		private List<TextMeshPro[]> m_user = new List<TextMeshPro[]>(10);

		private List<TextMeshPro[]> m_globalPlayStation = new List<TextMeshPro[]>(10);

		private List<TextMeshPro[]> m_userPlayStation = new List<TextMeshPro[]>(10);

		private EventToken m_sceneLoadedEventToken;

		private EventToken m_leaderboardLoadedEventToken;

		private EventToken m_internetDisconnectedEventToken;

		private Interactable[] m_childInteractables;

		private Action m_internetDisconnectedAction;

		public BlackboardState CurrentState { get; private set; }

		private Interactable[] ChildInteractables
		{
			get
			{
				if (m_childInteractables.IsNullOrEmpty())
				{
					m_childInteractables = m_blackboardMenus.Where((BlackboardMenu b) => b.BlackboardState == BlackboardState.Leaderboards).SelectMany((BlackboardMenu b) => b.GameObject.GetComponentsInChildren<Interactable>()).ToArray();
				}
				return m_childInteractables;
			}
		}

		private void Start()
		{
			ToggleBlackboard(BlackboardState.News);
		}

		private void OnEnable()
		{
			m_sceneLoadedEventToken = EventHub.Subscribe<Events.SceneLoadedEvent>(OnSceneLoaded);
			m_leaderboardLoadedEventToken = EventHub.Subscribe<Events.LeadboardLoadedEvent>(OnLeaderboardLoaded);
			m_internetDisconnectedEventToken = EventHub.Subscribe<Events.InternetConnectionNotAvailableEvent>(OnInternetDisconnectedEvent);
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe<Events.SceneLoadedEvent>(m_sceneLoadedEventToken);
			EventHub.Unsubscribe<Events.LeadboardLoadedEvent>(m_leaderboardLoadedEventToken);
			EventHub.Unsubscribe<Events.InternetConnectionNotAvailableEvent>(m_internetDisconnectedEventToken);
		}

		private void OnLeaderboardLoaded(Events.LeadboardLoadedEvent eventData)
		{
			LeaderboardLoaded(eventData.LeaderboardType);
		}

		private void LeaderboardLoaded(LeaderboardType leaderboardType)
		{
			List<Assets.Scripts.Platform.LeaderboardEntry> list = GameControl.Instance.Leaderboards.Entries[leaderboardType];
			if (!list.IsNullOrEmpty())
			{
				WriteToBoard(leaderboardType, list);
			}
		}

		private void OnSceneLoaded(Events.SceneLoadedEvent eventData)
		{
			SceneLoaded(eventData.Scene, eventData.LoadSceneMode);
		}

		private void SceneLoaded(Scene scene, LoadSceneMode loadMode)
		{
			RetrieveTextComponents();
			ClearLeaderboards();
			if (GameControl.Instance.Leaderboards.Entries == null)
			{
				return;
			}
			foreach (LeaderboardType key in GameControl.Instance.Leaderboards.Entries.Keys)
			{
				LeaderboardLoaded(key);
			}
		}

		private void OnInternetDisconnectedEvent(Events.InternetConnectionNotAvailableEvent eventData)
		{
			if (m_internetDisconnectedAction != null)
			{
				m_internetDisconnectedAction();
				m_internetDisconnectedAction = null;
			}
		}

		public override void ToggleBlackboard(BlackboardState newState)
		{
			base.ToggleBlackboard(newState);
			if (newState == BlackboardState.Leaderboards)
			{
				WriteToBoard(LeaderboardType.RatingUser, null);
				m_internetDisconnectedAction = delegate
				{
					EventHub.Publish(new Events.InternetRequiredButNotAvailableEvent());
					ToggleBlackboard(BlackboardState.News);
				};
			}
			if (newState != BlackboardState.Leaderboards && m_internetDisconnectedAction != null)
			{
				m_internetDisconnectedAction = null;
			}
		}

		private void RetrieveTextComponents()
		{
			if (m_global.Count != 0 && m_user.Count != 0)
			{
				return;
			}
			for (int i = 0; i < m_holders.Length; i++)
			{
				TextMeshPro[] componentsInChildren = m_holders[i].GetComponentsInChildren<TextMeshPro>();
				for (int j = 0; j < 10; j++)
				{
					TextMeshPro textMeshPro = componentsInChildren[j + j];
					TextMeshPro textMeshPro2 = componentsInChildren[j + 1 + j];
					switch (i)
					{
					case 0:
						m_global.Add(new TextMeshPro[2] { textMeshPro, textMeshPro2 });
						break;
					case 1:
						m_user.Add(new TextMeshPro[2] { textMeshPro, textMeshPro2 });
						break;
					case 2:
						m_globalPlayStation.Add(new TextMeshPro[2] { textMeshPro, textMeshPro2 });
						break;
					case 3:
						m_userPlayStation.Add(new TextMeshPro[2] { textMeshPro, textMeshPro2 });
						break;
					}
				}
			}
		}

		private void WriteToBoard(LeaderboardType leaderboardType, List<Assets.Scripts.Platform.LeaderboardEntry> entries)
		{
			if (SeasonControl.SeasonLocked)
			{
				Localize[] globalLeaderboards = m_globalLeaderboards;
				foreach (Localize localize in globalLeaderboards)
				{
					localize.SetTerm("Workshop/Blackboard/SeasonWinners");
				}
				Renderer[] userLeaderboards = m_userLeaderboards;
				foreach (Renderer renderer in userLeaderboards)
				{
					renderer.enabled = false;
				}
				GameObject[] enableOnSeasonLock = m_enableOnSeasonLock;
				foreach (GameObject gameObject in enableOnSeasonLock)
				{
					gameObject.SetActive(value: true);
				}
				GameObject[] disableOnSeasonLock = m_disableOnSeasonLock;
				foreach (GameObject gameObject2 in disableOnSeasonLock)
				{
					gameObject2.SetActive(value: false);
				}
				if (GameControl.Instance.Player.HasUnlockedRating)
				{
					GameObject[] enableOnSeasonLockIfHasRating = m_enableOnSeasonLockIfHasRating;
					foreach (GameObject gameObject3 in enableOnSeasonLockIfHasRating)
					{
						gameObject3.SetActive(value: true);
					}
				}
				if (leaderboardType == LeaderboardType.RatingUser || leaderboardType == LeaderboardType.RatingPlayStationUser)
				{
					return;
				}
			}
			if (entries == null || entries.Count == 0)
			{
				return;
			}
			List<TextMeshPro[]> tempList = null;
			switch (leaderboardType)
			{
			case LeaderboardType.RatingGlobal:
				tempList = m_global;
				break;
			case LeaderboardType.RatingUser:
				if (GameControl.Instance.Player.HasUnlockedRating)
				{
					tempList = m_user;
					GameObject[] userLockedDisplays3 = m_userLockedDisplays;
					foreach (GameObject gameObject6 in userLockedDisplays3)
					{
						gameObject6.gameObject.SetActive(value: false);
					}
				}
				else if (!SeasonControl.SeasonLocked)
				{
					GameObject[] userLockedDisplays4 = m_userLockedDisplays;
					foreach (GameObject gameObject7 in userLockedDisplays4)
					{
						gameObject7.gameObject.SetActive(value: true);
					}
					return;
				}
				break;
			case LeaderboardType.RatingPlayStationGlobal:
				tempList = m_globalPlayStation;
				break;
			case LeaderboardType.RatingPlayStationUser:
				if (GameControl.Instance.Player.HasUnlockedRating)
				{
					tempList = m_userPlayStation;
					GameObject[] userLockedDisplays = m_userLockedDisplays;
					foreach (GameObject gameObject4 in userLockedDisplays)
					{
						gameObject4.gameObject.SetActive(value: false);
					}
				}
				else if (!SeasonControl.SeasonLocked)
				{
					GameObject[] userLockedDisplays2 = m_userLockedDisplays;
					foreach (GameObject gameObject5 in userLockedDisplays2)
					{
						gameObject5.gameObject.SetActive(value: true);
					}
					return;
				}
				break;
			}
			if (tempList.IsNullOrEmpty())
			{
				return;
			}
			bool flag = leaderboardType != LeaderboardType.RatingPlayStationGlobal && leaderboardType != LeaderboardType.RatingPlayStationUser;
			m_lineParents[(int)leaderboardType].gameObject.SetActive(value: false);
			for (int num4 = 0; num4 < entries.Count; num4++)
			{
				TextMeshPro[] array = tempList[num4];
				if (array != null && array.Length != 0)
				{
					TextMeshPro textMeshPro = tempList[num4][0];
					string text = entries[num4].Name;
					int score = entries[num4].Score;
					int rank = entries[num4].Rank;
					bool flag2 = score > 0;
					if (text == GameControl.Instance.Platform.AccountID && rank == GameControl.Instance.Player.Rank)
					{
						m_lineParents[(int)leaderboardType].localPosition = textMeshPro.transform.parent.localPosition;
						m_lineParents[(int)leaderboardType].gameObject.SetActive(value: true);
						flag2 = GameControl.Instance.Player.HasUnlockedRating;
					}
					tempList[num4][1].text = ((!flag2) ? string.Empty : score.ToString());
					tempList[num4][1].transform.GetChild(0).gameObject.SetActive(!flag2);
					if (!flag)
					{
						string text2 = ((string.IsNullOrEmpty(text) || rank < 0) ? string.Empty : $"{rank}. {text}");
						textMeshPro.text = text2;
					}
				}
			}
			if (!flag)
			{
				return;
			}
			string[] array2 = new string[entries.Count];
			for (int num5 = 0; num5 < entries.Count; num5++)
			{
				string text3 = entries[num5].Name;
				array2[num5] = text3;
			}
			GameControl.Instance.Platform.FilterStrings(array2, delegate(string[] response)
			{
				for (int num6 = 0; num6 < entries.Count; num6++)
				{
					string text4 = response[num6];
					int rank2 = entries[num6].Rank;
					string text5 = ((string.IsNullOrEmpty(text4) || rank2 < 0) ? string.Empty : $"{rank2}. {text4}");
					tempList[num6][0].text = text5;
				}
			});
		}

		private void ClearLeaderboards()
		{
			for (int i = 0; i < m_global.Count; i++)
			{
				for (int j = 0; j < m_global[i].Length; j++)
				{
					m_global[i][j].text = string.Empty;
					if (j == 1)
					{
						m_global[i][j].transform.GetChild(0).gameObject.SetActive(value: false);
					}
				}
			}
			for (int k = 0; k < m_user.Count; k++)
			{
				for (int l = 0; l < m_user[k].Length; l++)
				{
					m_user[k][l].text = string.Empty;
					if (l == 1)
					{
						m_user[k][l].transform.GetChild(0).gameObject.SetActive(value: false);
					}
				}
			}
			for (int m = 0; m < m_globalPlayStation.Count; m++)
			{
				for (int n = 0; n < m_globalPlayStation[m].Length; n++)
				{
					m_globalPlayStation[m][n].text = string.Empty;
					if (n == 1)
					{
						m_globalPlayStation[m][n].transform.GetChild(0).gameObject.SetActive(value: false);
					}
				}
			}
			for (int num = 0; num < m_userPlayStation.Count; num++)
			{
				for (int num2 = 0; num2 < m_userPlayStation[num].Length; num2++)
				{
					m_userPlayStation[num][num2].text = string.Empty;
					if (num2 == 1)
					{
						m_userPlayStation[num][num2].transform.GetChild(0).gameObject.SetActive(value: false);
					}
				}
			}
			Transform[] lineParents = m_lineParents;
			foreach (Transform transform in lineParents)
			{
				transform.gameObject.SetActive(value: false);
			}
		}

		public override void ToggleInteractionActive(bool active)
		{
			base.ToggleInteractionActive(active);
			Interactable[] childInteractables = ChildInteractables;
			foreach (Interactable interactable in childInteractables)
			{
				interactable.LockInteraction(!active);
				interactable.LockLook(!active);
			}
		}

		public override void ToggleActive(bool active)
		{
			base.ToggleActive(active);
			if (active)
			{
				ToggleBlackboard(BlackboardState.News);
			}
			else
			{
				ToggleBlackboard(BlackboardState.Profile);
			}
		}
	}
	[RequireComponent(typeof(Image))]
	public class ImageColorPulser : MonoBehaviour
	{
		[SerializeField]
		private Color m_color1 = Color.white;

		[SerializeField]
		private Color m_color2 = Color.white;

		[SerializeField]
		private float m_fadeTime = 1f;

		[SerializeField]
		private Image m_image;

		[SerializeField]
		private float m_normalizedFadeTime;

		private float m_currentTime;

		private void Update()
		{
			m_currentTime += Time.deltaTime;
			m_image.color = Color.Lerp(m_color1, m_color2, m_normalizedFadeTime * Mathf.PingPong(m_currentTime, m_fadeTime));
		}
	}
	public class InfoBlackboard : Blackboard
	{
		[SerializeField]
		private Renderer m_blackboard;

		[SerializeField]
		private Texture[] m_textures;

		private EventToken m_purchasedFullGameEventToken;

		private Interactable[] m_childInteractables;

		private Interactable[] ChildInteractables
		{
			get
			{
				if (m_childInteractables.IsNullOrEmpty())
				{
					m_childInteractables = m_blackboardMenus.Where((BlackboardMenu b) => b.BlackboardState == BlackboardState.Options || b.BlackboardState == BlackboardState.Titles).SelectMany((BlackboardMenu b) => b.GameObject.GetComponentsInChildren<Interactable>()).ToArray();
				}
				return m_childInteractables;
			}
		}

		private void Start()
		{
			ToggleBlackboard(BlackboardState.Profile);
		}

		private void OnEnable()
		{
			m_purchasedFullGameEventToken = EventHub.Subscribe<Events.PurchasedFullGameEvent>(OnPurchasedFullGame);
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe<Events.PurchasedFullGameEvent>(m_purchasedFullGameEventToken);
		}

		private void OnPurchasedFullGame(Events.PurchasedFullGameEvent eventData)
		{
			ToggleBlackboard(BlackboardState.Tutorial);
		}

		private void ChangeTexture(int textureIndex)
		{
			if (!(m_blackboard == null) && m_textures != null)
			{
				if (textureIndex < 0 || textureIndex >= m_textures.Length)
				{
					throw new IndexOutOfRangeException($"Blackboard | Trying to change texture to index {textureIndex} but it is out of range.");
				}
				m_blackboard.material.mainTexture = m_textures[textureIndex];
			}
		}

		public override void ToggleInteractionActive(bool active)
		{
			base.ToggleInteractionActive(active);
			Interactable[] childInteractables = ChildInteractables;
			foreach (Interactable interactable in childInteractables)
			{
				interactable.LockInteraction(!active);
				interactable.LockLook(!active);
			}
		}

		public override void ToggleActive(bool active)
		{
			base.ToggleActive(active);
			if (active)
			{
				ToggleBlackboard(BlackboardState.Profile);
			}
			else
			{
				ToggleBlackboard(BlackboardState.Leaderboards);
			}
		}
	}
	public class LeaderboardBlackboardButton : BlackboardButton
	{
		private ButtonTextColorPulser m_colorPulser;

		protected override void Awake()
		{
			base.Awake();
			m_colorPulser = GetComponentInChildren<ButtonTextColorPulser>();
			if (CustomEventFetcher.Instance != null)
			{
				CustomEventFetcher.Instance.FetchActiveAndUpcomingEvents(OnActiveAndUpcomingEventsFetched);
			}
		}

		public override void LookEnter()
		{
			if (!base.LookLocked)
			{
				base.LookEnter();
				m_colorPulser.PausePulse();
			}
		}

		public override void LookExit()
		{
			if (!base.LookLocked)
			{
				base.LookExit();
				if (m_colorPulser.IsPaused)
				{
					m_colorPulser.StartPulse();
				}
			}
		}

		public override void Interact()
		{
			m_colorPulser.StopPulse();
			base.Interact();
		}

		private void OnActiveAndUpcomingEventsFetched(List<CustomEvent> events)
		{
			foreach (CustomEvent @event in events)
			{
				if (!WandsSave.GetBoolPref("e" + @event.Id))
				{
					m_colorPulser.StartPulse();
					break;
				}
			}
		}
	}
}
namespace Scripts.UI.Workshop
{
	public class LeaderboardBlackboardTabController : MonoBehaviour
	{
		[SerializeField]
		private RectTransform[] m_tabs = Array.Empty<RectTransform>();

		[SerializeField]
		private BoxCollider[] m_colliders = Array.Empty<BoxCollider>();

		[SerializeField]
		private Transform[] m_verticalLines = Array.Empty<Transform>();

		[SerializeField]
		private float m_totalWidth = 2.28f;

		[SerializeField]
		private float m_leftZPosition = -0.62f;

		[SerializeField]
		private Transform m_rewardMarker;

		[SerializeField]
		private float m_rewardMarkerPositionZ = 1.5f;

		private void Start()
		{
			int num = m_tabs.Length;
			if (GameControl.Instance.Platform.Type != PlatformType.PlayStation)
			{
				RectTransform rectTransform = m_rewardMarker as RectTransform;
				rectTransform.anchoredPosition3D = new Vector3(rectTransform.anchoredPosition3D.x, rectTransform.anchoredPosition3D.y, m_rewardMarkerPositionZ);
				m_verticalLines[m_verticalLines.Length - 1].gameObject.SetActive(value: false);
				m_tabs[m_tabs.Length - 1].gameObject.SetActive(value: false);
				num--;
			}
			float num2 = m_totalWidth / (float)num;
			for (int i = 0; i < num; i++)
			{
				m_tabs[i].SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal, num2);
				Vector3 localPosition = m_tabs[i].localPosition;
				localPosition.z = m_leftZPosition + (float)i * num2;
				m_tabs[i].localPosition = localPosition;
				BoxCollider boxCollider = m_colliders[i];
				Vector3 size = boxCollider.size;
				size.x = num2;
				boxCollider.size = size;
				Vector3 center = boxCollider.center;
				center.x = size.x / 2f;
				boxCollider.center = center;
				if (i < m_verticalLines.Length)
				{
					localPosition = m_verticalLines[i].localPosition;
					localPosition.z = m_leftZPosition + (float)(i + 1) * num2;
					m_verticalLines[i].localPosition = localPosition;
				}
			}
		}
	}
}
namespace Assets.Scripts.UI.Workshop.Mirus
{
	public class FriendlyMatchMirusButton : MirusButton
	{
		[SerializeField]
		private TMP_Text m_playerName;

		[SerializeField]
		private TMP_Text m_matchInfo;

		private RoomInfo m_roomInfo;

		public override bool ShouldBeEnabled => base.gameObject.activeSelf;

		protected override void OnEnable()
		{
			base.OnEnable();
			m_interactable.OnInteract += OnInteract;
		}

		protected override void OnDisable()
		{
			base.OnDisable();
			m_interactable.OnInteract -= OnInteract;
		}

		public void SetFriendlyMatchInfo(RoomInfo info, string filteredRoomName)
		{
			m_roomInfo = info;
			PlatformType platformType = (PlatformType)info.CustomProperties["A1"];
			string text = filteredRoomName ?? ((string)info.CustomProperties["P1"]).Split('/')[0];
			string text2 = (string)info.CustomProperties["A2"];
			m_playerName.text = text;
			m_matchInfo.text = string.Format("{0}", ScriptLocalization.Get("Levels/" + text2));
		}

		private void OnInteract()
		{
			string value = (string)m_roomInfo.CustomProperties["A2"];
			Arena arena = (Arena)Enum.Parse(typeof(Arena), value);
			Events.ConnectToMatch connectToMatch = new Events.ConnectToMatch();
			connectToMatch.RoomName = m_roomInfo.Name;
			connectToMatch.JoinState = JoinState.Join;
			connectToMatch.Arena = arena;
			connectToMatch.MatchType = (MatchType)(int)m_roomInfo.CustomProperties["C3"];
			EventHub.Publish(connectToMatch);
		}

		protected override void OnLookEnter()
		{
			base.OnLookEnter();
			m_playerName.color = Color.white;
			m_matchInfo.color = Color.white;
		}

		protected override void OnLookExit()
		{
			base.OnLookExit();
			m_playerName.color = base.DefaultTextColour;
			m_matchInfo.color = base.DefaultTextColour;
		}
	}
	public class Mirus : MonoBehaviour, IWorkshopTileListener
	{
		[Serializable]
		private class MirusStateButtons
		{
			public MirusState State;

			public string TitleTerm;

			public MirusButton[] Buttons;
		}

		[SerializeField]
		private MirusStateButtons[] m_mirusStateButtons;

		[SerializeField]
		private InteractableButton m_returnButton;

		[SerializeField]
		private InteractableButton m_scrollLeftButton;

		[SerializeField]
		private InteractableButton m_scrollRightButton;

		[SerializeField]
		private Localize m_title;

		[SerializeField]
		private Localize m_message;

		[SerializeField]
		private LocalizationParamsManager m_messageParams;

		[SerializeField]
		private ButtonSorter m_buttonSorter;

		[SerializeField]
		private WorkshopManager m_workshopManager;

		[SerializeField]
		private SeasonStatsFetcher m_seasonStats;

		private MirusStateButtons m_currentMirusStateButtons;

		private Dictionary<MirusState, MirusStateButtons> m_mirusStateButtonsLookup;

		private Stack<MirusStateButtons> m_previousStateButtons = new Stack<MirusStateButtons>(4);

		private List<RoomInfo> m_friendlyMatchInfos = new List<RoomInfo>(4);

		private int m_friendlyMatchPage;

		private readonly Dictionary<int, string> m_roomFilteredNames = new Dictionary<int, string>(4);

		private const float FadeInDuration = 1f;

		private const float FadeInDelay = 1f;

		private const float DefaultMessageDisplayTime = 5f;

		private const string NoInternetConnectionTerm = "NoInternetConnection";

		private const string ConnectionFailedTerm = "ConnectionFailed";

		private const string UpdateMatchesTerm = "UpdateMatches";

		private const string ConnectingTerm = "Connecting";

		private const string ConnectingInternetTerm = "ConnectingInternet";

		private const string UpdateMatchesFailTerm = "UpdateMatchesFail";

		private const string SelectionWarningTerm = "SelectionWarning2";

		private const string TermCategory = "Workshop/Mirus/Error";

		private EventToken m_connectToMatchEventToken;

		private EventToken m_friendlyMatchesUpdatedEventToken;

		private EventToken m_connectToMatchRoomFailedEventToken;

		private EventToken m_connectToMatchLobbyFailedEventToken;

		private EventToken m_triedStartingWithoutCompleteLoadoutEventToken;

		private EventToken m_portalLeverInteractedWithEventToken;

		private EventToken m_portalLeverRotatedEventToken;

		private EventToken m_photonConnectionFailedEventToken;

		private EventToken m_internetConnectedEventToken;

		private Action m_onInternetConnectedAction;

		private Action<Interactable> m_standardButtonsOnLookEnter;

		private Action<Interactable> m_standardButtonsOnInteract;

		private void OnEnable()
		{
			m_internetConnectedEventToken = EventHub.Subscribe<Events.InternetConnectionVerifiedEvent>(OnInternetConnectionVerifiedEvent);
			m_connectToMatchEventToken = EventHub.Subscribe<Events.ConnectToMatch>(OnConnectToMatch);
			m_friendlyMatchesUpdatedEventToken = EventHub.Subscribe<Events.FriendlyMatchesUpdatedEvent>(OnFriendlyMatchesUpdated);
			m_connectToMatchRoomFailedEventToken = EventHub.Subscribe<Events.ConnectToMatchRoomFailed>(OnConnectToMatchRoomFailed);
			m_connectToMatchLobbyFailedEventToken = EventHub.Subscribe<Events.ConnectToMatchLobbyFailed>(OnConnectToMatchLobbyFailed);
			m_triedStartingWithoutCompleteLoadoutEventToken = EventHub.Subscribe<Events.TriedStartingWithoutCompleteLoadoutEvent>(OnTriedStartingWithoutCompleteLoadout);
			m_portalLeverInteractedWithEventToken = EventHub.Subscribe<Events.PortalLeverInteractedWithEvent>(OnPortalLeverInteractedWithEvent);
			m_portalLeverRotatedEventToken = EventHub.Subscribe<Events.PortalLeverRotatedEvent>(OnPortalLeverRotated);
			m_photonConnectionFailedEventToken = EventHub.Subscribe<NetworkEvents.PhotonConnectionFailedEvent>(OnPhotonConnectionFailed);
			m_standardButtonsOnLookEnter = delegate
			{
				PunSingleton<SoundManager>.Instance.PlayLocalSound("portal_ui_button_hover", 1f, 1);
			};
			m_standardButtonsOnInteract = delegate
			{
				PunSingleton<SoundManager>.Instance.PlayLocalSound("portal_ui_button_press", 1f, 1);
			};
			m_returnButton.OnLookEnterListeners.Add(m_standardButtonsOnLookEnter);
			m_scrollLeftButton.OnLookEnterListeners.Add(m_standardButtonsOnLookEnter);
			m_scrollRightButton.OnLookEnterListeners.Add(m_standardButtonsOnLookEnter);
			m_returnButton.OnInteractListeners.Add(m_standardButtonsOnInteract);
			m_scrollLeftButton.OnInteractListeners.Add(m_standardButtonsOnInteract);
			m_scrollRightButton.OnInteractListeners.Add(m_standardButtonsOnInteract);
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe<Events.InternetConnectionVerifiedEvent>(m_internetConnectedEventToken);
			EventHub.Unsubscribe<Events.ConnectToMatch>(m_connectToMatchEventToken);
			EventHub.Unsubscribe<Events.FriendlyMatchesUpdatedEvent>(m_friendlyMatchesUpdatedEventToken);
			EventHub.Unsubscribe<Events.ConnectToMatchRoomFailed>(m_connectToMatchRoomFailedEventToken);
			EventHub.Unsubscribe<Events.ConnectToMatchLobbyFailed>(m_connectToMatchLobbyFailedEventToken);
			EventHub.Unsubscribe<Events.TriedStartingWithoutCompleteLoadoutEvent>(m_triedStartingWithoutCompleteLoadoutEventToken);
			EventHub.Unsubscribe<Events.PortalLeverInteractedWithEvent>(m_portalLeverInteractedWithEventToken);
			EventHub.Unsubscribe<Events.PortalLeverRotatedEvent>(m_portalLeverRotatedEventToken);
			EventHub.Unsubscribe<NetworkEvents.PhotonConnectionFailedEvent>(m_photonConnectionFailedEventToken);
			m_returnButton.OnLookEnterListeners.Remove(m_standardButtonsOnLookEnter);
			m_scrollLeftButton.OnLookEnterListeners.Remove(m_standardButtonsOnLookEnter);
			m_scrollRightButton.OnLookEnterListeners.Remove(m_standardButtonsOnLookEnter);
			m_returnButton.OnInteractListeners.Remove(m_standardButtonsOnInteract);
			m_scrollLeftButton.OnInteractListeners.Remove(m_standardButtonsOnInteract);
			m_scrollRightButton.OnInteractListeners.Remove(m_standardButtonsOnInteract);
		}

		private void Start()
		{
			MirusStateButtons[] mirusStateButtons = m_mirusStateButtons;
			foreach (MirusStateButtons mirusStateButtons2 in mirusStateButtons)
			{
				MirusButton[] buttons = mirusStateButtons2.Buttons;
				foreach (MirusButton mirusButton in buttons)
				{
					mirusButton.gameObject.SetActive(value: false);
				}
			}
			m_mirusStateButtonsLookup = m_mirusStateButtons.ToDictionary((MirusStateButtons m) => m.State, (MirusStateButtons m) => m);
			m_message.gameObject.SetActive(value: false);
			m_title.gameObject.SetActive(value: false);
			SetBackButtonEnabled(enabled: false);
			m_scrollLeftButton.gameObject.SetActive(value: false);
			m_scrollRightButton.gameObject.SetActive(value: false);
		}

		public void ToggleInteractionActive(bool active)
		{
			if (m_currentMirusStateButtons == null)
			{
				return;
			}
			MirusStateButtons[] mirusStateButtons = m_mirusStateButtons;
			foreach (MirusStateButtons mirusStateButtons2 in mirusStateButtons)
			{
				MirusButton[] buttons = mirusStateButtons2.Buttons;
				foreach (MirusButton mirusButton in buttons)
				{
					mirusButton.LockInteractable(!active);
				}
			}
			m_returnButton.LockLook(!active);
			m_returnButton.LockInteraction(!active);
			m_scrollLeftButton.LockLook(!active);
			m_scrollLeftButton.LockInteraction(!active);
			m_scrollRightButton.LockLook(!active);
			m_scrollRightButton.LockInteraction(!active);
		}

		public void ToggleActive(bool active)
		{
		}

		public void ChangeState(MirusState mirusState)
		{
			m_previousStateButtons.Push(m_currentMirusStateButtons);
			ChangeStateInternal(mirusState);
		}

		public void ReceiverBack()
		{
			if (TryDisplayInternetConnectionError())
			{
				return;
			}
			if (m_previousStateButtons.Count <= 0)
			{
				WandsLogger.LogError("Tried to go back when there was nothing in PreviousStack.");
				return;
			}
			MirusStateButtons mirusStateButtons = m_previousStateButtons.Pop();
			ChangeStateInternal(mirusStateButtons.State);
			if (mirusStateButtons.State == MirusState.Start)
			{
				TryWriteSeasonStatsMessage();
			}
		}

		public void ReceiverUpdateFriendlyMatches()
		{
			if (!TryDisplayInternetConnectionError())
			{
				m_friendlyMatchPage = 0;
				m_friendlyMatchInfos.Clear();
				DisplayCorrectFriendlyMatches();
				DisplayCorrectFriendlyMatchPageSelectors();
				m_workshopManager.UpdatePrivateMatches();
				WriteMirusErrorMessage("UpdateMatches");
				SetBackButtonEnabled(enabled: false);
			}
		}

		public void ReceiverScrollFriendlyMatchesLeft()
		{
			m_friendlyMatchPage--;
			DisplayCorrectFriendlyMatches();
			DisplayCorrectFriendlyMatchPageSelectors();
		}

		public void ReceiverScrollFriendlyMatchesRight()
		{
			m_friendlyMatchPage++;
			DisplayCorrectFriendlyMatches();
			DisplayCorrectFriendlyMatchPageSelectors();
		}

		public void ReceiverStartDuel()
		{
			if (!TryDisplayInternetConnectionError())
			{
				MonoSingleton<PortalHandler>.Instance.SetJoinState(JoinState.Ranked);
				MonoSingleton<PortalHandler>.Instance.LoadLevel(0);
			}
		}

		public void ReceiverSetJoinState(string state)
		{
			if (!TryDisplayInternetConnectionError())
			{
				if (Enum.TryParse<JoinState>(state, out var result))
				{
					MonoSingleton<PortalHandler>.Instance.SetJoinState(result);
				}
				else
				{
					WandsLogger.LogError("Could not correctly parse JoinState " + state);
				}
			}
		}

		public void ReceiverLoadArena(string arena)
		{
			if (TryDisplayInternetConnectionError())
			{
				return;
			}
			if (Enum.TryParse<Arena>(arena, out var result))
			{
				if (MonoSingleton<PortalHandler>.Instance.LoadLevel((int)result))
				{
					Interactable.LockAllInteraction = true;
					Interactable.LockAllLook = true;
				}
			}
			else
			{
				WandsLogger.LogError("Could not correctly parse Arena " + arena);
			}
		}

		public bool TryDisplayInternetConnectionError()
		{
			if (MonoSingleton<NetworkManager>.Instance.LatestInternetCheckWasSuccessful)
			{
				return false;
			}
			DisplayNetworkErrorAndWaitForInternet();
			return true;
		}

		public void WriteInternetConnectionMessage()
		{
			WriteMirusErrorMessage("ConnectingInternet");
		}

		public void WriteInternetConnectionFailedMessage()
		{
			WriteMirusErrorMessage("NoInternetConnection");
		}

		private bool TryWriteSeasonStatsMessage()
		{
			if (!m_seasonStats.HasFetchedSeasonStats)
			{
				return false;
			}
			SetParam(m_seasonStats.LocalizationParam, m_seasonStats.RankedMatchCount.ToString());
			WriteMirusMessage(m_seasonStats.LocalizationTerm);
			return true;
		}

		private void DisplayNetworkErrorAndWaitForInternet()
		{
			m_previousStateButtons.Clear();
			ChangeStateInternal(MirusState.Hide);
			WriteMirusErrorMessage("NoInternetConnection");
			m_onInternetConnectedAction = delegate
			{
				ChangeStateInternal(MirusState.Start);
			};
		}

		private void OnInternetConnectionVerifiedEvent(Events.InternetConnectionVerifiedEvent eventData)
		{
			if (m_onInternetConnectedAction != null)
			{
				m_onInternetConnectedAction();
				m_onInternetConnectedAction = null;
			}
		}

		private void OnConnectToMatch(Events.ConnectToMatch eventData)
		{
			WriteMirusErrorMessage("Connecting");
		}

		private void OnFriendlyMatchesUpdated(Events.FriendlyMatchesUpdatedEvent eventData)
		{
			m_friendlyMatchInfos = new List<RoomInfo>(eventData.RoomInfos);
			if (m_friendlyMatchInfos.Count == 0)
			{
				ReceiverBack();
				WriteMirusErrorMessage("UpdateMatchesFail", 5f);
				return;
			}
			List<string> list = new List<string>(m_friendlyMatchInfos.Count);
			List<int> roomIndices = new List<int>(m_friendlyMatchInfos.Count);
			m_roomFilteredNames.Clear();
			for (int i = 0; i < m_friendlyMatchInfos.Count; i++)
			{
				RoomInfo roomInfo = m_friendlyMatchInfos[i];
				PlatformType platformType = (PlatformType)roomInfo.CustomProperties["A1"];
				if (platformType != PlatformType.PlayStation)
				{
					roomIndices.Add(i);
					string item = ((string)roomInfo.CustomProperties["P1"]).Split('/')[0];
					list.Add(item);
				}
			}
			if (roomIndices.Count > 0)
			{
				GameControl.Instance.Platform.FilterStrings(list, delegate(string[] response)
				{
					for (int j = 0; j < roomIndices.Count; j++)
					{
						m_roomFilteredNames.Add(roomIndices[j], response[j]);
					}
					SetParam("MATCH_COUNT", m_friendlyMatchInfos.Count);
					WriteMirusErrorMessage("UpdateMatchesSuccess");
					SetBackButtonEnabled(enabled: true);
					DisplayCorrectFriendlyMatches();
					DisplayCorrectFriendlyMatchPageSelectors();
				});
			}
			else
			{
				SetParam("MATCH_COUNT", m_friendlyMatchInfos.Count);
				WriteMirusErrorMessage("UpdateMatchesSuccess");
				SetBackButtonEnabled(enabled: true);
				DisplayCorrectFriendlyMatches();
				DisplayCorrectFriendlyMatchPageSelectors();
			}
		}

		private void OnConnectToMatchRoomFailed(Events.ConnectToMatchRoomFailed eventData)
		{
			ResetAfterError("[OnConnectToMatch Could not connect to match room]");
		}

		private void OnConnectToMatchLobbyFailed(Events.ConnectToMatchLobbyFailed eventData)
		{
			ResetAfterError("[OnConnectToMatch Could not connect to match lobby]");
		}

		private void OnPhotonConnectionFailed(NetworkEvents.PhotonConnectionFailedEvent eventData)
		{
			ResetAfterError("[Photon Connection Failed]");
		}

		private void OnTriedStartingWithoutCompleteLoadout(Events.TriedStartingWithoutCompleteLoadoutEvent eventData)
		{
			PunSingleton<SoundManager>.Instance.PlayLocalSound("No Mana");
			m_previousStateButtons.Clear();
			ChangeStateInternal(MirusState.Start);
			WriteMirusErrorMessage("SelectionWarning2");
		}

		private void OnPortalLeverRotated(Events.PortalLeverRotatedEvent eventData)
		{
			if (eventData.Enabled)
			{
				ActivateMainMenu();
				return;
			}
			SetBackButtonEnabled(enabled: false);
			m_scrollLeftButton.gameObject.SetActive(value: false);
			m_scrollRightButton.gameObject.SetActive(value: false);
			if (m_currentMirusStateButtons != null)
			{
				MirusButton[] buttons = m_currentMirusStateButtons.Buttons;
				foreach (MirusButton mirusButton in buttons)
				{
					mirusButton.gameObject.SetActive(value: false);
				}
			}
			m_title.gameObject.SetActive(value: false);
			DeactivateMessage();
			m_previousStateButtons.Clear();
		}

		private void OnPortalLeverInteractedWithEvent(Events.PortalLeverInteractedWithEvent eventData)
		{
			ToggleInteractionActive(eventData.Enabled);
		}

		private void ResetAfterError(string errorMessageAddon)
		{
			if (!TryDisplayInternetConnectionError())
			{
				m_previousStateButtons.Clear();
				ChangeStateInternal(MirusState.Start);
				WriteErrorMessage(errorMessageAddon);
			}
		}

		private void SetParam(string param, object value)
		{
			m_messageParams.SetParameterValue(param, value.ToString());
		}

		private void WriteErrorMessage(string debugErrorInfo)
		{
			MonoSingleton<NetworkManager>.Instance.IsInternetReachable(delegate(bool hasInternet)
			{
				WriteMirusErrorMessage((!hasInternet) ? "NoInternetConnection" : "ConnectionFailed");
				if (GameControl.Instance.IsExpectedConnectionType(ConnectionType.Develop))
				{
					TMP_Text obj = m_message.mTarget as TMP_Text;
					obj.text = obj.text + "\n" + debugErrorInfo;
				}
			});
		}

		private void WriteMirusMessage(string term)
		{
			m_message.SetTerm(term);
			m_message.gameObject.SetActive(value: true);
			CancelInvoke("DeactivateMessage");
		}

		private void WriteMirusErrorMessage(string term)
		{
			m_message.SetTerm(string.Format("{0}/{1}", "Workshop/Mirus/Error", term));
			m_message.gameObject.SetActive(value: true);
			CancelInvoke("DeactivateMessage");
		}

		private void WriteMirusErrorMessage(string term, float time)
		{
			WriteMirusErrorMessage(term);
			if (time > 0f)
			{
				Invoke("DeactivateMessage", time);
			}
		}

		private void DeactivateMessage()
		{
			CancelInvoke("DeactivateMessage");
			m_message.gameObject.SetActive(value: false);
		}

		private void DisplayCorrectFriendlyMatchPageSelectors()
		{
			if (m_currentMirusStateButtons.State != MirusState.JoinFriendSelect)
			{
				m_scrollLeftButton.gameObject.SetActive(value: false);
				m_scrollRightButton.gameObject.SetActive(value: false);
			}
			else if (m_friendlyMatchInfos == null || m_friendlyMatchInfos.Count <= 6)
			{
				m_scrollLeftButton.gameObject.SetActive(value: false);
				m_scrollRightButton.gameObject.SetActive(value: false);
			}
			else
			{
				m_scrollLeftButton.gameObject.SetActive(m_friendlyMatchPage != 0);
				m_scrollRightButton.gameObject.SetActive(m_friendlyMatchPage < m_friendlyMatchInfos.Count / 6);
			}
		}

		private void DisplayCorrectFriendlyMatches()
		{
			MirusButton[] buttons = m_mirusStateButtonsLookup[MirusState.JoinFriendSelect].Buttons;
			for (int i = 0; i < 6; i++)
			{
				buttons[i].gameObject.SetActive(value: false);
			}
			int num = m_friendlyMatchPage * 6;
			List<FriendlyMatchMirusButton> list = new List<FriendlyMatchMirusButton>(6);
			for (int j = 0; j < Mathf.Min(m_friendlyMatchInfos.Count - m_friendlyMatchPage * 6, 6); j++)
			{
				FriendlyMatchMirusButton friendlyMatchMirusButton = (FriendlyMatchMirusButton)buttons[j];
				friendlyMatchMirusButton.gameObject.SetActive(value: true);
				m_roomFilteredNames.TryGetValue(num, out var value);
				friendlyMatchMirusButton.SetFriendlyMatchInfo(m_friendlyMatchInfos[num], value);
				list.Add(friendlyMatchMirusButton);
				num++;
			}
			if (list.Count > 0)
			{
				m_buttonSorter.Sort(list.ToArray());
			}
		}

		public void ChangeToConnectingState()
		{
			if (m_currentMirusStateButtons != null)
			{
				MirusButton[] buttons = m_currentMirusStateButtons.Buttons;
				foreach (MirusButton mirusButton in buttons)
				{
					mirusButton.gameObject.SetActive(value: false);
				}
			}
			SetBackButtonEnabled(enabled: false);
			m_title.gameObject.SetActive(value: false);
			WriteMirusErrorMessage("Connecting");
		}

		private void ChangeStateInternal(MirusState mirusState)
		{
			if (m_currentMirusStateButtons != null)
			{
				MirusButton[] buttons = m_currentMirusStateButtons.Buttons;
				foreach (MirusButton mirusButton in buttons)
				{
					mirusButton.gameObject.SetActive(value: false);
				}
			}
			m_currentMirusStateButtons = m_mirusStateButtonsLookup[mirusState];
			MirusButton[] buttons2 = m_currentMirusStateButtons.Buttons;
			foreach (MirusButton mirusButton2 in buttons2)
			{
				mirusButton2.gameObject.SetActive(mirusButton2.ShouldBeEnabled);
			}
			m_buttonSorter.Sort(m_currentMirusStateButtons.Buttons);
			bool backButtonEnabled = m_previousStateButtons.Count > 0 && mirusState != MirusState.Hide;
			SetBackButtonEnabled(backButtonEnabled);
			DisplayCorrectFriendlyMatchPageSelectors();
			if (mirusState == MirusState.Hide)
			{
				m_title.gameObject.SetActive(value: false);
			}
			else
			{
				m_title.gameObject.SetActive(value: true);
				m_title.SetTerm(m_currentMirusStateButtons.TitleTerm);
			}
			DeactivateMessage();
		}

		private void SetBackButtonEnabled(bool enabled)
		{
			if (enabled != m_returnButton.gameObject.activeSelf)
			{
				m_returnButton.gameObject.SetActive(enabled);
			}
		}

		private void ActivateMainMenu()
		{
			if (TryDisplayInternetConnectionError())
			{
				TMP_Text tMP_Text = m_message.mTarget as TMP_Text;
				tMP_Text.DOFade(tMP_Text.alpha, 1f).SetDelay(1f);
				tMP_Text.alpha = 0f;
				return;
			}
			ChangeStateInternal(MirusState.Start);
			MirusButton[] buttons = m_currentMirusStateButtons.Buttons;
			if (GameControl.Instance.Player.TutorialState >= TutorialState.Completed)
			{
				if (TryWriteSeasonStatsMessage())
				{
					TMP_Text tMP_Text2 = m_message.mTarget as TMP_Text;
					tMP_Text2.DOFade(tMP_Text2.alpha, 1f).SetDelay(1f);
					tMP_Text2.alpha = 0f;
				}
				m_title.gameObject.SetActive(value: true);
				TMP_Text tMP_Text3 = m_title.mTarget as TMP_Text;
				tMP_Text3.DOFade(tMP_Text3.alpha, 1f).SetDelay(1f);
				tMP_Text3.alpha = 0f;
			}
			MirusButton[] array = buttons;
			foreach (MirusButton mirusButton in array)
			{
				mirusButton.FadeInButton(1f, 1f);
			}
		}
	}
	public class MirusButton : MonoBehaviour, IVisibilityToggleable
	{
		[SerializeField]
		private MirusState m_newState;

		[SerializeField]
		private UnityEvent m_shouldBeEnabledMethod = new UnityEvent();

		[Header("Automatically set references")]
		[SerializeField]
		protected InteractableButton m_interactable;

		[SerializeField]
		private Mirus m_mirus;

		[SerializeField]
		private TMP_Text m_text;

		[SerializeField]
		private SpriteRenderer m_frame;

		[SerializeField]
		private bool m_showMirusAsConnectingWhenClicked;

		private Action<Interactable> m_onInteractAction;

		private Action<Interactable> m_onLookEnterAction;

		private Action<Interactable> m_onLookExitAction;

		private int m_shouldBeEnabledCount;

		protected Color DefaultTextColour { get; private set; }

		public virtual bool ShouldBeEnabled
		{
			get
			{
				if (m_shouldBeEnabledMethod == null)
				{
					return true;
				}
				m_shouldBeEnabledCount = 0;
				m_shouldBeEnabledMethod.Invoke();
				return m_shouldBeEnabledCount == m_shouldBeEnabledMethod.GetPersistentEventCount();
			}
		}

		private void Awake()
		{
			if (m_onInteractAction == null)
			{
				m_onInteractAction = delegate
				{
					OnInteract();
				};
			}
			if (m_onLookEnterAction == null)
			{
				m_onLookEnterAction = delegate
				{
					OnLookEnter();
				};
			}
			if (m_onLookExitAction == null)
			{
				m_onLookExitAction = delegate
				{
					OnLookExit();
				};
			}
			DefaultTextColour = m_text.color;
		}

		protected virtual void OnEnable()
		{
			m_interactable.OnInteractListeners.Add(m_onInteractAction);
			m_interactable.AddClickListener(OnClick);
			m_interactable.OnLookEnterListeners.Add(m_onLookEnterAction);
			m_interactable.OnLookExitListeners.Add(m_onLookExitAction);
		}

		protected virtual void OnDisable()
		{
			m_interactable.OnInteractListeners.Remove(m_onInteractAction);
			m_interactable.RemoveClickListener(OnClick);
			m_interactable.OnLookEnterListeners.Remove(m_onLookEnterAction);
			m_interactable.OnLookExitListeners.Remove(m_onLookExitAction);
		}

		public void LockInteractable(bool lockInteractable)
		{
			m_interactable.LockLook(lockInteractable);
			m_interactable.LockInteraction(lockInteractable);
		}

		public void FadeInButton(float fadeTime, float delay)
		{
			m_text.DOFade(m_text.alpha, fadeTime).SetDelay(delay);
			m_frame.material.DOFade(m_frame.material.color.a, fadeTime).SetDelay(delay).OnComplete(delegate
			{
				m_interactable.LockLook(locked: false);
				m_interactable.LockInteraction(locked: false);
			});
			Color color = m_frame.material.color;
			color.a = 0f;
			m_frame.material.color = color;
			m_text.alpha = 0f;
			m_interactable.LockLook(locked: true);
			m_interactable.LockInteraction(locked: true);
		}

		public void GetAiEnabled()
		{
			if (PlayFabTitleData.GetBotsEnabled())
			{
				m_shouldBeEnabledCount++;
			}
		}

		public void GetArenaEnabled(string arena)
		{
			if (Enum.TryParse<Arena>(arena, out var result))
			{
				if (ArenaUtils.IsArenaPlayable(result))
				{
					m_shouldBeEnabledCount++;
				}
			}
			else
			{
				WandsLogger.LogError("Could not parse arena " + arena);
			}
		}

		public void GetTutorialStateIsAtLeast(string tutorialState)
		{
			if (Enum.TryParse<TutorialState>(tutorialState, out var result))
			{
				if (GameControl.Instance.Player.TutorialState >= result)
				{
					m_shouldBeEnabledCount++;
				}
			}
			else
			{
				WandsLogger.LogError("Could not parse tutorial state " + tutorialState);
			}
		}

		public void GetPlatformSupported()
		{
			if (PlatformSupportControl.HasDeprecationDate())
			{
				DateTime date = PlatformSupportControl.GetDate();
				if (date <= DateTime.Today)
				{
					return;
				}
			}
			m_shouldBeEnabledCount++;
		}

		private void OnInteract()
		{
			m_interactable.LookExit();
			PunSingleton<SoundManager>.Instance.PlayLocalSound("portal_ui_button_press", 1f, 1);
			if (m_showMirusAsConnectingWhenClicked)
			{
				m_interactable.SingleCheckActions.Enqueue(new InteractableButton.SingleCheckAction
				{
					OnFailure = delegate
					{
						m_mirus.ChangeState(MirusState.Start);
					}
				});
				m_mirus.WriteInternetConnectionMessage();
			}
		}

		private void OnClick()
		{
			m_mirus.ChangeState(m_newState);
		}

		protected virtual void OnLookEnter()
		{
			PunSingleton<SoundManager>.Instance.PlayLocalSound("portal_ui_button_hover", 1f, 1);
			m_text.color = Color.white;
		}

		protected virtual void OnLookExit()
		{
			m_text.color = DefaultTextColour;
		}
	}
	public enum MirusState
	{
		Start,
		DuelFriend,
		HostFriendlyLevelSelect,
		ExplorationLevelSelect,
		VersusAILevelSelect,
		JoinFriendSelect,
		Hide
	}
}
namespace Assets.Scripts.UI.Workshop
{
	public class NewsBlackboardButton : BlackboardButton
	{
		[SerializeField]
		private TextMeshPro m_header;

		[SerializeField]
		private TextMeshPro m_body;

		private void Start()
		{
			WriteHeader(NewsControl.Header);
			WriteBody(NewsControl.Body);
		}

		private void WriteHeader(string header)
		{
			if (m_header != null)
			{
				m_header.text = header;
			}
		}

		private void WriteBody(string body)
		{
			if (m_body != null)
			{
				m_body.text = body;
			}
		}
	}
	public class ProjectorScreenUI : MonoSingleton<ProjectorScreenUI>
	{
		private const string RelicInteractPointPath = "InteractRelicsPoint";

		private const string RelicInteractStickPath = "InteractRelicsStick";

		private const string RelicInteractDualPath = "InteractRelicsDual";

		private const string InteractPath = "ProjectorInteract";

		[Header("Screen")]
		[SerializeField]
		private Image m_interactionsBackgroundImage;

		[SerializeField]
		private GameObject[] m_instructionTextGos = Array.Empty<GameObject>();

		[SerializeField]
		private Image[] m_wandSlotImages = Array.Empty<Image>();

		[Header("Info")]
		[SerializeField]
		private LocalizationParamsManager m_screenParamsManager;

		[SerializeField]
		private Localize m_spellName;

		[SerializeField]
		private Localize m_spellDescription;

		[SerializeField]
		private TextMeshProUGUI m_spellCastCost;

		[SerializeField]
		private TextMeshProUGUI m_spellDamage;

		[SerializeField]
		private GameObject m_owned;

		[SerializeField]
		private TextMeshProUGUI[] m_secDisplays = Array.Empty<TextMeshProUGUI>();

		[Header("Buy")]
		[SerializeField]
		private WorkshopButton m_buyBtn;

		private Spell m_currentSpell;

		private InfoType m_activeInfo = InfoType.Empty;

		private ControlType? m_controlType;

		private WandInput? m_wandInput;

		private EventToken m_loadoutSelectedEventToken;

		private EventToken m_spellInfoUpdatedEventToken;

		private EventToken m_spellUnlockedEventToken;

		private EventToken m_inputChangedEventToken;

		private void OnEnable()
		{
			m_spellInfoUpdatedEventToken = EventHub.Subscribe<Events.SpellInfoUpdatedEvent>(OnSpellInfoUpdated);
			m_spellUnlockedEventToken = EventHub.Subscribe<Events.SpellUnlockedEvent>(OnSpellUnlocked);
			m_inputChangedEventToken = EventHub.Subscribe<InputEvents.InputChangedEvent>(OnInputChanged);
		}

		protected override void OnDisable()
		{
			base.OnDisable();
			EventHub.Unsubscribe<Events.SpellInfoUpdatedEvent>(m_spellInfoUpdatedEventToken);
			EventHub.Unsubscribe<Events.SpellUnlockedEvent>(m_spellUnlockedEventToken);
			EventHub.Unsubscribe<InputEvents.InputChangedEvent>(m_inputChangedEventToken);
		}

		private void Start()
		{
			CheckInstructionConditions();
		}

		private void OnInputChanged(InputEvents.InputChangedEvent eventData)
		{
			ChangeInput(eventData.WandInput);
		}

		private void ChangeInput(WandInput wandInput)
		{
			if (wandInput == WandInput.None)
			{
				ClearInformation();
				SetInstructionsActive(InfoType.InteractUnsupported);
				return;
			}
			UpdateControlScreenTexture();
			UpdateControlSchemeSprite(wandInput);
			if (m_activeInfo != InfoType.SpellInfo)
			{
				ClearInformation();
			}
		}

		private void UpdateControlScreenTexture()
		{
			if (m_controlType.HasValue)
			{
				ControlType? controlType = m_controlType;
				if (controlType.GetValueOrDefault() == GameControl.Instance.Platform.ControlType && controlType.HasValue)
				{
					return;
				}
			}
			m_controlType = GameControl.Instance.Platform.ControlType;
			if (m_interactionsBackgroundImage == null)
			{
				WandsLogger.LogError("Can't update interaction background image due to not being set in inspector");
				return;
			}
			ControlType? controlType2 = m_controlType;
			if (controlType2.HasValue)
			{
				switch (controlType2.Value)
				{
				case ControlType.Gamepad:
					m_interactionsBackgroundImage.sprite = GameControl.Instance.AssetHandler.LoadAsset<Sprite>(AssetBundleType.CombinedUI, "ProjectorInteract" + "Gamepad");
					return;
				case ControlType.PlayStationDualShock:
					m_interactionsBackgroundImage.sprite = GameControl.Instance.AssetHandler.LoadAsset<Sprite>(AssetBundleType.UI, "ProjectorInteract" + "PlaystationController");
					return;
				case ControlType.PlayStationMotion:
					m_interactionsBackgroundImage.sprite = GameControl.Instance.AssetHandler.LoadAsset<Sprite>(AssetBundleType.UI, "ProjectorInteract" + "PlaystationMove");
					return;
				case ControlType.RiftTouchRight:
				case ControlType.RiftTouchLeft:
					m_interactionsBackgroundImage.sprite = GameControl.Instance.AssetHandler.LoadAsset<Sprite>(AssetBundleType.UI, "ProjectorInteract" + "RiftTouch");
					return;
				case ControlType.QuestRight:
				case ControlType.QuestLeft:
					m_interactionsBackgroundImage.sprite = GameControl.Instance.AssetHandler.LoadAsset<Sprite>(AssetBundleType.UI, "ProjectorInteract" + "Quest");
					return;
				case ControlType.PicoNeo2:
					m_interactionsBackgroundImage.sprite = GameControl.Instance.AssetHandler.LoadAsset<Sprite>(AssetBundleType.UI, "ProjectorInteract" + "PicoNeo2");
					return;
				}
			}
			m_interactionsBackgroundImage.sprite = GameControl.Instance.AssetHandler.LoadAsset<Sprite>(AssetBundleType.UI, "ProjectorInteract" + m_controlType);
		}

		private void UpdateControlSchemeSprite(WandInput wandInput)
		{
			if (!m_wandInput.HasValue || m_wandInput != wandInput)
			{
				m_wandInput = (WandInput)Mathf.Min((int)wandInput, 4);
				string assetName = (GameControl.Instance.IsDualWieldSupportedAndActive ? "InteractRelicsDual" : ((!((Enum)(object)m_wandInput).ContainsFlag(WandInput.Pointing)) ? "InteractRelicsStick" : "InteractRelicsPoint"));
				Sprite sprite = GameControl.Instance.AssetHandler.LoadAsset<Sprite>(AssetBundleType.CombinedUI, assetName);
				Image[] wandSlotImages = m_wandSlotImages;
				foreach (Image image in wandSlotImages)
				{
					image.sprite = sprite;
				}
			}
		}

		public void OnSpellUnlocked(Events.SpellUnlockedEvent eventData)
		{
			SetOwned(1.ToString(), spellOwned: true);
		}

		private void OnSpellInfoUpdated(Events.SpellInfoUpdatedEvent eventData)
		{
			ShowSpellInfo(eventData.SpellSlot);
		}

		private void ShowSpellInfo(SpellSlot spellSlot)
		{
			if (spellSlot == null || spellSlot.m_spell == null)
			{
				if (m_activeInfo != InfoType.Empty)
				{
					ClearInformation();
				}
				return;
			}
			SpellBase spell = spellSlot.m_spell;
			bool spellUnlocked = GameControl.Instance.Player.OwnsSpell(spell.Type);
			WriteInfo(spellUnlocked, spell.NameTerm, spell.DescriptionTerm, spell.CastCost, spell.SpellDamage, 1.ToString());
			IReadOnlyDictionary<string, string> spellDescriptionParams = spell.GetSpellDescriptionParams();
			if (spellDescriptionParams != null)
			{
				foreach (KeyValuePair<string, string> item in spellDescriptionParams)
				{
					m_screenParamsManager.SetParameterValue(item.Key, item.Value);
				}
			}
			m_currentSpell = spell.Type;
		}

		public void UnlockSpell()
		{
			if (m_currentSpell == Spell.None)
			{
				WandsLogger.LogError("Current spell is None");
				return;
			}
			if (GameControl.Instance.Player.OwnsSpell(m_currentSpell))
			{
				WandsLogger.LogError("Trying to unlock an already owned spell");
				return;
			}
			GameControl.Instance.UnlockSpell(m_currentSpell);
			MonoSingleton<SpellSelectUI>.Instance.UnlockSpell(m_currentSpell);
		}

		private void SetName(string term)
		{
			if (!(m_spellName == null))
			{
				m_spellName.gameObject.SetActive(!string.IsNullOrEmpty(term));
				m_spellName.SetTerm(term);
			}
		}

		private void SetDescription(string term)
		{
			if (m_spellDescription != null)
			{
				m_spellDescription.SetTerm(term);
			}
		}

		private void SetCastCost(string castCost)
		{
			if (m_spellCastCost != null)
			{
				m_secDisplays[0].gameObject.SetActive(castCost.Contains("/s"));
				m_spellCastCost.text = castCost.Replace("/s", string.Empty);
			}
		}

		private void SetDamage(string spellDamage)
		{
			if (m_spellDamage != null)
			{
				m_secDisplays[1].gameObject.SetActive(spellDamage.Contains("/s"));
				m_spellDamage.text = spellDamage.Replace("/s", string.Empty);
			}
		}

		private void SetOwned(string spellCost, bool spellOwned = false)
		{
			if (spellOwned)
			{
				m_buyBtn.gameObject.SetActive(value: false);
				m_owned.SetActive(value: true);
				return;
			}
			m_owned.SetActive(value: false);
			int result = 0;
			if (int.TryParse(spellCost, out result))
			{
				bool flag = result <= GameControl.Instance.Player.GetSpellTokens();
				m_buyBtn.gameObject.SetActive(value: true);
				m_buyBtn.Lock(!flag);
			}
			else
			{
				m_buyBtn.gameObject.SetActive(value: false);
			}
		}

		public void ClearInformation()
		{
			SetName(null);
			SetDescription(null);
			SetCastCost(string.Empty);
			SetDamage(string.Empty);
			CheckInstructionConditions();
		}

		public void ShowLockedLoadoutInfo()
		{
			SetInstructionsActive(InfoType.LoadoutLocked);
		}

		public void WriteInfo(bool spellUnlocked, string nameTerm, string descriptionTerm, string castCost, string damage, string spellCost)
		{
			if (m_activeInfo != InfoType.SpellInfo)
			{
				SetInstructionsActive(InfoType.SpellInfo);
				m_buyBtn.gameObject.SetActive(value: false);
			}
			SetName(nameTerm);
			SetDescription(descriptionTerm);
			SetCastCost(castCost);
			SetDamage(damage);
			SetOwned(spellCost, spellUnlocked);
		}

		public void SetInstructionsActive(InfoType type)
		{
			if (m_instructionTextGos.IsNullOrEmpty())
			{
				WandsLogger.LogError("Instruction GameObjects are null or empty!");
				return;
			}
			m_activeInfo = type;
			string value = type.ToString();
			for (int i = 0; i < m_instructionTextGos.Length; i++)
			{
				GameObject gameObject = m_instructionTextGos[i];
				gameObject.SetActive(gameObject.name.Equals(value));
			}
		}

		private void CheckInstructionConditions()
		{
			if (!GameControl.Instance.Player.GetLoadoutSpells(0).Contains(Spell.None))
			{
				Loadout[] unlockedLoadouts = GameControl.Instance.Player.GetUnlockedLoadouts();
				if (unlockedLoadouts.Length > 1)
				{
					for (int i = 1; i < unlockedLoadouts.Length; i++)
					{
						if (GameControl.Instance.Player.GetLoadoutSpells(i).Contains(Spell.None))
						{
							EnableLoadoutTutorial();
							return;
						}
					}
				}
				if (GameControl.Instance.Player.GetSpellTokens() > 0)
				{
					EnableSpellTokenTutorial();
					return;
				}
			}
			SetInstructionsActive(MonoSingleton<SpellSelectUI>.Instance.IsSpellSelectActive ? InfoType.InteractRelics : InfoType.InteractWand);
		}

		private void EnableLoadoutTutorial()
		{
			SetInstructionsActive(InfoType.LoadoutUnlocked);
			m_loadoutSelectedEventToken = EventHub.Subscribe<Events.LoadoutSelectedEvent>(OnLoadoutSelected);
		}

		private void OnLoadoutSelected(Events.LoadoutSelectedEvent eventData)
		{
			Spell[] loadoutSpells = GameControl.Instance.Player.GetLoadoutSpells(eventData.WandIndex);
			if (Array.IndexOf(loadoutSpells, Spell.None) != -1)
			{
				EventHub.Unsubscribe<Events.LoadoutSelectedEvent>(m_loadoutSelectedEventToken);
				SetInstructionsActive(InfoType.InteractWand);
			}
		}

		private void EnableSpellTokenTutorial()
		{
			SetInstructionsActive(InfoType.SpellToken);
		}
	}
	public class ScrollingNumber : MonoBehaviour
	{
		[SerializeField]
		private Renderer m_renderer;

		[SerializeField]
		private float m_yOffset;

		private TweenCallback m_callback;

		public void SetNumber(int number)
		{
			m_renderer.material.SetTextureOffset("_MainTex", new Vector2(0f, m_yOffset * (float)number));
		}

		public void TweenNumber(int number, float time, float delay, TweenCallback onComplete)
		{
			m_callback = onComplete;
			float y = 10f + m_yOffset * (float)number;
			m_renderer.material.DOOffset(new Vector2(0f, y), time).SetDelay(delay).OnComplete(OnCompleted);
		}

		private void OnCompleted()
		{
			if (m_callback != null)
			{
				m_callback();
			}
			Vector2 mainTextureOffset = m_renderer.material.mainTextureOffset;
			mainTextureOffset.y -= 10f;
			m_renderer.material.mainTextureOffset = mainTextureOffset;
		}
	}
	public class ScrollingNumberManager : MonoBehaviour
	{
		[SerializeField]
		protected ScrollingNumber[] m_scollingNumbers;

		public void SetNumber(int number, bool playSfx = false)
		{
			for (int i = 0; i < m_scollingNumbers.Length; i++)
			{
				m_scollingNumbers[i].SetNumber(GetNumberAtIndex(number, i));
			}
			if (playSfx)
			{
				SetSfxActive(active: false);
			}
		}

		protected int GetNumberAtIndex(int number, int index)
		{
			int num = (int)Mathf.Pow(10f, index);
			return number / num % 10;
		}

		protected virtual void SetSfxActive(bool active)
		{
		}
	}
}
namespace Assets.Scripts.UI.Workshop.SpellTable
{
	public class SpellTableCrank : Interactable
	{
		[SerializeField]
		private UnityEvent m_onClick;

		[SerializeField]
		private int m_halfRotations;

		private EventToken m_workshopWandOpenedEventToken;

		private EventToken m_workshopWandClosedEventToken;

		private void OnEnable()
		{
			m_workshopWandOpenedEventToken = EventHub.Subscribe<Events.WorkshopWandOpenedEvent>(OnOpen);
			m_workshopWandClosedEventToken = EventHub.Subscribe<Events.WorkshopWandClosedEvent>(OnClose);
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe<Events.WorkshopWandOpenedEvent>(m_workshopWandOpenedEventToken);
			EventHub.Unsubscribe<Events.WorkshopWandClosedEvent>(m_workshopWandClosedEventToken);
		}

		private void OnOpen(Events.WorkshopWandOpenedEvent eventData)
		{
			base.transform.DOKill();
			base.transform.DOLocalRotate(base.transform.localEulerAngles + new Vector3(0f, 0f, 180 * m_halfRotations), 0.75f, RotateMode.LocalAxisAdd).SetEase(Ease.Linear);
		}

		private void OnClose(Events.WorkshopWandClosedEvent eventData)
		{
			base.transform.DOKill();
			base.transform.DOLocalRotate(base.transform.localEulerAngles - new Vector3(0f, 0f, 180 * m_halfRotations), 0.75f, RotateMode.LocalAxisAdd).SetEase(Ease.Linear);
		}

		public override void Interact()
		{
			if (!base.InteractionLocked)
			{
				base.Interact();
				if (m_onClick != null)
				{
					m_onClick.Invoke();
				}
			}
		}
	}
	public class SpellTableLoadoutButton : InteractableButton
	{
		[SerializeField]
		private int m_loadoutIndex;

		[SerializeField]
		private GameObject m_numberObject;

		private bool m_isLoadoutLocked;

		private void Start()
		{
			m_isLoadoutLocked = GameControl.Instance.Player.GetLoadout(m_loadoutIndex).Locked;
			ToggleParticleEffects(m_isLoadoutLocked);
			m_numberObject.SetActive(!m_isLoadoutLocked);
			if (GameControl.Instance.Player.ActiveLoadoutIndex == m_loadoutIndex)
			{
				WandsButtonHighlighter[] buttonHighlighters = m_buttonHighlighters;
				foreach (WandsButtonHighlighter wandsButtonHighlighter in buttonHighlighters)
				{
					wandsButtonHighlighter.LookEnter();
				}
			}
		}

		public override void LookEnter()
		{
			if (!base.LookLocked && !MonoSingleton<SpellSelectUI>.Instance.WorkshopWand.LookLocked)
			{
				PunSingleton<SoundManager>.Instance.PlayLocalSoundAtPoint("menu_click02", 1f, base.transform.position, 1);
				if (GameControl.Instance.Player.ActiveLoadoutIndex != m_loadoutIndex)
				{
					base.LookEnter();
				}
			}
		}

		public override void LookExit()
		{
			if (!base.LookLocked && GameControl.Instance.Player.ActiveLoadoutIndex != m_loadoutIndex)
			{
				base.LookExit();
			}
		}

		public override void Interact()
		{
			if (!base.InteractionLocked && !MonoSingleton<SpellSelectUI>.Instance.WorkshopWand.InteractionLocked && GameControl.Instance.Player.ActiveLoadoutIndex != m_loadoutIndex)
			{
				if (m_isLoadoutLocked)
				{
					MonoSingleton<ProjectorScreenUI>.Instance.ShowLockedLoadoutInfo();
					return;
				}
				base.Interact();
				MonoSingleton<SpellSelectUI>.Instance.TryChangeWand(m_loadoutIndex);
			}
		}
	}
	public class SpellTableRod : MonoBehaviour
	{
		[SerializeField]
		private float m_moveDistance;

		private Vector3? m_closedPoint;

		private Vector3? m_openedPoint;

		private EventToken m_workshopWandOpenedEventToken;

		private EventToken m_workshopWandClosedEventToken;

		private void Start()
		{
			m_closedPoint = base.transform.localPosition;
			Vector3? closedPoint = m_closedPoint;
			m_openedPoint = ((!closedPoint.HasValue) ? null : new Vector3?(closedPoint.GetValueOrDefault() + new Vector3(m_moveDistance, 0f, 0f)));
		}

		private void OnEnable()
		{
			m_workshopWandOpenedEventToken = EventHub.Subscribe<Events.WorkshopWandOpenedEvent>(OnOpen);
			m_workshopWandClosedEventToken = EventHub.Subscribe<Events.WorkshopWandClosedEvent>(OnClose);
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe<Events.WorkshopWandOpenedEvent>(m_workshopWandOpenedEventToken);
			EventHub.Unsubscribe<Events.WorkshopWandClosedEvent>(m_workshopWandClosedEventToken);
		}

		private void OnOpen(Events.WorkshopWandOpenedEvent eventData)
		{
			if (m_openedPoint.HasValue)
			{
				base.transform.DOKill();
				base.transform.DOLocalMove(m_openedPoint.Value, 0.75f).SetEase(Ease.Linear);
			}
		}

		private void OnClose(Events.WorkshopWandClosedEvent eventData)
		{
			if (m_closedPoint.HasValue)
			{
				base.transform.DOKill();
				base.transform.DOLocalMove(m_closedPoint.Value, 0.75f).SetEase(Ease.Linear);
			}
		}
	}
	public class SpellTableScrollingNumberManager : ScrollingNumberManager
	{
		private EventToken m_spellTokensChangedEventToken;

		private void OnEnable()
		{
			m_spellTokensChangedEventToken = EventHub.Subscribe<Events.SpellUnlockedEvent>(OnSpellUnlocked);
			SetNumber(GameControl.Instance.Player.GetSpellTokens());
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe<Events.SpellUnlockedEvent>(m_spellTokensChangedEventToken);
		}

		private void OnSpellUnlocked(Events.SpellUnlockedEvent eventData)
		{
			SetNumber(GameControl.Instance.Player.GetSpellTokens(), playSfx: true);
		}

		protected override void SetSfxActive(bool active)
		{
			if (!active)
			{
				PunSingleton<SoundManager>.Instance?.PlayLocalSoundAtPoint("currency_counter_spell_token", 1f, base.transform.position, 1);
			}
		}
	}
	public class SpellTableWandSnappable : MonoBehaviour, ISnapObject, IWorkshopTileListener
	{
		[SerializeField]
		private Collider m_collider;

		private EventToken m_spellSelectActivatedEventToken;

		public Vector3 SnapPoint => base.transform.position;

		public Quaternion SnapRotation => base.transform.rotation;

		public bool IsSnappable => !MonoSingleton<SpellSelectUI>.Instance.IsSpellSelectActive;

		private void OnEnable()
		{
			m_spellSelectActivatedEventToken = EventHub.Subscribe<Events.SpellSelectActivatedEvent>(OnSpellSelectActivated);
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe<Events.SpellSelectActivatedEvent>(m_spellSelectActivatedEventToken);
		}

		private void OnSpellSelectActivated(Events.SpellSelectActivatedEvent eventData)
		{
			m_collider.enabled = !eventData.Active;
		}

		public void ToggleInteractionActive(bool active)
		{
			m_collider.enabled = active;
		}

		public void ToggleActive(bool active)
		{
		}
	}
}
namespace Assets.Scripts.UI.Workshop
{
	public class TableNote : Interactable, IDragObject
	{
		[SerializeField]
		private TutorialSubtitleManager m_tutorialSubtitleManager;

		private bool m_isMoving;

		private bool m_isRotating;

		private Vector3 m_startingPoint;

		private Vector3 m_targetPoint;

		private Quaternion m_startingRotation;

		private Quaternion m_targetRotation;

		private const float MoveSpeed = 8f;

		public bool IsBeingDragged { get; private set; }

		public bool IsDraggable => true;

		public bool IsSnappable => false;

		public bool ShouldRaycastToDragPlane => false;

		public float DragTime { get; private set; }

		public event DragBeginDelegate OnDragBegin;

		public event DragEndDelegate OnDragEnd;

		private void Start()
		{
			m_startingPoint = base.transform.position;
			m_startingRotation = base.transform.rotation;
		}

		private void Update()
		{
			if (m_isMoving)
			{
				MoveTowardsTarget();
			}
			if (m_isRotating)
			{
				RotateTowardsTarget();
			}
		}

		private void MoveAndRotate(Vector3 targetPoint, Quaternion targetRotation)
		{
			m_targetPoint = targetPoint;
			m_targetRotation = targetRotation;
			m_isMoving = true;
			m_isRotating = true;
		}

		private void MoveTowardsTarget()
		{
			base.transform.position = Vector3.Lerp(base.transform.position, m_targetPoint, Time.deltaTime * 8f);
			if ((base.transform.position - m_targetPoint).sqrMagnitude < 0.0001f)
			{
				base.transform.position = m_targetPoint;
				m_isMoving = false;
			}
		}

		private void RotateTowardsTarget()
		{
			base.transform.rotation = Quaternion.Lerp(base.transform.rotation, m_targetRotation, Time.deltaTime * 8f);
			if (Quaternion.Angle(base.transform.rotation, m_targetRotation) < 1f)
			{
				base.transform.rotation = m_targetRotation;
				m_isRotating = false;
			}
		}

		public void BeginDrag(Vector3 dragPoint, Vector3 cameraPoint)
		{
			DragTime = 0f;
			if (GameControl.Instance.GetCurrentLanguage() != 0)
			{
				m_tutorialSubtitleManager.ShowSubtitle("Letter");
			}
			if (this.OnDragBegin != null)
			{
				this.OnDragBegin();
			}
			Vector3 euler = Quaternion.LookRotation(dragPoint - cameraPoint).eulerAngles + new Vector3(0f, 180f, 0f);
			euler.x *= -1f;
			MoveAndRotate(dragPoint, Quaternion.Euler(euler));
			IsBeingDragged = true;
			PunSingleton<SoundManager>.Instance.PlayLocalSoundAtPoint("letter_pick_up", 1f, base.transform.position, 1);
		}

		public void Drag(Vector3 dragPoint, Vector3 cameraPoint)
		{
			DragTime += Time.deltaTime;
			Vector3 euler = Quaternion.LookRotation(dragPoint - cameraPoint).eulerAngles + new Vector3(0f, 180f, 0f);
			euler.x *= -1f;
			MoveAndRotate(dragPoint, Quaternion.Euler(euler));
		}

		public void EndDrag()
		{
			m_tutorialSubtitleManager.HideSubtitle();
			if (this.OnDragEnd != null)
			{
				this.OnDragEnd();
			}
			MoveAndRotate(m_startingPoint, m_startingRotation);
			IsBeingDragged = false;
			PunSingleton<SoundManager>.Instance.PlayLocalSoundAtPoint("letter_put_down", 1f, m_startingPoint, 1);
		}

		public void SnapToObject(ISnapObject snapObject)
		{
			DragTime += Time.deltaTime;
		}
	}
	public class TitleScroller : MonoBehaviour
	{
		public void ScrollTo(Vector3 to, float speed, Action callback)
		{
			to += base.transform.position;
			StartCoroutine(Scroll(to, speed, callback));
		}

		private IEnumerator Scroll(Vector3 to, float speed, Action completed)
		{
			PunSingleton<SoundManager>.Instance.PlayLocalSoundAtPoint("menu_click02", 1f, base.transform.position, 1);
			while (Vector3.Distance(base.transform.position, to) > 0.01f)
			{
				base.transform.position = Vector3.Lerp(base.transform.position, to, Time.deltaTime * speed);
				yield return null;
			}
			base.transform.position = to;
			completed();
		}
	}
	public class TitleSelectButton : InteractableButton
	{
		[SerializeField]
		private Localize m_localize;

		[SerializeField]
		private LocalizationParamsManager m_localizeParams;

		[SerializeField]
		private Color m_selectColor = Color.white;

		[SerializeField]
		private GameObject m_chalkEffect;

		[SerializeField]
		private GameObject m_chalkLine;

		private ButtonTextColorer m_buttonTextColorer;

		public Title Title { get; private set; }

		protected override void Awake()
		{
			base.Awake();
			m_chalkLine.SetActive(value: false);
			m_chalkEffect.SetActive(value: false);
			m_buttonTextColorer = GetComponentInChildren<ButtonTextColorer>();
		}

		public void SetTitle(Title title, string displayName)
		{
			Title = title;
			string text = displayName.ToNumbers();
			m_localize.SetTerm(displayName.TrimEnd(text.ToCharArray()));
			m_localizeParams.SetParameterValue("SEASON", text);
		}

		public void Clear()
		{
			m_buttonTextColorer.LookExit();
			LockLook(locked: false);
			LockInteraction(locked: false);
			m_chalkEffect.SetActive(value: false);
			m_chalkLine.SetActive(value: false);
		}

		public void OnClick()
		{
			if (!base.InteractionLocked)
			{
				PunSingleton<SoundManager>.Instance?.PlayLocalSoundAtPoint("chalk_press", 1f, base.transform.position, 1);
				m_buttonTextColorer.ChangeTextColor(m_selectColor);
				m_chalkEffect.SetActive(value: false);
				m_chalkLine.SetActive(value: true);
				LockLook(locked: true);
				LockInteraction(locked: true);
			}
		}

		public void ToggleCollider(bool active)
		{
			base.Collider.enabled = active;
		}

		public override void LookEnter()
		{
			if (!base.LookLocked)
			{
				PunSingleton<SoundManager>.Instance?.PlayLocalSoundAtPoint("chalk_hover", 1f, base.transform.position, 1);
				m_chalkEffect.SetActive(value: true);
				base.LookEnter();
			}
		}

		public override void LookExit()
		{
			if (!base.LookLocked)
			{
				m_chalkEffect.SetActive(value: false);
				base.LookExit();
			}
		}
	}
}
namespace Assets.Scripts.UI.Workshop.Tutorial.Progressors
{
	public class BeginDragTutorialReactor : DragObjectTutorialReactor
	{
		private void OnEnable()
		{
			m_dragObject = m_component as IDragObject;
			if (m_dragObject == null)
			{
				WandsLogger.Log("BeginDragTutorialReactor | Cannot cast m_component to IDragObject!", LogType.Error);
			}
			else
			{
				m_dragObject.OnDragBegin += React;
			}
		}

		private void OnDisable()
		{
			if (m_dragObject == null)
			{
				WandsLogger.Log("BeginDragTutorialReactor | m_dragObject == null!", LogType.Error);
			}
			else
			{
				m_dragObject.OnDragBegin -= React;
			}
		}
	}
	public abstract class DragObjectTutorialReactor : TutorialReactor
	{
		[SerializeField]
		protected UnityEngine.Component m_component;

		protected IDragObject m_dragObject;

		public UnityEngine.Component Component => m_component;
	}
	public class EndDragTutorialReactor : DragObjectTutorialReactor
	{
		private void OnEnable()
		{
			m_dragObject = m_component as IDragObject;
			if (m_dragObject == null)
			{
				WandsLogger.Log("EndDragTutorialReactor | Cannot cast m_component to IDragObject!", LogType.Error);
			}
			else
			{
				m_dragObject.OnDragEnd += React;
			}
		}

		private void OnDisable()
		{
			if (m_dragObject == null)
			{
				WandsLogger.Log("EndDragTutorialReactor | m_dragObject == null!", LogType.Error);
			}
			else
			{
				m_dragObject.OnDragEnd -= React;
			}
		}
	}
	public abstract class EventListenerTutorialReactor<T> : TutorialReactor where T : EventBase, IEvent
	{
		private EventToken m_token;

		protected virtual void OnEnable()
		{
			m_token = EventHub.Subscribe<T>(OnEventTriggered);
		}

		protected virtual void OnDisable()
		{
			EventHub.Unsubscribe<T>(m_token);
		}

		protected virtual void OnEventTriggered(T eventData)
		{
			React();
		}
	}
	public abstract class EventMicroListenerTutorialReactor<T> : TutorialReactor where T : EventBase, IEvent
	{
		private EventToken m_token;

		protected virtual void OnEnable()
		{
			m_token = EventHub.Subscribe<T>(OnEventTriggered);
		}

		protected virtual void OnDisable()
		{
			EventHub.Unsubscribe<T>(m_token);
		}

		protected virtual void OnEventTriggered(T eventData)
		{
			React();
		}
	}
	public class InteractTutorialReactor : TutorialReactor
	{
		[SerializeField]
		private Interactable m_interactable;

		private Action<Interactable> m_interactAction;

		private void Awake()
		{
			m_interactAction = delegate
			{
				React();
			};
		}

		private void OnEnable()
		{
			if (m_interactable == null)
			{
				WandsLogger.Log("InteractTutorialReactor | m_interactable == null!", LogType.Error);
			}
			else
			{
				m_interactable.OnInteractListeners.Add(m_interactAction);
			}
		}

		private void OnDisable()
		{
			if (m_interactable == null)
			{
				WandsLogger.Log("InteractTutorialReactor | m_interactable == null!", LogType.Error);
			}
			else
			{
				m_interactable.OnInteractListeners.Remove(m_interactAction);
			}
		}
	}
	public class LevelStartedTutorialReactor : TutorialReactor
	{
		private IEnumerator Start()
		{
			while (GameControl.Instance.Player == null)
			{
				yield return null;
			}
			React();
		}
	}
	public class LookEnterTutorialReactor : TutorialReactor
	{
		[SerializeField]
		private Interactable m_interactable;

		private void OnEnable()
		{
			if (m_interactable == null)
			{
				WandsLogger.Log("LookEnterTutorialProgressor | m_interactable == null!", LogType.Error);
			}
			else
			{
				m_interactable.OnLookEnter += React;
			}
		}

		private void OnDisable()
		{
			if (m_interactable == null)
			{
				WandsLogger.Log("LookEnterTutorialProgressor | m_interactable == null!", LogType.Error);
			}
			else
			{
				m_interactable.OnLookEnter -= React;
			}
		}
	}
	public class LookExitTutorialReactor : TutorialReactor
	{
		[SerializeField]
		private Interactable m_interactable;

		private void OnEnable()
		{
			if (m_interactable == null)
			{
				WandsLogger.Log("LookExitTutorialReactor | m_interactable == null!", LogType.Error);
			}
			else
			{
				m_interactable.OnLookExit += React;
			}
		}

		private void OnDisable()
		{
			if (m_interactable == null)
			{
				WandsLogger.Log("LookExitTutorialReactor | m_interactable == null!", LogType.Error);
			}
			else
			{
				m_interactable.OnLookExit -= React;
			}
		}
	}
	public class OpponentSpawnedTutorialReactor : EventListenerTutorialReactor<Events.WielderSpawnedEvent>
	{
		protected override void OnEventTriggered(Events.WielderSpawnedEvent eventData)
		{
			if (PlayerManager.Instance.WielderCount == 2)
			{
				React();
			}
		}
	}
	public class SpellCastTutorialReactor : EventListenerTutorialReactor<Events.SpellCastEvent>
	{
	}
	public class SpellSelectedTutorialReactor : EventListenerTutorialReactor<Events.SpellSelectedEvent>
	{
	}
	public abstract class TutorialReactor : MonoBehaviour
	{
		[SerializeField]
		private TutorialCondition[] m_conditions;

		[SerializeField]
		private TutorialReactionType m_reactionType;

		[SerializeField]
		private int m_int;

		protected virtual void React()
		{
			TutorialCondition[] conditions = m_conditions;
			foreach (TutorialCondition tutorialCondition in conditions)
			{
				if (!tutorialCondition.IsMet())
				{
					if (tutorialCondition.ShouldSwitchStateOnFail)
					{
						GameControl.Instance.Player.TutorialState = tutorialCondition.StateOnConditionFailed;
					}
					return;
				}
			}
			switch (m_reactionType)
			{
			case TutorialReactionType.ProgressTutorial:
				ProgressTutorial();
				break;
			case TutorialReactionType.ActivatePostTutorialTrigger:
				ActivatePostTutorialTrigger();
				break;
			}
		}

		private void ProgressTutorial()
		{
			GameControl.Instance.Player.TutorialState = (TutorialState)m_int;
		}

		private void ActivatePostTutorialTrigger()
		{
			GameControl.Instance.Player.ActivatePostTutorialTrigger((PostTutorialTriggerType)m_int);
		}
	}
	public class VoiceOverCompleteTutorialReactor : EventMicroListenerTutorialReactor<Events.TutorialVoiceOverCompleted>
	{
	}
}
namespace Assets.Scripts.UI.Workshop.Tutorial
{
	public class RelicSlotHighlighter : TutorialHighlighter
	{
		private EventToken m_tutorialVoiceOverCompletedEventToken;

		private EventToken m_spellInfoUpdatedEventToken;

		private EventToken m_spellUnlockedEventToken;

		private ParticleSystem m_highlightedParticles;

		private void OnEnable()
		{
			m_tutorialVoiceOverCompletedEventToken = EventHub.Subscribe<Events.TutorialVoiceOverCompleted>(OnVoiceOverCompleted);
			m_spellInfoUpdatedEventToken = EventHub.Subscribe<Events.SpellInfoUpdatedEvent>(OnSpellInfoUpdated);
			m_spellUnlockedEventToken = EventHub.Subscribe<Events.SpellUnlockedEvent>(OnSpellUnlocked);
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe<Events.TutorialVoiceOverCompleted>(m_tutorialVoiceOverCompletedEventToken);
			EventHub.Unsubscribe<Events.SpellInfoUpdatedEvent>(m_spellInfoUpdatedEventToken);
			EventHub.Unsubscribe<Events.SpellUnlockedEvent>(m_spellUnlockedEventToken);
		}

		private void OnSpellUnlocked(Events.SpellUnlockedEvent eventData)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}

		private void OnSpellInfoUpdated(Events.SpellInfoUpdatedEvent eventData)
		{
			if (eventData.SpellSlot == null || eventData.SpellSlot.m_behaviourState != SlotState.Locked)
			{
				if ((object)m_highlightedParticles != null)
				{
					m_highlightedParticles.Play();
				}
			}
			else if (m_attentionGrabber == null)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
			else
			{
				m_highlightedParticles = m_attentionGrabber.GetComponentInChildren<ParticleSystem>();
				m_highlightedParticles.Stop();
			}
		}

		private void OnVoiceOverCompleted(Events.TutorialVoiceOverCompleted eventData)
		{
			if (eventData.State != m_activeState)
			{
				return;
			}
			IOrderedEnumerable<SpellSlot> source = from x in MonoSingleton<SpellSelectUI>.Instance.AllSpellSlots
				where x.m_behaviourState == SlotState.Locked
				orderby x.m_spell.Type
				select x;
			SpellSlot spellSlot = source.FirstOrDefault((SpellSlot x) => Constants.InitialUnlockableGuidanceSpells.Contains(x.m_spell.Type));
			if (spellSlot == null)
			{
				spellSlot = source.FirstOrDefault((SpellSlot x) => !x.m_spell.IsType(Spell.Spell_Teleport));
			}
			base.transform.SetParent(spellSlot.transform.parent);
			base.transform.localPosition = new Vector3(0f, 0.06f, 0.089f);
			base.transform.localRotation = Quaternion.identity;
			GameObject original = GameControl.Instance.AssetHandler.LoadAsset<GameObject>(AssetBundleType.Vanity, "AttentionGrabber");
			m_attentionGrabber = UnityEngine.Object.Instantiate(original, base.transform.position, base.transform.rotation, base.transform);
		}
	}
	[Serializable]
	public class TutorialCondition
	{
		[SerializeField]
		private TutorialConditionType m_type;

		[SerializeField]
		private int m_int;

		[SerializeField]
		private float m_float;

		[SerializeField]
		private bool m_bool;

		[SerializeField]
		private UnityEngine.Object m_object;

		[SerializeField]
		private bool m_shouldSwitchStateOnFail;

		[SerializeField]
		private TutorialState m_stateOnConditionFailed;

		public bool ShouldSwitchStateOnFail => m_shouldSwitchStateOnFail;

		public TutorialState StateOnConditionFailed => m_stateOnConditionFailed;

		public bool IsMet()
		{
			switch (m_type)
			{
			case TutorialConditionType.State:
				return GameControl.Instance.Player.TutorialState == (TutorialState)m_int || m_int == 101;
			case TutorialConditionType.PlayerLevelEqual:
				return GameControl.Instance.Player.SaveData.LevelData.Level == m_int;
			case TutorialConditionType.PlayerLevelGreaterThan:
				return GameControl.Instance.Player.SaveData.LevelData.Level > m_int;
			case TutorialConditionType.PlayerLevelLesserThan:
				return GameControl.Instance.Player.SaveData.LevelData.Level < m_int;
			case TutorialConditionType.SpellTokensEqual:
				return GameControl.Instance.Player.GetSpellTokens() == m_int;
			case TutorialConditionType.SpellTokensGreaterThan:
				return GameControl.Instance.Player.GetSpellTokens() > m_int;
			case TutorialConditionType.SpellTokensLesserThan:
				return GameControl.Instance.Player.GetSpellTokens() < m_int;
			case TutorialConditionType.SpellSlotState:
				return ((SpellSlot)m_object).m_behaviourState == (SlotState)m_int;
			case TutorialConditionType.DragTimeGreaterThan:
				return ((IDragObject)m_object).DragTime > m_float;
			case TutorialConditionType.DragTimeLesserThan:
				return ((IDragObject)m_object).DragTime < m_float;
			case TutorialConditionType.SpellEqual:
			{
				bool? flag3 = PlayerManager.Instance?.PlayerControl?.Wand?.IsSpellTypeSelected((Spell)m_int);
				return flag3.HasValue && flag3.Value;
			}
			case TutorialConditionType.SpellNotEqual:
			{
				bool? flag = PlayerManager.Instance?.PlayerControl?.Wand?.IsSpellTypeSelected((Spell)m_int);
				bool? flag2 = ((!flag.HasValue) ? null : new bool?(!flag.Value));
				return !flag2.HasValue || flag2.Value;
			}
			case TutorialConditionType.PostTutorialStateNotTriggered:
				return !GameControl.Instance.Player.IsPostTutorialTriggered((PostTutorialTriggerType)m_int);
			case TutorialConditionType.DevelopmentBuild:
				return GameControl.Instance.GetConnectionType() == ConnectionType.Develop || GameControl.Instance.GetConnectionType() == ConnectionType.CIN;
			case TutorialConditionType.PlayerInputLocked:
				return GameControl.Instance.PlayerControl != null && GameControl.Instance.PlayerControl.IsInputLocked == m_bool;
			case TutorialConditionType.MatchTypeContainsFlag:
				return MonoSingleton<NetworkManager>.Instance.CurrentMatchType.ContainsFlag((MatchType)m_int);
			default:
				return true;
			}
		}

		public override string ToString()
		{
			return $"Type: {m_type}, Int: {m_int}, Float: {m_float}, Object: {m_object}, SwitchOnFail: {m_shouldSwitchStateOnFail}, StateOnFail: {m_stateOnConditionFailed}";
		}
	}
	public class TutorialHighlighter : MonoBehaviour
	{
		[SerializeField]
		protected Interactable m_interactable;

		[SerializeField]
		protected TutorialState m_activeState;

		protected GameObject m_attentionGrabber;

		private EventToken m_tutorialVoiceOverCompletedEventToken;

		private void OnEnable()
		{
			m_tutorialVoiceOverCompletedEventToken = EventHub.Subscribe<Events.TutorialVoiceOverCompleted>(OnVoiceOverCompleted);
			m_interactable.OnInteract += OnInteract;
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe<Events.TutorialVoiceOverCompleted>(m_tutorialVoiceOverCompletedEventToken);
			m_interactable.OnInteract -= OnInteract;
		}

		private void OnInteract()
		{
			if (m_attentionGrabber == null)
			{
				UnityEngine.Object.Destroy(base.gameObject);
				return;
			}
			ParticleSystem componentInChildren = m_attentionGrabber.GetComponentInChildren<ParticleSystem>();
			componentInChildren.Stop();
			UnityEngine.Object.Destroy(base.gameObject, 5f);
		}

		private void OnVoiceOverCompleted(Events.TutorialVoiceOverCompleted eventData)
		{
			if (eventData.State == m_activeState)
			{
				GameObject original = GameControl.Instance.AssetHandler.LoadAsset<GameObject>(AssetBundleType.Vanity, "AttentionGrabber");
				m_attentionGrabber = UnityEngine.Object.Instantiate(original, base.transform.position, base.transform.rotation, base.transform);
			}
		}
	}
	public class TutorialInteractionLocker : MonoBehaviour
	{
		private PlayerControl m_playerControl;

		private EventToken m_playerControlSpawnedEventToken;

		private EventToken m_tutorialProgressedEventToken;

		private EventToken m_tutorialVoiceOverCompletedEventToken;

		private void OnEnable()
		{
			m_playerControlSpawnedEventToken = EventHub.Subscribe<Events.PlayerControlSpawnedEvent>(OnPlayerSpawned);
			m_tutorialProgressedEventToken = EventHub.Subscribe<Events.TutorialProgressedEvent>(OnTutorialProgressed);
			m_tutorialVoiceOverCompletedEventToken = EventHub.Subscribe<Events.TutorialVoiceOverCompleted>(OnVoiceOverCompleted);
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe<Events.PlayerControlSpawnedEvent>(m_playerControlSpawnedEventToken);
			EventHub.Unsubscribe<Events.TutorialProgressedEvent>(m_tutorialProgressedEventToken);
			EventHub.Unsubscribe<Events.TutorialVoiceOverCompleted>(m_tutorialVoiceOverCompletedEventToken);
		}

		private void OnTutorialProgressed(Events.TutorialProgressedEvent eventData)
		{
			LockInteractions(locked: true);
		}

		private void OnVoiceOverCompleted(Events.TutorialVoiceOverCompleted eventData)
		{
			LockInteractions(locked: false);
		}

		private void OnPlayerSpawned(Events.PlayerControlSpawnedEvent eventData)
		{
			m_playerControl = eventData.PlayerControl;
		}

		private void LockInteractions(bool locked)
		{
			Interactable.LockAllInteraction = locked;
			Interactable.LockAllLook = locked;
			if (m_playerControl != null)
			{
				m_playerControl.ToggleInputActive(!locked);
				m_playerControl.SetSpellInputActive(!locked);
			}
		}
	}
	public class TutorialManager : MonoBehaviour
	{
		[Serializable]
		public class TutorialProgressReactor
		{
			public TutorialState[] m_activateOnState;

			public GameObject m_gameObject;
		}

		[SerializeField]
		private TutorialProgressReactor[] m_toturialProgressReactors;

		private EventToken m_tutorialProgressedEventToken;

		private EventToken m_tutorialVoiceOverCompletedEventToken;

		private void OnEnable()
		{
			m_tutorialProgressedEventToken = EventHub.Subscribe<Events.TutorialProgressedEvent>(OnTutorialProgressed);
			m_tutorialVoiceOverCompletedEventToken = EventHub.Subscribe<Events.TutorialVoiceOverCompleted>(OnVoiceOverCompleted);
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe<Events.TutorialProgressedEvent>(m_tutorialProgressedEventToken);
			EventHub.Unsubscribe<Events.TutorialVoiceOverCompleted>(m_tutorialVoiceOverCompletedEventToken);
		}

		private void Start()
		{
			TryActivateReactors();
		}

		private void TryActivateReactors()
		{
			TutorialProgressReactor[] toturialProgressReactors = m_toturialProgressReactors;
			foreach (TutorialProgressReactor tutorialProgressReactor in toturialProgressReactors)
			{
				tutorialProgressReactor.m_gameObject.SetActive(tutorialProgressReactor.m_activateOnState.Contains(GameControl.Instance.Player.TutorialState));
			}
		}

		private void OnTutorialProgressed(Events.TutorialProgressedEvent eventData)
		{
			TutorialProgressReactor[] toturialProgressReactors = m_toturialProgressReactors;
			foreach (TutorialProgressReactor tutorialProgressReactor in toturialProgressReactors)
			{
				if (!tutorialProgressReactor.m_activateOnState.Contains(eventData.State))
				{
					tutorialProgressReactor.m_gameObject.SetActive(value: false);
				}
			}
		}

		private void OnVoiceOverCompleted(Events.TutorialVoiceOverCompleted eventData)
		{
			TutorialProgressReactor[] toturialProgressReactors = m_toturialProgressReactors;
			foreach (TutorialProgressReactor tutorialProgressReactor in toturialProgressReactors)
			{
				bool active = tutorialProgressReactor.m_activateOnState.Contains(eventData.State);
				tutorialProgressReactor.m_gameObject.SetActive(active);
			}
		}
	}
	public class TutorialSoundManager : MonoBehaviour
	{
		[Serializable]
		public class TutorialSound
		{
			public TutorialState m_activateOnState;

			public AudioClip[] m_tutorialAudioClips;

			public AudioClip[] m_reminderAudioClips;
		}

		[Serializable]
		public class PostTutorialSound
		{
			public PostTutorialTriggerType m_activateOnState;

			public AudioClip[] m_audioClips;

			public bool m_pickRandom;
		}

		[SerializeField]
		private AudioSource m_audioSource;

		[SerializeField]
		private TutorialSound[] m_tutorialSounds;

		[SerializeField]
		private PostTutorialSound[] m_postTutorialSounds;

		private bool m_isSoundsLoaded;

		private EventToken m_saveDataLoadedEventToken;

		private EventToken m_tutorialProgressedEventToken;

		private EventToken m_postTutorialTriggeredEventToken;

		private EventToken m_sceneLoadedEventToken;

		private const float ReminderDelayTime = 30f;

		private void OnEnable()
		{
			StopAllCoroutines();
			m_saveDataLoadedEventToken = EventHub.Subscribe<Events.GameSaveDataLoadedEvent>(OnSaveDataLoaded);
			m_tutorialProgressedEventToken = EventHub.Subscribe<Events.TutorialProgressedEvent>(OnTutorialProgressed);
			m_postTutorialTriggeredEventToken = EventHub.Subscribe<Events.PostTutorialTriggeredEvent>(OnPostTutorialTriggered);
			m_sceneLoadedEventToken = EventHub.Subscribe<Events.SceneLoadedEvent>(OnSceneLoaded);
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe<Events.GameSaveDataLoadedEvent>(m_saveDataLoadedEventToken);
			EventHub.Unsubscribe<Events.TutorialProgressedEvent>(m_tutorialProgressedEventToken);
			EventHub.Unsubscribe<Events.PostTutorialTriggeredEvent>(m_postTutorialTriggeredEventToken);
			EventHub.Unsubscribe<Events.SceneLoadedEvent>(m_sceneLoadedEventToken);
		}

		private void OnSaveDataLoaded(Events.GameSaveDataLoadedEvent eventData)
		{
			if (GameControl.Instance.Player.TutorialState == TutorialState.Completed)
			{
				UnloadAudio();
			}
			else
			{
				LoadAudio();
			}
		}

		private void OnTutorialProgressed(Events.TutorialProgressedEvent eventData)
		{
			for (int i = 0; i < m_tutorialSounds.Length; i++)
			{
				TutorialSound tutorialSound = m_tutorialSounds[i];
				if (tutorialSound.m_activateOnState == eventData.State)
				{
					StopPlayingSound();
					StopAllCoroutines();
					StartCoroutine(PlayTutorialSounds(tutorialSound));
					return;
				}
			}
			StartCoroutine(SendVoiceOverCompletedEvent(eventData.State));
		}

		private void OnPostTutorialTriggered(Events.PostTutorialTriggeredEvent eventData)
		{
			for (int i = 0; i < m_postTutorialSounds.Length; i++)
			{
				PostTutorialSound postTutorialSound = m_postTutorialSounds[i];
				if (postTutorialSound.m_activateOnState == eventData.Trigger)
				{
					StopPlayingSound();
					StopAllCoroutines();
					StartCoroutine(PlayPostTutorialSounds(postTutorialSound));
				}
			}
		}

		private void OnSceneLoaded(Events.SceneLoadedEvent eventData)
		{
			StopPlayingSound();
			StopAllCoroutines();
		}

		private IEnumerator SendVoiceOverCompletedEvent(TutorialState state)
		{
			yield return new WaitForEndOfFrame();
			Events.TutorialVoiceOverCompleted tutorialVoiceOverCompleted = new Events.TutorialVoiceOverCompleted();
			tutorialVoiceOverCompleted.State = state;
			EventHub.Publish(tutorialVoiceOverCompleted);
			if (state == TutorialState.Completed)
			{
				UnloadAudio();
			}
		}

		private void StopPlayingSound()
		{
			if (m_audioSource.isPlaying)
			{
				m_audioSource.Stop();
			}
		}

		private IEnumerator PlayTutorialSounds(TutorialSound sound)
		{
			yield return PlaySoundsSequentually(sound.m_tutorialAudioClips);
			Events.TutorialVoiceOverCompleted tutorialVoiceOverCompleted = new Events.TutorialVoiceOverCompleted();
			tutorialVoiceOverCompleted.State = sound.m_activateOnState;
			EventHub.Publish(tutorialVoiceOverCompleted);
			if (!sound.m_reminderAudioClips.IsNullOrEmpty())
			{
				StartCoroutine(PlayRandomRemindSound(sound.m_reminderAudioClips));
			}
		}

		private IEnumerator PlayRandomRemindSound(AudioClip[] audioClips)
		{
			WaitForSeconds wait = new WaitForSeconds(30f);
			while (true)
			{
				yield return wait;
				yield return PlaySound(audioClips.GetRandomElement());
			}
		}

		private IEnumerator PlayPostTutorialSounds(PostTutorialSound sound)
		{
			if (sound.m_pickRandom)
			{
				yield return PlaySound(sound.m_audioClips.GetRandomElement());
			}
			else
			{
				yield return PlaySoundsSequentually(sound.m_audioClips);
			}
		}

		private IEnumerator PlaySoundsSequentually(IList<AudioClip> clips)
		{
			for (int i = 0; i < clips.Count; i++)
			{
				AudioClip clip = clips[i];
				yield return PlaySound(clip);
			}
		}

		private IEnumerator PlaySound(AudioClip clip)
		{
			m_audioSource.clip = clip;
			m_audioSource.Play();
			Events.TutorialVoiceOverClipStartedEvent tutorialVoiceOverClipStartedEvent = new Events.TutorialVoiceOverClipStartedEvent();
			tutorialVoiceOverClipStartedEvent.AudioClip = clip;
			EventHub.Publish(tutorialVoiceOverClipStartedEvent);
			while (m_audioSource.isPlaying)
			{
				yield return null;
			}
			Events.TutorialVoiceOverClipCompletedEvent tutorialVoiceOverClipCompletedEvent = new Events.TutorialVoiceOverClipCompletedEvent();
			tutorialVoiceOverClipCompletedEvent.AudioClip = clip;
			EventHub.Publish(tutorialVoiceOverClipCompletedEvent);
		}

		private void LoadAudio()
		{
			TutorialSound[] tutorialSounds = m_tutorialSounds;
			foreach (TutorialSound tutorialSound in tutorialSounds)
			{
				AudioClip[] tutorialAudioClips = tutorialSound.m_tutorialAudioClips;
				foreach (AudioClip audioClip in tutorialAudioClips)
				{
					audioClip.LoadAudioData();
				}
				AudioClip[] reminderAudioClips = tutorialSound.m_reminderAudioClips;
				foreach (AudioClip audioClip2 in reminderAudioClips)
				{
					audioClip2.LoadAudioData();
				}
			}
			PostTutorialSound[] postTutorialSounds = m_postTutorialSounds;
			foreach (PostTutorialSound postTutorialSound in postTutorialSounds)
			{
				AudioClip[] audioClips = postTutorialSound.m_audioClips;
				foreach (AudioClip audioClip3 in audioClips)
				{
					audioClip3.LoadAudioData();
				}
			}
			m_isSoundsLoaded = true;
		}

		private void UnloadAudio()
		{
			if (!m_isSoundsLoaded)
			{
				return;
			}
			m_isSoundsLoaded = false;
			TutorialSound[] tutorialSounds = m_tutorialSounds;
			foreach (TutorialSound tutorialSound in tutorialSounds)
			{
				AudioClip[] tutorialAudioClips = tutorialSound.m_tutorialAudioClips;
				foreach (AudioClip audioClip in tutorialAudioClips)
				{
					audioClip.UnloadAudioData();
				}
				AudioClip[] reminderAudioClips = tutorialSound.m_reminderAudioClips;
				foreach (AudioClip audioClip2 in reminderAudioClips)
				{
					audioClip2.UnloadAudioData();
				}
			}
			PostTutorialSound[] postTutorialSounds = m_postTutorialSounds;
			foreach (PostTutorialSound postTutorialSound in postTutorialSounds)
			{
				AudioClip[] audioClips = postTutorialSound.m_audioClips;
				foreach (AudioClip audioClip3 in audioClips)
				{
					audioClip3.UnloadAudioData();
				}
			}
		}
	}
	public class TutorialSubtitleManager : MonoBehaviour
	{
		[SerializeField]
		private Localize m_localize;

		[SerializeField]
		private SpriteRenderer m_background;

		private bool m_enabled;

		private float m_fontRatio;

		private float m_widthRatio;

		private Vector3 m_backgroundRatio;

		private float m_startAlpha;

		private TMP_Text m_text;

		private TextContainer m_textContainer;

		private Transform m_cameraTransform;

		private LayerMask m_hitMask;

		private EventToken m_tutorialVoiceOverClipStartedEventToken;

		private EventToken m_tutorialVoiceOverClipCompletedEventToken;

		private const float ForwardOffset = 4f;

		private const float LerpSpeed = 0.5f;

		private const float OutlineWidth = 0.15f;

		private const float CameraForwardScale = 0.1f;

		public static bool AreSubtitlesCurrentlyDisplayed { get; private set; }

		private void OnEnable()
		{
			m_tutorialVoiceOverClipStartedEventToken = EventHub.Subscribe<Events.TutorialVoiceOverClipStartedEvent>(OnTutorialVoiceOverClipStarted);
			m_tutorialVoiceOverClipCompletedEventToken = EventHub.Subscribe<Events.TutorialVoiceOverClipCompletedEvent>(OnTutorialVoiceOverClipCompleted);
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe<Events.TutorialVoiceOverClipStartedEvent>(m_tutorialVoiceOverClipStartedEventToken);
			EventHub.Unsubscribe<Events.TutorialVoiceOverClipCompletedEvent>(m_tutorialVoiceOverClipCompletedEventToken);
			AreSubtitlesCurrentlyDisplayed = false;
		}

		private void Awake()
		{
			m_text = m_localize.mTarget as TMP_Text;
			m_localize.mTerm = (m_localize.FinalTerm = null);
			m_text.text = string.Empty;
			m_background.enabled = false;
		}

		private void Start()
		{
			m_fontRatio = m_text.fontSize / 4f;
			m_widthRatio = m_text.rectTransform.rect.width / 4f;
			m_backgroundRatio = m_background.transform.localScale / 4f;
			m_textContainer = m_text.GetComponent<TextContainer>();
			base.transform.localPosition = Vector3.zero;
			base.transform.localRotation = Quaternion.identity;
			m_cameraTransform = GameControl.Instance.PlayerControl.CameraTransform;
			m_hitMask = GameControl.Instance.PlayerControl.Input.GetAim().AimHitMask;
			m_text.outlineWidth = 0.15f;
		}

		private void Update()
		{
			if (m_enabled && !(m_cameraTransform == null))
			{
				float t = Time.deltaTime * 0.5f * Quaternion.Angle(base.transform.rotation, m_cameraTransform.rotation);
				if (Physics.Raycast(new Ray(m_cameraTransform.position, m_cameraTransform.forward), out var hitInfo, 4f, m_hitMask))
				{
					base.transform.position = Vector3.Lerp(base.transform.position, hitInfo.point - m_cameraTransform.forward * 0.1f, t);
					m_text.fontSize = Mathf.Lerp(m_text.fontSize, hitInfo.distance * m_fontRatio, t);
					m_textContainer.width = Mathf.Lerp(m_textContainer.width, hitInfo.distance * m_widthRatio, t);
					m_background.transform.localScale = Vector3.Lerp(m_background.transform.localScale, hitInfo.distance * m_backgroundRatio, t);
				}
				else
				{
					base.transform.position = Vector3.Lerp(base.transform.position, m_cameraTransform.position + m_cameraTransform.forward * 4f, t);
					m_text.fontSize = Mathf.Lerp(m_text.fontSize, 4f * m_fontRatio, t);
					m_textContainer.width = Mathf.Lerp(m_textContainer.width, 4f * m_widthRatio, t);
					m_background.transform.localScale = Vector3.Lerp(m_background.transform.localScale, 4f * m_backgroundRatio, t);
				}
				base.transform.rotation = Quaternion.Slerp(base.transform.rotation, m_cameraTransform.rotation, t);
			}
		}

		private void OnTutorialVoiceOverClipStarted(Events.TutorialVoiceOverClipStartedEvent eventData)
		{
			ShowSubtitle(eventData.AudioClip.name);
		}

		private void OnTutorialVoiceOverClipCompleted(Events.TutorialVoiceOverClipCompletedEvent eventData)
		{
			HideSubtitle();
		}

		public void ShowSubtitle(string term)
		{
			if (WandsSave.GetBoolPref("SE"))
			{
				m_enabled = true;
				m_localize.SetTerm($"Tutorial/Subtitles/{term}");
				m_background.enabled = m_text.text != string.Empty;
				AreSubtitlesCurrentlyDisplayed = true;
			}
		}

		public void HideSubtitle()
		{
			if (WandsSave.GetBoolPref("SE"))
			{
				m_enabled = false;
				m_localize.mTerm = (m_localize.FinalTerm = null);
				m_text.text = string.Empty;
				m_background.enabled = false;
				AreSubtitlesCurrentlyDisplayed = false;
				EventHub.Publish(new Events.OnSubtitlesShowEvent());
			}
		}
	}
}
namespace Assets.Scripts.UI.Workshop
{
	public class UI_PlayerProfile : MonoBehaviour
	{
		[SerializeField]
		private TextMeshProUGUI m_rating;

		[SerializeField]
		private Localize m_ratingTitle;

		[SerializeField]
		private GameObject m_ratingLock;

		[SerializeField]
		private TextMeshProUGUI m_matchesPlayed;

		[SerializeField]
		private UI_ExpHandler m_expHandler;

		[SerializeField]
		private GameObject m_winOfTheDayCheckmark;

		[SerializeField]
		private GameObject m_matchOfTheDayCheckmark;

		[SerializeField]
		private LocalizationParamsManager m_dustParamsManager;

		private EventToken m_virtualCurrencyChangedEventToken;

		private void OnEnable()
		{
			UpdateRating();
			UpdateMatchesPlayed();
			if (m_expHandler != null)
			{
				m_expHandler.UpdateUI();
			}
			UpdateDailies();
			m_virtualCurrencyChangedEventToken = EventHub.Subscribe<Events.VirtualCurrencyChanged>(OnVirtualCurrencyChanged);
			SetDustCount(GameControl.Instance.Player.SaveData.VirtualCurrency);
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe<Events.VirtualCurrencyChanged>(m_virtualCurrencyChangedEventToken);
		}

		private void UpdateRating()
		{
			if (m_rating != null)
			{
				m_rating.text = ((!GameControl.Instance.Player.HasUnlockedRating) ? string.Empty : GameControl.Instance.Player.SeasonScore.ToString());
			}
			if (m_ratingTitle != null)
			{
				int num = GameControl.Instance.Player.SeasonScore;
				if (GameControl.Instance.Player.HasUnlockedRating)
				{
					num += 1500;
				}
				m_ratingTitle.SetTerm($"Titles/{PlayerUtils.RatingToTitle(num)}");
				m_ratingTitle.gameObject.SetActive(GameControl.Instance.Player.HasUnlockedRating);
			}
			if (m_ratingLock != null)
			{
				m_ratingLock.SetActive(!GameControl.Instance.Player.HasUnlockedRating);
			}
		}

		private void UpdateMatchesPlayed()
		{
			if (!(m_matchesPlayed == null) && GameControl.Instance.Player != null)
			{
				m_matchesPlayed.text = GameControl.Instance.Player.SaveData.MatchData.MatchesPlayed.ToString();
			}
		}

		private void UpdateDailies()
		{
			DateTime now = DateTime.Now;
			m_winOfTheDayCheckmark.SetActive((now - GameControl.Instance.Player.SaveData.MatchData.LastWinDate).TotalDays < 1.0);
			m_matchOfTheDayCheckmark.SetActive((now - GameControl.Instance.Player.SaveData.MatchData.LastMatchDate).TotalDays < 1.0);
		}

		private void OnVirtualCurrencyChanged(Events.VirtualCurrencyChanged eventData)
		{
			SetDustCount(eventData.Amount);
		}

		private void SetDustCount(int value)
		{
			m_dustParamsManager.SetParameterValue("DUST_COUNT", value.ToString());
		}
	}
	public class VanityWandHandler : MonoBehaviour
	{
		[SerializeField]
		private List<Renderer> m_wands = new List<Renderer>();

		public List<Renderer> GetWands()
		{
			if (m_wands == null || m_wands.Count == 0)
			{
				SpawnWands();
			}
			return m_wands;
		}

		private void SpawnWands()
		{
			GameObject[] array = Resources.LoadAll<GameObject>("Wands");
			for (int i = 0; i < array.Length; i++)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(array[i]);
				gameObject.transform.SetParent(base.transform);
				gameObject.transform.localPosition = Vector3.zero;
				gameObject.transform.localRotation = Quaternion.identity;
				gameObject.transform.localScale = Vector3.one * 0.8f;
				gameObject.SetActive(value: false);
				Renderer componentInChildren = gameObject.GetComponentInChildren<Renderer>();
				m_wands.Add(componentInChildren);
			}
		}

		public bool CanGetWand(out Renderer wandRenderer, WandType type)
		{
			if (m_wands == null || m_wands.Count == 0)
			{
				SpawnWands();
			}
			wandRenderer = m_wands.Find((Renderer wand) => wand.name.ToLower().Contains(type.ToString().ToLower()));
			if (wandRenderer == null)
			{
				return false;
			}
			wandRenderer.gameObject.SetActive(value: true);
			return true;
		}

		public void SetWandSelectionActive(bool enable)
		{
			base.gameObject.SetActive(enable);
		}
	}
}
namespace Cortopia.Scripts.UI.Workshop.WandStation
{
	public class WandPropertyUI : MonoBehaviour
	{
		[SerializeField]
		private Localize[] m_localizeComponents = Array.Empty<Localize>();

		[SerializeField]
		private LocalizationParamsManager[] m_localizationParamsComponents = Array.Empty<LocalizationParamsManager>();

		private WandProperty[] m_cachedProperties;

		private EventToken m_wandStationWandSelectedEventToken;

		private EventToken m_wandTypeChangedEventToken;

		private void OnEnable()
		{
			m_wandStationWandSelectedEventToken = EventHub.Subscribe<Events.WandStationWandSelectedEvent>(OnWandStationWandSelected);
			m_wandTypeChangedEventToken = EventHub.Subscribe<Events.WandTypeChangedEvent>(OnWandTypeChanged);
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe<Events.WandStationWandSelectedEvent>(m_wandStationWandSelectedEventToken);
			EventHub.Unsubscribe<Events.WandTypeChangedEvent>(m_wandTypeChangedEventToken);
		}

		private void OnWandStationWandSelected(Events.WandStationWandSelectedEvent eventData)
		{
			UpdateWandProperties(eventData.Wand.WandType);
		}

		private void OnWandTypeChanged(Events.WandTypeChangedEvent eventData)
		{
			UpdateWandProperties(eventData.WandType);
		}

		private void UpdateWandProperties(WandType wandType)
		{
			if (WandProperties.Get(wandType, out m_cachedProperties))
			{
				for (int i = 0; i < m_localizeComponents.Length; i++)
				{
					if (i < m_cachedProperties.Length)
					{
						Localize localize = m_localizeComponents[i];
						WandProperty wandProperty = m_cachedProperties[i];
						m_localizationParamsComponents[i].SetParameterValue("VALUE", wandProperty.GetLocalizationValue(!GameControl.Instance.IsDualWieldSupportedAndActive));
						localize.SetTerm(wandProperty.Description);
						localize.gameObject.SetActive(value: true);
					}
					else
					{
						m_localizeComponents[i].gameObject.SetActive(value: false);
					}
				}
			}
			else
			{
				for (int j = 0; j < m_localizeComponents.Length; j++)
				{
					m_localizeComponents[j].gameObject.SetActive(value: false);
				}
			}
		}
	}
}
namespace Assets.Scripts.UI.Workshop.WandStation
{
	public class WandStation : MonoBehaviour, IWorkshopTileListener
	{
		private const int WandsPerPage = 4;

		private const int NumberOfPages = 5;

		private const int LastPageIndex = 4;

		[SerializeField]
		private WandStationProjector m_projector;

		[SerializeField]
		private WandVfxHandler m_unlockVfxHandler;

		[SerializeField]
		private WandStationWand[] m_wands = Array.Empty<WandStationWand>();

		[SerializeField]
		private WandStationWandHolder[] m_wandHolders = Array.Empty<WandStationWandHolder>();

		[SerializeField]
		private WandStationButton[] m_wandStationButtons = Array.Empty<WandStationButton>();

		[SerializeField]
		private WandStationScrollingNumberManager m_scrollingNumberManager;

		private int m_currentPage;

		private bool m_interactionLocked;

		private WandStationWand m_selectedWand;

		private List<WandStationWand>[] m_pages;

		private EventToken m_wandStationWandSelectedEventToken;

		private void OnEnable()
		{
			m_wandStationWandSelectedEventToken = EventHub.Subscribe<Events.WandStationWandSelectedEvent>(OnWandStationWandSelected);
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe<Events.WandStationWandSelectedEvent>(m_wandStationWandSelectedEventToken);
		}

		private void OnWandStationWandSelected(Events.WandStationWandSelectedEvent eventData)
		{
			m_selectedWand = eventData.Wand;
		}

		private void Start()
		{
			m_unlockVfxHandler.gameObject.SetActive(value: false);
			CreatePages();
			AddWandsToPages();
			DeactivateWands();
			InitializeFirstPageWands();
			InitializeButtons();
		}

		private void CreatePages()
		{
			m_pages = new List<WandStationWand>[5];
			for (int i = 0; i < 5; i++)
			{
				m_pages[i] = new List<WandStationWand>(4);
			}
		}

		private void AddWandsToPages()
		{
			int num = 0;
			List<WandStationWand> list = m_pages[num];
			for (int i = 0; i < m_wands.Length; i++)
			{
				WandStationWand wandStationWand = m_wands[i];
				if (Constants.BaseWands.Contains(wandStationWand.WandType))
				{
					list.Add(wandStationWand);
					if (list.Count >= list.Capacity && i != m_wands.Length - 1)
					{
						list = m_pages[++num];
					}
				}
				else if (Constants.SpecialWands.Contains(wandStationWand.WandType))
				{
					m_pages[4].Add(wandStationWand);
				}
				else
				{
					WandsLogger.LogError($"Wand - {wandStationWand} - was neither Base or Special.");
					wandStationWand.gameObject.SetActive(value: false);
				}
			}
		}

		private void DeactivateWands()
		{
			List<WandStationWand>[] pages = m_pages;
			foreach (List<WandStationWand> list in pages)
			{
				foreach (WandStationWand item in list)
				{
					item.SetActive(active: false, deactivateWhenDone: true);
				}
			}
		}

		private void InitializeFirstPageWands()
		{
			for (int i = 0; i < m_wandHolders.Length; i++)
			{
				WandStationWand wandStationWand = m_pages[0][i];
				m_wandHolders[i].SetWand(wandStationWand);
				wandStationWand.UpdateStartTransform();
			}
		}

		private void InitializeButtons()
		{
			WandStationButton[] wandStationButtons = m_wandStationButtons;
			foreach (WandStationButton wandStationButton in wandStationButtons)
			{
				wandStationButton.Init(m_pages.Length, this);
			}
		}

		public void BuyWand()
		{
			if (!(m_selectedWand == null))
			{
				CatalogItemWrapper wand = WandsDatabase.GetWand(m_selectedWand.WandType);
				if (GameControl.Instance.Player.CanAfford(wand.DustPrice))
				{
					m_selectedWand.Unlock(m_unlockVfxHandler.gameObject);
					GameControl.Instance.BuyWand(m_selectedWand.WandType);
				}
			}
		}

		public void ShowPage(int index)
		{
			if (m_interactionLocked || m_currentPage == index || m_wandHolders.Any((WandStationWandHolder holder) => holder.IsSpinning))
			{
				return;
			}
			bool flag = false;
			for (int i = 0; i < m_wandHolders.Length; i++)
			{
				WandStationWandHolder wandStationWandHolder = m_wandHolders[i];
				List<WandStationWand> list = ((index >= m_pages.Length) ? null : m_pages[index]);
				WandStationWand newWandToShow = null;
				int? num = list?.Count;
				if (num.HasValue && i < num.GetValueOrDefault())
				{
					newWandToShow = list[i];
				}
				wandStationWandHolder.SpinBoard(newWandToShow);
				if (wandStationWandHolder.IsSpinning)
				{
					flag = true;
				}
			}
			if (flag)
			{
				PunSingleton<SoundManager>.Instance.PlayLocalSoundAtPoint("wand_hanger_switch", 1f, base.transform.GetChild(0).position, 1);
			}
			Events.WandStationPageChangedEvent wandStationPageChangedEvent = new Events.WandStationPageChangedEvent();
			wandStationPageChangedEvent.Index = index;
			EventHub.Publish(wandStationPageChangedEvent);
			m_currentPage = index;
		}

		public void ToggleInteractionActive(bool active)
		{
			m_interactionLocked = !active;
			List<WandStationWand>[] pages = m_pages;
			foreach (List<WandStationWand> list in pages)
			{
				foreach (WandStationWand item in list)
				{
					item.LockInteraction(!active);
					item.LockLook(!active);
				}
			}
			WandStationButton[] wandStationButtons = m_wandStationButtons;
			foreach (WandStationButton wandStationButton in wandStationButtons)
			{
				if (wandStationButton.IsEnabled)
				{
					wandStationButton.LockInteraction(!active);
					wandStationButton.LockLook(!active);
				}
			}
			if (!active)
			{
				m_projector.DisableScreen();
			}
		}

		public void ToggleActive(bool active)
		{
			m_projector.gameObject.SetActive(active);
			foreach (WandStationWand item in m_pages[m_currentPage])
			{
				item.gameObject.SetActive(active);
			}
			m_scrollingNumberManager.gameObject.SetActive(active);
		}
	}
	public class WandStationButton : Interactable
	{
		[SerializeField]
		private int m_index;

		[SerializeField]
		private Renderer m_renderer;

		[SerializeField]
		private Material[] m_materials;

		private bool m_isSelected;

		private WandStation m_wandStation;

		private EventToken m_wandStationPageChangedEventToken;

		public bool IsEnabled { get; private set; }

		private void OnDisable()
		{
			if (m_wandStationPageChangedEventToken != null)
			{
				EventHub.Unsubscribe<Events.WandStationPageChangedEvent>(m_wandStationPageChangedEventToken);
			}
		}

		public void Init(int pageCount, WandStation wandStation)
		{
			m_materials = GameControl.Instance.AssetHandler.ReplaceMaterials(m_materials);
			Renderer[] componentsInChildren = base.transform.GetComponentsInChildren<Renderer>();
			foreach (Renderer renderer in componentsInChildren)
			{
				renderer.sharedMaterials = GameControl.Instance.AssetHandler.ReplaceMaterials(renderer.sharedMaterials);
			}
			m_wandStation = wandStation;
			if (m_index >= pageCount)
			{
				SetDisabled();
				return;
			}
			IsEnabled = true;
			m_wandStationPageChangedEventToken = EventHub.Subscribe<Events.WandStationPageChangedEvent>(OnWandStationPageChanged);
			m_isSelected = m_index == 0;
		}

		public override void LookEnter()
		{
			if (!base.LookLocked)
			{
				base.LookEnter();
				ChangeMaterial(isHighlighted: true);
				PunSingleton<SoundManager>.Instance.PlayLocalSoundAtPoint("menu_click02", 1f, base.transform.position, 1);
			}
		}

		public override void LookExit()
		{
			if (!base.LookLocked)
			{
				base.LookExit();
				if (!m_isSelected)
				{
					ChangeMaterial(isHighlighted: false);
				}
			}
		}

		public override void Interact()
		{
			base.Interact();
			m_wandStation.ShowPage(m_index);
		}

		private void OnWandStationPageChanged(Events.WandStationPageChangedEvent eventData)
		{
			m_isSelected = m_index == eventData.Index;
			ChangeMaterial(m_isSelected);
		}

		private void ChangeMaterial(bool isHighlighted)
		{
			m_renderer.sharedMaterial = m_materials[isHighlighted ? 1 : 0];
		}

		private void SetDisabled()
		{
			IsEnabled = false;
			LockLook(locked: true);
			LockInteraction(locked: true);
			m_renderer.sharedMaterial = m_materials[2];
		}
	}
	public class WandStationPageArrow : MonoBehaviour
	{
		[SerializeField]
		private float m_distanceBetweenPages;

		private EventToken m_wandStationPageChangedEventToken;

		private Vector3? m_startPosition;

		private void Start()
		{
			m_startPosition = base.transform.localPosition;
		}

		private void OnEnable()
		{
			m_wandStationPageChangedEventToken = EventHub.Subscribe<Events.WandStationPageChangedEvent>(OnWandStationPageChanged);
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe<Events.WandStationPageChangedEvent>(m_wandStationPageChangedEventToken);
		}

		private void OnWandStationPageChanged(Events.WandStationPageChangedEvent eventData)
		{
			SetPage(eventData.Index);
		}

		private void SetPage(int page)
		{
			if (!m_startPosition.HasValue)
			{
				Start();
			}
			base.transform.DOKill();
			base.transform.DOLocalMove(m_startPosition.Value - new Vector3(m_distanceBetweenPages * (float)page, 0f, 0f), 0.5f);
		}
	}
	public class WandStationProjector : MonoBehaviour
	{
		[Header("Parents")]
		[SerializeField]
		private GameObject m_wandSelected;

		[SerializeField]
		private GameObject m_wandNotSelected;

		[SerializeField]
		private GameObject m_costParent;

		[Header("References")]
		[SerializeField]
		private Localize m_title;

		[SerializeField]
		private Localize m_description;

		[SerializeField]
		private TMP_Text m_cost;

		[SerializeField]
		private WandStationWorkshopButton m_unlockButton;

		[SerializeField]
		private WandStationWorkshopButton[] m_equipButtons = Array.Empty<WandStationWorkshopButton>();

		private WandType m_selectedWandType;

		private EventToken m_wandStationWandSelectedEventToken;

		private EventToken m_wandPurchasedEventToken;

		private EventToken m_wandTypeChangedEventToken;

		private EventToken m_wandStationPageChangedEventToken;

		private EventToken m_loadoutChangedEventToken;

		private bool IsActive
		{
			[CompilerGenerated]
			get
			{
				return m_wandSelected.activeSelf;
			}
		}

		private void OnEnable()
		{
			m_wandStationWandSelectedEventToken = EventHub.Subscribe<Events.WandStationWandSelectedEvent>(OnWandStationWandSelected);
			m_wandPurchasedEventToken = EventHub.Subscribe<Events.WandPurchasedEvent>(OnWandPurchased);
			m_wandTypeChangedEventToken = EventHub.Subscribe<Events.WandTypeChangedEvent>(OnWandTypeChanged);
			m_wandStationPageChangedEventToken = EventHub.Subscribe<Events.WandStationPageChangedEvent>(OnWandStationPageChanged);
			m_loadoutChangedEventToken = EventHub.Subscribe<Events.WandLoadoutSwitchedEvent>(OnLoadoutChanged);
			m_wandSelected.SetActive(value: false);
			m_wandNotSelected.SetActive(value: true);
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe<Events.WandStationWandSelectedEvent>(m_wandStationWandSelectedEventToken);
			EventHub.Unsubscribe<Events.WandPurchasedEvent>(m_wandPurchasedEventToken);
			EventHub.Unsubscribe<Events.WandTypeChangedEvent>(m_wandTypeChangedEventToken);
			EventHub.Unsubscribe<Events.WandStationPageChangedEvent>(m_wandStationPageChangedEventToken);
			EventHub.Unsubscribe<Events.WandLoadoutSwitchedEvent>(m_loadoutChangedEventToken);
		}

		private void Awake()
		{
			DisableScreen();
		}

		public void DisableScreen()
		{
			m_unlockButton.gameObject.SetActive(value: true);
			for (int i = 0; i < m_equipButtons.Length; i++)
			{
				m_equipButtons[i].gameObject.SetActive(value: false);
			}
		}

		private void OnWandStationPageChanged(Events.WandStationPageChangedEvent eventdata)
		{
			m_wandSelected.SetActive(value: false);
			m_wandNotSelected.SetActive(value: true);
		}

		private void OnWandTypeChanged(Events.WandTypeChangedEvent eventData)
		{
			EquipWand(eventData.WandType, eventData.WandHand, updateScreen: true);
		}

		private void OnLoadoutChanged(Events.WandLoadoutSwitchedEvent eventData)
		{
			if (IsActive)
			{
				UpdateScreen(m_selectedWandType);
			}
		}

		private void OnWandPurchased(Events.WandPurchasedEvent eventData)
		{
			UpdateScreen(eventData.WandType);
		}

		private void OnWandStationWandSelected(Events.WandStationWandSelectedEvent eventData)
		{
			UpdateScreen(eventData.Wand.WandType);
		}

		private void EquipWand(WandType wandType, WandHand wandHand, bool updateScreen)
		{
			GameControl.Instance.Player.SetWand(wandHand, wandType);
			if (updateScreen)
			{
				ShowEquippedScreen(wandType);
			}
		}

		private void UpdateScreen(WandType wandType)
		{
			m_selectedWandType = wandType;
			m_wandSelected.SetActive(value: true);
			m_wandNotSelected.SetActive(value: false);
			CatalogItemWrapper wand = WandsDatabase.GetWand(wandType);
			m_title.SetTerm(wand.DisplayName);
			m_description.SetTerm(wand.Description);
			if (GameControl.Instance.Player.GetWand() == wandType || (GameControl.Instance.IsDualWieldSupportedAndActive && GameControl.Instance.Player.GetWand(WandHand.Left) == wandType))
			{
				ShowEquippedScreen(wandType);
			}
			else if (GameControl.Instance.Player.OwnsWand(wandType))
			{
				ShowUnlockedScreen(wandType);
			}
			else if (Constants.SpecialWands.Contains(wandType))
			{
				ShowSpecialScreen(wandType);
			}
			else
			{
				ShowLockedScreen(wandType);
			}
		}

		private void ShowEquippedScreen(WandType wandType)
		{
			m_costParent.SetActive(value: false);
			if (!GameControl.Instance.IsDualWieldSupportedAndActive)
			{
				m_unlockButton.UpdateButton(ButtonState.Equipped, wandType);
				return;
			}
			m_unlockButton.gameObject.SetActive(value: false);
			for (int i = 0; i < m_equipButtons.Length; i++)
			{
				if (GameControl.Instance.Player.GetWand((WandHand)i) == wandType)
				{
					m_equipButtons[i].UpdateButton(ButtonState.Equipped, wandType);
				}
				else
				{
					m_equipButtons[i].UpdateButton(ButtonState.Equip, wandType);
				}
				m_equipButtons[i].gameObject.SetActive(value: true);
			}
		}

		private void ShowUnlockedScreen(WandType wandType)
		{
			m_costParent.SetActive(value: false);
			if (!GameControl.Instance.IsDualWieldSupportedAndActive)
			{
				m_unlockButton.UpdateButton(ButtonState.Equip, wandType);
				return;
			}
			m_unlockButton.gameObject.SetActive(value: false);
			for (int i = 0; i < m_equipButtons.Length; i++)
			{
				m_equipButtons[i].UpdateButton(ButtonState.Equip, wandType);
				m_equipButtons[i].gameObject.SetActive(value: true);
			}
		}

		private void ShowSpecialScreen(WandType wandType)
		{
			m_costParent.SetActive(value: false);
			DisableEquipButtons();
			m_unlockButton.UpdateButton(ButtonState.Locked, wandType);
			m_unlockButton.gameObject.SetActive(value: true);
		}

		private void ShowLockedScreen(WandType wandType)
		{
			m_costParent.SetActive(value: true);
			DisableEquipButtons();
			CatalogItemWrapper wand = WandsDatabase.GetWand(wandType);
			m_cost.text = wand.DustPrice.ToString();
			m_unlockButton.UpdateButton(ButtonState.Unlock, wandType);
			m_unlockButton.gameObject.SetActive(value: true);
		}

		private void DisableEquipButtons()
		{
			for (int i = 0; i < m_equipButtons.Length; i++)
			{
				m_equipButtons[i].gameObject.SetActive(value: false);
			}
		}
	}
	public class WandStationScrollingNumberManager : ScrollingNumberManager
	{
		[SerializeField]
		[Range(0f, 1f)]
		private float m_timeMultiplier = 0.5f;

		[SerializeField]
		private AudioSource m_loopingAudioSource;

		private Coroutine m_unlockCoroutine;

		private EventToken m_wandPurchasedEventToken;

		private void OnEnable()
		{
			m_wandPurchasedEventToken = EventHub.Subscribe<Events.WandPurchasedEvent>(OnWandPurchased);
			SetNumber(GameControl.Instance.Player.SaveData.VirtualCurrency);
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe<Events.WandPurchasedEvent>(m_wandPurchasedEventToken);
		}

		private void OnWandPurchased(Events.WandPurchasedEvent eventData)
		{
			if (m_unlockCoroutine != null)
			{
				StopCoroutine(m_unlockCoroutine);
				m_unlockCoroutine = null;
			}
			m_unlockCoroutine = StartCoroutine(AwaitUnlockEffect());
		}

		private IEnumerator AwaitUnlockEffect()
		{
			yield return new WaitForSeconds(5f);
			ScrollNumbers(GameControl.Instance.Player.SaveData.VirtualCurrency);
		}

		private void ScrollNumbers(int number)
		{
			SetSfxActive(active: true);
			for (int i = 0; i < m_scollingNumbers.Length; i++)
			{
				int numberAtIndex = GetNumberAtIndex(number, i);
				float time = (float)(m_scollingNumbers.Length - i) * m_timeMultiplier;
				float delay = (float)i * 0.2f;
				if (i == 0)
				{
					m_scollingNumbers[i].TweenNumber(numberAtIndex, time, delay, OnScrollingComplete);
				}
				else
				{
					m_scollingNumbers[i].TweenNumber(numberAtIndex, time, delay, null);
				}
			}
		}

		private void OnScrollingComplete()
		{
			SetSfxActive(active: false);
		}

		protected override void SetSfxActive(bool active)
		{
			if (!(m_loopingAudioSource == null))
			{
				if (active)
				{
					m_loopingAudioSource.Play();
					return;
				}
				m_loopingAudioSource.Stop();
				PunSingleton<SoundManager>.Instance?.PlayLocalSoundAtPoint("currency_counter_dust_loop_end", 1f, m_loopingAudioSource.transform.position, 1);
			}
		}
	}
	public class WandStationWand : VanityUnlockable, IDragObject
	{
		[SerializeField]
		private WandType m_wandType;

		[SerializeField]
		private MeshRenderer[] m_meshRenderers = Array.Empty<MeshRenderer>();

		[SerializeField]
		private Transform m_middle;

		[SerializeField]
		private GameObject m_specialFX;

		private Vector3 m_offset;

		private Vector3 m_targetPoint;

		private Quaternion m_targetRotation;

		private Vector3 m_displayRotation;

		private bool m_isMoving;

		private bool m_isRotating;

		private bool m_isSelected;

		private EventToken m_wandStationWandSelectedEventToken;

		private EventToken m_wandStationPageChangedEventToken;

		protected override bool IsHighlightToggleActive
		{
			[CompilerGenerated]
			get
			{
				return !m_isSelected || IsBeingDragged;
			}
		}

		public Transform Middle
		{
			[CompilerGenerated]
			get
			{
				return m_middle;
			}
		}

		public WandType WandType
		{
			get
			{
				return m_wandType;
			}
			set
			{
				m_wandType = value;
			}
		}

		public bool IsBeingDragged { get; private set; }

		public bool IsDraggable
		{
			[CompilerGenerated]
			get
			{
				return !base.InteractionLocked;
			}
		}

		public bool IsSnappable
		{
			[CompilerGenerated]
			get
			{
				return false;
			}
		}

		public bool ShouldRaycastToDragPlane
		{
			[CompilerGenerated]
			get
			{
				return false;
			}
		}

		public bool IsUnlocked
		{
			[CompilerGenerated]
			get
			{
				return GameControl.Instance.Player.OwnsWand(m_wandType);
			}
		}

		public float DragTime { get; private set; }

		public event DragBeginDelegate OnDragBegin;

		public event DragEndDelegate OnDragEnd;

		private void OnEnable()
		{
			m_wandStationWandSelectedEventToken = EventHub.Subscribe<Events.WandStationWandSelectedEvent>(OnWandStationWandSelected);
			m_wandStationPageChangedEventToken = EventHub.Subscribe<Events.WandStationPageChangedEvent>(OnWandStationPageChanged);
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe<Events.WandStationWandSelectedEvent>(m_wandStationWandSelectedEventToken);
			EventHub.Unsubscribe<Events.WandStationPageChangedEvent>(m_wandStationPageChangedEventToken);
			CancelInvoke();
		}

		protected override void Start()
		{
			foreach (UnlockableRendererMaterialPair meshMaterial in m_meshMaterials)
			{
				meshMaterial.ReplaceMaterial((!IsUnlocked) ? ItemMaterialType.Locked : ItemMaterialType.Default);
			}
			switch (m_wandType)
			{
			case WandType.Classic:
			case WandType.Inductor:
			case WandType.Sword:
			case WandType.Lion:
			case WandType.Remnant:
			case WandType.Scepter:
			case WandType.Invicta:
			case WandType.Snake:
			case WandType.Claw:
			case WandType.Vigil:
			case WandType.Spine:
			case WandType.Armament:
			case WandType.Staff:
			case WandType.Crystal:
				m_displayRotation = new Vector3(0f, 90f, 0f);
				break;
			case WandType.ScarabOfSahir:
				m_displayRotation = new Vector3(0f, 90f, 90f);
				break;
			default:
				throw new NotImplementedException($"{m_wandType} not implemented.");
			}
		}

		private void Update()
		{
			if (m_isMoving)
			{
				MoveTowardsTarget();
			}
			if (m_isRotating)
			{
				RotateTowardsTarget();
			}
		}

		public void UpdateStartTransform()
		{
			base.StartingPosition = base.transform.position;
			base.StartingRotation = base.transform.rotation;
			if (m_middle != null)
			{
				m_offset = m_middle.localPosition - base.transform.localPosition;
			}
		}

		public override void Unlock(GameObject vfx)
		{
			StartCoroutine(PlayUnlockVfx(vfx.GetComponent<WandVfxHandler>()));
		}

		private IEnumerator PlayUnlockVfx(WandVfxHandler vfxHandler)
		{
			m_isMoving = false;
			m_isRotating = false;
			Interactable.LockAllInteraction = true;
			Interactable.LockAllLook = true;
			vfxHandler.AssignCorrectWand(WandType);
			yield return MoveToUnlock(vfxHandler.transform.parent, 1f).WaitForCompletion();
			PunSingleton<SoundManager>.Instance.PlayLocalSoundAtPoint("unlock_effect", 1f, vfxHandler.transform.position, 2);
			vfxHandler.gameObject.SetActive(value: true);
			SetMeshRenderersActive(active: false);
			yield return new WaitForSeconds(5f);
			AssignMaterial(ItemMaterialType.Default, highlighted: true);
			vfxHandler.gameObject.SetActive(value: false);
			vfxHandler.ResetEffect();
			SetMeshRenderersActive(active: true);
			yield return ReturnToSlot(1f).WaitForCompletion();
			Interactable.LockAllInteraction = false;
			Interactable.LockAllLook = false;
		}

		public override void LookEnter()
		{
			if (!base.LookLocked)
			{
				base.LookEnter();
				m_targetPoint = base.StartingPosition + (GameControl.Instance.PlayerControl.Input.GetAim().AimRay.origin - base.StartingPosition).normalized * 0.1f;
				m_isMoving = true;
			}
		}

		public override void LookExit()
		{
			if (!base.LookLocked)
			{
				base.LookExit();
				m_targetPoint = base.StartingPosition;
				m_isMoving = true;
			}
		}

		public override void Interact()
		{
			if (!base.InteractionLocked)
			{
				base.Interact();
				m_isSelected = true;
				Events.WandStationWandSelectedEvent wandStationWandSelectedEvent = new Events.WandStationWandSelectedEvent();
				wandStationWandSelectedEvent.Wand = this;
				EventHub.Publish(wandStationWandSelectedEvent);
			}
		}

		private void OnWandStationPageChanged(Events.WandStationPageChangedEvent eventData)
		{
			m_isSelected = false;
			SetHighlighted(highlighted: false);
		}

		private void OnWandStationWandSelected(Events.WandStationWandSelectedEvent eventData)
		{
			if (eventData.Wand != this)
			{
				m_isSelected = false;
				SetHighlighted(highlighted: false);
			}
		}

		public void SetActive(bool active, bool deactivateWhenDone = false)
		{
			CancelInvoke();
			if (active)
			{
				base.gameObject.SetActive(value: true);
			}
			else if (deactivateWhenDone)
			{
				Invoke("DeactivateGameObject", 0.75f);
			}
		}

		private void DeactivateGameObject()
		{
			base.gameObject.SetActive(value: false);
		}

		public void BeginDrag(Vector3 dragPoint, Vector3 cameraPoint)
		{
			PunSingleton<SoundManager>.Instance.PlayLocalSoundAtPoint("wand_grab", 0.55f, base.transform.position, 1);
			DragTime = 0f;
			if (this.OnDragBegin != null)
			{
				this.OnDragBegin();
			}
			IsBeingDragged = true;
			Vector3 eulerAngles = Quaternion.LookRotation(dragPoint - cameraPoint).eulerAngles;
			float x = eulerAngles.x;
			eulerAngles.x = eulerAngles.z;
			eulerAngles.z = x;
			Quaternion quaternion = Quaternion.Euler(eulerAngles + m_displayRotation);
			Vector3 vector = quaternion * m_offset;
			MoveAndRotate(dragPoint - vector * 0.5f, quaternion);
			AssignMaterial(ItemMaterialType.Default, highlighted: false);
		}

		public void Drag(Vector3 dragPoint, Vector3 cameraPoint)
		{
			DragTime += Time.deltaTime;
			Vector3 eulerAngles = Quaternion.LookRotation(dragPoint - cameraPoint).eulerAngles;
			float x = eulerAngles.x;
			eulerAngles.x = eulerAngles.z;
			eulerAngles.z = x;
			Quaternion quaternion = Quaternion.Euler(eulerAngles + m_displayRotation);
			Vector3 vector = quaternion * m_offset;
			MoveAndRotate(dragPoint - vector * 0.5f, quaternion);
		}

		public void EndDrag()
		{
			AssignMaterial((!IsUnlocked) ? ItemMaterialType.Locked : ItemMaterialType.Default, highlighted: true);
			if (this.OnDragEnd != null)
			{
				this.OnDragEnd();
			}
			IsBeingDragged = false;
			PunSingleton<SoundManager>.Instance.PlayLocalSoundAtPoint("wand_drop", 0.25f, base.transform.position, 1);
			MoveAndRotate(base.StartingPosition, base.StartingRotation);
		}

		public void SnapToObject(ISnapObject snapObject)
		{
			DragTime += Time.deltaTime;
			Vector3 vector = snapObject.SnapRotation * m_offset;
			MoveAndRotate(snapObject.SnapPoint - vector * 0.5f, snapObject.SnapRotation);
		}

		private void MoveTowardsTarget()
		{
			base.transform.position = Vector3.Lerp(base.transform.position, m_targetPoint, Time.deltaTime * 8f);
			if ((base.transform.position - m_targetPoint).sqrMagnitude < 0.0001f)
			{
				base.transform.position = m_targetPoint;
				m_isMoving = false;
			}
		}

		private void RotateTowardsTarget()
		{
			base.transform.rotation = Quaternion.Lerp(base.transform.rotation, m_targetRotation, Time.deltaTime * 8f);
			if (Quaternion.Angle(base.transform.rotation, m_targetRotation) < 1f)
			{
				base.transform.rotation = m_targetRotation;
				m_isRotating = false;
			}
		}

		private void MoveAndRotate(Vector3 targetPoint, Quaternion targetRotation)
		{
			m_targetPoint = targetPoint;
			m_targetRotation = targetRotation;
			m_isMoving = true;
			m_isRotating = true;
		}

		private void SetMeshRenderersActive(bool active)
		{
			MeshRenderer[] meshRenderers = m_meshRenderers;
			foreach (MeshRenderer meshRenderer in meshRenderers)
			{
				meshRenderer.enabled = active;
			}
			if (m_specialFX != null)
			{
				m_specialFX.SetActive(active);
			}
		}
	}
	public class WandStationWandHolder : MonoBehaviour
	{
		[SerializeField]
		private Transform m_frontWandPosition;

		[SerializeField]
		private Transform m_backWandPosition;

		[SerializeField]
		private float spinTime;

		[SerializeField]
		private int m_fullRotations;

		private bool m_isFrontForward = true;

		private WandStationWand m_frontWand;

		private WandStationWand m_backWand;

		public bool IsSpinning { get; private set; }

		public void SetWand(WandStationWand wand)
		{
			SetWand(wand, m_isFrontForward);
		}

		public void SpinBoard(WandStationWand newWandToShow)
		{
			WandStationWand wandStationWand = ((!m_isFrontForward) ? m_backWand : m_frontWand);
			SetWand(newWandToShow, !m_isFrontForward);
			if ((object)m_frontWand != null)
			{
				m_frontWand.LockInteraction(locked: true);
			}
			if ((object)m_frontWand != null)
			{
				m_frontWand.LockLook(locked: true);
			}
			if ((object)m_backWand != null)
			{
				m_backWand.LockInteraction(locked: true);
			}
			if ((object)m_backWand != null)
			{
				m_backWand.LockLook(locked: true);
			}
			if (wandStationWand != newWandToShow)
			{
				IsSpinning = true;
				base.transform.DORotate(base.transform.eulerAngles + new Vector3(0f, 360 * m_fullRotations + 180, 0f), spinTime, RotateMode.FastBeyond360).SetEase(Ease.OutBack).OnComplete(OnSpinComplete);
			}
		}

		private void SetWand(WandStationWand wand, bool setFront)
		{
			if (setFront)
			{
				m_frontWand = wand;
			}
			else
			{
				m_backWand = wand;
			}
			if (wand != null)
			{
				wand.transform.SetParent((!setFront) ? m_backWandPosition : m_frontWandPosition, worldPositionStays: false);
				wand.transform.localPosition = -wand.Middle.localPosition;
				wand.gameObject.SetActive(value: true);
				wand.SetActive(active: true);
			}
		}

		private void OnSpinComplete()
		{
			m_isFrontForward = !m_isFrontForward;
			if (m_isFrontForward)
			{
				if ((object)m_backWand != null)
				{
					m_backWand.gameObject.SetActive(value: false);
				}
				if ((object)m_frontWand != null)
				{
					m_frontWand.UpdateStartTransform();
				}
				if ((object)m_frontWand != null)
				{
					m_frontWand.LockInteraction(locked: false);
				}
				if ((object)m_frontWand != null)
				{
					m_frontWand.LockLook(locked: false);
				}
			}
			else
			{
				if ((object)m_frontWand != null)
				{
					m_frontWand.gameObject.SetActive(value: false);
				}
				if ((object)m_backWand != null)
				{
					m_backWand.UpdateStartTransform();
				}
				if ((object)m_backWand != null)
				{
					m_backWand.LockInteraction(locked: false);
				}
				if ((object)m_backWand != null)
				{
					m_backWand.LockLook(locked: false);
				}
			}
			IsSpinning = false;
		}
	}
	public class WandVfxHandler : MonoBehaviour
	{
		[SerializeField]
		private Transform m_wandMeshesParent;

		[SerializeField]
		[Tooltip("Follow the same order as WandType enum")]
		private Transform[] m_wandParents = Array.Empty<Transform>();

		private Transform m_activeWandParent;

		private List<Transform> m_wandTransforms = new List<Transform>(2);

		public void AssignCorrectWand(WandType wandType)
		{
			m_activeWandParent = m_wandParents[(int)wandType];
			if (m_activeWandParent == null)
			{
				WandsLogger.LogError($"Couldn't find wand of type {wandType} in wand vfx");
				return;
			}
			m_wandTransforms.Clear();
			while (m_activeWandParent.childCount > 0)
			{
				Transform child = m_activeWandParent.GetChild(0);
				m_wandTransforms.Add(child);
				child.transform.SetParent(m_wandMeshesParent);
			}
		}

		public void ResetEffect()
		{
			if (m_activeWandParent == null || m_wandTransforms.IsNullOrEmpty())
			{
				return;
			}
			foreach (Transform wandTransform in m_wandTransforms)
			{
				wandTransform.SetParent(m_activeWandParent);
			}
			m_activeWandParent = null;
		}
	}
}
namespace Assets.Scripts.UI.Workshop
{
	public class WorkshopDebugUI : MonoSingleton<WorkshopDebugUI>
	{
		[SerializeField]
		private TextMeshPro m_deviceId;

		[SerializeField]
		private TextMeshPro m_accountId;

		[SerializeField]
		private TextMeshPro m_debug;

		private EventToken m_writeDebugMessageEventToken;

		protected override void Awake()
		{
			base.Awake();
		}

		private void OnEnable()
		{
			m_writeDebugMessageEventToken = EventHub.Subscribe<Events.WriteDebugMessage>(OnWriteDebugMessageEvent);
		}

		protected override void OnDisable()
		{
			base.OnDisable();
			EventHub.Unsubscribe<Events.WriteDebugMessage>(m_writeDebugMessageEventToken);
		}

		private void Start()
		{
			UpdateDeviceID();
			if (GameControl.Instance.IsExpectedConnectionType(ConnectionType.Develop))
			{
				DebugAccountID(GameControl.Instance.Platform.EncryptionID);
				return;
			}
			DebugAccountID(string.Empty);
			WriteDebugMessage(string.Empty);
		}

		private void UpdateDeviceID()
		{
			if (!(m_deviceId == null))
			{
				if (GameControl.Instance.IsExpectedConnectionType(ConnectionType.Develop))
				{
					m_deviceId.text = "Device ID: " + GetDeviceID();
				}
				else
				{
					m_deviceId.text = string.Empty;
				}
			}
		}

		private string GetDeviceID()
		{
			string text = SystemInfo.deviceUniqueIdentifier;
			if (text.Length > 24)
			{
				text = text.Remove(24).Normalize();
			}
			return text;
		}

		public void DebugAccountID(string id)
		{
			if (!(m_accountId == null))
			{
				if (GameControl.Instance.IsExpectedConnectionType(ConnectionType.Develop))
				{
					m_accountId.text = ((!string.IsNullOrEmpty(id)) ? $"Account ID: {id}" : "Account ID: ");
				}
				else
				{
					m_accountId.text = string.Empty;
				}
			}
		}

		private void OnWriteDebugMessageEvent(Events.WriteDebugMessage eventData)
		{
			WriteDebugMessage(eventData.Message);
		}

		private void WriteDebugMessage(string msg)
		{
			if (!(m_debug == null))
			{
				if (GameControl.Instance.IsExpectedConnectionType(ConnectionType.Develop))
				{
					m_debug.text = ((!string.IsNullOrEmpty(msg)) ? $"Debug: {msg}" : "Debug: ");
				}
				else if (!string.IsNullOrEmpty(m_debug.text))
				{
					m_debug.text = string.Empty;
				}
			}
		}
	}
	public class WorkshopStationTileReference : MonoBehaviour
	{
		[SerializeField]
		private WorkshopTile m_workshopTile;

		public WorkshopTile WorkshopTile => m_workshopTile;
	}
}
public class AnimatedTextureUV : MonoBehaviour
{
	public int m_uvAnimationTileX = 4;

	public int m_uvAnimationTileY = 4;

	public float m_framesPerSecond = 30f;

	private Material m_material;

	private Vector2 m_size;

	private void Start()
	{
		m_material = GetComponent<Renderer>().material;
		m_size = new Vector2(1f / (float)m_uvAnimationTileX, 1f / (float)m_uvAnimationTileY);
		m_material.SetTextureScale("_MainTex", m_size);
	}

	private void Update()
	{
		int num = Mathf.FloorToInt(Time.time * m_framesPerSecond);
		num %= m_uvAnimationTileX * m_uvAnimationTileY;
		int num2 = num % m_uvAnimationTileX;
		int num3 = num / m_uvAnimationTileX;
		Vector2 value = new Vector2((float)num2 * m_size.x, 1f - m_size.y - (float)num3 * m_size.y);
		m_material.SetTextureOffset("_MainTex", value);
	}
}
namespace Assets.Scripts.Utils
{
	public static class ArenaUtils
	{
		public const Arena DefaultArena = Arena.AspisPrison;

		public static bool IsArenaPlayable(Arena arena)
		{
			return GetPlayableArenas().Contains(arena);
		}

		public static Arena GetRandomArena(Arena exludeArena = Arena.None, MatchType matchType = MatchType.None)
		{
			List<Arena> list = new List<Arena>(GetPlayableArenas());
			if (matchType.ContainsFlag(MatchType.Bot))
			{
				exludeArena |= Arena.SanctumOfSahir;
			}
			for (int num = list.Count - 1; num >= 0; num--)
			{
				Arena e = list[num];
				if (e.ContainsFlag(exludeArena))
				{
					list.RemoveAt(num);
				}
			}
			if (list.IsNullOrEmpty())
			{
				return Arena.AspisPrison;
			}
			return list.GetRandomElement();
		}

		private static IList<Arena> GetPlayableArenas()
		{
			if (GameControl.Instance.IsExpectedConnectionType(ConnectionType.Release) || Constants.CustomLevelQueue.IsNullOrEmpty())
			{
				return Constants.BaseLevels;
			}
			return Constants.CustomLevelQueue;
		}
	}
	public class AssetBundleManager
	{
		private readonly Dictionary<string, AssetBundle> m_loadedBundles = new Dictionary<string, AssetBundle>();

		private IEnumerator LoadAndroidBundle(string bundleName, Action<bool> loaded)
		{
			string path = Path.Combine(UnityEngine.Application.streamingAssetsPath, "AssetBundles");
			path = Path.Combine(path, "Android");
			path = Path.Combine(path, bundleName);
			AssetBundleCreateRequest bundleLoadRequest = AssetBundle.LoadFromFileAsync(path);
			while (!bundleLoadRequest.isDone)
			{
				yield return null;
			}
			AssetBundle bundle = bundleLoadRequest.assetBundle;
			if (bundle == null)
			{
				if (!bundleName.Contains("level."))
				{
					WandsLogger.LogError("Assetbundle at path " + path + " was not found.", LogColor.Bundles);
				}
				loaded?.Invoke(obj: false);
			}
			else
			{
				m_loadedBundles.Add(bundleName, bundle);
				loaded(obj: true);
			}
		}

		private IEnumerator LoadPcBundleAsync(string bundleName, Action<bool> loaded)
		{
			string path = UnityEngine.Application.streamingAssetsPath + "/AssetBundles/Windows/" + bundleName;
			if (!File.Exists(path))
			{
				if (!bundleName.Contains("level."))
				{
					WandsLogger.LogError("Assetbundle at path " + path + " was not found.", LogColor.Bundles);
				}
				loaded(obj: false);
				yield break;
			}
			AssetBundleCreateRequest bundleLoadRequest = AssetBundle.LoadFromFileAsync(path);
			while (!bundleLoadRequest.isDone)
			{
				yield return null;
			}
			AssetBundle bundle = bundleLoadRequest.assetBundle;
			if (bundle == null)
			{
				WandsLogger.LogError("Assetbundle " + bundleName + " was not found in " + path, LogColor.Bundles);
				loaded(obj: false);
			}
			else
			{
				m_loadedBundles.Add(bundleName, bundle);
				loaded(obj: true);
			}
		}

		private void LoadPcBundle(string bundleName, Action<bool> loaded, string platformName = "Windows")
		{
			string text = UnityEngine.Application.streamingAssetsPath + "/AssetBundles/" + platformName + "/" + bundleName;
			if (!File.Exists(text))
			{
				if (!bundleName.Contains("level."))
				{
					WandsLogger.LogError("Assetbundle at path " + text + " was not found.", LogColor.Bundles);
				}
				loaded(obj: false);
				return;
			}
			AssetBundle assetBundle = AssetBundle.LoadFromFile(text);
			if (assetBundle == null)
			{
				WandsLogger.LogError("Error when trying to load Assetbundle " + bundleName + " from the path: " + text, LogColor.Bundles);
				loaded(obj: false);
			}
			else
			{
				m_loadedBundles.Add(bundleName, assetBundle);
				loaded(obj: true);
			}
		}

		public void LoadAssetBundle(string bundleName, MonoBehaviour host, Action<bool> loaded, bool loadAsync = true)
		{
			host.StartCoroutine(LoadAssetBundle(bundleName, loaded, loadAsync));
		}

		public IEnumerator LoadAssetBundle(string bundleName, Action<bool> loaded, bool loadAsync = true)
		{
			bundleName = bundleName.ToLower();
			if (m_loadedBundles.ContainsKey(bundleName))
			{
				loaded(obj: false);
				yield break;
			}
			switch (UnityEngine.Application.platform)
			{
			case RuntimePlatform.Android:
				yield return LoadAndroidBundle(bundleName, loaded);
				break;
			case RuntimePlatform.WindowsPlayer:
			case RuntimePlatform.PS4:
				yield return LoadPcBundleAsync(bundleName, loaded);
				break;
			default:
				WandsLogger.LogError("Platform does not support asset bundles", LogColor.Bundles);
				break;
			}
		}

		public bool UnloadAssetBundle(string bundleName)
		{
			if (!m_loadedBundles.ContainsKey(bundleName))
			{
				return false;
			}
			m_loadedBundles[bundleName].Unload(unloadAllLoadedObjects: true);
			m_loadedBundles.Remove(bundleName);
			return true;
		}

		public T LoadAsset<T>(string bundleName, string name) where T : UnityEngine.Object
		{
			if (m_loadedBundles.ContainsKey(bundleName))
			{
				return m_loadedBundles[bundleName].LoadAsset<T>(name);
			}
			WandsLogger.LogError($"Trying to load asset {name} from the unloaded asset bundle: {bundleName}", LogColor.Bundles);
			return (T)null;
		}

		public AssetBundleRequest LoadAssetAsync<T>(string bundleName, string name) where T : UnityEngine.Object
		{
			if (m_loadedBundles.ContainsKey(bundleName))
			{
				return m_loadedBundles[bundleName].LoadAssetAsync<T>(name);
			}
			WandsLogger.LogError($"Trying to load asset {name} from the unloaded asset bundle: {bundleName}", LogColor.Bundles);
			return null;
		}

		public T[] LoadAssets<T>(string bundleName) where T : UnityEngine.Object
		{
			if (m_loadedBundles.ContainsKey(bundleName))
			{
				return m_loadedBundles[bundleName].LoadAllAssets<T>();
			}
			WandsLogger.LogError($"Trying to load assets from the unloaded asset bundle: {bundleName}", LogColor.Bundles);
			return null;
		}
	}
	public class BadgeUtils
	{
		public static void CheckBadgesEarned(EndState state, Wielder player, Wielder opponent, Action<MatchRewardType> playerAddOn, Action<MatchRewardType> opponentAddOn)
		{
			if (playerAddOn == null || opponentAddOn == null)
			{
				return;
			}
			switch (state)
			{
			case EndState.Draw:
				playerAddOn(MatchRewardType.Draw);
				break;
			case EndState.Won:
				playerAddOn(MatchRewardType.Win);
				if (GameControl.Instance.Player.TryUpdateLastWinDate())
				{
					playerAddOn(MatchRewardType.FirstWinOfTheDay);
				}
				if (player.CharacterControl.DamageReceivedTotal == 0f)
				{
					playerAddOn(MatchRewardType.FlawlessVictory);
				}
				if ((int)PlayerProperty.Get("PU") == 0)
				{
					playerAddOn(MatchRewardType.WinWithoutPickups);
				}
				break;
			case EndState.Lost:
				playerAddOn(MatchRewardType.Loss);
				if (!(opponent == null))
				{
					if ((int)PlayerProperty.Get("DD", player.Owner) == 0)
					{
						opponentAddOn(MatchRewardType.FlawlessVictory);
					}
					if ((int)PlayerProperty.Get("PU", opponent.Owner) == 0)
					{
						opponentAddOn(MatchRewardType.WinWithoutPickups);
					}
				}
				break;
			}
			if (GameControl.Instance.Player.TryUpdateLastMatchDate())
			{
				playerAddOn(MatchRewardType.FirstMatchOfTheDay);
			}
			int num = (int)RoomProperty.GetRoomProperty("G0");
			if (num > 0)
			{
				if (num == player.ViewID)
				{
					opponentAddOn(MatchRewardType.FirstBlood);
				}
				else
				{
					playerAddOn(MatchRewardType.FirstBlood);
				}
			}
			int num2 = (int)RoomProperty.GetRoomProperty("G1");
			if (num2 > 0)
			{
				if (num2 == player.ViewID)
				{
					playerAddOn(MatchRewardType.HighestDamage);
				}
				else
				{
					opponentAddOn(MatchRewardType.HighestDamage);
				}
			}
			playerAddOn(MatchRewardType.Stop);
		}
	}
	public class BillboardingObject : MonoBehaviour
	{
		[SerializeField]
		private Vector3 m_rotationOffset;

		private Quaternion m_quaternionOffset;

		private Transform m_cameraTransform;

		private void Start()
		{
			m_quaternionOffset = Quaternion.Euler(m_rotationOffset);
			m_cameraTransform = GameControl.Instance.PlayerControl.CameraTransform;
		}

		private void Update()
		{
			Vector3 forward = base.transform.position - m_cameraTransform.position;
			base.transform.rotation = Quaternion.LookRotation(forward) * m_quaternionOffset;
		}
	}
	public static class BitwiseExtensions
	{
		public static bool ContainsFlag<T>(this Enum e, T flag) where T : struct, IConvertible
		{
			int num = (int)(object)e;
			int num2 = (int)(object)flag;
			return (num & num2) != 0;
		}

		public static bool ContainsFlag(this PlatformType e, PlatformTarget flag)
		{
			return ((uint)e & (uint)flag) != 0;
		}

		public static bool ContainsFlag(this Level e, Level flag)
		{
			return (e & flag) != 0;
		}

		public static bool ContainsFlag(this Arena e, Arena flag)
		{
			return (e & flag) != 0;
		}

		public static bool ContainsFlag(this MatchType e, MatchType flag)
		{
			return (e & flag) != 0;
		}

		public static bool ContainsFlag(this InputState e, InputState flag)
		{
			return (e & flag) != 0;
		}

		public static bool ContainsFlag(this EndState e, EndState flag)
		{
			return (e & flag) != 0;
		}

		public static bool ContainsFlag(this SlotState e, SlotState flag)
		{
			return (e & flag) != 0;
		}

		public static bool ContainsFlag(this AimInput e, AimInput flag)
		{
			return (e & flag) != 0;
		}

		public static bool ContainsFlag(this WandInput e, WandInput flag)
		{
			return (e & flag) != 0;
		}

		public static bool ContainsFlag(this NetworkState e, NetworkState flag)
		{
			return (e & flag) != 0;
		}

		public static bool ContainsFlag(this RoomCreationReason e, RoomCreationReason flag)
		{
			return (e & flag) != 0;
		}

		public static bool ContainsFlag(this ConnectionType e, ConnectionType flag)
		{
			return (e & flag) != 0;
		}

		public static bool ContainsFlag(this ResetBehaviour e, ResetBehaviour flag)
		{
			return (e & flag) != 0;
		}

		public static bool ContainsFlag(this ControlType e, ControlType flag)
		{
			return (e & flag) != 0;
		}

		public static bool ContainsFlag(this PoolObjectCreateState e, PoolObjectCreateState flag)
		{
			return (e & flag) != 0;
		}

		public static int GetArrayIndex(this Enum e)
		{
			return (int)Mathf.Log((int)(object)e, 2f);
		}

		public static WandHand Opposite(this WandHand wandHand)
		{
			return (wandHand != WandHand.Left) ? WandHand.Left : WandHand.Right;
		}

		public static WandHand ToWandHand(this AimInput aimInput)
		{
			return (aimInput == AimInput.LeftHand) ? WandHand.Left : WandHand.Right;
		}

		public static Arena ToArena(this Level level)
		{
			switch (level)
			{
			case Level.AspisPrison:
				return Arena.AspisPrison;
			case Level.TempleOfOphidian:
				return Arena.TempleOfOphidian;
			case Level.TheCelestialHalls:
				return Arena.TheCelestialHalls;
			case Level.OrtusStation:
				return Arena.OrtusStation;
			case Level.DeadMastersVale:
				return Arena.DeadMastersVale;
			case Level.SanctumOfSahir:
				return Arena.SanctumOfSahir;
			default:
				WandsLogger.LogError($"Can't convert {level} to Arena.");
				return Arena.None;
			}
		}

		public static bool IsXRNode(this WandHand wandHand, XRNode nodeType)
		{
			return wandHand switch
			{
				WandHand.Right => nodeType == XRNode.RightHand, 
				WandHand.Left => nodeType == XRNode.LeftHand, 
				_ => false, 
			};
		}
	}
	public class ButtonUtils
	{
		private static string GetLocalizedString(Option type)
		{
			return ScriptLocalization.Get("Options/" + type);
		}

		private static string GetLocalizedString(bool value)
		{
			return ScriptLocalization.Get("Options/" + ((!value) ? "Disabled" : "Enabled"));
		}

		private static string GetLocalizedString(string addOn)
		{
			return ScriptLocalization.Get("Options/" + addOn);
		}

		public static string GetTooltip(Option type, bool enabled)
		{
			string localizedString = GetLocalizedString(type);
			string empty = string.Empty;
			switch (type)
			{
			case Option.Music:
			case Option.PlayerVoIP:
			case Option.OpponentVoIP:
			case Option.ControlSchemeDualWield:
				empty = GetLocalizedString(enabled);
				break;
			case Option.Grip:
				empty = GetLocalizedString(((!enabled) ? WandGrip.Pistol : WandGrip.Wand).ToString());
				break;
			case Option.ControlSchemeWandInput:
				empty = ScriptLocalization.Get($"HUD/Controls/{GameControl.Instance.GetControlScheme()}");
				break;
			case Option.Quit:
				empty = localizedString;
				break;
			default:
				return string.Empty;
			}
			return $"{localizedString}:\n{empty}";
		}

		public static string GetSpriteName(Option type, bool enabled)
		{
			string text = "Icon_";
			switch (type)
			{
			case Option.Music:
				text += ((!enabled) ? "MusicOff" : "MusicOn");
				break;
			case Option.PlayerVoIP:
				text += ((!enabled) ? "PlayerVoIPOff" : "PlayerVoIPOn");
				break;
			case Option.OpponentVoIP:
				text += ((!enabled) ? "OpponentVoIPOff" : "OpponentVoIPOn");
				break;
			case Option.Grip:
				text += ((!enabled) ? "GripPistol" : "GripWand");
				break;
			case Option.ControlSchemeWandInput:
				text += GameControl.Instance.GetControlScheme();
				break;
			case Option.Ready:
				return (!enabled) ? "Icon_Rematch" : "Workshop_Icon_atlas_accept";
			}
			return text;
		}

		public static bool GetShouldOptionBeEnabled(Option type)
		{
			switch (type)
			{
			case Option.Music:
			case Option.PlayerVoIP:
			case Option.OpponentVoIP:
				return true;
			case Option.Grip:
				return GameControl.Instance.GetInputAim().ContainsFlag(AimInput.Hand);
			case Option.Quit:
				return GameControl.Instance.Platform.Type.ContainsFlag(PlatformTarget.OculusAndroid);
			case Option.Ready:
				return PunSingleton<LobbyManager>.Instance.State == LobbyState.Pre && PlayerManager.Instance.IsGameFull;
			case Option.ControlSchemeWandInput:
				return GameControl.Instance.GetInputAim().ContainsFlag(AimInput.Remote) && GameControl.Instance.Platform.SupportedWandInputs.Count > 1;
			case Option.ControlSchemeDualWield:
				return GameControl.Instance.Platform.ControlType.ContainsFlag((ControlType)380096);
			default:
				return false;
			}
		}

		public static bool CanToggle(Option option)
		{
			if (option == Option.PlayerVoIP || option == Option.OpponentVoIP)
			{
				return UniAndroidPermission.IsPermitted(AndroidPermission.RECORD_AUDIO);
			}
			return true;
		}

		public static bool GetOptionValue(Option type)
		{
			switch (type)
			{
			case Option.PlayerVoIP:
				return WandsVoip.IsPlayerEnabled;
			case Option.OpponentVoIP:
				return WandsVoip.IsOpponentEnabled;
			case Option.Music:
				return ToggleMusic(GameControl.Instance.MusicEnabled);
			case Option.Grip:
				return WandsSave.WandGrip == WandGrip.Wand;
			case Option.Ready:
			{
				bool? flag = PunSingleton<LobbyManager>.Instance?.IsReady;
				return flag.HasValue && flag.Value;
			}
			default:
				return false;
			}
		}

		public static void SetOptionValue(Option type, bool enabled)
		{
			switch (type)
			{
			case Option.Music:
				ToggleMusic(enabled);
				break;
			case Option.PlayerVoIP:
				WandsVoip.IsPlayerEnabled = enabled;
				break;
			case Option.OpponentVoIP:
				WandsVoip.IsOpponentEnabled = enabled;
				break;
			case Option.Grip:
				GameControl.Instance.ToggleWandGrip();
				break;
			case Option.Ready:
				PunSingleton<LobbyManager>.Instance.ToggleReady();
				break;
			case Option.ControlSchemeWandInput:
				GameControl.Instance.SetControlScheme(GetNextWandInputValue());
				break;
			}
		}

		public static WandInput GetNextWandInputValue()
		{
			IReadOnlyList<WandInput> supportedWandInputs = GameControl.Instance.Platform.SupportedWandInputs;
			if (supportedWandInputs.Count == 1)
			{
				WandsLogger.LogError($"{GameControl.Instance.Platform.Type} | Trying to toggle WandInput with only one available value.");
				return supportedWandInputs[0];
			}
			WandInput controlScheme = GameControl.Instance.GetControlScheme();
			for (int i = 0; i < supportedWandInputs.Count; i++)
			{
				if (supportedWandInputs[i] == controlScheme)
				{
					return supportedWandInputs[(i + 1).Wrap(0, supportedWandInputs.Count - 1)];
				}
			}
			WandsLogger.LogError($"ButtonUtils | Wand input <{controlScheme}> isn't supported on platform <{GameControl.Instance.Platform.Type}> | Returning first supported value");
			return supportedWandInputs[0];
		}

		private static bool ToggleMusic(bool enabled)
		{
			PunSingleton<SoundManager>.Instance?.SetOptionalMusicEnabled(enabled);
			GameControl.Instance.ToggleMusic(enabled);
			return enabled;
		}
	}
}
public class ByteConverter
{
	public static byte[] GetBytes(string bitString)
	{
		byte[] array = (from pos in Enumerable.Range(0, bitString.Length / 8)
			select Convert.ToByte(bitString.Substring(pos * 8, 8), 2)).ToArray();
		List<byte> list = new List<byte>();
		for (int num = array.Length - 1; num >= 0; num--)
		{
			list.Add(array[num]);
		}
		return list.ToArray();
	}

	public static string ToBitString(BitArray bits)
	{
		StringBuilder stringBuilder = new StringBuilder();
		for (int num = bits.Count - 1; num >= 0; num--)
		{
			char value = ((!bits[num]) ? '0' : '1');
			stringBuilder.Append(value);
		}
		return stringBuilder.ToString();
	}
}
namespace Assets.Scripts.Utils
{
	[ExecuteInEditMode]
	public class CatmullRomSpline : MonoBehaviour
	{
		public bool m_showGizmos;

		public Transform[] controlPointsList;

		public bool isLooping = true;

		public Queue<Vector3> GetPoints(Transform[] controlPoints)
		{
			controlPointsList = controlPoints;
			Queue<Vector3> queue = new Queue<Vector3>();
			for (int i = 0; i < controlPoints.Length; i++)
			{
				if (i != 0 && i != controlPoints.Length - 2 && i != controlPoints.Length - 1)
				{
					Vector3 position = controlPoints[ClampListPos(i - 1)].position;
					Vector3 position2 = controlPoints[i].position;
					Vector3 position3 = controlPoints[ClampListPos(i + 1)].position;
					Vector3 position4 = controlPoints[ClampListPos(i + 2)].position;
					float num = 0.05f;
					int num2 = Mathf.FloorToInt(1f / num);
					for (int j = 1; j <= num2; j++)
					{
						float t = (float)j * num;
						Vector3 catmullRomPosition = GetCatmullRomPosition(t, position, position2, position3, position4);
						queue.Enqueue(catmullRomPosition);
					}
				}
			}
			return queue;
		}

		private void OnDrawGizmos()
		{
			if (!m_showGizmos)
			{
				return;
			}
			for (int i = 0; i < controlPointsList.Length; i++)
			{
				if ((i != 0 && i != controlPointsList.Length - 2 && i != controlPointsList.Length - 1) || isLooping)
				{
					DisplayCatmullRomSpline(i);
				}
			}
		}

		private void DisplayCatmullRomSpline(int pos)
		{
			Vector3 position = controlPointsList[ClampListPos(pos - 1)].position;
			Vector3 position2 = controlPointsList[pos].position;
			Vector3 position3 = controlPointsList[ClampListPos(pos + 1)].position;
			Vector3 position4 = controlPointsList[ClampListPos(pos + 2)].position;
			Vector3 from = position2;
			float num = 0.1f;
			int num2 = Mathf.FloorToInt(1f / num);
			for (int i = 1; i <= num2; i++)
			{
				float t = (float)i * num;
				Vector3 catmullRomPosition = GetCatmullRomPosition(t, position, position2, position3, position4);
				Gizmos.color = Color.white;
				Gizmos.DrawLine(from, catmullRomPosition);
				Gizmos.color = Color.red;
				Gizmos.DrawSphere(catmullRomPosition, 0.2f);
				from = catmullRomPosition;
			}
		}

		private int ClampListPos(int pos)
		{
			if (pos < 0)
			{
				pos = controlPointsList.Length - 1;
			}
			if (pos > controlPointsList.Length)
			{
				pos = 1;
			}
			else if (pos > controlPointsList.Length - 1)
			{
				pos = 0;
			}
			return pos;
		}

		private Vector3 GetCatmullRomPosition(float t, Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3)
		{
			Vector3 vector = 2f * p1;
			Vector3 vector2 = p2 - p0;
			Vector3 vector3 = 2f * p0 - 5f * p1 + 4f * p2 - p3;
			Vector3 vector4 = -p0 + 3f * p1 - 3f * p2 + p3;
			return 0.5f * (vector + vector2 * t + vector3 * t * t + vector4 * t * t * t);
		}
	}
	public class CloudScriptConverter
	{
		private static readonly Dictionary<string, string> MethodNames = new Dictionary<string, string>
		{
			{ "Rating", "UpdateRating" },
			{ "SeasonScore", "UpdateSeasonScore" },
			{ "GetCombinedBackendRepresentation", "GetCombinedBackendRepresentation" },
			{ "GetUserInventory", "GetUserInventory" },
			{ "GetAllCatalogItems", "GetAllCatalogItems" },
			{ "GetSeasonInformation", "GetSeasonInfo" },
			{ "GetMinimumVersion", "GetMinimumVersion" },
			{ "SaveAllData", "SaveAllData" },
			{ "SaveExperienceRewards", "SaveExperienceRewards" },
			{ "SaveUnlockedSpells", "SaveUnlockedSpells" },
			{ "SaveUnlockedWands", "SaveUnlockedWands" },
			{ "SaveUnlockedCharacters", "SaveUnlockedCharacters" },
			{ "SaveUnlockedTitles", "SaveUnlockedTitles" },
			{ "SaveVirtualCurrency", "SaveVirtualCurrency" },
			{ "SaveGameAccess", "SaveGameAccess" },
			{ "SaveCompletedTutorial", "SaveCompletedTutorial" },
			{ "SaveLoadouts", "SaveLoadouts" },
			{ "SaveCustomEventRewards", "SaveCustomEventRewards" },
			{ "SaveMatchData", "SaveMatchData" },
			{ "SaveItemsToInventory", "SaveItemsToInventory" },
			{ "SaveAchievementData", "SaveAchievementData" }
		};

		public static string GetMethodName(string fieldName)
		{
			return (!MethodNames.ContainsKey(fieldName)) ? string.Empty : MethodNames[fieldName];
		}
	}
}
public static class CollectionExtensions
{
	public static bool Contains<T>(this T[] array, T item)
	{
		return Array.IndexOf(array, item) != -1;
	}

	public static T GetRandomElement<T>(this IList<T> list)
	{
		if (list == null || list.Count == 0)
		{
			return default(T);
		}
		return (list.Count != 1) ? list[UnityEngine.Random.Range(0, list.Count)] : list[0];
	}

	public static T GetRandomElement<T>(this IList<T> list, T excludedElement)
	{
		if (list == null)
		{
			return default(T);
		}
		if (list.Count == 1)
		{
			return list[0];
		}
		int count = list.Count;
		int num = UnityEngine.Random.Range(0, count);
		if (list.ElementAt(num).Equals(excludedElement))
		{
			if (num > 0)
			{
				num--;
			}
			else
			{
				num++;
				if (num >= count)
				{
					return default(T);
				}
			}
		}
		return list.ElementAt(num);
	}

	public static T GetRandomElement<T>(this T[] array, T excludedElement)
	{
		if (array == null || array.Length == 0)
		{
			return default(T);
		}
		if (array.Length == 1)
		{
			return array[0];
		}
		List<T> list = new List<T>(array);
		if (list.Contains(excludedElement))
		{
			list.Remove(excludedElement);
		}
		return list[UnityEngine.Random.Range(0, list.Count)];
	}

	public static T GetRandomElement<T>(this IList<T> list, IEnumerable<T> excludedElements)
	{
		if (list == null)
		{
			return default(T);
		}
		IEnumerable<T> source = list.Except(excludedElements);
		return source.ElementAt(UnityEngine.Random.Range(0, source.Count()));
	}

	public static List<T> GetRandomElements<T>(this IEnumerable<T> list, int amount)
	{
		if (list == null)
		{
			return new List<T>();
		}
		List<T> list2 = new List<T>(list);
		list2.Shuffle();
		return list2.Take(amount).ToList();
	}

	public static List<T> GetRandomElements<T>(this IEnumerable<T> list, int amount, T excludedElement)
	{
		if (list == null)
		{
			return new List<T>();
		}
		List<T> list2 = new List<T>(list);
		if (list2.Contains(excludedElement))
		{
			list2.Remove(excludedElement);
		}
		list2.Shuffle();
		return list2.Take(amount).ToList();
	}

	public static List<T> GetRandomElements<T>(this IEnumerable<T> list, int amount, IEnumerable<T> excludedElements)
	{
		if (list == null)
		{
			return new List<T>();
		}
		T[] array = list.Except(excludedElements).ToArray();
		array.Shuffle();
		return array.Take(amount).ToList();
	}

	public static KeyValuePair<TK, TV> GetRandomElement<TK, TV>(this IDictionary<TK, TV> dictionary)
	{
		if (dictionary == null)
		{
			throw new NullReferenceException("Source dictionary is null.");
		}
		return dictionary.ElementAt(UnityEngine.Random.Range(0, dictionary.Count));
	}

	public static List<T> Exclude<T>(this List<T> list, T excludedElement)
	{
		if (list == null)
		{
			return null;
		}
		if (excludedElement == null)
		{
			return list;
		}
		List<T> list2 = new List<T>(list);
		if (list2.Contains(excludedElement))
		{
			list2.Remove(excludedElement);
		}
		return list2;
	}

	public static List<T> Exclude<T>(this IEnumerable<T> enumerable, T excludedElement)
	{
		if (enumerable == null)
		{
			return null;
		}
		if (excludedElement == null)
		{
			return enumerable.ToList();
		}
		List<T> list = new List<T>(enumerable);
		if (list.Contains(excludedElement))
		{
			list.Remove(excludedElement);
		}
		return list;
	}

	public static bool IsEmpty<T>(this IEnumerable<T> list)
	{
		return list.Count() == 0;
	}

	public static bool IsNullOrEmpty<T>(this ICollection<T> collection)
	{
		return collection == null || collection.Count == 0;
	}

	public static bool IsNullOrEmpty<T>(this IEnumerable<T> collection)
	{
		return collection == null || collection.Count() == 0;
	}

	public static bool IsNullOrEmpty(this string text)
	{
		return string.IsNullOrEmpty(text);
	}

	public static string ToFormattedString<T>(this IList<T> collection)
	{
		StringBuilder stringBuilder = new StringBuilder();
		int num = 0;
		int count = collection.Count;
		foreach (T item in collection)
		{
			stringBuilder.Append(item);
			if (num < count - 1)
			{
				stringBuilder.Append(", ");
			}
			num++;
		}
		return stringBuilder.ToString();
	}

	public static string ToFormattedString<T, K>(this IDictionary<T, K> collection)
	{
		StringBuilder stringBuilder = new StringBuilder();
		int num = 0;
		int count = collection.Count;
		foreach (KeyValuePair<T, K> item in collection)
		{
			stringBuilder.Append("[");
			stringBuilder.Append(item.Key);
			stringBuilder.Append(", ");
			stringBuilder.Append(item.Value);
			stringBuilder.Append("]");
			if (num < count - 1)
			{
				stringBuilder.Append(", ");
			}
			num++;
		}
		return stringBuilder.ToString();
	}

	public static bool AddRange<T>(this HashSet<T> set, IEnumerable<T> range)
	{
		bool result = true;
		foreach (T item in range)
		{
			if (!set.Add(item))
			{
				result = false;
			}
		}
		return result;
	}

	public static void QuickSort<T>(this T[] arr) where T : IComparable
	{
		arr.QuickSort(0, arr.Length - 1);
	}

	public static void QuickSort<T>(this T[] arr, int left, int right) where T : IComparable
	{
		if (left < right)
		{
			int num = QuickSortPartition(arr, left, right);
			if (num > 1)
			{
				arr.QuickSort(left, num - 1);
			}
			if (num + 1 < right)
			{
				arr.QuickSort(num + 1, right);
			}
		}
	}

	public static void QuickSort<T1, T2>(this T1[] arr, Func<T1, T2> valueGetter) where T2 : IComparable
	{
		arr.QuickSort(0, arr.Length - 1, valueGetter);
	}

	public static void QuickSort<T1, T2>(this T1[] arr, int left, int right, Func<T1, T2> valueGetter) where T2 : IComparable
	{
		if (left < right)
		{
			int num = QuickSortPartition(arr, left, right, valueGetter);
			if (num > 1)
			{
				arr.QuickSort(left, num - 1, valueGetter);
			}
			if (num + 1 < right)
			{
				arr.QuickSort(num + 1, right, valueGetter);
			}
		}
	}

	public static void QuickSortDescending<T>(this T[] arr) where T : IComparable
	{
		arr.QuickSortDescending(0, arr.Length - 1);
	}

	public static void QuickSortDescending<T>(this T[] arr, int left, int right) where T : IComparable
	{
		if (left < right)
		{
			int num = QuickSortPartitionDescending(arr, left, right);
			if (num > 1)
			{
				arr.QuickSortDescending(left, num - 1);
			}
			if (num + 1 < right)
			{
				arr.QuickSortDescending(num + 1, right);
			}
		}
	}

	public static void QuickSortDescending<T1, T2>(this T1[] arr, Func<T1, T2> valueGetter) where T2 : IComparable
	{
		arr.QuickSortDescending(0, arr.Length - 1, valueGetter);
	}

	public static void QuickSortDescending<T1, T2>(this T1[] arr, int left, int right, Func<T1, T2> valueGetter) where T2 : IComparable
	{
		if (left < right)
		{
			int num = QuickSortPartitionDescending(arr, left, right, valueGetter);
			if (num > 1)
			{
				arr.QuickSortDescending(left, num - 1, valueGetter);
			}
			if (num + 1 < right)
			{
				arr.QuickSortDescending(num + 1, right, valueGetter);
			}
		}
	}

	private static int QuickSortPartition<T1, T2>(T1[] arr, int left, int right, Func<T1, T2> valueGetter) where T2 : IComparable
	{
		T2 val = valueGetter(arr[left]);
		while (true)
		{
			if (valueGetter(arr[left]).CompareTo(val) < 0)
			{
				left++;
				continue;
			}
			while (valueGetter(arr[right]).CompareTo(val) > 0)
			{
				right--;
			}
			if (left >= right)
			{
				break;
			}
			if (valueGetter(arr[right]).CompareTo(valueGetter(arr[left])) == 0)
			{
				return right;
			}
			T1 val2 = arr[right];
			arr[right] = arr[left];
			arr[left] = val2;
		}
		return right;
	}

	private static int QuickSortPartition<T>(T[] arr, int left, int right) where T : IComparable
	{
		T val = arr[left];
		while (true)
		{
			if (arr[left].CompareTo(val) < 0)
			{
				left++;
				continue;
			}
			while (arr[right].CompareTo(val) > 0)
			{
				right--;
			}
			if (left >= right)
			{
				break;
			}
			if (arr[right].CompareTo(arr[left]) == 0)
			{
				return right;
			}
			T val2 = arr[right];
			arr[right] = arr[left];
			arr[left] = val2;
		}
		return right;
	}

	private static int QuickSortPartitionDescending<T1, T2>(T1[] arr, int left, int right, Func<T1, T2> valueGetter) where T2 : IComparable
	{
		T2 val = valueGetter(arr[left]);
		while (true)
		{
			if (valueGetter(arr[left]).CompareTo(val) > 0)
			{
				left++;
				continue;
			}
			while (valueGetter(arr[right]).CompareTo(val) < 0)
			{
				right--;
			}
			if (left >= right)
			{
				break;
			}
			if (valueGetter(arr[right]).CompareTo(valueGetter(arr[left])) == 0)
			{
				return right;
			}
			T1 val2 = arr[right];
			arr[right] = arr[left];
			arr[left] = val2;
		}
		return right;
	}

	private static int QuickSortPartitionDescending<T>(T[] arr, int left, int right) where T : IComparable
	{
		T val = arr[left];
		while (true)
		{
			if (arr[left].CompareTo(val) > 0)
			{
				left++;
				continue;
			}
			while (arr[right].CompareTo(val) < 0)
			{
				right--;
			}
			if (left >= right)
			{
				break;
			}
			if (arr[right].CompareTo(arr[left]) == 0)
			{
				return right;
			}
			T val2 = arr[right];
			arr[right] = arr[left];
			arr[left] = val2;
		}
		return right;
	}

	public static void Shuffle<T>(this IList<T> arr)
	{
		arr.Shuffle(0, arr.Count - 1);
	}

	public static void Shuffle<T>(this IList<T> arr, int left, int right)
	{
		while (left <= right)
		{
			T value = arr[left];
			int index = UnityEngine.Random.Range(left, right + 1);
			arr[left] = arr[index];
			arr[index] = value;
			left++;
		}
	}

	public static void Shuffle<T>(this T[] arr)
	{
		arr.Shuffle(0, arr.Length - 1);
	}

	public static void Shuffle<T>(this T[] arr, int left, int right)
	{
		while (left <= right)
		{
			T val = arr[left];
			int num = UnityEngine.Random.Range(left, right + 1);
			arr[left] = arr[num];
			arr[num] = val;
			left++;
		}
	}
}
namespace Assets.Scripts.Utils
{
	public class CustomWaitForSeconds : CustomYieldInstruction
	{
		private float m_waitTime;

		private float m_currentWaitTime;

		private float m_lastUpdate = -1f;

		public override bool keepWaiting
		{
			get
			{
				if (GameControl.Instance.IsGamePaused)
				{
					return true;
				}
				float timeSinceLevelLoad = Time.timeSinceLevelLoad;
				if (timeSinceLevelLoad > m_lastUpdate)
				{
					m_lastUpdate = timeSinceLevelLoad;
					m_currentWaitTime += Time.deltaTime;
				}
				if (m_currentWaitTime >= m_waitTime)
				{
					m_currentWaitTime = 0f;
					m_lastUpdate = -1f;
					return false;
				}
				return true;
			}
		}

		public CustomWaitForSeconds(float waitTime)
		{
			m_waitTime = waitTime;
		}
	}
	public class EffectUtils
	{
		private readonly Dictionary<EffectType, ParticleAudioEffect> m_effects = new Dictionary<EffectType, ParticleAudioEffect>();

		public GameObject[] LoadedEffects { get; private set; } = new GameObject[8];


		public void PreloadEffects()
		{
			for (int i = 0; i < 8; i++)
			{
				GameObject[] loadedEffects = LoadedEffects;
				int num = i;
				EffectType effectType = (EffectType)i;
				loadedEffects[num] = GameObjectLoader.GetGameObject(AssetBundleType.VFX, effectType.ToString());
			}
		}

		public void DestroyAllEffects()
		{
			if (m_effects.IsNullOrEmpty())
			{
				return;
			}
			foreach (KeyValuePair<EffectType, ParticleAudioEffect> effect in m_effects)
			{
				UnityEngine.Object.Destroy(effect.Value.GameObject);
			}
			m_effects.Clear();
		}

		public void SetCameraEffectActive(EffectType type, bool active, Transform cameraTransform)
		{
			if (m_effects.TryGetValue(type, out var value))
			{
				value.SetEmittersActive(active);
				value.TrySetAudioActive(active);
			}
			else if (CanInstantiateNewEffect(type, cameraTransform))
			{
				SetCameraEffectActive(type, active, cameraTransform);
			}
		}

		public void SetEffectActive(EffectType type, bool active, Transform parent)
		{
			if (m_effects.TryGetValue(type, out var value))
			{
				value.SetEmittersActive(active);
				value.TrySetAudioActive(active);
				return;
			}
			if (parent == null)
			{
				WandsLogger.Log("Intended parent is null, Origo here I come!", LogType.Warning);
			}
			if (CanInstantiateNewEffect(type, parent))
			{
				SetEffectActive(type, active, parent);
			}
		}

		private bool CanInstantiateNewEffect(EffectType type, Transform parent)
		{
			GameObject gameObject = LoadedEffects[(int)type];
			if (gameObject == null)
			{
				return false;
			}
			GameObject gameObject2 = UnityEngine.Object.Instantiate(gameObject, parent);
			gameObject2.transform.localPosition = Vector3.zero;
			gameObject2.transform.localRotation = Quaternion.identity;
			m_effects.Add(type, new ParticleAudioEffect(gameObject2, gameObject2.GetComponent<AudioSource>(), gameObject2.GetComponentsInChildren<ParticleSystem>()));
			return true;
		}
	}
	[Serializable]
	public class ParticleAudioEffect
	{
		public GameObject GameObject;

		public AudioSource Audio;

		public ParticleSystem[] Particles;

		public ParticleAudioEffect(GameObject gameObject, AudioSource audioSource, params ParticleSystem[] particles)
		{
			GameObject = gameObject;
			Audio = audioSource;
			Particles = particles;
		}

		public void SetEmittersActive(bool active)
		{
			ParticleSystem[] particles = Particles;
			foreach (ParticleSystem particleSystem in particles)
			{
				if (active)
				{
					particleSystem.Play();
				}
				else
				{
					particleSystem.Stop();
				}
			}
		}

		public void TrySetAudioActive(bool active)
		{
			if (Audio != null)
			{
				SetAudioActive(active);
			}
		}

		private void SetAudioActive(bool active)
		{
			Audio.DOKill();
			if (active)
			{
				Audio.DOFade(0.85f, 0.5f).OnStart(delegate
				{
					Audio.Play();
				});
			}
			else
			{
				Audio.DOFade(0f, 0.5f).OnComplete(delegate
				{
					Audio.Stop();
				});
			}
		}
	}
	public static class EloUtils
	{
		private const int SeasonScoreKFactor = 10;

		public static bool ShouldAffectRating
		{
			get
			{
				if (SeasonControl.SeasonLocked)
				{
					return false;
				}
				if (GameControl.Instance.PlatformSettings.EnableScoreFromBotMatches)
				{
					return RoomProperty.GetMatchType().ContainsFlag(MatchType.Competitive | MatchType.Bot);
				}
				return RoomProperty.GetMatchType().ContainsFlag(MatchType.Competitive);
			}
		}

		public static bool ShouldAffectCustomEventRating
		{
			get
			{
				if (GameControl.Instance.PlatformSettings.EnableScoreFromBotMatches)
				{
					return RoomProperty.GetMatchType().ContainsFlag(MatchType.Competitive | MatchType.Bot);
				}
				return RoomProperty.GetMatchType().ContainsFlag(MatchType.Competitive);
			}
		}

		public static bool GetRatingDiffTooHigh(int rating, int diff)
		{
			if (rating >= 2400)
			{
				return diff >= 597;
			}
			if (rating >= 2100)
			{
				return diff >= 669;
			}
			return diff >= 720;
		}

		public static int GetKFactor(int rating)
		{
			if (rating >= 2400)
			{
				return 16;
			}
			if (rating >= 2100)
			{
				return 24;
			}
			return 32;
		}

		public static int[] GetSeasonScoreChange(EndState endState, int[] eloRatings)
		{
			return GetEloChange(endState, eloRatings, 10, 10);
		}

		public static int[] GetEloChange(EndState endState, int[] eloRatings, int kFactorP, int kFactorO)
		{
			int num = eloRatings[0];
			int num2 = eloRatings[1];
			float num3 = Mathf.Pow(10f, (float)num / 400f);
			float num4 = Mathf.Pow(10f, (float)num2 / 400f);
			float num5 = num3 / (num3 + num4);
			float num6 = num4 / (num3 + num4);
			float num7 = 0.5f;
			float num8 = 0.5f;
			switch (endState)
			{
			case EndState.Won:
				num7 = 1f;
				num8 = 0f;
				break;
			case EndState.Lost:
			case EndState.ForceLost:
				num7 = 0f;
				num8 = 1f;
				break;
			}
			int num9 = Mathf.Clamp(Mathf.RoundToInt((float)kFactorP * (num7 - num5)), -kFactorP, kFactorP);
			int num10 = Mathf.Clamp(Mathf.RoundToInt((float)kFactorO * (num8 - num6)), -kFactorO, kFactorO);
			return new int[2] { num9, num10 };
		}
	}
	public static class EnumExtensions
	{
		public static bool IsObsolete(this Enum @enum)
		{
			return HasAttribute<ObsoleteAttribute>(@enum);
		}

		private static bool HasAttribute<TAttribute>(Enum @enum) where TAttribute : Attribute
		{
			Type type = @enum.GetType();
			return Attribute.IsDefined(type.GetField(@enum.ToString()), typeof(TAttribute));
		}
	}
}
namespace Assets.Scripts.Utils.FinalIK
{
	public class CustomJointConstraint : MonoBehaviour
	{
		[SerializeField]
		private Transform m_parentJoint;

		[SerializeField]
		private Transform m_childJoint;

		[SerializeField]
		private float m_positionLerpStrength;

		[SerializeField]
		private float m_rotationLerpStrength;

		private Vector3 m_childPositionOffset;

		private Quaternion m_childRotationOffset;

		private Quaternion m_parentRotationOffset;

		private Matrix4x4 m_parentMatrix;

		private void Awake()
		{
			Initialize();
		}

		private void Update()
		{
			ConstrainJoint();
		}

		private void Initialize()
		{
			m_childPositionOffset = DivideVectors(Quaternion.Inverse(m_parentJoint.rotation) * (m_childJoint.position - m_parentJoint.position), m_parentJoint.lossyScale);
			m_childRotationOffset = m_childJoint.rotation;
			m_parentRotationOffset = m_parentJoint.rotation;
		}

		private void ConstrainJoint()
		{
			m_parentMatrix = Matrix4x4.TRS(m_parentJoint.position, m_parentJoint.rotation, m_parentJoint.lossyScale);
			Vector3 vector = m_parentMatrix.MultiplyPoint3x4(m_childPositionOffset);
			Quaternion b = m_parentJoint.rotation * Quaternion.Inverse(m_parentRotationOffset) * m_childRotationOffset;
			float num = Quaternion.Angle(m_childJoint.rotation, b) * m_rotationLerpStrength;
			float num2 = Vector3.Magnitude(vector - m_childJoint.position) * m_positionLerpStrength;
			m_childJoint.position = Vector3.Lerp(m_childJoint.position, vector, Time.deltaTime * num2);
			m_childJoint.rotation = Quaternion.Slerp(m_childJoint.rotation, b, Time.deltaTime * num);
		}

		private Vector3 DivideVectors(Vector3 num, Vector3 den)
		{
			return new Vector3(num.x / den.x, num.y / den.y, num.z / den.z);
		}
	}
	public class CustomScaleAnimation : MonoBehaviour
	{
		[SerializeField]
		private float m_animSpeed;

		[SerializeField]
		private float m_animTimeOffest;

		[SerializeField]
		private AnimationCurve m_scaleDeltaAnimation;

		private Vector3 m_startingScale;

		private float m_animCurveOutTime;

		private float m_animcurveInTime;

		private float m_elapsedTime;

		private void Awake()
		{
			InitilizeScaler();
		}

		private void Update()
		{
			ScaleAnimation();
		}

		private void InitilizeScaler()
		{
			m_startingScale = base.transform.localScale;
			m_animcurveInTime = m_scaleDeltaAnimation.keys[0].time;
			m_animCurveOutTime = m_scaleDeltaAnimation.keys[m_scaleDeltaAnimation.length - 1].time;
			m_elapsedTime += m_animTimeOffest;
		}

		private void ScaleAnimation()
		{
			m_elapsedTime = Time.deltaTime * m_animSpeed + m_elapsedTime;
			if (m_elapsedTime > m_animCurveOutTime)
			{
				ResetAnimationLoop();
			}
			base.transform.localScale = m_scaleDeltaAnimation.Evaluate(m_elapsedTime) * m_startingScale + m_startingScale;
		}

		private void ResetAnimationLoop()
		{
			m_elapsedTime -= m_animCurveOutTime - m_animcurveInTime;
			if (m_elapsedTime > m_animCurveOutTime)
			{
				ResetAnimationLoop();
			}
		}
	}
	public class PostUpdateLimits : MonoBehaviour
	{
		[SerializeField]
		private VRIK m_vrIK;

		[SerializeField]
		private RotationLimit[] m_limits;

		private void OnValidate()
		{
			m_limits = m_vrIK.GetComponentsInChildren<RotationLimit>();
		}

		private void Start()
		{
			RotationLimit[] limits = m_limits;
			foreach (RotationLimit rotationLimit in limits)
			{
				rotationLimit.Disable();
			}
		}

		private void OnEnable()
		{
			IKSolver iKSolver = m_vrIK.GetIKSolver();
			iKSolver.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Combine(iKSolver.OnPostUpdate, new IKSolver.UpdateDelegate(OnIKPostUpdate));
		}

		private void OnDisable()
		{
			IKSolver iKSolver = m_vrIK.GetIKSolver();
			iKSolver.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Remove(iKSolver.OnPostUpdate, new IKSolver.UpdateDelegate(OnIKPostUpdate));
		}

		private void OnIKPostUpdate()
		{
			RotationLimit[] limits = m_limits;
			foreach (RotationLimit rotationLimit in limits)
			{
				rotationLimit.Apply();
			}
		}
	}
	public class VRIKDynamicHeight : MonoBehaviour
	{
		[Header("Height Data")]
		[SerializeField]
		private float m_defaultHeadHeight;

		[SerializeField]
		private float m_crouchHeadHeight;

		[SerializeField]
		private AnimationCurve m_heightWeightCurve;

		[Header("Feet Stance Width")]
		[SerializeField]
		private Vector2 m_feetWidthRange;

		[Header("Arm Swivel Offset")]
		[SerializeField]
		private Vector2 m_leftArmSwivelRange;

		[SerializeField]
		private Vector2 m_rightArmSwivelRange;

		[SerializeField]
		private Vector2 m_leftLegSwivelRange;

		[SerializeField]
		private Vector2 m_rightLegSwivelRange;

		[Header("Leaning")]
		[SerializeField]
		private Vector2 m_comAngleRange;

		private VRIK m_vrikSolver;

		private Transform m_headJoint;

		private Transform m_rootJoint;

		public void SetArmSwivelRange(Vector2 leftArm, Vector2 rightArm)
		{
			m_leftArmSwivelRange = leftArm;
			m_rightArmSwivelRange = rightArm;
		}

		private void Awake()
		{
			InitilizeVRIKController(GetComponent<VRIK>());
		}

		private void Update()
		{
			if (m_vrikSolver != null && m_vrikSolver.enabled)
			{
				FeetWidthHandler();
			}
		}

		private void InitilizeVRIKController(VRIK VRIKSolver)
		{
			m_vrikSolver = VRIKSolver;
			m_headJoint = VRIKSolver.references.head;
			m_rootJoint = VRIKSolver.references.root;
		}

		private void FeetWidthHandler()
		{
			float value = m_headJoint.position.y - m_rootJoint.position.y;
			float time = Mathf.InverseLerp(m_crouchHeadHeight, m_defaultHeadHeight, value);
			time = m_heightWeightCurve.Evaluate(time);
			m_vrikSolver.solver.locomotion.footDistance = Mathf.Lerp(m_feetWidthRange.x, m_feetWidthRange.y, time);
			m_vrikSolver.solver.locomotion.comAngleMlp = Mathf.Lerp(m_comAngleRange.x, m_comAngleRange.y, time);
			m_vrikSolver.solver.leftArm.swivelOffset = Mathf.Lerp(m_leftArmSwivelRange.x, m_leftArmSwivelRange.y, time);
			m_vrikSolver.solver.rightArm.swivelOffset = Mathf.Lerp(m_rightArmSwivelRange.x, m_rightArmSwivelRange.y, time);
			m_vrikSolver.solver.leftLeg.swivelOffset = Mathf.Lerp(m_leftLegSwivelRange.x, m_leftLegSwivelRange.y, time);
			m_vrikSolver.solver.rightLeg.swivelOffset = Mathf.Lerp(m_rightLegSwivelRange.x, m_rightLegSwivelRange.y, time);
		}
	}
}
namespace Assets.Scripts.Utils
{
	public class FontUtils
	{
		private static string sm_path = "Fonts/";

		private static string sm_westernStandard = "Brawler";

		private static string sm_chineseStandard = "ch_SourceHanSans-Bold";

		private static string sm_japaneseStandard = "jp_AozoraMinchoMedium";

		private static string sm_koreanStandard = "ko_batang";

		private static string sm_hindiStandard = "hi_adobe-devanagari_844";

		public static Font GetStandardFont(Language language)
		{
			string path = sm_path + sm_westernStandard;
			switch (language)
			{
			case Language.Chinese:
				path = sm_path + sm_chineseStandard;
				break;
			case Language.Japanese:
				path = sm_path + sm_japaneseStandard;
				break;
			case Language.Korean:
				path = sm_path + sm_koreanStandard;
				break;
			case Language.Hindi:
				path = sm_path + sm_hindiStandard;
				break;
			}
			if ((bool)Resources.Load(path))
			{
				return (Font)Resources.Load(path);
			}
			WandsLogger.LogFormat(LogType.Error, "Couldn't find standard font for language {0}, make sure the font has been added to Resources!", language);
			return null;
		}
	}
	public static class GameObjectLoader
	{
		public static GameObject GetGameObject(AssetBundleType type, string path)
		{
			GameObject gameObject = Resources.Load<GameObject>(path);
			return (!(gameObject != null)) ? GameControl.Instance.AssetHandler.LoadAsset<GameObject>(type, path) : gameObject;
		}

		public static void GetGameObjectAsync(AssetBundleType type, string path, Action<GameObject> onLoaded)
		{
			AssetBundleRequest request = GameControl.Instance.AssetHandler.LoadAssetAsync<GameObject>(type, path);
			if (request == null)
			{
				onLoaded(null);
				return;
			}
			request.completed += delegate
			{
				onLoaded(request.asset as GameObject);
			};
		}
	}
	public class GameObjectPool : ObjectPool<GameObject>
	{
		private GameObject m_prefab;

		private GameObject m_poolContainerObject;

		public GameObjectPool(GameObject prefab, int capacity)
			: this(prefab, capacity, 0)
		{
		}

		public GameObjectPool(GameObject prefab, int capacity, int preAllocateAmount)
			: this(prefab, capacity, preAllocateAmount, new GameObject(prefab.name + " Pool"))
		{
		}

		public GameObjectPool(GameObject prefab, int capacity, int preAllocateAmount, GameObject parent)
		{
			m_prefab = prefab;
			m_poolContainerObject = parent;
			Initialize(capacity, preAllocateAmount);
		}

		protected override GameObject AllocateObject()
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(m_prefab);
			AssetMaterialChanger component = gameObject.GetComponent<AssetMaterialChanger>();
			if (component != null)
			{
				component.ChangeMaterials();
				UnityEngine.Object.Destroy(component);
			}
			gameObject.SetActive(value: false);
			return gameObject;
		}

		public override GameObject Borrow(bool forceCreate = false)
		{
			GameObject gameObject = base.Borrow(forceCreate);
			gameObject.SetActive(value: true);
			return gameObject;
		}

		public override void Return(GameObject obj)
		{
			obj.SetActive(value: false);
			base.Return(obj);
		}

		public override void Dispose()
		{
			if (m_poolContainerObject != null)
			{
				UnityEngine.Object.Destroy(m_poolContainerObject);
				m_poolContainerObject = null;
			}
		}

		protected override void OnBorrowed(GameObject borrowedObject)
		{
			borrowedObject.transform.SetParent(null);
		}

		protected override void OnReturned(GameObject returnedObject)
		{
			returnedObject.transform.SetParent(((object)m_poolContainerObject != null) ? m_poolContainerObject.transform : null, worldPositionStays: false);
		}

		protected override void OnUnableToReturn(GameObject returnedObject)
		{
			if (returnedObject != null)
			{
				UnityEngine.Object.Destroy(returnedObject);
				returnedObject = null;
			}
		}
	}
	public interface IObjectPool
	{
		bool IsPoolEmpty { get; }

		bool IsPoolFull { get; }
	}
	public class ItemMaterialHandler : MonoBehaviour
	{
		[Tooltip("Default | Locked")]
		[SerializeField]
		private Material[] m_itemMaterials;

		[SerializeField]
		private Material[] m_highlightedItemMaterials;

		[SerializeField]
		private Renderer[] m_renderers;

		private EventToken m_assetBundlesLoadedToken;

		private void Awake()
		{
			if (!m_itemMaterials.IsNullOrEmpty())
			{
				if (GameControl.Instance.AssetHandler.HasLoaded)
				{
					OnAssetBundlesLoaded(null);
				}
				else
				{
					m_assetBundlesLoadedToken = EventHub.Subscribe<Events.AssetBundlesLoadedEvent>(OnAssetBundlesLoaded);
				}
			}
		}

		private void OnAssetBundlesLoaded(Events.AssetBundlesLoadedEvent eventData)
		{
			m_itemMaterials = GameControl.Instance.AssetHandler.ReplaceMaterials(m_itemMaterials);
			m_highlightedItemMaterials = GameControl.Instance.AssetHandler.ReplaceMaterials(m_highlightedItemMaterials);
			AssignMaterial(ItemMaterialType.Default, highlighted: false);
			if (m_assetBundlesLoadedToken != null)
			{
				EventHub.Unsubscribe<Events.AssetBundlesLoadedEvent>(m_assetBundlesLoadedToken);
				m_assetBundlesLoadedToken = null;
			}
		}

		public void AssignRenderers(Renderer[] renderers)
		{
			m_renderers = renderers;
		}

		public void AssignMaterial(ItemMaterialType type, bool highlighted)
		{
			Material[] array = ((!highlighted) ? m_itemMaterials : m_highlightedItemMaterials);
			if (m_renderers.IsNullOrEmpty() || array.IsNullOrEmpty())
			{
				return;
			}
			Renderer[] renderers = m_renderers;
			foreach (Renderer renderer in renderers)
			{
				if (renderer.sharedMaterial.name != array[(int)type].name)
				{
					renderer.sharedMaterial = array[(int)type];
				}
			}
		}
	}
}
namespace Assets.Scripts.Utils.Json
{
	public class PlayFabJsonObjectConverter : JsonConverter
	{
		private readonly Type m_ConversionType = typeof(JsonObject);

		public override bool CanRead
		{
			[CompilerGenerated]
			get
			{
				return false;
			}
		}

		public override void WriteJson(Newtonsoft.Json.JsonWriter writer, object value, JsonSerializer serializer)
		{
			JsonObject jsonObject = (JsonObject)value;
			writer.WriteRawValue(jsonObject.ToString());
		}

		public override object ReadJson(Newtonsoft.Json.JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
		{
			throw new NotImplementedException();
		}

		public override bool CanConvert(Type objectType)
		{
			return objectType == m_ConversionType;
		}
	}
}
public static class JsonExtensions
{
	public static string ToJson<T>(this T t)
	{
		return JsonConvert.SerializeObject(t);
	}
}
public class MathUtils
{
	public static Vector3 GetMidPoint(Transform startTf, Transform endTf)
	{
		return GetMidPoint(startTf.position, endTf.position);
	}

	public static Vector3 GetMidPoint(Vector3 start, Vector3 end)
	{
		return Vector3.Lerp(start, end, 0.5f);
	}

	public static Vector3 GetMidPoint(Vector3 start, Vector3 end, out float distance)
	{
		distance = Vector3.Distance(start, end);
		return new Vector3((start.x + end.x) / 2f, (start.y + end.y) / 2f, (start.z + end.z) / 2f);
	}

	public static float Distance2D(Vector3 target, Vector3 origin)
	{
		Vector3 vector = target - origin;
		vector.y = 0f;
		return Vector3.Magnitude(vector);
	}

	public static float PingPong(float aValue, float aMin, float aMax)
	{
		return Mathf.PingPong(aValue, aMax - aMin) + aMin;
	}

	public static float EaseOut(float t)
	{
		return Mathf.Sin(t * (float)Math.PI * 0.5f);
	}

	public static float EaseIn(float t)
	{
		return 1f - Mathf.Cos(t * (float)Math.PI * 0.5f);
	}

	public static float SmoothStep(float t)
	{
		return t * t * (3f - 2f * t);
	}

	public static float SmootherStep(float t)
	{
		return t * t * t * (t * (6f * t - 15f) + 10f);
	}

	public static float RoundToNearestHalf(float a)
	{
		return a -= a % 0.5f;
	}

	public static float SnapTo(float a, float snap)
	{
		return Mathf.Round(a / snap) * snap;
	}
}
[Serializable]
public struct MinMax
{
	public float Min;

	public float Max;

	public MinMax(float min, float max)
	{
		Min = min;
		Max = max;
	}
}
namespace Assets.Scripts.Utils
{
	public class ObjectPool<T> : IObjectPool where T : class, new()
	{
		protected Stack<T> m_pool;

		protected int m_capacity;

		public bool IsPoolEmpty => m_pool.Count == 0;

		public bool IsPoolFull => m_pool.Count == m_capacity;

		protected void Initialize(int capacity, int preAllocateAmount)
		{
			if (capacity < 1)
			{
				WandsLogger.Log("Capacity must be at least one(1)", LogType.Warning);
				capacity = 1;
			}
			m_pool = new Stack<T>(capacity);
			m_capacity = capacity;
			if (preAllocateAmount > capacity)
			{
				WandsLogger.Log("PreAllocateAmount cannot be higher than capacity", LogType.Warning);
				preAllocateAmount = capacity;
			}
			Allocate(preAllocateAmount);
		}

		public void Allocate(int amount)
		{
			for (int i = 0; i < amount; i++)
			{
				if (IsPoolFull)
				{
					break;
				}
				AddObject();
			}
		}

		private void AddObject()
		{
			if (IsPoolFull)
			{
				WandsLogger.Log("Cannot addObject, pool is already full", LogType.Warning);
				return;
			}
			T val = AllocateObject();
			m_pool.Push(val);
			OnReturned(val);
		}

		public virtual T Borrow(bool forceCreate = false)
		{
			T val = (T)null;
			if (IsPoolEmpty)
			{
				if (forceCreate)
				{
					val = AllocateObject();
				}
			}
			else
			{
				val = m_pool.Pop();
			}
			OnBorrowed(val);
			return val;
		}

		public virtual void Return(T obj)
		{
			if (IsPoolFull)
			{
				WandsLogger.Log("Pool is full, failed returning object", LogType.Warning);
				OnUnableToReturn(obj);
			}
			else
			{
				m_pool.Push(obj);
				OnReturned(obj);
			}
		}

		protected virtual T AllocateObject()
		{
			return new T();
		}

		public virtual void Dispose()
		{
		}

		protected virtual void OnBorrowed(T borrowedObject)
		{
		}

		protected virtual void OnReturned(T returnedObject)
		{
		}

		protected virtual void OnUnableToReturn(T returnedObject)
		{
		}
	}
	public static class PhysicsExtensions
	{
		public static bool CapsuleCast(this CapsuleCollider capsule, Vector3 direction, out RaycastHit hitInfo, float maxDistance = float.PositiveInfinity, int layerMask = -5, QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.UseGlobal)
		{
			capsule.ToWorldSpaceCapsule(out var point, out var point2, out var radius);
			return Physics.CapsuleCast(point, point2, radius, direction, out hitInfo, maxDistance, layerMask, queryTriggerInteraction);
		}

		public static Collider[] OverlapCapsule(this CapsuleCollider capsule, int layerMask = -5, QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.UseGlobal)
		{
			capsule.ToWorldSpaceCapsule(out var point, out var point2, out var radius);
			return Physics.OverlapCapsule(point, point2, radius, layerMask, queryTriggerInteraction);
		}

		public static int OverlapCapsuleNonAlloc(this CapsuleCollider capsule, Collider[] results, int layerMask = -5, QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.UseGlobal)
		{
			capsule.ToWorldSpaceCapsule(out var point, out var point2, out var radius);
			return Physics.OverlapCapsuleNonAlloc(point, point2, radius, results, layerMask, queryTriggerInteraction);
		}

		public static void ToWorldSpaceCapsule(this CapsuleCollider capsule, out Vector3 point0, out Vector3 point1, out float radius)
		{
			Vector3 vector = capsule.transform.TransformPoint(capsule.center);
			radius = 0f;
			float num = 0f;
			Vector3 vector2 = new Vector3(Mathf.Abs(capsule.transform.lossyScale.x), Mathf.Abs(capsule.transform.lossyScale.y), Mathf.Abs(capsule.transform.lossyScale.z));
			Vector3 vector3 = Vector3.zero;
			switch (capsule.direction)
			{
			case 0:
				radius = Mathf.Max(vector2.y, vector2.z) * capsule.radius;
				num = vector2.x * capsule.height;
				vector3 = capsule.transform.TransformDirection(Vector3.right);
				break;
			case 1:
				radius = Mathf.Max(vector2.x, vector2.z) * capsule.radius;
				num = vector2.y * capsule.height;
				vector3 = capsule.transform.TransformDirection(Vector3.up);
				break;
			case 2:
				radius = Mathf.Max(vector2.x, vector2.y) * capsule.radius;
				num = vector2.z * capsule.height;
				vector3 = capsule.transform.TransformDirection(Vector3.forward);
				break;
			}
			if (num < radius * 2f)
			{
				vector3 = Vector3.zero;
			}
			point0 = vector + vector3 * (num * 0.5f - radius);
			point1 = vector - vector3 * (num * 0.5f - radius);
		}
	}
	public class PlayerUtils
	{
		public static int LevelToNumberOfSpellUnlocks(int level)
		{
			IReadOnlyDictionary<int, ExperienceTableObject> experienceTable = PlayFabTitleData.GetExperienceTable();
			if (experienceTable.IsNullOrEmpty())
			{
				return 0;
			}
			int num = 0;
			foreach (KeyValuePair<int, ExperienceTableObject> item in experienceTable)
			{
				if (item.Key <= level)
				{
					num += item.Value.SpellTokenReward;
				}
			}
			return num + Constants.DefaultSpells.Count;
		}

		public static int LevelToXp(int level)
		{
			ExperienceTableObject experienceTableEntry = PlayFabTitleData.GetExperienceTableEntry(level);
			if (experienceTableEntry == null)
			{
				return int.MaxValue;
			}
			int num = level / 100 + 1;
			return experienceTableEntry.XPNeeded * num;
		}

		public static int LevelToDustReward(int level)
		{
			return PlayFabTitleData.GetExperienceTableEntry(level)?.DustReward ?? 0;
		}

		public static int LevelToSpellUnlocks(int level)
		{
			return PlayFabTitleData.GetExperienceTableEntry(level)?.SpellTokenReward ?? 0;
		}

		public static int LevelToLoadoutUnlocks(int level)
		{
			return PlayFabTitleData.GetExperienceTableEntry(level)?.LoadoutReward ?? 0;
		}

		public static int LevelToLoadouts(int level)
		{
			IReadOnlyDictionary<int, ExperienceTableObject> experienceTable = PlayFabTitleData.GetExperienceTable();
			if (experienceTable.IsNullOrEmpty())
			{
				return 0;
			}
			int num = (from p in experienceTable
				where p.Key <= level
				select p.Value.LoadoutReward).Sum();
			return num + 1;
		}

		public static RewardType LevelToReward(int level)
		{
			return (PlayFabTitleData.GetExperienceTableEntry(level).SpellTokenReward == 0) ? RewardType.Dust : RewardType.Spell;
		}

		public static RatingTitle RatingToTitle(int rating)
		{
			if (rating < 0)
			{
				return RatingTitle.Developer;
			}
			RatingTitle result = RatingTitle.GoatHerder;
			foreach (KeyValuePair<RatingTitle, int> ratingTitle in Constants.RatingTitles)
			{
				if (rating >= ratingTitle.Value)
				{
					result = ratingTitle.Key;
				}
			}
			return result;
		}

		public static int TitleToRating(RatingTitle title)
		{
			return Constants.RatingTitles[title];
		}

		public static void ConvertItemsToDust(JObject jObject)
		{
			JToken token = jObject["UnlockedMasks"];
			JToken token2 = jObject["UnlockedOutfits"];
			JToken token3 = jObject["UnlockedWands"];
			JToken token4 = jObject["UnlockedTitles"];
			ConversionResult conversionResult = ConvertMasks(token);
			ConversionResult conversionResult2 = ConvertOutfits(token2);
			ConversionResult conversionResult3 = ConvertWands(token3);
			ConversionResult conversionResult4 = ConvertTitles(token4);
			int amount = conversionResult.Dust + conversionResult2.Dust + conversionResult3.Dust + conversionResult4.Dust;
			List<Title> titles = conversionResult.Titles.Concat(conversionResult2.Titles).Concat(conversionResult3.Titles).Concat(conversionResult4.Titles)
				.ToList();
			GameControl.Instance.Player.AddVirtualCurrency(amount, VirtualCurrencySource.Conversion);
			GameControl.Instance.Player.TryAddTitlesToInventory(titles, saveToServer: true);
		}

		public static void ConvertItemsToDust(IDictionary<string, UserDataRecord> data)
		{
			JArray token = JArray.Parse(data["UnlockedMasks"].Value);
			JArray token2 = JArray.Parse(data["UnlockedOutfits"].Value);
			JArray token3 = JArray.Parse(data["UnlockedWands"].Value);
			ConversionResult conversionResult = ConvertMasks(token);
			ConversionResult conversionResult2 = ConvertOutfits(token2);
			ConversionResult conversionResult3 = ConvertWands(token3);
			int amount = conversionResult.Dust + conversionResult2.Dust + conversionResult3.Dust;
			List<Title> titles = conversionResult.Titles.Concat(conversionResult2.Titles).Concat(conversionResult3.Titles).ToList();
			GameControl.Instance.Player.AddVirtualCurrency(amount, VirtualCurrencySource.Conversion);
			GameControl.Instance.Player.TryAddTitlesToInventory(titles, saveToServer: true);
		}

		private static ConversionResult ConvertMasks(JToken token)
		{
			ConversionResult conversionResult = new ConversionResult();
			if (token != null)
			{
				List<Legacy_MaskType> list = token.ToObject<List<Legacy_MaskType>>();
				foreach (Legacy_MaskType item in list)
				{
					if (!WandsDatabase.LegacyItems.Masks.ContainsKey(item))
					{
						continue;
					}
					int num = WandsDatabase.LegacyItems.Masks[item];
					if (num >= 0)
					{
						conversionResult.Dust += num;
						continue;
					}
					switch (item)
					{
					case Legacy_MaskType.Vitis_1:
						conversionResult.Titles.Add(Title.SeasonTwoChampion);
						break;
					case Legacy_MaskType.Vitis_2:
						conversionResult.Titles.Add(Title.SeasonTwoTopTen);
						break;
					case Legacy_MaskType.Vitis_3:
						conversionResult.Titles.Add(Title.SeasonTwoTopHundred);
						break;
					}
				}
			}
			return conversionResult;
		}

		private static ConversionResult ConvertOutfits(JToken token)
		{
			ConversionResult conversionResult = new ConversionResult();
			if (token != null)
			{
				List<Legacy_OutfitType> list = token.ToObject<List<Legacy_OutfitType>>();
				foreach (Legacy_OutfitType item in list)
				{
					if (!WandsDatabase.LegacyItems.Outfits.ContainsKey(item))
					{
						continue;
					}
					int num = WandsDatabase.LegacyItems.Outfits[item];
					if (num >= 0)
					{
						conversionResult.Dust += num;
						continue;
					}
					switch (item)
					{
					case Legacy_OutfitType.Inquisitor_1:
						conversionResult.Titles.Add(Title.HolyAdjudicator);
						break;
					case Legacy_OutfitType.Inquisitor_2:
						conversionResult.Titles.Add(Title.HunterOfTheDamned);
						break;
					}
				}
			}
			return conversionResult;
		}

		private static ConversionResult ConvertWands(JToken token)
		{
			ConversionResult conversionResult = new ConversionResult();
			if (token != null)
			{
				List<Legacy_WandType> list = token.ToObject<List<Legacy_WandType>>();
				foreach (Legacy_WandType item in list)
				{
					if (!WandsDatabase.LegacyItems.Wands.ContainsKey(item))
					{
						continue;
					}
					int num = WandsDatabase.LegacyItems.Wands[item];
					if (num >= 0)
					{
						conversionResult.Dust += num;
						continue;
					}
					switch (item)
					{
					case Legacy_WandType.SnakeGold:
						conversionResult.Titles.Add(Title.SeasonThreeChampion);
						break;
					case Legacy_WandType.SnakeSilver:
						conversionResult.Titles.Add(Title.SeasonThreeTopTen);
						break;
					case Legacy_WandType.SnakeJade:
						conversionResult.Titles.Add(Title.SeasonThreeTopHundred);
						break;
					case Legacy_WandType.Invicta:
						conversionResult.Titles.Add(Title.SeasonFourTopTen);
						break;
					}
				}
			}
			return conversionResult;
		}

		private static ConversionResult ConvertTitles(JToken token)
		{
			ConversionResult conversionResult = new ConversionResult();
			if (token != null)
			{
				List<Title> list = token.ToObject<List<Title>>();
				foreach (Title item in list)
				{
					if (item > (Title)0)
					{
						conversionResult.Titles.Add(item);
					}
				}
			}
			return conversionResult;
		}
	}
}
namespace Assets.Scripts.Spells.Utils
{
	public class PoolObject : MonoBehaviourPun, IPunInstantiateMagicCallback, IPoolObject
	{
		[SerializeField]
		[Tooltip("Set LifeTime to 0 if it's a continuous spell")]
		protected float m_lifeTime;

		[SerializeField]
		protected PoolObjectType m_poolObjectType;

		[SerializeField]
		protected GameObject m_core;

		private void OnDisable()
		{
			StopAllCoroutines();
		}

		public virtual void OnPhotonInstantiate(PhotonMessageInfo info)
		{
			PunDisableObject();
			base.transform.SetParent(ObjectPoolHandler.PoolParent);
		}

		public void EnableObject(Vector3 position, params object[] data)
		{
			base.photonView.RPC("PunEnableObject", RpcTarget.All, position, data);
		}

		[PunRPC]
		public virtual void PunEnableObject(Vector3 position, params object[] data)
		{
			base.transform.position = position;
			base.gameObject.SetActive(value: true);
			if (m_core != null)
			{
				m_core.SetActive(value: true);
			}
			if (m_lifeTime > 0f && base.photonView.IsMine)
			{
				StartCoroutine(DisableAfterTime());
			}
		}

		protected IEnumerator DisableAfterTime()
		{
			yield return new WaitForSeconds(m_lifeTime);
			DisableObject();
		}

		public void DisableObject()
		{
			if (GameControl.Instance.IsCurrentLevel(Level.Lobby))
			{
				PunDisableObject();
				return;
			}
			ObjectPoolHandler.TryReturnToPool(m_poolObjectType, this);
			base.photonView.RPC("PunDisableObject", RpcTarget.All);
		}

		[PunRPC]
		protected virtual void PunDisableObject()
		{
			base.gameObject.SetActive(value: false);
			if (m_core != null)
			{
				m_core.SetActive(value: false);
			}
		}

		PhotonView IPoolObject.get_photonView()
		{
			return base.photonView;
		}
	}
}
namespace Assets.Scripts.Utils
{
	[ExecuteInEditMode]
	[RequireComponent(typeof(PostProcessingBehaviour))]
	public class PostProcessingSwitcher : MonoBehaviour
	{
		[Serializable]
		public class PostProfile
		{
			public Level Level;

			public PostProcessingProfile Profile;
		}

		[SerializeField]
		public Level DebugLevel;

		[SerializeField]
		public List<PostProfile> Profiles = new List<PostProfile>();

		private Level m_level;

		private EventToken m_sceneLoadedEventToken;

		private PostProcessingBehaviour m_postProcessingComponent;

		private void OnEnable()
		{
			m_sceneLoadedEventToken = EventHub.Subscribe<Events.SceneLoadedEvent>(OnLevelUpdated);
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe<Events.SceneLoadedEvent>(m_sceneLoadedEventToken);
		}

		private void OnLevelUpdated(Events.SceneLoadedEvent eventData)
		{
			DebugLevel = GameControl.Instance.GetCurrentLevel();
			SetCorrectPostEffect(DebugLevel);
		}

		private void Start()
		{
			DebugLevel = GameControl.Instance.GetCurrentLevel();
			SetCorrectPostEffect(DebugLevel);
		}

		private void SetCorrectPostEffect(Level level)
		{
			m_level = level;
			if (Profiles.IsNullOrEmpty())
			{
				return;
			}
			PostProcessingProfile postProcessingProfile = null;
			foreach (PostProfile profile in Profiles)
			{
				if (m_level == profile.Level)
				{
					postProcessingProfile = profile.Profile;
					break;
				}
			}
			if (!(postProcessingProfile == null))
			{
				if (m_postProcessingComponent == null)
				{
					m_postProcessingComponent = GetComponent<PostProcessingBehaviour>();
				}
				m_postProcessingComponent.profile = postProcessingProfile;
			}
		}
	}
	public enum PromiseState
	{
		Pending,
		Rejected,
		Resolved
	}
	public interface IPromise
	{
		void Done(Action onResolved);

		void Done(Action onResolved, Action<Exception> onRejected);
	}
	public class Promise : IPromise
	{
		private static readonly Promise sm_resolvedPromise = new Promise(PromiseState.Resolved);

		private static readonly Promise sm_rejectedPromise = new Promise(PromiseState.Rejected);

		private Exception m_rejectionException;

		private PromiseState m_state;

		private event Action m_resolveHandler;

		private event Action<Exception> m_rejectionHandler;

		public Promise()
		{
			m_state = PromiseState.Pending;
		}

		public Promise(PromiseState state)
			: this()
		{
			m_state = state;
		}

		public static IPromise Resolved()
		{
			return sm_resolvedPromise;
		}

		public static IPromise Rejected(Exception exception)
		{
			sm_rejectedPromise.m_rejectionException = exception;
			return sm_rejectedPromise;
		}

		public void Done(Action onResolved)
		{
			m_resolveHandler += onResolved;
			if (m_state != 0)
			{
				FinishPromise();
			}
		}

		public void Done(Action onResolved, Action<Exception> onRejected)
		{
			m_resolveHandler += onResolved;
			m_rejectionHandler += onRejected;
			if (m_state != 0)
			{
				FinishPromise();
			}
		}

		public void Resolve()
		{
			m_state = PromiseState.Resolved;
			if (this.m_resolveHandler != null)
			{
				this.m_resolveHandler();
			}
			this.m_resolveHandler = null;
		}

		public void Reject(Exception exception)
		{
			m_rejectionException = exception;
			m_state = PromiseState.Rejected;
			if (this.m_rejectionHandler != null)
			{
				this.m_rejectionHandler(m_rejectionException);
			}
			this.m_rejectionHandler = null;
		}

		private void FinishPromise()
		{
			if (m_state == PromiseState.Resolved)
			{
				Resolve();
			}
			else
			{
				Reject(m_rejectionException);
			}
		}
	}
	public interface IPromise<T>
	{
		void Done(Action<T> onResolved);

		void Done(Action<T> onResolved, Action<Exception> onRejected);
	}
	public class Promise<T> : IPromise<T>
	{
		private static readonly Promise<T> sm_resolvedPromise = new Promise<T>(PromiseState.Resolved);

		private static readonly Promise<T> sm_rejectedPromise = new Promise<T>(PromiseState.Rejected);

		private T m_resolveValue;

		private Exception m_rejectionException;

		private PromiseState m_state;

		private event Action<T> m_resolveHandler;

		private event Action<Exception> m_rejectionHandler;

		public Promise()
		{
			m_state = PromiseState.Pending;
		}

		public Promise(PromiseState state)
			: this()
		{
			m_state = state;
		}

		public static IPromise<T> Resolved(T value)
		{
			sm_resolvedPromise.m_resolveValue = value;
			return sm_resolvedPromise;
		}

		public static IPromise<T> Rejected(Exception exception)
		{
			sm_rejectedPromise.m_rejectionException = exception;
			return sm_rejectedPromise;
		}

		public void Done(Action<T> onResolved)
		{
			m_resolveHandler += onResolved;
			if (m_state != 0)
			{
				FinishPromise();
			}
		}

		public void Done(Action<T> onResolved, Action<Exception> onRejected)
		{
			m_resolveHandler += onResolved;
			m_rejectionHandler += onRejected;
			if (m_state != 0)
			{
				FinishPromise();
			}
		}

		public void Resolve(T value)
		{
			m_resolveValue = value;
			m_state = PromiseState.Resolved;
			if (this.m_resolveHandler != null)
			{
				this.m_resolveHandler(m_resolveValue);
			}
			this.m_resolveHandler = null;
		}

		public void Reject(Exception exception)
		{
			m_rejectionException = exception;
			m_state = PromiseState.Rejected;
			if (this.m_rejectionHandler != null)
			{
				this.m_rejectionHandler(m_rejectionException);
			}
			this.m_rejectionHandler = null;
		}

		private void FinishPromise()
		{
			if (m_state == PromiseState.Resolved)
			{
				Resolve(m_resolveValue);
			}
			else
			{
				Reject(m_rejectionException);
			}
		}
	}
}
public static class QuaternionExtensions
{
	public static float GetRoll(this Quaternion q)
	{
		return Mathf.Atan2(2f * q.y * q.w - 2f * q.x * q.z, 1f - 2f * q.y * q.y - 2f * q.z * q.z);
	}

	public static float GetPitch(this Quaternion q)
	{
		return Mathf.Atan2(2f * q.x * q.w - 2f * q.y * q.z, 1f - 2f * q.x * q.x - 2f * q.z * q.z);
	}

	public static float GetYaw(this Quaternion q)
	{
		return Mathf.Asin(2f * q.x * q.y + 2f * q.z * q.w);
	}

	public static bool IsValid(this Quaternion q)
	{
		return q.x != 0f || q.y != 0f || q.z != 0f || q.w != 0f;
	}

	public static bool IsValidThorough(this Quaternion q)
	{
		if (float.IsNaN(q.x) || float.IsNaN(q.y) || float.IsNaN(q.z) || float.IsNaN(q.w))
		{
			return false;
		}
		return Mathf.Abs(1f - Mathf.Pow(q.x, 2f) + Mathf.Pow(q.y, 2f) + Mathf.Pow(q.z, 2f) + Mathf.Pow(q.w, 2f)) < 0.001f;
	}
}
namespace Assets.Scripts.GoogleSheetsDatabase
{
	public static class RijndaelManagedConverter
	{
		private static readonly byte[] SALT = new byte[16]
		{
			38, 220, 255, 0, 173, 237, 122, 238, 197, 254,
			7, 175, 77, 8, 34, 60
		};

		public static byte[] Encrypt(byte[] plain, string password)
		{
			Rijndael rijndael = Rijndael.Create();
			Rfc2898DeriveBytes rfc2898DeriveBytes = new Rfc2898DeriveBytes(password, SALT);
			rijndael.Key = rfc2898DeriveBytes.GetBytes(32);
			rijndael.IV = rfc2898DeriveBytes.GetBytes(16);
			MemoryStream memoryStream = new MemoryStream();
			CryptoStream cryptoStream = new CryptoStream(memoryStream, rijndael.CreateEncryptor(), CryptoStreamMode.Write);
			cryptoStream.Write(plain, 0, plain.Length);
			cryptoStream.Close();
			return memoryStream.ToArray();
		}

		public static byte[] Decrypt(byte[] cipher, string password)
		{
			Rijndael rijndael = Rijndael.Create();
			Rfc2898DeriveBytes rfc2898DeriveBytes = new Rfc2898DeriveBytes(password, SALT);
			rijndael.Key = rfc2898DeriveBytes.GetBytes(32);
			rijndael.IV = rfc2898DeriveBytes.GetBytes(16);
			MemoryStream memoryStream = new MemoryStream();
			CryptoStream cryptoStream = new CryptoStream(memoryStream, rijndael.CreateDecryptor(), CryptoStreamMode.Write);
			cryptoStream.Write(cipher, 0, cipher.Length);
			cryptoStream.Close();
			return memoryStream.ToArray();
		}
	}
}
namespace Assets.Scripts.Utils
{
	public abstract class DrawableDictionary
	{
	}
	[Serializable]
	public class SerializableDictionaryBase<TKey, TValue> : DrawableDictionary, IDictionary<TKey, TValue>, ISerializationCallbackReceiver, ICollection<KeyValuePair<TKey, TValue>>, IEnumerable<KeyValuePair<TKey, TValue>>, IEnumerable
	{
		[NonSerialized]
		private Dictionary<TKey, TValue> _dict;

		[SerializeField]
		private TKey[] _keys;

		[SerializeField]
		private TValue[] _values;

		bool ICollection<KeyValuePair<TKey, TValue>>.IsReadOnly => false;

		public int Count => (_dict != null) ? _dict.Count : 0;

		public ICollection<TKey> Keys
		{
			get
			{
				if (_dict == null)
				{
					_dict = new Dictionary<TKey, TValue>();
				}
				return _dict.Keys;
			}
		}

		public ICollection<TValue> Values
		{
			get
			{
				if (_dict == null)
				{
					_dict = new Dictionary<TKey, TValue>();
				}
				return _dict.Values;
			}
		}

		public TValue this[TKey key]
		{
			get
			{
				if (_dict == null)
				{
					throw new KeyNotFoundException();
				}
				return _dict[key];
			}
			set
			{
				if (_dict == null)
				{
					_dict = new Dictionary<TKey, TValue>();
				}
				_dict[key] = value;
			}
		}

		public void Add(TKey key, TValue value)
		{
			if (_dict == null)
			{
				_dict = new Dictionary<TKey, TValue>();
			}
			_dict.Add(key, value);
		}

		public bool ContainsKey(TKey key)
		{
			if (_dict == null)
			{
				return false;
			}
			return _dict.ContainsKey(key);
		}

		public bool Remove(TKey key)
		{
			if (_dict == null)
			{
				return false;
			}
			return _dict.Remove(key);
		}

		public bool TryGetValue(TKey key, out TValue value)
		{
			if (_dict == null)
			{
				value = default(TValue);
				return false;
			}
			return _dict.TryGetValue(key, out value);
		}

		public void Clear()
		{
			if (_dict != null)
			{
				_dict.Clear();
			}
		}

		void ICollection<KeyValuePair<TKey, TValue>>.Add(KeyValuePair<TKey, TValue> item)
		{
			if (_dict == null)
			{
				_dict = new Dictionary<TKey, TValue>();
			}
			((ICollection<KeyValuePair<TKey, TValue>>)_dict).Add(item);
		}

		bool ICollection<KeyValuePair<TKey, TValue>>.Contains(KeyValuePair<TKey, TValue> item)
		{
			if (_dict == null)
			{
				return false;
			}
			return ((ICollection<KeyValuePair<TKey, TValue>>)_dict).Contains(item);
		}

		void ICollection<KeyValuePair<TKey, TValue>>.CopyTo(KeyValuePair<TKey, TValue>[] array, int arrayIndex)
		{
			if (_dict != null)
			{
				((ICollection<KeyValuePair<TKey, TValue>>)_dict).CopyTo(array, arrayIndex);
			}
		}

		bool ICollection<KeyValuePair<TKey, TValue>>.Remove(KeyValuePair<TKey, TValue> item)
		{
			if (_dict == null)
			{
				return false;
			}
			return ((ICollection<KeyValuePair<TKey, TValue>>)_dict).Remove(item);
		}

		public Dictionary<TKey, TValue>.Enumerator GetEnumerator()
		{
			if (_dict == null)
			{
				return default(Dictionary<TKey, TValue>.Enumerator);
			}
			return _dict.GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			if (_dict == null)
			{
				return Enumerable.Empty<KeyValuePair<TKey, TValue>>().GetEnumerator();
			}
			return _dict.GetEnumerator();
		}

		IEnumerator<KeyValuePair<TKey, TValue>> IEnumerable<KeyValuePair<TKey, TValue>>.GetEnumerator()
		{
			if (_dict == null)
			{
				return Enumerable.Empty<KeyValuePair<TKey, TValue>>().GetEnumerator();
			}
			return _dict.GetEnumerator();
		}

		void ISerializationCallbackReceiver.OnAfterDeserialize()
		{
			if (_keys != null && _values != null)
			{
				if (_dict == null)
				{
					_dict = new Dictionary<TKey, TValue>(_keys.Length);
				}
				else
				{
					_dict.Clear();
				}
				for (int i = 0; i < _keys.Length; i++)
				{
					if (i < _values.Length)
					{
						_dict[_keys[i]] = _values[i];
					}
					else
					{
						_dict[_keys[i]] = default(TValue);
					}
				}
			}
			_keys = null;
			_values = null;
		}

		void ISerializationCallbackReceiver.OnBeforeSerialize()
		{
			if (_dict == null || _dict.Count == 0)
			{
				_keys = null;
				_values = null;
				return;
			}
			int count = _dict.Count;
			_keys = new TKey[count];
			_values = new TValue[count];
			int num = 0;
			Dictionary<TKey, TValue>.Enumerator enumerator = _dict.GetEnumerator();
			while (enumerator.MoveNext())
			{
				_keys[num] = enumerator.Current.Key;
				_values[num] = enumerator.Current.Value;
				num++;
			}
		}
	}
}
public static class StringExtensions
{
	public static string Truncate(this string value, int maxLength)
	{
		if (string.IsNullOrEmpty(value))
		{
			return value;
		}
		return (value.Length > maxLength) ? value.Substring(0, maxLength) : value;
	}

	public static string WithPrefix(this float value)
	{
		return (!(value > 0f)) ? value.ToString() : $"+{value}";
	}

	public static string WithPrefix(this int value)
	{
		return (value <= 0) ? value.ToString() : $"+{value}";
	}

	public static string ToNumbers(this string value)
	{
		return Regex.Match(value, "\\d+").Value;
	}

	public static void EmptyTerm(this Localize localize)
	{
		localize.SetTerm(null);
		TMP_Text tMP_Text = localize.mTarget as TMP_Text;
		if (tMP_Text != null)
		{
			tMP_Text.text = string.Empty;
		}
	}
}
namespace Assets.Scripts.Utils
{
	public class TrailerCamera : MonoBehaviour
	{
		[SerializeField]
		private Camera m_camera;

		[SerializeField]
		private LerpConstraint m_lerpConstraint;

		private void Start()
		{
			ConfigureTrailerCamera();
		}

		private void ConfigureTrailerCamera()
		{
			if (GameControl.Instance.PlatformSettings.UseDebugInput)
			{
				EnableTrailerCamera(enable: false);
			}
			else if (GameControl.Instance.PlatformSettings.ConnectionType == ConnectionType.Trailer)
			{
				EnableTrailerCamera(enable: true);
			}
			else
			{
				EnableTrailerCamera(enable: false);
			}
		}

		private void EnableTrailerCamera(bool enable)
		{
			m_camera.enabled = enable;
			if (enable)
			{
				m_lerpConstraint.ActivateConstraint();
			}
			else
			{
				m_lerpConstraint.DeactivateConstraint();
			}
			m_lerpConstraint.enabled = enable;
		}
	}
}
namespace Assets.Scripts.Utils.Tweeners
{
	[RequireComponent(typeof(RectTransform))]
	public class AnchorMoveTweener : WandsTweener
	{
		[SerializeField]
		private Vector2 m_startPos;

		[SerializeField]
		private Vector2 m_endPos;

		protected override void StartTweener()
		{
			m_activeTweener = (base.transform as RectTransform).DOAnchorPos(m_endPos, m_tweenTime).SetDelay(m_tweenStartDelay).OnComplete(base.EndTweener)
				.SetEase(m_ease);
		}

		protected override void ResetTweener()
		{
			(base.transform as RectTransform).anchoredPosition = m_startPos;
		}

		protected override void SetTweener()
		{
			(base.transform as RectTransform).anchoredPosition = m_endPos;
		}
	}
	[RequireComponent(typeof(Image))]
	public class ImageMaterialPropertyTweener : WandsTweener
	{
		[SerializeField]
		private string m_materialPropertyName;

		[SerializeField]
		private float m_startValue;

		[SerializeField]
		private float m_endValue;

		private bool m_playBackWards;

		private Material m_material;

		private Material Material
		{
			get
			{
				if (m_material == null)
				{
					Image component = GetComponent<Image>();
					m_material = new Material(component.material.shader);
					m_material.CopyPropertiesFromMaterial(component.material);
					component.material = m_material;
				}
				return m_material;
			}
		}

		protected override void StartTweener()
		{
			if (CanGetMaterialProperty())
			{
				if (Material.GetFloat(m_materialPropertyName) == m_endValue)
				{
					EndTweener();
				}
				else
				{
					m_activeTweener = Material.DOFloat(m_endValue, m_materialPropertyName, m_tweenTime).SetDelay(m_tweenStartDelay).OnComplete(base.EndTweener)
						.SetEase(m_ease);
				}
			}
		}

		protected override void ResetTweener()
		{
			if (CanGetMaterialProperty())
			{
				bool? flag = ((m_activeTweener != null) ? new bool?(m_activeTweener.IsPlaying()) : null);
				if (flag.HasValue && flag.Value)
				{
					m_activeTweener.PlayBackwards();
				}
				else
				{
					Material.SetFloat(m_materialPropertyName, m_startValue);
				}
			}
		}

		protected override void SetTweener()
		{
			if (CanGetMaterialProperty())
			{
				Material.SetFloat(m_materialPropertyName, m_endValue);
			}
		}

		private bool CanGetMaterialProperty()
		{
			if (Material.HasProperty(m_materialPropertyName))
			{
				return true;
			}
			WandsLogger.LogFormat(LogType.Warning, "Material {0} is lacking property: {1}", Material, m_materialPropertyName);
			return false;
		}
	}
	public class MaterialPropertyTweener : WandsTweener
	{
		[SerializeField]
		private string m_materialPropertyName;

		[SerializeField]
		private float m_startValue;

		[SerializeField]
		private float m_endValue;

		private Material m_material;

		private Material Material
		{
			get
			{
				if (m_material == null)
				{
					m_material = GetComponent<Renderer>().material;
				}
				return m_material;
			}
		}

		protected override void StartTweener()
		{
			if (CanGetMaterialProperty())
			{
				m_activeTweener = Material.DOFloat(m_endValue, m_materialPropertyName, m_tweenTime).SetDelay(m_tweenStartDelay).OnComplete(base.EndTweener)
					.SetEase(m_ease);
			}
		}

		protected override void ResetTweener()
		{
			if (CanGetMaterialProperty())
			{
				Material.SetFloat(m_materialPropertyName, m_startValue);
			}
		}

		protected override void SetTweener()
		{
			if (CanGetMaterialProperty())
			{
				Material.SetFloat(m_materialPropertyName, m_endValue);
			}
		}

		private bool CanGetMaterialProperty()
		{
			bool? flag = Material?.HasProperty(m_materialPropertyName);
			if (flag.HasValue && flag.Value)
			{
				return true;
			}
			WandsLogger.LogFormat(LogType.Warning, "Material {0} is lacking property: {1}", Material, m_materialPropertyName);
			return false;
		}
	}
	[RequireComponent(typeof(TextMeshPro))]
	public class MonolithTextTweener : WandsTweener
	{
		[Header("Text Color")]
		[SerializeField]
		private Color m_startColor;

		[SerializeField]
		private Color m_middleColor;

		[SerializeField]
		private Color m_endColor;

		[Header("Text Property")]
		[SerializeField]
		private float m_endValue;

		private bool m_reverse;

		private List<Tweener> m_activeTweeners = new List<Tweener>();

		private TextMeshPro m_textComponent;

		private Material m_material;

		private Color EndColor => (!m_reverse) ? m_middleColor : m_endColor;

		private float EndValue => (!m_reverse) ? m_endValue : 0f;

		private TextMeshPro TextComponent
		{
			get
			{
				if (m_textComponent == null)
				{
					m_textComponent = GetComponent<TextMeshPro>();
				}
				return m_textComponent;
			}
		}

		private Material Material
		{
			get
			{
				if (m_material == null)
				{
					m_material = TextComponent.fontMaterial;
				}
				return m_material;
			}
		}

		public override void SkipTweener()
		{
			for (int i = 0; i < m_activeTweeners.Count; i++)
			{
				m_activeTweeners[i]?.Kill();
			}
			m_reverse = false;
			SetTweener();
		}

		protected override void StartTweener()
		{
			m_activeTweeners.Add(TextComponent.DOColor(EndColor, m_tweenTime).SetDelay(m_tweenStartDelay).SetEase(m_ease));
			m_activeTweeners.Add(Material.DOFloat(EndValue, "_OutlineSoftness", m_tweenTime).SetDelay(m_tweenStartDelay).SetEase(m_ease));
			m_activeTweeners.Add(Material.DOFloat(EndValue, "_FaceDilate", m_tweenTime).SetDelay(m_tweenStartDelay).OnComplete(Reverse)
				.SetEase(m_ease));
		}

		private void Reverse()
		{
			if (m_reverse)
			{
				EndTweener();
				return;
			}
			m_reverse = true;
			m_tweenStartDelay = 0f;
			StartTweener();
		}

		protected override void ResetTweener()
		{
			TextComponent.color = m_startColor;
			Material.SetFloat("_OutlineSoftness", 0f);
			Material.SetFloat("_FaceDilate", 0f);
		}

		protected override void SetTweener()
		{
			TextComponent.color = m_endColor;
			Material.SetFloat("_OutlineSoftness", 0f);
			Material.SetFloat("_FaceDilate", 0f);
		}
	}
	public class MoveTweener : WandsTweener
	{
		[SerializeField]
		private Vector3 m_startPos;

		[SerializeField]
		private Vector3 m_endPos;

		[SerializeField]
		private bool m_localSpace;

		protected override void StartTweener()
		{
			if (m_localSpace)
			{
				m_activeTweener = base.transform.DOLocalMove(m_endPos, m_tweenTime).SetDelay(m_tweenStartDelay).OnComplete(base.EndTweener)
					.SetEase(m_ease);
			}
			else
			{
				m_activeTweener = base.transform.DOMove(m_endPos, m_tweenTime).SetDelay(m_tweenStartDelay).OnComplete(base.EndTweener)
					.SetEase(m_ease);
			}
		}

		protected override void ResetTweener()
		{
			if (m_localSpace)
			{
				base.transform.localPosition = m_startPos;
			}
			else
			{
				base.transform.position = m_startPos;
			}
		}

		protected override void SetTweener()
		{
			if (m_localSpace)
			{
				base.transform.localPosition = m_endPos;
			}
			else
			{
				base.transform.position = m_endPos;
			}
		}
	}
	public class ScaleTweener : WandsTweener
	{
		[SerializeField]
		private float m_startScale;

		[SerializeField]
		private float m_endScale;

		protected override void StartTweener()
		{
			m_activeTweener = base.transform.DOScale(m_endScale, m_tweenTime).SetDelay(m_tweenStartDelay).OnComplete(base.EndTweener)
				.SetEase(m_ease);
		}

		protected override void ResetTweener()
		{
			base.transform.localScale = Vector3.one * m_startScale;
		}

		protected override void SetTweener()
		{
			if (m_activeTweener != null)
			{
				m_activeTweener.Kill();
			}
			base.transform.localScale = Vector3.one * m_endScale;
		}
	}
	public class TextColorTweener : WandsTweener
	{
		[SerializeField]
		private Color m_startColor;

		[SerializeField]
		private Color m_endColor;

		private MaskableGraphic m_textComponent;

		private MaskableGraphic TextComponent
		{
			get
			{
				if (m_textComponent == null)
				{
					m_textComponent = GetComponent<MaskableGraphic>();
				}
				return m_textComponent;
			}
		}

		protected override void StartTweener()
		{
			m_activeTweener = TextComponent.DOColor(m_endColor, m_tweenTime).SetDelay(m_tweenStartDelay).OnComplete(base.EndTweener)
				.SetEase(m_ease);
		}

		protected override void ResetTweener()
		{
			TextComponent.color = m_startColor;
		}

		protected override void SetTweener()
		{
			TextComponent.color = m_endColor;
		}
	}
	public class TextFadeTweener : WandsTweener
	{
		[SerializeField]
		private float m_startAlpha;

		[SerializeField]
		private float m_endAlpha = 1f;

		private MaskableGraphic m_textComponent;

		private MaskableGraphic TextComponent
		{
			get
			{
				if (m_textComponent == null)
				{
					m_textComponent = GetComponent<MaskableGraphic>();
				}
				return m_textComponent;
			}
		}

		protected override void StartTweener()
		{
			m_activeTweener = TextComponent.DOFade(m_endAlpha, m_tweenTime).SetDelay(m_tweenStartDelay).OnComplete(base.EndTweener)
				.SetEase(m_ease);
		}

		protected override void ResetTweener()
		{
			Color color = TextComponent.color;
			color.a = m_startAlpha;
			TextComponent.color = color;
		}

		protected override void SetTweener()
		{
			Color color = TextComponent.color;
			color.a = m_endAlpha;
			TextComponent.color = color;
		}
	}
	public abstract class WandsTweener : MonoBehaviour
	{
		[SerializeField]
		protected float m_tweenTime;

		[SerializeField]
		protected float m_tweenStartDelay;

		[SerializeField]
		protected Ease m_ease = Ease.Linear;

		protected Tweener m_activeTweener;

		protected Action OnComplete;

		public void ResetTween()
		{
			ResetTweener();
		}

		public void Initiate(Action onComplete)
		{
			OnComplete = onComplete;
			StartTweener();
		}

		protected void EndTweener()
		{
			if (OnComplete != null)
			{
				OnComplete();
			}
		}

		public virtual void SkipTweener()
		{
			if (m_activeTweener != null)
			{
				m_activeTweener.Kill();
			}
			SetTweener();
		}

		protected abstract void ResetTweener();

		protected abstract void StartTweener();

		protected abstract void SetTweener();
	}
	public class WandsTweenerController : MonoBehaviour
	{
		[SerializeField]
		private TweenerControlOption m_startOption = TweenerControlOption.ResetOnAwake;

		[SerializeField]
		private WandsTweener[] m_tweeners;

		[SerializeField]
		private UnityEvent m_onStart;

		[SerializeField]
		private UnityEvent m_onComplete;

		[SerializeField]
		private UnityEvent m_onSkip;

		private int m_tweenersCompleted;

		private int m_tweenersToComplete;

		private bool m_tweenControllerCompleted;

		private EventToken m_postMatchUiSkippedEventToken;

		private WandsTweener[] Tweeners
		{
			get
			{
				if (m_tweeners.IsNullOrEmpty())
				{
					m_tweeners = base.gameObject.GetComponentsInChildren<WandsTweener>();
				}
				return m_tweeners;
			}
		}

		private void OnEnable()
		{
			m_postMatchUiSkippedEventToken = EventHub.Subscribe<Events.PostMatchUiSkippedEvent>(OnPostMatchUiSkipped);
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe<Events.PostMatchUiSkippedEvent>(m_postMatchUiSkippedEventToken);
		}

		private void OnPostMatchUiSkipped(Events.PostMatchUiSkippedEvent eventData)
		{
			PostMatchUiSkipped();
		}

		private void Awake()
		{
			switch (m_startOption)
			{
			case TweenerControlOption.ResetOnAwake:
				ResetTweeners();
				break;
			case TweenerControlOption.PlayOnAwake:
				ResetTweeners();
				StartTweeners();
				break;
			}
		}

		public void ResetTweeners()
		{
			if (!Tweeners.IsNullOrEmpty())
			{
				WandsTweener[] tweeners = Tweeners;
				foreach (WandsTweener wandsTweener in tweeners)
				{
					wandsTweener.ResetTween();
				}
				m_tweenControllerCompleted = false;
				m_tweeners = null;
				m_tweenersToComplete = 0;
			}
		}

		public void StartTweeners()
		{
			if (Tweeners.IsNullOrEmpty())
			{
				m_tweenersToComplete = 1;
				OnTweenComplete();
			}
			else
			{
				if (m_tweenControllerCompleted || m_tweenersToComplete > 0)
				{
					return;
				}
				if (m_onStart != null)
				{
					m_onStart.Invoke();
				}
				WandsTweener[] tweeners = Tweeners;
				foreach (WandsTweener wandsTweener in tweeners)
				{
					if (wandsTweener.gameObject.activeSelf)
					{
						wandsTweener.Initiate(OnTweenComplete);
						m_tweenersToComplete++;
					}
				}
			}
		}

		public void PostMatchUiSkipped()
		{
			if (!Tweeners.IsNullOrEmpty())
			{
				if (m_onSkip != null)
				{
					m_onSkip.Invoke();
				}
				WandsTweener[] tweeners = Tweeners;
				foreach (WandsTweener wandsTweener in tweeners)
				{
					wandsTweener.SkipTweener();
				}
			}
		}

		private void OnTweenComplete()
		{
			m_tweenersCompleted++;
			if (m_tweenersCompleted == m_tweenersToComplete)
			{
				if (m_onComplete != null)
				{
					m_onComplete.Invoke();
				}
				m_tweenControllerCompleted = true;
			}
		}
	}
}
public static class UnityExtensions
{
	public static string Trim<Spell>(this Spell spell)
	{
		return spell.ToString().Substring(6);
	}

	public static Transform RetrieveOrCreateChild(this Transform tf, string childName, bool includeInactive = false)
	{
		Transform transform = tf.Find(childName);
		if (transform != null)
		{
			return transform;
		}
		Transform[] componentsInChildren = tf.GetComponentsInChildren<Transform>(includeInactive);
		foreach (Transform transform2 in componentsInChildren)
		{
			if (transform2.name == childName)
			{
				return transform2;
			}
		}
		transform = new GameObject(childName).transform;
		transform.SetParent(tf);
		return transform;
	}

	public static Transform RetrieveChild(this Transform tf, string childName, bool includeInactive = false, bool includePartials = false)
	{
		Transform transform = tf.Find(childName);
		if (transform != null)
		{
			return transform;
		}
		Transform[] componentsInChildren = tf.GetComponentsInChildren<Transform>(includeInactive);
		foreach (Transform transform2 in componentsInChildren)
		{
			if (transform2.name == childName)
			{
				return transform2;
			}
			if (includePartials && transform2.name.Contains(childName))
			{
				return transform2;
			}
		}
		return null;
	}

	public static List<Transform> RetrieveChildren(this Transform tf, string childName, bool includeInactive = false, bool includePartials = false)
	{
		List<Transform> list = new List<Transform>();
		Transform[] componentsInChildren = tf.GetComponentsInChildren<Transform>(includeInactive);
		foreach (Transform transform in componentsInChildren)
		{
			if (transform.name == childName)
			{
				list.Add(transform);
			}
			else if (includePartials && transform.name.Contains(childName))
			{
				list.Add(transform);
			}
		}
		return list;
	}

	public static void SetParent(this Transform transform, Transform parent, ResetBehaviour resetBehaviour)
	{
		transform.SetParent(parent);
		if (resetBehaviour.ContainsFlag(ResetBehaviour.Position))
		{
			transform.localPosition = Vector3.zero;
		}
		if (resetBehaviour.ContainsFlag(ResetBehaviour.Rotation))
		{
			transform.localRotation = Quaternion.identity;
		}
		if (resetBehaviour.ContainsFlag(ResetBehaviour.Scale))
		{
			transform.localScale = Vector3.one;
		}
	}

	public static void SetParent(this Transform transform, Transform parent, bool worldPositionStays, ResetBehaviour resetBehaviour)
	{
		transform.SetParent(parent, worldPositionStays);
		if (resetBehaviour.ContainsFlag(ResetBehaviour.Position))
		{
			transform.localPosition = Vector3.zero;
		}
		if (resetBehaviour.ContainsFlag(ResetBehaviour.Rotation))
		{
			transform.localRotation = Quaternion.identity;
		}
		if (resetBehaviour.ContainsFlag(ResetBehaviour.Scale))
		{
			transform.localScale = Vector3.one;
		}
	}

	public static void SetLocalPositionAndRotation(this Transform transform, Vector3 position, Quaternion rotation)
	{
		transform.localPosition = position;
		transform.localRotation = rotation;
	}

	public static void SetLocalPositionRotationAndScale(this Transform transform, Vector3 position, Quaternion rotation, Vector3 scale)
	{
		transform.localPosition = position;
		transform.localRotation = rotation;
		transform.localScale = scale;
	}

	public static void ResetPositionAndRotation(this Transform transform, bool useWorldPositions)
	{
		if (useWorldPositions)
		{
			transform.position = Vector3.zero;
			transform.rotation = Quaternion.identity;
		}
		else
		{
			transform.localPosition = Vector3.zero;
			transform.localRotation = Quaternion.identity;
		}
	}

	public static string SplitCamelCase(this string s)
	{
		Regex regex = new Regex("([A-Z][a-z]+|[A-Z]+[A-Z]|[A-Z]|[^A-Za-z]+[^A-Za-z])", RegexOptions.RightToLeft);
		return regex.Replace(s, " $1").TrimStart(' ');
	}

	public static string UppercaseFirst(this string s)
	{
		if (string.IsNullOrEmpty(s))
		{
			return string.Empty;
		}
		char[] array = s.ToCharArray();
		array[0] = char.ToUpper(array[0]);
		return new string(array);
	}

	public static bool HasParameterOfType(this Animator self, string name, AnimatorControllerParameterType type)
	{
		AnimatorControllerParameter[] parameters = self.parameters;
		AnimatorControllerParameter[] array = parameters;
		foreach (AnimatorControllerParameter animatorControllerParameter in array)
		{
			if (animatorControllerParameter.type == type && animatorControllerParameter.name == name)
			{
				return true;
			}
		}
		return false;
	}

	public static T GetOrAddComponent<T>(this GameObject go) where T : UnityEngine.Component
	{
		T val = go.GetComponent<T>();
		if (val == null)
		{
			val = go.AddComponent<T>();
		}
		return val;
	}

	public static int Wrap(this int value, int min, int max)
	{
		if (value < min)
		{
			return max;
		}
		if (value > max)
		{
			return min;
		}
		return value;
	}

	public static float RoundToDecimal(this float value, int decimals)
	{
		return (float)Math.Round(value, decimals);
	}
}
[Serializable]
public class VirtualTransform
{
	public Vector3 Position;

	public Quaternion Rotation;

	public Vector3 Scale;

	public VirtualTransform()
	{
		Position = Vector3.zero;
		Rotation = Quaternion.identity;
		Scale = Vector3.one;
	}

	public VirtualTransform(Vector3 position, Quaternion rotation, Vector3 scale)
	{
		Position = position;
		Rotation = rotation;
		Scale = scale;
	}

	public void SetValues(Vector3 newPosition, Quaternion newRotation)
	{
		SetValues(newPosition, newRotation, Scale);
	}

	public void SetValues(Vector3 newPosition, Quaternion newRotation, Vector3 newScale)
	{
		Position = newPosition;
		Rotation = newRotation;
		Scale = newScale;
	}

	public void SetValues(VirtualTransform virtualTransform)
	{
		Position = virtualTransform.Position;
		Rotation = virtualTransform.Rotation;
		Scale = virtualTransform.Scale;
	}

	public static explicit operator VirtualTransform(Transform transform)
	{
		return new VirtualTransform(transform.position, transform.rotation, transform.localScale);
	}
}
namespace Assets.Scripts.Utils
{
	public class WandFPS : MonoBehaviour
	{
		[SerializeField]
		private float m_fpsMeasurePeriod = 0.5f;

		[SerializeField]
		private bool m_perFrameUpdate;

		[SerializeField]
		private Text m_text;

		private int m_fpsAccumulator;

		private int m_currentFps;

		private float m_fpsNextPeriod;

		private string m_display = "{0} FPS";

		private void Start()
		{
			if (GameControl.Instance.IsExpectedConnectionType(ConnectionType.Develop))
			{
				m_fpsNextPeriod = Time.realtimeSinceStartup + m_fpsMeasurePeriod;
			}
			else
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}

		private void Update()
		{
			if (!(m_text == null))
			{
				if (m_perFrameUpdate)
				{
					m_fpsMeasurePeriod = Time.deltaTime;
				}
				m_fpsAccumulator++;
				if (Time.realtimeSinceStartup > m_fpsNextPeriod)
				{
					m_currentFps = (int)((float)m_fpsAccumulator / m_fpsMeasurePeriod);
					m_fpsAccumulator = 0;
					m_fpsNextPeriod += m_fpsMeasurePeriod;
				}
				m_text.text = string.Format(m_display, m_currentFps);
			}
		}
	}
}
public static class WandsLogger
{
	private const int MaximumPlayFabBodySize = 1000;

	private static bool sm_isPicoGoblin;

	private static string[] sm_analyticsStackTraceSplit;

	public static IReadOnlyDictionary<LogColor, Color> LogColors { get; }

	static WandsLogger()
	{
		LogColors = new Dictionary<LogColor, Color>
		{
			{
				LogColor.Debug,
				new Color(1f, 1f, 1f)
			},
			{
				LogColor.System,
				new Color(1f, 1f, 0.5f)
			},
			{
				LogColor.Loading,
				new Color(1f, 0.5f, 1f)
			},
			{
				LogColor.Login,
				new Color(0.5f, 1f, 1f)
			},
			{
				LogColor.PlayFab,
				new Color(1f, 0.5f, 0.5f)
			},
			{
				LogColor.Bundles,
				new Color(0.5f, 0.6f, 0.7f)
			},
			{
				LogColor.PlayerData,
				new Color(0.5f, 0.5f, 1f)
			},
			{
				LogColor.Tutorial,
				new Color(0.6f, 0.5f, 0.7f)
			},
			{
				LogColor.Database,
				new Color(0.5f, 0.7f, 0.6f)
			},
			{
				LogColor.ObjectPooling,
				new Color(0.7f, 0.7f, 0f)
			},
			{
				LogColor.PlayerPrefs,
				new Color(0.7f, 0.7f, 0.5f)
			},
			{
				LogColor.Conversion,
				new Color(0.4f, 0.8f, 0.6f)
			},
			{
				LogColor.CustomEvent,
				new Color(0.3f, 0.8f, 0.5f)
			},
			{
				LogColor.Photon,
				new Color(0.9f, 0.1f, 0.4f)
			},
			{
				LogColor.Inventory,
				new Color(0.5f, 0.8f, 0.2f)
			},
			{
				LogColor.PlayFabFieldParsing,
				new Color(0.3f, 0.5f, 0.6f)
			},
			{
				LogColor.VoIP,
				new Color(0.9f, 0.8f, 0.7f)
			},
			{
				LogColor.Events,
				new Color(0.8f, 0.9f, 0.7f)
			},
			{
				LogColor.Matchmaking,
				new Color(0.1f, 0.9f, 0.2f)
			},
			{
				LogColor.Achievements,
				new Color(1f, 0.92f, 0.016f)
			},
			{
				LogColor.Audio,
				new Color(0f, 1f, 0.75f)
			},
			{
				LogColor.WandProperty,
				new Color(0.235f, 0.74f, 0.62f)
			}
		};
		sm_analyticsStackTraceSplit = new string[2] { "UnityEngine.DebugLogHandler.", "WandsLogger" };
		sm_isPicoGoblin = SystemInfo.deviceModel == "Goblin";
	}

	[Conditional("THIS_IS_NOT_TRUE")]
	public static void Log(string message, LogColor logColor)
	{
		Log(message, LogType.Log, logColor);
	}

	[Conditional("THIS_IS_NOT_TRUE")]
	public static void LogWarning(string message, LogColor logColor = LogColor.Default)
	{
		Log(message, LogType.Warning, logColor);
	}

	public static void LogError(string message, LogColor logColor = LogColor.Default)
	{
		Log(message, LogType.Error, logColor);
	}

	public static void LogException(string message, LogColor logColor = LogColor.Default)
	{
		Log(message, LogType.Exception, logColor);
	}

	public static void LogAssert(string message, LogColor logColor = LogColor.Default)
	{
		Log(message, LogType.Assert, logColor);
	}

	[Conditional("THIS_IS_NOT_TRUE")]
	public static void Log(string message, GameObject gameObject, LogColor logColor)
	{
		Log(message, gameObject, LogType.Log, logColor);
	}

	[Conditional("THIS_IS_NOT_TRUE")]
	public static void LogWarning(string message, GameObject gameObject, LogColor logColor = LogColor.Default)
	{
		Log(message, gameObject, LogType.Warning, logColor);
	}

	public static void LogError(string message, GameObject gameObject, LogColor logColor = LogColor.Default)
	{
		Log(message, gameObject, LogType.Error, logColor);
	}

	public static void LogException(string message, GameObject gameObject, LogColor logColor = LogColor.Default)
	{
		Log(message, gameObject, LogType.Exception, logColor);
	}

	public static void LogAssert(string message, GameObject gameObject, LogColor logColor = LogColor.Default)
	{
		Log(message, gameObject, LogType.Assert, logColor);
	}

	[Conditional("THIS_IS_NOT_TRUE")]
	public static void Log(string message)
	{
		Log(message, LogType.Log);
	}

	[Conditional("THIS_IS_NOT_TRUE")]
	public static void LogFormat(string message, params object[] args)
	{
		LogFormat(LogType.Log, message, args);
	}

	[Conditional("THIS_IS_NOT_TRUE")]
	public static void Log(string message, GameObject gameObject)
	{
		Log(message, gameObject, LogType.Log);
	}

	private static void Log(string message, LogType logType, LogColor logColor)
	{
		LogAnalytics(logType, message, null);
	}

	private static void Log(string message, GameObject gameObject, LogType logType, LogColor logColor)
	{
		LogAnalytics(logType, message, null, gameObject);
	}

	public static void LogFormat(LogType logType, string message, params object[] args)
	{
		LogAnalytics(logType, message, null, args);
	}

	public static void Log(string message, LogType logType)
	{
		LogAnalytics(logType, message, null);
	}

	public static void Log(string message, GameObject gameObject, LogType logType)
	{
		LogAnalytics(logType, message, null, gameObject);
	}

	public static void LogAnalytics(LogType logType, string message, string stackTrace, params object[] args)
	{
		if ((logType == LogType.Exception || logType == LogType.Error) && (logType != 0 || !sm_isPicoGoblin) && (logType != LogType.Exception || !message.Contains("PlayFabException: /Client/WritePlayerEvent PlayFabError(ServiceUnavailable, Cannot connect to destination host, 400 BadRequest)")) && PlayFabClientAPI.IsClientLoggedIn())
		{
			if (string.IsNullOrEmpty(stackTrace))
			{
				stackTrace = Environment.StackTrace;
			}
			if (!args.IsNullOrEmpty())
			{
				message = ((!(args[0] is GameObject)) ? string.Format(message, args) : (message + " Context: " + args[0]));
			}
			string[] array = stackTrace.Split(sm_analyticsStackTraceSplit, StringSplitOptions.None);
			stackTrace = array[array.Length - 1];
			int num = 1000 - ("Error".Length + "Reason".Length + "StackTrace".Length + message.Length + logType.ToString().Length);
			if (num > 0)
			{
				stackTrace = ((stackTrace.Length <= num) ? stackTrace : stackTrace.Substring(0, num));
			}
			WandsAnalytics.SendCustomEvent(CustomEventType.player_caused_error, new Dictionary<string, object>
			{
				{ "Error", message },
				{ "Reason", logType },
				{ "StackTrace", stackTrace }
			});
		}
	}
}
namespace Assets.Scripts.Vanity
{
	public class VanityObject
	{
		public string Name { get; private set; }

		public string DefaultMaterialName { get; private set; }

		public string RimMaterialName => DefaultMaterialName + "_rim";

		public string HighlightMaterialName => DefaultMaterialName + "_highlight";

		public int Cost { get; private set; }

		public ItemRarity Rarity { get; private set; }

		public VanityObject(string name, string defaultMaterialName, int cost, ItemRarity rarity)
		{
			Name = name;
			DefaultMaterialName = defaultMaterialName;
			Cost = cost;
			Rarity = rarity;
		}
	}
}
namespace Cortopia.Scripts.Vanity
{
	public abstract class VanityUnlockable : InteractableUnlockable, IUnlockable
	{
		public Vector3 StartingPosition { get; protected set; }

		public Quaternion StartingRotation { get; protected set; }

		public abstract void Unlock(GameObject vfx);

		public Sequence MoveToUnlock(Transform parent, float time)
		{
			Sequence sequence = DOTween.Sequence();
			sequence.Insert(0f, base.transform.DOMove(parent.position, time));
			sequence.Insert(0f, base.transform.DORotateQuaternion(parent.rotation, time));
			return sequence;
		}

		public Sequence ReturnToSlot(float time)
		{
			Sequence sequence = DOTween.Sequence();
			sequence.Insert(0f, base.transform.DOMove(StartingPosition, time));
			sequence.Insert(0f, base.transform.DORotateQuaternion(StartingRotation, time));
			return sequence;
		}
	}
}
namespace Assets.Scripts.Vanity
{
	public class VirtualCurrencyObject
	{
		public ItemRarity Rarity { get; set; }

		public int Amount { get; set; }

		public string TextureName { get; set; }

		public string Name { get; set; }

		public VirtualCurrencyObject(ItemRarity rarity, int amount, string textureName, string name)
		{
			Rarity = rarity;
			Amount = amount;
			TextureName = textureName;
			Name = name;
		}
	}
}
namespace Cortopia.Scripts.Wand
{
	public class BotWandControl : WandControl
	{
		private const int MaxSpellCheckIterations = 20;

		private int m_spellCheckIterations;

		public Transform Transform
		{
			[CompilerGenerated]
			get
			{
				return base.transform;
			}
		}

		public Transform WandMeshTransform
		{
			[CompilerGenerated]
			get
			{
				return base.WandHandler.transform;
			}
		}

		protected override void OnEnable()
		{
			m_matchPausedEventToken = EventHub.Subscribe<Events.MatchPausedEvent>(base.OnMatchPaused);
			m_matchResetEventToken = EventHub.Subscribe<Events.MatchResetEvent>(base.OnMatchReset);
		}

		protected override void OnDisable()
		{
			EventHub.Unsubscribe<Events.MatchPausedEvent>(m_matchPausedEventToken);
			EventHub.Unsubscribe<Events.MatchResetEvent>(m_matchResetEventToken);
		}

		public override bool CanCastSpell()
		{
			for (int i = 0; i < base.AvailableSpells.Count; i++)
			{
				SpellBase spellBase = base.AvailableSpells[i];
				if (spellBase != null && spellBase.IsActive)
				{
					if (ShouldForceReleaseSpell(spellBase))
					{
						spellBase.SpellRelease(forceRelease: true);
					}
					return false;
				}
			}
			m_spellCheckIterations = 0;
			return true;
		}

		private bool ShouldForceReleaseSpell(SpellBase spell)
		{
			Spell type = spell.Type;
			if (type == Spell.Spell_ShieldOfLight || type == Spell.Spell_HeavenlyDome)
			{
				return false;
			}
			return m_spellCheckIterations++ >= 20;
		}

		protected override void UpdateLoadout()
		{
			if (m_spellSpawner == null)
			{
				m_spellSpawner = new WandSpellSpawner();
			}
			if (base.AvailableSpells.IsEmpty())
			{
				AddSpells(m_spellSpawner.SpawnRelics(base.Wielder, this, m_debugSpells), isLocal: true);
			}
			ResetActiveSpell();
		}

		protected override void AddSpells(SpellBase[] spells, bool isLocal)
		{
			m_availableSpellTypes = new Spell[spells.Length];
			m_spellCastCosts = new int[spells.Length];
			for (int i = 0; i < spells.Length; i++)
			{
				SpellBase spellBase = spells[i];
				m_availableSpellTypes[i] = spellBase.Type;
				m_spellCastCosts[i] = spellBase.GetCastCost();
				base.AvailableSpells.Add(spellBase);
				GenerateSpellPool(spellBase);
			}
		}

		public override void ResetActiveSpell()
		{
			base.ArcHandler.HideDots();
			base.ActiveSpell?.AbortSpellCasting(discret: false, backButtonForce: true);
			if (base.AvailableSpells.IsNullOrEmpty())
			{
				WandsLogger.LogError("WandController | Trying to reset spells without properly setting up available spells");
			}
			else
			{
				ChangeSpell(base.AvailableSpells[0]);
			}
		}

		public void SelectSpell(int spellSlotIndex)
		{
			SpellBase spellBase = base.AvailableSpells[spellSlotIndex];
			if (base.ActiveSpell != spellBase)
			{
				ChangeSpell(spellBase);
			}
		}

		protected override void ChangeSpell(SpellBase newSpell)
		{
			m_activeSpell = newSpell;
		}

		protected override void OnSystemMenuPress()
		{
		}
	}
	public interface IWandControl
	{
		bool IsConnected { get; }

		WandHandler WandHandler { get; }

		WandArcHandler ArcHandler { get; }

		Aim Aim { get; }

		PlayerAim PlayerAim { get; }

		PhotonView photonView { get; }

		int ViewID { get; }

		Wielder Wielder { get; }

		WandInput WandInput { get; }

		WandHand WandHand { get; }

		IList<SpellBase> AvailableSpells { get; }

		SpellBase ActiveSpell { get; }

		bool IsCasting { get; }

		Vector3 CachedTipPoint { get; }

		LayerMask HitMask { get; }

		void RunUpdate();

		void DestroyWand();

		void SetAim(Aim aim);

		void SetStatsData(StatsData m_healthData, StatsData m_manaData);

		void SetWandHandler(WandHandler wandHandler);

		void AddChargeEffect(WandChargeEffect chargeEffect);

		void SetChargeEffectsParent(Transform wandParent);

		void ResetPosition();

		bool IsSpellTypeSelected(Spell spell_Teleport);

		bool CanCastSpell();

		void CacheWandProperties(WandType wandType);

		void InstantiateSpells(WandInput wandInput, WandHand wandHand = WandHand.Right);

		void AbortSpellCasting(bool discrete = false, bool backButtonForce = false);

		void ResetActiveSpell();

		SpellBase TrySelectSpell(int spellSlotIndex);

		void DeselectSpell();

		bool TrySelectTeleport();

		void DeselectTeleport();

		void PlaySpellActiveSound();

		T GetSpell<T>() where T : SpellBase;

		float GetAimDistance();

		Vector3 GetTipPosition(float m_originOffset);

		Vector3 GetCurrentHitPoint(float m_collisionRadius);
	}
}
namespace Cortopia.Scripts.Wand.Properties
{
	public static class WandProperties
	{
		private static readonly JsonSerializerSettings sm_jsonSerializerSettings = new JsonSerializerSettings
		{
			PreserveReferencesHandling = PreserveReferencesHandling.Objects,
			TypeNameHandling = TypeNameHandling.All,
			Formatting = Formatting.Indented
		};

		private static Dictionary<WandType, WandProperty[]> sm_properties = new Dictionary<WandType, WandProperty[]>(15);

		public static void Create(WandType wandType, JObject parsedData)
		{
			if (parsedData.TryGetValue("Properties", StringComparison.CurrentCulture, out var value))
			{
				try
				{
					WandProperty[] properties = JsonConvert.DeserializeObject<WandProperty[]>(value.ToString(), sm_jsonSerializerSettings);
					Create(wandType, properties);
					return;
				}
				catch (Exception ex)
				{
					WandsLogger.LogError(wandType.ToString() + " | " + value.ToString() + "\n" + ex.ToString());
					return;
				}
			}
			WandsLogger.LogError($"No WandProperties found for {wandType}.", LogColor.Database);
		}

		public static void Create(WandType wandType, WandProperty[] properties)
		{
			if (properties.IsNullOrEmpty())
			{
				WandsLogger.LogError($"No properties created for {wandType}", LogColor.Database);
			}
			else
			{
				sm_properties.Add(wandType, properties);
			}
		}

		public static bool Get(WandType wandType, out WandProperty[] properties)
		{
			return sm_properties.TryGetValue(wandType, out properties);
		}
	}
}
public enum WandPropertyType
{
	UserEffect,
	PlayerEffect,
	WandEffect,
	SpellEffect,
	SplashDamageMultiplier
}
public enum DamageMultiplierType
{
	General,
	Fire,
	Cold,
	Electric
}
[Serializable]
public abstract class WandProperty
{
	public float Value;

	public float ValueDouble;

	public virtual string Description
	{
		[CompilerGenerated]
		get
		{
			return $"Wands/Properties/{GetType()}";
		}
	}

	public abstract WandPropertyType Type { get; }

	public override string ToString()
	{
		return $"{GetType()} of type: {Type} | Values: {Value} / {ValueDouble}";
	}

	public virtual string GetLocalizationValue(bool applyDoubleEffect)
	{
		return Mathf.RoundToInt(GetValue(applyDoubleEffect) * 100f % 100f).WithPrefix();
	}

	protected float GetValue(bool applyDoubleValue)
	{
		return (!applyDoubleValue) ? Value : ValueDouble;
	}

	protected float GetMultiplierValue(bool applyDoubleValue)
	{
		return ((!applyDoubleValue) ? Value : ValueDouble) - 1f;
	}
}
[Serializable]
public abstract class UserEffect : WandProperty
{
	public override WandPropertyType Type
	{
		[CompilerGenerated]
		get
		{
			return WandPropertyType.UserEffect;
		}
	}

	public abstract void Apply(ref RewardModifiers rewardModifiers, bool applyDoubleEffect);
}
[Serializable]
public abstract class PlayerEffect : WandProperty
{
	public override WandPropertyType Type
	{
		[CompilerGenerated]
		get
		{
			return WandPropertyType.PlayerEffect;
		}
	}

	public abstract void Apply(ref PlayerStats playerStats, bool applyDoubleEffect, WandHand wandHand);
}
[Serializable]
public abstract class WandEffect : WandProperty
{
	public override WandPropertyType Type
	{
		[CompilerGenerated]
		get
		{
			return WandPropertyType.WandEffect;
		}
	}

	public override string GetLocalizationValue(bool applyDoubleEffect)
	{
		return string.Empty;
	}

	public abstract void Apply(ref ActiveWandEffects activeWandEffects);
}
[Serializable]
public abstract class SpellEffect : WandProperty
{
	public override WandPropertyType Type
	{
		[CompilerGenerated]
		get
		{
			return WandPropertyType.SpellEffect;
		}
	}

	public abstract void Apply(ref SpellBase spell, bool applyDoubleEffects);
}
[Serializable]
public class ExperienceProperty : UserEffect
{
	public override void Apply(ref RewardModifiers rewardModifiers, bool applyDoubleEffect)
	{
		rewardModifiers.Experience += GetMultiplierValue(applyDoubleEffect);
		if (rewardModifiers.Experience < 0f)
		{
			WandsLogger.LogError("Experience multiplier is below 0.", LogColor.WandProperty);
			rewardModifiers.Experience = 0f;
		}
	}
}
[Serializable]
public class CurrencyProperty : UserEffect
{
	public override string GetLocalizationValue(bool applyDoubleEffect)
	{
		return Mathf.RoundToInt(GetValue(applyDoubleEffect) * 100f - 100f).WithPrefix();
	}

	public override void Apply(ref RewardModifiers rewardModifiers, bool applyDoubleEffect)
	{
		rewardModifiers.Currency += GetMultiplierValue(applyDoubleEffect);
		if (rewardModifiers.Currency < 0f)
		{
			WandsLogger.LogError("Currency multiplier is below 0.", LogColor.WandProperty);
			rewardModifiers.Currency = 0f;
		}
	}
}
[Serializable]
public class ScoreProperty : UserEffect
{
	public override void Apply(ref RewardModifiers rewardModifiers, bool applyDoubleEffect)
	{
		rewardModifiers.Score += GetMultiplierValue(applyDoubleEffect);
		if (rewardModifiers.Score < 0f)
		{
			WandsLogger.LogError("Score multiplier is below 0.", LogColor.WandProperty);
			rewardModifiers.Score = 0f;
		}
	}
}
[Serializable]
public class KOWinProperty : UserEffect
{
	public override void Apply(ref RewardModifiers rewardModifiers, bool applyDoubleEffect)
	{
		rewardModifiers.KOMultiplier.WinMultiplier += GetMultiplierValue(applyDoubleEffect);
		if (rewardModifiers.KOMultiplier.WinMultiplier < 0f)
		{
			WandsLogger.LogError("KO Win multiplier is below 0.", LogColor.WandProperty);
			rewardModifiers.KOMultiplier.WinMultiplier = 0f;
		}
	}
}
[Serializable]
public class KOLoseProperty : UserEffect
{
	public override void Apply(ref RewardModifiers rewardModifiers, bool applyDoubleEffect)
	{
		rewardModifiers.KOMultiplier.LoseMultiplier += GetMultiplierValue(applyDoubleEffect);
		if (rewardModifiers.KOMultiplier.LoseMultiplier < 0f)
		{
			WandsLogger.LogError("KO Lose multiplier is below 0.", LogColor.WandProperty);
			rewardModifiers.KOMultiplier.LoseMultiplier = 0f;
		}
	}
}
[Serializable]
public class MaxManaProperty : PlayerEffect
{
	public override string GetLocalizationValue(bool applyDoubleEffect)
	{
		return GetValue(applyDoubleEffect).WithPrefix();
	}

	public override void Apply(ref PlayerStats playerStats, bool applyDoubleEffect, WandHand wandHand)
	{
		playerStats.MaxMana += GetValue(applyDoubleEffect);
	}
}
[Serializable]
public class ManaRegenProperty : PlayerEffect
{
	public override string GetLocalizationValue(bool applyDoubleEffect)
	{
		return Mathf.RoundToInt((GetValue(applyDoubleEffect) - 1f) * 100f % 100f).WithPrefix();
	}

	public override void Apply(ref PlayerStats playerStats, bool applyDoubleEffect, WandHand wandHand)
	{
		playerStats.ManaRegen *= GetValue(applyDoubleEffect);
	}
}
[Serializable]
public class ManaRestoreOnHitProperty : PlayerEffect
{
	public override string GetLocalizationValue(bool applyDoubleEffect)
	{
		return GetValue(applyDoubleEffect).WithPrefix();
	}

	public override void Apply(ref PlayerStats playerStats, bool applyDoubleEffect, WandHand wandHand)
	{
		playerStats.ManaRestoreOnDamageTakenMultiplier = new ActivatableValue(GetValue(applyDoubleEffect), wandHand);
	}
}
[Serializable]
public class MaxHealthProperty : PlayerEffect
{
	public override string GetLocalizationValue(bool applyDoubleEffect)
	{
		return GetValue(applyDoubleEffect).WithPrefix();
	}

	public override void Apply(ref PlayerStats playerStats, bool applyDoubleEffect, WandHand wandHand)
	{
		playerStats.MaxHealth += GetValue(applyDoubleEffect);
	}
}
[Serializable]
public class DamageTakenProperty : PlayerEffect
{
	public override string Description
	{
		[CompilerGenerated]
		get
		{
			return string.Format("Wands/Properties/DamageTaken{0}", (!(Value < 1f)) ? "Increased" : "Reduced");
		}
	}

	public override string GetLocalizationValue(bool applyDoubleEffect)
	{
		return Mathf.Abs(Mathf.RoundToInt((1f - GetValue(applyDoubleEffect)) * 100f % 100f)).ToString();
	}

	public override void Apply(ref PlayerStats playerStats, bool applyDoubleEffect, WandHand wandHand)
	{
		playerStats.DamageTakenMultiplier += GetMultiplierValue(applyDoubleEffect);
		if (playerStats.DamageTakenMultiplier < 0f)
		{
			WandsLogger.LogError("Damage multiplier is below 0.", LogColor.WandProperty);
			playerStats.DamageTakenMultiplier = 0f;
		}
	}
}
[Serializable]
public class HealBonusProperty : PlayerEffect
{
	public override void Apply(ref PlayerStats playerStats, bool applyDoubleEffect, WandHand wandHand)
	{
		playerStats.HealMultiplier += GetMultiplierValue(applyDoubleEffect);
		if (playerStats.HealMultiplier < 0f)
		{
			WandsLogger.LogError("Heal multiplier is below 0.", LogColor.WandProperty);
			playerStats.DamageTakenMultiplier = 0f;
		}
	}
}
[Serializable]
public class StartingArmorProperty : PlayerEffect
{
	public override string GetLocalizationValue(bool applyDoubleEffect)
	{
		return GetValue(applyDoubleEffect).WithPrefix();
	}

	public override void Apply(ref PlayerStats playerStats, bool applyDoubleEffect, WandHand wandHand)
	{
		playerStats.StartingArmor = new ActivatableValue(GetValue(applyDoubleEffect), wandHand);
	}
}
[Serializable]
public class AlwaysCursedProperty : PlayerEffect
{
	public override string GetLocalizationValue(bool applyDoubleEffect)
	{
		return string.Empty;
	}

	public override void Apply(ref PlayerStats playerStats, bool applyDoubleEffect, WandHand wandHand)
	{
		playerStats.IsAlwaysCursed = true;
	}
}
[Serializable]
public class AutoLeapProperty : PlayerEffect
{
	public const float ContinuousAutoLeapPerSeconds = 1f;

	public override void Apply(ref PlayerStats playerStats, bool applyDoubleEffect, WandHand wandHand)
	{
		playerStats.AutoCastLeapOnHitChance = new ActivatableValue(GetValue(applyDoubleEffect), wandHand);
	}
}
[Serializable]
public class HealTileProperty : PlayerEffect
{
	public override string GetLocalizationValue(bool applyDoubleEffect)
	{
		return GetValue(applyDoubleEffect).WithPrefix();
	}

	public override void Apply(ref PlayerStats playerStats, bool applyDoubleEffect, WandHand wandHand)
	{
		playerStats.AddHealToTileAfterSeconds = new ActivatableValue(GetValue(applyDoubleEffect), wandHand);
	}
}
[Serializable]
public class ManaRestoringPickupsProperty : PlayerEffect
{
	public override string GetLocalizationValue(bool applyDoubleEffect)
	{
		return GetValue(applyDoubleEffect).WithPrefix();
	}

	public override void Apply(ref PlayerStats playerStats, bool applyDoubleEffect, WandHand wandHand)
	{
		playerStats.ManaRestoringPickups = new ActivatableValue(GetValue(applyDoubleEffect), wandHand);
	}
}
[Serializable]
public class AcidTeleportProperty : WandEffect
{
	public override void Apply(ref ActiveWandEffects activeWandEffects)
	{
		activeWandEffects.AcidTeleport = new ActivatableValue(Value);
	}
}
[Serializable]
public class AlternateSpellLookProperty : WandEffect
{
	public override void Apply(ref ActiveWandEffects activeWandEffects)
	{
		activeWandEffects.UseAlternateSpellVisuals = true;
	}
}
[Serializable]
public class TeleportCostProperty : SpellEffect
{
	public override string GetLocalizationValue(bool applyDoubleEffect)
	{
		return GetValue(applyDoubleEffect).WithPrefix();
	}

	public override void Apply(ref SpellBase spell, bool applyDoubleEffect)
	{
		if (spell.Type == Spell.Spell_Teleport)
		{
			spell.SetCastCost((int)((float)spell.GetCastCost() + GetValue(applyDoubleEffect)));
		}
	}
}
[Serializable]
public class SummonedCostProperty : SpellEffect
{
	public override void Apply(ref SpellBase spell, bool applyDoubleEffect)
	{
		Spell type = spell.Type;
		if (type == Spell.Spell_FlamingPhoenix || type == Spell.Spell_StoneDemon || type == Spell.Spell_Oxymora || type == Spell.Spell_SkullSpecter)
		{
			spell.SetCastCost((int)((float)spell.GetCastCost() * GetValue(applyDoubleEffect)));
		}
	}
}
[Serializable]
public class DamageDealtProperty : SpellEffect
{
	public override void Apply(ref SpellBase spell, bool applyDoubleEffect)
	{
		spell.ApplyDamageMultiplier(GetValue(applyDoubleEffect));
	}
}
[Serializable]
public class FireDamageProperty : SpellEffect
{
	public override void Apply(ref SpellBase spell, bool applyDoubleEffect)
	{
		switch (spell.Type)
		{
		case Spell.Spell_DevilsSpit:
		case Spell.Spell_FlamingPhoenix:
		case Spell.Spell_BlazingMeteor:
		case Spell.Spell_DragonsBreath:
		case Spell.Spell_Rocket:
			spell.ApplyDamageMultiplier(GetValue(applyDoubleEffect));
			break;
		}
	}
}
[Serializable]
public class ElectricDamageProperty : SpellEffect
{
	public override void Apply(ref SpellBase spell, bool applyDoubleEffect)
	{
		Spell type = spell.Type;
		if (type == Spell.Spell_LightningStrike || type == Spell.Spell_ElectricFist)
		{
			spell.ApplyDamageMultiplier(GetValue(applyDoubleEffect));
		}
	}
}
[Serializable]
public class ColdDamageProperty : SpellEffect
{
	public override void Apply(ref SpellBase spell, bool applyDoubleEffect)
	{
		Spell type = spell.Type;
		if (type == Spell.Spell_HailOfDeath || type == Spell.Spell_ChillingClutch)
		{
			spell.ApplyDamageMultiplier(GetValue(applyDoubleEffect));
		}
	}
}
[Serializable]
public class SplashDamageProperty : SpellEffect
{
	public override WandPropertyType Type
	{
		[CompilerGenerated]
		get
		{
			return WandPropertyType.SplashDamageMultiplier;
		}
	}

	public override void Apply(ref SpellBase spell, bool applyDoubleEffect)
	{
		WandsLogger.LogError("Splash Damage should be called using its custom Apply method.", LogColor.WandProperty);
	}

	public void Apply(ref SpellBase spell, bool applyDoubleEffect, IDictionary<DamageMultiplierType, float> activeDamageMultipliers)
	{
		if (activeDamageMultipliers.IsNullOrEmpty())
		{
			return;
		}
		SpellBase_Projectile spellBase_Projectile = spell as SpellBase_Projectile;
		if (spellBase_Projectile == null || !spellBase_Projectile.HasSplashDamageData)
		{
			return;
		}
		float num = GetValue(applyDoubleEffect);
		float value = 0f;
		if (activeDamageMultipliers.TryGetValue(DamageMultiplierType.General, out value))
		{
			num += value % 1f;
		}
		switch (spellBase_Projectile.Type)
		{
		case Spell.Spell_FlamingPhoenix:
		case Spell.Spell_BlazingMeteor:
			if (activeDamageMultipliers.TryGetValue(DamageMultiplierType.Fire, out value))
			{
				num += value % 1f;
			}
			break;
		case Spell.Spell_LightningStrike:
		case Spell.Spell_ElectricFist:
			if (activeDamageMultipliers.TryGetValue(DamageMultiplierType.Electric, out value))
			{
				num += value % 1f;
			}
			break;
		case Spell.Spell_HailOfDeath:
		case Spell.Spell_ChillingClutch:
			if (activeDamageMultipliers.TryGetValue(DamageMultiplierType.Cold, out value))
			{
				num += value % 1f;
			}
			break;
		}
		spellBase_Projectile.ApplySplashDamageMultiplier(num);
	}
}
namespace Cortopia.Scripts.Wand
{
	public class WandArcHandler : MonoBehaviour
	{
		private const int ArcPointsCount = 30;

		[Header("Arc trajectory settings")]
		[SerializeField]
		private GameObject m_trajectoryPrefab;

		private IList<GameObject> m_dots = new List<GameObject>(30);

		private IList<Vector3> m_arcPositions = new List<Vector3>(30);

		public void Clear()
		{
			m_dots.Clear();
		}

		public void TryInstantiateDotPool(IList<Spell> availableSpellTypes)
		{
			if (availableSpellTypes.Contains(Spell.Spell_DevilsSpit) || availableSpellTypes.Contains(Spell.Spell_FlamingPhoenix))
			{
				InstantiateDotPool();
			}
		}

		private void InstantiateDotPool()
		{
			if (base.transform.RetrieveChild("ProjectorPool") != null)
			{
				return;
			}
			GameObject gameObject = new GameObject("ProjectorPool");
			gameObject.transform.SetParent(base.transform);
			for (int i = 0; i < 30; i++)
			{
				GameObject gameObject2;
				if (m_trajectoryPrefab != null)
				{
					gameObject2 = UnityEngine.Object.Instantiate(m_trajectoryPrefab);
				}
				else
				{
					gameObject2 = GameObject.CreatePrimitive(PrimitiveType.Sphere);
					gameObject2.transform.localScale *= 0.1f;
					UnityEngine.Object.Destroy(gameObject2.GetComponent<Collider>());
				}
				gameObject2.transform.SetParent(gameObject.transform);
				gameObject2.SetActive(value: false);
				m_dots.Add(gameObject2);
			}
		}

		public void CalculateProjectileCurve(Vector3[] points, bool bounceActive, Vector3 offset = default(Vector3))
		{
			if (m_dots.IsEmpty())
			{
				return;
			}
			if (points.Length < 3)
			{
				WandsLogger.LogError("Trying to calculate projectile curve with less than 3 points");
				return;
			}
			if (m_arcPositions.Count > 0)
			{
				m_arcPositions.Clear();
			}
			float f = Vector3.Distance(points[0], points[1]) + Vector3.Distance(points[1], points[2]);
			int num = Mathf.Clamp(5 + Mathf.CeilToInt(f), 5, (!bounceActive) ? m_dots.Count : (m_dots.Count - 6));
			float num2 = 0f;
			Vector3 zero = Vector3.zero;
			for (int i = 1; i < m_dots.Count; i++)
			{
				if (i > num)
				{
					m_dots[i].SetActive(value: false);
					continue;
				}
				num2 = (float)i / ((float)num - 1f);
				zero = Bezier.GetPoint(points[0], points[1], points[2], num2);
				if (!m_arcPositions.Contains(zero))
				{
					m_arcPositions.Add(zero);
					m_dots[i].transform.position = zero + offset;
					m_dots[i].SetActive(value: true);
				}
			}
		}

		public void HideDots(bool clearArcPositions = false)
		{
			if (m_dots.IsEmpty())
			{
				return;
			}
			if (clearArcPositions)
			{
				m_arcPositions.Clear();
			}
			foreach (GameObject dot in m_dots)
			{
				if (!(dot == null) && dot.activeSelf)
				{
					dot.SetActive(value: false);
				}
			}
		}
	}
	[RequireComponent(typeof(AudioSource))]
	public class WandControl : MonoBehaviourPun, IPunInstantiateMagicCallback, IPauseObject, IWandControl
	{
		protected const string UIChooseClipName = "ui_choose";

		[SerializeField]
		private WandArcHandler m_arcHandler;

		[SerializeField]
		private LayerMask m_hitMask = -1;

		[Header("Debug")]
		[SerializeField]
		protected Spell[] m_debugSpells = Array.Empty<Spell>();

		protected StatsData m_healthData;

		protected StatsData m_manaData;

		protected WandSpellSpawner m_spellSpawner;

		protected SpellBase m_activeSpell;

		protected SpellBase m_previouslyActiveSpell;

		protected AudioSource m_audioSource;

		protected WandHandler m_wandHandler;

		protected WandType m_wandType;

		protected Spell[] m_availableSpellTypes;

		protected int[] m_spellCastCosts;

		protected EventToken m_matchPausedEventToken;

		protected EventToken m_matchResetEventToken;

		private bool m_isWandPositionValid;

		private bool m_hasHandTracking = true;

		private IList<SpellEffect> m_activeSpellEffects;

		private ActiveWandEffects m_activeEffects;

		private IList<WandChargeEffect> m_wandChargeEffects = new List<WandChargeEffect>(5);

		private IDictionary<DamageMultiplierType, float> m_activeDamageMultipliers;

		private EventToken m_systemMenuInputEventToken;

		private EventToken m_platformInputUpdatedEventToken;

		private EventToken m_tileAreaExitEventToken;

		public bool IsPaused { get; private set; }

		public bool IsConnected
		{
			[CompilerGenerated]
			get
			{
				return NetworkUtils.ConnectedToGame && base.photonView != null && base.photonView.ViewID > 0;
			}
		}

		public WandHandler WandHandler
		{
			[CompilerGenerated]
			get
			{
				return (!(m_wandHandler != null)) ? null : m_wandHandler;
			}
		}

		public WandArcHandler ArcHandler
		{
			[CompilerGenerated]
			get
			{
				return m_arcHandler;
			}
		}

		public Aim Aim { get; private set; }

		public PlayerAim PlayerAim { get; private set; }

		public int ViewID
		{
			[CompilerGenerated]
			get
			{
				return base.photonView.ViewID;
			}
		}

		public Wielder Wielder { get; private set; }

		public WandInput WandInput { get; protected set; }

		public WandHand WandHand { get; protected set; }

		public IList<SpellBase> AvailableSpells { get; private set; } = new List<SpellBase>(5);


		public SpellBase ActiveSpell
		{
			[CompilerGenerated]
			get
			{
				return (!(m_activeSpell != null)) ? null : m_activeSpell;
			}
		}

		public bool IsCasting
		{
			[CompilerGenerated]
			get
			{
				bool? flag = ActiveSpell?.IsActive;
				return flag.HasValue && flag.Value;
			}
		}

		public Vector3 CachedTipPoint { get; protected set; }

		public LayerMask HitMask
		{
			[CompilerGenerated]
			get
			{
				return m_hitMask;
			}
		}

		protected virtual bool ApplyDoubleWandPropertyEffects
		{
			[CompilerGenerated]
			get
			{
				return false;
			}
		}

		private void OnDestroy()
		{
			if (base.photonView.IsLocal() || !NetworkUtils.ConnectedToGame)
			{
				EventHub.Publish(new InputEvents.WandControllerDespawnedEvent());
			}
		}

		protected virtual void OnEnable()
		{
			m_matchPausedEventToken = EventHub.Subscribe<Events.MatchPausedEvent>(OnMatchPaused);
			m_matchResetEventToken = EventHub.Subscribe<Events.MatchResetEvent>(OnMatchReset);
			if (base.photonView.IsLocal() || !NetworkUtils.ConnectedToGame)
			{
				m_systemMenuInputEventToken = EventHub.Subscribe<InputEvents.SystemMenuInputEvent>(OnSystemMenuPress);
				m_platformInputUpdatedEventToken = EventHub.Subscribe<InputEvents.InputChangedEvent>(OnInputUpdated);
				m_tileAreaExitEventToken = EventHub.Subscribe<Events.TileAreaExitEvent>(OnTileAreaExit);
				InputTracking.trackingAcquired += OnTrackingAquired;
				InputTracking.trackingLost += OnTrackingLost;
			}
		}

		protected virtual void OnDisable()
		{
			EventHub.Unsubscribe<Events.MatchPausedEvent>(m_matchPausedEventToken);
			EventHub.Unsubscribe<Events.MatchResetEvent>(m_matchResetEventToken);
			if (base.photonView.IsLocal() || !NetworkUtils.ConnectedToGame)
			{
				EventHub.Unsubscribe<InputEvents.SystemMenuInputEvent>(m_systemMenuInputEventToken);
				EventHub.Unsubscribe<InputEvents.InputChangedEvent>(m_platformInputUpdatedEventToken);
				EventHub.Unsubscribe<Events.TileAreaExitEvent>(m_tileAreaExitEventToken);
				InputTracking.trackingAcquired -= OnTrackingAquired;
				InputTracking.trackingLost -= OnTrackingLost;
			}
		}

		private void Awake()
		{
			m_audioSource = GetComponent<AudioSource>();
		}

		public virtual void OnPhotonInstantiate(PhotonMessageInfo info)
		{
			if (Wielder != null)
			{
				return;
			}
			PhotonView photonView = PhotonView.Find((int)base.photonView.InstantiationData[0]);
			if (photonView != null)
			{
				Wielder = photonView.GetComponent<Wielder>();
			}
			else
			{
				for (int i = 0; i < PlayerManager.Instance.WielderCount; i++)
				{
					Wielder wielder = PlayerManager.Instance.AllWielders[i];
					if (wielder.photonView.Owner.IsLocal == base.photonView.Owner.IsLocal)
					{
						Wielder = wielder;
					}
				}
			}
			if (Wielder == null)
			{
				WandsLogger.LogError("Couldn't connect to Wielder!", base.gameObject);
				return;
			}
			base.transform.SetParent((!info.Sender.IsLocal) ? Wielder.RemoteCharacter.transform : Wielder.CharacterControl.transform, ResetBehaviour.Position);
			if (!Wielder.IsBot)
			{
				WandHand = (WandHand)(int)base.photonView.InstantiationData[1];
				if (Wielder.RemoteCharacter != null)
				{
					Wielder.RemoteCharacter.Wand = this;
				}
			}
		}

		public void Pause(bool pause)
		{
			IsPaused = pause;
			if (pause && base.photonView.IsLocal())
			{
				AbortSpellCasting(discrete: false, backButtonForce: true);
			}
		}

		public void RunUpdate()
		{
			UpdateTipPoint();
			ValidateWandPosition();
		}

		public void DestroyWand()
		{
			if (!(this == null) && !(base.gameObject == null))
			{
				OnDisable();
				ArcHandler.Clear();
				ClearAllSpells();
				ObjectPoolHandler.DestroySpellPool();
				if (NetworkUtils.ConnectedToGame && base.photonView.ViewID > 0 && base.photonView.IsMine)
				{
					NetworkUtils.DestroyObject(base.photonView);
				}
				else if (base.gameObject != null)
				{
					UnityEngine.Object.Destroy(base.gameObject);
				}
			}
		}

		private void ClearAllSpells()
		{
			for (int i = 0; i < AvailableSpells.Count; i++)
			{
				SpellBase spellBase = AvailableSpells[i];
				if (!(spellBase == null))
				{
					if (spellBase is Spell_DevilsTwins)
					{
						(spellBase as Spell_DevilsTwins).ClearDuplicates();
					}
					else if (spellBase is Tile_AreaEffect)
					{
						(spellBase as Tile_AreaEffect).RemoveActiveEffect();
					}
					spellBase.AbortSpellCasting(discret: true);
					spellBase.ResetSpellEffectors();
					NetworkUtils.DestroyObject(spellBase.photonView);
					m_availableSpellTypes[i] = Spell.None;
					m_spellCastCosts[i] = 0;
				}
			}
			AvailableSpells.Clear();
		}

		public void SetAim(Aim aim)
		{
			Aim = aim;
			PlayerAim = aim as PlayerAim;
		}

		public void SetStatsData(StatsData healthData, StatsData manaData)
		{
			m_healthData = healthData;
			m_manaData = manaData;
		}

		public virtual void SetWandHandler(WandHandler wandHandler)
		{
			m_wandHandler = wandHandler;
			m_wandHandler.UpdateLoadout(m_availableSpellTypes.Skip(1).ToList(), m_spellCastCosts);
			m_wandHandler.SetRelicHighlighted(-1);
		}

		public void AddChargeEffect(WandChargeEffect chargeEffect)
		{
			if (!(chargeEffect == null) && !m_wandChargeEffects.Contains(chargeEffect))
			{
				m_wandChargeEffects.Add(chargeEffect);
			}
		}

		public void SetChargeEffectsParent(Transform wandParent)
		{
			for (int i = 0; i < m_wandChargeEffects.Count; i++)
			{
				m_wandChargeEffects[i].SetWandParent(wandParent);
			}
		}

		public void ResetPosition()
		{
			Vector3 zero = Vector3.zero;
			zero.y = 1.7f;
			base.transform.localPosition = zero;
		}

		public bool IsSpellTypeSelected(Spell spellType)
		{
			bool? flag = ActiveSpell?.IsType(spellType);
			return flag.HasValue && flag.Value;
		}

		public virtual bool CanCastSpell()
		{
			for (int i = 0; i < AvailableSpells.Count; i++)
			{
				SpellBase spellBase = AvailableSpells[i];
				if (spellBase != null && spellBase.IsActive)
				{
					return false;
				}
			}
			return true;
		}

		public void CacheWandProperties(WandType wandType)
		{
			m_activeEffects = default(ActiveWandEffects);
			if (!WandProperties.Get(GameControl.Instance.Player.GetWand(WandHand), out var properties))
			{
				return;
			}
			m_activeSpellEffects = new List<SpellEffect>(properties.Length);
			m_activeDamageMultipliers = new Dictionary<DamageMultiplierType, float>(properties.Length);
			WandProperty[] array = properties;
			foreach (WandProperty wandProperty in array)
			{
				switch (wandProperty.Type)
				{
				case WandPropertyType.WandEffect:
					(wandProperty as WandEffect).Apply(ref m_activeEffects);
					break;
				case WandPropertyType.SpellEffect:
				{
					SpellEffect spellEffect = wandProperty as SpellEffect;
					m_activeSpellEffects.Add(spellEffect);
					TryCacheDamageMultiplier(spellEffect, ApplyDoubleWandPropertyEffects);
					break;
				}
				case WandPropertyType.SplashDamageMultiplier:
					m_activeSpellEffects.Add(wandProperty as SpellEffect);
					break;
				}
			}
		}

		public virtual void InstantiateSpells(WandInput wandInput, WandHand wandHand = WandHand.Right)
		{
			WandInput = wandInput;
			WandHand = wandHand;
			m_wandType = GameControl.Instance.Player.GetWand(wandHand);
			ResetSpells();
			UpdateLoadout();
		}

		private void ResetSpells()
		{
			for (int i = 0; i < AvailableSpells.Count; i++)
			{
				SpellBase spellBase = AvailableSpells[i];
				if (spellBase != null)
				{
					spellBase.AbortSpellCasting(discret: false, backButtonForce: true);
					spellBase.ResetSpellEffectors();
				}
			}
		}

		protected virtual void UpdateLoadout()
		{
			if (m_spellSpawner == null)
			{
				m_spellSpawner = new WandSpellSpawner();
			}
			if (AvailableSpells.IsEmpty())
			{
				AddSpells(m_spellSpawner.SpawnRelics(Wielder, this, m_debugSpells, WandHand), isLocal: true);
			}
			ArcHandler.TryInstantiateDotPool(m_availableSpellTypes);
			if (IsConnected)
			{
				base.photonView.RPC("PunUpdateLoadout", RpcTarget.OthersBuffered, (int)m_wandType);
			}
		}

		[PunRPC]
		protected void PunUpdateLoadout(int wandTypeIndex)
		{
			CacheWandProperties((WandType)wandTypeIndex);
			AddSpells(GetComponentsInChildren<SpellBase>(), isLocal: false);
		}

		protected virtual void AddSpells(SpellBase[] spells, bool isLocal)
		{
			m_availableSpellTypes = new Spell[spells.Length];
			m_spellCastCosts = new int[spells.Length];
			for (int i = 0; i < spells.Length; i++)
			{
				SpellBase spellBase = spells[i];
				TryApplyModifierToSpell(spellBase);
				m_availableSpellTypes[i] = spellBase.Type;
				m_spellCastCosts[i] = spellBase.GetCastCost();
				AvailableSpells.Add(spellBase);
				AddChargeEffect(spellBase.WandChargeEffect);
				if (isLocal)
				{
					GenerateSpellPool(spellBase);
				}
				else
				{
					RemoteGenerateSpellPool(spellBase, spellBase.Type != Spell.Spell_FlamingPhoenix);
				}
			}
			if (isLocal && m_activeEffects.AcidTeleport.IsActive)
			{
				EnableAcidTeleport();
			}
		}

		private void TryApplyModifierToSpell(SpellBase spell)
		{
			SpellEffect[] array = m_activeSpellEffects.ToArray();
			foreach (SpellEffect spellEffect in array)
			{
				if (spellEffect.Type == WandPropertyType.SplashDamageMultiplier)
				{
					(spellEffect as SplashDamageProperty).Apply(ref spell, ApplyDoubleWandPropertyEffects, m_activeDamageMultipliers);
				}
				else
				{
					spellEffect.Apply(ref spell, ApplyDoubleWandPropertyEffects);
				}
			}
		}

		protected void GenerateSpellPool(SpellBase spell)
		{
			int viewID = spell.photonView.ViewID;
			switch (spell.Type)
			{
			case Spell.Spell_Teleport:
				if (!ObjectPoolHandler.GetPoolContainsObject(PoolObjectType.Teleport) && !ObjectPoolHandler.GetPoolContainsObject(PoolObjectType.TeleportArrive))
				{
					ObjectPoolHandler.CreateObjectPoolAsync(spell.PoolSize, PoolObjectType.Teleport);
					ObjectPoolHandler.CreateObjectPoolAsync(spell.PoolSize, PoolObjectType.TeleportArrive);
				}
				break;
			case Spell.Spell_ShieldOfLight:
			case Spell.Spell_HeavenlyDome:
			case Spell.Spell_ChaosLeap:
			case Spell.Spell_DragonsBreath:
			case Spell.Spell_CalciteShield:
				break;
			case Spell.Spell_ArmorOfTheSun:
				ObjectPoolHandler.CreateObjectPoolAsync(spell.PoolSize, PoolObjectType.ArmorOfTheSunStart);
				ObjectPoolHandler.CreateObjectPoolAsync(spell.PoolSize, PoolObjectType.ArmorOfTheSunEnd);
				break;
			case Spell.Spell_LightningStrike:
			case Spell.Spell_AcidCloud:
			case Spell.Spell_HailOfDeath:
			case Spell.Spell_DevilsSpit:
			case Spell.Spell_ElectricFist:
			case Spell.Spell_BlazingMeteor:
			case Spell.Spell_SoilSpikes:
			case Spell.Spell_PetrifyingPrison:
			case Spell.Spell_MagicMissile:
			case Spell.Spell_BloodBolt:
			case Spell.Spell_Demi:
			case Spell.Spell_DiscOfAntioch:
			case Spell.Spell_ChillingClutch:
				ObjectPoolHandler.CreateSpellPool(spell.PoolSize, spell.Type, viewID);
				break;
			case Spell.Spell_DevilsTwins:
				ObjectPoolHandler.CreateObjectPoolAsync(spell.PoolSize, PoolObjectType.DevilsTwinDead);
				break;
			case Spell.Spell_FlamingPhoenix:
				if (PunSingleton<SceneControl>.Instance.CurrentMatchType.ContainsFlag(MatchType.SinglePlayer))
				{
					ObjectPoolHandler.CreateSpellPool(spell.PoolSize, spell.Type, viewID);
				}
				break;
			case Spell.Spell_StoneDemon:
				ObjectPoolHandler.CreateSpellPool(spell.PoolSize, spell.Type, viewID, new PoolObjectType[1] { PoolObjectType.StoneDemonProjectile });
				break;
			case Spell.Spell_CurseOfTheUndead:
				ObjectPoolHandler.CreateSpellPool(spell.PoolSize, spell.Type, (PoolObjectCreateState)6, viewID, new PoolObjectType[2]
				{
					PoolObjectType.CurseOfTheUndeadExplosion,
					PoolObjectType.CurseOfTheUndeadLingering
				});
				break;
			case Spell.Spell_Oxymora:
				ObjectPoolHandler.CreateSpellPool(spell.PoolSize, spell.Type, viewID, new PoolObjectType[2]
				{
					PoolObjectType.OxymoraProjectileBad,
					PoolObjectType.OxymoraProjectileGood
				});
				break;
			case Spell.Spell_CerberusCollars:
				ObjectPoolHandler.CreateSpellPool(spell.PoolSize, spell.Type, viewID, new PoolObjectType[1] { PoolObjectType.CerberusCollarsInit });
				break;
			case Spell.Spell_SkullSpecter:
				ObjectPoolHandler.CreateSpellPool(spell.PoolSize, spell.Type, viewID, new PoolObjectType[2]
				{
					PoolObjectType.SkullSpecterInit,
					PoolObjectType.SkullSpecterProjectile
				});
				break;
			case Spell.Spell_CrystalShards:
				ObjectPoolHandler.CreateSpellPool(spell.PoolSize, spell.Type, viewID);
				break;
			default:
				throw new NotImplementedException($"Couldn't create spell pool for {spell.Type}.");
			}
		}

		private void RemoteGenerateSpellPool(SpellBase spell, bool checkForDuplicates)
		{
			if (!checkForDuplicates || !GameControl.Instance.Player.ActiveLoadout.Spells.Contains(spell.Type))
			{
				int viewID = spell.photonView.ViewID;
				switch (spell.Type)
				{
				case Spell.Spell_CurseOfTheUndead:
					ObjectPoolHandler.CreateSpellPool(spell.PoolSize, spell.Type, (PoolObjectCreateState)6, viewID, new PoolObjectType[2]
					{
						PoolObjectType.CurseOfTheUndeadExplosion,
						PoolObjectType.CurseOfTheUndeadLingering
					});
					break;
				case Spell.Spell_DevilsTwins:
					ObjectPoolHandler.CreateObjectPoolAsync(spell.PoolSize, PoolObjectType.DevilsTwinDead);
					break;
				case Spell.Spell_FlamingPhoenix:
					ObjectPoolHandler.CreateSpellPool(spell.PoolSize, spell.Type, viewID);
					break;
				}
			}
		}

		public virtual void AbortSpellCasting(bool discrete = false, bool backButtonForce = false)
		{
			if (!(m_activeSpell == null))
			{
				m_activeSpell.AbortSpellCasting(discrete, backButtonForce);
				if (WandInput != WandInput.Point && m_activeSpell.IsType(Spell.Spell_Teleport))
				{
					DeselectSpell();
				}
			}
		}

		public virtual void ResetActiveSpell()
		{
			ArcHandler.HideDots();
			if (m_activeSpell != null)
			{
				m_activeSpell.AbortSpellCasting(discret: false, backButtonForce: true);
				m_activeSpell = null;
			}
		}

		protected virtual void ChangeSpell(SpellBase newSpell)
		{
			if (m_activeSpell != newSpell)
			{
				SpellBase activeSpell = m_activeSpell;
				m_activeSpell = newSpell;
				if (activeSpell != null)
				{
					activeSpell.OnSpellChange();
				}
			}
			newSpell.OnSpellSelect();
			PlayerAim?.SetAimReticle(newSpell.ReticleType);
			WandHandler?.SetRelicHighlighted(AvailableSpells.IndexOf(newSpell) - 1);
		}

		public SpellBase TrySelectSpell(int spellSlotIndex)
		{
			bool? flag = ActiveSpell?.IsActive;
			if (flag.HasValue && flag.Value)
			{
				return null;
			}
			SpellBase spellBase = AvailableSpells[spellSlotIndex];
			ChangeSpell(spellBase);
			return spellBase;
		}

		public void DeselectSpell()
		{
			if (!(m_activeSpell == null))
			{
				m_activeSpell.OnSpellChange();
				PlayerAim?.ResetAimReticle();
				PunSingleton<TileManager>.Instance.SetTilesUnavailable(WandHand);
				WandHandler?.SetRelicHighlighted(-1);
				m_activeSpell = null;
			}
		}

		public virtual bool TrySelectTeleport()
		{
			if (m_activeSpell == null)
			{
				TrySelectSpell(0);
				return true;
			}
			if (m_activeSpell.IsActive)
			{
				return false;
			}
			if (!m_activeSpell.IsType(Spell.Spell_Teleport))
			{
				m_previouslyActiveSpell = m_activeSpell;
			}
			TrySelectSpell(0);
			return true;
		}

		public virtual void DeselectTeleport()
		{
			DeselectSpell();
		}

		public void PlaySpellActiveSound()
		{
			if (!(m_activeSpell.SelectSound == null))
			{
				m_audioSource.Stop();
				m_audioSource.clip = m_activeSpell.SelectSound;
				m_audioSource.Play();
			}
		}

		public T GetSpell<T>() where T : SpellBase
		{
			for (int i = 0; i < AvailableSpells.Count; i++)
			{
				if (AvailableSpells[i].GetType() == typeof(T))
				{
					return AvailableSpells[i] as T;
				}
			}
			return (T)null;
		}

		public float GetAimDistance()
		{
			return Aim.AimDistance;
		}

		public Vector3 GetTipPosition(float offset)
		{
			return Aim.GetAimOrigin(offset);
		}

		public Vector3 GetCurrentHitPoint(float collisionRadius = 0f)
		{
			return Aim.GetHitPointOrClosest(collisionRadius);
		}

		protected virtual void OnSystemMenuPress()
		{
			AbortSpellCasting(discrete: false, backButtonForce: true);
		}

		private void UpdateTipPoint()
		{
			CachedTipPoint = Aim.GetAimOrigin();
		}

		private void ValidateWandPosition()
		{
			if (!Wielder.PlayerControl.IsTeleporting && Wielder.PlayerControl.Input.AimInput != AimInput.Head)
			{
				bool flag = !m_hasHandTracking || CachedTipPoint.y > Wielder.CurrentTile.transform.position.y;
				if (m_isWandPositionValid != flag)
				{
					m_isWandPositionValid = flag;
					Wielder.Wand.SendWandPositionValidationEvent(WandHand, flag);
				}
			}
		}

		private void ResetWand()
		{
			for (int i = 0; i < AvailableSpells.Count; i++)
			{
				SpellBase spellBase = AvailableSpells[i];
				if (!(spellBase == null))
				{
					spellBase.SetTotalDamage(0f);
				}
			}
			if (PunSingleton<SceneControl>.Instance.CurrentMatchType.ContainsFlag(MatchType.SoloExperience))
			{
				ResetActiveSpell();
			}
		}

		protected void OnMatchPaused(Events.MatchPausedEvent eventData)
		{
			Pause(eventData.IsPaused);
		}

		protected void OnMatchReset(Events.MatchResetEvent eventData)
		{
			ResetWand();
		}

		private void OnSystemMenuPress(InputEvents.SystemMenuInputEvent eventData)
		{
			OnSystemMenuPress();
		}

		private void OnInputUpdated(InputEvents.InputChangedEvent eventData)
		{
			InstantiateSpells(eventData.WandInput, WandHand);
		}

		private void OnTileAreaExit(Events.TileAreaExitEvent eventData)
		{
			AbortSpellCasting();
		}

		private void OnTrackingAquired(XRNodeState nodeState)
		{
			if (WandHand.IsXRNode(nodeState.nodeType))
			{
				m_hasHandTracking = true;
			}
		}

		private void OnTrackingLost(XRNodeState nodeState)
		{
			if (WandHand.IsXRNode(nodeState.nodeType))
			{
				m_hasHandTracking = false;
			}
		}

		private void TryCacheDamageMultiplier(SpellEffect spellEffect, bool applyDoubleEffect)
		{
			if (spellEffect is DamageDealtProperty)
			{
				m_activeDamageMultipliers.Add(DamageMultiplierType.General, (!applyDoubleEffect) ? spellEffect.Value : spellEffect.ValueDouble);
			}
			else if (spellEffect is FireDamageProperty)
			{
				m_activeDamageMultipliers.Add(DamageMultiplierType.Fire, (!applyDoubleEffect) ? spellEffect.Value : spellEffect.ValueDouble);
			}
			else if (spellEffect is ElectricDamageProperty)
			{
				m_activeDamageMultipliers.Add(DamageMultiplierType.Electric, (!applyDoubleEffect) ? spellEffect.Value : spellEffect.ValueDouble);
			}
			else if (spellEffect is ColdDamageProperty)
			{
				m_activeDamageMultipliers.Add(DamageMultiplierType.Cold, (!applyDoubleEffect) ? spellEffect.Value : spellEffect.ValueDouble);
			}
		}

		private void EnableAcidTeleport()
		{
			if (GameControl.Instance.PlayerControl.Wand.GetOrCreateAcidCloud(WandHand, out m_activeEffects.Acid))
			{
				GenerateSpellPool(m_activeEffects.Acid);
			}
			GetSpell<Tile_Teleport>().OnTeleportSuccessful += OnTeleportedSuccessfully;
		}

		private void OnTeleportedSuccessfully(Tile oldTile, Tile newTile)
		{
			if (!oldTile.IsEffectActive)
			{
				TileEffectBase tileEffectBase = ObjectPoolHandler.GrabFromPool(Spell.Spell_AcidCloud, null) as TileEffectBase;
				tileEffectBase.EnableObject(oldTile.transform.position, m_activeEffects.Acid.photonView.ViewID, oldTile.photonView.ViewID, m_activeEffects.AcidTeleport.Value);
			}
		}

		PhotonView IWandControl.get_photonView()
		{
			return base.photonView;
		}
	}
	public class WandControlOneHand : WandControl
	{
		private bool m_wasActiveSpellReplaced;

		public WandUI UI { get; private set; }

		protected override bool ApplyDoubleWandPropertyEffects
		{
			[CompilerGenerated]
			get
			{
				return true;
			}
		}

		public override void OnPhotonInstantiate(PhotonMessageInfo info)
		{
			base.OnPhotonInstantiate(info);
			if (info.Sender.IsLocal && UI == null)
			{
				UI = UnityEngine.Object.Instantiate(Resources.Load<WandUI>("WandUI"), base.transform);
			}
		}

		public override void SetWandHandler(WandHandler wandHandler)
		{
			base.SetWandHandler(wandHandler);
			m_wandHandler.SetRelicHighlighted(base.WandInput.ContainsFlag(WandInput.Point) ? (-1) : 0);
		}

		public override bool CanCastSpell()
		{
			if (UI.IsActive && !UI.IsScaling)
			{
				return false;
			}
			return base.CanCastSpell();
		}

		public override void InstantiateSpells(WandInput wandInput, WandHand wandHand = WandHand.Right)
		{
			UI.Initialize(this, wandInput);
			base.InstantiateSpells(wandInput, wandHand);
		}

		protected override void UpdateLoadout()
		{
			if (m_spellSpawner == null)
			{
				m_spellSpawner = new WandSpellSpawner();
			}
			UI.TryHideUI();
			if (base.AvailableSpells.IsEmpty())
			{
				AddSpells(m_spellSpawner.SpawnRelics(base.Wielder, this, m_debugSpells), isLocal: true);
			}
			ResetActiveSpell();
			base.ArcHandler.TryInstantiateDotPool(m_availableSpellTypes);
			UI.SetupRelicIcons();
			if (base.IsConnected)
			{
				base.photonView.RPC("PunUpdateLoadout", RpcTarget.OthersBuffered, (int)m_wandType);
			}
		}

		public override void AbortSpellCasting(bool discrete = false, bool backButtonForce = false)
		{
			TryDisableUI();
			base.AbortSpellCasting(discrete, backButtonForce);
		}

		private void TryDisableUI()
		{
			if (UI != null && UI.IsActive && !UI.IsScaling)
			{
				UI.ToggleUI(active: false, selectHighlightedRadialElement: false);
			}
		}

		public override void ResetActiveSpell()
		{
			base.ArcHandler.HideDots();
			base.ActiveSpell?.AbortSpellCasting(discret: false, backButtonForce: true);
			if (!GameControl.Instance.IsCurrentLevel(Level.Lobby))
			{
				if (base.AvailableSpells.IsNullOrEmpty())
				{
					WandsLogger.LogError("WandController | Trying to reset spells without properly setting up available spells");
				}
				else if (base.WandInput.ContainsFlag(WandInput.Point))
				{
					ChangeSpell(base.AvailableSpells[0]);
				}
				else
				{
					ChangeSpell(base.AvailableSpells[1]);
				}
			}
		}

		public void SelectSpell(SpellBase spell, bool playSfx = true, bool playHighlightSfx = false)
		{
			if (!base.AvailableSpells.Contains(spell))
			{
				PunSingleton<SoundManager>.Instance.PlayPlayerSound("No Mana", 0.8f, base.transform.position, 1);
				return;
			}
			if (base.ActiveSpell != spell)
			{
				ChangeSpell(spell);
			}
			if (playSfx)
			{
				PlaySpellActiveSound();
			}
			else if (playHighlightSfx)
			{
				PunSingleton<SoundManager>.Instance.PlayPlayerSound("ui_choose", 0.5f, base.transform.position, 1);
			}
		}

		public override bool TrySelectTeleport()
		{
			if (UI.IsActive && !UI.IsScaling)
			{
				return false;
			}
			return base.TrySelectTeleport();
		}

		public override void DeselectTeleport()
		{
			SelectSpell(m_previouslyActiveSpell, playSfx: false);
		}

		protected override void OnSystemMenuPress()
		{
			UI.ResetUI();
			base.OnSystemMenuPress();
		}

		public void HighlightSpellSlot(PrimaryAxisState spellSlotType, bool selectSpell)
		{
			if (base.ActiveSpell == null)
			{
				return;
			}
			if (spellSlotType == PrimaryAxisState.Release)
			{
				if (base.ActiveSpell.IsType(Spell.Spell_Teleport))
				{
					UI.ToggleUI(active: false, selectHighlightedRadialElement: false, playSfx: false, playSpellSelectSfx: false);
					return;
				}
				UI.HighlightSpellSlot((int)spellSlotType);
				UI.ToggleUI(active: false, selectHighlightedRadialElement: true, playSfx: false, m_wasActiveSpellReplaced);
				m_wasActiveSpellReplaced = false;
			}
			else
			{
				if (base.ActiveSpell.IsActive && !base.ActiveSpell.IsType(Spell.Spell_ChaosLeap))
				{
					return;
				}
				UI.HighlightAndReturnSpellSlot((int)spellSlotType);
				SpellBase spellBase = base.AvailableSpells[(int)spellSlotType];
				if (selectSpell || base.ActiveSpell != spellBase)
				{
					if (base.ActiveSpell.IsType(Spell.Spell_Teleport))
					{
						m_previouslyActiveSpell = spellBase;
						Events.SpellSelectedEvent spellSelectedEvent = new Events.SpellSelectedEvent();
						spellSelectedEvent.Spell = spellBase;
						EventHub.Publish(spellSelectedEvent);
					}
					else
					{
						m_wasActiveSpellReplaced = true;
						SelectSpell(spellBase, playSfx: false, playHighlightSfx: true);
					}
				}
				if (!UI.IsActive && !UI.IsScaling)
				{
					UI.ToggleUI(active: true, selectHighlightedRadialElement: false, playSfx: false, playSpellSelectSfx: false);
				}
			}
		}

		public bool ToggleSpellSelectionUi()
		{
			return ToggleSpellSelectionUi(!UI.IsActive, selectHighlightedRadialElement: true);
		}

		public bool ToggleSpellSelectionUi(bool active)
		{
			return ToggleSpellSelectionUi(active, selectHighlightedRadialElement: true);
		}

		public bool ToggleSpellSelectionUi(bool active, bool selectHighlightedRadialElement)
		{
			bool result = false;
			if (active)
			{
				result = !base.ActiveSpell.IsActive;
			}
			UI.ToggleUI(active, selectHighlightedRadialElement);
			return result;
		}
	}
	public class WandHandler : MonoBehaviour
	{
		[SerializeField]
		private WandType m_wandType;

		[SerializeField]
		private Transform m_wandTipTransform;

		[SerializeField]
		private Vector3 m_wandTipTwoWandsPosition = Vector3.forward * -0.149f;

		[SerializeField]
		private Vector3 m_lobbyAdjustedLocalPosition = Vector3.zero;

		[SerializeField]
		private Vector3 m_aimAdjustedLocalPosition = Vector3.zero;

		[SerializeField]
		private List<UnlockableRendererMaterialPair> m_meshMaterials = new List<UnlockableRendererMaterialPair>(2);

		private IReadOnlyList<Renderer> m_relicRenderers;

		private IReadOnlyList<Relic> m_relics;

		private IReadOnlyList<int> m_castCosts;

		private float m_bloodBoltCastCost;

		private Relic m_bloodBoltRelic;

		public WandType Type
		{
			[CompilerGenerated]
			get
			{
				return m_wandType;
			}
		}

		public Vector3 AimAdjustedLocalPosition
		{
			[CompilerGenerated]
			get
			{
				return m_aimAdjustedLocalPosition;
			}
		}

		private void Awake()
		{
			for (int i = 0; i < m_meshMaterials.Count; i++)
			{
				m_meshMaterials[i].PreloadMaterials();
			}
		}

		public void InitializeInLobby()
		{
			m_relics = new List<Relic>(GetComponentsInChildren<Relic>());
			base.transform.localPosition = m_lobbyAdjustedLocalPosition;
			if (GameControl.Instance.IsDualWieldSupportedAndActive)
			{
				AdjustWandTipToDualWield();
			}
		}

		public void AdjustWandTipToDualWield(bool disableRelics = false)
		{
			m_wandTipTransform.transform.localPosition = m_wandTipTwoWandsPosition;
			if (disableRelics)
			{
				Relic[] componentsInChildren = GetComponentsInChildren<Relic>();
				componentsInChildren[2].gameObject.SetActive(value: false);
				componentsInChildren[3].gameObject.SetActive(value: false);
			}
		}

		public Relic[] UpdateLobbyLoadout(Spell[] spells)
		{
			UpdateRelicRenderers();
			if (spells.Length > 2)
			{
				m_relics.Reverse();
				m_relicRenderers.Reverse();
			}
			for (int i = 0; i < m_relics.Count; i++)
			{
				if (i >= spells.Length)
				{
					m_relics[i].gameObject.SetActive(value: false);
				}
				else if (spells[i] != 0)
				{
					m_relics[i].AssignIcon(IconAtlasHandler.GetSpellSprite(spells[i]), enable: true);
				}
			}
			return m_relics.ToArray();
		}

		public void UpdateLoadout(IList<Spell> spells, int[] spellCastCosts)
		{
			if (spells.IsEmpty() || spellCastCosts.IsEmpty())
			{
				WandsLogger.LogError("Tried updating loadout on WandHandler but arrays were empty.");
				return;
			}
			UpdateRelicRenderers();
			m_castCosts = new List<int>(spellCastCosts.Skip(1));
			m_relics = new List<Relic>(GetComponentsInChildren<Relic>());
			if (spells.Contains(Spell.None) || spells.Count == 2)
			{
				m_relics[2].gameObject.SetActive(value: false);
				m_relics[3].gameObject.SetActive(value: false);
				AdjustWandTipToDualWield();
			}
			else
			{
				m_relics.Reverse();
				m_relicRenderers.Reverse();
				m_castCosts.Reverse();
			}
			for (int i = 0; i < m_relics.Count; i++)
			{
				if (i >= spells.Count)
				{
					m_relics[i].FadeRelic(fadeIn: false, 0f, null);
				}
				else if (spells[i] != 0)
				{
					m_relics[i].AssignIcon(IconAtlasHandler.GetSpellSprite(spells[i]), enable: true);
					if (spells[i] == Spell.Spell_BloodBolt)
					{
						m_bloodBoltRelic = m_relics[i];
						m_bloodBoltCastCost = spellCastCosts[i];
					}
				}
			}
		}

		private void UpdateRelicRenderers()
		{
			foreach (UnlockableRendererMaterialPair meshMaterial in m_meshMaterials)
			{
				meshMaterial.ReplaceMaterial(ItemMaterialType.Default);
				if (meshMaterial.Renderers.Length > 0 && meshMaterial.Renderers[0].name.Contains("Relic"))
				{
					m_relicRenderers = new List<Renderer>(meshMaterial.Renderers);
				}
			}
		}

		public void UpdateManaRelics(float currentMana)
		{
			if (m_relics.IsNullOrEmpty())
			{
				return;
			}
			for (int i = 0; i < m_relics.Count; i++)
			{
				Relic relic = m_relics[i];
				if (i >= m_castCosts.Count)
				{
					relic.FadeRelic(fadeIn: false, 0f, null);
				}
				else if (currentMana < (float)m_castCosts[i])
				{
					if (relic.IsFadedIn)
					{
						relic.FadeRelic(fadeIn: false, 0.25f, null);
					}
				}
				else if (relic.IsFadedOut)
				{
					relic.FadeRelic(fadeIn: true, 0.25f, null);
				}
			}
		}

		public void UpdateBloodBoltRelic(float currentHealth)
		{
			if (m_bloodBoltRelic == null)
			{
				return;
			}
			if (currentHealth - m_bloodBoltCastCost <= 5f)
			{
				if (m_bloodBoltRelic.IsFadedIn)
				{
					m_bloodBoltRelic.FadeRelic(fadeIn: false, 0.25f, null);
				}
			}
			else if (m_bloodBoltRelic.IsFadedOut)
			{
				m_bloodBoltRelic.FadeRelic(fadeIn: true, 0.25f, null);
			}
		}

		public void SetRelicHighlighted(int highlightIndex)
		{
			if (m_relicRenderers.IsNullOrEmpty())
			{
				WandsLogger.LogError($"No relic renderers references set on {base.name} of type WandHandler");
				return;
			}
			highlightIndex.Wrap(-1, m_relicRenderers.Count - 1);
			for (int i = 0; i < m_relicRenderers.Count; i++)
			{
				bool flag = i == highlightIndex;
				m_relicRenderers[i].material.SetFloat("_Highlighted", (!flag) ? 0f : 1f);
			}
		}
	}
	public class WandManager
	{
		public const int MinHealthThresholdForBloodSpells = 5;

		private readonly PlayerControl m_playerControl;

		private readonly StatsData m_healthData;

		private readonly StatsData m_manaData;

		private PlayerWand m_defaultPlayerWand;

		private IList<PlayerWand> m_playerWands = new List<PlayerWand>(2);

		private HashSet<Spell> m_availableSpellTypes = new HashSet<Spell>();

		private IList<int> m_spellCastCosts = new List<int>(5);

		private Spell_ArmorOfTheSun m_armor;

		private Spell_DevilsTwins m_twins;

		private Spell_LightningStrike m_lightning;

		private Spell_AcidCloud m_acid;

		private SpellBase m_previouslySelectedSpell;

		private bool m_isSpellCastingActive;

		private bool[] m_isWandPositionValid = new bool[2] { true, true };

		private Events.WandPositionValidationEvent m_wandPositionValidationEvent = new Events.WandPositionValidationEvent
		{
			IsWandPositionValid = true
		};

		public bool IsSpellCastingLocked
		{
			[CompilerGenerated]
			get
			{
				return !m_isSpellCastingActive || !m_wandPositionValidationEvent.IsWandPositionValid;
			}
		}

		public WandInput WandInput
		{
			[CompilerGenerated]
			get
			{
				return (!IsPlayer) ? WandInput.Stick : m_playerControl.Input.WandInput;
			}
		}

		public Spell_DevilsTwins Twins
		{
			[CompilerGenerated]
			get
			{
				return (!(m_twins != null)) ? null : m_twins;
			}
		}

		public Tile_TeleportRandom ChaosLeap { get; private set; }

		public IDictionary<WandHand, IList<SpellBase>> AvailableSpells { get; private set; } = new Dictionary<WandHand, IList<SpellBase>>(5);


		public Spell[] AvailableSpellTypes
		{
			[CompilerGenerated]
			get
			{
				return m_availableSpellTypes.ToArray();
			}
		}

		public int[] SpellCastCosts
		{
			[CompilerGenerated]
			get
			{
				return m_spellCastCosts.ToArray();
			}
		}

		public int WandCount
		{
			[CompilerGenerated]
			get
			{
				return m_playerWands.Count;
			}
		}

		private bool IsPlayer
		{
			[CompilerGenerated]
			get
			{
				return m_playerControl != null;
			}
		}

		public WandManager(CharacterControl characterControl, StatsData healthData, StatsData manaData, Transform wandParent, Aim aim)
		{
			m_healthData = healthData;
			m_manaData = manaData;
			InstantiateBotWand(characterControl, wandParent, aim);
		}

		public WandManager(PlayerControl playerControl, StatsData healthData, StatsData manaData)
		{
			m_playerControl = playerControl;
			m_healthData = healthData;
			m_manaData = manaData;
			PlayerAim aim = playerControl.Input.GetAim(WandHand.Right);
			InstantiatePlayerWand(aim);
			PlayerAim aim2 = playerControl.Input.GetAim(WandHand.Left);
			if (aim2 != null)
			{
				InstantiatePlayerWand(aim2);
			}
			else if (playerControl.IsDualWielding)
			{
				WandsLogger.LogError("Is dual wielding but couldn't find left aim.");
			}
		}

		public void Update()
		{
			for (int i = 0; i < m_playerWands.Count; i++)
			{
				m_playerWands[i].WandControl.RunUpdate();
			}
		}

		public void OnTeleportInitiated()
		{
			ResetHighlightedTiles();
			if (m_lightning != null && m_lightning.IsActive)
			{
				m_lightning.AbortSpellCasting();
			}
		}

		public void SetSpellInputActive(bool active)
		{
			m_isSpellCastingActive = active;
		}

		public void SendWandPositionValidationEvent(WandHand wandHand, bool isPositionValid)
		{
			if (m_isWandPositionValid[(int)wandHand] != isPositionValid)
			{
				m_isWandPositionValid[(int)wandHand] = isPositionValid;
				if (!isPositionValid)
				{
					AbortSpellCasting();
				}
				else if (!m_isWandPositionValid[(int)wandHand.Opposite()])
				{
					return;
				}
				m_wandPositionValidationEvent.IsWandPositionValid = isPositionValid;
				EventHub.Publish(m_wandPositionValidationEvent);
			}
		}

		public void OnArmorHit(ref float damage)
		{
			m_armor.ArmorHit(damage);
			damage *= m_armor.DeflectValue;
		}

		public void SetFreeTeleport(float timeFrame)
		{
			for (int i = 0; i < m_playerWands.Count; i++)
			{
				m_playerWands[i].WandControl.GetSpell<Tile_Teleport>().SetFreeTeleport(timeFrame);
			}
		}

		public void TrackTileHit()
		{
			m_defaultPlayerWand.TrackTileHit();
		}

		public void TrackTileHit(WandHand wandHand)
		{
			GetPlayerWand(wandHand).TrackTileHit();
		}

		public bool IsTileHighlighted(WandHand wandHand, Tile tile)
		{
			return GetPlayerWand(wandHand).HighlightedTile == tile;
		}

		public Tile GetHighlightedTile()
		{
			return m_defaultPlayerWand.HighlightedTile;
		}

		public Tile GetHighlightedTile(WandHand wandHand)
		{
			return m_playerWands[(int)wandHand].HighlightedTile;
		}

		public void ResetHighlightedTile()
		{
			m_defaultPlayerWand.ResetHighlightedTile();
		}

		public void ResetHighlightedTile(WandHand wandHand)
		{
			m_playerWands[(int)wandHand].ResetHighlightedTile();
		}

		public void ResetHighlightedTiles()
		{
			for (int i = 0; i < m_playerWands.Count; i++)
			{
				m_playerWands[i].ResetHighlightedTile();
			}
		}

		public PlayerWand GetPlayerWand()
		{
			return m_defaultPlayerWand;
		}

		public PlayerWand GetPlayerWand(WandHand wandHand)
		{
			return m_playerWands[(int)wandHand];
		}

		public IWandControl GetWandControl()
		{
			return (m_defaultPlayerWand != null) ? m_defaultPlayerWand.WandControl : null;
		}

		public IWandControl GetWandControl(WandHand wandHand)
		{
			return m_playerWands[(int)wandHand].WandControl;
		}

		public SpellBase GetActiveSpell()
		{
			return m_defaultPlayerWand.WandControl.ActiveSpell;
		}

		public SpellBase GetActiveSpell(WandHand wandHand)
		{
			return GetWandControl(wandHand).ActiveSpell;
		}

		public bool IsSpellTypeSelected(Spell spellType)
		{
			for (int i = 0; i < m_playerWands.Count; i++)
			{
				if (m_playerWands[i].WandControl.ActiveSpell.IsType(spellType))
				{
					return true;
				}
			}
			return false;
		}

		public void DestroyPlayerWands()
		{
			if (!m_playerWands.IsEmpty())
			{
				for (int i = 0; i < m_playerWands.Count; i++)
				{
					m_playerWands[i].DestroyWandController();
				}
				m_playerWands.Clear();
				m_defaultPlayerWand = null;
			}
		}

		public void SpawnOnlineWandControllers(int wielderViewID, Transform parent, AimInput aimInput)
		{
			for (int i = 0; i < m_playerWands.Count; i++)
			{
				WandHand wandHand = (WandHand)i;
				PlayerWand playerWand = m_playerWands[i];
				playerWand.SpawnWandController(wielderViewID, parent, WandInput, m_playerWands.Count > 1, wandHand);
				playerWand.TrySpawnWandMesh(aimInput);
			}
			UpdateAvailableSpells();
		}

		public void SpawnOfflineWandControllers(Transform parent, AimInput aimInput)
		{
			for (int i = 0; i < m_playerWands.Count; i++)
			{
				PlayerWand playerWand = m_playerWands[i];
				playerWand.SpawnWandControllerOffline(parent, WandInput);
				playerWand.TrySpawnWandMesh(aimInput);
			}
			UpdateAvailableSpells();
		}

		public void SpawnBotWandController(int wielderViewID, Transform parent, AimInput aimInput)
		{
			m_defaultPlayerWand.SpawnBotWandController(wielderViewID, parent, WandInput);
			m_defaultPlayerWand.TrySpawnWandMesh(aimInput);
			UpdateAvailableSpells();
		}

		private void UpdateAvailableSpells()
		{
			for (int i = 0; i < m_playerWands.Count; i++)
			{
				IList<SpellBase> availableSpells = m_playerWands[i].WandControl.AvailableSpells;
				AvailableSpells.Add((WandHand)i, m_playerWands[i].WandControl.AvailableSpells);
				for (int j = 0; j < availableSpells.Count; j++)
				{
					SpellBase spellBase = availableSpells[j];
					Spell type = spellBase.Type;
					switch (type)
					{
					case Spell.Spell_ArmorOfTheSun:
						m_armor = spellBase as Spell_ArmorOfTheSun;
						break;
					case Spell.Spell_DevilsTwins:
						m_twins = spellBase as Spell_DevilsTwins;
						break;
					case Spell.Spell_LightningStrike:
						m_lightning = spellBase as Spell_LightningStrike;
						break;
					case Spell.Spell_ChaosLeap:
						ChaosLeap = spellBase as Tile_TeleportRandom;
						break;
					case Spell.Spell_AcidCloud:
						m_acid = spellBase as Spell_AcidCloud;
						break;
					}
					if (m_availableSpellTypes.Add(type))
					{
						m_spellCastCosts.Add(spellBase.GetCastCost());
					}
				}
			}
		}

		private void InstantiateBotWand(CharacterControl characterControl, Transform wandParent, Aim aim)
		{
			PlayerWand playerWand = new PlayerWand(aim, isWieldedByBot: true);
			playerWand.SetWandParent(wandParent);
			m_playerWands.Add(playerWand);
			m_defaultPlayerWand = playerWand;
		}

		private void InstantiatePlayerWand(PlayerAim playerAim)
		{
			PlayerWand playerWand = new PlayerWand(playerAim, isWieldedByBot: false);
			m_playerWands.Add(playerWand);
			if (m_defaultPlayerWand == null)
			{
				m_defaultPlayerWand = playerWand;
			}
			if (playerAim.WandPivot != null)
			{
				playerWand.SetWandParent(playerAim.WandPivot);
			}
		}

		public bool CanCastSpell()
		{
			return m_defaultPlayerWand.WandControl.CanCastSpell();
		}

		public bool OutOfEnergy(SpellBase spell)
		{
			return OutOfEnergy(spell.GetCastCost(), spell.CostType, m_defaultPlayerWand.WandControl.WandHand);
		}

		public bool OutOfEnergy(SpellBase spell, WandHand wandHand)
		{
			return OutOfEnergy(spell.GetCastCost(), spell.CostType, wandHand);
		}

		public bool OutOfEnergy(float castCost, CostType costType, WandHand wandHand)
		{
			bool flag = false;
			switch (costType)
			{
			case CostType.Mana:
				flag = m_manaData.Current == 0f || m_manaData.Current - castCost < 1f;
				break;
			case CostType.Health:
				flag = m_healthData.Current <= 5f || m_manaData.Current - castCost <= 5f;
				break;
			}
			if (flag && IsPlayer && !ExpandedSingleton<FadeHandler>.Instance.IsFading)
			{
				Events.EnergyDepletedEvent energyDepletedEvent = new Events.EnergyDepletedEvent();
				energyDepletedEvent.CostType = costType;
				energyDepletedEvent.WandPosition = GetWandControl(wandHand).CachedTipPoint;
				energyDepletedEvent.WandHand = wandHand;
				EventHub.Publish(energyDepletedEvent);
			}
			return flag;
		}

		public void AbortSpellCasting(bool discrete = false, bool backButtonForce = false)
		{
			for (int i = 0; i < m_playerWands.Count; i++)
			{
				m_playerWands[i].WandControl.AbortSpellCasting(discrete, backButtonForce);
			}
		}

		public void TryCastingSpell(InputState inputState)
		{
			if (IsSpellCastingLocked)
			{
				return;
			}
			SpellBase activeSpell = GetWandControl().ActiveSpell;
			if (activeSpell == null)
			{
				WandsLogger.LogError("Active spell is null");
				return;
			}
			switch (inputState)
			{
			case InputState.Down:
				if (CanCastSpell() && !OutOfEnergy(activeSpell) && activeSpell.CanCast())
				{
					activeSpell.SpellPress();
				}
				break;
			case InputState.Up:
				activeSpell.SpellRelease();
				break;
			case InputState.Hold:
				activeSpell.SpellHold();
				break;
			}
		}

		public void TryCastAndDeselectTeleport()
		{
			SpellBase activeSpell = GetWandControl().ActiveSpell;
			if (!(activeSpell == null) && activeSpell.Type == Spell.Spell_Teleport)
			{
				if (WandInput.ContainsFlag(WandInput.PressMove))
				{
					TryCastingSpell(InputState.Down);
				}
				activeSpell.SpellRelease();
				GetWandControl().DeselectTeleport();
			}
		}

		public void SpellPress(WandHand wandHand, int spellSlotIndex)
		{
			IWandControl wandControl = GetWandControl(wandHand);
			SpellBase spellBase = wandControl.TrySelectSpell(spellSlotIndex);
			if (!(spellBase == null))
			{
				if (m_previouslySelectedSpell != spellBase)
				{
					wandControl.PlaySpellActiveSound();
					m_previouslySelectedSpell = spellBase;
				}
				if (spellBase.CanCast() && !OutOfEnergy(spellBase, wandHand))
				{
					spellBase.SpellPress();
				}
			}
		}

		public bool SpellRelease(WandHand wandHand, int spellSlotIndex)
		{
			IWandControl wandControl = GetWandControl(wandHand);
			SpellBase spellBase = wandControl.AvailableSpells[spellSlotIndex];
			if (wandControl.ActiveSpell != null && wandControl.ActiveSpell != spellBase)
			{
				return false;
			}
			if (spellBase.IsActive && OutOfEnergy(spellBase, wandHand))
			{
				spellBase.AbortSpellCasting();
			}
			else
			{
				spellBase.SpellRelease();
			}
			wandControl.DeselectSpell();
			m_playerControl.HUD?.DeselectSpell(wandHand);
			return true;
		}

		public void SpellHold(WandHand wandHand)
		{
			GetActiveSpell(wandHand)?.SpellHold();
		}

		public bool TrySelectTeleport(WandHand wandHand)
		{
			return GetWandControl(wandHand).TrySelectTeleport();
		}

		public void DeselectTeleport(WandHand wandHand)
		{
			IWandControl wandControl = GetWandControl(wandHand);
			SpellBase activeSpell = wandControl.ActiveSpell;
			bool? flag = activeSpell?.IsType(Spell.Spell_Teleport);
			if (flag.HasValue && flag.Value)
			{
				activeSpell.SpellRelease();
				wandControl.DeselectTeleport();
				m_playerControl.HUD?.DeselectSpell(wandHand);
			}
		}

		public void UpdatedPlayerStatsMana(float currentMana)
		{
			for (int i = 0; i < m_playerWands.Count; i++)
			{
				m_playerWands[i].WandControl.WandHandler?.UpdateManaRelics(currentMana);
			}
		}

		public void UpdatedPlayerStatsHealth(float currentHealth)
		{
			for (int i = 0; i < m_playerWands.Count; i++)
			{
				m_playerWands[i].WandControl.WandHandler?.UpdateBloodBoltRelic(currentHealth);
			}
		}

		public void OnMatchEnded()
		{
			SetSpellInputActive(active: false);
			for (int i = 0; i < m_playerWands.Count; i++)
			{
				IWandControl wandControl = m_playerWands[i].WandControl;
				wandControl.AbortSpellCasting();
				wandControl.ArcHandler.HideDots();
			}
		}

		public void TrySpawnArmor(WandHand wandHand, Transform wandParent, float durability)
		{
			if (m_armor != null)
			{
				m_armor.ActivateArmor(durability);
				return;
			}
			PlayerWand playerWand = GetPlayerWand(wandHand);
			IWandControl wandControl = playerWand.WandControl;
			object[] data = new object[2] { wandControl.ViewID, -1 };
			m_armor = NetworkUtils.Instantiate(Spell.Spell_ArmorOfTheSun.ToString(), Vector3.zero, Quaternion.identity, 0, data).GetComponent<Spell_ArmorOfTheSun>();
			ObjectPoolHandler.CreateObjectPoolAsync(m_armor.PoolSize, PoolObjectType.ArmorOfTheSunEnd);
			wandControl.AddChargeEffect(m_armor.WandChargeEffect);
			m_armor.WandChargeEffect?.SetWandParent(playerWand.WandParent);
			m_armor.ActivateArmor(durability);
		}

		public void TrySpawnLeap()
		{
			if (!(ChaosLeap != null))
			{
				object[] data = new object[2]
				{
					GetWandControl(WandHand.Right).ViewID,
					-1
				};
				ChaosLeap = NetworkUtils.Instantiate(Spell.Spell_ChaosLeap.ToString(), Vector3.zero, Quaternion.identity, 0, data).GetComponent<Tile_TeleportRandom>();
			}
		}

		public bool GetOrCreateAcidCloud(WandHand wandHand, out Spell_AcidCloud acidCloud)
		{
			if (m_acid != null)
			{
				acidCloud = m_acid;
				return false;
			}
			object[] data = new object[2]
			{
				GetWandControl(wandHand).ViewID,
				-1
			};
			acidCloud = NetworkUtils.Instantiate(Spell.Spell_AcidCloud.ToString(), Vector3.zero, Quaternion.identity, 0, data).GetComponent<Spell_AcidCloud>();
			return true;
		}
	}
	public class WandSpellSpawner
	{
		private IWandControl m_wandControl;

		private IList<SpellBase> m_availableSpells = new List<SpellBase>(5);

		public SpellBase[] SpawnRelics(Wielder wielder, IWandControl wandControl, Spell[] defaultSpells)
		{
			m_wandControl = wandControl;
			m_availableSpells.Clear();
			SpawnSpell(Spell.Spell_Teleport, 0);
			Spell[] array = new Spell[5];
			if (wielder.IsBot)
			{
				array = wielder.BotControl?.GetRandomizedSpells();
				for (int i = 1; i < 5; i++)
				{
					if (array[i] != 0)
					{
						SpawnSpell(array[i], i);
					}
				}
				return m_availableSpells.ToArray();
			}
			array = ((GameControl.Instance.GetPreviousLevel() != 0) ? GameControl.Instance.Player.ActiveLoadout.Spells : new Spell[5]
			{
				Spell.Spell_Teleport,
				defaultSpells[0],
				defaultSpells[1],
				defaultSpells[2],
				defaultSpells[3]
			});
			if (array.Contains(Spell.None) || array.Length < 5)
			{
				array = Constants.DefaultSpells.Take(5).ToArray();
				GameControl.Instance.Player.UpdateCurrentLoadout(array);
			}
			for (int j = 1; j < 5; j++)
			{
				SpawnSpell(array[j], j);
			}
			return m_availableSpells.ToArray();
		}

		public SpellBase[] SpawnRelics(Wielder wielder, IWandControl wandControl, Spell[] defaultSpells, WandHand wandHand)
		{
			if (wielder.IsBot)
			{
				WandsLogger.LogError("Bot should never try and spawn a split loadout");
				return null;
			}
			m_wandControl = wandControl;
			m_availableSpells.Clear();
			Spell[] array = new Spell[3];
			array = ((GameControl.Instance.GetPreviousLevel() != 0) ? ((wandHand == WandHand.Left) ? new Spell[3]
			{
				Spell.Spell_Teleport,
				GameControl.Instance.Player.ActiveLoadout.Spells[1],
				GameControl.Instance.Player.ActiveLoadout.Spells[2]
			} : new Spell[3]
			{
				Spell.Spell_Teleport,
				GameControl.Instance.Player.ActiveLoadout.Spells[3],
				GameControl.Instance.Player.ActiveLoadout.Spells[4]
			}) : ((wandHand == WandHand.Left) ? new Spell[3]
			{
				Spell.Spell_Teleport,
				defaultSpells[0],
				defaultSpells[1]
			} : new Spell[3]
			{
				Spell.Spell_Teleport,
				defaultSpells[2],
				defaultSpells[3]
			}));
			if (array.Contains(Spell.None) || array.Length < 3)
			{
				array = Constants.DefaultSpells.Take(3).ToArray();
				GameControl.Instance.Player.UpdateCurrentLoadout(array);
			}
			for (int i = 0; i < 3; i++)
			{
				SpawnSpell(array[i], i);
			}
			return m_availableSpells.ToArray();
		}

		private void SpawnSpell(Spell spellType, int spellIndex)
		{
			object[] data = new object[2] { m_wandControl.ViewID, spellIndex };
			SpellBase component = NetworkUtils.Instantiate(spellType.ToString(), Vector3.zero, Quaternion.identity, 0, data).GetComponent<SpellBase>();
			if (m_availableSpells.Contains(component))
			{
				WandsLogger.LogError($"WandController | Can't add spell {spellType}, available spells contain it? {m_availableSpells.Contains(component)}");
			}
			else
			{
				m_availableSpells.Add(component);
			}
		}
	}
}
namespace Assets.Scripts.UI
{
	public class WandStatsHandler : MonoBehaviour
	{
		private const int ColorCount = 3;

		[SerializeField]
		public Renderer[] m_bars = new Renderer[2];

		[SerializeField]
		private Color m_manaAccentColor = Color.black;

		[SerializeField]
		private Color m_manaAccentColorOriginal = Color.black;

		[SerializeField]
		private Color[] m_hpStartColors = Array.Empty<Color>();

		[SerializeField]
		private Color[] m_armorHighlightColors = Array.Empty<Color>();

		private WandControlOneHand m_wandControl;

		private StatsData m_healthData;

		private StatsData m_manaData;

		private Material[] m_fillMaterials;

		private bool[] m_awaitClose;

		private float[] m_startFill;

		private float[] m_currentValue;

		private float[] m_hideTime;

		private bool m_suddenDeath;

		private EventToken m_matchResetEventToken;

		private EventToken m_suddenDeathStartedEventToken;

		private EventToken m_armorActivationEventToken;

		private string[] GetStatsColors()
		{
			return new string[3] { "Surface", "Accent", "Base" };
		}

		private void OnEnable()
		{
			m_matchResetEventToken = EventHub.Subscribe<Events.MatchResetEvent>(OnMatchReset);
			m_suddenDeathStartedEventToken = EventHub.Subscribe<Events.SuddenDeathStartedEvent>(OnSuddenDeathStarted);
			m_armorActivationEventToken = EventHub.Subscribe<Events.ArmorActivationEvent>(OnArmorActivated);
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe<Events.MatchResetEvent>(m_matchResetEventToken);
			EventHub.Unsubscribe<Events.SuddenDeathStartedEvent>(m_suddenDeathStartedEventToken);
			EventHub.Unsubscribe<Events.ArmorActivationEvent>(m_armorActivationEventToken);
		}

		private void Awake()
		{
			m_fillMaterials = new Material[2];
			m_awaitClose = new bool[2];
			m_startFill = new float[2];
			m_currentValue = new float[2];
			m_hideTime = new float[2];
			for (int i = 0; i < 2; i++)
			{
				m_startFill[i] = 0f;
				m_currentValue[i] = 0f;
				m_hideTime[i] = 0f;
				m_awaitClose[i] = false;
				m_fillMaterials[i] = m_bars[i].material;
			}
		}

		private void Update()
		{
			if (!base.gameObject.activeSelf)
			{
				return;
			}
			bool? flag = PunSingleton<SceneControl>.Instance?.GameOver;
			if (flag.HasValue && flag.Value)
			{
				return;
			}
			if (m_suddenDeath)
			{
				Color value = Color.LerpUnclamped(m_manaAccentColor, m_manaAccentColorOriginal, Mathf.PingPong(Time.time, 0.5f));
				m_fillMaterials[1].SetColor("_Color", value);
			}
			for (int i = 0; i < m_bars.Length; i++)
			{
				if (m_fillMaterials[i].GetFloat("_Fill") > ((i != 0) ? m_manaData.Fill : m_healthData.Fill))
				{
					UpdateFillValue(i);
				}
				else if (m_fillMaterials[i].GetFloat("_Fill") < ((i != 0) ? m_manaData.Fill : m_healthData.Fill))
				{
					SetFillValue(i);
				}
			}
		}

		public void Initialize(WandControlOneHand wandController)
		{
			m_wandControl = wandController;
			m_healthData = m_wandControl.Wielder.HealthData;
			m_manaData = m_wandControl.Wielder.ManaData;
		}

		public void SetActive(bool active)
		{
			Renderer[] bars = m_bars;
			foreach (Renderer renderer in bars)
			{
				renderer.gameObject.SetActive(active);
			}
		}

		private void OnReset()
		{
			SetSuddenDeathActive(enable: false);
		}

		private void OnSuddenDeath()
		{
			SetSuddenDeathActive(enable: true);
		}

		private void OnArmorActivated(bool isArmorActive)
		{
			if (isArmorActive)
			{
				SetColor(0, m_armorHighlightColors[0], m_armorHighlightColors[1], m_armorHighlightColors[2]);
			}
			else
			{
				SetColor(0);
			}
		}

		private void SetSuddenDeathActive(bool enable)
		{
			m_suddenDeath = enable;
			if (m_suddenDeath)
			{
				SetColor(1, m_fillMaterials[1].GetColor("_SurfaceColor"), m_manaAccentColor, m_fillMaterials[1].GetColor("_BaseColor"));
			}
			else
			{
				SetColor(1, m_fillMaterials[1].GetColor("_SurfaceColor"), m_manaAccentColorOriginal, m_fillMaterials[1].GetColor("_BaseColor"));
			}
		}

		public void SetColor(int index)
		{
			SetColor(index, m_hpStartColors[0], m_hpStartColors[1], m_hpStartColors[2]);
		}

		public void SetColor(int index, Color surfaceColor, Color accentColor, Color baseColor)
		{
			bool? flag = PunSingleton<SceneControl>.Instance?.GameOver;
			if ((!flag.HasValue || !flag.Value) && base.gameObject.activeSelf)
			{
				StartCoroutine(ChangeColor(index, surfaceColor, accentColor, baseColor));
			}
		}

		private IEnumerator ChangeColor(int index, Color surfaceColor, Color accentColor, Color baseColor)
		{
			Color startSurface = m_fillMaterials[index].GetColor("_SurfaceColor");
			Color startAccent = m_fillMaterials[index].GetColor("_Color");
			Color startBase = m_fillMaterials[index].GetColor("_BaseColor");
			float currentTime = 0f;
			while (currentTime < 1f)
			{
				currentTime += Time.deltaTime * 2f;
				m_fillMaterials[index].SetColor("_SurfaceColor", Color.Lerp(startSurface, surfaceColor, currentTime));
				m_fillMaterials[index].SetColor("_Color", Color.Lerp(startAccent, accentColor, currentTime));
				m_fillMaterials[index].SetColor("_BaseColor", Color.Lerp(startBase, baseColor, currentTime));
				yield return null;
			}
			UpdateFillValue(index);
		}

		private void SetFillValue(int matIndex)
		{
			if (matIndex < m_fillMaterials.Length)
			{
				m_fillMaterials[matIndex].SetFloat("_Fill", (matIndex != 0) ? m_manaData.Fill : m_healthData.Fill);
			}
		}

		private void SetStartValues(int i)
		{
			m_startFill[i] = m_fillMaterials[i].GetFloat("_Fill");
			m_currentValue[i] = 0f;
		}

		private void UpdateFillValue(int i)
		{
			if (m_startFill[i] != m_fillMaterials[i].GetFloat("_Fill"))
			{
				SetStartValues(i);
			}
			m_currentValue[i] += Time.deltaTime * 5f;
			m_fillMaterials[i].SetFloat("_Fill", Mathf.Lerp(m_startFill[i], (i != 0) ? m_manaData.Fill : m_healthData.Fill, m_currentValue[i]));
			if (Mathf.Abs(m_fillMaterials[i].GetFloat("_Fill") - ((i != 0) ? m_manaData.Fill : m_healthData.Fill)) < 0.001f)
			{
				DoneDeal(i);
			}
		}

		private void DoneDeal(int i)
		{
			if (i < m_fillMaterials.Length)
			{
				m_fillMaterials[i].SetFloat("_Fill", (i != 0) ? m_manaData.Fill : m_healthData.Fill);
			}
			if (!m_wandControl.UI.IsActive)
			{
				m_hideTime[i] = 0f;
				m_awaitClose[i] = true;
			}
		}

		private void OnMatchReset(Events.MatchResetEvent eventData)
		{
			OnReset();
		}

		private void OnSuddenDeathStarted(Events.SuddenDeathStartedEvent eventData)
		{
			OnSuddenDeath();
		}

		private void OnArmorActivated(Events.ArmorActivationEvent eventData)
		{
			OnArmorActivated(eventData.IsActive);
		}
	}
}
namespace Cortopia.Scripts.Wand
{
	public class WandUI : MonoBehaviour
	{
		[SerializeField]
		private bool m_showText = true;

		[SerializeField]
		private bool m_followWandMovement;

		[SerializeField]
		[Range(0f, 1.5f)]
		private float m_positionOffsetZ = 1.1f;

		[SerializeField]
		private WandStatsHandler m_wandStats;

		private bool m_isDirectionalInput;

		private bool m_isHudActive;

		private List<RadialElement> m_spellSelecionElements = new List<RadialElement>(5);

		private float m_currentScaleTime;

		private Vector3 m_startScale;

		private Vector3 m_endScale;

		private Quaternion m_trackRotation;

		private GameObject m_radialElementsParent;

		private Transform m_selectionScalerParent;

		private Transform m_radialRoot;

		private WandInput m_wandInput;

		private WandControlOneHand m_wandControl;

		private PlayerControl m_playerControl;

		private EventToken m_matchResetEventToken;

		private EventToken m_matchEndedEventToken;

		public RadialElement HighlightedRelic { get; set; }

		public bool IsScaling { get; private set; }

		public bool IsActive { get; private set; }

		public bool ShowTooltip
		{
			[CompilerGenerated]
			get
			{
				return m_showText;
			}
		}

		private void OnEnable()
		{
			m_matchResetEventToken = EventHub.Subscribe<Events.MatchResetEvent>(OnMatchReset);
			m_matchEndedEventToken = EventHub.Subscribe<Events.MatchEndedEvent>(OnMatchEnded);
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe<Events.MatchResetEvent>(m_matchResetEventToken);
			EventHub.Unsubscribe<Events.MatchEndedEvent>(m_matchEndedEventToken);
		}

		private void OnMatchReset(Events.MatchResetEvent eventData)
		{
			ResetUI();
		}

		private void OnMatchEnded(Events.MatchEndedEvent eventData)
		{
			ResetUI();
		}

		public void Update()
		{
			if (m_isDirectionalInput)
			{
				return;
			}
			if (IsScaling)
			{
				m_playerControl.Input.TryTrackInteractObjects();
				m_currentScaleTime += Time.deltaTime;
				float num = Mathf.Clamp01(m_currentScaleTime / 0.15f);
				m_selectionScalerParent.localScale = Vector3.Lerp(m_startScale, m_endScale, num);
				if (Mathf.Approximately(num, 1f))
				{
					EndScale(m_endScale);
				}
			}
			else if (m_followWandMovement)
			{
				UpdatePositionAndRotation();
			}
		}

		private void LateUpdate()
		{
			if (IsActive && !m_followWandMovement)
			{
				m_radialRoot.rotation = m_trackRotation;
			}
		}

		public void Initialize(WandControlOneHand wandControl, WandInput wandInput)
		{
			if (wandControl == null)
			{
				WandsLogger.LogError("WandUI is currently only supported using WandControlOneHand");
				return;
			}
			m_wandControl = wandControl;
			m_playerControl = wandControl.Wielder.CharacterControl as PlayerControl;
			m_wandStats.Initialize(wandControl);
			HighlightedRelic = null;
			if (m_radialRoot != null)
			{
				m_radialRoot.gameObject.SetActive(value: false);
			}
			if (wandInput != 0)
			{
				m_wandInput = wandInput;
				m_isDirectionalInput = m_wandInput != WandInput.Point;
				if (m_isDirectionalInput)
				{
					SetWandStatsActive(active: false);
					return;
				}
				m_radialRoot = base.transform.RetrieveChild("Radial" + wandInput, includeInactive: true);
				m_radialRoot.gameObject.SetActive(value: true);
				m_selectionScalerParent = m_radialRoot.RetrieveChild("spellselection", includeInactive: true);
				m_radialElementsParent = m_radialRoot.RetrieveChild("Radial_Elements", includeInactive: true).gameObject;
				ResetUI();
			}
		}

		public void SetupRelicIcons()
		{
			if (m_isDirectionalInput || m_wandControl.AvailableSpells.IsNullOrEmpty())
			{
				return;
			}
			if (m_radialRoot == null)
			{
				WandsLogger.LogError("Radial root is null, check instantiation order!");
				return;
			}
			m_spellSelecionElements.Clear();
			m_spellSelecionElements.AddRange(from x in m_radialRoot.GetComponentsInChildren<RadialElement>(includeInactive: true)
				orderby x.m_radialParent.name
				select x);
			if (GameControl.Instance.IsCurrentLevel(Level.Lobby))
			{
				for (int i = 0; i < 5; i++)
				{
					if (i == 1 || i == 2)
					{
						SetupRelicIcon(m_wandControl.AvailableSpells[i], i);
					}
					else
					{
						(m_spellSelecionElements[i] as RadialElement_Spell)?.SetElementActive(active: false);
					}
				}
			}
			else
			{
				for (int j = 0; j < m_wandControl.AvailableSpells.Count; j++)
				{
					if (m_wandControl.AvailableSpells[j] != null)
					{
						SetupRelicIcon(m_wandControl.AvailableSpells[j], j);
					}
				}
			}
			SetSpellSelectionColliders(value: false);
		}

		private void SetupRelicIcon(SpellBase spell, int index)
		{
			Sprite spellSprite = IconAtlasHandler.GetSpellSprite(spell.Type);
			(m_spellSelecionElements[index] as RadialElement_Spell)?.Initialize(m_wandControl, spell, spellSprite);
		}

		private void EndScale(Vector3 endScale)
		{
			IsScaling = false;
			if (m_selectionScalerParent != null)
			{
				m_selectionScalerParent.localScale = endScale;
			}
			if (endScale == Vector3.zero)
			{
				TryHideUI();
			}
			else
			{
				ShowUI();
			}
		}

		public void ResetUI()
		{
			ResetBarColor(0);
			EndScale(Vector3.zero);
			SetSpellSelectionColliders(value: false);
			SetWandStatsActive(active: false);
		}

		public void HighlightSpellSlot(int selectIndex)
		{
			if (selectIndex < 0)
			{
				if (HighlightedRelic != null)
				{
					(HighlightedRelic as RadialElement_Spell).SelectSpell();
				}
			}
			else
			{
				if (m_spellSelecionElements.IsNullOrEmpty() || HighlightedRelic == m_spellSelecionElements[selectIndex])
				{
					return;
				}
				HighlightedRelic = m_spellSelecionElements[selectIndex];
				for (int i = 1; i < m_spellSelecionElements.Count; i++)
				{
					RadialElement radialElement = m_spellSelecionElements[i];
					if (!(radialElement == null))
					{
						if (i == selectIndex)
						{
							radialElement.LookEnter();
						}
						else if (radialElement is RadialElement_Spell)
						{
							(radialElement as RadialElement_Spell).DeSelectElement();
						}
					}
				}
			}
		}

		public RadialElement_Spell HighlightAndReturnSpellSlot(int selectIndex)
		{
			if (selectIndex < 0)
			{
				if (HighlightedRelic != null)
				{
					(HighlightedRelic as RadialElement_Spell).SelectSpell();
				}
				return HighlightedRelic as RadialElement_Spell;
			}
			if (m_spellSelecionElements.IsNullOrEmpty())
			{
				return null;
			}
			if (HighlightedRelic == m_spellSelecionElements[selectIndex])
			{
				return HighlightedRelic as RadialElement_Spell;
			}
			HighlightedRelic = m_spellSelecionElements[selectIndex];
			for (int i = 1; i < m_spellSelecionElements.Count; i++)
			{
				RadialElement radialElement = m_spellSelecionElements[i];
				if (!(radialElement == null))
				{
					if (i == selectIndex)
					{
						radialElement.LookEnter();
					}
					else if (radialElement is RadialElement_Spell)
					{
						(radialElement as RadialElement_Spell).DeSelectElement();
					}
				}
			}
			return HighlightedRelic as RadialElement_Spell;
		}

		public void ToggleUI(bool active, bool selectHighlightedRadialElement = true, bool playSfx = true, bool playSpellSelectSfx = true)
		{
			if (m_wandControl.Wielder.Wand.IsSpellCastingLocked)
			{
				return;
			}
			if (m_isDirectionalInput)
			{
				if (m_isHudActive != active)
				{
					m_isHudActive = active;
					Events.SpellSelectActivatedEvent spellSelectActivatedEvent = new Events.SpellSelectActivatedEvent();
					spellSelectActivatedEvent.Active = active;
					EventHub.Publish(spellSelectActivatedEvent);
					if (playSpellSelectSfx)
					{
						m_wandControl.PlaySpellActiveSound();
					}
				}
				return;
			}
			bool? flag = MonoSingleton<ArenaUI>.Instance?.GetAnyMenuOpen();
			if (flag.HasValue && flag.Value)
			{
				return;
			}
			if (IsScaling)
			{
				EndScale(m_selectionScalerParent.localScale);
			}
			if (!active && !IsActive)
			{
				return;
			}
			if (active && m_playerControl != null)
			{
				m_radialElementsParent.SetActive(value: true);
				MonoSingleton<ArenaUI>.Instance?.DisableNotification(force: true);
				if (playSfx)
				{
					PunSingleton<SoundManager>.Instance.PlaySoundAtPoint("ui_open", 0.75f, base.transform.position);
				}
				UpdatePositionAndRotation();
				SetTrackPosition(m_radialRoot.position, m_radialRoot.rotation);
			}
			EventHub.Publish(new Events.WandUiToggledEvent());
			SetUIActive(active: false, active, selectHighlightedRadialElement, playSpellSelectSfx);
			m_currentScaleTime = 0f;
			m_startScale = ((!active) ? Vector3.one : Vector3.zero);
			m_endScale = ((!active) ? Vector3.zero : Vector3.one);
			SetSpellSelectionColliders(active);
			SetWandStatsActive(active);
			IsScaling = true;
		}

		private void ShowUI()
		{
			if (!(m_playerControl == null))
			{
				IsActive = true;
				m_playerControl.HUD?.FadeHUD(fadeIn: false);
				m_playerControl.Wand?.ResetHighlightedTile();
				SetUIActive(active: true, enableInteraction: true, selectHighlightedRadialElement: false);
			}
		}

		public void TryHideUI()
		{
			if (IsActive && !(m_playerControl == null) && !(m_radialElementsParent == null))
			{
				IsActive = false;
				SetUIVisible(updatePosition: false);
				m_playerControl.HUD?.FadeHUD(fadeIn: true);
				m_radialElementsParent.SetActive(value: false);
			}
		}

		private void SetSpellSelectionColliders(bool value)
		{
			if (m_spellSelecionElements.IsNullOrEmpty())
			{
				return;
			}
			foreach (RadialElement spellSelecionElement in m_spellSelecionElements)
			{
				if (spellSelecionElement.IsEnabled)
				{
					spellSelecionElement.gameObject.SetActive(value);
				}
				else if (spellSelecionElement.gameObject.activeInHierarchy)
				{
					spellSelecionElement.gameObject.SetActive(value: false);
				}
			}
		}

		private void SetUIVisible(bool updatePosition)
		{
			if (updatePosition)
			{
				UpdatePositionAndRotation();
				SetTrackPosition(m_radialRoot.position, m_radialRoot.rotation);
			}
		}

		private void SetUIActive(bool active, bool enableInteraction, bool selectHighlightedRadialElement, bool playSpellSelectSfx = true)
		{
			if (!active && HighlightedRelic != null)
			{
				if (selectHighlightedRadialElement)
				{
					if (HighlightedRelic is RadialElement_Option)
					{
						if ((HighlightedRelic as RadialElement_Option).m_option == Option.Menu)
						{
							MonoSingleton<ArenaUI>.Instance?.ToggleMenuActive(enable: true);
						}
					}
					else
					{
						int index = m_spellSelecionElements.IndexOf(HighlightedRelic);
						SpellBase spell = m_wandControl.AvailableSpells[index];
						m_wandControl.SelectSpell(spell, playSpellSelectSfx);
					}
				}
				HighlightedRelic = null;
			}
			bool locked = !((!enableInteraction) ? active : enableInteraction);
			foreach (RadialElement spellSelecionElement in m_spellSelecionElements)
			{
				if (spellSelecionElement.IsEnabled && (!(spellSelecionElement is RadialElement_Spell) || !((spellSelecionElement as RadialElement_Spell).Spell == null)))
				{
					spellSelecionElement.LockInteraction(locked);
					spellSelecionElement.LockLook(locked);
				}
			}
		}

		public void DisableWandStatsObject()
		{
			if (m_wandStats != null)
			{
				m_wandStats.gameObject.SetActive(value: false);
			}
		}

		public void SetWandStatsActive(bool active)
		{
			if (m_wandStats != null && m_wandStats.gameObject.activeSelf)
			{
				m_wandStats.SetActive(active);
			}
		}

		public void ResetBarColor(int index)
		{
			if (!(m_wandStats == null) && index < m_wandStats.transform.childCount)
			{
				m_wandStats.SetColor(index);
			}
		}

		public void SetBarColor(int index, Color surfaceColor, Color accentColor, Color baseColor)
		{
			if (m_wandStats != null && index < m_wandStats.transform.childCount)
			{
				m_wandStats.SetColor(index, surfaceColor, accentColor, baseColor);
			}
		}

		public void SetTrackPosition(Vector3 position, Quaternion rotation)
		{
			m_trackRotation = rotation;
		}

		private void UpdatePositionAndRotation()
		{
			if (!(m_radialRoot == null) && !(m_playerControl == null))
			{
				if (m_playerControl.Input.AimInput == AimInput.Head)
				{
					m_radialRoot.position = m_playerControl.Input.GetAim().CameraRay.GetPoint(1.35f) + Vector3.up * -0.08f;
					m_radialRoot.rotation = Quaternion.LookRotation(-(m_wandControl.Aim.AimPivot.position - m_radialRoot.position).normalized);
				}
				else
				{
					m_radialRoot.position = m_wandControl.Aim.AimRay.GetPoint(m_positionOffsetZ);
					m_radialRoot.rotation = Quaternion.LookRotation(m_wandControl.Aim.AimRay.direction.normalized);
				}
				UpdatedWandStatsTransform();
			}
		}

		private void UpdatedWandStatsTransform()
		{
			if (!(m_wandStats == null) && m_wandStats.gameObject.activeSelf)
			{
				m_wandStats.transform.position = m_radialRoot.position;
				m_wandStats.transform.rotation = m_radialRoot.rotation;
			}
		}
	}
}
public static class WandsAnalytics
{
	public const string ClientVersion = "ClientVersion";

	public const string Platform = "Platform";

	public const string Level = "Level";

	public const string MatchesPlayed = "MatchesPlayed";

	public const string SpellsUnlocked = "SpellsUnlocked";

	public const string Rating = "Rating";

	public const string ArenaID = "ArenaId";

	public const string SpellID = "SpellId";

	public const string UnlockOrder = "UnlockOrder";

	public const string Score = "Score";

	public const string Reason = "Reason";

	public const string Result = "Result";

	public const string SpellTokenCount = "SpellTokenCount";

	public const string MatchID = "MatchId";

	public const string Error = "Error";

	public const string StackTrace = "StackTrace";

	public const string VirtualCurrency = "VirtualCurrency";

	public const string ItemType = "ItemType";

	public const string ItemID = "ItemId";

	public const string ItemCost = "ItemCost";

	public const string Language = "Language";

	public const string Amount = "Amount";

	public const string NewTutorialState = "NewTutorialState";

	public const string OldWandID = "OldWandId";

	public const string NewWandID = "NewWandId";

	public const string OldCharacterID = "OldCharacterId";

	public const string NewCharacterID = "NewCharacterId";

	public const string CurrentLoadoutInfo = "CurrentLoadoutInfo";

	private const string FullGamePurchasedEventName = "FullGamePurchased";

	private static Dictionary<string, object> sm_predefinedEventData = new Dictionary<string, object>
	{
		{
			"ClientVersion",
			GameControl.Instance.ClientVersion.ToString()
		},
		{
			"Platform",
			GameControl.Instance.Platform.Type
		}
	};

	public static void SendCustomEvent(CustomEventType customEventType, Dictionary<string, object> predefinedData = null)
	{
		if (predefinedData == null)
		{
			GameControl.Instance.CloudManager?.SendCustomEvent(customEventType, sm_predefinedEventData);
			return;
		}
		foreach (KeyValuePair<string, object> sm_predefinedEventDatum in sm_predefinedEventData)
		{
			predefinedData[sm_predefinedEventDatum.Key] = sm_predefinedEventDatum.Value;
		}
		GameControl.Instance.CloudManager?.SendCustomEvent(customEventType, predefinedData);
	}
}
namespace Assets.Scripts.WandsInput
{
	[RequireComponent(typeof(LineRenderer))]
	public class AimPivot : MonoBehaviour
	{
		[SerializeField]
		[Range(0f, 10f)]
		private float m_maxLaserDistance = 0.75f;

		[SerializeField]
		private bool m_allowWandGrip;

		private float m_startRotationX;

		private Vector3 m_localStartPosition;

		private EventToken m_wandGripChangedEventToken;

		private EventToken m_wandControllerSpawnedEventToken;

		private EventToken m_inputChangedEventToken;

		public LineRenderer LineRenderer { get; private set; }

		private void Awake()
		{
			m_startRotationX = base.transform.parent.localEulerAngles.x;
			m_localStartPosition = base.transform.localPosition;
			LineRenderer = GetComponent<LineRenderer>();
			LineRenderer.useWorldSpace = false;
			LineRenderer.SetPosition(1, Vector3.forward * m_maxLaserDistance);
		}

		private void OnEnable()
		{
			m_inputChangedEventToken = EventHub.Subscribe<InputEvents.InputChangedEvent>(OnInputChanged);
			if (m_allowWandGrip)
			{
				m_wandGripChangedEventToken = EventHub.Subscribe<InputEvents.WandGripChangedEvent>(OnWandGripChanged);
				m_wandControllerSpawnedEventToken = EventHub.Subscribe<InputEvents.WandControllerSpawnedEvent>(OnWandControllerSpawned);
			}
		}

		private void OnDisable()
		{
			EventHub.Unsubscribe<InputEvents.InputChangedEvent>(m_inputChangedEventToken);
			if (m_allowWandGrip)
			{
				EventHub.Unsubscribe<InputEvents.WandGripChangedEvent>(m_wandGripChangedEventToken);
				EventHub.Unsubscribe<InputEvents.WandControllerSpawnedEvent>(m_wandControllerSpawnedEventToken);
			}
		}

		private void ChangePrimaryHand(AimInput aimInput)
		{
			Vector3 localStartPosition = m_localStartPosition;
			localStartPosition.x = m_localStartPosition.x * ((aimInput != AimInput.LeftHand) ? 1f : (-1f));
			base.transform.localPosition = localStartPosition;
		}

		private void OnWandControllerSpawned(InputEvents.WandControllerSpawnedEvent eventData)
		{
			ChangeWandGrip(eventData.WandGrip);
		}

		private void OnWandGripChanged(InputEvents.WandGripChangedEvent eventData)
		{
			ChangeWandGrip(eventData.WandGrip);
		}

		private void ChangeWandGrip(WandGrip wandGrip)
		{
			SetWandGripAngle(wandGrip == WandGrip.Wand);
		}

		private void SetWandGripAngle(bool isWandGrip)
		{
			Vector3 localEulerAngles = base.transform.parent.localEulerAngles;
			localEulerAngles.x = ((!isWandGrip) ? m_startRotationX : (m_startRotationX + -28f));
			base.transform.parent.localRotation = Quaternion.Euler(localEulerAngles);
		}

		private void OnInputChanged(InputEvents.InputChangedEvent eventData)
		{
			ChangePrimaryHand(eventData.AimInput);
		}
	}
	public class GearVrTouchInput : IPlatformInput
	{
		private const OVRInput.Button MenuButton = OVRInput.Button.Back;

		private const OVRInput.Touch PrimaryTouch = OVRInput.Touch.PrimaryTouchpad;

		private Action<InputState> m_menuAction;

		private Action<InputState, float> m_swipeAction;

		private Action<InputState> m_holdAction;

		private const float MinSwipeMagnitue = 25f;

		private const float MinSwipeMagnitudeSqr = 625f;

		private Vector2 m_swipeStartPoint;

		private float m_currentHoldTime;

		private bool m_isHolding;

		private bool m_hasSwiped;

		public bool IsCorrectInputSystem => !OVRInput.IsControllerConnected(OVRInput.Controller.Gamepad) && !OVRInput.IsControllerConnected(OVRInput.Controller.LTrackedRemote | OVRInput.Controller.RTrackedRemote);

		public bool IsAutoTeleportEnabled
		{
			[CompilerGenerated]
			get
			{
				return false;
			}
		}

		public AimInput Aim
		{
			[CompilerGenerated]
			get
			{
				return AimInput.Head;
			}
		}

		public WandInput WandInput
		{
			[CompilerGenerated]
			get
			{
				return WandInput.Point;
			}
		}

		public void BindActions(IInputListener listener)
		{
			m_menuAction = listener.OnMenuInput;
			m_swipeAction = listener.OnSwipeInput;
			m_holdAction = listener.OnPrimaryInput;
		}

		public void UnbindActions(IInputListener listener)
		{
		}

		public void Update()
		{
			CheckButtonBindings();
			CheckTouchBindings();
		}

		private void CheckButtonBindings()
		{
			InputState buttonInputState = GetButtonInputState(OVRInput.Button.Back);
			if (buttonInputState != 0)
			{
				m_menuAction(buttonInputState);
			}
		}

		private InputState GetSwipeDirection(Vector2 diff)
		{
			if (Mathf.Abs(diff.x) >= Mathf.Abs(diff.y))
			{
				if (diff.x > 0f)
				{
					return InputState.AxisRight;
				}
				return InputState.AxisLeft;
			}
			if (diff.y > 0f)
			{
				return InputState.AxisUp;
			}
			return InputState.AxisDown;
		}

		private void CheckTouchBindings()
		{
			switch (GetTouchInputState(OVRInput.Touch.PrimaryTouchpad))
			{
			case InputState.Down:
				m_hasSwiped = false;
				m_isHolding = false;
				m_currentHoldTime = 0f;
				m_swipeStartPoint = Input.mousePosition;
				break;
			case InputState.Hold:
			{
				m_currentHoldTime += Time.deltaTime;
				Vector2 diff = (Vector2)Input.mousePosition - m_swipeStartPoint;
				bool flag = diff.sqrMagnitude >= 625f;
				if (!m_isHolding && flag && !m_hasSwiped)
				{
					m_hasSwiped = true;
					m_swipeAction(InputState.Up | GetSwipeDirection(diff), Mathf.Clamp((1f - Mathf.Min(m_currentHoldTime / 2f, 0.28f) * 3f) / 0.85f * Mathf.Clamp(diff.magnitude / 50f, 0.8f, 1.2f), 0.3f, 1.3f));
				}
				if (m_isHolding || (m_currentHoldTime >= 0.15f && !flag && !m_hasSwiped))
				{
					if (!m_isHolding)
					{
						m_holdAction(InputState.Down);
						m_isHolding = true;
					}
					m_holdAction(InputState.Hold);
				}
				break;
			}
			case InputState.Up:
				if (m_isHolding || ((Vector2)Input.mousePosition - m_swipeStartPoint).sqrMagnitude < 625f)
				{
					if (!m_isHolding)
					{
						m_holdAction(InputState.Down);
						m_holdAction(InputState.Hold);
					}
					m_holdAction(InputState.Up);
				}
				break;
			}
		}

		public InputState GetTouchInputState(OVRInput.Touch touch)
		{
			if (OVRInput.GetDown(touch, OVRInput.Controller.Touchpad))
			{
				return InputState.Down;
			}
			if (OVRInput.GetUp(touch, OVRInput.Controller.Touchpad))
			{
				return InputState.Up;
			}
			if (OVRInput.Get(touch, OVRInput.Controller.Touchpad))
			{
				return InputState.Hold;
			}
			return InputState.None;
		}

		public InputState GetButtonInputState(OVRInput.Button button)
		{
			if (OVRInput.GetDown(button, OVRInput.Controller.Touchpad))
			{
				return InputState.Down;
			}
			if (OVRInput.GetUp(button, OVRInput.Controller.Touchpad))
			{
				return InputState.Up;
			}
			if (OVRInput.Get(button, OVRInput.Controller.Touchpad))
			{
				return InputState.Hold;
			}
			return InputState.None;
		}
	}
	public class GoblinInputPoint : IPlatformInput, IPauseListenerInput<Pvr_KeyCode>
	{
		private const Pvr_KeyCode PrimaryButton = Pvr_KeyCode.TOUCHPAD;

		private const Pvr_KeyCode SecondaryButton = Pvr_KeyCode.APP;

		private const int HandIndex = 0;

		private readonly Dictionary<Action<InputState>, InputState> m_actions = new Dictionary<Action<InputState>, InputState>(2);

		private InputPauseListener<Pvr_KeyCode> m_inputPauseListener;

		public Dictionary<Pvr_KeyCode, Action<InputState>> ButtonBindings { get; } = new Dictionary<Pvr_KeyCode, Action<InputState>>(2);


		public bool IsCorrectInputSystem
		{
			[CompilerGenerated]
			get
			{
				return true;
			}
		}

		public bool IsAutoTeleportEnabled
		{
			[CompilerGenerated]
			get
			{
				return false;
			}
		}

		public AimInput Aim
		{
			[CompilerGenerated]
			get
			{
				return AimInput.Remote;
			}
		}

		public WandInput WandInput
		{
			[CompilerGenerated]
			get
			{
				return WandInput.Point;
			}
		}

		public GoblinInputPoint()
		{
			m_inputPauseListener = new InputPauseListener<Pvr_KeyCode>(this);
		}

		public void BindActions(IInputListener listener)
		{
			BindButton(Pvr_KeyCode.TOUCHPAD, listener.OnPrimaryInput);
			BindButton(Pvr_KeyCode.APP, listener.OnSecondaryInput);
		}

		public void UnbindActions(IInputListener listener)
		{
			UnbindButton(Pvr_KeyCode.TOUCHPAD, listener.OnPrimaryInput);
			UnbindButton(Pvr_KeyCode.APP, listener.OnSecondaryInput);
		}

		private void BindButton(Pvr_KeyCode button, Action<InputState> action)
		{
			if (ButtonBindings.ContainsKey(button))
			{
				Dictionary<Pvr_KeyCode, Action<InputState>> buttonBindings;
				Pvr_KeyCode key;
				(buttonBindings = ButtonBindings)[key = button] = (Action<InputState>)Delegate.Combine(buttonBindings[key], action);
			}
			else
			{
				ButtonBindings.Add(button, action);
			}
		}

		private void UnbindButton(Pvr_KeyCode button, Action<InputState> action)
		{
			if (ButtonBindings.ContainsKey(button))
			{
				Dictionary<Pvr_KeyCode, Action<InputState>> buttonBindings;
				Pvr_KeyCode key;
				(buttonBindings = ButtonBindings)[key = button] = (Action<InputState>)Delegate.Remove(buttonBindings[key], action);
			}
		}

		public void Update()
		{
			CheckButtonBindings();
		}

		private void CheckButtonBindings()
		{
			m_actions.Clear();
			foreach (KeyValuePair<Pvr_KeyCode, Action<InputState>> buttonBinding in ButtonBindings)
			{
				InputState buttonInputState = GetButtonInputState(buttonBinding.Key);
				if (buttonInputState != 0 && buttonBinding.Value != null && !m_actions.ContainsKey(buttonBinding.Value))
				{
					m_actions.Add(buttonBinding.Value, buttonInputState);
				}
			}
			foreach (KeyValuePair<Action<InputState>, InputState> action in m_actions)
			{
				action.Key(action.Value);
			}
		}

		public InputState GetButtonInputState(Pvr_KeyCode button)
		{
			if (Controller.UPvr_GetKeyDown(0, button))
			{
				return InputState.Down;
			}
			if (Controller.UPvr_GetKeyUp(0, button))
			{
				return InputState.Up;
			}
			if (Controller.UPvr_GetKey(0, button))
			{
				return InputState.Hold;
			}
			return InputState.None;
		}
	}
	public class GoblinInputSwipe : IPlatformInput
	{
		private const Pvr_KeyCode PrimaryButton = Pvr_KeyCode.TOUCHPAD;

		private const Pvr_KeyCode SecondaryButton = Pvr_KeyCode.APP;

		private const int HandIndex = 0;

		private Action<InputState> m_swipeAction;

		private Action<InputState> m_primaryAction;

		private Action<InputState> m_menuAction;

		private Action<InputState> m_teleportAction;

		private Action<InputState, float> m_eulaSwipeAction;

		private bool m_isTouching;

		private bool m_awaitingDoubleButtonRelease;

		private bool m_firstSwipeInput;

		private Queue<Vector2> m_swipePoints = new Queue<Vector2>();

		private InputState m_previousSwipeState;

		private const float PicoToNormal = 0.007843138f;

		private const int MaxSwipePoints = 20;

		private const float MinSwipeCenterOffset = 0.25f;

		private const float MinSwipeDistance = 0.707f;

		private const float MinSwipeDistanceSqr = 0.49984902f;

		public bool IsCorrectInputSystem
		{
			[CompilerGenerated]
			get
			{
				return true;
			}
		}

		public bool IsAutoTeleportEnabled
		{
			[CompilerGenerated]
			get
			{
				return false;
			}
		}

		public AimInput Aim
		{
			[CompilerGenerated]
			get
			{
				return AimInput.Remote;
			}
		}

		public WandInput WandInput
		{
			[CompilerGenerated]
			get
			{
				return WandInput.Swipe;
			}
		}

		public void BindActions(IInputListener listener)
		{
			m_swipeAction = listener.OnPrimaryAxisInput;
			m_menuAction = listener.OnMenuInput;
			m_teleportAction = listener.OnTeleportInput;
			m_primaryAction = listener.OnPrimaryInput;
		}

		public void UnbindActions(IInputListener listener)
		{
			m_eulaSwipeAction = null;
			m_swipeAction = null;
			m_primaryAction = null;
			m_menuAction = null;
			m_teleportAction = null;
		}

		public void Update()
		{
			UpdateMenuInput(out var justPressedBothButtons, out var shouldGatherOtherInput);
			if (justPressedBothButtons)
			{
				if (m_teleportAction != null)
				{
					m_teleportAction(InputState.Up);
				}
				PlayerManager.Instance.PlayerControl.Wand.AbortSpellCasting();
			}
			if (shouldGatherOtherInput)
			{
				UpdatePrimaryInput();
				UpdateSwipeInput();
				UpdateSecondaryInput();
			}
		}

		private void UpdatePrimaryInput()
		{
			InputState buttonInputState = GetButtonInputState(Pvr_KeyCode.TOUCHPAD);
			if (buttonInputState != 0)
			{
				if (m_primaryAction != null)
				{
					m_primaryAction(buttonInputState);
				}
				if (buttonInputState == InputState.Down)
				{
					ResetSwipe();
				}
			}
		}

		private void UpdateSecondaryInput()
		{
			InputState buttonInputState = GetButtonInputState(Pvr_KeyCode.APP);
			switch (buttonInputState)
			{
			case InputState.Down:
				if (m_teleportAction != null)
				{
					m_teleportAction(buttonInputState);
				}
				break;
			case InputState.Up:
			{
				bool? flag = PlayerManager.Instance.PlayerControl.Wand?.IsSpellTypeSelected(Spell.Spell_Teleport);
				if (flag.HasValue && flag.Value)
				{
					if (m_primaryAction != null)
					{
						m_primaryAction(InputState.Down);
					}
					ResetSwipe();
				}
				if (m_teleportAction != null)
				{
					m_teleportAction(buttonInputState);
				}
				break;
			}
			}
		}

		private void UpdateMenuInput(out bool justPressedBothButtons, out bool shouldGatherOtherInput)
		{
			justPressedBothButtons = false;
			shouldGatherOtherInput = true;
			InputState buttonInputState = GetButtonInputState(Pvr_KeyCode.APP);
			InputState buttonInputState2 = GetButtonInputState(Pvr_KeyCode.TOUCHPAD);
			InputState inputState = buttonInputState2 | buttonInputState;
			if (inputState == InputState.None)
			{
				return;
			}
			if (inputState.ContainsFlag(InputState.Down) && buttonInputState2 != 0 && buttonInputState != 0)
			{
				justPressedBothButtons = (m_awaitingDoubleButtonRelease = true);
			}
			if (!m_awaitingDoubleButtonRelease)
			{
				return;
			}
			shouldGatherOtherInput = false;
			if (inputState.ContainsFlag(InputState.Up) && (buttonInputState2 == InputState.None || buttonInputState == InputState.None || buttonInputState2 == buttonInputState))
			{
				m_awaitingDoubleButtonRelease = false;
				if (m_menuAction != null)
				{
					m_menuAction(InputState.Up);
				}
			}
		}

		private void UpdateSwipeInput()
		{
			InputState touchState = GetTouchState();
			if (touchState != 0 && m_swipeAction != null)
			{
				m_swipeAction(touchState);
			}
		}

		public InputState GetButtonInputState(Pvr_KeyCode button)
		{
			if (Controller.UPvr_GetKeyDown(0, button))
			{
				return InputState.Down;
			}
			if (Controller.UPvr_GetKeyUp(0, button))
			{
				return InputState.Up;
			}
			if (Controller.UPvr_GetKey(0, button))
			{
				return InputState.Hold;
			}
			return InputState.None;
		}

		private void ResetSwipe()
		{
			m_swipePoints.Clear();
			m_firstSwipeInput = true;
			m_swipePoints.Enqueue(GetTouchPadPosition());
		}

		private InputState GetStateInsideSlice(Vector2 currentPoint)
		{
			float x = currentPoint.x;
			float y = currentPoint.y;
			if (Mathf.Abs(y) > Mathf.Abs(x))
			{
				if (y > 0.25f)
				{
					InputState inputState = InputState.AxisUp;
					if (!m_previousSwipeState.ContainsFlag(inputState))
					{
						inputState |= InputState.Down;
					}
					return m_previousSwipeState = inputState;
				}
				if (y < -0.25f)
				{
					InputState inputState2 = InputState.AxisDown;
					if (!m_previousSwipeState.ContainsFlag(inputState2))
					{
						inputState2 |= InputState.Down;
					}
					return m_previousSwipeState = inputState2;
				}
			}
			else
			{
				if (x > 0.25f)
				{
					InputState inputState3 = InputState.AxisRight;
					if (!m_previousSwipeState.ContainsFlag(inputState3))
					{
						inputState3 |= InputState.Down;
					}
					return m_previousSwipeState = inputState3;
				}
				if (x < -0.25f)
				{
					InputState inputState4 = InputState.AxisLeft;
					if (!m_previousSwipeState.ContainsFlag(inputState4))
					{
						inputState4 |= InputState.Down;
					}
					return m_previousSwipeState = inputState4;
				}
			}
			return m_previousSwipeState;
		}

		private InputState GetSwipeState(Vector2 currentPoint, Vector2 swipeStartPoint)
		{
			Vector2 vector = currentPoint - swipeStartPoint;
			if (vector.sqrMagnitude >= 0.49984902f || (m_eulaSwipeAction != null && vector.sqrMagnitude >= 0.24992451f))
			{
				m_firstSwipeInput = false;
				if (Mathf.Abs(vector.x) >= Mathf.Abs(vector.y))
				{
					if (vector.x > 0f)
					{
						m_previousSwipeState = InputState.AxisRight;
						if (m_eulaSwipeAction != null)
						{
							m_eulaSwipeAction(m_previousSwipeState, vector.magnitude);
						}
						return m_previousSwipeState | InputState.Down;
					}
					m_previousSwipeState = InputState.AxisLeft;
					if (m_eulaSwipeAction != null)
					{
						m_eulaSwipeAction(m_previousSwipeState, vector.magnitude);
					}
					return m_previousSwipeState | InputState.Down;
				}
				if (vector.y > 0f)
				{
					m_previousSwipeState = InputState.AxisUp;
					if (m_eulaSwipeAction != null)
					{
						m_eulaSwipeAction(m_previousSwipeState, vector.magnitude);
					}
					return m_previousSwipeState | InputState.Down;
				}
				m_previousSwipeState = InputState.AxisDown;
				return m_previousSwipeState | InputState.Down;
			}
			return InputState.None;
		}

		private Vector2 GetTouchPadPosition()
		{
			return Controller.UPvr_GetTouchPadPosition(0);
		}

		private InputState GetTouchState()
		{
			if (!m_isTouching && Controller.UPvr_IsTouching(0))
			{
				m_isTouching = true;
				ResetSwipe();
			}
			else
			{
				if (Controller.UPvr_IsTouching(0))
				{
					Vector2 touchPadPosition = GetTouchPadPosition();
					m_swipePoints.Enqueue(touchPadPosition);
					if (!m_firstSwipeInput)
					{
						return GetStateInsideSlice(touchPadPosition);
					}
					Vector2 swipeStartPoint = ((m_swipePoints.Count <= 20) ? m_swipePoints.Peek() : m_swipePoints.Dequeue());
					return GetSwipeState(touchPadPosition, swipeStartPoint);
				}
				if (m_isTouching && !Controller.UPvr_IsTouching(0))
				{
					m_isTouching = false;
					return InputState.Up;
				}
			}
			return InputState.None;
		}
	}
	public class GoTouchInput : IPlatformInput
	{
		public bool IsCorrectInputSystem
		{
			[CompilerGenerated]
			get
			{
				return false;
			}
		}

		public bool IsAutoTeleportEnabled
		{
			[CompilerGenerated]
			get
			{
				return false;
			}
		}

		public AimInput Aim
		{
			[CompilerGenerated]
			get
			{
				return AimInput.Head;
			}
		}

		public WandInput WandInput
		{
			[CompilerGenerated]
			get
			{
				return WandInput.None;
			}
		}

		public void BindActions(IInputListener listener)
		{
		}

		public void UnbindActions(IInputListener listener)
		{
		}

		public void Update()
		{
		}
	}
}
namespace Assets.Scripts.WandsInput.Haptics
{
	[CreateAssetMenu(fileName = "EmptyHapticsData", menuName = "Haptics/Create data object", order = 1)]
	public class HapticsData : ScriptableObject
	{
		public VibrationType Type;

		public VibrateController Controller;

		public VibrationForce Force;

		public float Time;

		[Range(0f, 255f)]
		public int StartLevel;

		[Range(0f, 255f)]
		public int EndLevel;

		public override string ToString()
		{
			return string.Concat(Type, ", ", Controller, ", ", Force, ", ", Time, ", ", StartLevel, ", ", EndLevel);
		}

		public static HapticsData Copy(HapticsData data)
		{
			HapticsData hapticsData = ScriptableObject.CreateInstance<HapticsData>();
			hapticsData.Type = data.Type;
			hapticsData.Controller = data.Controller;
			hapticsData.Force = data.Force;
			hapticsData.Time = data.Time;
			hapticsData.StartLevel = data.StartLevel;
			hapticsData.EndLevel = data.EndLevel;
			return hapticsData;
		}
	}
	public interface IPlatformHaptics
	{
		void InitializeHaptics(MonoBehaviour Owner);

		void StartHaptics(HapticsData hapticsData, bool overrideCurrent, WandHand wandHand);

		void CancelHaptics();

		void UpdatePrimaryChannel(bool primaryIsRight);

		IEnumerator ContinuousVibration(VibrationForce vibrationForce);

		IEnumerator TimedVibration(VibrationForce vibrationForce, float time);

		IEnumerator TimedIncreasingVibration(float time, int startingLevel, int endingLevel);
	}
	public class OculusTouchHapticsController : IPlatformHaptics
	{
		private OVRHapticsClip m_clipLight;

		private OVRHapticsClip m_clipMedium;

		private OVRHapticsClip m_clipHard;

		private OVRHapticsClip[] m_clipIncreasing;

		private OVRHaptics.OVRHapticsChannel m_channel;

		private HapticsData m_activeHaptics;

		private IEnumerator m_activeCoroutine;

		private MonoBehaviour m_owner;

		private byte m_lightValue;

		private byte m_mediumValue;

		private byte m_hardValue;

		public OculusTouchHapticsController(byte lightValue, byte mediumValue, byte hardValue)
		{
			m_lightValue = lightValue;
			m_mediumValue = mediumValue;
			m_hardValue = hardValue;
		}

		public void InitializeHaptics(MonoBehaviour owner)
		{
			m_owner = owner;
			int num = 10;
			m_clipLight = new OVRHapticsClip(num);
			m_clipMedium = new OVRHapticsClip(num);
			m_clipHard = new OVRHapticsClip(num);
			m_clipIncreasing = new OVRHapticsClip[256];
			for (int i = 0; i < num; i++)
			{
				m_clipLight.Samples[i] = (byte)((i % 2 != 0) ? m_lightValue : 0);
				m_clipMedium.Samples[i] = (byte)((i % 2 != 0) ? m_mediumValue : 0);
				m_clipHard.Samples[i] = (byte)((i % 2 != 0) ? m_hardValue : 0);
			}
			m_clipLight = new OVRHapticsClip(m_clipLight.Samples, m_clipLight.Samples.Length);
			m_clipMedium = new OVRHapticsClip(m_clipMedium.Samples, m_clipMedium.Samples.Length);
			m_clipHard = new OVRHapticsClip(m_clipHard.Samples, m_clipHard.Samples.Length);
			num = 4;
			for (int j = 0; j < 255; j++)
			{
				m_clipIncreasing[j] = new OVRHapticsClip(num);
				for (int k = 0; k < num; k++)
				{
					m_clipIncreasing[j].Samples[k] = (byte)((k % 2 != 0) ? ((byte)j) : 0);
				}
				m_clipIncreasing[j] = new OVRHapticsClip(m_clipIncreasing[j].Samples, m_clipIncreasing[j].Samples.Length);
			}
		}

		public void UpdatePrimaryChannel(bool primaryIsRight)
		{
			m_channel = ((!primaryIsRight) ? OVRHaptics.LeftChannel : OVRHaptics.RightChannel);
		}

		public void StartHaptics(HapticsData hapticsData, bool overrideCurrent, WandHand wandHand)
		{
			if (hapticsData.Type == VibrationType.None)
			{
				CancelHaptics();
				return;
			}
			if (m_activeHaptics != null)
			{
				if (!overrideCurrent)
				{
					return;
				}
				CancelHaptics();
			}
			m_activeHaptics = hapticsData;
			switch (m_activeHaptics.Type)
			{
			case VibrationType.Continuous:
				m_activeCoroutine = ContinuousVibration(hapticsData.Force);
				break;
			case VibrationType.Timed:
				m_activeCoroutine = TimedVibration(hapticsData.Force, hapticsData.Time);
				break;
			case VibrationType.TimedIncreasing:
				m_activeCoroutine = TimedIncreasingVibration(hapticsData.Time, hapticsData.StartLevel, hapticsData.EndLevel);
				break;
			}
			m_owner.StartCoroutine(m_activeCoroutine);
		}

		public void CancelHaptics()
		{
			m_activeHaptics = null;
			m_channel.Clear();
			if (m_activeCoroutine != null)
			{
				m_owner.StopCoroutine(m_activeCoroutine);
				m_activeCoroutine = null;
			}
		}

		public IEnumerator ContinuousVibration(VibrationForce vibrationForce)
		{
			while (!(m_activeHaptics == null))
			{
				AddClipToQueue(m_channel, vibrationForce);
				yield return null;
			}
			CancelHaptics();
		}

		public IEnumerator TimedVibration(VibrationForce vibrationForce, float time)
		{
			for (float num = 0f; num <= time; num += Time.deltaTime)
			{
				AddClipToQueue(m_channel, vibrationForce);
			}
			yield return new WaitForSeconds(time);
			CancelHaptics();
		}

		public IEnumerator TimedIncreasingVibration(float time, int startingLevel, int endingLevel)
		{
			float t = 0f;
			float levelMin = startingLevel;
			float levelMax = Mathf.Min(endingLevel, 254);
			while (t < 1f)
			{
				t += Time.deltaTime / time;
				int level = (int)Mathf.Lerp(levelMin, levelMax, t);
				m_channel.Preempt(m_clipIncreasing[level]);
				yield return null;
			}
			CancelHaptics();
		}

		private void AddClipToQueue(OVRHaptics.OVRHapticsChannel channel, VibrationForce vibrationForce)
		{
			switch (vibrationForce)
			{
			case VibrationForce.Light:
				channel.Queue(m_clipLight);
				break;
			case VibrationForce.Medium:
				channel.Queue(m_clipMedium);
				break;
			case VibrationForce.Hard:
				channel.Queue(m_clipHard);
				break;
			}
		}
	}
	public class QuestHapticsController : IPlatformHaptics
	{
		private OVRInput.Controller m_controller;

		private HapticsData m_activeHaptics;

		private IEnumerator m_activeCoroutine;

		private MonoBehaviour m_owner;

		private float m_lightValue;

		private float m_mediumValue;

		private float m_hardValue;

		private float m_frequency;

		public QuestHapticsController(float lightValue, float mediumValue, float hardValue, float frequency)
		{
			m_lightValue = lightValue;
			m_mediumValue = mediumValue;
			m_hardValue = hardValue;
			m_frequency = frequency;
		}

		public void InitializeHaptics(MonoBehaviour Owner)
		{
			m_owner = Owner;
		}

		public void UpdatePrimaryChannel(bool primaryIsRight)
		{
			m_controller = ((!primaryIsRight) ? OVRInput.Controller.LTouch : OVRInput.Controller.RTouch);
		}

		public void StartHaptics(HapticsData hapticsData, bool overrideCurrent, WandHand wandHand)
		{
			if (hapticsData.Type == VibrationType.None)
			{
				CancelHaptics();
				return;
			}
			if (m_activeHaptics != null)
			{
				if (!overrideCurrent)
				{
					return;
				}
				CancelHaptics();
			}
			m_activeHaptics = hapticsData;
			switch (m_activeHaptics.Type)
			{
			case VibrationType.Continuous:
				m_activeCoroutine = ContinuousVibration(hapticsData.Force);
				break;
			case VibrationType.Timed:
				m_activeCoroutine = TimedVibration(hapticsData.Force, hapticsData.Time);
				break;
			case VibrationType.TimedIncreasing:
				m_activeCoroutine = TimedIncreasingVibration(hapticsData.Time, hapticsData.StartLevel, hapticsData.EndLevel);
				break;
			}
			m_owner.StartCoroutine(m_activeCoroutine);
		}

		public void CancelHaptics()
		{
			m_activeHaptics = null;
			OVRInput.SetControllerVibration(0f, 0f, m_controller);
			if (m_activeCoroutine != null)
			{
				m_owner.StopCoroutine(m_activeCoroutine);
				m_activeCoroutine = null;
			}
		}

		public IEnumerator ContinuousVibration(VibrationForce vibrationForce)
		{
			while (!(m_activeHaptics == null))
			{
				TriggerVibrationValue(m_controller, vibrationForce);
				yield return null;
			}
			CancelHaptics();
		}

		public IEnumerator TimedVibration(VibrationForce vibrationForce, float time)
		{
			for (float num = 0f; num <= time; num += Time.deltaTime)
			{
				TriggerVibrationValue(m_controller, vibrationForce);
			}
			yield return new WaitForSeconds(time);
			CancelHaptics();
		}

		public IEnumerator TimedIncreasingVibration(float time, int startingLevel, int endingLevel)
		{
			float t = 0f;
			while (t < 1f)
			{
				t += Time.deltaTime / time;
				OVRInput.SetControllerVibration(m_frequency, t, m_controller);
				yield return null;
			}
			CancelHaptics();
		}

		private void TriggerVibrationValue(OVRInput.Controller controller, VibrationForce vibrationForce)
		{
			switch (vibrationForce)
			{
			case VibrationForce.Light:
				OVRInput.SetControllerVibration(m_frequency, m_lightValue, controller);
				break;
			case VibrationForce.Medium:
				OVRInput.SetControllerVibration(m_frequency, m_mediumValue, controller);
				break;
			case VibrationForce.Hard:
				OVRInput.SetControllerVibration(m_frequency, m_hardValue, controller);
				break;
			}
		}
	}
	public class ViveHapticsController : IPlatformHaptics
	{
		private uint m_controllerId;

		private HapticsData m_activeHaptics;

		private IEnumerator m_activeCoroutine;

		private MonoBehaviour m_owner;

		private global::OVR.OpenVR.CVRSystem m_system;

		private ushort m_light = 500;

		private ushort m_medium = 1000;

		private ushort m_hard = 1500;

		private uint m_leftHandID;

		private uint m_rightHandID;

		public void InitializeHaptics(MonoBehaviour Owner)
		{
			m_owner = Owner;
			m_system = global::OVR.OpenVR.OpenVR.System;
			if (m_system == null)
			{
				return;
			}
			for (uint num = 0u; num < 16; num++)
			{
				switch (m_system.GetControllerRoleForTrackedDeviceIndex(num))
				{
				case global::OVR.OpenVR.ETrackedControllerRole.LeftHand:
					m_leftHandID = num;
					break;
				case global::OVR.OpenVR.ETrackedControllerRole.RightHand:
					m_rightHandID = num;
					break;
				}
			}
			m_controllerId = ((!WandsSave.GetBoolPref("P1", defaultValue: true)) ? m_leftHandID : m_rightHandID);
		}

		public void UpdatePrimaryChannel(bool primaryIsRight)
		{
			m_controllerId = ((!primaryIsRight) ? m_leftHandID : m_rightHandID);
		}

		public void CancelHaptics()
		{
			m_activeHaptics = null;
			if (m_activeCoroutine != null)
			{
				m_owner.StopCoroutine(m_activeCoroutine);
				m_activeCoroutine = null;
			}
		}

		public void StartHaptics(HapticsData hapticsData, bool overrideCurrent, WandHand wandHand)
		{
			if (hapticsData.Type == VibrationType.None)
			{
				CancelHaptics();
				return;
			}
			if (m_activeHaptics != null)
			{
				if (!overrideCurrent)
				{
					return;
				}
				CancelHaptics();
			}
			m_activeHaptics = hapticsData;
			switch (m_activeHaptics.Type)
			{
			case VibrationType.Continuous:
				m_activeCoroutine = ContinuousVibration(hapticsData.Force);
				break;
			case VibrationType.Timed:
				m_activeCoroutine = TimedVibration(hapticsData.Force, hapticsData.Time);
				break;
			case VibrationType.TimedIncreasing:
				m_activeCoroutine = TimedIncreasingVibration(hapticsData.Time, hapticsData.StartLevel, hapticsData.EndLevel);
				break;
			}
			m_owner.StartCoroutine(m_activeCoroutine);
		}

		public IEnumerator ContinuousVibration(VibrationForce vibrationForce)
		{
			ushort strength = ConvertStrength(vibrationForce);
			while (!(m_activeHaptics == null))
			{
				TriggerHapticPulse(m_controllerId, strength);
				yield return null;
			}
			CancelHaptics();
		}

		public IEnumerator TimedIncreasingVibration(float time, int startingLevel, int endingLevel)
		{
			ushort[] convertedStrength = ConvertStrength(startingLevel, endingLevel);
			float timer = time;
			while (timer >= 0f)
			{
				timer -= Time.deltaTime;
				TriggerHapticPulse(durationMicroSec: (ushort)Mathf.Clamp((int)((1f - timer / time) * 3999f), convertedStrength[0], convertedStrength[1]), controller: m_controllerId);
				yield return null;
			}
			CancelHaptics();
		}

		public IEnumerator TimedVibration(VibrationForce vibrationForce, float time)
		{
			ushort strength = ConvertStrength(vibrationForce);
			float timer = time;
			while (timer >= 0f)
			{
				timer -= Time.deltaTime;
				TriggerHapticPulse(m_controllerId, strength);
				yield return null;
			}
			CancelHaptics();
		}

		private ushort ConvertStrength(VibrationForce vibrationForce)
		{
			return vibrationForce switch
			{
				VibrationForce.Light => m_light, 
				VibrationForce.Medium => m_medium, 
				VibrationForce.Hard => m_hard, 
				_ => 0, 
			};
		}

		private ushort[] ConvertStrength(int startingLevel, int endingLevel)
		{
			return new ushort[2]
			{
				(ushort)((float)(startingLevel / 255) * 3999f),
				(ushort)((float)(endingLevel / 255) * 3999f)
			};
		}

		private void TriggerHapticPulse(uint controller, ushort durationMicroSec = 500)
		{
			if (m_system != null)
			{
				m_system.TriggerHapticPulse(controller, 0u, durationMicroSec);
			}
		}
	}
}
namespace Assets.Scripts.WandsInput
{
	public abstract class InputPauseListener
	{
		protected EventToken m_matchPausedEventToken;

		protected void AddBindings<T>(Dictionary<T, Action<InputState>> buttonBindings, Func<T, InputState> getButtonInputState, List<T> pressedOnPaused)
		{
			foreach (KeyValuePair<T, Action<InputState>> buttonBinding in buttonBindings)
			{
				InputState inputState = getButtonInputState(buttonBinding.Key);
				if ((inputState & (InputState.Down | InputState.Hold)) != 0)
				{
					pressedOnPaused.Add(buttonBinding.Key);
				}
			}
		}

		protected void TryTriggerBinding<T>(Dictionary<T, Action<InputState>> buttonBindings, Func<T, InputState> getButtonInputState, List<T> pressedOnPaused)
		{
			foreach (T item in pressedOnPaused)
			{
				InputState inputState = getButtonInputState(item);
				if ((inputState & (InputState.Down | InputState.Hold)) == 0)
				{
					buttonBindings[item]?.Invoke(InputState.Up);
				}
			}
			pressedOnPaused.Clear();
		}
	}
	public class InputPauseListener<T> : InputPauseListener
	{
		private readonly IPauseListenerInput<T> m_inputHandler;

		private readonly List<T> m_pressedOnPaused = new List<T>(4);

		public InputPauseListener(IPauseListenerInput<T> inputHandler)
		{
			m_matchPausedEventToken = EventHub.Subscribe<Events.MatchPausedEvent>(OnMatchPaused);
			m_inputHandler = inputHandler;
		}

		~InputPauseListener()
		{
			EventHub.Unsubscribe<Events.MatchPausedEvent>(m_matchPausedEventToken);
		}

		private void OnMatchPaused(Events.MatchPausedEvent eventData)
		{
			if (eventData.IsPaused)
			{
				AddBindings(m_inputHandler.ButtonBindings, m_inputHandler.GetButtonInputState, m_pressedOnPaused);
			}
			else
			{
				TryTriggerBinding(m_inputHandler.ButtonBindings, m_inputHandler.GetButtonInputState, m_pressedOnPaused);
			}
		}
	}
	public class InputPauseListener<T1, T2> : InputPauseListener
	{
		private readonly IPauseListenerInput<T1, T2> m_inputHandler;

		private readonly List<T1> m_pressedOnPaused = new List<T1>(4);

		private readonly List<T2> m_secondaryPressedOnPaused = new List<T2>(4);

		public InputPauseListener(IPauseListenerInput<T1, T2> inputHandler)
		{
			m_matchPausedEventToken = EventHub.Subscribe<Events.MatchPausedEvent>(OnMatchPaused);
			m_inputHandler = inputHandler;
		}

		~InputPauseListener()
		{
			EventHub.Unsubscribe<Events.MatchPausedEvent>(m_matchPausedEventToken);
		}

		private void OnMatchPaused(Events.MatchPausedEvent eventData)
		{
			if (eventData.IsPaused)
			{
				AddBindings(m_inputHandler.ButtonBindings, m_inputHandler.GetButtonInputState, m_pressedOnPaused);
				AddBindings(m_inputHandler.SecondaryButtonBindings, m_inputHandler.GetSecondaryButtonInputState, m_secondaryPressedOnPaused);
			}
			else
			{
				TryTriggerBinding(m_inputHandler.ButtonBindings, m_inputHandler.GetButtonInputState, m_pressedOnPaused);
				TryTriggerBinding(m_inputHandler.SecondaryButtonBindings, m_inputHandler.GetSecondaryButtonInputState, m_secondaryPressedOnPaused);
			}
		}
	}
	public interface IPauseListenerInput<T>
	{
		Dictionary<T, Action<InputState>> ButtonBindings { get; }

		InputState GetButtonInputState(T button);
	}
	public interface IPauseListenerInput<T1, T2>
	{
		Dictionary<T1, Action<InputState>> ButtonBindings { get; }

		Dictionary<T2, Action<InputState>> SecondaryButtonBindings { get; }

		InputState GetButtonInputState(T1 button);

		InputState GetSecondaryButtonInputState(T2 button);
	}
	public interface IPlatformInput
	{
		bool IsCorrectInputSystem { get; }

		bool IsAutoTeleportEnabled { get; }

		AimInput Aim { get; }

		WandInput WandInput { get; }

		void Update();

		void BindActions(IInputListener listener);

		void UnbindActions(IInputListener listener);
	}
	public interface IPlatformInputTwoWands : IPlatformInput
	{
		void BindSpellButtonActions(IInputListenerTwoWands listener);

		void UnbindSpellButtonActions(IInputListenerTwoWands listener);
	}
	public class MouseAndKeyboardInput : IPlatformInput, IPauseListenerInput<KeyCode>
	{
		private InputPauseListener<KeyCode> m_inputPauseListener;

		private Action<InputState> m_swipeAction;

		private InputState m_previousSwipeState;

		private readonly Dictionary<Action<InputState>, InputState> m_actions = new Dictionary<Action<InputState>, InputState>(3);

		private Vector3 m_playerPosition;

		private Quaternion m_cameraRotation;

		private const KeyCode PrimaryButton = KeyCode.Mouse0;

		private const KeyCode SecondaryButton = KeyCode.Mouse1;

		private const KeyCode ReverseButton = KeyCode.Mouse2;

		private const KeyCode MenuButton = KeyCode.Escape;

		public Dictionary<KeyCode, Action<InputState>> ButtonBindings { get; } = new Dictionary<KeyCode, Action<InputState>>(3);


		public bool IsCorrectInputSystem
		{
			get
			{
				if (GameControl.Instance.Platform.Type.ContainsFlag(PlatformTarget.Oculus))
				{
					if (OVRInput.IsControllerConnected(OVRInput.Controller.Gamepad) || OVRInput.IsControllerConnected(OVRInput.Controller.RTouch) || OVRInput.IsControllerConnected(OVRInput.Controller.LTouch))
					{
						return false;
					}
				}
				else if (GameControl.Instance.Platform.Type.ContainsFlag(PlatformTarget.OpenVr))
				{
					return false;
				}
				return true;
			}
		}

		public bool IsAutoTeleportEnabled
		{
			[CompilerGenerated]
			get
			{
				return false;
			}
		}

		public AimInput Aim
		{
			[CompilerGenerated]
			get
			{
				return AimInput.Head;
			}
		}

		public WandInput WandInput
		{
			[CompilerGenerated]
			get
			{
				return WandInput.Press;
			}
		}

		public MouseAndKeyboardInput()
		{
			m_inputPauseListener = new InputPauseListener<KeyCode>(this);
		}

		public void BindActions(IInputListener listener)
		{
			BindButton(KeyCode.Mouse0, listener.OnPrimaryInput);
			BindButton(KeyCode.Mouse1, listener.OnTeleportInput);
			BindButton(KeyCode.Escape, listener.OnMenuInput);
			BindButton(KeyCode.Mouse2, listener.OnReverseInput);
			m_swipeAction = listener.OnPrimaryAxisInput;
		}

		public void UnbindActions(IInputListener listener)
		{
			if (listener != null)
			{
				UnbindButton(KeyCode.Mouse0, listener.OnPrimaryInput);
				UnbindButton(KeyCode.Mouse1, listener.OnTeleportInput);
				UnbindButton(KeyCode.Escape, listener.OnMenuInput);
				UnbindButton(KeyCode.Mouse2, listener.OnReverseInput);
				m_swipeAction = null;
			}
		}

		private void BindButton(KeyCode button, Action<InputState> action)
		{
			if (ButtonBindings.ContainsKey(button))
			{
				Dictionary<KeyCode, Action<InputState>> buttonBindings;
				KeyCode key;
				(buttonBindings = ButtonBindings)[key = button] = (Action<InputState>)Delegate.Combine(buttonBindings[key], action);
			}
			else
			{
				ButtonBindings.Add(button, action);
			}
		}

		private void UnbindButton(KeyCode button, Action<InputState> action)
		{
			if (ButtonBindings.ContainsKey(button))
			{
				Dictionary<KeyCode, Action<InputState>> buttonBindings;
				KeyCode key;
				(buttonBindings = ButtonBindings)[key = button] = (Action<InputState>)Delegate.Remove(buttonBindings[key], action);
			}
		}

		public void Update()
		{
			CheckButtonBindings();
			if (m_swipeAction != null)
			{
				UpdateTouchState();
			}
		}

		[Conditional("UNITY_EDITOR")]
		private void CheckPlayerMovement()
		{
		}

		private void CheckButtonBindings()
		{
			m_actions.Clear();
			foreach (KeyValuePair<KeyCode, Action<InputState>> buttonBinding in ButtonBindings)
			{
				InputState buttonInputState = GetButtonInputState(buttonBinding.Key);
				if (buttonInputState != 0 && buttonBinding.Value != null && !m_actions.ContainsKey(buttonBinding.Value))
				{
					m_actions.Add(buttonBinding.Value, buttonInputState);
				}
			}
			foreach (KeyValuePair<Action<InputState>, InputState> action in m_actions)
			{
				action.Key(action.Value);
			}
		}

		public InputState GetButtonInputState(KeyCode keyCode)
		{
			if (Input.GetKeyDown(keyCode))
			{
				return InputState.Down;
			}
			if (Input.GetKeyUp(keyCode))
			{
				return InputState.Up;
			}
			if (Input.GetKey(keyCode))
			{
				return InputState.Hold;
			}
			return InputState.None;
		}

		private void UpdateTouchState()
		{
			InputState touchState = GetTouchState();
			if (touchState != 0)
			{
				m_swipeAction(touchState);
			}
		}

		private InputState GetTouchState()
		{
			if (Input.GetKey(KeyCode.LeftArrow))
			{
				return GetStateInsideSlice(new Vector2(-1f, 0f));
			}
			if (Input.GetKeyUp(KeyCode.LeftArrow))
			{
				return InputState.Up;
			}
			if (Input.GetKey(KeyCode.RightArrow))
			{
				return GetStateInsideSlice(new Vector2(1f, 0f));
			}
			if (Input.GetKeyUp(KeyCode.RightArrow))
			{
				return InputState.Up;
			}
			if (Input.GetKey(KeyCode.UpArrow))
			{
				return GetStateInsideSlice(new Vector2(0f, 1f));
			}
			if (Input.GetKeyUp(KeyCode.UpArrow))
			{
				return InputState.Up;
			}
			if (Input.GetKey(KeyCode.DownArrow))
			{
				return GetStateInsideSlice(new Vector2(0f, -1f));
			}
			if (Input.GetKeyUp(KeyCode.DownArrow))
			{
				return InputState.Up;
			}
			return InputState.None;
		}

		private InputState GetStateInsideSlice(Vector2 currentPoint)
		{
			float x = currentPoint.x;
			float y = currentPoint.y;
			if (Mathf.Abs(y) > Mathf.Abs(x))
			{
				if (y > 0.25f)
				{
					InputState inputState = InputState.AxisUp;
					if (!m_previousSwipeState.ContainsFlag(inputState))
					{
						inputState |= InputState.Down;
					}
					return m_previousSwipeState = inputState;
				}
				if (y < -0.25f)
				{
					InputState inputState2 = InputState.AxisDown;
					if (!m_previousSwipeState.ContainsFlag(inputState2))
					{
						inputState2 |= InputState.Down;
					}
					return m_previousSwipeState = inputState2;
				}
			}
			else
			{
				if (x > 0.25f)
				{
					InputState inputState3 = InputState.AxisRight;
					if (!m_previousSwipeState.ContainsFlag(inputState3))
					{
						inputState3 |= InputState.Down;
					}
					return m_previousSwipeState = inputState3;
				}
				if (x < -0.25f)
				{
					InputState inputState4 = InputState.AxisLeft;
					if (!m_previousSwipeState.ContainsFlag(inputState4))
					{
						inputState4 |= InputState.Down;
					}
					return m_previousSwipeState = inputState4;
				}
			}
			return m_previousSwipeState;
		}
	}
	public class MouseInput : IPlatformInput, IPauseListenerInput<KeyCode>
	{
		private InputPauseListener<KeyCode> m_inputPauseListener;

		private readonly Dictionary<Action<InputState>, InputState> m_actions = new Dictionary<Action<InputState>, InputState>(3);

		private Vector3 m_playerPosition;

		private const KeyCode PrimaryButton = KeyCode.Mouse0;

		private const KeyCode SecondaryButton = KeyCode.Mouse1;

		private const KeyCode ReverseButton = KeyCode.Mouse2;

		private const KeyCode MenuButton = KeyCode.Escape;

		public Dictionary<KeyCode, Action<InputState>> ButtonBindings { get; } = new Dictionary<KeyCode, Action<InputState>>(3);


		public bool IsCorrectInputSystem
		{
			get
			{
				if (GameControl.Instance.Platform.Type.ContainsFlag(PlatformTarget.Oculus))
				{
					if (OVRInput.IsControllerConnected(OVRInput.Controller.Gamepad) || OVRInput.IsControllerConnected(OVRInput.Controller.RTouch) || OVRInput.IsControllerConnected(OVRInput.Controller.LTouch))
					{
						return false;
					}
				}
				else if (GameControl.Instance.Platform.Type.ContainsFlag(PlatformTarget.OpenVr))
				{
					return false;
				}
				return true;
			}
		}

		public bool IsAutoTeleportEnabled
		{
			[CompilerGenerated]
			get
			{
				return false;
			}
		}

		public AimInput Aim
		{
			[CompilerGenerated]
			get
			{
				return AimInput.Head;
			}
		}

		public WandInput WandInput
		{
			[CompilerGenerated]
			get
			{
				return WandInput.Point;
			}
		}

		public MouseInput()
		{
			m_inputPauseListener = new InputPauseListener<KeyCode>(this);
		}

		public void BindActions(IInputListener listener)
		{
			BindButton(KeyCode.Mouse0, listener.OnPrimaryInput);
			BindButton(KeyCode.Mouse1, listener.OnSecondaryInput);
			BindButton(KeyCode.Escape, listener.OnMenuInput);
			BindButton(KeyCode.Mouse2, listener.OnReverseInput);
		}

		public void UnbindActions(IInputListener listener)
		{
			if (listener != null)
			{
				UnbindButton(KeyCode.Mouse0, listener.OnPrimaryInput);
				UnbindButton(KeyCode.Mouse1, listener.OnSecondaryInput);
				UnbindButton(KeyCode.Escape, listener.OnMenuInput);
				UnbindButton(KeyCode.Mouse2, listener.OnReverseInput);
			}
		}

		private void BindButton(KeyCode button, Action<InputState> action)
		{
			if (ButtonBindings.ContainsKey(button))
			{
				Dictionary<KeyCode, Action<InputState>> buttonBindings;
				KeyCode key;
				(buttonBindings = ButtonBindings)[key = button] = (Action<InputState>)Delegate.Combine(buttonBindings[key], action);
			}
			else
			{
				ButtonBindings.Add(button, action);
			}
		}

		private void UnbindButton(KeyCode button, Action<InputState> action)
		{
			if (ButtonBindings.ContainsKey(button))
			{
				Dictionary<KeyCode, Action<InputState>> buttonBindings;
				KeyCode key;
				(buttonBindings = ButtonBindings)[key = button] = (Action<InputState>)Delegate.Remove(buttonBindings[key], action);
			}
		}

		public void Update()
		{
			CheckButtonBindings();
		}

		[Conditional("UNITY_EDITOR")]
		private void CheckPlayerMovement()
		{
		}

		private void CheckButtonBindings()
		{
			m_actions.Clear();
			foreach (KeyValuePair<KeyCode, Action<InputState>> buttonBinding in ButtonBindings)
			{
				InputState buttonInputState = GetButtonInputState(buttonBinding.Key);
				if (buttonInputState != 0 && buttonBinding.Value != null && !m_actions.ContainsKey(buttonBinding.Value))
				{
					m_actions.Add(buttonBinding.Value, buttonInputState);
				}
			}
			foreach (KeyValuePair<Action<InputState>, InputState> action in m_actions)
			{
				action.Key(action.Value);
			}
		}

		public InputState GetButtonInputState(KeyCode keyCode)
		{
			if (Input.GetKeyDown(keyCode))
			{
				return InputState.Down;
			}
			if (Input.GetKeyUp(keyCode))
			{
				return InputState.Up;
			}
			if (Input.GetKey(keyCode))
			{
				return InputState.Hold;
			}
			return InputState.None;
		}
	}
	public class ButtonAxisCombination
	{
		public readonly OVRInput.RawButton Button;

		public readonly OVRInput.RawAxis1D Axis;

		public InputState PreviousAxisInputState { get; set; }

		public ButtonAxisCombination(OVRInput.RawButton button, OVRInput.RawAxis1D axis)
		{
			Button = button;
			Axis = axis;
			PreviousAxisInputState = InputState.None;
		}
	}
	public class OculusGamepadInput : IPlatformInput, IPauseListenerInput<OVRInput.RawButton, ButtonAxisCombination>
	{
		private InputPauseListener<OVRInput.RawButton, ButtonAxisCombination> m_inputPauseListener;

		private readonly InputState[] m_previousAxis2DState = new InputState[2];

		private readonly ButtonAxisCombination m_primary = new ButtonAxisCombination(OVRInput.RawButton.RShoulder, OVRInput.RawAxis1D.RIndexTrigger);

		private readonly ButtonAxisCombination m_teleport = new ButtonAxisCombination(OVRInput.RawButton.LShoulder, OVRInput.RawAxis1D.LIndexTrigger);

		private readonly Dictionary<OVRInput.RawAxis2D, Action<InputState>> m_axis2DBindings = new Dictionary<OVRInput.RawAxis2D, Action<InputState>>(15);

		private readonly Dictionary<Action<InputState>, InputState> m_actions = new Dictionary<Action<InputState>, InputState>(15);

		private const OVRInput.RawButton Menu = OVRInput.RawButton.Start;

		private const OVRInput.RawButton Recenter = OVRInput.RawButton.A;

		private const OVRInput.RawAxis2D PrimaryThumbstick = OVRInput.RawAxis2D.LThumbstick;

		private const OVRInput.RawAxis2D SecondaryThumbstick = OVRInput.RawAxis2D.RThumbstick;

		public Dictionary<OVRInput.RawButton, Action<InputState>> ButtonBindings { get; } = new Dictionary<OVRInput.RawButton, Action<InputState>>(15);


		public Dictionary<ButtonAxisCombination, Action<InputState>> SecondaryButtonBindings { get; } = new Dictionary<ButtonAxisCombination, Action<InputState>>(15);


		public bool IsCorrectInputSystem
		{
			[CompilerGenerated]
			get
			{
				return OVRInput.IsControllerConnected(OVRInput.Controller.Gamepad);
			}
		}

		public bool IsAutoTeleportEnabled
		{
			[CompilerGenerated]
			get
			{
				return false;
			}
		}

		public AimInput Aim
		{
			[CompilerGenerated]
			get
			{
				return AimInput.Head;
			}
		}

		public WandInput WandInput
		{
			[CompilerGenerated]
			get
			{
				return WandInput.Stick;
			}
		}

		public OculusGamepadInput()
		{
			m_inputPauseListener = new InputPauseListener<OVRInput.RawButton, ButtonAxisCombination>(this);
		}

		public void BindActions(IInputListener listener)
		{
			BindButton(OVRInput.RawButton.Start, listener.OnMenuInput);
			BindButton(OVRInput.RawButton.A, listener.OnRecenterInput);
			BindButtonAxis(m_primary, listener.OnPrimaryInput);
			BindButtonAxis(m_teleport, listener.OnTeleportInput);
			BindAxis(OVRInput.RawAxis2D.LThumbstick, listener.OnPrimaryAxisInput);
			BindAxis(OVRInput.RawAxis2D.RThumbstick, listener.OnSecondaryAxisInput);
			if (listener is MainMenuInputListener)
			{
				BindButton(OVRInput.RawButton.A, listener.OnPrimaryInput);
				BindButton(OVRInput.RawButton.B, listener.OnPrimaryInput);
				BindButton(OVRInput.RawButton.X, listener.OnPrimaryInput);
				BindButton(OVRInput.RawButton.Y, listener.OnPrimaryInput);
				BindButton(OVRInput.RawButton.Start, listener.OnPrimaryInput);
				BindButton(OVRInput.RawButton.RShoulder, listener.OnPrimaryInput);
				BindButton(OVRInput.RawButton.LShoulder, listener.OnPrimaryInput);
				BindButton(OVRInput.RawButton.RIndexTrigger, listener.OnPrimaryInput);
				BindButton(OVRInput.RawButton.LIndexTrigger, listener.OnPrimaryInput);
			}
		}

		public void UnbindActions(IInputListener listener)
		{
			UnbindButton(OVRInput.RawButton.Start, listener.OnMenuInput);
			UnbindButton(OVRInput.RawButton.A, listener.OnRecenterInput);
			UnbindButtonAxis(m_primary, listener.OnPrimaryInput);
			UnbindButtonAxis(m_teleport, listener.OnTeleportInput);
			UnbindAxis(OVRInput.RawAxis2D.LThumbstick, listener.OnPrimaryAxisInput);
			UnbindAxis(OVRInput.RawAxis2D.RThumbstick, listener.OnSecondaryAxisInput);
			if (listener is MainMenuInputListener)
			{
				UnbindButton(OVRInput.RawButton.A, listener.OnPrimaryInput);
				UnbindButton(OVRInput.RawButton.B, listener.OnPrimaryInput);
				UnbindButton(OVRInput.RawButton.X, listener.OnPrimaryInput);
				UnbindButton(OVRInput.RawButton.Y, listener.OnPrimaryInput);
				UnbindButton(OVRInput.RawButton.Start, listener.OnPrimaryInput);
				UnbindButton(OVRInput.RawButton.RShoulder, listener.OnPrimaryInput);
				UnbindButton(OVRInput.RawButton.LShoulder, listener.OnPrimaryInput);
				UnbindButton(OVRInput.RawButton.RIndexTrigger, listener.OnPrimaryInput);
				UnbindButton(OVRInput.RawButton.LIndexTrigger, listener.OnPrimaryInput);
			}
		}

		private void BindButton(OVRInput.RawButton button, Action<InputState> action)
		{
			if (ButtonBindings.ContainsKey(button))
			{
				Dictionary<OVRInput.RawButton, Action<InputState>> buttonBindings;
				OVRInput.RawButton key;
				(buttonBindings = ButtonBindings)[key = button] = (Action<InputState>)Delegate.Combine(buttonBindings[key], action);
			}
			else
			{
				ButtonBindings.Add(button, action);
			}
		}

		private void UnbindButton(OVRInput.RawButton button, Action<InputState> action)
		{
			if (ButtonBindings.ContainsKey(button))
			{
				Dictionary<OVRInput.RawButton, Action<InputState>> buttonBindings;
				OVRInput.RawButton key;
				(buttonBindings = ButtonBindings)[key = button] = (Action<InputState>)Delegate.Remove(buttonBindings[key], action);
			}
		}

		private void BindButtonAxis(ButtonAxisCombination buttonAxis, Action<InputState> action)
		{
			if (SecondaryButtonBindings.ContainsKey(buttonAxis))
			{
				Dictionary<ButtonAxisCombination, Action<InputState>> secondaryButtonBindings;
				ButtonAxisCombination key;
				(secondaryButtonBindings = SecondaryButtonBindings)[key = buttonAxis] = (Action<InputState>)Delegate.Combine(secondaryButtonBindings[key], action);
			}
			else
			{
				SecondaryButtonBindings.Add(buttonAxis, action);
			}
		}

		private void UnbindButtonAxis(ButtonAxisCombination buttonAxis, Action<InputState> action)
		{
			if (SecondaryButtonBindings.ContainsKey(buttonAxis))
			{
				Dictionary<ButtonAxisCombination, Action<InputState>> secondaryButtonBindings;
				ButtonAxisCombination key;
				(secondaryButtonBindings = SecondaryButtonBindings)[key = buttonAxis] = (Action<InputState>)Delegate.Remove(secondaryButtonBindings[key], action);
			}
		}

		private void BindAxis(OVRInput.RawAxis2D axis, Action<InputState> action)
		{
			if (m_axis2DBindings.ContainsKey(axis))
			{
				Dictionary<OVRInput.RawAxis2D, Action<InputState>> axis2DBindings;
				OVRInput.RawAxis2D key;
				(axis2DBindings = m_axis2DBindings)[key = axis] = (Action<InputState>)Delegate.Combine(axis2DBindings[key], action);
			}
			else
			{
				m_axis2DBindings.Add(axis, action);
			}
		}

		private void UnbindAxis(OVRInput.RawAxis2D axis, Action<InputState> action)
		{
			if (m_axis2DBindings.ContainsKey(axis))
			{
				Dictionary<OVRInput.RawAxis2D, Action<InputState>> axis2DBindings;
				OVRInput.RawAxis2D key;
				(axis2DBindings = m_axis2DBindings)[key = axis] = (Action<InputState>)Delegate.Remove(axis2DBindings[key], action);
			}
		}

		public void Update()
		{
			CheckButtonBindings();
			CheckAxisBindings();
			CheckButtonAxisBindings();
		}

		private void CheckButtonBindings()
		{
			m_actions.Clear();
			foreach (KeyValuePair<OVRInput.RawButton, Action<InputState>> buttonBinding in ButtonBindings)
			{
				InputState buttonInputState = GetButtonInputState(buttonBinding.Key);
				if (buttonInputState != 0 && buttonBinding.Value != null && !m_actions.ContainsKey(buttonBinding.Value))
				{
					m_actions.Add(buttonBinding.Value, buttonInputState);
				}
			}
			foreach (KeyValuePair<Action<InputState>, InputState> action in m_actions)
			{
				action.Key(action.Value);
			}
		}

		private void CheckButtonAxisBindings()
		{
			m_actions.Clear();
			foreach (KeyValuePair<ButtonAxisCombination, Action<InputState>> secondaryButtonBinding in SecondaryButtonBindings)
			{
				ButtonAxisCombination key = secondaryButtonBinding.Key;
				InputState buttonInputState = GetButtonInputState(key.Button);
				InputState state = (key.PreviousAxisInputState = GetAxis1DInputState(key.Axis, key.PreviousAxisInputState));
				InputState prioritizedInputState = GetPrioritizedInputState(buttonInputState, state);
				if (prioritizedInputState != 0 && secondaryButtonBinding.Value != null && !m_actions.ContainsKey(secondaryButtonBinding.Value))
				{
					m_actions.Add(secondaryButtonBinding.Value, prioritizedInputState);
				}
			}
			foreach (KeyValuePair<Action<InputState>, InputState> action in m_actions)
			{
				action.Key(action.Value);
			}
		}

		private void CheckAxisBindings()
		{
			m_actions.Clear();
			for (int i = 0; i < m_axis2DBindings.Count; i++)
			{
				KeyValuePair<OVRInput.RawAxis2D, Action<InputState>> keyValuePair = m_axis2DBindings.ElementAt(i);
				InputState axis2DInputState = GetAxis2DInputState(keyValuePair.Key, m_previousAxis2DState[i]);
				m_previousAxis2DState[i] = axis2DInputState;
				if (axis2DInputState != 0 && keyValuePair.Value != null && !m_actions.ContainsKey(keyValuePair.Value))
				{
					m_actions.Add(keyValuePair.Value, axis2DInputState);
				}
			}
			foreach (KeyValuePair<Action<InputState>, InputState> action in m_actions)
			{
				action.Key(action.Value);
			}
		}

		public InputState GetButtonInputState(OVRInput.RawButton button)
		{
			if (OVRInput.GetDown(button, OVRInput.Controller.Gamepad))
			{
				return InputState.Down;
			}
			if (OVRInput.GetUp(button, OVRInput.Controller.Gamepad))
			{
				return InputState.Up;
			}
			if (OVRInput.Get(button, OVRInput.Controller.Gamepad))
			{
				return InputState.Hold;
			}
			return InputState.None;
		}

		public InputState GetAxis1DInputState(OVRInput.RawAxis1D axis, InputState prevState)
		{
			float num = OVRInput.Get(axis, OVRInput.Controller.Gamepad);
			if (num > 0.2f)
			{
				if (prevState == InputState.None || prevState == InputState.Up)
				{
					return InputState.Down;
				}
				return InputState.Hold;
			}
			if (prevState != 0 && prevState != InputState.Up)
			{
				return InputState.Up;
			}
			return InputState.None;
		}

		public InputState GetAxis2DInputState(OVRInput.RawAxis2D axis, InputState prevState)
		{
			Vector2 vector = OVRInput.Get(axis, OVRInput.Controller.Gamepad);
			if (vector.x > 0.5f)
			{
				InputState inputState = InputState.AxisRight;
				if (!prevState.ContainsFlag(inputState))
				{
					inputState |= InputState.Down;
				}
				return inputState;
			}
			if (vector.x < -0.5f)
			{
				InputState inputState2 = InputState.AxisLeft;
				if (!prevState.ContainsFlag(inputState2))
				{
					inputState2 |= InputState.Down;
				}
				return inputState2;
			}
			if (vector.y > 0.5f)
			{
				InputState inputState3 = InputState.AxisUp;
				if (!prevState.ContainsFlag(inputState3))
				{
					inputState3 |= InputState.Down;
				}
				return inputState3;
			}
			if (vector.y < -0.5f)
			{
				InputState inputState4 = InputState.AxisDown;
				if (!prevState.ContainsFlag(inputState4))
				{
					inputState4 |= InputState.Down;
				}
				return inputState4;
			}
			if (prevState != 0 && prevState != InputState.Up)
			{
				return InputState.Up;
			}
			return InputState.None;
		}

		public InputState GetSecondaryButtonInputState(ButtonAxisCombination buttonAxisCombination)
		{
			InputState buttonInputState = GetButtonInputState(buttonAxisCombination.Button);
			InputState axis1DInputState = GetAxis1DInputState(buttonAxisCombination.Axis, buttonAxisCombination.PreviousAxisInputState);
			return GetPrioritizedInputState(buttonInputState, axis1DInputState);
		}

		private InputState GetPrioritizedInputState(InputState state1, InputState state2)
		{
			InputState flag = state1 | state2;
			if (InputState.Hold.ContainsFlag(flag))
			{
				return InputState.Hold;
			}
			if (InputState.Axis.ContainsFlag(state1))
			{
				return state1;
			}
			if (InputState.Axis.ContainsFlag(state2))
			{
				return state2;
			}
			if (InputState.Up.ContainsFlag(flag))
			{
				return InputState.Up;
			}
			if (InputState.Down.ContainsFlag(flag))
			{
				return InputState.Down;
			}
			return InputState.None;
		}
	}
	public class OculusRemoteInput : IPlatformInput, IPauseListenerInput<KeyValuePair<OVRInput.Button, OVRInput.Controller>>
	{
		public const OVRInput.Controller RemoteController = OVRInput.Controller.LTrackedRemote | OVRInput.Controller.RTrackedRemote;

		protected readonly KeyValuePair<OVRInput.Button, OVRInput.Controller> m_secondaryInput = new KeyValuePair<OVRInput.Button, OVRInput.Controller>(OVRInput.Button.PrimaryTouchpad, OVRInput.Controller.LTrackedRemote | OVRInput.Controller.RTrackedRemote);

		protected readonly KeyValuePair<OVRInput.Button, OVRInput.Controller> m_menuInput = new KeyValuePair<OVRInput.Button, OVRInput.Controller>(OVRInput.Button.Back, OVRInput.Controller.LTrackedRemote | OVRInput.Controller.RTrackedRemote);

		protected readonly KeyValuePair<OVRInput.Button, OVRInput.Controller> m_primaryInput = new KeyValuePair<OVRInput.Button, OVRInput.Controller>(OVRInput.Button.PrimaryIndexTrigger, OVRInput.Controller.LTrackedRemote | OVRInput.Controller.RTrackedRemote);

		protected readonly Dictionary<Action<InputState>, InputState> m_actions = new Dictionary<Action<InputState>, InputState>(6);

		private InputPauseListener<KeyValuePair<OVRInput.Button, OVRInput.Controller>> m_inputPauseListener;

		public bool IsCorrectInputSystem
		{
			[CompilerGenerated]
			get
			{
				return !OVRPlugin.hasInputFocus || OVRInput.IsControllerConnected(OVRInput.Controller.RTrackedRemote) || OVRInput.IsControllerConnected(OVRInput.Controller.LTrackedRemote);
			}
		}

		public Dictionary<KeyValuePair<OVRInput.Button, OVRInput.Controller>, Action<InputState>> ButtonBindings { get; } = new Dictionary<KeyValuePair<OVRInput.Button, OVRInput.Controller>, Action<InputState>>(6);


		public bool IsAutoTeleportEnabled
		{
			[CompilerGenerated]
			get
			{
				return false;
			}
		}

		public AimInput Aim
		{
			[CompilerGenerated]
			get
			{
				return AimInput.Remote;
			}
		}

		public virtual WandInput WandInput
		{
			[CompilerGenerated]
			get
			{
				return WandInput.Point;
			}
		}

		public OculusRemoteInput()
		{
			m_inputPauseListener = new InputPauseListener<KeyValuePair<OVRInput.Button, OVRInput.Controller>>(this);
		}

		public virtual void BindActions(IInputListener listener)
		{
		}

		public virtual void UnbindActions(IInputListener listener)
		{
		}

		protected void BindButton(KeyValuePair<OVRInput.Button, OVRInput.Controller> button, Action<InputState> action)
		{
			if (ButtonBindings.ContainsKey(button))
			{
				Dictionary<KeyValuePair<OVRInput.Button, OVRInput.Controller>, Action<InputState>> buttonBindings;
				KeyValuePair<OVRInput.Button, OVRInput.Controller> key;
				(buttonBindings = ButtonBindings)[key = button] = (Action<InputState>)Delegate.Combine(buttonBindings[key], action);
			}
			else
			{
				ButtonBindings.Add(button, action);
			}
		}

		protected void UnbindButton(KeyValuePair<OVRInput.Button, OVRInput.Controller> button, Action<InputState> action)
		{
			if (ButtonBindings.ContainsKey(button))
			{
				Dictionary<KeyValuePair<OVRInput.Button, OVRInput.Controller>, Action<InputState>> buttonBindings;
				KeyValuePair<OVRInput.Button, OVRInput.Controller> key;
				(buttonBindings = ButtonBindings)[key = button] = (Action<InputState>)Delegate.Remove(buttonBindings[key], action);
			}
		}

		public virtual void Update()
		{
			CheckButtonBindings();
		}

		private void CheckButtonBindings()
		{
			m_actions.Clear();
			foreach (KeyValuePair<KeyValuePair<OVRInput.Button, OVRInput.Controller>, Action<InputState>> buttonBinding in ButtonBindings)
			{
				InputState buttonInputState = GetButtonInputState(buttonBinding.Key);
				if (buttonInputState != 0 && buttonBinding.Value != null && !m_actions.ContainsKey(buttonBinding.Value))
				{
					m_actions.Add(buttonBinding.Value, buttonInputState);
				}
			}
			CheckActions(m_actions);
		}

		protected virtual void CheckActions(Dictionary<Action<InputState>, InputState> actions)
		{
			foreach (KeyValuePair<Action<InputState>, InputState> action in actions)
			{
				action.Key(action.Value);
			}
		}

		public InputState GetButtonInputState(KeyValuePair<OVRInput.Button, OVRInput.Controller> button)
		{
			if (OVRInput.GetDown(button.Key, button.Value))
			{
				return InputState.Down;
			}
			if (OVRInput.GetUp(button.Key, button.Value))
			{
				return InputState.Up;
			}
			if (OVRInput.Get(button.Key, button.Value))
			{
				return InputState.Hold;
			}
			return InputState.None;
		}
	}
	public class OculusRemoteInputDirectional : OculusRemoteInput
	{
		private const OVRInput.Touch Touch = OVRInput.Touch.PrimaryTouchpad;

		private const OVRInput.Axis2D TouchAxis = OVRInput.Axis2D.PrimaryTouchpad;

		private Action<InputState> m_swipeAction;

		private InputState m_previousSwipeState;

		public override WandInput WandInput => WandInput.Press;

		public override void BindActions(IInputListener listener)
		{
			BindButton(m_menuInput, listener.OnMenuInput);
			if (GameControl.Instance.IsCurrentLevel(Level.Workshop))
			{
				BindButton(m_primaryInput, listener.OnPrimaryInput);
				return;
			}
			BindButton(m_primaryInput, listener.OnInteractionInput);
			BindButton(m_primaryInput, listener.OnTeleportInput);
			BindButton(m_secondaryInput, listener.OnPrimaryInput);
			m_swipeAction = listener.OnPrimaryAxisInput;
		}

		public override void UnbindActions(IInputListener listener)
		{
			UnbindButton(m_menuInput, listener.OnMenuInput);
			if (GameControl.Instance.IsCurrentLevel(Level.Workshop))
			{
				UnbindButton(m_primaryInput, listener.OnPrimaryInput);
				return;
			}
			UnbindButton(m_primaryInput, listener.OnInteractionInput);
			UnbindButton(m_primaryInput, listener.OnTeleportInput);
			UnbindButton(m_secondaryInput, listener.OnPrimaryInput);
			m_swipeAction = null;
		}

		public override void Update()
		{
			if (m_swipeAction != null)
			{
				UpdateTouchState();
			}
			base.Update();
		}

		private void UpdateTouchState()
		{
			InputState touchState = GetTouchState();
			if (touchState != 0)
			{
				m_swipeAction(touchState);
			}
		}

		private InputState GetTouchState()
		{
			if (OVRInput.GetDown(OVRInput.Touch.PrimaryTouchpad, OVRInput.Controller.LTrackedRemote | OVRInput.Controller.RTrackedRemote))
			{
				return GetStateInsideSlice(OVRInput.Get(OVRInput.Axis2D.PrimaryTouchpad, OVRInput.Controller.LTrackedRemote | OVRInput.Controller.RTrackedRemote));
			}
			if (OVRInput.Get(OVRInput.Touch.PrimaryTouchpad, OVRInput.Controller.LTrackedRemote | OVRInput.Controller.RTrackedRemote))
			{
				return GetStateInsideSlice(OVRInput.Get(OVRInput.Axis2D.PrimaryTouchpad, OVRInput.Controller.LTrackedRemote | OVRInput.Controller.RTrackedRemote));
			}
			if (OVRInput.GetUp(OVRInput.Touch.PrimaryTouchpad, OVRInput.Controller.LTrackedRemote | OVRInput.Controller.RTrackedRemote))
			{
				return InputState.Up;
			}
			return InputState.None;
		}

		private InputState GetStateInsideSlice(Vector2 currentPoint)
		{
			float x = currentPoint.x;
			float y = currentPoint.y;
			if (Mathf.Abs(y) > Mathf.Abs(x))
			{
				if (y > 0.1f)
				{
					InputState inputState = InputState.AxisUp;
					if (!m_previousSwipeState.ContainsFlag(inputState))
					{
						inputState |= InputState.Down;
					}
					return m_previousSwipeState = inputState;
				}
				if (y < -0.1f)
				{
					InputState inputState2 = InputState.AxisDown;
					if (!m_previousSwipeState.ContainsFlag(inputState2))
					{
						inputState2 |= InputState.Down;
					}
					return m_previousSwipeState = inputState2;
				}
			}
			else
			{
				if (x > 0.25f)
				{
					InputState inputState3 = InputState.AxisRight;
					if (!m_previousSwipeState.ContainsFlag(inputState3))
					{
						inputState3 |= InputState.Down;
					}
					return m_previousSwipeState = inputState3;
				}
				if (x < -0.25f)
				{
					InputState inputState4 = InputState.AxisLeft;
					if (!m_previousSwipeState.ContainsFlag(inputState4))
					{
						inputState4 |= InputState.Down;
					}
					return m_previousSwipeState = inputState4;
				}
			}
			return m_previousSwipeState;
		}
	}
	public class OculusRemoteInputPoint : OculusRemoteInput
	{
		public override void BindActions(IInputListener listener)
		{
			BindButton(m_menuInput, listener.OnMenuInput);
			BindButton(m_primaryInput, listener.OnPrimaryInput);
			BindButton(m_secondaryInput, listener.OnSecondaryInput);
		}

		public override void UnbindActions(IInputListener listener)
		{
			UnbindButton(m_menuInput, listener.OnMenuInput);
			UnbindButton(m_primaryInput, listener.OnPrimaryInput);
			UnbindButton(m_secondaryInput, listener.OnSecondaryInput);
		}
	}
	public class OculusRemoteInputSwipe : OculusRemoteInput
	{
		private const OVRInput.Touch Touch = OVRInput.Touch.PrimaryTouchpad;

		private const OVRInput.Axis2D TouchAxis = OVRInput.Axis2D.PrimaryTouchpad;

		private Action<InputState> m_swipeAction;

		private float m_tick;

		private bool m_firstSwipeInput;

		private Vector2 m_previousPoint;

		private Queue<Vector2> m_swipePoints = new Queue<Vector2>();

		private InputState m_previousSwipeState;

		public override WandInput WandInput => WandInput.Swipe;

		public override void BindActions(IInputListener listener)
		{
			BindButton(m_menuInput, listener.OnMenuInput);
			BindButton(m_primaryInput, listener.OnPrimaryInput);
			BindButton(m_secondaryInput, listener.OnTeleportInput);
			m_swipeAction = listener.OnPrimaryAxisInput;
		}

		public override void UnbindActions(IInputListener listener)
		{
			UnbindButton(m_menuInput, listener.OnMenuInput);
			UnbindButton(m_primaryInput, listener.OnPrimaryInput);
			UnbindButton(m_secondaryInput, listener.OnTeleportInput);
			m_swipeAction = null;
		}

		public override void Update()
		{
			base.Update();
			if (m_swipeAction != null)
			{
				CheckSwipeInput();
			}
		}

		protected override void CheckActions(Dictionary<Action<InputState>, InputState> actions)
		{
			foreach (KeyValuePair<Action<InputState>, InputState> action in actions)
			{
				action.Key(action.Value);
				if (action.Value == InputState.Down)
				{
					ResetSwipe();
				}
			}
		}

		private void CheckSwipeInput()
		{
			InputState touchState = GetTouchState();
			if (touchState != 0)
			{
				m_swipeAction(touchState);
			}
		}

		private void ResetSwipe()
		{
			m_swipePoints.Clear();
			m_firstSwipeInput = true;
			m_previousPoint = OVRInput.Get(OVRInput.Axis2D.PrimaryTouchpad, OVRInput.Controller.LTrackedRemote | OVRInput.Controller.RTrackedRemote);
			m_swipePoints.Enqueue(m_previousPoint);
		}

		private InputState GetStateInsideSlice(Vector2 currentPoint)
		{
			float x = currentPoint.x;
			float y = currentPoint.y;
			if (Mathf.Abs(y) > Mathf.Abs(x))
			{
				if (y > 0.25f)
				{
					InputState inputState = InputState.AxisUp;
					if (!m_previousSwipeState.ContainsFlag(inputState))
					{
						inputState |= InputState.Down;
					}
					return m_previousSwipeState = inputState;
				}
				if (y < -0.25f)
				{
					InputState inputState2 = InputState.AxisDown;
					if (!m_previousSwipeState.ContainsFlag(inputState2))
					{
						inputState2 |= InputState.Down;
					}
					return m_previousSwipeState = inputState2;
				}
			}
			else
			{
				if (x > 0.25f)
				{
					InputState inputState3 = InputState.AxisRight;
					if (!m_previousSwipeState.ContainsFlag(inputState3))
					{
						inputState3 |= InputState.Down;
					}
					return m_previousSwipeState = inputState3;
				}
				if (x < -0.25f)
				{
					InputState inputState4 = InputState.AxisLeft;
					if (!m_previousSwipeState.ContainsFlag(inputState4))
					{
						inputState4 |= InputState.Down;
					}
					return m_previousSwipeState = inputState4;
				}
			}
			return m_previousSwipeState;
		}

		private InputState GetSwipeState(Vector2 currentPoint, Vector2 swipeStartPoint)
		{
			Vector2 vector = currentPoint - swipeStartPoint;
			if (vector.sqrMagnitude >= 0.42249995f)
			{
				m_tick = 0f;
				m_firstSwipeInput = false;
				if (Mathf.Abs(vector.x) >= Mathf.Abs(vector.y))
				{
					if (vector.x > 0f)
					{
						m_previousSwipeState = InputState.AxisRight;
						return m_previousSwipeState | InputState.Down;
					}
					m_previousSwipeState = InputState.AxisLeft;
					return m_previousSwipeState | InputState.Down;
				}
				if (vector.y > 0f)
				{
					m_previousSwipeState = InputState.AxisUp;
					return m_previousSwipeState | InputState.Down;
				}
				m_previousSwipeState = InputState.AxisDown;
				return m_previousSwipeState | InputState.Down;
			}
			return InputState.None;
		}

		private InputState GetTouchState()
		{
			if (OVRInput.GetDown(OVRInput.Touch.PrimaryTouchpad, OVRInput.Controller.LTrackedRemote | OVRInput.Controller.RTrackedRemote))
			{
				ResetSwipe();
			}
			else
			{
				if (OVRInput.Get(OVRInput.Touch.PrimaryTouchpad, OVRInput.Controller.LTrackedRemote | OVRInput.Controller.RTrackedRemote))
				{
					Vector2 vector = OVRInput.Get(OVRInput.Axis2D.PrimaryTouchpad, OVRInput.Controller.LTrackedRemote | OVRInput.Controller.RTrackedRemote);
					if ((vector - m_previousPoint).sqrMagnitude >= 0.0001f)
					{
						m_swipePoints.Enqueue(vector);
						m_previousPoint = vector;
					}
					if (!m_firstSwipeInput)
					{
						if (m_tick >= 0.15f)
						{
							return GetStateInsideSlice(vector);
						}
						m_tick += Time.deltaTime;
						return m_previousSwipeState;
					}
					Vector2 swipeStartPoint = ((m_swipePoints.Count <= 30) ? m_swipePoints.Peek() : m_swipePoints.Dequeue());
					return GetSwipeState(vector, swipeStartPoint);
				}
				if (OVRInput.GetUp(OVRInput.Touch.PrimaryTouchpad, OVRInput.Controller.LTrackedRemote | OVRInput.Controller.RTrackedRemote))
				{
					return InputState.Up;
				}
			}
			return InputState.None;
		}
	}
	public class OculusRemoteInputSwipeMainMenu : OculusRemoteInput
	{
		public override WandInput WandInput
		{
			[CompilerGenerated]
			get
			{
				return WandInput.Swipe;
			}
		}

		public override void BindActions(IInputListener listener)
		{
			BindButton(m_primaryInput, listener.OnPrimaryInput);
			BindButton(m_secondaryInput, listener.OnPrimaryInput);
		}

		public override void UnbindActions(IInputListener listener)
		{
			UnbindButton(m_primaryInput, listener.OnPrimaryInput);
			UnbindButton(m_secondaryInput, listener.OnPrimaryInput);
		}
	}
}
namespace Cortopia.Scripts.WandsInput
{
	public class OculusRemoteTracker : MonoBehaviour
	{
		[SerializeField]
		private GameObject m_gearVrMesh;

		[SerializeField]
		private Renderer m_goMesh;

		[SerializeField]
		private Material m_goMaterial;

		[SerializeField]
		private Material m_miVrMaterial;

		[SerializeField]
		private bool m_skipControllerRenderers = true;

		private void Start()
		{
			if (m_skipControllerRenderers)
			{
				return;
			}
			if (m_gearVrMesh == null || m_goMesh == null)
			{
				WandsLogger.LogError("Either the GearVr or Go controller mesh isn't setup correctly in the OculusRemoteTracker!");
				return;
			}
			bool flag = GameControl.Instance.Platform.Type == PlatformType.GearVr;
			m_gearVrMesh.SetActive(flag);
			if (!flag)
			{
				m_goMesh.material = ((GameControl.Instance.Platform.Type != PlatformType.Go) ? m_miVrMaterial : m_goMaterial);
			}
			m_goMesh.transform.parent.gameObject.SetActive(!flag);
		}

		private void Update()
		{
			if (OVRInput.IsControllerConnected(OVRInput.Controller.RTrackedRemote))
			{
				UpdateTransform(OVRInput.Controller.RTrackedRemote);
			}
			else if (OVRInput.IsControllerConnected(OVRInput.Controller.LTrackedRemote))
			{
				UpdateTransform(OVRInput.Controller.LTrackedRemote);
			}
		}

		private void UpdateTransform(OVRInput.Controller controller)
		{
			base.transform.localRotation = OVRInput.GetLocalControllerRotation(controller);
			base.transform.localPosition = OVRInput.GetLocalControllerPosition(controller);
		}

		[Conditional("UNITY_EDITOR")]
		private void TrackOculusTouch()
		{
		}
	}
}
namespace Assets.Scripts.WandsInput
{
	public class QuestInput : OculusTouchInput
	{
		public QuestInput(OVRInput.Controller primaryController)
			: base(primaryController)
		{
		}
	}
	public class RiftInput : OculusTouchInput
	{
		public RiftInput(OVRInput.Controller primaryController)
			: base(primaryController)
		{
		}
	}
	public class OculusTouchInput : IPlatformInputTwoWands, IPauseListenerInput<OVRInput.RawButton>, IPlatformInput
	{
		private readonly InputPauseListener<OVRInput.RawButton> m_inputPauseListener;

		private readonly InputState[] m_prevAxis = new InputState[2];

		private readonly Dictionary<Action<InputState>, InputState> m_actionMap = new Dictionary<Action<InputState>, InputState>(8);

		private readonly Dictionary<OVRInput.RawAxis2D, Action<InputState>> m_axisBindings = new Dictionary<OVRInput.RawAxis2D, Action<InputState>>(2);

		private readonly OVRInput.Controller m_primaryController;

		private const OVRInput.RawButton PrimaryButtonLeft = OVRInput.RawButton.LIndexTrigger;

		private const OVRInput.RawButton PrimaryButtonRight = OVRInput.RawButton.RIndexTrigger;

		private const OVRInput.RawButton PointButtonLeft = OVRInput.RawButton.LHandTrigger;

		private const OVRInput.RawButton PointButtonRight = OVRInput.RawButton.RHandTrigger;

		private const OVRInput.RawButton MenuButton = OVRInput.RawButton.Start;

		private const OVRInput.RawButton RecenterButtonLeft = OVRInput.RawButton.X;

		private const OVRInput.RawButton RecenterButtonRight = OVRInput.RawButton.A;

		private const OVRInput.RawAxis2D LeftThumbstick = OVRInput.RawAxis2D.LThumbstick;

		private const OVRInput.RawAxis2D RightThumbstick = OVRInput.RawAxis2D.RThumbstick;

		private const OVRInput.RawButton SpellLeft01 = OVRInput.RawButton.X;

		private const OVRInput.RawButton SpellLeft02 = OVRInput.RawButton.Y;

		private const OVRInput.RawButton SpellRight01 = OVRInput.RawButton.A;

		private const OVRInput.RawButton SpellRight02 = OVRInput.RawButton.B;

		public bool IsCorrectInputSystem
		{
			[CompilerGenerated]
			get
			{
				return true;
			}
		}

		public bool IsAutoTeleportEnabled
		{
			[CompilerGenerated]
			get
			{
				return false;
			}
		}

		public AimInput Aim { get; private set; }

		public WandInput WandInput
		{
			[CompilerGenerated]
			get
			{
				return WandInput.Stick;
			}
		}

		public Dictionary<OVRInput.RawButton, Action<InputState>> ButtonBindings { get; } = new Dictionary<OVRInput.RawButton, Action<InputState>>(8);


		public OculusTouchInput(OVRInput.Controller primaryController)
		{
			m_primaryController = primaryController;
			Aim = ((primaryController != OVRInput.Controller.LTouch) ? AimInput.RightHand : AimInput.LeftHand);
			m_inputPauseListener = new InputPauseListener<OVRInput.RawButton>(this);
		}

		public void BindActions(IInputListener listener)
		{
			if (GameControl.Instance.IsCurrentLevel(Level.MainMenu))
			{
				if (m_primaryController == OVRInput.Controller.RTouch)
				{
					BindButton(OVRInput.RawButton.A, listener.OnPrimaryInput);
					BindButton(OVRInput.RawButton.B, listener.OnPrimaryInput);
					BindButton(OVRInput.RawButton.RHandTrigger, listener.OnPrimaryInput);
					BindButton(OVRInput.RawButton.RIndexTrigger, listener.OnPrimaryInput);
					BindAxis(OVRInput.RawAxis2D.LThumbstick, listener.OnSecondaryAxisInput);
					BindAxis(OVRInput.RawAxis2D.RThumbstick, listener.OnPrimaryAxisInput);
				}
				else
				{
					BindButton(OVRInput.RawButton.X, listener.OnPrimaryInput);
					BindButton(OVRInput.RawButton.Y, listener.OnPrimaryInput);
					BindButton(OVRInput.RawButton.LHandTrigger, listener.OnPrimaryInput);
					BindButton(OVRInput.RawButton.LIndexTrigger, listener.OnPrimaryInput);
					BindAxis(OVRInput.RawAxis2D.LThumbstick, listener.OnPrimaryAxisInput);
					BindAxis(OVRInput.RawAxis2D.RThumbstick, listener.OnSecondaryAxisInput);
				}
				return;
			}
			BindButton(OVRInput.RawButton.Start, listener.OnMenuInput);
			BindButton(OVRInput.RawButton.RHandTrigger, listener.OnRecenterInput);
			BindButton(OVRInput.RawButton.LHandTrigger, listener.OnRecenterInput);
			if (listener is IInputListenerTwoWands listener2)
			{
				BindAxis(OVRInput.RawAxis2D.LThumbstick, listener.OnSecondaryAxisInput);
				BindAxis(OVRInput.RawAxis2D.RThumbstick, listener.OnSecondaryAxisInput);
				BindSpellButtonActions(listener2);
			}
			else if (m_primaryController == OVRInput.Controller.RTouch)
			{
				BindButton(OVRInput.RawButton.RIndexTrigger, listener.OnPrimaryInput);
				BindButton(OVRInput.RawButton.LIndexTrigger, listener.OnTeleportInput);
				BindAxis(OVRInput.RawAxis2D.LThumbstick, listener.OnSecondaryAxisInput);
				BindAxis(OVRInput.RawAxis2D.RThumbstick, listener.OnPrimaryAxisInput);
			}
			else
			{
				BindButton(OVRInput.RawButton.LIndexTrigger, listener.OnPrimaryInput);
				BindButton(OVRInput.RawButton.RIndexTrigger, listener.OnTeleportInput);
				BindAxis(OVRInput.RawAxis2D.LThumbstick, listener.OnPrimaryAxisInput);
				BindAxis(OVRInput.RawAxis2D.RThumbstick, listener.OnSecondaryAxisInput);
			}
		}

		public void BindSpellButtonActions(IInputListenerTwoWands listener)
		{
			BindButton(OVRInput.RawButton.LIndexTrigger, listener.OnInteractionLeftInput);
			BindButton(OVRInput.RawButton.RIndexTrigger, listener.OnInteractionInput);
			BindButton(OVRInput.RawButton.LIndexTrigger, listener.OnAutoTeleportLeftInput);
			BindButton(OVRInput.RawButton.RIndexTrigger, listener.OnAutoTeleportRightInput);
			BindButton(OVRInput.RawButton.X, listener.OnSpellInput01);
			BindButton(OVRInput.RawButton.Y, listener.OnSpellInput02);
			BindButton(OVRInput.RawButton.A, listener.OnSpellInput03);
			BindButton(OVRInput.RawButton.B, listener.OnSpellInput04);
		}

		public void UnbindActions(IInputListener listener)
		{
			if (GameControl.Instance.IsCurrentLevel(Level.MainMenu))
			{
				if (m_primaryController == OVRInput.Controller.RTouch)
				{
					UnbindButton(OVRInput.RawButton.A, listener.OnPrimaryInput);
					UnbindButton(OVRInput.RawButton.B, listener.OnPrimaryInput);
					UnbindButton(OVRInput.RawButton.RHandTrigger, listener.OnPrimaryInput);
					UnbindButton(OVRInput.RawButton.RIndexTrigger, listener.OnPrimaryInput);
					UnbindAxis(OVRInput.RawAxis2D.LThumbstick, listener.OnSecondaryAxisInput);
					UnbindAxis(OVRInput.RawAxis2D.RThumbstick, listener.OnPrimaryAxisInput);
				}
				else
				{
					UnbindButton(OVRInput.RawButton.X, listener.OnPrimaryInput);
					UnbindButton(OVRInput.RawButton.Y, listener.OnPrimaryInput);
					UnbindButton(OVRInput.RawButton.LHandTrigger, listener.OnPrimaryInput);
					UnbindButton(OVRInput.RawButton.LIndexTrigger, listener.OnPrimaryInput);
					UnbindAxis(OVRInput.RawAxis2D.LThumbstick, listener.OnPrimaryAxisInput);
					UnbindAxis(OVRInput.RawAxis2D.RThumbstick, listener.OnSecondaryAxisInput);
				}
				return;
			}
			UnbindButton(OVRInput.RawButton.Start, listener.OnMenuInput);
			UnbindButton(OVRInput.RawButton.RHandTrigger, listener.OnRecenterInput);
			UnbindButton(OVRInput.RawButton.LHandTrigger, listener.OnRecenterInput);
			if (listener is IInputListenerTwoWands listener2)
			{
				UnbindAxis(OVRInput.RawAxis2D.LThumbstick, listener.OnSecondaryAxisInput);
				UnbindAxis(OVRInput.RawAxis2D.RThumbstick, listener.OnSecondaryAxisInput);
				UnbindSpellButtonActions(listener2);
			}
			else if (m_primaryController == OVRInput.Controller.RTouch)
			{
				UnbindButton(OVRInput.RawButton.RIndexTrigger, listener.OnPrimaryInput);
				UnbindButton(OVRInput.RawButton.LIndexTrigger, listener.OnTeleportInput);
				UnbindAxis(OVRInput.RawAxis2D.LThumbstick, listener.OnSecondaryAxisInput);
				UnbindAxis(OVRInput.RawAxis2D.RThumbstick, listener.OnPrimaryAxisInput);
			}
			else
			{
				UnbindButton(OVRInput.RawButton.LIndexTrigger, listener.OnPrimaryInput);
				UnbindButton(OVRInput.RawButton.RIndexTrigger, listener.OnTeleportInput);
				UnbindAxis(OVRInput.RawAxis2D.LThumbstick, listener.OnPrimaryAxisInput);
				UnbindAxis(OVRInput.RawAxis2D.RThumbstick, listener.OnSecondaryAxisInput);
			}
		}

		public void UnbindSpellButtonActions(IInputListenerTwoWands listener)
		{
			UnbindButton(OVRInput.RawButton.LIndexTrigger, listener.OnInteractionLeftInput);
			UnbindButton(OVRInput.RawButton.RIndexTrigger, listener.OnInteractionInput);
			UnbindButton(OVRInput.RawButton.LIndexTrigger, listener.OnAutoTeleportLeftInput);
			UnbindButton(OVRInput.RawButton.RIndexTrigger, listener.OnAutoTeleportRightInput);
			UnbindButton(OVRInput.RawButton.X, listener.OnSpellInput01);
			UnbindButton(OVRInput.RawButton.Y, listener.OnSpellInput02);
			UnbindButton(OVRInput.RawButton.A, listener.OnSpellInput03);
			UnbindButton(OVRInput.RawButton.B, listener.OnSpellInput04);
		}

		private void BindButton(OVRInput.RawButton button, Action<InputState> action)
		{
			if (ButtonBindings.ContainsKey(button))
			{
				Dictionary<OVRInput.RawButton, Action<InputState>> buttonBindings;
				OVRInput.RawButton key;
				(buttonBindings = ButtonBindings)[key = button] = (Action<InputState>)Delegate.Combine(buttonBindings[key], action);
			}
			else
			{
				ButtonBindings.Add(button, action);
			}
		}

		private void UnbindButton(OVRInput.RawButton button, Action<InputState> action)
		{
			if (ButtonBindings.ContainsKey(button))
			{
				Dictionary<OVRInput.RawButton, Action<InputState>> buttonBindings;
				OVRInput.RawButton key;
				(buttonBindings = ButtonBindings)[key = button] = (Action<InputState>)Delegate.Remove(buttonBindings[key], action);
			}
		}

		private void BindAxis(OVRInput.RawAxis2D axis, Action<InputState> action)
		{
			if (m_axisBindings.ContainsKey(axis))
			{
				Dictionary<OVRInput.RawAxis2D, Action<InputState>> axisBindings;
				OVRInput.RawAxis2D key;
				(axisBindings = m_axisBindings)[key = axis] = (Action<InputState>)Delegate.Combine(axisBindings[key], action);
			}
			else
			{
				m_axisBindings.Add(axis, action);
			}
		}

		private void UnbindAxis(OVRInput.RawAxis2D axis, Action<InputState> action)
		{
			if (m_axisBindings.ContainsKey(axis))
			{
				Dictionary<OVRInput.RawAxis2D, Action<InputState>> axisBindings;
				OVRInput.RawAxis2D key;
				(axisBindings = m_axisBindings)[key = axis] = (Action<InputState>)Delegate.Remove(axisBindings[key], action);
			}
		}

		public void Update()
		{
			CheckButtonBindings();
			CheckAxisBindings();
		}

		private void CheckButtonBindings()
		{
			m_actionMap.Clear();
			foreach (KeyValuePair<OVRInput.RawButton, Action<InputState>> buttonBinding in ButtonBindings)
			{
				InputState buttonInputState = GetButtonInputState(buttonBinding.Key);
				if (buttonInputState != 0 && buttonBinding.Value != null && !m_actionMap.ContainsKey(buttonBinding.Value))
				{
					m_actionMap.Add(buttonBinding.Value, buttonInputState);
				}
			}
			foreach (KeyValuePair<Action<InputState>, InputState> item in m_actionMap)
			{
				item.Key(item.Value);
			}
		}

		private void CheckAxisBindings()
		{
			m_actionMap.Clear();
			int num = 0;
			foreach (KeyValuePair<OVRInput.RawAxis2D, Action<InputState>> axisBinding in m_axisBindings)
			{
				InputState axisInputState = GetAxisInputState(axisBinding.Key, m_prevAxis[num]);
				m_prevAxis[num++] = axisInputState;
				if (axisInputState != 0 && axisBinding.Value != null && !m_actionMap.ContainsKey(axisBinding.Value))
				{
					m_actionMap.Add(axisBinding.Value, axisInputState);
				}
			}
			foreach (KeyValuePair<Action<InputState>, InputState> item in m_actionMap)
			{
				item.Key(item.Value);
			}
		}

		public InputState GetButtonInputState(OVRInput.RawButton button)
		{
			if (OVRInput.GetDown(button, OVRInput.Controller.Touch))
			{
				return InputState.Down;
			}
			if (OVRInput.GetUp(button, OVRInput.Controller.Touch))
			{
				return InputState.Up;
			}
			if (OVRInput.Get(button, OVRInput.Controller.Touch))
			{
				return InputState.Hold;
			}
			return InputState.None;
		}

		private InputState GetAxisInputState(OVRInput.RawAxis2D axis, InputState prevState)
		{
			Vector2 vector = OVRInput.Get(axis);
			if (vector.x > 0.5f)
			{
				InputState inputState = InputState.AxisRight;
				if (!prevState.ContainsFlag(inputState))
				{
					inputState |= InputState.Down;
				}
				return inputState;
			}
			if (vector.x < -0.5f)
			{
				InputState inputState2 = InputState.AxisLeft;
				if (!prevState.ContainsFlag(inputState2))
				{
					inputState2 |= InputState.Down;
				}
				return inputState2;
			}
			if (vector.y > 0.5f)
			{
				InputState inputState3 = InputState.AxisUp;
				if (!prevState.ContainsFlag(inputState3))
				{
					inputState3 |= InputState.Down;
				}
				return inputState3;
			}
			if (vector.y < -0.5f)
			{
				InputState inputState4 = InputState.AxisDown;
				if (!prevState.ContainsFlag(inputState4))
				{
					inputState4 |= InputState.Down;
				}
				return inputState4;
			}
			if (prevState != 0 && prevState != InputState.Up)
			{
				return InputState.Up;
			}
			return InputState.None;
		}
	}
}
namespace Cortopia.Scripts.WandsInput
{
	public class OpenVRGamepadInput : IPlatformInput, IPauseListenerInput<SteamVR_Action_Boolean>
	{
		private const float Half = 0.5f;

		private readonly SteamVR_Action_Boolean m_indexLeft = SteamVR_Actions.Wands.IndexLeft;

		private readonly SteamVR_Action_Boolean m_indexRight = SteamVR_Actions.Wands.IndexRight;

		private readonly SteamVR_Action_Boolean m_menuButton = SteamVR_Actions.Wands.Menu;

		private readonly SteamVR_Action_Boolean m_buttonLeft01 = SteamVR_Actions.Wands.ButtonLeft01;

		private readonly SteamVR_Action_Boolean m_buttonRight01 = SteamVR_Actions.Wands.ButtonRight01;

		private readonly SteamVR_Action_Vector2 m_leftThumbstick = SteamVR_Actions.Wands.ThumbstickLeft;

		private readonly SteamVR_Action_Vector2 m_rightThumbstick = SteamVR_Actions.Wands.ThumbstickRight;

		private readonly InputState[] m_prevAxis = new InputState[2];

		private readonly Dictionary<SteamVR_Action_Vector2, Action<InputState>> m_axisBindings = new Dictionary<SteamVR_Action_Vector2, Action<InputState>>(2);

		private readonly Dictionary<Action<InputState>, InputState> m_actions = new Dictionary<Action<InputState>, InputState>(2);

		private InputPauseListener<SteamVR_Action_Boolean> m_inputPauseListener;

		public bool IsCorrectInputSystem
		{
			[CompilerGenerated]
			get
			{
				return true;
			}
		}

		public bool IsAutoTeleportEnabled
		{
			[CompilerGenerated]
			get
			{
				return false;
			}
		}

		public AimInput Aim
		{
			[CompilerGenerated]
			get
			{
				return AimInput.Head;
			}
		}

		public WandInput WandInput
		{
			[CompilerGenerated]
			get
			{
				return WandInput.Stick;
			}
		}

		public Dictionary<SteamVR_Action_Boolean, Action<InputState>> ButtonBindings { get; } = new Dictionary<SteamVR_Action_Boolean, Action<InputState>>(8);


		public OpenVRGamepadInput()
		{
			m_inputPauseListener = new InputPauseListener<SteamVR_Action_Boolean>(this);
		}

		public void BindActions(IInputListener listener)
		{
			if (GameControl.Instance.IsCurrentLevel(Level.MainMenu))
			{
				BindButton(m_indexRight, listener.OnPrimaryInput);
				BindButton(m_indexLeft, listener.OnPrimaryInput);
				BindButton(m_buttonRight01, listener.OnPrimaryInput);
				BindButton(m_buttonLeft01, listener.OnPrimaryInput);
				BindAxis(m_leftThumbstick, listener.OnSecondaryAxisInput);
				BindAxis(m_rightThumbstick, listener.OnPrimaryAxisInput);
			}
			else
			{
				BindButton(m_menuButton, listener.OnMenuInput);
				BindButton(m_buttonLeft01, listener.OnRecenterInput);
				BindButton(m_buttonRight01, listener.OnRecenterInput);
				BindButton(m_indexRight, listener.OnPrimaryInput);
				BindButton(m_indexLeft, listener.OnTeleportInput);
				BindAxis(m_rightThumbstick, listener.OnPrimaryAxisInput);
				BindAxis(m_leftThumbstick, listener.OnSecondaryAxisInput);
			}
		}

		public void UnbindActions(IInputListener listener)
		{
			if (GameControl.Instance.IsCurrentLevel(Level.MainMenu))
			{
				UnbindButton(m_indexRight, listener.OnPrimaryInput);
				UnbindButton(m_indexLeft, listener.OnPrimaryInput);
				UnbindButton(m_buttonRight01, listener.OnPrimaryInput);
				UnbindButton(m_buttonLeft01, listener.OnPrimaryInput);
				UnbindAxis(m_leftThumbstick, listener.OnSecondaryAxisInput);
				UnbindAxis(m_rightThumbstick, listener.OnPrimaryAxisInput);
			}
			else
			{
				UnbindButton(m_menuButton, listener.OnMenuInput);
				UnbindButton(m_buttonLeft01, listener.OnRecenterInput);
				UnbindButton(m_buttonRight01, listener.OnRecenterInput);
				UnbindButton(m_indexRight, listener.OnPrimaryInput);
				UnbindButton(m_indexLeft, listener.OnTeleportInput);
				UnbindAxis(m_rightThumbstick, listener.OnPrimaryAxisInput);
				UnbindAxis(m_leftThumbstick, listener.OnSecondaryAxisInput);
			}
		}

		public void Update()
		{
			CheckButtonBindings();
			CheckAxisBindings();
		}

		private void BindButton(SteamVR_Action_Boolean button, Action<InputState> action)
		{
			if (ButtonBindings.ContainsKey(button))
			{
				Dictionary<SteamVR_Action_Boolean, Action<InputState>> buttonBindings;
				SteamVR_Action_Boolean key;
				(buttonBindings = ButtonBindings)[key = button] = (Action<InputState>)Delegate.Combine(buttonBindings[key], action);
			}
			else
			{
				ButtonBindings.Add(button, action);
			}
		}

		private void UnbindButton(SteamVR_Action_Boolean button, Action<InputState> action)
		{
			if (ButtonBindings.ContainsKey(button))
			{
				Dictionary<SteamVR_Action_Boolean, Action<InputState>> buttonBindings;
				SteamVR_Action_Boolean key;
				(buttonBindings = ButtonBindings)[key = button] = (Action<InputState>)Delegate.Remove(buttonBindings[key], action);
			}
		}

		private void BindAxis(SteamVR_Action_Vector2 axis, Action<InputState> action)
		{
			if (m_axisBindings.ContainsKey(axis))
			{
				Dictionary<SteamVR_Action_Vector2, Action<InputState>> axisBindings;
				SteamVR_Action_Vector2 key;
				(axisBindings = m_axisBindings)[key = axis] = (Action<InputState>)Delegate.Combine(axisBindings[key], action);
			}
			else
			{
				m_axisBindings.Add(axis, action);
			}
		}

		private void UnbindAxis(SteamVR_Action_Vector2 axis, Action<InputState> action)
		{
			if (m_axisBindings.ContainsKey(axis))
			{
				Dictionary<SteamVR_Action_Vector2, Action<InputState>> axisBindings;
				SteamVR_Action_Vector2 key;
				(axisBindings = m_axisBindings)[key = axis] = (Action<InputState>)Delegate.Remove(axisBindings[key], action);
			}
		}

		private void CheckButtonBindings()
		{
			m_actions.Clear();
			foreach (KeyValuePair<SteamVR_Action_Boolean, Action<InputState>> buttonBinding in ButtonBindings)
			{
				InputState buttonInputState = GetButtonInputState(buttonBinding.Key);
				if (buttonInputState != 0 && buttonBinding.Value != null && !m_actions.ContainsKey(buttonBinding.Value))
				{
					m_actions.Add(buttonBinding.Value, buttonInputState);
				}
			}
			foreach (KeyValuePair<Action<InputState>, InputState> action in m_actions)
			{
				action.Key(action.Value);
			}
		}

		private void CheckAxisBindings()
		{
			m_actions.Clear();
			int num = 0;
			foreach (KeyValuePair<SteamVR_Action_Vector2, Action<InputState>> axisBinding in m_axisBindings)
			{
				InputState axisInputState = GetAxisInputState(axisBinding.Key, m_prevAxis[num]);
				m_prevAxis[num++] = axisInputState;
				if (axisInputState != 0 && axisBinding.Value != null && !m_actions.ContainsKey(axisBinding.Value))
				{
					m_actions.Add(axisBinding.Value, axisInputState);
				}
			}
			foreach (KeyValuePair<Action<InputState>, InputState> action in m_actions)
			{
				action.Key(action.Value);
			}
		}

		public InputState GetButtonInputState(SteamVR_Action_Boolean button)
		{
			if (button.stateDown)
			{
				return InputState.Down;
			}
			if (button.stateUp)
			{
				return InputState.Up;
			}
			if (button.state)
			{
				return InputState.Hold;
			}
			return InputState.None;
		}

		private InputState GetAxisInputState(SteamVR_Action_Vector2 axis, InputState prevState)
		{
			Vector2 axis2 = axis.axis;
			if (axis2.x > 0.5f)
			{
				InputState inputState = InputState.AxisRight;
				if (!prevState.ContainsFlag(inputState))
				{
					inputState |= InputState.Down;
				}
				return inputState;
			}
			if (axis2.x < -0.5f)
			{
				InputState inputState2 = InputState.AxisLeft;
				if (!prevState.ContainsFlag(inputState2))
				{
					inputState2 |= InputState.Down;
				}
				return inputState2;
			}
			if (axis2.y > 0.5f)
			{
				InputState inputState3 = InputState.AxisUp;
				if (!prevState.ContainsFlag(inputState3))
				{
					inputState3 |= InputState.Down;
				}
				return inputState3;
			}
			if (axis2.y < -0.5f)
			{
				InputState inputState4 = InputState.AxisDown;
				if (!prevState.ContainsFlag(inputState4))
				{
					inputState4 |= InputState.Down;
				}
				return inputState4;
			}
			if (prevState != 0 && prevState != InputState.Up)
			{
				return InputState.Up;
			}
			return InputState.None;
		}
	}
	public class OpenVRInput : SteamInput
	{
		public OpenVRInput(Valve.VR.ETrackedControllerRole primaryController, StringBuilder inputStringBuilder)
			: base(primaryController, inputStringBuilder)
		{
		}

		public override void BindDefaultActions(IInputListener listener)
		{
			BindButton(m_menuButton, listener.OnMenuInput);
			BindButton(m_grabRight, listener.OnRecenterInput);
			BindButton(m_grabLeft, listener.OnRecenterInput);
			if (listener is IInputListenerTwoWands listener2)
			{
				BindAxis(m_leftThumbstick, listener.OnSecondaryAxisInput);
				BindAxis(m_rightThumbstick, listener.OnSecondaryAxisInput);
				BindSpellButtonActions(listener2);
			}
			else if (m_primaryController == Valve.VR.ETrackedControllerRole.RightHand)
			{
				BindButton(m_indexRight, listener.OnPrimaryInput);
				BindButton(m_indexLeft, listener.OnTeleportInput);
				BindAxis(m_rightThumbstick, listener.OnPrimaryAxisInput);
				BindAxis(m_leftThumbstick, listener.OnSecondaryAxisInput);
			}
			else
			{
				BindButton(m_indexLeft, listener.OnPrimaryInput);
				BindButton(m_indexRight, listener.OnTeleportInput);
				BindAxis(m_leftThumbstick, listener.OnPrimaryAxisInput);
				BindAxis(m_rightThumbstick, listener.OnSecondaryAxisInput);
			}
		}

		public override void BindSpellButtonActions(IInputListenerTwoWands listener)
		{
			BindButton(m_indexLeft, listener.OnInteractionLeftInput);
			BindButton(m_indexRight, listener.OnInteractionInput);
			BindButton(m_indexLeft, listener.OnAutoTeleportLeftInput);
			BindButton(m_indexRight, listener.OnAutoTeleportRightInput);
			BindButton(m_buttonLeft01, listener.OnSpellInput01);
			BindButton(m_buttonLeft02, listener.OnSpellInput02);
			BindButton(m_buttonRight01, listener.OnSpellInput03);
			BindButton(m_buttonRight02, listener.OnSpellInput04);
		}

		public override void UnbindDefaultActions(IInputListener listener)
		{
			UnbindButton(m_menuButton, listener.OnMenuInput);
			UnbindButton(m_grabRight, listener.OnRecenterInput);
			UnbindButton(m_grabLeft, listener.OnRecenterInput);
			if (listener is IInputListenerTwoWands listener2)
			{
				UnbindAxis(m_leftThumbstick, listener.OnSecondaryAxisInput);
				UnbindAxis(m_rightThumbstick, listener.OnSecondaryAxisInput);
				UnbindSpellButtonActions(listener2);
			}
			else if (m_primaryController == Valve.VR.ETrackedControllerRole.RightHand)
			{
				UnbindButton(m_indexRight, listener.OnPrimaryInput);
				UnbindButton(m_indexLeft, listener.OnTeleportInput);
				UnbindAxis(m_rightThumbstick, listener.OnPrimaryAxisInput);
				UnbindAxis(m_leftThumbstick, listener.OnSecondaryAxisInput);
			}
			else
			{
				UnbindButton(m_indexLeft, listener.OnPrimaryInput);
				UnbindButton(m_indexRight, listener.OnTeleportInput);
				UnbindAxis(m_leftThumbstick, listener.OnPrimaryAxisInput);
				UnbindAxis(m_rightThumbstick, listener.OnSecondaryAxisInput);
			}
		}

		public override void UnbindSpellButtonActions(IInputListenerTwoWands listener)
		{
			UnbindButton(m_indexLeft, listener.OnInteractionLeftInput);
			UnbindButton(m_indexRight, listener.OnInteractionInput);
			UnbindButton(m_indexLeft, listener.OnAutoTeleportLeftInput);
			UnbindButton(m_indexRight, listener.OnAutoTeleportRightInput);
			UnbindButton(m_buttonLeft01, listener.OnSpellInput01);
			UnbindButton(m_buttonLeft02, listener.OnSpellInput02);
			UnbindButton(m_buttonRight01, listener.OnSpellInput03);
			UnbindButton(m_buttonRight02, listener.OnSpellInput04);
		}
	}
}
namespace Assets.Scripts.WandsInput
{
	public class PicoController : MonoBehaviour
	{
		[SerializeField]
		private int m_handIndex;

		[SerializeField]
		private bool m_trackPosition;

		private void Update()
		{
			base.transform.rotation = Controller.UPvr_GetControllerQUA(m_handIndex);
			if (m_trackPosition)
			{
				base.transform.position = Controller.UPvr_GetControllerPOS(m_handIndex);
			}
		}
	}
	public struct PicoNeo2Key
	{
		public int Hand;

		public bool CanBeSwap;

		public Pvr_KeyCode Key;
	}
	public enum AxisControl
	{
		Left,
		Right
	}
	public class PicoNeo2Input : IPlatformInput, IPauseListenerInput<PicoNeo2Key>
	{
		private PicoNeo2Key PrimaryButton = new PicoNeo2Key
		{
			Hand = 1,
			CanBeSwap = true,
			Key = Pvr_KeyCode.TRIGGER
		};

		private PicoNeo2Key SecondaryButton = new PicoNeo2Key
		{
			Hand = 1,
			CanBeSwap = true,
			Key = Pvr_KeyCode.APP
		};

		private PicoNeo2Key PrimaryButtonLeft = new PicoNeo2Key
		{
			Hand = 0,
			CanBeSwap = false,
			Key = Pvr_KeyCode.TRIGGER
		};

		private PicoNeo2Key PrimaryButtonRight = new PicoNeo2Key
		{
			Hand = 1,
			CanBeSwap = false,
			Key = Pvr_KeyCode.TRIGGER
		};

		private PicoNeo2Key PointButtonLeft = new PicoNeo2Key
		{
			Hand = 0,
			CanBeSwap = false,
			Key = Pvr_KeyCode.Left
		};

		private PicoNeo2Key PointButtonRight = new PicoNeo2Key
		{
			Hand = 1,
			CanBeSwap = false,
			Key = Pvr_KeyCode.Right
		};

		private PicoNeo2Key MenuButtonLeft = new PicoNeo2Key
		{
			Hand = 0,
			CanBeSwap = false,
			Key = Pvr_KeyCode.APP
		};

		private PicoNeo2Key MenuButtonRight = new PicoNeo2Key
		{
			Hand = 1,
			CanBeSwap = false,
			Key = Pvr_KeyCode.APP
		};

		private PicoNeo2Key RecenterButtonLeft = new PicoNeo2Key
		{
			Hand = 0,
			CanBeSwap = false,
			Key = Pvr_KeyCode.X
		};

		private PicoNeo2Key RecenterButtonRight = new PicoNeo2Key
		{
			Hand = 1,
			CanBeSwap = false,
			Key = Pvr_KeyCode.A
		};

		private PicoNeo2Key SpellLeft01 = new PicoNeo2Key
		{
			Hand = 0,
			CanBeSwap = false,
			Key = Pvr_KeyCode.X
		};

		private PicoNeo2Key SpellLeft02 = new PicoNeo2Key
		{
			Hand = 0,
			CanBeSwap = false,
			Key = Pvr_KeyCode.Y
		};

		private PicoNeo2Key SpellRight01 = new PicoNeo2Key
		{
			Hand = 1,
			CanBeSwap = false,
			Key = Pvr_KeyCode.A
		};

		private PicoNeo2Key SpellRight02 = new PicoNeo2Key
		{
			Hand = 1,
			CanBeSwap = false,
			Key = Pvr_KeyCode.B
		};

		private readonly Dictionary<Action<InputState>, InputState> m_actions = new Dictionary<Action<InputState>, InputState>(2);

		private InputPauseListener<PicoNeo2Key> m_inputPauseListener;

		private int m_handIndex = 1;

		private readonly Dictionary<AxisControl, Action<InputState>> m_axis2DBindings = new Dictionary<AxisControl, Action<InputState>>(15);

		private readonly InputState[] m_previousAxis2DState = new InputState[2];

		public Dictionary<PicoNeo2Key, Action<InputState>> ButtonBindings { get; } = new Dictionary<PicoNeo2Key, Action<InputState>>(2);


		public bool IsCorrectInputSystem
		{
			[CompilerGenerated]
			get
			{
				return true;
			}
		}

		public bool IsAutoTeleportEnabled
		{
			[CompilerGenerated]
			get
			{
				return false;
			}
		}

		public AimInput Aim { get; private set; }

		public WandInput WandInput
		{
			[CompilerGenerated]
			get
			{
				return WandInput.Stick;
			}
		}

		private bool IsRightHanded
		{
			[CompilerGenerated]
			get
			{
				return m_handIndex == 1;
			}
		}

		public PicoNeo2Input()
		{
			m_handIndex = (WandsSave.GetBoolPref("P1", defaultValue: true) ? 1 : 0);
			Aim = ((!IsRightHanded) ? AimInput.LeftHand : AimInput.RightHand);
			m_inputPauseListener = new InputPauseListener<PicoNeo2Key>(this);
		}

		public void BindActions(IInputListener listener)
		{
			if (GameControl.Instance.IsCurrentLevel(Level.MainMenu))
			{
				BindButton(PrimaryButton, listener.OnPrimaryInput);
				BindButton(SecondaryButton, listener.OnSecondaryInput);
				return;
			}
			BindButton(MenuButtonLeft, listener.OnMenuInput);
			BindButton(MenuButtonRight, listener.OnMenuInput);
			BindButton(PointButtonRight, listener.OnRecenterInput);
			BindButton(PointButtonLeft, listener.OnRecenterInput);
			if (listener is IInputListenerTwoWands listener2)
			{
				BindAxis(AxisControl.Left, listener.OnSecondaryAxisInput);
				BindAxis(AxisControl.Right, listener.OnSecondaryAxisInput);
				BindSpellButtonActions(listener2);
			}
			else if (IsRightHanded)
			{
				BindButton(PrimaryButtonRight, listener.OnPrimaryInput);
				BindButton(PrimaryButtonLeft, listener.OnTeleportInput);
				BindAxis(AxisControl.Left, listener.OnSecondaryAxisInput);
				BindAxis(AxisControl.Right, listener.OnPrimaryAxisInput);
			}
			else
			{
				BindButton(PrimaryButtonLeft, listener.OnPrimaryInput);
				BindButton(PrimaryButtonRight, listener.OnTeleportInput);
				BindAxis(AxisControl.Left, listener.OnPrimaryAxisInput);
				BindAxis(AxisControl.Right, listener.OnSecondaryAxisInput);
			}
		}

		public void BindSpellButtonActions(IInputListenerTwoWands listener)
		{
			BindButton(PrimaryButtonLeft, listener.OnInteractionLeftInput);
			BindButton(PrimaryButtonRight, listener.OnInteractionInput);
			BindButton(PrimaryButtonLeft, listener.OnAutoTeleportLeftInput);
			BindButton(PrimaryButtonRight, listener.OnAutoTeleportRightInput);
			BindButton(SpellLeft01, listener.OnSpellInput01);
			BindButton(SpellLeft02, listener.OnSpellInput02);
			BindButton(SpellRight01, listener.OnSpellInput03);
			BindButton(SpellRight02, listener.OnSpellInput04);
		}

		public void UnbindActions(IInputListener listener)
		{
			if (GameControl.Instance.IsCurrentLevel(Level.MainMenu))
			{
				UnbindButton(PrimaryButton, listener.OnPrimaryInput);
				UnbindButton(SecondaryButton, listener.OnSecondaryInput);
				return;
			}
			UnbindButton(MenuButtonRight, listener.OnMenuInput);
			UnbindButton(PointButtonRight, listener.OnRecenterInput);
			UnbindButton(PointButtonRight, listener.OnRecenterInput);
			UnbindButton(PointButtonLeft, listener.OnRecenterInput);
			if (listener is IInputListenerTwoWands listener2)
			{
				UnbindAxis(AxisControl.Left, listener.OnSecondaryAxisInput);
				UnbindAxis(AxisControl.Right, listener.OnSecondaryAxisInput);
				UnbindSpellButtonActions(listener2);
			}
			else if (IsRightHanded)
			{
				UnbindButton(PrimaryButtonRight, listener.OnPrimaryInput);
				UnbindButton(PrimaryButtonLeft, listener.OnTeleportInput);
				UnbindAxis(AxisControl.Left, listener.OnSecondaryAxisInput);
				UnbindAxis(AxisControl.Right, listener.OnPrimaryAxisInput);
			}
			else
			{
				UnbindButton(PrimaryButtonLeft, listener.OnPrimaryInput);
				UnbindButton(PrimaryButtonRight, listener.OnTeleportInput);
				UnbindAxis(AxisControl.Left, listener.OnPrimaryAxisInput);
				UnbindAxis(AxisControl.Right, listener.OnSecondaryAxisInput);
			}
		}

		private void BindAxis(AxisControl axis, Action<InputState> action)
		{
			if (m_axis2DBindings.ContainsKey(axis))
			{
				Dictionary<AxisControl, Action<InputState>> axis2DBindings;
				AxisControl key;
				(axis2DBindings = m_axis2DBindings)[key = axis] = (Action<InputState>)Delegate.Combine(axis2DBindings[key], action);
			}
			else
			{
				m_axis2DBindings.Add(axis, action);
			}
		}

		private void UnbindAxis(AxisControl axis, Action<InputState> action)
		{
			if (m_axis2DBindings.ContainsKey(axis))
			{
				Dictionary<AxisControl, Action<InputState>> axis2DBindings;
				AxisControl key;
				(axis2DBindings = m_axis2DBindings)[key = axis] = (Action<InputState>)Delegate.Remove(axis2DBindings[key], action);
			}
		}

		public void UnbindSpellButtonActions(IInputListenerTwoWands listener)
		{
			UnbindButton(PrimaryButtonLeft, listener.OnInteractionLeftInput);
			UnbindButton(PrimaryButtonRight, listener.OnInteractionInput);
			UnbindButton(PrimaryButtonLeft, listener.OnAutoTeleportLeftInput);
			UnbindButton(PrimaryButtonRight, listener.OnAutoTeleportRightInput);
			UnbindButton(SpellLeft01, listener.OnSpellInput01);
			UnbindButton(SpellLeft02, listener.OnSpellInput02);
			UnbindButton(SpellRight01, listener.OnSpellInput03);
			UnbindButton(SpellRight02, listener.OnSpellInput04);
		}

		private void BindButton(PicoNeo2Key button, Action<InputState> action)
		{
			if (ButtonBindings.ContainsKey(button))
			{
				Dictionary<PicoNeo2Key, Action<InputState>> buttonBindings;
				PicoNeo2Key key;
				(buttonBindings = ButtonBindings)[key = button] = (Action<InputState>)Delegate.Combine(buttonBindings[key], action);
			}
			else
			{
				ButtonBindings.Add(button, action);
			}
		}

		private void UnbindButton(PicoNeo2Key button, Action<InputState> action)
		{
			if (ButtonBindings.ContainsKey(button))
			{
				Dictionary<PicoNeo2Key, Action<InputState>> buttonBindings;
				PicoNeo2Key key;
				(buttonBindings = ButtonBindings)[key = button] = (Action<InputState>)Delegate.Remove(buttonBindings[key], action);
			}
		}

		public void Update()
		{
			CheckButtonBindings();
			CheckAxisBindings();
		}

		private void CheckButtonBindings()
		{
			m_actions.Clear();
			foreach (KeyValuePair<PicoNeo2Key, Action<InputState>> buttonBinding in ButtonBindings)
			{
				InputState buttonInputState = GetButtonInputState(buttonBinding.Key);
				if (buttonInputState != 0 && buttonBinding.Value != null && !m_actions.ContainsKey(buttonBinding.Value))
				{
					m_actions.Add(buttonBinding.Value, buttonInputState);
				}
			}
			foreach (KeyValuePair<Action<InputState>, InputState> action in m_actions)
			{
				action.Key(action.Value);
			}
		}

		private void CheckAxisBindings()
		{
			m_actions.Clear();
			for (int i = 0; i < m_axis2DBindings.Count; i++)
			{
				KeyValuePair<AxisControl, Action<InputState>> keyValuePair = m_axis2DBindings.ElementAt(i);
				InputState axisInputState = GetAxisInputState(keyValuePair.Key, m_previousAxis2DState[i]);
				m_previousAxis2DState[i] = axisInputState;
				if (axisInputState != 0 && keyValuePair.Value != null && !m_actions.ContainsKey(keyValuePair.Value))
				{
					m_actions.Add(keyValuePair.Value, axisInputState);
				}
			}
			foreach (KeyValuePair<Action<InputState>, InputState> action in m_actions)
			{
				action.Key(action.Value);
			}
		}

		public InputState GetButtonInputState(PicoNeo2Key button)
		{
			int hand = m_handIndex;
			if (!button.CanBeSwap)
			{
				hand = button.Hand;
			}
			if (Controller.UPvr_GetKeyDown(hand, button.Key))
			{
				return InputState.Down;
			}
			if (Controller.UPvr_GetKeyUp(hand, button.Key))
			{
				return InputState.Up;
			}
			if (Controller.UPvr_GetKey(hand, button.Key))
			{
				return InputState.Hold;
			}
			return InputState.None;
		}

		private InputState GetAxisInputState(AxisControl axis, InputState prevState)
		{
			Vector2 vector = Controller.UPvr_GetAxis2D((int)axis);
			if (vector.x > 0.5f)
			{
				InputState inputState = InputState.AxisRight;
				if (!prevState.ContainsFlag(inputState))
				{
					inputState |= InputState.Down;
				}
				return inputState;
			}
			if (vector.x < -0.5f)
			{
				InputState inputState2 = InputState.AxisLeft;
				if (!prevState.ContainsFlag(inputState2))
				{
					inputState2 |= InputState.Down;
				}
				return inputState2;
			}
			if (vector.y > 0.5f)
			{
				InputState inputState3 = InputState.AxisUp;
				if (!prevState.ContainsFlag(inputState3))
				{
					inputState3 |= InputState.Down;
				}
				return inputState3;
			}
			if (vector.y < -0.5f)
			{
				InputState inputState4 = InputState.AxisDown;
				if (!prevState.ContainsFlag(inputState4))
				{
					inputState4 |= InputState.Down;
				}
				return inputState4;
			}
			if (prevState != 0 && prevState != InputState.Up)
			{
				return InputState.Up;
			}
			return InputState.None;
		}
	}
}
namespace Assets.Cortopia.Scripts.WandsInput
{
	public class PlayStationDualShockInput : IPlatformInput
	{
		private readonly InputState[] PreviousAxis2DState = new InputState[2];

		private readonly Dictionary<InputControlType, Action<InputState>> ButtonBindings = new Dictionary<InputControlType, Action<InputState>>();

		private const InputControlType Menu = InputControlType.TouchPadButton;

		private const InputControlType Recenter = InputControlType.Options;

		private readonly InputControlType[] Primary = new InputControlType[2]
		{
			InputControlType.RightBumper,
			InputControlType.RightTrigger
		};

		private readonly InputControlType[] Teleport = new InputControlType[2]
		{
			InputControlType.LeftBumper,
			InputControlType.LeftTrigger
		};

		private readonly InputControlType[] LeftAxis = new InputControlType[2]
		{
			InputControlType.LeftStickX,
			InputControlType.LeftStickY
		};

		private readonly InputControlType[] RightAxis = new InputControlType[2]
		{
			InputControlType.RightStickX,
			InputControlType.RightStickY
		};

		private InputDevice inputDevice = InControl.InputManager.ActiveDevice;

		private readonly Dictionary<InputControlType[], Action<InputState>> ButtonCombinationBindings = new Dictionary<InputControlType[], Action<InputState>>();

		private readonly Dictionary<InputControlType[], Action<InputState>> Axis2DBindings = new Dictionary<InputControlType[], Action<InputState>>();

		private readonly Dictionary<InputControlType, Action<InputState>> ButtonAxisBindings = new Dictionary<InputControlType, Action<InputState>>();

		private readonly Dictionary<Action<InputState>, InputState> buttonsActions = new Dictionary<Action<InputState>, InputState>();

		private readonly Dictionary<Action<InputState>, InputState> buttonCombinationActions = new Dictionary<Action<InputState>, InputState>();

		private readonly Dictionary<Action<InputState>, InputState> axisActions = new Dictionary<Action<InputState>, InputState>();

		public bool IsCorrectInputSystem => false;

		public bool IsControllerPlugged => false;

		public bool IsAutoTeleportEnabled
		{
			[CompilerGenerated]
			get
			{
				return false;
			}
		}

		public AimInput Aim
		{
			[CompilerGenerated]
			get
			{
				return AimInput.Head;
			}
		}

		public WandInput WandInput
		{
			[CompilerGenerated]
			get
			{
				return WandInput.Press;
			}
		}

		public bool IsValidated { get; set; } = true;


		public void BindActions(IInputListener listener)
		{
			BindButton(InputControlType.TouchPadButton, listener.OnMenuInput);
			BindButton(InputControlType.Options, listener.OnRecenterInput);
			Level currentLevel = GameControl.Instance.GetCurrentLevel();
			if (currentLevel == Level.Workshop || currentLevel == Level.Lobby)
			{
				BindButtonCombination(Primary, listener.OnPrimaryInput);
				BindButtonCombination(Teleport, listener.OnPrimaryInput);
			}
			else
			{
				BindButtonCombination(Primary, listener.OnTeleportInput);
				BindButtonCombination(Teleport, listener.OnTeleportInput);
			}
			if (listener is MainMenuInputListener)
			{
				BindButtonCombination(Primary, listener.OnPrimaryInput);
				BindButtonCombination(Teleport, listener.OnPrimaryInput);
				BindButton(InputControlType.Action1, listener.OnPrimaryInput);
				BindButton(InputControlType.Action2, listener.OnPrimaryInput);
				BindButton(InputControlType.Action3, listener.OnPrimaryInput);
				BindButton(InputControlType.Action4, listener.OnPrimaryInput);
				BindButton(InputControlType.TouchPadButton, listener.OnPrimaryInput);
				return;
			}
			BindAxis(RightAxis, listener.OnPrimaryAxisInput);
			BindAxis(LeftAxis, listener.OnSecondaryAxisInput);
			Action<InputState> action = delegate(InputState state)
			{
				listener.OnPrimaryAxisInput(((state != InputState.Up) ? InputState.AxisDown : InputState.None) | state);
				listener.OnPrimaryInput(state);
			};
			ButtonAxisBindings[InputControlType.Action1] = action;
			BindButton(InputControlType.Action1, action);
			action = delegate(InputState state)
			{
				listener.OnPrimaryAxisInput(((state != InputState.Up) ? InputState.AxisRight : InputState.None) | state);
				listener.OnPrimaryInput(state);
			};
			ButtonAxisBindings[InputControlType.Action2] = action;
			BindButton(InputControlType.Action2, action);
			action = delegate(InputState state)
			{
				listener.OnPrimaryAxisInput(((state != InputState.Up) ? InputState.AxisLeft : InputState.None) | state);
				listener.OnPrimaryInput(state);
			};
			ButtonAxisBindings[InputControlType.Action3] = action;
			BindButton(InputControlType.Action3, action);
			action = delegate(InputState state)
			{
				listener.OnPrimaryAxisInput(((state != InputState.Up) ? InputState.AxisUp : InputState.None) | state);
				listener.OnPrimaryInput(state);
			};
			ButtonAxisBindings[InputControlType.Action4] = action;
			BindButton(InputControlType.Action4, action);
			action = delegate(InputState state)
			{
				if (state == InputState.Hold || state == InputState.Down)
				{
					listener.OnSecondaryAxisInput(InputState.AxisLeft | state);
				}
			};
			ButtonAxisBindings[InputControlType.DPadLeft] = action;
			BindButton(InputControlType.DPadLeft, action);
			action = delegate(InputState state)
			{
				if (state == InputState.Hold || state == InputState.Down)
				{
					listener.OnSecondaryAxisInput(InputState.AxisRight | state);
				}
			};
			ButtonAxisBindings[InputControlType.DPadRight] = action;
			BindButton(InputControlType.DPadRight, action);
			action = delegate(InputState state)
			{
				if (state == InputState.Hold || state == InputState.Down)
				{
					listener.OnSecondaryAxisInput(InputState.AxisDown | state);
				}
			};
			ButtonAxisBindings[InputControlType.DPadUp] = action;
			BindButton(InputControlType.DPadUp, action);
			action = delegate(InputState state)
			{
				if (state == InputState.Hold || state == InputState.Down)
				{
					listener.OnSecondaryAxisInput(InputState.AxisDown | state);
				}
			};
			ButtonAxisBindings[InputControlType.DPadDown] = action;
			BindButton(InputControlType.DPadDown, action);
		}

		public void UnbindActions(IInputListener listener)
		{
			UnbindButton(InputControlType.TouchPadButton, listener.OnMenuInput);
			UnbindButton(InputControlType.Options, listener.OnRecenterInput);
			Level currentLevel = GameControl.Instance.GetCurrentLevel();
			if (currentLevel == Level.Workshop || currentLevel == Level.Lobby)
			{
				UnbindButtonCombination(Primary, listener.OnPrimaryInput);
				UnbindButtonCombination(Teleport, listener.OnPrimaryInput);
			}
			else
			{
				UnbindButtonCombination(Primary, listener.OnTeleportInput);
				UnbindButtonCombination(Teleport, listener.OnTeleportInput);
			}
			if (listener is MainMenuInputListener)
			{
				UnbindButtonCombination(Primary, listener.OnPrimaryInput);
				UnbindButtonCombination(Teleport, listener.OnPrimaryInput);
				UnbindButton(InputControlType.Action1, listener.OnPrimaryInput);
				UnbindButton(InputControlType.Action2, listener.OnPrimaryInput);
				UnbindButton(InputControlType.Action3, listener.OnPrimaryInput);
				UnbindButton(InputControlType.Action4, listener.OnPrimaryInput);
				UnbindButton(InputControlType.TouchPadButton, listener.OnPrimaryInput);
			}
			else
			{
				UnbindAxis(LeftAxis, listener.OnSecondaryAxisInput);
				UnbindAxis(RightAxis, listener.OnPrimaryAxisInput);
				UnbindButton(InputControlType.Action1, ButtonAxisBindings[InputControlType.Action1]);
				UnbindButton(InputControlType.Action2, ButtonAxisBindings[InputControlType.Action2]);
				UnbindButton(InputControlType.Action3, ButtonAxisBindings[InputControlType.Action3]);
				UnbindButton(InputControlType.Action4, ButtonAxisBindings[InputControlType.Action4]);
				UnbindButton(InputControlType.DPadLeft, ButtonAxisBindings[InputControlType.DPadLeft]);
				UnbindButton(InputControlType.DPadDown, ButtonAxisBindings[InputControlType.DPadDown]);
				UnbindButton(InputControlType.DPadUp, ButtonAxisBindings[InputControlType.DPadUp]);
				UnbindButton(InputControlType.DPadRight, ButtonAxisBindings[InputControlType.DPadRight]);
			}
		}

		private void BindButton(InputControlType button, Action<InputState> action)
		{
			if (ButtonBindings.ContainsKey(button))
			{
				Dictionary<InputControlType, Action<InputState>> buttonBindings;
				InputControlType key;
				(buttonBindings = ButtonBindings)[key = button] = (Action<InputState>)Delegate.Combine(buttonBindings[key], action);
			}
			else
			{
				ButtonBindings.Add(button, action);
			}
		}

		private void BindButtonCombination(InputControlType[] buttonCombination, Action<InputState> action)
		{
			if (ButtonCombinationBindings.ContainsKey(buttonCombination))
			{
				Dictionary<InputControlType[], Action<InputState>> buttonCombinationBindings;
				InputControlType[] key;
				(buttonCombinationBindings = ButtonCombinationBindings)[key = buttonCombination] = (Action<InputState>)Delegate.Combine(buttonCombinationBindings[key], action);
			}
			else
			{
				ButtonCombinationBindings.Add(buttonCombination, action);
			}
		}

		private void BindAxis(InputControlType[] axis, Action<InputState> action)
		{
			if (Axis2DBindings.ContainsKey(axis))
			{
				Dictionary<InputControlType[], Action<InputState>> axis2DBindings;
				InputControlType[] key;
				(axis2DBindings = Axis2DBindings)[key = axis] = (Action<InputState>)Delegate.Combine(axis2DBindings[key], action);
			}
			else
			{
				Axis2DBindings.Add(axis, action);
			}
		}

		private void UnbindButton(InputControlType button, Action<InputState> action)
		{
			if (ButtonBindings.ContainsKey(button))
			{
				Dictionary<InputControlType, Action<InputState>> buttonBindings;
				InputControlType key;
				(buttonBindings = ButtonBindings)[key = button] = (Action<InputState>)Delegate.Remove(buttonBindings[key], action);
			}
		}

		private void UnbindButtonCombination(InputControlType[] buttonCombination, Action<InputState> action)
		{
			if (ButtonCombinationBindings.ContainsKey(buttonCombination))
			{
				Dictionary<InputControlType[], Action<InputState>> buttonCombinationBindings;
				InputControlType[] key;
				(buttonCombinationBindings = ButtonCombinationBindings)[key = buttonCombination] = (Action<InputState>)Delegate.Remove(buttonCombinationBindings[key], action);
			}
		}

		private void UnbindAxis(InputControlType[] axis, Action<InputState> action)
		{
			if (Axis2DBindings.ContainsKey(axis))
			{
				Dictionary<InputControlType[], Action<InputState>> axis2DBindings;
				InputControlType[] key;
				(axis2DBindings = Axis2DBindings)[key = axis] = (Action<InputState>)Delegate.Remove(axis2DBindings[key], action);
			}
		}

		public void Update()
		{
			CheckAxisBindings();
			CheckButtonBindings();
			CheckButtonCombinationBindings();
		}

		private void CheckButtonBindings()
		{
			buttonsActions.Clear();
			foreach (KeyValuePair<InputControlType, Action<InputState>> buttonBinding in ButtonBindings)
			{
				InputState buttonInputState = GetButtonInputState(buttonBinding.Key);
				if (buttonInputState != 0 && buttonBinding.Value != null && !buttonsActions.ContainsKey(buttonBinding.Value))
				{
					buttonsActions.Add(buttonBinding.Value, buttonInputState);
				}
			}
			foreach (KeyValuePair<Action<InputState>, InputState> buttonsAction in buttonsActions)
			{
				buttonsAction.Key(buttonsAction.Value);
			}
		}

		private void CheckAxisBindings()
		{
			axisActions.Clear();
			int num = 0;
			foreach (KeyValuePair<InputControlType[], Action<InputState>> axis2DBinding in Axis2DBindings)
			{
				InputState axis2DInputState = GetAxis2DInputState(axis2DBinding.Key, PreviousAxis2DState[num]);
				PreviousAxis2DState[num++] = axis2DInputState;
				if (axis2DInputState != 0 && axis2DBinding.Value != null && !axisActions.ContainsKey(axis2DBinding.Value))
				{
					axisActions.Add(axis2DBinding.Value, axis2DInputState);
				}
			}
			foreach (KeyValuePair<Action<InputState>, InputState> axisAction in axisActions)
			{
				axisAction.Key(axisAction.Value);
			}
		}

		private void CheckButtonCombinationBindings()
		{
			buttonCombinationActions.Clear();
			foreach (KeyValuePair<InputControlType[], Action<InputState>> buttonCombinationBinding in ButtonCombinationBindings)
			{
				InputControlType[] key = buttonCombinationBinding.Key;
				InputState buttonInputState = GetButtonInputState(key[0]);
				InputState buttonInputState2 = GetButtonInputState(key[1]);
				InputState prioritizedInputState = GetPrioritizedInputState(buttonInputState, buttonInputState2);
				if (prioritizedInputState != 0 && buttonCombinationBinding.Value != null && !buttonCombinationActions.ContainsKey(buttonCombinationBinding.Value))
				{
					buttonCombinationActions.Add(buttonCombinationBinding.Value, prioritizedInputState);
				}
			}
			foreach (KeyValuePair<Action<InputState>, InputState> buttonCombinationAction in buttonCombinationActions)
			{
				buttonCombinationAction.Key(buttonCombinationAction.Value);
			}
		}

		private InputState GetButtonInputState(InputControlType button)
		{
			inputDevice = InControl.InputManager.ActiveDevice;
			if (inputDevice.GetControl(button).WasPressed)
			{
				return InputState.Down;
			}
			if (inputDevice.GetControl(button).WasReleased)
			{
				return InputState.Up;
			}
			if ((bool)inputDevice.GetControl(button))
			{
				return InputState.Hold;
			}
			return InputState.None;
		}

		private static InputState GetAxis2DInputState(InputControlType[] axis, InputState prevState)
		{
			InputControl control = InControl.InputManager.ActiveDevice.GetControl(axis[0]);
			InputControl control2 = InControl.InputManager.ActiveDevice.GetControl(axis[1]);
			if ((float)control > 0.5f)
			{
				InputState inputState = InputState.AxisRight;
				if (!prevState.ContainsFlag(inputState))
				{
					inputState |= InputState.Down;
				}
				return inputState;
			}
			if ((float)control < -0.5f)
			{
				InputState inputState2 = InputState.AxisLeft;
				if (!prevState.ContainsFlag(inputState2))
				{
					inputState2 |= InputState.Down;
				}
				return inputState2;
			}
			if ((float)control2 > 0.5f)
			{
				InputState inputState3 = InputState.AxisUp;
				if (!prevState.ContainsFlag(inputState3))
				{
					inputState3 |= InputState.Down;
				}
				return inputState3;
			}
			if ((float)control2 < -0.5f)
			{
				InputState inputState4 = InputState.AxisDown;
				if (!prevState.ContainsFlag(inputState4))
				{
					inputState4 |= InputState.Down;
				}
				return inputState4;
			}
			if (prevState != 0 && prevState != InputState.Up)
			{
				return InputState.Up;
			}
			return InputState.None;
		}

		private InputState GetPrioritizedInputState(InputState state1, InputState state2)
		{
			InputState inputState = state1 | state2;
			if ((InputState.Hold & inputState) != 0)
			{
				return InputState.Hold;
			}
			if ((InputState.Axis & state1) != 0)
			{
				return state1;
			}
			if ((InputState.Axis & state2) != 0)
			{
				return state2;
			}
			if ((InputState.Up & inputState) != 0)
			{
				return InputState.Up;
			}
			if ((InputState.Down & inputState) != 0)
			{
				return InputState.Down;
			}
			return InputState.None;
		}
	}
	public class PlayStationMotionControllerInput : IPlatformInput
	{
		private class ButtonAssociation
		{
			public InputState State;

			public Action<InputState> Action;

			public int ControllerIndex;
		}

		private readonly int PrimaryControllerIndex;

		private readonly int SecondaryControllerIndex = 1;

		private const PlayStationMoveHandler.MoveInput Menu = PlayStationMoveHandler.MoveInput.Select;

		private const PlayStationMoveHandler.MoveInput Recenter = PlayStationMoveHandler.MoveInput.Select;

		private readonly Dictionary<PlayStationMoveHandler.MoveInput, ButtonAssociation>[] ButtonBindings = new Dictionary<PlayStationMoveHandler.MoveInput, ButtonAssociation>[2]
		{
			new Dictionary<PlayStationMoveHandler.MoveInput, ButtonAssociation>(),
			new Dictionary<PlayStationMoveHandler.MoveInput, ButtonAssociation>()
		};

		private const PlayStationMoveHandler.MoveInput Primary = PlayStationMoveHandler.MoveInput.Trigger;

		private const PlayStationMoveHandler.MoveInput Teleport = PlayStationMoveHandler.MoveInput.Move;

		private readonly Dictionary<PlayStationMoveHandler.MoveInput[], ButtonAssociation> ButtonCombinationBindings = new Dictionary<PlayStationMoveHandler.MoveInput[], ButtonAssociation>();

		private readonly Dictionary<PlayStationMoveHandler.MoveInput[], ButtonAssociation>[] Axis2DBindings = new Dictionary<PlayStationMoveHandler.MoveInput[], ButtonAssociation>[2]
		{
			new Dictionary<PlayStationMoveHandler.MoveInput[], ButtonAssociation>(),
			new Dictionary<PlayStationMoveHandler.MoveInput[], ButtonAssociation>()
		};

		private readonly Dictionary<PlayStationMoveHandler.MoveInput, Action<InputState>> ButtonAxisBindings = new Dictionary<PlayStationMoveHandler.MoveInput, Action<InputState>>();

		private readonly PlayStationMoveHandler.MoveInput[] LeftAxis = new PlayStationMoveHandler.MoveInput[1] { PlayStationMoveHandler.MoveInput.Cross };

		private readonly PlayStationMoveHandler.MoveInput[] RightAxis = new PlayStationMoveHandler.MoveInput[1] { PlayStationMoveHandler.MoveInput.Circle };

		private readonly PlayStationMoveHandler.MoveInput[] LeftAxisSecondary = new PlayStationMoveHandler.MoveInput[1] { PlayStationMoveHandler.MoveInput.Square };

		private readonly PlayStationMoveHandler.MoveInput[] RightAxisSecondary = new PlayStationMoveHandler.MoveInput[1] { PlayStationMoveHandler.MoveInput.Triangle };

		private readonly PlayStationMoveHandler.MoveInput[] DownAxis = new PlayStationMoveHandler.MoveInput[1] { PlayStationMoveHandler.MoveInput.Move };

		private readonly PlayStationMoveHandler.MoveInput[] DownAxisSecondary = new PlayStationMoveHandler.MoveInput[1] { PlayStationMoveHandler.MoveInput.Trigger };

		private readonly PlayStationMoveHandler.MoveInput[] Spell1 = new PlayStationMoveHandler.MoveInput[1] { PlayStationMoveHandler.MoveInput.Triangle };

		private readonly PlayStationMoveHandler.MoveInput[] Spell2 = new PlayStationMoveHandler.MoveInput[1] { PlayStationMoveHandler.MoveInput.Circle };

		private readonly PlayStationMoveHandler.MoveInput[] Spell3 = new PlayStationMoveHandler.MoveInput[1] { PlayStationMoveHandler.MoveInput.Cross };

		private readonly PlayStationMoveHandler.MoveInput[] Spell4 = new PlayStationMoveHandler.MoveInput[1] { PlayStationMoveHandler.MoveInput.Square };

		private readonly Dictionary<Action<InputState>, InputState> actionsAxisBindings = new Dictionary<Action<InputState>, InputState>();

		private readonly Dictionary<Action<InputState>, InputState> actionsButtonBindings = new Dictionary<Action<InputState>, InputState>();

		private readonly Dictionary<Action<InputState>, InputState> actionsButtonCombinationBindings = new Dictionary<Action<InputState>, InputState>();

		public bool IsCorrectInputSystem => IsControllerPlugged && IsValidated;

		public bool IsAutoTeleportEnabled
		{
			[CompilerGenerated]
			get
			{
				return false;
			}
		}

		public bool IsControllerPlugged => false;

		public AimInput Aim
		{
			[CompilerGenerated]
			get
			{
				return (PrimaryControllerIndex != 0) ? AimInput.LeftHand : AimInput.RightHand;
			}
		}

		public WandInput WandInput
		{
			[CompilerGenerated]
			get
			{
				return WandInput.Move;
			}
		}

		public bool IsValidated { get; set; } = true;


		public PlayStationMotionControllerInput(int primaryControllerIndex)
		{
			PrimaryControllerIndex = primaryControllerIndex;
			SecondaryControllerIndex = ((PrimaryControllerIndex == 0) ? 1 : 0);
		}

		public void BindActions(IInputListener listener)
		{
			BindButton(PlayStationMoveHandler.MoveInput.Select, PrimaryControllerIndex, listener.OnRecenterInput);
			BindButton(PlayStationMoveHandler.MoveInput.Select, SecondaryControllerIndex, listener.OnMenuInput);
			Level currentLevel = GameControl.Instance.GetCurrentLevel();
			Action<InputState> action;
			if (currentLevel == Level.Workshop || currentLevel == Level.Lobby)
			{
				BindButton(PlayStationMoveHandler.MoveInput.Trigger, PrimaryControllerIndex, listener.OnPrimaryInput);
				BindButton(PlayStationMoveHandler.MoveInput.Move, PrimaryControllerIndex, listener.OnPrimaryInput);
			}
			else
			{
				BindButton(PlayStationMoveHandler.MoveInput.Trigger, PrimaryControllerIndex, listener.OnTeleportInput);
				int primaryControllerIndex = PrimaryControllerIndex;
				action = delegate(InputState state)
				{
					if (GameControl.Instance?.IsGamePaused == true || MonoSingleton<ArenaUI>.Instance?.Menu.IsMenuActive == true)
					{
						listener.OnPrimaryInput(state);
					}
					else
					{
						listener.OnTeleportInput(state);
					}
				};
				ButtonAxisBindings[PlayStationMoveHandler.MoveInput.Move] = action;
				BindButton(PlayStationMoveHandler.MoveInput.Move, primaryControllerIndex, action);
			}
			BindAxis(LeftAxis, SecondaryControllerIndex, InputState.AxisLeft, listener.OnSecondaryAxisInput);
			BindAxis(RightAxis, SecondaryControllerIndex, InputState.AxisRight, listener.OnSecondaryAxisInput);
			BindAxis(LeftAxisSecondary, SecondaryControllerIndex, InputState.AxisLeft, listener.OnSecondaryAxisInput);
			BindAxis(RightAxisSecondary, SecondaryControllerIndex, InputState.AxisRight, listener.OnSecondaryAxisInput);
			BindAxis(DownAxis, SecondaryControllerIndex, InputState.AxisDown, listener.OnSecondaryAxisInput);
			BindAxis(DownAxisSecondary, SecondaryControllerIndex, InputState.AxisDown, listener.OnSecondaryAxisInput);
			if (listener is MainMenuInputListener)
			{
				BindButton(PlayStationMoveHandler.MoveInput.Trigger, PrimaryControllerIndex, listener.OnPrimaryInput);
				BindButton(PlayStationMoveHandler.MoveInput.Move, PrimaryControllerIndex, listener.OnPrimaryInput);
				BindButton(PlayStationMoveHandler.MoveInput.Cross, PrimaryControllerIndex, listener.OnPrimaryInput);
				BindButton(PlayStationMoveHandler.MoveInput.Square, PrimaryControllerIndex, listener.OnPrimaryInput);
				BindButton(PlayStationMoveHandler.MoveInput.Circle, PrimaryControllerIndex, listener.OnPrimaryInput);
				BindButton(PlayStationMoveHandler.MoveInput.Triangle, PrimaryControllerIndex, listener.OnPrimaryInput);
				BindButton(PlayStationMoveHandler.MoveInput.Select, PrimaryControllerIndex, listener.OnPrimaryInput);
				BindButton(Spell1[0], PrimaryControllerIndex, listener.OnPrimaryInput);
				BindButton(Spell2[0], PrimaryControllerIndex, listener.OnPrimaryInput);
				BindButton(Spell3[0], PrimaryControllerIndex, listener.OnPrimaryInput);
				BindButton(Spell4[0], PrimaryControllerIndex, listener.OnPrimaryInput);
				return;
			}
			PlayStationMoveHandler.MoveInput button = Spell1[0];
			int primaryControllerIndex2 = PrimaryControllerIndex;
			action = delegate(InputState state)
			{
				listener.OnPrimaryAxisInput(((state != InputState.Up) ? InputState.AxisUp : InputState.None) | state);
				listener.OnPrimaryInput(state);
			};
			ButtonAxisBindings[PlayStationMoveHandler.MoveInput.Triangle] = action;
			BindButton(button, primaryControllerIndex2, action);
			PlayStationMoveHandler.MoveInput button2 = Spell2[0];
			int primaryControllerIndex3 = PrimaryControllerIndex;
			action = delegate(InputState state)
			{
				listener.OnPrimaryAxisInput(((state != InputState.Up) ? InputState.AxisRight : InputState.None) | state);
				listener.OnPrimaryInput(state);
			};
			ButtonAxisBindings[PlayStationMoveHandler.MoveInput.Circle] = action;
			BindButton(button2, primaryControllerIndex3, action);
			PlayStationMoveHandler.MoveInput button3 = Spell3[0];
			int primaryControllerIndex4 = PrimaryControllerIndex;
			action = delegate(InputState state)
			{
				listener.OnPrimaryAxisInput(((state != InputState.Up) ? InputState.AxisDown : InputState.None) | state);
				listener.OnPrimaryInput(state);
			};
			ButtonAxisBindings[PlayStationMoveHandler.MoveInput.Cross] = action;
			BindButton(button3, primaryControllerIndex4, action);
			PlayStationMoveHandler.MoveInput button4 = Spell4[0];
			int primaryControllerIndex5 = PrimaryControllerIndex;
			action = delegate(InputState state)
			{
				listener.OnPrimaryAxisInput(((state != InputState.Up) ? InputState.AxisLeft : InputState.None) | state);
				listener.OnPrimaryInput(state);
			};
			ButtonAxisBindings[PlayStationMoveHandler.MoveInput.Square] = action;
			BindButton(button4, primaryControllerIndex5, action);
		}

		public void UnbindActions(IInputListener listener)
		{
			UnbindButton(PlayStationMoveHandler.MoveInput.Select, PrimaryControllerIndex, listener.OnMenuInput);
			UnbindButton(PlayStationMoveHandler.MoveInput.Select, PrimaryControllerIndex, listener.OnRecenterInput);
			Level currentLevel = GameControl.Instance.GetCurrentLevel();
			if (currentLevel == Level.Workshop || currentLevel == Level.Lobby)
			{
				UnbindButton(PlayStationMoveHandler.MoveInput.Trigger, PrimaryControllerIndex, listener.OnPrimaryInput);
				UnbindButton(PlayStationMoveHandler.MoveInput.Move, PrimaryControllerIndex, listener.OnPrimaryInput);
			}
			else
			{
				UnbindButton(PlayStationMoveHandler.MoveInput.Trigger, PrimaryControllerIndex, listener.OnTeleportInput);
				UnbindButton(PlayStationMoveHandler.MoveInput.Move, PrimaryControllerIndex, ButtonAxisBindings[PlayStationMoveHandler.MoveInput.Move]);
			}
			UnbindAxis(LeftAxis, SecondaryControllerIndex, listener.OnSecondaryAxisInput);
			UnbindAxis(RightAxis, SecondaryControllerIndex, listener.OnSecondaryAxisInput);
			UnbindAxis(LeftAxisSecondary, SecondaryControllerIndex, listener.OnSecondaryAxisInput);
			UnbindAxis(RightAxisSecondary, SecondaryControllerIndex, listener.OnSecondaryAxisInput);
			UnbindAxis(DownAxis, SecondaryControllerIndex, listener.OnSecondaryAxisInput);
			UnbindAxis(DownAxisSecondary, SecondaryControllerIndex, listener.OnSecondaryAxisInput);
			if (listener is MainMenuInputListener)
			{
				UnbindButton(PlayStationMoveHandler.MoveInput.Trigger, PrimaryControllerIndex, listener.OnPrimaryInput);
				UnbindButton(PlayStationMoveHandler.MoveInput.Move, PrimaryControllerIndex, listener.OnPrimaryInput);
				UnbindButton(PlayStationMoveHandler.MoveInput.Cross, PrimaryControllerIndex, listener.OnPrimaryInput);
				UnbindButton(PlayStationMoveHandler.MoveInput.Square, PrimaryControllerIndex, listener.OnPrimaryInput);
				UnbindButton(PlayStationMoveHandler.MoveInput.Circle, PrimaryControllerIndex, listener.OnPrimaryInput);
				UnbindButton(PlayStationMoveHandler.MoveInput.Triangle, PrimaryControllerIndex, listener.OnPrimaryInput);
				UnbindButton(PlayStationMoveHandler.MoveInput.Select, PrimaryControllerIndex, listener.OnPrimaryInput);
				UnbindButton(Spell1[0], PrimaryControllerIndex, listener.OnPrimaryInput);
				UnbindButton(Spell2[0], PrimaryControllerIndex, listener.OnPrimaryInput);
				UnbindButton(Spell3[0], PrimaryControllerIndex, listener.OnPrimaryInput);
				UnbindButton(Spell4[0], PrimaryControllerIndex, listener.OnPrimaryInput);
			}
			else
			{
				UnbindButton(Spell1[0], PrimaryControllerIndex, ButtonAxisBindings[PlayStationMoveHandler.MoveInput.Triangle]);
				UnbindButton(Spell2[0], PrimaryControllerIndex, ButtonAxisBindings[PlayStationMoveHandler.MoveInput.Circle]);
				UnbindButton(Spell3[0], PrimaryControllerIndex, ButtonAxisBindings[PlayStationMoveHandler.MoveInput.Cross]);
				UnbindButton(Spell4[0], PrimaryControllerIndex, ButtonAxisBindings[PlayStationMoveHandler.MoveInput.Square]);
			}
		}

		private void BindButton(PlayStationMoveHandler.MoveInput button, int controllerIndex, Action<InputState> action)
		{
			if (ButtonBindings[controllerIndex].ContainsKey(button))
			{
				ButtonAssociation buttonAssociation = ButtonBindings[controllerIndex][button];
				buttonAssociation.Action = (Action<InputState>)Delegate.Combine(buttonAssociation.Action, action);
			}
			else
			{
				ButtonBindings[controllerIndex].Add(button, new ButtonAssociation
				{
					Action = action,
					ControllerIndex = controllerIndex
				});
			}
		}

		private void BindButtonCombination(PlayStationMoveHandler.MoveInput[] buttonCombination, int controllerIndex, Action<InputState> action)
		{
			if (ButtonCombinationBindings.ContainsKey(buttonCombination) && ButtonCombinationBindings[buttonCombination].ControllerIndex == controllerIndex)
			{
				ButtonAssociation buttonAssociation = ButtonCombinationBindings[buttonCombination];
				buttonAssociation.Action = (Action<InputState>)Delegate.Combine(buttonAssociation.Action, action);
			}
			else
			{
				ButtonCombinationBindings.Add(buttonCombination, new ButtonAssociation
				{
					Action = action,
					ControllerIndex = controllerIndex
				});
			}
		}

		private void BindAxis(PlayStationMoveHandler.MoveInput[] axis, int controllerIndex, InputState matchingState, Action<InputState> action)
		{
			if (Axis2DBindings[controllerIndex].ContainsKey(axis))
			{
				ButtonAssociation buttonAssociation = Axis2DBindings[controllerIndex][axis];
				buttonAssociation.Action = (Action<InputState>)Delegate.Combine(buttonAssociation.Action, action);
				return;
			}
			Axis2DBindings[controllerIndex].Add(axis, new ButtonAssociation
			{
				Action = action,
				State = matchingState,
				ControllerIndex = controllerIndex
			});
		}

		private void UnbindButton(PlayStationMoveHandler.MoveInput button, int controllerIndex, Action<InputState> action)
		{
			if (ButtonBindings[controllerIndex].ContainsKey(button))
			{
				ButtonAssociation buttonAssociation = ButtonBindings[controllerIndex][button];
				buttonAssociation.Action = (Action<InputState>)Delegate.Remove(buttonAssociation.Action, action);
			}
		}

		private void UnbindButtonCombination(PlayStationMoveHandler.MoveInput[] buttonCombination, int controllerIndex, Action<InputState> action)
		{
			if (ButtonCombinationBindings.ContainsKey(buttonCombination) && ButtonCombinationBindings[buttonCombination].ControllerIndex == controllerIndex)
			{
				ButtonAssociation buttonAssociation = ButtonCombinationBindings[buttonCombination];
				buttonAssociation.Action = (Action<InputState>)Delegate.Remove(buttonAssociation.Action, action);
			}
		}

		private void UnbindAxis(PlayStationMoveHandler.MoveInput[] axis, int controllerIndex, Action<InputState> action)
		{
			if (Axis2DBindings[controllerIndex].ContainsKey(axis))
			{
				ButtonAssociation buttonAssociation = Axis2DBindings[controllerIndex][axis];
				buttonAssociation.Action = (Action<InputState>)Delegate.Remove(buttonAssociation.Action, action);
			}
		}

		public void Update()
		{
			CheckAxisBindings();
			CheckButtonBindings();
			CheckButtonCombinationBindings();
		}

		private void CheckButtonBindings()
		{
			actionsButtonBindings.Clear();
			for (int i = 0; i < ButtonBindings.Length; i++)
			{
				foreach (KeyValuePair<PlayStationMoveHandler.MoveInput, ButtonAssociation> item in ButtonBindings[i])
				{
					InputState buttonInputState = PlayStationMoveHandler.GetButtonInputState(item.Key, item.Value.ControllerIndex);
					if (buttonInputState != 0 && item.Value != null && !actionsButtonBindings.ContainsKey(item.Value.Action))
					{
						actionsButtonBindings.Add(item.Value.Action, buttonInputState);
					}
				}
			}
			foreach (KeyValuePair<Action<InputState>, InputState> actionsButtonBinding in actionsButtonBindings)
			{
				actionsButtonBinding.Key(actionsButtonBinding.Value);
			}
		}

		private void CheckButtonCombinationBindings()
		{
			actionsButtonCombinationBindings.Clear();
			foreach (KeyValuePair<PlayStationMoveHandler.MoveInput[], ButtonAssociation> buttonCombinationBinding in ButtonCombinationBindings)
			{
				PlayStationMoveHandler.MoveInput[] key = buttonCombinationBinding.Key;
				InputState buttonInputState = PlayStationMoveHandler.GetButtonInputState(key[0], buttonCombinationBinding.Value.ControllerIndex);
				InputState buttonInputState2 = PlayStationMoveHandler.GetButtonInputState(key[1], buttonCombinationBinding.Value.ControllerIndex);
				InputState inputState = GetPrioritizedInputState(buttonInputState, buttonInputState2) | InputState.Axis;
				if (inputState != 0 && buttonCombinationBinding.Value != null && !actionsButtonCombinationBindings.ContainsKey(buttonCombinationBinding.Value.Action))
				{
					actionsButtonCombinationBindings.Add(buttonCombinationBinding.Value.Action, inputState);
				}
			}
			foreach (KeyValuePair<Action<InputState>, InputState> actionsButtonCombinationBinding in actionsButtonCombinationBindings)
			{
				actionsButtonCombinationBinding.Key(actionsButtonCombinationBinding.Value);
			}
		}

		private void CheckAxisBindings()
		{
			actionsAxisBindings.Clear();
			for (int i = 0; i < Axis2DBindings.Length; i++)
			{
				foreach (KeyValuePair<PlayStationMoveHandler.MoveInput[], ButtonAssociation> item in Axis2DBindings[i])
				{
					PlayStationMoveHandler.MoveInput[] key = item.Key;
					InputState buttonInputState = PlayStationMoveHandler.GetButtonInputState(key[0], item.Value.ControllerIndex);
					InputState inputState = buttonInputState;
					if (key.Length > 1)
					{
						InputState buttonInputState2 = PlayStationMoveHandler.GetButtonInputState(key[1], item.Value.ControllerIndex);
						inputState = GetPrioritizedInputState(buttonInputState, buttonInputState2);
					}
					if (inputState != 0 && item.Value != null && !actionsAxisBindings.ContainsKey(item.Value.Action))
					{
						inputState |= item.Value.State;
						actionsAxisBindings.Add(item.Value.Action, inputState);
					}
				}
			}
			foreach (KeyValuePair<Action<InputState>, InputState> actionsAxisBinding in actionsAxisBindings)
			{
				actionsAxisBinding.Key(actionsAxisBinding.Value);
			}
		}

		private InputState GetPrioritizedInputState(InputState state1, InputState state2)
		{
			InputState flag = state1 | state2;
			if (InputState.Hold.ContainsFlag(flag))
			{
				return InputState.Hold;
			}
			if (InputState.Axis.ContainsFlag(state1))
			{
				return state1;
			}
			if (InputState.Axis.ContainsFlag(state2))
			{
				return state2;
			}
			if (InputState.Up.ContainsFlag(flag))
			{
				return InputState.Up;
			}
			if (InputState.Down.ContainsFlag(flag))
			{
				return InputState.Down;
			}
			return InputState.None;
		}
	}
}
namespace Cortopia.Scripts.WandsInput
{
	public static class PlayStationMoveHandler
	{
		[Flags]
		public enum MoveInput
		{
			Trigger = 2,
			Move = 4,
			Select = 8,
			Triangle = 0x10,
			Circle = 0x20,
			Cross = 0x40,
			Square = 0x80
		}

		private static readonly Dictionary<MoveInput, InputState>[] PrevButton = new Dictionary<MoveInput, InputState>[2]
		{
			new Dictionary<MoveInput, InputState>
			{
				{
					MoveInput.Trigger,
					InputState.None
				},
				{
					MoveInput.Move,
					InputState.None
				},
				{
					MoveInput.Select,
					InputState.None
				},
				{
					MoveInput.Triangle,
					InputState.None
				},
				{
					MoveInput.Circle,
					InputState.None
				},
				{
					MoveInput.Square,
					InputState.None
				},
				{
					MoveInput.Cross,
					InputState.None
				}
			},
			new Dictionary<MoveInput, InputState>
			{
				{
					MoveInput.Trigger,
					InputState.None
				},
				{
					MoveInput.Move,
					InputState.None
				},
				{
					MoveInput.Select,
					InputState.None
				},
				{
					MoveInput.Triangle,
					InputState.None
				},
				{
					MoveInput.Circle,
					InputState.None
				},
				{
					MoveInput.Square,
					InputState.None
				},
				{
					MoveInput.Cross,
					InputState.None
				}
			}
		};

		private static readonly Dictionary<MoveInput, InputState>[] PrevButtonBuffered = new Dictionary<MoveInput, InputState>[2]
		{
			new Dictionary<MoveInput, InputState>
			{
				{
					MoveInput.Trigger,
					InputState.None
				},
				{
					MoveInput.Move,
					InputState.None
				},
				{
					MoveInput.Select,
					InputState.None
				},
				{
					MoveInput.Triangle,
					InputState.None
				},
				{
					MoveInput.Circle,
					InputState.None
				},
				{
					MoveInput.Square,
					InputState.None
				},
				{
					MoveInput.Cross,
					InputState.None
				}
			},
			new Dictionary<MoveInput, InputState>
			{
				{
					MoveInput.Trigger,
					InputState.None
				},
				{
					MoveInput.Move,
					InputState.None
				},
				{
					MoveInput.Select,
					InputState.None
				},
				{
					MoveInput.Triangle,
					InputState.None
				},
				{
					MoveInput.Circle,
					InputState.None
				},
				{
					MoveInput.Square,
					InputState.None
				},
				{
					MoveInput.Cross,
					InputState.None
				}
			}
		};

		public static void Flush()
		{
			foreach (KeyValuePair<MoveInput, InputState> item in PrevButtonBuffered[0])
			{
				PrevButton[0][item.Key] = item.Value;
			}
			foreach (KeyValuePair<MoveInput, InputState> item2 in PrevButtonBuffered[1])
			{
				PrevButton[1][item2.Key] = item2.Value;
			}
		}

		public static bool GetButtonInputStateRaw(MoveInput bindingKey, int controllerIndex)
		{
			MoveInput moveInput = (MoveInput)0;
			return (bindingKey & moveInput) != 0;
		}

		public static InputState GetButtonInputState(MoveInput bindingKey, int controllerIndex)
		{
			return InputState.None;
		}

		public static InputState GetButtonInputState(MoveInput[] bindingKeys, int controllerIndex)
		{
			InputState inputState = InputState.None;
			foreach (MoveInput bindingKey in bindingKeys)
			{
				inputState |= GetButtonInputState(bindingKey, controllerIndex);
			}
			if ((inputState & InputState.Hold) != 0)
			{
				return InputState.Hold;
			}
			return ((inputState & InputState.Down) != 0) ? InputState.Down : inputState;
		}
	}
	public abstract class SteamInput : IPlatformInputTwoWands, IPauseListenerInput<SteamVR_Action_Boolean>, IPlatformInput
	{
		protected readonly SteamVR_Action_Boolean m_indexLeft = SteamVR_Actions.Wands.IndexLeft;

		protected readonly SteamVR_Action_Boolean m_indexRight = SteamVR_Actions.Wands.IndexRight;

		protected readonly SteamVR_Action_Boolean m_grabLeft = SteamVR_Actions.Wands.GrabLeft;

		protected readonly SteamVR_Action_Boolean m_grabRight = SteamVR_Actions.Wands.GrabRight;

		protected readonly SteamVR_Action_Boolean m_menuButton = SteamVR_Actions.Wands.Menu;

		protected readonly SteamVR_Action_Boolean m_buttonLeft01 = SteamVR_Actions.Wands.ButtonLeft01;

		protected readonly SteamVR_Action_Boolean m_buttonLeft02 = SteamVR_Actions.Wands.ButtonLeft02;

		protected readonly SteamVR_Action_Boolean m_buttonRight01 = SteamVR_Actions.Wands.ButtonRight01;

		protected readonly SteamVR_Action_Boolean m_buttonRight02 = SteamVR_Actions.Wands.ButtonRight02;

		protected readonly SteamVR_Action_Vector2 m_leftThumbstick = SteamVR_Actions.Wands.ThumbstickLeft;

		protected readonly SteamVR_Action_Vector2 m_rightThumbstick = SteamVR_Actions.Wands.ThumbstickRight;

		private const float Half = 0.5f;

		private readonly StringBuilder m_inputStringBuilder = new StringBuilder(32);

		private readonly StringBuilder m_compareInputStringBuilder = new StringBuilder(32);

		private readonly InputState[] m_prevAxis = new InputState[2];

		private readonly Dictionary<SteamVR_Action_Vector2, Action<InputState>> m_axisBindings = new Dictionary<SteamVR_Action_Vector2, Action<InputState>>(2);

		private readonly Dictionary<Action<InputState>, InputState> m_actions = new Dictionary<Action<InputState>, InputState>(2);

		protected Valve.VR.ETrackedControllerRole m_primaryController;

		private InputPauseListener<SteamVR_Action_Boolean> m_inputPauseListener;

		public bool IsCorrectInputSystem
		{
			[CompilerGenerated]
			get
			{
				return IsControllerConnected();
			}
		}

		public bool IsAutoTeleportEnabled
		{
			[CompilerGenerated]
			get
			{
				return false;
			}
		}

		public AimInput Aim { get; private set; }

		public WandInput WandInput
		{
			[CompilerGenerated]
			get
			{
				return WandInput.Stick;
			}
		}

		public Dictionary<SteamVR_Action_Boolean, Action<InputState>> ButtonBindings { get; } = new Dictionary<SteamVR_Action_Boolean, Action<InputState>>(8);


		public SteamInput(Valve.VR.ETrackedControllerRole primaryController, StringBuilder inputStringBuilder)
		{
			m_primaryController = primaryController;
			Aim = ((primaryController != Valve.VR.ETrackedControllerRole.LeftHand) ? AimInput.RightHand : AimInput.LeftHand);
			m_inputPauseListener = new InputPauseListener<SteamVR_Action_Boolean>(this);
			m_inputStringBuilder = inputStringBuilder;
		}

		public void BindActions(IInputListener listener)
		{
			if (GameControl.Instance.IsCurrentLevel(Level.MainMenu))
			{
				if (m_primaryController == Valve.VR.ETrackedControllerRole.RightHand)
				{
					BindButton(m_indexRight, listener.OnPrimaryInput);
					BindButton(m_grabRight, listener.OnPrimaryInput);
					BindAxis(m_leftThumbstick, listener.OnSecondaryAxisInput);
					BindAxis(m_rightThumbstick, listener.OnPrimaryAxisInput);
				}
				else
				{
					BindButton(m_indexLeft, listener.OnPrimaryInput);
					BindButton(m_grabLeft, listener.OnPrimaryInput);
					BindAxis(m_leftThumbstick, listener.OnPrimaryAxisInput);
					BindAxis(m_rightThumbstick, listener.OnSecondaryAxisInput);
				}
			}
			else
			{
				BindDefaultActions(listener);
			}
		}

		public void UnbindActions(IInputListener listener)
		{
			if (GameControl.Instance.IsCurrentLevel(Level.MainMenu))
			{
				if (m_primaryController == Valve.VR.ETrackedControllerRole.RightHand)
				{
					UnbindButton(m_indexRight, listener.OnPrimaryInput);
					UnbindButton(m_grabRight, listener.OnPrimaryInput);
					UnbindAxis(m_leftThumbstick, listener.OnSecondaryAxisInput);
					UnbindAxis(m_rightThumbstick, listener.OnPrimaryAxisInput);
				}
				else
				{
					UnbindButton(m_indexLeft, listener.OnPrimaryInput);
					UnbindButton(m_grabLeft, listener.OnPrimaryInput);
					UnbindAxis(m_leftThumbstick, listener.OnPrimaryAxisInput);
					UnbindAxis(m_rightThumbstick, listener.OnSecondaryAxisInput);
				}
			}
			else
			{
				UnbindDefaultActions(listener);
			}
		}

		public abstract void BindDefaultActions(IInputListener listener);

		public abstract void UnbindDefaultActions(IInputListener listener);

		public abstract void BindSpellButtonActions(IInputListenerTwoWands listener);

		public abstract void UnbindSpellButtonActions(IInputListenerTwoWands listener);

		public void Update()
		{
			CheckButtonBindings();
			CheckAxisBindings();
		}

		protected void BindButton(SteamVR_Action_Boolean button, Action<InputState> action)
		{
			if (ButtonBindings.ContainsKey(button))
			{
				Dictionary<SteamVR_Action_Boolean, Action<InputState>> buttonBindings;
				SteamVR_Action_Boolean key;
				(buttonBindings = ButtonBindings)[key = button] = (Action<InputState>)Delegate.Combine(buttonBindings[key], action);
			}
			else
			{
				ButtonBindings.Add(button, action);
			}
		}

		protected void UnbindButton(SteamVR_Action_Boolean button, Action<InputState> action)
		{
			if (ButtonBindings.ContainsKey(button))
			{
				Dictionary<SteamVR_Action_Boolean, Action<InputState>> buttonBindings;
				SteamVR_Action_Boolean key;
				(buttonBindings = ButtonBindings)[key = button] = (Action<InputState>)Delegate.Remove(buttonBindings[key], action);
			}
		}

		protected void BindAxis(SteamVR_Action_Vector2 axis, Action<InputState> action)
		{
			if (m_axisBindings.ContainsKey(axis))
			{
				Dictionary<SteamVR_Action_Vector2, Action<InputState>> axisBindings;
				SteamVR_Action_Vector2 key;
				(axisBindings = m_axisBindings)[key = axis] = (Action<InputState>)Delegate.Combine(axisBindings[key], action);
			}
			else
			{
				m_axisBindings.Add(axis, action);
			}
		}

		protected void UnbindAxis(SteamVR_Action_Vector2 axis, Action<InputState> action)
		{
			if (m_axisBindings.ContainsKey(axis))
			{
				Dictionary<SteamVR_Action_Vector2, Action<InputState>> axisBindings;
				SteamVR_Action_Vector2 key;
				(axisBindings = m_axisBindings)[key = axis] = (Action<InputState>)Delegate.Remove(axisBindings[key], action);
			}
		}

		private void CheckButtonBindings()
		{
			m_actions.Clear();
			foreach (KeyValuePair<SteamVR_Action_Boolean, Action<InputState>> buttonBinding in ButtonBindings)
			{
				InputState buttonInputState = GetButtonInputState(buttonBinding.Key);
				if (buttonInputState != 0 && buttonBinding.Value != null && !m_actions.ContainsKey(buttonBinding.Value))
				{
					m_actions.Add(buttonBinding.Value, buttonInputState);
				}
			}
			foreach (KeyValuePair<Action<InputState>, InputState> action in m_actions)
			{
				action.Key(action.Value);
			}
		}

		private void CheckAxisBindings()
		{
			m_actions.Clear();
			int num = 0;
			foreach (KeyValuePair<SteamVR_Action_Vector2, Action<InputState>> axisBinding in m_axisBindings)
			{
				InputState axisInputState = GetAxisInputState(axisBinding.Key, m_prevAxis[num]);
				m_prevAxis[num++] = axisInputState;
				if (axisInputState != 0 && axisBinding.Value != null && !m_actions.ContainsKey(axisBinding.Value))
				{
					m_actions.Add(axisBinding.Value, axisInputState);
				}
			}
			foreach (KeyValuePair<Action<InputState>, InputState> action in m_actions)
			{
				action.Key(action.Value);
			}
		}

		public InputState GetButtonInputState(SteamVR_Action_Boolean button)
		{
			if (button.stateDown)
			{
				return InputState.Down;
			}
			if (button.stateUp)
			{
				return InputState.Up;
			}
			if (button.state)
			{
				return InputState.Hold;
			}
			return InputState.None;
		}

		private InputState GetAxisInputState(SteamVR_Action_Vector2 axis, InputState prevState)
		{
			Vector2 axis2 = axis.axis;
			if (axis2.x > 0.5f)
			{
				InputState inputState = InputState.AxisRight;
				if (!prevState.ContainsFlag(inputState))
				{
					inputState |= InputState.Down;
				}
				return inputState;
			}
			if (axis2.x < -0.5f)
			{
				InputState inputState2 = InputState.AxisLeft;
				if (!prevState.ContainsFlag(inputState2))
				{
					inputState2 |= InputState.Down;
				}
				return inputState2;
			}
			if (axis2.y > 0.5f)
			{
				InputState inputState3 = InputState.AxisUp;
				if (!prevState.ContainsFlag(inputState3))
				{
					inputState3 |= InputState.Down;
				}
				return inputState3;
			}
			if (axis2.y < -0.5f)
			{
				InputState inputState4 = InputState.AxisDown;
				if (!prevState.ContainsFlag(inputState4))
				{
					inputState4 |= InputState.Down;
				}
				return inputState4;
			}
			if (prevState != 0 && prevState != InputState.Up)
			{
				return InputState.Up;
			}
			return InputState.None;
		}

		private bool IsControllerConnected()
		{
			Valve.VR.ETrackedPropertyError pError = Valve.VR.ETrackedPropertyError.TrackedProp_Success;
			m_compareInputStringBuilder.Clear();
			Valve.VR.OpenVR.System.GetStringTrackedDeviceProperty(Valve.VR.OpenVR.System.GetTrackedDeviceIndexForControllerRole(Valve.VR.ETrackedControllerRole.RightHand), Valve.VR.ETrackedDeviceProperty.Prop_ControllerType_String, m_compareInputStringBuilder, 1024u, ref pError);
			if (m_compareInputStringBuilder.Equals(m_inputStringBuilder))
			{
				return true;
			}
			m_compareInputStringBuilder.Clear();
			Valve.VR.OpenVR.System.GetStringTrackedDeviceProperty(Valve.VR.OpenVR.System.GetTrackedDeviceIndexForControllerRole(Valve.VR.ETrackedControllerRole.LeftHand), Valve.VR.ETrackedDeviceProperty.Prop_ControllerType_String, m_compareInputStringBuilder, 1024u, ref pError);
			if (m_compareInputStringBuilder.Equals(m_inputStringBuilder))
			{
				return true;
			}
			return false;
		}
	}
	public class ViveControllerInput : SteamInput
	{
		public ViveControllerInput(Valve.VR.ETrackedControllerRole primaryController, StringBuilder inputStringBuilder)
			: base(primaryController, inputStringBuilder)
		{
		}

		public override void BindDefaultActions(IInputListener listener)
		{
			BindButton(m_menuButton, listener.OnMenuInput);
			BindButton(m_grabRight, listener.OnRecenterInput);
			BindButton(m_grabLeft, listener.OnReverseInput);
			if (listener is IInputListenerTwoWands listener2)
			{
				BindAxis(m_leftThumbstick, listener.OnSecondaryAxisInput);
				BindAxis(m_rightThumbstick, listener.OnSecondaryAxisInput);
				BindSpellButtonActions(listener2);
			}
			else if (m_primaryController == Valve.VR.ETrackedControllerRole.RightHand)
			{
				BindButton(m_indexRight, listener.OnPrimaryInput);
				BindButton(m_indexLeft, listener.OnTeleportInput);
				BindAxis(m_rightThumbstick, listener.OnPrimaryAxisInput);
				BindAxis(m_leftThumbstick, listener.OnSecondaryAxisInput);
			}
			else
			{
				BindButton(m_indexLeft, listener.OnPrimaryInput);
				BindButton(m_indexRight, listener.OnTeleportInput);
				BindAxis(m_leftThumbstick, listener.OnPrimaryAxisInput);
				BindAxis(m_rightThumbstick, listener.OnSecondaryAxisInput);
			}
		}

		public override void BindSpellButtonActions(IInputListenerTwoWands listener)
		{
			BindButton(m_indexLeft, listener.OnInteractionLeftInput);
			BindButton(m_indexRight, listener.OnInteractionInput);
			BindButton(m_indexLeft, listener.OnAutoTeleportLeftInput);
			BindButton(m_indexRight, listener.OnAutoTeleportRightInput);
			BindButton(m_buttonLeft01, listener.OnSpellInput01);
			BindButton(m_buttonLeft02, listener.OnSpellInput02);
			BindButton(m_buttonRight01, listener.OnSpellInput03);
			BindButton(m_buttonRight02, listener.OnSpellInput04);
		}

		public override void UnbindDefaultActions(IInputListener listener)
		{
			UnbindButton(m_menuButton, listener.OnMenuInput);
			UnbindButton(m_grabRight, listener.OnRecenterInput);
			UnbindButton(m_grabLeft, listener.OnReverseInput);
			if (listener is IInputListenerTwoWands listener2)
			{
				UnbindAxis(m_leftThumbstick, listener.OnSecondaryAxisInput);
				UnbindAxis(m_rightThumbstick, listener.OnSecondaryAxisInput);
				UnbindSpellButtonActions(listener2);
			}
			else if (m_primaryController == Valve.VR.ETrackedControllerRole.RightHand)
			{
				UnbindButton(m_indexRight, listener.OnPrimaryInput);
				UnbindButton(m_indexLeft, listener.OnTeleportInput);
				UnbindAxis(m_rightThumbstick, listener.OnPrimaryAxisInput);
				UnbindAxis(m_leftThumbstick, listener.OnSecondaryAxisInput);
			}
			else
			{
				UnbindButton(m_indexLeft, listener.OnPrimaryInput);
				UnbindButton(m_indexRight, listener.OnTeleportInput);
				UnbindAxis(m_leftThumbstick, listener.OnPrimaryAxisInput);
				UnbindAxis(m_rightThumbstick, listener.OnSecondaryAxisInput);
			}
		}

		public override void UnbindSpellButtonActions(IInputListenerTwoWands listener)
		{
			UnbindButton(m_indexLeft, listener.OnInteractionLeftInput);
			UnbindButton(m_indexRight, listener.OnInteractionInput);
			UnbindButton(m_indexLeft, listener.OnAutoTeleportLeftInput);
			UnbindButton(m_indexRight, listener.OnAutoTeleportRightInput);
			UnbindButton(m_buttonLeft01, listener.OnSpellInput01);
			UnbindButton(m_buttonLeft02, listener.OnSpellInput02);
			UnbindButton(m_buttonRight01, listener.OnSpellInput03);
			UnbindButton(m_buttonRight02, listener.OnSpellInput04);
		}
	}
}
namespace Assets.Scripts.WandsInput
{
	public class WandsDebugInput : MonoBehaviour
	{
	}
	public class WandsInputManager
	{
		private IPlatformInput m_platformInput;

		private IInputListener m_inputListener;

		public bool IsInputLocked { get; private set; }

		public bool IsAutoTeleportEnabled
		{
			[CompilerGenerated]
			get
			{
				return m_platformInput.IsAutoTeleportEnabled;
			}
		}

		public bool IsDualWandInputListener
		{
			[CompilerGenerated]
			get
			{
				return m_inputListener is IInputListenerTwoWands;
			}
		}

		public void EnableInputLock()
		{
			IsInputLocked = true;
		}

		public void DisableInputLock()
		{
			IsInputLocked = false;
		}

		public void TryUpdateInputMethod()
		{
			IPlatformInput platformInput = GameControl.Instance.Platform.CreateInputController();
			if (m_platformInput == null || m_platformInput.GetType() != platformInput.GetType())
			{
				SetInputMethod(platformInput);
			}
		}

		public void UpdateInputMethod()
		{
			SetInputMethod(GameControl.Instance.Platform.CreateInputController());
		}

		private void SetInputMethod(IPlatformInput platformInput)
		{
			if (m_inputListener != null)
			{
				StopListening(m_inputListener);
			}
			m_platformInput = platformInput;
			InputEvents.PlatformInputUpdated platformInputUpdated = new InputEvents.PlatformInputUpdated();
			platformInputUpdated.AimInput = m_platformInput.Aim;
			platformInputUpdated.WandInput = m_platformInput.WandInput;
			platformInputUpdated.IsDualWieldEnabled = GameControl.Instance.IsDualWieldSupportedAndActive;
			EventHub.Publish(platformInputUpdated);
		}

		public void SetInputListener(IInputListener listener)
		{
			if (m_inputListener != listener)
			{
				StopCurrentListener();
				StartListening(listener);
			}
		}

		public void SetWandManager(WandManager wandManager)
		{
			if (m_inputListener == null)
			{
				throw new Exception("Trying to set wandcontroller while input listener is missing");
			}
			if (m_inputListener is IWandControllable wandControllable)
			{
				wandControllable.SetWandControl(wandManager);
				return;
			}
			throw new Exception("Input listener does not implement IWandControllable (incorrect listener type?)");
		}

		private void StartListening(IInputListener listener)
		{
			m_inputListener = listener;
			m_platformInput.BindActions(listener);
		}

		public void StopCurrentListener()
		{
			if (m_inputListener != null)
			{
				StopListening(m_inputListener);
			}
		}

		private void StopListening(IInputListener listener)
		{
			if (m_platformInput != null)
			{
				m_inputListener = null;
				m_platformInput.UnbindActions(listener);
			}
		}

		public void Update()
		{
			if (m_platformInput == null)
			{
				return;
			}
			if (m_platformInput.IsCorrectInputSystem)
			{
				if (!IsInputLocked)
				{
					m_platformInput.Update();
				}
			}
			else
			{
				TryUpdateInputMethod();
			}
		}
	}
}
namespace Cortopia.Scripts.WandsInput
{
	public class WindowsMixedRealityInput : SteamInput
	{
		public WindowsMixedRealityInput(Valve.VR.ETrackedControllerRole primaryController, StringBuilder inputStringBuilder)
			: base(primaryController, inputStringBuilder)
		{
		}

		public override void BindDefaultActions(IInputListener listener)
		{
			BindButton(m_menuButton, listener.OnMenuInput);
			BindButton(m_buttonLeft02, listener.OnMenuInput);
			BindButton(m_buttonRight02, listener.OnRecenterInput);
			if (listener is IInputListenerTwoWands listener2)
			{
				BindAxis(m_leftThumbstick, listener.OnSecondaryAxisInput);
				BindAxis(m_rightThumbstick, listener.OnSecondaryAxisInput);
				BindSpellButtonActions(listener2);
			}
			else if (m_primaryController == Valve.VR.ETrackedControllerRole.RightHand)
			{
				BindButton(m_indexRight, listener.OnPrimaryInput);
				BindButton(m_indexLeft, listener.OnTeleportInput);
				BindAxis(m_rightThumbstick, listener.OnPrimaryAxisInput);
				BindAxis(m_leftThumbstick, listener.OnSecondaryAxisInput);
			}
			else
			{
				BindButton(m_indexLeft, listener.OnPrimaryInput);
				BindButton(m_indexRight, listener.OnTeleportInput);
				BindAxis(m_leftThumbstick, listener.OnPrimaryAxisInput);
				BindAxis(m_rightThumbstick, listener.OnSecondaryAxisInput);
			}
		}

		public override void BindSpellButtonActions(IInputListenerTwoWands listener)
		{
			BindButton(m_indexLeft, listener.OnInteractionLeftInput);
			BindButton(m_indexRight, listener.OnInteractionInput);
			BindButton(m_grabLeft, listener.OnAutoTeleportLeftInput);
			BindButton(m_grabRight, listener.OnAutoTeleportRightInput);
			BindButton(m_indexLeft, listener.OnSpellInput02);
			BindButton(m_buttonLeft01, listener.OnSpellInput01);
			BindButton(m_indexRight, listener.OnSpellInput04);
			BindButton(m_buttonRight01, listener.OnSpellInput03);
		}

		public override void UnbindDefaultActions(IInputListener listener)
		{
			UnbindButton(m_menuButton, listener.OnMenuInput);
			UnbindButton(m_buttonLeft02, listener.OnMenuInput);
			UnbindButton(m_buttonRight02, listener.OnRecenterInput);
			if (listener is IInputListenerTwoWands listener2)
			{
				UnbindAxis(m_leftThumbstick, listener.OnSecondaryAxisInput);
				UnbindAxis(m_rightThumbstick, listener.OnSecondaryAxisInput);
				UnbindSpellButtonActions(listener2);
			}
			else if (m_primaryController == Valve.VR.ETrackedControllerRole.RightHand)
			{
				UnbindButton(m_indexRight, listener.OnPrimaryInput);
				UnbindButton(m_indexLeft, listener.OnTeleportInput);
				UnbindAxis(m_rightThumbstick, listener.OnPrimaryAxisInput);
				UnbindAxis(m_leftThumbstick, listener.OnSecondaryAxisInput);
			}
			else
			{
				UnbindButton(m_indexLeft, listener.OnPrimaryInput);
				UnbindButton(m_indexRight, listener.OnTeleportInput);
				UnbindAxis(m_leftThumbstick, listener.OnPrimaryAxisInput);
				UnbindAxis(m_rightThumbstick, listener.OnSecondaryAxisInput);
			}
		}

		public override void UnbindSpellButtonActions(IInputListenerTwoWands listener)
		{
			UnbindButton(m_indexLeft, listener.OnInteractionLeftInput);
			UnbindButton(m_indexRight, listener.OnInteractionInput);
			UnbindButton(m_grabLeft, listener.OnAutoTeleportLeftInput);
			UnbindButton(m_grabRight, listener.OnAutoTeleportRightInput);
			UnbindButton(m_indexLeft, listener.OnSpellInput02);
			UnbindButton(m_buttonLeft01, listener.OnSpellInput01);
			UnbindButton(m_indexRight, listener.OnSpellInput04);
			UnbindButton(m_buttonRight01, listener.OnSpellInput03);
		}
	}
}
public sealed class WandsPrefs
{
	public const string MUSIC_OPTIONAL = "MO";

	public const string SUBTITLES_ENABLED = "SE";

	public const string VOIP_ENABLED = "VE";

	public const string VOIP_ENABLED_OPP = "VEO";

	public const string PRIMARY_HAND = "P1";

	public const string WAND_GRIP = "WG";

	public const string POSITIONAL_TRACKING_OPPONENT = "PTO";

	public const string CONTROL_SCHEME = "CS";

	public const string DUAL_WIELD = "DW";

	public const string TUTORIAL = "TU";

	public const string POST_TUTORIAL_TYPE = "PTT";

	public const string PRE_TUTORIAL = "PT";

	public const string CHARACTER_INDEX = "V0";

	public const string WAND_INDEX_RIGHT = "V1";

	public const string WAND_INDEX_LEFT = "V3";

	public const string TITLE = "V2";
}
public static class WandsSave
{
	private static bool sm_isSaving;

	private const int MaximumTextlength = 64;

	public static bool IsDualWieldEnabled
	{
		get
		{
			return GetBoolPref("DW", GameControl.Instance.Platform.Type.ContainsFlag(PlatformTarget.SixDoF));
		}
		set
		{
			SetPlayerPref("DW", value);
		}
	}

	public static WandGrip WandGrip
	{
		get
		{
			return (WandGrip)GetIntPref("WG", (int)GameControl.Instance.Platform.DefaultWandGrip);
		}
		set
		{
			SetPlayerPref("WG", (int)value);
		}
	}

	public static void SetPlayerPref(string key, string value)
	{
		PlayerPrefs.SetString(key, value);
		bool flag = value.Length > 64;
		string text = value.Substring(0, (!flag) ? value.Length : 64);
		string text2 = text + ((!flag) ? string.Empty : "...");
		Save();
	}

	public static void SetPlayerPref(string key, int value)
	{
		PlayerPrefs.SetInt(key, value);
		Save();
	}

	public static void SetPlayerPref(string key, bool value)
	{
		PlayerPrefs.SetInt(key, value ? 1 : 0);
		Save();
	}

	public static void SetPlayerPref(string key, float value)
	{
		PlayerPrefs.SetFloat(key, value);
		Save();
	}

	public static bool HasPlayerPref(string key)
	{
		return PlayerPrefs.HasKey(key);
	}

	public static string GetStringPref(string key, string defaultValue = null)
	{
		if (PlayerPrefs.HasKey(key))
		{
			return PlayerPrefs.GetString(key);
		}
		PlayerPrefs.SetString(key, defaultValue);
		return defaultValue;
	}

	public static int GetIntPref(string key, int defaultValue = 0)
	{
		if (PlayerPrefs.HasKey(key))
		{
			return PlayerPrefs.GetInt(key);
		}
		PlayerPrefs.SetInt(key, defaultValue);
		return defaultValue;
	}

	public static bool GetBoolPref(string key, bool defaultValue = false)
	{
		if (PlayerPrefs.HasKey(key))
		{
			return PlayerPrefs.GetInt(key) != 0;
		}
		PlayerPrefs.SetInt(key, defaultValue ? 1 : 0);
		return defaultValue;
	}

	public static float GetFloatPref(string key, float defaultValue = 0f)
	{
		if (PlayerPrefs.HasKey(key))
		{
			return PlayerPrefs.GetFloat(key);
		}
		PlayerPrefs.SetFloat(key, defaultValue);
		return defaultValue;
	}

	public static void Save()
	{
		if (!sm_isSaving)
		{
			Task.Run(delegate
			{
				sm_isSaving = true;
				Task.Delay(3000).Wait();
			}).ContinueWith(delegate
			{
				PlayerPrefs.Save();
				sm_isSaving = false;
			}, TaskScheduler.FromCurrentSynchronizationContext());
		}
	}
}
namespace Assets.Scripts
{
	public class WandsSceneManager : MonoBehaviour
	{
		private Level m_currentLevel;

		private Level m_previousLevel;

		public Level PreviousLevel => m_previousLevel;

		private void OnEnable()
		{
			SceneManager.sceneLoaded += SceneLoaded;
		}

		private void OnDisable()
		{
			SceneManager.sceneLoaded -= SceneLoaded;
		}

		private void SceneLoaded(Scene scene, LoadSceneMode loadSceneMode)
		{
			ParseScene(scene.name);
			Events.SceneLoadedEvent sceneLoadedEvent = new Events.SceneLoadedEvent();
			sceneLoadedEvent.Scene = scene;
			sceneLoadedEvent.LoadSceneMode = loadSceneMode;
			sceneLoadedEvent.Level = m_currentLevel;
			EventHub.Publish(sceneLoadedEvent);
		}

		private void ParseScene(string activeSceneName)
		{
			if (Enum.TryParse<Level>(activeSceneName, out var result))
			{
				if (m_currentLevel == result)
				{
					return;
				}
				m_previousLevel = m_currentLevel;
			}
			else
			{
				WandsLogger.LogError("Couldn't parse current scene, make sure it's been added to the Level Enum!");
			}
			m_currentLevel = result;
		}

		public Level GetCurrentLevel(bool callBeforeLevelLoaded = false)
		{
			if (m_currentLevel == Level.Unknown || callBeforeLevelLoaded)
			{
				ParseScene(SceneManager.GetActiveScene().name);
			}
			return m_currentLevel;
		}
	}
}
namespace Assets.Scripts.Workshop
{
	public class InputImageHandler : MonoBehaviour
	{
		[SerializeField]
		private SpriteRenderer m_renderer;

		private EventToken m_controllerEventToken;

		private void OnDestroy()
		{
			EventHub.Unsubscribe<InputEvents.ControllerConnectionStatusChanged>(m_controllerEventToken);
		}

		private void Awake()
		{
			m_controllerEventToken = EventHub.Subscribe<InputEvents.ControllerConnectionStatusChanged>(OnControllerConnectionStatusChanged);
		}

		private void Start()
		{
			ShowCorrectImage();
		}

		private void OnControllerConnectionStatusChanged(InputEvents.ControllerConnectionStatusChanged eventData)
		{
			if (eventData.IsConnected)
			{
				ShowCorrectImage();
			}
		}

		private void ShowCorrectImage()
		{
			bool boolPref = WandsSave.GetBoolPref("P1", defaultValue: true);
			switch (GameControl.Instance.Platform.ControlType)
			{
			case ControlType.Daydream:
				m_renderer.sprite = GameControl.Instance.AssetHandler.LoadAsset<Sprite>(AssetBundleType.UI, "DaydreamRemote");
				break;
			case ControlType.Gamepad:
				if (GameControl.Instance.Platform.Type.ContainsFlag(PlatformTarget.OculusAndroid))
				{
					m_renderer.sprite = GameControl.Instance.AssetHandler.LoadAsset<Sprite>(AssetBundleType.UI, "GearVRGamepad");
				}
				else
				{
					m_renderer.sprite = GameControl.Instance.AssetHandler.LoadAsset<Sprite>(AssetBundleType.UI, "GenericGamepad");
				}
				break;
			case ControlType.GearVrRemote:
				m_renderer.sprite = GameControl.Instance.AssetHandler.LoadAsset<Sprite>(AssetBundleType.UI, "GearVRRemote");
				break;
			case ControlType.GearVr:
				m_renderer.sprite = GameControl.Instance.AssetHandler.LoadAsset<Sprite>(AssetBundleType.UI, "GearVRTouchpad");
				break;
			case ControlType.GoRemote:
				m_renderer.sprite = GameControl.Instance.AssetHandler.LoadAsset<Sprite>(AssetBundleType.UI, "GoRemote");
				break;
			case ControlType.QuestRight:
				m_renderer.sprite = GameControl.Instance.AssetHandler.LoadAsset<Sprite>(AssetBundleType.UI, "Quest");
				m_renderer.transform.localScale = new Vector3(1f, 1f, 1f);
				break;
			case ControlType.QuestLeft:
				m_renderer.sprite = GameControl.Instance.AssetHandler.LoadAsset<Sprite>(AssetBundleType.UI, "Quest");
				m_renderer.transform.localScale = new Vector3(-1f, 1f, 1f);
				break;
			case ControlType.MiVrRemote:
				m_renderer.sprite = GameControl.Instance.AssetHandler.LoadAsset<Sprite>(AssetBundleType.UI, "MiVrRemote");
				break;
			case ControlType.Pico:
				m_renderer.sprite = GameControl.Instance.AssetHandler.LoadAsset<Sprite>(AssetBundleType.UI, "PicoRemote");
				break;
			case ControlType.PicoNeo2:
				m_renderer.sprite = GameControl.Instance.AssetHandler.LoadAsset<Sprite>(AssetBundleType.UI, "PicoNeo2Controller");
				break;
			case ControlType.PlayStationDualShock:
				m_renderer.sprite = GameControl.Instance.AssetHandler.LoadAsset<Sprite>(AssetBundleType.UI, "DualShockRemote");
				break;
			case ControlType.PlayStationMotion:
				m_renderer.sprite = GameControl.Instance.AssetHandler.LoadAsset<Sprite>(AssetBundleType.UI, "PlaystationMoveRemote");
				break;
			case ControlType.RiftTouchRight:
				m_renderer.sprite = GameControl.Instance.AssetHandler.LoadAsset<Sprite>(AssetBundleType.UI, "RiftTouch");
				m_renderer.transform.localScale = new Vector3(-1f, 1f, 1f);
				break;
			case ControlType.RiftTouchLeft:
				m_renderer.sprite = GameControl.Instance.AssetHandler.LoadAsset<Sprite>(AssetBundleType.UI, "RiftTouch");
				m_renderer.transform.localScale = new Vector3(1f, 1f, 1f);
				break;
			case ControlType.ViveController:
			case ControlType.ViveKnuckles:
			case ControlType.ViveCosmos:
			case ControlType.WindowsMixedReality:
				m_renderer.sprite = GameControl.Instance.AssetHandler.LoadAsset<Sprite>(AssetBundleType.UI, GameControl.Instance.Platform.ControlType.ToString());
				m_renderer.transform.localScale = new Vector3((!boolPref) ? 1 : (-1), 1f, 1f);
				break;
			default:
				throw new NotImplementedException($"{GameControl.Instance.Platform.ControlType} not recognized as control type");
			}
		}
	}
}
namespace Assets.Scripts
{
	public class PortalHandler : MonoSingleton<PortalHandler>
	{
		[SerializeField]
		private GameObject[] m_toggleActiveOnOpen = Array.Empty<GameObject>();

		[SerializeField]
		private GameObject[] m_toggleActiveOnClose = Array.Empty<GameObject>();

		[Header("Effects")]
		[SerializeField]
		private SplitAudioSoundPlayer m_portalEffectHolder;

		[SerializeField]
		private AudioSource m_portalMatchStart;

		private int m_lvlIndex;

		private GameObject m_portalVfx;

		public bool IsActive { get; private set; }

		public JoinState JoinState { get; private set; }

		private Arena SelectedLevel
		{
			[CompilerGenerated]
			get
			{
				return (Arena)m_lvlIndex;
			}
		}

		private void Start()
		{
			SpawnPortalVfx();
			SetMirrorActive(enable: false);
		}

		private void SpawnPortalVfx()
		{
			m_portalVfx = UnityEngine.Object.Instantiate(GameControl.Instance.AssetHandler.LoadAsset<GameObject>(AssetBundleType.VFX, "Mirrus_VFX_Active"), m_portalEffectHolder.transform);
		}

		public void PlayStartMatchSound()
		{
			if (!(m_portalMatchStart == null))
			{
				ExpandedSingleton<LevelLoader>.Instance.SetLoadingSound(m_portalMatchStart);
				m_portalMatchStart.Play();
			}
		}

		public void Toggle()
		{
			SetMirrorActive(!IsActive);
			Events.PortalLeverRotatedEvent portalLeverRotatedEvent = new Events.PortalLeverRotatedEvent();
			portalLeverRotatedEvent.Enabled = IsActive;
			EventHub.Publish(portalLeverRotatedEvent);
		}

		public void SetPortalEffectActive(bool enable, bool effectOnly = false)
		{
			m_portalVfx.SetActive(enable);
			if (!effectOnly)
			{
				if (enable)
				{
					m_portalEffectHolder.PlaySplitAudio();
				}
				else
				{
					m_portalEffectHolder.PlayStopSound();
				}
			}
		}

		public void SetJoinState(JoinState newState)
		{
			JoinState = newState;
		}

		public bool LoadLevel(int index)
		{
			m_lvlIndex = index;
			return TryStartMatch(multiplayer: true);
		}

		public void SetMirrorActive(bool enable)
		{
			IsActive = enable;
			GameObject[] toggleActiveOnOpen = m_toggleActiveOnOpen;
			foreach (GameObject gameObject in toggleActiveOnOpen)
			{
				gameObject.SetActive(enable);
			}
			GameObject[] toggleActiveOnClose = m_toggleActiveOnClose;
			foreach (GameObject gameObject2 in toggleActiveOnClose)
			{
				gameObject2.SetActive(!enable);
			}
			MonoSingleton<SnapshotHandler>.Instance?.TransitionTo(enable ? 1 : 0);
			SetPortalEffectActive(enable);
		}

		public bool TryStartMatch(bool multiplayer)
		{
			if (!MonoSingleton<SpellSelectUI>.Instance.TryDisableSpellSelection())
			{
				EventHub.Publish(new Events.TriedStartingWithoutCompleteLoadoutEvent());
				return false;
			}
			if (multiplayer)
			{
				Events.ConnectToMatch connectToMatch = new Events.ConnectToMatch();
				connectToMatch.JoinState = JoinState;
				connectToMatch.Arena = SelectedLevel;
				EventHub.Publish(connectToMatch);
			}
			MonoSingleton<SpellSelectUI>.Instance.SetSpellSelectionActive(enable: false, playSound: false, saveSelection: true);
			return true;
		}
	}
}
namespace Assets.Scripts.Workshop
{
	public class WorkshopElevator : MonoBehaviour
	{
		private const float MoveTime = 0f;

		private readonly Vector3 StartPosition = new Vector3(0f, -3f, -0.5f);

		private readonly Vector3 EndPosition = new Vector3(0f, -0.395f, -0.5f);

		private void Awake()
		{
			if (GameControl.Instance.Player.TutorialState <= TutorialState.EnteredWorkshop)
			{
				base.transform.position = StartPosition;
				MoveElevator();
			}
		}

		private void MoveElevator()
		{
			GameControl.Instance.PlayerControl.transform.SetParent(base.transform);
			GameControl.Instance.PlayerControl.transform.localPosition = Vector3.zero;
			base.transform.DOMove(EndPosition, 0f).SetEase(Ease.OutSine).OnComplete(OnMoveCompleted);
		}

		private void OnMoveCompleted()
		{
			GameControl.Instance.PlayerControl.transform.SetParent(null);
		}
	}
}
namespace Assets.Scripts.Network
{
	public class WorkshopManager : MonoBehaviour
	{
		private const float MaxRoomUpdateWaitTime = 5f;

		private const int MaxRoomPings = 2;

		private const string NoInternetConnectionTerm = "NoInternetConnection";

		private const string ConnectionFailedTerm = "ConnectionFailed";

		private EventToken m_connectToMatchEventToken;

		private EventToken m_connectedToMatchRoomEventToken;

		private EventToken m_receivedRoomListUpdateEventToken;

		private EventToken m_connectToMatchRoomFailedEventToken;

		private EventToken m_connectToMatchLobbyFailedEventToken;

		private EventToken m_levelInitializedEventToken;

		private EventToken m_photonPlayerConnectedEventToken;

		private EventToken m_photonConnectionFailedEventToken;

		private EventToken m_sceneLoadedEventToken;

		public bool IsUpdatingMatches { get; private set; }

		public bool WasMatchUpdateSuccessful { get; private set; }

		public bool FirstEntraceInWorkshop { get; set; }

		protected void OnEnable()
		{
			m_connectToMatchEventToken = EventHub.Subscribe<Events.ConnectToMatch>(OnConnectToMatch);
			m_connectedToMatchRoomEventToken = EventHub.Subscribe<Events.ConnectedToMatchRoom>(OnConnectedToMatchRoom);
			m_connectToMatchRoomFailedEventToken = EventHub.Subscribe<Events.ConnectToMatchRoomFailed>(OnConnectToMatchRoomFailed);
			m_connectToMatchLobbyFailedEventToken = EventHub.Subscribe<Events.ConnectToMatchLobbyFailed>(OnConnectToMatchLobbyFailed);
			m_levelInitializedEventToken = EventHub.Subscribe<Events.LevelInitializedEvent>(OnLevelInitialized);
			m_photonPlayerConnectedEventToken = EventHub.Subscribe<NetworkEvents.PhotonPlayerConnectedEvent>(OnAnyPhotonPlayerConnected);
			m_photonConnectionFailedEventToken = EventHub.Subscribe<NetworkEvents.PhotonConnectionFailedEvent>(OnPhotonConnectionFailed);
			m_sceneLoadedEventToken = EventHub.Subscribe<Events.SceneLoadedEvent>(OnSceneLoaded);
		}

		protected void OnDisable()
		{
			EventHub.Unsubscribe<Events.ConnectToMatch>(m_connectToMatchEventToken);
			EventHub.Unsubscribe<Events.ConnectedToMatchRoom>(m_connectedToMatchRoomEventToken);
			EventHub.Unsubscribe<Events.ConnectToMatchRoomFailed>(m_connectToMatchRoomFailedEventToken);
			EventHub.Unsubscribe<Events.ConnectToMatchLobbyFailed>(m_connectToMatchLobbyFailedEventToken);
			EventHub.Unsubscribe<Events.LevelInitializedEvent>(m_levelInitializedEventToken);
			EventHub.Unsubscribe<NetworkEvents.PhotonPlayerConnectedEvent>(m_photonPlayerConnectedEventToken);
			EventHub.Unsubscribe<NetworkEvents.PhotonConnectionFailedEvent>(m_photonConnectionFailedEventToken);
			EventHub.Unsubscribe<Events.SceneLoadedEvent>(m_sceneLoadedEventToken);
			if (m_receivedRoomListUpdateEventToken != null)
			{
				EventHub.Unsubscribe<Events.ReceivedRoomListUpdate>(m_receivedRoomListUpdateEventToken);
			}
		}

		private void OnConnectToMatch(Events.ConnectToMatch eventData)
		{
			switch (eventData.JoinState)
			{
			case JoinState.Ranked:
				MonoSingleton<NetworkManager>.Instance.ConnectToMatchRoom(null, RoomCreationType.Create, RoomCreationReason.HostRanked, ArenaUtils.GetRandomArena(), MatchType.Competitive);
				break;
			case JoinState.HostPublic:
				MonoSingleton<NetworkManager>.Instance.ConnectToMatchRoom(null, RoomCreationType.Create, RoomCreationReason.HostPublic, eventData.Arena, MatchType.Public);
				break;
			case JoinState.Join:
				MonoSingleton<NetworkManager>.Instance.ConnectToMatchRoom(eventData.RoomName, RoomCreationType.Join, RoomCreationReason.None, eventData.Arena, MatchType.None);
				break;
			case JoinState.Exploration:
				MonoSingleton<NetworkManager>.Instance.ConnectToMatchRoom(null, RoomCreationType.Create, RoomCreationReason.LevelExploration, eventData.Arena, MatchType.Exploration);
				break;
			case JoinState.Bot:
				MonoSingleton<NetworkManager>.Instance.ConnectToMatchRoom(null, RoomCreationType.Create, RoomCreationReason.Bot, eventData.Arena, MatchType.Bot);
				break;
			default:
				WandsLogger.LogError("Not implemented join state: " + eventData.JoinState);
				break;
			}
		}

		private void OnConnectedToMatchRoom(Events.ConnectedToMatchRoom eventData)
		{
			switch (eventData.CreationReason)
			{
			case RoomCreationReason.HostRanked:
				MonoSingleton<NetworkManager>.Instance.FindMatch();
				StartCoroutine("LoadLobbyAndStartMatch");
				break;
			case RoomCreationReason.HostPublic:
			case RoomCreationReason.Bot:
				StartCoroutine("LoadLobbyAndStartMatch");
				break;
			case RoomCreationReason.LevelExploration:
				StartCoroutine("LoadArenaAndStartExploration", eventData.Arena);
				break;
			}
		}

		private void OnReceivedRoomUpdate(Events.ReceivedRoomListUpdate eventData)
		{
			if (m_receivedRoomListUpdateEventToken != null)
			{
				EventHub.Unsubscribe<Events.ReceivedRoomListUpdate>(m_receivedRoomListUpdateEventToken);
				m_receivedRoomListUpdateEventToken = null;
			}
			if (IsUpdatingMatches)
			{
				RoomInfo[] rooms = eventData.Rooms;
				if (rooms == null)
				{
					WandsLogger.LogError("WorkShopManager | Could not update rooms, room list was null", LogColor.Photon);
					IsUpdatingMatches = false;
					WasMatchUpdateSuccessful = false;
				}
				else
				{
					IsUpdatingMatches = false;
					WasMatchUpdateSuccessful = true;
					MonoSingleton<NetworkManager>.Instance.Disconnect();
					CheckRooms(rooms);
				}
			}
		}

		private void OnConnectToMatchRoomFailed(Events.ConnectToMatchRoomFailed eventData)
		{
			GameControl.Instance.PlayerControl.ToggleInputActive(active: true);
			ResetPortalAfterError("[OnConnectToMatch Could not connect to match room]");
		}

		private void OnConnectToMatchLobbyFailed(Events.ConnectToMatchLobbyFailed eventData)
		{
			GameControl.Instance.PlayerControl.ToggleInputActive(active: true);
			IsUpdatingMatches = false;
			WasMatchUpdateSuccessful = false;
			ResetPortalAfterError("[OnConnectToMatch Could not connect to match lobby]");
		}

		private void OnError()
		{
			ExpandedSingleton<FadeHandler>.Instance?.FadeIn(1f);
			if (MonoSingleton<PortalHandler>.Instance.IsActive)
			{
				Interactable.LockAllInteraction = false;
				Interactable.LockAllLook = false;
			}
		}

		private void ResetPortalAfterError(string errorMessage)
		{
			IsUpdatingMatches = false;
			WasMatchUpdateSuccessful = false;
			OnError();
			MonoSingleton<NetworkManager>.Instance.Disconnect();
			SceneLoaded();
			StopAllCoroutines();
		}

		private IEnumerator LoadLobbyAndStartMatch()
		{
			GameControl.Instance.PlayerControl.ToggleInputActive(active: false);
			MonoSingleton<PortalHandler>.Instance.PlayStartMatchSound();
			yield return new WaitForSeconds(1f);
			ExpandedSingleton<LevelLoader>.Instance.LoadLevel(Level.Lobby, 3f);
		}

		private IEnumerator LoadArenaAndStartExploration(Arena explorationArena)
		{
			GameControl.Instance.PlayerControl.ToggleInputActive(active: false);
			MonoSingleton<PortalHandler>.Instance.PlayStartMatchSound();
			yield return new WaitForSeconds(1f);
			ExpandedSingleton<LevelLoader>.Instance.LoadLevel(explorationArena, 3f);
		}

		private void OnSceneLoaded(Events.SceneLoadedEvent eventData)
		{
			SceneLoaded();
		}

		private void SceneLoaded()
		{
			bool flag = GameControl.Instance.GetPreviousLevel().ContainsFlag(Level.Lobby | Level.AspisPrison | Level.TempleOfOphidian | Level.TheCelestialHalls | Level.OrtusStation | Level.DeadMastersVale | Level.SanctumOfSahir | Level.TheCelestialHalls_AIBot | Level.FountainOfTheFallen);
			if (flag)
			{
				GameControl.Instance.LoadLeaderboards();
			}
			if (flag && GameControl.Instance.IsExpectedConnectionType((ConnectionType)3))
			{
				FirstEntraceInWorkshop = false;
			}
			else
			{
				FirstEntraceInWorkshop = true;
			}
		}

		public void UpdatePrivateMatches()
		{
			IsUpdatingMatches = true;
			if (m_receivedRoomListUpdateEventToken != null)
			{
				EventHub.Unsubscribe<Events.ReceivedRoomListUpdate>(m_receivedRoomListUpdateEventToken);
			}
			m_receivedRoomListUpdateEventToken = EventHub.Subscribe<Events.ReceivedRoomListUpdate>(OnReceivedRoomUpdate);
			MonoSingleton<NetworkManager>.Instance.ConnectToMatchLobby();
		}

		private void CheckRooms(RoomInfo[] roomList)
		{
			roomList = roomList.Where((RoomInfo room) => (int)room.CustomProperties["C4"] == 1 && !(bool)room.CustomProperties["C5"] && (int)room.CustomProperties["C3"] == 2 && ArenaUtils.IsArenaPlayable((Arena)Enum.Parse(typeof(Arena), (string)room.CustomProperties["A2"])) && ((string)room.CustomProperties["P1"]).Split('/')[0] != string.Empty).ToArray();
			if (GameControl.Instance.Platform.SupportsPositionalTracking)
			{
				roomList = roomList.Where((RoomInfo room) => (int)room.CustomProperties["C2"] >= 1).ToArray();
			}
			else if (!GameControl.Instance.PositionalTrackingOpponentEnabled)
			{
				roomList = roomList.Where((RoomInfo room) => (int)room.CustomProperties["C2"] <= 1).ToArray();
			}
			Events.FriendlyMatchesUpdatedEvent friendlyMatchesUpdatedEvent = new Events.FriendlyMatchesUpdatedEvent();
			friendlyMatchesUpdatedEvent.RoomInfos = roomList;
			EventHub.Publish(friendlyMatchesUpdatedEvent);
		}

		private void OnLevelInitialized(Events.LevelInitializedEvent eventData)
		{
			PhotonNetwork.IsMessageQueueRunning = true;
			MonoSingleton<NetworkManager>.Instance.ResetPreviousOpponent();
		}

		private void OnAnyPhotonPlayerConnected(NetworkEvents.PhotonPlayerConnectedEvent eventData)
		{
			PhotonPlayerConnected(eventData.PhotonPlayer);
		}

		private void PhotonPlayerConnected(Photon.Realtime.Player otherPlayer)
		{
			PhotonNetwork.IsMessageQueueRunning = false;
		}

		private void OnPhotonConnectionFailed(NetworkEvents.PhotonConnectionFailedEvent eventData)
		{
			GameControl.Instance.PlayerControl.ToggleInputActive(active: true);
			ResetPortalAfterError("[OnConnectToMatch Could not connect to photon]");
		}
	}
}
namespace Assets.Scripts.Workshop
{
	public class WorkshopTeleportHandler : MonoBehaviour
	{
		[SerializeField]
		private float m_teleportFadeTime = 0.1f;

		[SerializeField]
		private float m_teleportStartTime;

		[SerializeField]
		private AudioSource m_audioSource;

		private Vector3 m_teleportStartPosition;

		private Vector3 m_teleportEndPosition;

		private float m_teleportDistance;

		private float m_teleportAcceleration;

		private bool m_isTeleporting;

		private Transform m_playerTransform;

		private void Update()
		{
			if (m_isTeleporting)
			{
				TeleportTransport();
			}
		}

		public void TeleportPlayer(Transform playerTransform, WorkshopTile newTile)
		{
			m_playerTransform = playerTransform;
			SetTeleportVariables(newTile);
			StopCoroutine("Teleport");
			StartCoroutine("Teleport");
			m_isTeleporting = true;
			m_audioSource.Play();
		}

		private void SetTeleportVariables(WorkshopTile newTile)
		{
			if (newTile == null)
			{
				WandsLogger.Log("New tils is null", LogType.Warning);
				return;
			}
			m_teleportStartPosition = m_playerTransform.transform.position;
			m_teleportEndPosition = newTile.transform.position;
			m_teleportDistance = Vector3.Distance(m_teleportStartPosition, m_teleportEndPosition);
			m_teleportAcceleration = Mathf.Clamp(m_teleportDistance / 3f / 2f, 1f, m_teleportDistance);
		}

		private IEnumerator Teleport()
		{
			WaitForEndOfFrame endOfFrameWait = new WaitForEndOfFrame();
			if (ExpandedSingleton<FadeHandler>.Instance != null)
			{
				ExpandedSingleton<FadeHandler>.Instance.BlockScreenFlash = true;
				ExpandedSingleton<FadeHandler>.Instance.FadeOut(m_teleportFadeTime, 0.25f, Color.white);
				while (ExpandedSingleton<FadeHandler>.Instance.IsFading)
				{
					yield return endOfFrameWait;
				}
			}
			m_teleportStartTime = Time.time;
			while (m_isTeleporting)
			{
				yield return endOfFrameWait;
			}
			if (ExpandedSingleton<FadeHandler>.Instance != null)
			{
				ExpandedSingleton<FadeHandler>.Instance.BlockScreenFlash = false;
				ExpandedSingleton<FadeHandler>.Instance.FadeIn(m_teleportFadeTime, 0f, resetAlpha: false);
			}
		}

		private void TeleportTransport()
		{
			float num = (Time.time - m_teleportStartTime) * (45f * m_teleportAcceleration);
			float t = num / m_teleportDistance;
			m_playerTransform.transform.position = Vector3.Lerp(m_teleportStartPosition, m_teleportEndPosition, t);
			if (m_playerTransform.transform.position == m_teleportEndPosition)
			{
				m_isTeleporting = false;
			}
		}
	}
	public class WorkshopTile : Interactable
	{
		[SerializeField]
		private WorkshopTileManager m_workshopTileManager;

		public bool IsOccupied
		{
			[CompilerGenerated]
			get
			{
				return m_workshopTileManager.CurrentTile == this;
			}
		}

		private void OnEnable()
		{
			if (m_workshopTileManager.CurrentTile == this)
			{
				base.gameObject.SetActive(value: false);
			}
		}

		private void OnDisable()
		{
			if (m_particleEffect != null)
			{
				m_particleEffect.SetActive(value: false);
			}
		}

		public override void LookEnter()
		{
			if (!base.LookLocked)
			{
				base.LookEnter();
				if (!(m_particleEffect == null))
				{
					m_particleEffect.SetActive(value: true);
					m_particleEffect.transform.position = base.transform.position;
				}
			}
		}

		public override void LookExit()
		{
			if (!base.LookLocked)
			{
				base.LookExit();
				if (m_particleEffect != null)
				{
					m_particleEffect.SetActive(value: false);
				}
			}
		}

		public override void Interact()
		{
			if (!base.InteractionLocked)
			{
				base.Interact();
				m_workshopTileManager.TeleportPlayer(this);
			}
		}
	}
	public class WorkshopTileManager : MonoBehaviour
	{
		[Serializable]
		public class WorkshopTileToggle
		{
			public WorkshopTile m_workshopTile;

			public bool[] m_enableInteractions;

			public bool[] m_enalbeObjects;

			public GameObject[] m_objects;

			public IWorkshopTileListener[] WorkshopTileListeners;

			public void UpdateWorkshopTileListeners()
			{
				WorkshopTileListeners = new IWorkshopTileListener[m_objects.Length];
				for (int i = 0; i < m_objects.Length; i++)
				{
					WorkshopTileListeners[i] = m_objects[i].GetComponent<IWorkshopTileListener>();
				}
			}
		}

		[SerializeField]
		private WorkshopTile m_startTile;

		[SerializeField]
		private WorkshopTeleportHandler m_workshopTeleportHandler;

		[SerializeField]
		private WorkshopTileToggle[] m_allTileToggles;

		private Dictionary<WorkshopTile, WorkshopTileToggle> m_tileToggleDictionary;

		private PlayerControl m_playerControl;

		private Material m_tileMaterial;

		private WorkshopTile[] m_allTiles;

		private WorkshopTile m_currentTile;

		private WorkshopTile[] AllTiles
		{
			get
			{
				if (m_allTiles.IsNullOrEmpty())
				{
					m_allTiles = m_allTileToggles.Select((WorkshopTileToggle t) => t.m_workshopTile).ToArray();
				}
				return m_allTiles;
			}
		}

		public WorkshopTile CurrentTile
		{
			get
			{
				if (m_currentTile == null)
				{
					m_currentTile = m_startTile;
				}
				return m_currentTile;
			}
			private set
			{
				m_currentTile = value;
				Events.WorkshopTileChangedEvent workshopTileChangedEvent = new Events.WorkshopTileChangedEvent();
				workshopTileChangedEvent.NewTile = m_currentTile;
				EventHub.Publish(workshopTileChangedEvent);
			}
		}

		private void Awake()
		{
			m_playerControl = GameControl.Instance.PlayerControl;
		}

		private void Start()
		{
			m_tileToggleDictionary = new Dictionary<WorkshopTile, WorkshopTileToggle>(m_allTileToggles.Length);
			WorkshopTileToggle[] allTileToggles = m_allTileToggles;
			foreach (WorkshopTileToggle workshopTileToggle in allTileToggles)
			{
				workshopTileToggle.UpdateWorkshopTileListeners();
				m_tileToggleDictionary.Add(workshopTileToggle.m_workshopTile, workshopTileToggle);
			}
			m_tileMaterial = m_startTile.transform.RetrieveChild("ActiveEffect").GetChild(0).GetComponent<ParticleSystem>()
				.GetComponent<Renderer>()
				.sharedMaterial;
			SetTileMaterialColor(Colors.TileColor);
			if (GameControl.Instance.Player.TutorialState == TutorialState.CastSpell)
			{
				MoveToPortalTile();
			}
			else
			{
				MoveToStartTile();
			}
			MatchPlayerRotationWithStartTile();
		}

		private void MatchPlayerRotationWithStartTile()
		{
			m_playerControl.MatchTileRotation(CurrentTile.transform);
		}

		private void OnDisable()
		{
			CancelInvoke();
		}

		private void MoveToStartTile()
		{
			m_playerControl.transform.position = m_startTile.transform.position;
			m_startTile.gameObject.SetActive(value: false);
			CurrentTile = m_startTile;
			ToggleObjects(CurrentTile);
		}

		private void MoveToPortalTile()
		{
			WorkshopTile workshopTile = AllTiles.FirstOrDefault((WorkshopTile t) => t.name.Contains("Portal"));
			if (workshopTile == null)
			{
				WandsLogger.LogError("Couldn't find tile with \"Portal\" in its name");
				workshopTile = m_startTile;
			}
			m_playerControl.transform.position = workshopTile.transform.position;
			m_playerControl.transform.rotation = workshopTile.transform.rotation;
			Vector3 eulerAngles = m_playerControl.transform.eulerAngles;
			eulerAngles.y += 180f;
			m_playerControl.transform.eulerAngles = eulerAngles;
			workshopTile.gameObject.SetActive(value: false);
			CurrentTile = workshopTile;
			ToggleObjects(CurrentTile);
		}

		private void SetTileMaterialColor(Color color)
		{
			if ((object)m_tileMaterial != null)
			{
				m_tileMaterial.SetColor("_Color", color);
			}
		}

		public void TeleportPlayer(WorkshopTile newTile)
		{
			m_playerControl.RecenterCamera();
			m_workshopTeleportHandler.TeleportPlayer(m_playerControl.transform, newTile);
			WorkshopTile currentTile = CurrentTile;
			CurrentTile = newTile;
			if (currentTile != null && GameControl.Instance.Player.TutorialState == TutorialState.Completed)
			{
				currentTile.gameObject.SetActive(value: true);
			}
			newTile.gameObject.SetActive(value: false);
			ToggleObjects(newTile);
		}

		private void ToggleObjects(WorkshopTile newTile)
		{
			WorkshopTileToggle workshopTileToggle = m_tileToggleDictionary[newTile];
			for (int i = 0; i < workshopTileToggle.WorkshopTileListeners.Length; i++)
			{
				if (workshopTileToggle.m_enalbeObjects[i])
				{
					workshopTileToggle.WorkshopTileListeners[i].ToggleActive(active: true);
					workshopTileToggle.WorkshopTileListeners[i].ToggleInteractionActive(active: true);
				}
				else
				{
					workshopTileToggle.WorkshopTileListeners[i].ToggleInteractionActive(active: false);
					workshopTileToggle.WorkshopTileListeners[i].ToggleActive(active: false);
				}
			}
		}
	}
}
namespace Assets.Scripts.Utils
{
	[ExecuteInEditMode]
	public class CameraSaturationHandler : MonoBehaviour
	{
		private const string ShaderName = "Hidden/Desaturation";

		private const string DesaturationProperty = "_desaturation";

		[SerializeField]
		[Range(0f, 1f)]
		private float m_saturation;

		[SerializeField]
		private float m_tweenTime = 0.125f;

		private Material m_material;

		private Tween m_tween;

		private void Awake()
		{
			m_material = new Material(Shader.Find("Hidden/Desaturation"));
			SaturateCamera(value: false, null);
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (m_material == null)
			{
				WandsLogger.LogError(string.Format("Could not create material with shader {0}", "Hidden/Desaturation"));
				return;
			}
			m_material.SetFloat("_desaturation", m_saturation);
			Graphics.Blit(source, destination, m_material);
		}

		public void SaturateCamera(bool value, Action onCompleted)
		{
			if (m_tween != null)
			{
				m_tween.Kill();
			}
			base.enabled = true;
			float endValue = ((!value) ? 1f : 0f);
			m_tween = DOTween.To(GetSaturation, SetSaturation, endValue, m_tweenTime).OnComplete(delegate
			{
				onCompleted?.Invoke();
				if (!value)
				{
					base.enabled = false;
				}
			});
		}

		private float GetSaturation()
		{
			return m_saturation;
		}

		private void SetSaturation(float value)
		{
			m_saturation = value;
		}
	}
}
namespace MIVR
{
	public class AccountInfo
	{
		public string OpenId { get; set; }

		public string SessionId { get; set; }

		public string NickName { get; set; }

		public string Avatar { get; set; }

		public string Gender { get; set; }
	}
	public class BillCreatedEventArgs : EventArgs
	{
		public ErrorCode Code { get; set; }

		public OrderInfo OrderInfo { get; set; }
	}
	public class CommerceCallback : AndroidJavaProxy
	{
		public event EventHandler<LoginFinishedEventArgs> LoginFinished;

		public event EventHandler<BillCreatedEventArgs> BillCreated;

		public CommerceCallback()
			: base("com.mi.dlabs.sdk.commerce.IPaymentCallback")
		{
		}

		public void OnLoginFinished(int errorCode, AndroidJavaObject accountInfo)
		{
			EventHandler<LoginFinishedEventArgs> loginFinished = this.LoginFinished;
			if (!object.ReferenceEquals(loginFinished, null))
			{
				AccountInfo account = null;
				if (!object.ReferenceEquals(accountInfo, null))
				{
					AccountInfo accountInfo2 = new AccountInfo();
					accountInfo2.OpenId = accountInfo.Call<string>("getOpenId", Array.Empty<object>());
					accountInfo2.SessionId = accountInfo.Call<string>("getSessionId", Array.Empty<object>());
					accountInfo2.NickName = accountInfo.Call<string>("getNickName", Array.Empty<object>());
					accountInfo2.Avatar = accountInfo.Call<string>("getAvatar", Array.Empty<object>());
					accountInfo2.Gender = accountInfo.Call<string>("getGender", Array.Empty<object>());
					account = accountInfo2;
				}
				ErrorCode errorCode2 = ErrorCode.UnknownError;
				errorCode2 = errorCode switch
				{
					0 => ErrorCode.Success, 
					1 => ErrorCode.InvalidParameter, 
					2 => ErrorCode.NotLogin, 
					10 => ErrorCode.LoginError, 
					-102 => ErrorCode.LoginError, 
					_ => ErrorCode.UnknownError, 
				};
				loginFinished(this, new LoginFinishedEventArgs
				{
					Code = errorCode2,
					Account = account
				});
			}
		}

		public void OnCreateBillFinished(int status, AndroidJavaObject orderInfo)
		{
			EventHandler<BillCreatedEventArgs> billCreated = this.BillCreated;
			if (!object.ReferenceEquals(billCreated, null))
			{
				OrderInfo orderInfo2 = null;
				if (!object.ReferenceEquals(orderInfo, null))
				{
					OrderInfo orderInfo3 = new OrderInfo();
					orderInfo3.OrderId = orderInfo.Call<string>("getCpOrderId", Array.Empty<object>());
					orderInfo3.AppId = orderInfo.Call<string>("getAppId", Array.Empty<object>());
					orderInfo3.AppKey = orderInfo.Call<string>("getAppKey", Array.Empty<object>());
					orderInfo3.OpenId = orderInfo.Call<string>("getOpenId", Array.Empty<object>());
					orderInfo3.LocalCreatedTime = orderInfo.Call<long>("getLocalCreatedTime", Array.Empty<object>());
					orderInfo3.Quantity = orderInfo.Call<int>("getAmounts", Array.Empty<object>());
					orderInfo3.CurrencyType = orderInfo.Call<string>("getCurrencyType", Array.Empty<object>());
					orderInfo3.ProductName = orderInfo.Call<string>("getProductName", Array.Empty<object>());
					orderInfo3.ExtraData = orderInfo.Call<string>("getCpExtraData", Array.Empty<object>());
					orderInfo2 = orderInfo3;
				}
				ErrorCode errorCode = ErrorCode.UnknownError;
				errorCode = status switch
				{
					102 => ErrorCode.Success, 
					100 => ErrorCode.CreateBillFailed, 
					101 => ErrorCode.CanceledByUser, 
					103 => ErrorCode.PayError, 
					_ => ErrorCode.UnknownError, 
				};
				billCreated(this, new BillCreatedEventArgs
				{
					Code = errorCode,
					OrderInfo = orderInfo2
				});
			}
		}
	}
	public class CommerceManager : MonoBehaviour
	{
		public string AppId = string.Empty;

		public string AppKey = string.Empty;

		private AndroidJavaObject nativeCommerceManager;

		private CommerceCallback commerceCallback;

		public static CommerceManager Instance { get; private set; }

		public event EventHandler<LoginFinishedEventArgs> LoginFinished;

		public event EventHandler<BillCreatedEventArgs> BillCreated;

		public void Login()
		{
			if (nativeCommerceManager != null)
			{
				nativeCommerceManager.Call("login");
			}
		}

		public void CreateBill(string orderId, string displayTitle, string accountOpenId, int totalPrice)
		{
			if (nativeCommerceManager != null)
			{
				nativeCommerceManager.Call("createPaymentBill", orderId, displayTitle, accountOpenId, totalPrice);
			}
		}

		private void Awake()
		{
			if (!(Instance != null) && !UnityEngine.Application.isEditor)
			{
				Instance = this;
				commerceCallback = new CommerceCallback();
				commerceCallback.LoginFinished += CommerceCallback_LoginFinished;
				commerceCallback.BillCreated += CommerceCallback_BillCreated;
				nativeCommerceManager = new AndroidJavaObject("com.mi.dlabs.sdk.commerce.CommerceManager");
				AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
				AndroidJavaObject @static = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
				nativeCommerceManager.Call("registerPayService", @static, AppId, AppKey, commerceCallback);
			}
		}

		private void CommerceCallback_LoginFinished(object sender, LoginFinishedEventArgs e)
		{
			this.LoginFinished?.Invoke(this, e);
		}

		private void CommerceCallback_BillCreated(object sender, BillCreatedEventArgs e)
		{
			this.BillCreated?.Invoke(this, e);
		}
	}
	public sealed class EntitlementCheck
	{
		private static AndroidJavaClass nativeVrLibClass;

		public static void InitAndCheckEntitlement()
		{
			UnityEngine.Debug.Log("InitAndCheckEntitlement");
			if (nativeVrLibClass == null)
			{
				nativeVrLibClass = new AndroidJavaClass("com.mi.dlabs.vr.sdk.VrLib");
			}
			if (nativeVrLibClass != null)
			{
				UnityEngine.Debug.Log("initSystemService is called in unity");
				AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
				AndroidJavaObject @static = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
				nativeVrLibClass.CallStatic("initAndCheckEntitlement", @static);
			}
		}

		public static void ReleaseEntitlementCheck()
		{
			UnityEngine.Debug.Log("ReleaseEntitlementCheck");
			if (nativeVrLibClass == null)
			{
				nativeVrLibClass = new AndroidJavaClass("com.mi.dlabs.vr.sdk.VrLib");
			}
			if (nativeVrLibClass != null)
			{
				nativeVrLibClass.Call("releaseEntitlementCheck");
			}
		}
	}
	public enum ErrorCode
	{
		Success,
		UnknownError,
		InvalidParameter,
		NotLogin,
		LoginError,
		NoLauncher,
		CreateBillFailed,
		CanceledByUser,
		PayError
	}
	public class LoginFinishedEventArgs : EventArgs
	{
		public ErrorCode Code { get; set; }

		public AccountInfo Account { get; set; }
	}
	public class OrderInfo
	{
		public string OrderId { get; set; }

		public string AppId { get; set; }

		public string AppKey { get; set; }

		public string OpenId { get; set; }

		public long LocalCreatedTime { get; set; }

		public int Quantity { get; set; }

		public string CurrencyType { get; set; }

		public string ProductName { get; set; }

		public string ExtraData { get; set; }
	}
	public class OrderVerification
	{
		public enum QueryStatus
		{
			Success,
			WrongParameter
		}

		public enum PayType
		{
			Unknown,
			ALIPAY
		}

		[StructLayout(LayoutKind.Sequential, Size = 1)]
		public struct VerificationInfo
		{
			public QueryStatus Status { get; set; }

			public int PayedAmount { get; set; }

			public bool IsPayed { get; set; }

			public PayType PayType { get; set; }
		}

		[Serializable]
		public class Detail
		{
			public string orderId;

			public int buyerPayAmount;

			public string paymentStatus;

			public string paymentType;
		}

		[Serializable]
		public class QueryResult
		{
			public string msg;

			public int code;

			public Detail data;
		}

		public VerificationInfo Query(string appId, string orderId, string appSecret)
		{
			string text = "devAppId=" + appId;
			text = text + "&orderId=" + orderId;
			HMACSHA1 hMACSHA = new HMACSHA1(Encoding.UTF8.GetBytes(appSecret));
			byte[] array = hMACSHA.ComputeHash(Encoding.UTF8.GetBytes(text));
			text = text + "&signature=" + BitConverter.ToString(array).Replace("-", string.Empty).ToLower();
			string text2 = "http://api.miglass.mi.com/queryOrder?" + text;
			UnityEngine.Debug.Log("final url is " + text2);
			WebRequest webRequest = WebRequest.Create(text2);
			webRequest.Credentials = CredentialCache.DefaultCredentials;
			webRequest.Method = "GET";
			WebResponse response = webRequest.GetResponse();
			Stream responseStream = response.GetResponseStream();
			StreamReader streamReader = new StreamReader(responseStream);
			string text3 = streamReader.ReadToEnd();
			UnityEngine.Debug.Log("response is " + text3);
			streamReader.Close();
			response.Close();
			QueryResult queryResult = JsonUtility.FromJson<QueryResult>(text3);
			VerificationInfo result = default(VerificationInfo);
			if (queryResult.code == 0)
			{
				result.Status = QueryStatus.Success;
				if (queryResult.data != null)
				{
					result.PayedAmount = queryResult.data.buyerPayAmount;
					result.IsPayed = queryResult.data.paymentStatus.Equals("TRADE_SUCCESS");
					if (queryResult.data.paymentType == "ALIPAY")
					{
						result.PayType = PayType.ALIPAY;
					}
					else
					{
						result.PayType = PayType.Unknown;
					}
				}
			}
			else if (queryResult.code == 1353)
			{
				result.Status = QueryStatus.WrongParameter;
			}
			return result;
		}
	}
}
namespace OVR
{
	public class AmbienceEmitter : MonoBehaviour
	{
		public SoundFXRef[] ambientSounds = new SoundFXRef[0];

		public bool autoActivate = true;

		[Tooltip("Automatically play the sound randomly again when checked.  Should be OFF for looping sounds")]
		public bool autoRetrigger = true;

		[MinMax(2f, 4f, 0.1f, 10f)]
		public Vector2 randomRetriggerDelaySecs = new Vector2(2f, 4f);

		[Tooltip("If defined, the sounds will randomly play from these transform positions, otherwise the sound will play from this transform")]
		public Transform[] playPositions = new Transform[0];

		private bool activated;

		private int playingIdx = -1;

		private float nextPlayTime;

		private float fadeTime = 0.25f;

		private int lastPosIdx = -1;

		private void Awake()
		{
			if (autoActivate)
			{
				activated = true;
				nextPlayTime = Time.time + UnityEngine.Random.Range(randomRetriggerDelaySecs.x, randomRetriggerDelaySecs.y);
			}
			Transform[] array = playPositions;
			foreach (Transform transform in array)
			{
				if (transform == null)
				{
					UnityEngine.Debug.LogWarning("[AmbienceEmitter] Invalid play positions in " + base.name);
					playPositions = new Transform[0];
					break;
				}
			}
		}

		private void Update()
		{
			if (activated && (playingIdx == -1 || autoRetrigger) && Time.time >= nextPlayTime)
			{
				Play();
				if (!autoRetrigger)
				{
					activated = false;
				}
			}
		}

		public void OnTriggerEnter(Collider col)
		{
			activated = !activated;
		}

		public void Play()
		{
			Transform transform = base.transform;
			if (playPositions.Length > 0)
			{
				int num = UnityEngine.Random.Range(0, playPositions.Length);
				while (playPositions.Length > 1 && num == lastPosIdx)
				{
					num = UnityEngine.Random.Range(0, playPositions.Length);
				}
				transform = playPositions[num];
				lastPosIdx = num;
			}
			playingIdx = ambientSounds[UnityEngine.Random.Range(0, ambientSounds.Length)].PlaySoundAt(transform.position);
			if (playingIdx != -1)
			{
				AudioManager.FadeInSound(playingIdx, fadeTime);
				nextPlayTime = Time.time + UnityEngine.Random.Range(randomRetriggerDelaySecs.x, randomRetriggerDelaySecs.y);
			}
		}

		public void EnableEmitter(bool enable)
		{
			activated = enable;
			if (enable)
			{
				Play();
			}
			else if (playingIdx != -1)
			{
				AudioManager.FadeOutSound(playingIdx, fadeTime);
			}
		}
	}
	public enum PreloadSounds
	{
		Default,
		Preload,
		ManualPreload
	}
	public enum Fade
	{
		In,
		Out
	}
	[Serializable]
	public class SoundGroup
	{
		public string name = string.Empty;

		public SoundFX[] soundList = new SoundFX[0];

		public AudioMixerGroup mixerGroup;

		[Range(0f, 64f)]
		public int maxPlayingSounds;

		public PreloadSounds preloadAudio;

		public float volumeOverride = 1f;

		[HideInInspector]
		public int playingSoundCount;

		public SoundGroup(string name)
		{
			this.name = name;
		}

		public SoundGroup()
		{
			mixerGroup = null;
			maxPlayingSounds = 0;
			preloadAudio = PreloadSounds.Default;
			volumeOverride = 1f;
		}

		public void IncrementPlayCount()
		{
			playingSoundCount = Mathf.Clamp(++playingSoundCount, 0, maxPlayingSounds);
		}

		public void DecrementPlayCount()
		{
			playingSoundCount = Mathf.Clamp(--playingSoundCount, 0, maxPlayingSounds);
		}

		public bool CanPlaySound()
		{
			return maxPlayingSounds == 0 || playingSoundCount < maxPlayingSounds;
		}
	}
	public class AudioManager : MonoBehaviour
	{
		public enum Fade
		{
			In,
			Out
		}

		[Tooltip("Make the audio manager persistent across all scene loads")]
		public bool makePersistent = true;

		[Tooltip("Enable the OSP audio plugin features")]
		public bool enableSpatializedAudio = true;

		[Tooltip("Always play spatialized sounds with no reflections (Default)")]
		public bool enableSpatializedFastOverride;

		[Tooltip("The audio mixer asset used for snapshot blends, etc.")]
		public AudioMixer audioMixer;

		[Tooltip("The audio mixer group used for the pooled emitters")]
		public AudioMixerGroup defaultMixerGroup;

		[Tooltip("The audio mixer group used for the reserved pool emitter")]
		public AudioMixerGroup reservedMixerGroup;

		[Tooltip("The audio mixer group used for voice chat")]
		public AudioMixerGroup voiceChatMixerGroup;

		[Tooltip("Log all PlaySound calls to the Unity console")]
		public bool verboseLogging;

		[Tooltip("Maximum sound emitters")]
		public int maxSoundEmitters = 32;

		[Tooltip("Default volume for all sounds modulated by individual sound FX volumes")]
		public float volumeSoundFX = 1f;

		[Tooltip("Sound FX fade time")]
		public float soundFxFadeSecs = 1f;

		public float audioMinFallOffDistance = 1f;

		public float audioMaxFallOffDistance = 25f;

		public SoundGroup[] soundGroupings = new SoundGroup[0];

		private Dictionary<string, SoundFX> soundFXCache;

		private static AudioManager theAudioManager = null;

		private static FastList<string> names = new FastList<string>();

		private static string[] defaultSound = new string[1] { "Default Sound" };

		private static SoundFX nullSound = new SoundFX();

		private static bool hideWarnings = false;

		private float audioMaxFallOffDistanceSqr = 625f;

		private SoundEmitter[] soundEmitters;

		private FastList<SoundEmitter> playingEmitters = new FastList<SoundEmitter>();

		private FastList<SoundEmitter> nextFreeEmitters = new FastList<SoundEmitter>();

		private MixerSnapshot currentSnapshot;

		private static GameObject soundEmitterParent = null;

		private static Transform staticListenerPosition = null;

		private static bool showPlayingEmitterCount = false;

		private static bool forceShowEmitterCount = false;

		private static bool soundEnabled = true;

		private static readonly AnimationCurve defaultReverbZoneMix = new AnimationCurve(new Keyframe(0f, 1f), new Keyframe(1f, 1f));

		public static bool enableSpatialization => theAudioManager != null && theAudioManager.enableSpatializedAudio;

		public static AudioManager Instance => theAudioManager;

		public static float NearFallOff => theAudioManager.audioMinFallOffDistance;

		public static float FarFallOff => theAudioManager.audioMaxFallOffDistance;

		public static AudioMixerGroup EmitterGroup => theAudioManager.defaultMixerGroup;

		public static AudioMixerGroup ReservedGroup => theAudioManager.reservedMixerGroup;

		public static AudioMixerGroup VoipGroup => theAudioManager.voiceChatMixerGroup;

		public static bool SoundEnabled => soundEnabled;

		private void Awake()
		{
			Init();
		}

		private void OnDestroy()
		{
			if (theAudioManager == this && soundEmitterParent != null)
			{
				UnityEngine.Object.Destroy(soundEmitterParent);
			}
		}

		private void Init()
		{
			if (theAudioManager != null)
			{
				if (UnityEngine.Application.isPlaying && theAudioManager != this)
				{
					base.enabled = false;
				}
				return;
			}
			theAudioManager = this;
			nullSound.name = "Default Sound";
			RebuildSoundFXCache();
			if (UnityEngine.Application.isPlaying)
			{
				InitializeSoundSystem();
				if (makePersistent && base.transform.parent == null)
				{
					UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
				}
			}
		}

		private void Update()
		{
			UpdateFreeEmitters();
		}

		private void RebuildSoundFXCache()
		{
			int num = 0;
			for (int i = 0; i < soundGroupings.Length; i++)
			{
				num += soundGroupings[i].soundList.Length;
			}
			soundFXCache = new Dictionary<string, SoundFX>(num + 1);
			soundFXCache.Add(nullSound.name, nullSound);
			for (int j = 0; j < soundGroupings.Length; j++)
			{
				for (int k = 0; k < soundGroupings[j].soundList.Length; k++)
				{
					if (soundFXCache.ContainsKey(soundGroupings[j].soundList[k].name))
					{
						UnityEngine.Debug.LogError("ERROR: Duplicate Sound FX name in the audio manager: '" + soundGroupings[j].name + "' > '" + soundGroupings[j].soundList[k].name + "'");
					}
					else
					{
						soundGroupings[j].soundList[k].Group = soundGroupings[j];
						soundFXCache.Add(soundGroupings[j].soundList[k].name, soundGroupings[j].soundList[k]);
					}
				}
				soundGroupings[j].playingSoundCount = 0;
			}
		}

		public static SoundFX FindSoundFX(string name, bool rebuildCache = false)
		{
			if (string.IsNullOrEmpty(name))
			{
				return nullSound;
			}
			if (rebuildCache)
			{
				theAudioManager.RebuildSoundFXCache();
			}
			if (!theAudioManager.soundFXCache.ContainsKey(name))
			{
				return nullSound;
			}
			return theAudioManager.soundFXCache[name];
		}

		private static bool FindAudioManager()
		{
			GameObject gameObject = GameObject.Find("AudioManager");
			if (gameObject == null || gameObject.GetComponent<AudioManager>() == null)
			{
				if (!hideWarnings)
				{
					UnityEngine.Debug.LogError("[ERROR] AudioManager object missing from hierarchy!");
					hideWarnings = true;
				}
				return false;
			}
			gameObject.GetComponent<AudioManager>().Init();
			return true;
		}

		public static GameObject GetGameObject()
		{
			if (theAudioManager == null && !FindAudioManager())
			{
				return null;
			}
			return theAudioManager.gameObject;
		}

		public static string NameMinusGroup(string name)
		{
			if (name.IndexOf("/") > -1)
			{
				return name.Substring(name.IndexOf("/") + 1);
			}
			return name;
		}

		public static string[] GetSoundFXNames(string currentValue, out int currentIdx)
		{
			currentIdx = 0;
			names.Clear();
			if (theAudioManager == null && !FindAudioManager())
			{
				return defaultSound;
			}
			names.Add(nullSound.name);
			for (int i = 0; i < theAudioManager.soundGroupings.Length; i++)
			{
				for (int j = 0; j < theAudioManager.soundGroupings[i].soundList.Length; j++)
				{
					if (string.Compare(currentValue, theAudioManager.soundGroupings[i].soundList[j].name, ignoreCase: true) == 0)
					{
						currentIdx = names.Count;
					}
					names.Add(theAudioManager.soundGroupings[i].name + "/" + theAudioManager.soundGroupings[i].soundList[j].name);
				}
			}
			return names.ToArray();
		}

		private void InitializeSoundSystem()
		{
			int bufferLength = 960;
			int numBuffers = 4;
			AudioSettings.GetDSPBufferSize(out bufferLength, out numBuffers);
			if (UnityEngine.Application.isPlaying)
			{
				UnityEngine.Debug.Log("[AudioManager] Audio Sample Rate: " + AudioSettings.outputSampleRate);
				UnityEngine.Debug.Log("[AudioManager] Audio Buffer Length: " + bufferLength + " Size: " + numBuffers);
			}
			AudioListener audioListener = UnityEngine.Object.FindObjectOfType<AudioListener>();
			if (audioListener == null)
			{
				UnityEngine.Debug.LogError("[AudioManager] Missing AudioListener object!  Add one to the scene.");
			}
			else
			{
				staticListenerPosition = audioListener.transform;
			}
			soundEmitters = new SoundEmitter[maxSoundEmitters + 1];
			soundEmitterParent = GameObject.Find("__SoundEmitters__");
			if (soundEmitterParent != null)
			{
				UnityEngine.Object.Destroy(soundEmitterParent);
			}
			soundEmitterParent = new GameObject("__SoundEmitters__");
			for (int i = 0; i < maxSoundEmitters + 1; i++)
			{
				GameObject gameObject = new GameObject("SoundEmitter_" + i);
				gameObject.transform.parent = soundEmitterParent.transform;
				gameObject.transform.position = Vector3.zero;
				gameObject.hideFlags = HideFlags.DontSaveInEditor;
				soundEmitters[i] = gameObject.AddComponent<SoundEmitter>();
				soundEmitters[i].SetDefaultParent(soundEmitterParent.transform);
				soundEmitters[i].SetChannel(i);
				soundEmitters[i].Stop();
				soundEmitters[i].originalIdx = i;
			}
			ResetFreeEmitters();
			soundEmitterParent.hideFlags = HideFlags.DontSaveInEditor;
			audioMaxFallOffDistanceSqr = audioMaxFallOffDistance * audioMaxFallOffDistance;
		}

		private void UpdateFreeEmitters()
		{
			if (verboseLogging)
			{
				if (Input.GetKeyDown(KeyCode.A))
				{
					forceShowEmitterCount = !forceShowEmitterCount;
				}
				if (forceShowEmitterCount)
				{
					showPlayingEmitterCount = true;
				}
			}
			int num = 0;
			int num2 = 0;
			int num3 = 0;
			int num4 = 0;
			int num5 = 0;
			int num6 = 0;
			int num7 = 0;
			while (num7 < playingEmitters.size)
			{
				if (playingEmitters[num7] == null)
				{
					UnityEngine.Debug.LogError("[AudioManager] ERROR: playingEmitters list had a null emitter! Something nuked a sound emitter!!!");
					playingEmitters.RemoveAtFast(num7);
					return;
				}
				if (!playingEmitters[num7].IsPlaying())
				{
					if (verboseLogging && nextFreeEmitters.Contains(playingEmitters[num7]))
					{
						UnityEngine.Debug.LogError("[AudioManager] ERROR: playing sound emitter already in the free emitters list!");
					}
					playingEmitters[num7].Stop();
					nextFreeEmitters.Add(playingEmitters[num7]);
					playingEmitters.RemoveAtFast(num7);
					continue;
				}
				if (verboseLogging && showPlayingEmitterCount)
				{
					num++;
					switch (playingEmitters[num7].priority)
					{
					case SoundPriority.VeryLow:
						num2++;
						break;
					case SoundPriority.Low:
						num3++;
						break;
					case SoundPriority.Default:
						num4++;
						break;
					case SoundPriority.High:
						num5++;
						break;
					case SoundPriority.VeryHigh:
						num6++;
						break;
					}
				}
				num7++;
			}
			if (verboseLogging && showPlayingEmitterCount)
			{
				UnityEngine.Debug.LogWarning($"[AudioManager] Playing sounds: Total {Fmt(num)} | VeryLow {Fmt(num2)} | Low {Fmt(num3)} | Default {Fmt(num4)} | High {Fmt(num5)} | VeryHigh {Fmt(num6)} | Free {FmtFree(nextFreeEmitters.Count)}");
				showPlayingEmitterCount = false;
			}
		}

		private string Fmt(int count)
		{
			float num = (float)count / (float)theAudioManager.maxSoundEmitters;
			if (num < 0.5f)
			{
				return "<color=green>" + count + "</color>";
			}
			if ((double)num < 0.7)
			{
				return "<color=yellow>" + count + "</color>";
			}
			return "<color=red>" + count + "</color>";
		}

		private string FmtFree(int count)
		{
			float num = (float)count / (float)theAudioManager.maxSoundEmitters;
			if (num < 0.2f)
			{
				return "<color=red>" + count + "</color>";
			}
			if ((double)num < 0.3)
			{
				return "<color=yellow>" + count + "</color>";
			}
			return "<color=green>" + count + "</color>";
		}

		private void OnPreSceneLoad()
		{
			UnityEngine.Debug.Log("[AudioManager] OnPreSceneLoad cleanup");
			for (int i = 0; i < soundEmitters.Length; i++)
			{
				soundEmitters[i].Stop();
				soundEmitters[i].ResetParent(soundEmitterParent.transform);
			}
			ResetFreeEmitters();
		}

		private void ResetFreeEmitters()
		{
			nextFreeEmitters.Clear();
			playingEmitters.Clear();
			for (int i = 1; i < soundEmitters.Length; i++)
			{
				nextFreeEmitters.Add(soundEmitters[i]);
			}
		}

		public static void FadeOutSoundChannel(int channel, float delaySecs, float fadeTime)
		{
			theAudioManager.soundEmitters[channel].FadeOutDelayed(delaySecs, fadeTime);
		}

		public static bool StopSound(int idx, bool fadeOut = true, bool stopReserved = false)
		{
			if (!stopReserved && idx == 0)
			{
				return false;
			}
			if (!fadeOut)
			{
				theAudioManager.soundEmitters[idx].Stop();
			}
			else
			{
				theAudioManager.soundEmitters[idx].FadeOut(theAudioManager.soundFxFadeSecs);
			}
			return true;
		}

		public static void FadeInSound(int idx, float fadeTime, float volume)
		{
			theAudioManager.soundEmitters[idx].FadeIn(fadeTime, volume);
		}

		public static void FadeInSound(int idx, float fadeTime)
		{
			theAudioManager.soundEmitters[idx].FadeIn(fadeTime);
		}

		public static void FadeOutSound(int idx, float fadeTime)
		{
			theAudioManager.soundEmitters[idx].FadeOut(fadeTime);
		}

		public static void StopAllSounds(bool fadeOut, bool stopReserved = false)
		{
			for (int i = 0; i < theAudioManager.soundEmitters.Length; i++)
			{
				StopSound(i, fadeOut, stopReserved);
			}
		}

		public void MuteAllSounds(bool mute, bool muteReserved = false)
		{
			for (int i = 0; i < soundEmitters.Length; i++)
			{
				if (muteReserved || i != 0)
				{
					soundEmitters[i].audioSource.mute = true;
				}
			}
		}

		public void UnMuteAllSounds(bool unmute, bool unmuteReserved = false)
		{
			for (int i = 0; i < soundEmitters.Length; i++)
			{
				if ((unmuteReserved || i != 0) && soundEmitters[i].audioSource.isPlaying)
				{
					soundEmitters[i].audioSource.mute = false;
				}
			}
		}

		public static float GetEmitterEndTime(int idx)
		{
			return theAudioManager.soundEmitters[idx].endPlayTime;
		}

		public static float SetEmitterTime(int idx, float time)
		{
			theAudioManager.soundEmitters[idx].time = time;
			return time;
		}

		public static int PlaySound(AudioClip clip, float volume, EmitterChannel src = EmitterChannel.Any, float delay = 0f, float pitchVariance = 1f, bool loop = false)
		{
			if (!SoundEnabled)
			{
				return -1;
			}
			return PlaySoundAt((!(staticListenerPosition != null)) ? Vector3.zero : staticListenerPosition.position, clip, volume, src, delay, pitchVariance, loop);
		}

		private static int FindFreeEmitter(EmitterChannel src, SoundPriority priority)
		{
			SoundEmitter soundEmitter = theAudioManager.soundEmitters[0];
			if (src == EmitterChannel.Any)
			{
				if (theAudioManager.nextFreeEmitters.size > 0)
				{
					soundEmitter = theAudioManager.nextFreeEmitters[0];
					theAudioManager.nextFreeEmitters.RemoveAtFast(0);
				}
				else
				{
					if (priority == SoundPriority.VeryLow)
					{
						return -1;
					}
					soundEmitter = theAudioManager.playingEmitters.Find((SoundEmitter item) => item != null && item.priority < priority);
					if (soundEmitter == null)
					{
						if (priority < SoundPriority.Default)
						{
							if (theAudioManager.verboseLogging)
							{
								UnityEngine.Debug.LogWarning("[AudioManager] skipping sound " + priority);
							}
							return -1;
						}
						soundEmitter = theAudioManager.playingEmitters.Find((SoundEmitter item) => item != null && item.priority <= SoundPriority.Default);
					}
					if (soundEmitter != null)
					{
						if (theAudioManager.verboseLogging)
						{
							UnityEngine.Debug.LogWarning("[AudioManager] cannabalizing " + soundEmitter.originalIdx + " Time: " + Time.time);
						}
						soundEmitter.Stop();
						theAudioManager.playingEmitters.RemoveFast(soundEmitter);
					}
				}
			}
			if (soundEmitter == null)
			{
				UnityEngine.Debug.LogError(string.Concat("[AudioManager] ERROR - absolutely couldn't find a free emitter! Priority = ", priority, " TOO MANY PlaySound* calls!"));
				showPlayingEmitterCount = true;
				return -1;
			}
			return soundEmitter.originalIdx;
		}

		public static int PlaySound(SoundFX soundFX, EmitterChannel src = EmitterChannel.Any, float delay = 0f)
		{
			if (!SoundEnabled)
			{
				return -1;
			}
			return PlaySoundAt((!(staticListenerPosition != null)) ? Vector3.zero : staticListenerPosition.position, soundFX, src, delay);
		}

		public static int PlaySoundAt(Vector3 position, SoundFX soundFX, EmitterChannel src = EmitterChannel.Any, float delay = 0f, float volumeOverride = 1f, float pitchMultiplier = 1f)
		{
			if (!SoundEnabled)
			{
				return -1;
			}
			AudioClip clip = soundFX.GetClip();
			if (clip == null)
			{
				return -1;
			}
			if (staticListenerPosition != null)
			{
				float sqrMagnitude = (staticListenerPosition.position - position).sqrMagnitude;
				if (sqrMagnitude > theAudioManager.audioMaxFallOffDistanceSqr)
				{
					return -1;
				}
				if (sqrMagnitude > soundFX.MaxFalloffDistSquared)
				{
					return -1;
				}
			}
			if (soundFX.ReachedGroupPlayLimit())
			{
				if (theAudioManager.verboseLogging)
				{
					UnityEngine.Debug.Log("[AudioManager] PlaySoundAt() with " + soundFX.name + " skipped due to group play limit");
				}
				return -1;
			}
			int num = FindFreeEmitter(src, soundFX.priority);
			if (num == -1)
			{
				return -1;
			}
			SoundEmitter soundEmitter = theAudioManager.soundEmitters[num];
			soundEmitter.ResetParent(soundEmitterParent.transform);
			soundEmitter.gameObject.SetActive(value: true);
			AudioSource source = soundEmitter.audioSource;
			ONSPAudioSource osp = soundEmitter.osp;
			source.enabled = true;
			source.volume = Mathf.Clamp01(Mathf.Clamp01(theAudioManager.volumeSoundFX * soundFX.volume) * volumeOverride * soundFX.GroupVolumeOverride);
			source.pitch = soundFX.GetPitch() * pitchMultiplier;
			source.time = 0f;
			source.spatialBlend = 1f;
			source.rolloffMode = soundFX.falloffCurve;
			if (soundFX.falloffCurve == AudioRolloffMode.Custom)
			{
				source.SetCustomCurve(AudioSourceCurveType.CustomRolloff, soundFX.volumeFalloffCurve);
			}
			source.SetCustomCurve(AudioSourceCurveType.ReverbZoneMix, soundFX.reverbZoneMix);
			source.dopplerLevel = 0f;
			source.clip = clip;
			source.spread = soundFX.spread;
			source.loop = soundFX.looping;
			source.mute = false;
			source.minDistance = soundFX.falloffDistance.x;
			source.maxDistance = soundFX.falloffDistance.y;
			source.outputAudioMixerGroup = soundFX.GetMixerGroup(EmitterGroup);
			soundEmitter.endPlayTime = Time.time + clip.length + delay;
			soundEmitter.defaultVolume = source.volume;
			soundEmitter.priority = soundFX.priority;
			soundEmitter.onFinished = null;
			soundEmitter.SetPlayingSoundGroup(soundFX.Group);
			if (src == EmitterChannel.Any)
			{
				theAudioManager.playingEmitters.AddUnique(soundEmitter);
			}
			if (osp != null)
			{
				osp.EnableSpatialization = soundFX.ospProps.enableSpatialization;
				osp.EnableRfl = ((theAudioManager.enableSpatializedFastOverride || soundFX.ospProps.useFastOverride) ? true : false);
				osp.Gain = soundFX.ospProps.gain;
				osp.UseInvSqr = soundFX.ospProps.enableInvSquare;
				osp.Near = soundFX.ospProps.invSquareFalloff.x;
				osp.Far = soundFX.ospProps.invSquareFalloff.y;
				source.spatialBlend = ((!soundFX.ospProps.enableSpatialization) ? 0.8f : 1f);
				osp.SetParameters(ref source);
			}
			source.transform.position = position;
			if (theAudioManager.verboseLogging)
			{
				UnityEngine.Debug.Log("[AudioManager] PlaySoundAt() channel = " + num + " soundFX = " + soundFX.name + " volume = " + soundEmitter.volume + " Delay = " + delay + " time = " + Time.time + "\n");
			}
			if (delay > 0f)
			{
				source.PlayDelayed(delay);
			}
			else
			{
				source.Play();
			}
			return num;
		}

		public static int PlayRandomSoundAt(Vector3 position, AudioClip[] clips, float volume, EmitterChannel src = EmitterChannel.Any, float delay = 0f, float pitch = 1f, bool loop = false)
		{
			if (clips == null || clips.Length == 0)
			{
				return -1;
			}
			int num = UnityEngine.Random.Range(0, clips.Length);
			return PlaySoundAt(position, clips[num], volume, src, delay, pitch, loop);
		}

		public static int PlaySoundAt(Vector3 position, AudioClip clip, float volume = 1f, EmitterChannel src = EmitterChannel.Any, float delay = 0f, float pitch = 1f, bool loop = false)
		{
			if (!SoundEnabled)
			{
				return -1;
			}
			if (clip == null)
			{
				return -1;
			}
			if (staticListenerPosition != null && (staticListenerPosition.position - position).sqrMagnitude > theAudioManager.audioMaxFallOffDistanceSqr)
			{
				return -1;
			}
			int num = FindFreeEmitter(src, SoundPriority.Default);
			if (num == -1)
			{
				return -1;
			}
			SoundEmitter soundEmitter = theAudioManager.soundEmitters[num];
			soundEmitter.ResetParent(soundEmitterParent.transform);
			soundEmitter.gameObject.SetActive(value: true);
			AudioSource audioSource = soundEmitter.audioSource;
			ONSPAudioSource osp = soundEmitter.osp;
			audioSource.enabled = true;
			audioSource.volume = Mathf.Clamp01(theAudioManager.volumeSoundFX * volume);
			audioSource.pitch = pitch;
			audioSource.spatialBlend = 0.8f;
			audioSource.rolloffMode = AudioRolloffMode.Linear;
			audioSource.SetCustomCurve(AudioSourceCurveType.ReverbZoneMix, defaultReverbZoneMix);
			audioSource.dopplerLevel = 0f;
			audioSource.clip = clip;
			audioSource.spread = 0f;
			audioSource.loop = loop;
			audioSource.mute = false;
			audioSource.minDistance = theAudioManager.audioMinFallOffDistance;
			audioSource.maxDistance = theAudioManager.audioMaxFallOffDistance;
			audioSource.outputAudioMixerGroup = EmitterGroup;
			soundEmitter.endPlayTime = Time.time + clip.length + delay;
			soundEmitter.defaultVolume = audioSource.volume;
			soundEmitter.priority = SoundPriority.Default;
			soundEmitter.onFinished = null;
			soundEmitter.SetPlayingSoundGroup(null);
			if (src == EmitterChannel.Any)
			{
				theAudioManager.playingEmitters.AddUnique(soundEmitter);
			}
			if (osp != null)
			{
				osp.EnableSpatialization = false;
			}
			audioSource.transform.position = position;
			if (theAudioManager.verboseLogging)
			{
				UnityEngine.Debug.Log("[AudioManager] PlaySoundAt() channel = " + num + " clip = " + clip.name + " volume = " + soundEmitter.volume + " Delay = " + delay + " time = " + Time.time + "\n");
			}
			if (delay > 0f)
			{
				audioSource.PlayDelayed(delay);
			}
			else
			{
				audioSource.Play();
			}
			return num;
		}

		public static void SetOnFinished(int emitterIdx, Action onFinished)
		{
			if (emitterIdx >= 0 && emitterIdx < theAudioManager.maxSoundEmitters)
			{
				theAudioManager.soundEmitters[emitterIdx].SetOnFinished(onFinished);
			}
		}

		public static void SetOnFinished(int emitterIdx, Action<object> onFinished, object obj)
		{
			if (emitterIdx >= 0 && emitterIdx < theAudioManager.maxSoundEmitters)
			{
				theAudioManager.soundEmitters[emitterIdx].SetOnFinished(onFinished, obj);
			}
		}

		public static void AttachSoundToParent(int idx, Transform parent)
		{
			if (theAudioManager.verboseLogging)
			{
				string text = parent.name;
				if (parent.parent != null)
				{
					text = parent.parent.name + "/" + text;
				}
				UnityEngine.Debug.Log("[AudioManager] ATTACHING INDEX " + idx + " to " + text);
			}
			theAudioManager.soundEmitters[idx].ParentTo(parent);
		}

		public static void DetachSoundFromParent(int idx)
		{
			if (theAudioManager.verboseLogging)
			{
				UnityEngine.Debug.Log("[AudioManager] DETACHING INDEX " + idx);
			}
			theAudioManager.soundEmitters[idx].DetachFromParent();
		}

		public static void DetachSoundsFromParent(SoundEmitter[] emitters, bool stopSounds = true)
		{
			if (emitters == null)
			{
				return;
			}
			foreach (SoundEmitter soundEmitter in emitters)
			{
				if (soundEmitter.defaultParent != null)
				{
					if (stopSounds)
					{
						soundEmitter.Stop();
					}
					soundEmitter.DetachFromParent();
					soundEmitter.gameObject.SetActive(value: true);
				}
				else if (stopSounds)
				{
					soundEmitter.Stop();
				}
			}
		}

		public static void SetEmitterMixerGroup(int idx, AudioMixerGroup mixerGroup)
		{
			if (theAudioManager != null && idx > -1)
			{
				theAudioManager.soundEmitters[idx].SetAudioMixer(mixerGroup);
			}
		}

		public static MixerSnapshot GetActiveSnapshot()
		{
			return (!(theAudioManager != null)) ? null : theAudioManager.currentSnapshot;
		}

		public static void SetCurrentSnapshot(MixerSnapshot mixerSnapshot)
		{
			if (theAudioManager != null)
			{
				if (mixerSnapshot != null && mixerSnapshot.snapshot != null)
				{
					mixerSnapshot.snapshot.TransitionTo(mixerSnapshot.transitionTime);
				}
				else
				{
					mixerSnapshot = null;
				}
				theAudioManager.currentSnapshot = mixerSnapshot;
			}
		}

		public static void BlendWithCurrentSnapshot(MixerSnapshot blendSnapshot, float weight, float blendTime = 0f)
		{
			if (!(theAudioManager != null))
			{
				return;
			}
			if (theAudioManager.audioMixer == null)
			{
				UnityEngine.Debug.LogWarning("[AudioManager] can't call BlendWithCurrentSnapshot if the audio mixer is not set!");
				return;
			}
			if (blendTime == 0f)
			{
				blendTime = Time.deltaTime;
			}
			if (theAudioManager.currentSnapshot != null && theAudioManager.currentSnapshot.snapshot != null && blendSnapshot != null && blendSnapshot.snapshot != null)
			{
				weight = Mathf.Clamp01(weight);
				if (weight == 0f)
				{
					theAudioManager.currentSnapshot.snapshot.TransitionTo(blendTime);
					return;
				}
				AudioMixerSnapshot[] snapshots = new AudioMixerSnapshot[2]
				{
					theAudioManager.currentSnapshot.snapshot,
					blendSnapshot.snapshot
				};
				float[] weights = new float[2]
				{
					1f - weight,
					weight
				};
				theAudioManager.audioMixer.TransitionToSnapshots(snapshots, weights, blendTime);
			}
		}
	}
	public enum EmitterChannel
	{
		None = -1,
		Reserved,
		Any
	}
	[Serializable]
	public class MixerSnapshot
	{
		public AudioMixerSnapshot snapshot;

		public float transitionTime = 0.25f;
	}
	public class MinMaxAttribute : PropertyAttribute
	{
		public float minDefaultVal = 1f;

		public float maxDefaultVal = 1f;

		public float min;

		public float max = 1f;

		public MinMaxAttribute(float minDefaultVal, float maxDefaultVal, float min, float max)
		{
			this.minDefaultVal = minDefaultVal;
			this.maxDefaultVal = maxDefaultVal;
			this.min = min;
			this.max = max;
		}
	}
	public class SoundEmitter : MonoBehaviour
	{
		public enum FadeState
		{
			Null,
			FadingIn,
			FadingOut,
			Ducking
		}

		public EmitterChannel channel;

		public bool disableSpatialization;

		private FadeState state;

		[NonSerialized]
		[HideInInspector]
		public AudioSource audioSource;

		[NonSerialized]
		[HideInInspector]
		public SoundPriority priority;

		[NonSerialized]
		[HideInInspector]
		public ONSPAudioSource osp;

		[NonSerialized]
		[HideInInspector]
		public float endPlayTime;

		private Transform lastParentTransform;

		[NonSerialized]
		[HideInInspector]
		public float defaultVolume = 1f;

		[NonSerialized]
		[HideInInspector]
		public Transform defaultParent;

		[NonSerialized]
		[HideInInspector]
		public int originalIdx = -1;

		[NonSerialized]
		[HideInInspector]
		public Action onFinished;

		[NonSerialized]
		[HideInInspector]
		public Action<object> onFinishedObject;

		[NonSerialized]
		[HideInInspector]
		public object onFinishedParam;

		[NonSerialized]
		[HideInInspector]
		public SoundGroup playingSoundGroup;

		public float volume
		{
			get
			{
				return audioSource.volume;
			}
			set
			{
				audioSource.volume = value;
			}
		}

		public float pitch
		{
			get
			{
				return audioSource.pitch;
			}
			set
			{
				audioSource.pitch = value;
			}
		}

		public AudioClip clip
		{
			get
			{
				return audioSource.clip;
			}
			set
			{
				audioSource.clip = value;
			}
		}

		public float time
		{
			get
			{
				return audioSource.time;
			}
			set
			{
				audioSource.time = value;
			}
		}

		public float length => (!(audioSource.clip != null)) ? 0f : audioSource.clip.length;

		public bool loop
		{
			get
			{
				return audioSource.loop;
			}
			set
			{
				audioSource.loop = value;
			}
		}

		public bool mute
		{
			get
			{
				return audioSource.mute;
			}
			set
			{
				audioSource.mute = value;
			}
		}

		public AudioVelocityUpdateMode velocityUpdateMode
		{
			get
			{
				return audioSource.velocityUpdateMode;
			}
			set
			{
				audioSource.velocityUpdateMode = value;
			}
		}

		public bool isPlaying => audioSource.isPlaying;

		private void Awake()
		{
			audioSource = GetComponent<AudioSource>();
			if (audioSource == null)
			{
				audioSource = base.gameObject.AddComponent<AudioSource>();
			}
			if (AudioManager.enableSpatialization && !disableSpatialization)
			{
				osp = GetComponent<ONSPAudioSource>();
				if (osp == null)
				{
					osp = base.gameObject.AddComponent<ONSPAudioSource>();
				}
			}
			audioSource.playOnAwake = false;
			audioSource.Stop();
		}

		public void SetPlayingSoundGroup(SoundGroup soundGroup)
		{
			playingSoundGroup = soundGroup;
			soundGroup?.IncrementPlayCount();
		}

		public void SetOnFinished(Action onFinished)
		{
			this.onFinished = onFinished;
		}

		public void SetOnFinished(Action<object> onFinished, object obj)
		{
			onFinishedObject = onFinished;
			onFinishedParam = obj;
		}

		public void SetChannel(int _channel)
		{
			channel = (EmitterChannel)_channel;
		}

		public void SetDefaultParent(Transform parent)
		{
			defaultParent = parent;
		}

		public void SetAudioMixer(AudioMixerGroup _mixer)
		{
			if (audioSource != null)
			{
				audioSource.outputAudioMixerGroup = _mixer;
			}
		}

		public bool IsPlaying()
		{
			if (loop && audioSource.isPlaying)
			{
				return true;
			}
			return endPlayTime > Time.time;
		}

		public void Play()
		{
			state = FadeState.Null;
			endPlayTime = Time.time + length;
			StopAllCoroutines();
			audioSource.Play();
		}

		public void Pause()
		{
			state = FadeState.Null;
			StopAllCoroutines();
			audioSource.Pause();
		}

		public void Stop()
		{
			state = FadeState.Null;
			StopAllCoroutines();
			if (audioSource != null)
			{
				audioSource.Stop();
			}
			if (onFinished != null)
			{
				onFinished();
				onFinished = null;
			}
			if (onFinishedObject != null)
			{
				onFinishedObject(onFinishedParam);
				onFinishedObject = null;
			}
			if (playingSoundGroup != null)
			{
				playingSoundGroup.DecrementPlayCount();
				playingSoundGroup = null;
			}
		}

		private int GetSampleTime()
		{
			return audioSource.clip.samples - audioSource.timeSamples;
		}

		public void ParentTo(Transform parent)
		{
			if (lastParentTransform != null)
			{
				UnityEngine.Debug.LogError("[SoundEmitter] You must detach the sound emitter before parenting to another object!");
				return;
			}
			lastParentTransform = base.transform.parent;
			base.transform.parent = parent;
		}

		public void DetachFromParent()
		{
			if (lastParentTransform == null)
			{
				base.transform.parent = defaultParent;
				return;
			}
			base.transform.parent = lastParentTransform;
			lastParentTransform = null;
		}

		public void ResetParent(Transform parent)
		{
			base.transform.parent = parent;
			lastParentTransform = null;
		}

		public void SyncTo(SoundEmitter other, float fadeTime, float toVolume)
		{
			StartCoroutine(DelayedSyncTo(other, fadeTime, toVolume));
		}

		private IEnumerator DelayedSyncTo(SoundEmitter other, float fadeTime, float toVolume)
		{
			yield return new WaitForEndOfFrame();
			audioSource.time = other.time;
			audioSource.Play();
			FadeTo(fadeTime, toVolume);
		}

		public void FadeTo(float fadeTime, float toVolume)
		{
			if (state != FadeState.FadingOut)
			{
				state = FadeState.Ducking;
				StopAllCoroutines();
				StartCoroutine(FadeSoundChannelTo(fadeTime, toVolume));
			}
		}

		public void FadeIn(float fadeTime, float defaultVolume)
		{
			audioSource.volume = 0f;
			state = FadeState.FadingIn;
			StopAllCoroutines();
			StartCoroutine(FadeSoundChannel(0f, fadeTime, Fade.In, defaultVolume));
		}

		public void FadeIn(float fadeTime)
		{
			audioSource.volume = 0f;
			state = FadeState.FadingIn;
			StopAllCoroutines();
			StartCoroutine(FadeSoundChannel(0f, fadeTime, Fade.In, defaultVolume));
		}

		public void FadeOut(float fadeTime)
		{
			if (audioSource.isPlaying)
			{
				state = FadeState.FadingOut;
				StopAllCoroutines();
				StartCoroutine(FadeSoundChannel(0f, fadeTime, Fade.Out, audioSource.volume));
			}
		}

		public void FadeOutDelayed(float delayedSecs, float fadeTime)
		{
			if (audioSource.isPlaying)
			{
				state = FadeState.FadingOut;
				StopAllCoroutines();
				StartCoroutine(FadeSoundChannel(delayedSecs, fadeTime, Fade.Out, audioSource.volume));
			}
		}

		private IEnumerator FadeSoundChannelTo(float fadeTime, float toVolume)
		{
			float start = audioSource.volume;
			float startTime = Time.realtimeSinceStartup;
			float elapsedTime = 0f;
			while (elapsedTime < fadeTime)
			{
				elapsedTime = Time.realtimeSinceStartup - startTime;
				float t = elapsedTime / fadeTime;
				audioSource.volume = Mathf.Lerp(start, toVolume, t);
				yield return 0;
			}
			state = FadeState.Null;
		}

		private IEnumerator FadeSoundChannel(float delaySecs, float fadeTime, Fade fadeType, float defaultVolume)
		{
			if (delaySecs > 0f)
			{
				yield return new WaitForSeconds(delaySecs);
			}
			float start = ((fadeType != 0) ? defaultVolume : 0f);
			float end = ((fadeType != 0) ? 0f : defaultVolume);
			bool restartPlay = false;
			if (fadeType == Fade.In)
			{
				if (Time.time == 0f)
				{
					restartPlay = true;
				}
				audioSource.volume = 0f;
				audioSource.Play();
			}
			float startTime = Time.realtimeSinceStartup;
			float elapsedTime = 0f;
			while (elapsedTime < fadeTime)
			{
				elapsedTime = Time.realtimeSinceStartup - startTime;
				float t = elapsedTime / fadeTime;
				audioSource.volume = Mathf.Lerp(start, end, t);
				yield return 0;
				if (restartPlay && Time.time > 0f)
				{
					audioSource.Play();
					restartPlay = false;
				}
				if (!audioSource.isPlaying)
				{
					break;
				}
			}
			if (fadeType == Fade.Out)
			{
				Stop();
			}
			state = FadeState.Null;
		}
	}
	public enum SoundFXNext
	{
		Random,
		Sequential
	}
	public enum FreqHint
	{
		None,
		Wide,
		Narrow
	}
	public enum SoundPriority
	{
		VeryLow = -2,
		Low,
		Default,
		High,
		VeryHigh
	}
	[Serializable]
	public class OSPProps
	{
		[Tooltip("Set to true to play the sound FX spatialized with binaural HRTF, default = false")]
		public bool enableSpatialization;

		[Tooltip("Play the sound FX with reflections, default = false")]
		public bool useFastOverride;

		[Tooltip("Boost the gain on the spatialized sound FX, default = 0.0")]
		[Range(0f, 24f)]
		public float gain;

		[Tooltip("Enable Inverse Square attenuation curve, default = false")]
		public bool enableInvSquare;

		[Tooltip("Change the sound from point source (0.0f) to a spherical volume, default = 0.0")]
		[Range(0f, 1000f)]
		public float volumetric;

		[Tooltip("Set the near and far falloff value for the OSP attenuation curve, default = 1.0")]
		[MinMax(1f, 25f, 0f, 250f)]
		public Vector2 invSquareFalloff = new Vector2(1f, 25f);

		public OSPProps()
		{
			enableSpatialization = false;
			useFastOverride = false;
			gain = 0f;
			enableInvSquare = false;
			volumetric = 0f;
			invSquareFalloff = new Vector2(1f, 25f);
		}
	}
	[Serializable]
	public class SoundFX
	{
		[Tooltip("Each sound FX should have a unique name")]
		public string name = string.Empty;

		[Tooltip("Sound diversity playback option when multiple audio clips are defined, default = Random")]
		public SoundFXNext playback;

		[Tooltip("Default volume for this sound FX, default = 1.0")]
		[Range(0f, 1f)]
		public float volume = 1f;

		[Tooltip("Random pitch variance each time a sound FX is played, default = 1.0 (none)")]
		[MinMax(1f, 1f, 0f, 2f)]
		public Vector2 pitchVariance = Vector2.one;

		[Tooltip("Falloff distance for the sound FX, default = 1m min to 25m max")]
		[MinMax(1f, 25f, 0f, 250f)]
		public Vector2 falloffDistance = new Vector2(1f, 25f);

		[Tooltip("Volume falloff curve - sets how the sound FX attenuates over distance, default = Linear")]
		public AudioRolloffMode falloffCurve = AudioRolloffMode.Linear;

		[Tooltip("Defines the custom volume falloff curve")]
		public AnimationCurve volumeFalloffCurve = new AnimationCurve(new Keyframe(0f, 1f), new Keyframe(1f, 1f));

		[Tooltip("The amount by which the signal from the AudioSource will be mixed into the global reverb associated with the Reverb Zones | Valid range is 0.0 - 1.1, default = 1.0")]
		public AnimationCurve reverbZoneMix = new AnimationCurve(new Keyframe(0f, 1f), new Keyframe(1f, 1f));

		[Tooltip("Sets the spread angle (in degrees) of a 3d stereo or multichannel sound in speaker space, default = 0")]
		[Range(0f, 360f)]
		public float spread;

		[Tooltip("The percentage chance that this sound FX will play | 0.0 = none, 1.0 = 100%, default = 1.0")]
		[Range(0f, 1f)]
		public float pctChanceToPlay = 1f;

		[Tooltip("Sets the priority for this sound to play and/or to override a currently playing sound FX, default = Default")]
		public SoundPriority priority;

		[Tooltip("Specifies the default delay when this sound FX is played, default = 0.0 secs")]
		[MinMax(0f, 0f, 0f, 2f)]
		public Vector2 delay = Vector2.zero;

		[Tooltip("Set to true for the sound to loop continuously, default = false")]
		public bool looping;

		public OSPProps ospProps = new OSPProps();

		[Tooltip("List of the audio clips assigned to this sound FX")]
		public AudioClip[] soundClips = new AudioClip[1];

		public bool visibilityToggle;

		[NonSerialized]
		private SoundGroup soundGroup;

		private int lastIdx = -1;

		private int playingIdx = -1;

		public int Length => soundClips.Length;

		public bool IsValid => soundClips.Length != 0 && soundClips[0] != null;

		public SoundGroup Group
		{
			get
			{
				return soundGroup;
			}
			set
			{
				soundGroup = value;
			}
		}

		public float MaxFalloffDistSquared => falloffDistance.y * falloffDistance.y;

		public float GroupVolumeOverride => (soundGroup == null) ? 1f : soundGroup.volumeOverride;

		public SoundFX()
		{
			playback = SoundFXNext.Random;
			volume = 1f;
			pitchVariance = Vector2.one;
			falloffDistance = new Vector2(1f, 25f);
			falloffCurve = AudioRolloffMode.Linear;
			volumeFalloffCurve = new AnimationCurve(new Keyframe(0f, 1f), new Keyframe(1f, 1f));
			reverbZoneMix = new AnimationCurve(new Keyframe(0f, 1f), new Keyframe(1f, 1f));
			spread = 0f;
			pctChanceToPlay = 1f;
			priority = SoundPriority.Default;
			delay = Vector2.zero;
			looping = false;
			ospProps = new OSPProps();
		}

		public AudioClip GetClip()
		{
			if (soundClips.Length == 0)
			{
				return null;
			}
			if (soundClips.Length == 1)
			{
				return soundClips[0];
			}
			if (playback == SoundFXNext.Random)
			{
				int num;
				for (num = UnityEngine.Random.Range(0, soundClips.Length); num == lastIdx; num = UnityEngine.Random.Range(0, soundClips.Length))
				{
				}
				lastIdx = num;
				return soundClips[num];
			}
			if (++lastIdx >= soundClips.Length)
			{
				lastIdx = 0;
			}
			return soundClips[lastIdx];
		}

		public AudioMixerGroup GetMixerGroup(AudioMixerGroup defaultMixerGroup)
		{
			if (soundGroup != null)
			{
				return (!(soundGroup.mixerGroup != null)) ? defaultMixerGroup : soundGroup.mixerGroup;
			}
			return defaultMixerGroup;
		}

		public bool ReachedGroupPlayLimit()
		{
			if (soundGroup != null)
			{
				return !soundGroup.CanPlaySound();
			}
			return false;
		}

		public float GetClipLength(int idx)
		{
			if (idx == -1 || soundClips.Length == 0 || idx >= soundClips.Length || soundClips[idx] == null)
			{
				return 0f;
			}
			return soundClips[idx].length;
		}

		public float GetPitch()
		{
			return UnityEngine.Random.Range(pitchVariance.x, pitchVariance.y);
		}

		public int PlaySound(float delaySecs = 0f)
		{
			playingIdx = -1;
			if (!IsValid)
			{
				return playingIdx;
			}
			if (pctChanceToPlay > 0.99f || UnityEngine.Random.value < pctChanceToPlay)
			{
				if (delay.y > 0f)
				{
					delaySecs = UnityEngine.Random.Range(delay.x, delay.y);
				}
				playingIdx = AudioManager.PlaySound(this, EmitterChannel.Any, delaySecs);
			}
			return playingIdx;
		}

		public int PlaySoundAt(Vector3 pos, float delaySecs = 0f, float volumeOverride = 1f, float pitchMultiplier = 1f)
		{
			playingIdx = -1;
			if (!IsValid)
			{
				return playingIdx;
			}
			if (pctChanceToPlay > 0.99f || UnityEngine.Random.value < pctChanceToPlay)
			{
				if (delay.y > 0f)
				{
					delaySecs = UnityEngine.Random.Range(delay.x, delay.y);
				}
				playingIdx = AudioManager.PlaySoundAt(pos, this, EmitterChannel.Any, delaySecs, volumeOverride, pitchMultiplier);
			}
			return playingIdx;
		}

		public void SetOnFinished(Action onFinished)
		{
			if (playingIdx > -1)
			{
				AudioManager.SetOnFinished(playingIdx, onFinished);
			}
		}

		public void SetOnFinished(Action<object> onFinished, object obj)
		{
			if (playingIdx > -1)
			{
				AudioManager.SetOnFinished(playingIdx, onFinished, obj);
			}
		}

		public bool StopSound()
		{
			bool result = false;
			if (playingIdx > -1)
			{
				result = AudioManager.StopSound(playingIdx);
				playingIdx = -1;
			}
			return result;
		}

		public void AttachToParent(Transform parent)
		{
			if (playingIdx > -1)
			{
				AudioManager.AttachSoundToParent(playingIdx, parent);
			}
		}

		public void DetachFromParent()
		{
			if (playingIdx > -1)
			{
				AudioManager.DetachSoundFromParent(playingIdx);
			}
		}
	}
	[Serializable]
	public class SoundFXRef
	{
		public string soundFXName = string.Empty;

		private bool initialized;

		private SoundFX soundFXCached;

		public SoundFX soundFX
		{
			get
			{
				if (!initialized)
				{
					Init();
				}
				return soundFXCached;
			}
		}

		public string name
		{
			get
			{
				return soundFXName;
			}
			set
			{
				soundFXName = value;
				Init();
			}
		}

		public int Length => soundFX.Length;

		public bool IsValid => soundFX.IsValid;

		private void Init()
		{
			soundFXCached = AudioManager.FindSoundFX(soundFXName);
			if (soundFXCached == null)
			{
				soundFXCached = AudioManager.FindSoundFX(string.Empty);
			}
			initialized = true;
		}

		public AudioClip GetClip()
		{
			return soundFX.GetClip();
		}

		public float GetClipLength(int idx)
		{
			return soundFX.GetClipLength(idx);
		}

		public int PlaySound(float delaySecs = 0f)
		{
			return soundFX.PlaySound(delaySecs);
		}

		public int PlaySoundAt(Vector3 pos, float delaySecs = 0f, float volume = 1f, float pitchMultiplier = 1f)
		{
			return soundFX.PlaySoundAt(pos, delaySecs, volume, pitchMultiplier);
		}

		public void SetOnFinished(Action onFinished)
		{
			soundFX.SetOnFinished(onFinished);
		}

		public void SetOnFinished(Action<object> onFinished, object obj)
		{
			soundFX.SetOnFinished(onFinished, obj);
		}

		public bool StopSound()
		{
			return soundFX.StopSound();
		}

		public void AttachToParent(Transform parent)
		{
			soundFX.AttachToParent(parent);
		}

		public void DetachFromParent()
		{
			soundFX.DetachFromParent();
		}
	}
}
public class FastList<T>
{
	public delegate int CompareFunc(T left, T right);

	public T[] array;

	public int size;

	public int Count
	{
		get
		{
			return size;
		}
		set
		{
		}
	}

	public T this[int i]
	{
		get
		{
			return array[i];
		}
		set
		{
			array[i] = value;
		}
	}

	public FastList()
	{
	}

	public FastList(int size)
	{
		if (size > 0)
		{
			this.size = 0;
			array = new T[size];
		}
		else
		{
			this.size = 0;
		}
	}

	public void Add(T item)
	{
		if (array == null || size == array.Length)
		{
			Allocate();
		}
		array[size] = item;
		size++;
	}

	public void AddUnique(T item)
	{
		if (array == null || size == array.Length)
		{
			Allocate();
		}
		if (!Contains(item))
		{
			array[size] = item;
			size++;
		}
	}

	public void AddRange(IEnumerable<T> items)
	{
		foreach (T item in items)
		{
			Add(item);
		}
	}

	public void Insert(int index, T item)
	{
		if (array == null || size == array.Length)
		{
			Allocate();
		}
		if (index < size)
		{
			for (int num = size; num > index; num--)
			{
				array[num] = array[num - 1];
			}
			array[index] = item;
			size++;
		}
		else
		{
			Add(item);
		}
	}

	public bool Remove(T item)
	{
		if (array != null)
		{
			for (int i = 0; i < size; i++)
			{
				if (item.Equals(array[i]))
				{
					size--;
					for (int j = i; j < size; j++)
					{
						array[j] = array[j + 1];
					}
					array[size] = default(T);
					return true;
				}
			}
		}
		return false;
	}

	public void RemoveAt(int index)
	{
		if (array != null && size > 0 && index < size)
		{
			size--;
			for (int i = index; i < size; i++)
			{
				array[i] = array[i + 1];
			}
			array[size] = default(T);
		}
	}

	public bool RemoveFast(T item)
	{
		if (array != null)
		{
			for (int i = 0; i < size; i++)
			{
				if (item.Equals(array[i]))
				{
					if (i < size - 1)
					{
						T val = array[size - 1];
						array[size - 1] = default(T);
						array[i] = val;
					}
					else
					{
						array[i] = default(T);
					}
					size--;
					return true;
				}
			}
		}
		return false;
	}

	public void RemoveAtFast(int index)
	{
		if (array != null && index < size && index >= 0)
		{
			if (index == size - 1)
			{
				array[index] = default(T);
			}
			else
			{
				T val = array[size - 1];
				array[index] = val;
				array[size - 1] = default(T);
			}
			size--;
		}
	}

	public bool Contains(T item)
	{
		if (array == null || size <= 0)
		{
			return false;
		}
		for (int i = 0; i < size; i++)
		{
			if (array[i].Equals(item))
			{
				return true;
			}
		}
		return false;
	}

	public int IndexOf(T item)
	{
		if (size <= 0 || array == null)
		{
			return -1;
		}
		for (int i = 0; i < size; i++)
		{
			if (item.Equals(array[i]))
			{
				return i;
			}
		}
		return -1;
	}

	public T Pop()
	{
		if (array != null && size > 0)
		{
			T result = array[size - 1];
			array[size - 1] = default(T);
			size--;
			return result;
		}
		return default(T);
	}

	public T[] ToArray()
	{
		Trim();
		return array;
	}

	public void Sort(CompareFunc comparer)
	{
		int num = 0;
		int num2 = size - 1;
		bool flag = true;
		while (flag)
		{
			flag = false;
			for (int i = num; i < num2; i++)
			{
				if (comparer(array[i], array[i + 1]) > 0)
				{
					T val = array[i];
					array[i] = array[i + 1];
					array[i + 1] = val;
					flag = true;
				}
				else if (!flag)
				{
					num = ((i != 0) ? (i - 1) : 0);
				}
			}
		}
	}

	public void InsertionSort(CompareFunc comparer)
	{
		for (int i = 1; i < size; i++)
		{
			T val = array[i];
			int num = i;
			while (num > 0 && comparer(array[num - 1], val) > 0)
			{
				array[num] = array[num - 1];
				num--;
			}
			array[num] = val;
		}
	}

	public IEnumerator<T> GetEnumerator()
	{
		if (array != null)
		{
			for (int i = 0; i < size; i++)
			{
				yield return array[i];
			}
		}
	}

	public T Find(Predicate<T> match)
	{
		if (match != null && array != null)
		{
			for (int i = 0; i < size; i++)
			{
				if (match(array[i]))
				{
					return array[i];
				}
			}
		}
		return default(T);
	}

	private void Allocate()
	{
		T[] array = ((this.array != null) ? new T[Mathf.Max(this.array.Length << 1, 32)] : new T[32]);
		if (this.array != null && size > 0)
		{
			this.array.CopyTo(array, 0);
		}
		this.array = array;
	}

	private void Trim()
	{
		if (size > 0)
		{
			T[] array = new T[size];
			for (int i = 0; i < size; i++)
			{
				array[i] = this.array[i];
			}
			this.array = array;
		}
		else
		{
			this.array = null;
		}
	}

	public void Clear()
	{
		size = 0;
	}

	public void Release()
	{
		Clear();
		array = null;
	}
}
public class InspectorNoteAttribute : PropertyAttribute
{
	public readonly string header;

	public readonly string message;

	public InspectorNoteAttribute(string header, string message = "")
	{
		this.header = header;
		this.message = message;
	}
}
public class InspectorCommentAttribute : PropertyAttribute
{
	public readonly string message;

	public InspectorCommentAttribute(string message = "")
	{
		this.message = message;
	}
}
public struct ReflectionSnapshot
{
	public AudioMixerSnapshot mixerSnapshot;

	public float fadeTime;
}
public class ONSPReflectionZone : MonoBehaviour
{
	public AudioMixerSnapshot mixerSnapshot;

	public float fadeTime;

	private static Stack<ReflectionSnapshot> snapshotList = new Stack<ReflectionSnapshot>();

	private static ReflectionSnapshot currentSnapshot = default(ReflectionSnapshot);

	private void Start()
	{
	}

	private void Update()
	{
	}

	private void OnTriggerEnter(Collider other)
	{
		if (CheckForAudioListener(other.gameObject))
		{
			PushCurrentMixerShapshot();
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (CheckForAudioListener(other.gameObject))
		{
			PopCurrentMixerSnapshot();
		}
	}

	private bool CheckForAudioListener(GameObject gameObject)
	{
		AudioListener componentInChildren = gameObject.GetComponentInChildren<AudioListener>();
		if (componentInChildren != null)
		{
			return true;
		}
		return false;
	}

	private void PushCurrentMixerShapshot()
	{
		ReflectionSnapshot item = currentSnapshot;
		snapshotList.Push(item);
		SetReflectionValues();
	}

	private void PopCurrentMixerSnapshot()
	{
		ReflectionSnapshot mss = snapshotList.Pop();
		SetReflectionValues(ref mss);
	}

	private void SetReflectionValues()
	{
		if (mixerSnapshot != null)
		{
			UnityEngine.Debug.Log("Setting off snapshot " + mixerSnapshot.name);
			mixerSnapshot.TransitionTo(fadeTime);
			currentSnapshot.mixerSnapshot = mixerSnapshot;
			currentSnapshot.fadeTime = fadeTime;
		}
		else
		{
			UnityEngine.Debug.Log("Mixer snapshot not set - Please ensure play area has at least one encompassing snapshot.");
		}
	}

	private void SetReflectionValues(ref ReflectionSnapshot mss)
	{
		if (mss.mixerSnapshot != null)
		{
			UnityEngine.Debug.Log("Setting off snapshot " + mss.mixerSnapshot.name);
			mss.mixerSnapshot.TransitionTo(mss.fadeTime);
			currentSnapshot.mixerSnapshot = mss.mixerSnapshot;
			currentSnapshot.fadeTime = mss.fadeTime;
		}
		else
		{
			UnityEngine.Debug.Log("Mixer snapshot not set - Please ensure play area has at least one encompassing snapshot.");
		}
	}
}
public class OculusSpatializerUnity : MonoBehaviour
{
	public delegate void AudioRaycastCallback(Vector3 origin, Vector3 direction, out Vector3 point, out Vector3 normal, IntPtr data);

	public LayerMask layerMask = -1;

	public bool visualizeRoom = true;

	private bool roomVisualizationInitialized;

	public int raysPerSecond = 256;

	public float roomInterpSpeed = 0.9f;

	public float maxWallDistance = 50f;

	public int rayCacheSize = 512;

	public bool dynamicReflectionsEnabled = true;

	private AudioRaycastCallback _raycastCallback;

	private float particleSize = 0.2f;

	private float particleOffset = 0.1f;

	private GameObject room;

	private Renderer[] wallRenderer = new Renderer[6];

	private float[] dims = new float[3] { 1f, 1f, 1f };

	private float[] coefs = new float[6];

	private const int HIT_COUNT = 2048;

	private Vector3[] points = new Vector3[2048];

	private Vector3[] normals = new Vector3[2048];

	private ParticleSystem sys;

	private ParticleSystem.Particle[] particles = new ParticleSystem.Particle[2048];

	private static LayerMask gLayerMask = -1;

	private const string strOSP = "AudioPluginOculusSpatializer";

	private static Vector3 swapHandedness(Vector3 vec)
	{
		return new Vector3(vec.x, vec.y, 0f - vec.z);
	}

	private static void AudioRaycast(Vector3 origin, Vector3 direction, out Vector3 point, out Vector3 normal, IntPtr data)
	{
		point = Vector3.zero;
		normal = Vector3.zero;
		if (Physics.Raycast(swapHandedness(origin), swapHandedness(direction), out var hitInfo, 1000f, gLayerMask.value))
		{
			point = swapHandedness(hitInfo.point);
			normal = swapHandedness(hitInfo.normal);
		}
	}

	private void Start()
	{
		_raycastCallback = AudioRaycast;
		OSP_Unity_AssignRaycastCallback(_raycastCallback, IntPtr.Zero);
	}

	private void OnDestroy()
	{
		OSP_Unity_AssignRaycastCallback(IntPtr.Zero, IntPtr.Zero);
	}

	private void Update()
	{
		if (dynamicReflectionsEnabled)
		{
			OSP_Unity_AssignRaycastCallback(_raycastCallback, IntPtr.Zero);
		}
		else
		{
			OSP_Unity_AssignRaycastCallback(IntPtr.Zero, IntPtr.Zero);
		}
		OSP_Unity_SetDynamicRoomRaysPerSecond(raysPerSecond);
		OSP_Unity_SetDynamicRoomInterpSpeed(roomInterpSpeed);
		OSP_Unity_SetDynamicRoomMaxWallDistance(maxWallDistance);
		OSP_Unity_SetDynamicRoomRaysRayCacheSize(rayCacheSize);
		gLayerMask = layerMask;
		OSP_Unity_UpdateRoomModel(1f);
		if (!visualizeRoom)
		{
			return;
		}
		if (!roomVisualizationInitialized)
		{
			inititalizeRoomVisualization();
			roomVisualizationInitialized = true;
		}
		OSP_Unity_GetRoomDimensions(dims, coefs, out var position);
		position.z *= -1f;
		Vector3 vector = new Vector3(dims[0], dims[1], dims[2]);
		float sqrMagnitude = vector.sqrMagnitude;
		if (!float.IsNaN(sqrMagnitude) && 0f < sqrMagnitude && sqrMagnitude < 1000000f)
		{
			base.transform.localScale = vector * 0.999f;
		}
		base.transform.position = position;
		OSP_Unity_GetRaycastHits(points, normals, 2048);
		for (int i = 0; i < 2048; i++)
		{
			if (points[i] == Vector3.zero)
			{
				points[i].y = -10000f;
			}
			points[i].z *= -1f;
			normals[i].z *= -1f;
			particles[i].position = points[i] + normals[i] * particleOffset;
			if (normals[i] != Vector3.zero)
			{
				particles[i].rotation3D = Quaternion.LookRotation(normals[i]).eulerAngles;
			}
			particles[i].startSize = particleSize;
			particles[i].startColor = new Color(0.8156863f, 0.14901961f, 58f / 85f, 1f);
		}
		for (int j = 0; j < 6; j++)
		{
			Color value = Color.Lerp(Color.red, Color.green, coefs[j]);
			wallRenderer[j].material.SetColor("_TintColor", value);
		}
		sys.SetParticles(particles, particles.Length);
	}

	private void inititalizeRoomVisualization()
	{
		UnityEngine.Debug.Log("Oculus Audio dynamic room estimation visualization enabled");
		base.transform.position = Vector3.zero;
		GameObject gameObject = new GameObject("DecalManager");
		gameObject.transform.parent = base.transform;
		sys = gameObject.AddComponent<ParticleSystem>();
		ParticleSystem.MainModule main = sys.main;
		main.simulationSpace = ParticleSystemSimulationSpace.World;
		main.loop = false;
		main.playOnAwake = false;
		ParticleSystem.EmissionModule emission = sys.emission;
		emission.enabled = false;
		ParticleSystem.ShapeModule shape = sys.shape;
		shape.enabled = false;
		ParticleSystemRenderer component = sys.GetComponent<ParticleSystemRenderer>();
		component.renderMode = ParticleSystemRenderMode.Mesh;
		component.material.shader = Shader.Find("Particles/Additive");
		Texture2D texture2D = new Texture2D(64, 64);
		for (int i = 0; i < 32; i++)
		{
			for (int j = 0; j < 32; j++)
			{
				float num = 32 - i;
				float num2 = 32 - j;
				float num3 = Mathf.Sqrt(num * num + num2 * num2);
				float num4 = 2f * num3 / 32f;
				float a = ((!(num3 < 32f)) ? 0f : Mathf.Clamp01(Mathf.Sin((float)Math.PI * 2f * num4)));
				Color color = new Color(1f, 1f, 1f, a);
				texture2D.SetPixel(i, j, color);
				texture2D.SetPixel(64 - i, j, color);
				texture2D.SetPixel(i, 64 - j, color);
				texture2D.SetPixel(64 - i, 64 - j, color);
			}
		}
		texture2D.Apply();
		component.material.mainTexture = texture2D;
		Mesh mesh = new Mesh();
		mesh.name = "ParticleQuad";
		mesh.vertices = new Vector3[4]
		{
			new Vector3(-0.5f, -0.5f, 0f),
			new Vector3(0.5f, -0.5f, 0f),
			new Vector3(0.5f, 0.5f, 0f),
			new Vector3(-0.5f, 0.5f, 0f)
		};
		mesh.uv = new Vector2[4]
		{
			new Vector2(0f, 0f),
			new Vector2(0f, 1f),
			new Vector2(1f, 1f),
			new Vector2(1f, 0f)
		};
		mesh.triangles = new int[6] { 0, 1, 2, 0, 2, 3 };
		mesh.RecalculateNormals();
		component.mesh = mesh;
		sys.Emit(2048);
		room = new GameObject("RoomVisualizer");
		room.transform.parent = base.transform;
		room.transform.localPosition = Vector3.zero;
		Texture2D texture2D2 = new Texture2D(32, 32);
		Color color2 = new Color(0f, 0f, 0f, 0f);
		for (int k = 0; k < 32; k++)
		{
			for (int l = 0; l < 32; l++)
			{
				texture2D2.SetPixel(k, l, color2);
			}
		}
		for (int m = 0; m < 32; m++)
		{
			Color color3 = Color.white * 0.125f;
			texture2D2.SetPixel(8, m, color3);
			texture2D2.SetPixel(m, 8, color3);
			texture2D2.SetPixel(24, m, color3);
			texture2D2.SetPixel(m, 24, color3);
			color3 *= 2f;
			texture2D2.SetPixel(16, m, color3);
			texture2D2.SetPixel(m, 16, color3);
			color3 *= 2f;
			texture2D2.SetPixel(0, m, color3);
			texture2D2.SetPixel(m, 0, color3);
		}
		texture2D2.Apply();
		for (int n = 0; n < 6; n++)
		{
			Mesh mesh2 = new Mesh();
			mesh2.name = "Plane" + n;
			Vector3[] array = new Vector3[4];
			int num5 = n / 2;
			int num6 = ((n % 2 == 0) ? 1 : (-1));
			for (int num7 = 0; num7 < 4; num7++)
			{
				array[num7][num5] = (float)num6 * 0.5f;
				array[num7][(num5 + 1) % 3] = 0.5f * (float)((num7 == 1 || num7 == 2) ? 1 : (-1));
				array[num7][(num5 + 2) % 3] = 0.5f * (float)((num7 == 2 || num7 == 3) ? 1 : (-1));
			}
			mesh2.vertices = array;
			mesh2.uv = new Vector2[4]
			{
				new Vector2(0f, 0f),
				new Vector2(0f, 1f),
				new Vector2(1f, 1f),
				new Vector2(1f, 0f)
			};
			mesh2.triangles = new int[6] { 0, 1, 2, 0, 2, 3 };
			mesh2.RecalculateNormals();
			GameObject gameObject2 = new GameObject("Wall_" + n);
			gameObject2.AddComponent<MeshFilter>().mesh = mesh2;
			MeshRenderer meshRenderer = gameObject2.AddComponent<MeshRenderer>();
			wallRenderer[n] = meshRenderer;
			meshRenderer.material.shader = Shader.Find("Particles/Additive");
			meshRenderer.material.mainTexture = texture2D2;
			meshRenderer.material.mainTextureScale = new Vector2(8f, 8f);
			gameObject2.transform.parent = room.transform;
			room.transform.localPosition = Vector3.zero;
		}
	}

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_AssignRaycastCallback(MulticastDelegate callback, IntPtr data);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_AssignRaycastCallback(IntPtr callback, IntPtr data);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_SetDynamicRoomRaysPerSecond(int RaysPerSecond);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_SetDynamicRoomInterpSpeed(float InterpSpeed);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_SetDynamicRoomMaxWallDistance(float MaxWallDistance);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_SetDynamicRoomRaysRayCacheSize(int RayCacheSize);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_UpdateRoomModel(float wetLevel);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_GetRoomDimensions(float[] roomDimensions, float[] reflectionsCoefs, out Vector3 position);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_GetRaycastHits(Vector3[] points, Vector3[] normals, int length);
}
public class ONSPAmbisonicsNative : MonoBehaviour
{
	public enum ovrAmbisonicsNativeStatus
	{
		Uninitialized = -1,
		NotEnabled,
		Success,
		StreamError,
		ProcessError,
		MaxStatValue
	}

	private static int numFOAChannels = 4;

	private static int paramVSpeakerMode = 6;

	private static int paramAmbiStat = 7;

	private ovrAmbisonicsNativeStatus currentStatus = ovrAmbisonicsNativeStatus.Uninitialized;

	[SerializeField]
	private bool useVirtualSpeakers;

	public bool UseVirtualSpeakers
	{
		get
		{
			return useVirtualSpeakers;
		}
		set
		{
			useVirtualSpeakers = value;
		}
	}

	private void OnEnable()
	{
		AudioSource component = GetComponent<AudioSource>();
		currentStatus = ovrAmbisonicsNativeStatus.Uninitialized;
		if (component == null)
		{
			UnityEngine.Debug.Log("Ambisonic ERROR: AudioSource does not exist.");
			return;
		}
		if (component.spatialize)
		{
			UnityEngine.Debug.Log("Ambisonic WARNING: Turning spatialize field off for Ambisonic sources.");
			component.spatialize = false;
		}
		if (component.clip == null)
		{
			UnityEngine.Debug.Log("Ambisonic ERROR: AudioSource does not contain an audio clip.");
		}
		else if (component.clip.channels != numFOAChannels)
		{
			UnityEngine.Debug.Log("Ambisonic ERROR: AudioSource clip does not have correct number of channels.");
		}
	}

	private void Update()
	{
		AudioSource component = GetComponent<AudioSource>();
		if (component == null)
		{
			return;
		}
		if (useVirtualSpeakers)
		{
			component.SetAmbisonicDecoderFloat(paramVSpeakerMode, 1f);
		}
		else
		{
			component.SetAmbisonicDecoderFloat(paramVSpeakerMode, 0f);
		}
		float value = 0f;
		component.GetAmbisonicDecoderFloat(paramAmbiStat, out value);
		ovrAmbisonicsNativeStatus ovrAmbisonicsNativeStatus = (ovrAmbisonicsNativeStatus)value;
		if (ovrAmbisonicsNativeStatus != currentStatus)
		{
			switch (ovrAmbisonicsNativeStatus)
			{
			case ovrAmbisonicsNativeStatus.NotEnabled:
				UnityEngine.Debug.Log("Ambisonic Native: Ambisonic not enabled on clip. Check clip field and turn it on");
				break;
			case ovrAmbisonicsNativeStatus.Uninitialized:
				UnityEngine.Debug.Log("Ambisonic Native: Stream uninitialized");
				break;
			case ovrAmbisonicsNativeStatus.Success:
				UnityEngine.Debug.Log("Ambisonic Native: Stream successfully initialized and playing/playable");
				break;
			case ovrAmbisonicsNativeStatus.StreamError:
				UnityEngine.Debug.Log("Ambisonic Native WARNING: Stream error (bad input format?)");
				break;
			case ovrAmbisonicsNativeStatus.ProcessError:
				UnityEngine.Debug.Log("Ambisonic Native WARNING: Stream process error (check default speaker setup)");
				break;
			}
		}
		currentStatus = ovrAmbisonicsNativeStatus;
	}
}
public class ONSPAudioSource : MonoBehaviour
{
	private enum Parameters
	{
		P_GAIN,
		P_USEINVSQR,
		P_NEAR,
		P_FAR,
		P_RADIUS,
		P_DISABLE_RFL,
		P_VSPEAKERMODE,
		P_AMBISTAT,
		P_READONLY_GLOBAL_RFL_ENABLED,
		P_READONLY_NUM_VOICES,
		P_SENDLEVEL,
		P_NUM
	}

	public const string strONSPS = "AudioPluginOculusSpatializer";

	[SerializeField]
	private bool enableSpatialization = true;

	[SerializeField]
	private float gain;

	[SerializeField]
	private bool useInvSqr;

	[SerializeField]
	private float near = 0.25f;

	[SerializeField]
	private float far = 250f;

	[SerializeField]
	private float volumetricRadius;

	[SerializeField]
	private float reverbSend;

	[SerializeField]
	private bool enableRfl;

	private static ONSPAudioSource RoomReflectionGizmoAS;

	public bool EnableSpatialization
	{
		get
		{
			return enableSpatialization;
		}
		set
		{
			enableSpatialization = value;
		}
	}

	public float Gain
	{
		get
		{
			return gain;
		}
		set
		{
			gain = Mathf.Clamp(value, 0f, 24f);
		}
	}

	public bool UseInvSqr
	{
		get
		{
			return useInvSqr;
		}
		set
		{
			useInvSqr = value;
		}
	}

	public float Near
	{
		get
		{
			return near;
		}
		set
		{
			near = Mathf.Clamp(value, 0f, 1000000f);
		}
	}

	public float Far
	{
		get
		{
			return far;
		}
		set
		{
			far = Mathf.Clamp(value, 0f, 1000000f);
		}
	}

	public float VolumetricRadius
	{
		get
		{
			return volumetricRadius;
		}
		set
		{
			volumetricRadius = Mathf.Clamp(value, 0f, 1000f);
		}
	}

	public float ReverbSend
	{
		get
		{
			return reverbSend;
		}
		set
		{
			reverbSend = Mathf.Clamp(value, -60f, 20f);
		}
	}

	public bool EnableRfl
	{
		get
		{
			return enableRfl;
		}
		set
		{
			enableRfl = value;
		}
	}

	[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
	private static void OnBeforeSceneLoadRuntimeMethod()
	{
		OSP_SetGlobalVoiceLimit(ONSPSettings.Instance.voiceLimit);
	}

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern void ONSP_GetGlobalRoomReflectionValues(ref bool reflOn, ref bool reverbOn, ref float width, ref float height, ref float length);

	private void Awake()
	{
		AudioSource source = GetComponent<AudioSource>();
		SetParameters(ref source);
	}

	private void Start()
	{
	}

	private void Update()
	{
		AudioSource source = GetComponent<AudioSource>();
		if (!UnityEngine.Application.isPlaying || AudioListener.pause || !source.isPlaying || !source.isActiveAndEnabled)
		{
			source.spatialize = false;
		}
		else
		{
			SetParameters(ref source);
		}
	}

	public void SetParameters(ref AudioSource source)
	{
		source.spatialize = enableSpatialization;
		source.SetSpatializerFloat(0, gain);
		if (useInvSqr)
		{
			source.SetSpatializerFloat(1, 1f);
		}
		else
		{
			source.SetSpatializerFloat(1, 0f);
		}
		source.SetSpatializerFloat(2, near);
		source.SetSpatializerFloat(3, far);
		source.SetSpatializerFloat(4, volumetricRadius);
		if (enableRfl)
		{
			source.SetSpatializerFloat(5, 0f);
		}
		else
		{
			source.SetSpatializerFloat(5, 1f);
		}
		source.SetSpatializerFloat(10, reverbSend);
	}

	private void OnDrawGizmos()
	{
		if (RoomReflectionGizmoAS == null)
		{
			RoomReflectionGizmoAS = this;
		}
		Color color = default(Color);
		color.r = 1f;
		color.g = 0.5f;
		color.b = 0f;
		color.a = 1f;
		Gizmos.color = color;
		Gizmos.DrawWireSphere(base.transform.position, Near);
		color.a = 0.1f;
		Gizmos.color = color;
		Gizmos.DrawSphere(base.transform.position, Near);
		color.r = 1f;
		color.g = 0f;
		color.b = 0f;
		color.a = 1f;
		Gizmos.color = Color.red;
		Gizmos.DrawWireSphere(base.transform.position, Far);
		color.a = 0.1f;
		Gizmos.color = color;
		Gizmos.DrawSphere(base.transform.position, Far);
		color.r = 1f;
		color.g = 0f;
		color.b = 1f;
		color.a = 1f;
		Gizmos.color = color;
		Gizmos.DrawWireSphere(base.transform.position, VolumetricRadius);
		color.a = 0.1f;
		Gizmos.color = color;
		Gizmos.DrawSphere(base.transform.position, VolumetricRadius);
		if (RoomReflectionGizmoAS == this)
		{
			bool reflOn = false;
			bool reverbOn = false;
			float width = 1f;
			float height = 1f;
			float length = 1f;
			ONSP_GetGlobalRoomReflectionValues(ref reflOn, ref reverbOn, ref width, ref height, ref length);
			if (Camera.main != null && reflOn)
			{
				color = (Gizmos.color = ((!reverbOn) ? Color.cyan : Color.white));
				Gizmos.DrawWireCube(Camera.main.transform.position, new Vector3(width, height, length));
				color.a = 0.1f;
				Gizmos.color = color;
				Gizmos.DrawCube(Camera.main.transform.position, new Vector3(width, height, length));
			}
		}
	}

	private void OnDestroy()
	{
		if (RoomReflectionGizmoAS == this)
		{
			RoomReflectionGizmoAS = null;
		}
	}

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_SetGlobalVoiceLimit(int VoiceLimit);
}
public class ONSPProfiler : MonoBehaviour
{
	public bool profilerEnabled;

	private const int DEFAULT_PORT = 2121;

	public int port = 2121;

	public const string strONSPS = "AudioPluginOculusSpatializer";

	private void Start()
	{
		UnityEngine.Application.runInBackground = true;
	}

	private void Update()
	{
		if (port < 0 || port > 65535)
		{
			port = 2121;
		}
		ONSP_SetProfilerPort(port);
		ONSP_SetProfilerEnabled(profilerEnabled);
	}

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int ONSP_SetProfilerEnabled(bool enabled);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int ONSP_SetProfilerPort(int port);
}
public class ONSPPropagationGeometry : MonoBehaviour
{
	private struct MeshMaterial
	{
		public MeshFilter meshFilter;

		public ONSPPropagationMaterial[] materials;
	}

	private struct TerrainMaterial
	{
		public Terrain terrain;

		public ONSPPropagationMaterial[] materials;

		public Mesh[] treePrototypeMeshes;
	}

	public static string GeometryAssetDirectory = "AudioGeometry";

	public string filePathRelative = string.Empty;

	public bool fileEnabled;

	public bool includeChildMeshes = true;

	private IntPtr geometryHandle = IntPtr.Zero;

	public static int OSPSuccess;

	public const string GEOMETRY_FILE_EXTENSION = "ovramesh";

	private static int terrainDecimation = 4;

	public static string GeometryAssetPath => UnityEngine.Application.streamingAssetsPath + "/" + GeometryAssetDirectory;

	public string filePath => GeometryAssetPath + "/" + filePathRelative;

	private static string GetPath(Transform current)
	{
		if (current.parent == null)
		{
			return current.gameObject.scene.name + "/" + current.name;
		}
		return GetPath(current.parent) + "-" + current.name;
	}

	private void Awake()
	{
		CreatePropagationGeometry();
	}

	private void CreatePropagationGeometry()
	{
		if (ONSPPropagation.Interface.CreateAudioGeometry(out geometryHandle) != OSPSuccess)
		{
			throw new Exception("Unable to create geometry handle");
		}
		if (filePath != null && filePath.Length != 0 && fileEnabled && UnityEngine.Application.isPlaying)
		{
			if (!ReadFile())
			{
				UnityEngine.Debug.LogError("Failed to read file, attempting to regenerate audio geometry");
				UploadGeometry();
			}
		}
		else
		{
			UploadGeometry();
		}
	}

	private void Update()
	{
		if (!(geometryHandle == IntPtr.Zero))
		{
			Matrix4x4 localToWorldMatrix = base.transform.localToWorldMatrix;
			float[] matrix4x = new float[16]
			{
				localToWorldMatrix[0, 0],
				localToWorldMatrix[1, 0],
				0f - localToWorldMatrix[2, 0],
				localToWorldMatrix[3, 0],
				localToWorldMatrix[0, 1],
				localToWorldMatrix[1, 1],
				0f - localToWorldMatrix[2, 1],
				localToWorldMatrix[3, 1],
				localToWorldMatrix[0, 2],
				localToWorldMatrix[1, 2],
				0f - localToWorldMatrix[2, 2],
				localToWorldMatrix[3, 2],
				localToWorldMatrix[0, 3],
				localToWorldMatrix[1, 3],
				0f - localToWorldMatrix[2, 3],
				localToWorldMatrix[3, 3]
			};
			ONSPPropagation.Interface.AudioGeometrySetTransform(geometryHandle, matrix4x);
		}
	}

	private void OnDestroy()
	{
		if (geometryHandle != IntPtr.Zero && ONSPPropagation.Interface.DestroyAudioGeometry(geometryHandle) != OSPSuccess)
		{
			throw new Exception("Unable to destroy geometry");
		}
		geometryHandle = IntPtr.Zero;
	}

	private static void traverseMeshHierarchy(GameObject obj, ONSPPropagationMaterial[] currentMaterials, bool includeChildren, List<MeshMaterial> meshMaterials, List<TerrainMaterial> terrainMaterials, bool ignoreStatic, ref int ignoredMeshCount)
	{
		if (!obj.activeInHierarchy)
		{
			return;
		}
		MeshFilter[] components = obj.GetComponents<MeshFilter>();
		Terrain[] components2 = obj.GetComponents<Terrain>();
		ONSPPropagationMaterial[] components3 = obj.GetComponents<ONSPPropagationMaterial>();
		if (components3 != null && components3.Length > 0)
		{
			int num = components3.Length;
			if (currentMaterials != null)
			{
				num = Math.Max(num, currentMaterials.Length);
			}
			ONSPPropagationMaterial[] array = new ONSPPropagationMaterial[num];
			if (currentMaterials != null)
			{
				for (int i = components3.Length; i < num; i++)
				{
					array[i] = currentMaterials[i];
				}
			}
			currentMaterials = array;
			for (int j = 0; j < components3.Length; j++)
			{
				currentMaterials[j] = components3[j];
			}
		}
		MeshFilter[] array2 = components;
		foreach (MeshFilter meshFilter in array2)
		{
			Mesh sharedMesh = meshFilter.sharedMesh;
			if (!(sharedMesh == null))
			{
				if (ignoreStatic && !sharedMesh.isReadable)
				{
					UnityEngine.Debug.LogWarning("Mesh: " + meshFilter.gameObject.name + " not readable, cannot be static.", meshFilter.gameObject);
					ignoredMeshCount++;
					continue;
				}
				MeshMaterial item = default(MeshMaterial);
				item.meshFilter = meshFilter;
				item.materials = currentMaterials;
				meshMaterials.Add(item);
			}
		}
		Terrain[] array3 = components2;
		foreach (Terrain terrain in array3)
		{
			TerrainMaterial item2 = default(TerrainMaterial);
			item2.terrain = terrain;
			item2.materials = currentMaterials;
			terrainMaterials.Add(item2);
		}
		if (!includeChildren)
		{
			return;
		}
		foreach (Transform item3 in obj.transform)
		{
			if (item3.GetComponent<ONSPPropagationGeometry>() == null)
			{
				traverseMeshHierarchy(item3.gameObject, currentMaterials, includeChildren, meshMaterials, terrainMaterials, ignoreStatic, ref ignoredMeshCount);
			}
		}
	}

	private int uploadMesh(IntPtr geometryHandle, GameObject meshObject, Matrix4x4 worldToLocal)
	{
		int ignoredMeshCount = 0;
		return uploadMesh(geometryHandle, meshObject, worldToLocal, ignoreStatic: false, ref ignoredMeshCount);
	}

	private int uploadMesh(IntPtr geometryHandle, GameObject meshObject, Matrix4x4 worldToLocal, bool ignoreStatic, ref int ignoredMeshCount)
	{
		List<MeshMaterial> list = new List<MeshMaterial>();
		List<TerrainMaterial> list2 = new List<TerrainMaterial>();
		traverseMeshHierarchy(meshObject, null, includeChildMeshes, list, list2, ignoreStatic, ref ignoredMeshCount);
		ONSPPropagationMaterial[] array = new ONSPPropagationMaterial[1] { base.gameObject.AddComponent<ONSPPropagationMaterial>() };
		array[0].SetPreset(ONSPPropagationMaterial.Preset.Foliage);
		int totalVertexCount = 0;
		uint totalIndexCount = 0u;
		int totalFaceCount = 0;
		int totalMaterialCount = 0;
		foreach (MeshMaterial item in list)
		{
			updateCountsForMesh(ref totalVertexCount, ref totalIndexCount, ref totalFaceCount, ref totalMaterialCount, item.meshFilter.sharedMesh);
		}
		for (int i = 0; i < list2.Count; i++)
		{
			TerrainMaterial value = list2[i];
			TerrainData terrainData = value.terrain.terrainData;
			int heightmapWidth = terrainData.heightmapWidth;
			int heightmapHeight = terrainData.heightmapHeight;
			int num = (heightmapWidth - 1) / terrainDecimation + 1;
			int num2 = (heightmapHeight - 1) / terrainDecimation + 1;
			int num3 = num * num2;
			int num4 = (num - 1) * (num2 - 1) * 6;
			totalMaterialCount++;
			totalVertexCount += num3;
			totalIndexCount += (uint)num4;
			totalFaceCount += num4 / 3;
			TreePrototype[] treePrototypes = terrainData.treePrototypes;
			value.treePrototypeMeshes = new Mesh[treePrototypes.Length];
			for (int j = 0; j < treePrototypes.Length; j++)
			{
				GameObject prefab = treePrototypes[j].prefab;
				MeshFilter[] componentsInChildren = prefab.GetComponentsInChildren<MeshFilter>();
				int num5 = int.MaxValue;
				int num6 = -1;
				for (int k = 0; k < componentsInChildren.Length; k++)
				{
					int vertexCount = componentsInChildren[k].sharedMesh.vertexCount;
					if (vertexCount < num5)
					{
						num5 = vertexCount;
						num6 = k;
					}
				}
				value.treePrototypeMeshes[j] = componentsInChildren[num6].sharedMesh;
			}
			TreeInstance[] treeInstances = terrainData.treeInstances;
			TreeInstance[] array2 = treeInstances;
			for (int l = 0; l < array2.Length; l++)
			{
				TreeInstance treeInstance = array2[l];
				updateCountsForMesh(ref totalVertexCount, ref totalIndexCount, ref totalFaceCount, ref totalMaterialCount, value.treePrototypeMeshes[treeInstance.prototypeIndex]);
			}
			list2[i] = value;
		}
		List<Vector3> tempVertices = new List<Vector3>();
		List<int> tempIndices = new List<int>();
		MeshGroup[] array3 = new MeshGroup[totalMaterialCount];
		float[] array4 = new float[totalVertexCount * 3];
		int[] array5 = new int[totalIndexCount];
		int vertexOffset = 0;
		int indexOffset = 0;
		int groupOffset = 0;
		foreach (MeshMaterial item2 in list)
		{
			MeshFilter meshFilter = item2.meshFilter;
			Matrix4x4 matrix = worldToLocal * meshFilter.gameObject.transform.localToWorldMatrix;
			uploadMeshFilter(tempVertices, tempIndices, array3, array4, array5, ref vertexOffset, ref indexOffset, ref groupOffset, meshFilter.sharedMesh, item2.materials, matrix);
		}
		foreach (TerrainMaterial item3 in list2)
		{
			TerrainData terrainData2 = item3.terrain.terrainData;
			Matrix4x4 matrix4x = worldToLocal * item3.terrain.gameObject.transform.localToWorldMatrix;
			int heightmapWidth2 = terrainData2.heightmapWidth;
			int heightmapHeight2 = terrainData2.heightmapHeight;
			float[,] heights = terrainData2.GetHeights(0, 0, heightmapWidth2, heightmapHeight2);
			Vector3 size = terrainData2.size;
			size = new Vector3(size.x / (float)(heightmapWidth2 - 1) * (float)terrainDecimation, size.y, size.z / (float)(heightmapHeight2 - 1) * (float)terrainDecimation);
			int num7 = (heightmapWidth2 - 1) / terrainDecimation + 1;
			int num8 = (heightmapHeight2 - 1) / terrainDecimation + 1;
			int num9 = num7 * num8;
			int num10 = (num7 - 1) * (num8 - 1) * 2;
			array3[groupOffset].faceType = FaceType.TRIANGLES;
			array3[groupOffset].faceCount = (UIntPtr)(ulong)num10;
			array3[groupOffset].indexOffset = (UIntPtr)(ulong)indexOffset;
			if (item3.materials != null && 0 < item3.materials.Length)
			{
				item3.materials[0].StartInternal();
				array3[groupOffset].material = item3.materials[0].materialHandle;
			}
			else
			{
				array3[groupOffset].material = IntPtr.Zero;
			}
			for (int m = 0; m < num8; m++)
			{
				for (int n = 0; n < num7; n++)
				{
					int num11 = (vertexOffset + m * num7 + n) * 3;
					Vector3 vector = matrix4x.MultiplyPoint3x4(Vector3.Scale(size, new Vector3(m, heights[n * terrainDecimation, m * terrainDecimation], n)));
					array4[num11] = vector.x;
					array4[num11 + 1] = vector.y;
					array4[num11 + 2] = vector.z;
				}
			}
			for (int num12 = 0; num12 < num8 - 1; num12++)
			{
				for (int num13 = 0; num13 < num7 - 1; num13++)
				{
					array5[indexOffset] = vertexOffset + num12 * num7 + num13;
					array5[indexOffset + 1] = vertexOffset + (num12 + 1) * num7 + num13;
					array5[indexOffset + 2] = vertexOffset + num12 * num7 + num13 + 1;
					array5[indexOffset + 3] = vertexOffset + (num12 + 1) * num7 + num13;
					array5[indexOffset + 4] = vertexOffset + (num12 + 1) * num7 + num13 + 1;
					array5[indexOffset + 5] = vertexOffset + num12 * num7 + num13 + 1;
					indexOffset += 6;
				}
			}
			vertexOffset += num9;
			groupOffset++;
			TreeInstance[] treeInstances2 = terrainData2.treeInstances;
			TreeInstance[] array6 = treeInstances2;
			for (int num14 = 0; num14 < array6.Length; num14++)
			{
				TreeInstance treeInstance2 = array6[num14];
				Vector3 vector2 = Vector3.Scale(treeInstance2.position, terrainData2.size);
				Matrix4x4 localToWorldMatrix = item3.terrain.gameObject.transform.localToWorldMatrix;
				localToWorldMatrix.SetColumn(3, localToWorldMatrix.GetColumn(3) + new Vector4(vector2.x, vector2.y, vector2.z, 0f));
				Matrix4x4 matrix2 = worldToLocal * localToWorldMatrix;
				uploadMeshFilter(tempVertices, tempIndices, array3, array4, array5, ref vertexOffset, ref indexOffset, ref groupOffset, item3.treePrototypeMeshes[treeInstance2.prototypeIndex], array, matrix2);
			}
		}
		return ONSPPropagation.Interface.AudioGeometryUploadMeshArrays(geometryHandle, array4, totalVertexCount, array5, array5.Length, array3, array3.Length);
	}

	private static void uploadMeshFilter(List<Vector3> tempVertices, List<int> tempIndices, MeshGroup[] groups, float[] vertices, int[] indices, ref int vertexOffset, ref int indexOffset, ref int groupOffset, Mesh mesh, ONSPPropagationMaterial[] materials, Matrix4x4 matrix)
	{
		tempVertices.Clear();
		mesh.GetVertices(tempVertices);
		int count = tempVertices.Count;
		for (int i = 0; i < count; i++)
		{
			Vector3 vector = matrix.MultiplyPoint3x4(tempVertices[i]);
			int num = (vertexOffset + i) * 3;
			vertices[num] = vector.x;
			vertices[num + 1] = vector.y;
			vertices[num + 2] = vector.z;
		}
		for (int j = 0; j < mesh.subMeshCount; j++)
		{
			MeshTopology topology = mesh.GetTopology(j);
			if (topology != 0 && topology != MeshTopology.Quads)
			{
				continue;
			}
			tempIndices.Clear();
			mesh.GetIndices(tempIndices, j);
			int count2 = tempIndices.Count;
			for (int k = 0; k < count2; k++)
			{
				indices[indexOffset + k] = tempIndices[k] + vertexOffset;
			}
			switch (topology)
			{
			case MeshTopology.Triangles:
				groups[groupOffset + j].faceType = FaceType.TRIANGLES;
				groups[groupOffset + j].faceCount = (UIntPtr)(ulong)(count2 / 3);
				break;
			case MeshTopology.Quads:
				groups[groupOffset + j].faceType = FaceType.QUADS;
				groups[groupOffset + j].faceCount = (UIntPtr)(ulong)(count2 / 4);
				break;
			}
			groups[groupOffset + j].indexOffset = (UIntPtr)(ulong)indexOffset;
			if (materials != null && materials.Length != 0)
			{
				int num2 = j;
				if (num2 >= materials.Length)
				{
					num2 = materials.Length - 1;
				}
				materials[num2].StartInternal();
				groups[groupOffset + j].material = materials[num2].materialHandle;
			}
			else
			{
				groups[groupOffset + j].material = IntPtr.Zero;
			}
			indexOffset += count2;
		}
		vertexOffset += count;
		groupOffset += mesh.subMeshCount;
	}

	private static void updateCountsForMesh(ref int totalVertexCount, ref uint totalIndexCount, ref int totalFaceCount, ref int totalMaterialCount, Mesh mesh)
	{
		totalMaterialCount += mesh.subMeshCount;
		totalVertexCount += mesh.vertexCount;
		for (int i = 0; i < mesh.subMeshCount; i++)
		{
			MeshTopology topology = mesh.GetTopology(i);
			if (topology == MeshTopology.Triangles || topology == MeshTopology.Quads)
			{
				uint indexCount = mesh.GetIndexCount(i);
				totalIndexCount += indexCount;
				switch (topology)
				{
				case MeshTopology.Triangles:
					totalFaceCount += (int)indexCount / 3;
					break;
				case MeshTopology.Quads:
					totalFaceCount += (int)indexCount / 4;
					break;
				}
			}
		}
	}

	public void UploadGeometry()
	{
		int ignoredMeshCount = 0;
		if (uploadMesh(geometryHandle, base.gameObject, base.gameObject.transform.worldToLocalMatrix, ignoreStatic: true, ref ignoredMeshCount) != OSPSuccess)
		{
			throw new Exception("Unable to upload audio mesh geometry");
		}
		if (ignoredMeshCount != 0)
		{
			UnityEngine.Debug.LogError("Failed to upload meshes, " + ignoredMeshCount + " static meshes ignored. Turn on \"File Enabled\" to process static meshes offline", base.gameObject);
		}
	}

	public bool ReadFile()
	{
		if (filePath == null || filePath.Length == 0)
		{
			UnityEngine.Debug.LogError("Invalid mesh file path");
			return false;
		}
		if (ONSPPropagation.Interface.AudioGeometryReadMeshFile(geometryHandle, filePath) != OSPSuccess)
		{
			UnityEngine.Debug.LogError("Error reading mesh file " + filePath);
			return false;
		}
		return true;
	}

	public bool WriteToObj()
	{
		IntPtr geometry = IntPtr.Zero;
		if (ONSPPropagation.Interface.CreateAudioGeometry(out geometry) != OSPSuccess)
		{
			throw new Exception("Failed to create temp geometry handle");
		}
		if (uploadMesh(geometry, base.gameObject, base.gameObject.transform.worldToLocalMatrix) != OSPSuccess)
		{
			UnityEngine.Debug.LogError("Error uploading mesh " + base.gameObject.name);
			return false;
		}
		if (ONSPPropagation.Interface.AudioGeometryWriteMeshFileObj(geometry, filePath + ".obj") != OSPSuccess)
		{
			UnityEngine.Debug.LogError("Error writing .obj file " + filePath + ".obj");
			return false;
		}
		if (ONSPPropagation.Interface.DestroyAudioGeometry(geometry) != OSPSuccess)
		{
			throw new Exception("Failed to destroy temp geometry handle");
		}
		return true;
	}
}
namespace Oculus.Spatializer.Propagation
{
	public enum FaceType : uint
	{
		TRIANGLES,
		QUADS
	}
	public enum MaterialProperty : uint
	{
		ABSORPTION,
		TRANSMISSION,
		SCATTERING
	}
	[StructLayout(LayoutKind.Sequential, Pack = 1)]
	public struct MeshGroup
	{
		public UIntPtr indexOffset;

		public UIntPtr faceCount;

		[MarshalAs(UnmanagedType.U4)]
		public FaceType faceType;

		public IntPtr material;
	}
}
internal class ONSPPropagation
{
	public enum ovrAudioScalarType : uint
	{
		Int8,
		UInt8,
		Int16,
		UInt16,
		Int32,
		UInt32,
		Int64,
		UInt64,
		Float16,
		Float32,
		Float64
	}

	public class ClientType
	{
		public const uint OVRA_CLIENT_TYPE_NATIVE = 0u;

		public const uint OVRA_CLIENT_TYPE_WWISE_2016 = 1u;

		public const uint OVRA_CLIENT_TYPE_WWISE_2017_1 = 2u;

		public const uint OVRA_CLIENT_TYPE_WWISE_2017_2 = 3u;

		public const uint OVRA_CLIENT_TYPE_WWISE_2018_1 = 4u;

		public const uint OVRA_CLIENT_TYPE_FMOD = 5u;

		public const uint OVRA_CLIENT_TYPE_UNITY = 6u;

		public const uint OVRA_CLIENT_TYPE_UE4 = 7u;

		public const uint OVRA_CLIENT_TYPE_VST = 8u;

		public const uint OVRA_CLIENT_TYPE_AAX = 9u;

		public const uint OVRA_CLIENT_TYPE_TEST = 10u;

		public const uint OVRA_CLIENT_TYPE_OTHER = 11u;

		public const uint OVRA_CLIENT_TYPE_WWISE_UNKNOWN = 12u;

		public const uint OVRA_CLIENT_TYPE_WWISE_2019_1 = 13u;
	}

	public interface PropagationInterface
	{
		int SetPropagationQuality(float quality);

		int SetPropagationThreadAffinity(ulong cpuMask);

		int CreateAudioGeometry(out IntPtr geometry);

		int DestroyAudioGeometry(IntPtr geometry);

		int AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, int vertexCount, int[] indices, int indexCount, MeshGroup[] groups, int groupCount);

		int AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4);

		int AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4);

		int AudioGeometryWriteMeshFile(IntPtr geometry, string filePath);

		int AudioGeometryReadMeshFile(IntPtr geometry, string filePath);

		int AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath);

		int AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value);

		int CreateAudioMaterial(out IntPtr material);

		int DestroyAudioMaterial(IntPtr material);

		int AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value);

		int AudioMaterialReset(IntPtr material, MaterialProperty property);
	}

	public class UnityNativeInterface : PropagationInterface
	{
		public const string strOSPS = "AudioPluginOculusSpatializer";

		private IntPtr context_ = IntPtr.Zero;

		private IntPtr context
		{
			get
			{
				if (context_ == IntPtr.Zero)
				{
					ovrAudio_GetPluginContext(out context_, 6u);
				}
				return context_;
			}
		}

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_GetPluginContext(out IntPtr context, uint clientType);

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_SetPropagationQuality(IntPtr context, float quality);

		public int SetPropagationQuality(float quality)
		{
			return ovrAudio_SetPropagationQuality(context, quality);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_SetPropagationThreadAffinity(IntPtr context, ulong cpuMask);

		public int SetPropagationThreadAffinity(ulong cpuMask)
		{
			return ovrAudio_SetPropagationThreadAffinity(context, cpuMask);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_CreateAudioGeometry(IntPtr context, out IntPtr geometry);

		public int CreateAudioGeometry(out IntPtr geometry)
		{
			return ovrAudio_CreateAudioGeometry(context, out geometry);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_DestroyAudioGeometry(IntPtr geometry);

		public int DestroyAudioGeometry(IntPtr geometry)
		{
			return ovrAudio_DestroyAudioGeometry(geometry);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, UIntPtr verticesBytesOffset, UIntPtr vertexCount, UIntPtr vertexStride, ovrAudioScalarType vertexType, int[] indices, UIntPtr indicesByteOffset, UIntPtr indexCount, ovrAudioScalarType indexType, MeshGroup[] groups, UIntPtr groupCount);

		public int AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, int vertexCount, int[] indices, int indexCount, MeshGroup[] groups, int groupCount)
		{
			return ovrAudio_AudioGeometryUploadMeshArrays(geometry, vertices, UIntPtr.Zero, (UIntPtr)(ulong)vertexCount, UIntPtr.Zero, ovrAudioScalarType.Float32, indices, UIntPtr.Zero, (UIntPtr)(ulong)indexCount, ovrAudioScalarType.UInt32, groups, (UIntPtr)(ulong)groupCount);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4);

		public int AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4)
		{
			return ovrAudio_AudioGeometrySetTransform(geometry, matrix4x4);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4);

		public int AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4)
		{
			return ovrAudio_AudioGeometryGetTransform(geometry, out matrix4x4);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioGeometryWriteMeshFile(IntPtr geometry, string filePath);

		public int AudioGeometryWriteMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFile(geometry, filePath);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioGeometryReadMeshFile(IntPtr geometry, string filePath);

		public int AudioGeometryReadMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryReadMeshFile(geometry, filePath);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath);

		public int AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFileObj(geometry, filePath);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_CreateAudioMaterial(IntPtr context, out IntPtr material);

		public int CreateAudioMaterial(out IntPtr material)
		{
			return ovrAudio_CreateAudioMaterial(context, out material);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_DestroyAudioMaterial(IntPtr material);

		public int DestroyAudioMaterial(IntPtr material)
		{
			return ovrAudio_DestroyAudioMaterial(material);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value);

		public int AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value)
		{
			return ovrAudio_AudioMaterialSetFrequency(material, property, frequency, value);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value);

		public int AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value)
		{
			return ovrAudio_AudioMaterialGetFrequency(material, property, frequency, out value);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioMaterialReset(IntPtr material, MaterialProperty property);

		public int AudioMaterialReset(IntPtr material, MaterialProperty property)
		{
			return ovrAudio_AudioMaterialReset(material, property);
		}
	}

	public class WwisePluginInterface : PropagationInterface
	{
		public const string strOSPS = "OculusSpatializerWwise";

		private IntPtr context_ = IntPtr.Zero;

		private IntPtr context
		{
			get
			{
				if (context_ == IntPtr.Zero)
				{
					ovrAudio_GetPluginContext(out context_, 12u);
				}
				return context_;
			}
		}

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_GetPluginContext(out IntPtr context, uint clientType);

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_SetPropagationQuality(IntPtr context, float quality);

		public int SetPropagationQuality(float quality)
		{
			return ovrAudio_SetPropagationQuality(context, quality);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_SetPropagationThreadAffinity(IntPtr context, ulong cpuMask);

		public int SetPropagationThreadAffinity(ulong cpuMask)
		{
			return ovrAudio_SetPropagationThreadAffinity(context, cpuMask);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_CreateAudioGeometry(IntPtr context, out IntPtr geometry);

		public int CreateAudioGeometry(out IntPtr geometry)
		{
			return ovrAudio_CreateAudioGeometry(context, out geometry);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_DestroyAudioGeometry(IntPtr geometry);

		public int DestroyAudioGeometry(IntPtr geometry)
		{
			return ovrAudio_DestroyAudioGeometry(geometry);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, UIntPtr verticesBytesOffset, UIntPtr vertexCount, UIntPtr vertexStride, ovrAudioScalarType vertexType, int[] indices, UIntPtr indicesByteOffset, UIntPtr indexCount, ovrAudioScalarType indexType, MeshGroup[] groups, UIntPtr groupCount);

		public int AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, int vertexCount, int[] indices, int indexCount, MeshGroup[] groups, int groupCount)
		{
			return ovrAudio_AudioGeometryUploadMeshArrays(geometry, vertices, UIntPtr.Zero, (UIntPtr)(ulong)vertexCount, UIntPtr.Zero, ovrAudioScalarType.Float32, indices, UIntPtr.Zero, (UIntPtr)(ulong)indexCount, ovrAudioScalarType.UInt32, groups, (UIntPtr)(ulong)groupCount);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4);

		public int AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4)
		{
			return ovrAudio_AudioGeometrySetTransform(geometry, matrix4x4);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4);

		public int AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4)
		{
			return ovrAudio_AudioGeometryGetTransform(geometry, out matrix4x4);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioGeometryWriteMeshFile(IntPtr geometry, string filePath);

		public int AudioGeometryWriteMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFile(geometry, filePath);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioGeometryReadMeshFile(IntPtr geometry, string filePath);

		public int AudioGeometryReadMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryReadMeshFile(geometry, filePath);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath);

		public int AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFileObj(geometry, filePath);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_CreateAudioMaterial(IntPtr context, out IntPtr material);

		public int CreateAudioMaterial(out IntPtr material)
		{
			return ovrAudio_CreateAudioMaterial(context, out material);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_DestroyAudioMaterial(IntPtr material);

		public int DestroyAudioMaterial(IntPtr material)
		{
			return ovrAudio_DestroyAudioMaterial(material);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value);

		public int AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value)
		{
			return ovrAudio_AudioMaterialSetFrequency(material, property, frequency, value);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value);

		public int AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value)
		{
			return ovrAudio_AudioMaterialGetFrequency(material, property, frequency, out value);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioMaterialReset(IntPtr material, MaterialProperty property);

		public int AudioMaterialReset(IntPtr material, MaterialProperty property)
		{
			return ovrAudio_AudioMaterialReset(material, property);
		}
	}

	public class FMODPluginInterface : PropagationInterface
	{
		public const string strOSPS = "OculusSpatializerFMOD";

		private IntPtr context_ = IntPtr.Zero;

		private IntPtr context
		{
			get
			{
				if (context_ == IntPtr.Zero)
				{
					ovrAudio_GetPluginContext(out context_, 5u);
				}
				return context_;
			}
		}

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_GetPluginContext(out IntPtr context, uint clientType);

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_SetPropagationQuality(IntPtr context, float quality);

		public int SetPropagationQuality(float quality)
		{
			return ovrAudio_SetPropagationQuality(context, quality);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_SetPropagationThreadAffinity(IntPtr context, ulong cpuMask);

		public int SetPropagationThreadAffinity(ulong cpuMask)
		{
			return ovrAudio_SetPropagationThreadAffinity(context, cpuMask);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_CreateAudioGeometry(IntPtr context, out IntPtr geometry);

		public int CreateAudioGeometry(out IntPtr geometry)
		{
			return ovrAudio_CreateAudioGeometry(context, out geometry);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_DestroyAudioGeometry(IntPtr geometry);

		public int DestroyAudioGeometry(IntPtr geometry)
		{
			return ovrAudio_DestroyAudioGeometry(geometry);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, UIntPtr verticesBytesOffset, UIntPtr vertexCount, UIntPtr vertexStride, ovrAudioScalarType vertexType, int[] indices, UIntPtr indicesByteOffset, UIntPtr indexCount, ovrAudioScalarType indexType, MeshGroup[] groups, UIntPtr groupCount);

		public int AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, int vertexCount, int[] indices, int indexCount, MeshGroup[] groups, int groupCount)
		{
			return ovrAudio_AudioGeometryUploadMeshArrays(geometry, vertices, UIntPtr.Zero, (UIntPtr)(ulong)vertexCount, UIntPtr.Zero, ovrAudioScalarType.Float32, indices, UIntPtr.Zero, (UIntPtr)(ulong)indexCount, ovrAudioScalarType.UInt32, groups, (UIntPtr)(ulong)groupCount);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4);

		public int AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4)
		{
			return ovrAudio_AudioGeometrySetTransform(geometry, matrix4x4);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4);

		public int AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4)
		{
			return ovrAudio_AudioGeometryGetTransform(geometry, out matrix4x4);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioGeometryWriteMeshFile(IntPtr geometry, string filePath);

		public int AudioGeometryWriteMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFile(geometry, filePath);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioGeometryReadMeshFile(IntPtr geometry, string filePath);

		public int AudioGeometryReadMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryReadMeshFile(geometry, filePath);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath);

		public int AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFileObj(geometry, filePath);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_CreateAudioMaterial(IntPtr context, out IntPtr material);

		public int CreateAudioMaterial(out IntPtr material)
		{
			return ovrAudio_CreateAudioMaterial(context, out material);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_DestroyAudioMaterial(IntPtr material);

		public int DestroyAudioMaterial(IntPtr material)
		{
			return ovrAudio_DestroyAudioMaterial(material);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value);

		public int AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value)
		{
			return ovrAudio_AudioMaterialSetFrequency(material, property, frequency, value);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value);

		public int AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value)
		{
			return ovrAudio_AudioMaterialGetFrequency(material, property, frequency, out value);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioMaterialReset(IntPtr material, MaterialProperty property);

		public int AudioMaterialReset(IntPtr material, MaterialProperty property)
		{
			return ovrAudio_AudioMaterialReset(material, property);
		}
	}

	private static PropagationInterface CachedInterface;

	public static PropagationInterface Interface
	{
		get
		{
			if (CachedInterface == null)
			{
				CachedInterface = FindInterface();
			}
			return CachedInterface;
		}
	}

	private static PropagationInterface FindInterface()
	{
		IntPtr context;
		try
		{
			WwisePluginInterface.ovrAudio_GetPluginContext(out context, 12u);
			UnityEngine.Debug.Log("Propagation initialized with Wwise Oculus Spatializer plugin");
			return new WwisePluginInterface();
		}
		catch (DllNotFoundException)
		{
		}
		try
		{
			FMODPluginInterface.ovrAudio_GetPluginContext(out context, 5u);
			UnityEngine.Debug.Log("Propagation initialized with FMOD Oculus Spatializer plugin");
			return new FMODPluginInterface();
		}
		catch (DllNotFoundException)
		{
		}
		UnityEngine.Debug.Log("Propagation initialized with Unity Oculus Spatializer plugin");
		return new UnityNativeInterface();
	}
}
public sealed class ONSPPropagationMaterial : MonoBehaviour
{
	public enum Preset
	{
		Custom,
		AcousticTile,
		Brick,
		BrickPainted,
		Carpet,
		CarpetHeavy,
		CarpetHeavyPadded,
		CeramicTile,
		Concrete,
		ConcreteRough,
		ConcreteBlock,
		ConcreteBlockPainted,
		Curtain,
		Foliage,
		Glass,
		GlassHeavy,
		Grass,
		Gravel,
		GypsumBoard,
		PlasterOnBrick,
		PlasterOnConcreteBlock,
		Soil,
		SoundProof,
		Snow,
		Steel,
		Water,
		WoodThin,
		WoodThick,
		WoodFloor,
		WoodOnConcrete
	}

	[Serializable]
	public sealed class Point
	{
		public float frequency;

		public float data;

		public Point(float frequency = 0f, float data = 0f)
		{
			this.frequency = frequency;
			this.data = data;
		}

		public static implicit operator Point(Vector2 v)
		{
			return new Point(v.x, v.y);
		}

		public static implicit operator Vector2(Point point)
		{
			return new Vector2(point.frequency, point.data);
		}
	}

	[Serializable]
	public sealed class Spectrum
	{
		public int selection = int.MaxValue;

		public List<Point> points = new List<Point>();

		public float this[float f]
		{
			get
			{
				if (points.Count > 0)
				{
					Point point = new Point(float.MinValue);
					Point point2 = new Point(float.MaxValue);
					foreach (Point point3 in points)
					{
						if (point3.frequency < f)
						{
							if (point3.frequency > point.frequency)
							{
								point = point3;
							}
						}
						else if (point3.frequency < point2.frequency)
						{
							point2 = point3;
						}
					}
					if (point.frequency == float.MinValue)
					{
						point.data = points.OrderBy((Point p) => p.frequency).First().data;
					}
					if (point2.frequency == float.MaxValue)
					{
						point2.data = points.OrderBy((Point p) => p.frequency).Last().data;
					}
					return point.data + (f - point.frequency) * (point2.data - point.data) / (point2.frequency - point.frequency);
				}
				return 0f;
			}
		}
	}

	public IntPtr materialHandle = IntPtr.Zero;

	[Tooltip("Absorption")]
	public Spectrum absorption = new Spectrum();

	[Tooltip("Transmission")]
	public Spectrum transmission = new Spectrum();

	[Tooltip("Scattering")]
	public Spectrum scattering = new Spectrum();

	[SerializeField]
	private Preset preset_;

	public Preset preset
	{
		get
		{
			return preset_;
		}
		set
		{
			SetPreset(value);
			preset_ = value;
		}
	}

	private void Start()
	{
		StartInternal();
	}

	public void StartInternal()
	{
		if (!(materialHandle != IntPtr.Zero))
		{
			if (ONSPPropagation.Interface.CreateAudioMaterial(out materialHandle) != ONSPPropagationGeometry.OSPSuccess)
			{
				throw new Exception("Unable to create internal audio material");
			}
			UploadMaterial();
		}
	}

	private void OnDestroy()
	{
		DestroyInternal();
	}

	public void DestroyInternal()
	{
		if (materialHandle != IntPtr.Zero)
		{
			ONSPPropagation.Interface.DestroyAudioMaterial(materialHandle);
			materialHandle = IntPtr.Zero;
		}
	}

	public void UploadMaterial()
	{
		if (materialHandle == IntPtr.Zero)
		{
			return;
		}
		ONSPPropagation.Interface.AudioMaterialReset(materialHandle, MaterialProperty.ABSORPTION);
		foreach (Point point in absorption.points)
		{
			ONSPPropagation.Interface.AudioMaterialSetFrequency(materialHandle, MaterialProperty.ABSORPTION, point.frequency, point.data);
		}
		ONSPPropagation.Interface.AudioMaterialReset(materialHandle, MaterialProperty.TRANSMISSION);
		foreach (Point point2 in transmission.points)
		{
			ONSPPropagation.Interface.AudioMaterialSetFrequency(materialHandle, MaterialProperty.TRANSMISSION, point2.frequency, point2.data);
		}
		ONSPPropagation.Interface.AudioMaterialReset(materialHandle, MaterialProperty.SCATTERING);
		foreach (Point point3 in scattering.points)
		{
			ONSPPropagation.Interface.AudioMaterialSetFrequency(materialHandle, MaterialProperty.SCATTERING, point3.frequency, point3.data);
		}
	}

	public void SetPreset(Preset preset)
	{
		ONSPPropagationMaterial material = this;
		switch (preset)
		{
		case Preset.AcousticTile:
			AcousticTile(ref material);
			break;
		case Preset.Brick:
			Brick(ref material);
			break;
		case Preset.BrickPainted:
			BrickPainted(ref material);
			break;
		case Preset.Carpet:
			Carpet(ref material);
			break;
		case Preset.CarpetHeavy:
			CarpetHeavy(ref material);
			break;
		case Preset.CarpetHeavyPadded:
			CarpetHeavyPadded(ref material);
			break;
		case Preset.CeramicTile:
			CeramicTile(ref material);
			break;
		case Preset.Concrete:
			Concrete(ref material);
			break;
		case Preset.ConcreteRough:
			ConcreteRough(ref material);
			break;
		case Preset.ConcreteBlock:
			ConcreteBlock(ref material);
			break;
		case Preset.ConcreteBlockPainted:
			ConcreteBlockPainted(ref material);
			break;
		case Preset.Curtain:
			Curtain(ref material);
			break;
		case Preset.Foliage:
			Foliage(ref material);
			break;
		case Preset.Glass:
			Glass(ref material);
			break;
		case Preset.GlassHeavy:
			GlassHeavy(ref material);
			break;
		case Preset.Grass:
			Grass(ref material);
			break;
		case Preset.Gravel:
			Gravel(ref material);
			break;
		case Preset.GypsumBoard:
			GypsumBoard(ref material);
			break;
		case Preset.PlasterOnBrick:
			PlasterOnBrick(ref material);
			break;
		case Preset.PlasterOnConcreteBlock:
			PlasterOnConcreteBlock(ref material);
			break;
		case Preset.Soil:
			Soil(ref material);
			break;
		case Preset.SoundProof:
			SoundProof(ref material);
			break;
		case Preset.Snow:
			Snow(ref material);
			break;
		case Preset.Steel:
			Steel(ref material);
			break;
		case Preset.Water:
			Water(ref material);
			break;
		case Preset.WoodThin:
			WoodThin(ref material);
			break;
		case Preset.WoodThick:
			WoodThick(ref material);
			break;
		case Preset.WoodFloor:
			WoodFloor(ref material);
			break;
		case Preset.WoodOnConcrete:
			WoodOnConcrete(ref material);
			break;
		case Preset.Custom:
			break;
		}
	}

	private static void AcousticTile(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.5f),
			new Point(250f, 0.7f),
			new Point(500f, 0.6f),
			new Point(1000f, 0.7f),
			new Point(2000f, 0.7f),
			new Point(4000f, 0.5f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.25f),
			new Point(4000f, 0.3f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.05f),
			new Point(250f, 0.04f),
			new Point(500f, 0.03f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.005f),
			new Point(4000f, 0.002f)
		};
	}

	private static void Brick(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.02f),
			new Point(500f, 0.03f),
			new Point(1000f, 0.04f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.07f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.25f),
			new Point(500f, 0.3f),
			new Point(1000f, 0.35f),
			new Point(2000f, 0.4f),
			new Point(4000f, 0.45f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.025f),
			new Point(250f, 0.019f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.0045f),
			new Point(2000f, 0.0018f),
			new Point(4000f, 0.00089f)
		};
	}

	private static void BrickPainted(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.01f),
			new Point(500f, 0.02f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.03f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.15f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.2f),
			new Point(4000f, 0.25f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.025f),
			new Point(250f, 0.019f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.0045f),
			new Point(2000f, 0.0018f),
			new Point(4000f, 0.00089f)
		};
	}

	private static void Carpet(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.05f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.45f),
			new Point(4000f, 0.65f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.15f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.3f),
			new Point(4000f, 0.45f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void CarpetHeavy(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.06f),
			new Point(500f, 0.14f),
			new Point(1000f, 0.37f),
			new Point(2000f, 0.48f),
			new Point(4000f, 0.63f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.25f),
			new Point(2000f, 0.35f),
			new Point(4000f, 0.5f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void CarpetHeavyPadded(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.08f),
			new Point(250f, 0.24f),
			new Point(500f, 0.57f),
			new Point(1000f, 0.69f),
			new Point(2000f, 0.71f),
			new Point(4000f, 0.73f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.25f),
			new Point(2000f, 0.35f),
			new Point(4000f, 0.5f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void CeramicTile(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.01f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.01f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.02f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.12f),
			new Point(500f, 0.14f),
			new Point(1000f, 0.16f),
			new Point(2000f, 0.18f),
			new Point(4000f, 0.2f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void Concrete(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.01f),
			new Point(500f, 0.02f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.02f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.11f),
			new Point(500f, 0.12f),
			new Point(1000f, 0.13f),
			new Point(2000f, 0.14f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void ConcreteRough(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.02f),
			new Point(500f, 0.04f),
			new Point(1000f, 0.06f),
			new Point(2000f, 0.08f),
			new Point(4000f, 0.1f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.12f),
			new Point(500f, 0.15f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.25f),
			new Point(4000f, 0.3f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void ConcreteBlock(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.36f),
			new Point(250f, 0.44f),
			new Point(500f, 0.31f),
			new Point(1000f, 0.29f),
			new Point(2000f, 0.39f),
			new Point(4000f, 0.21f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.12f),
			new Point(500f, 0.15f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.3f),
			new Point(4000f, 0.4f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.01f),
			new Point(500f, 0.0063f),
			new Point(1000f, 0.0035f),
			new Point(2000f, 0.00011f),
			new Point(4000f, 0.00063f)
		};
	}

	private static void ConcreteBlockPainted(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.05f),
			new Point(500f, 0.06f),
			new Point(1000f, 0.07f),
			new Point(2000f, 0.09f),
			new Point(4000f, 0.08f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.11f),
			new Point(500f, 0.13f),
			new Point(1000f, 0.15f),
			new Point(2000f, 0.16f),
			new Point(4000f, 0.2f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.01f),
			new Point(500f, 0.0063f),
			new Point(1000f, 0.0035f),
			new Point(2000f, 0.00011f),
			new Point(4000f, 0.00063f)
		};
	}

	private static void Curtain(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.07f),
			new Point(250f, 0.31f),
			new Point(500f, 0.49f),
			new Point(1000f, 0.75f),
			new Point(2000f, 0.7f),
			new Point(4000f, 0.6f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.3f),
			new Point(2000f, 0.4f),
			new Point(4000f, 0.5f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.42f),
			new Point(250f, 0.39f),
			new Point(500f, 0.21f),
			new Point(1000f, 0.14f),
			new Point(2000f, 0.079f),
			new Point(4000f, 0.045f)
		};
	}

	private static void Foliage(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.03f),
			new Point(250f, 0.06f),
			new Point(500f, 0.11f),
			new Point(1000f, 0.17f),
			new Point(2000f, 0.27f),
			new Point(4000f, 0.31f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.3f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.5f),
			new Point(2000f, 0.7f),
			new Point(4000f, 0.8f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.9f),
			new Point(250f, 0.9f),
			new Point(500f, 0.9f),
			new Point(1000f, 0.8f),
			new Point(2000f, 0.5f),
			new Point(4000f, 0.3f)
		};
	}

	private static void Glass(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.35f),
			new Point(250f, 0.25f),
			new Point(500f, 0.18f),
			new Point(1000f, 0.12f),
			new Point(2000f, 0.07f),
			new Point(4000f, 0.05f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.05f),
			new Point(250f, 0.05f),
			new Point(500f, 0.05f),
			new Point(1000f, 0.05f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.05f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.125f),
			new Point(250f, 0.089f),
			new Point(500f, 0.05f),
			new Point(1000f, 0.028f),
			new Point(2000f, 0.022f),
			new Point(4000f, 0.079f)
		};
	}

	private static void GlassHeavy(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.18f),
			new Point(250f, 0.06f),
			new Point(500f, 0.04f),
			new Point(1000f, 0.03f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.02f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.05f),
			new Point(250f, 0.05f),
			new Point(500f, 0.05f),
			new Point(1000f, 0.05f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.05f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.056f),
			new Point(250f, 0.039f),
			new Point(500f, 0.028f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.032f),
			new Point(4000f, 0.014f)
		};
	}

	private static void Grass(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.11f),
			new Point(250f, 0.26f),
			new Point(500f, 0.6f),
			new Point(1000f, 0.69f),
			new Point(2000f, 0.92f),
			new Point(4000f, 0.99f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.3f),
			new Point(250f, 0.3f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.5f),
			new Point(2000f, 0.6f),
			new Point(4000f, 0.7f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void Gravel(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.25f),
			new Point(250f, 0.6f),
			new Point(500f, 0.65f),
			new Point(1000f, 0.7f),
			new Point(2000f, 0.75f),
			new Point(4000f, 0.8f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.3f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.5f),
			new Point(2000f, 0.6f),
			new Point(4000f, 0.7f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void GypsumBoard(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.29f),
			new Point(250f, 0.1f),
			new Point(500f, 0.05f),
			new Point(1000f, 0.04f),
			new Point(2000f, 0.07f),
			new Point(4000f, 0.09f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.11f),
			new Point(500f, 0.12f),
			new Point(1000f, 0.13f),
			new Point(2000f, 0.14f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.035f),
			new Point(250f, 0.0125f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0025f),
			new Point(2000f, 0.0013f),
			new Point(4000f, 0.0032f)
		};
	}

	private static void PlasterOnBrick(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.02f),
			new Point(500f, 0.02f),
			new Point(1000f, 0.03f),
			new Point(2000f, 0.04f),
			new Point(4000f, 0.05f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.25f),
			new Point(500f, 0.3f),
			new Point(1000f, 0.35f),
			new Point(2000f, 0.4f),
			new Point(4000f, 0.45f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.025f),
			new Point(250f, 0.019f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.0045f),
			new Point(2000f, 0.0018f),
			new Point(4000f, 0.00089f)
		};
	}

	private static void PlasterOnConcreteBlock(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.12f),
			new Point(250f, 0.09f),
			new Point(500f, 0.07f),
			new Point(1000f, 0.05f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.04f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.25f),
			new Point(500f, 0.3f),
			new Point(1000f, 0.35f),
			new Point(2000f, 0.4f),
			new Point(4000f, 0.45f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.01f),
			new Point(500f, 0.0063f),
			new Point(1000f, 0.0035f),
			new Point(2000f, 0.00011f),
			new Point(4000f, 0.00063f)
		};
	}

	private static void Soil(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.15f),
			new Point(250f, 0.25f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.55f),
			new Point(2000f, 0.6f),
			new Point(4000f, 0.6f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.2f),
			new Point(500f, 0.25f),
			new Point(1000f, 0.4f),
			new Point(2000f, 0.55f),
			new Point(4000f, 0.7f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void SoundProof(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(1000f, 1f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(1000f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void Snow(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.45f),
			new Point(250f, 0.75f),
			new Point(500f, 0.9f),
			new Point(1000f, 0.95f),
			new Point(2000f, 0.95f),
			new Point(4000f, 0.95f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.3f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.5f),
			new Point(2000f, 0.6f),
			new Point(4000f, 0.75f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void Steel(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.05f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.07f),
			new Point(4000f, 0.02f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.1f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.25f),
			new Point(250f, 0.2f),
			new Point(500f, 0.17f),
			new Point(1000f, 0.089f),
			new Point(2000f, 0.089f),
			new Point(4000f, 0.0056f)
		};
	}

	private static void Water(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.01f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.03f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.07f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.05f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.03f),
			new Point(250f, 0.03f),
			new Point(500f, 0.03f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.015f),
			new Point(4000f, 0.01f)
		};
	}

	private static void WoodThin(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.42f),
			new Point(250f, 0.21f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.08f),
			new Point(2000f, 0.06f),
			new Point(4000f, 0.06f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.125f),
			new Point(500f, 0.079f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.089f),
			new Point(4000f, 0.05f)
		};
	}

	private static void WoodThick(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.19f),
			new Point(250f, 0.14f),
			new Point(500f, 0.09f),
			new Point(1000f, 0.06f),
			new Point(2000f, 0.06f),
			new Point(4000f, 0.05f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.035f),
			new Point(250f, 0.028f),
			new Point(500f, 0.028f),
			new Point(1000f, 0.028f),
			new Point(2000f, 0.011f),
			new Point(4000f, 0.0071f)
		};
	}

	private static void WoodFloor(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.15f),
			new Point(250f, 0.11f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.07f),
			new Point(2000f, 0.06f),
			new Point(4000f, 0.07f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.071f),
			new Point(250f, 0.025f),
			new Point(500f, 0.0158f),
			new Point(1000f, 0.0056f),
			new Point(2000f, 0.0035f),
			new Point(4000f, 0.0016f)
		};
	}

	private static void WoodOnConcrete(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.04f),
			new Point(250f, 0.04f),
			new Point(500f, 0.07f),
			new Point(1000f, 0.06f),
			new Point(2000f, 0.06f),
			new Point(4000f, 0.07f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}
}
public class ONSPPropagationSettings : MonoBehaviour
{
	public float quality = 100f;

	private void Update()
	{
		ONSPPropagation.Interface.SetPropagationQuality(quality / 100f);
	}
}
public sealed class ONSPSettings : ScriptableObject
{
	[SerializeField]
	public int voiceLimit = 64;

	private static ONSPSettings instance;

	public static ONSPSettings Instance
	{
		get
		{
			if (instance == null)
			{
				instance = Resources.Load<ONSPSettings>("ONSPSettings");
				if (instance == null)
				{
					instance = ScriptableObject.CreateInstance<ONSPSettings>();
				}
			}
			return instance;
		}
	}
}
public class ONSPVersion : MonoBehaviour
{
	public const string strONSPS = "AudioPluginOculusSpatializer";

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern void ONSP_GetVersion(ref int Major, ref int Minor, ref int Patch);

	private void Awake()
	{
		int Major = 0;
		int Minor = 0;
		int Patch = 0;
		ONSP_GetVersion(ref Major, ref Minor, ref Patch);
		string message = $"ONSP Version: {Major:F0}.{Minor:F0}.{Patch:F0}";
		UnityEngine.Debug.Log(message);
	}

	private void Start()
	{
	}

	private void Update()
	{
	}
}
namespace Pvr_UnitySDKAPI.Achievement
{
	public sealed class AchievementCore
	{
		private static bool IsPlatformInitialized = true;

		public static bool LogMessages;

		public static bool IsInitialized()
		{
			return IsPlatformInitialized;
		}

		public static void Initialize()
		{
		}

		public static void RegisterNetwork()
		{
			Pvr_AchievementAPI.RegisterNetwork();
		}

		public static void UnRegisterNetwork()
		{
			Pvr_AchievementAPI.UnRegisterNetwork();
		}
	}
	public static class Achievements
	{
		public static Pvr_Request<Pvr_AchievementUpdate> Init()
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementUpdate>(Pvr_AchievementAPI.Init());
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementUpdate> AddCount(string name, long count)
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementUpdate>(Pvr_AchievementAPI.pvr_Achievements_AddCount(name, count));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementUpdate> AddFields(string name, string fields)
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementUpdate>(Pvr_AchievementAPI.pvr_Achievements_AddFields(name, fields));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementDefinitionList> GetAllDefinitions()
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementDefinitionList>(Pvr_AchievementAPI.pvr_Achievements_GetAllDefinitions());
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementProgressList> GetAllProgress()
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementProgressList>(Pvr_AchievementAPI.pvr_Achievements_GetAllProgress());
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementDefinitionList> GetDefinitionsByName(string[] names)
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementDefinitionList>(Pvr_AchievementAPI.pvr_Achievements_GetDefinitionsByName(names, (names != null) ? names.Length : 0));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementProgressList> GetProgressByName(string[] names)
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementProgressList>(Pvr_AchievementAPI.pvr_Achievements_GetProgressByName(names, (names != null) ? names.Length : 0));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementUpdate> Unlock(string name)
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementUpdate>(Pvr_AchievementAPI.pvr_Achievements_Unlock(name));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementDefinitionList> GetNextAchievementDefinitionListPage(Pvr_AchievementDefinitionList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Platform.GetNextAchievementDefinitionListPage: List has no next page");
				return null;
			}
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementDefinitionList>(Pvr_AchievementAPI.pvr_HTTP_GetWithMessageType(list.NextUrl, Pvr_Message.MessageType.Achievements_GetNextAchievementDefinitionArrayPage));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementProgressList> GetNextAchievementProgressListPage(Pvr_AchievementProgressList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Platform.GetNextAchievementProgressListPage: List has no next page");
				return null;
			}
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementProgressList>(Pvr_AchievementAPI.pvr_HTTP_GetWithMessageType(list.NextUrl, Pvr_Message.MessageType.Achievements_GetNextAchievementProgressArrayPage));
			}
			return null;
		}
	}
	public enum AchievementType
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("SIMPLE")]
		Simple,
		[Description("BITFIELD")]
		Bitfield,
		[Description("COUNT")]
		Count
	}
	public class Pvr_AchievementAPI
	{
		private static AndroidJavaClass achievementAPI = new AndroidJavaClass("com.pico.achievenment.AchievementAPI");

		private static AndroidJavaClass definitionArrayHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementDefinitionArrayHandle");

		private static AndroidJavaClass definitionHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementDefinitionHandle");

		private static AndroidJavaClass progressArrayHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementProgressArrayHandle");

		private static AndroidJavaClass progressHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementProgressHandle");

		private static AndroidJavaClass updateHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementUpdateHandle");

		private static AndroidJavaObject errorHandle = new AndroidJavaObject("com.picovr.achievement.utils.pvrAchievementErrorHandle");

		private static AndroidJavaObject unityInterface = new AndroidJavaObject("com.pico.loginpaysdk.UnityInterface");

		private static string openId;

		private static string accessToken;

		private static string appId = Pvr_UnitySDKPlatformSetting.Instance.appID;

		internal static long Init()
		{
			long num = 0L;
			AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
			AndroidJavaObject @static = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
			unityInterface.Call("init", @static);
			unityInterface.Call("authSSO");
			AndroidJavaClass androidJavaClass2 = new AndroidJavaClass("com.pico.loginpaysdk.utils.PicoAccessTokenKeeper");
			AndroidJavaObject androidJavaObject = androidJavaClass2.CallStatic<AndroidJavaObject>("readAccessToken", new object[1] { @static });
			accessToken = androidJavaObject.Call<string>("getAccessToken", Array.Empty<object>());
			openId = androidJavaObject.Call<string>("getOpenId", Array.Empty<object>());
			return achievementAPI.CallStatic<long>("init", new object[3] { accessToken, openId, @static });
		}

		internal static void RegisterNetwork()
		{
			AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
			AndroidJavaObject @static = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
			achievementAPI.CallStatic("registerNetwork", @static);
		}

		internal static void UnRegisterNetwork()
		{
			achievementAPI.CallStatic("unregisterNetwork");
		}

		internal static AndroidJavaObject PopMessage()
		{
			return achievementAPI.CallStatic<AndroidJavaObject>("pvr_PopMessage", Array.Empty<object>());
		}

		internal static string pvr_Error_GetMessage(AndroidJavaObject popMessage)
		{
			string empty = string.Empty;
			return errorHandle.CallStatic<string>("pvr_Error_GetMessage", new object[1] { popMessage });
		}

		internal static int pvr_Error_GetHttpCode(AndroidJavaObject popMessage)
		{
			int num = 0;
			return errorHandle.CallStatic<int>("pvr_Error_GetHttpCode", new object[1] { popMessage });
		}

		internal static int pvr_Error_GetCode(AndroidJavaObject popMessage)
		{
			int num = 0;
			return errorHandle.CallStatic<int>("pvr_Error_GetCode", new object[1] { popMessage });
		}

		internal static long pvr_Achievements_AddCount(string name, long count)
		{
			long num = 0L;
			return achievementAPI.CallStatic<long>("pvr_Achievements_AddCount", new object[3] { name, count, accessToken });
		}

		internal static long pvr_Achievements_AddFields(string name, string fields)
		{
			long num = 0L;
			return achievementAPI.CallStatic<long>("pvr_Achievements_AddFields", new object[3] { name, fields, accessToken });
		}

		internal static long pvr_Achievements_GetAllDefinitions()
		{
			long num = 0L;
			AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
			AndroidJavaObject @static = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
			return achievementAPI.CallStatic<long>("pvr_Achievements_GetAllDefinitions", new object[2] { appId, @static });
		}

		internal static long pvr_Achievements_GetAllProgress()
		{
			long num = 0L;
			return achievementAPI.CallStatic<long>("pvr_Achievements_GetAllProgress", new object[1] { accessToken });
		}

		internal static long pvr_Achievements_GetDefinitionsByName(string[] names, int v)
		{
			long num = 0L;
			AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
			AndroidJavaObject @static = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
			return achievementAPI.CallStatic<long>("pvr_Achievements_GetDefinitionsByName", new object[2] { names, @static });
		}

		internal static long pvr_Achievements_GetProgressByName(string[] names, int v)
		{
			long num = 0L;
			return achievementAPI.CallStatic<long>("pvr_Achievements_GetProgressByName", new object[2] { names, accessToken });
		}

		internal static long pvr_Achievements_Unlock(string name)
		{
			long num = 0L;
			return achievementAPI.CallStatic<long>("pvr_Achievements_Unlock", new object[2] { name, accessToken });
		}

		internal static long pvr_HTTP_GetWithMessageType(string nextUrl, Pvr_Message.MessageType messageType)
		{
			long result = 0L;
			switch (messageType)
			{
			case Pvr_Message.MessageType.Achievements_GetNextAchievementDefinitionArrayPage:
			{
				AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
				AndroidJavaObject @static = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
				result = achievementAPI.CallStatic<long>("pvr_Achievements_GetAllDefinitionsByUrl", new object[2] { nextUrl, @static });
				break;
			}
			case Pvr_Message.MessageType.Achievements_GetNextAchievementProgressArrayPage:
				result = achievementAPI.CallStatic<long>("pvr_Achievements_GetAllProgressByUrl", new object[1] { nextUrl });
				break;
			}
			return result;
		}

		internal static long pvr_Message_GetType(AndroidJavaObject popMessage)
		{
			long num = 0L;
			return popMessage.Call<AndroidJavaObject>("getHandleType", Array.Empty<object>()).Call<long>("getIndex", Array.Empty<object>());
		}

		internal static bool pvr_Message_IsError(AndroidJavaObject popMessage)
		{
			return popMessage.Call<bool>("isMessage_IsError", Array.Empty<object>());
		}

		internal static long pvr_Message_GetRequestID(AndroidJavaObject popMessage)
		{
			long num = 0L;
			return popMessage.Call<long>("getId", Array.Empty<object>());
		}

		internal static string pvr_Message_GetString(AndroidJavaObject popMessage)
		{
			string empty = string.Empty;
			return popMessage.Call<string>("getContent", Array.Empty<object>());
		}

		internal static bool pvr_AchievementUpdate_GetJustUnlocked(AndroidJavaObject popMessage)
		{
			bool flag = true;
			return updateHandle.CallStatic<bool>("pvr_AchievementUpdate_GetJustUnlocked", new object[1] { popMessage });
		}

		internal static string pvr_AchievementUpdate_GetName(AndroidJavaObject popMessage)
		{
			string empty = string.Empty;
			return updateHandle.CallStatic<string>("pvr_AchievementUpdate_GetName", new object[1] { popMessage });
		}

		internal static int pvr_AchievementProgressArray_GetSize(AndroidJavaObject msg)
		{
			int num = 0;
			return progressArrayHandle.CallStatic<int>("pvr_AchievementProgressArray_GetSize", new object[1] { msg });
		}

		internal static AndroidJavaObject pvr_AchievementProgressArray_GetElement(AndroidJavaObject msg, int index)
		{
			return progressArrayHandle.CallStatic<AndroidJavaObject>("pvr_AchievementProgressArray_GetElement", new object[2] { msg, index });
		}

		internal static string pvr_AchievementProgressArray_GetNextUrl(AndroidJavaObject msg)
		{
			string empty = string.Empty;
			return progressArrayHandle.CallStatic<string>("pvr_AchievementProgressArray_GetNextUrl", new object[1] { msg });
		}

		internal static string pvr_AchievementProgress_GetBitfield(AndroidJavaObject msg)
		{
			string empty = string.Empty;
			return progressHandle.CallStatic<string>("pvr_AchievementProgress_GetBitfield", new object[1] { msg });
		}

		internal static long pvr_AchievementProgress_GetCount(AndroidJavaObject msg)
		{
			long num = 0L;
			return progressHandle.CallStatic<long>("pvr_AchievementProgress_GetCount", new object[1] { msg });
		}

		internal static bool pvr_AchievementProgress_GetIsUnlocked(AndroidJavaObject msg)
		{
			bool flag = true;
			return progressHandle.CallStatic<bool>("pvr_AchievementProgress_GetIsUnlocked", new object[1] { msg });
		}

		internal static string pvr_AchievementProgress_GetName(AndroidJavaObject msg)
		{
			string empty = string.Empty;
			return progressHandle.CallStatic<string>("pvr_AchievementProgress_GetName", new object[1] { msg });
		}

		internal static DateTime pvr_AchievementProgress_GetUnlockTime(AndroidJavaObject msg)
		{
			DateTime dateTime = new DateTime(1970, 1, 1, 0, 0, 0, 0);
			return DateTimeFromNative(progressHandle.CallStatic<long>("pvr_AchievementProgress_GetUnlockTime", new object[1] { msg }));
		}

		internal static DateTime DateTimeFromNative(long seconds_since_the_one_true_epoch)
		{
			return new DateTime(1970, 1, 1, 0, 0, 0, 0).AddSeconds(seconds_since_the_one_true_epoch).ToLocalTime();
		}

		internal static int pvr_AchievementDefinitionArray_GetSize(AndroidJavaObject msg)
		{
			int num = 0;
			return definitionArrayHandle.CallStatic<int>("pvr_AchievementDefinitionArray_GetSize", new object[1] { msg });
		}

		internal static AndroidJavaObject pvr_AchievementDefinitionArray_GetElement(AndroidJavaObject msg, int index)
		{
			return definitionArrayHandle.CallStatic<AndroidJavaObject>("pvr_AchievementDefinitionArray_GetElement", new object[2] { msg, index });
		}

		internal static string pvr_AchievementDefinitionArray_GetNextUrl(AndroidJavaObject msg)
		{
			string empty = string.Empty;
			return definitionArrayHandle.CallStatic<string>("pvr_AchievementDefinitionArray_GetNextUrl", new object[1] { msg });
		}

		internal static AchievementType pvr_AchievementDefinition_GetType(AndroidJavaObject msg)
		{
			AchievementType achievementType = AchievementType.Bitfield;
			AndroidJavaObject androidJavaObject = definitionHandle.CallStatic<AndroidJavaObject>("pvr_AchievementDefinition_GetType", new object[1] { msg });
			return (AchievementType)androidJavaObject.Call<int>("getIndex", Array.Empty<object>());
		}

		internal static string pvr_AchievementDefinition_GetName(AndroidJavaObject msg)
		{
			string empty = string.Empty;
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetName", new object[1] { msg });
		}

		internal static int pvr_AchievementDefinition_GetBitfieldLength(AndroidJavaObject msg)
		{
			int num = 0;
			return definitionHandle.CallStatic<int>("pvr_AchievementDefinition_GetBitfieldLength", new object[1] { msg });
		}

		internal static long pvr_AchievementDefinition_GetTarget(AndroidJavaObject msg)
		{
			long num = 0L;
			return definitionHandle.CallStatic<long>("pvr_AchievementDefinition_GetTarget", new object[1] { msg });
		}

		internal static string pvr_AchievementDefinition_GetTitle(AndroidJavaObject msg)
		{
			string empty = string.Empty;
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetTitle", new object[1] { msg });
		}

		internal static string pvr_AchievementDefinition_GetUnlockedDescription(AndroidJavaObject msg)
		{
			string empty = string.Empty;
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetUnlocked_description", new object[1] { msg });
		}

		internal static string pvr_AchievementDefinition_GetLockedIcon(AndroidJavaObject msg)
		{
			string empty = string.Empty;
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetLocked_image", new object[1] { msg });
		}

		internal static bool pvr_AchievementDefinition_GetIsSecrect(AndroidJavaObject msg)
		{
			bool flag = false;
			return definitionHandle.CallStatic<bool>("pvr_AchievementDefinition_GetIs_secret", new object[1] { msg });
		}

		internal static string pvr_AchievementDefinition_GetUnlockedIcon(AndroidJavaObject msg)
		{
			string empty = string.Empty;
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetUnlocked_image", new object[1] { msg });
		}

		internal static string pvr_AchievementDefinition_GetDescription(AndroidJavaObject msg)
		{
			string empty = string.Empty;
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetDescription", new object[1] { msg });
		}
	}
}
public class AchievementSample : MonoBehaviour
{
	public Text dataOutput;

	public InputField getDefinitionsByNameInputField;

	public InputField getProgressByNameInputField;

	public InputField unLockInputField;

	public InputField addCountInputField;

	public InputField addFieldsInputField;

	private void Start()
	{
		AchievementCore.RegisterNetwork();
	}

	private void OnDestroy()
	{
		AchievementCore.UnRegisterNetwork();
	}

	private void OnApplicationPause(bool pause)
	{
		if (!pause)
		{
			printOutputLine("Achievement Init");
			achievementInit();
		}
	}

	private void Update()
	{
		Pvr_UnitySDKAPI.Achievement.Request.RunCallbacks();
	}

	public void AsyncInitialize()
	{
		dataOutput.text = "> ";
		printOutputLine("AsyncInitialize");
		achievementInit();
	}

	public void GetDefinitionsByName()
	{
		dataOutput.text = "> ";
		printOutputLine("GetDefinitionsByName");
		string text = getDefinitionsByNameInputField.text;
		if (text != string.Empty)
		{
			string[] achievementNames = text.Split(',');
			getAchievementDefinition(achievementNames);
			getDefinitionsByNameInputField.text = string.Empty;
		}
		else
		{
			printOutputLine("Invalid Command");
		}
	}

	public void GetProgressByName()
	{
		dataOutput.text = "> ";
		printOutputLine("GetProgressByName");
		string text = getProgressByNameInputField.text;
		if (text != string.Empty)
		{
			string[] achievementNames = text.Split(',');
			getAchievementProgress(achievementNames);
			getProgressByNameInputField.text = string.Empty;
		}
		else
		{
			printOutputLine("Invalid Command");
		}
	}

	public void GetAllDefinitions()
	{
		dataOutput.text = "> ";
		printOutputLine("GetAllDefinitions");
		getAchievementAllDefinition();
	}

	public void GetAllProgress()
	{
		dataOutput.text = "> ";
		printOutputLine("GetAllProgress");
		getAchievementAllProgress();
	}

	public void UnLock()
	{
		dataOutput.text = "> ";
		printOutputLine("UnLock");
		string text = unLockInputField.text;
		if (text != string.Empty)
		{
			unlockAchievement(text);
			unLockInputField.text = string.Empty;
		}
		else
		{
			printOutputLine("Invalid Command");
		}
	}

	public void AddCount()
	{
		dataOutput.text = "> ";
		printOutputLine("AddCount");
		string text = addCountInputField.text;
		if (text != string.Empty)
		{
			string[] array = text.Split(',');
			if (array.Length > 1)
			{
				try
				{
					Convert.ToInt64(array[1]);
				}
				catch (Exception)
				{
					printOutputLine("Invalid Command");
					throw;
				}
				addCountAchievement(array[0], array[1]);
				addCountInputField.text = string.Empty;
			}
			else
			{
				printOutputLine("Invalid Command");
			}
		}
		else
		{
			printOutputLine("Invalid Command");
		}
	}

	public void AddFields()
	{
		dataOutput.text = "> ";
		printOutputLine("AddFields");
		string text = addFieldsInputField.text;
		if (text != string.Empty)
		{
			string[] array = text.Split(',');
			if (array.Length > 1)
			{
				addFieldsAchievement(array[0], array[1]);
				addFieldsInputField.text = string.Empty;
			}
			else
			{
				printOutputLine("Invalid Command");
			}
		}
		else
		{
			printOutputLine("Invalid Command");
		}
	}

	private void achievementInit()
	{
		Pvr_UnitySDKAPI.Achievement.Achievements.Init().OnComplete(initAchievementCallback);
	}

	private void getAchievementAllDefinition()
	{
		Pvr_UnitySDKAPI.Achievement.Achievements.GetAllDefinitions().OnComplete(achievementAllDefinitionCallback);
	}

	private void getAchievementAllProgress()
	{
		Pvr_UnitySDKAPI.Achievement.Achievements.GetAllProgress().OnComplete(achievementAllProgressCallback);
	}

	private void addFieldsAchievement(string achievementName, string fields)
	{
		Pvr_UnitySDKAPI.Achievement.Achievements.AddFields(achievementName, fields).OnComplete(achievementFieldsCallback);
	}

	private void addCountAchievement(string achievementName, string count)
	{
		Pvr_UnitySDKAPI.Achievement.Achievements.AddCount(achievementName, Convert.ToInt64(count)).OnComplete(achievementCountCallback);
	}

	private void unlockAchievement(string achievementName)
	{
		Pvr_UnitySDKAPI.Achievement.Achievements.Unlock(achievementName).OnComplete(achievementUnlockCallback);
	}

	private void getAchievementProgress(string[] achievementNames)
	{
		Pvr_UnitySDKAPI.Achievement.Achievements.GetProgressByName(achievementNames).OnComplete(achievementProgressCallback);
	}

	private void getAchievementDefinition(string[] achievementNames)
	{
		Pvr_UnitySDKAPI.Achievement.Achievements.GetDefinitionsByName(achievementNames).OnComplete(achievementDefinitionCallback);
	}

	private void printOutputLine(string newLine)
	{
		dataOutput.text = "> " + newLine + Environment.NewLine + dataOutput.text;
	}

	private void achievementAllDefinitionCallback(Pvr_Message<Pvr_AchievementDefinitionList> msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Received achievement definitions success");
			Pvr_AchievementDefinitionList achievementDefinitions = msg.GetAchievementDefinitions();
			if (achievementDefinitions.HasNextPage)
			{
				Pvr_UnitySDKAPI.Achievement.Achievements.GetNextAchievementDefinitionListPage(achievementDefinitions).OnComplete(achievementAllDefinitionCallback);
			}
			{
				foreach (Pvr_AchievementDefinition item in achievementDefinitions)
				{
					printOutputLine("Bitfield Name: " + item.Name.ToString());
					switch (item.Type)
					{
					case Pvr_UnitySDKAPI.Achievement.AchievementType.Simple:
						printOutputLine("Achievement Type: Simple");
						break;
					case Pvr_UnitySDKAPI.Achievement.AchievementType.Bitfield:
						printOutputLine("Achievement Type: Bitfield");
						printOutputLine("Bitfield Length: " + item.BitfieldLength);
						printOutputLine("Target: " + item.Target);
						break;
					case Pvr_UnitySDKAPI.Achievement.AchievementType.Count:
						printOutputLine("Achievement Type: Count");
						printOutputLine("Target: " + item.Target);
						break;
					default:
						printOutputLine("Achievement Type: Unknown");
						break;
					}
					printOutputLine("Bitfield Title: " + item.Title.ToString());
					printOutputLine("Bitfield Description: " + item.Description.ToString());
					printOutputLine("Bitfield UnlockedDescription: " + item.UnlockedDescription.ToString());
					printOutputLine("Bitfield UnlockedIcon: " + item.UnlockedIcon.ToString());
					printOutputLine("Bitfield LockedIcon: " + item.LockedIcon.ToString());
					printOutputLine("Bitfield IsSecrect: " + item.IsSecrect);
				}
				return;
			}
		}
		printOutputLine("Received achievement definitions error");
		Pvr_UnitySDKAPI.Achievement.Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementAllProgressCallback(Pvr_Message<Pvr_AchievementProgressList> msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Received achievement progress success");
			Pvr_AchievementProgressList achievementProgressList = msg.GetAchievementProgressList();
			if (achievementProgressList.HasNextPage)
			{
				Pvr_UnitySDKAPI.Achievement.Achievements.GetNextAchievementProgressListPage(achievementProgressList).OnComplete(achievementAllProgressCallback);
			}
			{
				foreach (Pvr_AchievementProgress item in achievementProgressList)
				{
					printOutputLine("Current Name: " + item.Name.ToString());
					if (item.IsUnlocked)
					{
						printOutputLine("Achievement Unlocked");
					}
					else
					{
						printOutputLine("Achievement Locked");
					}
					printOutputLine("Current Bitfield: " + item.Bitfield.ToString());
					printOutputLine("Current Count: " + item.Count);
					printOutputLine("Current UnlockTime: " + item.UnlockTime.ToString());
				}
				return;
			}
		}
		printOutputLine("Received achievement progress error");
		Pvr_UnitySDKAPI.Achievement.Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementFieldsCallback(Pvr_Message msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Achievement fields added.");
			return;
		}
		printOutputLine("Received achievement fields add error");
		Pvr_UnitySDKAPI.Achievement.Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementCountCallback(Pvr_Message msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Achievement count added.");
			return;
		}
		printOutputLine("Received achievement count add error");
		Pvr_UnitySDKAPI.Achievement.Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementUnlockCallback(Pvr_Message msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Achievement unlocked");
			return;
		}
		printOutputLine("Received achievement unlock error");
		Pvr_UnitySDKAPI.Achievement.Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementProgressCallback(Pvr_Message<Pvr_AchievementProgressList> msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Received achievement progress success");
			Pvr_AchievementProgressList achievementProgressList = msg.GetAchievementProgressList();
			{
				foreach (Pvr_AchievementProgress item in achievementProgressList)
				{
					if (item.IsUnlocked)
					{
						printOutputLine("Achievement Unlocked");
					}
					else
					{
						printOutputLine("Achievement Locked");
					}
					printOutputLine("Current Bitfield: " + item.Bitfield.ToString());
					printOutputLine("Current Count: " + item.Count);
				}
				return;
			}
		}
		printOutputLine("Received achievement progress error");
		Pvr_UnitySDKAPI.Achievement.Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementDefinitionCallback(Pvr_Message<Pvr_AchievementDefinitionList> msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Received achievement definitions success");
			Pvr_AchievementDefinitionList achievementDefinitions = msg.GetAchievementDefinitions();
			{
				foreach (Pvr_AchievementDefinition item in achievementDefinitions)
				{
					switch (item.Type)
					{
					case Pvr_UnitySDKAPI.Achievement.AchievementType.Simple:
						printOutputLine("Achievement Type: Simple");
						break;
					case Pvr_UnitySDKAPI.Achievement.AchievementType.Bitfield:
						printOutputLine("Achievement Type: Bitfield");
						printOutputLine("Bitfield Length: " + item.BitfieldLength);
						printOutputLine("Target: " + item.Target);
						break;
					case Pvr_UnitySDKAPI.Achievement.AchievementType.Count:
						printOutputLine("Achievement Type: Count");
						printOutputLine("Target: " + item.Target);
						break;
					default:
						printOutputLine("Achievement Type: Unknown");
						break;
					}
				}
				return;
			}
		}
		printOutputLine("Received achievement definitions error");
		Pvr_UnitySDKAPI.Achievement.Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void initAchievementCallback(Pvr_Message msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Received init success");
			return;
		}
		printOutputLine("Received init error");
		Pvr_UnitySDKAPI.Achievement.Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void LoginCallback(string LoginInfo)
	{
		UnityEngine.Debug.Log("Received loginCallback:" + LoginInfo);
		printOutputLine("Received loginCallback: " + LoginInfo);
	}
}
namespace Pvr_UnitySDKAPI.Achievement
{
	public class Pvr_AchievementDefinition
	{
		public readonly AchievementType Type;

		public readonly string Name;

		public readonly int BitfieldLength;

		public readonly long Target;

		public readonly string Title;

		public readonly string Description;

		public readonly string UnlockedDescription;

		public readonly string UnlockedIcon;

		public readonly string LockedIcon;

		public readonly bool IsSecrect;

		public Pvr_AchievementDefinition(AndroidJavaObject msg)
		{
			Type = Pvr_AchievementAPI.pvr_AchievementDefinition_GetType(msg);
			Name = Pvr_AchievementAPI.pvr_AchievementDefinition_GetName(msg);
			BitfieldLength = Pvr_AchievementAPI.pvr_AchievementDefinition_GetBitfieldLength(msg);
			Target = Pvr_AchievementAPI.pvr_AchievementDefinition_GetTarget(msg);
			Title = Pvr_AchievementAPI.pvr_AchievementDefinition_GetTitle(msg);
			Description = Pvr_AchievementAPI.pvr_AchievementDefinition_GetDescription(msg);
			UnlockedDescription = Pvr_AchievementAPI.pvr_AchievementDefinition_GetUnlockedDescription(msg);
			UnlockedIcon = Pvr_AchievementAPI.pvr_AchievementDefinition_GetUnlockedIcon(msg);
			LockedIcon = Pvr_AchievementAPI.pvr_AchievementDefinition_GetLockedIcon(msg);
			IsSecrect = Pvr_AchievementAPI.pvr_AchievementDefinition_GetIsSecrect(msg);
		}
	}
	public class Pvr_AchievementDefinitionList : Pvr_DeserializableList<Pvr_AchievementDefinition>
	{
		public Pvr_AchievementDefinitionList(AndroidJavaObject msg)
		{
			int num = Pvr_AchievementAPI.pvr_AchievementDefinitionArray_GetSize(msg);
			data = new List<Pvr_AchievementDefinition>(num);
			for (int i = 0; i < num; i++)
			{
				data.Add(new Pvr_AchievementDefinition(Pvr_AchievementAPI.pvr_AchievementDefinitionArray_GetElement(msg, i)));
			}
			nextUrl = Pvr_AchievementAPI.pvr_AchievementDefinitionArray_GetNextUrl(msg);
		}
	}
	public class Pvr_AchievementProgress
	{
		public readonly string Bitfield;

		public readonly long Count;

		public readonly bool IsUnlocked;

		public readonly string Name;

		public readonly DateTime UnlockTime;

		public Pvr_AchievementProgress(AndroidJavaObject msg)
		{
			Bitfield = Pvr_AchievementAPI.pvr_AchievementProgress_GetBitfield(msg);
			Count = Pvr_AchievementAPI.pvr_AchievementProgress_GetCount(msg);
			IsUnlocked = Pvr_AchievementAPI.pvr_AchievementProgress_GetIsUnlocked(msg);
			Name = Pvr_AchievementAPI.pvr_AchievementProgress_GetName(msg);
			UnlockTime = Pvr_AchievementAPI.pvr_AchievementProgress_GetUnlockTime(msg);
		}
	}
	public class Pvr_AchievementProgressList : Pvr_DeserializableList<Pvr_AchievementProgress>
	{
		public Pvr_AchievementProgressList(AndroidJavaObject msg)
		{
			int num = Pvr_AchievementAPI.pvr_AchievementProgressArray_GetSize(msg);
			data = new List<Pvr_AchievementProgress>(num);
			for (int i = 0; i < num; i++)
			{
				data.Add(new Pvr_AchievementProgress(Pvr_AchievementAPI.pvr_AchievementProgressArray_GetElement(msg, i)));
			}
			nextUrl = Pvr_AchievementAPI.pvr_AchievementProgressArray_GetNextUrl(msg);
		}
	}
	public class Pvr_AchievementUpdate
	{
		public readonly bool JustUnlocked;

		public readonly string Name;

		public Pvr_AchievementUpdate(AndroidJavaObject msg)
		{
			JustUnlocked = Pvr_AchievementAPI.pvr_AchievementUpdate_GetJustUnlocked(msg);
			Name = Pvr_AchievementAPI.pvr_AchievementUpdate_GetName(msg);
		}
	}
	public class Pvr_DeserializableList<T> : IList<T>, ICollection<T>, IEnumerable<T>, IEnumerable
	{
		protected List<T> data;

		protected string nextUrl;

		protected string previousUrl;

		bool ICollection<T>.IsReadOnly => ((ICollection<T>)data).IsReadOnly;

		public int Count => data.Count;

		public T this[int index]
		{
			get
			{
				return data[index];
			}
			set
			{
				data[index] = value;
			}
		}

		public bool HasNextPage => !string.IsNullOrEmpty(NextUrl);

		public bool HasPreviousPage => !string.IsNullOrEmpty(PreviousUrl);

		public string NextUrl => nextUrl;

		public string PreviousUrl => previousUrl;

		public int IndexOf(T obj)
		{
			return data.IndexOf(obj);
		}

		public void Add(T item)
		{
			data.Add(item);
		}

		public void Clear()
		{
			data.Clear();
		}

		public bool Contains(T item)
		{
			return data.Contains(item);
		}

		public void CopyTo(T[] array, int arrayIndex)
		{
			data.CopyTo(array, arrayIndex);
		}

		public IEnumerator<T> GetEnumerator()
		{
			return data.GetEnumerator();
		}

		public void Insert(int index, T item)
		{
			data.Insert(index, item);
		}

		public bool Remove(T item)
		{
			return data.Remove(item);
		}

		public void RemoveAt(int index)
		{
			data.RemoveAt(index);
		}

		private IEnumerator GetEnumerator1()
		{
			return GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator1();
		}
	}
	public static class Pvr_Callback
	{
		private class RequestCallback
		{
			private Pvr_Message.Callback messageCallback;

			public RequestCallback()
			{
			}

			public RequestCallback(Pvr_Message.Callback callback)
			{
				messageCallback = callback;
			}

			public virtual void HandleMessage(Pvr_Message msg)
			{
				if (messageCallback != null)
				{
					messageCallback(msg);
				}
			}
		}

		private sealed class RequestCallback<T> : RequestCallback
		{
			private Pvr_Message<T>.Callback callback;

			public RequestCallback(Pvr_Message<T>.Callback callback)
			{
				this.callback = callback;
			}

			public override void HandleMessage(Pvr_Message msg)
			{
				if (callback != null)
				{
					if (msg is Pvr_Message<T>)
					{
						callback((Pvr_Message<T>)msg);
					}
					else
					{
						UnityEngine.Debug.LogError("Unable to handle message: " + msg.GetType());
					}
				}
			}
		}

		private static Dictionary<long, Request> requestIDsToRequests = new Dictionary<long, Request>();

		private static Dictionary<Pvr_Message.MessageType, RequestCallback> notificationCallbacks = new Dictionary<Pvr_Message.MessageType, RequestCallback>();

		internal static void AddRequest(Request request)
		{
			if (request.RequestID <= 2)
			{
				long requestID = request.RequestID;
				if (requestID >= 0 && requestID <= 2)
				{
					switch (requestID)
					{
					case 0L:
						UnityEngine.Debug.LogError("An PARAM_INVALIDE error occurred. Request failed.");
						return;
					case 1L:
						UnityEngine.Debug.LogError("An NETWORK_INVALIDE error occurred. Request failed.");
						return;
					case 2L:
						UnityEngine.Debug.LogError("An NOT_INTIALIZE error occurred. Request failed.");
						return;
					}
				}
				UnityEngine.Debug.LogError("An unknown error occurred. Request failed.");
			}
			else
			{
				requestIDsToRequests[request.RequestID] = request;
			}
		}

		internal static void RunCallbacks()
		{
			while (true)
			{
				Pvr_Message pvr_Message = Pvr_Message.PopMessage();
				if (pvr_Message == null)
				{
					break;
				}
				HandleMessage(pvr_Message);
			}
		}

		internal static void RunLimitedCallbacks(uint limit)
		{
			for (int i = 0; i < limit; i++)
			{
				Pvr_Message pvr_Message = Pvr_Message.PopMessage();
				if (pvr_Message == null)
				{
					break;
				}
				HandleMessage(pvr_Message);
			}
		}

		internal static void OnApplicationQuit()
		{
			requestIDsToRequests.Clear();
			notificationCallbacks.Clear();
		}

		internal static void HandleMessage(Pvr_Message msg)
		{
			if (msg.RequestID != 0 && requestIDsToRequests.TryGetValue(msg.RequestID, out var value))
			{
				try
				{
					value.HandleMessage(msg);
					return;
				}
				finally
				{
					requestIDsToRequests.Remove(msg.RequestID);
				}
			}
			if (notificationCallbacks.TryGetValue(msg.Type, out var value2))
			{
				value2.HandleMessage(msg);
			}
		}
	}
	public class Pvr_CallbackRunner : MonoBehaviour
	{
		public bool IsPersistantBetweenSceneLoads = true;

		private void Awake()
		{
			Pvr_CallbackRunner pvr_CallbackRunner = UnityEngine.Object.FindObjectOfType<Pvr_CallbackRunner>();
			if (pvr_CallbackRunner != this)
			{
				UnityEngine.Debug.LogWarning("You only need one instance of CallbackRunner");
			}
			if (IsPersistantBetweenSceneLoads)
			{
				UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
			}
		}

		private void Update()
		{
			Request.RunCallbacks();
		}

		private void OnApplicationQuit()
		{
			Pvr_Callback.OnApplicationQuit();
		}
	}
	public abstract class Pvr_Message<T> : Pvr_Message
	{
		public new delegate void Callback(Pvr_Message<T> message);

		private T data;

		public T Data => data;

		public Pvr_Message(AndroidJavaObject msg)
			: base(msg)
		{
			if (!base.IsError)
			{
				data = GetDataFromMessage(msg);
			}
		}

		protected abstract T GetDataFromMessage(AndroidJavaObject msg);
	}
	public class Pvr_Message
	{
		public delegate void Callback(Pvr_Message message);

		public enum MessageType : uint
		{
			Unknown = 0u,
			Achievements_AddCount = 65495601u,
			Achievements_AddFields = 346693929u,
			Achievements_GetAllDefinitions = 64177549u,
			Achievements_GetAllProgress = 1335877149u,
			Achievements_GetDefinitionsByName = 1653670332u,
			Achievements_GetNextAchievementDefinitionArrayPage = 712888917u,
			Achievements_GetNextAchievementProgressArrayPage = 792913703u,
			Achievements_GetProgressByName = 354837425u,
			Achievements_Unlock = 1497156573u,
			Achievements_WriteAchievementProgress = 121027549u,
			Achievements_VerifyAccessToken = 53284924u
		}

		internal delegate Pvr_Message ExtraMessageTypesHandler(AndroidJavaObject messageHandle, MessageType message_type);

		private MessageType type;

		private long requestID;

		private Error error;

		public MessageType Type => type;

		public bool IsError => error != null;

		public long RequestID => requestID;

		internal static ExtraMessageTypesHandler HandleExtraMessageTypes { private get; set; }

		public Pvr_Message(AndroidJavaObject msg)
		{
			type = (MessageType)Pvr_AchievementAPI.pvr_Message_GetType(msg);
			bool flag = Pvr_AchievementAPI.pvr_Message_IsError(msg);
			requestID = Pvr_AchievementAPI.pvr_Message_GetRequestID(msg);
			if (flag)
			{
				error = new Error(Pvr_AchievementAPI.pvr_Error_GetCode(msg), Pvr_AchievementAPI.pvr_Error_GetMessage(msg), Pvr_AchievementAPI.pvr_Error_GetHttpCode(msg));
			}
			else if (AchievementCore.LogMessages)
			{
				string text = Pvr_AchievementAPI.pvr_Message_GetString(msg);
				if (text != null)
				{
					UnityEngine.Debug.Log(text);
				}
				else
				{
					UnityEngine.Debug.Log($"null message string {msg}");
				}
			}
		}

		public virtual Error GetError()
		{
			return error;
		}

		public virtual Pvr_AchievementDefinitionList GetAchievementDefinitions()
		{
			return null;
		}

		public virtual Pvr_AchievementProgressList GetAchievementProgressList()
		{
			return null;
		}

		public virtual Pvr_AchievementUpdate GetAchievementUpdate()
		{
			return null;
		}

		public virtual string GetString()
		{
			return null;
		}

		internal static Pvr_Message ParseMessageHandle(AndroidJavaObject messageHandle)
		{
			if (messageHandle == null)
			{
				return null;
			}
			Pvr_Message result = null;
			switch ((MessageType)Pvr_AchievementAPI.pvr_Message_GetType(messageHandle))
			{
			case MessageType.Achievements_GetAllDefinitions:
			case MessageType.Achievements_GetNextAchievementDefinitionArrayPage:
			case MessageType.Achievements_GetDefinitionsByName:
				result = new MessageWithAchievementDefinitions(messageHandle);
				break;
			case MessageType.Achievements_GetProgressByName:
			case MessageType.Achievements_GetNextAchievementProgressArrayPage:
			case MessageType.Achievements_GetAllProgress:
				result = new MessageWithAchievementProgressList(messageHandle);
				break;
			case MessageType.Achievements_VerifyAccessToken:
			case MessageType.Achievements_AddCount:
			case MessageType.Achievements_AddFields:
			case MessageType.Achievements_Unlock:
				result = new MessageWithAchievementUpdate(messageHandle);
				break;
			}
			return result;
		}

		public static Pvr_Message PopMessage()
		{
			AndroidJavaObject messageHandle = Pvr_AchievementAPI.PopMessage();
			return ParseMessageHandle(messageHandle);
		}
	}
	public class MessageWithAchievementDefinitions : Pvr_Message<Pvr_AchievementDefinitionList>
	{
		public MessageWithAchievementDefinitions(AndroidJavaObject msg)
			: base(msg)
		{
		}

		public override Pvr_AchievementDefinitionList GetAchievementDefinitions()
		{
			return base.Data;
		}

		protected override Pvr_AchievementDefinitionList GetDataFromMessage(AndroidJavaObject msg)
		{
			return new Pvr_AchievementDefinitionList(msg);
		}
	}
	public class MessageWithAchievementProgressList : Pvr_Message<Pvr_AchievementProgressList>
	{
		public MessageWithAchievementProgressList(AndroidJavaObject msg)
			: base(msg)
		{
		}

		public override Pvr_AchievementProgressList GetAchievementProgressList()
		{
			return base.Data;
		}

		protected override Pvr_AchievementProgressList GetDataFromMessage(AndroidJavaObject msg)
		{
			return new Pvr_AchievementProgressList(msg);
		}
	}
	public class MessageWithAchievementUpdate : Pvr_Message<Pvr_AchievementUpdate>
	{
		public MessageWithAchievementUpdate(AndroidJavaObject msg)
			: base(msg)
		{
		}

		public override Pvr_AchievementUpdate GetAchievementUpdate()
		{
			return base.Data;
		}

		protected override Pvr_AchievementUpdate GetDataFromMessage(AndroidJavaObject msg)
		{
			return new Pvr_AchievementUpdate(msg);
		}
	}
	public class MessageWithString : Pvr_Message<string>
	{
		public MessageWithString(AndroidJavaObject msg)
			: base(msg)
		{
		}

		public override string GetString()
		{
			return base.Data;
		}

		protected override string GetDataFromMessage(AndroidJavaObject msg)
		{
			return Pvr_AchievementAPI.pvr_Message_GetString(msg);
		}
	}
	public class Error
	{
		public readonly int Code;

		public readonly int HttpCode;

		public readonly string Message;

		public Error(int code, string message, int httpCode)
		{
			Message = message;
			Code = code;
			HttpCode = httpCode;
		}
	}
	public sealed class Pvr_Request<T> : Request
	{
		private Pvr_Message<T>.Callback callback_;

		public Pvr_Request(long requestID)
			: base(requestID)
		{
		}

		public Pvr_Request<T> OnComplete(Pvr_Message<T>.Callback callback)
		{
			if (callback_ != null)
			{
				throw new UnityException("Attempted to attach multiple handlers to a Request.  This is not allowed.");
			}
			callback_ = callback;
			Pvr_Callback.AddRequest(this);
			return this;
		}

		public override void HandleMessage(Pvr_Message msg)
		{
			if (!(msg is Pvr_Message<T>))
			{
				UnityEngine.Debug.LogError("Unable to handle message: " + msg.GetType());
				return;
			}
			if (callback_ != null)
			{
				callback_((Pvr_Message<T>)msg);
				return;
			}
			throw new UnityException("Request with no handler.  This should never happen.");
		}
	}
	public class Request
	{
		private Pvr_Message.Callback callback_;

		public long RequestID { get; set; }

		public Request(long requestID)
		{
			RequestID = requestID;
		}

		public Request OnComplete(Pvr_Message.Callback callback)
		{
			callback_ = callback;
			Pvr_Callback.AddRequest(this);
			return this;
		}

		public virtual void HandleMessage(Pvr_Message msg)
		{
			if (callback_ != null)
			{
				callback_(msg);
				return;
			}
			throw new UnityException("Request with no handler.  This should never happen.");
		}

		public static void RunCallbacks(uint limit = 0u)
		{
			if (limit == 0)
			{
				Pvr_Callback.RunCallbacks();
			}
			else
			{
				Pvr_Callback.RunLimitedCallbacks(limit);
			}
		}
	}
}
namespace BoundarySystem_Ext
{
	internal static class Pvr_BoundaryAPI
	{
		private const string LibFileName = "Pvr_UnitySDK";

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_StartSDKBoundary();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_ShutdownSDKBoundary();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetMainSensorStateExt(ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz, ref float vfov, ref float hfov, ref int viewNumber);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr Pvr_GetCameraData_Ext();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_ResetVrModebyForce();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_ResumeBoundaryForSTS();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_PauseBoundaryForSTS();

		public static int UPvr_GetMainSensorStateExt(ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz, ref float vfov, ref float hfov, ref int viewNumber)
		{
			return Pvr_GetMainSensorStateExt(ref x, ref y, ref z, ref w, ref px, ref py, ref pz, ref vfov, ref hfov, ref viewNumber);
		}

		public static IntPtr UPvr_GetCameraData_Ext()
		{
			IntPtr zero = IntPtr.Zero;
			return Pvr_GetCameraData_Ext();
		}

		public static bool UPvr_ResumeBoundaryForSTS()
		{
			bool flag = false;
			return Pvr_ResumeBoundaryForSTS();
		}

		public static void UPvr_PauseBoundaryForSTS()
		{
			Pvr_PauseBoundaryForSTS();
		}

		public static IntPtr StructToIntPtr<T>(T info)
		{
			int cb = Marshal.SizeOf(info);
			IntPtr intPtr = Marshal.AllocHGlobal(cb);
			Marshal.StructureToPtr(info, intPtr, fDeleteOld: true);
			return intPtr;
		}

		public static T IntPtrToStruct<T>(IntPtr info)
		{
			return (T)Marshal.PtrToStructure(info, typeof(T));
		}
	}
	internal static class Pvr_SafeAreaAlgoAPI
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		public delegate void SafeAreaCallback(IntPtr lineCollectionPtr, IntPtr safeAreaRectPtr);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		public delegate void SafeAreaCallbackShrink(IntPtr lineCollectionPtr, IntPtr safeAreaDetailRectPtr);

		public struct GSAPoint3i
		{
			public int x;

			public int y;

			public int z;
		}

		public struct GSALine
		{
			public IntPtr pointArray;

			public int pointCount;
		}

		public struct GSALineCollection
		{
			public IntPtr lineArray;

			public int lineCount;
		}

		public struct GSALegalData
		{
			public int overMaxRange;

			public int includeBigGrap;

			public int bigGapNum;

			public int centerOut;

			public int removeNarrow;

			public int overMaxRange_more;

			public int validShrinkArea;
		}

		public struct GSARect
		{
			public GSAPoint3i leftup;

			public GSAPoint3i leftdown;

			public GSAPoint3i rightup;

			public GSAPoint3i rightdown;

			public GSAPoint3i center;

			public uint width;

			public uint height;

			public int isLegal;

			public GSALegalData legalData;
		}

		private const string LibFileName = "SafetyArea";

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSAInit(int width, int height);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSAShutDown();

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSASetCallback(SafeAreaCallback cb);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSASetCallbackShrink(SafeAreaCallbackShrink cb);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSAUpDateData(IntPtr lineCollectionPtr);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSASetConfigFilePath(IntPtr configPath);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool GSAGetClosedAreaUpdateFlag();

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSALoadSafetyArea(IntPtr lineCollectionPtr);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern double GSABoundaryDetector(ref GSAPoint3i pointPtr);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSALoadSafetyArea2(IntPtr lineCollectionPtr, bool isPlayArea);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern double GSABoundaryDetector2(ref GSAPoint3i point, bool isPlayArea, ref GSAPoint3i closestPoint, ref GSAPoint3i normalDir);

		public static int Pvr_GSAInit(int width, int height)
		{
			int num = -1;
			return GSAInit(width, height);
		}

		public static int Pvr_GSASetCallback(SafeAreaCallback cb)
		{
			int num = -1;
			return GSASetCallback(cb);
		}

		public static int Pvr_GSASetCallbackShrink(SafeAreaCallbackShrink cb)
		{
			int num = -1;
			return GSASetCallbackShrink(cb);
		}

		public static int Pvr_GSAUpDateData(IntPtr lineCollectionPtr)
		{
			int num = -1;
			return GSAUpDateData(lineCollectionPtr);
		}

		public static bool Pvr_GSAGetClosedAreaUpdateFlag()
		{
			bool flag = false;
			return GSAGetClosedAreaUpdateFlag();
		}

		public static int Pvr_GSASetConfigFilePath(string configPath)
		{
			int num = -1;
			IntPtr intPtr = Marshal.StringToHGlobalAnsi(configPath);
			num = GSASetConfigFilePath(intPtr);
			Marshal.FreeHGlobal(intPtr);
			return num;
		}

		public static int Pvr_GSALoadSafetyArea(IntPtr lineCollectionPtr)
		{
			int num = -1;
			return GSALoadSafetyArea(lineCollectionPtr);
		}

		public static double Pvr_GSABoundaryDetector(ref GSAPoint3i point)
		{
			double num = 0.0;
			return GSABoundaryDetector(ref point);
		}

		public static int Pvr_GSAShutDown()
		{
			int num = -1;
			return GSAShutDown();
		}

		public static int Pvr_GSALoadSafetyArea2(IntPtr lineCollectionPtr, bool isPlayArea)
		{
			int num = -1;
			return GSALoadSafetyArea2(lineCollectionPtr, isPlayArea);
		}

		public static double Pvr_GSABoundaryDetector2(ref GSAPoint3i point, bool isPlayArea, ref GSAPoint3i closestPoint, ref GSAPoint3i normalDir)
		{
			double num = 0.0;
			return GSABoundaryDetector2(ref point, isPlayArea, ref closestPoint, ref normalDir);
		}
	}
	public class Pvr_BoundarySystem
	{
		private static Pvr_BoundarySystem instance;

		public const int CameraImageWidth = 1280;

		public const int CameraImageHeight = 400;

		public IntPtr CameraFramePtr = IntPtr.Zero;

		public static Pvr_BoundarySystem Instance
		{
			get
			{
				if (instance == null)
				{
					instance = new Pvr_BoundarySystem();
				}
				return instance;
			}
		}

		public void OpenBoundary()
		{
			Pvr_BoundaryAPI.Pvr_StartSDKBoundary();
		}

		public void CloseBoundary()
		{
			Pvr_BoundaryAPI.Pvr_ShutdownSDKBoundary();
		}

		public void Reset6Dof()
		{
			Pvr_BoundaryAPI.Pvr_ResetVrModebyForce();
		}

		public float[] GetControllerFixedPoseData(int hand)
		{
			float[] result = new float[7] { 0f, 0f, 0f, 1f, 0f, 0f, 0f };
			if (Pvr_ControllerManager.controllerlink != null)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, Pvr_ControllerManager.controllerlink.javaCVClass, "getControllerFixedSensorState", hand);
			}
			result[2] = 0f - result[2];
			result[3] = 0f - result[3];
			return result;
		}
	}
	public class Pvr_SafeAreaAlgoModule
	{
		public struct ExtraInfo
		{
			public bool overMaxRange;

			public bool includeBigGap;

			public int bigGapNum;

			public bool centerOut;

			public bool removeNarrow;

			public bool overMaxRange_more;

			public int validShrinkArea;
		}

		public struct BoundaryPlayerArea
		{
			public Vector3 lowerleft;

			public Vector3 upperleft;

			public Vector3 upperRight;

			public Vector3 lowerRight;

			public Vector3 center;

			public uint width;

			public uint height;

			public bool isLegal;

			public ExtraInfo extraInfo;
		}

		public delegate void BoundarySystemCallback(BoundaryPlayerArea playAreaInfo, List<Vector3> boundaryPoints, List<List<Vector3>> unusedLines);

		public delegate void BoundarySystemCallbackShrink(List<Vector3> rectPoints, List<Vector3> boundaryPoints, List<List<Vector3>> unusedLines);

		private static Pvr_SafeAreaAlgoModule instance;

		private BoundarySystemCallback boundarySystemCallback;

		private BoundarySystemCallbackShrink boundarySystemCallbackShrink;

		public static Pvr_SafeAreaAlgoModule Instance
		{
			get
			{
				if (instance == null)
				{
					instance = new Pvr_SafeAreaAlgoModule();
				}
				return instance;
			}
		}

		public void RegisterCallBack(BoundarySystemCallback callback)
		{
			boundarySystemCallback = callback;
		}

		public void RegisterCallBackShrink(BoundarySystemCallbackShrink callback)
		{
			boundarySystemCallbackShrink = callback;
		}

		public bool Start()
		{
			int num = Pvr_SafeAreaAlgoAPI.Pvr_GSASetCallback(_SafeAreaCallback);
			int num2 = Pvr_SafeAreaAlgoAPI.Pvr_GSASetCallbackShrink(_SafeAreaCallbackShrink);
			if (num != 0 || num2 != 0)
			{
				UnityEngine.Debug.LogError("BoundarySystem register callback failed!");
				return false;
			}
			if (Pvr_SafeAreaAlgoAPI.Pvr_GSAInit(300, 300) != 0)
			{
				UnityEngine.Debug.LogError("BoundarySystem init failed!");
				return false;
			}
			return true;
		}

		public bool CommitNewLineData(bool isFistLine, Vector3[] points)
		{
			Pvr_SafeAreaAlgoAPI.GSALineCollection info = default(Pvr_SafeAreaAlgoAPI.GSALineCollection);
			info.lineCount = 2;
			Pvr_SafeAreaAlgoAPI.GSALine[] array = new Pvr_SafeAreaAlgoAPI.GSALine[2];
			if (isFistLine)
			{
				array[0].pointArray = IntPtr.Zero;
				array[0].pointCount = 0;
			}
			else
			{
				Pvr_SafeAreaAlgoAPI.GSAPoint3i[] arr = new Pvr_SafeAreaAlgoAPI.GSAPoint3i[1]
				{
					new Pvr_SafeAreaAlgoAPI.GSAPoint3i
					{
						x = 0,
						y = 0,
						z = 0
					}
				};
				array[0].pointArray = Marshal.UnsafeAddrOfPinnedArrayElement(arr, 0);
				array[0].pointCount = 1;
			}
			Pvr_SafeAreaAlgoAPI.GSAPoint3i[] array2 = new Pvr_SafeAreaAlgoAPI.GSAPoint3i[points.Length];
			for (int i = 0; i < points.Length; i++)
			{
				Pvr_SafeAreaAlgoAPI.GSAPoint3i gSAPoint3i = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
				gSAPoint3i.x = (int)(points[i].x * 1000f);
				gSAPoint3i.y = (int)(points[i].y * 1000f);
				gSAPoint3i.z = (int)(points[i].z * 1000f);
				array2[i] = gSAPoint3i;
			}
			array[1].pointArray = Marshal.UnsafeAddrOfPinnedArrayElement(array2, 0);
			array[1].pointCount = array2.Length;
			info.lineArray = Marshal.UnsafeAddrOfPinnedArrayElement(array, 0);
			IntPtr intPtr = Pvr_BoundaryAPI.StructToIntPtr(info);
			int num = Pvr_SafeAreaAlgoAPI.Pvr_GSAUpDateData(intPtr);
			Marshal.FreeHGlobal(intPtr);
			if (num != 0)
			{
				UnityEngine.Debug.LogError("BoundarySystem commit new line data failed!");
				return false;
			}
			return true;
		}

		public bool Shutdown()
		{
			if (Pvr_SafeAreaAlgoAPI.Pvr_GSAShutDown() != 0)
			{
				UnityEngine.Debug.LogError("BoundarySystem shutdown failed!");
				return false;
			}
			return true;
		}

		public double QueryDistanceOfPoint(Vector3 point)
		{
			Pvr_SafeAreaAlgoAPI.GSAPoint3i point2 = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
			point2.x = (int)(point.x * 1000f);
			point2.y = (int)(point.y * 1000f);
			point2.z = (int)(point.z * 1000f);
			double num = Pvr_SafeAreaAlgoAPI.Pvr_GSABoundaryDetector(ref point2);
			return num / 1000.0;
		}

		public double QueryDistanceOfPoint(Vector3 point, bool isPlayArea, ref Vector3 closestPoint, ref Vector3 normalDir)
		{
			Pvr_SafeAreaAlgoAPI.GSAPoint3i point2 = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
			point2.x = (int)(point.x * 1000f);
			point2.y = (int)(point.y * 1000f);
			point2.z = (int)(point.z * 1000f);
			Pvr_SafeAreaAlgoAPI.GSAPoint3i closestPoint2 = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
			Pvr_SafeAreaAlgoAPI.GSAPoint3i normalDir2 = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
			double num = Pvr_SafeAreaAlgoAPI.Pvr_GSABoundaryDetector2(ref point2, isPlayArea, ref closestPoint2, ref normalDir2);
			closestPoint.x = (float)closestPoint2.x / 1000f;
			closestPoint.y = (float)closestPoint2.y / 1000f;
			closestPoint.z = (float)closestPoint2.z / 1000f;
			normalDir.x = (float)normalDir2.x / 1000f;
			normalDir.y = (float)normalDir2.y / 1000f;
			normalDir.z = (float)normalDir2.z / 1000f;
			return num / 1000.0;
		}

		[MonoPInvokeCallback(typeof(Pvr_SafeAreaAlgoAPI.SafeAreaCallback))]
		private static void _SafeAreaCallback(IntPtr lineCollectionPtr, IntPtr safeAreaRectPtr)
		{
			if (lineCollectionPtr == IntPtr.Zero || safeAreaRectPtr == IntPtr.Zero)
			{
				UnityEngine.Debug.LogError("BoundarySystem callback is inValid!");
			}
			else
			{
				if (instance.boundarySystemCallback == null)
				{
					return;
				}
				List<Vector3> boundaryPoints = new List<Vector3>();
				List<List<Vector3>> list = new List<List<Vector3>>();
				int num = Marshal.SizeOf(typeof(Pvr_SafeAreaAlgoAPI.GSALine));
				int num2 = Marshal.SizeOf(typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
				Pvr_SafeAreaAlgoAPI.GSALineCollection gSALineCollection = Pvr_BoundaryAPI.IntPtrToStruct<Pvr_SafeAreaAlgoAPI.GSALineCollection>(lineCollectionPtr);
				for (int i = 0; i < gSALineCollection.lineCount; i++)
				{
					IntPtr ptr = new IntPtr(gSALineCollection.lineArray.ToInt64() + num * i);
					Pvr_SafeAreaAlgoAPI.GSALine gSALine = (Pvr_SafeAreaAlgoAPI.GSALine)Marshal.PtrToStructure(ptr, typeof(Pvr_SafeAreaAlgoAPI.GSALine));
					List<Vector3> list2 = new List<Vector3>();
					for (int j = 0; j < gSALine.pointCount; j++)
					{
						IntPtr ptr2 = new IntPtr(gSALine.pointArray.ToInt64() + num2 * j);
						Pvr_SafeAreaAlgoAPI.GSAPoint3i gSAPoint3i = (Pvr_SafeAreaAlgoAPI.GSAPoint3i)Marshal.PtrToStructure(ptr2, typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
						list2.Add(new Vector3((float)gSAPoint3i.x / 1000f, (float)gSAPoint3i.y / 1000f, (float)gSAPoint3i.z / 1000f));
					}
					if (i == 0)
					{
						boundaryPoints = list2;
					}
					else
					{
						list.Add(list2);
					}
				}
				Pvr_SafeAreaAlgoAPI.GSARect gSARect = Pvr_BoundaryAPI.IntPtrToStruct<Pvr_SafeAreaAlgoAPI.GSARect>(safeAreaRectPtr);
				BoundaryPlayerArea playAreaInfo = default(BoundaryPlayerArea);
				playAreaInfo.lowerleft = new Vector3((float)gSARect.leftup.x / 1000f, (float)gSARect.leftup.y / 1000f, (float)gSARect.leftup.z / 1000f);
				playAreaInfo.upperleft = new Vector3((float)gSARect.leftdown.x / 1000f, (float)gSARect.leftdown.y / 1000f, (float)gSARect.leftdown.z / 1000f);
				playAreaInfo.upperRight = new Vector3((float)gSARect.rightdown.x / 1000f, (float)gSARect.rightdown.y / 1000f, (float)gSARect.rightdown.z / 1000f);
				playAreaInfo.lowerRight = new Vector3((float)gSARect.rightup.x / 1000f, (float)gSARect.rightup.y / 1000f, (float)gSARect.rightup.z / 1000f);
				playAreaInfo.center = new Vector3((float)gSARect.center.x / 1000f, (float)gSARect.center.y / 1000f, (float)gSARect.center.z / 1000f);
				playAreaInfo.width = gSARect.width;
				playAreaInfo.height = gSARect.height;
				playAreaInfo.isLegal = ((gSARect.isLegal != 0) ? true : false);
				playAreaInfo.extraInfo.overMaxRange = ((gSARect.legalData.overMaxRange != 0) ? true : false);
				playAreaInfo.extraInfo.includeBigGap = ((gSARect.legalData.includeBigGrap != 0) ? true : false);
				playAreaInfo.extraInfo.bigGapNum = gSARect.legalData.bigGapNum;
				playAreaInfo.extraInfo.centerOut = ((gSARect.legalData.centerOut != 0) ? true : false);
				playAreaInfo.extraInfo.removeNarrow = ((gSARect.legalData.removeNarrow != 0) ? true : false);
				playAreaInfo.extraInfo.overMaxRange_more = ((gSARect.legalData.overMaxRange_more != 0) ? true : false);
				playAreaInfo.extraInfo.validShrinkArea = gSARect.legalData.validShrinkArea;
				instance.boundarySystemCallback(playAreaInfo, boundaryPoints, list);
			}
		}

		[MonoPInvokeCallback(typeof(Pvr_SafeAreaAlgoAPI.SafeAreaCallbackShrink))]
		private static void _SafeAreaCallbackShrink(IntPtr lineCollectionPtr, IntPtr safeAreaDetailRectPtr)
		{
			if (lineCollectionPtr == IntPtr.Zero || safeAreaDetailRectPtr == IntPtr.Zero)
			{
				UnityEngine.Debug.LogError("BoundarySystem callback is inValid!");
			}
			else
			{
				if (instance.boundarySystemCallbackShrink == null)
				{
					return;
				}
				List<Vector3> boundaryPoints = new List<Vector3>();
				List<List<Vector3>> list = new List<List<Vector3>>();
				int num = Marshal.SizeOf(typeof(Pvr_SafeAreaAlgoAPI.GSALine));
				int num2 = Marshal.SizeOf(typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
				Pvr_SafeAreaAlgoAPI.GSALineCollection gSALineCollection = Pvr_BoundaryAPI.IntPtrToStruct<Pvr_SafeAreaAlgoAPI.GSALineCollection>(lineCollectionPtr);
				for (int i = 0; i < gSALineCollection.lineCount; i++)
				{
					IntPtr ptr = new IntPtr(gSALineCollection.lineArray.ToInt64() + num * i);
					Pvr_SafeAreaAlgoAPI.GSALine gSALine = (Pvr_SafeAreaAlgoAPI.GSALine)Marshal.PtrToStructure(ptr, typeof(Pvr_SafeAreaAlgoAPI.GSALine));
					List<Vector3> list2 = new List<Vector3>();
					for (int j = 0; j < gSALine.pointCount; j++)
					{
						IntPtr ptr2 = new IntPtr(gSALine.pointArray.ToInt64() + num2 * j);
						Pvr_SafeAreaAlgoAPI.GSAPoint3i gSAPoint3i = (Pvr_SafeAreaAlgoAPI.GSAPoint3i)Marshal.PtrToStructure(ptr2, typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
						list2.Add(new Vector3((float)gSAPoint3i.x / 1000f, (float)gSAPoint3i.y / 1000f, (float)gSAPoint3i.z / 1000f));
					}
					if (i == 0)
					{
						boundaryPoints = list2;
					}
					else
					{
						list.Add(list2);
					}
				}
				List<Vector3> list3 = new List<Vector3>();
				Pvr_SafeAreaAlgoAPI.GSALineCollection gSALineCollection2 = Pvr_BoundaryAPI.IntPtrToStruct<Pvr_SafeAreaAlgoAPI.GSALineCollection>(safeAreaDetailRectPtr);
				for (int k = 0; k < gSALineCollection2.lineCount; k++)
				{
					IntPtr ptr3 = new IntPtr(gSALineCollection2.lineArray.ToInt64() + num * k);
					Pvr_SafeAreaAlgoAPI.GSALine gSALine2 = (Pvr_SafeAreaAlgoAPI.GSALine)Marshal.PtrToStructure(ptr3, typeof(Pvr_SafeAreaAlgoAPI.GSALine));
					for (int l = 0; l < gSALine2.pointCount; l++)
					{
						IntPtr ptr4 = new IntPtr(gSALine2.pointArray.ToInt64() + num2 * l);
						Pvr_SafeAreaAlgoAPI.GSAPoint3i gSAPoint3i2 = (Pvr_SafeAreaAlgoAPI.GSAPoint3i)Marshal.PtrToStructure(ptr4, typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
						list3.Add(new Vector3((float)gSAPoint3i2.x / 1000f, (float)gSAPoint3i2.y / 1000f, (float)gSAPoint3i2.z / 1000f));
					}
				}
				instance.boundarySystemCallbackShrink(list3, boundaryPoints, list);
			}
		}
	}
}
namespace Pvr_UnitySDKAPI
{
	public class PvrControllerKey
	{
		public bool State;

		public bool PressedDown;

		public bool PressedUp;

		public bool LongPressed;

		public bool Click;

		public bool Touch;

		public bool TouchDown;

		public bool TouchUp;

		public PvrControllerKey()
		{
			State = false;
			PressedDown = false;
			PressedUp = false;
			LongPressed = false;
			Click = false;
			Touch = false;
			TouchDown = false;
			TouchUp = false;
		}
	}
	public class ControllerHand
	{
		public PvrControllerKey App;

		public PvrControllerKey Touch;

		public PvrControllerKey Home;

		public PvrControllerKey VolumeDown;

		public PvrControllerKey VolumeUp;

		public PvrControllerKey Trigger;

		public PvrControllerKey X;

		public PvrControllerKey Y;

		public PvrControllerKey A;

		public PvrControllerKey B;

		public PvrControllerKey Left;

		public PvrControllerKey Right;

		public PvrControllerKey Thumbrest;

		public Vector2 TouchPadPosition;

		public int TriggerNum;

		public int GripValue;

		public Quaternion Rotation;

		public Vector3 Position;

		public int Battery;

		public ControllerState ConnectState;

		public SwipeDirection SwipeDirection;

		public TouchPadClick TouchPadClick;

		public bool isShowBoundary;

		public ControllerHand()
		{
			App = new PvrControllerKey();
			Touch = new PvrControllerKey();
			Home = new PvrControllerKey();
			VolumeDown = new PvrControllerKey();
			VolumeUp = new PvrControllerKey();
			Trigger = new PvrControllerKey();
			A = new PvrControllerKey();
			B = new PvrControllerKey();
			X = new PvrControllerKey();
			Y = new PvrControllerKey();
			Left = new PvrControllerKey();
			Right = new PvrControllerKey();
			Thumbrest = new PvrControllerKey();
			TouchPadPosition = default(Vector2);
			Rotation = default(Quaternion);
			Position = default(Vector3);
			Battery = 0;
			TriggerNum = 0;
			GripValue = 0;
			ConnectState = ControllerState.Error;
			SwipeDirection = SwipeDirection.No;
			TouchPadClick = TouchPadClick.No;
			isShowBoundary = false;
		}
	}
	public enum ControllerState
	{
		Error = -1,
		DisConnected,
		Connected
	}
	public enum Pvr_KeyCode
	{
		APP = 1,
		TOUCHPAD,
		HOME,
		VOLUMEUP,
		VOLUMEDOWN,
		TRIGGER,
		A,
		B,
		X,
		Y,
		Left,
		Right,
		Thumbrest
	}
	public enum SwipeDirection
	{
		No,
		SwipeUp,
		SwipeDown,
		SwipeLeft,
		SwipeRight
	}
	public enum TouchPadClick
	{
		No,
		ClickUp,
		ClickDown,
		ClickLeft,
		ClickRight
	}
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	public struct Controller
	{
		public const string LibFileName = "Pvr_UnitySDK";

		public static Vector2 UPvr_GetTouchPadPosition(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition, 
				_ => new Vector2(0f, 0f), 
			};
		}

		public static float UPvr_GetAxis1D(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.TRIGGER => (float)Pvr_ControllerManager.controllerlink.Controller0.TriggerNum / 255f, 
					Pvr_KeyCode.Left => (float)Pvr_ControllerManager.controllerlink.Controller0.GripValue / 255f, 
					_ => 0f, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.TRIGGER => (float)Pvr_ControllerManager.controllerlink.Controller1.TriggerNum / 255f, 
					Pvr_KeyCode.Right => (float)Pvr_ControllerManager.controllerlink.Controller1.GripValue / 255f, 
					_ => 0f, 
				}, 
				_ => 0f, 
			};
		}

		public static Vector2 UPvr_GetAxis2D(int hand)
		{
			switch (hand)
			{
			case 0:
				if (Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition != Vector2.zero)
				{
					return new Vector2(Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.x / 128f - 1f, Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.y / 128f - 1f);
				}
				return Vector2.zero;
			case 1:
				if (Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition != Vector2.zero)
				{
					return new Vector2(Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.x / 128f - 1f, Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.y / 128f - 1f);
				}
				return Vector2.zero;
			default:
				return Vector2.zero;
			}
		}

		public static ControllerState UPvr_GetControllerState(int hand)
		{
			return hand switch
			{
				0 => (ControllerState)Convert.ToInt16(Pvr_ControllerManager.controllerlink.controller0Connected), 
				1 => (ControllerState)Convert.ToInt16(Pvr_ControllerManager.controllerlink.controller1Connected), 
				_ => ControllerState.Error, 
			};
		}

		public static Quaternion UPvr_GetControllerQUA(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.Rotation, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.Rotation, 
				_ => new Quaternion(0f, 0f, 0f, 1f), 
			};
		}

		public static Vector3 UPvr_GetControllerPOS(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.Position, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.Position, 
				_ => new Vector3(0f, 0f, 0f), 
			};
		}

		public static int UPvr_GetControllerTriggerValue(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.TriggerNum, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.TriggerNum, 
				_ => 0, 
			};
		}

		public static int UPvr_GetControllerPower(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.Battery, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.Battery, 
				_ => 0, 
			};
		}

		public static SwipeDirection UPvr_GetSwipeDirection(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.SwipeDirection, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.SwipeDirection, 
				_ => SwipeDirection.No, 
			};
		}

		public static TouchPadClick UPvr_GetTouchPadClick(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.TouchPadClick, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.TouchPadClick, 
				_ => TouchPadClick.No, 
			};
		}

		public static bool UPvr_GetKey(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller0.App.State, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller0.Home.State, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.State, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.State, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.State, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.State, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.State, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.State, 
					Pvr_KeyCode.Left => Pvr_ControllerManager.controllerlink.Controller0.Left.State, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller1.App.State, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller1.Home.State, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.State, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.State, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.State, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.State, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.State, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.State, 
					Pvr_KeyCode.Right => Pvr_ControllerManager.controllerlink.Controller1.Right.State, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_GetKeyDown(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller0.App.PressedDown, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller0.Home.PressedDown, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.PressedDown, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.PressedDown, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.PressedDown, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.PressedDown, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.PressedDown, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.PressedDown, 
					Pvr_KeyCode.Left => Pvr_ControllerManager.controllerlink.Controller0.Left.PressedDown, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller1.App.PressedDown, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller1.Home.PressedDown, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.PressedDown, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.PressedDown, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.PressedDown, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.PressedDown, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.PressedDown, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.PressedDown, 
					Pvr_KeyCode.Right => Pvr_ControllerManager.controllerlink.Controller1.Right.PressedDown, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_GetKeyUp(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller0.App.PressedUp, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller0.Home.PressedUp, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.PressedUp, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.PressedUp, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.PressedUp, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.PressedUp, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.PressedUp, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.PressedUp, 
					Pvr_KeyCode.Left => Pvr_ControllerManager.controllerlink.Controller0.Left.PressedUp, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller1.App.PressedUp, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller1.Home.PressedUp, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.PressedUp, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.PressedUp, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.PressedUp, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.PressedUp, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.PressedUp, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.PressedUp, 
					Pvr_KeyCode.Right => Pvr_ControllerManager.controllerlink.Controller1.Right.PressedUp, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_GetTouch(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.Touch, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.Touch, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.Touch, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.Touch, 
					Pvr_KeyCode.Thumbrest => Pvr_ControllerManager.controllerlink.Controller0.Thumbrest.Touch, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.Touch, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.Touch, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.Touch, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.Touch, 
					Pvr_KeyCode.Thumbrest => Pvr_ControllerManager.controllerlink.Controller1.Thumbrest.Touch, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_GetTouchDown(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.TouchDown, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.TouchDown, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.TouchDown, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.TouchDown, 
					Pvr_KeyCode.Thumbrest => Pvr_ControllerManager.controllerlink.Controller0.Thumbrest.TouchDown, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.TouchDown, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.TouchDown, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.TouchDown, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.TouchDown, 
					Pvr_KeyCode.Thumbrest => Pvr_ControllerManager.controllerlink.Controller1.Thumbrest.TouchDown, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_GetTouchUp(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.TouchUp, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.TouchUp, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.TouchUp, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.TouchUp, 
					Pvr_KeyCode.Thumbrest => Pvr_ControllerManager.controllerlink.Controller0.Thumbrest.TouchUp, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.TouchUp, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.TouchUp, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.TouchUp, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.TouchUp, 
					Pvr_KeyCode.Thumbrest => Pvr_ControllerManager.controllerlink.Controller1.Thumbrest.TouchUp, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_GetKeyClick(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller0.App.Click, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller0.Home.Click, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.Click, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.Click, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.Click, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.Click, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.Click, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.Click, 
					Pvr_KeyCode.Left => Pvr_ControllerManager.controllerlink.Controller0.Left.Click, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller1.App.Click, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller1.Home.Click, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.Click, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.Click, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.Click, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.Click, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.Click, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.Click, 
					Pvr_KeyCode.Right => Pvr_ControllerManager.controllerlink.Controller1.Right.Click, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_GetKeyLongPressed(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller0.App.LongPressed, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller0.Home.LongPressed, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.LongPressed, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.LongPressed, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.LongPressed, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.LongPressed, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.LongPressed, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.LongPressed, 
					Pvr_KeyCode.Left => Pvr_ControllerManager.controllerlink.Controller0.Left.LongPressed, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller1.App.LongPressed, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller1.Home.LongPressed, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.LongPressed, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.LongPressed, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.LongPressed, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.LongPressed, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.LongPressed, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.LongPressed, 
					Pvr_KeyCode.Right => Pvr_ControllerManager.controllerlink.Controller1.Right.LongPressed, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_IsTouching(int hand)
		{
			return hand switch
			{
				0 => Math.Abs(Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.x) > 0f || Math.Abs(Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.y) > 0f, 
				1 => Math.Abs(Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.x) > 0f || Math.Abs(Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.y) > 0f, 
				_ => false, 
			};
		}

		public static void UPvr_SetHandNess(Pvr_Controller.UserHandNess hand)
		{
			if (Pvr_ControllerManager.controllerlink.getHandness() != (int)hand)
			{
				Pvr_ControllerManager.controllerlink.setHandness((int)hand);
			}
		}

		public static Pvr_Controller.UserHandNess UPvr_GetHandNess()
		{
			return Pvr_ControllerManager.controllerlink.handness;
		}

		public static int UPvr_GetPreferenceDevice()
		{
			int trackingmode = Pvr_ControllerManager.controllerlink.trackingmode;
			int systemProp = Pvr_ControllerManager.controllerlink.systemProp;
			if (trackingmode == 0 || trackingmode == 1 || ((trackingmode == 3 || trackingmode == 5 || trackingmode == 6) && (systemProp == 1 || systemProp == 3)))
			{
				return 1;
			}
			return 2;
		}

		public static bool UPvr_IsEnbleTrigger()
		{
			return Pvr_ControllerManager.controllerlink.IsEnbleTrigger();
		}

		public static int UPvr_GetDeviceType()
		{
			return Pvr_ControllerManager.controllerlink.controllerType;
		}

		public static int UPvr_GetMainHandNess()
		{
			return Pvr_ControllerManager.controllerlink.mainHandID;
		}

		public static void UPvr_SetMainHandNess(int hand)
		{
			Pvr_ControllerManager.controllerlink.SetMainController(hand);
		}

		public static int UPvr_GetControllerAbility(int hand)
		{
			return Pvr_ControllerManager.controllerlink.GetControllerAbility(hand);
		}

		public static void UPvr_VibrateNeo2Controller(float strength, int time, int hand)
		{
			Pvr_ControllerManager.controllerlink.VibrateNeo2Controller(strength, time, hand);
		}

		public static int UPvr_GetControllerBindingState(int hand)
		{
			return Pvr_ControllerManager.controllerlink.GetControllerBindingState(hand);
		}

		public static Vector3 UPvr_GetVelocity(int hand)
		{
			return Pvr_ControllerManager.controllerlink.GetVelocity(hand);
		}

		public static Vector3 UPvr_GetAngularVelocity(int hand)
		{
			return Pvr_ControllerManager.controllerlink.GetAngularVelocity(hand);
		}

		public static Vector3 UPvr_GetAcceleration(int hand)
		{
			return Pvr_ControllerManager.controllerlink.GetAcceleration(hand);
		}

		public static void UPvr_ScanController()
		{
			Pvr_ControllerManager.controllerlink.StartScan();
		}

		public static void UPvr_StopScanController()
		{
			Pvr_ControllerManager.controllerlink.StopScan();
		}

		public static void UPvr_ConnectController(string mac)
		{
			if (mac != string.Empty)
			{
				Pvr_ControllerManager.controllerlink.hummingBirdMac = mac;
			}
			Pvr_ControllerManager.controllerlink.ConnectBLE();
		}

		public static void UPvr_DisConnectController()
		{
			Pvr_ControllerManager.controllerlink.DisConnectBLE();
		}

		public static void UPvr_ResetController(int hand)
		{
			Pvr_ControllerManager.controllerlink.ResetController(hand);
		}

		public static string UPvr_GetControllerVersion()
		{
			return Pvr_ControllerManager.controllerlink.GetControllerVersion();
		}

		public static void UPvr_GetDeviceVersion(int deviceType)
		{
			Pvr_ControllerManager.controllerlink.GetDeviceVersion(deviceType);
		}

		public static void UPvr_GetControllerSnCode(int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.GetControllerSnCode(controllerSerialNum);
		}

		public static void UPvr_SetControllerUnbind(int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.SetControllerUnbind(controllerSerialNum);
		}

		public static void UPvr_SetStationRestart()
		{
			Pvr_ControllerManager.controllerlink.SetStationRestart();
		}

		public static void UPvr_StartStationOtaUpdate()
		{
			Pvr_ControllerManager.controllerlink.StartStationOtaUpdate();
		}

		public static void UPvr_StartControllerOtaUpdate(int mode, int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.StartControllerOtaUpdate(mode, controllerSerialNum);
		}

		public static void UPvr_EnterPairMode(int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.EnterPairMode(controllerSerialNum);
		}

		public static void UPvr_SetControllerShutdown(int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.SetControllerShutdown(controllerSerialNum);
		}

		public static int UPvr_GetStationPairState()
		{
			return Pvr_ControllerManager.controllerlink.GetStationPairState();
		}

		public static int UPvr_GetStationOtaUpdateProgress()
		{
			return Pvr_ControllerManager.controllerlink.GetStationOtaUpdateProgress();
		}

		public static int UPvr_GetControllerOtaUpdateProgress()
		{
			return Pvr_ControllerManager.controllerlink.GetControllerOtaUpdateProgress();
		}

		public static void UPvr_GetControllerVersionAndSN(int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.GetControllerVersionAndSN(controllerSerialNum);
		}

		public static void UPvr_GetControllerUniqueID()
		{
			Pvr_ControllerManager.controllerlink.GetControllerUniqueID();
		}

		public void UPvr_InterruptStationPairMode()
		{
			Pvr_ControllerManager.controllerlink.InterruptStationPairMode();
		}

		public void UPvr_StartCV2PairingMode(int deviceType)
		{
			Pvr_ControllerManager.controllerlink.StartCV2PairingMode(deviceType);
		}

		public void UPvr_StopCV2PairingMode(int deviceType)
		{
			Pvr_ControllerManager.controllerlink.StopCV2PairingMode(deviceType);
		}

		public static void UPvr_SetArmModelParameters(int hand, int gazeType, float elbowHeight, float elbowDepth, float pointerTiltAngle)
		{
			Pvr_SetArmModelParameters(hand, gazeType, elbowHeight, elbowDepth, pointerTiltAngle);
		}

		public static void UPvr_CalcArmModelParameters(float[] headOrientation, float[] controllerOrientation, float[] controllerPrimary)
		{
			Pvr_CalcArmModelParameters(headOrientation, controllerOrientation, controllerPrimary);
		}

		public static void UPvr_GetPointerPose(float[] rotation, float[] position)
		{
			Pvr_GetPointerPose(rotation, position);
		}

		public static void UPvr_GetElbowPose(float[] rotation, float[] position)
		{
			Pvr_GetElbowPose(rotation, position);
		}

		public static void UPvr_GetWristPose(float[] rotation, float[] position)
		{
			Pvr_GetWristPose(rotation, position);
		}

		public static void UPvr_GetShoulderPose(float[] rotation, float[] position)
		{
			Pvr_GetShoulderPose(rotation, position);
		}

		public static void UPvr_IsEnbleHomeKey(bool state)
		{
			Pvr_ControllerManager.controllerlink.setIsEnbleHomeKey(state);
		}

		public static void UPvr_SwitchHomeKey(bool state)
		{
			Pvr_ControllerManager.controllerlink.SwitchHomeKey(state);
		}

		public static int UPvr_GetControllerSensorStatus(int id)
		{
			return Pvr_ControllerManager.controllerlink.getControllerSensorStatus(id);
		}

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_CalcArmModelParameters(float[] headOrientation, float[] controllerOrientation, float[] gyro);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_GetPointerPose(float[] rotation, float[] position);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_GetElbowPose(float[] rotation, float[] position);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_GetWristPose(float[] rotation, float[] position);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_GetShoulderPose(float[] rotation, float[] position);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetArmModelParameters(int hand, int gazeType, float elbowHeight, float elbowDepth, float pointerTiltAngle);
	}
}
public class Pvr_Controller : MonoBehaviour
{
	public enum UserHandNess
	{
		Right,
		Left
	}

	public enum GazeType
	{
		Never,
		DuringMotion,
		Always
	}

	public enum ControllerAxis
	{
		Controller,
		Wrist,
		Elbow,
		Shoulder
	}

	public GameObject controller0;

	public GameObject controller1;

	private static UserHandNess handness;

	public ControllerAxis Axis;

	public GazeType Gazetype;

	[Range(0f, 0.2f)]
	public float ElbowHeight;

	[Range(0f, 0.2f)]
	public float ElbowDepth;

	[Range(0f, 30f)]
	public float PointerTiltAngle = 15f;

	private float mouseX;

	private float mouseY;

	private float mouseZ;

	private Vector3[] inputDirection = new Vector3[2];

	public static Vector3 pointerPosition { get; set; }

	public static Quaternion pointerRotation { get; set; }

	public static Vector3 elbowPosition { get; set; }

	public static Quaternion elbowRotation { get; set; }

	public static Vector3 wristPosition { get; set; }

	public static Quaternion wristRotation { get; set; }

	public static Vector3 shoulderPosition { get; set; }

	public static Quaternion shoulderRotation { get; set; }

	private void Awake()
	{
		Pvr_ControllerManager.PvrServiceStartSuccessEvent += ServiceStartSuccess;
		Pvr_ControllerManager.SetControllerAbilityEvent += CheckControllerState;
		Pvr_ControllerManager.ChangeMainControllerCallBackEvent += MainControllerChanged;
		Pvr_ControllerManager.ChangeHandNessCallBackEvent += HandnessChanged;
	}

	private void Start()
	{
		handness = Controller.UPvr_GetHandNess();
		if (handness == (UserHandNess)(-1))
		{
			handness = UserHandNess.Right;
		}
	}

	private void OnDestroy()
	{
		Pvr_ControllerManager.PvrServiceStartSuccessEvent -= ServiceStartSuccess;
		Pvr_ControllerManager.SetControllerAbilityEvent -= CheckControllerState;
		Pvr_ControllerManager.ChangeMainControllerCallBackEvent -= MainControllerChanged;
		Pvr_ControllerManager.ChangeHandNessCallBackEvent -= HandnessChanged;
	}

	private void MainControllerChanged(string index)
	{
		RefreshHandness();
	}

	private void HandnessChanged(string index)
	{
		RefreshHandness();
	}

	private void ServiceStartSuccess()
	{
		RefreshHandness();
	}

	private void RefreshHandness()
	{
		handness = Controller.UPvr_GetHandNess();
		if (Controller.UPvr_GetMainHandNess() == 1)
		{
			ChangeHandNess();
		}
	}

	private void OnApplicationPause(bool pause)
	{
		if (!pause)
		{
			if (controller0 != null)
			{
				controller0.transform.localScale = Vector3.zero;
			}
			if (controller1 != null)
			{
				controller1.transform.localScale = Vector3.zero;
			}
		}
		Invoke("ShowController", 0.1f * Time.timeScale);
	}

	private void ShowController()
	{
		if (controller0 != null)
		{
			controller0.transform.localScale = Vector3.one;
		}
		if (controller1 != null)
		{
			controller1.transform.localScale = Vector3.one;
		}
	}

	private void CheckControllerState(string data)
	{
		bool flag = Convert.ToBoolean(Convert.ToInt16(data.Substring(4, 1)));
		short num = Convert.ToInt16(data.Substring(0, 1));
		if (flag && num == 1)
		{
			RefreshHandness();
		}
	}

	private void Update()
	{
		if (Pvr_UnitySDKManager.SDK.ControllerOnlyrot)
		{
			DoUpdateControler0();
			DoUpdateControler1();
			UpdateControlloerRay();
			return;
		}
		if (Controller.UPvr_GetPreferenceDevice() == 1)
		{
			DoUpdateControler0();
			DoUpdateControler1();
			UpdateControlloerRay();
			return;
		}
		if (controller0 != null)
		{
			controller0.transform.localRotation = Controller.UPvr_GetControllerQUA(0);
			controller0.transform.localPosition = Controller.UPvr_GetControllerPOS(0);
			UpdateControlloerRay(update0: true, update1: false);
		}
		if (controller1 != null)
		{
			controller1.transform.localRotation = Controller.UPvr_GetControllerQUA(1);
			controller1.transform.localPosition = Controller.UPvr_GetControllerPOS(1);
			UpdateControlloerRay(update0: false);
		}
	}

	public static void ChangeHandNess()
	{
		handness = ((handness == UserHandNess.Right) ? UserHandNess.Left : UserHandNess.Right);
	}

	private void DoUpdateControler0()
	{
		SetArmParaToSo((int)handness, (int)Gazetype, ElbowHeight, ElbowDepth, PointerTiltAngle);
		CalcArmModelfromSo(0);
		UpdateControllerDataSO(0);
	}

	private void DoUpdateControler1()
	{
		int hand = ((handness != UserHandNess.Left) ? 1 : 0);
		SetArmParaToSo(hand, (int)Gazetype, ElbowHeight, ElbowDepth, PointerTiltAngle);
		CalcArmModelfromSo(1);
		UpdateControllerDataSO(1);
	}

	private void UpdateControlloerRay(bool update0 = true, bool update1 = true)
	{
		if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
		{
			if (update0 && controller0 != null)
			{
				controller0.GetComponent<Pvr_ControllerModuleInit>().UpdateRay();
			}
			if (update1 && controller1 != null)
			{
				controller1.GetComponent<Pvr_ControllerModuleInit>().UpdateRay();
			}
		}
	}

	private Quaternion UpdateSimulatedFrameParams()
	{
		if (Input.GetKey(KeyCode.LeftShift))
		{
			mouseX += Input.GetAxis("Mouse X") * 5f;
			if (mouseX <= -180f)
			{
				mouseX += 360f;
			}
			else if (mouseX > 180f)
			{
				mouseX -= 360f;
			}
			mouseY -= Input.GetAxis("Mouse Y") * 2.4f;
			mouseY = Mathf.Clamp(mouseY, -80f, 80f);
		}
		else if (Input.GetKey(KeyCode.RightShift))
		{
			mouseZ += Input.GetAxis("Mouse X") * 5f;
			mouseZ = Mathf.Clamp(mouseZ, -80f, 80f);
		}
		return Quaternion.Euler(mouseY, mouseX, mouseZ);
	}

	private void SetArmParaToSo(int hand, int gazeType, float elbowHeight, float elbowDepth, float pointerTiltAngle)
	{
		Controller.UPvr_SetArmModelParameters(hand, gazeType, elbowHeight, elbowDepth, pointerTiltAngle);
	}

	private void CalcArmModelfromSo(int hand)
	{
		float[] array = new float[4];
		float[] array2 = new float[4];
		float[] array3 = new float[3];
		Quaternion quaternion = default(Quaternion);
		quaternion = Controller.UPvr_GetControllerQUA(hand);
		Vector3 vector = Controller.UPvr_GetAngularVelocity(hand);
		array2[0] = quaternion.x;
		array2[1] = quaternion.y;
		array2[2] = quaternion.z;
		array2[3] = quaternion.w;
		array3[0] = vector.x;
		array3[1] = vector.y;
		array3[2] = vector.z;
		if (Gazetype == GazeType.DuringMotion)
		{
			Vector3 b = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation * Vector3.forward;
			b.y = 0f;
			b.Normalize();
			float magnitude = vector.magnitude;
			float t = Mathf.Clamp((magnitude - 0.2f) / 45f, 0f, 0.1f);
			ref Vector3 reference = ref inputDirection[hand];
			reference = Vector3.Slerp(inputDirection[hand], b, t);
			if (Controller.UPvr_GetKeyLongPressed(hand, Pvr_KeyCode.HOME))
			{
				inputDirection[hand] = default(Vector3);
			}
			Quaternion quaternion2 = Quaternion.FromToRotation(Vector3.forward, inputDirection[hand]);
			array[0] = quaternion2.x;
			array[1] = quaternion2.y;
			array[2] = quaternion2.z;
			array[3] = quaternion2.w;
		}
		else
		{
			array[0] = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.x;
			array[1] = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.y;
			array[2] = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.z;
			array[3] = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.w;
		}
		Controller.UPvr_CalcArmModelParameters(array, array2, array3);
	}

	public void UpdateControllerDataSO(int hand)
	{
		float[] array = new float[4];
		float[] array2 = new float[3];
		Vector3 vector;
		Quaternion localRotation;
		switch (Axis)
		{
		case ControllerAxis.Controller:
			Controller.UPvr_GetPointerPose(array, array2);
			pointerPosition = new Vector3(array2[0], array2[1], array2[2]);
			pointerRotation = new Quaternion(array[0], array[1], array[2], array[3]);
			vector = pointerPosition;
			localRotation = pointerRotation;
			break;
		case ControllerAxis.Wrist:
			Controller.UPvr_GetWristPose(array, array2);
			wristPosition = new Vector3(array2[0], array2[1], array2[2]);
			wristRotation = new Quaternion(array[0], array[1], array[2], array[3]);
			vector = wristPosition;
			localRotation = wristRotation;
			break;
		case ControllerAxis.Elbow:
			Controller.UPvr_GetElbowPose(array, array2);
			elbowPosition = new Vector3(array2[0], array2[1], array2[2]);
			elbowRotation = new Quaternion(array[0], array[1], array[2], array[3]);
			vector = elbowPosition;
			localRotation = elbowRotation;
			break;
		case ControllerAxis.Shoulder:
			Controller.UPvr_GetShoulderPose(array, array2);
			shoulderPosition = new Vector3(array2[0], array2[1], array2[2]);
			shoulderRotation = new Quaternion(array[0], array[1], array[2], array[3]);
			vector = shoulderPosition;
			localRotation = shoulderRotation;
			break;
		default:
			throw new Exception("Invalid FromJoint.");
		}
		if (hand == 0)
		{
			if (controller0 != null)
			{
				if (!Pvr_UnitySDKManager.SDK.HmdOnlyrot)
				{
					controller0.transform.localPosition = vector + Pvr_UnitySDKSensor.Instance.HeadPose.Position;
				}
				else if (Pvr_UnitySDKManager.SDK.TrackingOrigin == TrackingOrigin.FloorLevel)
				{
					controller0.transform.localPosition = vector + Pvr_UnitySDKSensor.Instance.HeadPose.Position;
				}
				else
				{
					controller0.transform.localPosition = vector;
				}
				controller0.transform.localRotation = localRotation;
			}
		}
		else if (controller1 != null)
		{
			if (!Pvr_UnitySDKManager.SDK.HmdOnlyrot)
			{
				controller1.transform.localPosition = vector + Pvr_UnitySDKSensor.Instance.HeadPose.Position;
			}
			else if (Pvr_UnitySDKManager.SDK.TrackingOrigin == TrackingOrigin.FloorLevel)
			{
				controller1.transform.localPosition = vector + Pvr_UnitySDKSensor.Instance.HeadPose.Position;
			}
			else
			{
				controller1.transform.localPosition = vector;
			}
			controller1.transform.localRotation = localRotation;
		}
	}
}
public class Pvr_ControllerDemo : MonoBehaviour
{
	public GameObject HeadSetController;

	public GameObject controller0;

	public GameObject controller1;

	public GameObject cube;

	private Ray ray;

	private GameObject currentController;

	private Transform lastHit;

	private Transform currentHit;

	[SerializeField]
	private Material normat;

	[SerializeField]
	private Material gazemat;

	[SerializeField]
	private Material clickmat;

	private bool noClick;

	private GameObject referenceObj;

	public float rayDefaultLength = 4f;

	private bool isHasController;

	private bool headcontrolmode;

	private RaycastHit hit;

	private GameObject rayLine;

	private GameObject dot;

	private Transform dragObj;

	private float disX;

	private float disY;

	private float disZ;

	private void Start()
	{
		ray = default(Ray);
		hit = default(RaycastHit);
		if (Pvr_UnitySDKManager.SDK.isHasController)
		{
			Pvr_ControllerManager.PvrServiceStartSuccessEvent += ServiceStartSuccess;
			Pvr_ControllerManager.SetControllerStateChangedEvent += ControllerStateListener;
			Pvr_ControllerManager.ControllerStatusChangeEvent += CheckControllerStateForGoblin;
			isHasController = true;
		}
		referenceObj = new GameObject("ReferenceObj");
	}

	private void OnDestroy()
	{
		if (isHasController)
		{
			Pvr_ControllerManager.PvrServiceStartSuccessEvent -= ServiceStartSuccess;
			Pvr_ControllerManager.SetControllerStateChangedEvent -= ControllerStateListener;
			Pvr_ControllerManager.ControllerStatusChangeEvent -= CheckControllerStateForGoblin;
		}
	}

	private void Update()
	{
		if (HeadSetController.activeSelf)
		{
			HeadSetController.transform.parent.localRotation = Quaternion.Euler(Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.eulerAngles.x, Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.eulerAngles.y, 0f);
			HeadSetController.transform.parent.localPosition = Pvr_UnitySDKSensor.Instance.HeadPose.Position;
			ray.direction = HeadSetController.transform.position - HeadSetController.transform.parent.parent.Find("Head").position;
			ray.origin = HeadSetController.transform.parent.parent.Find("Head").position;
			if (Physics.Raycast(ray, out hit))
			{
				if (HeadSetController.name == "SightPointer")
				{
					HeadSetController.transform.localScale = new Vector3(0.09f, 0.09f, 0.09f);
				}
				currentHit = hit.transform;
				if (currentHit != null && lastHit != null && currentHit != lastHit && (bool)lastHit.GetComponent<Pvr_UIGraphicRaycaster>() && lastHit.transform.gameObject.activeInHierarchy && lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = false;
				}
				if (currentHit != null && lastHit != null && currentHit == lastHit && (bool)currentHit.GetComponent<Pvr_UIGraphicRaycaster>() && !currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = true;
				}
				if (1 << hit.transform.gameObject.layer == LayerMask.GetMask("Water") && !noClick)
				{
					hit.transform.GetComponent<Renderer>().material = gazemat;
				}
				lastHit = hit.transform;
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					HeadSetController.transform.position = hit.point;
					HeadSetController.transform.position -= (hit.point - HeadSetController.transform.parent.parent.Find("Head").position).normalized * 0.02f;
					float num = 0.008f * hit.distance / 4f;
					Mathf.Clamp(num, 0.002f, 0.008f);
					HeadSetController.transform.localScale = new Vector3(num, num, 1f);
				}
			}
			else
			{
				if (HeadSetController.name == "SightPointer")
				{
					HeadSetController.transform.localScale = Vector3.zero;
				}
				if (lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water"))
				{
					lastHit.transform.GetComponent<Renderer>().material = normat;
				}
				currentHit = null;
				noClick = false;
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					HeadSetController.transform.position = HeadSetController.transform.parent.parent.Find("Head").position + ray.direction.normalized * (0.5f + rayDefaultLength);
					HeadSetController.transform.localScale = new Vector3(0.008f, 0.008f, 1f);
				}
			}
			if ((Input.GetKeyDown(KeyCode.JoystickButton0) || Input.GetMouseButtonDown(0)) && lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water") && currentHit != null)
			{
				lastHit.transform.GetComponent<Renderer>().material = clickmat;
				noClick = true;
			}
			return;
		}
		if (currentController != null)
		{
			ray.direction = currentController.transform.forward - currentController.transform.up * 0.25f;
			ray.origin = currentController.transform.Find("start").position;
			if (Physics.Raycast(ray, out hit))
			{
				currentHit = hit.transform;
				if (currentHit != null && lastHit != null && currentHit != lastHit && (bool)lastHit.GetComponent<Pvr_UIGraphicRaycaster>() && lastHit.transform.gameObject.activeInHierarchy && lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = false;
				}
				if (currentHit != null && lastHit != null && currentHit == lastHit && (bool)currentHit.GetComponent<Pvr_UIGraphicRaycaster>() && !currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = true;
				}
				if (1 << hit.transform.gameObject.layer == LayerMask.GetMask("Water"))
				{
					if (!noClick)
					{
						hit.transform.GetComponent<Renderer>().material = gazemat;
					}
					if (Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TOUCHPAD) || Input.GetMouseButtonDown(0))
					{
						referenceObj.transform.position = hit.point;
						disX = hit.transform.position.x - referenceObj.transform.position.x;
						disY = hit.transform.position.y - referenceObj.transform.position.y;
						dragObj = hit.transform;
					}
					if ((Controller.UPvr_GetKey(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKey(1, Pvr_KeyCode.TOUCHPAD) || Input.GetMouseButton(0)) && hit.transform == dragObj.transform)
					{
						referenceObj.transform.position = new Vector3(hit.point.x, hit.point.y, hit.transform.position.z);
						dragObj.position = new Vector3(referenceObj.transform.position.x + disX, referenceObj.transform.position.y + disY, hit.transform.position.z);
					}
				}
				lastHit = hit.transform;
				currentController.transform.Find("dot").position = hit.point;
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					float num2 = 0.178f * currentController.transform.Find("dot").localPosition.z / 3.3f;
					Mathf.Clamp(num2, 0.05f, 0.178f);
					currentController.transform.Find("dot").localScale = new Vector3(num2, num2, 1f);
				}
			}
			else
			{
				if (lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water"))
				{
					lastHit.transform.GetComponent<Renderer>().material = normat;
				}
				currentHit = null;
				noClick = false;
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					currentController.transform.Find("dot").localScale = new Vector3(0.178f, 0.178f, 1f);
				}
			}
		}
		if ((Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TOUCHPAD) || Input.GetMouseButtonDown(0)) && lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water") && currentHit != null)
		{
			lastHit.transform.GetComponent<Renderer>().material = clickmat;
			noClick = true;
		}
	}

	private void ServiceStartSuccess()
	{
		if (Controller.UPvr_GetControllerState(0) == ControllerState.Connected || Controller.UPvr_GetControllerState(1) == ControllerState.Connected)
		{
			HeadSetController.SetActive(value: false);
		}
		else
		{
			HeadSetController.SetActive(value: true);
		}
		if (Controller.UPvr_GetMainHandNess() == 0)
		{
			currentController = controller0;
		}
		if (Controller.UPvr_GetMainHandNess() == 1)
		{
			currentController = controller1;
		}
	}

	private void ControllerStateListener(string data)
	{
		if (Controller.UPvr_GetControllerState(0) == ControllerState.Connected || Controller.UPvr_GetControllerState(1) == ControllerState.Connected)
		{
			HeadSetController.SetActive(value: false);
		}
		else
		{
			HeadSetController.SetActive(value: true);
		}
		if (Controller.UPvr_GetMainHandNess() == 0)
		{
			currentController = controller0;
		}
		if (Controller.UPvr_GetMainHandNess() == 1)
		{
			currentController = controller1;
		}
	}

	private void CheckControllerStateForGoblin(string state)
	{
		HeadSetController.SetActive(Convert.ToInt16(state) != 1);
	}

	public void SwitchControlMode()
	{
	}
}
public class Pvr_ControllerEventsExamples : MonoBehaviour
{
	private void Start()
	{
		if (!(GetComponent<Pvr_UIPointer>() == null))
		{
			GetComponent<Pvr_UIPointer>().UIPointerElementEnter += UIPointerElementEnter;
			GetComponent<Pvr_UIPointer>().UIPointerElementExit += UIPointerElementExit;
			GetComponent<Pvr_UIPointer>().UIPointerElementClick += UIPointerElementClick;
			GetComponent<Pvr_UIPointer>().UIPointerElementDragStart += UIPointerElementDragStart;
			GetComponent<Pvr_UIPointer>().UIPointerElementDragEnd += UIPointerElementDragEnd;
		}
	}

	private void UIPointerElementEnter(object sender, UIPointerEventArgs e)
	{
		PLOG.I("UI Pointer entered" + e.currentTarget.name);
	}

	private void UIPointerElementExit(object sender, UIPointerEventArgs e)
	{
		PLOG.I("UI Pointer exited" + e.currentTarget.name);
	}

	private void UIPointerElementClick(object sender, UIPointerEventArgs e)
	{
		PLOG.I("UI Pointer clicked" + e.currentTarget.name);
	}

	private void UIPointerElementDragStart(object sender, UIPointerEventArgs e)
	{
		PLOG.I("UI Pointer started dragging" + e.currentTarget.name);
	}

	private void UIPointerElementDragEnd(object sender, UIPointerEventArgs e)
	{
		PLOG.I("UI Pointer stopped dragging" + e.currentTarget.name);
	}
}
public class Pvr_ControllerInit : MonoBehaviour
{
	private ControllerVariety Variety;

	private bool isCustomModel;

	[SerializeField]
	private GameObject goblin;

	[SerializeField]
	private GameObject g2;

	[SerializeField]
	private GameObject neo2L;

	[SerializeField]
	private GameObject neo2R;

	[SerializeField]
	private GameObject neo3L;

	[SerializeField]
	private GameObject neo3R;

	[SerializeField]
	private Material standardMat;

	[SerializeField]
	private Material unlitMat;

	private int controllerType = -1;

	[HideInInspector]
	public bool loadModelSuccess;

	private int systemOrUnity;

	private JsonData curControllerData;

	private string modelName = string.Empty;

	private string texFormat = string.Empty;

	private string prePath = string.Empty;

	private string modelFilePath = "/system/media/PvrRes/controller/";

	private const string goblinTexbasePath = "Controller/controller1/controller1";

	private const string g2TexbasePath = "Controller/controller3/controller3";

	private const string neo2TexbasePath = "Controller/controller4/controller4";

	private const string neo3TexbasePath = "Controller/controller5/controller5";

	private void Awake()
	{
		int configsenum = 15;
		Render.UPvr_GetIntConfig(configsenum, ref systemOrUnity);
		Variety = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().Variety;
		isCustomModel = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().IsCustomModel;
		if (!isCustomModel)
		{
			Pvr_ControllerManager.PvrServiceStartSuccessEvent += ServiceStartSuccess;
			Pvr_ControllerManager.SetControllerAbilityEvent += CheckControllerStateOfAbility;
			Pvr_ControllerManager.ControllerStatusChangeEvent += CheckControllerStateForGoblin;
		}
	}

	private void OnDestroy()
	{
		Pvr_ControllerManager.PvrServiceStartSuccessEvent -= ServiceStartSuccess;
		Pvr_ControllerManager.SetControllerAbilityEvent -= CheckControllerStateOfAbility;
		Pvr_ControllerManager.ControllerStatusChangeEvent -= CheckControllerStateForGoblin;
	}

	private void OnApplicationPause(bool pause)
	{
		if (pause)
		{
			DestroyLocalController();
		}
	}

	private void ServiceStartSuccess()
	{
		int num = Controller.UPvr_GetDeviceType();
		if (controllerType != num && num != 0)
		{
			controllerType = num;
		}
		LoadResFromJson();
		if (Pvr_ControllerManager.controllerlink.neoserviceStarted)
		{
			if (Variety == ControllerVariety.Controller0)
			{
				if (Pvr_ControllerManager.controllerlink.controller0Connected)
				{
					StartCoroutine(RefreshController(0));
				}
				else
				{
					DestroyLocalController();
				}
			}
			if (Variety == ControllerVariety.Controller1)
			{
				if (Pvr_ControllerManager.controllerlink.controller1Connected)
				{
					StartCoroutine(RefreshController(1));
				}
				else
				{
					DestroyLocalController();
				}
			}
		}
		if (Pvr_ControllerManager.controllerlink.goblinserviceStarted && Variety == ControllerVariety.Controller0)
		{
			if (Pvr_ControllerManager.controllerlink.controller0Connected)
			{
				StartCoroutine(RefreshController(0));
			}
			else
			{
				DestroyLocalController();
			}
		}
	}

	private void LoadResFromJson()
	{
		string text = Pvr_UnitySDKAPI.System.UPvr_GetObjectOrArray("config.controller", 7);
		if (text != null)
		{
			JsonData jsonData = JsonMapper.ToObject(text);
			if (controllerType >= 0 && jsonData.Count >= controllerType)
			{
				curControllerData = jsonData[controllerType - 1];
				modelFilePath = (string)curControllerData["base_path"];
				modelName = (string)curControllerData["model_name"] + "_sys";
			}
		}
		else
		{
			PLOG.E("PvrLog LoadJsonFromSystem Error");
		}
	}

	private void CheckControllerStateForGoblin(string state)
	{
		int num = Controller.UPvr_GetDeviceType();
		if (Variety != 0)
		{
			return;
		}
		if (Convert.ToInt16(state) == 1)
		{
			if (controllerType != num)
			{
				DestroySysController();
				controllerType = num;
			}
			StartCoroutine(RefreshController(0));
		}
		else
		{
			DestroyLocalController();
		}
	}

	private void CheckControllerStateOfAbility(string data)
	{
		bool flag = Convert.ToBoolean(Convert.ToInt16(data.Substring(4, 1)));
		short num = Convert.ToInt16(data.Substring(0, 1));
		int num2 = Controller.UPvr_GetDeviceType();
		if (flag)
		{
			controllerType = num2;
			switch (num)
			{
			case 0:
				if (Variety == ControllerVariety.Controller0)
				{
					StartCoroutine(RefreshController(0));
				}
				break;
			case 1:
				if (Variety == ControllerVariety.Controller1)
				{
					StartCoroutine(RefreshController(1));
				}
				break;
			}
			return;
		}
		switch (num)
		{
		case 0:
			if (Variety == ControllerVariety.Controller0)
			{
				DestroyLocalController();
			}
			break;
		case 1:
			if (Variety == ControllerVariety.Controller1)
			{
				DestroyLocalController();
			}
			break;
		}
	}

	private void DestroyLocalController()
	{
		foreach (Transform item in base.transform)
		{
			UnityEngine.Object.Destroy(item.gameObject);
			loadModelSuccess = false;
		}
	}

	private void DestroySysController()
	{
		foreach (Transform item in base.transform)
		{
			if (item.name == modelName)
			{
				UnityEngine.Object.Destroy(item.gameObject);
				loadModelSuccess = false;
			}
		}
	}

	private IEnumerator RefreshController(int id)
	{
		yield return null;
		yield return null;
		if (Controller.UPvr_GetControllerState(id) != ControllerState.Connected)
		{
			yield break;
		}
		if (systemOrUnity == 0)
		{
			LoadControllerFromPrefab();
			if (!loadModelSuccess)
			{
				LoadControllerFromSystem(id);
			}
		}
		else
		{
			bool flag = false;
			foreach (Transform item in base.transform)
			{
				if (item.name == modelName)
				{
					flag = true;
				}
			}
			if (!flag)
			{
				LoadControllerFromSystem(id);
				if (!loadModelSuccess)
				{
					LoadControllerFromPrefab();
				}
			}
			else
			{
				Transform transform2 = base.transform.Find(modelName);
				transform2.gameObject.SetActive(value: true);
			}
		}
		Pvr_ToolTips.RefreshTips();
		PLOG.I("PvrLog Controller Refresh Success");
	}

	private void LoadControllerFromPrefab()
	{
		switch (controllerType)
		{
		case 1:
		{
			GameObject gameObject3 = UnityEngine.Object.Instantiate(goblin, base.transform, worldPositionStays: false);
			Pvr_ControllerVisual pvr_ControllerVisual3 = gameObject3.AddComponent<Pvr_ControllerVisual>();
			pvr_ControllerVisual3.currentDevice = ControllerDevice.Goblin;
			LoadTexture(pvr_ControllerVisual3, "Controller/controller1/controller1", fromRes: true);
			loadModelSuccess = true;
			break;
		}
		case 3:
		{
			GameObject gameObject2 = UnityEngine.Object.Instantiate(g2, base.transform, worldPositionStays: false);
			Pvr_ControllerVisual pvr_ControllerVisual2 = gameObject2.AddComponent<Pvr_ControllerVisual>();
			pvr_ControllerVisual2.currentDevice = ControllerDevice.G2;
			LoadTexture(pvr_ControllerVisual2, "Controller/controller3/controller3", fromRes: true);
			loadModelSuccess = true;
			break;
		}
		case 4:
		{
			GameObject gameObject4 = UnityEngine.Object.Instantiate((Variety != 0) ? neo2R : neo2L, base.transform, worldPositionStays: false);
			Pvr_ControllerVisual pvr_ControllerVisual4 = gameObject4.AddComponent<Pvr_ControllerVisual>();
			pvr_ControllerVisual4.currentDevice = ControllerDevice.Neo2;
			LoadTexture(pvr_ControllerVisual4, "Controller/controller4/controller4", fromRes: true);
			loadModelSuccess = true;
			break;
		}
		case 5:
		{
			GameObject gameObject = UnityEngine.Object.Instantiate((Variety != 0) ? neo3R : neo3L, base.transform, worldPositionStays: false);
			Pvr_ControllerVisual pvr_ControllerVisual = gameObject.AddComponent<Pvr_ControllerVisual>();
			pvr_ControllerVisual.currentDevice = ControllerDevice.Neo3;
			LoadTexture(pvr_ControllerVisual, "Controller/controller5/controller5", fromRes: true);
			loadModelSuccess = true;
			break;
		}
		default:
			loadModelSuccess = false;
			break;
		}
	}

	private void LoadControllerFromSystem(int id)
	{
		string text = controllerType.ToString() + id + ".obj";
		string text2 = modelFilePath + text;
		if (!File.Exists(text2))
		{
			PLOG.I("PvrLog Obj File does not exist==" + text2);
			return;
		}
		GameObject gameObject = new GameObject();
		gameObject.name = modelName;
		MeshFilter meshFilter = gameObject.AddComponent<MeshFilter>();
		meshFilter.mesh = Pvr_ObjImporter.Instance.ImportFile(text2);
		gameObject.transform.SetParent(base.transform);
		gameObject.transform.localPosition = Vector3.zero;
		MeshRenderer meshRenderer = gameObject.AddComponent<MeshRenderer>();
		int num = (int)curControllerData["material_type"];
		meshRenderer.material = ((num != 0) ? unlitMat : standardMat);
		loadModelSuccess = true;
		Pvr_ControllerVisual pvr_ControllerVisual = gameObject.AddComponent<Pvr_ControllerVisual>();
		switch (controllerType)
		{
		case 1:
			pvr_ControllerVisual.currentDevice = ControllerDevice.Goblin;
			break;
		case 3:
			pvr_ControllerVisual.currentDevice = ControllerDevice.G2;
			break;
		case 4:
			pvr_ControllerVisual.currentDevice = ControllerDevice.Neo2;
			break;
		case 5:
			pvr_ControllerVisual.currentDevice = ControllerDevice.Neo3;
			break;
		default:
			pvr_ControllerVisual.currentDevice = ControllerDevice.NewController;
			break;
		}
		pvr_ControllerVisual.variety = Variety;
		LoadTexture(pvr_ControllerVisual, controllerType.ToString() + id, fromRes: false);
		gameObject.transform.localRotation = Quaternion.Euler(new Vector3(0f, 180f, 0f));
		gameObject.transform.localScale = new Vector3(-0.01f, 0.01f, 0.01f);
	}

	private void LoadTexture(Pvr_ControllerVisual visual, string controllerName, bool fromRes)
	{
		if (fromRes)
		{
			texFormat = string.Empty;
			prePath = controllerName;
		}
		else
		{
			texFormat = "." + (string)curControllerData["tex_format"];
			prePath = modelFilePath + controllerName;
		}
		string filepath = prePath + "_idle" + texFormat;
		visual.m_idle = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_app" + texFormat;
		visual.m_app = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_home" + texFormat;
		visual.m_home = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_touch" + texFormat;
		visual.m_touchpad = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_volume_down" + texFormat;
		visual.m_volDn = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_volume_up" + texFormat;
		visual.m_volUp = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_trigger" + texFormat;
		visual.m_trigger = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_a" + texFormat;
		visual.m_a = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_b" + texFormat;
		visual.m_b = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_x" + texFormat;
		visual.m_x = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_y" + texFormat;
		visual.m_y = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_grip" + texFormat;
		visual.m_grip = LoadOneTexture(filepath, fromRes);
	}

	private Texture2D LoadOneTexture(string filepath, bool fromRes)
	{
		if (fromRes)
		{
			return Resources.Load<Texture2D>(filepath);
		}
		int width = (int)curControllerData["tex_width"];
		int height = (int)curControllerData["tex_height"];
		Texture2D texture2D = new Texture2D(width, height);
		texture2D.LoadImage(ReadPNG(filepath));
		return texture2D;
	}

	private byte[] ReadPNG(string path)
	{
		FileStream fileStream = new FileStream(path, FileMode.Open, FileAccess.Read);
		fileStream.Seek(0L, SeekOrigin.Begin);
		byte[] array = new byte[fileStream.Length];
		fileStream.Read(array, 0, (int)fileStream.Length);
		fileStream.Close();
		fileStream.Dispose();
		fileStream = null;
		return array;
	}
}
public class Pvr_ControllerLink
{
	public AndroidJavaClass javaHummingbirdClass;

	public AndroidJavaClass javaPico2ReceiverClass;

	public AndroidJavaClass javaserviceClass;

	public AndroidJavaClass javavractivityclass;

	public AndroidJavaClass javaCVClass;

	public AndroidJavaObject activity;

	public string gameobjname = string.Empty;

	public bool picoDevice;

	public string hummingBirdMac;

	public int hummingBirdRSSI;

	public bool goblinserviceStarted;

	public bool neoserviceStarted;

	public bool controller0Connected;

	public bool controller1Connected;

	public int mainHandID;

	public Pvr_Controller.UserHandNess handness;

	public int controllerType;

	public ControllerHand Controller0;

	public ControllerHand Controller1;

	public int platFormType = -1;

	public int trackingmode = -1;

	public int systemProp = -1;

	public int enablehand6dofbyhead = -1;

	public bool switchHomeKey = true;

	private int iPhoneHMDModeEnabled;

	private float[] hbPoseData = new float[4];

	private float[] sensorData = new float[28];

	private int[] keyData = new int[134];

	private int[] neo3TouchValue = new int[15];

	private float[] fixedState = new float[7] { 0f, 0f, 0f, 1f, 0f, 0f, 0f };

	private float[] neoposeData = new float[7] { 0f, 0f, 0f, 1f, 0f, 0f, 0f };

	private int[] goblinKeyArray = new int[47];

	private int[] neoKeyArray = new int[67];

	private int[] neotriggerV = new int[9];

	private float[] velocity = new float[3];

	private float[] angularVelocity = new float[3];

	private float[] acceData = new float[3];

	public Pvr_ControllerLink(string name)
	{
		gameobjname = name;
		hummingBirdMac = string.Empty;
		hummingBirdRSSI = 0;
		UnityEngine.Debug.Log("PvrLog Controller GameObject:" + gameobjname);
		StartHummingBirdService();
		Controller0 = new ControllerHand();
		Controller0.Position = new Vector3(0f, Pvr_UnitySDKSensor.Instance.HeadPose.Position.y, 0f) + new Vector3(-0.1f, -0.3f, 0.3f);
		Controller1 = new ControllerHand();
		Controller1.Position = new Vector3(0f, Pvr_UnitySDKSensor.Instance.HeadPose.Position.y, 0f) + new Vector3(0.1f, -0.3f, 0.3f);
	}

	private void StartHummingBirdService()
	{
		try
		{
			AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
			activity = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
			javaHummingbirdClass = new AndroidJavaClass("com.picovr.picovrlib.hummingbirdclient.HbClientActivity");
			javaCVClass = new AndroidJavaClass("com.picovr.picovrlib.cvcontrollerclient.ControllerClient");
			javavractivityclass = new AndroidJavaClass("com.psmart.vrlib.VrActivity");
			javaserviceClass = new AndroidJavaClass("com.picovr.picovrlib.hummingbirdclient.UnityClient");
			Pvr_UnitySDKAPI.System.Pvr_SetInitActivity(activity.GetRawObject(), javaHummingbirdClass.GetRawClass());
			int configsenum = 4;
			Render.UPvr_GetIntConfig(configsenum, ref platFormType);
			UnityEngine.Debug.Log("PvrLog platform" + platFormType);
			configsenum = 5;
			Render.UPvr_GetIntConfig(configsenum, ref trackingmode);
			UnityEngine.Debug.Log("PvrLog trackingmode" + trackingmode);
			systemProp = GetSysproc();
			UnityEngine.Debug.Log("PvrLog systemProp" + systemProp);
			configsenum = 7;
			Render.UPvr_GetIntConfig(configsenum, ref enablehand6dofbyhead);
			UnityEngine.Debug.Log("PvrLog enablehand6dofbyhead" + enablehand6dofbyhead);
			if (trackingmode == 0 || trackingmode == 1 || ((trackingmode == 3 || trackingmode == 5 || trackingmode == 6) && (systemProp == 1 || systemProp == 3)))
			{
				picoDevice = platFormType != 0;
				javaPico2ReceiverClass = new AndroidJavaClass("com.picovr.picovrlib.hummingbirdclient.HbClientReceiver");
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "startReceiver", activity, gameobjname);
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "setPlatformType", platFormType);
			}
			else
			{
				picoDevice = true;
				SetGameObjectToJar(gameobjname);
			}
			Render.UPvr_GetIntConfig(16, ref iPhoneHMDModeEnabled);
			if (iPhoneHMDModeEnabled == 1)
			{
				BindService();
			}
			else if (IsServiceExisted())
			{
				BindService();
			}
		}
		catch (AndroidJavaException ex)
		{
			PLOG.E("ConnectToAndriod--catch" + ex.Message);
		}
	}

	public bool IsServiceExisted()
	{
		bool result = false;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaserviceClass, "isServiceExisted", activity, trackingmode);
		UnityEngine.Debug.Log("PvrLog ServiceExisted ?" + result);
		return result;
	}

	public void SetGameObjectToJar(string name)
	{
		UnityEngine.Debug.Log("PvrLog SetGameObjectToJar " + name);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setGameObjectCallback", name);
	}

	public void BindService()
	{
		UnityEngine.Debug.Log("PvrLog Bind Service");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaserviceClass, "bindService", activity, trackingmode);
	}

	public void UnBindService()
	{
		UnityEngine.Debug.Log("PvrLog UnBind Service");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaserviceClass, "unbindService", activity, trackingmode);
	}

	public void StopLark2Receiver()
	{
		UnityEngine.Debug.Log("PvrLog StopLark2Receiver");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "stopReceiver", activity);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "stopOnBootReceiver", activity);
	}

	public void StartLark2Receiver()
	{
		UnityEngine.Debug.Log("PvrLog StartLark2Receiver");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "startReceiver", activity, gameobjname);
	}

	public void StopLark2Service()
	{
		UnityEngine.Debug.Log("PvrLog StopLark2Service");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "stopReceiver", activity);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "unbindHbService", activity);
	}

	public void StartLark2Service()
	{
		UnityEngine.Debug.Log("PvrLog StartLark2Service");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "startReceiver", activity, gameobjname);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "bindHbService", activity);
	}

	public int getHandness()
	{
		int result = -1;
		if (iPhoneHMDModeEnabled == 0)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javavractivityclass, "getPvrHandness", activity);
		}
		else
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getHbHandednessInSP");
		}
		PLOG.I("PvrLog GetHandness =" + result);
		return result;
	}

	public void setHandness(int hand)
	{
		PLOG.I("PvrLog SetHandness =" + hand);
		if (iPhoneHMDModeEnabled == 1)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "setHbHandednessInSP", hand);
		}
	}

	public void StartScan()
	{
		PLOG.I("PvrLog ScanHBController");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "scanHbDevice", true);
	}

	public void StopScan()
	{
		PLOG.I("PvrLog StopScanHBController");
		if (iPhoneHMDModeEnabled == 0)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "scanHbDevice", false);
		}
	}

	public int GetSysproc()
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaserviceClass, "getSysproc");
		PLOG.I("PvrLog GetSysproc" + result);
		return result;
	}

	public void ResetController(int num)
	{
		UnityEngine.Debug.Log("PvrLog ResetController" + num);
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "resetControllerSensorState", num);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "resetHbSensorState");
		}
	}

	public void ConnectBLE()
	{
		UnityEngine.Debug.Log("PvrLog ConnectHBController" + hummingBirdMac);
		if (hummingBirdMac != string.Empty)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "connectHbController", hummingBirdMac);
		}
	}

	public void DisConnectBLE()
	{
		UnityEngine.Debug.Log("PvrLog DisConnectHBController");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "disconnectHbController");
	}

	public bool StartUpgrade()
	{
		UnityEngine.Debug.Log("PvrLog StartUpgradeHBController");
		bool result = false;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "startUpgrade");
		return result;
	}

	public void setBinPath(string path, bool isasset)
	{
		UnityEngine.Debug.Log("PvrLog setBinPath" + path + isasset);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "setBinPath", path, isasset);
	}

	public string GetBLEImageType()
	{
		string result = string.Empty;
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getBLEImageType");
		}
		UnityEngine.Debug.Log("PvrLog GetBLEImageType" + result);
		return result;
	}

	public long GetBLEVersion()
	{
		long result = 0L;
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getBLEVersion");
		}
		UnityEngine.Debug.Log("PvrLog GetBLEVersion" + result);
		return result;
	}

	public string GetFileImageType()
	{
		string result = string.Empty;
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getFileImageType");
		}
		UnityEngine.Debug.Log("PvrLog GetFileImageType" + result);
		return result;
	}

	public long GetFileVersion()
	{
		long result = 0L;
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getFileVersion");
		}
		UnityEngine.Debug.Log("PvrLog GetFileVersion" + result);
		return result;
	}

	public int GetControllerConnectionState(int num)
	{
		int result = -1;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerConnectionState", num);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getHbConnectionState");
		}
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog GetControllerState:" + num + "state:" + result);
		}
		return result;
	}

	public void RebackToLauncher()
	{
		UnityEngine.Debug.Log("PvrLog RebackToLauncher");
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startLauncher");
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "startLauncher");
		}
	}

	public void TurnUpVolume()
	{
		UnityEngine.Debug.Log("PvrLog TurnUpVolume");
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "turnUpVolume", activity);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "turnUpVolume", activity);
		}
	}

	public void TurnDownVolume()
	{
		UnityEngine.Debug.Log("PvrLog TurnDownVolume");
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "turnDownVolume", activity);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "turnDownVolume", activity);
		}
	}

	public float[] GetHBControllerPoseData()
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref hbPoseData, javaHummingbirdClass, "getHBSensorPose");
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog HBControllerData" + hbPoseData[0] + "," + hbPoseData[1] + "," + hbPoseData[2] + "," + hbPoseData[3]);
		}
		return hbPoseData;
	}

	public float[] GetControllerSensorData()
	{
		if (enablehand6dofbyhead == 1)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref sensorData, javaCVClass, "getControllerDataInfoBySharmem", Pvr_UnitySDKManager.SDK.headData);
		}
		else
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref sensorData, javaCVClass, "getControllerDataInfoBySharmem");
		}
		return sensorData;
	}

	public int[] GetControllerKeyData()
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref keyData, javaCVClass, "getDoubleControllerKeyEventUnityExtBySharmem");
		return keyData;
	}

	public int[] GetNeo3TouchData(int hand)
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neo3TouchValue, javaCVClass, "getControllerTouchEvent", hand);
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog Neo3Touch hand:" + hand + "-" + neo3TouchValue[0] + neo3TouchValue[1] + neo3TouchValue[2] + neo3TouchValue[3] + neo3TouchValue[4] + "," + neo3TouchValue[5] + neo3TouchValue[6] + neo3TouchValue[7] + neo3TouchValue[8] + neo3TouchValue[9] + "," + neo3TouchValue[10] + neo3TouchValue[11] + neo3TouchValue[12] + neo3TouchValue[13] + neo3TouchValue[14]);
		}
		return neo3TouchValue;
	}

	public int GetNeo3GripValue(int hand)
	{
		int result = 0;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerGripValue", hand);
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog Neo3GripValue:" + result);
		}
		return result;
	}

	public float[] GetControllerFixedSensorState(int hand)
	{
		if (trackingmode == 2 || trackingmode == 3)
		{
			return fixedState;
		}
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref fixedState, javaCVClass, "getControllerFixedSensorState", hand);
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog GetControllerFixedSensorState " + hand + "Rotation:" + fixedState[0] + "," + fixedState[1] + "," + fixedState[2] + "," + fixedState[3] + "Position:" + fixedState[4] + "," + fixedState[5] + "," + fixedState[6]);
		}
		return fixedState;
	}

	public float[] GetCvControllerPoseData(int hand)
	{
		if (enablehand6dofbyhead == 1)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neoposeData, javaCVClass, "getControllerSensorState", hand, Pvr_UnitySDKManager.SDK.headData);
		}
		else
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neoposeData, javaCVClass, "getControllerSensorState", hand);
		}
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog CVControllerData :" + neoposeData[0] + "," + neoposeData[1] + "," + neoposeData[2] + "," + neoposeData[3] + "," + neoposeData[4] + "," + neoposeData[5] + "," + neoposeData[6]);
		}
		return neoposeData;
	}

	public int[] GetHBControllerKeyData()
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref goblinKeyArray, javaHummingbirdClass, "getHBKeyEventUnityExt");
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog HBControllerKey" + goblinKeyArray[0] + goblinKeyArray[1] + goblinKeyArray[2] + goblinKeyArray[3] + goblinKeyArray[4] + "," + goblinKeyArray[5] + goblinKeyArray[6] + goblinKeyArray[7] + goblinKeyArray[8] + goblinKeyArray[9] + "," + goblinKeyArray[10] + goblinKeyArray[11] + goblinKeyArray[12] + goblinKeyArray[13] + goblinKeyArray[14] + "," + goblinKeyArray[15] + goblinKeyArray[16] + goblinKeyArray[17] + goblinKeyArray[18] + goblinKeyArray[19] + "," + goblinKeyArray[20] + goblinKeyArray[21] + goblinKeyArray[22] + goblinKeyArray[23] + goblinKeyArray[24] + "," + goblinKeyArray[25] + goblinKeyArray[26] + goblinKeyArray[27] + goblinKeyArray[28] + goblinKeyArray[29] + "," + goblinKeyArray[30] + goblinKeyArray[31] + goblinKeyArray[32] + goblinKeyArray[33] + goblinKeyArray[34] + "," + goblinKeyArray[35] + goblinKeyArray[36] + goblinKeyArray[37] + goblinKeyArray[38] + goblinKeyArray[39] + "," + goblinKeyArray[40] + goblinKeyArray[41] + goblinKeyArray[42] + goblinKeyArray[43] + goblinKeyArray[44] + "," + goblinKeyArray[45] + goblinKeyArray[46]);
		}
		return goblinKeyArray;
	}

	public int GetHBKeyValue()
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getTriggerKeyEvent");
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog GoblinControllerTriggerKey:" + result);
		}
		return result;
	}

	public int[] GetCvControllerKeyData(int hand)
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neoKeyArray, javaCVClass, "getControllerKeyEventUnityExt", hand);
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog CVControllerKey hand:" + hand + "-" + neoKeyArray[0] + neoKeyArray[1] + neoKeyArray[2] + neoKeyArray[3] + neoKeyArray[4] + "," + neoKeyArray[5] + neoKeyArray[6] + neoKeyArray[7] + neoKeyArray[8] + neoKeyArray[9] + "," + neoKeyArray[10] + neoKeyArray[11] + neoKeyArray[12] + neoKeyArray[13] + neoKeyArray[14] + "," + neoKeyArray[15] + neoKeyArray[16] + neoKeyArray[17] + neoKeyArray[18] + neoKeyArray[19] + "," + neoKeyArray[20] + neoKeyArray[21] + neoKeyArray[22] + neoKeyArray[23] + neoKeyArray[24] + "," + neoKeyArray[25] + neoKeyArray[26] + neoKeyArray[27] + neoKeyArray[28] + neoKeyArray[29] + "," + neoKeyArray[30] + neoKeyArray[31] + neoKeyArray[32] + neoKeyArray[33] + neoKeyArray[34] + "," + neoKeyArray[35] + neoKeyArray[36] + neoKeyArray[37] + neoKeyArray[38] + neoKeyArray[39] + "," + neoKeyArray[40] + neoKeyArray[41] + neoKeyArray[42] + neoKeyArray[43] + neoKeyArray[44] + "," + neoKeyArray[45] + neoKeyArray[46] + neoKeyArray[47] + neoKeyArray[48] + neoKeyArray[49] + "," + neoKeyArray[50] + neoKeyArray[51] + neoKeyArray[52] + neoKeyArray[53] + neoKeyArray[54] + "," + neoKeyArray[55] + neoKeyArray[56] + neoKeyArray[57] + neoKeyArray[58] + neoKeyArray[59] + "," + neoKeyArray[60] + neoKeyArray[61] + neoKeyArray[62] + neoKeyArray[63] + neoKeyArray[64] + "," + neoKeyArray[65] + neoKeyArray[66]);
		}
		return neoKeyArray;
	}

	public int GetCVTriggerValue(int hand)
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neotriggerV, javaCVClass, "getControllerKeyEvent", hand);
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog CVTriggerValue " + neotriggerV[7]);
		}
		return neotriggerV[7];
	}

	public void AutoConnectHbController(int scanTimeMs)
	{
		PLOG.I("PvrLog AutoConnectHbController" + scanTimeMs);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "autoConnectHbController", scanTimeMs, gameobjname);
	}

	public void StartControllerThread(int headSensorState, int handSensorState)
	{
		if (BoundarySystem.UPvr_IsBoundaryEnable())
		{
			headSensorState = 1;
			handSensorState = 1;
		}
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startControllerThread", headSensorState, handSensorState);
		UnityEngine.Debug.Log("PvrLog StartControllerThread" + headSensorState + handSensorState);
	}

	public void StopControllerThread(int headSensorState, int handSensorState)
	{
		if (BoundarySystem.UPvr_IsBoundaryEnable())
		{
			headSensorState = 1;
			handSensorState = 1;
		}
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "stopControllerThread", headSensorState, handSensorState);
		UnityEngine.Debug.Log("PvrLog StopControllerThread" + headSensorState + handSensorState);
	}

	public void SetUnityVersionToJar(string version)
	{
		if (trackingmode == 4 || trackingmode == 5 || trackingmode == 6)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setUnityVersion", version);
		}
		UnityEngine.Debug.Log("PvrLog SetUnityVersionToJar" + version);
	}

	public Vector3 GetVelocity(int num)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref velocity, javaCVClass, "getControllerLinearVelocity", num);
		}
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog Velocity" + velocity[0] + "," + velocity[1] + "," + velocity[2]);
		}
		return new Vector3(velocity[0], velocity[1], 0f - velocity[2]);
	}

	public Vector3 GetAngularVelocity(int num)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref angularVelocity, javaCVClass, "getControllerAngularVelocity", num);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref angularVelocity, javaHummingbirdClass, "getHbAngularVelocity");
		}
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog Gyro:" + angularVelocity[0] + "," + angularVelocity[1] + "," + angularVelocity[2]);
		}
		return new Vector3(0f, 0f, 0f);
	}

	public Vector3 GetAcceleration(int num)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref acceData, javaCVClass, "getControllerAcceleration", num);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref acceData, javaHummingbirdClass, "getHbAcceleration");
		}
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog Acce:" + acceData[0] + acceData[1] + acceData[2]);
		}
		return new Vector3(0f, 0f, 0f);
	}

	public string GetConnectedDeviceMac()
	{
		string result = string.Empty;
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getConnectedDeviceMac");
		}
		PLOG.I("PvrLog ConnectedDeviceMac:" + result);
		return result;
	}

	public void VibrateNeo2Controller(float strength, int time, int hand)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "vibrateCV2ControllerStrength", strength, time, hand);
		}
		PLOG.I("PvrLog VibrateNeo2Controller:" + strength + time + hand);
	}

	public int GetMainControllerIndex()
	{
		int result = 0;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getMainControllerIndex");
		}
		PLOG.I("PvrLog GetMainControllerIndex:" + result);
		return result;
	}

	public void SetMainController(int index)
	{
		PLOG.I("PvrLog SetMainController:" + index);
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setMainController", index);
		}
	}

	public void ResetHeadSensorForController()
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "resetHeadSensorForController");
		}
		PLOG.I("PvrLog ResetHeadSensorForController:");
	}

	public void GetDeviceVersion(int deviceType)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "getDeviceVersion", deviceType);
		}
		PLOG.I("PvrLog GetDeviceVersion:" + deviceType);
	}

	public void GetControllerSnCode(int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "getControllerSnCode", controllerSerialNum);
		}
		PLOG.I("PvrLog GetControllerSnCode:" + controllerSerialNum);
	}

	public void SetControllerUnbind(int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setControllerUnbind", controllerSerialNum);
		}
		PLOG.I("PvrLog SetControllerUnbind:" + controllerSerialNum);
	}

	public void SetStationRestart()
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setStationRestart");
		}
		PLOG.I("PvrLog SetStationRestart");
	}

	public void StartStationOtaUpdate()
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startStationOtaUpdate");
		}
		PLOG.I("PvrLog StartStationOtaUpdate");
	}

	public void StartControllerOtaUpdate(int mode, int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startControllerOtaUpdate", mode, controllerSerialNum);
		}
		PLOG.I("PvrLog StartControllerOtaUpdate" + mode + controllerSerialNum);
	}

	public void EnterPairMode(int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "enterPairMode", controllerSerialNum);
		}
		PLOG.I("PvrLog EnterPairMode" + controllerSerialNum);
	}

	public void SetControllerShutdown(int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setControllerShutdown", controllerSerialNum);
		}
		PLOG.I("PvrLog SetControllerShutdown" + controllerSerialNum);
	}

	public int GetStationPairState()
	{
		int result = -1;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getStationPairState");
		}
		PLOG.I("PvrLog StationPairState" + result);
		return result;
	}

	public int GetStationOtaUpdateProgress()
	{
		int result = -1;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getStationOtaUpdateProgress");
		}
		PLOG.I("PvrLog StationOtaUpdateProgress" + result);
		return result;
	}

	public int GetControllerOtaUpdateProgress()
	{
		int result = -1;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerOtaUpdateProgress");
		}
		PLOG.I("PvrLog ControllerOtaUpdateProgress" + result);
		return result;
	}

	public void GetControllerVersionAndSN(int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "getControllerVersionAndSN", controllerSerialNum);
		}
		PLOG.I("PvrLog GetControllerVersionAndSN" + controllerSerialNum);
	}

	public void GetControllerUniqueID()
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "getControllerUniqueID");
		}
		PLOG.I("PvrLog GetControllerUniqueID");
	}

	public void InterruptStationPairMode()
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "interruptStationPairMode");
		}
		PLOG.I("PvrLog InterruptStationPairMode");
	}

	public int GetControllerAbility(int controllerSerialNum)
	{
		int result = -1;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerAbility", controllerSerialNum);
		}
		PLOG.I("PvrLog ControllerAbility:" + result);
		return result;
	}

	public void SwitchHomeKey(bool state)
	{
		PLOG.I("PvrLog SwitchHomeKey:" + state);
		switchHomeKey = state;
	}

	public void SetBootReconnect()
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "setBootReconnect");
		PLOG.I("PvrLog SetBootReconnect");
	}

	public int GetTemperature()
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getTemperature");
		PLOG.I("PvrLog Temperature:" + result);
		return result;
	}

	public int GetDeviceType()
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getDeviceType");
		PLOG.I("PvrLog DeviceType:" + result);
		return result;
	}

	public int GetControllerType()
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getControllerType");
		return result;
	}

	public string GetHummingBird2SN()
	{
		string result = string.Empty;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getHummingBird2SN");
		PLOG.I("PvrLog HummingBird2SN:" + result);
		return result;
	}

	public string GetControllerVersion()
	{
		string result = string.Empty;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getControllerVersion");
		PLOG.I("PvrLog ControllerVersion:" + result);
		return result;
	}

	public bool IsEnbleTrigger()
	{
		bool result = false;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "isEnbleTrigger");
		PLOG.I("PvrLog IsEnbleTrigger:" + result);
		return result;
	}

	public void StartCV2PairingMode(int devicetype)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startCV2PairingMode", devicetype);
		}
		PLOG.I("PvrLog StartCV2PairingMode:" + devicetype);
	}

	public void StopCV2PairingMode(int devicetype)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "stopCV2PairingMode", devicetype);
		}
		PLOG.I("PvrLog StopCV2PairingMode:" + devicetype);
	}

	public int GetControllerBindingState(int id)
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerBindingState", id);
		PLOG.I("PvrLog getControllerBindingState:" + result);
		return result;
	}

	public void setIsEnbleHomeKey(bool state)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setIsEnbleHomeKey", state);
		}
		PLOG.I("PvrLog setIsEnbleHomeKey:" + state);
	}

	public int getControllerSensorStatus(int id)
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerSensorStatus", id);
		PLOG.I("PvrLog getControllerSensorStatus:" + result);
		return result;
	}
}
public class Pvr_ControllerManager : MonoBehaviour
{
	public delegate void PvrServiceStartSuccess();

	public delegate void PvrControllerStateChanged(string data);

	public delegate void ChangeMainControllerCallBack(string index);

	public delegate void ChangeHandNessCallBack(string index);

	public delegate void SetHbServiceBindState();

	public delegate void ControllerThreadStartedCallback();

	public delegate void SetControllerServiceBindState();

	public delegate void ControllerStatusChange(string isconnect);

	public delegate void SetControllerAbility(string data);

	public delegate void SetControllerStateChanged(string data);

	public delegate void SetHbControllerMac(string mac);

	public delegate void ControllerDeviceVersionCallback(string data);

	public delegate void ControllerSnCodeCallback(string data);

	public delegate void ControllerUnbindCallback(string status);

	public delegate void ControllerStationStatusCallback(string status);

	public delegate void ControllerStationBusyCallback(string status);

	public delegate void ControllerOtaStartCodeCallback(string data);

	public delegate void ControllerDeviceVersionAndSNCallback(string data);

	public delegate void ControllerUniqueIDCallback(string data);

	public delegate void ControllerCombinedKeyUnbindCallback(string data);

	private static Pvr_ControllerManager instance;

	public static Pvr_ControllerLink controllerlink;

	private float cTime = 1f;

	private bool stopConnect;

	public Text toast;

	private bool controllerServicestate;

	private float disConnectTime;

	public bool LengthAdaptiveRay;

	private float[] sensorData = new float[28];

	private int[] keyData = new int[134];

	private float[] g2SensorData = new float[4];

	private int[] g2KeyData = new int[47];

	private int keyOffset;

	private int rotControllerMode = 1;

	public static Pvr_ControllerManager Instance
	{
		get
		{
			if (instance == null)
			{
				instance = UnityEngine.Object.FindObjectOfType<Pvr_ControllerManager>();
			}
			if (instance == null)
			{
				GameObject gameObject = new GameObject("GameObject");
				instance = gameObject.AddComponent<Pvr_ControllerManager>();
				gameObject.transform.localPosition = Vector3.zero;
			}
			return instance;
		}
	}

	public static event PvrServiceStartSuccess PvrServiceStartSuccessEvent;

	public static event PvrControllerStateChanged PvrControllerStateChangedEvent;

	public static event ChangeMainControllerCallBack ChangeMainControllerCallBackEvent;

	public static event ChangeHandNessCallBack ChangeHandNessCallBackEvent;

	public static event SetHbServiceBindState SetHbServiceBindStateEvent;

	public static event ControllerThreadStartedCallback ControllerThreadStartedCallbackEvent;

	public static event SetControllerServiceBindState SetControllerServiceBindStateEvent;

	public static event ControllerStatusChange ControllerStatusChangeEvent;

	public static event SetControllerAbility SetControllerAbilityEvent;

	public static event SetControllerStateChanged SetControllerStateChangedEvent;

	public static event SetHbControllerMac SetHbControllerMacEvent;

	public static event ControllerDeviceVersionCallback ControllerDeviceVersionCallbackEvent;

	public static event ControllerSnCodeCallback ControllerSnCodeCallbackEvent;

	public static event ControllerUnbindCallback ControllerUnbindCallbackEvent;

	public static event ControllerStationStatusCallback ControllerStationStatusCallbackEvent;

	public static event ControllerStationBusyCallback ControllerStationBusyCallbackEvent;

	public static event ControllerOtaStartCodeCallback ControllerOtaStartCodeCallbackEvent;

	public static event ControllerDeviceVersionAndSNCallback ControllerDeviceVersionAndSNCallbackEvent;

	public static event ControllerUniqueIDCallback ControllerUniqueIDCallbackEvent;

	public static event ControllerCombinedKeyUnbindCallback ControllerCombinedKeyUnbindCallbackEvent;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
		if (instance != this)
		{
			PLOG.E("instance object should be a singleton.");
			return;
		}
		if (controllerlink == null)
		{
			controllerlink = new Pvr_ControllerLink(base.gameObject.name);
			return;
		}
		controllerlink.SetGameObjectToJar(base.gameObject.name);
		BindService();
	}

	private void Start()
	{
		if (controllerlink.trackingmode < 2)
		{
			Invoke("CheckControllerService", 10f);
		}
		Render.UPvr_GetIntConfig(23, ref rotControllerMode);
	}

	private void Update()
	{
		if (controllerlink.neoserviceStarted)
		{
			sensorData = controllerlink.GetControllerSensorData();
			keyData = controllerlink.GetControllerKeyData();
			if (controllerlink.controller0Connected)
			{
				if (Pvr_UnitySDKManager.SDK.ShowVideoSeethrough)
				{
					sensorData[2] = 0f - sensorData[2];
					sensorData[3] = 0f - sensorData[3];
					controllerlink.Controller0.Rotation.Set(sensorData[0], sensorData[1], sensorData[2], sensorData[3]);
					if (rotControllerMode == 0)
					{
						controllerlink.Controller0.Rotation *= Quaternion.Euler(34f, 0f, 0f);
					}
					controllerlink.Controller0.Position.Set(sensorData[4] / 1000f, sensorData[5] / 1000f, (0f - sensorData[6]) / 1000f);
				}
				else
				{
					controllerlink.Controller0.Rotation.Set(sensorData[7], sensorData[8], sensorData[9], sensorData[10]);
					if (rotControllerMode == 0)
					{
						controllerlink.Controller0.Rotation *= Quaternion.Euler(34f, 0f, 0f);
					}
					controllerlink.Controller0.Position.Set(sensorData[11] / 1000f, sensorData[12] / 1000f, (0f - sensorData[13]) / 1000f);
				}
				if (!controllerlink.Controller0.isShowBoundary)
				{
					if (controllerlink.getControllerSensorStatus(0) == 0)
					{
						Sensor.UPvr_SetReinPosition(sensorData[0], sensorData[1], sensorData[2], sensorData[3], sensorData[4], sensorData[5], sensorData[6], 0, valid: false, 0);
					}
					else
					{
						controllerlink.Controller0.isShowBoundary = true;
						Sensor.UPvr_SetReinPosition(sensorData[0], sensorData[1], sensorData[2], sensorData[3], sensorData[4], sensorData[5], sensorData[6], 0, valid: true, Convert.ToInt32(Convert.ToString(keyData[35]) + Convert.ToString(keyData[15]) + "00", 2));
					}
				}
				else
				{
					Sensor.UPvr_SetReinPosition(sensorData[0], sensorData[1], sensorData[2], sensorData[3], sensorData[4], sensorData[5], sensorData[6], 0, valid: true, Convert.ToInt32(Convert.ToString(keyData[35]) + Convert.ToString(keyData[15]) + "00", 2));
				}
				TransformData(controllerlink.Controller0, 0, keyData);
			}
			else
			{
				Sensor.UPvr_SetReinPosition(sensorData[0], sensorData[1], sensorData[2], sensorData[3], sensorData[4], sensorData[5], sensorData[6], 0, valid: false, 0);
			}
			if (controllerlink.controller1Connected)
			{
				if (Pvr_UnitySDKManager.SDK.ShowVideoSeethrough)
				{
					sensorData[16] = 0f - sensorData[16];
					sensorData[17] = 0f - sensorData[17];
					controllerlink.Controller1.Rotation.Set(sensorData[14], sensorData[15], sensorData[16], sensorData[17]);
					if (rotControllerMode == 0)
					{
						controllerlink.Controller1.Rotation *= Quaternion.Euler(34f, 0f, 0f);
					}
					controllerlink.Controller1.Position.Set(sensorData[18] / 1000f, sensorData[19] / 1000f, (0f - sensorData[20]) / 1000f);
				}
				else
				{
					controllerlink.Controller1.Rotation.Set(sensorData[21], sensorData[22], sensorData[23], sensorData[24]);
					if (rotControllerMode == 0)
					{
						controllerlink.Controller1.Rotation *= Quaternion.Euler(34f, 0f, 0f);
					}
					controllerlink.Controller1.Position.Set(sensorData[25] / 1000f, sensorData[26] / 1000f, (0f - sensorData[27]) / 1000f);
				}
				if (!controllerlink.Controller1.isShowBoundary)
				{
					if (controllerlink.getControllerSensorStatus(1) == 0)
					{
						Sensor.UPvr_SetReinPosition(sensorData[14], sensorData[15], sensorData[16], sensorData[17], sensorData[18], sensorData[19], sensorData[20], 1, valid: false, 0);
					}
					else
					{
						controllerlink.Controller1.isShowBoundary = true;
						Sensor.UPvr_SetReinPosition(sensorData[14], sensorData[15], sensorData[16], sensorData[17], sensorData[18], sensorData[19], sensorData[20], 1, valid: true, Convert.ToInt32(Convert.ToString(keyData[102]) + Convert.ToString(keyData[82]) + "00", 2));
					}
				}
				else
				{
					Sensor.UPvr_SetReinPosition(sensorData[14], sensorData[15], sensorData[16], sensorData[17], sensorData[18], sensorData[19], sensorData[20], 1, valid: true, Convert.ToInt32(Convert.ToString(keyData[102]) + Convert.ToString(keyData[82]) + "00", 2));
				}
				TransformData(controllerlink.Controller1, 1, keyData);
			}
			else
			{
				Sensor.UPvr_SetReinPosition(sensorData[14], sensorData[15], sensorData[16], sensorData[17], sensorData[18], sensorData[19], sensorData[20], 1, valid: false, 0);
			}
		}
		if (controllerlink.goblinserviceStarted && controllerlink.controller0Connected)
		{
			g2SensorData = controllerlink.GetHBControllerPoseData();
			controllerlink.Controller0.Rotation.Set(g2SensorData[0], g2SensorData[1], g2SensorData[2], g2SensorData[3]);
			g2KeyData = controllerlink.GetHBControllerKeyData();
			TransformData(controllerlink.Controller0, 0, g2KeyData);
		}
		SetSystemKey();
	}

	private void OnApplicationPause(bool pause)
	{
		int headSensorState = ((!Pvr_UnitySDKManager.SDK.HmdOnlyrot) ? 1 : 0);
		int handSensorState = ((!Pvr_UnitySDKManager.SDK.ControllerOnlyrot) ? 1 : 0);
		if (pause)
		{
			if (controllerlink.neoserviceStarted)
			{
				controllerlink.SetGameObjectToJar(string.Empty);
				controllerlink.StopControllerThread(headSensorState, handSensorState);
			}
			if (controllerlink.goblinserviceStarted)
			{
				controllerlink.StopLark2Receiver();
			}
			return;
		}
		controllerlink.Controller0 = new ControllerHand();
		controllerlink.Controller1 = new ControllerHand();
		if (controllerlink.neoserviceStarted)
		{
			controllerlink.SetGameObjectToJar(base.gameObject.name);
			controllerlink.SetUnityVersionToJar("2.8.9.12");
			controllerlink.StartControllerThread(headSensorState, handSensorState);
		}
		if (controllerlink.goblinserviceStarted)
		{
			controllerlink.StartLark2Receiver();
			controllerlink.controller0Connected = GetControllerConnectionState(0) == 1;
			controllerlink.controllerType = controllerlink.GetControllerType();
			controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
			if (Pvr_ControllerManager.PvrServiceStartSuccessEvent != null)
			{
				Pvr_ControllerManager.PvrServiceStartSuccessEvent();
			}
		}
	}

	private void OnDestroy()
	{
		controllerlink.UnBindService();
		Sensor.UPvr_SetReinPosition(0f, 0f, 0f, 1f, 0f, 0f, 0f, 0, valid: false, 0);
		Sensor.UPvr_SetReinPosition(0f, 0f, 0f, 1f, 0f, 0f, 0f, 1, valid: false, 0);
	}

	private void OnApplicationQuit()
	{
		int headSensorState = ((!Pvr_UnitySDKManager.SDK.HmdOnlyrot) ? 1 : 0);
		int handSensorState = ((!Pvr_UnitySDKManager.SDK.ControllerOnlyrot) ? 1 : 0);
		if (controllerlink.neoserviceStarted)
		{
			controllerlink.SetGameObjectToJar(string.Empty);
			controllerlink.StopControllerThread(headSensorState, handSensorState);
		}
	}

	public void StopLark2Service()
	{
		if (controllerlink != null)
		{
			controllerlink.StopLark2Service();
		}
	}

	public Vector3 GetAngularVelocity(int num)
	{
		if (controllerlink != null)
		{
			return controllerlink.GetAngularVelocity(num);
		}
		return new Vector3(0f, 0f, 0f);
	}

	public Vector3 GetAcceleration(int num)
	{
		if (controllerlink != null)
		{
			return controllerlink.GetAcceleration(num);
		}
		return new Vector3(0f, 0f, 0f);
	}

	public void BindService()
	{
		if (controllerlink != null)
		{
			controllerlink.BindService();
		}
	}

	public void StartScan()
	{
		if (controllerlink != null)
		{
			controllerlink.StartScan();
		}
	}

	public void StopScan()
	{
		if (controllerlink != null)
		{
			controllerlink.StopScan();
		}
	}

	public void ResetController(int num)
	{
		if (controllerlink != null)
		{
			controllerlink.ResetController(num);
		}
	}

	public static int GetControllerConnectionState(int num)
	{
		return controllerlink.GetControllerConnectionState(num);
	}

	public void ConnectBLE()
	{
		if (controllerlink != null)
		{
			controllerlink.ConnectBLE();
		}
	}

	public void DisConnectBLE()
	{
		if (controllerlink != null)
		{
			controllerlink.DisConnectBLE();
		}
	}

	public void SetBinPath(string path, bool isAsset)
	{
		if (controllerlink != null)
		{
			controllerlink.setBinPath(path, isAsset);
		}
	}

	public void StartUpgrade()
	{
		if (controllerlink != null)
		{
			controllerlink.StartUpgrade();
		}
	}

	public static string GetBLEImageType()
	{
		return controllerlink.GetBLEImageType();
	}

	public static long GetBLEVersion()
	{
		return controllerlink.GetBLEVersion();
	}

	public static string GetFileImageType()
	{
		return controllerlink.GetFileImageType();
	}

	public static long GetFileVersion()
	{
		return controllerlink.GetFileVersion();
	}

	public static void AutoConnectHbController(int scans)
	{
		if (controllerlink != null)
		{
			controllerlink.AutoConnectHbController(scans);
		}
	}

	public static string GetConnectedDeviceMac()
	{
		string result = string.Empty;
		if (controllerlink != null)
		{
			result = controllerlink.GetConnectedDeviceMac();
		}
		return result;
	}

	public void setHbControllerMac(string mac)
	{
		PLOG.I("PvrLog HBMacRSSI" + mac);
		controllerlink.hummingBirdMac = mac.Substring(0, 17);
		controllerlink.hummingBirdRSSI = Convert.ToInt16(mac.Remove(0, 18));
		if (Pvr_ControllerManager.SetHbControllerMacEvent != null)
		{
			Pvr_ControllerManager.SetHbControllerMacEvent(mac.Substring(0, 17));
		}
	}

	public int GetControllerRSSI()
	{
		return controllerlink.hummingBirdRSSI;
	}

	public void setHbServiceBindState(string state)
	{
		PLOG.I("PvrLog HBBindCallBack" + state);
		controllerServicestate = true;
		if (Convert.ToInt16(state) == 0)
		{
			Invoke("BindService", 0.5f);
			controllerlink.goblinserviceStarted = false;
		}
		else if (Convert.ToInt16(state) == 1)
		{
			controllerlink.goblinserviceStarted = true;
			controllerlink.controller0Connected = GetControllerConnectionState(0) == 1;
			controllerlink.controllerType = controllerlink.GetControllerType();
			controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
			if (Pvr_ControllerManager.SetHbServiceBindStateEvent != null)
			{
				Pvr_ControllerManager.SetHbServiceBindStateEvent();
			}
			if (Pvr_ControllerManager.PvrServiceStartSuccessEvent != null)
			{
				Pvr_ControllerManager.PvrServiceStartSuccessEvent();
			}
		}
	}

	public void setControllerServiceBindState(string state)
	{
		PLOG.I("PvrLog CVBindCallBack" + state);
		if (Convert.ToInt16(state) == 0)
		{
			Invoke("BindService", 0.5f);
			controllerlink.neoserviceStarted = false;
		}
		else if (Convert.ToInt16(state) == 1)
		{
			controllerlink.SetUnityVersionToJar("2.8.9.12");
			controllerlink.neoserviceStarted = true;
			int headSensorState = ((!Pvr_UnitySDKManager.SDK.HmdOnlyrot) ? 1 : 0);
			int handSensorState = ((!Pvr_UnitySDKManager.SDK.ControllerOnlyrot) ? 1 : 0);
			controllerlink.StartControllerThread(headSensorState, handSensorState);
			if (Pvr_ControllerManager.SetControllerServiceBindStateEvent != null)
			{
				Pvr_ControllerManager.SetControllerServiceBindStateEvent();
			}
		}
	}

	public void setHbControllerConnectState(string isconnect)
	{
		PLOG.I("PvrLog HBControllerConnect" + isconnect);
		controllerlink.controller0Connected = Convert.ToInt16(isconnect) == 1;
		if (!controllerlink.controller0Connected)
		{
			controllerlink.Controller0 = new ControllerHand();
		}
		else
		{
			ResetController(0);
			controllerlink.controllerType = controllerlink.GetControllerType();
			controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
		}
		stopConnect = false;
		if (Pvr_ControllerManager.ControllerStatusChangeEvent != null)
		{
			Pvr_ControllerManager.ControllerStatusChangeEvent(isconnect);
		}
		if (Pvr_ControllerManager.PvrControllerStateChangedEvent != null)
		{
			Pvr_ControllerManager.PvrControllerStateChangedEvent(isconnect);
		}
	}

	public void setControllerStateChanged(string state)
	{
		PLOG.I("PvrLog CVControllerStateChanged" + state);
		int num = Convert.ToInt16(state.Substring(0, 1));
		if (num == 0)
		{
			controllerlink.controller0Connected = Convert.ToBoolean(Convert.ToInt16(state.Substring(2, 1)));
			if (!controllerlink.controller0Connected)
			{
				controllerlink.Controller0 = new ControllerHand();
				controllerlink.Controller0.Position = new Vector3(0f, Pvr_UnitySDKSensor.Instance.HeadPose.Position.y, 0f) + new Vector3(-0.1f, -0.3f, 0.3f);
			}
		}
		else
		{
			controllerlink.controller1Connected = Convert.ToBoolean(Convert.ToInt16(state.Substring(2, 1)));
			if (!controllerlink.controller1Connected)
			{
				controllerlink.Controller1 = new ControllerHand();
				controllerlink.Controller1.Position = new Vector3(0f, Pvr_UnitySDKSensor.Instance.HeadPose.Position.y, 0f) + new Vector3(0.1f, -0.3f, 0.3f);
			}
		}
		if (Convert.ToBoolean(Convert.ToInt16(state.Substring(2, 1))))
		{
			controllerlink.controllerType = controllerlink.GetControllerType();
			controllerlink.ResetController(num);
		}
		controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
		controllerlink.mainHandID = controllerlink.GetMainControllerIndex();
		if (Pvr_ControllerManager.SetControllerStateChangedEvent != null)
		{
			Pvr_ControllerManager.SetControllerStateChangedEvent(state);
		}
		if (Pvr_ControllerManager.PvrControllerStateChangedEvent != null)
		{
			Pvr_ControllerManager.PvrControllerStateChangedEvent(state);
		}
	}

	public void setControllerAbility(string data)
	{
		PLOG.I("PvrLog setControllerAbility" + data);
		if (Pvr_ControllerManager.SetControllerAbilityEvent != null)
		{
			Pvr_ControllerManager.SetControllerAbilityEvent(data);
		}
	}

	public void controllerThreadStartedCallback()
	{
		PLOG.I("PvrLog ThreadStartSuccess");
		GetCVControllerState();
		if (Pvr_ControllerManager.ControllerThreadStartedCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerThreadStartedCallbackEvent();
		}
		if (Pvr_ControllerManager.PvrServiceStartSuccessEvent != null)
		{
			Pvr_ControllerManager.PvrServiceStartSuccessEvent();
		}
	}

	public void controllerDeviceVersionCallback(string data)
	{
		PLOG.I("PvrLog VersionCallBack" + data);
		if (Pvr_ControllerManager.ControllerDeviceVersionCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerDeviceVersionCallbackEvent(data);
		}
	}

	public void controllerSnCodeCallback(string data)
	{
		PLOG.I("PvrLog SNCodeCallBack" + data);
		if (Pvr_ControllerManager.ControllerSnCodeCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerSnCodeCallbackEvent(data);
		}
	}

	public void controllerUnbindCallback(string status)
	{
		PLOG.I("PvrLog ControllerUnBindCallBack" + status);
		if (Pvr_ControllerManager.ControllerUnbindCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerUnbindCallbackEvent(status);
		}
	}

	public void controllerStationStatusCallback(string status)
	{
		PLOG.I("PvrLog StationStatusCallBack" + status);
		if (Pvr_ControllerManager.ControllerStationStatusCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerStationStatusCallbackEvent(status);
		}
	}

	public void controllerStationBusyCallback(string status)
	{
		PLOG.I("PvrLog StationBusyCallBack" + status);
		if (Pvr_ControllerManager.ControllerStationBusyCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerStationBusyCallbackEvent(status);
		}
	}

	public void controllerOTAStartCodeCallback(string data)
	{
		PLOG.I("PvrLog OTAUpdateCallBack" + data);
		if (Pvr_ControllerManager.ControllerOtaStartCodeCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerOtaStartCodeCallbackEvent(data);
		}
	}

	public void controllerDeviceVersionAndSNCallback(string data)
	{
		PLOG.I("PvrLog DeviceVersionAndSNCallback" + data);
		if (Pvr_ControllerManager.ControllerDeviceVersionAndSNCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerDeviceVersionAndSNCallbackEvent(data);
		}
	}

	public void controllerUniqueIDCallback(string data)
	{
		PLOG.I("PvrLog controllerUniqueIDCallback" + data);
		if (Pvr_ControllerManager.ControllerUniqueIDCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerUniqueIDCallbackEvent(data);
		}
	}

	public void controllerCombinedKeyUnbindCallback(string controllerSerialNum)
	{
		if (Pvr_ControllerManager.ControllerCombinedKeyUnbindCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerCombinedKeyUnbindCallbackEvent(controllerSerialNum);
		}
	}

	public void setupdateFailed()
	{
	}

	public void setupdateSuccess()
	{
	}

	public void setupdateProgress(string progress)
	{
	}

	public void setHbAutoConnectState(string state)
	{
		PLOG.I("PvrLog HBAutoConnectState" + state);
		controllerServicestate = true;
		if (Convert.ToInt16(state) == 0 && GetControllerConnectionState(0) == 0)
		{
			ShowToast(2);
		}
		if (Convert.ToInt16(state) == 2)
		{
			ShowToast(3);
		}
	}

	public void callbackControllerServiceState(string state)
	{
		PLOG.I("PvrLog HBServiceState" + state);
		controllerServicestate = true;
		if (Convert.ToInt16(state) == 0)
		{
			ShowToast(0);
		}
		if (Convert.ToInt16(state) == 1)
		{
			BindService();
		}
		if (Convert.ToInt16(state) == 2)
		{
			ShowToast(1);
		}
	}

	public void changeMainControllerCallback(string index)
	{
		PLOG.I("PvrLog MainControllerCallBack" + index);
		controllerlink.mainHandID = Convert.ToInt16(index);
		if (Pvr_ControllerManager.ChangeMainControllerCallBackEvent != null)
		{
			Pvr_ControllerManager.ChangeMainControllerCallBackEvent(index);
		}
	}

	public void changeHandnessCallback(string index)
	{
		PLOG.I("PvrLog changeHandnessCallback" + index);
		controllerlink.handness = (Pvr_Controller.UserHandNess)Convert.ToInt16(index);
		if (Pvr_ControllerManager.ChangeHandNessCallBackEvent != null)
		{
			Pvr_ControllerManager.ChangeHandNessCallBackEvent(index);
		}
	}

	private void ShowToast(int type)
	{
		if (toast != null)
		{
			switch (type)
			{
			case 0:
				toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip0");
				Invoke("HideToast", 5f);
				break;
			case 1:
				toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip1");
				Invoke("HideToast", 5f);
				break;
			case 2:
				toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip2");
				AutoConnectHbController(6000);
				Invoke("HideToast", 5f);
				break;
			case 3:
				toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip3");
				AutoConnectHbController(6000);
				Invoke("HideToast", 5f);
				break;
			case 4:
				toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip4");
				Invoke("HideToast", 10f);
				break;
			}
		}
	}

	private void HideToast()
	{
		if (toast != null)
		{
			toast.text = string.Empty;
		}
	}

	private void CheckControllerService()
	{
		if (!controllerServicestate)
		{
			ShowToast(4);
		}
	}

	private void GetCVControllerState()
	{
		int controllerConnectionState = GetControllerConnectionState(0);
		int controllerConnectionState2 = GetControllerConnectionState(1);
		PLOG.I("PvrLog CVconnect" + controllerConnectionState + controllerConnectionState2);
		if (controllerConnectionState == -1 && controllerConnectionState2 == -1)
		{
			Invoke("GetCVControllerState", 0.02f);
		}
		if (controllerConnectionState != -1 && controllerConnectionState2 != -1)
		{
			controllerlink.controller0Connected = controllerConnectionState == 1;
			controllerlink.controller1Connected = controllerConnectionState2 == 1;
			if (!controllerlink.controller0Connected && controllerlink.controller1Connected && controllerlink.GetMainControllerIndex() == 0)
			{
				Controller.UPvr_SetMainHandNess(1);
			}
			if (controllerlink.controller0Connected || controllerlink.controller1Connected)
			{
				controllerlink.controllerType = controllerlink.GetControllerType();
			}
			controllerlink.mainHandID = controllerlink.GetMainControllerIndex();
			controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
		}
	}

	private void SetSystemKey()
	{
		if (controllerlink.switchHomeKey && (Controller.UPvr_GetKeyLongPressed(0, Pvr_KeyCode.HOME) || Controller.UPvr_GetKeyLongPressed(1, Pvr_KeyCode.HOME)))
		{
			if (Pvr_UnitySDKManager.SDK.HmdOnlyrot)
			{
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 0);
			}
			else if (controllerlink.trackingmode == 0 || controllerlink.trackingmode == 1)
			{
				Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
			}
			else
			{
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
			}
			if (Pvr_UnitySDKManager.SDK.ControllerOnlyrot || (controllerlink.controller0Connected && Controller.UPvr_GetControllerPOS(0).Equals(Vector3.zero)) || (controllerlink.controller1Connected && Controller.UPvr_GetControllerPOS(1).Equals(Vector3.zero)))
			{
				if (Controller.UPvr_GetKeyLongPressed(0, Pvr_KeyCode.HOME))
				{
					ResetController(0);
				}
				if (Controller.UPvr_GetKeyLongPressed(1, Pvr_KeyCode.HOME))
				{
					ResetController(1);
				}
			}
		}
		if (controllerlink.picoDevice)
		{
			if (controllerlink.switchHomeKey && (Controller.UPvr_GetKeyClick(0, Pvr_KeyCode.HOME) || (Controller.UPvr_GetKeyClick(1, Pvr_KeyCode.HOME) && !stopConnect)))
			{
				controllerlink.RebackToLauncher();
			}
			if (Controller.UPvr_GetKeyClick(0, Pvr_KeyCode.VOLUMEUP) || Controller.UPvr_GetKeyClick(1, Pvr_KeyCode.VOLUMEUP))
			{
				controllerlink.TurnUpVolume();
			}
			if (Controller.UPvr_GetKeyClick(0, Pvr_KeyCode.VOLUMEDOWN) || Controller.UPvr_GetKeyClick(1, Pvr_KeyCode.VOLUMEDOWN))
			{
				controllerlink.TurnDownVolume();
			}
			if (!Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEUP) && !Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEDOWN) && !Controller.UPvr_GetKey(1, Pvr_KeyCode.VOLUMEUP) && !Controller.UPvr_GetKey(1, Pvr_KeyCode.VOLUMEDOWN))
			{
				cTime = 1f;
			}
			if (Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEUP) || Controller.UPvr_GetKey(1, Pvr_KeyCode.VOLUMEUP))
			{
				cTime -= Time.deltaTime;
				if (cTime <= 0f)
				{
					cTime = 0.2f;
					controllerlink.TurnUpVolume();
				}
			}
			if (!Controller.UPvr_GetKey(0, Pvr_KeyCode.HOME) && !Controller.UPvr_GetKey(1, Pvr_KeyCode.HOME) && (Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEDOWN) || Controller.UPvr_GetKey(1, Pvr_KeyCode.VOLUMEDOWN)))
			{
				cTime -= Time.deltaTime;
				if (cTime <= 0f)
				{
					cTime = 0.2f;
					controllerlink.TurnDownVolume();
				}
			}
		}
		if (controllerlink.goblinserviceStarted && Controller.UPvr_GetKey(0, Pvr_KeyCode.HOME) && Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEDOWN) && !stopConnect)
		{
			disConnectTime += Time.deltaTime;
			if ((double)disConnectTime > 1.0)
			{
				DisConnectBLE();
				controllerlink.hummingBirdMac = string.Empty;
				stopConnect = true;
				disConnectTime = 0f;
			}
		}
	}

	private void TransformData(ControllerHand hand, int handId, int[] data)
	{
		keyOffset = ((handId == 1) ? 67 : 0);
		hand.TouchPadPosition.x = data[keyOffset];
		hand.TouchPadPosition.y = data[5 + keyOffset];
		TransSingleKey(hand.Home, 10 + keyOffset, data);
		TransSingleKey(hand.App, 15 + keyOffset, data);
		TransSingleKey(hand.Touch, 20 + keyOffset, data);
		TransSingleKey(hand.VolumeUp, 25 + keyOffset, data);
		TransSingleKey(hand.VolumeDown, 30 + keyOffset, data);
		TransSingleKey(hand.Trigger, 35 + keyOffset, data);
		if (controllerlink.goblinserviceStarted && !controllerlink.neoserviceStarted)
		{
			hand.TriggerNum = controllerlink.GetHBKeyValue();
		}
		if (!controllerlink.goblinserviceStarted && controllerlink.neoserviceStarted)
		{
			hand.TriggerNum = controllerlink.GetCVTriggerValue(handId);
		}
		hand.Battery = data[40 + keyOffset];
		if (data.Length == 47)
		{
			hand.SwipeDirection = (SwipeDirection)data[45];
			hand.TouchPadClick = (TouchPadClick)data[46];
		}
		else
		{
			switch (handId)
			{
			case 0:
				TransSingleKey(hand.X, 45 + keyOffset, data);
				TransSingleKey(hand.Y, 50 + keyOffset, data);
				TransSingleKey(hand.Left, 60 + keyOffset, data);
				break;
			case 1:
				TransSingleKey(hand.A, 45 + keyOffset, data);
				TransSingleKey(hand.B, 50 + keyOffset, data);
				TransSingleKey(hand.Right, 55 + keyOffset, data);
				break;
			}
			hand.SwipeDirection = (SwipeDirection)data[65 + keyOffset];
			hand.TouchPadClick = (TouchPadClick)data[66 + keyOffset];
		}
		hand.GripValue = controllerlink.GetNeo3GripValue(handId);
		TransformTouchData(hand, handId, controllerlink.GetNeo3TouchData(handId));
	}

	private void TransSingleKey(PvrControllerKey key, int beginIndex, int[] data)
	{
		key.State = Convert.ToBoolean(data[beginIndex]);
		key.PressedDown = Convert.ToBoolean(data[beginIndex + 1]);
		key.PressedUp = Convert.ToBoolean(data[beginIndex + 2]);
		key.LongPressed = Convert.ToBoolean(data[beginIndex + 3]);
		key.Click = Convert.ToBoolean(data[beginIndex + 4]);
	}

	private void TransformTouchData(ControllerHand hand, int handId, int[] data)
	{
		switch (handId)
		{
		case 0:
			TransSingleTouchValue(hand.X, 0, data);
			TransSingleTouchValue(hand.Y, 3, data);
			break;
		case 1:
			TransSingleTouchValue(hand.A, 0, data);
			TransSingleTouchValue(hand.B, 3, data);
			break;
		}
		TransSingleTouchValue(hand.Touch, 6, data);
		TransSingleTouchValue(hand.Trigger, 9, data);
		TransSingleTouchValue(hand.Thumbrest, 12, data);
	}

	private void TransSingleTouchValue(PvrControllerKey key, int beginIndex, int[] data)
	{
		key.Touch = Convert.ToBoolean(data[beginIndex]);
		key.TouchDown = Convert.ToBoolean(data[beginIndex + 1]);
		key.TouchUp = Convert.ToBoolean(data[beginIndex + 2]);
	}
}
namespace Pvr_UnitySDKAPI
{
	public enum ControllerVariety
	{
		Controller0,
		Controller1
	}
}
public class Pvr_ControllerModuleInit : MonoBehaviour
{
	public ControllerVariety Variety;

	public bool IsCustomModel;

	[SerializeField]
	private GameObject dot;

	[SerializeField]
	private GameObject rayLine;

	[SerializeField]
	private GameObject controller;

	private bool moduleState = true;

	private void Awake()
	{
		Pvr_ControllerManager.PvrServiceStartSuccessEvent += ServiceStartSuccess;
		Pvr_ControllerManager.PvrControllerStateChangedEvent += ControllerStateChanged;
		Pvr_ControllerManager.ChangeMainControllerCallBackEvent += MainControllerIDChanged;
		if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
		{
			rayLine = base.transform.GetComponentInChildren<LineRenderer>(includeInactive: true).gameObject;
			rayLine.GetComponent<LineRenderer>().startWidth = 0.003f;
			rayLine.GetComponent<LineRenderer>().endWidth = 0.0015f;
		}
	}

	private void OnDestroy()
	{
		Pvr_ControllerManager.PvrServiceStartSuccessEvent -= ServiceStartSuccess;
		Pvr_ControllerManager.PvrControllerStateChangedEvent -= ControllerStateChanged;
		Pvr_ControllerManager.ChangeMainControllerCallBackEvent -= MainControllerIDChanged;
	}

	private void ServiceStartSuccess()
	{
		RefreshRay();
	}

	private void ControllerStateChanged(string data)
	{
		if (Pvr_ControllerManager.controllerlink.controller0Connected || Pvr_ControllerManager.controllerlink.controller1Connected)
		{
			moduleState = true;
			controller.transform.localScale = Vector3.one;
		}
		RefreshRay();
	}

	private void MainControllerIDChanged(string data)
	{
		RefreshRay();
	}

	private void RefreshRay()
	{
		if (Variety == ControllerVariety.Controller0)
		{
			StartCoroutine(ShowOrHideRay(0));
		}
		if (Variety == ControllerVariety.Controller1)
		{
			StartCoroutine(ShowOrHideRay(1));
		}
	}

	private IEnumerator ShowOrHideRay(int id)
	{
		yield return null;
		yield return null;
		if (moduleState)
		{
			bool active = Controller.UPvr_GetMainHandNess() == id && Controller.UPvr_GetControllerState(id) == ControllerState.Connected;
			dot.SetActive(active);
			rayLine.SetActive(active);
		}
	}

	public void ForceHideOrShow(bool state)
	{
		dot.SetActive(state);
		rayLine.SetActive(state);
		controller.transform.localScale = ((!state) ? Vector3.zero : Vector3.one);
		moduleState = state;
	}

	public void UpdateRay()
	{
		if (!Pvr_ControllerManager.Instance.LengthAdaptiveRay)
		{
			return;
		}
		bool flag = false;
		flag = ((Pvr_ControllerManager.controllerlink.controller0Connected || Pvr_ControllerManager.controllerlink.controller1Connected) ? true : false);
		if (flag && rayLine != null && rayLine.gameObject.activeSelf)
		{
			int num = Controller.UPvr_GetDeviceType();
			if (num == 1)
			{
				rayLine.GetComponent<LineRenderer>().SetPosition(0, base.transform.TransformPoint(0f, 0f, 0.058f));
			}
			else
			{
				rayLine.GetComponent<LineRenderer>().SetPosition(0, base.transform.TransformPoint(0f, 0.009f, 0.055f));
			}
			rayLine.GetComponent<LineRenderer>().SetPosition(1, dot.transform.position);
		}
	}
}
public class Pvr_ControllerPower : MonoBehaviour
{
	[SerializeField]
	private Sprite power1;

	[SerializeField]
	private Sprite power2;

	[SerializeField]
	private Sprite power3;

	[SerializeField]
	private Sprite power4;

	[SerializeField]
	private Sprite power5;

	[HideInInspector]
	public ControllerVariety variety;

	[HideInInspector]
	public ControllerDevice currentDevice;

	private Image powerImage;

	private int powerValue;

	private float power;

	private void Start()
	{
		powerImage = base.transform.GetComponent<Image>();
		powerValue = -1;
		variety = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().Variety;
		currentDevice = base.transform.GetComponentInParent<Pvr_ControllerVisual>().currentDevice;
	}

	private void Update()
	{
		RefreshPower((variety != 0) ? 1 : 0);
	}

	private void RefreshPower(int hand)
	{
		if (powerValue != Controller.UPvr_GetControllerPower(hand))
		{
			switch (Controller.UPvr_GetControllerPower(hand))
			{
			case 1:
				powerImage.sprite = power1;
				powerImage.color = Color.red;
				break;
			case 2:
				powerImage.sprite = power2;
				powerImage.color = Color.white;
				break;
			case 3:
				powerImage.sprite = power3;
				powerImage.color = Color.white;
				break;
			case 4:
				powerImage.sprite = power4;
				powerImage.color = Color.white;
				break;
			case 5:
				powerImage.sprite = power5;
				powerImage.color = Color.white;
				break;
			default:
				powerImage.sprite = power1;
				powerImage.color = Color.white;
				break;
			}
			powerValue = Controller.UPvr_GetControllerPower(hand);
		}
	}
}
namespace Pvr_UnitySDKAPI
{
	public enum ControllerDevice
	{
		Goblin,
		Neo,
		G2,
		Neo2,
		Neo3,
		NewController
	}
}
public class Pvr_ControllerVisual : MonoBehaviour
{
	public ControllerDevice currentDevice;

	public Texture2D m_idle;

	public Texture2D m_app;

	public Texture2D m_home;

	public Texture2D m_touchpad;

	public Texture2D m_volUp;

	public Texture2D m_volDn;

	public Texture2D m_trigger;

	public Texture2D m_a;

	public Texture2D m_b;

	public Texture2D m_x;

	public Texture2D m_y;

	public Texture2D m_grip;

	private Renderer controllerRenderMat;

	[HideInInspector]
	public ControllerVariety variety;

	private void Awake()
	{
		controllerRenderMat = GetComponent<Renderer>();
	}

	private void Start()
	{
		variety = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().Variety;
	}

	private void Update()
	{
		ChangeKeyEffects((variety != 0) ? 1 : 0);
	}

	private void ChangeKeyEffects(int hand)
	{
		if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.TOUCHPAD))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_touchpad);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.APP))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_app);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.HOME))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_home);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.VOLUMEUP))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_volUp);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.VOLUMEDOWN))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_volDn);
		}
		else if (Controller.UPvr_GetControllerTriggerValue(hand) > 0 || Controller.UPvr_GetKey(hand, Pvr_KeyCode.TRIGGER))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_trigger);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.X))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_x);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.Y))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_y);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.A))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_a);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.B))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_b);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.Left) || Controller.UPvr_GetKey(hand, Pvr_KeyCode.Right))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_grip);
		}
		else if (controllerRenderMat.material.GetTexture("_MainTex") != m_idle)
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_idle);
		}
	}
}
public class Pvr_ToolTips : MonoBehaviour
{
	public enum TipBtn
	{
		app,
		touchpad,
		home,
		volup,
		voldown,
		trigger,
		grip
	}

	private ControllerDevice currentDevice;

	private float tipsAlpha;

	public static Pvr_ToolTips tooltips;

	public void ChangeTipsText(TipBtn tip, string key)
	{
		switch (tip)
		{
		case TipBtn.app:
			base.transform.Find("apptip/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.touchpad:
			base.transform.Find("touchtip/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.home:
			base.transform.Find("hometip/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.volup:
			base.transform.Find("volup/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.voldown:
			base.transform.Find("voldown/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.trigger:
			base.transform.Find("triggertip/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.grip:
			base.transform.Find("grip/btn/Text").GetComponent<Text>().text = key;
			break;
		}
	}

	private void Awake()
	{
		tooltips = base.transform.GetComponent<Pvr_ToolTips>();
	}

	private void Update()
	{
		switch (currentDevice)
		{
		case ControllerDevice.Goblin:
		case ControllerDevice.G2:
			tipsAlpha = (330f - base.transform.parent.parent.parent.localRotation.eulerAngles.x) / 45f;
			if (base.transform.parent.parent.parent.localRotation.eulerAngles.x >= 270f && base.transform.parent.parent.parent.localRotation.eulerAngles.x <= 330f)
			{
				tipsAlpha = Mathf.Max(0f, tipsAlpha);
				tipsAlpha = ((!(tipsAlpha > 1f)) ? tipsAlpha : 1f);
			}
			else
			{
				tipsAlpha = 0f;
			}
			GetComponent<CanvasGroup>().alpha = tipsAlpha;
			break;
		case ControllerDevice.Neo2:
		case ControllerDevice.Neo3:
			tipsAlpha = (330f - base.transform.parent.parent.parent.localRotation.eulerAngles.x) / 45f;
			if (base.transform.parent.parent.parent.localRotation.eulerAngles.x >= 270f && base.transform.parent.parent.parent.localRotation.eulerAngles.x <= 330f)
			{
				tipsAlpha = Mathf.Max(0f, tipsAlpha);
				tipsAlpha = ((!(tipsAlpha > 1f)) ? tipsAlpha : 1f);
			}
			else
			{
				tipsAlpha = 0f;
			}
			GetComponent<CanvasGroup>().alpha = tipsAlpha;
			break;
		case ControllerDevice.Neo:
			break;
		}
	}

	private void LoadTextFromJson()
	{
		currentDevice = base.transform.GetComponentInParent<Pvr_ControllerVisual>().currentDevice;
		base.transform.Find("apptip/btn/Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("apptip");
		base.transform.Find("touchtip/btn/Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("touchtip");
		base.transform.Find("hometip/btn/Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("hometip");
		Transform transform = base.transform.Find("volup/btn/Text");
		if (transform != null)
		{
			transform.GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("voluptip");
		}
		Transform transform2 = base.transform.Find("voldown/btn/Text");
		if (transform2 != null)
		{
			transform2.GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("voldowntip");
		}
		Transform transform3 = base.transform.Find("triggertip/btn/Text");
		if (transform3 != null)
		{
			transform3.GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("triggertip");
		}
		Transform transform4 = base.transform.Find("grip/btn/Text");
		if (transform4 != null)
		{
			transform4.GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("griptip");
		}
	}

	public static void RefreshTips()
	{
		if (tooltips != null)
		{
			tooltips.LoadTextFromJson();
		}
	}
}
public class Pvr_TouchPadScroll : MonoBehaviour
{
	private ScrollRect scrollRect;

	private bool isHoving;

	private int mainHand;

	private SwipeDirection direction;

	private Vector2 currPos;

	private Vector2 tarPos;

	private float lerpSpeed = 10f;

	private Transform tranViewport;

	private float ignoreDis = 3f;

	private Vector2 lastTouchDownPos;

	private Vector2 lastTouchUpPos;

	private bool isTouching;

	private bool isClosed = true;

	private Vector2 vecOrigin = Vector2.zero;

	private Vector2 vecOriginNeo2 = new Vector2(128f, 128f);

	private void Awake()
	{
		scrollRect = base.gameObject.GetComponent<ScrollRect>();
		tranViewport = base.transform.Find("Viewport");
	}

	private void Update()
	{
		Process();
		UpdateTargetPos();
		UpdatePos();
	}

	private bool IsControllerConnect()
	{
		mainHand = Controller.UPvr_GetMainHandNess();
		if (mainHand == 0 && Pvr_ControllerManager.controllerlink.controller0Connected)
		{
			return true;
		}
		if (mainHand == 1 && Pvr_ControllerManager.controllerlink.controller1Connected)
		{
			return true;
		}
		return false;
	}

	private void UpdateTargetPos()
	{
		if (Controller.UPvr_GetKey(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TOUCHPAD))
		{
			ResetParameter();
		}
		else if (isHoving)
		{
			if (Pvr_ControllerManager.controllerlink.GetControllerType() == 3)
			{
				ComputeTouchPos();
			}
			else
			{
				ComputeRockerPos();
			}
			if ((currPos - tarPos).sqrMagnitude <= 10f)
			{
				isClosed = true;
			}
		}
	}

	private void ComputeTouchPos()
	{
		mainHand = Controller.UPvr_GetMainHandNess();
		currPos = scrollRect.content.localPosition;
		Vector2 vector = vecOrigin;
		if (mainHand == 0 && Pvr_ControllerManager.controllerlink.controller0Connected)
		{
			vector = Controller.UPvr_GetTouchPadPosition(mainHand);
		}
		if (mainHand == 1 && Pvr_ControllerManager.controllerlink.controller1Connected)
		{
			vector = Controller.UPvr_GetTouchPadPosition(mainHand);
		}
		if ((vector - vecOrigin).sqrMagnitude >= 1f)
		{
			if (!isTouching)
			{
				lastTouchDownPos = vector;
				isTouching = true;
			}
			lastTouchUpPos.x = vector.x;
			float num = Mathf.Abs(lastTouchUpPos.x - lastTouchDownPos.x);
			if (num > ignoreDis)
			{
				Vector2 vector2 = new Vector2((lastTouchUpPos.x - lastTouchDownPos.x) * 10f, 0f);
				lastTouchDownPos.x = lastTouchUpPos.x;
				if (isClosed)
				{
					tarPos = currPos + vector2;
					isClosed = false;
				}
				else
				{
					tarPos += vector2;
				}
			}
		}
		else
		{
			lastTouchDownPos = vecOrigin;
			lastTouchUpPos = vecOrigin;
			isTouching = false;
			if ((double)scrollRect.horizontalScrollbar.value >= 0.999 || (double)scrollRect.horizontalScrollbar.value <= 0.0001)
			{
				isClosed = true;
			}
		}
	}

	private void ComputeRockerPos()
	{
		mainHand = Controller.UPvr_GetMainHandNess();
		currPos = scrollRect.content.localPosition;
		Vector2 vector = vecOriginNeo2;
		if (mainHand == 0 && Pvr_ControllerManager.controllerlink.controller0Connected)
		{
			vector = Controller.UPvr_GetTouchPadPosition(mainHand);
		}
		if (mainHand == 1 && Pvr_ControllerManager.controllerlink.controller1Connected)
		{
			vector = Controller.UPvr_GetTouchPadPosition(mainHand);
		}
		if (VerifyNeo2TouchValid(vector) && (vector - vecOriginNeo2).sqrMagnitude >= 1f)
		{
			if (!isTouching)
			{
				lastTouchDownPos = vector;
				isTouching = true;
			}
			lastTouchUpPos.x = vector.x;
			float num = Mathf.Abs(lastTouchUpPos.x - lastTouchDownPos.x);
			if (num > ignoreDis)
			{
				Vector2 vector2 = new Vector2((lastTouchUpPos.x - lastTouchDownPos.x) * 10f, 0f);
				lastTouchDownPos.x = lastTouchUpPos.x;
				if (isClosed)
				{
					tarPos = currPos + vector2;
					isClosed = false;
				}
				else
				{
					tarPos += vector2;
				}
			}
		}
		else
		{
			lastTouchDownPos = vecOriginNeo2;
			lastTouchUpPos = vecOriginNeo2;
			isTouching = false;
			if ((double)scrollRect.horizontalScrollbar.value >= 0.999 || (double)scrollRect.horizontalScrollbar.value <= 0.0001)
			{
				isClosed = true;
			}
		}
	}

	private bool VerifyNeo2TouchValid(Vector2 nowTouchPos)
	{
		if (nowTouchPos.x > vecOriginNeo2.x && nowTouchPos.x > lastTouchDownPos.x)
		{
			return true;
		}
		if (nowTouchPos.x < vecOriginNeo2.x && nowTouchPos.x < lastTouchDownPos.x)
		{
			return true;
		}
		return false;
	}

	private void UpdatePos()
	{
		if (Controller.UPvr_GetKey(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TOUCHPAD))
		{
			ResetParameter();
		}
		else if (!isClosed && IsControllerConnect())
		{
			if ((double)scrollRect.horizontalScrollbar.value >= 0.9999 && tarPos.x <= currPos.x)
			{
				isClosed = true;
				return;
			}
			if ((double)scrollRect.horizontalScrollbar.value <= 0.0001 && tarPos.x >= currPos.x)
			{
				isClosed = true;
				return;
			}
			currPos.x = Mathf.Lerp(currPos.x, tarPos.x, lerpSpeed * Time.deltaTime);
			currPos.y = Mathf.Lerp(currPos.y, tarPos.y, lerpSpeed * Time.deltaTime);
			scrollRect.content.localPosition = currPos;
		}
	}

	private void ResetParameter()
	{
		currPos = scrollRect.content.localPosition;
		tarPos = scrollRect.content.localPosition;
		isClosed = true;
	}

	private void Process()
	{
		for (int i = 0; i < Pvr_InputModule.pointers.Count; i++)
		{
			Pvr_UIPointer pvr_UIPointer = Pvr_InputModule.pointers[i];
			if (pvr_UIPointer.gameObject.activeInHierarchy && pvr_UIPointer.enabled)
			{
				isHoving = IsHovering(pvr_UIPointer);
			}
		}
	}

	private bool IsHovering(Pvr_UIPointer pointer)
	{
		if (!IsControllerConnect())
		{
			return false;
		}
		foreach (GameObject item in pointer.pointerEventData.hovered)
		{
			if (FindTree(item.transform))
			{
				mainHand = Controller.UPvr_GetMainHandNess();
				if (mainHand == 0 && Pvr_ControllerManager.controllerlink.controller0Connected)
				{
					return true;
				}
				if (mainHand == 1 && Pvr_ControllerManager.controllerlink.controller1Connected)
				{
					return true;
				}
			}
		}
		return false;
	}

	private bool FindTree(Transform tran)
	{
		if (tran == base.transform || tran == tranViewport)
		{
			return true;
		}
		if (tran.IsChildOf(tranViewport))
		{
			return true;
		}
		return false;
	}
}
public class Pvr_TouchVisual : MonoBehaviour
{
	[HideInInspector]
	public ControllerDevice currentDevice;

	[HideInInspector]
	public ControllerVariety variety;

	private MeshRenderer touchRenderer;

	private void Start()
	{
		variety = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().Variety;
		currentDevice = GetComponentInParent<Pvr_ControllerVisual>().currentDevice;
		touchRenderer = GetComponent<MeshRenderer>();
	}

	private void Update()
	{
		ChangeEffects((variety != 0) ? 1 : 0);
	}

	private void ChangeEffects(int hand)
	{
		ControllerDevice controllerDevice = currentDevice;
		if (controllerDevice == ControllerDevice.G2)
		{
			if (Controller.UPvr_IsTouching(0))
			{
				touchRenderer.enabled = true;
				base.transform.localPosition = new Vector3(1.3f - Controller.UPvr_GetTouchPadPosition(hand).x * 0.01f, 1.6f, -1.7f - Controller.UPvr_GetTouchPadPosition(hand).y * 0.01f);
			}
			else
			{
				touchRenderer.enabled = false;
			}
		}
	}
}
public class DemoController : MonoBehaviour
{
	public delegate void showLoadingEventHandler();

	private Callback callback;

	private GameObject msg;

	private Pvr_UnitySDKManager picoVrManager;

	private string currentOrderID;

	public GameObject loading;

	public GameObject BG;

	public GameObject InputPanel;

	public static showLoadingEventHandler showLoading;

	private void Awake()
	{
		UnityEngine.Debug.Log(loading.name);
		UnityEngine.Debug.Log(BG.name);
		showLoading = (showLoadingEventHandler)Delegate.Combine(showLoading, new showLoadingEventHandler(StopLoading));
		InputManager.doEnter = (InputManager.doEnterEventHandler)Delegate.Combine(InputManager.doEnter, new InputManager.doEnterEventHandler(DoPayByCode));
		currentOrderID = string.Empty;
	}

	private void Start()
	{
		msg = GameObject.Find("MassageInfo");
		InitDelegate();
		callback = new Callback();
		picoVrManager = GameObject.Find("Pvr_UnitySDK").GetComponent<Pvr_UnitySDKManager>();
		InputPanel.SetActive(value: false);
	}

	private void Update()
	{
		if (picoVrManager != null && (Input.GetKeyDown(KeyCode.Y) || Input.GetKeyDown(KeyCode.Joystick1Button2)))
		{
			UnityEngine.Debug.Log("update");
			Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
		}
		if (Input.GetKeyDown(KeyCode.Joystick1Button1) || Input.GetKeyDown(KeyCode.Escape))
		{
			if (InputPanel.activeInHierarchy)
			{
				InputPanel.SetActive(value: false);
			}
			else
			{
				UnityEngine.Application.Quit();
			}
		}
	}

	private void InitDelegate()
	{
		ArrayList arrayList = new ArrayList();
		arrayList.Add("Login");
		arrayList.Add("GetUserAPI");
		arrayList.Add("PayOne");
		arrayList.Add("PayCode");
		arrayList.Add("QueryOrder");
		foreach (string item in arrayList)
		{
			GameObject btnObj = GameObject.Find(item);
			Button component = btnObj.GetComponent<Button>();
			component.onClick.AddListener(delegate
			{
				OnClick(btnObj);
			});
		}
	}

	private void OnClick(GameObject btnObj)
	{
		switch (btnObj.name)
		{
		case "Login":
			StartLoading();
			LoginSDK.Login();
			break;
		case "PayOne":
			CommonDic.getInstance().setParameters("subject", "game");
			CommonDic.getInstance().setParameters("body", "gamePay");
			CommonDic.getInstance().setParameters("order_id", getRamdomTestOrderID());
			CommonDic.getInstance().setParameters("total", "1");
			CommonDic.getInstance().setParameters("goods_tag", "game");
			CommonDic.getInstance().setParameters("notify_url", "www.picovr.com");
			CommonDic.getInstance().setParameters("pay_code", string.Empty);
			StartLoading();
			PicoPaymentSDK.Pay(CommonDic.getInstance().PayOrderString());
			break;
		case "PayCode":
			InputPanel.SetActive(value: true);
			break;
		case "QueryOrder":
			StartLoading();
			PicoPaymentSDK.QueryOrder(currentOrderID);
			break;
		case "GetUserAPI":
			StartLoading();
			LoginSDK.GetUserAPI();
			break;
		}
	}

	public string getRamdomTestOrderID()
	{
		currentOrderID = (UnityEngine.Random.value * 65535f).ToString();
		return currentOrderID;
	}

	private void StartLoading()
	{
		loading.SetActive(value: true);
		BG.SetActive(value: true);
	}

	public void StopLoading()
	{
		if ((bool)loading && (bool)BG)
		{
			loading.SetActive(value: false);
			BG.SetActive(value: false);
		}
		else
		{
			UnityEngine.Debug.LogError("demo");
		}
	}

	public void DoPayByCode()
	{
		CommonDic.getInstance().setParameters("subject", "game");
		CommonDic.getInstance().setParameters("body", "gamePay");
		CommonDic.getInstance().setParameters("order_id", getRamdomTestOrderID());
		CommonDic.getInstance().setParameters("total", "0");
		CommonDic.getInstance().setParameters("goods_tag", "game");
		CommonDic.getInstance().setParameters("notify_url", "www.picovr.com");
		CommonDic.getInstance().setParameters("pay_code", GameObject.Find("CodeText").GetComponent<Text>().text);
		UnityEngine.Debug.Log("" + GameObject.Find("CodeText").GetComponent<Text>().text);
		StartLoading();
		GameObject.Find("CodeText").GetComponent<Text>().text = string.Empty;
		InputPanel.SetActive(value: false);
		PicoPaymentSDK.Pay(CommonDic.getInstance().PayOrderString());
	}

	private bool VerifyLocalToken()
	{
		if (CommonDic.getInstance().access_token.Equals(string.Empty))
		{
			GameObject.Find("MassageInfo").GetComponent<Text>().text = "{code:exception,msg:}";
			currentOrderID = string.Empty;
			StopLoading();
			return false;
		}
		return true;
	}
}
public class LoadingRatation : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
		base.gameObject.transform.Rotate(new Vector3(0f, 0f, -4f));
	}
}
public class InputManager : MonoBehaviour
{
	public delegate void doEnterEventHandler();

	public static doEnterEventHandler doEnter;

	private StringBuilder sb = new StringBuilder();

	private ArrayList btnsName = new ArrayList();

	private GameObject enter;

	private void Awake()
	{
		InitKeyBoard();
	}

	private void Start()
	{
	}

	private void Update()
	{
	}

	private void InitKeyBoard()
	{
		btnsName.Add("1");
		btnsName.Add("2");
		btnsName.Add("3");
		btnsName.Add("4");
		btnsName.Add("5");
		btnsName.Add("6");
		btnsName.Add("7");
		btnsName.Add("8");
		btnsName.Add("9");
		btnsName.Add("0");
		btnsName.Add("Q");
		btnsName.Add("W");
		btnsName.Add("E");
		btnsName.Add("R");
		btnsName.Add("T");
		btnsName.Add("Y");
		btnsName.Add("U");
		btnsName.Add("I");
		btnsName.Add("O");
		btnsName.Add("P");
		btnsName.Add("A");
		btnsName.Add("S");
		btnsName.Add("D");
		btnsName.Add("F");
		btnsName.Add("G");
		btnsName.Add("H");
		btnsName.Add("J");
		btnsName.Add("K");
		btnsName.Add("L");
		btnsName.Add("Z");
		btnsName.Add("X");
		btnsName.Add("C");
		btnsName.Add("V");
		btnsName.Add("B");
		btnsName.Add("N");
		btnsName.Add("M");
		btnsName.Add("Clear");
		btnsName.Add("Capslock");
		btnsName.Add("Enter");
		foreach (string item in btnsName)
		{
			GameObject btnObj = GameObject.Find(item);
			Button component = btnObj.GetComponent<Button>();
			component.onClick.AddListener(delegate
			{
				OnClick(btnObj);
			});
		}
		enter = GameObject.Find("Enter");
		enter.SetActive(sb.Length > 0);
	}

	private void OnClick(GameObject btnObj)
	{
		if (btnObj.name.Equals("Capslock"))
		{
			if (GameObject.Find("Q").transform.GetChild(0).GetComponent<Text>().text.Equals("Q"))
			{
				DoCapslock(IsUpper: true);
			}
			else
			{
				DoCapslock(IsUpper: false);
			}
		}
		else if (btnObj.name.Equals("Clear"))
		{
			GameObject.Find("CodeText").GetComponent<Text>().text = string.Empty;
			ClearBuffer();
		}
		else if (btnObj.name.Equals("Enter"))
		{
			ClearBuffer();
			doEnter();
		}
		else
		{
			EnterChar(btnObj.transform.GetChild(0).GetComponent<Text>().text);
		}
	}

	private void EnterChar(string s)
	{
		sb.Append(s);
		GameObject.Find("CodeText").GetComponent<Text>().text = sb.ToString();
		enter.SetActive(sb.Length > 0);
	}

	private void DoCapslock(bool IsUpper)
	{
		if (IsUpper)
		{
			foreach (string item in btnsName)
			{
				GameObject gameObject = GameObject.Find(item);
				Text component = gameObject.transform.GetChild(0).GetComponent<Text>();
				component.text = component.text.ToLower();
			}
			return;
		}
		foreach (string item2 in btnsName)
		{
			GameObject gameObject2 = GameObject.Find(item2);
			Text component2 = gameObject2.transform.GetChild(0).GetComponent<Text>();
			component2.text = component2.text.ToUpper();
		}
	}

	private void ClearBuffer()
	{
		sb.Remove(0, sb.Length);
		enter.SetActive(sb.Length > 0);
	}
}
public class Callback : MonoBehaviour
{
	private GameObject messageGameObject;

	private static string IS_SUCCESS = "isSuccess";

	private static string MSG = "msg";

	private static string CODE = "code";

	private static string DATA = "data";

	private static string USERNAME = "username";

	private static string OPENID = "openid";

	public static event Action<string> OnLoginCallback;

	public static event Action<string, string> OnUserInfoCallback;

	private void _ShowAndroidToastMessage(string message)
	{
		AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
		AndroidJavaObject unityActivity = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
		if (unityActivity != null)
		{
			AndroidJavaClass toastClass = new AndroidJavaClass("android.widget.Toast");
			unityActivity.Call("runOnUiThread", (AndroidJavaRunnable)delegate
			{
				AndroidJavaObject androidJavaObject = toastClass.CallStatic<AndroidJavaObject>("makeText", new object[3] { unityActivity, message, 0 });
				androidJavaObject.Call("show");
			});
		}
	}

	public void LoginCallback(string LoginInfo)
	{
		UnityEngine.Debug.Log($"Pico login: {LoginInfo}");
		JsonData jsonData = JsonMapper.ToObject(LoginInfo);
		SetMassage(LoginInfo);
		JsonData jsonData2 = jsonData[IS_SUCCESS];
		if (jsonData2 != null)
		{
			CommonDic.getInstance().isSuccess = jsonData2.ToString();
		}
		JsonData jsonData3 = jsonData[MSG];
		if (jsonData3 != null)
		{
			CommonDic.getInstance().loginMsg = jsonData3.ToString();
		}
		UnityEngine.Debug.Log("login:" + LoginInfo);
		if (bool.TryParse(jsonData2.ToString(), out var _))
		{
			if (Callback.OnLoginCallback != null)
			{
				Callback.OnLoginCallback(string.Empty);
			}
			return;
		}
		UnityEngine.Debug.LogError($"Pico loading failure : {jsonData3}");
		_ShowAndroidToastMessage(jsonData3.ToString());
		if (Callback.OnLoginCallback != null)
		{
			Callback.OnLoginCallback(jsonData3.ToString());
		}
	}

	public void QueryOrPayCallback(string queryOrPayInfo)
	{
		UnityEngine.Debug.Log($"QueryOrPayCallback: {queryOrPayInfo}");
		JsonData jsonData = JsonMapper.ToObject(queryOrPayInfo);
		if (jsonData[CODE] != null)
		{
			CommonDic.getInstance().code = jsonData["code"].ToString();
		}
		if (jsonData[MSG] != null)
		{
			CommonDic.getInstance().msg = jsonData["msg"].ToString();
		}
		if (jsonData != null)
		{
			CommonDic.getInstance().order_info = jsonData[1].ToString();
		}
		SetMassage(queryOrPayInfo);
		UnityEngine.Debug.Log("pay:" + queryOrPayInfo);
	}

	public void UserInfoCallback(string userInfo)
	{
		CommonDic.getInstance().user_info = userInfo;
		SetMassage(userInfo);
		UnityEngine.Debug.Log("userInfo:" + userInfo);
		JsonData jsonData = JsonMapper.ToObject(userInfo);
		JsonData jsonData2 = jsonData[DATA];
		if (Callback.OnUserInfoCallback != null)
		{
			Callback.OnUserInfoCallback(jsonData2[USERNAME].ToString(), jsonData2[OPENID].ToString());
		}
	}

	public void SetMassage(string massage)
	{
		if (messageGameObject == null)
		{
			messageGameObject = GetCurrentGameObject();
		}
		if (messageGameObject != null)
		{
			GetCurrentGameObject().GetComponent<Text>().text = massage;
		}
		else
		{
			UnityEngine.Debug.LogError("Message");
		}
	}

	public GameObject GetCurrentGameObject()
	{
		return GameObject.Find("MassageInfo");
	}

	public void ActivityForResultCallback(string activity)
	{
		PicoPaymentSDK.jo.Call("authCallback", activity);
	}
}
public class CommonDic
{
	private static CommonDic dic;

	private static Dictionary<string, string> mydic;

	private string _app_ID;

	private string _app_Key;

	private string _user_token;

	private string _access_token = string.Empty;

	private string _open_id;

	private string _refresh_token;

	private string _expires_in;

	private string _user_info;

	private string _subject;

	private string _body;

	private string _order_id;

	private string _total;

	private string _goods_tag;

	private string _notify_url;

	private string _trade_type;

	private string _pay_code = string.Empty;

	private string _order_info;

	private string _code;

	private string _msg = "null";

	private string _merchant_ID;

	private string _payKey;

	private string _isSuucess;

	private string _loginMsg;

	public string subject
	{
		get
		{
			return _subject;
		}
		set
		{
			_subject = value;
		}
	}

	public string body
	{
		get
		{
			return _body;
		}
		set
		{
			_body = value;
		}
	}

	public string order_id
	{
		get
		{
			return _order_id;
		}
		set
		{
			_order_id = value;
		}
	}

	public string total
	{
		get
		{
			return _total;
		}
		set
		{
			_total = value;
		}
	}

	public string goods_tag
	{
		get
		{
			return _goods_tag;
		}
		set
		{
			_goods_tag = value;
		}
	}

	public string notify_url
	{
		get
		{
			return _notify_url;
		}
		set
		{
			_notify_url = value;
		}
	}

	public string pay_code
	{
		get
		{
			return _pay_code;
		}
		set
		{
			_pay_code = value;
		}
	}

	public string trade_type
	{
		get
		{
			return _trade_type;
		}
		set
		{
			_trade_type = value;
		}
	}

	public string user_token
	{
		get
		{
			return _user_token;
		}
		set
		{
			_user_token = value;
		}
	}

	public string access_token
	{
		get
		{
			return _access_token;
		}
		set
		{
			_access_token = value;
		}
	}

	public string open_id
	{
		get
		{
			return _open_id;
		}
		set
		{
			_open_id = value;
		}
	}

	public string refresh_token
	{
		get
		{
			return _refresh_token;
		}
		set
		{
			_refresh_token = value;
		}
	}

	public string expires_in
	{
		get
		{
			return _expires_in;
		}
		set
		{
			_expires_in = value;
		}
	}

	public string isSuccess
	{
		get
		{
			return _isSuucess;
		}
		set
		{
			_isSuucess = value;
		}
	}

	public string loginMsg
	{
		get
		{
			return _loginMsg;
		}
		set
		{
			_loginMsg = value;
		}
	}

	public string user_info
	{
		get
		{
			return _user_info;
		}
		set
		{
			_user_info = value;
		}
	}

	public string order_info
	{
		get
		{
			return _order_info;
		}
		set
		{
			_order_info = value;
		}
	}

	public string code
	{
		get
		{
			return _code;
		}
		set
		{
			_code = value;
		}
	}

	public string msg
	{
		get
		{
			return _msg;
		}
		set
		{
			_msg = value;
		}
	}

	public string app_ID
	{
		get
		{
			return _app_ID;
		}
		set
		{
			_app_ID = value;
		}
	}

	public string app_Key
	{
		get
		{
			return _app_Key;
		}
		set
		{
			_app_Key = value;
		}
	}

	public string merchant_ID
	{
		get
		{
			return _merchant_ID;
		}
		set
		{
			_merchant_ID = value;
		}
	}

	public string paykey
	{
		get
		{
			return _payKey;
		}
		set
		{
			_payKey = value;
		}
	}

	public static CommonDic getInstance()
	{
		if (dic == null)
		{
			dic = new CommonDic();
		}
		if (mydic == null)
		{
			mydic = new Dictionary<string, string>();
			InitDicData(mydic);
		}
		return dic;
	}

	public Dictionary<string, string> getDic()
	{
		return mydic;
	}

	public void setParameters(string name, string value)
	{
		if (name.Equals("subject"))
		{
			subject = value;
		}
		if (name.Equals("body"))
		{
			body = value;
		}
		if (name.Equals("order_id"))
		{
			order_id = value;
		}
		if (name.Equals("total"))
		{
			total = value;
		}
		if (name.Equals("goods_tag"))
		{
			goods_tag = value;
		}
		if (name.Equals("notify_url"))
		{
			notify_url = value;
		}
		if (name.Equals("trade_type"))
		{
			trade_type = value;
		}
		if (name.Equals("pay_code"))
		{
			pay_code = value;
		}
	}

	public string PayOrderString()
	{
		return JsonMapper.ToJson(getInstance());
	}

	public static void InitDicData(Dictionary<string, string> mydic)
	{
		mydic.Add("00000", "");
		mydic.Add("10000", "");
		mydic.Add("10001", "");
		mydic.Add("10002", "");
		mydic.Add("10003", "");
		mydic.Add("11000", "");
		mydic.Add("11001", "");
		mydic.Add("11002", "");
		mydic.Add("11003", "");
		mydic.Add("12000", "");
		mydic.Add("12001", "");
		mydic.Add("12003", "P");
		mydic.Add("12004", "");
		mydic.Add("13000", "");
		mydic.Add("13001", "");
		mydic.Add("13002", "");
		mydic.Add("14000", "");
		mydic.Add("14001", "/");
		mydic.Add("14002", "");
		mydic.Add("15000", "");
		mydic.Add("15001", "ID");
		mydic.Add("15002", "Pico");
		mydic.Add("NOAUTH", "");
		mydic.Add("SYSTEMERROR", "");
		mydic.Add("APP_ID_NOT_EXIST", "APP_ID");
		mydic.Add("MCHID_NOT_EXIST", "MCHID");
		mydic.Add("APP_ID_MCHID_NOT_MATCH", "app_idmch_idID");
		mydic.Add("LACK_PARAMS", "");
		mydic.Add("SIGNERROR", "");
		mydic.Add("NO_DATA", "");
	}
}
public class LoginSDK
{
	public static void Login()
	{
		PicoPaymentSDK.Login();
	}

	public static void GetUserAPI()
	{
		PicoPaymentSDK.GetUserAPI();
	}
}
public class PicoPaymentSDK
{
	private static AndroidJavaObject _jo = new AndroidJavaObject("com.pico.loginpaysdk.UnityInterface");

	public static AndroidJavaObject jo
	{
		get
		{
			return _jo;
		}
		set
		{
			_jo = value;
		}
	}

	public static void Login()
	{
		AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
		AndroidJavaObject @static = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
		jo.Call("init", @static);
		jo.Call("authSSO");
	}

	public static void Pay(string payOrderJson)
	{
		AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
		AndroidJavaObject @static = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
		jo.Call("init", @static);
		jo.Call("pay", payOrderJson);
	}

	public static void QueryOrder(string orderId)
	{
		AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
		AndroidJavaObject @static = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
		jo.Call("init", @static);
		jo.Call("queryOrder", orderId);
	}

	public static void GetUserAPI()
	{
		AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
		AndroidJavaObject @static = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
		jo.Call("init", @static);
		jo.Call("getUserAPI");
	}
}
namespace Pvr_UnitySDKAPI
{
	public enum PBS_SystemInfoEnum
	{
		ELECTRIC_QUANTITY,
		PUI_VERSION,
		EQUIPMENT_MODEL,
		EQUIPMENT_SN,
		CUSTOMER_SN,
		INTERNAL_STORAGE_SPACE_OF_THE_DEVICE,
		DEVICE_BLUETOOTH_STATUS,
		BLUETOOTH_NAME_CONNECTED,
		BLUETOOTH_MAC_ADDRESS,
		DEVICE_WIFI_STATUS,
		WIFI_NAME_CONNECTED,
		WLAN_MAC_ADDRESS,
		DEVICE_IP
	}
	public enum PBS_DeviceControlEnum
	{
		DEVICE_CONTROL_REBOOT,
		DEVICE_CONTROL_SHUTDOWN
	}
	public enum PBS_PackageControlEnum
	{
		PACKAGE_SILENCE_INSTALL,
		PACKAGE_SILENCE_UNINSTALL
	}
	public enum PBS_SwitchEnum
	{
		S_ON,
		S_OFF
	}
	public enum PBS_HomeEventEnum
	{
		SINGLE_CLICK,
		DOUBLE_CLICK,
		LONG_PRESS
	}
	public enum PBS_HomeFunctionEnum
	{
		VALUE_HOME_GO_TO_SETTING,
		VALUE_HOME_BACK,
		VALUE_HOME_RECENTER,
		VALUE_HOME_OPEN_APP,
		VALUE_HOME_DISABLE,
		VALUE_HOME_GO_TO_HOME,
		VALUE_HOME_SEND_BROADCAST,
		VALUE_HOME_CLEAN_MEMORY
	}
	public enum PBS_ScreenOffDelayTimeEnum
	{
		THREE = 3,
		TEN = 10,
		THIRTY = 30,
		SIXTY = 60,
		THREE_HUNDRED = 300,
		SIX_HUNDRED = 600,
		NEVER = -1
	}
	public enum PBS_SleepDelayTimeEnum
	{
		FIFTEEN = 15,
		THIRTY = 30,
		SIXTY = 60,
		THREE_HUNDRED = 300,
		SIX_HUNDRED = 600,
		ONE_THOUSAND_AND_EIGHT_HUNDRED = 1800,
		NEVER = -1
	}
	public enum PBS_SystemFunctionSwitchEnum
	{
		SFS_USB,
		SFS_AUTOSLEEP,
		SFS_SCREENON_CHARGING,
		SFS_OTG_CHARGING,
		SFS_RETURN_MENU_IN_2DMODE,
		SFS_COMBINATION_KEY,
		SFS_CALIBRATION_WITH_POWER_ON,
		SFS_SYSTEM_UPDATE,
		SFS_CAST_SERVICE,
		SFS_EYE_PROTECTION,
		SFS_SECURITY_ZONE_PERMANENTLY,
		SFS_GLOBAL_CALIBRATION,
		SFS_Auto_Calibration,
		SFS_USB_BOOT
	}
	public enum PBS_USBConfigModeEnum
	{
		MTP,
		CHARGE
	}
	public struct ToBService
	{
		public static Action<bool> BoolCallback;

		public static Action<int> IntCallback;

		public static Action<long> LongCallback;

		private static AndroidJavaClass unityPlayer;

		private static AndroidJavaObject currentActivity;

		private static AndroidJavaObject tobHelper;

		private static AndroidJavaClass tobHelperClass;

		public static void UPvr_InitToBService()
		{
			tobHelperClass = new AndroidJavaClass("com.pvr.tobservice.ToBServiceHelper");
			tobHelper = tobHelperClass.CallStatic<AndroidJavaObject>("getInstance", Array.Empty<object>());
			unityPlayer = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
			currentActivity = unityPlayer.GetStatic<AndroidJavaObject>("currentActivity");
		}

		public static void UPvr_SetUnityObjectName(string obj)
		{
			System.UPvr_CallMethod(tobHelper, "setUnityObjectName", obj);
		}

		public static void UPvr_BindToBService()
		{
			System.UPvr_CallMethod(tobHelper, "bindTobService", currentActivity);
		}

		public static void UPvr_UnBindToBService()
		{
			System.UPvr_CallMethod(tobHelper, "unBindTobService", currentActivity);
		}

		private static AndroidJavaObject GetEnumType(Enum enumType)
		{
			AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.pvr.tobservice.enums" + enumType.GetType().ToString().Replace("Pvr_UnitySDKAPI", string.Empty));
			return androidJavaClass.GetStatic<AndroidJavaObject>(enumType.ToString());
		}

		public static string UPvr_StateGetDeviceInfo(PBS_SystemInfoEnum type)
		{
			string result = string.Empty;
			System.UPvr_CallMethod(ref result, tobHelper, "pbsStateGetDeviceInfo", GetEnumType(type), 0);
			return result;
		}

		public static void UPvr_ControlSetDeviceAction(PBS_DeviceControlEnum deviceControl, Action<int> callback)
		{
			if (callback != null)
			{
				IntCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsControlSetDeviceAction", GetEnumType(deviceControl), null);
		}

		public static void UPvr_ControlAPPManger(PBS_PackageControlEnum packageControl, string path, Action<int> callback)
		{
			if (callback != null)
			{
				IntCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsControlAPPManger", GetEnumType(packageControl), path, 0, null);
		}

		public static void UPvr_ControlSetAutoConnectWIFI(string ssid, string pwd, Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsControlSetAutoConnectWIFI", ssid, pwd, 0, null);
		}

		public static void UPvr_ControlClearAutoConnectWIFI(Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsControlClearAutoConnectWIFI", null);
		}

		public static void UPvr_PropertySetHomeKey(PBS_HomeEventEnum eventEnum, PBS_HomeFunctionEnum function, Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsPropertySetHomeKey", GetEnumType(eventEnum), GetEnumType(function), null);
		}

		public static void UPvr_PropertySetHomeKeyAll(PBS_HomeEventEnum eventEnum, PBS_HomeFunctionEnum function, int timesetup, string pkg, string className, Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsPropertySetHomeKeyAll", GetEnumType(eventEnum), GetEnumType(function), timesetup, pkg, className, null);
		}

		public static void UPvr_PropertyDisablePowerKey(bool isSingleTap, bool enable, Action<int> callback)
		{
			if (callback != null)
			{
				IntCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsPropertyDisablePowerKey", isSingleTap, enable, null);
		}

		public static void UPvr_PropertySetScreenOffDelay(PBS_ScreenOffDelayTimeEnum timeEnum, Action<int> callback)
		{
			if (callback != null)
			{
				IntCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsPropertySetScreenOffDelay", GetEnumType(timeEnum), null);
		}

		public static void UPvr_PropertySetSleepDelay(PBS_SleepDelayTimeEnum timeEnum)
		{
			System.UPvr_CallMethod(tobHelper, "pbsPropertySetSleepDelay", GetEnumType(timeEnum));
		}

		public static void UPvr_SwitchSystemFunction(PBS_SystemFunctionSwitchEnum systemFunction, PBS_SwitchEnum switchEnum)
		{
			System.UPvr_CallMethod(tobHelper, "pbsSwitchSystemFunction", GetEnumType(systemFunction), GetEnumType(switchEnum), 0);
		}

		public static void UPvr_SwitchSetUsbConfigurationOption(PBS_USBConfigModeEnum uSBConfigModeEnum)
		{
			System.UPvr_CallMethod(tobHelper, "pbsSwitchSetUsbConfigurationOption", GetEnumType(uSBConfigModeEnum), 0);
		}

		public static void UPvr_ScreenOn()
		{
			System.UPvr_CallMethod(tobHelper, "pbsScreenOn");
		}

		public static void UPvr_ScreenOff()
		{
			System.UPvr_CallMethod(tobHelper, "pbsScreenOff");
		}

		public static void UPvr_AcquireWakeLock()
		{
			System.UPvr_CallMethod(tobHelper, "pbsAcquireWakeLock");
		}

		public static void UPvr_ReleaseWakeLock()
		{
			System.UPvr_CallMethod(tobHelper, "pbsReleaseWakeLock");
		}

		public static void UPvr_EnableEnterKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsEnableEnterKey");
		}

		public static void UPvr_DisableEnterKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsDisableEnterKey");
		}

		public static void UPvr_EnableVolumeKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsEnableVolumeKey");
		}

		public static void UPvr_DisableVolumeKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsDisableVolumeKey");
		}

		public static void UPvr_EnableBackKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsEnableBackKey");
		}

		public static void UPvr_DisableBackKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsDisableBackKey");
		}

		public static void UPvr_WriteConfigFileToDataLocal(string path, string content, Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsWriteConfigFileToDataLocal", path, content, null);
		}

		public static void UPvr_ResetAllKeyToDefault(Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsResetAllKeyToDefault", null);
		}
	}
}
public class Pvr_ToBService : MonoBehaviour
{
	public Text deviceInfoText;

	private void Awake()
	{
		InitToBService();
	}

	private void Start()
	{
		BindToBService();
	}

	private void OnDestory()
	{
		UnBindToBService();
	}

	private void InitToBService()
	{
		ToBService.UPvr_InitToBService();
		ToBService.UPvr_SetUnityObjectName(base.name);
	}

	private void BindToBService()
	{
		ToBService.UPvr_BindToBService();
	}

	private void UnBindToBService()
	{
		ToBService.UPvr_UnBindToBService();
	}

	private void BoolCallback(string value)
	{
		if (ToBService.BoolCallback != null)
		{
			ToBService.BoolCallback(bool.Parse(value));
		}
		ToBService.BoolCallback = null;
	}

	private void IntCallback(string value)
	{
		if (ToBService.IntCallback != null)
		{
			ToBService.IntCallback(int.Parse(value));
		}
		ToBService.IntCallback = null;
	}

	private void LongCallback(string value)
	{
		if (ToBService.LongCallback != null)
		{
			ToBService.LongCallback(int.Parse(value));
		}
		ToBService.LongCallback = null;
	}

	public void StateGetDeviceInfo()
	{
		string text = ToBService.UPvr_StateGetDeviceInfo(PBS_SystemInfoEnum.PUI_VERSION);
		deviceInfoText.text = "PUI_VERSION:" + text;
	}

	public void ControlSetDeviceAction()
	{
		ToBService.UPvr_ControlSetDeviceAction(PBS_DeviceControlEnum.DEVICE_CONTROL_SHUTDOWN, ControlSetDeviceActionCallBack);
	}

	private void ControlSetDeviceActionCallBack(int value)
	{
		UnityEngine.Debug.Log("ControlSetDeviceActionCallBack : " + value);
	}

	public void AppManager()
	{
		ToBService.UPvr_ControlAPPManger(PBS_PackageControlEnum.PACKAGE_SILENCE_UNINSTALL, "com.pico.ipd.test", AppManagerCallBack);
	}

	private void AppManagerCallBack(int value)
	{
		UnityEngine.Debug.Log("AppManagerCallBack : " + value);
	}
}
namespace Pvr_UnitySDKAPI
{
	public enum GlobalIntConfigs
	{
		EYE_TEXTURE_RESOLUTION0,
		EYE_TEXTURE_RESOLUTION1,
		SEENSOR_COUNT,
		ABILITY6DOF,
		PLATFORM_TYPE,
		TRACKING_MODE,
		LOG_LEVEL,
		ENBLE_HAND6DOF_BY_HEAD,
		ENBLE_6DOF_GLOBAL_TRACKING,
		TARGET_FRAME_RATE,
		iShowFPS,
		SensorMode,
		LOGICFLOW,
		EYE_TEXTURE_RES_HIGH,
		EYE_TEXTURE_RES_NORMAL,
		iCtrlModelLoadingPri,
		iPhoneHMDModeEnabled,
		isEnableBoundary,
		Enable_Activity_Rotation,
		GetDisplay_Orientation,
		GetWaitFrameNum,
		GetResetFrameNum,
		EnableFFRBYSYS,
		RotControllerMode
	}
	public enum GlobalFloatConfigs
	{
		IPD,
		VFOV,
		HFOV,
		NECK_MODEL_X,
		NECK_MODEL_Y,
		NECK_MODEL_Z,
		DISPLAY_REFRESH_RATE
	}
	public enum RenderTextureAntiAliasing
	{
		X_1 = 1,
		X_2 = 2,
		X_4 = 4,
		X_8 = 8
	}
	public enum PlatForm
	{
		Android = 1,
		IOS,
		Win,
		Notsupport
	}
	public enum RenderTextureDepth
	{
		BD_0 = 0,
		BD_16 = 16,
		BD_24 = 24
	}
	public enum RenderTextureLevel
	{
		Normal,
		High
	}
	public enum Sensorindex
	{
		Default,
		FirstSensor,
		SecondSensor
	}
	public enum Eye
	{
		LeftEye,
		RightEye,
		BothEye
	}
	public enum ResUtilsType
	{
		TYPE_TEXTSIZE,
		TYPE_COLOR,
		TYPE_TEXT,
		TYPE_FONT,
		TYPE_VALUE,
		TYPE_DRAWABLE,
		TYPE_OBJECT,
		TYPR_OBJECTARRAY
	}
	public enum TrackingOrigin
	{
		EyeLevel,
		FloorLevel,
		StageLevel
	}
	public enum EFoveationLevel
	{
		Low,
		Med,
		High,
		Top_High
	}
	public enum StereoRenderingPathPico
	{
		MultiPass,
		SinglePass
	}
	public enum pvrEyePoseStatus
	{
		kGazePointValid = 1,
		kGazeVectorValid = 2,
		kEyeOpennessValid = 4,
		kEyePupilDilationValid = 8,
		kEyePositionGuideValid = 0x10
	}
	public enum TrackingMode
	{
		PVR_TRACKING_MODE_ROTATION = 1,
		PVR_TRACKING_MODE_POSITION = 2,
		PVR_TRACKING_MODE_EYE = 4
	}
	public struct EyeTrackingData
	{
		public int leftEyePoseStatus;

		public int rightEyePoseStatus;

		public int combinedEyePoseStatus;

		public Vector3 leftEyeGazePoint;

		public Vector3 rightEyeGazePoint;

		public Vector3 combinedEyeGazePoint;

		public Vector3 leftEyeGazeVector;

		public Vector3 rightEyeGazeVector;

		public Vector3 combinedEyeGazeVector;

		public float leftEyeOpenness;

		public float rightEyeOpenness;

		public float leftEyePupilDilation;

		public float rightEyePupilDilation;

		public Vector3 leftEyePositionGuide;

		public Vector3 rightEyePositionGuide;

		public Vector3 foveatedGazeDirection;

		public int foveatedGazeTrackingState;

		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
		public byte[] reserved;
	}
	public struct EyeTrackingGazeRay
	{
		public Vector3 Direction;

		public bool IsValid;

		public Vector3 Origin;
	}
	public struct EyeDeviceInfo
	{
		public ViewFrustum targetFrustumLeft;

		public ViewFrustum targetFrustumRight;
	}
	public struct ViewFrustum
	{
		public float left;

		public float right;

		public float top;

		public float bottom;

		public float near;

		public float far;
	}
	public struct EyeSetting
	{
		public Transform eyelocalPosition;

		public Rect eyeRect;

		public float eyeFov;

		public float eyeAspect;

		public Matrix4x4 eyeProjectionMatrix;

		public Shader eyeShader;
	}
	public struct Sensor
	{
		public const string LibFileName = "Pvr_UnitySDK";

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_Enable6DofModule(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_OptionalResetSensor(int index, int resetRot, int resetPos);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_Init(int index);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_StartSensor(int index);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_StopSensor(int index);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_ResetSensor(int index);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_ResetSensorAll(int index);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetSensorState(int index, ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetMainSensorState(ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz, ref float vfov, ref float hfov, ref int viewNumber);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetPsensorState();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetHmdPSensorStatus();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetSensorGyroscope(int index, ref float x, ref float y, ref float z);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetSensorMagnet(int index, ref float x, ref float y, ref float z);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_Get6DofSensorQualityStatus();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_Get6DofSafePanelFlag();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetReinPosition(float x, float y, float z, float w, float px, float py, float pz, int hand, bool valid, int key);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_SetTrackingOriginType(TrackingOrigin trackingOriginType);

		public static bool UPvr_Pvr_Get6DofSafePanelFlag()
		{
			return Pvr_Get6DofSafePanelFlag();
		}

		public static int UPvr_Init(int index)
		{
			return Pvr_Init(index);
		}

		public static void UPvr_InitPsensor()
		{
			Pvr_InitPsensor();
		}

		public static int UPvr_GetPsensorState()
		{
			int res = -1;
			int configsenum = 4;
			Render.UPvr_GetIntConfig(configsenum, ref res);
			if (res == 1)
			{
				return Pvr_GetPsensorState();
			}
			int num = Pvr_GetAndroidPsensorState();
			if (num != 0 && num != -1)
			{
				num = 1;
			}
			return num;
		}

		public static int UPvr_GetPSensorStatus()
		{
			return Pvr_GetHmdPSensorStatus();
		}

		public static void UPvr_UnregisterPsensor()
		{
			Pvr_UnregisterPsensor();
		}

		public static int UPvr_StartSensor(int index)
		{
			return Pvr_StartSensor(index);
		}

		public static int UPvr_StopSensor(int index)
		{
			return Pvr_StopSensor(index);
		}

		public static int UPvr_ResetSensor(int index)
		{
			Pvr_UnitySDKManager.SDK.resetBasePos = default(Vector3);
			return Pvr_ResetSensor(index);
		}

		public static int UPvr_OptionalResetSensor(int index, int resetRot, int resetPos)
		{
			return Pvr_OptionalResetSensor(index, resetRot, resetPos);
		}

		public static int UPvr_GetSensorState(int index, ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz)
		{
			return Pvr_GetSensorState(index, ref x, ref y, ref z, ref w, ref px, ref py, ref pz);
		}

		public static int UPvr_GetMainSensorState(ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz, ref float vfov, ref float hfov, ref int viewNumber)
		{
			return Pvr_GetMainSensorState(ref x, ref y, ref z, ref w, ref px, ref py, ref pz, ref vfov, ref hfov, ref viewNumber);
		}

		public static int UPvr_GetSensorGyroscope(int index, ref float x, ref float y, ref float z)
		{
			return Pvr_GetSensorGyroscope(index, ref x, ref y, ref z);
		}

		public static int UPvr_GetSensorMagnet(int index, ref float x, ref float y, ref float z)
		{
			return Pvr_GetSensorMagnet(index, ref x, ref y, ref z);
		}

		public static int UPvr_Get6DofSensorQualityStatus()
		{
			return Pvr_Get6DofSensorQualityStatus();
		}

		public static int UPvr_Enable6DofModule(bool enable)
		{
			return Pvr_Enable6DofModule(enable);
		}

		public static void Pvr_InitPsensor()
		{
			try
			{
				System.UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaSysActivityClass, "initPsensor", Pvr_UnitySDKRender.Instance.activity);
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
		}

		public static bool Pvr_IsHead6dofReset()
		{
			int res = 0;
			Render.UPvr_GetIntConfig(17, ref res);
			if (res > 0)
			{
				return false;
			}
			bool result = false;
			try
			{
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaSysActivityClass, "isHead6dofReset", Pvr_UnitySDKRender.Instance.activity);
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
			return result;
		}

		public static int Pvr_GetAndroidPsensorState()
		{
			int result = -1;
			try
			{
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaSysActivityClass, "getPsensorState");
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
			return result;
		}

		public static void Pvr_UnregisterPsensor()
		{
			try
			{
				System.UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaSysActivityClass, "unregisterListener");
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
		}

		public static int UPvr_ResetSensorAll(int index)
		{
			return Pvr_ResetSensorAll(index);
		}

		public static void UPvr_SetReinPosition(float x, float y, float z, float w, float px, float py, float pz, int hand, bool valid, int key)
		{
			if (PLOG.logLevel > 2)
			{
				PLOG.D("PvrLog UPvr_SetReinPosition" + x + y + z + w + px + py + pz + hand + valid + key);
			}
			Pvr_SetReinPosition(x, y, z, w, px, py, pz, hand, valid, key);
		}

		public static bool UPvr_SetTrackingOriginType(TrackingOrigin trackingOriginType)
		{
			bool flag = true;
			return Pvr_SetTrackingOriginType(trackingOriginType);
		}
	}
	public struct Render
	{
		public const string LibFileName = "Pvr_UnitySDK";

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_ChangeScreenParameters(string model, int width, int height, double xppi, double yppi, double densityDpi);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_SetRatio(float midH, float midV);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_SetPupillaryPoint(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr Pvr_GetSupportHMDTypes();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetCurrentHMDType([MarshalAs(UnmanagedType.LPStr)] string type);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetIntConfig(int configsenum, ref int res);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetFloatConfig(int configsenum, ref float res);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetupLayerData(int layerIndex, int sideMask, int textureId, int textureType, int layerFlags, float[] colorScaleAndOffset);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetupLayerCoords(int layerIndex, int sideMask, float[] lowerLeft, float[] lowerRight, float[] upperLeft, float[] upperRight);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetOverlayModelViewMatrix(int overlayType, int overlayShape, int texId, int eyeSide, int layerIndex, bool isHeadLocked, int layerFlags, float[] mvMatrix, float[] modelS, float[] modelR, float[] modelT, float[] cameraR, float[] cameraT, float[] colorScaleAndOffset);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_EnableFoveation(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetFoveationParameters(int textureId, int previousId, float focalPointX, float focalPointY, float foveationGainX, float foveationGainY, float foveationArea, float foveationMinimum);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetFoveationResource(int textureId, int previousId, float focalPointX, float focalPointY);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetFoveationParameters2(float foveationGainX, float foveationGainY, float foveationArea, float foveationMinimum);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetFoveationLevel(EFoveationLevel level);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern EFoveationLevel Pvr_GetFoveationLevel();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_GetIntSysProc(string property, ref int res);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetColorspaceType(int colorspaceType);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetCastingColorspaceType(int colorspaceType);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr Pvr_CreateLayerAndroidSurface(int layerType, int layerIndex);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr Pvr_GetLayerAndroidSurface(int layerType, int layerIndex);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetMonoMode(bool openMono);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_GetStencilMesh(int eye, ref int vertexCount, ref int triangleCount, ref IntPtr vertexData, ref IntPtr indexData);

		public static void UPvr_ChangeScreenParameters(string model, int width, int height, double xppi, double yppi, double densityDpi)
		{
			Pvr_ChangeScreenParameters(model, width, height, xppi, yppi, densityDpi);
		}

		public static int UPvr_SetRatio(float midH, float midV)
		{
			return Pvr_SetRatio(midH, midV);
		}

		public static void UPvr_EnableFoveation(bool enable)
		{
			if (Pvr_UnitySDKManager.SDK.SystemFFRLevel != -1 || Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel != -1)
			{
				enable = true;
			}
			Pvr_EnableFoveation(enable);
		}

		[Obsolete("This API will be removed in later versions")]
		public static void UPvr_SetFoveationParameters(int textureId, int previousId, float focalPointX, float focalPointY, float foveationGainX, float foveationGainY, float foveationArea, float foveationMinimum)
		{
			Pvr_SetFoveationParameters(textureId, previousId, focalPointX, focalPointY, foveationGainX, foveationGainY, foveationArea, foveationMinimum);
		}

		public static void UPvr_SetFoveationResource(int textureId, int previousId, float focalPointX, float focalPointY)
		{
			Pvr_SetFoveationResource(textureId, previousId, focalPointX, focalPointY);
		}

		public static void SetFoveatedRenderingLevel(EFoveationLevel level)
		{
			if (Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel != -1)
			{
				Pvr_SetFoveationLevel((EFoveationLevel)Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel);
			}
			else if (Pvr_UnitySDKManager.SDK.SystemFFRLevel != -1)
			{
				Pvr_SetFoveationLevel((EFoveationLevel)Pvr_UnitySDKManager.SDK.SystemFFRLevel);
			}
			else
			{
				Pvr_SetFoveationLevel(level);
			}
		}

		public static EFoveationLevel GetFoveatedRenderingLevel()
		{
			return Pvr_GetFoveationLevel();
		}

		public static void SetFoveatedRenderingParameters(Vector2 ffrGainValue, float ffrAreaValue, float ffrMinimumValue)
		{
			if (Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel != -1)
			{
				Pvr_SetFoveationLevel((EFoveationLevel)Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel);
			}
			else if (Pvr_UnitySDKManager.SDK.SystemFFRLevel != -1)
			{
				Pvr_SetFoveationLevel((EFoveationLevel)Pvr_UnitySDKManager.SDK.SystemFFRLevel);
			}
			else
			{
				Pvr_SetFoveationParameters2(ffrGainValue.x, ffrGainValue.y, ffrAreaValue, ffrMinimumValue);
			}
		}

		public static bool UPvr_GetIntSysProc(string property, ref int res)
		{
			bool flag = false;
			return Pvr_GetIntSysProc(property, ref res);
		}

		public static int UPvr_GetIntConfig(int configsenum, ref int res)
		{
			return Pvr_GetIntConfig(configsenum, ref res);
		}

		public static int UPvr_GetFloatConfig(int configsenum, ref float res)
		{
			return Pvr_GetFloatConfig(configsenum, ref res);
		}

		public static string UPvr_GetSupportHMDTypes()
		{
			IntPtr intPtr = Pvr_GetSupportHMDTypes();
			if (intPtr != IntPtr.Zero)
			{
				return Marshal.PtrToStringAnsi(intPtr);
			}
			return null;
		}

		public static void UPvr_SetCurrentHMDType(string type)
		{
			Pvr_SetCurrentHMDType(type);
		}

		public static void UPvr_SetupLayerData(int layerIndex, int sideMask, int textureId, int textureType, int layerFlags, Vector4 colorScale, Vector4 colorOffset)
		{
			Pvr_SetupLayerData(layerIndex, sideMask, textureId, textureType, layerFlags, new float[8] { colorScale.x, colorScale.y, colorScale.z, colorScale.w, colorOffset.x, colorOffset.y, colorOffset.z, colorOffset.w });
		}

		public static void UPvr_SetupLayerCoords(int layerIndex, int sideMask, float[] lowerLeft, float[] lowerRight, float[] upperLeft, float[] upperRight)
		{
			Pvr_SetupLayerCoords(layerIndex, sideMask, lowerLeft, lowerRight, upperLeft, upperRight);
		}

		public static void UPvr_SetOverlayModelViewMatrix(int overlayType, int overlayShape, int texId, int eyeSide, int layerIndex, bool isHeadLocked, int layerFlags, Matrix4x4 mvMatrix, Vector3 modelS, Quaternion modelR, Vector3 modelT, Quaternion cameraR, Vector3 cameraT, Vector4 colorScale, Vector4 colorOffset)
		{
			Pvr_SetOverlayModelViewMatrix(overlayType, overlayShape, texId, eyeSide, layerIndex, isHeadLocked, layerFlags, new float[16]
			{
				mvMatrix.m00, mvMatrix.m01, mvMatrix.m02, mvMatrix.m03, mvMatrix.m10, mvMatrix.m11, mvMatrix.m12, mvMatrix.m13, mvMatrix.m20, mvMatrix.m21,
				mvMatrix.m22, mvMatrix.m23, mvMatrix.m30, mvMatrix.m31, mvMatrix.m32, mvMatrix.m33
			}, new float[3] { modelS.x, modelS.y, modelS.z }, new float[4] { modelR.x, modelR.y, modelR.z, modelR.w }, new float[3] { modelT.x, modelT.y, modelT.z }, new float[4] { cameraR.x, cameraR.y, cameraR.z, cameraR.w }, new float[3] { cameraT.x, cameraT.y, cameraT.z }, new float[8] { colorScale.x, colorScale.y, colorScale.z, colorScale.w, colorOffset.x, colorOffset.y, colorOffset.z, colorOffset.w });
		}

		public static void UPvr_SetColorspaceType(int colorspaceType)
		{
			Pvr_SetColorspaceType(colorspaceType);
		}

		public static void UPvr_SetCastingColorspaceType(int colorspaceType)
		{
			Pvr_SetCastingColorspaceType(colorspaceType);
		}

		public static IntPtr UPvr_CreateLayerAndroidSurface(int layerType, int layerIndex)
		{
			return Pvr_CreateLayerAndroidSurface(layerType, layerIndex);
		}

		public static IntPtr UPvr_GetLayerAndroidSurface(int layerType, int layerIndex)
		{
			return Pvr_GetLayerAndroidSurface(layerType, layerIndex);
		}

		public static void UPvr_SetMonoMode(bool openMono)
		{
			Pvr_SetMonoMode(openMono);
		}

		public static void UPvr_GetStencilMesh(int eye, ref int vertexCount, ref int triangleCount, ref IntPtr vertexDataPtr, ref IntPtr indexDataPtr)
		{
			Pvr_GetStencilMesh(eye, ref vertexCount, ref triangleCount, ref vertexDataPtr, ref indexDataPtr);
		}
	}
	public struct System
	{
		public const string LibFileName = "Pvr_UnitySDK";

		public const string UnitySDKVersion = "2.8.9.12";

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_SetInitActivity(IntPtr activity, IntPtr vrActivityClass);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr Pvr_GetSDKVersion();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int Pvr_GetHmdHardwareVersion();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr Pvr_GetHmdFirmwareVersion();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr Pvr_GetHmdSerialNumber();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int PVR_GetHmdBatteryStatus();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern float PVR_GetHmdBatteryTemperature();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int PVR_SetHmdAudioStatus(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_GetEyeTrackingData(ref int leftEyePoseStatus, ref int rightEyePoseStatus, ref int combinedEyePoseStatus, ref float leftEyeGazePointX, ref float leftEyeGazePointY, ref float leftEyeGazePointZ, ref float rightEyeGazePointX, ref float rightEyeGazePointY, ref float rightEyeGazePointZ, ref float combinedEyeGazePointX, ref float combinedEyeGazePointY, ref float combinedEyeGazePointZ, ref float leftEyeGazeVectorX, ref float leftEyeGazeVectorY, ref float leftEyeGazeVectorZ, ref float rightEyeGazeVectorX, ref float rightEyeGazeVectorY, ref float rightEyeGazeVectorZ, ref float combinedEyeGazeVectorX, ref float combinedEyeGazeVectorY, ref float combinedEyeGazeVectorZ, ref float leftEyeOpenness, ref float rightEyeOpenness, ref float leftEyePupilDilation, ref float rightEyePupilDilation, ref float leftEyePositionGuideX, ref float leftEyePositionGuideY, ref float leftEyePositionGuideZ, ref float rightEyePositionGuideX, ref float rightEyePositionGuideY, ref float rightEyePositionGuideZ, ref float foveatedGazeDirectionX, ref float foveatedGazeDirectionY, ref float foveatedGazeDirectionZ, ref int foveatedGazeTrackingState);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_SetTrackingMode(int trackingMode);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int Pvr_GetTrackingMode();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr GetRenderEventFunc();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void UnityEventData(long data);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_EnableSinglePass(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_SetAntiAliasing(int antiAliasing);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_SinglePassBeforeForwardOpaque();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_SetCurrentRenderTexture(uint textureId);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_SetSinglePassDepthBufferWidthHeight(int width, int height);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int PVR_setPerformanceLevels(int cpuLevel, int gpuLevel);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_SetIPD(float distance);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern float Pvr_GetIPD();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_SetTrackingIPDEnabled(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_GetTrackingIPDEnabled();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_GetEyeTrackingAutoIPD(ref float autoIPD);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int PVR_GetHmdAudioStatus();

		public static bool UPvr_CallStaticMethod<T>(ref T result, AndroidJavaClass jclass, string name, params object[] args)
		{
			try
			{
				result = jclass.CallStatic<T>(name, args);
				return true;
			}
			catch (AndroidJavaException ex)
			{
				PLOG.E("Exception calling static method " + name + ": " + ex);
				return false;
			}
		}

		public static bool UPvr_CallStaticMethod(AndroidJavaObject jobj, string name, params object[] args)
		{
			try
			{
				jobj.CallStatic(name, args);
				return true;
			}
			catch (AndroidJavaException ex)
			{
				PLOG.E("CallStaticMethod  Exception calling activity method " + name + ": " + ex);
				return false;
			}
		}

		public static bool UPvr_CallMethod<T>(ref T result, AndroidJavaObject jobj, string name, params object[] args)
		{
			try
			{
				result = jobj.Call<T>(name, args);
				return true;
			}
			catch (AndroidJavaException ex)
			{
				PLOG.E("Exception calling activity method " + name + ": " + ex);
				return false;
			}
		}

		public static bool UPvr_CallMethod(AndroidJavaObject jobj, string name, params object[] args)
		{
			try
			{
				jobj.Call(name, args);
				return true;
			}
			catch (AndroidJavaException ex)
			{
				PLOG.E(" Exception calling activity method " + name + ": " + ex);
				return false;
			}
		}

		public static string UPvr_GetSDKVersion()
		{
			IntPtr intPtr = Pvr_GetSDKVersion();
			if (intPtr != IntPtr.Zero)
			{
				return Marshal.PtrToStringAnsi(intPtr);
			}
			return string.Empty;
		}

		public static string UPvr_GetUnitySDKVersion()
		{
			return "2.8.9.12";
		}

		public static string UPvr_GetDeviceMode()
		{
			string empty = string.Empty;
			return SystemInfo.deviceModel;
		}

		public static string UPvr_GetDeviceModel()
		{
			return SystemInfo.deviceModel;
		}

		public static string UPvr_GetDeviceSN()
		{
			string result = "UNKONWN";
			UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaSysActivityClass, "getDeviceSN");
			return result;
		}

		public static AndroidJavaObject UPvr_GetCurrentActivity()
		{
			AndroidJavaObject androidJavaObject = null;
			AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
			return androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
		}

		public static bool UPvr_SetMonoPresentation()
		{
			bool flag = false;
			return UPvr_CallMethod(UPvr_GetCurrentActivity(), "Pvr_setMonoPresentation");
		}

		public static bool UPvr_IsPresentationExisted()
		{
			bool flag = false;
			bool result = false;
			return UPvr_CallMethod(ref result, UPvr_GetCurrentActivity(), "Pvr_isPresentationExisted") && result;
		}

		public static bool UPvr_GetMainActivityPauseStatus()
		{
			bool flag = false;
			bool result = false;
			return UPvr_CallMethod(ref result, UPvr_GetCurrentActivity(), "Pvr_getMainActivityPauseStatus") && result;
		}

		public static void UPvr_Sleep()
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaSysActivityClass, "Pvr_Sleep");
		}

		public static bool UPvr_StartHomeKeyReceiver(string startreceivre)
		{
			try
			{
				if (Pvr_UnitySDKRender.Instance != null)
				{
					UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityLongReceiver, "Pvr_StartReceiver", Pvr_UnitySDKRender.Instance.activity, startreceivre);
					PLOG.I("Start home key Receiver");
					return true;
				}
			}
			catch (Exception ex)
			{
				PLOG.E("Start home key  Receiver  Error :" + ex.ToString());
				return false;
			}
			return true;
		}

		public static bool UPvr_StopHomeKeyReceiver()
		{
			try
			{
				if (Pvr_UnitySDKRender.Instance != null)
				{
					UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityLongReceiver, "Pvr_StopReceiver", Pvr_UnitySDKRender.Instance.activity);
					PLOG.I("Stop home key Receiver");
					return true;
				}
			}
			catch (Exception ex)
			{
				PLOG.E("Stop home key Receiver Error :" + ex.ToString());
				return false;
			}
			return true;
		}

		public static void UPvr_StartVRModel()
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClass, "startVRModel");
		}

		public static void UPvr_RemovePlatformLogo()
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClass, "removePlatformLogo");
		}

		public static void UPvr_ShowPlatformLogo()
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClass, "showPlatformLogo");
		}

		public static bool UPvr_IsPicoActivity()
		{
			bool flag = false;
			bool result = false;
			return UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "isPicoActivity", UPvr_GetCurrentActivity()) && result;
		}

		public static void UPvr_StopVRModel()
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClass, "stopVRModel");
		}

		public static string UPvr_GetCountryCode()
		{
			string result = string.Empty;
			UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getCountryCode", UPvr_GetCurrentActivity());
			return result;
		}

		public static bool UPvr_SetIPD(float distance)
		{
			bool flag = false;
			flag = Pvr_SetIPD(distance);
			if (flag)
			{
				for (int i = 0; i < Pvr_UnitySDKEyeManager.Instance.Eyes.Length; i++)
				{
					Pvr_UnitySDKEyeManager.Instance.Eyes[i].RefreshCameraPosition(distance);
				}
			}
			return flag;
		}

		public static float UPvr_GetIPD()
		{
			float num = Pvr_GetIPD();
			UnityEngine.Debug.Log("DISFT IPD:" + num);
			return num;
		}

		public static bool UPvr_SetTrackingIPDEnabled(bool enable)
		{
			return Pvr_SetTrackingIPDEnabled(enable);
		}

		public static bool UPvr_GetTrackingIPDEnabled()
		{
			return Pvr_GetTrackingIPDEnabled();
		}

		public static bool UPvr_GetEyeTrackingAutoIPD(ref float autoipd)
		{
			return Pvr_GetEyeTrackingAutoIPD(ref autoipd);
		}

		public static void UPvr_UnityEventData(long data)
		{
			UnityEventData(data);
		}

		public static long UPvr_GetEyeBufferData(int id)
		{
			return ((long)Pvr_UnitySDKRender.Instance.RenderviewNumber << 32) | id;
		}

		public static bool UPvr_checkDevice(string packagename)
		{
			bool result = false;
			UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "checkDevice", packagename, UPvr_GetCurrentActivity());
			return result;
		}

		public static int UPvr_GetHmdHardwareVersion()
		{
			return Pvr_GetHmdHardwareVersion();
		}

		public static string UPvr_GetHmdFirmwareVersion()
		{
			IntPtr intPtr = Pvr_GetHmdFirmwareVersion();
			if (intPtr != IntPtr.Zero)
			{
				return Marshal.PtrToStringAnsi(intPtr);
			}
			return string.Empty;
		}

		public static string UPvr_GetHmdSerialNumber()
		{
			IntPtr intPtr = Pvr_GetHmdSerialNumber();
			if (intPtr != IntPtr.Zero)
			{
				return Marshal.PtrToStringAnsi(intPtr);
			}
			return string.Empty;
		}

		public static int UPvr_GetHmdBatteryStatus()
		{
			return PVR_GetHmdBatteryStatus();
		}

		public static float UPvr_GetHmdBatteryTemperature()
		{
			return PVR_GetHmdBatteryTemperature();
		}

		public static int UPvr_SetHmdAudioStatus(bool enable)
		{
			return PVR_SetHmdAudioStatus(enable);
		}

		public static int UPvr_GetTrackingMode()
		{
			int num = 0;
			return Pvr_GetTrackingMode();
		}

		public static bool UPvr_setTrackingMode(int trackingMode)
		{
			return Pvr_SetTrackingMode(trackingMode);
		}

		public static bool UPvr_getEyeTrackingData(ref EyeTrackingData trackingData)
		{
			if (!Pvr_UnitySDKEyeManager.supportEyeTracking)
			{
				PLOG.E("The device is not supported");
				return false;
			}
			if (!Pvr_UnitySDKEyeManager.Instance.EyeTracking)
			{
				PLOG.E("Please Enable \"Pvr_UnitySDK/Head/Pvr_UnitySDKEyeManager.cs/EyeTracking\"option first.");
				return false;
			}
			bool result = Pvr_GetEyeTrackingData(ref trackingData.leftEyePoseStatus, ref trackingData.rightEyePoseStatus, ref trackingData.combinedEyePoseStatus, ref trackingData.leftEyeGazePoint.x, ref trackingData.leftEyeGazePoint.y, ref trackingData.leftEyeGazePoint.z, ref trackingData.rightEyeGazePoint.x, ref trackingData.rightEyeGazePoint.y, ref trackingData.rightEyeGazePoint.z, ref trackingData.combinedEyeGazePoint.x, ref trackingData.combinedEyeGazePoint.y, ref trackingData.combinedEyeGazePoint.z, ref trackingData.leftEyeGazeVector.x, ref trackingData.leftEyeGazeVector.y, ref trackingData.leftEyeGazeVector.z, ref trackingData.rightEyeGazeVector.x, ref trackingData.rightEyeGazeVector.y, ref trackingData.rightEyeGazeVector.z, ref trackingData.combinedEyeGazeVector.x, ref trackingData.combinedEyeGazeVector.y, ref trackingData.combinedEyeGazeVector.z, ref trackingData.leftEyeOpenness, ref trackingData.rightEyeOpenness, ref trackingData.leftEyePupilDilation, ref trackingData.rightEyePupilDilation, ref trackingData.leftEyePositionGuide.x, ref trackingData.leftEyePositionGuide.y, ref trackingData.leftEyePositionGuide.z, ref trackingData.rightEyePositionGuide.x, ref trackingData.rightEyePositionGuide.y, ref trackingData.rightEyePositionGuide.z, ref trackingData.foveatedGazeDirection.x, ref trackingData.foveatedGazeDirection.y, ref trackingData.foveatedGazeDirection.z, ref trackingData.foveatedGazeTrackingState);
			trackingData.leftEyeGazeVector.z = 0f - trackingData.leftEyeGazeVector.z;
			trackingData.rightEyeGazeVector.z = 0f - trackingData.rightEyeGazeVector.z;
			trackingData.combinedEyeGazeVector.z = 0f - trackingData.combinedEyeGazeVector.z;
			trackingData.leftEyeGazePoint.z = 0f - trackingData.leftEyeGazePoint.z;
			trackingData.rightEyeGazePoint.z = 0f - trackingData.rightEyeGazePoint.z;
			trackingData.combinedEyeGazePoint.z = 0f - trackingData.combinedEyeGazePoint.z;
			trackingData.foveatedGazeDirection.z = 0f - trackingData.foveatedGazeDirection.z;
			return result;
		}

		public static bool UPvr_getEyeTrackingGazeRay(ref EyeTrackingGazeRay gazeRay)
		{
			if (!Pvr_UnitySDKEyeManager.supportEyeTracking)
			{
				PLOG.E("The device is not supported");
				return false;
			}
			if (!Pvr_UnitySDKEyeManager.Instance.EyeTracking)
			{
				PLOG.E("Please Enable \"Pvr_UnitySDK/Head/Pvr_UnitySDKEyeManager.cs/EyeTracking\"option first.");
				return false;
			}
			EyeTrackingData trackingData = default(EyeTrackingData);
			bool flag = UPvr_getEyeTrackingData(ref trackingData);
			gazeRay.IsValid = ((uint)trackingData.combinedEyePoseStatus & (true ? 1u : 0u)) != 0 && (trackingData.combinedEyePoseStatus & 2) != 0;
			if (gazeRay.IsValid)
			{
				gazeRay.Direction = trackingData.combinedEyeGazeVector;
				gazeRay.Origin = trackingData.combinedEyeGazePoint;
				gazeRay.Origin = Pvr_UnitySDKSensor.Instance.HeadPose.Matrix.MultiplyPoint(gazeRay.Origin);
				gazeRay.Direction = Pvr_UnitySDKSensor.Instance.HeadPose.Matrix.MultiplyVector(gazeRay.Direction);
				return true;
			}
			return false;
		}

		public static bool UPvr_getEyeTrackingGazeRayWorld(ref EyeTrackingGazeRay gazeRay)
		{
			if (!Pvr_UnitySDKEyeManager.supportEyeTracking)
			{
				PLOG.E("The device is not supported");
				return false;
			}
			if (!Pvr_UnitySDKEyeManager.Instance.EyeTracking)
			{
				PLOG.E("Please Enable \"Pvr_UnitySDK/Head/Pvr_UnitySDKEyeManager.cs/EyeTracking\"option first.");
				return false;
			}
			Transform transform = Pvr_UnitySDKEyeManager.Instance.transform;
			Matrix4x4 matrix4x = Matrix4x4.TRS(transform.position, transform.rotation, Vector3.one);
			EyeTrackingData trackingData = default(EyeTrackingData);
			bool flag = UPvr_getEyeTrackingData(ref trackingData);
			gazeRay.IsValid = ((uint)trackingData.combinedEyePoseStatus & (true ? 1u : 0u)) != 0 && (trackingData.combinedEyePoseStatus & 2) != 0;
			if (gazeRay.IsValid)
			{
				gazeRay.Direction = trackingData.combinedEyeGazeVector;
				gazeRay.Origin = trackingData.combinedEyeGazePoint;
				gazeRay.Origin = matrix4x.MultiplyPoint(gazeRay.Origin);
				gazeRay.Direction = matrix4x.MultiplyVector(gazeRay.Direction);
				return true;
			}
			return false;
		}

		public static Vector3 UPvr_getEyeTrackingPos()
		{
			if (!Pvr_UnitySDKEyeManager.supportEyeTracking)
			{
				PLOG.E("The device is not supported");
				return Vector3.zero;
			}
			if (!Pvr_UnitySDKEyeManager.Instance.EyeTracking)
			{
				PLOG.E("Please Enable \"Pvr_UnitySDK/Head/Pvr_UnitySDKEyeManager.cs/EyeTracking\"option first.");
				return Vector3.zero;
			}
			return Pvr_UnitySDKEyeManager.Instance.GetEyeTrackingPos();
		}

		public static int UPvr_GetPhoneScreenBrightness()
		{
			int result = 0;
			UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClientClass, "Pvr_GetScreen_Brightness", UPvr_GetCurrentActivity());
			return result;
		}

		public static void UPvr_SetPhoneScreenBrightness(int level)
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClientClass, "Pvr_setAPPScreen_Brightness", UPvr_GetCurrentActivity(), level);
		}

		public static bool UPvr_IsPicoDefaultActivity()
		{
			using (AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer"))
			{
				using AndroidJavaObject androidJavaObject = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
				string text = androidJavaObject.Call<string>("getLocalClassName", Array.Empty<object>());
				if (text == "com.unity3d.player.UnityPlayerNativeActivityPico")
				{
					return true;
				}
			}
			return false;
		}

		public static bool UPvr_EnableSinglePass(bool enable)
		{
			return Pvr_EnableSinglePass(enable);
		}

		public static void UPvr_SetAntiAliasing(int antiAliasing)
		{
			Pvr_SetAntiAliasing(antiAliasing);
		}

		public static void UPvr_SinglePassBeforeForwardOpaque()
		{
			Pvr_SinglePassBeforeForwardOpaque();
		}

		public static void UPvr_SetCurrentRenderTexture(uint textureId)
		{
			Pvr_SetCurrentRenderTexture(textureId);
		}

		public static bool UPvr_SetSinglePassDepthBufferWidthHeight(int width, int height)
		{
			bool flag = false;
			return Pvr_SetSinglePassDepthBufferWidthHeight(width, height);
		}

		public static int UPVR_setPerformanceLevels(int cpuLevel, int gpuLevel)
		{
			int num = -1;
			return PVR_setPerformanceLevels(cpuLevel, gpuLevel);
		}

		public static int UPvr_GetColorRes(string name)
		{
			int result = -1;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getColorRes", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetColorResError :" + ex.ToString());
			}
			return result;
		}

		public static int UPvr_GetConfigInt(string name)
		{
			int result = -1;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getConfigInt", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetConfigIntError :" + ex.ToString());
			}
			return result;
		}

		public static string UPvr_GetConfigString(string name)
		{
			string result = string.Empty;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getConfigString", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetConfigStringError :" + ex.ToString());
			}
			return result;
		}

		public static string UPvr_GetDrawableLocation(string name)
		{
			string result = string.Empty;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getDrawableLocation", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetDrawableLocationError :" + ex.ToString());
			}
			return result;
		}

		public static int UPvr_GetTextSize(string name)
		{
			int result = -1;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getTextSize", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetTextSizeError :" + ex.ToString());
			}
			return result;
		}

		public static string UPvr_GetLangString(string name)
		{
			string result = string.Empty;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getLangString", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetLangStringError :" + ex.ToString());
			}
			return result;
		}

		public static string UPvr_GetStringValue(string id, int type)
		{
			string result = string.Empty;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getStringValue", id, type);
			}
			catch (Exception ex)
			{
				PLOG.E("GetStringValueError :" + ex.ToString());
			}
			return result;
		}

		public static int UPvr_GetIntValue(string id, int type)
		{
			int result = -1;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getIntValue", id, type);
			}
			catch (Exception ex)
			{
				PLOG.E("GetIntValueError :" + ex.ToString());
			}
			return result;
		}

		public static float UPvr_GetFloatValue(string id)
		{
			float result = -1f;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getFloatValue", id);
			}
			catch (Exception ex)
			{
				PLOG.E("GetFloatValueError :" + ex.ToString());
			}
			return result;
		}

		public static string UPvr_GetObjectOrArray(string id, int type)
		{
			string result = string.Empty;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getObjectOrArray", id, type);
			}
			catch (Exception ex)
			{
				PLOG.E("GetObjectOrArrayError :" + ex.ToString());
			}
			return result;
		}

		public static int UPvr_GetCharSpace(string id)
		{
			int result = -1;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getCharSpace", id);
			}
			catch (Exception ex)
			{
				PLOG.E("GetCharSpaceError :" + ex.ToString());
			}
			return result;
		}
	}
	public struct BoundarySystem
	{
		public enum BoundaryType
		{
			OuterBoundary,
			PlayArea
		}

		public struct BoundaryTestResult
		{
			public bool IsTriggering;

			public float ClosestDistance;

			public Vector3 ClosestPoint;

			public Vector3 ClosestPointNormal;
		}

		public enum BoundaryTrackingNode
		{
			HandLeft,
			HandRight,
			Head
		}

		public enum BoundaryTrackingState
		{
			PVR_NOREASON,
			PVRRELOCATION_IN_PROGRESS,
			PVRLOW_FEATURE_COUNT_ERROR,
			PVRLOW_LIGHT_ERROR,
			PVRBRIGHT_LIGHT_ERROR,
			PVRSTEREO_CAMERA_CALIBRATION_ERROR
		}

		public const string LibFileName = "Pvr_UnitySDK";

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern float Pvr_GetFloorHeight();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetSeeThroughState();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_BoundarySetSTBackground(bool value);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetTrackingState();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_GetFrameRateLimit();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_IsBoundaryEnable();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_BoundaryGetConfigured();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_BoundaryTestNode(int node, bool isPlayArea, ref bool isTriggering, ref float closestDistance, ref float px, ref float py, ref float pz, ref float nx, ref float ny, ref float nz);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_BoundaryTestPoint(float x, float y, float z, bool isPlayArea, ref bool isTriggering, ref float closestDistance, ref float px, ref float py, ref float pz, ref float nx, ref float ny, ref float nz);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_BoundaryGetGeometry(out IntPtr handle, bool isPlayArea);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_BoundaryGetDimensions(ref float x, ref float y, ref float z, bool isPlayArea);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_BoundaryGetEnabled();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_BoundarySetVisible(bool value);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_BoundaryGetVisible();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_EnableLWRP(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_SetViewportSize(int w, int h);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_BoundarySetSeeThroughVisible(bool value);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void PVR_SetCameraImageRect(int width, int height);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetGuardianSystemDisable(bool value);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetDialogState();

		public static float UPvr_GetFloorHeight()
		{
			float num = 0f;
			return Pvr_GetFloorHeight();
		}

		public static int UPvr_GetSeeThroughState()
		{
			int num = 0;
			return Pvr_GetSeeThroughState();
		}

		public static void UPvr_EnableSeeThroughManual(bool enable)
		{
			Pvr_BoundarySetSTBackground(enable);
		}

		public static BoundaryTrackingState UPvr_GetTrackingState()
		{
			BoundaryTrackingState boundaryTrackingState = BoundaryTrackingState.PVR_NOREASON;
			return (BoundaryTrackingState)Pvr_GetTrackingState();
		}

		public static bool UPvr_GetFrameRateLimit()
		{
			bool flag = false;
			return Pvr_GetFrameRateLimit();
		}

		public static bool UPvr_IsBoundaryEnable()
		{
			bool flag = false;
			return Pvr_IsBoundaryEnable();
		}

		public static bool UPvr_BoundaryGetConfigured()
		{
			bool flag = false;
			return Pvr_BoundaryGetConfigured();
		}

		public static BoundaryTestResult UPvr_BoundaryTestNode(BoundaryTrackingNode node, BoundaryType boundaryType)
		{
			BoundaryTestResult result = default(BoundaryTestResult);
			bool flag = Pvr_BoundaryTestNode((int)node, boundaryType == BoundaryType.PlayArea, ref result.IsTriggering, ref result.ClosestDistance, ref result.ClosestPoint.x, ref result.ClosestPoint.y, ref result.ClosestPoint.z, ref result.ClosestPointNormal.x, ref result.ClosestPointNormal.y, ref result.ClosestPointNormal.z);
			result.ClosestPoint.z = 0f - result.ClosestPoint.z;
			result.ClosestPointNormal.z = 0f - result.ClosestPointNormal.z;
			if (!flag)
			{
				UnityEngine.Debug.LogError($"UPvr_BoundaryTestNode({node}, {boundaryType}) API call failed!");
			}
			return result;
		}

		public static BoundaryTestResult UPvr_BoundaryTestPoint(Vector3 point, BoundaryType boundaryType)
		{
			BoundaryTestResult result = default(BoundaryTestResult);
			if (!Pvr_BoundaryTestPoint(point.x, point.y, 0f - point.z, boundaryType == BoundaryType.PlayArea, ref result.IsTriggering, ref result.ClosestDistance, ref result.ClosestPoint.x, ref result.ClosestPoint.y, ref result.ClosestPoint.z, ref result.ClosestPointNormal.x, ref result.ClosestPointNormal.y, ref result.ClosestPointNormal.z))
			{
				UnityEngine.Debug.LogError($"UPvr_BoundaryTestPoint({point}, {boundaryType}) API call failed!");
			}
			return result;
		}

		public static Vector3[] UPvr_BoundaryGetGeometry(BoundaryType boundaryType)
		{
			IntPtr handle = IntPtr.Zero;
			int num = Pvr_BoundaryGetGeometry(out handle, boundaryType == BoundaryType.PlayArea);
			if (num <= 0)
			{
				UnityEngine.Debug.LogError("Boundary geometry point count is " + num);
				return null;
			}
			int num2 = num * 3;
			float[] array = new float[num2];
			Marshal.Copy(handle, array, 0, num2);
			Vector3[] array2 = new Vector3[num];
			for (int i = 0; i < num; i++)
			{
				ref Vector3 reference = ref array2[i];
				reference = new Vector3
				{
					x = array[3 * i],
					y = array[3 * i + 1],
					z = 0f - array[3 * i + 2]
				};
			}
			return array2;
		}

		public static Vector3 UPvr_BoundaryGetDimensions(BoundaryType boundaryType)
		{
			float x = 0f;
			float y = 0f;
			float z = 0f;
			Pvr_BoundaryGetDimensions(ref x, ref y, ref z, boundaryType == BoundaryType.PlayArea);
			return new Vector3(x, y, z);
		}

		public static bool UPvr_BoundaryGetEnabled()
		{
			bool flag = false;
			return Pvr_BoundaryGetEnabled();
		}

		public static void UPvr_BoundarySetVisible(bool value)
		{
			Pvr_BoundarySetVisible(value);
		}

		public static bool UPvr_BoundaryGetVisible()
		{
			return Pvr_BoundaryGetVisible();
		}

		public static bool UPvr_EnableLWRP(bool enable)
		{
			return Pvr_EnableLWRP(enable);
		}

		public static bool UPvr_SetViewportSize(int width, int height)
		{
			return Pvr_SetViewportSize(width, height);
		}

		public static void UPvr_StartCameraFrame()
		{
			try
			{
				Pvr_UnitySDKPluginEvent.Issue(RenderEventType.StartCameraFrame);
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_StartCameraFrame :" + ex.ToString());
			}
		}

		public static void UPvr_StopCameraFrame()
		{
			try
			{
				Pvr_UnitySDKPluginEvent.Issue(RenderEventType.StopCameraFrame);
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_StopCameraFrame :" + ex.ToString());
			}
		}

		public static void UPvr_BoundaryGetSeeThroughData(int cameraIndex, RenderTexture renderTexture)
		{
			try
			{
				if (renderTexture.IsCreated())
				{
					long data = renderTexture.GetNativeTexturePtr().ToInt32();
					System.UPvr_UnityEventData(data);
					switch (cameraIndex)
					{
					case 0:
						Pvr_UnitySDKPluginEvent.Issue(RenderEventType.CameraFrameLeft);
						break;
					case 1:
						Pvr_UnitySDKPluginEvent.Issue(RenderEventType.CameraFrameRight);
						break;
					}
				}
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_BoundaryGetSeeThroughDataError :" + ex.ToString());
			}
		}

		public static void UPvr_BoundarySetCameraImageRect(int width, int height)
		{
			try
			{
				PVR_SetCameraImageRect(width, height);
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_BoundarySetCameraImageRectError :" + ex.ToString());
			}
		}

		public static void UPvr_BoundarySetSeeThroughVisible(bool value)
		{
			try
			{
				Pvr_BoundarySetSeeThroughVisible(value);
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_BoundarySetSeeThroughVisibleError :" + ex.ToString());
			}
		}

		public static void UPvr_SetGuardianSystemDisable(bool value)
		{
			try
			{
				Pvr_SetGuardianSystemDisable(value);
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_SetGuardianSystemDisableError :" + ex.ToString());
			}
		}

		public static int UPvr_GetDialogState()
		{
			int result = 0;
			try
			{
				result = Pvr_GetDialogState();
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_GetDialogStateError :" + ex.ToString());
			}
			return result;
		}
	}
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	public struct PlatformSettings
	{
		public static Pvr_UnitySDKPlatformSetting.simulationType UPvr_IsCurrentDeviceValid()
		{
			if (Pvr_UnitySDKPlatformSetting.Entitlementchecksimulation)
			{
				if (Pvr_UnitySDKPlatformSetting.Instance.deviceSN.Count <= 0)
				{
					UnityEngine.Debug.Log("DISFT Entitlement Check Simulation deviceSN is Null");
					return Pvr_UnitySDKPlatformSetting.simulationType.Null;
				}
				foreach (string item in Pvr_UnitySDKPlatformSetting.Instance.deviceSN)
				{
					if (System.UPvr_GetDeviceSN() == item)
					{
						return Pvr_UnitySDKPlatformSetting.simulationType.Valid;
					}
				}
				UnityEngine.Debug.Log("DISFT Entitlement Check Simulation deviceSN is Invalid");
				return Pvr_UnitySDKPlatformSetting.simulationType.Invalid;
			}
			UnityEngine.Debug.Log("DISFT Entitlement Check Simulation DO NOT Enable");
			return Pvr_UnitySDKPlatformSetting.simulationType.Invalid;
		}

		public static bool UPvr_AppEntitlementCheck(string appid)
		{
			bool result = false;
			try
			{
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "verifyAPP", System.UPvr_GetCurrentActivity(), appid, string.Empty);
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
			UnityEngine.Debug.Log("PvrLog UPvr_AppEntitlementCheck" + result);
			return result;
		}

		[Obsolete("This API will be removed in later versions")]
		public static bool UPvr_KeyEntitlementCheck(string publicKey)
		{
			bool result = false;
			try
			{
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "verifyAPP", System.UPvr_GetCurrentActivity(), string.Empty, publicKey);
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
			UnityEngine.Debug.Log("PvrLog UPvr_KeyEntitlementCheck" + result);
			return result;
		}

		public static int UPvr_AppEntitlementCheckExtra(string appid)
		{
			return 0;
		}

		public static int UPvr_KeyEntitlementCheckExtra(string publicKey)
		{
			int result = -1;
			try
			{
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "verifyAPPExt", System.UPvr_GetCurrentActivity(), string.Empty, publicKey);
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
			UnityEngine.Debug.Log("PvrLog UPvr_KeyEntitlementCheck" + result);
			return result;
		}

		public static int UPvr_GetHmdAudioStatus()
		{
			return System.PVR_GetHmdAudioStatus();
		}
	}
}
public class PLOG : MonoBehaviour
{
	public static int logLevel;

	public static void getConfigTraceLevel()
	{
		int configsenum = 6;
		Render.UPvr_GetIntConfig(configsenum, ref logLevel);
	}

	public static void D(string msg)
	{
		if (logLevel > 2)
		{
			UnityEngine.Debug.Log(msg);
		}
	}

	public static void I(string msg)
	{
		if (logLevel > 1)
		{
			UnityEngine.Debug.Log(msg);
		}
	}

	public static void W(string msg)
	{
		if (logLevel > 0)
		{
			UnityEngine.Debug.LogWarning(msg);
		}
	}

	public static void E(string msg)
	{
		UnityEngine.Debug.LogError(msg);
	}
}
public class CPicoSDKSettingAsset : ScriptableObject
{
	public bool IgnoreSDKSetting;

	public bool DontshowBuildWaring;

	public bool AppIDChecked;
}
[Serializable]
public class Pvr_UnitySDKProjectSetting : ScriptableObject
{
	public RenderTextureAntiAliasing rtAntiAlising;

	public RenderTextureDepth rtBitDepth;

	public RenderTextureFormat rtFormat;

	public bool usedefaultRenderTexture;

	public Vector2 customRTSize;

	public bool usedefaultfps;

	public int customfps;

	public bool usesinglepass;

	public bool usecontentprotect;

	public static Pvr_UnitySDKProjectSetting GetProjectConfig()
	{
		return Resources.Load<Pvr_UnitySDKProjectSetting>("ProjectSetting");
	}
}
public sealed class Pvr_UnitySDKPlatformSetting : ScriptableObject
{
	public enum simulationType
	{
		Null,
		Invalid,
		Valid
	}

	[SerializeField]
	private bool entitlementchecksimulation;

	[SerializeField]
	private bool startTimeEntitlementCheck;

	[SerializeField]
	public string appID;

	public List<string> deviceSN = new List<string>();

	private static Pvr_UnitySDKPlatformSetting instance;

	public static bool Entitlementchecksimulation
	{
		get
		{
			return Instance.entitlementchecksimulation;
		}
		set
		{
			if (Instance.entitlementchecksimulation != value)
			{
				Instance.entitlementchecksimulation = value;
			}
		}
	}

	public static bool StartTimeEntitlementCheck
	{
		get
		{
			return Instance.startTimeEntitlementCheck;
		}
		set
		{
			if (Instance.startTimeEntitlementCheck != value)
			{
				Instance.startTimeEntitlementCheck = value;
			}
		}
	}

	public static Pvr_UnitySDKPlatformSetting Instance
	{
		get
		{
			if (instance == null)
			{
				instance = Resources.Load<Pvr_UnitySDKPlatformSetting>("PlatformSettings");
			}
			return instance;
		}
		set
		{
			instance = value;
		}
	}
}
public class Pvr_UnitySDKManager : MonoBehaviour
{
	public delegate void EntitlementCheckResult(int ReturnValue);

	public static PlatForm platform;

	private static Pvr_UnitySDKManager sdk;

	[HideInInspector]
	public float EyesAspect = 1f;

	[HideInInspector]
	public int posStatus;

	[HideInInspector]
	public bool ismirroring;

	[HideInInspector]
	public Vector3 resetBasePos = default(Vector3);

	[HideInInspector]
	public int trackingmode = -1;

	[HideInInspector]
	public int systemprop = -1;

	[HideInInspector]
	public bool systemFPS;

	[HideInInspector]
	public float[] headData = new float[7];

	[SerializeField]
	private bool rotfoldout;

	[SerializeField]
	private bool hmdOnlyrot;

	[SerializeField]
	private bool controllerOnlyrot;

	[SerializeField]
	private TrackingOrigin trackingOrigin;

	public bool ResetTrackerOnLoad;

	[HideInInspector]
	public Vector3 leftEyeOffset;

	[HideInInspector]
	public Vector3 rightEyeOffset;

	[HideInInspector]
	public Rect leftEyeRect;

	[HideInInspector]
	public Rect rightEyeRect;

	[HideInInspector]
	public Matrix4x4 leftEyeView;

	[HideInInspector]
	public Matrix4x4 rightEyeView;

	[HideInInspector]
	public Pvr_UnitySDKEditor pvr_UnitySDKEditor;

	[SerializeField]
	private bool vrModeEnabled = true;

	[HideInInspector]
	public Material Eyematerial;

	[HideInInspector]
	public Material Middlematerial;

	[HideInInspector]
	public bool newPicovrTriggered;

	[SerializeField]
	private bool showFPS;

	[HideInInspector]
	public Vector3 neckOffset = new Vector3(0f, 0.075f, 0.0805f);

	[SerializeField]
	private bool pVRNeck = true;

	[HideInInspector]
	public bool UseCustomNeckPara;

	[HideInInspector]
	public bool onResume;

	[HideInInspector]
	public bool isEnterVRMode;

	public bool isHasController;

	public Pvr_UnitySDKConfigProfile pvr_UnitySDKConfig;

	private GameObject calltoast;

	private GameObject msgtoast;

	private GameObject lowhmdBatterytoast;

	private GameObject lowphoneBatterytoast;

	private GameObject LowPhoneHealthtoast;

	private GameObject LowcontrollerBatterytoast;

	private bool lowControllerpowerstate;

	private float controllerpowershowtime;

	private bool UseToast = true;

	private int iPhoneHMDModeEnabled;

	private GameObject G3LiteTips;

	[SerializeField]
	private bool monoscopic;

	private bool mIsAndroid7;

	public static Func<bool> eventEnterVRMode;

	[HideInInspector]
	public bool ShowVideoSeethrough;

	public int SystemDebugFFRLevel = -1;

	public int SystemFFRLevel = -1;

	public int AppCheckResult = 100;

	public Action longPressHomeKeyAction;

	public static Pvr_UnitySDKManager SDK
	{
		get
		{
			if (sdk == null)
			{
				sdk = UnityEngine.Object.FindObjectOfType<Pvr_UnitySDKManager>();
			}
			return sdk;
		}
	}

	public bool Rotfoldout
	{
		get
		{
			return rotfoldout;
		}
		set
		{
			if (value != rotfoldout)
			{
				rotfoldout = value;
			}
		}
	}

	public bool HmdOnlyrot
	{
		get
		{
			return hmdOnlyrot;
		}
		set
		{
			if (value != hmdOnlyrot)
			{
				hmdOnlyrot = value;
			}
		}
	}

	public bool ControllerOnlyrot
	{
		get
		{
			return controllerOnlyrot;
		}
		set
		{
			if (value != controllerOnlyrot)
			{
				controllerOnlyrot = value;
			}
		}
	}

	public TrackingOrigin TrackingOrigin
	{
		get
		{
			return trackingOrigin;
		}
		set
		{
			if (value != trackingOrigin)
			{
				trackingOrigin = value;
				Sensor.UPvr_SetTrackingOriginType(value);
			}
		}
	}

	[HideInInspector]
	public bool VRModeEnabled
	{
		get
		{
			return vrModeEnabled;
		}
		set
		{
			if (value != vrModeEnabled)
			{
				vrModeEnabled = value;
			}
		}
	}

	[HideInInspector]
	public bool picovrTriggered { get; set; }

	public bool ShowFPS
	{
		get
		{
			return showFPS;
		}
		set
		{
			if (value != showFPS)
			{
				showFPS = value;
			}
		}
	}

	public bool PVRNeck
	{
		get
		{
			return pVRNeck;
		}
		set
		{
			if (value != pVRNeck)
			{
				pVRNeck = value;
			}
		}
	}

	[HideInInspector]
	public bool Monoscopic
	{
		get
		{
			return monoscopic;
		}
		set
		{
			if (value != monoscopic)
			{
				monoscopic = value;
				Render.UPvr_SetMonoMode(monoscopic);
			}
		}
	}

	public static event EntitlementCheckResult EntitlementCheckResultEvent;

	public void ChangeDefaultCustomRtSize(int w, int h)
	{
		Pvr_UnitySDKProjectSetting.GetProjectConfig().customRTSize = new Vector2(w, h);
	}

	public Vector3 EyeOffset(Eye eye)
	{
		return (eye != 0) ? rightEyeOffset : leftEyeOffset;
	}

	public Rect EyeRect(Eye eye)
	{
		return (eye != 0) ? rightEyeRect : leftEyeRect;
	}

	private bool SDKManagerInit()
	{
		if (SDKManagerInitConfigProfile())
		{
			mIsAndroid7 = SystemInfo.operatingSystem.Contains("Android OS 7.");
			PLOG.I("Android 7 = " + mIsAndroid7);
			if (SDKManagerInitCoreAbility())
			{
				return true;
			}
			return false;
		}
		return false;
	}

	private bool SDKManagerInitCoreAbility()
	{
		Sensor.UPvr_SetTrackingOriginType(trackingOrigin);
		Render.UPvr_SetMonoMode(monoscopic);
		if (Pvr_UnitySDKRender.Instance == null)
		{
			PLOG.I("pvr_UnitySDKRender init failed");
		}
		if (Pvr_UnitySDKSensor.Instance == null)
		{
			PLOG.I("pvr_UnitySDKSensor init failed");
		}
		Pvr_UnitySDKAPI.System.UPvr_StartHomeKeyReceiver(base.gameObject.name);
		return true;
	}

	public void smsReceivedCallback(string msg)
	{
		PLOG.I("PvrLog MSG" + msg);
		JsonData jsonData = JsonMapper.ToObject(msg);
		string text = string.Empty;
		if (msg.Contains("messageSender"))
		{
			text = (string)jsonData["messageSender"];
		}
		string text2 = string.Empty;
		if (msg.Contains("messageAdr"))
		{
			text2 = (string)jsonData["messageAdr"];
			if (text2.Substring(0, 3) == "+82")
			{
				text2 = "0" + text2.Remove(0, 3);
				text2 = TransformNumber(text2);
			}
			else if (text2.Substring(0, 1) != "+")
			{
				text2 = TransformNumber(text2);
			}
		}
		if (UseToast)
		{
			msgtoast.transform.Find("number").GetComponent<Text>().text = text2;
			msgtoast.transform.Find("name").GetComponent<Text>().text = text;
			if (text.Length == 0)
			{
				msgtoast.transform.Find("number").transform.localPosition = new Vector3(0f, 0f, 0f);
			}
			else
			{
				msgtoast.transform.Find("number").transform.localPosition = new Vector3(60f, 0f, 0f);
			}
			StartCoroutine(ToastManager(2, state: true, 0f));
			StartCoroutine(ToastManager(2, state: false, 5f));
		}
	}

	public void phoneStateCallback(string state)
	{
		PLOG.I("PvrLog phone" + state);
		JsonData jsonData = JsonMapper.ToObject(state);
		string text = string.Empty;
		if (state.Contains("phoneNumber"))
		{
			text = (string)jsonData["phoneNumber"];
			if (text.Substring(0, 3) == "+82")
			{
				text = "0" + text.Remove(0, 3);
				text = TransformNumber(text);
			}
			else if (text.Substring(0, 1) != "+")
			{
				text = TransformNumber(text);
			}
		}
		string text2 = string.Empty;
		if (state.Contains("contactName"))
		{
			text2 = (string)jsonData["contactName"];
		}
		if (UseToast)
		{
			calltoast.transform.Find("number").GetComponent<Text>().text = text;
			calltoast.transform.Find("name").GetComponent<Text>().text = text2;
			if (text2.Length == 0)
			{
				calltoast.transform.Find("number").transform.localPosition = new Vector3(0f, 0f, 0f);
			}
			else
			{
				calltoast.transform.Find("number").transform.localPosition = new Vector3(60f, 0f, 0f);
			}
			StartCoroutine(ToastManager(1, state: true, 0f));
			StartCoroutine(ToastManager(1, state: false, 5f));
		}
	}

	public void phoneBatteryStateCallback(string state)
	{
		PLOG.I("PvrLog phoneBatteryState" + state);
		JsonData jsonData = JsonMapper.ToObject(state);
		string value = string.Empty;
		if (state.Contains("phoneBatteryLevel"))
		{
			value = (string)jsonData["phoneBatteryLevel"];
		}
		string value2 = string.Empty;
		if (state.Contains("phoneBatteryHealth"))
		{
			value2 = (string)jsonData["phoneBatteryHealth"];
		}
		if (!UseToast)
		{
			return;
		}
		if (Convert.ToInt16(value) <= 5)
		{
			if (!lowhmdBatterytoast.activeSelf)
			{
				StartCoroutine(ToastManager(4, state: true, 0f));
				StartCoroutine(ToastManager(4, state: false, 3f));
			}
			else
			{
				StartCoroutine(ToastManager(4, state: true, 5f));
				StartCoroutine(ToastManager(4, state: false, 8f));
			}
		}
		if (Convert.ToInt16(value2) == 3)
		{
			StartCoroutine(ToastManager(5, state: true, 0f));
			StartCoroutine(ToastManager(5, state: false, 5f));
		}
	}

	public void hmdLowBatteryCallback(string level)
	{
		PLOG.I("PvrLog hmdLowBatteryCallback" + level);
		if (UseToast)
		{
			if (!lowphoneBatterytoast.activeSelf)
			{
				StartCoroutine(ToastManager(3, state: true, 0f));
				StartCoroutine(ToastManager(3, state: false, 3f));
			}
			else
			{
				StartCoroutine(ToastManager(3, state: true, 5f));
				StartCoroutine(ToastManager(3, state: false, 8f));
			}
		}
	}

	private string TransformNumber(string number)
	{
		if (number.Length == 11)
		{
			string text = number.Substring(0, 3);
			string text2 = number.Substring(3, 4);
			string text3 = number.Substring(7, 4);
			number = text + "-" + text2 + "-" + text3;
		}
		else if (number.Length == 10)
		{
			if (number.Substring(1, 1) == "1")
			{
				string text4 = number.Substring(0, 3);
				string text5 = number.Substring(3, 3);
				string text6 = number.Substring(6, 4);
				number = text4 + "-" + text5 + "-" + text6;
			}
			else
			{
				string text7 = number.Substring(0, 2);
				string text8 = number.Substring(2, 4);
				string text9 = number.Substring(6, 4);
				number = text7 + "-" + text8 + "-" + text9;
			}
		}
		else if (number.Length == 9)
		{
			if (number.Substring(1, 1) == "2")
			{
				string text10 = number.Substring(0, 2);
				string text11 = number.Substring(2, 3);
				string text12 = number.Substring(5, 4);
				number = text10 + "-" + text11 + "-" + text12;
			}
			else
			{
				number = "+82" + number.Remove(0, 1);
			}
		}
		return number;
	}

	public void onHmdOrientationReseted()
	{
	}

	private IEnumerator ToastManager(int type, bool state, float time)
	{
		yield return new WaitForSeconds(time);
		switch (type)
		{
		case 1:
			calltoast.SetActive(state);
			break;
		case 2:
			msgtoast.SetActive(state);
			break;
		case 3:
			lowhmdBatterytoast.SetActive(state);
			break;
		case 4:
			lowphoneBatterytoast.SetActive(state);
			break;
		case 5:
			LowPhoneHealthtoast.SetActive(state);
			break;
		case 6:
			LowcontrollerBatterytoast.SetActive(state);
			break;
		}
	}

	private void CheckControllerStateForG2(string state)
	{
		if (iPhoneHMDModeEnabled == 1 && Convert.ToBoolean(Convert.ToInt16(state)) && Controller.UPvr_GetControllerPower(0) == 0 && Pvr_ControllerManager.controllerlink.Controller0.Rotation.eulerAngles != Vector3.zero)
		{
			StartCoroutine(ToastManager(6, state: true, 0f));
			StartCoroutine(ToastManager(6, state: false, 3f));
		}
	}

	public void notificationCallback(string data)
	{
		JsonData jsonData = JsonMapper.ToObject(data);
		if (G3LiteTips == null)
		{
			G3LiteTips = UnityEngine.Object.Instantiate(Resources.Load("Prefabs/G3LiteTips") as GameObject, base.transform.Find("Head"), worldPositionStays: false);
		}
		string json = jsonData["str"].ToString();
		JsonData jsonData2 = JsonMapper.ToObject(json);
		switch ((int)jsonData["type"])
		{
		case -1:
			break;
		case 0:
			SetProperty(0, jsonData2, "Sms");
			break;
		case 1:
			SetProperty(1, jsonData2, "Call");
			break;
		case 2:
			SetProperty(2, jsonData2, "Warnning");
			break;
		case 3:
			SetProperty(3, jsonData2, "Warnning");
			break;
		case 4:
			SetProperty(4, jsonData2, "Warnning");
			break;
		case 5:
		{
			Transform transform = G3LiteTips.transform.Find("Onlyimage");
			SetBaseProperty(transform, jsonData2["General"], string.Empty);
			SetImageProperty(transform, jsonData2["General"], string.Empty);
			transform.gameObject.SetActive(value: true);
			StartCoroutine(G3TipsManager(transform.gameObject, (int)jsonData2["General"]["time"]));
			break;
		}
		}
	}

	private Sprite LoadSprite(Vector2 size, string filepath)
	{
		int width = (int)size.x;
		int height = (int)size.y;
		Texture2D texture2D = new Texture2D(width, height);
		texture2D.LoadImage(ReadTex(filepath));
		return Sprite.Create(texture2D, new Rect(0f, 0f, texture2D.width, texture2D.height), new Vector2(0.5f, 0.5f));
	}

	private byte[] ReadTex(string path)
	{
		if (path == string.Empty)
		{
			return new byte[0];
		}
		FileStream fileStream = new FileStream(path, FileMode.Open, FileAccess.Read);
		fileStream.Seek(0L, SeekOrigin.Begin);
		byte[] array = new byte[fileStream.Length];
		fileStream.Read(array, 0, (int)fileStream.Length);
		fileStream.Close();
		fileStream.Dispose();
		fileStream = null;
		return array;
	}

	private void SetProperty(int type, JsonData data, string value)
	{
		Transform trans = G3LiteTips.transform.Find(value);
		SetBaseProperty(trans, data, string.Empty);
		SetImageProperty(trans, data, string.Empty);
		trans.gameObject.SetActive(value: true);
		StartCoroutine(G3TipsManager(trans.gameObject, (int)data["time"]));
		Transform transform = trans.transform.Find("icon");
		SetBaseProperty(transform, data, "icon_");
		SetImageProperty(transform, data, "icon_");
		Transform transform2 = trans.transform.Find("title");
		SetBaseProperty(transform2, data, "title_");
		SetTextProperty(transform2, data, "title_");
		if (type != 1)
		{
			Transform transform3 = trans.transform.Find("details");
			SetBaseProperty(transform3, data, "details_");
			SetTextProperty(transform3, data, "details_");
			Transform transform4 = trans.transform.Find("image1");
			SetBaseProperty(transform4, data, "image1_");
			SetImageProperty(transform4, data, "image1_");
		}
		if (type == 0 || type == 1)
		{
			Transform transform5 = trans.transform.Find("explain");
			SetBaseProperty(transform5, data, "explain_");
			SetTextProperty(transform5, data, "explain_");
			Transform transform6 = trans.transform.Find("source");
			SetBaseProperty(transform6, data, "source_");
			SetTextProperty(transform6, data, "source_");
		}
		if (type == 0)
		{
			Transform transform7 = trans.transform.Find("time");
			SetBaseProperty(transform7, data, "system_time_");
			SetTextProperty(transform7, data, "system_time_");
		}
		Transform transform8 = trans.transform.Find("Button");
		SetBaseProperty(transform8, data, "button_");
		SetImageProperty(transform8, data, "button_");
		transform8.GetComponent<Button>().onClick.AddListener(delegate
		{
			StartCoroutine(G3TipsManager(trans.gameObject, 0f));
		});
		Transform transform9 = transform8.transform.Find("Text");
		SetBaseProperty(transform9, data, "button_text_");
		SetTextProperty(transform9, data, "button_text_");
	}

	private void SetBaseProperty(Transform trans, JsonData data, string value)
	{
		string prop_name = value + "pos";
		string prop_name2 = value + "angles";
		string prop_name3 = value + "size";
		string prop_name4 = value + "scale";
		trans.GetComponent<RectTransform>().anchoredPosition3D = new Vector3(JsonToFloat(data[prop_name][0]), JsonToFloat(data[prop_name][1]), JsonToFloat(data[prop_name][2]));
		trans.GetComponent<RectTransform>().eulerAngles = new Vector3(JsonToFloat(data[prop_name2][0]), JsonToFloat(data[prop_name2][1]), JsonToFloat(data[prop_name2][2]));
		trans.GetComponent<RectTransform>().sizeDelta = new Vector2(JsonToFloat(data[prop_name3][0]), JsonToFloat(data[prop_name3][1]));
		trans.GetComponent<RectTransform>().localScale = new Vector3(JsonToFloat(data[prop_name4][0]), JsonToFloat(data[prop_name4][1]), JsonToFloat(data[prop_name4][2]));
	}

	private void SetImageProperty(Transform image, JsonData data, string value)
	{
		string prop_name = value + "sprite";
		string prop_name2 = value + "color";
		string prop_name3 = value + "size";
		image.GetComponent<Image>().sprite = LoadSprite(new Vector2(JsonToFloat(data[prop_name3][0]), JsonToFloat(data[prop_name3][1])), (string)data[prop_name]);
		image.GetComponent<Image>().color = new Color(JsonToFloat(data[prop_name2][0]), JsonToFloat(data[prop_name2][1]), JsonToFloat(data[prop_name2][2]), JsonToFloat(data[prop_name2][3]));
	}

	private void SetTextProperty(Transform text, JsonData data, string value)
	{
		string prop_name = value + "color";
		string prop_name2 = value + "font_size";
		string prop_name3 = value + "font_style";
		string prop_name4 = value + "text";
		text.GetComponent<Text>().text = (string)data[prop_name4];
		text.GetComponent<Text>().color = new Color(JsonToFloat(data[prop_name][0]), JsonToFloat(data[prop_name][1]), JsonToFloat(data[prop_name][2]), JsonToFloat(data[prop_name][3]));
		text.GetComponent<Text>().fontSize = (int)data[prop_name2];
		text.GetComponent<Text>().fontStyle = (FontStyle)(int)data[prop_name3];
	}

	private IEnumerator G3TipsManager(GameObject tip, float time)
	{
		yield return new WaitForSeconds(time);
		tip.SetActive(value: false);
	}

	private float JsonToFloat(JsonData data)
	{
		return Convert.ToSingle((string)data);
	}

	private bool SDKManagerInitFPS()
	{
		Transform[] componentsInChildren = GetComponentsInChildren<Transform>(includeInactive: true);
		GameObject gameObject = null;
		Transform[] array = componentsInChildren;
		foreach (Transform transform in array)
		{
			if (transform.gameObject.name == "FPS")
			{
				gameObject = transform.gameObject;
			}
		}
		if (gameObject != null)
		{
			if (systemFPS)
			{
				gameObject.SetActive(value: true);
				return true;
			}
			int res = 0;
			int configsenum = 10;
			Render.UPvr_GetIntConfig(configsenum, ref res);
			if (Convert.ToBoolean(res))
			{
				gameObject.SetActive(value: true);
				return true;
			}
			if (ShowFPS)
			{
				gameObject.SetActive(value: true);
				return true;
			}
			return false;
		}
		return false;
	}

	private bool SDKManagerInitConfigProfile()
	{
		pvr_UnitySDKConfig = Pvr_UnitySDKConfigProfile.Default;
		return true;
	}

	private bool SDKManagerInitEditor()
	{
		if (pvr_UnitySDKEditor == null)
		{
			pvr_UnitySDKEditor = base.gameObject.AddComponent<Pvr_UnitySDKEditor>();
		}
		else
		{
			pvr_UnitySDKEditor = null;
			pvr_UnitySDKEditor = base.gameObject.AddComponent<Pvr_UnitySDKEditor>();
		}
		return true;
	}

	private bool SDKManagerInitPara()
	{
		return true;
	}

	public void SDKManagerLongHomeKey()
	{
		if (Pvr_UnitySDKSensor.Instance == null)
		{
			return;
		}
		if (isHasController)
		{
			if (Controller.UPvr_GetControllerState(0) == ControllerState.Connected || Controller.UPvr_GetControllerState(1) == ControllerState.Connected)
			{
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(0, 1);
			}
			else
			{
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
			}
		}
		else
		{
			Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
		}
	}

	private void setLongHomeKey()
	{
		if (sdk.HmdOnlyrot)
		{
			if (Pvr_UnitySDKSensor.Instance != null)
			{
				PLOG.I((!Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor()) ? "Long Home Key to Reset Sensor Failed!" : "Long Home Key to Reset Sensor Success!");
			}
			return;
		}
		if (trackingmode == 4 || trackingmode == 5 || trackingmode == 6)
		{
			Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
		}
		else
		{
			if (trackingmode == 2 || trackingmode == 3)
			{
				if (isHasController && (Controller.UPvr_GetControllerState(0) == ControllerState.Connected || Controller.UPvr_GetControllerState(1) == ControllerState.Connected))
				{
					Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(0, 1);
				}
				else
				{
					Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
				}
			}
			if (trackingmode == 0 || trackingmode == 1)
			{
				Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
			}
		}
		if (longPressHomeKeyAction != null)
		{
			longPressHomeKeyAction();
		}
	}

	public void verifyAPPCallback(string code)
	{
		UnityEngine.Debug.Log("PvrLog verifyAPPCallback" + code);
		AppCheckResult = Convert.ToInt32(code);
		if (Pvr_UnitySDKManager.EntitlementCheckResultEvent != null)
		{
			Pvr_UnitySDKManager.EntitlementCheckResultEvent(AppCheckResult);
		}
	}

	public void IpdRefreshCallBack(string ipd)
	{
		UnityEngine.Debug.Log("PvrLog IpdRefreshCallBack");
		Pvr_UnitySDKEye[] eyes = Pvr_UnitySDKEyeManager.Instance.Eyes;
		foreach (Pvr_UnitySDKEye pvr_UnitySDKEye in eyes)
		{
			pvr_UnitySDKEye.RefreshCameraPosition(Convert.ToSingle(ipd));
		}
	}

	private void Awake()
	{
		UnityEngine.Debug.Log("DISFT Unity Version:" + UnityEngine.Application.unityVersion);
		UnityEngine.Debug.Log("DISFT Customize NeckOffset:" + neckOffset);
		UnityEngine.Debug.Log("DISFT MSAA :" + Pvr_UnitySDKProjectSetting.GetProjectConfig().rtAntiAlising);
		if (GraphicsSettings.renderPipelineAsset != null)
		{
			UnityEngine.Debug.Log("DISFT LWRP = Enable");
		}
		UnityEngine.Debug.Log("DISFT Content Proctect :" + Pvr_UnitySDKProjectSetting.GetProjectConfig().usecontentprotect);
		int res = 0;
		int num = 0;
		LoadIsMirroringValue();
		if (!ismirroring)
		{
			num = 18;
			Render.UPvr_GetIntConfig(num, ref res);
			if (res == 1)
			{
				UnityEngine.Debug.Log("DISFT ScreenOrientation.Portrait = Enable");
				Screen.orientation = ScreenOrientation.Portrait;
			}
		}
		else
		{
			num = 19;
			Render.UPvr_GetIntConfig(num, ref res);
			Screen.orientation = ((res == 0) ? ScreenOrientation.Portrait : ScreenOrientation.LandscapeLeft);
		}
		AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.psmart.vrlib.VrActivity");
		AndroidJavaClass androidJavaClass2 = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
		AndroidJavaObject @static = androidJavaClass2.GetStatic<AndroidJavaObject>("currentActivity");
		Pvr_ControllerManager pvr_ControllerManager = UnityEngine.Object.FindObjectOfType<Pvr_ControllerManager>();
		isHasController = pvr_ControllerManager != null;
		PLOG.getConfigTraceLevel();
		int configsenum = 5;
		Render.UPvr_GetIntConfig(configsenum, ref trackingmode);
		UnityEngine.Application.targetFrameRate = 61;
		int res2 = 0;
		configsenum = 3;
		Render.UPvr_GetIntConfig(configsenum, ref res2);
		if (res2 == 0)
		{
			SDK.HmdOnlyrot = true;
		}
		int res3 = -1;
		int configsenum2 = 9;
		Render.UPvr_GetIntConfig(configsenum2, ref res3);
		float res4 = 0f;
		int configsenum3 = 6;
		Render.UPvr_GetFloatConfig(configsenum3, ref res4);
		UnityEngine.Application.targetFrameRate = ((res3 <= 0) ? ((int)res4) : res3);
		if (!Pvr_UnitySDKProjectSetting.GetProjectConfig().usedefaultfps)
		{
			if ((float)Pvr_UnitySDKProjectSetting.GetProjectConfig().customfps <= res4)
			{
				UnityEngine.Application.targetFrameRate = Pvr_UnitySDKProjectSetting.GetProjectConfig().customfps;
			}
			else
			{
				UnityEngine.Application.targetFrameRate = (int)res4;
			}
		}
		UnityEngine.Debug.Log("DISFT Customize FPS :" + UnityEngine.Application.targetFrameRate);
		if (!UseCustomNeckPara)
		{
			float res5 = 0f;
			float res6 = 0f;
			float res7 = 0f;
			int configsenum4 = 3;
			int configsenum5 = 4;
			int configsenum6 = 5;
			Render.UPvr_GetFloatConfig(configsenum4, ref res5);
			Render.UPvr_GetFloatConfig(configsenum5, ref res6);
			Render.UPvr_GetFloatConfig(configsenum6, ref res7);
			if (res5 != 0f || res6 != 0f || res7 != 0f)
			{
				neckOffset = new Vector3(res5, res6, res7);
			}
		}
		Render.UPvr_GetIntConfig(16, ref iPhoneHMDModeEnabled);
		Pvr_ControllerManager.ControllerStatusChangeEvent += CheckControllerStateForG2;
		InitUI();
		RefreshTextByLanguage();
	}

	private IEnumerator Start()
	{
		if (SDKManagerInit())
		{
			PLOG.I("SDK Init success.");
		}
		else
		{
			PLOG.E("SDK Init Failed.");
			UnityEngine.Application.Quit();
		}
		if (Pvr_UnitySDKRender.Instance != null)
		{
			Pvr_UnitySDKRender.Instance.ReInit();
		}
		SDKManagerInitFPS();
		if (Pvr_UnitySDKPlatformSetting.StartTimeEntitlementCheck)
		{
			if (Pvr_UnitySDKAPI.PlatformSettings.UPvr_IsCurrentDeviceValid() != Pvr_UnitySDKPlatformSetting.simulationType.Valid)
			{
				UnityEngine.Debug.Log("DISFT Entitlement Check Simulation DO NOT PASS");
				string appID = Pvr_UnitySDKPlatformSetting.Instance.appID;
				UnityEngine.Debug.Log("DISFT Start-time Entitlement Check Enable");
				PLOG.I("DISFT Start-time Entitlement Check APPID :" + appID);
				Pvr_UnitySDKAPI.PlatformSettings.UPvr_AppEntitlementCheckExtra(appID);
			}
			else
			{
				UnityEngine.Debug.Log("DISFT Entitlement Check Simulation PASS");
			}
		}
		yield return StartCoroutine(InitRenderThreadRoutine());
	}

	private IEnumerator InitRenderThreadRoutine()
	{
		PLOG.I("InitRenderThreadRoutine begin");
		for (int i = 0; i < 2; i++)
		{
			yield return null;
		}
		UnityEngine.Debug.Log("InitRenderThreadRoutine after a wait");
		if (Pvr_UnitySDKRender.Instance != null)
		{
			Pvr_UnitySDKRender.Instance.IssueRenderThread();
		}
		else
		{
			UnityEngine.Debug.Log("InitRenderThreadRoutine pvr_UnitySDKRender == null");
		}
		UnityEngine.Debug.Log("InitRenderThreadRoutine end");
	}

	private void Update()
	{
		if (isHasController && iPhoneHMDModeEnabled == 1 && Controller.UPvr_GetControllerPower(0) == 0 && Pvr_ControllerManager.controllerlink.controller0Connected && Pvr_ControllerManager.controllerlink.Controller0.Rotation.eulerAngles != Vector3.zero)
		{
			if (!lowControllerpowerstate)
			{
				StartCoroutine(ToastManager(6, state: true, 0f));
				StartCoroutine(ToastManager(6, state: false, 3f));
				lowControllerpowerstate = true;
			}
			controllerpowershowtime += Time.deltaTime;
			if (controllerpowershowtime >= 3600f)
			{
				lowControllerpowerstate = false;
				controllerpowershowtime = 0f;
			}
		}
		if (Input.touchCount == 1 && Input.touches[0].phase == TouchPhase.Began)
		{
			newPicovrTriggered = true;
		}
		if (Input.GetKeyDown(KeyCode.JoystickButton0))
		{
			newPicovrTriggered = true;
		}
		if (Pvr_UnitySDKSensor.Instance != null)
		{
			Pvr_UnitySDKSensor.Instance.SensorUpdate();
		}
		picovrTriggered = newPicovrTriggered;
		newPicovrTriggered = false;
	}

	private void OnDestroy()
	{
		if (sdk == this)
		{
			sdk = null;
		}
		RenderTexture.active = null;
		Resources.UnloadUnusedAssets();
		GC.Collect();
		Pvr_ControllerManager.ControllerStatusChangeEvent -= CheckControllerStateForG2;
	}

	private void OnEnable()
	{
		if (sdk == null)
		{
			sdk = this;
		}
		else if (sdk != this)
		{
			sdk = this;
		}
	}

	private void OnDisable()
	{
		StopAllCoroutines();
	}

	private void OnPause()
	{
		Pvr_UnitySDKAPI.System.UPvr_StopHomeKeyReceiver();
		LeaveVRMode();
		if (Pvr_UnitySDKSensor.Instance != null)
		{
			Pvr_UnitySDKSensor.Instance.StopUnitySDKSensor();
		}
	}

	private void OnApplicationPause(bool pause)
	{
		bool flag = pause;
		UnityEngine.Debug.Log("OnApplicationPause-------------------------" + ((!flag) ? "false" : "true"));
		if (Pvr_UnitySDKAPI.System.UPvr_IsPicoActivity() && !Pvr_UnitySDKRender.Instance.isShellMode)
		{
			bool flag2 = Pvr_UnitySDKAPI.System.UPvr_GetMainActivityPauseStatus();
			UnityEngine.Debug.Log("OnApplicationPause-------------------------Activity Pause State:" + flag2);
			pause = flag2;
		}
		if (flag == pause)
		{
			if (pause)
			{
				onResume = false;
				OnPause();
			}
			else
			{
				onResume = true;
				GL.InvalidateState();
				StartCoroutine(OnResume());
			}
		}
		else if (pause)
		{
			UnityEngine.Debug.Log("OnApplicationPause-------------------------Activity pause Unity resume");
			GL.InvalidateState();
			StartCoroutine(OnResume());
			onResume = false;
			OnPause();
		}
		else
		{
			UnityEngine.Debug.Log("OnApplicationPause-------------------------Activity resume Unity pause");
			OnPause();
			onResume = true;
			GL.InvalidateState();
			StartCoroutine(OnResume());
		}
	}

	public void EnterVRMode()
	{
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.Resume);
		isEnterVRMode = true;
		if (eventEnterVRMode != null)
		{
			eventEnterVRMode();
		}
	}

	public void LeaveVRMode()
	{
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.Pause);
		isEnterVRMode = false;
	}

	public void SixDofForceQuit()
	{
		UnityEngine.Application.Quit();
	}

	private void InitUI()
	{
		if (iPhoneHMDModeEnabled == 1)
		{
			Transform transform = UnityEngine.Object.Instantiate(Resources.Load("Prefabs/flamingo2Tips") as GameObject, base.transform.Find("Head"), worldPositionStays: false).transform;
			calltoast = transform.Find("Call").gameObject;
			msgtoast = transform.Find("Msg").gameObject;
			lowhmdBatterytoast = transform.Find("LowHmdBattery").gameObject;
			lowphoneBatterytoast = transform.Find("LowPhoneBattery").gameObject;
			LowPhoneHealthtoast = transform.Find("LowPhoneHealth").gameObject;
			LowcontrollerBatterytoast = transform.Find("LowControllerBattery").gameObject;
		}
	}

	private void RefreshTextByLanguage()
	{
		if (msgtoast != null)
		{
			msgtoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("msgtoast0");
			msgtoast.transform.Find("string").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("msgtoast1");
			calltoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("calltoast0");
			calltoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("calltoast1");
			lowhmdBatterytoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("lowhmdBatterytoast");
			lowphoneBatterytoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("lowphoneBatterytoast");
			LowPhoneHealthtoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("LowPhoneHealthtoast");
			LowcontrollerBatterytoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("LowcontrollerBatterytoast");
		}
	}

	private void LoadIsMirroringValue()
	{
		AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
		AndroidJavaObject @static = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
		AndroidJavaObject androidJavaObject = @static.Call<AndroidJavaObject>("getPackageManager", Array.Empty<object>());
		string text = @static.Call<string>("getPackageName", Array.Empty<object>());
		AndroidJavaObject androidJavaObject2 = androidJavaObject.Call<AndroidJavaObject>("getApplicationInfo", new object[2] { text, 128 });
		AndroidJavaObject androidJavaObject3 = androidJavaObject2.Get<AndroidJavaObject>("metaData");
		ismirroring = Convert.ToBoolean(androidJavaObject3.Call<int>("getInt", new object[2] { "bypass_presentation", 0 }));
	}

	private IEnumerator OnResume()
	{
		int ability6dof = 0;
		int enumindex = 3;
		Render.UPvr_GetIntConfig(enumindex, ref ability6dof);
		RefreshTextByLanguage();
		if (Pvr_UnitySDKSensor.Instance != null)
		{
			Pvr_UnitySDKSensor.Instance.StartUnitySDKSensor();
			int res = -1;
			int configsenum = 8;
			Render.UPvr_GetIntConfig(configsenum, ref res);
			if (res != 1)
			{
				int res2 = -1;
				int configsenum2 = 11;
				Render.UPvr_GetIntConfig(configsenum2, ref res2);
				if (res2 != 8)
				{
					Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
				}
			}
		}
		if (Pvr_UnitySDKAPI.System.UPvr_IsPicoActivity())
		{
			PLOG.I("onresume set monoPresentation success ?-------------" + Pvr_UnitySDKAPI.System.UPvr_SetMonoPresentation());
			PLOG.I("onresume presentation existed ?-------------" + Pvr_UnitySDKAPI.System.UPvr_IsPresentationExisted());
		}
		for (int j = 0; j < Pvr_UnitySDKEyeManager.Instance.Eyes.Length; j++)
		{
			Pvr_UnitySDKEyeManager.Instance.Eyes[j].RefreshCameraPosition(Pvr_UnitySDKAPI.System.UPvr_GetIPD());
		}
		int waitNum = 15;
		Render.UPvr_GetIntConfig(20, ref waitNum);
		int resetNum = 10;
		Render.UPvr_GetIntConfig(21, ref resetNum);
		for (int i = 0; i < waitNum; i++)
		{
			if (i == resetNum && ResetTrackerOnLoad && ability6dof == 1)
			{
				UnityEngine.Debug.Log("Reset Tracker OnLoad");
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
			}
			yield return null;
		}
		EnterVRMode();
		Pvr_UnitySDKAPI.System.UPvr_StartHomeKeyReceiver(base.gameObject.name);
		Pvr_UnitySDKEye.setLevel = false;
		if (longPressHomeKeyAction != null)
		{
			longPressHomeKeyAction();
		}
		if (Render.UPvr_GetIntSysProc("pvrsist.foveation.level", ref SystemDebugFFRLevel))
		{
			Render.SetFoveatedRenderingLevel((EFoveationLevel)SystemDebugFFRLevel);
			UnityEngine.Debug.Log("DISFT OnResume Get System Debug ffr level is : " + SystemDebugFFRLevel);
		}
		else
		{
			UnityEngine.Debug.Log("DISFT OnResume Get System Debug ffr level Error,ffr level is : " + SystemDebugFFRLevel);
		}
		if (SystemDebugFFRLevel == -1)
		{
			Render.UPvr_GetIntConfig(22, ref SystemFFRLevel);
			if (SystemFFRLevel != -1)
			{
				Render.SetFoveatedRenderingLevel((EFoveationLevel)SystemFFRLevel);
				UnityEngine.Debug.Log("DISFT OnResume Get System ffr level is : " + SystemFFRLevel);
			}
		}
	}
}
public class QuitGame : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Escape))
		{
			UnityEngine.Application.Quit();
		}
	}
}
public class Pvr_UnityEyeMask : MonoBehaviour
{
	private class EyeMaskData
	{
		public Eye eyeSide;

		public Camera camera;

		public CommandBuffer cmdBuf;
	}

	private Shader eyeMaskShader;

	private Material eyeMaskMaterial;

	private Mesh eyeMaskMeshLeft;

	private Mesh eyeMaskMeshRight;

	private Mesh eyeMaskMeshBoth;

	private float zDir = -1f;

	private Color eyeMaskColor = Color.black;

	private List<EyeMaskData> cameraDataList = new List<EyeMaskData>();

	private void Awake()
	{
		UnityEngine.Debug.Log("DISFT EyeMask = Enable");
		if (SystemInfo.graphicsDeviceType == GraphicsDeviceType.OpenGLES3 || SystemInfo.graphicsDeviceType == GraphicsDeviceType.OpenGLES2)
		{
			zDir = -1f;
		}
		else if (SystemInfo.usesReversedZBuffer)
		{
			zDir = 1f;
		}
		else
		{
			zDir = 0f;
		}
	}

	private void OnEnable()
	{
		if (eyeMaskShader == null)
		{
			eyeMaskShader = Shader.Find("Pvr_UnitySDK/Pvr_EyeMask");
		}
		if (eyeMaskMaterial == null && eyeMaskShader != null)
		{
			eyeMaskMaterial = new Material(eyeMaskShader);
			eyeMaskMaterial.SetColor("_Color", eyeMaskColor);
		}
		if (eyeMaskMaterial == null)
		{
			base.enabled = false;
			UnityEngine.Debug.LogWarning("EyeMask materil is null or EyeMask shader not found!");
		}
		else
		{
			PrepareCameras();
			Camera.onPreRender = (Camera.CameraCallback)Delegate.Combine(Camera.onPreRender, new Camera.CameraCallback(OnCustomPreRender));
			CreateCommandBuffer();
		}
	}

	private void OnDisable()
	{
		Camera.onPreRender = (Camera.CameraCallback)Delegate.Remove(Camera.onPreRender, new Camera.CameraCallback(OnCustomPreRender));
		foreach (EyeMaskData cameraData in cameraDataList)
		{
			if (cameraData.camera != null && cameraData.cmdBuf != null)
			{
				RemoveCameraCommandBuffer(cameraData);
			}
		}
		CleanEyeMask();
	}

	private void CreateCommandBuffer()
	{
		if (VerifyCommadBuffer())
		{
			return;
		}
		if (eyeMaskMeshLeft == null || eyeMaskMeshRight == null)
		{
			eyeMaskMeshLeft = GetStencilMesh(Eye.LeftEye);
			eyeMaskMeshRight = GetStencilMesh(Eye.RightEye);
			if (eyeMaskMeshLeft == null || eyeMaskMeshRight == null)
			{
				UnityEngine.Debug.LogWarning("Stencil Mesh is not exist, disable EyeMask.");
				base.enabled = false;
				return;
			}
		}
		foreach (EyeMaskData cameraData in cameraDataList)
		{
			if (cameraData.eyeSide == Eye.LeftEye)
			{
				CommandBuffer commandBuffer = new CommandBuffer();
				commandBuffer.name = "EyeMaskLeft";
				commandBuffer.DrawMesh(eyeMaskMeshLeft, Matrix4x4.identity, eyeMaskMaterial, 0, 0);
				cameraData.cmdBuf = commandBuffer;
			}
			else if (cameraData.eyeSide == Eye.RightEye)
			{
				CommandBuffer commandBuffer2 = new CommandBuffer();
				commandBuffer2.name = "EyeMaskRight";
				commandBuffer2.DrawMesh(eyeMaskMeshRight, Matrix4x4.identity, eyeMaskMaterial, 0, 0);
				cameraData.cmdBuf = commandBuffer2;
			}
			else if (cameraData.eyeSide == Eye.BothEye)
			{
				if (eyeMaskMeshBoth == null)
				{
					eyeMaskMeshBoth = GetStencilMeshBoth(eyeMaskMeshLeft, eyeMaskMeshRight);
					float value = Mathf.Max(Mathf.Abs(eyeMaskMeshLeft.bounds.max.x), Mathf.Abs(eyeMaskMeshRight.bounds.min.x));
					eyeMaskMaterial.SetFloat("_MeshOffsetX", value);
				}
				CommandBuffer commandBuffer3 = new CommandBuffer();
				commandBuffer3.name = "EyeMaskBoth";
				commandBuffer3.DrawMesh(eyeMaskMeshBoth, Matrix4x4.identity, eyeMaskMaterial, 0, 1);
				cameraData.cmdBuf = commandBuffer3;
			}
		}
	}

	private void OnCustomPreRender(Camera cam)
	{
		if (!VerifyCommadBuffer())
		{
			UnityEngine.Debug.LogWarning("Verify CommandBuffer failed!");
			return;
		}
		foreach (EyeMaskData cameraData in cameraDataList)
		{
			if (!(cameraData.camera != cam))
			{
				RemoveCameraCommandBuffer(cameraData);
				AddCameraCommandBuffer(cameraData);
			}
		}
	}

	private Mesh GetStencilMesh(Eye eyeSide)
	{
		int vertexCount = 0;
		int triangleCount = 0;
		IntPtr vertexDataPtr = IntPtr.Zero;
		IntPtr indexDataPtr = IntPtr.Zero;
		Render.UPvr_GetStencilMesh((int)eyeSide, ref vertexCount, ref triangleCount, ref vertexDataPtr, ref indexDataPtr);
		if (vertexCount <= 0 || triangleCount <= 0 || vertexDataPtr == IntPtr.Zero || indexDataPtr == IntPtr.Zero)
		{
			return null;
		}
		Vector3[] array = new Vector3[vertexCount];
		int[] array2 = new int[triangleCount * 3];
		float[] array3 = new float[vertexCount * 3];
		int[] array4 = new int[triangleCount * 3];
		Marshal.Copy(vertexDataPtr, array3, 0, vertexCount * 3);
		Marshal.Copy(indexDataPtr, array4, 0, triangleCount * 3);
		for (int i = 0; i < vertexCount; i++)
		{
			ref Vector3 reference = ref array[i];
			reference = new Vector3(array3[3 * i], array3[3 * i + 1], zDir);
		}
		for (int j = 0; j < triangleCount; j++)
		{
			array2[3 * j] = array4[3 * j + 2];
			array2[3 * j + 1] = array4[3 * j + 1];
			array2[3 * j + 2] = array4[3 * j];
		}
		Mesh mesh = new Mesh();
		mesh.name = "EyeMaskMesh";
		mesh.vertices = array;
		mesh.SetIndices(array2, MeshTopology.Triangles, 0);
		return mesh;
	}

	private Mesh GetStencilMeshBoth(Mesh leftMesh, Mesh rightMesh)
	{
		float num = Mathf.Max(Mathf.Abs(leftMesh.bounds.max.x), Mathf.Abs(rightMesh.bounds.min.x));
		Mesh mesh = new Mesh();
		mesh.name = "EyeMaskBoth";
		CombineInstance combineInstance = default(CombineInstance);
		combineInstance.mesh = leftMesh;
		Matrix4x4 identity = Matrix4x4.identity;
		identity.SetTRS(Vector3.left * num, Quaternion.identity, Vector3.one);
		combineInstance.transform = identity;
		CombineInstance combineInstance2 = default(CombineInstance);
		combineInstance2.mesh = rightMesh;
		Matrix4x4 identity2 = Matrix4x4.identity;
		identity2.SetTRS(Vector3.right * num, Quaternion.identity, Vector3.one);
		combineInstance2.transform = identity2;
		CombineInstance[] combine = new CombineInstance[2] { combineInstance, combineInstance2 };
		mesh.CombineMeshes(combine);
		return mesh;
	}

	private bool VerifyCommadBuffer()
	{
		if (cameraDataList == null || cameraDataList.Count <= 0)
		{
			return false;
		}
		foreach (EyeMaskData cameraData in cameraDataList)
		{
			if (cameraData == null || cameraData.cmdBuf == null)
			{
				return false;
			}
		}
		return true;
	}

	private void PrepareCameras()
	{
		cameraDataList.Clear();
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			if (Pvr_UnitySDKEyeManager.Instance.BothEyeCamera == null)
			{
				UnityEngine.Debug.LogWarning("BothEye Camera is null!");
				return;
			}
			EyeMaskData eyeMaskData = new EyeMaskData();
			eyeMaskData.eyeSide = Eye.BothEye;
			eyeMaskData.camera = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
			cameraDataList.Add(eyeMaskData);
		}
		else if (Pvr_UnitySDKEyeManager.Instance.LeftEyeCamera == null || Pvr_UnitySDKEyeManager.Instance.RightEyeCamera == null)
		{
			UnityEngine.Debug.LogWarning("LeftEye or RightEye Camera is null!");
		}
		else
		{
			EyeMaskData eyeMaskData2 = new EyeMaskData();
			eyeMaskData2.eyeSide = Eye.LeftEye;
			eyeMaskData2.camera = Pvr_UnitySDKEyeManager.Instance.LeftEyeCamera;
			eyeMaskData2.cmdBuf = null;
			cameraDataList.Add(eyeMaskData2);
			EyeMaskData eyeMaskData3 = new EyeMaskData();
			eyeMaskData3.eyeSide = Eye.RightEye;
			eyeMaskData3.camera = Pvr_UnitySDKEyeManager.Instance.RightEyeCamera;
			eyeMaskData3.cmdBuf = null;
			cameraDataList.Add(eyeMaskData3);
		}
	}

	private void AddCameraCommandBuffer(EyeMaskData data)
	{
		data.camera.AddCommandBuffer(CameraEvent.BeforeForwardOpaque, data.cmdBuf);
	}

	private void RemoveCameraCommandBuffer(EyeMaskData data)
	{
		data.camera.RemoveCommandBuffer(CameraEvent.BeforeForwardOpaque, data.cmdBuf);
	}

	private void CleanEyeMask()
	{
		cameraDataList.Clear();
		eyeMaskMeshLeft = null;
		eyeMaskMeshRight = null;
		eyeMaskMeshBoth = null;
		eyeMaskShader = null;
		eyeMaskMaterial = null;
	}
}
[RequireComponent(typeof(Camera))]
public class Pvr_UnitySDKEye : MonoBehaviour
{
	public static List<Pvr_UnitySDKEye> Instances = new List<Pvr_UnitySDKEye>();

	public Eye eyeSide;

	private int eyeCameraOriginCullingMask;

	private CameraClearFlags eyeCameraOriginClearFlag;

	private Color eyeCameraOriginBackgroundColor;

	private int lastBoundaryState;

	private Matrix4x4 realProj = Matrix4x4.identity;

	private const int bufferSize = 3;

	private int IDIndex;

	private RenderEventType eventType;

	private int previousId;

	public static bool setLevel = false;

	private Material mat_Vignette;

	public Camera eyecamera { get; private set; }

	private void Awake()
	{
		Instances.Add(this);
		eyecamera = GetComponent<Camera>();
	}

	private void Start()
	{
		Setup(eyeSide);
		SetupUpdate();
		if (eyecamera != null)
		{
			eyeCameraOriginCullingMask = eyecamera.cullingMask;
			eyeCameraOriginClearFlag = eyecamera.clearFlags;
			eyeCameraOriginBackgroundColor = eyecamera.backgroundColor;
		}
	}

	private void Update()
	{
		if (!(eyecamera != null) || !eyecamera.enabled)
		{
			return;
		}
		int num = BoundarySystem.UPvr_GetSeeThroughState();
		if (num == lastBoundaryState)
		{
			return;
		}
		switch (num)
		{
		case 2:
			eyeCameraOriginCullingMask = eyecamera.cullingMask;
			eyeCameraOriginClearFlag = eyecamera.clearFlags;
			eyeCameraOriginBackgroundColor = eyecamera.backgroundColor;
			eyecamera.cullingMask = 0;
			eyecamera.clearFlags = CameraClearFlags.Color;
			eyecamera.backgroundColor = Color.black;
			break;
		case 1:
			if (lastBoundaryState == 2)
			{
				if (eyecamera.cullingMask == 0)
				{
					eyecamera.cullingMask = eyeCameraOriginCullingMask;
				}
				if (eyecamera.clearFlags == CameraClearFlags.Color)
				{
					eyecamera.clearFlags = eyeCameraOriginClearFlag;
				}
				if (eyecamera.backgroundColor == Color.black)
				{
					eyecamera.backgroundColor = eyeCameraOriginBackgroundColor;
				}
			}
			break;
		default:
			if (lastBoundaryState == 2 || lastBoundaryState == 1)
			{
				if (eyecamera.cullingMask == 0)
				{
					eyecamera.cullingMask = eyeCameraOriginCullingMask;
				}
				if (eyecamera.clearFlags == CameraClearFlags.Color)
				{
					eyecamera.clearFlags = eyeCameraOriginClearFlag;
				}
				if (eyecamera.backgroundColor == Color.black)
				{
					eyecamera.backgroundColor = eyeCameraOriginBackgroundColor;
				}
			}
			break;
		}
		lastBoundaryState = num;
	}

	private void OnEnable()
	{
	}

	private void OnDisable()
	{
	}

	private void OnDestroy()
	{
		Instances.Remove(this);
	}

	public void MyPreRender(Camera camera)
	{
		if (!(camera.gameObject != base.gameObject))
		{
			OnPreRender();
		}
	}

	public void MyPreRender(ScriptableRenderContext context, Camera camera)
	{
		if (!(camera.gameObject != base.gameObject))
		{
			OnPreRender();
		}
	}

	public void MyPostRender(ScriptableRenderContext context, Camera camera)
	{
		if (!(camera.gameObject != base.gameObject))
		{
			OnPostRender();
		}
	}

	private void OnPreRender()
	{
		if (!eyecamera.enabled)
		{
			return;
		}
		if (Pvr_UnitySDKRender.Instance.StereoRendering != null)
		{
			if (Pvr_UnitySDKRender.Instance.isSwitchSDK)
			{
				return;
			}
			Pvr_UnitySDKRender.Instance.StereoRendering.OnSDKPreRender();
		}
		SetFFRParameter();
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.BeginEye);
	}

	private void OnPostRender()
	{
		if (!eyecamera.enabled)
		{
			return;
		}
		Pvr_UnitySDKAPI.System.UPvr_UnityEventData(Pvr_UnitySDKAPI.System.UPvr_GetEyeBufferData(Pvr_UnitySDKRender.Instance.eyeTextureIds[IDIndex]));
		Pvr_UnitySDKPluginEvent.Issue(eventType);
		if (Pvr_UnitySDKRender.Instance.StereoRendering != null)
		{
			if (Pvr_UnitySDKRender.Instance.isSwitchSDK)
			{
				return;
			}
			Pvr_UnitySDKRender.Instance.StereoRendering.OnSDKPostRender();
		}
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.EndEye);
	}

	public void EyeRender()
	{
		SetupUpdate();
		if (Pvr_UnitySDKRender.Instance.eyeTextures[IDIndex] != null)
		{
			Pvr_UnitySDKRender.Instance.eyeTextures[IDIndex].DiscardContents();
			eyecamera.targetTexture = Pvr_UnitySDKRender.Instance.eyeTextures[IDIndex];
		}
	}

	private void Setup(Eye eyeSide)
	{
		eyecamera = GetComponent<Camera>();
		switch (eyeSide)
		{
		case Eye.LeftEye:
		case Eye.RightEye:
			base.transform.localPosition = Pvr_UnitySDKManager.SDK.EyeOffset(eyeSide);
			break;
		case Eye.BothEye:
			base.transform.localPosition = Vector3.zero;
			break;
		}
		eyecamera.aspect = Pvr_UnitySDKManager.SDK.EyesAspect;
		eyecamera.rect = new Rect(0f, 0f, 1f, 1f);
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.MultiPass)
		{
			eventType = ((eyeSide != 0) ? RenderEventType.RightEyeEndFrame : RenderEventType.LeftEyeEndFrame);
		}
		else
		{
			eventType = RenderEventType.BothEyeEndFrame;
		}
	}

	private void SetupUpdate()
	{
		if (eyeSide == Eye.LeftEye || eyeSide == Eye.RightEye)
		{
			eyecamera.enabled = !Pvr_UnitySDKManager.SDK.Monoscopic && Pvr_UnitySDKRender.Instance.StereoRenderPath != StereoRenderingPathPico.SinglePass;
		}
		else if (eyeSide == Eye.BothEye)
		{
			eyecamera.enabled = Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass;
		}
		eyecamera.fieldOfView = Pvr_UnitySDKRender.Instance.EyeVFoV;
		eyecamera.aspect = Pvr_UnitySDKManager.SDK.EyesAspect;
		if (eyeSide == Eye.LeftEye || eyeSide == Eye.RightEye)
		{
			IDIndex = Pvr_UnitySDKRender.Instance.currEyeTextureIdx + (int)eyeSide * 3;
		}
		else if (eyeSide == Eye.BothEye)
		{
			IDIndex = Pvr_UnitySDKRender.Instance.currEyeTextureIdx;
			Pvr_UnitySDKRender.Instance.isSwitchSDK = Pvr_UnitySDKRender.Instance.lastEyeTextureIdx == Pvr_UnitySDKRender.Instance.currEyeTextureIdx;
			Pvr_UnitySDKRender.Instance.lastEyeTextureIdx = Pvr_UnitySDKRender.Instance.currEyeTextureIdx;
		}
	}

	public void RefreshCameraPosition(float ipd)
	{
		Pvr_UnitySDKManager.SDK.leftEyeOffset = new Vector3((0f - ipd) / 2f, 0f, 0f);
		Pvr_UnitySDKManager.SDK.rightEyeOffset = new Vector3(ipd / 2f, 0f, 0f);
		if (eyeSide == Eye.LeftEye || eyeSide == Eye.RightEye)
		{
			base.transform.localPosition = Pvr_UnitySDKManager.SDK.EyeOffset(eyeSide);
		}
		else if (eyeSide == Eye.BothEye)
		{
			eyecamera.stereoSeparation = ipd;
		}
	}

	private void DrawVignetteLine()
	{
		if (null == mat_Vignette)
		{
			mat_Vignette = new Material(Shader.Find("Diffuse"));
			if (null == mat_Vignette)
			{
				return;
			}
		}
		GL.PushMatrix();
		mat_Vignette.SetPass(0);
		GL.LoadOrtho();
		vignette();
		GL.PopMatrix();
	}

	private void vignette()
	{
		GL.Begin(7);
		GL.Color(Color.black);
		GL.Vertex3(0f, 1f, 0f);
		GL.Vertex3(1f, 1f, 0f);
		GL.Vertex3(1f, 0.995f, 0f);
		GL.Vertex3(0f, 0.995f, 0f);
		GL.Vertex3(0f, 0f, 0f);
		GL.Vertex3(0f, 0.005f, 0f);
		GL.Vertex3(1f, 0.005f, 0f);
		GL.Vertex3(1f, 0f, 0f);
		GL.Vertex(new Vector3(0f, 1f, 0f));
		GL.Vertex(new Vector3(0.005f, 1f, 0f));
		GL.Vertex(new Vector3(0.005f, 0f, 0f));
		GL.Vertex(new Vector3(0f, 0f, 0f));
		GL.Vertex(new Vector3(0.995f, 1f, 0f));
		GL.Vertex(new Vector3(1f, 1f, 0f));
		GL.Vertex(new Vector3(1f, 0f, 0f));
		GL.Vertex(new Vector3(0.995f, 0f, 0f));
		GL.End();
	}

	private void SetFFRParameter()
	{
		Vector3 vector = Vector3.zero;
		if (Pvr_UnitySDKManager.SDK.isEnterVRMode && Pvr_UnitySDKEyeManager.supportEyeTracking && Pvr_UnitySDKEyeManager.Instance.EyeTracking)
		{
			vector = Pvr_UnitySDKAPI.System.UPvr_getEyeTrackingPos();
		}
		int textureId = Pvr_UnitySDKRender.Instance.eyeTextureIds[IDIndex];
		Render.UPvr_SetFoveationResource(textureId, previousId, vector.x, vector.y);
		previousId = textureId;
	}
}
public class Pvr_UnitySDKEyeManager : MonoBehaviour
{
	private static Pvr_UnitySDKEyeManager instance;

	private Pvr_UnitySDKEye[] eyes;

	[HideInInspector]
	public Camera LeftEyeCamera;

	[HideInInspector]
	public Camera RightEyeCamera;

	[HideInInspector]
	public Camera MonoEyeCamera;

	[HideInInspector]
	public Camera BothEyeCamera;

	private int MonoEyeTextureID;

	private readonly int WaitSplashScreenFrames = 3;

	private int frameNum;

	[SerializeField]
	[HideInInspector]
	private bool foveatedRendering;

	[SerializeField]
	[HideInInspector]
	private EFoveationLevel foveationLevel;

	private int eyeTextureId;

	private RenderEventType eventType = RenderEventType.LeftEyeEndFrame;

	private Pvr_UnitySDKEyeOverlay compositeLayer;

	private int overlayLayerDepth = 1;

	private int underlayLayerDepth;

	private bool isHeadLocked;

	private int layerFlags;

	[HideInInspector]
	public bool EyeTracking;

	[HideInInspector]
	public Vector3 eyePoint;

	private EyeTrackingData eyePoseData;

	[HideInInspector]
	public static bool supportEyeTracking;

	[Tooltip("If true, specific color gradient when switching scenes.")]
	public bool screenFade;

	[Tooltip("Define the duration of screen fade.")]
	public float fadeTime = 5f;

	[Tooltip("Define the color of screen fade.")]
	public Color fadeColor = new Color(0f, 0f, 0f, 1f);

	public int renderQueue = 5000;

	private MeshRenderer fadeMeshRenderer;

	private MeshFilter fadeMeshFilter;

	private Material fadeMaterial;

	private float elapsedTime;

	private bool isFading;

	private float currentAlpha;

	private float nowFadeAlpha;

	public static Pvr_UnitySDKEyeManager Instance
	{
		get
		{
			if (instance == null)
			{
				PLOG.E("Pvr_UnitySDKEyeManager instance is not init yet...");
			}
			return instance;
		}
	}

	public Pvr_UnitySDKEye[] Eyes
	{
		get
		{
			if (eyes == null)
			{
				eyes = Pvr_UnitySDKEye.Instances.ToArray();
			}
			return eyes;
		}
	}

	[HideInInspector]
	public bool FoveatedRendering
	{
		get
		{
			return foveatedRendering;
		}
		set
		{
			if (value == foveatedRendering)
			{
				return;
			}
			foveatedRendering = value;
			if (UnityEngine.Application.isPlaying)
			{
				Render.UPvr_EnableFoveation(enable: true);
				if (!foveatedRendering)
				{
					Render.SetFoveatedRenderingLevel((EFoveationLevel)(-1));
				}
			}
		}
	}

	[HideInInspector]
	public EFoveationLevel FoveationLevel
	{
		get
		{
			return foveationLevel;
		}
		set
		{
			if (value != foveationLevel)
			{
				foveationLevel = value;
			}
		}
	}

	private void SetCameraEnableEditor()
	{
		MonoEyeCamera.enabled = !Pvr_UnitySDKManager.SDK.VRModeEnabled || Pvr_UnitySDKManager.SDK.Monoscopic;
		for (int i = 0; i < Eyes.Length; i++)
		{
			if (Eyes[i].eyeSide == Eye.LeftEye || Eyes[i].eyeSide == Eye.RightEye)
			{
				Eyes[i].eyecamera.enabled = Pvr_UnitySDKManager.SDK.VRModeEnabled;
			}
			else if (Eyes[i].eyeSide == Eye.BothEye)
			{
				Eyes[i].eyecamera.enabled = false;
			}
		}
	}

	private void SetCamerasEnableByStereoRendering()
	{
		MonoEyeCamera.enabled = Pvr_UnitySDKManager.SDK.Monoscopic && Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.MultiPass;
	}

	private void SetupMonoCamera()
	{
		base.transform.localPosition = Vector3.zero;
		MonoEyeCamera.aspect = Pvr_UnitySDKManager.SDK.EyesAspect;
		MonoEyeCamera.rect = new Rect(0f, 0f, 1f, 1f);
	}

	private void SetupUpdate()
	{
		MonoEyeCamera.fieldOfView = Pvr_UnitySDKRender.Instance.EyeVFoV;
		MonoEyeCamera.aspect = Pvr_UnitySDKManager.SDK.EyesAspect;
		MonoEyeTextureID = Pvr_UnitySDKRender.Instance.currEyeTextureIdx;
	}

	private void MonoEyeRender()
	{
		SetupUpdate();
		if (Pvr_UnitySDKRender.Instance.eyeTextures[MonoEyeTextureID] != null)
		{
			Pvr_UnitySDKRender.Instance.eyeTextures[MonoEyeTextureID].DiscardContents();
			MonoEyeCamera.targetTexture = Pvr_UnitySDKRender.Instance.eyeTextures[MonoEyeTextureID];
		}
	}

	private void Awake()
	{
		if (MonoEyeCamera == null)
		{
			MonoEyeCamera = GetComponent<Camera>();
		}
		if (LeftEyeCamera == null)
		{
			LeftEyeCamera = base.gameObject.transform.Find("LeftEye").GetComponent<Camera>();
		}
		if (RightEyeCamera == null)
		{
			RightEyeCamera = base.gameObject.transform.Find("RightEye").GetComponent<Camera>();
		}
		if (BothEyeCamera == null)
		{
			BothEyeCamera = base.gameObject.transform.Find("BothEye").GetComponent<Camera>();
		}
		if (BothEyeCamera != null)
		{
			BothEyeCamera.transform.GetComponent<Pvr_UnitySDKEye>().eyeSide = Eye.BothEye;
		}
		CreateFadeMesh();
		SetCurrentAlpha(0f);
		Render.UPvr_EnableFoveation(enable: true);
		if (foveatedRendering)
		{
			Render.SetFoveatedRenderingLevel(foveationLevel);
		}
		else
		{
			Render.SetFoveatedRenderingLevel((EFoveationLevel)(-1));
		}
		Pvr_UnitySDKManager.eventEnterVRMode = (Func<bool>)Delegate.Combine(Pvr_UnitySDKManager.eventEnterVRMode, new Func<bool>(SetEyeTrackingMode));
	}

	private void OnEnable()
	{
		if (instance == null)
		{
			instance = this;
		}
		else if (instance != this)
		{
			instance = this;
		}
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			Pvr_UnitySDKRender.Instance.StereoRendering.InitEye(BothEyeCamera);
		}
		foreach (Pvr_UnitySDKEyeOverlay instance in Pvr_UnitySDKEyeOverlay.Instances)
		{
			instance.RefreshCamera();
			if (instance.overlayType == Pvr_UnitySDKEyeOverlay.OverlayType.Overlay)
			{
				if (instance.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Cylinder)
				{
					UnityEngine.Debug.Log("DISFT Cylinder OverLay = Enable");
				}
				if (instance.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Equirect)
				{
					UnityEngine.Debug.Log("DISFT 360 OverLay= Enable");
				}
				if (instance.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Quad)
				{
					UnityEngine.Debug.Log("DISFT 2D OverLay= Enable");
				}
			}
			if (instance.overlayType == Pvr_UnitySDKEyeOverlay.OverlayType.Underlay)
			{
				UnityEngine.Debug.Log("DISFT UnderLay= Enable");
			}
		}
		GfxDeviceAdvanceFrameGLES();
		StartCoroutine("EndOfFrame");
		if (screenFade)
		{
			StartCoroutine(ScreenFade(1f, 0f));
		}
	}

	private void Start()
	{
		SetCamerasEnableByStereoRendering();
		SetupMonoCamera();
	}

	private void Update()
	{
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			for (int i = 0; i < Eyes.Length; i++)
			{
				if (Eyes[i].isActiveAndEnabled && Eyes[i].eyeSide == Eye.BothEye)
				{
					Eyes[i].EyeRender();
				}
			}
		}
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath != 0)
		{
			return;
		}
		if (!Pvr_UnitySDKManager.SDK.Monoscopic)
		{
			for (int j = 0; j < Eyes.Length; j++)
			{
				if (Eyes[j].isActiveAndEnabled && Eyes[j].eyeSide != Eye.BothEye)
				{
					Eyes[j].EyeRender();
				}
			}
		}
		else
		{
			MonoEyeRender();
		}
	}

	private void OnPause()
	{
		Pvr_UnitySDKManager.eventEnterVRMode = (Func<bool>)Delegate.Remove(Pvr_UnitySDKManager.eventEnterVRMode, new Func<bool>(SetEyeTrackingMode));
	}

	private void OnDisable()
	{
		StopAllCoroutines();
	}

	private void OnDestroy()
	{
		DestoryFadeMesh();
	}

	private void OnPostRender()
	{
		long data = Pvr_UnitySDKAPI.System.UPvr_GetEyeBufferData(Pvr_UnitySDKRender.Instance.eyeTextureIds[Pvr_UnitySDKRender.Instance.currEyeTextureIdx]);
		Pvr_UnitySDKAPI.System.UPvr_UnityEventData(data);
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.LeftEyeEndFrame);
		Pvr_UnitySDKAPI.System.UPvr_UnityEventData(data);
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.RightEyeEndFrame);
	}

	private IEnumerator EndOfFrame()
	{
		while (true)
		{
			yield return new WaitForEndOfFrame();
			if (!Pvr_UnitySDKManager.SDK.isEnterVRMode)
			{
				GL.Clear(clearDepth: false, clearColor: true, Color.black);
			}
			if (Pvr_UnitySDKRender.Instance.isFirstStartup && frameNum == WaitSplashScreenFrames)
			{
				Pvr_UnitySDKAPI.System.UPvr_RemovePlatformLogo();
				if (Pvr_UnitySDKManager.SDK.ResetTrackerOnLoad)
				{
					UnityEngine.Debug.Log("Reset Tracker OnLoad");
					Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
				}
				Pvr_UnitySDKAPI.System.UPvr_StartVRModel();
				Pvr_UnitySDKRender.Instance.isFirstStartup = false;
			}
			else if (Pvr_UnitySDKRender.Instance.isFirstStartup && frameNum < WaitSplashScreenFrames)
			{
				PLOG.I("frameNum:" + frameNum);
				frameNum++;
			}
			int boundaryState = BoundarySystem.UPvr_GetSeeThroughState();
			if (Pvr_UnitySDKEyeOverlay.Instances.Count > 0 && boundaryState != 2)
			{
				overlayLayerDepth = 1;
				underlayLayerDepth = 0;
				Pvr_UnitySDKEyeOverlay.Instances.Sort();
				for (int i = 0; i < Pvr_UnitySDKEyeOverlay.Instances.Count; i++)
				{
					compositeLayer = Pvr_UnitySDKEyeOverlay.Instances[i];
					if (!compositeLayer.isActiveAndEnabled || (compositeLayer.layerTextures[0] == null && compositeLayer.layerTextures[1] == null && !compositeLayer.isExternalAndroidSurface) || (compositeLayer.layerTransform != null && !compositeLayer.layerTransform.gameObject.activeSelf))
					{
						continue;
					}
					layerFlags = 0;
					if (compositeLayer.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Quad || compositeLayer.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Cylinder)
					{
						if (compositeLayer.overlayType == Pvr_UnitySDKEyeOverlay.OverlayType.Overlay)
						{
							isHeadLocked = false;
							if (compositeLayer.layerTransform != null && compositeLayer.layerTransform.parent == base.transform)
							{
								isHeadLocked = true;
							}
							if (compositeLayer.isExternalAndroidSurface)
							{
								layerFlags |= 1;
								CreateExternalSurface(compositeLayer, overlayLayerDepth);
							}
							Render.UPvr_SetOverlayModelViewMatrix((int)compositeLayer.overlayType, (int)compositeLayer.overlayShape, compositeLayer.layerTextureIds[0], 0, overlayLayerDepth, isHeadLocked, layerFlags, compositeLayer.MVMatrixs[0], compositeLayer.ModelScales[0], compositeLayer.ModelRotations[0], compositeLayer.ModelTranslations[0], compositeLayer.CameraRotations[0], compositeLayer.CameraTranslations[0], compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
							Render.UPvr_SetOverlayModelViewMatrix((int)compositeLayer.overlayType, (int)compositeLayer.overlayShape, compositeLayer.layerTextureIds[1], 1, overlayLayerDepth, isHeadLocked, layerFlags, compositeLayer.MVMatrixs[1], compositeLayer.ModelScales[1], compositeLayer.ModelRotations[1], compositeLayer.ModelTranslations[1], compositeLayer.CameraRotations[1], compositeLayer.CameraTranslations[1], compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
							overlayLayerDepth++;
						}
						else if (compositeLayer.overlayType == Pvr_UnitySDKEyeOverlay.OverlayType.Underlay)
						{
							if (compositeLayer.isExternalAndroidSurface)
							{
								layerFlags |= 1;
								CreateExternalSurface(compositeLayer, underlayLayerDepth);
							}
							Render.UPvr_SetOverlayModelViewMatrix((int)compositeLayer.overlayType, (int)compositeLayer.overlayShape, compositeLayer.layerTextureIds[0], 0, underlayLayerDepth, isHeadLocked: false, layerFlags, compositeLayer.MVMatrixs[0], compositeLayer.ModelScales[0], compositeLayer.ModelRotations[0], compositeLayer.ModelTranslations[0], compositeLayer.CameraRotations[0], compositeLayer.CameraTranslations[0], compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
							Render.UPvr_SetOverlayModelViewMatrix((int)compositeLayer.overlayType, (int)compositeLayer.overlayShape, compositeLayer.layerTextureIds[1], 1, underlayLayerDepth, isHeadLocked: false, layerFlags, compositeLayer.MVMatrixs[1], compositeLayer.ModelScales[1], compositeLayer.ModelRotations[1], compositeLayer.ModelTranslations[1], compositeLayer.CameraRotations[1], compositeLayer.CameraTranslations[1], compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
							underlayLayerDepth++;
						}
					}
					else if (compositeLayer.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Equirect)
					{
						if (compositeLayer.isExternalAndroidSurface)
						{
							layerFlags |= 1;
							CreateExternalSurface(compositeLayer, 0);
						}
						Render.UPvr_SetupLayerData(0, 0, compositeLayer.layerTextureIds[0], (int)compositeLayer.overlayShape, layerFlags, compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
						Render.UPvr_SetupLayerData(0, 1, compositeLayer.layerTextureIds[1], (int)compositeLayer.overlayShape, layerFlags, compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
					}
				}
			}
			Pvr_UnitySDKAPI.System.UPvr_UnityEventData(Pvr_UnitySDKAPI.System.UPvr_GetEyeBufferData(0));
			Pvr_UnitySDKPluginEvent.Issue(RenderEventType.TimeWarp);
			Pvr_UnitySDKRender.Instance.currEyeTextureIdx = Pvr_UnitySDKRender.Instance.nextEyeTextureIdx;
			Pvr_UnitySDKRender.Instance.nextEyeTextureIdx = (Pvr_UnitySDKRender.Instance.nextEyeTextureIdx + 1) % 3;
		}
	}

	private void CreateExternalSurface(Pvr_UnitySDKEyeOverlay overlayInstance, int layerDepth)
	{
		if (overlayInstance.externalAndroidSurfaceObject == IntPtr.Zero)
		{
			overlayInstance.externalAndroidSurfaceObject = Render.UPvr_CreateLayerAndroidSurface((int)overlayInstance.overlayType, layerDepth);
			UnityEngine.Debug.LogFormat("CreateExternalSurface: Overlay Type:{0}, LayerDepth:{1}, SurfaceObject:{2}", overlayInstance.overlayType, layerDepth, overlayInstance.externalAndroidSurfaceObject);
			if (overlayInstance.externalAndroidSurfaceObject != IntPtr.Zero && overlayInstance.externalAndroidSurfaceObjectCreated != null)
			{
				overlayInstance.externalAndroidSurfaceObjectCreated();
			}
		}
	}

	public bool SetEyeTrackingMode()
	{
		int num = Pvr_UnitySDKAPI.System.UPvr_GetTrackingMode();
		supportEyeTracking = (num & 4) != 0;
		bool flag = false;
		if (EyeTracking && supportEyeTracking)
		{
			flag = Pvr_UnitySDKAPI.System.UPvr_setTrackingMode(6);
		}
		UnityEngine.Debug.Log("SetEyeTrackingMode EyeTracking " + EyeTracking + " supportEyeTracking " + supportEyeTracking + " result " + flag);
		return flag;
	}

	public Vector3 GetEyeTrackingPos()
	{
		if (!Instance.EyeTracking)
		{
			return Vector3.zero;
		}
		bool flag = Pvr_UnitySDKAPI.System.UPvr_getEyeTrackingData(ref eyePoseData);
		if (!flag)
		{
			PLOG.E("UPvr_getEyeTrackingData failed " + flag);
			return Vector3.zero;
		}
		EyeDeviceInfo deviceInfo = GetDeviceInfo();
		Vector3 zero = Vector3.zero;
		zero.x = 0.5f * (deviceInfo.targetFrustumLeft.right - deviceInfo.targetFrustumLeft.left);
		zero.y = 0.5f * (deviceInfo.targetFrustumLeft.top - deviceInfo.targetFrustumLeft.bottom);
		zero.z = deviceInfo.targetFrustumLeft.near;
		Vector3 foveatedGazeDirection = eyePoseData.foveatedGazeDirection;
		float num = Vector3.Dot(foveatedGazeDirection, Vector3.forward);
		if (num > float.Epsilon)
		{
			eyePoint = foveatedGazeDirection * (zero.z / num);
			eyePoint.x /= zero.x;
			eyePoint.y /= zero.y;
		}
		return eyePoint;
	}

	private EyeDeviceInfo GetDeviceInfo()
	{
		float eyeVFoV = Pvr_UnitySDKRender.Instance.EyeVFoV;
		float num = Mathf.Tan(eyeVFoV / 2f * ((float)Math.PI / 180f));
		float eyeHFoV = Pvr_UnitySDKRender.Instance.EyeHFoV;
		float num2 = Mathf.Tan(eyeHFoV / 2f * ((float)Math.PI / 180f));
		EyeDeviceInfo result = default(EyeDeviceInfo);
		result.targetFrustumLeft.left = 0f - LeftEyeCamera.nearClipPlane * num2;
		result.targetFrustumLeft.right = LeftEyeCamera.nearClipPlane * num2;
		result.targetFrustumLeft.top = LeftEyeCamera.nearClipPlane * num;
		result.targetFrustumLeft.bottom = 0f - LeftEyeCamera.nearClipPlane * num;
		result.targetFrustumLeft.near = LeftEyeCamera.nearClipPlane;
		result.targetFrustumLeft.far = LeftEyeCamera.farClipPlane;
		result.targetFrustumRight.left = 0f - RightEyeCamera.nearClipPlane * num2;
		result.targetFrustumRight.right = RightEyeCamera.nearClipPlane * num2;
		result.targetFrustumRight.top = RightEyeCamera.nearClipPlane * num;
		result.targetFrustumRight.bottom = 0f - RightEyeCamera.nearClipPlane * num;
		result.targetFrustumRight.near = RightEyeCamera.nearClipPlane;
		result.targetFrustumRight.far = RightEyeCamera.farClipPlane;
		return result;
	}

	private void CreateFadeMesh()
	{
		fadeMaterial = new Material(Shader.Find("Pvr_UnitySDK/Fade"));
		fadeMeshFilter = base.gameObject.AddComponent<MeshFilter>();
		fadeMeshRenderer = base.gameObject.AddComponent<MeshRenderer>();
		Mesh mesh = new Mesh();
		fadeMeshFilter.mesh = mesh;
		Vector3[] array = new Vector3[4];
		float num = 2f;
		float num2 = 2f;
		float z = 1f;
		ref Vector3 reference = ref array[0];
		reference = new Vector3(0f - num, 0f - num2, z);
		ref Vector3 reference2 = ref array[1];
		reference2 = new Vector3(num, 0f - num2, z);
		ref Vector3 reference3 = ref array[2];
		reference3 = new Vector3(0f - num, num2, z);
		ref Vector3 reference4 = ref array[3];
		reference4 = new Vector3(num, num2, z);
		mesh.vertices = array;
		mesh.triangles = new int[6] { 0, 2, 1, 2, 3, 1 };
		mesh.normals = new Vector3[4]
		{
			-Vector3.forward,
			-Vector3.forward,
			-Vector3.forward,
			-Vector3.forward
		};
		mesh.uv = new Vector2[4]
		{
			new Vector2(0f, 0f),
			new Vector2(1f, 0f),
			new Vector2(0f, 1f),
			new Vector2(1f, 1f)
		};
	}

	private void DestoryFadeMesh()
	{
		if (fadeMeshRenderer != null)
		{
			UnityEngine.Object.Destroy(fadeMeshRenderer);
		}
		if (fadeMaterial != null)
		{
			UnityEngine.Object.Destroy(fadeMaterial);
		}
		if (fadeMeshFilter != null)
		{
			UnityEngine.Object.Destroy(fadeMeshFilter);
		}
	}

	public void SetCurrentAlpha(float alpha)
	{
		currentAlpha = alpha;
		SetMaterialAlpha();
	}

	private IEnumerator ScreenFade(float startAlpha, float endAlpha)
	{
		float elapsedTime = 0f;
		while (elapsedTime < fadeTime)
		{
			elapsedTime += Time.deltaTime;
			nowFadeAlpha = Mathf.Lerp(startAlpha, endAlpha, Mathf.Clamp01(elapsedTime / fadeTime));
			SetMaterialAlpha();
			yield return new WaitForEndOfFrame();
		}
	}

	private void SetMaterialAlpha()
	{
		Color color = fadeColor;
		color.a = Mathf.Max(currentAlpha, nowFadeAlpha);
		isFading = color.a > 0f;
		if (fadeMaterial != null)
		{
			fadeMaterial.color = color;
			fadeMaterial.renderQueue = renderQueue;
			fadeMeshRenderer.material = fadeMaterial;
			fadeMeshRenderer.enabled = isFading;
		}
	}

	public bool GfxDeviceAdvanceFrameGLES()
	{
		return false;
	}
}
public class Pvr_UnitySDKEyeOverlay : MonoBehaviour, IComparable<Pvr_UnitySDKEyeOverlay>
{
	public delegate void ExternalAndroidSurfaceObjectCreated();

	public enum OverlayShape
	{
		Quad,
		Cylinder,
		Equirect
	}

	public enum OverlayType
	{
		Overlay,
		Underlay
	}

	public enum OverlayTexFilterMode
	{
		NotCare,
		Nearest,
		Linear,
		Nearest_Mipmap_Nearest,
		Linear_Mipmap_Nearest,
		Nearest_Mipmap_Linear,
		Linear_Mipmap_Linear
	}

	public static List<Pvr_UnitySDKEyeOverlay> Instances = new List<Pvr_UnitySDKEyeOverlay>();

	public int layerIndex;

	public OverlayType overlayType;

	public OverlayShape overlayShape;

	public Transform layerTransform;

	public Texture[] layerTextures = new Texture[2];

	public int[] layerTextureIds = new int[2];

	public Matrix4x4[] MVMatrixs = new Matrix4x4[2];

	public Vector3[] ModelScales = new Vector3[2];

	public Quaternion[] ModelRotations = new Quaternion[2];

	public Vector3[] ModelTranslations = new Vector3[2];

	public Quaternion[] CameraRotations = new Quaternion[2];

	public Vector3[] CameraTranslations = new Vector3[2];

	public Camera[] layerEyeCamera = new Camera[2];

	public bool overrideColorScaleAndOffset;

	public Vector4 colorScale = Vector4.one;

	public Vector4 colorOffset = Vector4.zero;

	private Vector4 overlayLayerColorScaleDefault = Vector4.one;

	private Vector4 overlayLayerColorOffsetDefault = Vector4.zero;

	public bool isExternalAndroidSurface;

	public IntPtr externalAndroidSurfaceObject = IntPtr.Zero;

	public ExternalAndroidSurfaceObjectCreated externalAndroidSurfaceObjectCreated;

	public int CompareTo(Pvr_UnitySDKEyeOverlay other)
	{
		return layerIndex.CompareTo(other.layerIndex);
	}

	private void Awake()
	{
		Instances.Add(this);
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
		}
		else if (Pvr_UnitySDKManager.SDK.Monoscopic)
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.MonoEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.MonoEyeCamera;
		}
		else
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.LeftEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.RightEyeCamera;
		}
		layerTransform = GetComponent<Transform>();
		if (layerTransform != null)
		{
			MeshRenderer component = layerTransform.GetComponent<MeshRenderer>();
			if (component != null)
			{
				component.enabled = false;
			}
		}
		InitializeBuffer();
	}

	private void LateUpdate()
	{
		UpdateCoords();
	}

	private void OnDestroy()
	{
		Instances.Remove(this);
	}

	public void RefreshCamera()
	{
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
		}
		else if (Pvr_UnitySDKManager.SDK.Monoscopic)
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.MonoEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.MonoEyeCamera;
		}
		else
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.LeftEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.RightEyeCamera;
		}
	}

	private void InitializeBuffer()
	{
		switch (overlayShape)
		{
		case OverlayShape.Quad:
		case OverlayShape.Cylinder:
		case OverlayShape.Equirect:
		{
			for (int i = 0; i < layerTextureIds.Length; i++)
			{
				if (layerTextures[i] != null)
				{
					layerTextureIds[i] = layerTextures[i].GetNativeTexturePtr().ToInt32();
				}
				else
				{
					UnityEngine.Debug.LogWarning($"{(Eye)i} Texture is null!");
				}
			}
			break;
		}
		}
	}

	private void UpdateCoords()
	{
		if (layerTransform == null || !layerTransform.gameObject.activeSelf || layerEyeCamera[0] == null || layerEyeCamera[1] == null)
		{
			return;
		}
		for (int i = 0; i < MVMatrixs.Length; i++)
		{
			if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
			{
				Matrix4x4[] stereoWorldToCameraMat = Pvr_UnitySDKSinglePass.GetStereoWorldToCameraMat();
				ref Matrix4x4 reference = ref MVMatrixs[i];
				reference = stereoWorldToCameraMat[i] * layerTransform.localToWorldMatrix;
			}
			else
			{
				ref Matrix4x4 reference2 = ref MVMatrixs[i];
				reference2 = layerEyeCamera[i].worldToCameraMatrix * layerTransform.localToWorldMatrix;
			}
			ref Vector3 reference3 = ref ModelScales[i];
			reference3 = layerTransform.localScale;
			ref Quaternion reference4 = ref ModelRotations[i];
			reference4 = layerTransform.rotation;
			ref Vector3 reference5 = ref ModelTranslations[i];
			reference5 = layerTransform.position;
			ref Quaternion reference6 = ref CameraRotations[i];
			reference6 = layerEyeCamera[i].transform.rotation;
			ref Vector3 reference7 = ref CameraTranslations[i];
			reference7 = layerEyeCamera[i].transform.position;
		}
	}

	public void SetTexture(Texture texture)
	{
		for (int i = 0; i < layerTextures.Length; i++)
		{
			layerTextures[i] = texture;
		}
		InitializeBuffer();
	}

	public void SetLayerColorScaleAndOffset(Vector4 scale, Vector4 offset)
	{
		colorScale = scale;
		colorOffset = offset;
	}

	public Vector4 GetLayerColorScale()
	{
		if (!overrideColorScaleAndOffset)
		{
			return overlayLayerColorScaleDefault;
		}
		return colorScale;
	}

	public Vector4 GetLayerColorOffset()
	{
		if (!overrideColorScaleAndOffset)
		{
			return overlayLayerColorOffsetDefault;
		}
		return colorOffset;
	}
}
public class Pvr_UnitySDKRender
{
	private static Pvr_UnitySDKRender instance;

	public AndroidJavaObject activity;

	public static AndroidJavaClass javaVrActivityClass;

	public static AndroidJavaClass javaSysActivityClass;

	public static AndroidJavaClass javaserviceClass;

	public static AndroidJavaClass javaVrActivityLongReceiver;

	public static AndroidJavaClass javaVrActivityClientClass;

	private bool canConnecttoActivity;

	private bool isInitrenderThread = true;

	private string model;

	private Vector2 prefinger1 = new Vector2(0f, 0f);

	private Vector2 prefinger2 = new Vector2(0f, 0f);

	public int eyeTextureCount = 6;

	public RenderTexture[] eyeTextures;

	public int[] eyeTextureIds;

	public int currEyeTextureIdx;

	public int nextEyeTextureIdx = 1;

	public int lastEyeTextureIdx;

	public bool isSwitchSDK;

	public int RenderviewNumber;

	public bool isFirstStartup = true;

	public bool isShellMode;

	private StereoRenderingPathPico stereoRenderPath;

	private float rtScaleFactor = 1f;

	private float eyeVFov = 90f;

	private float eyeHFov = 90f;

	public static Pvr_UnitySDKRender Instance
	{
		get
		{
			if (instance == null)
			{
				instance = new Pvr_UnitySDKRender();
			}
			return instance;
		}
		set
		{
			instance = value;
		}
	}

	public StereoRenderingPathPico StereoRenderPath => stereoRenderPath;

	public SDKStereoRendering StereoRendering { get; private set; }

	public float RtScaleFactor
	{
		get
		{
			return rtScaleFactor;
		}
		set
		{
			if (value != rtScaleFactor)
			{
				rtScaleFactor = value;
				ReCreateEyeBuffer();
			}
		}
	}

	public float EyeVFoV
	{
		get
		{
			return eyeVFov;
		}
		set
		{
			if (value != eyeVFov)
			{
				eyeVFov = value;
			}
		}
	}

	public float EyeHFoV
	{
		get
		{
			return eyeHFov;
		}
		set
		{
			if (value != eyeHFov)
			{
				eyeHFov = value;
			}
		}
	}

	public Pvr_UnitySDKRender()
	{
		if (!canConnecttoActivity)
		{
			ConnectToAndriod();
			PLOG.I("PvrLog Init Render Ability Success!");
			isInitrenderThread = false;
		}
		Init();
	}

	public void ConnectToAndriod()
	{
		try
		{
			UnityEngine.Debug.Log("PvrLog SDK Version :  " + Pvr_UnitySDKAPI.System.UPvr_GetSDKVersion().ToString() + "  Unity Script Version :" + Pvr_UnitySDKAPI.System.UPvr_GetUnitySDKVersion().ToString());
			AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
			activity = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
			javaVrActivityClass = new AndroidJavaClass("com.psmart.vrlib.VrActivity");
			javaserviceClass = new AndroidJavaClass("com.picovr.picovrlib.hummingbirdclient.UnityClient");
			javaVrActivityLongReceiver = new AndroidJavaClass("com.psmart.vrlib.HomeKeyReceiver");
			javaSysActivityClass = new AndroidJavaClass("com.psmart.aosoperation.SysActivity");
			javaVrActivityClientClass = new AndroidJavaClass("com.psmart.vrlib.PvrClient");
			Pvr_UnitySDKAPI.System.Pvr_SetInitActivity(activity.GetRawObject(), javaVrActivityClass.GetRawClass());
			model = javaVrActivityClass.CallStatic<string>("Pvr_GetBuildModel", Array.Empty<object>());
			double[] result = new double[5];
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaVrActivityClass, "getDPIParameters", activity);
			int res = -1;
			int configsenum = 4;
			Render.UPvr_GetIntConfig(configsenum, ref res);
			string result2 = string.Empty;
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result2, javaserviceClass, "getSysproc", "persist.pvr.debug.appfps");
			if (result2 != string.Empty)
			{
				Pvr_UnitySDKManager.SDK.systemFPS = Convert.ToBoolean(Convert.ToInt16(result2));
			}
			if (res == 0)
			{
				Render.UPvr_ChangeScreenParameters(model, (int)result[0], (int)result[1], result[2], result[3], result[4]);
				Screen.sleepTimeout = -1;
			}
			if (Pvr_UnitySDKAPI.System.UPvr_IsPicoActivity())
			{
				UnityEngine.Debug.Log("ConnectToAndriod set monoPresentation success ?-------------" + Pvr_UnitySDKAPI.System.UPvr_SetMonoPresentation());
				UnityEngine.Debug.Log("ConnectToAndriod presentation existed ?-------------" + Pvr_UnitySDKAPI.System.UPvr_IsPresentationExisted());
			}
			isShellMode = GetIsShellMode();
			UnityEngine.Debug.Log("ConnectToAndriod isShellMode ?-------------" + isShellMode);
		}
		catch (AndroidJavaException ex)
		{
			PLOG.E("ConnectToAndriod--catch" + ex.Message);
		}
		canConnecttoActivity = true;
	}

	public void Init()
	{
		if (InitRenderAbility())
		{
			UnityEngine.Debug.Log("PvrLog Init Render Ability Success!");
			isInitrenderThread = false;
		}
		else
		{
			UnityEngine.Debug.Log("PvrLog Init Render Ability Failed!");
		}
	}

	private bool InitRenderAbility()
	{
		if (UpdateRenderParaFrame() && CreateEyeBuffer())
		{
			float num = Pvr_UnitySDKAPI.System.UPvr_GetIPD();
			Pvr_UnitySDKManager.SDK.leftEyeOffset = new Vector3((0f - num) / 2f, 0f, 0f);
			Pvr_UnitySDKManager.SDK.rightEyeOffset = new Vector3(num / 2f, 0f, 0f);
			return true;
		}
		return false;
	}

	private bool UpdateRenderParaFrame()
	{
		EyeVFoV = GetEyeVFOV();
		EyeHFoV = GetEyeHFOV();
		Pvr_UnitySDKManager.SDK.EyesAspect = EyeHFoV / EyeVFoV;
		return true;
	}

	private bool CreateEyeBuffer()
	{
		Vector2 eyeBufferResolution = GetEyeBufferResolution();
		if (isFirstStartup)
		{
			InitSinglePass();
			Pvr_UnitySDKAPI.System.UPvr_SetSinglePassDepthBufferWidthHeight((int)eyeBufferResolution.x, (int)eyeBufferResolution.y);
		}
		eyeTextures = new RenderTexture[eyeTextureCount];
		eyeTextureIds = new int[eyeTextureCount];
		for (int i = 0; i < eyeTextureCount; i++)
		{
			if (null == eyeTextures[i])
			{
				try
				{
					ConfigureEyeBuffer(i, eyeBufferResolution);
				}
				catch (Exception ex)
				{
					PLOG.E("ConfigureEyeBuffer ERROR " + ex.Message);
					throw;
				}
			}
			if (!eyeTextures[i].IsCreated())
			{
				eyeTextures[i].Create();
				eyeTextureIds[i] = eyeTextures[i].GetNativeTexturePtr().ToInt32();
			}
			eyeTextureIds[i] = eyeTextures[i].GetNativeTexturePtr().ToInt32();
		}
		return true;
	}

	private void InitSinglePass()
	{
		bool flag = true;
		if (Pvr_UnitySDKProjectSetting.GetProjectConfig().usesinglepass)
		{
			bool flag2 = false;
			if (flag)
			{
				flag2 = Pvr_UnitySDKAPI.System.UPvr_EnableSinglePass(enable: true);
			}
			if (flag2)
			{
				StereoRendering = new Pvr_UnitySDKSinglePass();
				stereoRenderPath = StereoRenderingPathPico.SinglePass;
				eyeTextureCount = 3;
			}
			UnityEngine.Debug.Log("EnableSinglePass supportSinglePass " + flag.ToString() + " result " + flag2);
		}
	}

	public float GetEyeVFOV()
	{
		float res = 102f;
		try
		{
			int configsenum = 1;
			Render.UPvr_GetFloatConfig(configsenum, ref res);
			if (res <= 0f)
			{
				res = 102f;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("GetEyeVFOV ERROR! " + ex.Message);
			throw;
		}
		return res;
	}

	public float GetEyeHFOV()
	{
		float res = 102f;
		try
		{
			int configsenum = 2;
			Render.UPvr_GetFloatConfig(configsenum, ref res);
			if (res <= 0f)
			{
				res = 102f;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("GetEyeHFOV ERROR! " + ex.Message);
			throw;
		}
		return res;
	}

	private void ConfigureEyeBuffer(int eyeTextureIndex, Vector2 resolution)
	{
		int width = (int)resolution.x;
		int height = (int)resolution.y;
		eyeTextures[eyeTextureIndex] = new RenderTexture(width, height, (int)Pvr_UnitySDKProjectSetting.GetProjectConfig().rtBitDepth, Pvr_UnitySDKProjectSetting.GetProjectConfig().rtFormat);
		if (StereoRenderPath == StereoRenderingPathPico.MultiPass)
		{
			eyeTextures[eyeTextureIndex].anisoLevel = 0;
			eyeTextures[eyeTextureIndex].antiAliasing = Mathf.Max(QualitySettings.antiAliasing, (int)Pvr_UnitySDKProjectSetting.GetProjectConfig().rtAntiAlising);
			UnityEngine.Debug.Log("MultiPass ConfigureEyeBuffer eyeTextureIndex " + eyeTextureIndex);
		}
		else if (StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			eyeTextures[eyeTextureIndex].useMipMap = false;
			eyeTextures[eyeTextureIndex].wrapMode = TextureWrapMode.Clamp;
			eyeTextures[eyeTextureIndex].filterMode = FilterMode.Bilinear;
			eyeTextures[eyeTextureIndex].anisoLevel = 1;
			eyeTextures[eyeTextureIndex].dimension = TextureDimension.Tex2DArray;
			eyeTextures[eyeTextureIndex].volumeDepth = 2;
			UnityEngine.Debug.Log("SinglePass ConfigureEyeBuffer eyeTextureIndex " + eyeTextureIndex);
		}
		eyeTextures[eyeTextureIndex].Create();
		if (eyeTextures[eyeTextureIndex].IsCreated())
		{
			eyeTextureIds[eyeTextureIndex] = eyeTextures[eyeTextureIndex].GetNativeTexturePtr().ToInt32();
			UnityEngine.Debug.Log("eyeTextureIndex : " + eyeTextureIndex);
		}
	}

	public bool ReCreateEyeBuffer()
	{
		if (!Pvr_UnitySDKProjectSetting.GetProjectConfig().usedefaultRenderTexture)
		{
			for (int i = 0; i < eyeTextureCount; i++)
			{
				if (eyeTextures[i] != null)
				{
					eyeTextures[i].Release();
				}
			}
			Array.Clear(eyeTextures, 0, eyeTextures.Length);
			return CreateEyeBuffer();
		}
		return false;
	}

	public void ReInit()
	{
		if (canConnecttoActivity && isInitrenderThread)
		{
			Init();
		}
	}

	public void IssueRenderThread()
	{
		if (canConnecttoActivity && !isInitrenderThread)
		{
			switch (QualitySettings.activeColorSpace)
			{
			case ColorSpace.Gamma:
				Render.UPvr_SetColorspaceType(0);
				break;
			case ColorSpace.Linear:
				Render.UPvr_SetColorspaceType(1);
				break;
			}
			Pvr_UnitySDKPluginEvent.Issue(RenderEventType.InitRenderThread);
			isInitrenderThread = true;
			if (StereoRendering != null)
			{
				StereoRendering.OnSDKRenderInited();
			}
			UnityEngine.Debug.Log("PvrLog IssueRenderThread end");
		}
		else
		{
			PLOG.I("PvrLog IssueRenderThread  canConnecttoActivity = " + canConnecttoActivity);
		}
	}

	private void AutoAdpatForPico1s()
	{
		Vector2 position = Input.touches[0].position;
		Vector2 position2 = Input.touches[1].position;
		if (Vector2.Distance(prefinger1, position) > 2f && Vector2.Distance(prefinger2, position2) > 2f)
		{
			float midH = (Input.touches[0].position.x + Input.touches[1].position.x) / (float)Screen.width - 1f;
			float midV = (Input.touches[0].position.y + Input.touches[1].position.y) / (float)Screen.height - 1f;
			Render.UPvr_SetRatio(midH, midV);
		}
		prefinger1 = position;
		prefinger2 = position2;
	}

	public Vector2 GetEyeBufferResolution()
	{
		int res = 1024;
		int res2 = 1024;
		if (Pvr_UnitySDKProjectSetting.GetProjectConfig().usedefaultRenderTexture)
		{
			try
			{
				int configsenum = 0;
				Render.UPvr_GetIntConfig(configsenum, ref res);
				configsenum = 1;
				Render.UPvr_GetIntConfig(configsenum, ref res2);
			}
			catch (Exception ex)
			{
				PLOG.E("GetEyeBufferResolution ERROR! " + ex.Message);
				throw;
			}
		}
		else
		{
			res = (int)(Pvr_UnitySDKProjectSetting.GetProjectConfig().customRTSize.x * RtScaleFactor);
			res2 = (int)(Pvr_UnitySDKProjectSetting.GetProjectConfig().customRTSize.y * RtScaleFactor);
		}
		Vector2 vector = new Vector2(res, res2);
		UnityEngine.Debug.Log(string.Concat("DISFT Customize RenderTexture:", vector, ", scaleFactor: ", RtScaleFactor));
		return vector;
	}

	public bool GetUsePredictedMatrix()
	{
		return true;
	}

	public bool GetIsShellMode()
	{
		if (activity == null)
		{
			return false;
		}
		AndroidJavaObject androidJavaObject = activity.Call<AndroidJavaObject>("getPackageManager", Array.Empty<object>());
		using (AndroidJavaObject androidJavaObject2 = androidJavaObject.Call<AndroidJavaObject>("getApplicationInfo", new object[2]
		{
			activity.Call<string>("getPackageName", Array.Empty<object>()),
			128
		}))
		{
			AndroidJavaObject androidJavaObject3 = androidJavaObject2.Get<AndroidJavaObject>("metaData");
			if (androidJavaObject3 != null)
			{
				int num = 0;
				num = androidJavaObject3.Call<int>("getInt", new object[1] { "shell_mode" });
				if (num == 1)
				{
					return true;
				}
				return false;
			}
		}
		return false;
	}
}
public class Pvr_UnitySDKSinglePass : SDKStereoRendering
{
	private static Camera bothCamera;

	private Matrix4x4[] unity_StereoMatrixP = new Matrix4x4[2];

	private Matrix4x4[] unity_StereoMatrixInvP = new Matrix4x4[2];

	private static Matrix4x4[] unity_StereoWorldToCamera = new Matrix4x4[2];

	private Matrix4x4[] unity_StereoCameraToWorld = new Matrix4x4[2];

	private Matrix4x4[] unity_StereoMatrixVP = new Matrix4x4[2];

	private Vector3[] eyesOffset = new Vector3[2];

	private static Matrix4x4[] eyesOffsetMatrix = new Matrix4x4[2];

	private CommandBuffer commandBufferBeforeForwardOpaque;

	private CommandBuffer commandBufferBeforeSkybox;

	private CommandBuffer commandBufferAfterSkybox;

	public override void InitEye(Camera eye)
	{
		bothCamera = eye;
		bothCamera.stereoSeparation = 0.0625f;
		bothCamera.stereoConvergence = 0f;
		bothCamera.allowHDR = false;
		bothCamera.allowDynamicResolution = false;
		SetEyesPosition();
		SetEyeProjection();
		Pvr_UnitySDKSensor.EyeFovChanged = (Action)Delegate.Combine(Pvr_UnitySDKSensor.EyeFovChanged, new Action(SetEyeProjection));
		UnityEngine.Debug.Log("SinglePass Init success! CameraName = " + eye.transform.name + " eye.eyeSide " + eye.GetComponent<Pvr_UnitySDKEye>().eyeSide);
	}

	public override void OnSDKRenderInited()
	{
		OnSDKRenderInited_SinglePass();
	}

	public override void OnSDKPreRender()
	{
		SinglePassPreRender();
	}

	public override void OnSDKPostRender()
	{
		SwitchKeywordAndDeviceView(enable: false);
	}

	public void OnSDKRenderInited_SinglePass()
	{
		Shader.SetGlobalVectorArray("unity_StereoScaleOffset", new Vector4[2]
		{
			new Vector4(1f, 1f, 0f, 0f),
			new Vector4(1f, 1f, 0.5f, 0f)
		});
		SetAntiAliasing();
		UnityEngine.Debug.Log("OnSDKRenderInited_SinglePass");
	}

	private void SetAntiAliasing()
	{
		int num = Mathf.Max(QualitySettings.antiAliasing, (int)Pvr_UnitySDKProjectSetting.GetProjectConfig().rtAntiAlising);
		Pvr_UnitySDKAPI.System.UPvr_SetAntiAliasing(num);
		UnityEngine.Debug.Log("SetAntiAliasing  antiAliasing = " + num);
	}

	public void SetEyesPosition()
	{
		float res = 0.0625f;
		int configsenum = 0;
		if (Render.UPvr_GetFloatConfig(configsenum, ref res) != 0)
		{
			PLOG.E("Cannot get ipd");
			res = 0.0625f;
		}
		bothCamera.stereoSeparation = res;
		Vector3 vector = new Vector3((0f - res) / 2f, 0f, 0f);
		Vector3 vector2 = new Vector3(res / 2f, 0f, 0f);
		Vector3 vector3 = (vector + vector2) / 2f;
		bothCamera.transform.localPosition = vector3;
		bothCamera.transform.localRotation = Quaternion.identity;
		Vector3 vector4 = vector - vector3;
		Vector3 vector5 = vector2 - vector3;
		eyesOffset[0] = vector4;
		eyesOffset[1] = vector5;
		ref Matrix4x4 reference = ref eyesOffsetMatrix[0];
		reference = Matrix4x4.TRS(vector4, Quaternion.identity, Vector3.one);
		ref Matrix4x4 reference2 = ref eyesOffsetMatrix[1];
		reference2 = Matrix4x4.TRS(vector5, Quaternion.identity, Vector3.one);
	}

	public void SetEyeProjection()
	{
		Matrix4x4 projection = GetProjection(bothCamera.nearClipPlane, bothCamera.farClipPlane);
		Matrix4x4 projection2 = GetProjection(bothCamera.nearClipPlane, bothCamera.farClipPlane);
		SetStereoProjectionMatrix(projection, projection2);
	}

	private static Matrix4x4 GetProjection(float near, float far)
	{
		if (near < 0.01f)
		{
			near = 0.01f;
		}
		if (far < 0.02f)
		{
			far = 0.02f;
		}
		Matrix4x4 identity = Matrix4x4.identity;
		return MakeProjection(near, far);
	}

	public static Matrix4x4 MakeProjection(float n, float f)
	{
		Vector2 eyeBufferResolution = Pvr_UnitySDKRender.Instance.GetEyeBufferResolution();
		float eyeVFoV = Pvr_UnitySDKRender.Instance.EyeVFoV;
		float num = Mathf.Tan(eyeVFoV / 2f * ((float)Math.PI / 180f));
		float num2 = 1f / num;
		Matrix4x4 zero = Matrix4x4.zero;
		zero[0, 0] = num2 / (eyeBufferResolution.x / eyeBufferResolution.y);
		zero[1, 1] = num2;
		zero[2, 2] = (0f - (f + n)) / (f - n);
		zero[2, 3] = -2f * f * n / (f - n);
		zero[3, 2] = -1f;
		return zero;
	}

	public void SetStereoProjectionMatrix(Matrix4x4 left, Matrix4x4 right)
	{
		unity_StereoMatrixP[0] = left;
		ref Matrix4x4 reference = ref unity_StereoMatrixInvP[0];
		reference = left.inverse;
		unity_StereoMatrixP[1] = right;
		ref Matrix4x4 reference2 = ref unity_StereoMatrixInvP[1];
		reference2 = right.inverse;
	}

	private void SwitchKeywordAndDeviceView(bool enable)
	{
		if (enable)
		{
			Shader.EnableKeyword("STEREO_MULTIVIEW_ON");
			Shader.EnableKeyword("UNITY_SINGLE_PASS_STEREO");
			XRSettings.showDeviceView = false;
		}
		else
		{
			XRSettings.showDeviceView = true;
			Shader.DisableKeyword("UNITY_SINGLE_PASS_STEREO");
			Shader.DisableKeyword("STEREO_MULTIVIEW_ON");
		}
	}

	public static Matrix4x4[] GetStereoWorldToCameraMat()
	{
		Matrix4x4 worldToCameraMatrix = bothCamera.worldToCameraMatrix;
		ref Matrix4x4 reference = ref unity_StereoWorldToCamera[0];
		reference = eyesOffsetMatrix[0].inverse * worldToCameraMatrix;
		ref Matrix4x4 reference2 = ref unity_StereoWorldToCamera[1];
		reference2 = eyesOffsetMatrix[1].inverse * worldToCameraMatrix;
		return unity_StereoWorldToCamera;
	}

	public void SinglePassPreRender()
	{
		SwitchKeywordAndDeviceView(enable: true);
		Shader.SetGlobalMatrixArray("unity_StereoCameraProjection", unity_StereoMatrixP);
		Shader.SetGlobalMatrixArray("unity_StereoCameraInvProjection", unity_StereoMatrixInvP);
		Shader.SetGlobalMatrixArray("unity_StereoMatrixP", unity_StereoMatrixP);
		Matrix4x4 worldToCameraMatrix = bothCamera.worldToCameraMatrix;
		Matrix4x4 cameraToWorldMatrix = bothCamera.cameraToWorldMatrix;
		ref Matrix4x4 reference = ref unity_StereoCameraToWorld[0];
		reference = cameraToWorldMatrix * eyesOffsetMatrix[0];
		ref Matrix4x4 reference2 = ref unity_StereoCameraToWorld[1];
		reference2 = cameraToWorldMatrix * eyesOffsetMatrix[1];
		Shader.SetGlobalMatrixArray("unity_StereoCameraToWorld", unity_StereoCameraToWorld);
		ref Matrix4x4 reference3 = ref unity_StereoWorldToCamera[0];
		reference3 = eyesOffsetMatrix[0].inverse * worldToCameraMatrix;
		ref Matrix4x4 reference4 = ref unity_StereoWorldToCamera[1];
		reference4 = eyesOffsetMatrix[1].inverse * worldToCameraMatrix;
		Shader.SetGlobalMatrixArray("unity_StereoWorldToCamera", unity_StereoWorldToCamera);
		Vector4[] values = new Vector4[2]
		{
			bothCamera.transform.position + eyesOffset[0],
			bothCamera.transform.position + eyesOffset[1]
		};
		Shader.SetGlobalVectorArray("unity_StereoWorldSpaceCameraPos", values);
		Shader.SetGlobalMatrixArray("unity_StereoMatrixV", unity_StereoWorldToCamera);
		Shader.SetGlobalMatrixArray("unity_StereoMatrixInvV", unity_StereoCameraToWorld);
		ref Matrix4x4 reference5 = ref unity_StereoMatrixVP[0];
		reference5 = unity_StereoMatrixP[0] * unity_StereoWorldToCamera[0];
		ref Matrix4x4 reference6 = ref unity_StereoMatrixVP[1];
		reference6 = unity_StereoMatrixP[1] * unity_StereoWorldToCamera[1];
		Shader.SetGlobalMatrixArray("unity_StereoMatrixVP", unity_StereoMatrixVP);
		SetRenderTextureWithDepth();
		SetCommandBuffers();
	}

	private void SetCommandBuffers()
	{
		if (commandBufferBeforeForwardOpaque == null)
		{
			commandBufferBeforeForwardOpaque = new CommandBuffer();
			Pvr_UnitySDKPluginEvent.SetSinglePassBeforeForwardOpaque(commandBufferBeforeForwardOpaque);
			commandBufferBeforeForwardOpaque.ClearRenderTarget(clearDepth: true, clearColor: true, bothCamera.backgroundColor);
			commandBufferBeforeForwardOpaque.name = "SinglePassPrepare";
		}
		bothCamera.RemoveCommandBuffer(CameraEvent.BeforeForwardOpaque, commandBufferBeforeForwardOpaque);
		bothCamera.AddCommandBuffer(CameraEvent.BeforeForwardOpaque, commandBufferBeforeForwardOpaque);
		if (commandBufferAfterSkybox == null)
		{
			commandBufferAfterSkybox = new CommandBuffer();
		}
		bothCamera.RemoveCommandBuffer(CameraEvent.AfterSkybox, commandBufferAfterSkybox);
		commandBufferAfterSkybox.Clear();
		commandBufferAfterSkybox.SetGlobalMatrixArray("unity_StereoMatrixVP", unity_StereoMatrixVP);
		commandBufferAfterSkybox.name = "SinglePassAfterSkyBox";
		bothCamera.AddCommandBuffer(CameraEvent.AfterSkybox, commandBufferAfterSkybox);
		if (commandBufferBeforeSkybox == null)
		{
			commandBufferBeforeSkybox = new CommandBuffer();
		}
		Matrix4x4 transpose = (Matrix4x4.LookAt(Vector3.zero, bothCamera.transform.forward, bothCamera.transform.up) * Matrix4x4.Scale(new Vector3(1f, 1f, -1f))).transpose;
		Matrix4x4 matrix4x = unity_StereoMatrixP[0];
		Matrix4x4 matrix4x2 = unity_StereoMatrixP[1];
		matrix4x.m22 = -1f;
		matrix4x2.m22 = -1f;
		Matrix4x4[] values = new Matrix4x4[2]
		{
			matrix4x * transpose,
			matrix4x2 * transpose
		};
		bothCamera.RemoveCommandBuffer(CameraEvent.BeforeSkybox, commandBufferBeforeSkybox);
		commandBufferBeforeSkybox.Clear();
		commandBufferBeforeSkybox.SetGlobalMatrixArray("unity_StereoMatrixVP", values);
		commandBufferBeforeSkybox.name = "SinglePassAfterSkybox";
		bothCamera.AddCommandBuffer(CameraEvent.BeforeSkybox, commandBufferBeforeSkybox);
	}

	private void SetRenderTextureWithDepth()
	{
		Pvr_UnitySDKAPI.System.UPvr_SetCurrentRenderTexture((uint)Pvr_UnitySDKRender.Instance.eyeTextureIds[Pvr_UnitySDKRender.Instance.currEyeTextureIdx]);
	}
}
public abstract class SDKStereoRendering
{
	public abstract void InitEye(Camera eye);

	public abstract void OnSDKRenderInited();

	public abstract void OnSDKPreRender();

	public abstract void OnSDKPostRender();
}
public class HighlightAtGaze : MonoBehaviour
{
	public Color HighlightColor = Color.red;

	public float AnimationTime = 0.1f;

	private Renderer myRenderer;

	private Color originalColor;

	private Color targetColor;

	private EyeTrackingGazeRay gazeRay;

	private void Start()
	{
		myRenderer = GetComponent<Renderer>();
		originalColor = myRenderer.material.color;
		targetColor = originalColor;
	}

	private void Update()
	{
		Pvr_UnitySDKAPI.System.UPvr_getEyeTrackingGazeRay(ref gazeRay);
		Ray ray = new Ray(gazeRay.Origin, gazeRay.Direction);
		if (Physics.Raycast(ray, out var hitInfo))
		{
			if (hitInfo.transform.name == base.transform.name)
			{
				if (targetColor != HighlightColor)
				{
					targetColor = HighlightColor;
				}
			}
			else if (targetColor != originalColor)
			{
				targetColor = originalColor;
			}
		}
		else if (targetColor != originalColor)
		{
			targetColor = originalColor;
		}
		myRenderer.material.color = Color.Lerp(myRenderer.material.color, targetColor, Time.deltaTime * (1f / AnimationTime));
	}
}
public class RayVisualizer : MonoBehaviour
{
	private LineRenderer _line;

	private EyeTrackingGazeRay gazeRay;

	private void Start()
	{
		_line = base.gameObject.GetComponent<LineRenderer>();
		_line.startWidth = 0.002f;
		_line.endWidth = 0.002f;
	}

	private void Update()
	{
		Matrix4x4 matrix = Pvr_UnitySDKSensor.Instance.HeadPose.Matrix;
		Pvr_UnitySDKAPI.System.UPvr_getEyeTrackingGazeRay(ref gazeRay);
		_line.SetPosition(0, matrix.MultiplyPoint(new Vector3(0f, -0.05f, 0.2f)));
		_line.SetPosition(1, gazeRay.Origin + gazeRay.Direction * 20f);
	}
}
public class GetSeeThroughImage : MonoBehaviour
{
	public RawImage viewImage_left;

	public RawImage viewImage_right;

	private int width;

	private int height;

	private RenderTexture cameraTex_left;

	private RenderTexture cameraTex_right;

	private bool cameraPreview;

	private void Start()
	{
		CreateTexture();
	}

	private void Update()
	{
		if (Input.GetKey(KeyCode.JoystickButton0))
		{
			DrawTexture();
		}
	}

	private void OnDestory()
	{
		if (cameraPreview)
		{
			cameraPreview = false;
			BoundarySystem.UPvr_StopCameraFrame();
		}
	}

	private void CreateTexture()
	{
		width = 600;
		height = 600;
		BoundarySystem.UPvr_BoundarySetCameraImageRect(width, height);
		cameraTex_left = new RenderTexture(width, height, 24, RenderTextureFormat.Default);
		cameraTex_right = new RenderTexture(width, height, 24, RenderTextureFormat.Default);
		cameraTex_left.Create();
		cameraTex_right.Create();
		viewImage_left.texture = cameraTex_left;
		viewImage_right.texture = cameraTex_right;
	}

	private void DrawTexture()
	{
		if (!cameraPreview)
		{
			cameraPreview = true;
			BoundarySystem.UPvr_StartCameraFrame();
		}
		BoundarySystem.UPvr_BoundaryGetSeeThroughData(0, cameraTex_left);
		BoundarySystem.UPvr_BoundaryGetSeeThroughData(1, cameraTex_right);
	}
}
public class OverlayExternalSurfaceDemo : MonoBehaviour
{
	public string movieName;

	public Pvr_UnitySDKEyeOverlay.OverlayType overlayType;

	public Pvr_UnitySDKEyeOverlay.OverlayShape overlayShape;

	private Pvr_UnitySDKEyeOverlay overlay;

	private const string TAG = "[ExternalSurface]>>>>>>";

	private void Awake()
	{
		overlay = GetComponent<Pvr_UnitySDKEyeOverlay>();
		if (overlay == null)
		{
			UnityEngine.Debug.LogError("[ExternalSurface]>>>>>>Overlay is null!");
			overlay = base.gameObject.AddComponent<Pvr_UnitySDKEyeOverlay>();
		}
		overlay.overlayType = overlayType;
		overlay.overlayShape = overlayShape;
		overlay.isExternalAndroidSurface = true;
	}

	private void Start()
	{
		if (!string.IsNullOrEmpty(movieName))
		{
			StartPlay(UnityEngine.Application.streamingAssetsPath + "/" + movieName, null);
		}
	}

	private void StartPlay(string moviePath, string licenceUrl)
	{
		if (moviePath != string.Empty)
		{
			if (overlay.isExternalAndroidSurface)
			{
				Pvr_UnitySDKEyeOverlay.ExternalAndroidSurfaceObjectCreated externalAndroidSurfaceObjectCreated = delegate
				{
					UnityEngine.Debug.Log("[ExternalSurface]>>>>>>SurfaceObject created callback is Invoke().");
				};
				if (overlay.externalAndroidSurfaceObject == IntPtr.Zero)
				{
					UnityEngine.Debug.Log("[ExternalSurface]>>>>>>Register surfaceObject crreated callback");
					overlay.externalAndroidSurfaceObjectCreated = externalAndroidSurfaceObjectCreated;
				}
				else
				{
					UnityEngine.Debug.Log("[ExternalSurface]>>>>>>SurfaceObject is already created! Invoke callback");
					externalAndroidSurfaceObjectCreated();
				}
			}
		}
		else
		{
			UnityEngine.Debug.LogError("[ExternalSurface]>>>>>>Movie path is null!");
		}
	}
}
public class MoveCylinder : MonoBehaviour
{
	private Vector3 startingPosition;

	private Quaternion startingRotation;

	private void Start()
	{
		startingPosition = base.transform.localPosition;
		startingRotation = base.transform.rotation;
	}

	public void Reset()
	{
		base.transform.localPosition = startingPosition;
		base.transform.rotation = startingRotation;
	}
}
[RequireComponent(typeof(Collider))]
public class MoveSphere : MonoBehaviour
{
	private Vector3 startingPosition;

	private void Start()
	{
		startingPosition = base.transform.localPosition;
		SetGazedAt(gazedAt: false);
		base.gameObject.GetComponent<Rigidbody>().AddForce(Vector3.right * 120f);
	}

	private void OnTriggerEnter(Collider other)
	{
	}

	public void SetGazedAt(bool gazedAt)
	{
		GetComponent<Renderer>().material.color = ((!gazedAt) ? Color.blue : Color.yellow);
	}

	public void Reset()
	{
		base.transform.localPosition = startingPosition;
		SetGazedAt(gazedAt: false);
		base.gameObject.GetComponent<Rigidbody>().Sleep();
		base.gameObject.GetComponent<Rigidbody>().AddForce(Vector3.right * 120f);
	}

	public void TeleportRandomly()
	{
		Vector3 onUnitSphere = UnityEngine.Random.onUnitSphere;
		onUnitSphere.y = Mathf.Clamp(onUnitSphere.y, 0.5f, 1f);
		float num = 2f * UnityEngine.Random.value + 1.5f;
		base.transform.localPosition = onUnitSphere * num;
	}
}
public class Resetbutton : MonoBehaviour
{
	public void DemoResetTracking()
	{
		if (Pvr_UnitySDKSensor.Instance != null)
		{
			Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
		}
	}
}
public class UserEntitlementCheck : MonoBehaviour
{
	private void OnEnable()
	{
		Pvr_UnitySDKManager.EntitlementCheckResultEvent += HandelEntitlementCheckResult;
	}

	private void OnDisable()
	{
		Pvr_UnitySDKManager.EntitlementCheckResultEvent -= HandelEntitlementCheckResult;
	}

	private void HandelEntitlementCheckResult(int resultCode)
	{
		UnityEngine.Debug.Log("The User Entitlement Check Result is :" + resultCode);
		switch (resultCode)
		{
		case 0:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: success");
			break;
		case -1:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: invalid params");
			break;
		case -2:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: service not exist");
			break;
		case -3:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: bind failed");
			break;
		case -4:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: exception");
			break;
		case -5:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: timeout");
			break;
		case 10:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: missing package name");
			break;
		case 11:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: missing appid");
			break;
		case 13:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: appid and package name not match");
			break;
		case 20:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: not login");
			break;
		case 21:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: not pay");
			break;
		case 31:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: invalid sn");
			break;
		default:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: unknown");
			break;
		}
	}
}
public class Pvr_UnitySDKHeadTrack : MonoBehaviour
{
	[Tooltip("If true, head tracking will affect the rotation of each Pvr_UnitySDK's cameras.")]
	public bool trackRotation = true;

	[Tooltip("If true, head tracking will affect the position of each Pvr_UnitySDK's cameras.")]
	public bool trackPosition = true;

	public Transform target;

	private bool updated;

	private bool dataClock;

	public Ray Gaze
	{
		get
		{
			UpdateHead();
			return new Ray(base.transform.position, base.transform.forward);
		}
	}

	private void Update()
	{
		updated = false;
		UpdateHead();
	}

	private void UpdateHead()
	{
		if (updated)
		{
			return;
		}
		updated = true;
		if (Pvr_UnitySDKManager.SDK == null)
		{
			return;
		}
		if (trackRotation)
		{
			Quaternion orientation = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation;
			if (target == null)
			{
				base.transform.localRotation = orientation;
			}
			else
			{
				base.transform.rotation = orientation * target.rotation;
			}
		}
		else
		{
			Quaternion orientation2 = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation;
			if (target == null)
			{
				base.transform.localRotation = Quaternion.identity;
			}
			else
			{
				base.transform.rotation = orientation2 * target.rotation;
			}
		}
		if (trackPosition)
		{
			Vector3 position = Pvr_UnitySDKSensor.Instance.HeadPose.Position;
			if (target == null)
			{
				base.transform.localPosition = position;
			}
			else
			{
				base.transform.position = target.position + target.rotation * position;
			}
		}
	}
}
public class Pvr_UnitySDKPose
{
	protected static readonly Matrix4x4 flipZ = Matrix4x4.Scale(new Vector3(1f, 1f, -1f));

	public Matrix4x4 RightHandedMatrix => flipZ * Matrix * flipZ;

	public Vector3 Position { get; protected set; }

	public Quaternion Orientation { get; protected set; }

	public Matrix4x4 Matrix { get; protected set; }

	public Pvr_UnitySDKPose(Matrix4x4 matrix)
	{
		Set(matrix);
	}

	public Pvr_UnitySDKPose(Vector3 position, Quaternion orientation)
	{
		Set(position, orientation);
	}

	public void Set(Vector3 position, Quaternion orientation)
	{
		Position = position;
		Orientation = orientation;
		Matrix = Matrix4x4.TRS(position, orientation, Vector3.one);
	}

	protected void Set(Matrix4x4 matrix)
	{
		Matrix = matrix;
		Position = matrix.GetColumn(3);
		Orientation = Quaternion.LookRotation(matrix.GetColumn(2), matrix.GetColumn(1));
	}

	private Quaternion NormalizeQuaternion(ref Quaternion q)
	{
		float num = 0f;
		for (int i = 0; i < 4; i++)
		{
			num += q[i] * q[i];
		}
		float num2 = 1f / Mathf.Sqrt(num);
		for (int j = 0; j < 4; j++)
		{
			q[j] *= num2;
		}
		return q;
	}
}
public class Pvr_UnitySDKSensor
{
	public delegate void Enter3DofModel();

	public delegate void Exit3DofModel();

	private static Pvr_UnitySDKSensor instance;

	private bool SensorStart;

	private bool SensorInit;

	private Quaternion UnityQuaternion = Quaternion.identity;

	private Vector3 UnityPosition = Vector3.zero;

	private Sensorindex sensorIndex;

	private bool dofClock;

	public static Action EyeFovChanged;

	public Pvr_UnitySDKPose HeadPose;

	private float vfov = 102f;

	private float hfov = 102f;

	private float w;

	private float x;

	private float y;

	private float z;

	private float px;

	private float py;

	private float pz;

	public static Pvr_UnitySDKSensor Instance
	{
		get
		{
			if (instance == null)
			{
				instance = new Pvr_UnitySDKSensor();
			}
			return instance;
		}
		set
		{
			instance = value;
		}
	}

	public static event Enter3DofModel Enter3DofModelEvent;

	public static event Exit3DofModel Exit3DofModelEvent;

	public Pvr_UnitySDKSensor()
	{
		Init();
	}

	public void Init()
	{
		InitUnitySDK6DofSensor();
		SensorInit = InitUnitySDKSensor();
		SensorStart = StartUnitySDKSensor();
		HeadPose = new Pvr_UnitySDKPose(Vector3.zero, Quaternion.identity);
	}

	public void SensorUpdate()
	{
		if (GetUnitySDKSensorState())
		{
			HeadPose.Set(UnityPosition, UnityQuaternion);
		}
	}

	public bool InitUnitySDKSensor()
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_Init((int)sensorIndex) == 0)
			{
				result = true;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("InitUnitySDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool InitUnitySDK6DofSensor()
	{
		bool result = false;
		try
		{
			int res = 0;
			int configsenum = 3;
			Render.UPvr_GetIntConfig(configsenum, ref res);
			if (res == 1)
			{
				if (Sensor.UPvr_Enable6DofModule(!Pvr_UnitySDKManager.SDK.HmdOnlyrot) == 0 && !Pvr_UnitySDKManager.SDK.HmdOnlyrot)
				{
					result = true;
					Pvr_UnitySDKManager.SDK.PVRNeck = false;
				}
			}
			else
			{
				UnityEngine.Debug.LogWarning("This platform does not support 6 Dof !");
			}
		}
		catch (Exception ex)
		{
			PLOG.E("InitUnity6DofSDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool StartUnitySDKSensor()
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_StartSensor((int)sensorIndex) == 0)
			{
				result = true;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("StartUnitySDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool StopUnitySDKSensor()
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_StopSensor((int)sensorIndex) == 0)
			{
				result = true;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("StopUnitySDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool ResetUnitySDKSensor()
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_ResetSensor((int)sensorIndex) == 0)
			{
				result = true;
				PLOG.E("ResetUnitySDKSensor OK! ");
			}
		}
		catch (Exception ex)
		{
			PLOG.E("ResetUnitySDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool OptionalResetUnitySDKSensor(int resetRot, int resetPos)
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_OptionalResetSensor((int)sensorIndex, resetRot, resetPos) == 0)
			{
				result = true;
				UnityEngine.Debug.Log("PvrLog OptionalResetUnitySDKSensor OK!" + resetRot + resetPos);
			}
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError("OptionalResetUnitySDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool GetUnitySDKSensorState()
	{
		bool result = false;
		if (SensorInit && SensorStart)
		{
			try
			{
				int num = -1;
				if (Pvr_UnitySDKManager.SDK.ShowVideoSeethrough)
				{
					Pvr_BoundarySystem.Instance.CameraFramePtr = Pvr_BoundaryAPI.UPvr_GetCameraData_Ext();
					num = Pvr_BoundaryAPI.UPvr_GetMainSensorStateExt(ref x, ref y, ref z, ref w, ref px, ref py, ref pz, ref vfov, ref hfov, ref Pvr_UnitySDKRender.Instance.RenderviewNumber);
				}
				else
				{
					num = Sensor.UPvr_GetMainSensorState(ref x, ref y, ref z, ref w, ref px, ref py, ref pz, ref vfov, ref hfov, ref Pvr_UnitySDKRender.Instance.RenderviewNumber);
				}
				Pvr_UnitySDKManager.SDK.posStatus = Sensor.UPvr_Get6DofSensorQualityStatus();
				if (num == 0)
				{
					if (!Convert.ToBoolean(Pvr_UnitySDKManager.SDK.posStatus & 2))
					{
						if (!dofClock)
						{
							if (Pvr_UnitySDKSensor.Enter3DofModelEvent != null)
							{
								Pvr_UnitySDKSensor.Enter3DofModelEvent();
							}
							dofClock = true;
						}
					}
					else if (dofClock)
					{
						if (Pvr_UnitySDKSensor.Exit3DofModelEvent != null)
						{
							Pvr_UnitySDKSensor.Exit3DofModelEvent();
						}
						dofClock = false;
					}
					RefreshHeadData(x, y, z, w, px, py, pz);
					UnityQuaternion.Set(x, y, 0f - z, 0f - w);
					if (Pvr_UnitySDKRender.Instance.EyeVFoV != vfov)
					{
						Pvr_UnitySDKRender.Instance.EyeVFoV = vfov;
						if (EyeFovChanged != null)
						{
							EyeFovChanged();
						}
					}
					Pvr_UnitySDKRender.Instance.EyeHFoV = hfov;
					Pvr_UnitySDKManager.SDK.EyesAspect = hfov / vfov;
					result = true;
					if (Pvr_UnitySDKManager.SDK.HmdOnlyrot)
					{
						if (Pvr_UnitySDKManager.SDK.PVRNeck)
						{
							if (Pvr_UnitySDKManager.SDK.TrackingOrigin == TrackingOrigin.FloorLevel)
							{
								UnityPosition.Set(0f, py, 0f);
								UnityPosition += UnityQuaternion * Pvr_UnitySDKManager.SDK.neckOffset - Pvr_UnitySDKManager.SDK.neckOffset.y * Vector3.up;
							}
							else
							{
								UnityPosition = UnityQuaternion * Pvr_UnitySDKManager.SDK.neckOffset - Pvr_UnitySDKManager.SDK.neckOffset.y * Vector3.up;
							}
						}
					}
					else
					{
						UnityPosition.Set(px, py, 0f - pz);
					}
					if (PLOG.logLevel > 2)
					{
						PLOG.D("posStatus=" + Pvr_UnitySDKManager.SDK.posStatus);
						PLOG.D("PvrLog 6DoFHeadRotation:" + x + "," + y + "," + (0f - z) + "," + (0f - w) + ",Position:" + px + "," + py + "," + (0f - pz) + ",eulerAngles:" + UnityQuaternion.eulerAngles);
					}
				}
				if (num == -1)
				{
					PLOG.I("PvrLog Sensor update --- GetUnitySDKSensorState  -1 ");
				}
			}
			catch (Exception ex)
			{
				PLOG.E("GetUnitySDKSensorState ERROR! " + ex.Message);
				throw;
			}
		}
		return result;
	}

	public bool GetUnitySDKPSensorState()
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_ResetSensor((int)sensorIndex) == 0)
			{
				result = true;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("GetUnitySDKPSensorState ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	private void RefreshHeadData(float x, float y, float z, float w, float px, float py, float pz)
	{
		Pvr_UnitySDKManager.SDK.headData[0] = x;
		Pvr_UnitySDKManager.SDK.headData[1] = y;
		Pvr_UnitySDKManager.SDK.headData[2] = z;
		Pvr_UnitySDKManager.SDK.headData[3] = w;
		Pvr_UnitySDKManager.SDK.headData[4] = px;
		Pvr_UnitySDKManager.SDK.headData[5] = py;
		Pvr_UnitySDKManager.SDK.headData[6] = pz;
	}
}
public class CLoadingAsset : ScriptableObject
{
	public int SplashScreenType;

	public List<Texture2D> splashImage = new List<Texture2D>();

	public Texture2D Inside_background;

	public bool UseSplashText;

	public string DefaultText;

	public string ChineseText;

	public string EnglishText;

	public string JapaneseText;

	public string KoreanText;

	public string FontSize;

	public Color FontColor;

	public string TextHeight;

	public bool UseCarousel;

	public int SplashTextAlignment;
}
[Serializable]
public class Pvr_UnitySDKConfigProfile
{
	public struct Lenses
	{
		public float separation;

		public float offset;

		public float distance;

		public int alignment;

		public const int AlignTop = -1;

		public const int AlignCenter = 0;

		public const int AlignBottom = 1;
	}

	public struct MaxFOV
	{
		public float upper;

		public float lower;

		public float inner;

		public float outer;
	}

	public struct Distortion
	{
		public float k1;

		public float k2;

		public float k3;

		public float k4;

		public float k5;

		public float k6;

		public float distort(float r)
		{
			return 0f;
		}

		public float distort(float r, float dist)
		{
			float num = r * dist * 1000f;
			float num2 = k1 * Mathf.Pow(num, 5f) + k2 * Mathf.Pow(num, 4f) + k3 * Mathf.Pow(num, 3f) + k4 * Mathf.Pow(num, 2f) + k5 * num + k6;
			return num2 / 1000f / dist;
		}

		public float diatortInv(float radious)
		{
			return 0f;
		}
	}

	public struct Device
	{
		public Lenses devLenses;

		public MaxFOV devMaxFov;

		public Distortion devDistortion;

		public Distortion devDistortionInv;
	}

	public static readonly Device SimulateDevice = new Device
	{
		devLenses = 
		{
			separation = 0.062f,
			offset = 0f,
			distance = 0.0403196f,
			alignment = 0
		},
		devMaxFov = 
		{
			upper = 40f,
			lower = 40f,
			inner = 40f,
			outer = 40f
		},
		devDistortion = 
		{
			k1 = 2.333E-06f,
			k2 = -0.000126f,
			k3 = 0.002978f,
			k4 = -0.02615f,
			k5 = 1.089f,
			k6 = -0.0337f
		},
		devDistortionInv = 
		{
			k1 = 1.342E-08f,
			k2 = 1.665E-06f,
			k3 = -0.0002797f,
			k4 = 0.001166f,
			k5 = 0.9945f,
			k6 = 0.004805f
		}
	};

	public Device device;

	public static readonly Pvr_UnitySDKConfigProfile Default = new Pvr_UnitySDKConfigProfile
	{
		device = SimulateDevice
	};

	public Pvr_UnitySDKConfigProfile Clone()
	{
		Pvr_UnitySDKConfigProfile pvr_UnitySDKConfigProfile = new Pvr_UnitySDKConfigProfile();
		pvr_UnitySDKConfigProfile.device = device;
		return pvr_UnitySDKConfigProfile;
	}

	public static Pvr_UnitySDKConfigProfile GetPicoProfile()
	{
		Pvr_UnitySDKConfigProfile pvr_UnitySDKConfigProfile = new Pvr_UnitySDKConfigProfile();
		pvr_UnitySDKConfigProfile.device = SimulateDevice;
		return pvr_UnitySDKConfigProfile;
	}

	public float[] GetLeftEyeVisibleTanAngles(float width, float height)
	{
		float val = (float)Math.Tan((double)(0f - device.devMaxFov.outer) * Math.PI / 180.0);
		float val2 = (float)Math.Tan((double)device.devMaxFov.upper * Math.PI / 180.0);
		float val3 = (float)Math.Tan((double)device.devMaxFov.inner * Math.PI / 180.0);
		float val4 = (float)Math.Tan((double)(0f - device.devMaxFov.lower) * Math.PI / 180.0);
		float num = width / 4f;
		float num2 = height / 2f;
		float num3 = device.devLenses.separation / 2f - num;
		float num4 = 0f;
		float distance = device.devLenses.distance;
		float val5 = device.devDistortion.distort((num3 - num) / distance, device.devLenses.distance);
		float val6 = device.devDistortion.distort((num4 + num2) / distance, device.devLenses.distance);
		float val7 = device.devDistortion.distort((num3 + num) / distance, device.devLenses.distance);
		float val8 = device.devDistortion.distort((num4 - num) / distance, device.devLenses.distance);
		float num5 = Math.Max(val, val5);
		float num6 = Math.Min(val2, val6);
		float num7 = Math.Min(val3, val7);
		float num8 = Math.Max(val4, val8);
		return new float[4] { num5, num6, num7, num8 };
	}

	public float[] GetLeftEyeNoLensTanAngles(float width, float height)
	{
		float val = device.devDistortionInv.distort((float)Math.Tan((double)(0f - device.devMaxFov.outer) * Math.PI / 180.0), device.devLenses.distance);
		float val2 = device.devDistortionInv.distort((float)Math.Tan((double)device.devMaxFov.upper * Math.PI / 180.0), device.devLenses.distance);
		float val3 = device.devDistortionInv.distort((float)Math.Tan((double)device.devMaxFov.inner * Math.PI / 180.0), device.devLenses.distance);
		float val4 = device.devDistortionInv.distort((float)Math.Tan((double)(0f - device.devMaxFov.lower) * Math.PI / 180.0), device.devLenses.distance);
		float num = width / 4f;
		float num2 = height / 2f;
		float num3 = device.devLenses.separation / 2f - num;
		float num4 = 0f;
		float distance = device.devLenses.distance;
		float val5 = (num3 - num) / distance;
		float val6 = (num4 + num2) / distance;
		float val7 = (num3 + num) / distance;
		float val8 = (num4 - num) / distance;
		float num5 = Math.Min(val, val5);
		float num6 = Math.Min(val2, val6);
		float num7 = Math.Min(val3, val7);
		float num8 = Math.Max(val4, val8);
		return new float[4] { num5, num6, num7, num8 };
	}

	public Rect GetLeftEyeVisibleScreenRect(float[] undistortedFrustum, float width, float height)
	{
		float distance = device.devLenses.distance;
		float num = (width - device.devLenses.separation) / 2f;
		float num2 = height / 2f;
		float num3 = (undistortedFrustum[0] * distance + num) / width;
		float num4 = (undistortedFrustum[1] * distance + num2) / height;
		float num5 = (undistortedFrustum[2] * distance + num) / width;
		float num6 = (undistortedFrustum[3] * distance + num2) / height;
		return new Rect(num3, num6, num5 - num3, num4 - num6);
	}
}
[RequireComponent(typeof(Text))]
public class Pvr_UnitySDKFPS : MonoBehaviour
{
	public Text fpsText;

	private float updateInterval = 0.5f;

	private float accum;

	private int frames;

	private float timeLeft;

	private string strFps;

	private void Update()
	{
		if (fpsText != null)
		{
			ShowFps();
		}
	}

	private void ShowFps()
	{
		timeLeft -= Time.unscaledDeltaTime;
		accum += Time.unscaledDeltaTime;
		frames++;
		if ((double)timeLeft <= 0.0)
		{
			float num = (float)frames / accum;
			strFps = $"FPS: {num:f0}";
			fpsText.text = strFps;
			timeLeft += updateInterval;
			accum = 0f;
			frames = 0;
		}
	}
}
public class Pvr_GazeFuse : MonoBehaviour
{
	public GameObject gazeGameObject;

	private Image image;

	private void Start()
	{
		image = GetComponent<Image>();
	}

	private void Update()
	{
		if (gazeGameObject == null || Pvr_GazeInputModule.gazeGameObject == gazeGameObject)
		{
			FuseAmountChanged(Pvr_GazeInputModule.gazeFraction);
		}
	}

	private void FuseAmountChanged(float fuseAmount)
	{
		if (image != null)
		{
			image.fillAmount = fuseAmount;
		}
	}
}
public class Pvr_GazeInputModule : PointerInputModule
{
	public enum Mode
	{
		Click,
		Gaze
	}

	public Mode mode;

	[Header("Click Settings")]
	public string ClickInputName = "Submit";

	[Header("Gaze Settings")]
	public float GazeTimeInSeconds = 2f;

	public RaycastResult CurrentRaycast;

	private PointerEventData pointerEventData;

	private GameObject currentLookAtHandler;

	private float currentLookAtHandlerClickTime;

	public static float gazeFraction { get; private set; }

	public static GameObject gazeGameObject { get; private set; }

	public override void Process()
	{
		HandleLook();
		HandleSelection();
	}

	private void HandleLook()
	{
		if (pointerEventData == null)
		{
			pointerEventData = new PointerEventData(base.eventSystem);
		}
		pointerEventData.position = new Vector2(Screen.width / 2, Screen.height / 2);
		pointerEventData.delta = Vector2.zero;
		List<RaycastResult> list = new List<RaycastResult>();
		base.eventSystem.RaycastAll(pointerEventData, list);
		RaycastResult raycastResult = BaseInputModule.FindFirstRaycast(list);
		pointerEventData.pointerCurrentRaycast = raycastResult;
		CurrentRaycast = raycastResult;
		ProcessMove(pointerEventData);
	}

	private void HandleSelection()
	{
		gazeFraction = 0f;
		if (pointerEventData.pointerEnter != null)
		{
			GameObject eventHandler = ExecuteEvents.GetEventHandler<IPointerClickHandler>(pointerEventData.pointerEnter);
			if (currentLookAtHandler != eventHandler)
			{
				gazeGameObject = (currentLookAtHandler = eventHandler);
				currentLookAtHandlerClickTime = Time.realtimeSinceStartup + GazeTimeInSeconds;
			}
			if (mode == Mode.Gaze && currentLookAtHandler != null)
			{
				gazeFraction = Mathf.Clamp01(1f - (currentLookAtHandlerClickTime - Time.realtimeSinceStartup) / GazeTimeInSeconds);
			}
			if ((currentLookAtHandler != null && mode == Mode.Gaze && Time.realtimeSinceStartup > currentLookAtHandlerClickTime) || (mode == Mode.Click && Input.GetButtonDown(ClickInputName)))
			{
				if (EventSystem.current.currentSelectedGameObject != null)
				{
				}
				EventSystem.current.SetSelectedGameObject(currentLookAtHandler);
				gazeFraction = 0f;
				ExecuteEvents.ExecuteHierarchy(currentLookAtHandler, pointerEventData, ExecuteEvents.pointerClickHandler);
				currentLookAtHandlerClickTime = float.MaxValue;
				ExecuteEvents.ExecuteHierarchy(EventSystem.current.currentSelectedGameObject, pointerEventData, ExecuteEvents.deselectHandler);
			}
		}
		else
		{
			gazeGameObject = (currentLookAtHandler = null);
		}
	}
}
[RequireComponent(typeof(Pvr_GazeInputModule))]
public class Pvr_GazeInputModuleCrosshair : MonoBehaviour
{
	public static bool DisplayCrosshair = true;

	[Tooltip("Crosshair GameObject attached to your VR Camera")]
	public Transform Crosshair;

	private Pvr_GazeInputModule gazeInputModule;

	private Vector3 CrosshairOriginalScale;

	private float CrosshairOriginalDistance;

	private void Awake()
	{
		gazeInputModule = GetComponent<Pvr_GazeInputModule>();
	}

	private void Start()
	{
		CrosshairOriginalScale = Crosshair.localScale;
		CrosshairOriginalDistance = Crosshair.localPosition.z;
		Crosshair.gameObject.SetActive(value: false);
	}

	private void Update()
	{
		Crosshair.gameObject.SetActive(DisplayCrosshair);
		if (DisplayCrosshair)
		{
			float crossHairAtDistance = CrosshairOriginalDistance;
			if (gazeInputModule.CurrentRaycast.isValid)
			{
				crossHairAtDistance = gazeInputModule.CurrentRaycast.distance * 0.8f - 0.5f;
			}
			SetCrossHairAtDistance(crossHairAtDistance);
		}
	}

	private void SetCrossHairAtDistance(float dist)
	{
		Vector3 localPosition = Crosshair.localPosition;
		Crosshair.localPosition = new Vector3(localPosition.x, localPosition.y, dist);
		Crosshair.localScale = CrosshairOriginalScale * dist;
	}
}
public enum RenderEventType
{
	InitRenderThread = 1024,
	Pause,
	Resume,
	LeftEyeEndFrame,
	RightEyeEndFrame,
	TimeWarp,
	ResetVrModeParms,
	ShutdownRenderThread,
	BeginEye,
	EndEye,
	BoundaryRenderLeft,
	BoundaryRenderRight,
	BothEyeEndFrame,
	CameraFrameLeft,
	CameraFrameRight,
	StartCameraFrame,
	StopCameraFrame
}
public static class Pvr_UnitySDKPluginEvent
{
	private delegate void RenderEventDelegate(int eventId);

	private const uint IS_DATA_FLAG = 2147483648u;

	private const uint DATA_POS_MASK = 1073741824u;

	private const int DATA_POS_SHIFT = 30;

	private const uint EVENT_TYPE_MASK = 1056899072u;

	private const int EVENT_TYPE_SHIFT = 17;

	private const uint PAYLOAD_MASK = 65535u;

	private const int PAYLOAD_SHIFT = 16;

	private static RenderEventDelegate SetSinglePassBeforeForwardOpaqueHandle = SetSinglePassBeforeForwardOpaque;

	private static IntPtr SetSinglePassBeforeForwardOpaquePtr = Marshal.GetFunctionPointerForDelegate(SetSinglePassBeforeForwardOpaqueHandle);

	public static void Issue(RenderEventType eventType)
	{
		GL.IssuePluginEvent(Pvr_UnitySDKAPI.System.GetRenderEventFunc(), (int)eventType);
	}

	private static int EncodeType(int eventType)
	{
		return eventType & 0x7FFFFFFF;
	}

	private static int EncodeData(int eventId, int eventData, int pos)
	{
		uint num = 0u;
		num |= 0x80000000u;
		num |= (uint)(pos << 30) & 0x40000000u;
		num |= (uint)(eventId << 17) & 0x3EFF0000u;
		return (int)num | ((eventData >>> pos * 16) & 0xFFFF);
	}

	private static int DecodeData(int eventData)
	{
		uint num = (uint)(eventData & 0x40000000) >> 30;
		return (eventData & 0xFFFF) << (int)(16 * num);
	}

	[MonoPInvokeCallback(typeof(RenderEventDelegate))]
	private static void SetSinglePassBeforeForwardOpaque(int eventId)
	{
		Pvr_UnitySDKAPI.System.UPvr_SinglePassBeforeForwardOpaque();
	}

	public static void SetSinglePassBeforeForwardOpaque(CommandBuffer cmd)
	{
		cmd.IssuePluginEvent(SetSinglePassBeforeForwardOpaquePtr, 0);
	}
}
public class Pvr_UnitySDKSightInputModule : BaseInputModule
{
	[Tooltip("Optional object to place at raycast intersections as a 3D cursor. Be sure it is on a layer that raycasts will ignore.")]
	public GameObject cursor;

	public int trigger;

	[HideInInspector]
	public float clickTime = 0.1f;

	[HideInInspector]
	public Vector2 hotspot = new Vector2(0.5f, 0.5f);

	private PointerEventData pointerData;

	public override bool ShouldActivateModule()
	{
		if (!base.ShouldActivateModule())
		{
			return false;
		}
		return Pvr_UnitySDKManager.SDK.VRModeEnabled;
	}

	public override void DeactivateModule()
	{
		base.DeactivateModule();
		if (pointerData != null)
		{
			HandlePendingClick();
			HandlePointerExitAndEnter(pointerData, null);
			pointerData = null;
		}
		base.eventSystem.SetSelectedGameObject(null, GetBaseEventData());
		if (cursor != null)
		{
			cursor.SetActive(value: false);
		}
	}

	public override bool IsPointerOverGameObject(int pointerId)
	{
		return pointerData != null && pointerData.pointerEnter != null;
	}

	public override void Process()
	{
		CastRayFromGaze();
		UpdateCurrentObject();
		PlaceCursor();
		HandlePendingClick();
		HandleTrigger();
	}

	private void CastRayFromGaze()
	{
		if (pointerData == null)
		{
			pointerData = new PointerEventData(base.eventSystem);
		}
		pointerData.Reset();
		pointerData.position = new Vector2(hotspot.x * (float)Screen.width, hotspot.y * (float)Screen.height);
		base.eventSystem.RaycastAll(pointerData, m_RaycastResultCache);
		pointerData.pointerCurrentRaycast = BaseInputModule.FindFirstRaycast(m_RaycastResultCache);
		m_RaycastResultCache.Clear();
	}

	private void UpdateCurrentObject()
	{
		GameObject gameObject = pointerData.pointerCurrentRaycast.gameObject;
		HandlePointerExitAndEnter(pointerData, gameObject);
		GameObject eventHandler = ExecuteEvents.GetEventHandler<ISelectHandler>(gameObject);
		if (eventHandler == base.eventSystem.currentSelectedGameObject)
		{
			ExecuteEvents.Execute(base.eventSystem.currentSelectedGameObject, GetBaseEventData(), ExecuteEvents.updateSelectedHandler);
		}
		else
		{
			base.eventSystem.SetSelectedGameObject(null, pointerData);
		}
	}

	private void PlaceCursor()
	{
		if (!(cursor == null))
		{
			GameObject gameObject = pointerData.pointerCurrentRaycast.gameObject;
			cursor.SetActive(gameObject != null);
			if (cursor.activeInHierarchy)
			{
				Camera enterEventCamera = pointerData.enterEventCamera;
				float num = pointerData.pointerCurrentRaycast.distance + enterEventCamera.nearClipPlane - 0.1f;
				cursor.transform.position = enterEventCamera.transform.position + enterEventCamera.transform.forward * num;
			}
		}
	}

	private void HandlePendingClick()
	{
		if (pointerData.eligibleForClick && (Pvr_UnitySDKManager.SDK.picovrTriggered || !(Time.unscaledTime - pointerData.clickTime < clickTime)))
		{
			ExecuteEvents.Execute(pointerData.pointerPress, pointerData, ExecuteEvents.pointerUpHandler);
			ExecuteEvents.Execute(pointerData.pointerPress, pointerData, ExecuteEvents.pointerClickHandler);
			pointerData.pointerPress = null;
			pointerData.rawPointerPress = null;
			pointerData.eligibleForClick = false;
			pointerData.clickCount = 0;
		}
	}

	private void HandleTrigger()
	{
		if (Pvr_UnitySDKManager.SDK.picovrTriggered)
		{
			GameObject gameObject = pointerData.pointerCurrentRaycast.gameObject;
			if (!(gameObject == null) && !(ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject) == null))
			{
				pointerData.pointerPress = ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject);
				pointerData.pressPosition = pointerData.position;
				pointerData.pointerPressRaycast = pointerData.pointerCurrentRaycast;
				pointerData.pointerPress = ExecuteEvents.ExecuteHierarchy(gameObject, pointerData, ExecuteEvents.pointerDownHandler) ?? ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject);
				pointerData.rawPointerPress = gameObject;
				pointerData.eligibleForClick = true;
				pointerData.clickCount = 1;
				pointerData.clickTime = Time.unscaledTime;
			}
		}
	}
}
public class Pvr_ObjImporter
{
	private static Pvr_ObjImporter _instance;

	private List<int> triangles;

	private List<Vector3> vertices;

	private List<Vector2> uv;

	private List<Vector3> normals;

	private List<PvrVector3Int> faceData;

	private List<int> intArray;

	private const int MIN_POW_10 = -16;

	private const int MAX_POW_10 = 16;

	private const int NUM_POWS_10 = 33;

	private static readonly float[] pow10 = GenerateLookupTable();

	public static Pvr_ObjImporter Instance => _instance ?? (_instance = new Pvr_ObjImporter());

	public Mesh ImportFile(string filePath)
	{
		triangles = new List<int>();
		vertices = new List<Vector3>();
		uv = new List<Vector2>();
		normals = new List<Vector3>();
		faceData = new List<PvrVector3Int>();
		intArray = new List<int>();
		LoadMeshData(filePath);
		Vector3[] array = new Vector3[faceData.Count];
		Vector2[] array2 = new Vector2[faceData.Count];
		Vector3[] array3 = new Vector3[faceData.Count];
		for (int i = 0; i < faceData.Count; i++)
		{
			ref Vector3 reference = ref array[i];
			reference = vertices[faceData[i].x - 1];
			if (faceData[i].y >= 1)
			{
				ref Vector2 reference2 = ref array2[i];
				reference2 = uv[faceData[i].y - 1];
			}
			if (faceData[i].z >= 1)
			{
				ref Vector3 reference3 = ref array3[i];
				reference3 = normals[faceData[i].z - 1];
			}
		}
		Mesh mesh = new Mesh();
		mesh.vertices = array;
		mesh.uv = array2;
		mesh.normals = array3;
		mesh.triangles = triangles.ToArray();
		mesh.RecalculateBounds();
		return mesh;
	}

	private void LoadMeshData(string fileName)
	{
		StringBuilder stringBuilder = new StringBuilder();
		string text = File.ReadAllText(fileName);
		int num = 0;
		string text2 = null;
		int num2 = 0;
		StringBuilder sbInt = new StringBuilder();
		for (int i = 0; i < text.Length; i++)
		{
			if (text[i] != '\n')
			{
				continue;
			}
			stringBuilder.Remove(0, stringBuilder.Length);
			stringBuilder.Append(text, num + 1, i - num);
			num = i;
			if (stringBuilder[0] == 'o' && stringBuilder[1] == ' ')
			{
				sbInt.Remove(0, sbInt.Length);
				for (int j = 2; j < stringBuilder.Length; j++)
				{
					text2 += stringBuilder[j];
				}
			}
			else if (stringBuilder[0] == 'v' && stringBuilder[1] == ' ')
			{
				int start = 2;
				vertices.Add(new Vector3(GetFloat(stringBuilder, ref start, ref sbInt), GetFloat(stringBuilder, ref start, ref sbInt), GetFloat(stringBuilder, ref start, ref sbInt)));
			}
			else if (stringBuilder[0] == 'v' && stringBuilder[1] == 't' && stringBuilder[2] == ' ')
			{
				int start2 = 3;
				uv.Add(new Vector2(GetFloat(stringBuilder, ref start2, ref sbInt), GetFloat(stringBuilder, ref start2, ref sbInt)));
			}
			else if (stringBuilder[0] == 'v' && stringBuilder[1] == 'n' && stringBuilder[2] == ' ')
			{
				int start3 = 3;
				normals.Add(new Vector3(GetFloat(stringBuilder, ref start3, ref sbInt), GetFloat(stringBuilder, ref start3, ref sbInt), GetFloat(stringBuilder, ref start3, ref sbInt)));
			}
			else if (stringBuilder[0] == 'f' && stringBuilder[1] == ' ')
			{
				int start4 = 2;
				int num3 = 1;
				intArray.Clear();
				int num4 = 0;
				while (start4 < stringBuilder.Length && char.IsDigit(stringBuilder[start4]))
				{
					faceData.Add(new PvrVector3Int(GetInt(stringBuilder, ref start4, ref sbInt), GetInt(stringBuilder, ref start4, ref sbInt), GetInt(stringBuilder, ref start4, ref sbInt)));
					num3++;
					intArray.Add(num2);
					num2++;
				}
				num4 += num3;
				for (num3 = 1; num3 + 2 < num4; num3++)
				{
					triangles.Add(intArray[0]);
					triangles.Add(intArray[num3]);
					triangles.Add(intArray[num3 + 1]);
				}
			}
		}
	}

	private float GetFloat(StringBuilder sb, ref int start, ref StringBuilder sbFloat)
	{
		sbFloat.Remove(0, sbFloat.Length);
		while (start < sb.Length && (char.IsDigit(sb[start]) || sb[start] == '-' || sb[start] == '.'))
		{
			sbFloat.Append(sb[start]);
			start++;
		}
		start++;
		return ParseFloat(sbFloat);
	}

	private int GetInt(StringBuilder sb, ref int start, ref StringBuilder sbInt)
	{
		sbInt.Remove(0, sbInt.Length);
		while (start < sb.Length && char.IsDigit(sb[start]))
		{
			sbInt.Append(sb[start]);
			start++;
		}
		start++;
		return IntParseFast(sbInt);
	}

	private static float[] GenerateLookupTable()
	{
		float[] array = new float[320];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = (float)(i / 33) * Mathf.Pow(10f, i % 33 + -16);
		}
		return array;
	}

	private float ParseFloat(StringBuilder value)
	{
		float num = 0f;
		bool flag = false;
		int length = value.Length;
		int num2 = value.Length;
		for (int num3 = length - 1; num3 >= 0; num3--)
		{
			if (value[num3] == '.')
			{
				num2 = num3;
				break;
			}
		}
		int num4 = 16 + num2;
		for (int i = 0; i < num2; i++)
		{
			if (i != num2 && value[i] != '-')
			{
				num += pow10[(value[i] - 48) * 33 + num4 - i - 1];
			}
			else if (value[i] == '-')
			{
				flag = true;
			}
		}
		for (int j = num2 + 1; j < length; j++)
		{
			if (j != num2)
			{
				num += pow10[(value[j] - 48) * 33 + num4 - j];
			}
		}
		if (flag)
		{
			num = 0f - num;
		}
		return num;
	}

	private int IntParseFast(StringBuilder value)
	{
		int num = 0;
		for (int i = 0; i < value.Length; i++)
		{
			num = 10 * num + (value[i] - 48);
		}
		return num;
	}
}
public sealed class PvrVector3Int
{
	public int x { get; set; }

	public int y { get; set; }

	public int z { get; set; }

	public PvrVector3Int()
	{
	}

	public PvrVector3Int(int x, int y, int z)
	{
		this.x = x;
		this.y = y;
		this.z = z;
	}
}
public class Pvr_EnumFlags : PropertyAttribute
{
}
public enum ConfirmBtn
{
	App = 1,
	TouchPad = 2,
	Trigger = 4
}
public class Pvr_InputModule : PointerInputModule
{
	public static List<Pvr_UIPointer> pointers = new List<Pvr_UIPointer>();

	[Pvr_EnumFlags]
	public ConfirmBtn confirmBtn = ConfirmBtn.TouchPad;

	private List<RaycastResult> rayCasts = new List<RaycastResult>();

	private RaycastResult rayCastResult = default(RaycastResult);

	public virtual void Initialise()
	{
		pointers.Clear();
	}

	public static void AddPoint(Pvr_UIPointer point)
	{
		if (!pointers.Contains(point))
		{
			pointers.Add(point);
		}
	}

	public static void RemovePoint(Pvr_UIPointer point)
	{
		if (pointers.Contains(point))
		{
			pointers.Remove(point);
		}
	}

	public override void Process()
	{
		if (Pvr_UnitySDKManager.SDK.isHasController)
		{
			if ((confirmBtn & ConfirmBtn.App) == ConfirmBtn.App)
			{
				Pvr_UIPointer.AppBtnValue = Controller.UPvr_GetKey(Pvr_ControllerManager.controllerlink.mainHandID, Pvr_KeyCode.APP);
			}
			if ((confirmBtn & ConfirmBtn.TouchPad) == ConfirmBtn.TouchPad)
			{
				Pvr_UIPointer.TouchBtnValue = Controller.UPvr_GetKey(Pvr_ControllerManager.controllerlink.mainHandID, Pvr_KeyCode.TOUCHPAD);
			}
			if ((confirmBtn & ConfirmBtn.Trigger) == ConfirmBtn.Trigger)
			{
				Pvr_UIPointer.TriggerBtnValue = Controller.UPvr_GetKey(Pvr_ControllerManager.controllerlink.mainHandID, Pvr_KeyCode.TRIGGER);
			}
		}
		for (int i = 0; i < pointers.Count; i++)
		{
			Pvr_UIPointer pvr_UIPointer = pointers[i];
			if (pvr_UIPointer.gameObject.activeInHierarchy && pvr_UIPointer.enabled)
			{
				List<RaycastResult> results = new List<RaycastResult>();
				if (pvr_UIPointer.PointerActive())
				{
					results = CheckRaycasts(pvr_UIPointer);
				}
				Hover(pvr_UIPointer, results);
				Click(pvr_UIPointer, results);
				Drag(pvr_UIPointer, results);
			}
		}
	}

	protected virtual List<RaycastResult> CheckRaycasts(Pvr_UIPointer pointer)
	{
		rayCastResult.worldPosition = pointer.GetOriginPosition();
		rayCastResult.worldNormal = pointer.GetOriginForward();
		pointer.pointerEventData.pointerCurrentRaycast = rayCastResult;
		base.eventSystem.RaycastAll(pointer.pointerEventData, rayCasts);
		return rayCasts;
	}

	protected virtual bool CheckTransformTree(Transform target, Transform source)
	{
		if (target == null)
		{
			return false;
		}
		if (target.Equals(source))
		{
			return true;
		}
		return CheckTransformTree(target.transform.parent, source);
	}

	protected virtual bool NoValidCollision(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		return results.Count == 0 || !CheckTransformTree(results[0].gameObject.transform, pointer.pointerEventData.pointerEnter.transform);
	}

	protected virtual bool IsHovering(Pvr_UIPointer pointer)
	{
		foreach (GameObject item in pointer.pointerEventData.hovered)
		{
			if ((bool)pointer.pointerEventData.pointerEnter && (bool)item && CheckTransformTree(item.transform, pointer.pointerEventData.pointerEnter.transform))
			{
				return true;
			}
		}
		return false;
	}

	protected virtual bool ValidElement(GameObject obj)
	{
		Pvr_UICanvas componentInParent = obj.GetComponentInParent<Pvr_UICanvas>();
		return ((bool)componentInParent && componentInParent.enabled) ? true : false;
	}

	protected virtual void CheckPointerHoverClick(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		if (pointer.hoverDurationTimer > 0f)
		{
			pointer.hoverDurationTimer -= Time.deltaTime;
		}
		if (pointer.canClickOnHover && pointer.hoverDurationTimer <= 0f)
		{
			pointer.canClickOnHover = false;
			ClickOnDown(pointer, results, forceClick: true);
		}
	}

	protected virtual void Hover(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		if ((bool)pointer.pointerEventData.pointerEnter)
		{
			CheckPointerHoverClick(pointer, results);
			if (!ValidElement(pointer.pointerEventData.pointerEnter))
			{
				pointer.pointerEventData.pointerEnter = null;
				return;
			}
			if (NoValidCollision(pointer, results))
			{
				ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerEnter, pointer.pointerEventData, ExecuteEvents.pointerExitHandler);
				pointer.pointerEventData.hovered.Remove(pointer.pointerEventData.pointerEnter);
				pointer.pointerEventData.pointerEnter = null;
			}
			if (results.Count <= 0 || !(pointer.pointerEventData.pointerEnter != results[0].gameObject))
			{
				return;
			}
			{
				foreach (RaycastResult result in results)
				{
					if (!ValidElement(result.gameObject))
					{
						continue;
					}
					GameObject gameObject = ExecuteEvents.ExecuteHierarchy(result.gameObject, pointer.pointerEventData, ExecuteEvents.pointerEnterHandler);
					if (gameObject != null)
					{
						Selectable component = gameObject.GetComponent<Selectable>();
						if ((bool)component)
						{
							Navigation navigation = default(Navigation);
							navigation.mode = Navigation.Mode.None;
							component.navigation = navigation;
						}
						pointer.pointerEventData.hovered.Remove(pointer.pointerEventData.pointerEnter);
						pointer.OnUIPointerElementEnter(pointer.SetUIPointerEvent(result, gameObject, pointer.hoveringElement));
						pointer.hoveringElement = gameObject;
						pointer.pointerEventData.pointerCurrentRaycast = result;
						pointer.pointerEventData.pointerEnter = gameObject;
						pointer.pointerEventData.hovered.Add(pointer.pointerEventData.pointerEnter);
						break;
					}
					if (result.gameObject != pointer.hoveringElement)
					{
						pointer.OnUIPointerElementEnter(pointer.SetUIPointerEvent(result, result.gameObject, pointer.hoveringElement));
					}
					pointer.hoveringElement = result.gameObject;
				}
				return;
			}
		}
		foreach (RaycastResult result2 in results)
		{
			if (!ValidElement(result2.gameObject))
			{
				continue;
			}
			GameObject gameObject2 = ExecuteEvents.ExecuteHierarchy(result2.gameObject, pointer.pointerEventData, ExecuteEvents.pointerEnterHandler);
			if (gameObject2 != null)
			{
				Selectable component2 = gameObject2.GetComponent<Selectable>();
				if ((bool)component2)
				{
					Navigation navigation2 = default(Navigation);
					navigation2.mode = Navigation.Mode.None;
					component2.navigation = navigation2;
				}
				pointer.OnUIPointerElementEnter(pointer.SetUIPointerEvent(result2, gameObject2, pointer.hoveringElement));
				pointer.hoveringElement = gameObject2;
				pointer.pointerEventData.pointerCurrentRaycast = result2;
				pointer.pointerEventData.pointerEnter = gameObject2;
				pointer.pointerEventData.hovered.Add(pointer.pointerEventData.pointerEnter);
				break;
			}
			if (result2.gameObject != pointer.hoveringElement)
			{
				pointer.OnUIPointerElementEnter(pointer.SetUIPointerEvent(result2, result2.gameObject, pointer.hoveringElement));
			}
			pointer.hoveringElement = result2.gameObject;
		}
		if ((bool)pointer.hoveringElement && results.Count == 0)
		{
			pointer.OnUIPointerElementExit(pointer.SetUIPointerEvent(default(RaycastResult), null, pointer.hoveringElement));
			pointer.hoveringElement = null;
		}
	}

	protected virtual void Click(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		switch (pointer.clickMethod)
		{
		case Pvr_UIPointer.ClickMethods.ClickOnButtonUp:
			ClickOnUp(pointer, results);
			break;
		case Pvr_UIPointer.ClickMethods.ClickOnButtonDown:
			ClickOnDown(pointer, results);
			break;
		}
	}

	protected virtual void ClickOnUp(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		pointer.pointerEventData.eligibleForClick = pointer.ValidClick(checkLastClick: false);
		if (!AttemptClick(pointer))
		{
			IsEligibleClick(pointer, results);
		}
	}

	protected virtual void ClickOnDown(Pvr_UIPointer pointer, List<RaycastResult> results, bool forceClick = false)
	{
		pointer.pointerEventData.eligibleForClick = forceClick || pointer.ValidClick(checkLastClick: true);
		if (IsEligibleClick(pointer, results))
		{
			pointer.pointerEventData.eligibleForClick = false;
			AttemptClick(pointer);
		}
	}

	protected virtual bool IsEligibleClick(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		if (pointer.pointerEventData.eligibleForClick)
		{
			foreach (RaycastResult result in results)
			{
				if (ValidElement(result.gameObject))
				{
					GameObject gameObject = ExecuteEvents.ExecuteHierarchy(result.gameObject, pointer.pointerEventData, ExecuteEvents.pointerDownHandler);
					if (gameObject != null)
					{
						pointer.pointerEventData.pressPosition = pointer.pointerEventData.position;
						pointer.pointerEventData.pointerPressRaycast = result;
						pointer.pointerEventData.pointerPress = gameObject;
						return true;
					}
				}
			}
		}
		return false;
	}

	protected virtual bool AttemptClick(Pvr_UIPointer pointer)
	{
		if ((bool)pointer.pointerEventData.pointerPress)
		{
			if (!ValidElement(pointer.pointerEventData.pointerPress))
			{
				pointer.pointerEventData.pointerPress = null;
				return true;
			}
			if (pointer.pointerEventData.eligibleForClick)
			{
				if (!IsHovering(pointer))
				{
					ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerPress, pointer.pointerEventData, ExecuteEvents.pointerUpHandler);
					pointer.pointerEventData.pointerPress = null;
				}
			}
			else
			{
				pointer.OnUIPointerElementClick(pointer.SetUIPointerEvent(pointer.pointerEventData.pointerPressRaycast, pointer.pointerEventData.pointerPress));
				ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerPress, pointer.pointerEventData, ExecuteEvents.pointerClickHandler);
				ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerPress, pointer.pointerEventData, ExecuteEvents.pointerUpHandler);
				pointer.pointerEventData.pointerPress = null;
			}
			return true;
		}
		return false;
	}

	protected virtual void Drag(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		pointer.pointerEventData.dragging = pointer.IsSelectionButtonPressed() && pointer.pointerEventData.delta != Vector2.zero;
		if ((bool)pointer.pointerEventData.pointerDrag)
		{
			if (!ValidElement(pointer.pointerEventData.pointerDrag))
			{
				pointer.pointerEventData.pointerDrag = null;
				return;
			}
			if (pointer.pointerEventData.dragging)
			{
				if (IsHovering(pointer))
				{
					ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerDrag, pointer.pointerEventData, ExecuteEvents.dragHandler);
				}
				return;
			}
			ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerDrag, pointer.pointerEventData, ExecuteEvents.dragHandler);
			ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerDrag, pointer.pointerEventData, ExecuteEvents.endDragHandler);
			foreach (RaycastResult result in results)
			{
				ExecuteEvents.ExecuteHierarchy(result.gameObject, pointer.pointerEventData, ExecuteEvents.dropHandler);
			}
			pointer.pointerEventData.pointerDrag = null;
		}
		else
		{
			if (!pointer.pointerEventData.dragging)
			{
				return;
			}
			foreach (RaycastResult result2 in results)
			{
				if (ValidElement(result2.gameObject))
				{
					ExecuteEvents.ExecuteHierarchy(result2.gameObject, pointer.pointerEventData, ExecuteEvents.initializePotentialDrag);
					ExecuteEvents.ExecuteHierarchy(result2.gameObject, pointer.pointerEventData, ExecuteEvents.beginDragHandler);
					GameObject gameObject = ExecuteEvents.ExecuteHierarchy(result2.gameObject, pointer.pointerEventData, ExecuteEvents.dragHandler);
					if (gameObject != null)
					{
						pointer.pointerEventData.pointerDrag = gameObject;
						break;
					}
				}
			}
		}
	}
}
public class Pvr_UICanvas : MonoBehaviour
{
	public bool clickOnPointerCollision;

	public float autoActivateWithinDistance;

	protected BoxCollider canvasBoxCollider;

	protected Rigidbody canvasRigidBody;

	protected Coroutine draggablePanelCreation;

	protected const string CANVAS_DRAGGABLE_PANEL = "UICANVAS_DRAGGABLE_PANEL";

	protected virtual void OnEnable()
	{
		SetupCanvas();
	}

	protected virtual void OnDisable()
	{
		RemoveCanvas();
	}

	protected virtual void OnDestroy()
	{
		RemoveCanvas();
	}

	protected virtual void SetupCanvas()
	{
		Canvas component = GetComponent<Canvas>();
		if ((bool)component && component.renderMode == RenderMode.WorldSpace)
		{
			RectTransform component2 = component.GetComponent<RectTransform>();
			Vector2 sizeDelta = component2.sizeDelta;
			GraphicRaycaster component3 = component.gameObject.GetComponent<GraphicRaycaster>();
			Pvr_UIGraphicRaycaster pvr_UIGraphicRaycaster = component.gameObject.GetComponent<Pvr_UIGraphicRaycaster>();
			if (!pvr_UIGraphicRaycaster)
			{
				pvr_UIGraphicRaycaster = component.gameObject.AddComponent<Pvr_UIGraphicRaycaster>();
			}
			if ((bool)component3 && component3.enabled)
			{
				pvr_UIGraphicRaycaster.ignoreReversedGraphics = component3.ignoreReversedGraphics;
				pvr_UIGraphicRaycaster.blockingObjects = component3.blockingObjects;
				component3.enabled = false;
			}
			if (!component.gameObject.GetComponent<BoxCollider>())
			{
				float num = 0.1f;
				float z = num / component2.localScale.z;
				canvasBoxCollider = component.gameObject.AddComponent<BoxCollider>();
				canvasBoxCollider.size = new Vector3(sizeDelta.x, sizeDelta.y, z);
				canvasBoxCollider.isTrigger = true;
			}
			if (!component.gameObject.GetComponent<Rigidbody>())
			{
				canvasRigidBody = component.gameObject.AddComponent<Rigidbody>();
				canvasRigidBody.isKinematic = true;
			}
			draggablePanelCreation = StartCoroutine(CreateDraggablePanel(component, sizeDelta));
		}
	}

	protected virtual IEnumerator CreateDraggablePanel(Canvas canvas, Vector2 canvasSize)
	{
		if ((bool)canvas && !canvas.transform.Find("UICANVAS_DRAGGABLE_PANEL"))
		{
			yield return null;
			GameObject draggablePanel = new GameObject("UICANVAS_DRAGGABLE_PANEL", typeof(RectTransform));
			draggablePanel.AddComponent<LayoutElement>().ignoreLayout = true;
			draggablePanel.AddComponent<Image>().color = Color.clear;
			draggablePanel.AddComponent<EventTrigger>();
			draggablePanel.transform.SetParent(canvas.transform);
			draggablePanel.GetComponent<RectTransform>().sizeDelta = canvasSize;
			draggablePanel.transform.localPosition = Vector3.zero;
			draggablePanel.transform.localRotation = Quaternion.identity;
			draggablePanel.transform.localScale = Vector3.one;
			draggablePanel.transform.SetAsFirstSibling();
		}
	}

	protected virtual void RemoveCanvas()
	{
		Canvas component = GetComponent<Canvas>();
		if ((bool)component)
		{
			GraphicRaycaster component2 = component.gameObject.GetComponent<GraphicRaycaster>();
			Pvr_UIGraphicRaycaster component3 = component.gameObject.GetComponent<Pvr_UIGraphicRaycaster>();
			if ((bool)component3)
			{
				UnityEngine.Object.Destroy(component3);
			}
			if ((bool)component2 && !component2.enabled)
			{
				component2.enabled = true;
			}
			if ((bool)canvasBoxCollider)
			{
				UnityEngine.Object.Destroy(canvasBoxCollider);
			}
			if ((bool)canvasRigidBody)
			{
				UnityEngine.Object.Destroy(canvasRigidBody);
			}
			StopCoroutine(draggablePanelCreation);
			Transform transform = component.transform.Find("UICANVAS_DRAGGABLE_PANEL");
			if ((bool)transform)
			{
				UnityEngine.Object.Destroy(transform.gameObject);
			}
		}
	}
}
public struct UIDraggableItemEventArgs
{
	public GameObject target;
}
public delegate void UIDraggableItemEventHandler(object sender, UIDraggableItemEventArgs e);
public class Pvr_UIDraggableItem : MonoBehaviour, IBeginDragHandler, IDragHandler, IEndDragHandler, IEventSystemHandler
{
	public bool restrictToDropZone;

	public bool restrictToOriginalCanvas;

	public float moveOffset = 0.1f;

	[HideInInspector]
	public GameObject validDropZone;

	protected RectTransform dragTransform;

	protected Vector3 startPosition;

	protected Quaternion startRotation;

	protected GameObject startDropZone;

	protected Transform startParent;

	protected Canvas startCanvas;

	protected CanvasGroup canvasGroup;

	protected Pvr_InputModule currentInputmodule;

	public event UIDraggableItemEventHandler DraggableItemDropped;

	public event UIDraggableItemEventHandler DraggableItemReset;

	public virtual void OnDraggableItemDropped(UIDraggableItemEventArgs e)
	{
		if (this.DraggableItemDropped != null)
		{
			this.DraggableItemDropped(this, e);
		}
	}

	public virtual void OnDraggableItemReset(UIDraggableItemEventArgs e)
	{
		if (this.DraggableItemReset != null)
		{
			this.DraggableItemReset(this, e);
		}
	}

	public void OnBeginDrag(PointerEventData eventData)
	{
		startPosition = base.transform.position;
		startRotation = base.transform.rotation;
		startParent = base.transform.parent;
		startCanvas = GetComponentInParent<Canvas>();
		canvasGroup.blocksRaycasts = false;
		if (restrictToDropZone)
		{
			startDropZone = GetComponentInParent<Pvr_UIDropZone>().gameObject;
			validDropZone = startDropZone;
		}
		SetDragPosition(eventData);
		Pvr_UIPointer pointer = GetPointer();
		if (pointer != null)
		{
			pointer.OnUIPointerElementDragStart(pointer.SetUIPointerEvent(pointer.pointerEventData.pointerPressRaycast, base.gameObject));
		}
	}

	public void OnDrag(PointerEventData eventData)
	{
		SetDragPosition(eventData);
	}

	public void OnEndDrag(PointerEventData eventData)
	{
		canvasGroup.blocksRaycasts = true;
		dragTransform = null;
		base.transform.position += base.transform.forward * moveOffset;
		bool flag = true;
		if (restrictToDropZone)
		{
			if (validDropZone != null && validDropZone != startDropZone)
			{
				base.transform.SetParent(validDropZone.transform);
			}
			else
			{
				ResetElement();
				flag = false;
			}
		}
		Canvas canvas = ((!(eventData.pointerEnter != null)) ? null : eventData.pointerEnter.GetComponentInParent<Canvas>());
		if (restrictToOriginalCanvas && canvas != null && canvas != startCanvas)
		{
			ResetElement();
			flag = false;
		}
		if (canvas == null)
		{
			ResetElement();
			flag = false;
		}
		if (flag)
		{
			Pvr_UIPointer pointer = GetPointer();
			if (pointer != null)
			{
				pointer.OnUIPointerElementDragEnd(pointer.SetUIPointerEvent(pointer.pointerEventData.pointerPressRaycast, base.gameObject));
			}
			OnDraggableItemDropped(SetEventPayload(validDropZone));
		}
		validDropZone = null;
		startParent = null;
		startCanvas = null;
	}

	protected virtual void OnEnable()
	{
		canvasGroup = GetComponent<CanvasGroup>();
		if (restrictToDropZone && GetComponentInParent<Pvr_UIDropZone>() == null)
		{
			base.enabled = false;
		}
		currentInputmodule = UnityEngine.Object.FindObjectOfType<Pvr_InputModule>();
	}

	protected virtual Pvr_UIPointer GetPointer()
	{
		foreach (Pvr_UIPointer pointer in Pvr_InputModule.pointers)
		{
			if (pointer.gameObject.activeInHierarchy && (bool)pointer)
			{
				return pointer;
			}
		}
		return null;
	}

	protected virtual void SetDragPosition(PointerEventData eventData)
	{
		if (eventData.pointerEnter != null && eventData.pointerEnter.transform as RectTransform != null)
		{
			dragTransform = eventData.pointerEnter.transform as RectTransform;
		}
		if (dragTransform != null && RectTransformUtility.ScreenPointToWorldPointInRectangle(dragTransform, eventData.position, eventData.pressEventCamera, out var worldPoint))
		{
			base.transform.position = worldPoint - base.transform.forward * moveOffset;
			base.transform.rotation = dragTransform.rotation;
		}
	}

	protected virtual void ResetElement()
	{
		base.transform.position = startPosition;
		base.transform.rotation = startRotation;
		base.transform.SetParent(startParent);
		OnDraggableItemReset(SetEventPayload(startParent.gameObject));
	}

	protected virtual UIDraggableItemEventArgs SetEventPayload(GameObject target)
	{
		UIDraggableItemEventArgs result = default(UIDraggableItemEventArgs);
		result.target = target;
		return result;
	}
}
public class Pvr_UIDropZone : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler, IEventSystemHandler
{
	protected Pvr_UIDraggableItem droppableItem;

	public void OnPointerEnter(PointerEventData eventData)
	{
		if ((bool)eventData.pointerDrag)
		{
			Pvr_UIDraggableItem component = eventData.pointerDrag.GetComponent<Pvr_UIDraggableItem>();
			if ((bool)component && component.restrictToDropZone)
			{
				component.validDropZone = base.gameObject;
				droppableItem = component;
			}
		}
	}

	public void OnPointerExit(PointerEventData eventData)
	{
		if ((bool)droppableItem)
		{
			droppableItem.validDropZone = null;
		}
		droppableItem = null;
	}
}
public class Pvr_UIGraphicRaycaster : GraphicRaycaster
{
	protected Canvas currentCanvas;

	protected Vector2 lastKnownPosition;

	protected const float UI_CONTROL_OFFSET = 1E-05f;

	[NonSerialized]
	private static List<RaycastResult> s_RaycastResults = new List<RaycastResult>();

	protected virtual Canvas canvas
	{
		get
		{
			if (currentCanvas != null)
			{
				return currentCanvas;
			}
			currentCanvas = base.gameObject.GetComponent<Canvas>();
			return currentCanvas;
		}
	}

	public override void Raycast(PointerEventData eventData, List<RaycastResult> resultAppendList)
	{
		if (!(canvas == null))
		{
			Ray ray = new Ray(eventData.pointerCurrentRaycast.worldPosition, eventData.pointerCurrentRaycast.worldNormal);
			Raycast(canvas, eventCamera, ray, ref s_RaycastResults);
			SetNearestRaycast(ref eventData, ref resultAppendList, ref s_RaycastResults);
			s_RaycastResults.Clear();
		}
	}

	protected virtual void SetNearestRaycast(ref PointerEventData eventData, ref List<RaycastResult> resultAppendList, ref List<RaycastResult> raycastResults)
	{
		RaycastResult? raycastResult = null;
		for (int i = 0; i < raycastResults.Count; i++)
		{
			RaycastResult raycastResult2 = raycastResults[i];
			raycastResult2.index = resultAppendList.Count;
			if (!raycastResult.HasValue || raycastResult2.distance < raycastResult.Value.distance)
			{
				raycastResult = raycastResult2;
			}
			resultAppendList.Add(raycastResult2);
		}
		if (raycastResult.HasValue)
		{
			eventData.position = raycastResult.Value.screenPosition;
			eventData.delta = eventData.position - lastKnownPosition;
			lastKnownPosition = eventData.position;
			eventData.pointerCurrentRaycast = raycastResult.Value;
		}
	}

	protected virtual float GetHitDistance(Ray ray)
	{
		float result = float.MaxValue;
		if (canvas.renderMode != 0 && base.blockingObjects != 0)
		{
			float num = Vector3.Distance(ray.origin, canvas.transform.position);
			if (base.blockingObjects == BlockingObjects.ThreeD || base.blockingObjects == BlockingObjects.All)
			{
				Physics.Raycast(ray, out var hitInfo, num);
				if ((bool)hitInfo.collider)
				{
					result = hitInfo.distance;
				}
			}
			if (base.blockingObjects == BlockingObjects.TwoD || base.blockingObjects == BlockingObjects.All)
			{
				RaycastHit2D raycastHit2D = Physics2D.Raycast(ray.origin, ray.direction, num);
				if (raycastHit2D.collider != null)
				{
					result = raycastHit2D.fraction * num;
				}
			}
		}
		return result;
	}

	protected virtual void Raycast(Canvas canvas, Camera eventCamera, Ray ray, ref List<RaycastResult> results)
	{
		float hitDistance = GetHitDistance(ray);
		IList<Graphic> graphicsForCanvas = GraphicRegistry.GetGraphicsForCanvas(canvas);
		for (int i = 0; i < graphicsForCanvas.Count; i++)
		{
			Graphic graphic = graphicsForCanvas[i];
			if (graphic.depth == -1 || !graphic.raycastTarget)
			{
				continue;
			}
			Transform transform = graphic.transform;
			Vector3 forward = transform.forward;
			float num = Vector3.Dot(forward, transform.position - ray.origin) / Vector3.Dot(forward, ray.direction);
			if (!(num < 0f) && !(num - 1E-05f > hitDistance))
			{
				Vector3 point = ray.GetPoint(num);
				Vector2 vector = eventCamera.WorldToScreenPoint(point);
				if (RectTransformUtility.RectangleContainsScreenPoint(graphic.rectTransform, vector, eventCamera) && graphic.Raycast(vector, eventCamera))
				{
					RaycastResult raycastResult = default(RaycastResult);
					raycastResult.gameObject = graphic.gameObject;
					raycastResult.module = this;
					raycastResult.distance = num;
					raycastResult.screenPosition = vector;
					raycastResult.worldPosition = point;
					raycastResult.depth = graphic.depth;
					raycastResult.sortingLayer = canvas.sortingLayerID;
					raycastResult.sortingOrder = canvas.sortingOrder;
					RaycastResult item = raycastResult;
					results.Add(item);
				}
			}
		}
		results.Sort((RaycastResult g1, RaycastResult g2) => g2.depth.CompareTo(g1.depth));
	}
}
public struct UIPointerEventArgs
{
	public bool isActive;

	public GameObject currentTarget;

	public GameObject previousTarget;

	public RaycastResult raycastResult;
}
public delegate void UIPointerEventHandler(object sender, UIPointerEventArgs e);
public class Pvr_UIPointer : MonoBehaviour
{
	public enum ClickMethods
	{
		ClickOnButtonUp,
		ClickOnButtonDown
	}

	public ClickMethods clickMethod;

	[HideInInspector]
	public bool collisionClick;

	[HideInInspector]
	public bool pressToDrag;

	[HideInInspector]
	public GameObject autoActivatingCanvas;

	[HideInInspector]
	public PointerEventData pointerEventData;

	[HideInInspector]
	public GameObject hoveringElement;

	[HideInInspector]
	public float hoverDurationTimer;

	[HideInInspector]
	public bool canClickOnHover;

	public Transform pointerOriginTransform;

	protected bool pointerClicked;

	protected bool beamEnabledState;

	protected bool lastPointerPressState;

	protected bool lastPointerClickState;

	protected GameObject currentTarget;

	protected EventSystem cachedEventSystem;

	protected Pvr_InputModule cachedVRInputModule;

	protected Transform originalPointerOriginTransform;

	public static bool TouchBtnValue;

	public static bool AppBtnValue;

	public static bool TriggerBtnValue;

	public event UIPointerEventHandler UIPointerElementEnter;

	public event UIPointerEventHandler UIPointerElementExit;

	public event UIPointerEventHandler UIPointerElementClick;

	public event UIPointerEventHandler UIPointerElementDragStart;

	public event UIPointerEventHandler UIPointerElementDragEnd;

	public virtual bool PointerActive()
	{
		return true;
	}

	public virtual bool IsSelectionButtonPressed()
	{
		return Input.GetMouseButton(0) || Input.GetKey(KeyCode.JoystickButton0) || TouchBtnValue || AppBtnValue || TriggerBtnValue;
	}

	public virtual Vector3 GetOriginPosition()
	{
		return (!pointerOriginTransform) ? base.transform.position : pointerOriginTransform.position;
	}

	public virtual Vector3 GetOriginForward()
	{
		return (!pointerOriginTransform) ? base.transform.forward : pointerOriginTransform.forward;
	}

	public virtual bool ValidClick(bool checkLastClick, bool lastClickState = false)
	{
		bool flag = ((!collisionClick) ? IsSelectionButtonPressed() : collisionClick);
		return (!checkLastClick) ? flag : flag;
	}

	protected virtual void ResetHoverTimer()
	{
		hoverDurationTimer = 0f;
		canClickOnHover = false;
	}

	public virtual void OnUIPointerElementEnter(UIPointerEventArgs e)
	{
		if (e.currentTarget != currentTarget)
		{
			ResetHoverTimer();
		}
		currentTarget = e.currentTarget;
		if (this.UIPointerElementEnter != null)
		{
			this.UIPointerElementEnter(this, e);
		}
	}

	public virtual void OnUIPointerElementExit(UIPointerEventArgs e)
	{
		if (e.previousTarget == currentTarget)
		{
			ResetHoverTimer();
		}
		if (this.UIPointerElementExit != null)
		{
			this.UIPointerElementExit(this, e);
		}
	}

	public virtual void OnUIPointerElementClick(UIPointerEventArgs e)
	{
		if (e.currentTarget == currentTarget)
		{
			ResetHoverTimer();
		}
		if (this.UIPointerElementClick != null)
		{
			this.UIPointerElementClick(this, e);
		}
	}

	public virtual void OnUIPointerElementDragStart(UIPointerEventArgs e)
	{
		if (this.UIPointerElementDragStart != null)
		{
			this.UIPointerElementDragStart(this, e);
		}
	}

	public virtual void OnUIPointerElementDragEnd(UIPointerEventArgs e)
	{
		if (this.UIPointerElementDragEnd != null)
		{
			this.UIPointerElementDragEnd(this, e);
		}
	}

	public virtual UIPointerEventArgs SetUIPointerEvent(RaycastResult currentRaycastResult, GameObject currentTarget, GameObject lastTarget = null)
	{
		UIPointerEventArgs result = default(UIPointerEventArgs);
		result.isActive = PointerActive();
		result.currentTarget = currentTarget;
		result.previousTarget = lastTarget;
		result.raycastResult = currentRaycastResult;
		return result;
	}

	protected virtual void Awake()
	{
		originalPointerOriginTransform = pointerOriginTransform;
	}

	protected virtual void OnEnable()
	{
		pointerOriginTransform = originalPointerOriginTransform;
		ConfigureEventSystem();
		pointerClicked = false;
		lastPointerPressState = false;
		lastPointerClickState = false;
		beamEnabledState = false;
	}

	protected virtual void OnDisable()
	{
		Pvr_InputModule.RemovePoint(this);
	}

	protected virtual void ConfigureEventSystem()
	{
		if (!cachedEventSystem)
		{
			cachedEventSystem = UnityEngine.Object.FindObjectOfType<EventSystem>();
		}
		if (!cachedVRInputModule)
		{
			cachedVRInputModule = cachedEventSystem.GetComponent<Pvr_InputModule>();
		}
		if ((bool)cachedEventSystem && (bool)cachedVRInputModule && pointerEventData == null)
		{
			pointerEventData = new PointerEventData(cachedEventSystem);
		}
		Pvr_InputModule.AddPoint(this);
	}
}
[ExecuteInEditMode]
public class Pvr_UnitySDKEditor : MonoBehaviour
{
	private bool vrModeEnabled = true;

	private float mouseX;

	private float mouseY;

	private float mouseZ;

	private float neckModelScale;

	private bool autoUntiltHead;

	private static readonly Vector3 neckOffset = new Vector3(0f, 0.075f, 0.0805f);

	[HideInInspector]
	public Matrix4x4 headView;

	[HideInInspector]
	public Matrix4x4 leftEyeUndistortedProj;

	[HideInInspector]
	public Matrix4x4 rightEyeUndistortedProj;

	[HideInInspector]
	public Matrix4x4 leftEyeProj;

	[HideInInspector]
	public Matrix4x4 rightEyeProj;

	private const float TOUCH_TIME_LIMIT = 0.2f;

	private float touchStartTime;

	public Matrix4x4 UndistortedProjection(Eye eye)
	{
		return (eye != 0) ? rightEyeUndistortedProj : leftEyeUndistortedProj;
	}

	public Matrix4x4 Projection(Eye eye)
	{
		return (eye != 0) ? rightEyeProj : leftEyeProj;
	}

	private void Awake()
	{
		InitEyePara();
		InitEditorSensorPara();
	}

	private void Update()
	{
		SimulateInput();
		Pvr_UnitySDKManager.SDK.picovrTriggered = Pvr_UnitySDKManager.SDK.newPicovrTriggered;
		Pvr_UnitySDKManager.SDK.newPicovrTriggered = false;
	}

	public void InitEyePara()
	{
		ComputeEyesFromProfile();
		InitForEye(ref Pvr_UnitySDKManager.SDK.Eyematerial, ref Pvr_UnitySDKManager.SDK.Middlematerial);
		if (Pvr_UnitySDKRender.Instance == null)
		{
			PLOG.I("pvr_UnitySDKRender init failed");
		}
		if (Pvr_UnitySDKSensor.Instance == null)
		{
			PLOG.I("pvr_UnitySDKSensor init failed");
		}
		FovAdjust();
	}

	private void InitEditorSensorPara()
	{
		Pvr_UnitySDKManager.SDK.picovrTriggered = Pvr_UnitySDKManager.SDK.newPicovrTriggered;
		Pvr_UnitySDKManager.SDK.newPicovrTriggered = false;
	}

	public static Matrix4x4 MakeProjection(float l, float t, float r, float b, float n, float f)
	{
		Matrix4x4 zero = Matrix4x4.zero;
		zero[0, 0] = 2f * n / (r - l);
		zero[1, 1] = 2f * n / (t - b);
		zero[0, 2] = (r + l) / (r - l);
		zero[1, 2] = (t + b) / (t - b);
		zero[2, 2] = (n + f) / (n - f);
		zero[2, 3] = 2f * n * f / (n - f);
		zero[3, 2] = -1f;
		return zero;
	}

	public bool UpdateStatesensor()
	{
		UpdateSimulatedSensor();
		return true;
	}

	public void ComputeEyesFromProfile()
	{
		Vector2 vector = new Vector2(0.11f, 0.062f);
		Pvr_UnitySDKManager.SDK.leftEyeView = Matrix4x4.identity;
		Pvr_UnitySDKManager.SDK.leftEyeView[0, 3] = (0f - Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.device.devLenses.separation) / 2f;
		float[] leftEyeVisibleTanAngles = Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.GetLeftEyeVisibleTanAngles(vector.x, vector.y);
		leftEyeProj = MakeProjection(leftEyeVisibleTanAngles[0], leftEyeVisibleTanAngles[1], leftEyeVisibleTanAngles[2], leftEyeVisibleTanAngles[3], 1f, 1000f);
		leftEyeVisibleTanAngles = Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.GetLeftEyeNoLensTanAngles(vector.x, vector.y);
		leftEyeUndistortedProj = MakeProjection(leftEyeVisibleTanAngles[0], leftEyeVisibleTanAngles[1], leftEyeVisibleTanAngles[2], leftEyeVisibleTanAngles[3], 1f, 1000f);
		Pvr_UnitySDKManager.SDK.leftEyeRect = Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.GetLeftEyeVisibleScreenRect(leftEyeVisibleTanAngles, vector.x, vector.y);
		Pvr_UnitySDKManager.SDK.rightEyeView = Pvr_UnitySDKManager.SDK.leftEyeView;
		Pvr_UnitySDKManager.SDK.rightEyeView[0, 3] *= -1f;
		rightEyeProj = leftEyeProj;
		rightEyeProj[0, 2] *= -1f;
		rightEyeUndistortedProj = leftEyeUndistortedProj;
		rightEyeUndistortedProj[0, 2] *= -1f;
		Rect leftEyeRect = new Rect(0f, 0f, 0.5f, 1f);
		Rect rightEyeRect = new Rect(0.5f, 0f, 0.5f, 1f);
		Pvr_UnitySDKManager.SDK.leftEyeRect = leftEyeRect;
		Pvr_UnitySDKManager.SDK.rightEyeRect = rightEyeRect;
		Pvr_UnitySDKManager.SDK.leftEyeOffset = new Vector3((0f - Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.device.devLenses.separation) / 2f, 0f, 0f);
		Pvr_UnitySDKManager.SDK.rightEyeOffset = new Vector3(Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.device.devLenses.separation / 2f, 0f, 0f);
	}

	public bool ResetUnitySDKSensor()
	{
		mouseX = (mouseY = (mouseZ = 0f));
		return true;
	}

	private void SimulateInput()
	{
		if (Input.GetMouseButtonDown(0) && (Input.GetKey(KeyCode.LeftAlt) || Input.GetKey(KeyCode.RightAlt)))
		{
			EnableVEmodel();
		}
		if (Input.GetMouseButtonDown(0))
		{
			touchStartTime = Time.time;
		}
		else if (Input.GetMouseButtonUp(0))
		{
			if (Time.time - touchStartTime <= 0.2f)
			{
				Pvr_UnitySDKManager.SDK.newPicovrTriggered = true;
			}
			touchStartTime = 0f;
		}
		UpdateSimulatedSensor();
	}

	private void FovAdjust()
	{
		Pvr_UnitySDKRender.Instance.EyeVFoV = 2f * Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.device.devMaxFov.upper;
	}

	private Rect RectAdjust(Rect eyeRect)
	{
		Rect result = new Rect(0f, 0f, 0.5f, 1f);
		result.width *= 2f * eyeRect.width;
		result.x = eyeRect.x + 2f * result.x * eyeRect.width;
		result.height *= eyeRect.height;
		result.y = eyeRect.y + result.y * eyeRect.height;
		return result;
	}

	private void UpdateSimulatedSensor()
	{
		bool flag = false;
		if (Input.GetKey(KeyCode.LeftAlt) || Input.GetKey(KeyCode.RightAlt))
		{
			mouseX += Input.GetAxis("Mouse X") * 5f;
			if (mouseX <= -180f)
			{
				mouseX += 360f;
			}
			else if (mouseX > 180f)
			{
				mouseX -= 360f;
			}
			mouseY -= Input.GetAxis("Mouse Y") * 2.4f;
			mouseY = Mathf.Clamp(mouseY, -91f, 91f);
		}
		else if (Input.GetKey(KeyCode.LeftControl) || Input.GetKey(KeyCode.RightControl))
		{
			flag = true;
			mouseZ += Input.GetAxis("Mouse X") * 5f;
			mouseZ = Mathf.Clamp(mouseZ, -91f, 91f);
		}
		if (!flag && autoUntiltHead)
		{
			mouseZ = Mathf.Lerp(mouseZ, 0f, Time.deltaTime / (Time.deltaTime + 0.1f));
		}
		Quaternion quaternion = Quaternion.Euler(mouseY, mouseX, mouseZ);
		Vector3 vector = quaternion * neckOffset;
		Vector3 vector2 = neckOffset;
		Vector3 pos = (vector - vector2.y * Vector3.up) * neckModelScale;
		Matrix4x4 matrix = Matrix4x4.TRS(pos, quaternion, Vector3.one);
		Pvr_UnitySDKSensor.Instance.HeadPose = new Pvr_UnitySDKPose(matrix);
	}

	private void InitForEye(ref Material mat, ref Material mat1)
	{
		Shader shader = Shader.Find("Pvr_UnitySDK/Undistortion");
		Shader shader2 = Shader.Find("Pvr_UnitySDK/FillColor");
		if (shader == null || shader2 == null)
		{
			PLOG.E("Ths Shader Missing ");
			return;
		}
		mat = new Material(shader);
		mat1 = new Material(shader2);
	}

	private void EnableVEmodel()
	{
		vrModeEnabled = !vrModeEnabled;
		Pvr_UnitySDKManager.SDK.VRModeEnabled = vrModeEnabled;
	}
}
namespace Pvr_UnitySDKAPI
{
	public enum DeviceCommand
	{
		SET_PICO_NEO_HMD_BRIGHTNESS = 12,
		SET_PICO_NEO_HMD_SLEEPDELAY
	}
	public enum BrightnessLevel
	{
		VR_BRIGHTNESS_LEVEL_MIN = 1,
		VR_BRIGHTNESS_LEVEL_MAX = 100,
		VR_BRIGHTNESS_LEVEL_DOWN = 1000,
		VR_BRIGHTNESS_LEVEL_UP = 1001,
		VR_BRIGHTNESS_LEVEL_SCREEN_OFF = -100
	}
	public struct VolumePowerBrightness
	{
		public const string LibFileName = "Pvr_UnitySDK";

		public AndroidJavaObject activity;

		public static AndroidJavaClass javaSysActivityClass;

		private static AndroidJavaClass batteryjavaVrActivityClass;

		private static AndroidJavaClass volumejavaVrActivityClass;

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_SetInitActivity(IntPtr activity, IntPtr vrActivityClass);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_IsHmdExist();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetHmdScreenBrightness();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_SetHmdScreenBrightness(int brightness);

		public static bool UPvr_IsHmdExist()
		{
			return Pvr_IsHmdExist();
		}

		public static int UPvr_GetHmdScreenBrightness()
		{
			return Pvr_GetHmdScreenBrightness();
		}

		public static bool UPvr_SetHmdScreenBrightness(int brightness)
		{
			return Pvr_SetHmdScreenBrightness(brightness);
		}

		public static bool UPvr_SetCommonBrightness(int brightness)
		{
			bool flag = false;
			if (UPvr_IsHmdExist())
			{
				return UPvr_SetHmdScreenBrightness(brightness);
			}
			return UPvr_SetBrightness(brightness);
		}

		public static int UPvr_GetCommonBrightness()
		{
			int num = 0;
			if (UPvr_IsHmdExist())
			{
				return UPvr_GetHmdScreenBrightness();
			}
			return UPvr_GetCurrentBrightness();
		}

		public static int[] UPvr_GetScreenBrightnessLevel()
		{
			return Pvr_GetScreenBrightnessLevel();
		}

		public static void UPvr_SetScreenBrightnessLevel(int vrBrightness, int level)
		{
			Pvr_SetScreenBrightnessLevel(vrBrightness, level);
		}

		public static bool UPvr_SetDevicePropForUser(DeviceCommand deviceid, string number)
		{
			return setDevicePropForUser(deviceid, number);
		}

		public static string UPvr_GetDevicePropForUser(DeviceCommand deviceid)
		{
			return getDevicePropForUser(deviceid);
		}

		public static bool UPvr_InitBatteryClass()
		{
			try
			{
				if (javaSysActivityClass == null)
				{
					javaSysActivityClass = new AndroidJavaClass("com.psmart.aosoperation.SysActivity");
				}
				if (javaSysActivityClass != null && Pvr_UnitySDKRender.Instance.activity != null)
				{
					if (batteryjavaVrActivityClass == null)
					{
						batteryjavaVrActivityClass = new AndroidJavaClass("com.psmart.aosoperation.BatteryReceiver");
					}
					return true;
				}
				return false;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_InitBatteryVolClass()
		{
			try
			{
				javaSysActivityClass = new AndroidJavaClass("com.psmart.aosoperation.SysActivity");
				if (javaSysActivityClass != null && Pvr_UnitySDKRender.Instance.activity != null)
				{
					batteryjavaVrActivityClass = new AndroidJavaClass("com.psmart.aosoperation.BatteryReceiver");
					volumejavaVrActivityClass = new AndroidJavaClass("com.psmart.aosoperation.AudioReceiver");
					System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_InitAudioDevice", Pvr_UnitySDKRender.Instance.activity);
					return true;
				}
				return false;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_StartBatteryReceiver(string startreceivre)
		{
			try
			{
				System.UPvr_CallStaticMethod(batteryjavaVrActivityClass, "Pvr_StartReceiver", Pvr_UnitySDKRender.Instance.activity, startreceivre);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_StopBatteryReceiver()
		{
			try
			{
				System.UPvr_CallStaticMethod(batteryjavaVrActivityClass, "Pvr_StopReceiver", Pvr_UnitySDKRender.Instance.activity);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_SetBrightness(int brightness)
		{
			try
			{
				System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_SetScreen_Brightness", brightness, Pvr_UnitySDKRender.Instance.activity);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
				return false;
			}
		}

		public static int UPvr_GetCurrentBrightness()
		{
			int result = 0;
			try
			{
				System.UPvr_CallStaticMethod(ref result, javaSysActivityClass, "Pvr_GetScreen_Brightness", Pvr_UnitySDKRender.Instance.activity);
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
			}
			return result;
		}

		public static int[] Pvr_GetScreenBrightnessLevel()
		{
			int[] result = new int[1];
			try
			{
				System.UPvr_CallStaticMethod(ref result, javaSysActivityClass, "getScreenBrightnessLevel");
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
			}
			return result;
		}

		public static void Pvr_SetScreenBrightnessLevel(int vrBrightness, int level)
		{
			try
			{
				System.UPvr_CallStaticMethod(javaSysActivityClass, "setScreenBrightnessLevel", vrBrightness, level);
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
			}
		}

		public static bool UPvr_StartAudioReceiver(string startreceivre)
		{
			try
			{
				System.UPvr_CallStaticMethod(volumejavaVrActivityClass, "Pvr_StartReceiver", Pvr_UnitySDKRender.Instance.activity, startreceivre);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_StopAudioReceiver()
		{
			try
			{
				System.UPvr_CallStaticMethod(volumejavaVrActivityClass, "Pvr_StopReceiver", Pvr_UnitySDKRender.Instance.activity);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static int UPvr_GetMaxVolumeNumber()
		{
			int result = 0;
			try
			{
				System.UPvr_CallStaticMethod(ref result, javaSysActivityClass, "Pvr_GetMaxAudionumber");
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
			}
			return result;
		}

		public static int UPvr_GetCurrentVolumeNumber()
		{
			int result = 0;
			try
			{
				System.UPvr_CallStaticMethod(ref result, javaSysActivityClass, "Pvr_GetAudionumber");
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
			}
			return result;
		}

		public static bool UPvr_VolumeUp()
		{
			try
			{
				System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_UpAudio");
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_VolumeDown()
		{
			try
			{
				System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_DownAudio");
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_SetVolumeNum(int volume)
		{
			try
			{
				System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_ChangeAudio", volume);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_SetAudio(string s)
		{
			return false;
		}

		public static bool UPvr_SetBattery(string s)
		{
			return false;
		}

		private static string getDevicePropForUser(DeviceCommand deviceid)
		{
			string result = "0";
			System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getDevicePropForUser", (int)deviceid);
			return result;
		}

		private static bool setDevicePropForUser(DeviceCommand deviceid, string number)
		{
			bool result = false;
			System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "setDevicePropForUser", (int)deviceid, number);
			return result;
		}
	}
}
public class Pvr_VolumePowerBrightness : MonoBehaviour
{
	private bool VolEnable;

	private bool BattEnable;

	public Text showResult;

	public Text setVolumnum;

	public Text setBrightnum;

	public string MusicPath;

	private void Awake()
	{
		InitBatteryVolClass();
		string startreceivre = base.gameObject.name;
		StartBatteryReceiver(startreceivre);
		StartAudioReceiver(startreceivre);
	}

	private void OnDisable()
	{
		if (VolEnable)
		{
			StopAudioReceiver();
		}
		if (BattEnable)
		{
			StopBatteryReceiver();
		}
	}

	public void GetMaxVolumeNumber()
	{
		int num = 0;
		num = VolumePowerBrightness.UPvr_GetMaxVolumeNumber();
		showResult.text = "Maximum volume: " + num;
	}

	public void GetCurrentVolumeNumber()
	{
		int num = 0;
		num = VolumePowerBrightness.UPvr_GetCurrentVolumeNumber();
		showResult.text = "Current volume" + num;
	}

	public void VolumeUp()
	{
		bool flag = false;
		if (!VolumePowerBrightness.UPvr_VolumeUp())
		{
			PLOG.E("VolumeUp Error");
		}
	}

	public void VolumeDown()
	{
		bool flag = false;
		if (!VolumePowerBrightness.UPvr_VolumeDown())
		{
			PLOG.E("VolumeDown Error");
		}
	}

	public void SetVolumeNum()
	{
		bool flag = false;
		System.Random random = new System.Random();
		int volume = random.Next(0, 15);
		setVolumnum.text = "Random number" + volume;
		if (!VolumePowerBrightness.UPvr_SetVolumeNum(volume))
		{
			PLOG.E("SetVolumeNum Error");
		}
	}

	public void SetBrightness()
	{
		bool flag = false;
		System.Random random = new System.Random();
		int brightness = random.Next(0, 255);
		setBrightnum.text = "Random number" + brightness;
		if (!VolumePowerBrightness.UPvr_SetCommonBrightness(brightness))
		{
			PLOG.E("SetBrightness Error");
		}
	}

	public void GetCurrentBrightness()
	{
		int num = 0;
		num = VolumePowerBrightness.UPvr_GetCommonBrightness();
		showResult.text = "Current brightness" + num;
	}

	public bool setAudio(string s)
	{
		PLOG.I(s.ToString());
		return true;
	}

	public bool setBattery(string s)
	{
		PLOG.I(s.ToString());
		return true;
	}

	private bool InitBatteryVolClass()
	{
		return VolumePowerBrightness.UPvr_InitBatteryVolClass();
	}

	private bool StartBatteryReceiver(string startreceivre)
	{
		BattEnable = VolumePowerBrightness.UPvr_StartBatteryReceiver(startreceivre);
		return BattEnable;
	}

	private bool StopBatteryReceiver()
	{
		return VolumePowerBrightness.UPvr_StopBatteryReceiver();
	}

	private bool StartAudioReceiver(string startreceivre)
	{
		VolEnable = VolumePowerBrightness.UPvr_StartAudioReceiver(startreceivre);
		return VolEnable;
	}

	private bool StopAudioReceiver()
	{
		return VolumePowerBrightness.UPvr_StopAudioReceiver();
	}
}
namespace Viveport
{
	public class MainThreadDispatcher : MonoBehaviour
	{
		private static readonly Queue<Action> actions = new Queue<Action>();

		private static MainThreadDispatcher instance = null;

		private void Awake()
		{
			if (instance == null)
			{
				instance = this;
				UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
			}
		}

		public void Update()
		{
			lock (actions)
			{
				while (actions.Count > 0)
				{
					actions.Dequeue()();
				}
			}
		}

		public static MainThreadDispatcher Instance()
		{
			if (instance == null)
			{
				throw new Exception("Could not find the MainThreadDispatcher GameObject. Please ensure you have added this script to an empty GameObject in your scene.");
			}
			return instance;
		}

		private void OnDestroy()
		{
			instance = null;
		}

		public void Enqueue(IEnumerator action)
		{
			lock (actions)
			{
				actions.Enqueue(delegate
				{
					StartCoroutine(action);
				});
			}
		}

		public void Enqueue(Action action)
		{
			Enqueue(ActionWrapper(action));
		}

		public void Enqueue<T1>(Action<T1> action, T1 param1)
		{
			Enqueue(ActionWrapper(action, param1));
		}

		public void Enqueue<T1, T2>(Action<T1, T2> action, T1 param1, T2 param2)
		{
			Enqueue(ActionWrapper(action, param1, param2));
		}

		public void Enqueue<T1, T2, T3>(Action<T1, T2, T3> action, T1 param1, T2 param2, T3 param3)
		{
			Enqueue(ActionWrapper(action, param1, param2, param3));
		}

		public void Enqueue<T1, T2, T3, T4>(Action<T1, T2, T3, T4> action, T1 param1, T2 param2, T3 param3, T4 param4)
		{
			Enqueue(ActionWrapper(action, param1, param2, param3, param4));
		}

		private IEnumerator ActionWrapper(Action action)
		{
			action();
			yield return null;
		}

		private IEnumerator ActionWrapper<T1>(Action<T1> action, T1 param1)
		{
			action(param1);
			yield return null;
		}

		private IEnumerator ActionWrapper<T1, T2>(Action<T1, T2> action, T1 param1, T2 param2)
		{
			action(param1, param2);
			yield return null;
		}

		private IEnumerator ActionWrapper<T1, T2, T3>(Action<T1, T2, T3> action, T1 param1, T2 param2, T3 param3)
		{
			action(param1, param2, param3);
			yield return null;
		}

		private IEnumerator ActionWrapper<T1, T2, T3, T4>(Action<T1, T2, T3, T4> action, T1 param1, T2 param2, T3 param3, T4 param4)
		{
			action(param1, param2, param3, param4);
			yield return null;
		}
	}
}
namespace PublicKeyConvert
{
	public class PEMKeyLoader
	{
		private static byte[] SeqOID = new byte[15]
		{
			48, 13, 6, 9, 42, 134, 72, 134, 247, 13,
			1, 1, 1, 5, 0
		};

		private static bool CompareBytearrays(byte[] a, byte[] b)
		{
			if (a.Length != b.Length)
			{
				return false;
			}
			int num = 0;
			foreach (byte b2 in a)
			{
				if (b2 != b[num])
				{
					return false;
				}
				num++;
			}
			return true;
		}

		public static RSACryptoServiceProvider CryptoServiceProviderFromPublicKeyInfo(byte[] x509key)
		{
			byte[] array = new byte[15];
			if (x509key == null || x509key.Length == 0)
			{
				return null;
			}
			MemoryStream input = new MemoryStream(x509key);
			BinaryReader binaryReader = new BinaryReader(input);
			byte b = 0;
			ushort num = 0;
			try
			{
				switch (binaryReader.ReadUInt16())
				{
				case 33072:
					binaryReader.ReadByte();
					break;
				case 33328:
					binaryReader.ReadInt16();
					break;
				default:
					return null;
				}
				array = binaryReader.ReadBytes(15);
				if (!CompareBytearrays(array, SeqOID))
				{
					return null;
				}
				switch (binaryReader.ReadUInt16())
				{
				case 33027:
					binaryReader.ReadByte();
					break;
				case 33283:
					binaryReader.ReadInt16();
					break;
				default:
					return null;
				}
				if (binaryReader.ReadByte() != 0)
				{
					return null;
				}
				switch (binaryReader.ReadUInt16())
				{
				case 33072:
					binaryReader.ReadByte();
					break;
				case 33328:
					binaryReader.ReadInt16();
					break;
				default:
					return null;
				}
				num = binaryReader.ReadUInt16();
				byte b2 = 0;
				byte b3 = 0;
				switch (num)
				{
				case 33026:
					b2 = binaryReader.ReadByte();
					break;
				case 33282:
					b3 = binaryReader.ReadByte();
					b2 = binaryReader.ReadByte();
					break;
				default:
					return null;
				}
				byte[] value = new byte[4] { b2, b3, 0, 0 };
				int num2 = BitConverter.ToInt32(value, 0);
				if (binaryReader.PeekChar() == 0)
				{
					binaryReader.ReadByte();
					num2--;
				}
				byte[] modulus = binaryReader.ReadBytes(num2);
				if (binaryReader.ReadByte() != 2)
				{
					return null;
				}
				int count = binaryReader.ReadByte();
				byte[] exponent = binaryReader.ReadBytes(count);
				RSACryptoServiceProvider rSACryptoServiceProvider = new RSACryptoServiceProvider();
				RSAParameters parameters = default(RSAParameters);
				parameters.Modulus = modulus;
				parameters.Exponent = exponent;
				rSACryptoServiceProvider.ImportParameters(parameters);
				return rSACryptoServiceProvider;
			}
			finally
			{
				binaryReader.Close();
			}
		}

		public static RSACryptoServiceProvider CryptoServiceProviderFromPublicKeyInfo(string base64EncodedKey)
		{
			try
			{
				return CryptoServiceProviderFromPublicKeyInfo(Convert.FromBase64String(base64EncodedKey));
			}
			catch (FormatException)
			{
			}
			return null;
		}
	}
}
namespace Viveport
{
	public enum Locale
	{
		US,
		DE,
		JP,
		KR,
		RU,
		CN,
		TW,
		FR
	}
}
namespace Viveport.Core
{
	public class Logger
	{
		private const string LoggerTypeNameUnity = "UnityEngine.Debug";

		private static bool _hasDetected;

		private static bool _usingUnityLog = true;

		private static Type _unityLogType;

		public static void Log(string message)
		{
			if (!_hasDetected || _usingUnityLog)
			{
				UnityLog(message);
			}
			else
			{
				ConsoleLog(message);
			}
		}

		private static void ConsoleLog(string message)
		{
			Console.WriteLine(message);
			_hasDetected = true;
		}

		private static void UnityLog(string message)
		{
			try
			{
				if (_unityLogType == null)
				{
					_unityLogType = GetType("UnityEngine.Debug");
				}
				MethodInfo method = _unityLogType.GetMethod("Log", new Type[1] { typeof(string) });
				method.Invoke(null, new object[1] { message });
				_usingUnityLog = true;
			}
			catch (Exception)
			{
				ConsoleLog(message);
				_usingUnityLog = false;
			}
			_hasDetected = true;
		}

		private static Type GetType(string typeName)
		{
			Type type = Type.GetType(typeName);
			if (type != null)
			{
				return type;
			}
			Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
			foreach (Assembly assembly in assemblies)
			{
				type = assembly.GetType(typeName);
				if (type != null)
				{
					return type;
				}
			}
			return null;
		}
	}
}
namespace Viveport
{
	public delegate void StatusCallback(int nResult);
	public delegate void StatusCallback2(int nResult, string message);
	public delegate void QueryRuntimeModeCallback(int nResult, int emu);
	public class Leaderboard
	{
		public int Rank { get; set; }

		public int Score { get; set; }

		public string UserName { get; set; }
	}
	public class SubscriptionStatus
	{
		public enum Platform
		{
			Windows,
			Android
		}

		public enum TransactionType
		{
			Unknown,
			Paid,
			Redeem,
			FreeTrial
		}

		public List<Platform> Platforms { get; set; }

		public TransactionType Type { get; set; }

		public SubscriptionStatus()
		{
			Platforms = new List<Platform>();
			Type = TransactionType.Unknown;
		}
	}
	public class Api
	{
		public abstract class LicenseChecker
		{
			public abstract void OnSuccess(long issueTime, long expirationTime, int latestVersion, bool updateRequired);

			public abstract void OnFailure(int errorCode, string errorMessage);
		}

		internal static readonly List<GetLicenseCallback> InternalGetLicenseCallbacks = new List<GetLicenseCallback>();

		internal static readonly List<Viveport.Internal.StatusCallback> InternalStatusCallbacks = new List<Viveport.Internal.StatusCallback>();

		internal static readonly List<Viveport.Internal.QueryRuntimeModeCallback> InternalQueryRunTimeCallbacks = new List<Viveport.Internal.QueryRuntimeModeCallback>();

		internal static readonly List<Viveport.Internal.StatusCallback2> InternalStatusCallback2s = new List<Viveport.Internal.StatusCallback2>();

		internal static readonly List<LicenseChecker> InternalLicenseCheckers = new List<LicenseChecker>();

		private static Viveport.Internal.StatusCallback initIl2cppCallback;

		private static Viveport.Internal.StatusCallback shutdownIl2cppCallback;

		private static Viveport.Internal.QueryRuntimeModeCallback queryRuntimeModeIl2cppCallback;

		private static readonly string VERSION = "1.7.2.24";

		private static string _appId = string.Empty;

		private static string _appKey = string.Empty;

		public static void GetLicense(LicenseChecker checker, string appId, string appKey)
		{
			if (checker == null || string.IsNullOrEmpty(appId) || string.IsNullOrEmpty(appKey))
			{
				throw new InvalidOperationException("checker == null || string.IsNullOrEmpty(appId) || string.IsNullOrEmpty(appKey)");
			}
			_appId = appId;
			_appKey = appKey;
			Viveport.Internal.Api.GetLicense(checker, _appId, _appKey);
		}

		[MonoPInvokeCallback(typeof(Viveport.Internal.StatusCallback))]
		private static void InitIl2cppCallback(int errorCode)
		{
			initIl2cppCallback(errorCode);
		}

		public static int Init(StatusCallback callback, string appId)
		{
			if (callback == null || string.IsNullOrEmpty(appId))
			{
				throw new InvalidOperationException("callback == null || string.IsNullOrEmpty(appId)");
			}
			initIl2cppCallback = callback.Invoke;
			InternalStatusCallbacks.Add(InitIl2cppCallback);
			return Viveport.Internal.Api.Init(InitIl2cppCallback, appId);
		}

		[MonoPInvokeCallback(typeof(Viveport.Internal.StatusCallback))]
		private static void ShutdownIl2cppCallback(int errorCode)
		{
			shutdownIl2cppCallback(errorCode);
		}

		public static int Shutdown(StatusCallback callback)
		{
			if (callback == null)
			{
				throw new InvalidOperationException("callback == null");
			}
			shutdownIl2cppCallback = callback.Invoke;
			InternalStatusCallbacks.Add(ShutdownIl2cppCallback);
			return Viveport.Internal.Api.Shutdown(ShutdownIl2cppCallback);
		}

		public static string Version()
		{
			string empty = string.Empty;
			empty = Viveport.Internal.Api.Version();
			return "C# version: " + VERSION + ", Native version: " + empty;
		}
	}
	public class User
	{
		private static Viveport.Internal.StatusCallback isReadyIl2cppCallback;

		[MonoPInvokeCallback(typeof(Viveport.Internal.StatusCallback))]
		private static void IsReadyIl2cppCallback(int errorCode)
		{
			isReadyIl2cppCallback(errorCode);
		}

		public static int IsReady(StatusCallback callback)
		{
			if (callback == null)
			{
				throw new InvalidOperationException("callback == null");
			}
			isReadyIl2cppCallback = callback.Invoke;
			Api.InternalStatusCallbacks.Add(IsReadyIl2cppCallback);
			return Viveport.Internal.User.IsReady(IsReadyIl2cppCallback);
		}

		public static string GetUserId()
		{
			return Viveport.Internal.User.GetUserId().ToString();
		}

		public static string GetUserName()
		{
			return Viveport.Internal.User.GetUserName().ToString();
		}

		public static string GetUserAvatarUrl()
		{
			return Viveport.Internal.User.GetUserAvatarUrl().ToString();
		}
	}
	public class UserStats
	{
		public enum LeaderBoardRequestType
		{
			GlobalData,
			GlobalDataAroundUser,
			LocalData,
			LocalDataAroundUser
		}

		public enum LeaderBoardTimeRange
		{
			AllTime,
			Daily,
			Weekly,
			Monthly
		}

		public enum LeaderBoardSortMethod
		{
			None,
			Ascending,
			Descending
		}

		public enum LeaderBoardDiaplayType
		{
			None,
			Numeric,
			TimeSeconds,
			TimeMilliSeconds
		}

		public enum LeaderBoardScoreMethod
		{
			None,
			KeepBest,
			ForceUpdate
		}

		public enum AchievementDisplayAttribute
		{
			Name,
			Desc,
			Hidden
		}

		private static Viveport.Internal.StatusCallback isReadyIl2cppCallback;

		private static Viveport.Internal.StatusCallback downloadStatsIl2cppCallback;

		private static Viveport.Internal.StatusCallback uploadStatsIl2cppCallback;

		private static Viveport.Internal.StatusCallback downloadLeaderboardScoresIl2cppCallback;

		private static Viveport.Internal.StatusCallback uploadLeaderboardScoreIl2cppCallback;

		[MonoPInvokeCallback(typeof(Viveport.Internal.StatusCallback))]
		private static void IsReadyIl2cppCallback(int errorCode)
		{
			isReadyIl2cppCallback(errorCode);
		}

		public static int IsReady(StatusCallback callback)
		{
			if (callback == null)
			{
				throw new InvalidOperationException("callback == null");
			}
			isReadyIl2cppCallback = callback.Invoke;
			Api.InternalStatusCallbacks.Add(IsReadyIl2cppCallback);
			return Viveport.Internal.UserStats.IsReady(IsReadyIl2cppCallback);
		}

		[MonoPInvokeCallback(typeof(Viveport.Internal.StatusCallback))]
		private static void DownloadStatsIl2cppCallback(int errorCode)
		{
			downloadStatsIl2cppCallback(errorCode);
		}

		public static int DownloadStats(StatusCallback callback)
		{
			if (callback == null)
			{
				throw new InvalidOperationException("callback == null");
			}
			downloadStatsIl2cppCallback = callback.Invoke;
			Api.InternalStatusCallbacks.Add(DownloadStatsIl2cppCallback);
			return Viveport.Internal.UserStats.DownloadStats(DownloadStatsIl2cppCallback);
		}

		public static int GetStat(string name, int defaultValue)
		{
			return Viveport.Internal.UserStats.GetStat(name, defaultValue);
		}

		public static float GetStat(string name, float defaultValue)
		{
			return Viveport.Internal.UserStats.GetStat(name, defaultValue);
		}

		public static void SetStat(string name, int value)
		{
			Viveport.Internal.UserStats.SetStat(name, value);
		}

		public static void SetStat(string name, float value)
		{
			Viveport.Internal.UserStats.SetStat(name, value);
		}

		[MonoPInvokeCallback(typeof(Viveport.Internal.StatusCallback))]
		private static void UploadStatsIl2cppCallback(int errorCode)
		{
			uploadStatsIl2cppCallback(errorCode);
		}

		public static int UploadStats(StatusCallback callback)
		{
			if (callback == null)
			{
				throw new InvalidOperationException("callback == null");
			}
			uploadStatsIl2cppCallback = callback.Invoke;
			Api.InternalStatusCallbacks.Add(UploadStatsIl2cppCallback);
			return Viveport.Internal.UserStats.UploadStats(UploadStatsIl2cppCallback);
		}

		public static bool GetAchievement(string pchName)
		{
			return Viveport.Internal.UserStats.GetAchievement(pchName);
		}

		public static int GetAchievementUnlockTime(string pchName)
		{
			return Viveport.Internal.UserStats.GetAchievementUnlockTime(pchName);
		}

		public static string GetAchievementIcon(string pchName)
		{
			return Viveport.Internal.UserStats.GetAchievementIcon(pchName);
		}

		public static string GetAchievementDisplayAttribute(string pchName, AchievementDisplayAttribute attr)
		{
			return Viveport.Internal.UserStats.GetAchievementDisplayAttribute(pchName, (EAchievementDisplayAttribute)attr);
		}

		public static string GetAchievementDisplayAttribute(string pchName, AchievementDisplayAttribute attr, Locale locale)
		{
			return Viveport.Internal.UserStats.GetAchievementDisplayAttribute(pchName, (EAchievementDisplayAttribute)attr, (ELocale)locale);
		}

		public static int SetAchievement(string pchName)
		{
			return Viveport.Internal.UserStats.SetAchievement(pchName);
		}

		public static int ClearAchievement(string pchName)
		{
			return Viveport.Internal.UserStats.ClearAchievement(pchName);
		}

		[MonoPInvokeCallback(typeof(Viveport.Internal.StatusCallback))]
		private static void DownloadLeaderboardScoresIl2cppCallback(int errorCode)
		{
			downloadLeaderboardScoresIl2cppCallback(errorCode);
		}

		public static int DownloadLeaderboardScores(StatusCallback callback, string pchLeaderboardName, LeaderBoardRequestType eLeaderboardDataRequest, LeaderBoardTimeRange eLeaderboardDataTimeRange, int nRangeStart, int nRangeEnd)
		{
			if (callback == null)
			{
				throw new InvalidOperationException("callback == null");
			}
			downloadLeaderboardScoresIl2cppCallback = callback.Invoke;
			Api.InternalStatusCallbacks.Add(DownloadLeaderboardScoresIl2cppCallback);
			return Viveport.Internal.UserStats.DownloadLeaderboardScores(DownloadLeaderboardScoresIl2cppCallback, pchLeaderboardName, (ELeaderboardDataRequest)eLeaderboardDataRequest, (ELeaderboardDataTimeRange)eLeaderboardDataTimeRange, nRangeStart, nRangeEnd);
		}

		[MonoPInvokeCallback(typeof(Viveport.Internal.StatusCallback))]
		private static void UploadLeaderboardScoreIl2cppCallback(int errorCode)
		{
			uploadLeaderboardScoreIl2cppCallback(errorCode);
		}

		public static int UploadLeaderboardScore(StatusCallback callback, string pchLeaderboardName, int nScore)
		{
			if (callback == null)
			{
				throw new InvalidOperationException("callback == null");
			}
			uploadLeaderboardScoreIl2cppCallback = callback.Invoke;
			Api.InternalStatusCallbacks.Add(UploadLeaderboardScoreIl2cppCallback);
			return Viveport.Internal.UserStats.UploadLeaderboardScore(UploadLeaderboardScoreIl2cppCallback, pchLeaderboardName, nScore);
		}

		public static Leaderboard GetLeaderboardScore(int index)
		{
			return Viveport.Internal.UserStats.GetLeaderboardScore(index);
		}

		public static int GetLeaderboardScoreCount()
		{
			return Viveport.Internal.UserStats.GetLeaderboardScoreCount();
		}

		public static LeaderBoardSortMethod GetLeaderboardSortMethod()
		{
			return (LeaderBoardSortMethod)Viveport.Internal.UserStats.GetLeaderboardSortMethod();
		}

		public static LeaderBoardDiaplayType GetLeaderboardDisplayType()
		{
			return (LeaderBoardDiaplayType)Viveport.Internal.UserStats.GetLeaderboardDisplayType();
		}
	}
	public class ArcadeLeaderboard
	{
	}
	public class IAPurchase
	{
		private class IAPHandler : BaseHandler
		{
			private static IAPurchaseListener listener;

			public IAPHandler(IAPurchaseListener cb)
			{
				listener = cb;
			}

			public IAPurchaseCallback getIsReadyHandler()
			{
				return IsReadyHandler;
			}

			protected override void IsReadyHandler(int code, [MarshalAs(UnmanagedType.LPStr)] string message)
			{
				Viveport.Core.Logger.Log("[IsReadyHandler] message=" + message);
				JsonData jsonData = JsonMapper.ToObject(message);
				int num = -1;
				string text = string.Empty;
				string text2 = string.Empty;
				if (code == 0)
				{
					try
					{
						num = (int)jsonData["statusCode"];
						text2 = (string)jsonData["message"];
					}
					catch (Exception ex)
					{
						Viveport.Core.Logger.Log("[IsReadyHandler] statusCode, message ex=" + ex);
					}
					Viveport.Core.Logger.Log("[IsReadyHandler] statusCode =" + num + ",errMessage=" + text2);
					if (num == 0)
					{
						try
						{
							text = (string)jsonData["currencyName"];
						}
						catch (Exception ex2)
						{
							Viveport.Core.Logger.Log("[IsReadyHandler] currencyName ex=" + ex2);
						}
						Viveport.Core.Logger.Log("[IsReadyHandler] currencyName=" + text);
					}
				}
				if (listener == null)
				{
					return;
				}
				if (code == 0)
				{
					if (num == 0)
					{
						listener.OnSuccess(text);
					}
					else
					{
						listener.OnFailure(num, text2);
					}
				}
				else
				{
					listener.OnFailure(code, message);
				}
			}

			public IAPurchaseCallback getRequestHandler()
			{
				return RequestHandler;
			}

			protected override void RequestHandler(int code, [MarshalAs(UnmanagedType.LPStr)] string message)
			{
				Viveport.Core.Logger.Log("[RequestHandler] message=" + message);
				JsonData jsonData = JsonMapper.ToObject(message);
				int num = -1;
				string text = string.Empty;
				string text2 = string.Empty;
				if (code == 0)
				{
					try
					{
						num = (int)jsonData["statusCode"];
						text2 = (string)jsonData["message"];
					}
					catch (Exception ex)
					{
						Viveport.Core.Logger.Log("[RequestHandler] statusCode, message ex=" + ex);
					}
					Viveport.Core.Logger.Log("[RequestHandler] statusCode =" + num + ",errMessage=" + text2);
					if (num == 0)
					{
						try
						{
							text = (string)jsonData["purchase_id"];
						}
						catch (Exception ex2)
						{
							Viveport.Core.Logger.Log("[RequestHandler] purchase_id ex=" + ex2);
						}
						Viveport.Core.Logger.Log("[RequestHandler] purchaseId =" + text);
					}
				}
				if (listener == null)
				{
					return;
				}
				if (code == 0)
				{
					if (num == 0)
					{
						listener.OnRequestSuccess(text);
					}
					else
					{
						listener.OnFailure(num, text2);
					}
				}
				else
				{
					listener.OnFailure(code, message);
				}
			}

			public IAPurchaseCallback getPurchaseHandler()
			{
				return PurchaseHandler;
			}

			protected override void PurchaseHandler(int code, [MarshalAs(UnmanagedType.LPStr)] string message)
			{
				Viveport.Core.Logger.Log("[PurchaseHandler] message=" + message);
				JsonData jsonData = JsonMapper.ToObject(message);
				int num = -1;
				string text = string.Empty;
				string text2 = string.Empty;
				long num2 = 0L;
				if (code == 0)
				{
					try
					{
						num = (int)jsonData["statusCode"];
						text2 = (string)jsonData["message"];
					}
					catch (Exception ex)
					{
						Viveport.Core.Logger.Log("[PurchaseHandler] statusCode, message ex=" + ex);
					}
					Viveport.Core.Logger.Log("[PurchaseHandler] statusCode =" + num + ",errMessage=" + text2);
					if (num == 0)
					{
						try
						{
							text = (string)jsonData["purchase_id"];
							num2 = (long)jsonData["paid_timestamp"];
						}
						catch (Exception ex2)
						{
							Viveport.Core.Logger.Log("[PurchaseHandler] purchase_id,paid_timestamp ex=" + ex2);
						}
						Viveport.Core.Logger.Log("[PurchaseHandler] purchaseId =" + text + ",paid_timestamp=" + num2);
					}
				}
				if (listener == null)
				{
					return;
				}
				if (code == 0)
				{
					if (num == 0)
					{
						listener.OnPurchaseSuccess(text);
					}
					else
					{
						listener.OnFailure(num, text2);
					}
				}
				else
				{
					listener.OnFailure(code, message);
				}
			}

			public IAPurchaseCallback getQueryHandler()
			{
				return QueryHandler;
			}

			protected override void QueryHandler(int code, [MarshalAs(UnmanagedType.LPStr)] string message)
			{
				Viveport.Core.Logger.Log("[QueryHandler] message=" + message);
				JsonData jsonData = JsonMapper.ToObject(message);
				int num = -1;
				string text = string.Empty;
				string text2 = string.Empty;
				string text3 = string.Empty;
				string text4 = string.Empty;
				string text5 = string.Empty;
				string text6 = string.Empty;
				long num2 = 0L;
				if (code == 0)
				{
					try
					{
						num = (int)jsonData["statusCode"];
						text2 = (string)jsonData["message"];
					}
					catch (Exception ex)
					{
						Viveport.Core.Logger.Log("[QueryHandler] statusCode, message ex=" + ex);
					}
					Viveport.Core.Logger.Log("[QueryHandler] statusCode =" + num + ",errMessage=" + text2);
					if (num == 0)
					{
						try
						{
							text = (string)jsonData["purchase_id"];
							text3 = (string)jsonData["order_id"];
							text4 = (string)jsonData["status"];
							text5 = (string)jsonData["price"];
							text6 = (string)jsonData["currency"];
							num2 = (long)jsonData["paid_timestamp"];
						}
						catch (Exception ex2)
						{
							Viveport.Core.Logger.Log("[QueryHandler] purchase_id, order_id ex=" + ex2);
						}
						Viveport.Core.Logger.Log("[QueryHandler] status =" + text4 + ",price=" + text5 + ",currency=" + text6);
						Viveport.Core.Logger.Log("[QueryHandler] purchaseId =" + text + ",order_id=" + text3 + ",paid_timestamp=" + num2);
					}
				}
				if (listener == null)
				{
					return;
				}
				if (code == 0)
				{
					if (num == 0)
					{
						QueryResponse queryResponse = new QueryResponse();
						queryResponse.purchase_id = text;
						queryResponse.order_id = text3;
						queryResponse.price = text5;
						queryResponse.currency = text6;
						queryResponse.paid_timestamp = num2;
						queryResponse.status = text4;
						listener.OnQuerySuccess(queryResponse);
					}
					else
					{
						listener.OnFailure(num, text2);
					}
				}
				else
				{
					listener.OnFailure(code, message);
				}
			}

			public IAPurchaseCallback getQueryListHandler()
			{
				return QueryListHandler;
			}

			protected override void QueryListHandler(int code, [MarshalAs(UnmanagedType.LPStr)] string message)
			{
				Viveport.Core.Logger.Log("[QueryListHandler] message=" + message);
				JsonData jsonData = JsonMapper.ToObject(message);
				int num = -1;
				int total = 0;
				int from = 0;
				int to = 0;
				List<QueryResponse2> list = new List<QueryResponse2>();
				string text = string.Empty;
				if (code == 0)
				{
					try
					{
						num = (int)jsonData["statusCode"];
						text = (string)jsonData["message"];
					}
					catch (Exception ex)
					{
						Viveport.Core.Logger.Log("[QueryListHandler] statusCode, message ex=" + ex);
					}
					Viveport.Core.Logger.Log("[QueryListHandler] statusCode =" + num + ",errMessage=" + text);
					if (num == 0)
					{
						try
						{
							JsonData jsonData2 = JsonMapper.ToObject(text);
							total = (int)jsonData2["total"];
							from = (int)jsonData2["from"];
							to = (int)jsonData2["to"];
							JsonData jsonData3 = jsonData2["purchases"];
							bool isArray = jsonData3.IsArray;
							foreach (JsonData item in (IEnumerable)jsonData3)
							{
								QueryResponse2 queryResponse = new QueryResponse2();
								IDictionary dictionary = item;
								queryResponse.app_id = ((!dictionary.Contains("app_id")) ? string.Empty : ((string)item["app_id"]));
								queryResponse.currency = ((!dictionary.Contains("currency")) ? string.Empty : ((string)item["currency"]));
								queryResponse.purchase_id = ((!dictionary.Contains("purchase_id")) ? string.Empty : ((string)item["purchase_id"]));
								queryResponse.order_id = ((!dictionary.Contains("order_id")) ? string.Empty : ((string)item["order_id"]));
								queryResponse.price = ((!dictionary.Contains("price")) ? string.Empty : ((string)item["price"]));
								queryResponse.user_data = ((!dictionary.Contains("user_data")) ? string.Empty : ((string)item["user_data"]));
								if (dictionary.Contains("paid_timestamp"))
								{
									if (item["paid_timestamp"].IsLong)
									{
										queryResponse.paid_timestamp = (long)item["paid_timestamp"];
									}
									else if (item["paid_timestamp"].IsInt)
									{
										queryResponse.paid_timestamp = (int)item["paid_timestamp"];
									}
								}
								list.Add(queryResponse);
							}
						}
						catch (Exception ex2)
						{
							Viveport.Core.Logger.Log("[QueryListHandler] purchase_id, order_id ex=" + ex2);
						}
					}
				}
				if (listener == null)
				{
					return;
				}
				if (code == 0)
				{
					if (num == 0)
					{
						QueryListResponse queryListResponse = new QueryListResponse();
						queryListResponse.total = total;
						queryListResponse.from = from;
						queryListResponse.to = to;
						queryListResponse.purchaseList = list;
						listener.OnQuerySuccess(queryListResponse);
					}
					else
					{
						listener.OnFailure(num, text);
					}
				}
				else
				{
					listener.OnFailure(code, message);
				}
			}

			public IAPurchaseCallback getBalanceHandler()
			{
				return BalanceHandler;
			}

			protected override void BalanceHandler(int code, [MarshalAs(UnmanagedType.LPStr)] string message)
			{
				Viveport.Core.Logger.Log("[BalanceHandler] code=" + code + ",message= " + message);
				JsonData jsonData = JsonMapper.ToObject(message);
				int num = -1;
				string text = string.Empty;
				string text2 = string.Empty;
				string text3 = string.Empty;
				if (code == 0)
				{
					try
					{
						num = (int)jsonData["statusCode"];
						text3 = (string)jsonData["message"];
					}
					catch (Exception ex)
					{
						Viveport.Core.Logger.Log("[BalanceHandler] statusCode, message ex=" + ex);
					}
					Viveport.Core.Logger.Log("[BalanceHandler] statusCode =" + num + ",errMessage=" + text3);
					if (num == 0)
					{
						try
						{
							text = (string)jsonData["currencyName"];
							text2 = (string)jsonData["balance"];
						}
						catch (Exception ex2)
						{
							Viveport.Core.Logger.Log("[BalanceHandler] currencyName, balance ex=" + ex2);
						}
						Viveport.Core.Logger.Log("[BalanceHandler] currencyName=" + text + ",balance=" + text2);
					}
				}
				if (listener == null)
				{
					return;
				}
				if (code == 0)
				{
					if (num == 0)
					{
						listener.OnBalanceSuccess(text2);
					}
					else
					{
						listener.OnFailure(num, text3);
					}
				}
				else
				{
					listener.OnFailure(code, message);
				}
			}

			public IAPurchaseCallback getRequestSubscriptionHandler()
			{
				return RequestSubscriptionHandler;
			}

			protected override void RequestSubscriptionHandler(int code, [MarshalAs(UnmanagedType.LPStr)] string message)
			{
				Viveport.Core.Logger.Log("[RequestSubscriptionHandler] message=" + message);
				JsonData jsonData = JsonMapper.ToObject(message);
				int num = -1;
				string text = string.Empty;
				string text2 = string.Empty;
				try
				{
					num = (int)jsonData["statusCode"];
					text2 = (string)jsonData["message"];
				}
				catch (Exception ex)
				{
					Viveport.Core.Logger.Log("[RequestSubscriptionHandler] statusCode, message ex=" + ex);
				}
				Viveport.Core.Logger.Log("[RequestSubscriptionHandler] statusCode =" + num + ",errMessage=" + text2);
				if (num == 0)
				{
					try
					{
						text = (string)jsonData["subscription_id"];
					}
					catch (Exception ex2)
					{
						Viveport.Core.Logger.Log("[RequestSubscriptionHandler] subscription_id ex=" + ex2);
					}
					Viveport.Core.Logger.Log("[RequestSubscriptionHandler] subscription_id =" + text);
				}
				if (listener == null)
				{
					return;
				}
				if (code == 0)
				{
					if (num == 0)
					{
						listener.OnRequestSubscriptionSuccess(text);
					}
					else
					{
						listener.OnFailure(num, text2);
					}
				}
				else
				{
					listener.OnFailure(code, message);
				}
			}

			public IAPurchaseCallback getRequestSubscriptionWithPlanIDHandler()
			{
				return RequestSubscriptionWithPlanIDHandler;
			}

			protected override void RequestSubscriptionWithPlanIDHandler(int code, [MarshalAs(UnmanagedType.LPStr)] string message)
			{
				Viveport.Core.Logger.Log("[RequestSubscriptionWithPlanIDHandler] message=" + message);
				JsonData jsonData = JsonMapper.ToObject(message);
				int num = -1;
				string text = string.Empty;
				string text2 = string.Empty;
				try
				{
					num = (int)jsonData["statusCode"];
					text2 = (string)jsonData["message"];
				}
				catch (Exception ex)
				{
					Viveport.Core.Logger.Log("[RequestSubscriptionWithPlanIDHandler] statusCode, message ex=" + ex);
				}
				Viveport.Core.Logger.Log("[RequestSubscriptionWithPlanIDHandler] statusCode =" + num + ",errMessage=" + text2);
				if (num == 0)
				{
					try
					{
						text = (string)jsonData["subscription_id"];
					}
					catch (Exception ex2)
					{
						Viveport.Core.Logger.Log("[RequestSubscriptionWithPlanIDHandler] subscription_id ex=" + ex2);
					}
					Viveport.Core.Logger.Log("[RequestSubscriptionWithPlanIDHandler] subscription_id =" + text);
				}
				if (listener == null)
				{
					return;
				}
				if (code == 0)
				{
					if (num == 0)
					{
						listener.OnRequestSubscriptionWithPlanIDSuccess(text);
					}
					else
					{
						listener.OnFailure(num, text2);
					}
				}
				else
				{
					listener.OnFailure(code, message);
				}
			}

			public IAPurchaseCallback getSubscribeHandler()
			{
				return SubscribeHandler;
			}

			protected override void SubscribeHandler(int code, [MarshalAs(UnmanagedType.LPStr)] string message)
			{
				Viveport.Core.Logger.Log("[SubscribeHandler] message=" + message);
				JsonData jsonData = JsonMapper.ToObject(message);
				int num = -1;
				string text = string.Empty;
				string text2 = string.Empty;
				string text3 = string.Empty;
				long num2 = 0L;
				try
				{
					num = (int)jsonData["statusCode"];
					text2 = (string)jsonData["message"];
				}
				catch (Exception ex)
				{
					Viveport.Core.Logger.Log("[SubscribeHandler] statusCode, message ex=" + ex);
				}
				Viveport.Core.Logger.Log("[SubscribeHandler] statusCode =" + num + ",errMessage=" + text2);
				if (num == 0)
				{
					try
					{
						text = (string)jsonData["subscription_id"];
						text3 = (string)jsonData["plan_id"];
						num2 = (long)jsonData["subscribed_timestamp"];
					}
					catch (Exception ex2)
					{
						Viveport.Core.Logger.Log("[SubscribeHandler] subscription_id, plan_id ex=" + ex2);
					}
					Viveport.Core.Logger.Log("[SubscribeHandler] subscription_id =" + text + ", plan_id=" + text3 + ", timestamp=" + num2);
				}
				if (listener == null)
				{
					return;
				}
				if (code == 0)
				{
					if (num == 0)
					{
						listener.OnSubscribeSuccess(text);
					}
					else
					{
						listener.OnFailure(num, text2);
					}
				}
				else
				{
					listener.OnFailure(code, message);
				}
			}

			public IAPurchaseCallback getQuerySubscriptionHandler()
			{
				return QuerySubscriptionHandler;
			}

			protected override void QuerySubscriptionHandler(int code, [MarshalAs(UnmanagedType.LPStr)] string message)
			{
				Viveport.Core.Logger.Log("[QuerySubscriptionHandler] message=" + message);
				JsonData jsonData = JsonMapper.ToObject(message);
				int num = -1;
				string text = string.Empty;
				List<Subscription> list = null;
				if (code == 0)
				{
					try
					{
						num = (int)jsonData["statusCode"];
						text = (string)jsonData["message"];
					}
					catch (Exception ex)
					{
						Viveport.Core.Logger.Log("[QuerySubscriptionHandler] statusCode, message ex=" + ex);
					}
					Viveport.Core.Logger.Log("[QuerySubscriptionHandler] statusCode =" + num + ",errMessage=" + text);
					if (num == 0)
					{
						try
						{
							QuerySubscritionResponse querySubscritionResponse = JsonMapper.ToObject<QuerySubscritionResponse>(message);
							list = querySubscritionResponse.subscriptions;
						}
						catch (Exception ex2)
						{
							Viveport.Core.Logger.Log("[QuerySubscriptionHandler] ex =" + ex2);
						}
					}
				}
				if (listener == null)
				{
					return;
				}
				if (code == 0)
				{
					if (num == 0 && list != null && list.Count > 0)
					{
						listener.OnQuerySubscriptionSuccess(list.ToArray());
					}
					else
					{
						listener.OnFailure(num, text);
					}
				}
				else
				{
					listener.OnFailure(code, message);
				}
			}

			public IAPurchaseCallback getQuerySubscriptionListHandler()
			{
				return QuerySubscriptionListHandler;
			}

			protected override void QuerySubscriptionListHandler(int code, [MarshalAs(UnmanagedType.LPStr)] string message)
			{
				Viveport.Core.Logger.Log("[QuerySubscriptionListHandler] message=" + message);
				JsonData jsonData = JsonMapper.ToObject(message);
				int num = -1;
				string text = string.Empty;
				List<Subscription> list = null;
				if (code == 0)
				{
					try
					{
						num = (int)jsonData["statusCode"];
						text = (string)jsonData["message"];
					}
					catch (Exception ex)
					{
						Viveport.Core.Logger.Log("[QuerySubscriptionListHandler] statusCode, message ex=" + ex);
					}
					Viveport.Core.Logger.Log("[QuerySubscriptionListHandler] statusCode =" + num + ",errMessage=" + text);
					if (num == 0)
					{
						try
						{
							QuerySubscritionResponse querySubscritionResponse = JsonMapper.ToObject<QuerySubscritionResponse>(message);
							list = querySubscritionResponse.subscriptions;
						}
						catch (Exception ex2)
						{
							Viveport.Core.Logger.Log("[QuerySubscriptionListHandler] ex =" + ex2);
						}
					}
				}
				if (listener == null)
				{
					return;
				}
				if (code == 0)
				{
					if (num == 0 && list != null && list.Count > 0)
					{
						listener.OnQuerySubscriptionListSuccess(list.ToArray());
					}
					else
					{
						listener.OnFailure(num, text);
					}
				}
				else
				{
					listener.OnFailure(code, message);
				}
			}

			public IAPurchaseCallback getCancelSubscriptionHandler()
			{
				return CancelSubscriptionHandler;
			}

			protected override void CancelSubscriptionHandler(int code, [MarshalAs(UnmanagedType.LPStr)] string message)
			{
				Viveport.Core.Logger.Log("[CancelSubscriptionHandler] message=" + message);
				JsonData jsonData = JsonMapper.ToObject(message);
				int num = -1;
				bool flag = false;
				string text = string.Empty;
				if (code == 0)
				{
					try
					{
						num = (int)jsonData["statusCode"];
						text = (string)jsonData["message"];
					}
					catch (Exception ex)
					{
						Viveport.Core.Logger.Log("[CancelSubscriptionHandler] statusCode, message ex=" + ex);
					}
					Viveport.Core.Logger.Log("[CancelSubscriptionHandler] statusCode =" + num + ",errMessage=" + text);
					if (num == 0)
					{
						flag = true;
						Viveport.Core.Logger.Log("[CancelSubscriptionHandler] isCanceled = " + flag);
					}
				}
				if (listener == null)
				{
					return;
				}
				if (code == 0)
				{
					if (num == 0)
					{
						listener.OnCancelSubscriptionSuccess(flag);
					}
					else
					{
						listener.OnFailure(num, text);
					}
				}
				else
				{
					listener.OnFailure(code, message);
				}
			}
		}

		private abstract class BaseHandler
		{
			protected abstract void IsReadyHandler(int code, [MarshalAs(UnmanagedType.LPStr)] string message);

			protected abstract void RequestHandler(int code, [MarshalAs(UnmanagedType.LPStr)] string message);

			protected abstract void PurchaseHandler(int code, [MarshalAs(UnmanagedType.LPStr)] string message);

			protected abstract void QueryHandler(int code, [MarshalAs(UnmanagedType.LPStr)] string message);

			protected abstract void QueryListHandler(int code, [MarshalAs(UnmanagedType.LPStr)] string message);

			protected abstract void BalanceHandler(int code, [MarshalAs(UnmanagedType.LPStr)] string message);

			protected abstract void RequestSubscriptionHandler(int code, [MarshalAs(UnmanagedType.LPStr)] string message);

			protected abstract void RequestSubscriptionWithPlanIDHandler(int code, [MarshalAs(UnmanagedType.LPStr)] string message);

			protected abstract void SubscribeHandler(int code, [MarshalAs(UnmanagedType.LPStr)] string message);

			protected abstract void QuerySubscriptionHandler(int code, [MarshalAs(UnmanagedType.LPStr)] string message);

			protected abstract void QuerySubscriptionListHandler(int code, [MarshalAs(UnmanagedType.LPStr)] string message);

			protected abstract void CancelSubscriptionHandler(int code, [MarshalAs(UnmanagedType.LPStr)] string message);
		}

		public class IAPurchaseListener
		{
			public virtual void OnSuccess(string pchCurrencyName)
			{
			}

			public virtual void OnRequestSuccess(string pchPurchaseId)
			{
			}

			public virtual void OnPurchaseSuccess(string pchPurchaseId)
			{
			}

			public virtual void OnQuerySuccess(QueryResponse response)
			{
			}

			public virtual void OnQuerySuccess(QueryListResponse response)
			{
			}

			public virtual void OnBalanceSuccess(string pchBalance)
			{
			}

			public virtual void OnFailure(int nCode, string pchMessage)
			{
			}

			public virtual void OnRequestSubscriptionSuccess(string pchSubscriptionId)
			{
			}

			public virtual void OnRequestSubscriptionWithPlanIDSuccess(string pchSubscriptionId)
			{
			}

			public virtual void OnSubscribeSuccess(string pchSubscriptionId)
			{
			}

			public virtual void OnQuerySubscriptionSuccess(Subscription[] subscriptionlist)
			{
			}

			public virtual void OnQuerySubscriptionListSuccess(Subscription[] subscriptionlist)
			{
			}

			public virtual void OnCancelSubscriptionSuccess(bool bCanceled)
			{
			}
		}

		public class QueryResponse
		{
			public string order_id { get; set; }

			public string purchase_id { get; set; }

			public string status { get; set; }

			public string price { get; set; }

			public string currency { get; set; }

			public long paid_timestamp { get; set; }
		}

		public class QueryResponse2
		{
			public string order_id { get; set; }

			public string app_id { get; set; }

			public string purchase_id { get; set; }

			public string user_data { get; set; }

			public string price { get; set; }

			public string currency { get; set; }

			public long paid_timestamp { get; set; }
		}

		public class QueryListResponse
		{
			public List<QueryResponse2> purchaseList;

			public int total { get; set; }

			public int from { get; set; }

			public int to { get; set; }
		}

		public class StatusDetailTransaction
		{
			public long create_time { get; set; }

			public string payment_method { get; set; }

			public string status { get; set; }
		}

		public class StatusDetail
		{
			public long date_next_charge { get; set; }

			public StatusDetailTransaction[] transactions { get; set; }

			public string cancel_reason { get; set; }
		}

		public class TimePeriod
		{
			public string time_type { get; set; }

			public int value { get; set; }
		}

		public class Subscription
		{
			public string app_id { get; set; }

			public string order_id { get; set; }

			public string subscription_id { get; set; }

			public string price { get; set; }

			public string currency { get; set; }

			public long subscribed_timestamp { get; set; }

			public TimePeriod free_trial_period { get; set; }

			public TimePeriod charge_period { get; set; }

			public int number_of_charge_period { get; set; }

			public string plan_id { get; set; }

			public string plan_name { get; set; }

			public string status { get; set; }

			public StatusDetail status_detail { get; set; }
		}

		public class QuerySubscritionResponse
		{
			public int statusCode { get; set; }

			public string message { get; set; }

			public List<Subscription> subscriptions { get; set; }
		}

		private static IAPurchaseCallback isReadyIl2cppCallback;

		private static IAPurchaseCallback request01Il2cppCallback;

		private static IAPurchaseCallback request02Il2cppCallback;

		private static IAPurchaseCallback purchaseIl2cppCallback;

		private static IAPurchaseCallback query01Il2cppCallback;

		private static IAPurchaseCallback query02Il2cppCallback;

		private static IAPurchaseCallback getBalanceIl2cppCallback;

		private static IAPurchaseCallback requestSubscriptionIl2cppCallback;

		private static IAPurchaseCallback requestSubscriptionWithPlanIDIl2cppCallback;

		private static IAPurchaseCallback subscribeIl2cppCallback;

		private static IAPurchaseCallback querySubscriptionIl2cppCallback;

		private static IAPurchaseCallback querySubscriptionListIl2cppCallback;

		private static IAPurchaseCallback cancelSubscriptionIl2cppCallback;

		[MonoPInvokeCallback(typeof(IAPurchaseCallback))]
		private static void IsReadyIl2cppCallback(int errorCode, string message)
		{
			isReadyIl2cppCallback(errorCode, message);
		}

		public static void IsReady(IAPurchaseListener listener, string pchAppKey)
		{
			isReadyIl2cppCallback = new IAPHandler(listener).getIsReadyHandler();
			Viveport.Internal.IAPurchase.IsReady(IsReadyIl2cppCallback, pchAppKey);
		}

		[MonoPInvokeCallback(typeof(IAPurchaseCallback))]
		private static void Request01Il2cppCallback(int errorCode, string message)
		{
			request01Il2cppCallback(errorCode, message);
		}

		public static void Request(IAPurchaseListener listener, string pchPrice)
		{
			request01Il2cppCallback = new IAPHandler(listener).getRequestHandler();
			Viveport.Internal.IAPurchase.Request(Request01Il2cppCallback, pchPrice);
		}

		[MonoPInvokeCallback(typeof(IAPurchaseCallback))]
		private static void Request02Il2cppCallback(int errorCode, string message)
		{
			request02Il2cppCallback(errorCode, message);
		}

		public static void Request(IAPurchaseListener listener, string pchPrice, string pchUserData)
		{
			request02Il2cppCallback = new IAPHandler(listener).getRequestHandler();
			Viveport.Internal.IAPurchase.Request(Request02Il2cppCallback, pchPrice, pchUserData);
		}

		[MonoPInvokeCallback(typeof(IAPurchaseCallback))]
		private static void PurchaseIl2cppCallback(int errorCode, string message)
		{
			purchaseIl2cppCallback(errorCode, message);
		}

		public static void Purchase(IAPurchaseListener listener, string pchPurchaseId)
		{
			purchaseIl2cppCallback = new IAPHandler(listener).getPurchaseHandler();
			Viveport.Internal.IAPurchase.Purchase(PurchaseIl2cppCallback, pchPurchaseId);
		}

		[MonoPInvokeCallback(typeof(IAPurchaseCallback))]
		private static void Query01Il2cppCallback(int errorCode, string message)
		{
			query01Il2cppCallback(errorCode, message);
		}

		public static void Query(IAPurchaseListener listener, string pchPurchaseId)
		{
			query01Il2cppCallback = new IAPHandler(listener).getQueryHandler();
			Viveport.Internal.IAPurchase.Query(Query01Il2cppCallback, pchPurchaseId);
		}

		[MonoPInvokeCallback(typeof(IAPurchaseCallback))]
		private static void Query02Il2cppCallback(int errorCode, string message)
		{
			query02Il2cppCallback(errorCode, message);
		}

		public static void Query(IAPurchaseListener listener)
		{
			query02Il2cppCallback = new IAPHandler(listener).getQueryListHandler();
			Viveport.Internal.IAPurchase.Query(Query02Il2cppCallback);
		}

		[MonoPInvokeCallback(typeof(IAPurchaseCallback))]
		private static void GetBalanceIl2cppCallback(int errorCode, string message)
		{
			getBalanceIl2cppCallback(errorCode, message);
		}

		public static void GetBalance(IAPurchaseListener listener)
		{
			getBalanceIl2cppCallback = new IAPHandler(listener).getBalanceHandler();
			Viveport.Internal.IAPurchase.GetBalance(GetBalanceIl2cppCallback);
		}

		[MonoPInvokeCallback(typeof(IAPurchaseCallback))]
		private static void RequestSubscriptionIl2cppCallback(int errorCode, string message)
		{
			requestSubscriptionIl2cppCallback(errorCode, message);
		}

		public static void RequestSubscription(IAPurchaseListener listener, string pchPrice, string pchFreeTrialType, int nFreeTrialValue, string pchChargePeriodType, int nChargePeriodValue, int nNumberOfChargePeriod, string pchPlanId)
		{
			requestSubscriptionIl2cppCallback = new IAPHandler(listener).getRequestSubscriptionHandler();
			Viveport.Internal.IAPurchase.RequestSubscription(RequestSubscriptionIl2cppCallback, pchPrice, pchFreeTrialType, nFreeTrialValue, pchChargePeriodType, nChargePeriodValue, nNumberOfChargePeriod, pchPlanId);
		}

		[MonoPInvokeCallback(typeof(IAPurchaseCallback))]
		private static void RequestSubscriptionWithPlanIDIl2cppCallback(int errorCode, string message)
		{
			requestSubscriptionWithPlanIDIl2cppCallback(errorCode, message);
		}

		public static void RequestSubscriptionWithPlanID(IAPurchaseListener listener, string pchPlanId)
		{
			requestSubscriptionWithPlanIDIl2cppCallback = new IAPHandler(listener).getRequestSubscriptionWithPlanIDHandler();
			Viveport.Internal.IAPurchase.RequestSubscriptionWithPlanID(RequestSubscriptionWithPlanIDIl2cppCallback, pchPlanId);
		}

		[MonoPInvokeCallback(typeof(IAPurchaseCallback))]
		private static void SubscribeIl2cppCallback(int errorCode, string message)
		{
			subscribeIl2cppCallback(errorCode, message);
		}

		public static void Subscribe(IAPurchaseListener listener, string pchSubscriptionId)
		{
			subscribeIl2cppCallback = new IAPHandler(listener).getSubscribeHandler();
			Viveport.Internal.IAPurchase.Subscribe(SubscribeIl2cppCallback, pchSubscriptionId);
		}

		[MonoPInvokeCallback(typeof(IAPurchaseCallback))]
		private static void QuerySubscriptionIl2cppCallback(int errorCode, string message)
		{
			querySubscriptionIl2cppCallback(errorCode, message);
		}

		public static void QuerySubscription(IAPurchaseListener listener, string pchSubscriptionId)
		{
			querySubscriptionIl2cppCallback = new IAPHandler(listener).getQuerySubscriptionHandler();
			Viveport.Internal.IAPurchase.QuerySubscription(QuerySubscriptionIl2cppCallback, pchSubscriptionId);
		}

		[MonoPInvokeCallback(typeof(IAPurchaseCallback))]
		private static void QuerySubscriptionListIl2cppCallback(int errorCode, string message)
		{
			querySubscriptionListIl2cppCallback(errorCode, message);
		}

		public static void QuerySubscriptionList(IAPurchaseListener listener)
		{
			querySubscriptionListIl2cppCallback = new IAPHandler(listener).getQuerySubscriptionListHandler();
			Viveport.Internal.IAPurchase.QuerySubscriptionList(QuerySubscriptionListIl2cppCallback);
		}

		[MonoPInvokeCallback(typeof(IAPurchaseCallback))]
		private static void CancelSubscriptionIl2cppCallback(int errorCode, string message)
		{
			cancelSubscriptionIl2cppCallback(errorCode, message);
		}

		public static void CancelSubscription(IAPurchaseListener listener, string pchSubscriptionId)
		{
			cancelSubscriptionIl2cppCallback = new IAPHandler(listener).getCancelSubscriptionHandler();
			Viveport.Internal.IAPurchase.CancelSubscription(CancelSubscriptionIl2cppCallback, pchSubscriptionId);
		}
	}
	public class DLC
	{
	}
	public class Subscription
	{
		private static Viveport.Internal.StatusCallback2 isReadyIl2cppCallback;

		[MonoPInvokeCallback(typeof(Viveport.Internal.StatusCallback2))]
		private static void IsReadyIl2cppCallback(int errorCode, string message)
		{
			isReadyIl2cppCallback(errorCode, message);
		}

		public static void IsReady(StatusCallback2 callback)
		{
			if (callback == null)
			{
				throw new InvalidOperationException("callback == null");
			}
			isReadyIl2cppCallback = callback.Invoke;
			Api.InternalStatusCallback2s.Add(IsReadyIl2cppCallback);
			Viveport.Internal.StatusCallback2 statusCallback = callback.Invoke;
			Viveport.Internal.Subscription.IsReady(IsReadyIl2cppCallback);
		}

		public static SubscriptionStatus GetUserStatus()
		{
			SubscriptionStatus subscriptionStatus = new SubscriptionStatus();
			if (Viveport.Internal.Subscription.IsWindowsSubscriber())
			{
				subscriptionStatus.Platforms.Add(SubscriptionStatus.Platform.Windows);
			}
			if (Viveport.Internal.Subscription.IsAndroidSubscriber())
			{
				subscriptionStatus.Platforms.Add(SubscriptionStatus.Platform.Android);
			}
			switch (Viveport.Internal.Subscription.GetTransactionType())
			{
			case ESubscriptionTransactionType.UNKNOWN:
				subscriptionStatus.Type = SubscriptionStatus.TransactionType.Unknown;
				break;
			case ESubscriptionTransactionType.PAID:
				subscriptionStatus.Type = SubscriptionStatus.TransactionType.Paid;
				break;
			case ESubscriptionTransactionType.REDEEM:
				subscriptionStatus.Type = SubscriptionStatus.TransactionType.Redeem;
				break;
			case ESubscriptionTransactionType.FREEE_TRIAL:
				subscriptionStatus.Type = SubscriptionStatus.TransactionType.FreeTrial;
				break;
			default:
				subscriptionStatus.Type = SubscriptionStatus.TransactionType.Unknown;
				break;
			}
			return subscriptionStatus;
		}
	}
	public class Deeplink
	{
		public abstract class DeeplinkChecker
		{
			public abstract void OnSuccess();

			public abstract void OnFailure(int errorCode, string errorMessage);
		}

		private const int MaxIdLength = 256;

		private static Viveport.Internal.StatusCallback isReadyIl2cppCallback;

		private static Viveport.Internal.StatusCallback2 goToAppIl2cppCallback;

		private static Viveport.Internal.StatusCallback2 goToAppWithBranchNameIl2cppCallback;

		private static Viveport.Internal.StatusCallback2 goToStoreIl2cppCallback;

		private static Viveport.Internal.StatusCallback2 goToAppOrGoToStoreIl2cppCallback;

		[MonoPInvokeCallback(typeof(Viveport.Internal.StatusCallback))]
		private static void IsReadyIl2cppCallback(int errorCode)
		{
			isReadyIl2cppCallback(errorCode);
		}

		public static void IsReady(StatusCallback callback)
		{
			if (callback == null)
			{
				throw new InvalidOperationException("callback == null");
			}
			isReadyIl2cppCallback = callback.Invoke;
			Api.InternalStatusCallbacks.Add(IsReadyIl2cppCallback);
			Viveport.Internal.Deeplink.IsReady(IsReadyIl2cppCallback);
		}

		public static void GoToApp(DeeplinkChecker checker, string appId, string launchData)
		{
			if (checker == null || string.IsNullOrEmpty(appId) || string.IsNullOrEmpty(launchData))
			{
				throw new InvalidOperationException("checker == null || string.IsNullOrEmpty(appId) || string.IsNullOrEmpty(launchData)");
			}
			Viveport.Internal.Deeplink.GoToApp(checker, appId, launchData);
		}

		public static void GoToApp(DeeplinkChecker checker, string appId, string launchData, string branchName)
		{
			if (checker == null || string.IsNullOrEmpty(appId) || string.IsNullOrEmpty(launchData))
			{
				throw new InvalidOperationException("checker == null || string.IsNullOrEmpty(appId) || string.IsNullOrEmpty(launchData)");
			}
			Viveport.Internal.Deeplink.GoToApp(checker, appId, launchData);
		}

		public static void GoToStore(DeeplinkChecker checker, string appId = "")
		{
			if (checker == null)
			{
				throw new InvalidOperationException("checker == null || string.IsNullOrEmpty(appId)");
			}
			Viveport.Internal.Deeplink.GoToStore(checker, appId);
		}

		public static void GoToAppOrGoToStore(DeeplinkChecker checker, string appId, string launchData)
		{
			if (checker == null || string.IsNullOrEmpty(appId) || string.IsNullOrEmpty(launchData))
			{
				throw new InvalidOperationException("checker == null || string.IsNullOrEmpty(appId) || string.IsNullOrEmpty(launchData)");
			}
			Viveport.Internal.Deeplink.GoToAppOrGoToStore(checker, appId, launchData);
		}

		public static string GetAppLaunchData()
		{
			return Viveport.Internal.Deeplink.GetAppLaunchData();
		}
	}
	internal class Token
	{
	}
}
namespace Viveport.Arcade
{
	internal class Session
	{
	}
}
namespace Viveport.Internal
{
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	internal delegate void GetLicenseCallback([MarshalAs(UnmanagedType.LPStr)] string message, [MarshalAs(UnmanagedType.LPStr)] string signature);
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	internal delegate void StatusCallback(int nResult);
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	internal delegate void StatusCallback2(int nResult, [MarshalAs(UnmanagedType.LPStr)] string message);
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	internal delegate void QueryRuntimeModeCallback(int nResult, int nMode);
	internal enum ELeaderboardDataRequest
	{
		k_ELeaderboardDataRequestGlobal,
		k_ELeaderboardDataRequestGlobalAroundUser,
		k_ELeaderboardDataRequestLocal,
		k_ELeaderboardDataRequestLocaleAroundUser
	}
	internal enum ELeaderboardDataTimeRange
	{
		k_ELeaderboardDataScropeAllTime,
		k_ELeaderboardDataScropeDaily,
		k_ELeaderboardDataScropeWeekly,
		k_ELeaderboardDataScropeMonthly
	}
	internal enum ELeaderboardSortMethod
	{
		k_ELeaderboardSortMethodNone,
		k_ELeaderboardSortMethodAscending,
		k_ELeaderboardSortMethodDescending
	}
	internal enum ELeaderboardDisplayType
	{
		k_ELeaderboardDisplayTypeNone,
		k_ELeaderboardDisplayTypeNumeric,
		k_ELeaderboardDisplayTypeTimeSeconds,
		k_ELeaderboardDisplayTypeTimeMilliSeconds
	}
	internal enum ELeaderboardUploadScoreMethod
	{
		k_ELeaderboardUploadScoreMethodNone,
		k_ELeaderboardUploadScoreMethodKeepBest,
		k_ELeaderboardUploadScoreMethodForceUpdate
	}
	internal enum ESubscriptionTransactionType
	{
		UNKNOWN,
		PAID,
		REDEEM,
		FREEE_TRIAL
	}
	internal enum ELocale
	{
		k_ELocaleUS,
		k_ELocaleDE,
		k_ELocaleJP,
		k_ELocaleKR,
		k_ELocaleRU,
		k_ELocaleCN,
		k_ELocaleTW,
		k_ELocaleFR
	}
	internal enum EAchievementDisplayAttribute
	{
		k_EAchievementDisplayAttributeName,
		k_EAchievementDisplayAttributeDesc,
		k_EAchievementDisplayAttributeHidden
	}
	internal struct LeaderboardEntry_t
	{
		internal int m_nGlobalRank;

		internal int m_nScore;

		[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 64)]
		internal string m_pUserName;
	}
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	internal delegate void IAPurchaseCallback(int code, [MarshalAs(UnmanagedType.LPStr)] string message);
	internal struct IAPCurrency_t
	{
		[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 16)]
		internal string m_pName;

		[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 16)]
		internal string m_pSymbol;
	}
	internal class Api
	{
		internal class AndroidLicenseChecker : AndroidJavaProxy
		{
			private Viveport.Api.LicenseChecker checker;

			internal AndroidLicenseChecker(Viveport.Api.LicenseChecker checker)
				: base("com.htc.viveport.Api$LicenseChecker")
			{
				this.checker = checker;
			}

			internal void onSuccess(long issueTime, long expirationTime, int latestVersion, bool updateRequired)
			{
				Viveport.Core.Logger.Log("AndroidLicenseChecker onSuccess: " + latestVersion + ":" + updateRequired);
				if (checker != null)
				{
					checker.OnSuccess(issueTime, expirationTime, latestVersion, updateRequired);
				}
			}

			internal void onFailure(int errorCode, string errorMessage)
			{
				Viveport.Core.Logger.Log("AndroidLicenseChecker onFailure: " + errorCode + ":" + errorMessage);
				if (checker != null)
				{
					checker.OnFailure(errorCode, errorMessage);
				}
			}
		}

		internal static int Init(StatusCallback callback, string pchAppKey)
		{
			return Android.GetJavaAPI().CallStatic<int>("init", new object[3]
			{
				Android.CurrentContext,
				new AndroidPluginCallback(callback),
				pchAppKey
			});
		}

		internal static int Shutdown(StatusCallback callback)
		{
			return Android.GetJavaAPI().CallStatic<int>("shutdown", new object[1]
			{
				new AndroidPluginCallback(callback)
			});
		}

		internal static string Version()
		{
			return Android.GetJavaAPI().CallStatic<string>("version", Array.Empty<object>());
		}

		internal static void GetLicense(Viveport.Api.LicenseChecker checker, string appId, string appKey)
		{
			Android.GetJavaAPI().CallStatic("getLicense", Android.CurrentContext, new AndroidLicenseChecker(checker), appId, appKey);
		}
	}
	internal class User
	{
		internal static int IsReady(StatusCallback callback)
		{
			return Android.GetJavaUser().CallStatic<int>("isReady", new object[2]
			{
				Android.CurrentContext,
				new AndroidPluginCallback(callback)
			});
		}

		internal static string GetUserId()
		{
			return Android.GetJavaUser().CallStatic<string>("getUserID", new object[1] { Android.CurrentContext });
		}

		internal static string GetUserName()
		{
			return Android.GetJavaUser().CallStatic<string>("getUserName", new object[1] { Android.CurrentContext });
		}

		internal static string GetUserAvatarUrl()
		{
			return Android.GetJavaUser().CallStatic<string>("getUserAvatar", new object[1] { Android.CurrentContext });
		}
	}
	internal class UserStats
	{
		internal static int IsReady(StatusCallback callback)
		{
			return Android.GetJavaUserStats().CallStatic<int>("isReady", new object[2]
			{
				Android.CurrentContext,
				new AndroidPluginCallback(callback)
			});
		}

		internal static int DownloadStats(StatusCallback callback)
		{
			return Android.GetJavaUserStats().CallStatic<int>("downloadStats", new object[2]
			{
				Android.CurrentContext,
				new AndroidPluginCallback(callback)
			});
		}

		internal static int UploadStats(StatusCallback callback)
		{
			return Android.GetJavaUserStats().CallStatic<int>("uploadStats", new object[2]
			{
				Android.CurrentContext,
				new AndroidPluginCallback(callback)
			});
		}

		internal static int SetStat(string pchName, int nData)
		{
			return Android.GetJavaUserStats().CallStatic<int>("setStats", new object[2] { pchName, nData });
		}

		internal static int SetStat(string pchName, float fData)
		{
			return Android.GetJavaUserStats().CallStatic<int>("setStats", new object[2] { pchName, fData });
		}

		internal static int GetStat(string pchName, int nData)
		{
			return Android.GetJavaUserStats().CallStatic<int>("getStats", new object[2] { pchName, nData });
		}

		internal static float GetStat(string pchName, float fData)
		{
			return Android.GetJavaUserStats().CallStatic<float>("getStats", new object[2] { pchName, fData });
		}

		internal static bool GetAchievement(string pchName)
		{
			return Android.GetJavaUserStats().CallStatic<bool>("getAchievement", new object[1] { pchName });
		}

		internal static int GetAchievementUnlockTime(string pchName)
		{
			return Android.GetJavaUserStats().CallStatic<int>("getAchievementUnlockTime", new object[1] { pchName });
		}

		internal static int SetAchievement(string pchName)
		{
			return Android.GetJavaUserStats().CallStatic<int>("setAchievement", new object[1] { pchName });
		}

		internal static int ClearAchievement(string pchName)
		{
			return Android.GetJavaUserStats().CallStatic<int>("clearAchievement", new object[1] { pchName });
		}

		internal static string GetAchievementDisplayAttribute(string pchName, EAchievementDisplayAttribute attr)
		{
			return Android.GetJavaUserStats().CallStatic<string>("getAchievementDisplayAttribute", new object[2]
			{
				pchName,
				(int)attr
			});
		}

		internal static string GetAchievementDisplayAttribute(string pchName, EAchievementDisplayAttribute attr, ELocale locale)
		{
			return Android.GetJavaUserStats().CallStatic<string>("getAchievementDisplayAttribute", new object[3]
			{
				pchName,
				(int)attr,
				(int)locale
			});
		}

		internal static string GetAchievementIcon(string pchName)
		{
			return Android.GetJavaUserStats().CallStatic<string>("getAchievementIcon", new object[1] { pchName });
		}

		internal static int DownloadLeaderboardScores(StatusCallback callback, string pchLeaderboardName, ELeaderboardDataRequest nDataRequest, ELeaderboardDataTimeRange nTimeRange, int nRangeStart, int nRangeEnd)
		{
			return Android.GetJavaUserStats().CallStatic<int>("getLeaderboard", new object[7]
			{
				Android.CurrentContext,
				new AndroidPluginCallback(callback),
				pchLeaderboardName,
				nRangeStart,
				nRangeEnd,
				(int)nTimeRange,
				(int)nDataRequest
			});
		}

		internal static int UploadLeaderboardScore(StatusCallback callback, string pchLeaderboardName, int nScores)
		{
			return Android.GetJavaUserStats().CallStatic<int>("setLeaderboard", new object[4]
			{
				Android.CurrentContext,
				new AndroidPluginCallback(callback),
				pchLeaderboardName,
				nScores
			});
		}

		internal static Leaderboard GetLeaderboardScore(int nIndex)
		{
			Leaderboard leaderboard = new Leaderboard();
			leaderboard.UserName = Android.GetJavaUserStats().CallStatic<string>("getLeaderboardNameData", new object[1] { nIndex });
			leaderboard.Rank = Android.GetJavaUserStats().CallStatic<int>("getLeaderboardRankData", new object[1] { nIndex });
			leaderboard.Score = Android.GetJavaUserStats().CallStatic<int>("getLeaderboardScoreData", new object[1] { nIndex });
			return leaderboard;
		}

		internal static int GetLeaderboardScoreCount()
		{
			return Android.GetJavaUserStats().CallStatic<int>("getLeaderboardScoreCount", Array.Empty<object>());
		}

		internal static ELeaderboardSortMethod GetLeaderboardSortMethod()
		{
			return (ELeaderboardSortMethod)Android.GetJavaUserStats().CallStatic<int>("getLeaderboardSortType", Array.Empty<object>());
		}

		internal static ELeaderboardDisplayType GetLeaderboardDisplayType()
		{
			return (ELeaderboardDisplayType)Android.GetJavaUserStats().CallStatic<int>("getLeaderboardDisplayType", Array.Empty<object>());
		}
	}
	internal class Deeplink
	{
		internal class AndroidDeeplinkChecker : AndroidJavaProxy
		{
			private Viveport.Deeplink.DeeplinkChecker checker;

			internal AndroidDeeplinkChecker(Viveport.Deeplink.DeeplinkChecker checker)
				: base("com.htc.viveport.Api$StatusCallback2")
			{
				this.checker = checker;
			}

			internal void onSuccess()
			{
				Viveport.Core.Logger.Log("AndroidDeeplinkChecker onSuccess");
				if (checker != null)
				{
					checker.OnSuccess();
				}
			}

			internal void onFailure(int errorCode, string errorMessage)
			{
				Viveport.Core.Logger.Log("AndroidDeeplinkChecker onFailure: " + errorCode + ":" + errorMessage);
				if (checker != null)
				{
					checker.OnFailure(errorCode, errorMessage);
				}
			}
		}

		internal static void IsReady(StatusCallback callback)
		{
			Android.GetDeeplink().CallStatic("isReady", new AndroidPluginCallback(callback));
		}

		internal static void GoToApp(Viveport.Deeplink.DeeplinkChecker checker, string appId, string launchData)
		{
			Android.GetDeeplink().CallStatic("GoToApp", Android.CurrentContext, new AndroidDeeplinkChecker(checker), appId, launchData);
		}

		internal static void GoToStore(Viveport.Deeplink.DeeplinkChecker checker, string appId)
		{
			Android.GetDeeplink().CallStatic("GoToStore", Android.CurrentContext, new AndroidDeeplinkChecker(checker), appId);
		}

		internal static void GoToAppOrGoToStore(Viveport.Deeplink.DeeplinkChecker checker, string appId, string launchData)
		{
			Android.GetDeeplink().CallStatic("GoToAppOrGoToStore", Android.CurrentContext, new AndroidDeeplinkChecker(checker), appId, launchData);
		}

		internal static string GetAppLaunchData()
		{
			return Android.GetDeeplink().CallStatic<string>("GetAppLaunchData", new object[1] { Android.CurrentContext });
		}
	}
	internal class IAPurchase
	{
		internal static void IsReady(IAPurchaseCallback callback, string pchAppKey)
		{
			Android.GetJavaIAPurchase().CallStatic("isReady", Android.CurrentContext, new AndroidPluginCallback(callback), pchAppKey);
		}

		internal static void Request(IAPurchaseCallback callback, string pchPrice)
		{
			Android.GetJavaIAPurchase().CallStatic("request", Android.CurrentContext, new AndroidPluginCallback(callback), pchPrice);
		}

		internal static void Request(IAPurchaseCallback callback, string pchPrice, string pchUserData)
		{
			Android.GetJavaIAPurchase().CallStatic("request", Android.CurrentContext, new AndroidPluginCallback(callback), pchPrice, pchUserData);
		}

		internal static void Purchase(IAPurchaseCallback callback, string pchPurchaseId)
		{
			Android.GetJavaIAPurchase().CallStatic("makePurchase", Android.CurrentContext, new AndroidPluginCallback(callback), pchPurchaseId);
		}

		internal static void Query(IAPurchaseCallback callback, string pchPurchaseId)
		{
			Android.GetJavaIAPurchase().CallStatic("query", Android.CurrentContext, new AndroidPluginCallback(callback), pchPurchaseId);
		}

		internal static void Query(IAPurchaseCallback callback)
		{
			Android.GetJavaIAPurchase().CallStatic("query", Android.CurrentContext, new AndroidPluginCallback(callback));
		}

		internal static void GetBalance(IAPurchaseCallback callback)
		{
			Android.GetJavaIAPurchase().CallStatic("getBalance", Android.CurrentContext, new AndroidPluginCallback(callback));
		}

		internal static void RequestSubscription(IAPurchaseCallback callback, string pchPrice, string pchFreeTrialType, int nFreeTrialValue, string pchChargePeriodType, int nChargePeriodValue, int nNumberOfChargePeriod, string pchPlanId)
		{
			Android.GetJavaIAPurchase().CallStatic("requestSubscription", Android.CurrentContext, new AndroidPluginCallback(callback), pchPrice, pchFreeTrialType, nFreeTrialValue, pchChargePeriodType, nChargePeriodValue, nNumberOfChargePeriod, pchPlanId);
		}

		internal static void RequestSubscriptionWithPlanID(IAPurchaseCallback callback, string pchPlanId)
		{
			Android.GetJavaIAPurchase().CallStatic("requestSubscriptionWithPlanId", Android.CurrentContext, new AndroidPluginCallback(callback), pchPlanId);
		}

		internal static void Subscribe(IAPurchaseCallback callback, string pchSubscriptionId)
		{
			Android.GetJavaIAPurchase().CallStatic("subscribe", Android.CurrentContext, new AndroidPluginCallback(callback), pchSubscriptionId);
		}

		internal static void QuerySubscription(IAPurchaseCallback callback, string pchSubscriptionId)
		{
			Android.GetJavaIAPurchase().CallStatic("querySubscription", Android.CurrentContext, new AndroidPluginCallback(callback), pchSubscriptionId);
		}

		internal static void QuerySubscriptionList(IAPurchaseCallback callback)
		{
			Android.GetJavaIAPurchase().CallStatic("querySubscriptionList", Android.CurrentContext, new AndroidPluginCallback(callback));
		}

		internal static void CancelSubscription(IAPurchaseCallback callback, string pchSubscriptionId)
		{
			Android.GetJavaIAPurchase().CallStatic("cancelSubscription", Android.CurrentContext, new AndroidPluginCallback(callback), pchSubscriptionId);
		}
	}
	internal class Subscription
	{
		internal static int IsReady(StatusCallback2 callback)
		{
			Android.GetJavaSubscription().CallStatic("isReady", Android.CurrentContext, new AndroidPluginCallback(callback));
			return 0;
		}

		internal static bool IsWindowsSubscriber()
		{
			return Android.GetJavaSubscription().CallStatic<bool>("isWindowsSubscriber", Array.Empty<object>());
		}

		internal static bool IsAndroidSubscriber()
		{
			return Android.GetJavaSubscription().CallStatic<bool>("isAndroidSubscriber", Array.Empty<object>());
		}

		internal static ESubscriptionTransactionType GetTransactionType()
		{
			int num = Android.GetJavaSubscription().CallStatic<AndroidJavaObject>("getTransactionType", Array.Empty<object>()).Call<int>("getValue", Array.Empty<object>());
			ESubscriptionTransactionType result = ESubscriptionTransactionType.UNKNOWN;
			switch (num)
			{
			case 0:
				result = ESubscriptionTransactionType.UNKNOWN;
				break;
			case 1:
				result = ESubscriptionTransactionType.PAID;
				break;
			case 2:
				result = ESubscriptionTransactionType.REDEEM;
				break;
			case 3:
				result = ESubscriptionTransactionType.FREEE_TRIAL;
				break;
			}
			return result;
		}
	}
	internal class Android
	{
		private static AndroidJavaObject _api;

		private static AndroidJavaObject _iAPurchase;

		private static AndroidJavaClass _unityPlayer;

		private static AndroidJavaObject _user;

		private static AndroidJavaObject _userStats;

		private static AndroidJavaObject _subscription;

		private static AndroidJavaObject _deeplink;

		internal static AndroidJavaClass UnityPlayer
		{
			get
			{
				if (_unityPlayer == null)
				{
					_unityPlayer = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
				}
				return _unityPlayer;
			}
		}

		internal static AndroidJavaObject CurrentActivity => UnityPlayer.GetStatic<AndroidJavaObject>("currentActivity");

		internal static AndroidJavaObject CurrentContext => CurrentActivity;

		internal static AndroidJavaObject GetJavaAPI()
		{
			if (_api == null)
			{
				_api = new AndroidJavaObject("com.htc.viveport.Api");
			}
			return _api;
		}

		internal static AndroidJavaObject GetJavaUser()
		{
			if (_user == null)
			{
				_user = new AndroidJavaObject("com.htc.viveport.User");
			}
			return _user;
		}

		internal static AndroidJavaObject GetJavaUserStats()
		{
			if (_userStats == null)
			{
				_userStats = new AndroidJavaObject("com.htc.viveport.UserStats");
			}
			return _userStats;
		}

		internal static AndroidJavaObject GetJavaIAPurchase()
		{
			if (_iAPurchase == null)
			{
				_iAPurchase = new AndroidJavaObject("com.htc.viveport.IAPurchase");
			}
			return _iAPurchase;
		}

		internal static AndroidJavaObject GetJavaSubscription()
		{
			if (_subscription == null)
			{
				_subscription = new AndroidJavaObject("com.htc.viveport.Subscription");
			}
			return _subscription;
		}

		internal static AndroidJavaObject GetDeeplink()
		{
			if (_deeplink == null)
			{
				_deeplink = new AndroidJavaObject("com.htc.viveport.Deeplink");
			}
			return _deeplink;
		}
	}
	internal class AndroidPluginCallback : AndroidJavaProxy
	{
		private IAPurchaseCallback callback;

		private StatusCallback statusCallback;

		private StatusCallback2 statusCallback2;

		internal AndroidPluginCallback(IAPurchaseCallback callback)
			: base("com.htc.viveport.Api$StatusCallback")
		{
			this.callback = callback;
		}

		internal AndroidPluginCallback(StatusCallback callback)
			: base("com.htc.viveport.Api$StatusCallback")
		{
			statusCallback = callback;
		}

		internal AndroidPluginCallback(StatusCallback2 callback)
			: base("com.htc.viveport.Api$StatusCallback")
		{
			statusCallback2 = callback;
		}

		internal void onResult(int statusCode, string result)
		{
			Viveport.Core.Logger.Log("ENTER callback onSuccess: " + statusCode + ":" + result);
			if (callback != null)
			{
				callback(statusCode, result);
			}
			if (statusCallback != null)
			{
				statusCallback(statusCode);
			}
			if (statusCallback2 != null)
			{
				statusCallback2(statusCode, result);
			}
		}
	}
}
