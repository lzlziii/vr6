using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using AOT;
using Battlehub.RTEditor;
using Battlehub.RTHandles;
using Battlehub.UIControls;
using Battlehub.Utils;
using BoundarySystem_Ext;
using I2.Loc;
using LitJson;
using NaughtyAttributes;
using Oculus.Spatializer.Propagation;
using Pvr_UnitySDKAPI;
using Pvr_UnitySDKAPI.Achievement;
using TMPro;
using UnityEngine;
using UnityEngine.Android;
using UnityEngine.Audio;
using UnityEngine.EventSystems;
using UnityEngine.Events;
using UnityEngine.Networking;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;
using UnityEngine.SceneManagement;
using UnityEngine.UI;
using UnityEngine.Video;
using UnityEngine.XR;

[assembly: CompilationRelaxations(8)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: AssemblyVersion("0.0.0.0")]
public class SlotPopulator : MonoBehaviour
{
	public float RaycastLength = 1f;

	private List<Vector3> Directions = new List<Vector3>
	{
		-Vector3.up,
		Vector3.up,
		-Vector3.right,
		Vector3.right,
		-Vector3.forward,
		Vector3.forward
	};

	public GameObject Wall;

	public List<Transform> Slots = new List<Transform>();

	public List<GameObject> HoldPrefabs = new List<GameObject>();

	public List<Material> HoldColorVariations = new List<Material>();

	public bool DEBUG_MODE;

	[HideInInspector]
	public List<GameObject> Holds = new List<GameObject>();

	public void PopulateHolds()
	{
		if (DEBUG_MODE)
		{
			UnityEngine.Debug.Log("Populate started");
		}
		if (Wall.GetComponent<Collider>() == null)
		{
			Wall.AddComponent<MeshCollider>();
		}
		foreach (GameObject hold in Holds)
		{
			UnityEngine.Object.DestroyImmediate(hold);
		}
		Holds.Clear();
		foreach (Transform slot in Slots)
		{
			if (DEBUG_MODE)
			{
				UnityEngine.Debug.Log("Find normal of " + slot.name);
			}
			float num = float.PositiveInfinity;
			Vector3 up = Vector3.zero;
			foreach (Vector3 direction in Directions)
			{
				Vector3 vector = slot.position - direction * RaycastLength / 2f;
				if (Physics.Raycast(vector, direction, out var hitInfo, RaycastLength))
				{
					float num2 = Vector3.Distance(slot.position, hitInfo.point);
					if (num2 < num)
					{
						up = hitInfo.normal;
						num = num2;
						if (DEBUG_MODE)
						{
							UnityEngine.Debug.DrawLine(vector, vector + direction * RaycastLength, Color.blue, 10f);
						}
					}
				}
				else if (DEBUG_MODE)
				{
					UnityEngine.Debug.LogWarning("Can't find a surface, please increse the raycast length.");
					UnityEngine.Debug.DrawLine(vector, vector + direction * RaycastLength, Color.red, 10f);
				}
			}
			if (num != float.PositiveInfinity)
			{
				GameObject gameObject = HoldPrefabs[UnityEngine.Random.Range(0, HoldPrefabs.Count)];
				if (DEBUG_MODE)
				{
					UnityEngine.Debug.Log("Create hand (" + gameObject.name + ") on slot (" + slot.name + ")");
				}
				GameObject gameObject2 = UnityEngine.Object.Instantiate(gameObject, slot.position, slot.rotation);
				gameObject2.transform.SetParent(slot);
				gameObject2.transform.up = up;
				Holds.Add(gameObject2);
				if (HoldColorVariations.Count > 0)
				{
					int num3 = UnityEngine.Random.Range(-1, HoldColorVariations.Count);
					if (num3 > -1)
					{
						gameObject2.GetComponent<MeshRenderer>().material = HoldColorVariations[num3];
					}
				}
			}
			else if (DEBUG_MODE)
			{
				UnityEngine.Debug.Log("Surface didn't found for slot (" + slot.name + ")");
			}
		}
	}
}
public class ModularTerrainCameraControl : MonoBehaviour
{
	[Range(-100f, 100f)]
	public float cameraMoveSpeed_x;

	[Range(-100f, 100f)]
	public float cameraMoveSpeed_y;

	[Range(-100f, 100f)]
	public float cameraMoveSpeed_z;

	private void Update()
	{
		base.gameObject.transform.Translate(cameraMoveSpeed_x * Time.deltaTime, cameraMoveSpeed_y * Time.deltaTime, cameraMoveSpeed_z * Time.deltaTime);
	}
}
public class ModularTerrainCloudsControl : MonoBehaviour
{
	[Range(-10f, 10f)]
	public float cloudsMoveSpeed_x;

	[Range(-10f, 10f)]
	public float cloudsMoveSpeed_z;

	private void Update()
	{
		base.gameObject.transform.Translate(cloudsMoveSpeed_x * Time.deltaTime, 0f, cloudsMoveSpeed_z * Time.deltaTime);
	}
}
public class ModularTerrainSunControl : MonoBehaviour
{
	[Range(-10f, 10f)]
	public float sunRotationSpeed_x;

	[Range(-10f, 10f)]
	public float sunRotationSpeed_y;

	private void Update()
	{
		base.gameObject.transform.Rotate(sunRotationSpeed_x * Time.deltaTime, sunRotationSpeed_y * Time.deltaTime, 0f);
	}
}
public class crane_animate : MonoBehaviour
{
	public Animator animator;

	public AnimatorControllerParameter animParam;

	public float rotateYaw;

	public float weight;

	public float dolly;

	public float hook;

	public bool demoMode;

	private float randomYawIncrease;

	private float randomDollyIncrease;

	private float randomHookIncrease;

	private void Start()
	{
		randomYawIncrease = UnityEngine.Random.Range(1, 10);
		randomDollyIncrease = UnityEngine.Random.Range(0.1f, 1f);
		randomHookIncrease = UnityEngine.Random.Range(0.1f, 1f);
	}

	private void Update()
	{
		if (demoMode)
		{
			rotateYaw += Time.deltaTime * randomYawIncrease;
			dolly = (Mathf.Sin(Time.time * randomDollyIncrease) * 100f + 100f) / 2f;
			hook = (Mathf.Sin(Time.time * randomHookIncrease) * 100f + 100f) / 2f;
		}
		animator.SetFloat("Rotate_YAW", Mathf.Abs(rotateYaw) % 360f);
		animator.SetFloat("weight", weight);
		animator.SetFloat("dolly", dolly);
		animator.SetFloat("hook", hook);
	}
}
public class crane_animate1 : MonoBehaviour
{
	public Animator animator;

	public AnimatorControllerParameter animParam;

	public float rotateYaw;

	public float dolly;

	public float hook;

	public bool demoMode;

	private float randomYawIncrease;

	private float randomDollyIncrease;

	private float randomHookIncrease;

	private void Start()
	{
		randomYawIncrease = UnityEngine.Random.Range(1, 10);
		randomDollyIncrease = UnityEngine.Random.Range(0.1f, 1f);
		randomHookIncrease = UnityEngine.Random.Range(0.1f, 1f);
	}

	private void Update()
	{
		if (demoMode)
		{
			rotateYaw += Time.deltaTime * randomYawIncrease;
			dolly = (Mathf.Sin(Time.time * randomDollyIncrease) * 100f + 100f) / 2f;
			hook = (Mathf.Sin(Time.time * randomHookIncrease) * 100f + 100f) / 2f;
		}
		animator.SetFloat("Rotate_YAW", Mathf.Abs(rotateYaw) % 360f);
		animator.SetFloat("dolly", dolly);
		animator.SetFloat("hook", hook);
	}
}
public class crane_animate2 : MonoBehaviour
{
	public Animator animator;

	public AnimatorControllerParameter animParam;

	public float rotateYaw;

	public float pitch;

	public float hook;

	public bool demoMode;

	private float randomYawIncrease;

	private float randomPitchIncrease;

	private float randomHookIncrease;

	private void Start()
	{
		randomYawIncrease = UnityEngine.Random.Range(1, 10);
		randomPitchIncrease = UnityEngine.Random.Range(0.1f, 1f);
		randomHookIncrease = UnityEngine.Random.Range(0.1f, 1f);
	}

	private void Update()
	{
		if (demoMode)
		{
			rotateYaw += Time.deltaTime * randomYawIncrease;
			pitch = (Mathf.Sin(Time.time * randomPitchIncrease) * 100f + 100f) / 2f;
			hook = (Mathf.Sin(Time.time * randomHookIncrease) * 100f + 100f) / 2f;
		}
		animator.SetFloat("Rotate_YAW", Mathf.Abs(rotateYaw) % 360f);
		animator.SetFloat("pitch", pitch);
		animator.SetFloat("hook", hook);
	}
}
public class flashlight_CTRL : MonoBehaviour
{
	private Animator anim;

	private CharacterController controller;

	private bool battle_state;

	public float speed = 6f;

	public float runSpeed = 1f;

	public float turnSpeed = 60f;

	public float gravity = 20f;

	public int goblin_class;

	private Vector3 moveDirection = Vector3.zero;

	private void Start()
	{
		anim = GetComponent<Animator>();
		controller = GetComponent<CharacterController>();
	}

	private void Update()
	{
		if (Input.GetKey("up"))
		{
			if (!battle_state)
			{
				anim.SetInteger("moving", 1);
				runSpeed = 2f;
			}
		}
		else
		{
			anim.SetInteger("moving", 0);
		}
		if (controller.isGrounded)
		{
			moveDirection = base.transform.forward * Input.GetAxis("Vertical") * speed * runSpeed;
		}
		float axis = Input.GetAxis("Horizontal");
		base.transform.Rotate(0f, axis * turnSpeed * Time.deltaTime, 0f);
		controller.Move(moveDirection * Time.deltaTime);
		moveDirection.y -= gravity * Time.deltaTime;
	}
}
public class WNDDisabler : MonoBehaviour
{
	public bool DisableAtPosition = true;

	public Vector3 disablingPosition;

	public float timeToDisableMin;

	public float timeToDisableMax;

	private bool mooving;

	private float moovingA;

	private Vector3 startPos;

	private Vector3 startScale;

	private void Start()
	{
		StartCoroutine(Disabler());
	}

	private void FixedUpdate()
	{
		if (mooving)
		{
			base.transform.localPosition = Vector3.Lerp(startPos, startPos + disablingPosition, moovingA);
			base.transform.localScale = Vector3.Lerp(startScale, Vector3.zero, moovingA);
			if (moovingA >= 1f)
			{
				base.gameObject.SetActive(value: false);
			}
			else
			{
				moovingA += Time.fixedDeltaTime;
			}
		}
	}

	private IEnumerator Disabler()
	{
		yield return new WaitForSeconds(UnityEngine.Random.Range(timeToDisableMin, timeToDisableMax));
		if (DisableAtPosition)
		{
			mooving = true;
			startPos = base.transform.localPosition;
			startScale = base.transform.localScale;
		}
		else
		{
			base.gameObject.SetActive(value: false);
		}
	}
}
public class WNDDispenser : MonoBehaviour
{
	public GameObject projectilePrefab;

	public GameObject particlePrefab;

	public float shootingDelay;

	public float power;

	public float randomPowerMinMultiplier;

	public float randomPowerMaxMultiplier;

	private Transform arrowsParent;

	private GameObject currentArrow;

	private bool arrowReady = true;

	private float arrowSize;

	private float timeToShoot;

	private float delayToSpawn;

	private void Start()
	{
		Transform[] componentsInChildren = GetComponentsInChildren<Transform>();
		foreach (Transform transform in componentsInChildren)
		{
			if (transform.gameObject.name.Contains("[Projectile Parent]"))
			{
				arrowsParent = transform;
				break;
			}
		}
		CreateArrow();
	}

	public void CreateArrow()
	{
		arrowReady = false;
		arrowSize = 0f;
		currentArrow = UnityEngine.Object.Instantiate(projectilePrefab, arrowsParent);
		if (currentArrow.GetComponent<WNDPrefabVariator>() != null)
		{
			currentArrow.GetComponent<WNDPrefabVariator>().RandomPrefab();
		}
		currentArrow.GetComponent<Rigidbody>().isKinematic = true;
		currentArrow.transform.localScale = Vector3.zero;
		timeToShoot = shootingDelay;
	}

	public void Shoot()
	{
		UnityEngine.Object.Instantiate(particlePrefab, arrowsParent.transform.position, default(Quaternion)).transform.localEulerAngles = Vector3.zero;
		currentArrow.transform.parent = null;
		currentArrow.GetComponent<Rigidbody>().isKinematic = false;
		currentArrow.GetComponent<Rigidbody>().AddForce(base.transform.up * (power * UnityEngine.Random.Range(randomPowerMinMultiplier, randomPowerMaxMultiplier)), ForceMode.Impulse);
		delayToSpawn = 1f;
	}

	private void FixedUpdate()
	{
		if (!arrowReady)
		{
			arrowSize += Time.fixedDeltaTime * 4f;
			currentArrow.transform.localScale = Vector3.Lerp(Vector3.zero, Vector3.one, arrowSize);
			if (arrowSize >= 1f)
			{
				arrowReady = true;
			}
		}
		else if (delayToSpawn <= 0f)
		{
			if (timeToShoot > 0f)
			{
				timeToShoot -= Time.fixedDeltaTime;
			}
			else
			{
				Shoot();
			}
		}
		else
		{
			delayToSpawn -= Time.fixedDeltaTime;
			if (delayToSpawn <= 0f)
			{
				CreateArrow();
			}
		}
	}
}
public class WNDMoover : MonoBehaviour
{
	public float distance;

	[Range(0.01f, 0.5f)]
	public float speed;

	public bool reversed;

	public bool randomStartPos;

	private List<Vector3> posToMoove;

	public List<Transform> objsToMoove;

	private void Start()
	{
		posToMoove = new List<Vector3>();
		for (int i = 0; i < objsToMoove.Count; i++)
		{
			if (objsToMoove[i] != null)
			{
				Vector3 localPosition = objsToMoove[i].localPosition;
				if (!reversed)
				{
					localPosition.x -= distance;
				}
				else
				{
					localPosition.x += distance;
				}
				posToMoove.Add(localPosition);
			}
		}
		if (randomStartPos)
		{
			RandomStartPos();
		}
	}

	private void RandomStartPos()
	{
		for (int i = 0; i < objsToMoove.Count; i++)
		{
			if (objsToMoove[i] != null)
			{
				objsToMoove[i].localPosition = Vector3.Lerp(objsToMoove[i].localPosition, posToMoove[i], UnityEngine.Random.Range(0f, 1f));
			}
		}
	}

	private void FixedUpdate()
	{
		for (int i = 0; i < objsToMoove.Count; i++)
		{
			if (objsToMoove[i] != null)
			{
				objsToMoove[i].localPosition = Vector3.MoveTowards(objsToMoove[i].localPosition, posToMoove[i], speed);
				if (Vector3.Distance(objsToMoove[i].localPosition, posToMoove[i]) < 0.1f)
				{
					Vector3 value = posToMoove[i];
					value.x *= -1f;
					posToMoove[i] = value;
				}
			}
		}
	}
}
public class WNDParticlesDestroyer : MonoBehaviour
{
	private ParticleSystem ParticleSystem;

	private void Awake()
	{
		ParticleSystem = GetComponent<ParticleSystem>();
	}

	private void FixedUpdate()
	{
		if (!ParticleSystem.IsAlive())
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}
}
public class WNDParticlesSpawner : MonoBehaviour
{
	public GameObject particle0;

	public GameObject particle1;

	public void Particle0()
	{
		UnityEngine.Object.Instantiate(particle0, base.transform.position, default(Quaternion));
	}

	public void Particle1()
	{
		UnityEngine.Object.Instantiate(particle1, base.transform.position, default(Quaternion));
	}
}
public class WNDPrefabVariator : MonoBehaviour
{
	public int selectedType;

	public int selectedColor;

	public int selectedStyle;

	public int selectedPillars;

	public List<Transform> types;

	public bool partsInitialized;

	public Texture headerLogo;

	public bool typesSelector;

	public bool isDynamicFence;

	public float fenceLength = 10f;

	public float fencePillarsFrequency = 2f;

	public ParticleSystem myPs;

	public bool hasStyle
	{
		get
		{
			if (isDynamicFence)
			{
				return true;
			}
			if (types[selectedType].GetChild(selectedColor).childCount > 1)
			{
				return true;
			}
			return false;
		}
	}

	public void InitializeParts()
	{
		if (partsInitialized)
		{
			return;
		}
		Transform[] componentsInChildren = GetComponentsInChildren<Transform>();
		types = new List<Transform>();
		Transform[] array = componentsInChildren;
		foreach (Transform transform in array)
		{
			if (transform.name.Contains("[Type]"))
			{
				types.Add(transform);
			}
		}
		if (types.Count == 0)
		{
			types.Add(base.transform);
		}
		else
		{
			typesSelector = true;
		}
		partsInitialized = true;
	}

	public void ChooseType(bool next)
	{
		InitializeParts();
		if (next)
		{
			selectedType++;
			if (selectedType >= types.Count)
			{
				selectedType = 0;
			}
		}
		else
		{
			selectedType--;
			if (selectedType < 0)
			{
				selectedType = types.Count - 1;
			}
		}
		Refresh();
	}

	public void RandomType()
	{
		InitializeParts();
		selectedType = UnityEngine.Random.Range(0, types.Count);
		Refresh();
	}

	public void ChooseColor(bool next)
	{
		InitializeParts();
		if (next)
		{
			selectedColor++;
			if (selectedColor >= types[selectedType].childCount)
			{
				selectedColor = 0;
			}
			else if (types[selectedType].GetChild(selectedColor).gameObject.name.Contains("[Ignore]"))
			{
				selectedColor = 0;
			}
		}
		else
		{
			selectedColor--;
			if (selectedColor < 0)
			{
				if (types[selectedType].GetChild(types[selectedType].childCount - 1).gameObject.name.Contains("[Ignore]"))
				{
					selectedColor = types[selectedType].childCount - 2;
				}
				else
				{
					selectedColor = types[selectedType].childCount - 1;
				}
			}
		}
		Refresh();
	}

	public void RandomColor()
	{
		InitializeParts();
		selectedColor = UnityEngine.Random.Range(0, types[selectedType].childCount);
		Refresh();
	}

	public void ChooseStyle(bool next)
	{
		InitializeParts();
		if (next)
		{
			selectedStyle++;
		}
		else
		{
			selectedStyle--;
			if (!isDynamicFence)
			{
				if (selectedStyle < 0)
				{
					selectedStyle = types[selectedType].GetChild(selectedColor).childCount - 1;
				}
				else if (selectedStyle < 0)
				{
					selectedStyle = types[selectedType].GetChild(selectedColor).GetChild(0).childCount - 1;
				}
			}
		}
		Refresh();
	}

	public void ChoosePillars(bool next)
	{
		InitializeParts();
		if (next)
		{
			selectedPillars++;
			if (selectedPillars >= types[selectedType].GetChild(selectedColor).GetChild(1).childCount)
			{
				selectedPillars = 0;
			}
		}
		else
		{
			selectedPillars--;
			if (selectedPillars < 0)
			{
				selectedPillars = types[selectedType].GetChild(selectedColor).GetChild(1).childCount - 1;
			}
		}
		Refresh();
	}

	public void RandomStyle()
	{
		InitializeParts();
		if (!isDynamicFence)
		{
			selectedStyle = UnityEngine.Random.Range(0, types[selectedType].GetChild(selectedColor).childCount);
		}
		else
		{
			selectedStyle = UnityEngine.Random.Range(0, types[selectedType].GetChild(selectedColor).GetChild(0).childCount);
		}
		Refresh();
	}

	public void RandomPillars()
	{
		InitializeParts();
		if (!isDynamicFence)
		{
			selectedPillars = UnityEngine.Random.Range(0, types[selectedType].GetChild(selectedColor).childCount);
		}
		else
		{
			selectedPillars = UnityEngine.Random.Range(0, types[selectedType].GetChild(selectedColor).GetChild(1).childCount);
		}
		Refresh();
	}

	public void RandomPrefab()
	{
		InitializeParts();
		RandomType();
		RandomColor();
		RandomStyle();
		Refresh();
	}

	private void Refresh()
	{
		for (int i = 0; i < types.Count; i++)
		{
			if (i != selectedType)
			{
				types[i].gameObject.SetActive(value: false);
				continue;
			}
			types[i].gameObject.SetActive(value: true);
			if (selectedColor >= types[i].childCount)
			{
				selectedColor = 0;
			}
			for (int j = 0; j < types[i].childCount; j++)
			{
				if (j != selectedColor)
				{
					if (!types[i].GetChild(j).gameObject.name.Contains("[Ignore]"))
					{
						types[i].GetChild(j).gameObject.SetActive(value: false);
					}
					continue;
				}
				types[i].GetChild(j).gameObject.SetActive(value: true);
				if (!isDynamicFence)
				{
					if (selectedStyle >= types[i].GetChild(j).childCount)
					{
						selectedStyle = 0;
					}
					for (int k = 0; k < types[i].GetChild(j).childCount; k++)
					{
						if (k != selectedStyle)
						{
							types[i].GetChild(j).GetChild(k).gameObject.SetActive(value: false);
							continue;
						}
						types[i].GetChild(j).GetChild(k).gameObject.SetActive(value: true);
						if (myPs != null)
						{
							myPs.transform.parent = types[i].GetChild(j).GetChild(k);
							ParticleSystem.ShapeModule shape = myPs.shape;
							shape.meshRenderer = types[i].GetChild(j).GetChild(k).GetComponent<MeshRenderer>();
						}
					}
					continue;
				}
				if (selectedStyle >= types[i].GetChild(j).GetChild(0).childCount)
				{
					selectedStyle = 0;
				}
				for (int l = 0; l < types[i].GetChild(j).GetChild(0).childCount; l++)
				{
					if (l != selectedStyle)
					{
						types[i].GetChild(j).GetChild(0).GetChild(l)
							.gameObject.SetActive(value: false);
					}
					else
					{
						types[i].GetChild(j).GetChild(0).GetChild(l)
							.gameObject.SetActive(value: true);
					}
				}
				if (selectedPillars >= types[i].GetChild(j).GetChild(1).childCount)
				{
					selectedPillars = 0;
				}
				for (int m = 0; m < types[i].GetChild(j).GetChild(1).childCount; m++)
				{
					if (m != selectedPillars)
					{
						types[i].GetChild(j).GetChild(1).GetChild(m)
							.gameObject.SetActive(value: false);
					}
					else
					{
						types[i].GetChild(j).GetChild(1).GetChild(m)
							.gameObject.SetActive(value: true);
					}
				}
				RefreshPillars();
			}
		}
	}

	public void RefreshPillars()
	{
		types[selectedType].GetChild(selectedColor).GetChild(0).GetChild(selectedStyle)
			.transform.localScale = new Vector3(1f, 1f, 1f * (fenceLength / 18f));
		for (int num = types[selectedType].GetChild(selectedColor).GetChild(1).GetChild(selectedPillars)
			.childCount - 1; num >= 0; num--)
		{
			UnityEngine.Object.DestroyImmediate(types[selectedType].GetChild(selectedColor).GetChild(1).GetChild(selectedPillars)
				.GetChild(num)
				.gameObject);
			}
			GameObject original = types[selectedType].GetChild(selectedColor).GetChild(1).GetChild(selectedPillars)
				.gameObject;
			Transform child = types[selectedType].GetChild(selectedColor).GetChild(1).GetChild(selectedPillars);
			float num2 = fenceLength / 2f;
			float num3 = num2 / (float)((int)fencePillarsFrequency + 1);
			List<Transform> list = new List<Transform>();
			if (fencePillarsFrequency > 0f)
			{
				for (float num4 = num3; num4 <= num2; num4 += num3)
				{
					GameObject gameObject = UnityEngine.Object.Instantiate(original, child);
					gameObject.transform.localPosition = new Vector3(0f, 0f, num4);
					list.Add(gameObject.transform);
					gameObject.transform.parent = null;
					gameObject = UnityEngine.Object.Instantiate(original, child);
					gameObject.transform.localPosition = new Vector3(0f, 0f, 0f - num4);
					list.Add(gameObject.transform);
					gameObject.transform.parent = null;
				}
			}
			else if (fencePillarsFrequency > -1f)
			{
				GameObject gameObject2 = UnityEngine.Object.Instantiate(original, child);
				gameObject2.transform.localPosition = new Vector3(0f, 0f, num2);
				list.Add(gameObject2.transform);
				gameObject2.transform.parent = null;
				gameObject2 = UnityEngine.Object.Instantiate(original, child);
				gameObject2.transform.localPosition = new Vector3(0f, 0f, 0f - num2);
				list.Add(gameObject2.transform);
				gameObject2.transform.parent = null;
			}
			foreach (Transform item in list)
			{
				item.parent = child;
			}
		}
	}
	public class WNDRotator : MonoBehaviour
	{
		public Vector3 rotationSpeed;

		private void FixedUpdate()
		{
			base.transform.Rotate(rotationSpeed);
		}
	}
	public class Nuclear_bomb : MonoBehaviour
	{
		[Range(1f, 256f)]
		public float NukeDuration = 40f;

		private float CurrentDuration;

		public AnimationCurve SizeCurve;

		[Range(1f, 1024f)]
		public float SizeCurve_multiply;

		public float LightRadius = 2048f;

		public AnimationCurve LightRadius_curve;

		public float LightPower = 64f;

		public AnimationCurve LightPower_curve;

		private float FinalCurveVaue;

		private Vector3 finalShockWaveSize;

		public float sizeSpeed = 1f;

		private float finalShockSizeF;

		public Transform ShockWaveTransform;

		public Light BlastLight;

		public ParticleSystem blowPart;

		public MeshRenderer Mushrom;

		public float Emmis_mush;

		public float Emmis_steam;

		public AnimationCurve Mat_SizeCurve;

		public float _mat_SizeCurve_multiply;

		private void Start()
		{
			finalShockWaveSize = new Vector3(0f, 0f, 0f);
			CurrentDuration = 0f;
			finalShockSizeF = 0f;
		}

		private void Update()
		{
			finalShockSizeF += Time.deltaTime * sizeSpeed;
			finalShockWaveSize = new Vector3(finalShockSizeF, finalShockSizeF, finalShockSizeF);
			ShockWaveTransform.localScale = finalShockWaveSize;
			CurrentDuration += Time.deltaTime;
			FinalCurveVaue = Mathf.Clamp01(CurrentDuration / NukeDuration);
			BlastLight.intensity = LightPower * LightPower_curve.Evaluate(FinalCurveVaue);
			BlastLight.range = Mathf.Lerp(LightRadius, 0f, LightRadius_curve.Evaluate(FinalCurveVaue));
			if (CurrentDuration > 40f)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}
	}
	public class NukeBomb : MonoBehaviour
	{
		public GameObject Prefab;

		private void Start()
		{
		}

		private void Update()
		{
			if (Input.GetButtonDown("Fire1"))
			{
				UnityEngine.Object.Instantiate(Prefab, base.transform.position, base.transform.rotation);
			}
		}
	}
	public class ShockWave : MonoBehaviour
	{
		public AudioSource shockwaveSound;

		private void Start()
		{
		}

		private void Update()
		{
		}

		private void OnTriggerEnter(Collider other)
		{
			if (other.gameObject.tag == "Player")
			{
				shockwaveSound.Play();
			}
		}
	}
	public class CoolDown : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
	{
		public Image overlay;

		private bool isCoolDown;

		private float coolDownDuration;

		private float coolDownInitTime;

		public bool IsCoolDown => isCoolDown;

		public void Update()
		{
			if (overlay != null)
			{
				if (Time.time - coolDownInitTime < coolDownDuration)
				{
					overlay.fillAmount = Mathf.Clamp01(1f - (Time.time - coolDownInitTime) / coolDownDuration);
				}
				else
				{
					overlay.fillAmount = 0f;
				}
				isCoolDown = overlay.fillAmount > 0f;
			}
		}

		public void OnPointerClick(PointerEventData eventData)
		{
			Cooldown(3f, 1.5f);
		}

		public void Cooldown(float coolDown, float globalCoolDown)
		{
			if (!isCoolDown)
			{
				coolDownDuration = coolDown;
				coolDownInitTime = Time.time;
				isCoolDown = true;
				base.transform.root.BroadcastMessage("GlobalCooldown", globalCoolDown, SendMessageOptions.DontRequireReceiver);
			}
		}

		private void GlobalCooldown(float coolDown)
		{
			if (Time.time + coolDownInitTime * coolDownDuration < Time.time + coolDownInitTime * coolDown || !isCoolDown)
			{
				coolDownDuration = coolDown;
				coolDownInitTime = Time.time;
			}
		}
	}
	public class SelectDifficulty : MonoBehaviour
	{
		public int index;

		public Toggle[] toggles;

		public void OnSelect()
		{
			for (int i = 0; i < toggles.Length; i++)
			{
				if (i != index)
				{
					toggles[i].isOn = false;
				}
			}
			toggles[index].isOn = true;
		}
	}
	public class ButtonAnimator : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler, IPointerDownHandler, IPointerUpHandler
	{
		private Animator buttonAnimator;

		private void Start()
		{
			buttonAnimator = GetComponent<Animator>();
		}

		public void OnPointerEnter(PointerEventData eventData)
		{
			buttonAnimator.SetTrigger("Highlighted");
		}

		public void OnPointerExit(PointerEventData eventData)
		{
			buttonAnimator.SetTrigger("Normal");
		}

		public void OnPointerDown(PointerEventData eventData)
		{
			buttonAnimator.SetTrigger("Pressed");
		}

		public void OnPointerUp(PointerEventData eventData)
		{
			if (eventData.hovered.Contains(base.gameObject))
			{
				buttonAnimator.SetTrigger("Highlighted");
			}
			else
			{
				buttonAnimator.SetTrigger("Normal");
			}
		}
	}
	[AddComponentMenu("Camera-Control/Mouse Look")]
	public class MouseLook : MonoBehaviour
	{
		public enum RotationAxes
		{
			MouseXAndY,
			MouseX,
			MouseY
		}

		public RotationAxes axes;

		public float sensitivityX = 15f;

		public float sensitivityY = 15f;

		public float minimumX = -360f;

		public float maximumX = 360f;

		public float minimumY = -60f;

		public float maximumY = 60f;

		private float rotationY;

		private void Update()
		{
			if (axes == RotationAxes.MouseXAndY)
			{
				float y = base.transform.localEulerAngles.y + Input.GetAxis("Mouse X") * sensitivityX;
				rotationY += Input.GetAxis("Mouse Y") * sensitivityY;
				rotationY = Mathf.Clamp(rotationY, minimumY, maximumY);
				base.transform.localEulerAngles = new Vector3(0f - rotationY, y, 0f);
			}
			else if (axes == RotationAxes.MouseX)
			{
				base.transform.Rotate(0f, Input.GetAxis("Mouse X") * sensitivityX, 0f);
			}
			else
			{
				rotationY += Input.GetAxis("Mouse Y") * sensitivityY;
				rotationY = Mathf.Clamp(rotationY, minimumY, maximumY);
				base.transform.localEulerAngles = new Vector3(0f - rotationY, base.transform.localEulerAngles.y, 0f);
			}
		}

		private void Start()
		{
			if ((bool)GetComponent<Rigidbody>())
			{
				GetComponent<Rigidbody>().freezeRotation = true;
			}
		}
	}
	public class ONSPAmbisonicsNative : MonoBehaviour
	{
		public enum ovrAmbisonicsNativeStatus
		{
			Uninitialized = -1,
			NotEnabled,
			Success,
			StreamError,
			ProcessError,
			MaxStatValue
		}

		private AudioSource source;

		private static int numFOAChannels = 4;

		private static int paramAmbiStat = 6;

		private ovrAmbisonicsNativeStatus currentStatus = ovrAmbisonicsNativeStatus.Uninitialized;

		private void OnEnable()
		{
			source = GetComponent<AudioSource>();
			currentStatus = ovrAmbisonicsNativeStatus.Uninitialized;
			if (source == null)
			{
				UnityEngine.Debug.Log("Ambisonic ERROR: AudioSource does not exist.");
				return;
			}
			if (source.spatialize)
			{
				UnityEngine.Debug.Log("Ambisonic WARNING: Turning spatialize field off for Ambisonic sources.");
				source.spatialize = false;
			}
			if (source.clip == null)
			{
				UnityEngine.Debug.Log("Ambisonic ERROR: AudioSource does not contain an audio clip.");
			}
			else if (source.clip.channels != numFOAChannels)
			{
				UnityEngine.Debug.Log("Ambisonic ERROR: AudioSource clip does not have correct number of channels.");
			}
		}

		private void Update()
		{
			if (source == null)
			{
				return;
			}
			float value = 0f;
			source.GetAmbisonicDecoderFloat(paramAmbiStat, out value);
			ovrAmbisonicsNativeStatus ovrAmbisonicsNativeStatus = (ovrAmbisonicsNativeStatus)value;
			if (ovrAmbisonicsNativeStatus != currentStatus)
			{
				switch (ovrAmbisonicsNativeStatus)
				{
				case ovrAmbisonicsNativeStatus.NotEnabled:
					UnityEngine.Debug.Log("Ambisonic Native: Ambisonic not enabled on clip. Check clip field and turn it on");
					break;
				case ovrAmbisonicsNativeStatus.Uninitialized:
					UnityEngine.Debug.Log("Ambisonic Native: Stream uninitialized");
					break;
				case ovrAmbisonicsNativeStatus.Success:
					UnityEngine.Debug.Log("Ambisonic Native: Stream successfully initialized and playing/playable");
					break;
				case ovrAmbisonicsNativeStatus.StreamError:
					UnityEngine.Debug.Log("Ambisonic Native WARNING: Stream error (bad input format?)");
					break;
				case ovrAmbisonicsNativeStatus.ProcessError:
					UnityEngine.Debug.Log("Ambisonic Native WARNING: Stream process error (check default speaker setup)");
					break;
				}
			}
			currentStatus = ovrAmbisonicsNativeStatus;
		}
	}
	public class ONSPAudioSource : MonoBehaviour
	{
		private enum Parameters
		{
			P_GAIN,
			P_USEINVSQR,
			P_NEAR,
			P_FAR,
			P_RADIUS,
			P_DISABLE_RFL,
			P_AMBISTAT,
			P_READONLY_GLOBAL_RFL_ENABLED,
			P_READONLY_NUM_VOICES,
			P_SENDLEVEL,
			P_NUM
		}

		public const string strONSPS = "AudioPluginOculusSpatializer";

		[SerializeField]
		private bool enableSpatialization = true;

		[SerializeField]
		private float gain;

		[SerializeField]
		private bool useInvSqr;

		[SerializeField]
		private float near = 0.25f;

		[SerializeField]
		private float far = 250f;

		[SerializeField]
		private float volumetricRadius;

		[SerializeField]
		private float reverbSend;

		[SerializeField]
		private bool enableRfl;

		private static ONSPAudioSource RoomReflectionGizmoAS;

		public bool EnableSpatialization
		{
			get
			{
				return enableSpatialization;
			}
			set
			{
				enableSpatialization = value;
			}
		}

		public float Gain
		{
			get
			{
				return gain;
			}
			set
			{
				gain = Mathf.Clamp(value, 0f, 24f);
			}
		}

		public bool UseInvSqr
		{
			get
			{
				return useInvSqr;
			}
			set
			{
				useInvSqr = value;
			}
		}

		public float Near
		{
			get
			{
				return near;
			}
			set
			{
				near = Mathf.Clamp(value, 0f, 1000000f);
			}
		}

		public float Far
		{
			get
			{
				return far;
			}
			set
			{
				far = Mathf.Clamp(value, 0f, 1000000f);
			}
		}

		public float VolumetricRadius
		{
			get
			{
				return volumetricRadius;
			}
			set
			{
				volumetricRadius = Mathf.Clamp(value, 0f, 1000f);
			}
		}

		public float ReverbSend
		{
			get
			{
				return reverbSend;
			}
			set
			{
				reverbSend = Mathf.Clamp(value, -60f, 20f);
			}
		}

		public bool EnableRfl
		{
			get
			{
				return enableRfl;
			}
			set
			{
				enableRfl = value;
			}
		}

		[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
		private static void OnBeforeSceneLoadRuntimeMethod()
		{
			OSP_SetGlobalVoiceLimit(ONSPSettings.Instance.voiceLimit);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern void ONSP_GetGlobalRoomReflectionValues(ref bool reflOn, ref bool reverbOn, ref float width, ref float height, ref float length);

		private void Awake()
		{
			AudioSource source = GetComponent<AudioSource>();
			SetParameters(ref source);
		}

		private void Start()
		{
		}

		private void Update()
		{
			AudioSource source = GetComponent<AudioSource>();
			if (!Application.isPlaying || AudioListener.pause || !source.isPlaying || !source.isActiveAndEnabled)
			{
				source.spatialize = false;
			}
			else
			{
				SetParameters(ref source);
			}
		}

		public void SetParameters(ref AudioSource source)
		{
			source.spatialize = enableSpatialization;
			source.SetSpatializerFloat(0, gain);
			if (useInvSqr)
			{
				source.SetSpatializerFloat(1, 1f);
			}
			else
			{
				source.SetSpatializerFloat(1, 0f);
			}
			source.SetSpatializerFloat(2, near);
			source.SetSpatializerFloat(3, far);
			source.SetSpatializerFloat(4, volumetricRadius);
			if (enableRfl)
			{
				source.SetSpatializerFloat(5, 0f);
			}
			else
			{
				source.SetSpatializerFloat(5, 1f);
			}
			source.SetSpatializerFloat(9, reverbSend);
		}

		private void OnDrawGizmos()
		{
			if (RoomReflectionGizmoAS == null)
			{
				RoomReflectionGizmoAS = this;
			}
			Color color = default(Color);
			color.r = 1f;
			color.g = 0.5f;
			color.b = 0f;
			color.a = 1f;
			Gizmos.color = color;
			Gizmos.DrawWireSphere(base.transform.position, Near);
			color.a = 0.1f;
			Gizmos.color = color;
			Gizmos.DrawSphere(base.transform.position, Near);
			color.r = 1f;
			color.g = 0f;
			color.b = 0f;
			color.a = 1f;
			Gizmos.color = Color.red;
			Gizmos.DrawWireSphere(base.transform.position, Far);
			color.a = 0.1f;
			Gizmos.color = color;
			Gizmos.DrawSphere(base.transform.position, Far);
			color.r = 1f;
			color.g = 0f;
			color.b = 1f;
			color.a = 1f;
			Gizmos.color = color;
			Gizmos.DrawWireSphere(base.transform.position, VolumetricRadius);
			color.a = 0.1f;
			Gizmos.color = color;
			Gizmos.DrawSphere(base.transform.position, VolumetricRadius);
			if (RoomReflectionGizmoAS == this)
			{
				bool reflOn = false;
				bool reverbOn = false;
				float width = 1f;
				float height = 1f;
				float length = 1f;
				ONSP_GetGlobalRoomReflectionValues(ref reflOn, ref reverbOn, ref width, ref height, ref length);
				if (Camera.main != null && reflOn)
				{
					color = (Gizmos.color = ((!reverbOn) ? Color.cyan : Color.white));
					Gizmos.DrawWireCube(Camera.main.transform.position, new Vector3(width, height, length));
					color.a = 0.1f;
					Gizmos.color = color;
					Gizmos.DrawCube(Camera.main.transform.position, new Vector3(width, height, length));
				}
			}
		}

		private void OnDestroy()
		{
			if (RoomReflectionGizmoAS == this)
			{
				RoomReflectionGizmoAS = null;
			}
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int OSP_SetGlobalVoiceLimit(int VoiceLimit);
	}
	public class ONSPProfiler : MonoBehaviour
	{
		public bool profilerEnabled;

		private const int DEFAULT_PORT = 2121;

		public int port = 2121;

		public const string strONSPS = "AudioPluginOculusSpatializer";

		private void Start()
		{
			Application.runInBackground = true;
		}

		private void Update()
		{
			if (port < 0 || port > 65535)
			{
				port = 2121;
			}
			ONSP_SetProfilerPort(port);
			ONSP_SetProfilerEnabled(profilerEnabled);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ONSP_SetProfilerEnabled(bool enabled);

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ONSP_SetProfilerPort(int port);
	}
	public class ONSPPropagationGeometry : MonoBehaviour
	{
		private struct MeshMaterial
		{
			public MeshFilter meshFilter;

			public ONSPPropagationMaterial[] materials;
		}

		private struct TerrainMaterial
		{
			public Terrain terrain;

			public ONSPPropagationMaterial[] materials;

			public Mesh[] treePrototypeMeshes;
		}

		public static string GeometryAssetDirectory = "AudioGeometry";

		public string filePathRelative = "";

		public bool fileEnabled;

		public bool includeChildMeshes = true;

		private IntPtr geometryHandle = IntPtr.Zero;

		public static int OSPSuccess = 0;

		public const string GEOMETRY_FILE_EXTENSION = "ovramesh";

		private static int terrainDecimation = 4;

		public static string GeometryAssetPath => Application.streamingAssetsPath + "/" + GeometryAssetDirectory;

		public string filePath => GeometryAssetPath + "/" + filePathRelative;

		private static string GetPath(Transform current)
		{
			if (current.parent == null)
			{
				return current.gameObject.scene.name + "/" + current.name;
			}
			return GetPath(current.parent) + "-" + current.name;
		}

		private void Awake()
		{
			CreatePropagationGeometry();
		}

		private void CreatePropagationGeometry()
		{
			if (ONSPPropagation.Interface.CreateAudioGeometry(out geometryHandle) != OSPSuccess)
			{
				throw new Exception("Unable to create geometry handle");
			}
			if (filePath != null && filePath.Length != 0 && fileEnabled && Application.isPlaying)
			{
				if (!ReadFile())
				{
					UnityEngine.Debug.LogError("Failed to read file, attempting to regenerate audio geometry");
					UploadGeometry();
				}
			}
			else
			{
				UploadGeometry();
			}
		}

		private void Update()
		{
			if (!(geometryHandle == IntPtr.Zero))
			{
				Matrix4x4 localToWorldMatrix = base.transform.localToWorldMatrix;
				float[] matrix4x = new float[16]
				{
					localToWorldMatrix[0, 0],
					localToWorldMatrix[1, 0],
					0f - localToWorldMatrix[2, 0],
					localToWorldMatrix[3, 0],
					localToWorldMatrix[0, 1],
					localToWorldMatrix[1, 1],
					0f - localToWorldMatrix[2, 1],
					localToWorldMatrix[3, 1],
					localToWorldMatrix[0, 2],
					localToWorldMatrix[1, 2],
					0f - localToWorldMatrix[2, 2],
					localToWorldMatrix[3, 2],
					localToWorldMatrix[0, 3],
					localToWorldMatrix[1, 3],
					0f - localToWorldMatrix[2, 3],
					localToWorldMatrix[3, 3]
				};
				ONSPPropagation.Interface.AudioGeometrySetTransform(geometryHandle, matrix4x);
			}
		}

		private void OnDestroy()
		{
			if (geometryHandle != IntPtr.Zero && ONSPPropagation.Interface.DestroyAudioGeometry(geometryHandle) != OSPSuccess)
			{
				throw new Exception("Unable to destroy geometry");
			}
			geometryHandle = IntPtr.Zero;
		}

		private static void traverseMeshHierarchy(GameObject obj, ONSPPropagationMaterial[] currentMaterials, bool includeChildren, List<MeshMaterial> meshMaterials, List<TerrainMaterial> terrainMaterials, bool ignoreStatic, ref int ignoredMeshCount)
		{
			if (!obj.activeInHierarchy)
			{
				return;
			}
			MeshFilter[] components = obj.GetComponents<MeshFilter>();
			Terrain[] components2 = obj.GetComponents<Terrain>();
			ONSPPropagationMaterial[] components3 = obj.GetComponents<ONSPPropagationMaterial>();
			if (components3 != null && components3.Length != 0)
			{
				int num = components3.Length;
				if (currentMaterials != null)
				{
					num = Math.Max(num, currentMaterials.Length);
				}
				ONSPPropagationMaterial[] array = new ONSPPropagationMaterial[num];
				if (currentMaterials != null)
				{
					for (int i = components3.Length; i < num; i++)
					{
						array[i] = currentMaterials[i];
					}
				}
				currentMaterials = array;
				for (int j = 0; j < components3.Length; j++)
				{
					currentMaterials[j] = components3[j];
				}
			}
			MeshFilter[] array2 = components;
			foreach (MeshFilter meshFilter in array2)
			{
				Mesh sharedMesh = meshFilter.sharedMesh;
				if (!(sharedMesh == null))
				{
					if (ignoreStatic && !sharedMesh.isReadable)
					{
						UnityEngine.Debug.LogWarning("Mesh: " + meshFilter.gameObject.name + " not readable, cannot be static.", meshFilter.gameObject);
						ignoredMeshCount++;
						continue;
					}
					MeshMaterial item = default(MeshMaterial);
					item.meshFilter = meshFilter;
					item.materials = currentMaterials;
					meshMaterials.Add(item);
				}
			}
			Terrain[] array3 = components2;
			foreach (Terrain terrain in array3)
			{
				TerrainMaterial item2 = default(TerrainMaterial);
				item2.terrain = terrain;
				item2.materials = currentMaterials;
				terrainMaterials.Add(item2);
			}
			if (!includeChildren)
			{
				return;
			}
			foreach (Transform item3 in obj.transform)
			{
				if (item3.GetComponent<ONSPPropagationGeometry>() == null)
				{
					traverseMeshHierarchy(item3.gameObject, currentMaterials, includeChildren, meshMaterials, terrainMaterials, ignoreStatic, ref ignoredMeshCount);
				}
			}
		}

		private int uploadMesh(IntPtr geometryHandle, GameObject meshObject, Matrix4x4 worldToLocal)
		{
			int ignoredMeshCount = 0;
			return uploadMesh(geometryHandle, meshObject, worldToLocal, ignoreStatic: false, ref ignoredMeshCount);
		}

		private int uploadMesh(IntPtr geometryHandle, GameObject meshObject, Matrix4x4 worldToLocal, bool ignoreStatic, ref int ignoredMeshCount)
		{
			List<MeshMaterial> list = new List<MeshMaterial>();
			List<TerrainMaterial> list2 = new List<TerrainMaterial>();
			traverseMeshHierarchy(meshObject, null, includeChildMeshes, list, list2, ignoreStatic, ref ignoredMeshCount);
			ONSPPropagationMaterial[] array = new ONSPPropagationMaterial[1] { base.gameObject.AddComponent<ONSPPropagationMaterial>() };
			array[0].SetPreset(ONSPPropagationMaterial.Preset.Foliage);
			int totalVertexCount = 0;
			uint totalIndexCount = 0u;
			int totalFaceCount = 0;
			int totalMaterialCount = 0;
			foreach (MeshMaterial item in list)
			{
				updateCountsForMesh(ref totalVertexCount, ref totalIndexCount, ref totalFaceCount, ref totalMaterialCount, item.meshFilter.sharedMesh);
			}
			for (int i = 0; i < list2.Count; i++)
			{
				TerrainMaterial value = list2[i];
				TerrainData terrainData = value.terrain.terrainData;
				int heightmapResolution = terrainData.heightmapResolution;
				int heightmapResolution2 = terrainData.heightmapResolution;
				int num = (heightmapResolution - 1) / terrainDecimation + 1;
				int num2 = (heightmapResolution2 - 1) / terrainDecimation + 1;
				int num3 = num * num2;
				int num4 = (num - 1) * (num2 - 1) * 6;
				totalMaterialCount++;
				totalVertexCount += num3;
				totalIndexCount += (uint)num4;
				totalFaceCount += num4 / 3;
				TreePrototype[] treePrototypes = terrainData.treePrototypes;
				value.treePrototypeMeshes = new Mesh[treePrototypes.Length];
				for (int j = 0; j < treePrototypes.Length; j++)
				{
					MeshFilter[] componentsInChildren = treePrototypes[j].prefab.GetComponentsInChildren<MeshFilter>();
					int num5 = int.MaxValue;
					int num6 = -1;
					for (int k = 0; k < componentsInChildren.Length; k++)
					{
						int vertexCount = componentsInChildren[k].sharedMesh.vertexCount;
						if (vertexCount < num5)
						{
							num5 = vertexCount;
							num6 = k;
						}
					}
					value.treePrototypeMeshes[j] = componentsInChildren[num6].sharedMesh;
				}
				TreeInstance[] treeInstances = terrainData.treeInstances;
				for (int l = 0; l < treeInstances.Length; l++)
				{
					TreeInstance treeInstance = treeInstances[l];
					updateCountsForMesh(ref totalVertexCount, ref totalIndexCount, ref totalFaceCount, ref totalMaterialCount, value.treePrototypeMeshes[treeInstance.prototypeIndex]);
				}
				list2[i] = value;
			}
			List<Vector3> tempVertices = new List<Vector3>();
			List<int> tempIndices = new List<int>();
			MeshGroup[] array2 = new MeshGroup[totalMaterialCount];
			float[] array3 = new float[totalVertexCount * 3];
			int[] array4 = new int[totalIndexCount];
			int vertexOffset = 0;
			int indexOffset = 0;
			int groupOffset = 0;
			foreach (MeshMaterial item2 in list)
			{
				MeshFilter meshFilter = item2.meshFilter;
				Matrix4x4 matrix = worldToLocal * meshFilter.gameObject.transform.localToWorldMatrix;
				uploadMeshFilter(tempVertices, tempIndices, array2, array3, array4, ref vertexOffset, ref indexOffset, ref groupOffset, meshFilter.sharedMesh, item2.materials, matrix);
			}
			foreach (TerrainMaterial item3 in list2)
			{
				TerrainData terrainData2 = item3.terrain.terrainData;
				Matrix4x4 matrix4x = worldToLocal * item3.terrain.gameObject.transform.localToWorldMatrix;
				int heightmapResolution3 = terrainData2.heightmapResolution;
				int heightmapResolution4 = terrainData2.heightmapResolution;
				float[,] heights = terrainData2.GetHeights(0, 0, heightmapResolution3, heightmapResolution4);
				Vector3 size = terrainData2.size;
				size = new Vector3(size.x / (float)(heightmapResolution3 - 1) * (float)terrainDecimation, size.y, size.z / (float)(heightmapResolution4 - 1) * (float)terrainDecimation);
				int num7 = (heightmapResolution3 - 1) / terrainDecimation + 1;
				int num8 = (heightmapResolution4 - 1) / terrainDecimation + 1;
				int num9 = num7 * num8;
				int num10 = (num7 - 1) * (num8 - 1) * 2;
				array2[groupOffset].faceType = FaceType.TRIANGLES;
				array2[groupOffset].faceCount = (UIntPtr)(ulong)num10;
				array2[groupOffset].indexOffset = (UIntPtr)(ulong)indexOffset;
				if (item3.materials != null && item3.materials.Length != 0)
				{
					item3.materials[0].StartInternal();
					array2[groupOffset].material = item3.materials[0].materialHandle;
				}
				else
				{
					array2[groupOffset].material = IntPtr.Zero;
				}
				for (int m = 0; m < num8; m++)
				{
					for (int n = 0; n < num7; n++)
					{
						int num11 = (vertexOffset + m * num7 + n) * 3;
						Vector3 vector = matrix4x.MultiplyPoint3x4(Vector3.Scale(size, new Vector3(m, heights[n * terrainDecimation, m * terrainDecimation], n)));
						array3[num11] = vector.x;
						array3[num11 + 1] = vector.y;
						array3[num11 + 2] = vector.z;
					}
				}
				for (int num12 = 0; num12 < num8 - 1; num12++)
				{
					for (int num13 = 0; num13 < num7 - 1; num13++)
					{
						array4[indexOffset] = vertexOffset + num12 * num7 + num13;
						array4[indexOffset + 1] = vertexOffset + num12 * num7 + num13 + 1;
						array4[indexOffset + 2] = vertexOffset + (num12 + 1) * num7 + num13;
						array4[indexOffset + 3] = vertexOffset + (num12 + 1) * num7 + num13;
						array4[indexOffset + 4] = vertexOffset + num12 * num7 + num13 + 1;
						array4[indexOffset + 5] = vertexOffset + (num12 + 1) * num7 + num13 + 1;
						indexOffset += 6;
					}
				}
				vertexOffset += num9;
				groupOffset++;
				TreeInstance[] treeInstances = terrainData2.treeInstances;
				for (int l = 0; l < treeInstances.Length; l++)
				{
					TreeInstance treeInstance2 = treeInstances[l];
					Vector3 vector2 = Vector3.Scale(treeInstance2.position, terrainData2.size);
					Matrix4x4 localToWorldMatrix = item3.terrain.gameObject.transform.localToWorldMatrix;
					localToWorldMatrix.SetColumn(3, localToWorldMatrix.GetColumn(3) + new Vector4(vector2.x, vector2.y, vector2.z, 0f));
					Matrix4x4 matrix2 = worldToLocal * localToWorldMatrix;
					uploadMeshFilter(tempVertices, tempIndices, array2, array3, array4, ref vertexOffset, ref indexOffset, ref groupOffset, item3.treePrototypeMeshes[treeInstance2.prototypeIndex], array, matrix2);
				}
			}
			return ONSPPropagation.Interface.AudioGeometryUploadMeshArrays(geometryHandle, array3, totalVertexCount, array4, array4.Length, array2, array2.Length);
		}

		private static void uploadMeshFilter(List<Vector3> tempVertices, List<int> tempIndices, MeshGroup[] groups, float[] vertices, int[] indices, ref int vertexOffset, ref int indexOffset, ref int groupOffset, Mesh mesh, ONSPPropagationMaterial[] materials, Matrix4x4 matrix)
		{
			tempVertices.Clear();
			mesh.GetVertices(tempVertices);
			int count = tempVertices.Count;
			for (int i = 0; i < count; i++)
			{
				Vector3 vector = matrix.MultiplyPoint3x4(tempVertices[i]);
				int num = (vertexOffset + i) * 3;
				vertices[num] = vector.x;
				vertices[num + 1] = vector.y;
				vertices[num + 2] = vector.z;
			}
			for (int j = 0; j < mesh.subMeshCount; j++)
			{
				MeshTopology topology = mesh.GetTopology(j);
				if (topology != 0 && topology != MeshTopology.Quads)
				{
					continue;
				}
				tempIndices.Clear();
				mesh.GetIndices(tempIndices, j);
				int count2 = tempIndices.Count;
				for (int k = 0; k < count2; k++)
				{
					indices[indexOffset + k] = tempIndices[k] + vertexOffset;
				}
				switch (topology)
				{
				case MeshTopology.Triangles:
					groups[groupOffset + j].faceType = FaceType.TRIANGLES;
					groups[groupOffset + j].faceCount = (UIntPtr)(ulong)(count2 / 3);
					break;
				case MeshTopology.Quads:
					groups[groupOffset + j].faceType = FaceType.QUADS;
					groups[groupOffset + j].faceCount = (UIntPtr)(ulong)(count2 / 4);
					break;
				}
				groups[groupOffset + j].indexOffset = (UIntPtr)(ulong)indexOffset;
				if (materials != null && materials.Length != 0)
				{
					int num2 = j;
					if (num2 >= materials.Length)
					{
						num2 = materials.Length - 1;
					}
					materials[num2].StartInternal();
					groups[groupOffset + j].material = materials[num2].materialHandle;
				}
				else
				{
					groups[groupOffset + j].material = IntPtr.Zero;
				}
				indexOffset += count2;
			}
			vertexOffset += count;
			groupOffset += mesh.subMeshCount;
		}

		private static void updateCountsForMesh(ref int totalVertexCount, ref uint totalIndexCount, ref int totalFaceCount, ref int totalMaterialCount, Mesh mesh)
		{
			totalMaterialCount += mesh.subMeshCount;
			totalVertexCount += mesh.vertexCount;
			for (int i = 0; i < mesh.subMeshCount; i++)
			{
				MeshTopology topology = mesh.GetTopology(i);
				if (topology == MeshTopology.Triangles || topology == MeshTopology.Quads)
				{
					uint indexCount = mesh.GetIndexCount(i);
					totalIndexCount += indexCount;
					switch (topology)
					{
					case MeshTopology.Triangles:
						totalFaceCount += (int)indexCount / 3;
						break;
					case MeshTopology.Quads:
						totalFaceCount += (int)indexCount / 4;
						break;
					}
				}
			}
		}

		public void UploadGeometry()
		{
			int ignoredMeshCount = 0;
			if (uploadMesh(geometryHandle, base.gameObject, base.gameObject.transform.worldToLocalMatrix, ignoreStatic: true, ref ignoredMeshCount) != OSPSuccess)
			{
				throw new Exception("Unable to upload audio mesh geometry");
			}
			if (ignoredMeshCount != 0)
			{
				UnityEngine.Debug.LogError("Failed to upload meshes, " + ignoredMeshCount + " static meshes ignored. Turn on \"File Enabled\" to process static meshes offline", base.gameObject);
			}
		}

		public bool ReadFile()
		{
			if (filePath == null || filePath.Length == 0)
			{
				UnityEngine.Debug.LogError("Invalid mesh file path");
				return false;
			}
			if (ONSPPropagation.Interface.AudioGeometryReadMeshFile(geometryHandle, filePath) != OSPSuccess)
			{
				UnityEngine.Debug.LogError("Error reading mesh file " + filePath);
				return false;
			}
			return true;
		}

		public bool WriteToObj()
		{
			IntPtr geometry = IntPtr.Zero;
			if (ONSPPropagation.Interface.CreateAudioGeometry(out geometry) != OSPSuccess)
			{
				throw new Exception("Failed to create temp geometry handle");
			}
			if (uploadMesh(geometry, base.gameObject, base.gameObject.transform.worldToLocalMatrix) != OSPSuccess)
			{
				UnityEngine.Debug.LogError("Error uploading mesh " + base.gameObject.name);
				return false;
			}
			if (ONSPPropagation.Interface.AudioGeometryWriteMeshFileObj(geometry, filePath + ".obj") != OSPSuccess)
			{
				UnityEngine.Debug.LogError("Error writing .obj file " + filePath + ".obj");
				return false;
			}
			if (ONSPPropagation.Interface.DestroyAudioGeometry(geometry) != OSPSuccess)
			{
				throw new Exception("Failed to destroy temp geometry handle");
			}
			return true;
		}
	}
	internal class ONSPPropagation
	{
		public enum ovrAudioScalarType : uint
		{
			Int8,
			UInt8,
			Int16,
			UInt16,
			Int32,
			UInt32,
			Int64,
			UInt64,
			Float16,
			Float32,
			Float64
		}

		public class ClientType
		{
			public const uint OVRA_CLIENT_TYPE_NATIVE = 0u;

			public const uint OVRA_CLIENT_TYPE_WWISE_2016 = 1u;

			public const uint OVRA_CLIENT_TYPE_WWISE_2017_1 = 2u;

			public const uint OVRA_CLIENT_TYPE_WWISE_2017_2 = 3u;

			public const uint OVRA_CLIENT_TYPE_WWISE_2018_1 = 4u;

			public const uint OVRA_CLIENT_TYPE_FMOD = 5u;

			public const uint OVRA_CLIENT_TYPE_UNITY = 6u;

			public const uint OVRA_CLIENT_TYPE_UE4 = 7u;

			public const uint OVRA_CLIENT_TYPE_VST = 8u;

			public const uint OVRA_CLIENT_TYPE_AAX = 9u;

			public const uint OVRA_CLIENT_TYPE_TEST = 10u;

			public const uint OVRA_CLIENT_TYPE_OTHER = 11u;

			public const uint OVRA_CLIENT_TYPE_WWISE_UNKNOWN = 12u;

			public const uint OVRA_CLIENT_TYPE_WWISE_2019_1 = 13u;

			public const uint OVRA_CLIENT_TYPE_WWISE_2019_2 = 14u;
		}

		public interface PropagationInterface
		{
			int SetPropagationQuality(float quality);

			int SetPropagationThreadAffinity(ulong cpuMask);

			int CreateAudioGeometry(out IntPtr geometry);

			int DestroyAudioGeometry(IntPtr geometry);

			int AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, int vertexCount, int[] indices, int indexCount, MeshGroup[] groups, int groupCount);

			int AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4);

			int AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4);

			int AudioGeometryWriteMeshFile(IntPtr geometry, string filePath);

			int AudioGeometryReadMeshFile(IntPtr geometry, string filePath);

			int AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath);

			int AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value);

			int CreateAudioMaterial(out IntPtr material);

			int DestroyAudioMaterial(IntPtr material);

			int AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value);

			int AudioMaterialReset(IntPtr material, MaterialProperty property);
		}

		public class UnityNativeInterface : PropagationInterface
		{
			public const string strOSPS = "AudioPluginOculusSpatializer";

			private IntPtr context_ = IntPtr.Zero;

			private IntPtr context
			{
				get
				{
					if (context_ == IntPtr.Zero)
					{
						ovrAudio_GetPluginContext(out context_, 6u);
					}
					return context_;
				}
			}

			[DllImport("AudioPluginOculusSpatializer")]
			public static extern int ovrAudio_GetPluginContext(out IntPtr context, uint clientType);

			[DllImport("AudioPluginOculusSpatializer")]
			private static extern int ovrAudio_SetPropagationQuality(IntPtr context, float quality);

			public int SetPropagationQuality(float quality)
			{
				return ovrAudio_SetPropagationQuality(context, quality);
			}

			[DllImport("AudioPluginOculusSpatializer")]
			private static extern int ovrAudio_SetPropagationThreadAffinity(IntPtr context, ulong cpuMask);

			public int SetPropagationThreadAffinity(ulong cpuMask)
			{
				return ovrAudio_SetPropagationThreadAffinity(context, cpuMask);
			}

			[DllImport("AudioPluginOculusSpatializer")]
			private static extern int ovrAudio_CreateAudioGeometry(IntPtr context, out IntPtr geometry);

			public int CreateAudioGeometry(out IntPtr geometry)
			{
				return ovrAudio_CreateAudioGeometry(context, out geometry);
			}

			[DllImport("AudioPluginOculusSpatializer")]
			private static extern int ovrAudio_DestroyAudioGeometry(IntPtr geometry);

			public int DestroyAudioGeometry(IntPtr geometry)
			{
				return ovrAudio_DestroyAudioGeometry(geometry);
			}

			[DllImport("AudioPluginOculusSpatializer")]
			private static extern int ovrAudio_AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, UIntPtr verticesBytesOffset, UIntPtr vertexCount, UIntPtr vertexStride, ovrAudioScalarType vertexType, int[] indices, UIntPtr indicesByteOffset, UIntPtr indexCount, ovrAudioScalarType indexType, MeshGroup[] groups, UIntPtr groupCount);

			public int AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, int vertexCount, int[] indices, int indexCount, MeshGroup[] groups, int groupCount)
			{
				return ovrAudio_AudioGeometryUploadMeshArrays(geometry, vertices, UIntPtr.Zero, (UIntPtr)(ulong)vertexCount, UIntPtr.Zero, ovrAudioScalarType.Float32, indices, UIntPtr.Zero, (UIntPtr)(ulong)indexCount, ovrAudioScalarType.UInt32, groups, (UIntPtr)(ulong)groupCount);
			}

			[DllImport("AudioPluginOculusSpatializer")]
			private static extern int ovrAudio_AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4);

			public int AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4)
			{
				return ovrAudio_AudioGeometrySetTransform(geometry, matrix4x4);
			}

			[DllImport("AudioPluginOculusSpatializer")]
			private static extern int ovrAudio_AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4);

			public int AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4)
			{
				return ovrAudio_AudioGeometryGetTransform(geometry, out matrix4x4);
			}

			[DllImport("AudioPluginOculusSpatializer")]
			private static extern int ovrAudio_AudioGeometryWriteMeshFile(IntPtr geometry, string filePath);

			public int AudioGeometryWriteMeshFile(IntPtr geometry, string filePath)
			{
				return ovrAudio_AudioGeometryWriteMeshFile(geometry, filePath);
			}

			[DllImport("AudioPluginOculusSpatializer")]
			private static extern int ovrAudio_AudioGeometryReadMeshFile(IntPtr geometry, string filePath);

			public int AudioGeometryReadMeshFile(IntPtr geometry, string filePath)
			{
				return ovrAudio_AudioGeometryReadMeshFile(geometry, filePath);
			}

			[DllImport("AudioPluginOculusSpatializer")]
			private static extern int ovrAudio_AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath);

			public int AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath)
			{
				return ovrAudio_AudioGeometryWriteMeshFileObj(geometry, filePath);
			}

			[DllImport("AudioPluginOculusSpatializer")]
			private static extern int ovrAudio_CreateAudioMaterial(IntPtr context, out IntPtr material);

			public int CreateAudioMaterial(out IntPtr material)
			{
				return ovrAudio_CreateAudioMaterial(context, out material);
			}

			[DllImport("AudioPluginOculusSpatializer")]
			private static extern int ovrAudio_DestroyAudioMaterial(IntPtr material);

			public int DestroyAudioMaterial(IntPtr material)
			{
				return ovrAudio_DestroyAudioMaterial(material);
			}

			[DllImport("AudioPluginOculusSpatializer")]
			private static extern int ovrAudio_AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value);

			public int AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value)
			{
				return ovrAudio_AudioMaterialSetFrequency(material, property, frequency, value);
			}

			[DllImport("AudioPluginOculusSpatializer")]
			private static extern int ovrAudio_AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value);

			public int AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value)
			{
				return ovrAudio_AudioMaterialGetFrequency(material, property, frequency, out value);
			}

			[DllImport("AudioPluginOculusSpatializer")]
			private static extern int ovrAudio_AudioMaterialReset(IntPtr material, MaterialProperty property);

			public int AudioMaterialReset(IntPtr material, MaterialProperty property)
			{
				return ovrAudio_AudioMaterialReset(material, property);
			}
		}

		public class WwisePluginInterface : PropagationInterface
		{
			public const string strOSPS = "OculusSpatializerWwise";

			private IntPtr context_ = IntPtr.Zero;

			private IntPtr context
			{
				get
				{
					if (context_ == IntPtr.Zero)
					{
						ovrAudio_GetPluginContext(out context_, 12u);
					}
					return context_;
				}
			}

			[DllImport("OculusSpatializerWwise")]
			public static extern int ovrAudio_GetPluginContext(out IntPtr context, uint clientType);

			[DllImport("OculusSpatializerWwise")]
			private static extern int ovrAudio_SetPropagationQuality(IntPtr context, float quality);

			public int SetPropagationQuality(float quality)
			{
				return ovrAudio_SetPropagationQuality(context, quality);
			}

			[DllImport("OculusSpatializerWwise")]
			private static extern int ovrAudio_SetPropagationThreadAffinity(IntPtr context, ulong cpuMask);

			public int SetPropagationThreadAffinity(ulong cpuMask)
			{
				return ovrAudio_SetPropagationThreadAffinity(context, cpuMask);
			}

			[DllImport("OculusSpatializerWwise")]
			private static extern int ovrAudio_CreateAudioGeometry(IntPtr context, out IntPtr geometry);

			public int CreateAudioGeometry(out IntPtr geometry)
			{
				return ovrAudio_CreateAudioGeometry(context, out geometry);
			}

			[DllImport("OculusSpatializerWwise")]
			private static extern int ovrAudio_DestroyAudioGeometry(IntPtr geometry);

			public int DestroyAudioGeometry(IntPtr geometry)
			{
				return ovrAudio_DestroyAudioGeometry(geometry);
			}

			[DllImport("OculusSpatializerWwise")]
			private static extern int ovrAudio_AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, UIntPtr verticesBytesOffset, UIntPtr vertexCount, UIntPtr vertexStride, ovrAudioScalarType vertexType, int[] indices, UIntPtr indicesByteOffset, UIntPtr indexCount, ovrAudioScalarType indexType, MeshGroup[] groups, UIntPtr groupCount);

			public int AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, int vertexCount, int[] indices, int indexCount, MeshGroup[] groups, int groupCount)
			{
				return ovrAudio_AudioGeometryUploadMeshArrays(geometry, vertices, UIntPtr.Zero, (UIntPtr)(ulong)vertexCount, UIntPtr.Zero, ovrAudioScalarType.Float32, indices, UIntPtr.Zero, (UIntPtr)(ulong)indexCount, ovrAudioScalarType.UInt32, groups, (UIntPtr)(ulong)groupCount);
			}

			[DllImport("OculusSpatializerWwise")]
			private static extern int ovrAudio_AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4);

			public int AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4)
			{
				return ovrAudio_AudioGeometrySetTransform(geometry, matrix4x4);
			}

			[DllImport("OculusSpatializerWwise")]
			private static extern int ovrAudio_AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4);

			public int AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4)
			{
				return ovrAudio_AudioGeometryGetTransform(geometry, out matrix4x4);
			}

			[DllImport("OculusSpatializerWwise")]
			private static extern int ovrAudio_AudioGeometryWriteMeshFile(IntPtr geometry, string filePath);

			public int AudioGeometryWriteMeshFile(IntPtr geometry, string filePath)
			{
				return ovrAudio_AudioGeometryWriteMeshFile(geometry, filePath);
			}

			[DllImport("OculusSpatializerWwise")]
			private static extern int ovrAudio_AudioGeometryReadMeshFile(IntPtr geometry, string filePath);

			public int AudioGeometryReadMeshFile(IntPtr geometry, string filePath)
			{
				return ovrAudio_AudioGeometryReadMeshFile(geometry, filePath);
			}

			[DllImport("OculusSpatializerWwise")]
			private static extern int ovrAudio_AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath);

			public int AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath)
			{
				return ovrAudio_AudioGeometryWriteMeshFileObj(geometry, filePath);
			}

			[DllImport("OculusSpatializerWwise")]
			private static extern int ovrAudio_CreateAudioMaterial(IntPtr context, out IntPtr material);

			public int CreateAudioMaterial(out IntPtr material)
			{
				return ovrAudio_CreateAudioMaterial(context, out material);
			}

			[DllImport("OculusSpatializerWwise")]
			private static extern int ovrAudio_DestroyAudioMaterial(IntPtr material);

			public int DestroyAudioMaterial(IntPtr material)
			{
				return ovrAudio_DestroyAudioMaterial(material);
			}

			[DllImport("OculusSpatializerWwise")]
			private static extern int ovrAudio_AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value);

			public int AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value)
			{
				return ovrAudio_AudioMaterialSetFrequency(material, property, frequency, value);
			}

			[DllImport("OculusSpatializerWwise")]
			private static extern int ovrAudio_AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value);

			public int AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value)
			{
				return ovrAudio_AudioMaterialGetFrequency(material, property, frequency, out value);
			}

			[DllImport("OculusSpatializerWwise")]
			private static extern int ovrAudio_AudioMaterialReset(IntPtr material, MaterialProperty property);

			public int AudioMaterialReset(IntPtr material, MaterialProperty property)
			{
				return ovrAudio_AudioMaterialReset(material, property);
			}
		}

		public class FMODPluginInterface : PropagationInterface
		{
			public const string strOSPS = "OculusSpatializerFMOD";

			private IntPtr context_ = IntPtr.Zero;

			private IntPtr context
			{
				get
				{
					if (context_ == IntPtr.Zero)
					{
						ovrAudio_GetPluginContext(out context_, 5u);
					}
					return context_;
				}
			}

			[DllImport("OculusSpatializerFMOD")]
			public static extern int ovrAudio_GetPluginContext(out IntPtr context, uint clientType);

			[DllImport("OculusSpatializerFMOD")]
			private static extern int ovrAudio_SetPropagationQuality(IntPtr context, float quality);

			public int SetPropagationQuality(float quality)
			{
				return ovrAudio_SetPropagationQuality(context, quality);
			}

			[DllImport("OculusSpatializerFMOD")]
			private static extern int ovrAudio_SetPropagationThreadAffinity(IntPtr context, ulong cpuMask);

			public int SetPropagationThreadAffinity(ulong cpuMask)
			{
				return ovrAudio_SetPropagationThreadAffinity(context, cpuMask);
			}

			[DllImport("OculusSpatializerFMOD")]
			private static extern int ovrAudio_CreateAudioGeometry(IntPtr context, out IntPtr geometry);

			public int CreateAudioGeometry(out IntPtr geometry)
			{
				return ovrAudio_CreateAudioGeometry(context, out geometry);
			}

			[DllImport("OculusSpatializerFMOD")]
			private static extern int ovrAudio_DestroyAudioGeometry(IntPtr geometry);

			public int DestroyAudioGeometry(IntPtr geometry)
			{
				return ovrAudio_DestroyAudioGeometry(geometry);
			}

			[DllImport("OculusSpatializerFMOD")]
			private static extern int ovrAudio_AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, UIntPtr verticesBytesOffset, UIntPtr vertexCount, UIntPtr vertexStride, ovrAudioScalarType vertexType, int[] indices, UIntPtr indicesByteOffset, UIntPtr indexCount, ovrAudioScalarType indexType, MeshGroup[] groups, UIntPtr groupCount);

			public int AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, int vertexCount, int[] indices, int indexCount, MeshGroup[] groups, int groupCount)
			{
				return ovrAudio_AudioGeometryUploadMeshArrays(geometry, vertices, UIntPtr.Zero, (UIntPtr)(ulong)vertexCount, UIntPtr.Zero, ovrAudioScalarType.Float32, indices, UIntPtr.Zero, (UIntPtr)(ulong)indexCount, ovrAudioScalarType.UInt32, groups, (UIntPtr)(ulong)groupCount);
			}

			[DllImport("OculusSpatializerFMOD")]
			private static extern int ovrAudio_AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4);

			public int AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4)
			{
				return ovrAudio_AudioGeometrySetTransform(geometry, matrix4x4);
			}

			[DllImport("OculusSpatializerFMOD")]
			private static extern int ovrAudio_AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4);

			public int AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4)
			{
				return ovrAudio_AudioGeometryGetTransform(geometry, out matrix4x4);
			}

			[DllImport("OculusSpatializerFMOD")]
			private static extern int ovrAudio_AudioGeometryWriteMeshFile(IntPtr geometry, string filePath);

			public int AudioGeometryWriteMeshFile(IntPtr geometry, string filePath)
			{
				return ovrAudio_AudioGeometryWriteMeshFile(geometry, filePath);
			}

			[DllImport("OculusSpatializerFMOD")]
			private static extern int ovrAudio_AudioGeometryReadMeshFile(IntPtr geometry, string filePath);

			public int AudioGeometryReadMeshFile(IntPtr geometry, string filePath)
			{
				return ovrAudio_AudioGeometryReadMeshFile(geometry, filePath);
			}

			[DllImport("OculusSpatializerFMOD")]
			private static extern int ovrAudio_AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath);

			public int AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath)
			{
				return ovrAudio_AudioGeometryWriteMeshFileObj(geometry, filePath);
			}

			[DllImport("OculusSpatializerFMOD")]
			private static extern int ovrAudio_CreateAudioMaterial(IntPtr context, out IntPtr material);

			public int CreateAudioMaterial(out IntPtr material)
			{
				return ovrAudio_CreateAudioMaterial(context, out material);
			}

			[DllImport("OculusSpatializerFMOD")]
			private static extern int ovrAudio_DestroyAudioMaterial(IntPtr material);

			public int DestroyAudioMaterial(IntPtr material)
			{
				return ovrAudio_DestroyAudioMaterial(material);
			}

			[DllImport("OculusSpatializerFMOD")]
			private static extern int ovrAudio_AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value);

			public int AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value)
			{
				return ovrAudio_AudioMaterialSetFrequency(material, property, frequency, value);
			}

			[DllImport("OculusSpatializerFMOD")]
			private static extern int ovrAudio_AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value);

			public int AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value)
			{
				return ovrAudio_AudioMaterialGetFrequency(material, property, frequency, out value);
			}

			[DllImport("OculusSpatializerFMOD")]
			private static extern int ovrAudio_AudioMaterialReset(IntPtr material, MaterialProperty property);

			public int AudioMaterialReset(IntPtr material, MaterialProperty property)
			{
				return ovrAudio_AudioMaterialReset(material, property);
			}
		}

		private static PropagationInterface CachedInterface;

		public static PropagationInterface Interface
		{
			get
			{
				if (CachedInterface == null)
				{
					CachedInterface = FindInterface();
				}
				return CachedInterface;
			}
		}

		private static PropagationInterface FindInterface()
		{
			IntPtr context;
			try
			{
				WwisePluginInterface.ovrAudio_GetPluginContext(out context, 12u);
				UnityEngine.Debug.Log("Propagation initialized with Wwise Oculus Spatializer plugin");
				return new WwisePluginInterface();
			}
			catch (DllNotFoundException)
			{
			}
			try
			{
				FMODPluginInterface.ovrAudio_GetPluginContext(out context, 5u);
				UnityEngine.Debug.Log("Propagation initialized with FMOD Oculus Spatializer plugin");
				return new FMODPluginInterface();
			}
			catch (DllNotFoundException)
			{
			}
			UnityEngine.Debug.Log("Propagation initialized with Unity Oculus Spatializer plugin");
			return new UnityNativeInterface();
		}
	}
	public sealed class ONSPPropagationMaterial : MonoBehaviour
	{
		public enum Preset
		{
			Custom,
			AcousticTile,
			Brick,
			BrickPainted,
			Carpet,
			CarpetHeavy,
			CarpetHeavyPadded,
			CeramicTile,
			Concrete,
			ConcreteRough,
			ConcreteBlock,
			ConcreteBlockPainted,
			Curtain,
			Foliage,
			Glass,
			GlassHeavy,
			Grass,
			Gravel,
			GypsumBoard,
			PlasterOnBrick,
			PlasterOnConcreteBlock,
			Soil,
			SoundProof,
			Snow,
			Steel,
			Water,
			WoodThin,
			WoodThick,
			WoodFloor,
			WoodOnConcrete
		}

		[Serializable]
		public sealed class Point
		{
			public float frequency;

			public float data;

			public Point(float frequency = 0f, float data = 0f)
			{
				this.frequency = frequency;
				this.data = data;
			}

			public static implicit operator Point(Vector2 v)
			{
				return new Point(v.x, v.y);
			}

			public static implicit operator Vector2(Point point)
			{
				return new Vector2(point.frequency, point.data);
			}
		}

		[Serializable]
		public sealed class Spectrum
		{
			public int selection = int.MaxValue;

			public List<Point> points = new List<Point>();

			public float this[float f]
			{
				get
				{
					if (points.Count > 0)
					{
						Point point = new Point(float.MinValue);
						Point point2 = new Point(float.MaxValue);
						foreach (Point point3 in points)
						{
							if (point3.frequency < f)
							{
								if (point3.frequency > point.frequency)
								{
									point = point3;
								}
							}
							else if (point3.frequency < point2.frequency)
							{
								point2 = point3;
							}
						}
						if (point.frequency == float.MinValue)
						{
							point.data = points.OrderBy((Point p) => p.frequency).First().data;
						}
						if (point2.frequency == float.MaxValue)
						{
							point2.data = points.OrderBy((Point p) => p.frequency).Last().data;
						}
						return point.data + (f - point.frequency) * (point2.data - point.data) / (point2.frequency - point.frequency);
					}
					return 0f;
				}
			}
		}

		public IntPtr materialHandle = IntPtr.Zero;

		[Tooltip("Absorption")]
		public Spectrum absorption = new Spectrum();

		[Tooltip("Transmission")]
		public Spectrum transmission = new Spectrum();

		[Tooltip("Scattering")]
		public Spectrum scattering = new Spectrum();

		[SerializeField]
		private Preset preset_;

		public Preset preset
		{
			get
			{
				return preset_;
			}
			set
			{
				SetPreset(value);
				preset_ = value;
			}
		}

		private void Start()
		{
			StartInternal();
		}

		public void StartInternal()
		{
			if (!(materialHandle != IntPtr.Zero))
			{
				if (ONSPPropagation.Interface.CreateAudioMaterial(out materialHandle) != ONSPPropagationGeometry.OSPSuccess)
				{
					throw new Exception("Unable to create internal audio material");
				}
				UploadMaterial();
			}
		}

		private void OnDestroy()
		{
			DestroyInternal();
		}

		public void DestroyInternal()
		{
			if (materialHandle != IntPtr.Zero)
			{
				ONSPPropagation.Interface.DestroyAudioMaterial(materialHandle);
				materialHandle = IntPtr.Zero;
			}
		}

		public void UploadMaterial()
		{
			if (materialHandle == IntPtr.Zero)
			{
				return;
			}
			ONSPPropagation.Interface.AudioMaterialReset(materialHandle, MaterialProperty.ABSORPTION);
			foreach (Point point in absorption.points)
			{
				ONSPPropagation.Interface.AudioMaterialSetFrequency(materialHandle, MaterialProperty.ABSORPTION, point.frequency, point.data);
			}
			ONSPPropagation.Interface.AudioMaterialReset(materialHandle, MaterialProperty.TRANSMISSION);
			foreach (Point point2 in transmission.points)
			{
				ONSPPropagation.Interface.AudioMaterialSetFrequency(materialHandle, MaterialProperty.TRANSMISSION, point2.frequency, point2.data);
			}
			ONSPPropagation.Interface.AudioMaterialReset(materialHandle, MaterialProperty.SCATTERING);
			foreach (Point point3 in scattering.points)
			{
				ONSPPropagation.Interface.AudioMaterialSetFrequency(materialHandle, MaterialProperty.SCATTERING, point3.frequency, point3.data);
			}
		}

		public void SetPreset(Preset preset)
		{
			ONSPPropagationMaterial material = this;
			switch (preset)
			{
			case Preset.AcousticTile:
				AcousticTile(ref material);
				break;
			case Preset.Brick:
				Brick(ref material);
				break;
			case Preset.BrickPainted:
				BrickPainted(ref material);
				break;
			case Preset.Carpet:
				Carpet(ref material);
				break;
			case Preset.CarpetHeavy:
				CarpetHeavy(ref material);
				break;
			case Preset.CarpetHeavyPadded:
				CarpetHeavyPadded(ref material);
				break;
			case Preset.CeramicTile:
				CeramicTile(ref material);
				break;
			case Preset.Concrete:
				Concrete(ref material);
				break;
			case Preset.ConcreteRough:
				ConcreteRough(ref material);
				break;
			case Preset.ConcreteBlock:
				ConcreteBlock(ref material);
				break;
			case Preset.ConcreteBlockPainted:
				ConcreteBlockPainted(ref material);
				break;
			case Preset.Curtain:
				Curtain(ref material);
				break;
			case Preset.Foliage:
				Foliage(ref material);
				break;
			case Preset.Glass:
				Glass(ref material);
				break;
			case Preset.GlassHeavy:
				GlassHeavy(ref material);
				break;
			case Preset.Grass:
				Grass(ref material);
				break;
			case Preset.Gravel:
				Gravel(ref material);
				break;
			case Preset.GypsumBoard:
				GypsumBoard(ref material);
				break;
			case Preset.PlasterOnBrick:
				PlasterOnBrick(ref material);
				break;
			case Preset.PlasterOnConcreteBlock:
				PlasterOnConcreteBlock(ref material);
				break;
			case Preset.Soil:
				Soil(ref material);
				break;
			case Preset.SoundProof:
				SoundProof(ref material);
				break;
			case Preset.Snow:
				Snow(ref material);
				break;
			case Preset.Steel:
				Steel(ref material);
				break;
			case Preset.Water:
				Water(ref material);
				break;
			case Preset.WoodThin:
				WoodThin(ref material);
				break;
			case Preset.WoodThick:
				WoodThick(ref material);
				break;
			case Preset.WoodFloor:
				WoodFloor(ref material);
				break;
			case Preset.WoodOnConcrete:
				WoodOnConcrete(ref material);
				break;
			case Preset.Custom:
				break;
			}
		}

		private static void AcousticTile(ref ONSPPropagationMaterial material)
		{
			material.absorption.points = new List<Point>
			{
				new Point(125f, 0.5f),
				new Point(250f, 0.7f),
				new Point(500f, 0.6f),
				new Point(1000f, 0.7f),
				new Point(2000f, 0.7f),
				new Point(4000f, 0.5f)
			};
			material.scattering.points = new List<Point>
			{
				new Point(125f, 0.1f),
				new Point(250f, 0.15f),
				new Point(500f, 0.2f),
				new Point(1000f, 0.2f),
				new Point(2000f, 0.25f),
				new Point(4000f, 0.3f)
			};
			material.transmission.points = new List<Point>
			{
				new Point(125f, 0.05f),
				new Point(250f, 0.04f),
				new Point(500f, 0.03f),
				new Point(1000f, 0.02f),
				new Point(2000f, 0.005f),
				new Point(4000f, 0.002f)
			};
		}

		private static void Brick(ref ONSPPropagationMaterial material)
		{
			material.absorption.points = new List<Point>
			{
				new Point(125f, 0.02f),
				new Point(250f, 0.02f),
				new Point(500f, 0.03f),
				new Point(1000f, 0.04f),
				new Point(2000f, 0.05f),
				new Point(4000f, 0.07f)
			};
			material.scattering.points = new List<Point>
			{
				new Point(125f, 0.2f),
				new Point(250f, 0.25f),
				new Point(500f, 0.3f),
				new Point(1000f, 0.35f),
				new Point(2000f, 0.4f),
				new Point(4000f, 0.45f)
			};
			material.transmission.points = new List<Point>
			{
				new Point(125f, 0.025f),
				new Point(250f, 0.019f),
				new Point(500f, 0.01f),
				new Point(1000f, 0.0045f),
				new Point(2000f, 0.0018f),
				new Point(4000f, 0.00089f)
			};
		}

		private static void BrickPainted(ref ONSPPropagationMaterial material)
		{
			material.absorption.points = new List<Point>
			{
				new Point(125f, 0.01f),
				new Point(250f, 0.01f),
				new Point(500f, 0.02f),
				new Point(1000f, 0.02f),
				new Point(2000f, 0.02f),
				new Point(4000f, 0.03f)
			};
			material.scattering.points = new List<Point>
			{
				new Point(125f, 0.15f),
				new Point(250f, 0.15f),
				new Point(500f, 0.2f),
				new Point(1000f, 0.2f),
				new Point(2000f, 0.2f),
				new Point(4000f, 0.25f)
			};
			material.transmission.points = new List<Point>
			{
				new Point(125f, 0.025f),
				new Point(250f, 0.019f),
				new Point(500f, 0.01f),
				new Point(1000f, 0.0045f),
				new Point(2000f, 0.0018f),
				new Point(4000f, 0.00089f)
			};
		}

		private static void Carpet(ref ONSPPropagationMaterial material)
		{
			material.absorption.points = new List<Point>
			{
				new Point(125f, 0.01f),
				new Point(250f, 0.05f),
				new Point(500f, 0.1f),
				new Point(1000f, 0.2f),
				new Point(2000f, 0.45f),
				new Point(4000f, 0.65f)
			};
			material.scattering.points = new List<Point>
			{
				new Point(125f, 0.1f),
				new Point(250f, 0.1f),
				new Point(500f, 0.15f),
				new Point(1000f, 0.2f),
				new Point(2000f, 0.3f),
				new Point(4000f, 0.45f)
			};
			material.transmission.points = new List<Point>
			{
				new Point(125f, 0.004f),
				new Point(250f, 0.0079f),
				new Point(500f, 0.0056f),
				new Point(1000f, 0.0016f),
				new Point(2000f, 0.0014f),
				new Point(4000f, 0.0005f)
			};
		}

		private static void CarpetHeavy(ref ONSPPropagationMaterial material)
		{
			material.absorption.points = new List<Point>
			{
				new Point(125f, 0.02f),
				new Point(250f, 0.06f),
				new Point(500f, 0.14f),
				new Point(1000f, 0.37f),
				new Point(2000f, 0.48f),
				new Point(4000f, 0.63f)
			};
			material.scattering.points = new List<Point>
			{
				new Point(125f, 0.1f),
				new Point(250f, 0.15f),
				new Point(500f, 0.2f),
				new Point(1000f, 0.25f),
				new Point(2000f, 0.35f),
				new Point(4000f, 0.5f)
			};
			material.transmission.points = new List<Point>
			{
				new Point(125f, 0.004f),
				new Point(250f, 0.0079f),
				new Point(500f, 0.0056f),
				new Point(1000f, 0.0016f),
				new Point(2000f, 0.0014f),
				new Point(4000f, 0.0005f)
			};
		}

		private static void CarpetHeavyPadded(ref ONSPPropagationMaterial material)
		{
			material.absorption.points = new List<Point>
			{
				new Point(125f, 0.08f),
				new Point(250f, 0.24f),
				new Point(500f, 0.57f),
				new Point(1000f, 0.69f),
				new Point(2000f, 0.71f),
				new Point(4000f, 0.73f)
			};
			material.scattering.points = new List<Point>
			{
				new Point(125f, 0.1f),
				new Point(250f, 0.15f),
				new Point(500f, 0.2f),
				new Point(1000f, 0.25f),
				new Point(2000f, 0.35f),
				new Point(4000f, 0.5f)
			};
			material.transmission.points = new List<Point>
			{
				new Point(125f, 0.004f),
				new Point(250f, 0.0079f),
				new Point(500f, 0.0056f),
				new Point(1000f, 0.0016f),
				new Point(2000f, 0.0014f),
				new Point(4000f, 0.0005f)
			};
		}

		private static void CeramicTile(ref ONSPPropagationMaterial material)
		{
			material.absorption.points = new List<Point>
			{
				new Point(125f, 0.01f),
				new Point(250f, 0.01f),
				new Point(500f, 0.01f),
				new Point(1000f, 0.01f),
				new Point(2000f, 0.02f),
				new Point(4000f, 0.02f)
			};
			material.scattering.points = new List<Point>
			{
				new Point(125f, 0.1f),
				new Point(250f, 0.12f),
				new Point(500f, 0.14f),
				new Point(1000f, 0.16f),
				new Point(2000f, 0.18f),
				new Point(4000f, 0.2f)
			};
			material.transmission.points = new List<Point>
			{
				new Point(125f, 0.004f),
				new Point(250f, 0.0079f),
				new Point(500f, 0.0056f),
				new Point(1000f, 0.0016f),
				new Point(2000f, 0.0014f),
				new Point(4000f, 0.0005f)
			};
		}

		private static void Concrete(ref ONSPPropagationMaterial material)
		{
			material.absorption.points = new List<Point>
			{
				new Point(125f, 0.01f),
				new Point(250f, 0.01f),
				new Point(500f, 0.02f),
				new Point(1000f, 0.02f),
				new Point(2000f, 0.02f),
				new Point(4000f, 0.02f)
			};
			material.scattering.points = new List<Point>
			{
				new Point(125f, 0.1f),
				new Point(250f, 0.11f),
				new Point(500f, 0.12f),
				new Point(1000f, 0.13f),
				new Point(2000f, 0.14f),
				new Point(4000f, 0.15f)
			};
			material.transmission.points = new List<Point>
			{
				new Point(125f, 0.004f),
				new Point(250f, 0.0079f),
				new Point(500f, 0.0056f),
				new Point(1000f, 0.0016f),
				new Point(2000f, 0.0014f),
				new Point(4000f, 0.0005f)
			};
		}

		private static void ConcreteRough(ref ONSPPropagationMaterial material)
		{
			material.absorption.points = new List<Point>
			{
				new Point(125f, 0.01f),
				new Point(250f, 0.02f),
				new Point(500f, 0.04f),
				new Point(1000f, 0.06f),
				new Point(2000f, 0.08f),
				new Point(4000f, 0.1f)
			};
			material.scattering.points = new List<Point>
			{
				new Point(125f, 0.1f),
				new Point(250f, 0.12f),
				new Point(500f, 0.15f),
				new Point(1000f, 0.2f),
				new Point(2000f, 0.25f),
				new Point(4000f, 0.3f)
			};
			material.transmission.points = new List<Point>
			{
				new Point(125f, 0.004f),
				new Point(250f, 0.0079f),
				new Point(500f, 0.0056f),
				new Point(1000f, 0.0016f),
				new Point(2000f, 0.0014f),
				new Point(4000f, 0.0005f)
			};
		}

		private static void ConcreteBlock(ref ONSPPropagationMaterial material)
		{
			material.absorption.points = new List<Point>
			{
				new Point(125f, 0.36f),
				new Point(250f, 0.44f),
				new Point(500f, 0.31f),
				new Point(1000f, 0.29f),
				new Point(2000f, 0.39f),
				new Point(4000f, 0.21f)
			};
			material.scattering.points = new List<Point>
			{
				new Point(125f, 0.1f),
				new Point(250f, 0.12f),
				new Point(500f, 0.15f),
				new Point(1000f, 0.2f),
				new Point(2000f, 0.3f),
				new Point(4000f, 0.4f)
			};
			material.transmission.points = new List<Point>
			{
				new Point(125f, 0.02f),
				new Point(250f, 0.01f),
				new Point(500f, 0.0063f),
				new Point(1000f, 0.0035f),
				new Point(2000f, 0.00011f),
				new Point(4000f, 0.00063f)
			};
		}

		private static void ConcreteBlockPainted(ref ONSPPropagationMaterial material)
		{
			material.absorption.points = new List<Point>
			{
				new Point(125f, 0.1f),
				new Point(250f, 0.05f),
				new Point(500f, 0.06f),
				new Point(1000f, 0.07f),
				new Point(2000f, 0.09f),
				new Point(4000f, 0.08f)
			};
			material.scattering.points = new List<Point>
			{
				new Point(125f, 0.1f),
				new Point(250f, 0.11f),
				new Point(500f, 0.13f),
				new Point(1000f, 0.15f),
				new Point(2000f, 0.16f),
				new Point(4000f, 0.2f)
			};
			material.transmission.points = new List<Point>
			{
				new Point(125f, 0.02f),
				new Point(250f, 0.01f),
				new Point(500f, 0.0063f),
				new Point(1000f, 0.0035f),
				new Point(2000f, 0.00011f),
				new Point(4000f, 0.00063f)
			};
		}

		private static void Curtain(ref ONSPPropagationMaterial material)
		{
			material.absorption.points = new List<Point>
			{
				new Point(125f, 0.07f),
				new Point(250f, 0.31f),
				new Point(500f, 0.49f),
				new Point(1000f, 0.75f),
				new Point(2000f, 0.7f),
				new Point(4000f, 0.6f)
			};
			material.scattering.points = new List<Point>
			{
				new Point(125f, 0.1f),
				new Point(250f, 0.15f),
				new Point(500f, 0.2f),
				new Point(1000f, 0.3f),
				new Point(2000f, 0.4f),
				new Point(4000f, 0.5f)
			};
			material.transmission.points = new List<Point>
			{
				new Point(125f, 0.42f),
				new Point(250f, 0.39f),
				new Point(500f, 0.21f),
				new Point(1000f, 0.14f),
				new Point(2000f, 0.079f),
				new Point(4000f, 0.045f)
			};
		}

		private static void Foliage(ref ONSPPropagationMaterial material)
		{
			material.absorption.points = new List<Point>
			{
				new Point(125f, 0.03f),
				new Point(250f, 0.06f),
				new Point(500f, 0.11f),
				new Point(1000f, 0.17f),
				new Point(2000f, 0.27f),
				new Point(4000f, 0.31f)
			};
			material.scattering.points = new List<Point>
			{
				new Point(125f, 0.2f),
				new Point(250f, 0.3f),
				new Point(500f, 0.4f),
				new Point(1000f, 0.5f),
				new Point(2000f, 0.7f),
				new Point(4000f, 0.8f)
			};
			material.transmission.points = new List<Point>
			{
				new Point(125f, 0.9f),
				new Point(250f, 0.9f),
				new Point(500f, 0.9f),
				new Point(1000f, 0.8f),
				new Point(2000f, 0.5f),
				new Point(4000f, 0.3f)
			};
		}

		private static void Glass(ref ONSPPropagationMaterial material)
		{
			material.absorption.points = new List<Point>
			{
				new Point(125f, 0.35f),
				new Point(250f, 0.25f),
				new Point(500f, 0.18f),
				new Point(1000f, 0.12f),
				new Point(2000f, 0.07f),
				new Point(4000f, 0.05f)
			};
			material.scattering.points = new List<Point>
			{
				new Point(125f, 0.05f),
				new Point(250f, 0.05f),
				new Point(500f, 0.05f),
				new Point(1000f, 0.05f),
				new Point(2000f, 0.05f),
				new Point(4000f, 0.05f)
			};
			material.transmission.points = new List<Point>
			{
				new Point(125f, 0.125f),
				new Point(250f, 0.089f),
				new Point(500f, 0.05f),
				new Point(1000f, 0.028f),
				new Point(2000f, 0.022f),
				new Point(4000f, 0.079f)
			};
		}

		private static void GlassHeavy(ref ONSPPropagationMaterial material)
		{
			material.absorption.points = new List<Point>
			{
				new Point(125f, 0.18f),
				new Point(250f, 0.06f),
				new Point(500f, 0.04f),
				new Point(1000f, 0.03f),
				new Point(2000f, 0.02f),
				new Point(4000f, 0.02f)
			};
			material.scattering.points = new List<Point>
			{
				new Point(125f, 0.05f),
				new Point(250f, 0.05f),
				new Point(500f, 0.05f),
				new Point(1000f, 0.05f),
				new Point(2000f, 0.05f),
				new Point(4000f, 0.05f)
			};
			material.transmission.points = new List<Point>
			{
				new Point(125f, 0.056f),
				new Point(250f, 0.039f),
				new Point(500f, 0.028f),
				new Point(1000f, 0.02f),
				new Point(2000f, 0.032f),
				new Point(4000f, 0.014f)
			};
		}

		private static void Grass(ref ONSPPropagationMaterial material)
		{
			material.absorption.points = new List<Point>
			{
				new Point(125f, 0.11f),
				new Point(250f, 0.26f),
				new Point(500f, 0.6f),
				new Point(1000f, 0.69f),
				new Point(2000f, 0.92f),
				new Point(4000f, 0.99f)
			};
			material.scattering.points = new List<Point>
			{
				new Point(125f, 0.3f),
				new Point(250f, 0.3f),
				new Point(500f, 0.4f),
				new Point(1000f, 0.5f),
				new Point(2000f, 0.6f),
				new Point(4000f, 0.7f)
			};
			material.transmission.points = new List<Point>();
		}

		private static void Gravel(ref ONSPPropagationMaterial material)
		{
			material.absorption.points = new List<Point>
			{
				new Point(125f, 0.25f),
				new Point(250f, 0.6f),
				new Point(500f, 0.65f),
				new Point(1000f, 0.7f),
				new Point(2000f, 0.75f),
				new Point(4000f, 0.8f)
			};
			material.scattering.points = new List<Point>
			{
				new Point(125f, 0.2f),
				new Point(250f, 0.3f),
				new Point(500f, 0.4f),
				new Point(1000f, 0.5f),
				new Point(2000f, 0.6f),
				new Point(4000f, 0.7f)
			};
			material.transmission.points = new List<Point>();
		}

		private static void GypsumBoard(ref ONSPPropagationMaterial material)
		{
			material.absorption.points = new List<Point>
			{
				new Point(125f, 0.29f),
				new Point(250f, 0.1f),
				new Point(500f, 0.05f),
				new Point(1000f, 0.04f),
				new Point(2000f, 0.07f),
				new Point(4000f, 0.09f)
			};
			material.scattering.points = new List<Point>
			{
				new Point(125f, 0.1f),
				new Point(250f, 0.11f),
				new Point(500f, 0.12f),
				new Point(1000f, 0.13f),
				new Point(2000f, 0.14f),
				new Point(4000f, 0.15f)
			};
			material.transmission.points = new List<Point>
			{
				new Point(125f, 0.035f),
				new Point(250f, 0.0125f),
				new Point(500f, 0.0056f),
				new Point(1000f, 0.0025f),
				new Point(2000f, 0.0013f),
				new Point(4000f, 0.0032f)
			};
		}

		private static void PlasterOnBrick(ref ONSPPropagationMaterial material)
		{
			material.absorption.points = new List<Point>
			{
				new Point(125f, 0.01f),
				new Point(250f, 0.02f),
				new Point(500f, 0.02f),
				new Point(1000f, 0.03f),
				new Point(2000f, 0.04f),
				new Point(4000f, 0.05f)
			};
			material.scattering.points = new List<Point>
			{
				new Point(125f, 0.2f),
				new Point(250f, 0.25f),
				new Point(500f, 0.3f),
				new Point(1000f, 0.35f),
				new Point(2000f, 0.4f),
				new Point(4000f, 0.45f)
			};
			material.transmission.points = new List<Point>
			{
				new Point(125f, 0.025f),
				new Point(250f, 0.019f),
				new Point(500f, 0.01f),
				new Point(1000f, 0.0045f),
				new Point(2000f, 0.0018f),
				new Point(4000f, 0.00089f)
			};
		}

		private static void PlasterOnConcreteBlock(ref ONSPPropagationMaterial material)
		{
			material.absorption.points = new List<Point>
			{
				new Point(125f, 0.12f),
				new Point(250f, 0.09f),
				new Point(500f, 0.07f),
				new Point(1000f, 0.05f),
				new Point(2000f, 0.05f),
				new Point(4000f, 0.04f)
			};
			material.scattering.points = new List<Point>
			{
				new Point(125f, 0.2f),
				new Point(250f, 0.25f),
				new Point(500f, 0.3f),
				new Point(1000f, 0.35f),
				new Point(2000f, 0.4f),
				new Point(4000f, 0.45f)
			};
			material.transmission.points = new List<Point>
			{
				new Point(125f, 0.02f),
				new Point(250f, 0.01f),
				new Point(500f, 0.0063f),
				new Point(1000f, 0.0035f),
				new Point(2000f, 0.00011f),
				new Point(4000f, 0.00063f)
			};
		}

		private static void Soil(ref ONSPPropagationMaterial material)
		{
			material.absorption.points = new List<Point>
			{
				new Point(125f, 0.15f),
				new Point(250f, 0.25f),
				new Point(500f, 0.4f),
				new Point(1000f, 0.55f),
				new Point(2000f, 0.6f),
				new Point(4000f, 0.6f)
			};
			material.scattering.points = new List<Point>
			{
				new Point(125f, 0.1f),
				new Point(250f, 0.2f),
				new Point(500f, 0.25f),
				new Point(1000f, 0.4f),
				new Point(2000f, 0.55f),
				new Point(4000f, 0.7f)
			};
			material.transmission.points = new List<Point>();
		}

		private static void SoundProof(ref ONSPPropagationMaterial material)
		{
			material.absorption.points = new List<Point>
			{
				new Point(1000f, 1f)
			};
			material.scattering.points = new List<Point>
			{
				new Point(1000f)
			};
			material.transmission.points = new List<Point>();
		}

		private static void Snow(ref ONSPPropagationMaterial material)
		{
			material.absorption.points = new List<Point>
			{
				new Point(125f, 0.45f),
				new Point(250f, 0.75f),
				new Point(500f, 0.9f),
				new Point(1000f, 0.95f),
				new Point(2000f, 0.95f),
				new Point(4000f, 0.95f)
			};
			material.scattering.points = new List<Point>
			{
				new Point(125f, 0.2f),
				new Point(250f, 0.3f),
				new Point(500f, 0.4f),
				new Point(1000f, 0.5f),
				new Point(2000f, 0.6f),
				new Point(4000f, 0.75f)
			};
			material.transmission.points = new List<Point>();
		}

		private static void Steel(ref ONSPPropagationMaterial material)
		{
			material.absorption.points = new List<Point>
			{
				new Point(125f, 0.05f),
				new Point(250f, 0.1f),
				new Point(500f, 0.1f),
				new Point(1000f, 0.1f),
				new Point(2000f, 0.07f),
				new Point(4000f, 0.02f)
			};
			material.scattering.points = new List<Point>
			{
				new Point(125f, 0.1f),
				new Point(250f, 0.1f),
				new Point(500f, 0.1f),
				new Point(1000f, 0.1f),
				new Point(2000f, 0.1f),
				new Point(4000f, 0.1f)
			};
			material.transmission.points = new List<Point>
			{
				new Point(125f, 0.25f),
				new Point(250f, 0.2f),
				new Point(500f, 0.17f),
				new Point(1000f, 0.089f),
				new Point(2000f, 0.089f),
				new Point(4000f, 0.0056f)
			};
		}

		private static void Water(ref ONSPPropagationMaterial material)
		{
			material.absorption.points = new List<Point>
			{
				new Point(125f, 0.01f),
				new Point(250f, 0.01f),
				new Point(500f, 0.01f),
				new Point(1000f, 0.02f),
				new Point(2000f, 0.02f),
				new Point(4000f, 0.03f)
			};
			material.scattering.points = new List<Point>
			{
				new Point(125f, 0.1f),
				new Point(250f, 0.1f),
				new Point(500f, 0.1f),
				new Point(1000f, 0.07f),
				new Point(2000f, 0.05f),
				new Point(4000f, 0.05f)
			};
			material.transmission.points = new List<Point>
			{
				new Point(125f, 0.03f),
				new Point(250f, 0.03f),
				new Point(500f, 0.03f),
				new Point(1000f, 0.02f),
				new Point(2000f, 0.015f),
				new Point(4000f, 0.01f)
			};
		}

		private static void WoodThin(ref ONSPPropagationMaterial material)
		{
			material.absorption.points = new List<Point>
			{
				new Point(125f, 0.42f),
				new Point(250f, 0.21f),
				new Point(500f, 0.1f),
				new Point(1000f, 0.08f),
				new Point(2000f, 0.06f),
				new Point(4000f, 0.06f)
			};
			material.scattering.points = new List<Point>
			{
				new Point(125f, 0.1f),
				new Point(250f, 0.1f),
				new Point(500f, 0.1f),
				new Point(1000f, 0.1f),
				new Point(2000f, 0.1f),
				new Point(4000f, 0.15f)
			};
			material.transmission.points = new List<Point>
			{
				new Point(125f, 0.2f),
				new Point(250f, 0.125f),
				new Point(500f, 0.079f),
				new Point(1000f, 0.1f),
				new Point(2000f, 0.089f),
				new Point(4000f, 0.05f)
			};
		}

		private static void WoodThick(ref ONSPPropagationMaterial material)
		{
			material.absorption.points = new List<Point>
			{
				new Point(125f, 0.19f),
				new Point(250f, 0.14f),
				new Point(500f, 0.09f),
				new Point(1000f, 0.06f),
				new Point(2000f, 0.06f),
				new Point(4000f, 0.05f)
			};
			material.scattering.points = new List<Point>
			{
				new Point(125f, 0.1f),
				new Point(250f, 0.1f),
				new Point(500f, 0.1f),
				new Point(1000f, 0.1f),
				new Point(2000f, 0.1f),
				new Point(4000f, 0.15f)
			};
			material.transmission.points = new List<Point>
			{
				new Point(125f, 0.035f),
				new Point(250f, 0.028f),
				new Point(500f, 0.028f),
				new Point(1000f, 0.028f),
				new Point(2000f, 0.011f),
				new Point(4000f, 0.0071f)
			};
		}

		private static void WoodFloor(ref ONSPPropagationMaterial material)
		{
			material.absorption.points = new List<Point>
			{
				new Point(125f, 0.15f),
				new Point(250f, 0.11f),
				new Point(500f, 0.1f),
				new Point(1000f, 0.07f),
				new Point(2000f, 0.06f),
				new Point(4000f, 0.07f)
			};
			material.scattering.points = new List<Point>
			{
				new Point(125f, 0.1f),
				new Point(250f, 0.1f),
				new Point(500f, 0.1f),
				new Point(1000f, 0.1f),
				new Point(2000f, 0.1f),
				new Point(4000f, 0.15f)
			};
			material.transmission.points = new List<Point>
			{
				new Point(125f, 0.071f),
				new Point(250f, 0.025f),
				new Point(500f, 0.0158f),
				new Point(1000f, 0.0056f),
				new Point(2000f, 0.0035f),
				new Point(4000f, 0.0016f)
			};
		}

		private static void WoodOnConcrete(ref ONSPPropagationMaterial material)
		{
			material.absorption.points = new List<Point>
			{
				new Point(125f, 0.04f),
				new Point(250f, 0.04f),
				new Point(500f, 0.07f),
				new Point(1000f, 0.06f),
				new Point(2000f, 0.06f),
				new Point(4000f, 0.07f)
			};
			material.scattering.points = new List<Point>
			{
				new Point(125f, 0.1f),
				new Point(250f, 0.1f),
				new Point(500f, 0.1f),
				new Point(1000f, 0.1f),
				new Point(2000f, 0.1f),
				new Point(4000f, 0.15f)
			};
			material.transmission.points = new List<Point>
			{
				new Point(125f, 0.004f),
				new Point(250f, 0.0079f),
				new Point(500f, 0.0056f),
				new Point(1000f, 0.0016f),
				new Point(2000f, 0.0014f),
				new Point(4000f, 0.0005f)
			};
		}
	}
	public class ONSPPropagationSettings : MonoBehaviour
	{
		public float quality = 100f;

		private void Update()
		{
			ONSPPropagation.Interface.SetPropagationQuality(quality / 100f);
		}
	}
	public sealed class ONSPSettings : ScriptableObject
	{
		[SerializeField]
		public int voiceLimit = 64;

		private static ONSPSettings instance;

		public static ONSPSettings Instance
		{
			get
			{
				if (instance == null)
				{
					instance = Resources.Load<ONSPSettings>("ONSPSettings");
					if (instance == null)
					{
						instance = ScriptableObject.CreateInstance<ONSPSettings>();
					}
				}
				return instance;
			}
		}
	}
	public class ONSPVersion : MonoBehaviour
	{
		public const string strONSPS = "AudioPluginOculusSpatializer";

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern void ONSP_GetVersion(ref int Major, ref int Minor, ref int Patch);

		private void Awake()
		{
			int Major = 0;
			int Minor = 0;
			int Patch = 0;
			ONSP_GetVersion(ref Major, ref Minor, ref Patch);
			UnityEngine.Debug.Log($"ONSP Version: {Major:F0}.{Minor:F0}.{Patch:F0}");
		}

		private void Start()
		{
		}

		private void Update()
		{
		}
	}
	public class OculusSpatializerUnity : MonoBehaviour
	{
		public delegate void AudioRaycastCallback(Vector3 origin, Vector3 direction, out Vector3 point, out Vector3 normal, IntPtr data);

		public LayerMask layerMask = -1;

		public bool visualizeRoom = true;

		private bool roomVisualizationInitialized;

		public int raysPerSecond = 256;

		public float roomInterpSpeed = 0.9f;

		public float maxWallDistance = 50f;

		public int rayCacheSize = 512;

		public bool dynamicReflectionsEnabled = true;

		private float particleSize = 0.2f;

		private float particleOffset = 0.1f;

		private GameObject room;

		private Renderer[] wallRenderer = new Renderer[6];

		private float[] dims = new float[3] { 1f, 1f, 1f };

		private float[] coefs = new float[6];

		private const int HIT_COUNT = 2048;

		private Vector3[] points = new Vector3[2048];

		private Vector3[] normals = new Vector3[2048];

		private ParticleSystem sys;

		private ParticleSystem.Particle[] particles = new ParticleSystem.Particle[2048];

		private static LayerMask gLayerMask = -1;

		private const string strOSP = "AudioPluginOculusSpatializer";

		private static Vector3 swapHandedness(Vector3 vec)
		{
			return new Vector3(vec.x, vec.y, 0f - vec.z);
		}

		[MonoPInvokeCallback(typeof(AudioRaycastCallback))]
		private static void AudioRaycast(Vector3 origin, Vector3 direction, out Vector3 point, out Vector3 normal, IntPtr data)
		{
			point = Vector3.zero;
			normal = Vector3.zero;
			if (Physics.Raycast(swapHandedness(origin), swapHandedness(direction), out var hitInfo, 1000f, gLayerMask.value))
			{
				point = swapHandedness(hitInfo.point);
				normal = swapHandedness(hitInfo.normal);
			}
		}

		private void Start()
		{
			OSP_Unity_AssignRaycastCallback(AudioRaycast, IntPtr.Zero);
		}

		private void OnDestroy()
		{
			OSP_Unity_AssignRaycastCallback(IntPtr.Zero, IntPtr.Zero);
		}

		private void Update()
		{
			if (dynamicReflectionsEnabled)
			{
				OSP_Unity_AssignRaycastCallback(AudioRaycast, IntPtr.Zero);
			}
			else
			{
				OSP_Unity_AssignRaycastCallback(IntPtr.Zero, IntPtr.Zero);
			}
			OSP_Unity_SetDynamicRoomRaysPerSecond(raysPerSecond);
			OSP_Unity_SetDynamicRoomInterpSpeed(roomInterpSpeed);
			OSP_Unity_SetDynamicRoomMaxWallDistance(maxWallDistance);
			OSP_Unity_SetDynamicRoomRaysRayCacheSize(rayCacheSize);
			gLayerMask = layerMask;
			OSP_Unity_UpdateRoomModel(1f);
			if (!visualizeRoom)
			{
				return;
			}
			if (!roomVisualizationInitialized)
			{
				inititalizeRoomVisualization();
				roomVisualizationInitialized = true;
			}
			OSP_Unity_GetRoomDimensions(dims, coefs, out var position);
			position.z *= -1f;
			Vector3 vector = new Vector3(dims[0], dims[1], dims[2]);
			float sqrMagnitude = vector.sqrMagnitude;
			if (!float.IsNaN(sqrMagnitude) && 0f < sqrMagnitude && sqrMagnitude < 1000000f)
			{
				base.transform.localScale = vector * 0.999f;
			}
			base.transform.position = position;
			OSP_Unity_GetRaycastHits(points, normals, 2048);
			for (int i = 0; i < 2048; i++)
			{
				if (points[i] == Vector3.zero)
				{
					points[i].y = -10000f;
				}
				points[i].z *= -1f;
				normals[i].z *= -1f;
				particles[i].position = points[i] + normals[i] * particleOffset;
				if (normals[i] != Vector3.zero)
				{
					particles[i].rotation3D = Quaternion.LookRotation(normals[i]).eulerAngles;
				}
				particles[i].startSize = particleSize;
				particles[i].startColor = new Color(0.8156863f, 0.14901961f, 58f / 85f, 1f);
			}
			for (int j = 0; j < 6; j++)
			{
				Color value = Color.Lerp(Color.red, Color.green, coefs[j]);
				wallRenderer[j].material.SetColor("_TintColor", value);
			}
			sys.SetParticles(particles, particles.Length);
		}

		private void inititalizeRoomVisualization()
		{
			UnityEngine.Debug.Log("Oculus Audio dynamic room estimation visualization enabled");
			base.transform.position = Vector3.zero;
			GameObject gameObject = new GameObject("DecalManager");
			gameObject.transform.parent = base.transform;
			sys = gameObject.AddComponent<ParticleSystem>();
			ParticleSystem.MainModule main = sys.main;
			main.simulationSpace = ParticleSystemSimulationSpace.World;
			main.loop = false;
			main.playOnAwake = false;
			ParticleSystem.EmissionModule emission = sys.emission;
			emission.enabled = false;
			ParticleSystem.ShapeModule shape = sys.shape;
			shape.enabled = false;
			ParticleSystemRenderer component = sys.GetComponent<ParticleSystemRenderer>();
			component.renderMode = ParticleSystemRenderMode.Mesh;
			component.material.shader = Shader.Find("Particles/Additive");
			Texture2D texture2D = new Texture2D(64, 64);
			for (int i = 0; i < 32; i++)
			{
				for (int j = 0; j < 32; j++)
				{
					float num = 32 - i;
					float num2 = 32 - j;
					float num3 = Mathf.Sqrt(num * num + num2 * num2);
					float num4 = 2f * num3 / 32f;
					float a = ((num3 < 32f) ? Mathf.Clamp01(Mathf.Sin((float)Math.PI * 2f * num4)) : 0f);
					Color color = new Color(1f, 1f, 1f, a);
					texture2D.SetPixel(i, j, color);
					texture2D.SetPixel(64 - i, j, color);
					texture2D.SetPixel(i, 64 - j, color);
					texture2D.SetPixel(64 - i, 64 - j, color);
				}
			}
			texture2D.Apply();
			component.material.mainTexture = texture2D;
			Mesh mesh = new Mesh();
			mesh.name = "ParticleQuad";
			mesh.vertices = new Vector3[4]
			{
				new Vector3(-0.5f, -0.5f, 0f),
				new Vector3(0.5f, -0.5f, 0f),
				new Vector3(0.5f, 0.5f, 0f),
				new Vector3(-0.5f, 0.5f, 0f)
			};
			mesh.uv = new Vector2[4]
			{
				new Vector2(0f, 0f),
				new Vector2(0f, 1f),
				new Vector2(1f, 1f),
				new Vector2(1f, 0f)
			};
			mesh.triangles = new int[6] { 0, 1, 2, 0, 2, 3 };
			mesh.RecalculateNormals();
			component.mesh = mesh;
			sys.Emit(2048);
			room = new GameObject("RoomVisualizer");
			room.transform.parent = base.transform;
			room.transform.localPosition = Vector3.zero;
			Texture2D texture2D2 = new Texture2D(32, 32);
			Color color2 = new Color(0f, 0f, 0f, 0f);
			for (int k = 0; k < 32; k++)
			{
				for (int l = 0; l < 32; l++)
				{
					texture2D2.SetPixel(k, l, color2);
				}
			}
			for (int m = 0; m < 32; m++)
			{
				Color color3 = Color.white * 0.125f;
				texture2D2.SetPixel(8, m, color3);
				texture2D2.SetPixel(m, 8, color3);
				texture2D2.SetPixel(24, m, color3);
				texture2D2.SetPixel(m, 24, color3);
				color3 *= 2f;
				texture2D2.SetPixel(16, m, color3);
				texture2D2.SetPixel(m, 16, color3);
				color3 *= 2f;
				texture2D2.SetPixel(0, m, color3);
				texture2D2.SetPixel(m, 0, color3);
			}
			texture2D2.Apply();
			for (int n = 0; n < 6; n++)
			{
				Mesh mesh2 = new Mesh();
				mesh2.name = "Plane" + n;
				Vector3[] array = new Vector3[4];
				int num5 = n / 2;
				int num6 = ((n % 2 == 0) ? 1 : (-1));
				for (int num7 = 0; num7 < 4; num7++)
				{
					array[num7][num5] = (float)num6 * 0.5f;
					array[num7][(num5 + 1) % 3] = 0.5f * (float)((num7 == 1 || num7 == 2) ? 1 : (-1));
					array[num7][(num5 + 2) % 3] = 0.5f * (float)((num7 == 2 || num7 == 3) ? 1 : (-1));
				}
				mesh2.vertices = array;
				mesh2.uv = new Vector2[4]
				{
					new Vector2(0f, 0f),
					new Vector2(0f, 1f),
					new Vector2(1f, 1f),
					new Vector2(1f, 0f)
				};
				mesh2.triangles = new int[6] { 0, 1, 2, 0, 2, 3 };
				mesh2.RecalculateNormals();
				GameObject obj = new GameObject("Wall_" + n);
				obj.AddComponent<MeshFilter>().mesh = mesh2;
				MeshRenderer meshRenderer = obj.AddComponent<MeshRenderer>();
				wallRenderer[n] = meshRenderer;
				meshRenderer.material.shader = Shader.Find("Particles/Additive");
				meshRenderer.material.mainTexture = texture2D2;
				meshRenderer.material.mainTextureScale = new Vector2(8f, 8f);
				obj.transform.parent = room.transform;
				room.transform.localPosition = Vector3.zero;
			}
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int OSP_Unity_AssignRaycastCallback(AudioRaycastCallback callback, IntPtr data);

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int OSP_Unity_AssignRaycastCallback(IntPtr callback, IntPtr data);

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int OSP_Unity_SetDynamicRoomRaysPerSecond(int RaysPerSecond);

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int OSP_Unity_SetDynamicRoomInterpSpeed(float InterpSpeed);

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int OSP_Unity_SetDynamicRoomMaxWallDistance(float MaxWallDistance);

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int OSP_Unity_SetDynamicRoomRaysRayCacheSize(int RayCacheSize);

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int OSP_Unity_UpdateRoomModel(float wetLevel);

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int OSP_Unity_GetRoomDimensions(float[] roomDimensions, float[] reflectionsCoefs, out Vector3 position);

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int OSP_Unity_GetRaycastHits(Vector3[] points, Vector3[] normals, int length);
	}
	public struct ReflectionSnapshot
	{
		public AudioMixerSnapshot mixerSnapshot;

		public float fadeTime;
	}
	public class ONSPReflectionZone : MonoBehaviour
	{
		public AudioMixerSnapshot mixerSnapshot;

		public float fadeTime;

		private static Stack<ReflectionSnapshot> snapshotList = new Stack<ReflectionSnapshot>();

		private static ReflectionSnapshot currentSnapshot = default(ReflectionSnapshot);

		private void Start()
		{
		}

		private void Update()
		{
		}

		private void OnTriggerEnter(Collider other)
		{
			if (CheckForAudioListener(other.gameObject))
			{
				PushCurrentMixerShapshot();
			}
		}

		private void OnTriggerExit(Collider other)
		{
			if (CheckForAudioListener(other.gameObject))
			{
				PopCurrentMixerSnapshot();
			}
		}

		private bool CheckForAudioListener(GameObject gameObject)
		{
			if (gameObject.GetComponentInChildren<AudioListener>() != null)
			{
				return true;
			}
			return false;
		}

		private void PushCurrentMixerShapshot()
		{
			ReflectionSnapshot item = currentSnapshot;
			snapshotList.Push(item);
			SetReflectionValues();
		}

		private void PopCurrentMixerSnapshot()
		{
			ReflectionSnapshot mss = snapshotList.Pop();
			SetReflectionValues(ref mss);
		}

		private void SetReflectionValues()
		{
			if (mixerSnapshot != null)
			{
				UnityEngine.Debug.Log("Setting off snapshot " + mixerSnapshot.name);
				mixerSnapshot.TransitionTo(fadeTime);
				currentSnapshot.mixerSnapshot = mixerSnapshot;
				currentSnapshot.fadeTime = fadeTime;
			}
			else
			{
				UnityEngine.Debug.Log("Mixer snapshot not set - Please ensure play area has at least one encompassing snapshot.");
			}
		}

		private void SetReflectionValues(ref ReflectionSnapshot mss)
		{
			if (mss.mixerSnapshot != null)
			{
				UnityEngine.Debug.Log("Setting off snapshot " + mss.mixerSnapshot.name);
				mss.mixerSnapshot.TransitionTo(mss.fadeTime);
				currentSnapshot.mixerSnapshot = mss.mixerSnapshot;
				currentSnapshot.fadeTime = mss.fadeTime;
			}
			else
			{
				UnityEngine.Debug.Log("Mixer snapshot not set - Please ensure play area has at least one encompassing snapshot.");
			}
		}
	}
	public class AchievementSample : MonoBehaviour
	{
		public Text dataOutput;

		public InputField getDefinitionsByNameInputField;

		public InputField getProgressByNameInputField;

		public InputField unLockInputField;

		public InputField addCountInputField;

		public InputField addFieldsInputField;

		private void Start()
		{
			AchievementCore.RegisterNetwork();
		}

		private void OnDestroy()
		{
			AchievementCore.UnRegisterNetwork();
		}

		private void OnApplicationPause(bool pause)
		{
			if (!pause)
			{
				printOutputLine("Achievement Init");
				achievementInit();
			}
		}

		private void Update()
		{
			Request.RunCallbacks();
		}

		public void AsyncInitialize()
		{
			dataOutput.text = "> ";
			printOutputLine("AsyncInitialize");
			achievementInit();
		}

		public void GetDefinitionsByName()
		{
			dataOutput.text = "> ";
			printOutputLine("GetDefinitionsByName");
			string text = getDefinitionsByNameInputField.text;
			if (text != "")
			{
				string[] achievementNames = text.Split(',');
				getAchievementDefinition(achievementNames);
				getDefinitionsByNameInputField.text = "";
			}
			else
			{
				printOutputLine("Invalid Command");
			}
		}

		public void GetProgressByName()
		{
			dataOutput.text = "> ";
			printOutputLine("GetProgressByName");
			string text = getProgressByNameInputField.text;
			if (text != "")
			{
				string[] achievementNames = text.Split(',');
				getAchievementProgress(achievementNames);
				getProgressByNameInputField.text = "";
			}
			else
			{
				printOutputLine("Invalid Command");
			}
		}

		public void GetAllDefinitions()
		{
			dataOutput.text = "> ";
			printOutputLine("GetAllDefinitions");
			getAchievementAllDefinition();
		}

		public void GetAllProgress()
		{
			dataOutput.text = "> ";
			printOutputLine("GetAllProgress");
			getAchievementAllProgress();
		}

		public void UnLock()
		{
			dataOutput.text = "> ";
			printOutputLine("UnLock");
			string text = unLockInputField.text;
			if (text != "")
			{
				unlockAchievement(text);
				unLockInputField.text = "";
			}
			else
			{
				printOutputLine("Invalid Command");
			}
		}

		public void AddCount()
		{
			dataOutput.text = "> ";
			printOutputLine("AddCount");
			string text = addCountInputField.text;
			if (text != "")
			{
				string[] array = text.Split(',');
				if (array.Length > 1)
				{
					try
					{
						Convert.ToInt64(array[1]);
					}
					catch (Exception)
					{
						printOutputLine("Invalid Command");
						throw;
					}
					addCountAchievement(array[0], array[1]);
					addCountInputField.text = "";
				}
				else
				{
					printOutputLine("Invalid Command");
				}
			}
			else
			{
				printOutputLine("Invalid Command");
			}
		}

		public void AddFields()
		{
			dataOutput.text = "> ";
			printOutputLine("AddFields");
			string text = addFieldsInputField.text;
			if (text != "")
			{
				string[] array = text.Split(',');
				if (array.Length > 1)
				{
					addFieldsAchievement(array[0], array[1]);
					addFieldsInputField.text = "";
				}
				else
				{
					printOutputLine("Invalid Command");
				}
			}
			else
			{
				printOutputLine("Invalid Command");
			}
		}

		private void achievementInit()
		{
			Achievements.Init().OnComplete(initAchievementCallback);
		}

		private void getAchievementAllDefinition()
		{
			Achievements.GetAllDefinitions().OnComplete(achievementAllDefinitionCallback);
		}

		private void getAchievementAllProgress()
		{
			Achievements.GetAllProgress().OnComplete(achievementAllProgressCallback);
		}

		private void addFieldsAchievement(string achievementName, string fields)
		{
			Achievements.AddFields(achievementName, fields).OnComplete(achievementFieldsCallback);
		}

		private void addCountAchievement(string achievementName, string count)
		{
			Achievements.AddCount(achievementName, Convert.ToInt64(count)).OnComplete(achievementCountCallback);
		}

		private void unlockAchievement(string achievementName)
		{
			Achievements.Unlock(achievementName).OnComplete(achievementUnlockCallback);
		}

		private void getAchievementProgress(string[] achievementNames)
		{
			Achievements.GetProgressByName(achievementNames).OnComplete(achievementProgressCallback);
		}

		private void getAchievementDefinition(string[] achievementNames)
		{
			Achievements.GetDefinitionsByName(achievementNames).OnComplete(achievementDefinitionCallback);
		}

		private void printOutputLine(string newLine)
		{
			dataOutput.text = "> " + newLine + Environment.NewLine + dataOutput.text;
		}

		private void achievementAllDefinitionCallback(Pvr_Message<Pvr_AchievementDefinitionList> msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Received achievement definitions success");
				Pvr_AchievementDefinitionList achievementDefinitions = msg.GetAchievementDefinitions();
				if (achievementDefinitions.HasNextPage)
				{
					Achievements.GetNextAchievementDefinitionListPage(achievementDefinitions).OnComplete(achievementAllDefinitionCallback);
				}
				{
					foreach (Pvr_AchievementDefinition item in achievementDefinitions)
					{
						printOutputLine("Bitfield Name: " + item.Name.ToString());
						switch (item.Type)
						{
						case AchievementType.Simple:
							printOutputLine("Achievement Type: Simple");
							break;
						case AchievementType.Bitfield:
							printOutputLine("Achievement Type: Bitfield");
							printOutputLine("Bitfield Length: " + item.BitfieldLength);
							printOutputLine("Target: " + item.Target);
							break;
						case AchievementType.Count:
							printOutputLine("Achievement Type: Count");
							printOutputLine("Target: " + item.Target);
							break;
						default:
							printOutputLine("Achievement Type: Unknown");
							break;
						}
						printOutputLine("Bitfield Title: " + item.Title.ToString());
						printOutputLine("Bitfield Description: " + item.Description.ToString());
						printOutputLine("Bitfield UnlockedDescription: " + item.UnlockedDescription.ToString());
						printOutputLine("Bitfield UnlockedIcon: " + item.UnlockedIcon.ToString());
						printOutputLine("Bitfield LockedIcon: " + item.LockedIcon.ToString());
						printOutputLine("Bitfield IsSecrect: " + item.IsSecrect);
					}
					return;
				}
			}
			printOutputLine("Received achievement definitions error");
			Error error = msg.GetError();
			printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
		}

		private void achievementAllProgressCallback(Pvr_Message<Pvr_AchievementProgressList> msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Received achievement progress success");
				Pvr_AchievementProgressList achievementProgressList = msg.GetAchievementProgressList();
				if (achievementProgressList.HasNextPage)
				{
					Achievements.GetNextAchievementProgressListPage(achievementProgressList).OnComplete(achievementAllProgressCallback);
				}
				{
					foreach (Pvr_AchievementProgress item in achievementProgressList)
					{
						printOutputLine("Current Name: " + item.Name.ToString());
						if (item.IsUnlocked)
						{
							printOutputLine("Achievement Unlocked");
						}
						else
						{
							printOutputLine("Achievement Locked");
						}
						printOutputLine("Current Bitfield: " + item.Bitfield.ToString());
						printOutputLine("Current Count: " + item.Count);
						printOutputLine("Current UnlockTime: " + item.UnlockTime.ToString());
					}
					return;
				}
			}
			printOutputLine("Received achievement progress error");
			Error error = msg.GetError();
			printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
		}

		private void achievementFieldsCallback(Pvr_Message msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Achievement fields added.");
				return;
			}
			printOutputLine("Received achievement fields add error");
			Error error = msg.GetError();
			printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
		}

		private void achievementCountCallback(Pvr_Message msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Achievement count added.");
				return;
			}
			printOutputLine("Received achievement count add error");
			Error error = msg.GetError();
			printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
		}

		private void achievementUnlockCallback(Pvr_Message msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Achievement unlocked");
				return;
			}
			printOutputLine("Received achievement unlock error");
			Error error = msg.GetError();
			printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
		}

		private void achievementProgressCallback(Pvr_Message<Pvr_AchievementProgressList> msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Received achievement progress success");
				{
					foreach (Pvr_AchievementProgress achievementProgress in msg.GetAchievementProgressList())
					{
						if (achievementProgress.IsUnlocked)
						{
							printOutputLine("Achievement Unlocked");
						}
						else
						{
							printOutputLine("Achievement Locked");
						}
						printOutputLine("Current Bitfield: " + achievementProgress.Bitfield.ToString());
						printOutputLine("Current Count: " + achievementProgress.Count);
					}
					return;
				}
			}
			printOutputLine("Received achievement progress error");
			Error error = msg.GetError();
			printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
		}

		private void achievementDefinitionCallback(Pvr_Message<Pvr_AchievementDefinitionList> msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Received achievement definitions success");
				{
					foreach (Pvr_AchievementDefinition achievementDefinition in msg.GetAchievementDefinitions())
					{
						switch (achievementDefinition.Type)
						{
						case AchievementType.Simple:
							printOutputLine("Achievement Type: Simple");
							break;
						case AchievementType.Bitfield:
							printOutputLine("Achievement Type: Bitfield");
							printOutputLine("Bitfield Length: " + achievementDefinition.BitfieldLength);
							printOutputLine("Target: " + achievementDefinition.Target);
							break;
						case AchievementType.Count:
							printOutputLine("Achievement Type: Count");
							printOutputLine("Target: " + achievementDefinition.Target);
							break;
						default:
							printOutputLine("Achievement Type: Unknown");
							break;
						}
					}
					return;
				}
			}
			printOutputLine("Received achievement definitions error");
			Error error = msg.GetError();
			printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
		}

		private void initAchievementCallback(Pvr_Message msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Received init success");
				return;
			}
			printOutputLine("Received init error");
			Error error = msg.GetError();
			printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
		}

		private void LoginCallback(string LoginInfo)
		{
			UnityEngine.Debug.Log("Received loginCallback:" + LoginInfo);
			printOutputLine("Received loginCallback: " + LoginInfo);
		}
	}
	public class Pvr_Controller : MonoBehaviour
	{
		public enum UserHandNess
		{
			Right,
			Left
		}

		public enum GazeType
		{
			Never,
			DuringMotion,
			Always
		}

		public enum ControllerAxis
		{
			Controller,
			Wrist,
			Elbow,
			Shoulder
		}

		public GameObject controller0;

		public GameObject controller1;

		private static UserHandNess handness;

		public ControllerAxis Axis;

		public GazeType Gazetype;

		[Range(0f, 0.2f)]
		public float ElbowHeight;

		[Range(0f, 0.2f)]
		public float ElbowDepth;

		[Range(0f, 30f)]
		public float PointerTiltAngle = 15f;

		private float mouseX;

		private float mouseY;

		private float mouseZ;

		private Vector3[] inputDirection = new Vector3[2];

		public static Vector3 pointerPosition { get; set; }

		public static Quaternion pointerRotation { get; set; }

		public static Vector3 elbowPosition { get; set; }

		public static Quaternion elbowRotation { get; set; }

		public static Vector3 wristPosition { get; set; }

		public static Quaternion wristRotation { get; set; }

		public static Vector3 shoulderPosition { get; set; }

		public static Quaternion shoulderRotation { get; set; }

		private void Awake()
		{
			Pvr_ControllerManager.PvrServiceStartSuccessEvent += ServiceStartSuccess;
			Pvr_ControllerManager.SetControllerAbilityEvent += CheckControllerState;
			Pvr_ControllerManager.ChangeMainControllerCallBackEvent += MainControllerChanged;
			Pvr_ControllerManager.ChangeHandNessCallBackEvent += HandnessChanged;
		}

		private void Start()
		{
			handness = Controller.UPvr_GetHandNess();
			if (handness == (UserHandNess)(-1))
			{
				handness = UserHandNess.Right;
			}
		}

		private void OnDestroy()
		{
			Pvr_ControllerManager.PvrServiceStartSuccessEvent -= ServiceStartSuccess;
			Pvr_ControllerManager.SetControllerAbilityEvent -= CheckControllerState;
			Pvr_ControllerManager.ChangeMainControllerCallBackEvent -= MainControllerChanged;
			Pvr_ControllerManager.ChangeHandNessCallBackEvent -= HandnessChanged;
		}

		private void MainControllerChanged(string index)
		{
			RefreshHandness();
		}

		private void HandnessChanged(string index)
		{
			RefreshHandness();
		}

		private void ServiceStartSuccess()
		{
			RefreshHandness();
		}

		private void RefreshHandness()
		{
			handness = Controller.UPvr_GetHandNess();
			if (Controller.UPvr_GetMainHandNess() == 1)
			{
				ChangeHandNess();
			}
		}

		private void OnApplicationPause(bool pause)
		{
			if (!pause)
			{
				if (controller0 != null)
				{
					controller0.transform.localScale = Vector3.zero;
				}
				if (controller1 != null)
				{
					controller1.transform.localScale = Vector3.zero;
				}
			}
			Invoke("ShowController", 0.1f * Time.timeScale);
		}

		private void ShowController()
		{
			if (controller0 != null)
			{
				controller0.transform.localScale = Vector3.one;
			}
			if (controller1 != null)
			{
				controller1.transform.localScale = Vector3.one;
			}
		}

		private void CheckControllerState(string data)
		{
			bool num = Convert.ToBoolean(Convert.ToInt16(data.Substring(4, 1)));
			short num2 = Convert.ToInt16(data.Substring(0, 1));
			if (num && num2 == 1)
			{
				RefreshHandness();
			}
		}

		private void Update()
		{
			if (Pvr_UnitySDKManager.SDK.ControllerOnlyrot)
			{
				DoUpdateControler0();
				DoUpdateControler1();
				UpdateControlloerRay();
				return;
			}
			if (Controller.UPvr_GetPreferenceDevice() == 1)
			{
				DoUpdateControler0();
				DoUpdateControler1();
				UpdateControlloerRay();
				return;
			}
			if (controller0 != null)
			{
				controller0.transform.localRotation = Controller.UPvr_GetControllerQUA(0);
				controller0.transform.localPosition = Controller.UPvr_GetControllerPOS(0);
				UpdateControlloerRay(update0: true, update1: false);
			}
			if (controller1 != null)
			{
				controller1.transform.localRotation = Controller.UPvr_GetControllerQUA(1);
				controller1.transform.localPosition = Controller.UPvr_GetControllerPOS(1);
				UpdateControlloerRay(update0: false);
			}
		}

		public static void ChangeHandNess()
		{
			handness = ((handness == UserHandNess.Right) ? UserHandNess.Left : UserHandNess.Right);
		}

		private void DoUpdateControler0()
		{
			SetArmParaToSo((int)handness, (int)Gazetype, ElbowHeight, ElbowDepth, PointerTiltAngle);
			CalcArmModelfromSo(0);
			UpdateControllerDataSO(0);
		}

		private void DoUpdateControler1()
		{
			int hand = ((handness != UserHandNess.Left) ? 1 : 0);
			SetArmParaToSo(hand, (int)Gazetype, ElbowHeight, ElbowDepth, PointerTiltAngle);
			CalcArmModelfromSo(1);
			UpdateControllerDataSO(1);
		}

		private void UpdateControlloerRay(bool update0 = true, bool update1 = true)
		{
			if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
			{
				if (update0 && controller0 != null)
				{
					controller0.GetComponent<Pvr_ControllerModuleInit>().UpdateRay();
				}
				if (update1 && controller1 != null)
				{
					controller1.GetComponent<Pvr_ControllerModuleInit>().UpdateRay();
				}
			}
		}

		private Quaternion UpdateSimulatedFrameParams()
		{
			if (Input.GetKey(KeyCode.LeftShift))
			{
				mouseX += Input.GetAxis("Mouse X") * 5f;
				if (mouseX <= -180f)
				{
					mouseX += 360f;
				}
				else if (mouseX > 180f)
				{
					mouseX -= 360f;
				}
				mouseY -= Input.GetAxis("Mouse Y") * 2.4f;
				mouseY = Mathf.Clamp(mouseY, -80f, 80f);
			}
			else if (Input.GetKey(KeyCode.RightShift))
			{
				mouseZ += Input.GetAxis("Mouse X") * 5f;
				mouseZ = Mathf.Clamp(mouseZ, -80f, 80f);
			}
			return Quaternion.Euler(mouseY, mouseX, mouseZ);
		}

		private void SetArmParaToSo(int hand, int gazeType, float elbowHeight, float elbowDepth, float pointerTiltAngle)
		{
			Controller.UPvr_SetArmModelParameters(hand, gazeType, elbowHeight, elbowDepth, pointerTiltAngle);
		}

		private void CalcArmModelfromSo(int hand)
		{
			float[] array = new float[4];
			float[] array2 = new float[4];
			float[] array3 = new float[3];
			Quaternion quaternion = default(Quaternion);
			quaternion = Controller.UPvr_GetControllerQUA(hand);
			Vector3 vector = Controller.UPvr_GetAngularVelocity(hand);
			array2[0] = quaternion.x;
			array2[1] = quaternion.y;
			array2[2] = quaternion.z;
			array2[3] = quaternion.w;
			array3[0] = vector.x;
			array3[1] = vector.y;
			array3[2] = vector.z;
			if (Gazetype == GazeType.DuringMotion)
			{
				Vector3 b = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation * Vector3.forward;
				b.y = 0f;
				b.Normalize();
				float t = Mathf.Clamp((vector.magnitude - 0.2f) / 45f, 0f, 0.1f);
				inputDirection[hand] = Vector3.Slerp(inputDirection[hand], b, t);
				if (Controller.UPvr_GetKeyLongPressed(hand, Pvr_KeyCode.HOME))
				{
					inputDirection[hand] = default(Vector3);
				}
				Quaternion quaternion2 = Quaternion.FromToRotation(Vector3.forward, inputDirection[hand]);
				array[0] = quaternion2.x;
				array[1] = quaternion2.y;
				array[2] = quaternion2.z;
				array[3] = quaternion2.w;
			}
			else
			{
				array[0] = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.x;
				array[1] = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.y;
				array[2] = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.z;
				array[3] = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.w;
			}
			Controller.UPvr_CalcArmModelParameters(array, array2, array3);
		}

		public void UpdateControllerDataSO(int hand)
		{
			float[] array = new float[4];
			float[] array2 = new float[3];
			Vector3 vector;
			Quaternion localRotation;
			switch (Axis)
			{
			case ControllerAxis.Controller:
				Controller.UPvr_GetPointerPose(array, array2);
				pointerPosition = new Vector3(array2[0], array2[1], array2[2]);
				pointerRotation = new Quaternion(array[0], array[1], array[2], array[3]);
				vector = pointerPosition;
				localRotation = pointerRotation;
				break;
			case ControllerAxis.Wrist:
				Controller.UPvr_GetWristPose(array, array2);
				wristPosition = new Vector3(array2[0], array2[1], array2[2]);
				wristRotation = new Quaternion(array[0], array[1], array[2], array[3]);
				vector = wristPosition;
				localRotation = wristRotation;
				break;
			case ControllerAxis.Elbow:
				Controller.UPvr_GetElbowPose(array, array2);
				elbowPosition = new Vector3(array2[0], array2[1], array2[2]);
				elbowRotation = new Quaternion(array[0], array[1], array[2], array[3]);
				vector = elbowPosition;
				localRotation = elbowRotation;
				break;
			case ControllerAxis.Shoulder:
				Controller.UPvr_GetShoulderPose(array, array2);
				shoulderPosition = new Vector3(array2[0], array2[1], array2[2]);
				shoulderRotation = new Quaternion(array[0], array[1], array[2], array[3]);
				vector = shoulderPosition;
				localRotation = shoulderRotation;
				break;
			default:
				throw new Exception("Invalid FromJoint.");
			}
			if (hand == 0)
			{
				if (controller0 != null)
				{
					if (!Pvr_UnitySDKManager.SDK.HmdOnlyrot)
					{
						controller0.transform.localPosition = vector + Pvr_UnitySDKSensor.Instance.HeadPose.Position;
					}
					else if (Pvr_UnitySDKManager.SDK.TrackingOrigin == TrackingOrigin.FloorLevel)
					{
						controller0.transform.localPosition = vector + Pvr_UnitySDKSensor.Instance.HeadPose.Position;
					}
					else
					{
						controller0.transform.localPosition = vector;
					}
					controller0.transform.localRotation = localRotation;
				}
			}
			else if (controller1 != null)
			{
				if (!Pvr_UnitySDKManager.SDK.HmdOnlyrot)
				{
					controller1.transform.localPosition = vector + Pvr_UnitySDKSensor.Instance.HeadPose.Position;
				}
				else if (Pvr_UnitySDKManager.SDK.TrackingOrigin == TrackingOrigin.FloorLevel)
				{
					controller1.transform.localPosition = vector + Pvr_UnitySDKSensor.Instance.HeadPose.Position;
				}
				else
				{
					controller1.transform.localPosition = vector;
				}
				controller1.transform.localRotation = localRotation;
			}
		}
	}
	public class Pvr_ControllerDemo : MonoBehaviour
	{
		public GameObject HeadSetController;

		public GameObject controller0;

		public GameObject controller1;

		public GameObject cube;

		private Ray ray;

		private GameObject currentController;

		private Transform lastHit;

		private Transform currentHit;

		[SerializeField]
		private Material normat;

		[SerializeField]
		private Material gazemat;

		[SerializeField]
		private Material clickmat;

		private bool noClick;

		private GameObject referenceObj;

		public float rayDefaultLength = 4f;

		private bool isHasController;

		private bool headcontrolmode;

		private RaycastHit hit;

		private GameObject rayLine;

		private GameObject dot;

		private Transform dragObj;

		private float disX;

		private float disY;

		private float disZ;

		private void Start()
		{
			ray = default(Ray);
			hit = default(RaycastHit);
			if (Pvr_UnitySDKManager.SDK.isHasController)
			{
				Pvr_ControllerManager.PvrServiceStartSuccessEvent += ServiceStartSuccess;
				Pvr_ControllerManager.SetControllerStateChangedEvent += ControllerStateListener;
				Pvr_ControllerManager.ControllerStatusChangeEvent += CheckControllerStateForGoblin;
				isHasController = true;
			}
			referenceObj = new GameObject("ReferenceObj");
		}

		private void OnDestroy()
		{
			if (isHasController)
			{
				Pvr_ControllerManager.PvrServiceStartSuccessEvent -= ServiceStartSuccess;
				Pvr_ControllerManager.SetControllerStateChangedEvent -= ControllerStateListener;
				Pvr_ControllerManager.ControllerStatusChangeEvent -= CheckControllerStateForGoblin;
			}
		}

		private void Update()
		{
			if (HeadSetController.activeSelf)
			{
				HeadSetController.transform.parent.localRotation = Quaternion.Euler(Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.eulerAngles.x, Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.eulerAngles.y, 0f);
				HeadSetController.transform.parent.localPosition = Pvr_UnitySDKSensor.Instance.HeadPose.Position;
				ray.direction = HeadSetController.transform.position - HeadSetController.transform.parent.parent.Find("Head").position;
				ray.origin = HeadSetController.transform.parent.parent.Find("Head").position;
				if (Physics.Raycast(ray, out hit))
				{
					if (HeadSetController.name == "SightPointer")
					{
						HeadSetController.transform.localScale = new Vector3(0.09f, 0.09f, 0.09f);
					}
					currentHit = hit.transform;
					if (currentHit != null && lastHit != null && currentHit != lastHit && (bool)lastHit.GetComponent<Pvr_UIGraphicRaycaster>() && lastHit.transform.gameObject.activeInHierarchy && lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
					{
						lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = false;
					}
					if (currentHit != null && lastHit != null && currentHit == lastHit && (bool)currentHit.GetComponent<Pvr_UIGraphicRaycaster>() && !currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
					{
						currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = true;
					}
					if (1 << hit.transform.gameObject.layer == LayerMask.GetMask("Water") && !noClick)
					{
						hit.transform.GetComponent<Renderer>().material = gazemat;
					}
					lastHit = hit.transform;
					if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
					{
						HeadSetController.transform.position = hit.point;
						HeadSetController.transform.position -= (hit.point - HeadSetController.transform.parent.parent.Find("Head").position).normalized * 0.02f;
						float num = 0.008f * hit.distance / 4f;
						Mathf.Clamp(num, 0.002f, 0.008f);
						HeadSetController.transform.localScale = new Vector3(num, num, 1f);
					}
				}
				else
				{
					if (HeadSetController.name == "SightPointer")
					{
						HeadSetController.transform.localScale = Vector3.zero;
					}
					if (lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water"))
					{
						lastHit.transform.GetComponent<Renderer>().material = normat;
					}
					currentHit = null;
					noClick = false;
					if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
					{
						HeadSetController.transform.position = HeadSetController.transform.parent.parent.Find("Head").position + ray.direction.normalized * (0.5f + rayDefaultLength);
						HeadSetController.transform.localScale = new Vector3(0.008f, 0.008f, 1f);
					}
				}
				if ((Input.GetKeyDown(KeyCode.JoystickButton0) || Input.GetMouseButtonDown(0)) && lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water") && currentHit != null)
				{
					lastHit.transform.GetComponent<Renderer>().material = clickmat;
					noClick = true;
				}
				return;
			}
			if (currentController != null)
			{
				ray.direction = currentController.transform.forward - currentController.transform.up * 0.25f;
				ray.origin = currentController.transform.Find("start").position;
				if (Physics.Raycast(ray, out hit))
				{
					currentHit = hit.transform;
					if (currentHit != null && lastHit != null && currentHit != lastHit && (bool)lastHit.GetComponent<Pvr_UIGraphicRaycaster>() && lastHit.transform.gameObject.activeInHierarchy && lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
					{
						lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = false;
					}
					if (currentHit != null && lastHit != null && currentHit == lastHit && (bool)currentHit.GetComponent<Pvr_UIGraphicRaycaster>() && !currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
					{
						currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = true;
					}
					if (1 << hit.transform.gameObject.layer == LayerMask.GetMask("Water"))
					{
						if (!noClick)
						{
							hit.transform.GetComponent<Renderer>().material = gazemat;
						}
						if (Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TOUCHPAD) || Input.GetMouseButtonDown(0))
						{
							referenceObj.transform.position = hit.point;
							disX = hit.transform.position.x - referenceObj.transform.position.x;
							disY = hit.transform.position.y - referenceObj.transform.position.y;
							dragObj = hit.transform;
						}
						if ((Controller.UPvr_GetKey(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKey(1, Pvr_KeyCode.TOUCHPAD) || Input.GetMouseButton(0)) && hit.transform == dragObj.transform)
						{
							referenceObj.transform.position = new Vector3(hit.point.x, hit.point.y, hit.transform.position.z);
							dragObj.position = new Vector3(referenceObj.transform.position.x + disX, referenceObj.transform.position.y + disY, hit.transform.position.z);
						}
					}
					lastHit = hit.transform;
					currentController.transform.Find("dot").position = hit.point;
					if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
					{
						float num2 = 0.178f * currentController.transform.Find("dot").localPosition.z / 3.3f;
						Mathf.Clamp(num2, 0.05f, 0.178f);
						currentController.transform.Find("dot").localScale = new Vector3(num2, num2, 1f);
					}
				}
				else
				{
					if (lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water"))
					{
						lastHit.transform.GetComponent<Renderer>().material = normat;
					}
					currentHit = null;
					noClick = false;
					if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
					{
						currentController.transform.Find("dot").localScale = new Vector3(0.178f, 0.178f, 1f);
					}
				}
			}
			if ((Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TOUCHPAD) || Input.GetMouseButtonDown(0)) && lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water") && currentHit != null)
			{
				lastHit.transform.GetComponent<Renderer>().material = clickmat;
				noClick = true;
			}
		}

		private void ServiceStartSuccess()
		{
			if (Controller.UPvr_GetControllerState(0) == ControllerState.Connected || Controller.UPvr_GetControllerState(1) == ControllerState.Connected)
			{
				HeadSetController.SetActive(value: false);
			}
			else
			{
				HeadSetController.SetActive(value: true);
			}
			if (Controller.UPvr_GetMainHandNess() == 0)
			{
				currentController = controller0;
			}
			if (Controller.UPvr_GetMainHandNess() == 1)
			{
				currentController = controller1;
			}
		}

		private void ControllerStateListener(string data)
		{
			if (Controller.UPvr_GetControllerState(0) == ControllerState.Connected || Controller.UPvr_GetControllerState(1) == ControllerState.Connected)
			{
				HeadSetController.SetActive(value: false);
			}
			else
			{
				HeadSetController.SetActive(value: true);
			}
			if (Controller.UPvr_GetMainHandNess() == 0)
			{
				currentController = controller0;
			}
			if (Controller.UPvr_GetMainHandNess() == 1)
			{
				currentController = controller1;
			}
		}

		private void CheckControllerStateForGoblin(string state)
		{
			HeadSetController.SetActive(Convert.ToInt16(state) != 1);
		}

		public void SwitchControlMode()
		{
		}
	}
	public class Pvr_ControllerEventsExamples : MonoBehaviour
	{
		private void Start()
		{
			if (!(GetComponent<Pvr_UIPointer>() == null))
			{
				GetComponent<Pvr_UIPointer>().UIPointerElementEnter += UIPointerElementEnter;
				GetComponent<Pvr_UIPointer>().UIPointerElementExit += UIPointerElementExit;
				GetComponent<Pvr_UIPointer>().UIPointerElementClick += UIPointerElementClick;
				GetComponent<Pvr_UIPointer>().UIPointerElementDragStart += UIPointerElementDragStart;
				GetComponent<Pvr_UIPointer>().UIPointerElementDragEnd += UIPointerElementDragEnd;
			}
		}

		private void UIPointerElementEnter(object sender, UIPointerEventArgs e)
		{
			PLOG.I("UI Pointer entered" + e.currentTarget.name);
		}

		private void UIPointerElementExit(object sender, UIPointerEventArgs e)
		{
			PLOG.I("UI Pointer exited" + e.currentTarget.name);
		}

		private void UIPointerElementClick(object sender, UIPointerEventArgs e)
		{
			PLOG.I("UI Pointer clicked" + e.currentTarget.name);
		}

		private void UIPointerElementDragStart(object sender, UIPointerEventArgs e)
		{
			PLOG.I("UI Pointer started dragging" + e.currentTarget.name);
		}

		private void UIPointerElementDragEnd(object sender, UIPointerEventArgs e)
		{
			PLOG.I("UI Pointer stopped dragging" + e.currentTarget.name);
		}
	}
	public class Pvr_ControllerInit : MonoBehaviour
	{
		private ControllerVariety Variety;

		private bool isCustomModel;

		[SerializeField]
		private GameObject goblin;

		[SerializeField]
		private GameObject g2;

		[SerializeField]
		private GameObject neo2L;

		[SerializeField]
		private GameObject neo2R;

		[SerializeField]
		private GameObject neo3L;

		[SerializeField]
		private GameObject neo3R;

		[SerializeField]
		private Material standardMat;

		[SerializeField]
		private Material unlitMat;

		private int controllerType = -1;

		[HideInInspector]
		public bool loadModelSuccess;

		private int systemOrUnity;

		private JsonData curControllerData;

		private string modelName = "";

		private string texFormat = "";

		private string prePath = "";

		private string modelFilePath = "/system/media/PvrRes/controller/";

		private const string goblinTexbasePath = "Controller/controller1/controller1";

		private const string g2TexbasePath = "Controller/controller3/controller3";

		private const string neo2TexbasePath = "Controller/controller4/controller4";

		private const string neo3TexbasePath = "Controller/controller5/controller5";

		private void Awake()
		{
			Render.UPvr_GetIntConfig(15, ref systemOrUnity);
			Variety = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().Variety;
			isCustomModel = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().IsCustomModel;
			if (!isCustomModel)
			{
				Pvr_ControllerManager.PvrServiceStartSuccessEvent += ServiceStartSuccess;
				Pvr_ControllerManager.SetControllerAbilityEvent += CheckControllerStateOfAbility;
				Pvr_ControllerManager.ControllerStatusChangeEvent += CheckControllerStateForGoblin;
			}
		}

		private void OnDestroy()
		{
			Pvr_ControllerManager.PvrServiceStartSuccessEvent -= ServiceStartSuccess;
			Pvr_ControllerManager.SetControllerAbilityEvent -= CheckControllerStateOfAbility;
			Pvr_ControllerManager.ControllerStatusChangeEvent -= CheckControllerStateForGoblin;
		}

		private void OnApplicationPause(bool pause)
		{
			if (pause)
			{
				DestroyLocalController();
			}
		}

		private void ServiceStartSuccess()
		{
			int num = Controller.UPvr_GetDeviceType();
			if (controllerType != num && num != 0)
			{
				controllerType = num;
			}
			LoadResFromJson();
			if (Pvr_ControllerManager.controllerlink.neoserviceStarted)
			{
				if (Variety == ControllerVariety.Controller0)
				{
					if (Pvr_ControllerManager.controllerlink.controller0Connected)
					{
						StartCoroutine(RefreshController(0));
					}
					else
					{
						DestroyLocalController();
					}
				}
				if (Variety == ControllerVariety.Controller1)
				{
					if (Pvr_ControllerManager.controllerlink.controller1Connected)
					{
						StartCoroutine(RefreshController(1));
					}
					else
					{
						DestroyLocalController();
					}
				}
			}
			if (Pvr_ControllerManager.controllerlink.goblinserviceStarted && Variety == ControllerVariety.Controller0)
			{
				if (Pvr_ControllerManager.controllerlink.controller0Connected)
				{
					StartCoroutine(RefreshController(0));
				}
				else
				{
					DestroyLocalController();
				}
			}
		}

		private void LoadResFromJson()
		{
			string text = Pvr_UnitySDKAPI.System.UPvr_GetObjectOrArray("config.controller", 7);
			if (text != null)
			{
				JsonData jsonData = JsonMapper.ToObject(text);
				if (controllerType >= 0 && jsonData.Count >= controllerType)
				{
					curControllerData = jsonData[controllerType - 1];
					modelFilePath = (string)curControllerData["base_path"];
					modelName = (string)curControllerData["model_name"] + "_sys";
				}
			}
			else
			{
				PLOG.E("PvrLog LoadJsonFromSystem Error");
			}
		}

		private void CheckControllerStateForGoblin(string state)
		{
			int num = Controller.UPvr_GetDeviceType();
			if (Variety != 0)
			{
				return;
			}
			if (Convert.ToInt16(state) == 1)
			{
				if (controllerType != num)
				{
					DestroySysController();
					controllerType = num;
				}
				StartCoroutine(RefreshController(0));
			}
			else
			{
				DestroyLocalController();
			}
		}

		private void CheckControllerStateOfAbility(string data)
		{
			bool num = Convert.ToBoolean(Convert.ToInt16(data.Substring(4, 1)));
			short num2 = Convert.ToInt16(data.Substring(0, 1));
			int num3 = Controller.UPvr_GetDeviceType();
			if (num)
			{
				controllerType = num3;
				switch (num2)
				{
				case 0:
					if (Variety == ControllerVariety.Controller0)
					{
						StartCoroutine(RefreshController(0));
					}
					break;
				case 1:
					if (Variety == ControllerVariety.Controller1)
					{
						StartCoroutine(RefreshController(1));
					}
					break;
				}
				return;
			}
			switch (num2)
			{
			case 0:
				if (Variety == ControllerVariety.Controller0)
				{
					DestroyLocalController();
				}
				break;
			case 1:
				if (Variety == ControllerVariety.Controller1)
				{
					DestroyLocalController();
				}
				break;
			}
		}

		private void DestroyLocalController()
		{
			foreach (Transform item in base.transform)
			{
				UnityEngine.Object.Destroy(item.gameObject);
				loadModelSuccess = false;
			}
		}

		private void DestroySysController()
		{
			foreach (Transform item in base.transform)
			{
				if (item.name == modelName)
				{
					UnityEngine.Object.Destroy(item.gameObject);
					loadModelSuccess = false;
				}
			}
		}

		private IEnumerator RefreshController(int id)
		{
			yield return null;
			yield return null;
			if (Controller.UPvr_GetControllerState(id) != ControllerState.Connected)
			{
				yield break;
			}
			if (systemOrUnity == 0)
			{
				LoadControllerFromPrefab();
				if (!loadModelSuccess)
				{
					LoadControllerFromSystem(id);
				}
			}
			else
			{
				bool flag = false;
				foreach (Transform item in base.transform)
				{
					if (item.name == modelName)
					{
						flag = true;
					}
				}
				if (!flag)
				{
					LoadControllerFromSystem(id);
					if (!loadModelSuccess)
					{
						LoadControllerFromPrefab();
					}
				}
				else
				{
					base.transform.Find(modelName).gameObject.SetActive(value: true);
				}
			}
			Pvr_ToolTips.RefreshTips();
			PLOG.I("PvrLog Controller Refresh Success");
		}

		private void LoadControllerFromPrefab()
		{
			switch (controllerType)
			{
			case 1:
			{
				Pvr_ControllerVisual pvr_ControllerVisual3 = UnityEngine.Object.Instantiate(goblin, base.transform, worldPositionStays: false).AddComponent<Pvr_ControllerVisual>();
				pvr_ControllerVisual3.currentDevice = ControllerDevice.Goblin;
				LoadTexture(pvr_ControllerVisual3, "Controller/controller1/controller1", fromRes: true);
				loadModelSuccess = true;
				break;
			}
			case 3:
			{
				Pvr_ControllerVisual pvr_ControllerVisual2 = UnityEngine.Object.Instantiate(g2, base.transform, worldPositionStays: false).AddComponent<Pvr_ControllerVisual>();
				pvr_ControllerVisual2.currentDevice = ControllerDevice.G2;
				LoadTexture(pvr_ControllerVisual2, "Controller/controller3/controller3", fromRes: true);
				loadModelSuccess = true;
				break;
			}
			case 4:
			{
				Pvr_ControllerVisual pvr_ControllerVisual4 = UnityEngine.Object.Instantiate((Variety == ControllerVariety.Controller0) ? neo2L : neo2R, base.transform, worldPositionStays: false).AddComponent<Pvr_ControllerVisual>();
				pvr_ControllerVisual4.currentDevice = ControllerDevice.Neo2;
				LoadTexture(pvr_ControllerVisual4, "Controller/controller4/controller4", fromRes: true);
				loadModelSuccess = true;
				break;
			}
			case 5:
			{
				Pvr_ControllerVisual pvr_ControllerVisual = UnityEngine.Object.Instantiate((Variety == ControllerVariety.Controller0) ? neo3L : neo3R, base.transform, worldPositionStays: false).AddComponent<Pvr_ControllerVisual>();
				pvr_ControllerVisual.currentDevice = ControllerDevice.Neo3;
				LoadTexture(pvr_ControllerVisual, "Controller/controller5/controller5", fromRes: true);
				loadModelSuccess = true;
				break;
			}
			default:
				loadModelSuccess = false;
				break;
			}
		}

		private void LoadControllerFromSystem(int id)
		{
			string text = controllerType.ToString() + id + ".obj";
			string text2 = modelFilePath + text;
			if (!File.Exists(text2))
			{
				PLOG.I("PvrLog Obj File does not exist==" + text2);
				return;
			}
			GameObject gameObject = new GameObject();
			gameObject.name = modelName;
			gameObject.AddComponent<MeshFilter>().mesh = Pvr_ObjImporter.Instance.ImportFile(text2);
			gameObject.transform.SetParent(base.transform);
			gameObject.transform.localPosition = Vector3.zero;
			gameObject.AddComponent<MeshRenderer>().material = (((int)curControllerData["material_type"] == 0) ? standardMat : unlitMat);
			loadModelSuccess = true;
			Pvr_ControllerVisual pvr_ControllerVisual = gameObject.AddComponent<Pvr_ControllerVisual>();
			switch (controllerType)
			{
			case 1:
				pvr_ControllerVisual.currentDevice = ControllerDevice.Goblin;
				break;
			case 3:
				pvr_ControllerVisual.currentDevice = ControllerDevice.G2;
				break;
			case 4:
				pvr_ControllerVisual.currentDevice = ControllerDevice.Neo2;
				break;
			case 5:
				pvr_ControllerVisual.currentDevice = ControllerDevice.Neo3;
				break;
			default:
				pvr_ControllerVisual.currentDevice = ControllerDevice.NewController;
				break;
			}
			pvr_ControllerVisual.variety = Variety;
			LoadTexture(pvr_ControllerVisual, controllerType.ToString() + id, fromRes: false);
			gameObject.transform.localRotation = Quaternion.Euler(new Vector3(0f, 180f, 0f));
			gameObject.transform.localScale = new Vector3(-0.01f, 0.01f, 0.01f);
		}

		private void LoadTexture(Pvr_ControllerVisual visual, string controllerName, bool fromRes)
		{
			if (fromRes)
			{
				texFormat = "";
				prePath = controllerName;
			}
			else
			{
				texFormat = "." + (string)curControllerData["tex_format"];
				prePath = modelFilePath + controllerName;
			}
			string filepath = prePath + "_idle" + texFormat;
			visual.m_idle = LoadOneTexture(filepath, fromRes);
			filepath = prePath + "_app" + texFormat;
			visual.m_app = LoadOneTexture(filepath, fromRes);
			filepath = prePath + "_home" + texFormat;
			visual.m_home = LoadOneTexture(filepath, fromRes);
			filepath = prePath + "_touch" + texFormat;
			visual.m_touchpad = LoadOneTexture(filepath, fromRes);
			filepath = prePath + "_volume_down" + texFormat;
			visual.m_volDn = LoadOneTexture(filepath, fromRes);
			filepath = prePath + "_volume_up" + texFormat;
			visual.m_volUp = LoadOneTexture(filepath, fromRes);
			filepath = prePath + "_trigger" + texFormat;
			visual.m_trigger = LoadOneTexture(filepath, fromRes);
			filepath = prePath + "_a" + texFormat;
			visual.m_a = LoadOneTexture(filepath, fromRes);
			filepath = prePath + "_b" + texFormat;
			visual.m_b = LoadOneTexture(filepath, fromRes);
			filepath = prePath + "_x" + texFormat;
			visual.m_x = LoadOneTexture(filepath, fromRes);
			filepath = prePath + "_y" + texFormat;
			visual.m_y = LoadOneTexture(filepath, fromRes);
			filepath = prePath + "_grip" + texFormat;
			visual.m_grip = LoadOneTexture(filepath, fromRes);
		}

		private Texture2D LoadOneTexture(string filepath, bool fromRes)
		{
			if (fromRes)
			{
				return Resources.Load<Texture2D>(filepath);
			}
			int width = (int)curControllerData["tex_width"];
			int height = (int)curControllerData["tex_height"];
			Texture2D texture2D = new Texture2D(width, height);
			texture2D.LoadImage(ReadPNG(filepath));
			return texture2D;
		}

		private byte[] ReadPNG(string path)
		{
			FileStream fileStream = new FileStream(path, FileMode.Open, FileAccess.Read);
			fileStream.Seek(0L, SeekOrigin.Begin);
			byte[] array = new byte[fileStream.Length];
			fileStream.Read(array, 0, (int)fileStream.Length);
			fileStream.Close();
			fileStream.Dispose();
			fileStream = null;
			return array;
		}
	}
	public class Pvr_ControllerLink
	{
		public AndroidJavaClass javaHummingbirdClass;

		public AndroidJavaClass javaPico2ReceiverClass;

		public AndroidJavaClass javaserviceClass;

		public AndroidJavaClass javavractivityclass;

		public AndroidJavaClass javaCVClass;

		public AndroidJavaObject activity;

		public string gameobjname = "";

		public bool picoDevice;

		public string hummingBirdMac;

		public int hummingBirdRSSI;

		public bool goblinserviceStarted;

		public bool neoserviceStarted;

		public bool controller0Connected;

		public bool controller1Connected;

		public int mainHandID;

		public Pvr_Controller.UserHandNess handness;

		public int controllerType;

		public ControllerHand Controller0;

		public ControllerHand Controller1;

		public int platFormType = -1;

		public int trackingmode = -1;

		public int systemProp = -1;

		public int enablehand6dofbyhead = -1;

		public bool switchHomeKey = true;

		private int iPhoneHMDModeEnabled;

		private float[] hbPoseData = new float[4];

		private float[] sensorData = new float[28];

		private int[] keyData = new int[134];

		private int[] neo3TouchValue = new int[15];

		private float[] fixedState = new float[7] { 0f, 0f, 0f, 1f, 0f, 0f, 0f };

		private float[] neoposeData = new float[7] { 0f, 0f, 0f, 1f, 0f, 0f, 0f };

		private int[] goblinKeyArray = new int[47];

		private int[] neoKeyArray = new int[67];

		private int[] neotriggerV = new int[9];

		private float[] velocity = new float[3];

		private float[] angularVelocity = new float[3];

		private float[] acceData = new float[3];

		public Pvr_ControllerLink(string name)
		{
			gameobjname = name;
			hummingBirdMac = "";
			hummingBirdRSSI = 0;
			UnityEngine.Debug.Log("PvrLog Controller GameObject:" + gameobjname);
			StartHummingBirdService();
			Controller0 = new ControllerHand();
			Controller0.Position = new Vector3(0f, Pvr_UnitySDKSensor.Instance.HeadPose.Position.y, 0f) + new Vector3(-0.1f, -0.3f, 0.3f);
			Controller1 = new ControllerHand();
			Controller1.Position = new Vector3(0f, Pvr_UnitySDKSensor.Instance.HeadPose.Position.y, 0f) + new Vector3(0.1f, -0.3f, 0.3f);
		}

		private void StartHummingBirdService()
		{
			try
			{
				AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
				activity = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
				javaHummingbirdClass = new AndroidJavaClass("com.picovr.picovrlib.hummingbirdclient.HbClientActivity");
				javaCVClass = new AndroidJavaClass("com.picovr.picovrlib.cvcontrollerclient.ControllerClient");
				javavractivityclass = new AndroidJavaClass("com.psmart.vrlib.VrActivity");
				javaserviceClass = new AndroidJavaClass("com.picovr.picovrlib.hummingbirdclient.UnityClient");
				Pvr_UnitySDKAPI.System.Pvr_SetInitActivity(activity.GetRawObject(), javaHummingbirdClass.GetRawClass());
				Render.UPvr_GetIntConfig(4, ref platFormType);
				UnityEngine.Debug.Log("PvrLog platform" + platFormType);
				Render.UPvr_GetIntConfig(5, ref trackingmode);
				UnityEngine.Debug.Log("PvrLog trackingmode" + trackingmode);
				systemProp = GetSysproc();
				UnityEngine.Debug.Log("PvrLog systemProp" + systemProp);
				Render.UPvr_GetIntConfig(7, ref enablehand6dofbyhead);
				UnityEngine.Debug.Log("PvrLog enablehand6dofbyhead" + enablehand6dofbyhead);
				if (trackingmode == 0 || trackingmode == 1 || ((trackingmode == 3 || trackingmode == 5 || trackingmode == 6) && (systemProp == 1 || systemProp == 3)))
				{
					picoDevice = platFormType != 0;
					javaPico2ReceiverClass = new AndroidJavaClass("com.picovr.picovrlib.hummingbirdclient.HbClientReceiver");
					Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "startReceiver", activity, gameobjname);
					Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "setPlatformType", platFormType);
				}
				else
				{
					picoDevice = true;
					SetGameObjectToJar(gameobjname);
				}
				Render.UPvr_GetIntConfig(16, ref iPhoneHMDModeEnabled);
				if (iPhoneHMDModeEnabled == 1)
				{
					BindService();
				}
				else if (IsServiceExisted())
				{
					BindService();
				}
			}
			catch (AndroidJavaException ex)
			{
				PLOG.E("ConnectToAndriod--catch" + ex.Message);
			}
		}

		public bool IsServiceExisted()
		{
			bool result = false;
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaserviceClass, "isServiceExisted", activity, trackingmode);
			UnityEngine.Debug.Log("PvrLog ServiceExisted ?" + result);
			return result;
		}

		public void SetGameObjectToJar(string name)
		{
			UnityEngine.Debug.Log("PvrLog SetGameObjectToJar " + name);
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setGameObjectCallback", name);
		}

		public void BindService()
		{
			UnityEngine.Debug.Log("PvrLog Bind Service");
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaserviceClass, "bindService", activity, trackingmode);
		}

		public void UnBindService()
		{
			UnityEngine.Debug.Log("PvrLog UnBind Service");
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaserviceClass, "unbindService", activity, trackingmode);
		}

		public void StopLark2Receiver()
		{
			UnityEngine.Debug.Log("PvrLog StopLark2Receiver");
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "stopReceiver", activity);
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "stopOnBootReceiver", activity);
		}

		public void StartLark2Receiver()
		{
			UnityEngine.Debug.Log("PvrLog StartLark2Receiver");
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "startReceiver", activity, gameobjname);
		}

		public void StopLark2Service()
		{
			UnityEngine.Debug.Log("PvrLog StopLark2Service");
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "stopReceiver", activity);
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "unbindHbService", activity);
		}

		public void StartLark2Service()
		{
			UnityEngine.Debug.Log("PvrLog StartLark2Service");
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "startReceiver", activity, gameobjname);
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "bindHbService", activity);
		}

		public int getHandness()
		{
			int result = -1;
			if (iPhoneHMDModeEnabled == 0)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javavractivityclass, "getPvrHandness", activity);
			}
			else
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getHbHandednessInSP");
			}
			PLOG.I("PvrLog GetHandness =" + result);
			return result;
		}

		public void setHandness(int hand)
		{
			PLOG.I("PvrLog SetHandness =" + hand);
			if (iPhoneHMDModeEnabled == 1)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "setHbHandednessInSP", hand);
			}
		}

		public void StartScan()
		{
			PLOG.I("PvrLog ScanHBController");
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "scanHbDevice", true);
		}

		public void StopScan()
		{
			PLOG.I("PvrLog StopScanHBController");
			if (iPhoneHMDModeEnabled == 0)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "scanHbDevice", false);
			}
		}

		public int GetSysproc()
		{
			int result = -1;
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaserviceClass, "getSysproc");
			PLOG.I("PvrLog GetSysproc" + result);
			return result;
		}

		public void ResetController(int num)
		{
			UnityEngine.Debug.Log("PvrLog ResetController" + num);
			if (neoserviceStarted)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "resetControllerSensorState", num);
			}
			if (goblinserviceStarted)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "resetHbSensorState");
			}
		}

		public void ConnectBLE()
		{
			UnityEngine.Debug.Log("PvrLog ConnectHBController" + hummingBirdMac);
			if (hummingBirdMac != "")
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "connectHbController", hummingBirdMac);
			}
		}

		public void DisConnectBLE()
		{
			UnityEngine.Debug.Log("PvrLog DisConnectHBController");
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "disconnectHbController");
		}

		public bool StartUpgrade()
		{
			UnityEngine.Debug.Log("PvrLog StartUpgradeHBController");
			bool result = false;
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "startUpgrade");
			return result;
		}

		public void setBinPath(string path, bool isasset)
		{
			UnityEngine.Debug.Log("PvrLog setBinPath" + path + isasset);
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "setBinPath", path, isasset);
		}

		public string GetBLEImageType()
		{
			string result = "";
			if (goblinserviceStarted)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getBLEImageType");
			}
			UnityEngine.Debug.Log("PvrLog GetBLEImageType" + result);
			return result;
		}

		public long GetBLEVersion()
		{
			long result = 0L;
			if (goblinserviceStarted)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getBLEVersion");
			}
			UnityEngine.Debug.Log("PvrLog GetBLEVersion" + result);
			return result;
		}

		public string GetFileImageType()
		{
			string result = "";
			if (goblinserviceStarted)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getFileImageType");
			}
			UnityEngine.Debug.Log("PvrLog GetFileImageType" + result);
			return result;
		}

		public long GetFileVersion()
		{
			long result = 0L;
			if (goblinserviceStarted)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getFileVersion");
			}
			UnityEngine.Debug.Log("PvrLog GetFileVersion" + result);
			return result;
		}

		public int GetControllerConnectionState(int num)
		{
			int result = -1;
			if (neoserviceStarted)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerConnectionState", num);
			}
			if (goblinserviceStarted)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getHbConnectionState");
			}
			if (PLOG.logLevel > 2)
			{
				PLOG.D("PvrLog GetControllerState:" + num + "state:" + result);
			}
			return result;
		}

		public void RebackToLauncher()
		{
			UnityEngine.Debug.Log("PvrLog RebackToLauncher");
			if (neoserviceStarted)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startLauncher");
			}
			if (goblinserviceStarted)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "startLauncher");
			}
		}

		public void TurnUpVolume()
		{
			UnityEngine.Debug.Log("PvrLog TurnUpVolume");
			if (neoserviceStarted)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "turnUpVolume", activity);
			}
			if (goblinserviceStarted)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "turnUpVolume", activity);
			}
		}

		public void TurnDownVolume()
		{
			UnityEngine.Debug.Log("PvrLog TurnDownVolume");
			if (neoserviceStarted)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "turnDownVolume", activity);
			}
			if (goblinserviceStarted)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "turnDownVolume", activity);
			}
		}

		public float[] GetHBControllerPoseData()
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref hbPoseData, javaHummingbirdClass, "getHBSensorPose");
			if (PLOG.logLevel > 2)
			{
				PLOG.D("PvrLog HBControllerData" + hbPoseData[0] + "," + hbPoseData[1] + "," + hbPoseData[2] + "," + hbPoseData[3]);
			}
			return hbPoseData;
		}

		public float[] GetControllerSensorData()
		{
			if (enablehand6dofbyhead == 1)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref sensorData, javaCVClass, "getControllerDataInfoBySharmem", Pvr_UnitySDKManager.SDK.headData);
			}
			else
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref sensorData, javaCVClass, "getControllerDataInfoBySharmem");
			}
			return sensorData;
		}

		public int[] GetControllerKeyData()
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref keyData, javaCVClass, "getDoubleControllerKeyEventUnityExtBySharmem");
			return keyData;
		}

		public int[] GetNeo3TouchData(int hand)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neo3TouchValue, javaCVClass, "getControllerTouchEvent", hand);
			if (PLOG.logLevel > 2)
			{
				PLOG.D("PvrLog Neo3Touch hand:" + hand + "-" + neo3TouchValue[0] + neo3TouchValue[1] + neo3TouchValue[2] + neo3TouchValue[3] + neo3TouchValue[4] + "," + neo3TouchValue[5] + neo3TouchValue[6] + neo3TouchValue[7] + neo3TouchValue[8] + neo3TouchValue[9] + "," + neo3TouchValue[10] + neo3TouchValue[11] + neo3TouchValue[12] + neo3TouchValue[13] + neo3TouchValue[14]);
			}
			return neo3TouchValue;
		}

		public int GetNeo3GripValue(int hand)
		{
			int result = 0;
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerGripValue", hand);
			if (PLOG.logLevel > 2)
			{
				PLOG.D("PvrLog Neo3GripValue:" + result);
			}
			return result;
		}

		public float[] GetControllerFixedSensorState(int hand)
		{
			if (trackingmode == 2 || trackingmode == 3)
			{
				return fixedState;
			}
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref fixedState, javaCVClass, "getControllerFixedSensorState", hand);
			if (PLOG.logLevel > 2)
			{
				PLOG.D("PvrLog GetControllerFixedSensorState " + hand + "Rotation:" + fixedState[0] + "," + fixedState[1] + "," + fixedState[2] + "," + fixedState[3] + "Position:" + fixedState[4] + "," + fixedState[5] + "," + fixedState[6]);
			}
			return fixedState;
		}

		public float[] GetCvControllerPoseData(int hand)
		{
			if (enablehand6dofbyhead == 1)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neoposeData, javaCVClass, "getControllerSensorState", hand, Pvr_UnitySDKManager.SDK.headData);
			}
			else
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neoposeData, javaCVClass, "getControllerSensorState", hand);
			}
			if (PLOG.logLevel > 2)
			{
				PLOG.D("PvrLog CVControllerData :" + neoposeData[0] + "," + neoposeData[1] + "," + neoposeData[2] + "," + neoposeData[3] + "," + neoposeData[4] + "," + neoposeData[5] + "," + neoposeData[6]);
			}
			return neoposeData;
		}

		public int[] GetHBControllerKeyData()
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref goblinKeyArray, javaHummingbirdClass, "getHBKeyEventUnityExt");
			if (PLOG.logLevel > 2)
			{
				PLOG.D("PvrLog HBControllerKey" + goblinKeyArray[0] + goblinKeyArray[1] + goblinKeyArray[2] + goblinKeyArray[3] + goblinKeyArray[4] + "," + goblinKeyArray[5] + goblinKeyArray[6] + goblinKeyArray[7] + goblinKeyArray[8] + goblinKeyArray[9] + "," + goblinKeyArray[10] + goblinKeyArray[11] + goblinKeyArray[12] + goblinKeyArray[13] + goblinKeyArray[14] + "," + goblinKeyArray[15] + goblinKeyArray[16] + goblinKeyArray[17] + goblinKeyArray[18] + goblinKeyArray[19] + "," + goblinKeyArray[20] + goblinKeyArray[21] + goblinKeyArray[22] + goblinKeyArray[23] + goblinKeyArray[24] + "," + goblinKeyArray[25] + goblinKeyArray[26] + goblinKeyArray[27] + goblinKeyArray[28] + goblinKeyArray[29] + "," + goblinKeyArray[30] + goblinKeyArray[31] + goblinKeyArray[32] + goblinKeyArray[33] + goblinKeyArray[34] + "," + goblinKeyArray[35] + goblinKeyArray[36] + goblinKeyArray[37] + goblinKeyArray[38] + goblinKeyArray[39] + "," + goblinKeyArray[40] + goblinKeyArray[41] + goblinKeyArray[42] + goblinKeyArray[43] + goblinKeyArray[44] + "," + goblinKeyArray[45] + goblinKeyArray[46]);
			}
			return goblinKeyArray;
		}

		public int GetHBKeyValue()
		{
			int result = -1;
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getTriggerKeyEvent");
			if (PLOG.logLevel > 2)
			{
				PLOG.D("PvrLog GoblinControllerTriggerKey:" + result);
			}
			return result;
		}

		public int[] GetCvControllerKeyData(int hand)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neoKeyArray, javaCVClass, "getControllerKeyEventUnityExt", hand);
			if (PLOG.logLevel > 2)
			{
				PLOG.D("PvrLog CVControllerKey hand:" + hand + "-" + neoKeyArray[0] + neoKeyArray[1] + neoKeyArray[2] + neoKeyArray[3] + neoKeyArray[4] + "," + neoKeyArray[5] + neoKeyArray[6] + neoKeyArray[7] + neoKeyArray[8] + neoKeyArray[9] + "," + neoKeyArray[10] + neoKeyArray[11] + neoKeyArray[12] + neoKeyArray[13] + neoKeyArray[14] + "," + neoKeyArray[15] + neoKeyArray[16] + neoKeyArray[17] + neoKeyArray[18] + neoKeyArray[19] + "," + neoKeyArray[20] + neoKeyArray[21] + neoKeyArray[22] + neoKeyArray[23] + neoKeyArray[24] + "," + neoKeyArray[25] + neoKeyArray[26] + neoKeyArray[27] + neoKeyArray[28] + neoKeyArray[29] + "," + neoKeyArray[30] + neoKeyArray[31] + neoKeyArray[32] + neoKeyArray[33] + neoKeyArray[34] + "," + neoKeyArray[35] + neoKeyArray[36] + neoKeyArray[37] + neoKeyArray[38] + neoKeyArray[39] + "," + neoKeyArray[40] + neoKeyArray[41] + neoKeyArray[42] + neoKeyArray[43] + neoKeyArray[44] + "," + neoKeyArray[45] + neoKeyArray[46] + neoKeyArray[47] + neoKeyArray[48] + neoKeyArray[49] + "," + neoKeyArray[50] + neoKeyArray[51] + neoKeyArray[52] + neoKeyArray[53] + neoKeyArray[54] + "," + neoKeyArray[55] + neoKeyArray[56] + neoKeyArray[57] + neoKeyArray[58] + neoKeyArray[59] + "," + neoKeyArray[60] + neoKeyArray[61] + neoKeyArray[62] + neoKeyArray[63] + neoKeyArray[64] + "," + neoKeyArray[65] + neoKeyArray[66]);
			}
			return neoKeyArray;
		}

		public int GetCVTriggerValue(int hand)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neotriggerV, javaCVClass, "getControllerKeyEvent", hand);
			if (PLOG.logLevel > 2)
			{
				PLOG.D("PvrLog CVTriggerValue " + neotriggerV[7]);
			}
			return neotriggerV[7];
		}

		public void AutoConnectHbController(int scanTimeMs)
		{
			PLOG.I("PvrLog AutoConnectHbController" + scanTimeMs);
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "autoConnectHbController", scanTimeMs, gameobjname);
		}

		public void StartControllerThread(int headSensorState, int handSensorState)
		{
			if (BoundarySystem.UPvr_IsBoundaryEnable())
			{
				headSensorState = 1;
				handSensorState = 1;
			}
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startControllerThread", headSensorState, handSensorState);
			UnityEngine.Debug.Log("PvrLog StartControllerThread" + headSensorState + handSensorState);
		}

		public void StopControllerThread(int headSensorState, int handSensorState)
		{
			if (BoundarySystem.UPvr_IsBoundaryEnable())
			{
				headSensorState = 1;
				handSensorState = 1;
			}
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "stopControllerThread", headSensorState, handSensorState);
			UnityEngine.Debug.Log("PvrLog StopControllerThread" + headSensorState + handSensorState);
		}

		public void SetUnityVersionToJar(string version)
		{
			if (trackingmode == 4 || trackingmode == 5 || trackingmode == 6)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setUnityVersion", version);
			}
			UnityEngine.Debug.Log("PvrLog SetUnityVersionToJar" + version);
		}

		public Vector3 GetVelocity(int num)
		{
			if (neoserviceStarted)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref velocity, javaCVClass, "getControllerLinearVelocity", num);
			}
			if (PLOG.logLevel > 2)
			{
				PLOG.D("PvrLog Velocity" + velocity[0] + "," + velocity[1] + "," + velocity[2]);
			}
			return new Vector3(velocity[0], velocity[1], 0f - velocity[2]);
		}

		public Vector3 GetAngularVelocity(int num)
		{
			if (neoserviceStarted)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref angularVelocity, javaCVClass, "getControllerAngularVelocity", num);
			}
			if (goblinserviceStarted)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref angularVelocity, javaHummingbirdClass, "getHbAngularVelocity");
			}
			if (PLOG.logLevel > 2)
			{
				PLOG.D("PvrLog Gyro:" + angularVelocity[0] + "," + angularVelocity[1] + "," + angularVelocity[2]);
			}
			return new Vector3(0f, 0f, 0f);
		}

		public Vector3 GetAcceleration(int num)
		{
			if (neoserviceStarted)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref acceData, javaCVClass, "getControllerAcceleration", num);
			}
			if (goblinserviceStarted)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref acceData, javaHummingbirdClass, "getHbAcceleration");
			}
			if (PLOG.logLevel > 2)
			{
				PLOG.D("PvrLog Acce:" + acceData[0] + acceData[1] + acceData[2]);
			}
			return new Vector3(0f, 0f, 0f);
		}

		public string GetConnectedDeviceMac()
		{
			string result = "";
			if (goblinserviceStarted)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getConnectedDeviceMac");
			}
			PLOG.I("PvrLog ConnectedDeviceMac:" + result);
			return result;
		}

		public void VibrateNeo2Controller(float strength, int time, int hand)
		{
			if (neoserviceStarted)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "vibrateCV2ControllerStrength", strength, time, hand);
			}
			PLOG.I("PvrLog VibrateNeo2Controller:" + strength + time + hand);
		}

		public int GetMainControllerIndex()
		{
			int result = 0;
			if (neoserviceStarted)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getMainControllerIndex");
			}
			PLOG.I("PvrLog GetMainControllerIndex:" + result);
			return result;
		}

		public void SetMainController(int index)
		{
			PLOG.I("PvrLog SetMainController:" + index);
			if (neoserviceStarted)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setMainController", index);
			}
		}

		public void ResetHeadSensorForController()
		{
			if (neoserviceStarted)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "resetHeadSensorForController");
			}
			PLOG.I("PvrLog ResetHeadSensorForController:");
		}

		public void GetDeviceVersion(int deviceType)
		{
			if (neoserviceStarted)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "getDeviceVersion", deviceType);
			}
			PLOG.I("PvrLog GetDeviceVersion:" + deviceType);
		}

		public void GetControllerSnCode(int controllerSerialNum)
		{
			if (neoserviceStarted)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "getControllerSnCode", controllerSerialNum);
			}
			PLOG.I("PvrLog GetControllerSnCode:" + controllerSerialNum);
		}

		public void SetControllerUnbind(int controllerSerialNum)
		{
			if (neoserviceStarted)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setControllerUnbind", controllerSerialNum);
			}
			PLOG.I("PvrLog SetControllerUnbind:" + controllerSerialNum);
		}

		public void SetStationRestart()
		{
			if (neoserviceStarted)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setStationRestart");
			}
			PLOG.I("PvrLog SetStationRestart");
		}

		public void StartStationOtaUpdate()
		{
			if (neoserviceStarted)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startStationOtaUpdate");
			}
			PLOG.I("PvrLog StartStationOtaUpdate");
		}

		public void StartControllerOtaUpdate(int mode, int controllerSerialNum)
		{
			if (neoserviceStarted)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startControllerOtaUpdate", mode, controllerSerialNum);
			}
			PLOG.I("PvrLog StartControllerOtaUpdate" + mode + controllerSerialNum);
		}

		public void EnterPairMode(int controllerSerialNum)
		{
			if (neoserviceStarted)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "enterPairMode", controllerSerialNum);
			}
			PLOG.I("PvrLog EnterPairMode" + controllerSerialNum);
		}

		public void SetControllerShutdown(int controllerSerialNum)
		{
			if (neoserviceStarted)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setControllerShutdown", controllerSerialNum);
			}
			PLOG.I("PvrLog SetControllerShutdown" + controllerSerialNum);
		}

		public int GetStationPairState()
		{
			int result = -1;
			if (neoserviceStarted)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getStationPairState");
			}
			PLOG.I("PvrLog StationPairState" + result);
			return result;
		}

		public int GetStationOtaUpdateProgress()
		{
			int result = -1;
			if (neoserviceStarted)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getStationOtaUpdateProgress");
			}
			PLOG.I("PvrLog StationOtaUpdateProgress" + result);
			return result;
		}

		public int GetControllerOtaUpdateProgress()
		{
			int result = -1;
			if (neoserviceStarted)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerOtaUpdateProgress");
			}
			PLOG.I("PvrLog ControllerOtaUpdateProgress" + result);
			return result;
		}

		public void GetControllerVersionAndSN(int controllerSerialNum)
		{
			if (neoserviceStarted)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "getControllerVersionAndSN", controllerSerialNum);
			}
			PLOG.I("PvrLog GetControllerVersionAndSN" + controllerSerialNum);
		}

		public void GetControllerUniqueID()
		{
			if (neoserviceStarted)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "getControllerUniqueID");
			}
			PLOG.I("PvrLog GetControllerUniqueID");
		}

		public void InterruptStationPairMode()
		{
			if (neoserviceStarted)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "interruptStationPairMode");
			}
			PLOG.I("PvrLog InterruptStationPairMode");
		}

		public int GetControllerAbility(int controllerSerialNum)
		{
			int result = -1;
			if (neoserviceStarted)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerAbility", controllerSerialNum);
			}
			PLOG.I("PvrLog ControllerAbility:" + result);
			return result;
		}

		public void SwitchHomeKey(bool state)
		{
			PLOG.I("PvrLog SwitchHomeKey:" + state);
			switchHomeKey = state;
		}

		public void SetBootReconnect()
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "setBootReconnect");
			PLOG.I("PvrLog SetBootReconnect");
		}

		public int GetTemperature()
		{
			int result = -1;
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getTemperature");
			PLOG.I("PvrLog Temperature:" + result);
			return result;
		}

		public int GetDeviceType()
		{
			int result = -1;
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getDeviceType");
			PLOG.I("PvrLog DeviceType:" + result);
			return result;
		}

		public int GetControllerType()
		{
			int result = -1;
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getControllerType");
			return result;
		}

		public string GetHummingBird2SN()
		{
			string result = "";
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getHummingBird2SN");
			PLOG.I("PvrLog HummingBird2SN:" + result);
			return result;
		}

		public string GetControllerVersion()
		{
			string result = "";
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getControllerVersion");
			PLOG.I("PvrLog ControllerVersion:" + result);
			return result;
		}

		public bool IsEnbleTrigger()
		{
			bool result = false;
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "isEnbleTrigger");
			PLOG.I("PvrLog IsEnbleTrigger:" + result);
			return result;
		}

		public void StartCV2PairingMode(int devicetype)
		{
			if (neoserviceStarted)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startCV2PairingMode", devicetype);
			}
			PLOG.I("PvrLog StartCV2PairingMode:" + devicetype);
		}

		public void StopCV2PairingMode(int devicetype)
		{
			if (neoserviceStarted)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "stopCV2PairingMode", devicetype);
			}
			PLOG.I("PvrLog StopCV2PairingMode:" + devicetype);
		}

		public int GetControllerBindingState(int id)
		{
			int result = -1;
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerBindingState", id);
			PLOG.I("PvrLog getControllerBindingState:" + result);
			return result;
		}

		public void setIsEnbleHomeKey(bool state)
		{
			if (neoserviceStarted)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setIsEnbleHomeKey", state);
			}
			PLOG.I("PvrLog setIsEnbleHomeKey:" + state);
		}

		public int getControllerSensorStatus(int id)
		{
			int result = -1;
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerSensorStatus", id);
			PLOG.I("PvrLog getControllerSensorStatus:" + result);
			return result;
		}
	}
	public class Pvr_ControllerManager : MonoBehaviour
	{
		public delegate void PvrServiceStartSuccess();

		public delegate void PvrControllerStateChanged(string data);

		public delegate void ChangeMainControllerCallBack(string index);

		public delegate void ChangeHandNessCallBack(string index);

		public delegate void SetHbServiceBindState();

		public delegate void ControllerThreadStartedCallback();

		public delegate void SetControllerServiceBindState();

		public delegate void ControllerStatusChange(string isconnect);

		public delegate void SetControllerAbility(string data);

		public delegate void SetControllerStateChanged(string data);

		public delegate void SetHbControllerMac(string mac);

		public delegate void ControllerDeviceVersionCallback(string data);

		public delegate void ControllerSnCodeCallback(string data);

		public delegate void ControllerUnbindCallback(string status);

		public delegate void ControllerStationStatusCallback(string status);

		public delegate void ControllerStationBusyCallback(string status);

		public delegate void ControllerOtaStartCodeCallback(string data);

		public delegate void ControllerDeviceVersionAndSNCallback(string data);

		public delegate void ControllerUniqueIDCallback(string data);

		public delegate void ControllerCombinedKeyUnbindCallback(string data);

		private static Pvr_ControllerManager instance;

		public static Pvr_ControllerLink controllerlink;

		private float cTime = 1f;

		private bool stopConnect;

		public Text toast;

		private bool controllerServicestate;

		private float disConnectTime;

		public bool LengthAdaptiveRay;

		private float[] sensorData = new float[28];

		private int[] keyData = new int[134];

		private float[] g2SensorData = new float[4];

		private int[] g2KeyData = new int[47];

		private int keyOffset;

		private int rotControllerMode = 1;

		public static Pvr_ControllerManager Instance
		{
			get
			{
				if (instance == null)
				{
					instance = UnityEngine.Object.FindObjectOfType<Pvr_ControllerManager>();
				}
				if (instance == null)
				{
					GameObject obj = new GameObject("GameObject");
					instance = obj.AddComponent<Pvr_ControllerManager>();
					obj.transform.localPosition = Vector3.zero;
				}
				return instance;
			}
		}

		public static event PvrServiceStartSuccess PvrServiceStartSuccessEvent;

		public static event PvrControllerStateChanged PvrControllerStateChangedEvent;

		public static event ChangeMainControllerCallBack ChangeMainControllerCallBackEvent;

		public static event ChangeHandNessCallBack ChangeHandNessCallBackEvent;

		public static event SetHbServiceBindState SetHbServiceBindStateEvent;

		public static event ControllerThreadStartedCallback ControllerThreadStartedCallbackEvent;

		public static event SetControllerServiceBindState SetControllerServiceBindStateEvent;

		public static event ControllerStatusChange ControllerStatusChangeEvent;

		public static event SetControllerAbility SetControllerAbilityEvent;

		public static event SetControllerStateChanged SetControllerStateChangedEvent;

		public static event SetHbControllerMac SetHbControllerMacEvent;

		public static event ControllerDeviceVersionCallback ControllerDeviceVersionCallbackEvent;

		public static event ControllerSnCodeCallback ControllerSnCodeCallbackEvent;

		public static event ControllerUnbindCallback ControllerUnbindCallbackEvent;

		public static event ControllerStationStatusCallback ControllerStationStatusCallbackEvent;

		public static event ControllerStationBusyCallback ControllerStationBusyCallbackEvent;

		public static event ControllerOtaStartCodeCallback ControllerOtaStartCodeCallbackEvent;

		public static event ControllerDeviceVersionAndSNCallback ControllerDeviceVersionAndSNCallbackEvent;

		public static event ControllerUniqueIDCallback ControllerUniqueIDCallbackEvent;

		public static event ControllerCombinedKeyUnbindCallback ControllerCombinedKeyUnbindCallbackEvent;

		private void Awake()
		{
			if (instance == null)
			{
				instance = this;
			}
			if (instance != this)
			{
				PLOG.E("instance object should be a singleton.");
				return;
			}
			if (controllerlink == null)
			{
				controllerlink = new Pvr_ControllerLink(base.gameObject.name);
				return;
			}
			controllerlink.SetGameObjectToJar(base.gameObject.name);
			BindService();
		}

		private void Start()
		{
			if (controllerlink.trackingmode < 2)
			{
				Invoke("CheckControllerService", 10f);
			}
			Render.UPvr_GetIntConfig(23, ref rotControllerMode);
		}

		private void Update()
		{
			if (controllerlink.neoserviceStarted)
			{
				sensorData = controllerlink.GetControllerSensorData();
				keyData = controllerlink.GetControllerKeyData();
				if (controllerlink.controller0Connected)
				{
					if (Pvr_UnitySDKManager.SDK.ShowVideoSeethrough)
					{
						sensorData[2] = 0f - sensorData[2];
						sensorData[3] = 0f - sensorData[3];
						controllerlink.Controller0.Rotation.Set(sensorData[0], sensorData[1], sensorData[2], sensorData[3]);
						if (rotControllerMode == 0)
						{
							controllerlink.Controller0.Rotation *= Quaternion.Euler(34f, 0f, 0f);
						}
						controllerlink.Controller0.Position.Set(sensorData[4] / 1000f, sensorData[5] / 1000f, (0f - sensorData[6]) / 1000f);
					}
					else
					{
						controllerlink.Controller0.Rotation.Set(sensorData[7], sensorData[8], sensorData[9], sensorData[10]);
						if (rotControllerMode == 0)
						{
							controllerlink.Controller0.Rotation *= Quaternion.Euler(34f, 0f, 0f);
						}
						controllerlink.Controller0.Position.Set(sensorData[11] / 1000f, sensorData[12] / 1000f, (0f - sensorData[13]) / 1000f);
					}
					if (!controllerlink.Controller0.isShowBoundary)
					{
						if (controllerlink.getControllerSensorStatus(0) == 0)
						{
							Sensor.UPvr_SetReinPosition(sensorData[0], sensorData[1], sensorData[2], sensorData[3], sensorData[4], sensorData[5], sensorData[6], 0, valid: false, 0);
						}
						else
						{
							controllerlink.Controller0.isShowBoundary = true;
							Sensor.UPvr_SetReinPosition(sensorData[0], sensorData[1], sensorData[2], sensorData[3], sensorData[4], sensorData[5], sensorData[6], 0, valid: true, Convert.ToInt32(Convert.ToString(keyData[35]) + Convert.ToString(keyData[15]) + "00", 2));
						}
					}
					else
					{
						Sensor.UPvr_SetReinPosition(sensorData[0], sensorData[1], sensorData[2], sensorData[3], sensorData[4], sensorData[5], sensorData[6], 0, valid: true, Convert.ToInt32(Convert.ToString(keyData[35]) + Convert.ToString(keyData[15]) + "00", 2));
					}
					TransformData(controllerlink.Controller0, 0, keyData);
				}
				else
				{
					Sensor.UPvr_SetReinPosition(sensorData[0], sensorData[1], sensorData[2], sensorData[3], sensorData[4], sensorData[5], sensorData[6], 0, valid: false, 0);
				}
				if (controllerlink.controller1Connected)
				{
					if (Pvr_UnitySDKManager.SDK.ShowVideoSeethrough)
					{
						sensorData[16] = 0f - sensorData[16];
						sensorData[17] = 0f - sensorData[17];
						controllerlink.Controller1.Rotation.Set(sensorData[14], sensorData[15], sensorData[16], sensorData[17]);
						if (rotControllerMode == 0)
						{
							controllerlink.Controller1.Rotation *= Quaternion.Euler(34f, 0f, 0f);
						}
						controllerlink.Controller1.Position.Set(sensorData[18] / 1000f, sensorData[19] / 1000f, (0f - sensorData[20]) / 1000f);
					}
					else
					{
						controllerlink.Controller1.Rotation.Set(sensorData[21], sensorData[22], sensorData[23], sensorData[24]);
						if (rotControllerMode == 0)
						{
							controllerlink.Controller1.Rotation *= Quaternion.Euler(34f, 0f, 0f);
						}
						controllerlink.Controller1.Position.Set(sensorData[25] / 1000f, sensorData[26] / 1000f, (0f - sensorData[27]) / 1000f);
					}
					if (!controllerlink.Controller1.isShowBoundary)
					{
						if (controllerlink.getControllerSensorStatus(1) == 0)
						{
							Sensor.UPvr_SetReinPosition(sensorData[14], sensorData[15], sensorData[16], sensorData[17], sensorData[18], sensorData[19], sensorData[20], 1, valid: false, 0);
						}
						else
						{
							controllerlink.Controller1.isShowBoundary = true;
							Sensor.UPvr_SetReinPosition(sensorData[14], sensorData[15], sensorData[16], sensorData[17], sensorData[18], sensorData[19], sensorData[20], 1, valid: true, Convert.ToInt32(Convert.ToString(keyData[102]) + Convert.ToString(keyData[82]) + "00", 2));
						}
					}
					else
					{
						Sensor.UPvr_SetReinPosition(sensorData[14], sensorData[15], sensorData[16], sensorData[17], sensorData[18], sensorData[19], sensorData[20], 1, valid: true, Convert.ToInt32(Convert.ToString(keyData[102]) + Convert.ToString(keyData[82]) + "00", 2));
					}
					TransformData(controllerlink.Controller1, 1, keyData);
				}
				else
				{
					Sensor.UPvr_SetReinPosition(sensorData[14], sensorData[15], sensorData[16], sensorData[17], sensorData[18], sensorData[19], sensorData[20], 1, valid: false, 0);
				}
			}
			if (controllerlink.goblinserviceStarted && controllerlink.controller0Connected)
			{
				g2SensorData = controllerlink.GetHBControllerPoseData();
				controllerlink.Controller0.Rotation.Set(g2SensorData[0], g2SensorData[1], g2SensorData[2], g2SensorData[3]);
				g2KeyData = controllerlink.GetHBControllerKeyData();
				TransformData(controllerlink.Controller0, 0, g2KeyData);
			}
			SetSystemKey();
		}

		private void OnApplicationPause(bool pause)
		{
			int headSensorState = ((!Pvr_UnitySDKManager.SDK.HmdOnlyrot) ? 1 : 0);
			int handSensorState = ((!Pvr_UnitySDKManager.SDK.ControllerOnlyrot) ? 1 : 0);
			if (pause)
			{
				if (controllerlink.neoserviceStarted)
				{
					controllerlink.SetGameObjectToJar("");
					controllerlink.StopControllerThread(headSensorState, handSensorState);
				}
				if (controllerlink.goblinserviceStarted)
				{
					controllerlink.StopLark2Receiver();
				}
				return;
			}
			controllerlink.Controller0 = new ControllerHand();
			controllerlink.Controller1 = new ControllerHand();
			if (controllerlink.neoserviceStarted)
			{
				controllerlink.SetGameObjectToJar(base.gameObject.name);
				controllerlink.SetUnityVersionToJar("2.8.9.12");
				controllerlink.StartControllerThread(headSensorState, handSensorState);
			}
			if (controllerlink.goblinserviceStarted)
			{
				controllerlink.StartLark2Receiver();
				controllerlink.controller0Connected = GetControllerConnectionState(0) == 1;
				controllerlink.controllerType = controllerlink.GetControllerType();
				controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
				if (Pvr_ControllerManager.PvrServiceStartSuccessEvent != null)
				{
					Pvr_ControllerManager.PvrServiceStartSuccessEvent();
				}
			}
		}

		private void OnDestroy()
		{
			controllerlink.UnBindService();
			Sensor.UPvr_SetReinPosition(0f, 0f, 0f, 1f, 0f, 0f, 0f, 0, valid: false, 0);
			Sensor.UPvr_SetReinPosition(0f, 0f, 0f, 1f, 0f, 0f, 0f, 1, valid: false, 0);
		}

		private void OnApplicationQuit()
		{
			int headSensorState = ((!Pvr_UnitySDKManager.SDK.HmdOnlyrot) ? 1 : 0);
			int handSensorState = ((!Pvr_UnitySDKManager.SDK.ControllerOnlyrot) ? 1 : 0);
			if (controllerlink.neoserviceStarted)
			{
				controllerlink.SetGameObjectToJar("");
				controllerlink.StopControllerThread(headSensorState, handSensorState);
			}
		}

		public void StopLark2Service()
		{
			if (controllerlink != null)
			{
				controllerlink.StopLark2Service();
			}
		}

		public Vector3 GetAngularVelocity(int num)
		{
			if (controllerlink != null)
			{
				return controllerlink.GetAngularVelocity(num);
			}
			return new Vector3(0f, 0f, 0f);
		}

		public Vector3 GetAcceleration(int num)
		{
			if (controllerlink != null)
			{
				return controllerlink.GetAcceleration(num);
			}
			return new Vector3(0f, 0f, 0f);
		}

		public void BindService()
		{
			if (controllerlink != null)
			{
				controllerlink.BindService();
			}
		}

		public void StartScan()
		{
			if (controllerlink != null)
			{
				controllerlink.StartScan();
			}
		}

		public void StopScan()
		{
			if (controllerlink != null)
			{
				controllerlink.StopScan();
			}
		}

		public void ResetController(int num)
		{
			if (controllerlink != null)
			{
				controllerlink.ResetController(num);
			}
		}

		public static int GetControllerConnectionState(int num)
		{
			return controllerlink.GetControllerConnectionState(num);
		}

		public void ConnectBLE()
		{
			if (controllerlink != null)
			{
				controllerlink.ConnectBLE();
			}
		}

		public void DisConnectBLE()
		{
			if (controllerlink != null)
			{
				controllerlink.DisConnectBLE();
			}
		}

		public void SetBinPath(string path, bool isAsset)
		{
			if (controllerlink != null)
			{
				controllerlink.setBinPath(path, isAsset);
			}
		}

		public void StartUpgrade()
		{
			if (controllerlink != null)
			{
				controllerlink.StartUpgrade();
			}
		}

		public static string GetBLEImageType()
		{
			return controllerlink.GetBLEImageType();
		}

		public static long GetBLEVersion()
		{
			return controllerlink.GetBLEVersion();
		}

		public static string GetFileImageType()
		{
			return controllerlink.GetFileImageType();
		}

		public static long GetFileVersion()
		{
			return controllerlink.GetFileVersion();
		}

		public static void AutoConnectHbController(int scans)
		{
			if (controllerlink != null)
			{
				controllerlink.AutoConnectHbController(scans);
			}
		}

		public static string GetConnectedDeviceMac()
		{
			string result = "";
			if (controllerlink != null)
			{
				result = controllerlink.GetConnectedDeviceMac();
			}
			return result;
		}

		public void setHbControllerMac(string mac)
		{
			PLOG.I("PvrLog HBMacRSSI" + mac);
			controllerlink.hummingBirdMac = mac.Substring(0, 17);
			controllerlink.hummingBirdRSSI = Convert.ToInt16(mac.Remove(0, 18));
			if (Pvr_ControllerManager.SetHbControllerMacEvent != null)
			{
				Pvr_ControllerManager.SetHbControllerMacEvent(mac.Substring(0, 17));
			}
		}

		public int GetControllerRSSI()
		{
			return controllerlink.hummingBirdRSSI;
		}

		public void setHbServiceBindState(string state)
		{
			PLOG.I("PvrLog HBBindCallBack" + state);
			controllerServicestate = true;
			if (Convert.ToInt16(state) == 0)
			{
				Invoke("BindService", 0.5f);
				controllerlink.goblinserviceStarted = false;
			}
			else if (Convert.ToInt16(state) == 1)
			{
				controllerlink.goblinserviceStarted = true;
				controllerlink.controller0Connected = GetControllerConnectionState(0) == 1;
				controllerlink.controllerType = controllerlink.GetControllerType();
				controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
				if (Pvr_ControllerManager.SetHbServiceBindStateEvent != null)
				{
					Pvr_ControllerManager.SetHbServiceBindStateEvent();
				}
				if (Pvr_ControllerManager.PvrServiceStartSuccessEvent != null)
				{
					Pvr_ControllerManager.PvrServiceStartSuccessEvent();
				}
			}
		}

		public void setControllerServiceBindState(string state)
		{
			PLOG.I("PvrLog CVBindCallBack" + state);
			if (Convert.ToInt16(state) == 0)
			{
				Invoke("BindService", 0.5f);
				controllerlink.neoserviceStarted = false;
			}
			else if (Convert.ToInt16(state) == 1)
			{
				controllerlink.SetUnityVersionToJar("2.8.9.12");
				controllerlink.neoserviceStarted = true;
				int headSensorState = ((!Pvr_UnitySDKManager.SDK.HmdOnlyrot) ? 1 : 0);
				int handSensorState = ((!Pvr_UnitySDKManager.SDK.ControllerOnlyrot) ? 1 : 0);
				controllerlink.StartControllerThread(headSensorState, handSensorState);
				if (Pvr_ControllerManager.SetControllerServiceBindStateEvent != null)
				{
					Pvr_ControllerManager.SetControllerServiceBindStateEvent();
				}
			}
		}

		public void setHbControllerConnectState(string isconnect)
		{
			PLOG.I("PvrLog HBControllerConnect" + isconnect);
			controllerlink.controller0Connected = Convert.ToInt16(isconnect) == 1;
			if (!controllerlink.controller0Connected)
			{
				controllerlink.Controller0 = new ControllerHand();
			}
			else
			{
				ResetController(0);
				controllerlink.controllerType = controllerlink.GetControllerType();
				controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
			}
			stopConnect = false;
			if (Pvr_ControllerManager.ControllerStatusChangeEvent != null)
			{
				Pvr_ControllerManager.ControllerStatusChangeEvent(isconnect);
			}
			if (Pvr_ControllerManager.PvrControllerStateChangedEvent != null)
			{
				Pvr_ControllerManager.PvrControllerStateChangedEvent(isconnect);
			}
		}

		public void setControllerStateChanged(string state)
		{
			PLOG.I("PvrLog CVControllerStateChanged" + state);
			int num = Convert.ToInt16(state.Substring(0, 1));
			if (num == 0)
			{
				controllerlink.controller0Connected = Convert.ToBoolean(Convert.ToInt16(state.Substring(2, 1)));
				if (!controllerlink.controller0Connected)
				{
					controllerlink.Controller0 = new ControllerHand();
					controllerlink.Controller0.Position = new Vector3(0f, Pvr_UnitySDKSensor.Instance.HeadPose.Position.y, 0f) + new Vector3(-0.1f, -0.3f, 0.3f);
				}
			}
			else
			{
				controllerlink.controller1Connected = Convert.ToBoolean(Convert.ToInt16(state.Substring(2, 1)));
				if (!controllerlink.controller1Connected)
				{
					controllerlink.Controller1 = new ControllerHand();
					controllerlink.Controller1.Position = new Vector3(0f, Pvr_UnitySDKSensor.Instance.HeadPose.Position.y, 0f) + new Vector3(0.1f, -0.3f, 0.3f);
				}
			}
			if (Convert.ToBoolean(Convert.ToInt16(state.Substring(2, 1))))
			{
				controllerlink.controllerType = controllerlink.GetControllerType();
				controllerlink.ResetController(num);
			}
			controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
			controllerlink.mainHandID = controllerlink.GetMainControllerIndex();
			if (Pvr_ControllerManager.SetControllerStateChangedEvent != null)
			{
				Pvr_ControllerManager.SetControllerStateChangedEvent(state);
			}
			if (Pvr_ControllerManager.PvrControllerStateChangedEvent != null)
			{
				Pvr_ControllerManager.PvrControllerStateChangedEvent(state);
			}
		}

		public void setControllerAbility(string data)
		{
			PLOG.I("PvrLog setControllerAbility" + data);
			if (Pvr_ControllerManager.SetControllerAbilityEvent != null)
			{
				Pvr_ControllerManager.SetControllerAbilityEvent(data);
			}
		}

		public void controllerThreadStartedCallback()
		{
			PLOG.I("PvrLog ThreadStartSuccess");
			GetCVControllerState();
			if (Pvr_ControllerManager.ControllerThreadStartedCallbackEvent != null)
			{
				Pvr_ControllerManager.ControllerThreadStartedCallbackEvent();
			}
			if (Pvr_ControllerManager.PvrServiceStartSuccessEvent != null)
			{
				Pvr_ControllerManager.PvrServiceStartSuccessEvent();
			}
		}

		public void controllerDeviceVersionCallback(string data)
		{
			PLOG.I("PvrLog VersionCallBack" + data);
			if (Pvr_ControllerManager.ControllerDeviceVersionCallbackEvent != null)
			{
				Pvr_ControllerManager.ControllerDeviceVersionCallbackEvent(data);
			}
		}

		public void controllerSnCodeCallback(string data)
		{
			PLOG.I("PvrLog SNCodeCallBack" + data);
			if (Pvr_ControllerManager.ControllerSnCodeCallbackEvent != null)
			{
				Pvr_ControllerManager.ControllerSnCodeCallbackEvent(data);
			}
		}

		public void controllerUnbindCallback(string status)
		{
			PLOG.I("PvrLog ControllerUnBindCallBack" + status);
			if (Pvr_ControllerManager.ControllerUnbindCallbackEvent != null)
			{
				Pvr_ControllerManager.ControllerUnbindCallbackEvent(status);
			}
		}

		public void controllerStationStatusCallback(string status)
		{
			PLOG.I("PvrLog StationStatusCallBack" + status);
			if (Pvr_ControllerManager.ControllerStationStatusCallbackEvent != null)
			{
				Pvr_ControllerManager.ControllerStationStatusCallbackEvent(status);
			}
		}

		public void controllerStationBusyCallback(string status)
		{
			PLOG.I("PvrLog StationBusyCallBack" + status);
			if (Pvr_ControllerManager.ControllerStationBusyCallbackEvent != null)
			{
				Pvr_ControllerManager.ControllerStationBusyCallbackEvent(status);
			}
		}

		public void controllerOTAStartCodeCallback(string data)
		{
			PLOG.I("PvrLog OTAUpdateCallBack" + data);
			if (Pvr_ControllerManager.ControllerOtaStartCodeCallbackEvent != null)
			{
				Pvr_ControllerManager.ControllerOtaStartCodeCallbackEvent(data);
			}
		}

		public void controllerDeviceVersionAndSNCallback(string data)
		{
			PLOG.I("PvrLog DeviceVersionAndSNCallback" + data);
			if (Pvr_ControllerManager.ControllerDeviceVersionAndSNCallbackEvent != null)
			{
				Pvr_ControllerManager.ControllerDeviceVersionAndSNCallbackEvent(data);
			}
		}

		public void controllerUniqueIDCallback(string data)
		{
			PLOG.I("PvrLog controllerUniqueIDCallback" + data);
			if (Pvr_ControllerManager.ControllerUniqueIDCallbackEvent != null)
			{
				Pvr_ControllerManager.ControllerUniqueIDCallbackEvent(data);
			}
		}

		public void controllerCombinedKeyUnbindCallback(string controllerSerialNum)
		{
			if (Pvr_ControllerManager.ControllerCombinedKeyUnbindCallbackEvent != null)
			{
				Pvr_ControllerManager.ControllerCombinedKeyUnbindCallbackEvent(controllerSerialNum);
			}
		}

		public void setupdateFailed()
		{
		}

		public void setupdateSuccess()
		{
		}

		public void setupdateProgress(string progress)
		{
		}

		public void setHbAutoConnectState(string state)
		{
			PLOG.I("PvrLog HBAutoConnectState" + state);
			controllerServicestate = true;
			if (Convert.ToInt16(state) == 0 && GetControllerConnectionState(0) == 0)
			{
				ShowToast(2);
			}
			if (Convert.ToInt16(state) == 2)
			{
				ShowToast(3);
			}
		}

		public void callbackControllerServiceState(string state)
		{
			PLOG.I("PvrLog HBServiceState" + state);
			controllerServicestate = true;
			if (Convert.ToInt16(state) == 0)
			{
				ShowToast(0);
			}
			if (Convert.ToInt16(state) == 1)
			{
				BindService();
			}
			if (Convert.ToInt16(state) == 2)
			{
				ShowToast(1);
			}
		}

		public void changeMainControllerCallback(string index)
		{
			PLOG.I("PvrLog MainControllerCallBack" + index);
			controllerlink.mainHandID = Convert.ToInt16(index);
			if (Pvr_ControllerManager.ChangeMainControllerCallBackEvent != null)
			{
				Pvr_ControllerManager.ChangeMainControllerCallBackEvent(index);
			}
		}

		public void changeHandnessCallback(string index)
		{
			PLOG.I("PvrLog changeHandnessCallback" + index);
			controllerlink.handness = (Pvr_Controller.UserHandNess)Convert.ToInt16(index);
			if (Pvr_ControllerManager.ChangeHandNessCallBackEvent != null)
			{
				Pvr_ControllerManager.ChangeHandNessCallBackEvent(index);
			}
		}

		private void ShowToast(int type)
		{
			if (toast != null)
			{
				switch (type)
				{
				case 0:
					toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip0");
					Invoke("HideToast", 5f);
					break;
				case 1:
					toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip1");
					Invoke("HideToast", 5f);
					break;
				case 2:
					toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip2");
					AutoConnectHbController(6000);
					Invoke("HideToast", 5f);
					break;
				case 3:
					toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip3");
					AutoConnectHbController(6000);
					Invoke("HideToast", 5f);
					break;
				case 4:
					toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip4");
					Invoke("HideToast", 10f);
					break;
				}
			}
		}

		private void HideToast()
		{
			if (toast != null)
			{
				toast.text = "";
			}
		}

		private void CheckControllerService()
		{
			if (!controllerServicestate)
			{
				ShowToast(4);
			}
		}

		private void GetCVControllerState()
		{
			int controllerConnectionState = GetControllerConnectionState(0);
			int controllerConnectionState2 = GetControllerConnectionState(1);
			PLOG.I("PvrLog CVconnect" + controllerConnectionState + controllerConnectionState2);
			if (controllerConnectionState == -1 && controllerConnectionState2 == -1)
			{
				Invoke("GetCVControllerState", 0.02f);
			}
			if (controllerConnectionState != -1 && controllerConnectionState2 != -1)
			{
				controllerlink.controller0Connected = controllerConnectionState == 1;
				controllerlink.controller1Connected = controllerConnectionState2 == 1;
				if (!controllerlink.controller0Connected && controllerlink.controller1Connected && controllerlink.GetMainControllerIndex() == 0)
				{
					Controller.UPvr_SetMainHandNess(1);
				}
				if (controllerlink.controller0Connected || controllerlink.controller1Connected)
				{
					controllerlink.controllerType = controllerlink.GetControllerType();
				}
				controllerlink.mainHandID = controllerlink.GetMainControllerIndex();
				controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
			}
		}

		private void SetSystemKey()
		{
			if (controllerlink.switchHomeKey && (Controller.UPvr_GetKeyLongPressed(0, Pvr_KeyCode.HOME) || Controller.UPvr_GetKeyLongPressed(1, Pvr_KeyCode.HOME)))
			{
				if (Pvr_UnitySDKManager.SDK.HmdOnlyrot)
				{
					Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 0);
				}
				else if (controllerlink.trackingmode == 0 || controllerlink.trackingmode == 1)
				{
					Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
				}
				else
				{
					Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
				}
				if (Pvr_UnitySDKManager.SDK.ControllerOnlyrot || (controllerlink.controller0Connected && Controller.UPvr_GetControllerPOS(0).Equals(Vector3.zero)) || (controllerlink.controller1Connected && Controller.UPvr_GetControllerPOS(1).Equals(Vector3.zero)))
				{
					if (Controller.UPvr_GetKeyLongPressed(0, Pvr_KeyCode.HOME))
					{
						ResetController(0);
					}
					if (Controller.UPvr_GetKeyLongPressed(1, Pvr_KeyCode.HOME))
					{
						ResetController(1);
					}
				}
			}
			if (controllerlink.picoDevice)
			{
				if (controllerlink.switchHomeKey && (Controller.UPvr_GetKeyClick(0, Pvr_KeyCode.HOME) || (Controller.UPvr_GetKeyClick(1, Pvr_KeyCode.HOME) && !stopConnect)))
				{
					controllerlink.RebackToLauncher();
				}
				if (Controller.UPvr_GetKeyClick(0, Pvr_KeyCode.VOLUMEUP) || Controller.UPvr_GetKeyClick(1, Pvr_KeyCode.VOLUMEUP))
				{
					controllerlink.TurnUpVolume();
				}
				if (Controller.UPvr_GetKeyClick(0, Pvr_KeyCode.VOLUMEDOWN) || Controller.UPvr_GetKeyClick(1, Pvr_KeyCode.VOLUMEDOWN))
				{
					controllerlink.TurnDownVolume();
				}
				if (!Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEUP) && !Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEDOWN) && !Controller.UPvr_GetKey(1, Pvr_KeyCode.VOLUMEUP) && !Controller.UPvr_GetKey(1, Pvr_KeyCode.VOLUMEDOWN))
				{
					cTime = 1f;
				}
				if (Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEUP) || Controller.UPvr_GetKey(1, Pvr_KeyCode.VOLUMEUP))
				{
					cTime -= Time.deltaTime;
					if (cTime <= 0f)
					{
						cTime = 0.2f;
						controllerlink.TurnUpVolume();
					}
				}
				if (!Controller.UPvr_GetKey(0, Pvr_KeyCode.HOME) && !Controller.UPvr_GetKey(1, Pvr_KeyCode.HOME) && (Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEDOWN) || Controller.UPvr_GetKey(1, Pvr_KeyCode.VOLUMEDOWN)))
				{
					cTime -= Time.deltaTime;
					if (cTime <= 0f)
					{
						cTime = 0.2f;
						controllerlink.TurnDownVolume();
					}
				}
			}
			if (controllerlink.goblinserviceStarted && Controller.UPvr_GetKey(0, Pvr_KeyCode.HOME) && Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEDOWN) && !stopConnect)
			{
				disConnectTime += Time.deltaTime;
				if ((double)disConnectTime > 1.0)
				{
					DisConnectBLE();
					controllerlink.hummingBirdMac = "";
					stopConnect = true;
					disConnectTime = 0f;
				}
			}
		}

		private void TransformData(ControllerHand hand, int handId, int[] data)
		{
			keyOffset = ((handId == 1) ? 67 : 0);
			hand.TouchPadPosition.x = data[keyOffset];
			hand.TouchPadPosition.y = data[5 + keyOffset];
			TransSingleKey(hand.Home, 10 + keyOffset, data);
			TransSingleKey(hand.App, 15 + keyOffset, data);
			TransSingleKey(hand.Touch, 20 + keyOffset, data);
			TransSingleKey(hand.VolumeUp, 25 + keyOffset, data);
			TransSingleKey(hand.VolumeDown, 30 + keyOffset, data);
			TransSingleKey(hand.Trigger, 35 + keyOffset, data);
			if (controllerlink.goblinserviceStarted && !controllerlink.neoserviceStarted)
			{
				hand.TriggerNum = controllerlink.GetHBKeyValue();
			}
			if (!controllerlink.goblinserviceStarted && controllerlink.neoserviceStarted)
			{
				hand.TriggerNum = controllerlink.GetCVTriggerValue(handId);
			}
			hand.Battery = data[40 + keyOffset];
			if (data.Length == 47)
			{
				hand.SwipeDirection = (SwipeDirection)data[45];
				hand.TouchPadClick = (TouchPadClick)data[46];
			}
			else
			{
				switch (handId)
				{
				case 0:
					TransSingleKey(hand.X, 45 + keyOffset, data);
					TransSingleKey(hand.Y, 50 + keyOffset, data);
					TransSingleKey(hand.Left, 60 + keyOffset, data);
					break;
				case 1:
					TransSingleKey(hand.A, 45 + keyOffset, data);
					TransSingleKey(hand.B, 50 + keyOffset, data);
					TransSingleKey(hand.Right, 55 + keyOffset, data);
					break;
				}
				hand.SwipeDirection = (SwipeDirection)data[65 + keyOffset];
				hand.TouchPadClick = (TouchPadClick)data[66 + keyOffset];
			}
			hand.GripValue = controllerlink.GetNeo3GripValue(handId);
			TransformTouchData(hand, handId, controllerlink.GetNeo3TouchData(handId));
		}

		private void TransSingleKey(PvrControllerKey key, int beginIndex, int[] data)
		{
			key.State = Convert.ToBoolean(data[beginIndex]);
			key.PressedDown = Convert.ToBoolean(data[beginIndex + 1]);
			key.PressedUp = Convert.ToBoolean(data[beginIndex + 2]);
			key.LongPressed = Convert.ToBoolean(data[beginIndex + 3]);
			key.Click = Convert.ToBoolean(data[beginIndex + 4]);
		}

		private void TransformTouchData(ControllerHand hand, int handId, int[] data)
		{
			switch (handId)
			{
			case 0:
				TransSingleTouchValue(hand.X, 0, data);
				TransSingleTouchValue(hand.Y, 3, data);
				break;
			case 1:
				TransSingleTouchValue(hand.A, 0, data);
				TransSingleTouchValue(hand.B, 3, data);
				break;
			}
			TransSingleTouchValue(hand.Touch, 6, data);
			TransSingleTouchValue(hand.Trigger, 9, data);
			TransSingleTouchValue(hand.Thumbrest, 12, data);
		}

		private void TransSingleTouchValue(PvrControllerKey key, int beginIndex, int[] data)
		{
			key.Touch = Convert.ToBoolean(data[beginIndex]);
			key.TouchDown = Convert.ToBoolean(data[beginIndex + 1]);
			key.TouchUp = Convert.ToBoolean(data[beginIndex + 2]);
		}
	}
	public class Pvr_ControllerModuleInit : MonoBehaviour
	{
		public ControllerVariety Variety;

		public bool IsCustomModel;

		[SerializeField]
		private GameObject dot;

		[SerializeField]
		private GameObject rayLine;

		[SerializeField]
		private GameObject controller;

		private bool moduleState = true;

		private void Awake()
		{
			Pvr_ControllerManager.PvrServiceStartSuccessEvent += ServiceStartSuccess;
			Pvr_ControllerManager.PvrControllerStateChangedEvent += ControllerStateChanged;
			Pvr_ControllerManager.ChangeMainControllerCallBackEvent += MainControllerIDChanged;
			if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
			{
				rayLine = base.transform.GetComponentInChildren<LineRenderer>(includeInactive: true).gameObject;
				rayLine.GetComponent<LineRenderer>().startWidth = 0.003f;
				rayLine.GetComponent<LineRenderer>().endWidth = 0.0015f;
			}
		}

		private void OnDestroy()
		{
			Pvr_ControllerManager.PvrServiceStartSuccessEvent -= ServiceStartSuccess;
			Pvr_ControllerManager.PvrControllerStateChangedEvent -= ControllerStateChanged;
			Pvr_ControllerManager.ChangeMainControllerCallBackEvent -= MainControllerIDChanged;
		}

		private void ServiceStartSuccess()
		{
			RefreshRay();
		}

		private void ControllerStateChanged(string data)
		{
			if (Pvr_ControllerManager.controllerlink.controller0Connected || Pvr_ControllerManager.controllerlink.controller1Connected)
			{
				moduleState = true;
				controller.transform.localScale = Vector3.one;
			}
			RefreshRay();
		}

		private void MainControllerIDChanged(string data)
		{
			RefreshRay();
		}

		private void RefreshRay()
		{
			if (Variety == ControllerVariety.Controller0)
			{
				StartCoroutine(ShowOrHideRay(0));
			}
			if (Variety == ControllerVariety.Controller1)
			{
				StartCoroutine(ShowOrHideRay(1));
			}
		}

		private IEnumerator ShowOrHideRay(int id)
		{
			yield return null;
			yield return null;
			if (moduleState)
			{
				bool active = Controller.UPvr_GetMainHandNess() == id && Controller.UPvr_GetControllerState(id) == ControllerState.Connected;
				dot.SetActive(active);
				rayLine.SetActive(active);
			}
		}

		public void ForceHideOrShow(bool state)
		{
			dot.SetActive(state);
			rayLine.SetActive(state);
			controller.transform.localScale = (state ? Vector3.one : Vector3.zero);
			moduleState = state;
		}

		public void UpdateRay()
		{
			if (!Pvr_ControllerManager.Instance.LengthAdaptiveRay)
			{
				return;
			}
			bool flag = false;
			flag = ((Pvr_ControllerManager.controllerlink.controller0Connected || Pvr_ControllerManager.controllerlink.controller1Connected) ? true : false);
			if (flag && rayLine != null && rayLine.gameObject.activeSelf)
			{
				if (Controller.UPvr_GetDeviceType() == 1)
				{
					rayLine.GetComponent<LineRenderer>().SetPosition(0, base.transform.TransformPoint(0f, 0f, 0.058f));
				}
				else
				{
					rayLine.GetComponent<LineRenderer>().SetPosition(0, base.transform.TransformPoint(0f, 0.009f, 0.055f));
				}
				rayLine.GetComponent<LineRenderer>().SetPosition(1, dot.transform.position);
			}
		}
	}
	public class Pvr_ControllerPower : MonoBehaviour
	{
		[SerializeField]
		private Sprite power1;

		[SerializeField]
		private Sprite power2;

		[SerializeField]
		private Sprite power3;

		[SerializeField]
		private Sprite power4;

		[SerializeField]
		private Sprite power5;

		[HideInInspector]
		public ControllerVariety variety;

		[HideInInspector]
		public ControllerDevice currentDevice;

		private Image powerImage;

		private int powerValue;

		private float power;

		private void Start()
		{
			powerImage = base.transform.GetComponent<Image>();
			powerValue = -1;
			variety = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().Variety;
			currentDevice = base.transform.GetComponentInParent<Pvr_ControllerVisual>().currentDevice;
		}

		private void Update()
		{
			RefreshPower((variety != 0) ? 1 : 0);
		}

		private void RefreshPower(int hand)
		{
			if (powerValue != Controller.UPvr_GetControllerPower(hand))
			{
				switch (Controller.UPvr_GetControllerPower(hand))
				{
				case 1:
					powerImage.sprite = power1;
					powerImage.color = Color.red;
					break;
				case 2:
					powerImage.sprite = power2;
					powerImage.color = Color.white;
					break;
				case 3:
					powerImage.sprite = power3;
					powerImage.color = Color.white;
					break;
				case 4:
					powerImage.sprite = power4;
					powerImage.color = Color.white;
					break;
				case 5:
					powerImage.sprite = power5;
					powerImage.color = Color.white;
					break;
				default:
					powerImage.sprite = power1;
					powerImage.color = Color.white;
					break;
				}
				powerValue = Controller.UPvr_GetControllerPower(hand);
			}
		}
	}
	public class Pvr_ControllerVisual : MonoBehaviour
	{
		public ControllerDevice currentDevice;

		public Texture2D m_idle;

		public Texture2D m_app;

		public Texture2D m_home;

		public Texture2D m_touchpad;

		public Texture2D m_volUp;

		public Texture2D m_volDn;

		public Texture2D m_trigger;

		public Texture2D m_a;

		public Texture2D m_b;

		public Texture2D m_x;

		public Texture2D m_y;

		public Texture2D m_grip;

		private Renderer controllerRenderMat;

		[HideInInspector]
		public ControllerVariety variety;

		private void Awake()
		{
			controllerRenderMat = GetComponent<Renderer>();
		}

		private void Start()
		{
			variety = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().Variety;
		}

		private void Update()
		{
			ChangeKeyEffects((variety != 0) ? 1 : 0);
		}

		private void ChangeKeyEffects(int hand)
		{
			if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.TOUCHPAD))
			{
				controllerRenderMat.material.SetTexture("_MainTex", m_touchpad);
			}
			else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.APP))
			{
				controllerRenderMat.material.SetTexture("_MainTex", m_app);
			}
			else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.HOME))
			{
				controllerRenderMat.material.SetTexture("_MainTex", m_home);
			}
			else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.VOLUMEUP))
			{
				controllerRenderMat.material.SetTexture("_MainTex", m_volUp);
			}
			else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.VOLUMEDOWN))
			{
				controllerRenderMat.material.SetTexture("_MainTex", m_volDn);
			}
			else if (Controller.UPvr_GetControllerTriggerValue(hand) > 0 || Controller.UPvr_GetKey(hand, Pvr_KeyCode.TRIGGER))
			{
				controllerRenderMat.material.SetTexture("_MainTex", m_trigger);
			}
			else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.X))
			{
				controllerRenderMat.material.SetTexture("_MainTex", m_x);
			}
			else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.Y))
			{
				controllerRenderMat.material.SetTexture("_MainTex", m_y);
			}
			else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.A))
			{
				controllerRenderMat.material.SetTexture("_MainTex", m_a);
			}
			else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.B))
			{
				controllerRenderMat.material.SetTexture("_MainTex", m_b);
			}
			else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.Left) || Controller.UPvr_GetKey(hand, Pvr_KeyCode.Right))
			{
				controllerRenderMat.material.SetTexture("_MainTex", m_grip);
			}
			else if (controllerRenderMat.material.GetTexture("_MainTex") != m_idle)
			{
				controllerRenderMat.material.SetTexture("_MainTex", m_idle);
			}
		}
	}
	public class Pvr_ToolTips : MonoBehaviour
	{
		public enum TipBtn
		{
			app,
			touchpad,
			home,
			volup,
			voldown,
			trigger,
			grip
		}

		private ControllerDevice currentDevice;

		private float tipsAlpha;

		public static Pvr_ToolTips tooltips;

		public void ChangeTipsText(TipBtn tip, string key)
		{
			switch (tip)
			{
			case TipBtn.app:
				base.transform.Find("apptip/btn/Text").GetComponent<Text>().text = key;
				break;
			case TipBtn.touchpad:
				base.transform.Find("touchtip/btn/Text").GetComponent<Text>().text = key;
				break;
			case TipBtn.home:
				base.transform.Find("hometip/btn/Text").GetComponent<Text>().text = key;
				break;
			case TipBtn.volup:
				base.transform.Find("volup/btn/Text").GetComponent<Text>().text = key;
				break;
			case TipBtn.voldown:
				base.transform.Find("voldown/btn/Text").GetComponent<Text>().text = key;
				break;
			case TipBtn.trigger:
				base.transform.Find("triggertip/btn/Text").GetComponent<Text>().text = key;
				break;
			case TipBtn.grip:
				base.transform.Find("grip/btn/Text").GetComponent<Text>().text = key;
				break;
			}
		}

		private void Awake()
		{
			tooltips = base.transform.GetComponent<Pvr_ToolTips>();
		}

		private void Update()
		{
			switch (currentDevice)
			{
			case ControllerDevice.Goblin:
			case ControllerDevice.G2:
				tipsAlpha = (330f - base.transform.parent.parent.parent.localRotation.eulerAngles.x) / 45f;
				if (base.transform.parent.parent.parent.localRotation.eulerAngles.x >= 270f && base.transform.parent.parent.parent.localRotation.eulerAngles.x <= 330f)
				{
					tipsAlpha = Mathf.Max(0f, tipsAlpha);
					tipsAlpha = ((tipsAlpha > 1f) ? 1f : tipsAlpha);
				}
				else
				{
					tipsAlpha = 0f;
				}
				GetComponent<CanvasGroup>().alpha = tipsAlpha;
				break;
			case ControllerDevice.Neo2:
			case ControllerDevice.Neo3:
				tipsAlpha = (330f - base.transform.parent.parent.parent.localRotation.eulerAngles.x) / 45f;
				if (base.transform.parent.parent.parent.localRotation.eulerAngles.x >= 270f && base.transform.parent.parent.parent.localRotation.eulerAngles.x <= 330f)
				{
					tipsAlpha = Mathf.Max(0f, tipsAlpha);
					tipsAlpha = ((tipsAlpha > 1f) ? 1f : tipsAlpha);
				}
				else
				{
					tipsAlpha = 0f;
				}
				GetComponent<CanvasGroup>().alpha = tipsAlpha;
				break;
			case ControllerDevice.Neo:
				break;
			}
		}

		private void LoadTextFromJson()
		{
			currentDevice = base.transform.GetComponentInParent<Pvr_ControllerVisual>().currentDevice;
			base.transform.Find("apptip/btn/Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("apptip");
			base.transform.Find("touchtip/btn/Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("touchtip");
			base.transform.Find("hometip/btn/Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("hometip");
			Transform transform = base.transform.Find("volup/btn/Text");
			if (transform != null)
			{
				transform.GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("voluptip");
			}
			Transform transform2 = base.transform.Find("voldown/btn/Text");
			if (transform2 != null)
			{
				transform2.GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("voldowntip");
			}
			Transform transform3 = base.transform.Find("triggertip/btn/Text");
			if (transform3 != null)
			{
				transform3.GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("triggertip");
			}
			Transform transform4 = base.transform.Find("grip/btn/Text");
			if (transform4 != null)
			{
				transform4.GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("griptip");
			}
		}

		public static void RefreshTips()
		{
			if (tooltips != null)
			{
				tooltips.LoadTextFromJson();
			}
		}
	}
	public class Pvr_TouchPadScroll : MonoBehaviour
	{
		private ScrollRect scrollRect;

		private bool isHoving;

		private int mainHand;

		private SwipeDirection direction;

		private Vector2 currPos;

		private Vector2 tarPos;

		private float lerpSpeed = 10f;

		private Transform tranViewport;

		private float ignoreDis = 3f;

		private Vector2 lastTouchDownPos;

		private Vector2 lastTouchUpPos;

		private bool isTouching;

		private bool isClosed = true;

		private Vector2 vecOrigin = Vector2.zero;

		private Vector2 vecOriginNeo2 = new Vector2(128f, 128f);

		private void Awake()
		{
			scrollRect = base.gameObject.GetComponent<ScrollRect>();
			tranViewport = base.transform.Find("Viewport");
		}

		private void Update()
		{
			Process();
			UpdateTargetPos();
			UpdatePos();
		}

		private bool IsControllerConnect()
		{
			mainHand = Controller.UPvr_GetMainHandNess();
			if (mainHand == 0 && Pvr_ControllerManager.controllerlink.controller0Connected)
			{
				return true;
			}
			if (mainHand == 1 && Pvr_ControllerManager.controllerlink.controller1Connected)
			{
				return true;
			}
			return false;
		}

		private void UpdateTargetPos()
		{
			if (Controller.UPvr_GetKey(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TOUCHPAD))
			{
				ResetParameter();
			}
			else if (isHoving)
			{
				if (Pvr_ControllerManager.controllerlink.GetControllerType() == 3)
				{
					ComputeTouchPos();
				}
				else
				{
					ComputeRockerPos();
				}
				if ((currPos - tarPos).sqrMagnitude <= 10f)
				{
					isClosed = true;
				}
			}
		}

		private void ComputeTouchPos()
		{
			mainHand = Controller.UPvr_GetMainHandNess();
			currPos = scrollRect.content.localPosition;
			Vector2 vector = vecOrigin;
			if (mainHand == 0 && Pvr_ControllerManager.controllerlink.controller0Connected)
			{
				vector = Controller.UPvr_GetTouchPadPosition(mainHand);
			}
			if (mainHand == 1 && Pvr_ControllerManager.controllerlink.controller1Connected)
			{
				vector = Controller.UPvr_GetTouchPadPosition(mainHand);
			}
			if ((vector - vecOrigin).sqrMagnitude >= 1f)
			{
				if (!isTouching)
				{
					lastTouchDownPos = vector;
					isTouching = true;
				}
				lastTouchUpPos.x = vector.x;
				if (Mathf.Abs(lastTouchUpPos.x - lastTouchDownPos.x) > ignoreDis)
				{
					Vector2 vector2 = new Vector2((lastTouchUpPos.x - lastTouchDownPos.x) * 10f, 0f);
					lastTouchDownPos.x = lastTouchUpPos.x;
					if (isClosed)
					{
						tarPos = currPos + vector2;
						isClosed = false;
					}
					else
					{
						tarPos += vector2;
					}
				}
			}
			else
			{
				lastTouchDownPos = vecOrigin;
				lastTouchUpPos = vecOrigin;
				isTouching = false;
				if ((double)scrollRect.horizontalScrollbar.value >= 0.999 || (double)scrollRect.horizontalScrollbar.value <= 0.0001)
				{
					isClosed = true;
				}
			}
		}

		private void ComputeRockerPos()
		{
			mainHand = Controller.UPvr_GetMainHandNess();
			currPos = scrollRect.content.localPosition;
			Vector2 vector = vecOriginNeo2;
			if (mainHand == 0 && Pvr_ControllerManager.controllerlink.controller0Connected)
			{
				vector = Controller.UPvr_GetTouchPadPosition(mainHand);
			}
			if (mainHand == 1 && Pvr_ControllerManager.controllerlink.controller1Connected)
			{
				vector = Controller.UPvr_GetTouchPadPosition(mainHand);
			}
			if (VerifyNeo2TouchValid(vector) && (vector - vecOriginNeo2).sqrMagnitude >= 1f)
			{
				if (!isTouching)
				{
					lastTouchDownPos = vector;
					isTouching = true;
				}
				lastTouchUpPos.x = vector.x;
				if (Mathf.Abs(lastTouchUpPos.x - lastTouchDownPos.x) > ignoreDis)
				{
					Vector2 vector2 = new Vector2((lastTouchUpPos.x - lastTouchDownPos.x) * 10f, 0f);
					lastTouchDownPos.x = lastTouchUpPos.x;
					if (isClosed)
					{
						tarPos = currPos + vector2;
						isClosed = false;
					}
					else
					{
						tarPos += vector2;
					}
				}
			}
			else
			{
				lastTouchDownPos = vecOriginNeo2;
				lastTouchUpPos = vecOriginNeo2;
				isTouching = false;
				if ((double)scrollRect.horizontalScrollbar.value >= 0.999 || (double)scrollRect.horizontalScrollbar.value <= 0.0001)
				{
					isClosed = true;
				}
			}
		}

		private bool VerifyNeo2TouchValid(Vector2 nowTouchPos)
		{
			if (nowTouchPos.x > vecOriginNeo2.x && nowTouchPos.x > lastTouchDownPos.x)
			{
				return true;
			}
			if (nowTouchPos.x < vecOriginNeo2.x && nowTouchPos.x < lastTouchDownPos.x)
			{
				return true;
			}
			return false;
		}

		private void UpdatePos()
		{
			if (Controller.UPvr_GetKey(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TOUCHPAD))
			{
				ResetParameter();
			}
			else if (!isClosed && IsControllerConnect())
			{
				if ((double)scrollRect.horizontalScrollbar.value >= 0.9999 && tarPos.x <= currPos.x)
				{
					isClosed = true;
					return;
				}
				if ((double)scrollRect.horizontalScrollbar.value <= 0.0001 && tarPos.x >= currPos.x)
				{
					isClosed = true;
					return;
				}
				currPos.x = Mathf.Lerp(currPos.x, tarPos.x, lerpSpeed * Time.deltaTime);
				currPos.y = Mathf.Lerp(currPos.y, tarPos.y, lerpSpeed * Time.deltaTime);
				scrollRect.content.localPosition = currPos;
			}
		}

		private void ResetParameter()
		{
			currPos = scrollRect.content.localPosition;
			tarPos = scrollRect.content.localPosition;
			isClosed = true;
		}

		private void Process()
		{
			for (int i = 0; i < Pvr_InputModule.pointers.Count; i++)
			{
				Pvr_UIPointer pvr_UIPointer = Pvr_InputModule.pointers[i];
				if (pvr_UIPointer.gameObject.activeInHierarchy && pvr_UIPointer.enabled)
				{
					isHoving = IsHovering(pvr_UIPointer);
				}
			}
		}

		private bool IsHovering(Pvr_UIPointer pointer)
		{
			if (!IsControllerConnect())
			{
				return false;
			}
			foreach (GameObject item in pointer.pointerEventData.hovered)
			{
				if (FindTree(item.transform))
				{
					mainHand = Controller.UPvr_GetMainHandNess();
					if (mainHand == 0 && Pvr_ControllerManager.controllerlink.controller0Connected)
					{
						return true;
					}
					if (mainHand == 1 && Pvr_ControllerManager.controllerlink.controller1Connected)
					{
						return true;
					}
				}
			}
			return false;
		}

		private bool FindTree(Transform tran)
		{
			if (tran == base.transform || tran == tranViewport)
			{
				return true;
			}
			if (tran.IsChildOf(tranViewport))
			{
				return true;
			}
			return false;
		}
	}
	public class Pvr_TouchVisual : MonoBehaviour
	{
		[HideInInspector]
		public ControllerDevice currentDevice;

		[HideInInspector]
		public ControllerVariety variety;

		private MeshRenderer touchRenderer;

		private void Start()
		{
			variety = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().Variety;
			currentDevice = GetComponentInParent<Pvr_ControllerVisual>().currentDevice;
			touchRenderer = GetComponent<MeshRenderer>();
		}

		private void Update()
		{
			ChangeEffects((variety != 0) ? 1 : 0);
		}

		private void ChangeEffects(int hand)
		{
			if (currentDevice == ControllerDevice.G2)
			{
				if (Controller.UPvr_IsTouching(0))
				{
					touchRenderer.enabled = true;
					base.transform.localPosition = new Vector3(1.3f - Controller.UPvr_GetTouchPadPosition(hand).x * 0.01f, 1.6f, -1.7f - Controller.UPvr_GetTouchPadPosition(hand).y * 0.01f);
				}
				else
				{
					touchRenderer.enabled = false;
				}
			}
		}
	}
	public class DemoController : MonoBehaviour
	{
		public delegate void showLoadingEventHandler();

		private Callback callback;

		private GameObject msg;

		private Pvr_UnitySDKManager picoVrManager;

		private string currentOrderID;

		public GameObject loading;

		public GameObject BG;

		public GameObject InputPanel;

		public static showLoadingEventHandler showLoading;

		private void Awake()
		{
			UnityEngine.Debug.Log(loading.name);
			UnityEngine.Debug.Log(BG.name);
			showLoading = (showLoadingEventHandler)Delegate.Combine(showLoading, new showLoadingEventHandler(StopLoading));
			InputManager.doEnter = (InputManager.doEnterEventHandler)Delegate.Combine(InputManager.doEnter, new InputManager.doEnterEventHandler(DoPayByCode));
			currentOrderID = "";
		}

		private void Start()
		{
			msg = GameObject.Find("MassageInfo");
			InitDelegate();
			callback = new Callback();
			picoVrManager = GameObject.Find("Pvr_UnitySDK").GetComponent<Pvr_UnitySDKManager>();
			InputPanel.SetActive(value: false);
		}

		private void Update()
		{
			if (picoVrManager != null && (Input.GetKeyDown(KeyCode.Y) || Input.GetKeyDown(KeyCode.Joystick1Button2)))
			{
				UnityEngine.Debug.Log("update");
				Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
			}
			if (Input.GetKeyDown(KeyCode.Joystick1Button1) || Input.GetKeyDown(KeyCode.Escape))
			{
				if (InputPanel.activeInHierarchy)
				{
					InputPanel.SetActive(value: false);
				}
				else
				{
					Application.Quit();
				}
			}
		}

		private void InitDelegate()
		{
			foreach (string item in new ArrayList { "Login", "GetUserAPI", "PayOne", "PayCode", "QueryOrder" })
			{
				GameObject btnObj = GameObject.Find(item);
				btnObj.GetComponent<Button>().onClick.AddListener(delegate
				{
					OnClick(btnObj);
				});
			}
		}

		private void OnClick(GameObject btnObj)
		{
			switch (btnObj.name)
			{
			case "Login":
				StartLoading();
				LoginSDK.Login();
				break;
			case "PayOne":
				CommonDic.getInstance().setParameters("subject", "game");
				CommonDic.getInstance().setParameters("body", "gamePay");
				CommonDic.getInstance().setParameters("order_id", getRamdomTestOrderID());
				CommonDic.getInstance().setParameters("total", "1");
				CommonDic.getInstance().setParameters("goods_tag", "game");
				CommonDic.getInstance().setParameters("notify_url", "www.picovr.com");
				CommonDic.getInstance().setParameters("pay_code", "");
				StartLoading();
				PicoPaymentSDK.Pay(CommonDic.getInstance().PayOrderString());
				break;
			case "PayCode":
				InputPanel.SetActive(value: true);
				break;
			case "QueryOrder":
				StartLoading();
				PicoPaymentSDK.QueryOrder(currentOrderID);
				break;
			case "GetUserAPI":
				StartLoading();
				LoginSDK.GetUserAPI();
				break;
			}
		}

		public string getRamdomTestOrderID()
		{
			currentOrderID = (UnityEngine.Random.value * 65535f).ToString();
			return currentOrderID;
		}

		private void StartLoading()
		{
			loading.SetActive(value: true);
			BG.SetActive(value: true);
		}

		public void StopLoading()
		{
			if ((bool)loading && (bool)BG)
			{
				loading.SetActive(value: false);
				BG.SetActive(value: false);
			}
			else
			{
				UnityEngine.Debug.LogError("用户自定义，非演示demo");
			}
		}

		public void DoPayByCode()
		{
			CommonDic.getInstance().setParameters("subject", "game");
			CommonDic.getInstance().setParameters("body", "gamePay");
			CommonDic.getInstance().setParameters("order_id", getRamdomTestOrderID());
			CommonDic.getInstance().setParameters("total", "0");
			CommonDic.getInstance().setParameters("goods_tag", "game");
			CommonDic.getInstance().setParameters("notify_url", "www.picovr.com");
			CommonDic.getInstance().setParameters("pay_code", GameObject.Find("CodeText").GetComponent<Text>().text);
			UnityEngine.Debug.Log("商品码支付" + GameObject.Find("CodeText").GetComponent<Text>().text);
			StartLoading();
			GameObject.Find("CodeText").GetComponent<Text>().text = "";
			InputPanel.SetActive(value: false);
			PicoPaymentSDK.Pay(CommonDic.getInstance().PayOrderString());
		}

		private bool VerifyLocalToken()
		{
			if (CommonDic.getInstance().access_token.Equals(""))
			{
				GameObject.Find("MassageInfo").GetComponent<Text>().text = "{code:exception,msg:请先登录}";
				currentOrderID = "";
				StopLoading();
				return false;
			}
			return true;
		}
	}
	public class LoadingRatation : MonoBehaviour
	{
		private void Start()
		{
		}

		private void Update()
		{
			base.gameObject.transform.Rotate(new Vector3(0f, 0f, -4f));
		}
	}
	public class InputManager : MonoBehaviour
	{
		public delegate void doEnterEventHandler();

		public static doEnterEventHandler doEnter;

		private StringBuilder sb = new StringBuilder();

		private ArrayList btnsName = new ArrayList();

		private GameObject enter;

		private void Awake()
		{
			InitKeyBoard();
		}

		private void Start()
		{
		}

		private void Update()
		{
		}

		private void InitKeyBoard()
		{
			btnsName.Add("1");
			btnsName.Add("2");
			btnsName.Add("3");
			btnsName.Add("4");
			btnsName.Add("5");
			btnsName.Add("6");
			btnsName.Add("7");
			btnsName.Add("8");
			btnsName.Add("9");
			btnsName.Add("0");
			btnsName.Add("Q");
			btnsName.Add("W");
			btnsName.Add("E");
			btnsName.Add("R");
			btnsName.Add("T");
			btnsName.Add("Y");
			btnsName.Add("U");
			btnsName.Add("I");
			btnsName.Add("O");
			btnsName.Add("P");
			btnsName.Add("A");
			btnsName.Add("S");
			btnsName.Add("D");
			btnsName.Add("F");
			btnsName.Add("G");
			btnsName.Add("H");
			btnsName.Add("J");
			btnsName.Add("K");
			btnsName.Add("L");
			btnsName.Add("Z");
			btnsName.Add("X");
			btnsName.Add("C");
			btnsName.Add("V");
			btnsName.Add("B");
			btnsName.Add("N");
			btnsName.Add("M");
			btnsName.Add("Clear");
			btnsName.Add("Capslock");
			btnsName.Add("Enter");
			foreach (string item in btnsName)
			{
				GameObject btnObj = GameObject.Find(item);
				btnObj.GetComponent<Button>().onClick.AddListener(delegate
				{
					OnClick(btnObj);
				});
			}
			enter = GameObject.Find("Enter");
			enter.SetActive(sb.Length > 0);
		}

		private void OnClick(GameObject btnObj)
		{
			if (btnObj.name.Equals("Capslock"))
			{
				if (GameObject.Find("Q").transform.GetChild(0).GetComponent<Text>().text.Equals("Q"))
				{
					DoCapslock(IsUpper: true);
				}
				else
				{
					DoCapslock(IsUpper: false);
				}
			}
			else if (btnObj.name.Equals("Clear"))
			{
				GameObject.Find("CodeText").GetComponent<Text>().text = "";
				ClearBuffer();
			}
			else if (btnObj.name.Equals("Enter"))
			{
				ClearBuffer();
				doEnter();
			}
			else
			{
				EnterChar(btnObj.transform.GetChild(0).GetComponent<Text>().text);
			}
		}

		private void EnterChar(string s)
		{
			sb.Append(s);
			GameObject.Find("CodeText").GetComponent<Text>().text = sb.ToString();
			enter.SetActive(sb.Length > 0);
		}

		private void DoCapslock(bool IsUpper)
		{
			if (IsUpper)
			{
				foreach (string item in btnsName)
				{
					Text component = GameObject.Find(item).transform.GetChild(0).GetComponent<Text>();
					component.text = component.text.ToLower();
				}
				return;
			}
			foreach (string item2 in btnsName)
			{
				Text component2 = GameObject.Find(item2).transform.GetChild(0).GetComponent<Text>();
				component2.text = component2.text.ToUpper();
			}
		}

		private void ClearBuffer()
		{
			sb.Remove(0, sb.Length);
			enter.SetActive(sb.Length > 0);
		}
	}
	public class Callback : MonoBehaviour
	{
		private static string IS_SUCCESS = "isSuccess";

		private static string MSG = "msg";

		private static string CODE = "code";

		public void LoginCallback(string LoginInfo)
		{
			JsonData jsonData = JsonMapper.ToObject(LoginInfo);
			SetMassage(LoginInfo);
			DemoController.showLoading();
			if (jsonData[IS_SUCCESS] != null)
			{
				CommonDic.getInstance().isSuccess = jsonData[IS_SUCCESS].ToString();
			}
			if (jsonData[MSG] != null)
			{
				CommonDic.getInstance().loginMsg = jsonData[MSG].ToString();
			}
			UnityEngine.Debug.Log("调用login回调:" + LoginInfo);
		}

		public void QueryOrPayCallback(string queryOrPayInfo)
		{
			JsonData jsonData = JsonMapper.ToObject(queryOrPayInfo);
			if (jsonData[CODE] != null)
			{
				CommonDic.getInstance().code = jsonData["code"].ToString();
			}
			if (jsonData[MSG] != null)
			{
				CommonDic.getInstance().msg = jsonData["msg"].ToString();
			}
			if (jsonData != null)
			{
				CommonDic.getInstance().order_info = jsonData[1].ToString();
			}
			SetMassage(queryOrPayInfo);
			DemoController.showLoading();
			UnityEngine.Debug.Log("调用pay回调:" + queryOrPayInfo);
		}

		public void UserInfoCallback(string userInfo)
		{
			CommonDic.getInstance().user_info = userInfo;
			SetMassage(userInfo);
			DemoController.showLoading();
			UnityEngine.Debug.Log("调用userInfo回调:" + userInfo);
		}

		public void SetMassage(string massage)
		{
			if (!GetCurrentGameObject().Equals(null))
			{
				GetCurrentGameObject().GetComponent<Text>().text = massage;
			}
			else
			{
				UnityEngine.Debug.LogError("无接收该Message的控件");
			}
		}

		public GameObject GetCurrentGameObject()
		{
			return GameObject.Find("MassageInfo");
		}

		public void ActivityForResultCallback(string activity)
		{
			PicoPaymentSDK.jo.Call("authCallback", activity);
		}
	}
	public class CommonDic
	{
		private static CommonDic dic;

		private static Dictionary<string, string> mydic;

		private string _app_ID;

		private string _app_Key;

		private string _user_token;

		private string _access_token = "";

		private string _open_id;

		private string _refresh_token;

		private string _expires_in;

		private string _user_info;

		private string _subject;

		private string _body;

		private string _order_id;

		private string _total;

		private string _goods_tag;

		private string _notify_url;

		private string _trade_type;

		private string _pay_code = "";

		private string _order_info;

		private string _code;

		private string _msg = "null";

		private string _merchant_ID;

		private string _payKey;

		private string _isSuucess;

		private string _loginMsg;

		public string subject
		{
			get
			{
				return _subject;
			}
			set
			{
				_subject = value;
			}
		}

		public string body
		{
			get
			{
				return _body;
			}
			set
			{
				_body = value;
			}
		}

		public string order_id
		{
			get
			{
				return _order_id;
			}
			set
			{
				_order_id = value;
			}
		}

		public string total
		{
			get
			{
				return _total;
			}
			set
			{
				_total = value;
			}
		}

		public string goods_tag
		{
			get
			{
				return _goods_tag;
			}
			set
			{
				_goods_tag = value;
			}
		}

		public string notify_url
		{
			get
			{
				return _notify_url;
			}
			set
			{
				_notify_url = value;
			}
		}

		public string pay_code
		{
			get
			{
				return _pay_code;
			}
			set
			{
				_pay_code = value;
			}
		}

		public string trade_type
		{
			get
			{
				return _trade_type;
			}
			set
			{
				_trade_type = value;
			}
		}

		public string user_token
		{
			get
			{
				return _user_token;
			}
			set
			{
				_user_token = value;
			}
		}

		public string access_token
		{
			get
			{
				return _access_token;
			}
			set
			{
				_access_token = value;
			}
		}

		public string open_id
		{
			get
			{
				return _open_id;
			}
			set
			{
				_open_id = value;
			}
		}

		public string refresh_token
		{
			get
			{
				return _refresh_token;
			}
			set
			{
				_refresh_token = value;
			}
		}

		public string expires_in
		{
			get
			{
				return _expires_in;
			}
			set
			{
				_expires_in = value;
			}
		}

		public string isSuccess
		{
			get
			{
				return _isSuucess;
			}
			set
			{
				_isSuucess = value;
			}
		}

		public string loginMsg
		{
			get
			{
				return _loginMsg;
			}
			set
			{
				_loginMsg = value;
			}
		}

		public string user_info
		{
			get
			{
				return _user_info;
			}
			set
			{
				_user_info = value;
			}
		}

		public string order_info
		{
			get
			{
				return _order_info;
			}
			set
			{
				_order_info = value;
			}
		}

		public string code
		{
			get
			{
				return _code;
			}
			set
			{
				_code = value;
			}
		}

		public string msg
		{
			get
			{
				return _msg;
			}
			set
			{
				_msg = value;
			}
		}

		public string app_ID
		{
			get
			{
				return _app_ID;
			}
			set
			{
				_app_ID = value;
			}
		}

		public string app_Key
		{
			get
			{
				return _app_Key;
			}
			set
			{
				_app_Key = value;
			}
		}

		public string merchant_ID
		{
			get
			{
				return _merchant_ID;
			}
			set
			{
				_merchant_ID = value;
			}
		}

		public string paykey
		{
			get
			{
				return _payKey;
			}
			set
			{
				_payKey = value;
			}
		}

		public static CommonDic getInstance()
		{
			if (dic == null)
			{
				dic = new CommonDic();
			}
			if (mydic == null)
			{
				mydic = new Dictionary<string, string>();
				InitDicData(mydic);
			}
			return dic;
		}

		public Dictionary<string, string> getDic()
		{
			return mydic;
		}

		public void setParameters(string name, string value)
		{
			if (name.Equals("subject"))
			{
				subject = value;
			}
			if (name.Equals("body"))
			{
				body = value;
			}
			if (name.Equals("order_id"))
			{
				order_id = value;
			}
			if (name.Equals("total"))
			{
				total = value;
			}
			if (name.Equals("goods_tag"))
			{
				goods_tag = value;
			}
			if (name.Equals("notify_url"))
			{
				notify_url = value;
			}
			if (name.Equals("trade_type"))
			{
				trade_type = value;
			}
			if (name.Equals("pay_code"))
			{
				pay_code = value;
			}
		}

		public string PayOrderString()
		{
			return JsonMapper.ToJson(getInstance());
		}

		public static void InitDicData(Dictionary<string, string> mydic)
		{
			mydic.Add("00000", "网络异常");
			mydic.Add("10000", "登录成功");
			mydic.Add("10001", "用户未登陆");
			mydic.Add("10002", "请输入正确金额");
			mydic.Add("10003", "登陆过期，请重新登陆");
			mydic.Add("11000", "商户验证成功");
			mydic.Add("11001", "商户验证失败");
			mydic.Add("11002", "用户验证参数错误或请求过期");
			mydic.Add("11003", "商户未验证");
			mydic.Add("12000", "支付成功");
			mydic.Add("12001", "支付失败");
			mydic.Add("12003", "P币不足");
			mydic.Add("12004", "余额可用");
			mydic.Add("13000", "生成订单");
			mydic.Add("13001", "获取数据失败");
			mydic.Add("13002", "生成订单失败");
			mydic.Add("14000", "查询订单成功");
			mydic.Add("14001", "订单不存在/有误");
			mydic.Add("14002", "用户取消支付操作");
			mydic.Add("15000", "未输入商品信息");
			mydic.Add("15001", "未输入预付ID");
			mydic.Add("15002", "请输入Pico支付订单号或商户订单号");
			mydic.Add("NOAUTH", "商户无此接口权限");
			mydic.Add("SYSTEMERROR", "系统错误");
			mydic.Add("APP_ID_NOT_EXIST", "APP_ID不存在");
			mydic.Add("MCHID_NOT_EXIST", "MCHID不存在");
			mydic.Add("APP_ID_MCHID_NOT_MATCH", "app_id和mch_id不匹配ID");
			mydic.Add("LACK_PARAMS", "缺少参数");
			mydic.Add("SIGNERROR", "签名错误");
			mydic.Add("NO_DATA", "没有查询到数据");
		}
	}
	public class LoginSDK
	{
		public static void Login()
		{
			PicoPaymentSDK.Login();
		}

		public static void GetUserAPI()
		{
			PicoPaymentSDK.GetUserAPI();
		}
	}
	public class PicoPaymentSDK
	{
		private static AndroidJavaObject _jo = new AndroidJavaObject("com.pico.loginpaysdk.UnityInterface");

		public static AndroidJavaObject jo
		{
			get
			{
				return _jo;
			}
			set
			{
				_jo = value;
			}
		}

		public static void Login()
		{
			AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
			jo.Call("init", @static);
			jo.Call("authSSO");
		}

		public static void Pay(string payOrderJson)
		{
			AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
			jo.Call("init", @static);
			jo.Call("pay", payOrderJson);
		}

		public static void QueryOrder(string orderId)
		{
			AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
			jo.Call("init", @static);
			jo.Call("queryOrder", orderId);
		}

		public static void GetUserAPI()
		{
			AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
			jo.Call("init", @static);
			jo.Call("getUserAPI");
		}
	}
	public class Pvr_ToBService : MonoBehaviour
	{
		public Text deviceInfoText;

		private void Awake()
		{
			InitToBService();
		}

		private void Start()
		{
			BindToBService();
		}

		private void OnDestory()
		{
			UnBindToBService();
		}

		private void InitToBService()
		{
			ToBService.UPvr_InitToBService();
			ToBService.UPvr_SetUnityObjectName(base.name);
		}

		private void BindToBService()
		{
			ToBService.UPvr_BindToBService();
		}

		private void UnBindToBService()
		{
			ToBService.UPvr_UnBindToBService();
		}

		private void BoolCallback(string value)
		{
			if (ToBService.BoolCallback != null)
			{
				ToBService.BoolCallback(bool.Parse(value));
			}
			ToBService.BoolCallback = null;
		}

		private void IntCallback(string value)
		{
			if (ToBService.IntCallback != null)
			{
				ToBService.IntCallback(int.Parse(value));
			}
			ToBService.IntCallback = null;
		}

		private void LongCallback(string value)
		{
			if (ToBService.LongCallback != null)
			{
				ToBService.LongCallback(int.Parse(value));
			}
			ToBService.LongCallback = null;
		}

		public void StateGetDeviceInfo()
		{
			string text = ToBService.UPvr_StateGetDeviceInfo(PBS_SystemInfoEnum.PUI_VERSION);
			deviceInfoText.text = "PUI_VERSION:" + text;
		}

		public void ControlSetDeviceAction()
		{
			ToBService.UPvr_ControlSetDeviceAction(PBS_DeviceControlEnum.DEVICE_CONTROL_SHUTDOWN, ControlSetDeviceActionCallBack);
		}

		private void ControlSetDeviceActionCallBack(int value)
		{
			UnityEngine.Debug.Log("ControlSetDeviceActionCallBack : " + value);
		}

		public void AppManager()
		{
			ToBService.UPvr_ControlAPPManger(PBS_PackageControlEnum.PACKAGE_SILENCE_UNINSTALL, "com.pico.ipd.test", AppManagerCallBack);
		}

		private void AppManagerCallBack(int value)
		{
			UnityEngine.Debug.Log("AppManagerCallBack : " + value);
		}
	}
	public class PLOG : MonoBehaviour
	{
		public static int logLevel;

		public static void getConfigTraceLevel()
		{
			Render.UPvr_GetIntConfig(6, ref logLevel);
		}

		public static void D(string msg)
		{
			if (logLevel > 2)
			{
				UnityEngine.Debug.Log(msg);
			}
		}

		public static void I(string msg)
		{
			if (logLevel > 1)
			{
				UnityEngine.Debug.Log(msg);
			}
		}

		public static void W(string msg)
		{
			if (logLevel > 0)
			{
				UnityEngine.Debug.LogWarning(msg);
			}
		}

		public static void E(string msg)
		{
			UnityEngine.Debug.LogError(msg);
		}
	}
	public class CPicoSDKSettingAsset : ScriptableObject
	{
		public bool IgnoreSDKSetting;

		public bool DontshowBuildWaring;

		public bool AppIDChecked;
	}
	[Serializable]
	public class Pvr_UnitySDKProjectSetting : ScriptableObject
	{
		public RenderTextureAntiAliasing rtAntiAlising;

		public RenderTextureDepth rtBitDepth;

		public RenderTextureFormat rtFormat;

		public bool usedefaultRenderTexture;

		public Vector2 customRTSize;

		public bool usedefaultfps;

		public int customfps;

		public bool usesinglepass;

		public bool usecontentprotect;

		public static Pvr_UnitySDKProjectSetting GetProjectConfig()
		{
			return Resources.Load<Pvr_UnitySDKProjectSetting>("ProjectSetting");
		}
	}
	public sealed class Pvr_UnitySDKPlatformSetting : ScriptableObject
	{
		public enum simulationType
		{
			Null,
			Invalid,
			Valid
		}

		[SerializeField]
		private bool entitlementchecksimulation;

		[SerializeField]
		private bool startTimeEntitlementCheck;

		[SerializeField]
		public string appID;

		public List<string> deviceSN = new List<string>();

		private static Pvr_UnitySDKPlatformSetting instance;

		public static bool Entitlementchecksimulation
		{
			get
			{
				return Instance.entitlementchecksimulation;
			}
			set
			{
				if (Instance.entitlementchecksimulation != value)
				{
					Instance.entitlementchecksimulation = value;
				}
			}
		}

		public static bool StartTimeEntitlementCheck
		{
			get
			{
				return Instance.startTimeEntitlementCheck;
			}
			set
			{
				if (Instance.startTimeEntitlementCheck != value)
				{
					Instance.startTimeEntitlementCheck = value;
				}
			}
		}

		public static Pvr_UnitySDKPlatformSetting Instance
		{
			get
			{
				if (instance == null)
				{
					instance = Resources.Load<Pvr_UnitySDKPlatformSetting>("PlatformSettings");
				}
				return instance;
			}
			set
			{
				instance = value;
			}
		}
	}
	public class Pvr_UnitySDKManager : MonoBehaviour
	{
		public delegate void EntitlementCheckResult(int ReturnValue);

		public static PlatForm platform;

		private static Pvr_UnitySDKManager sdk;

		[HideInInspector]
		public float EyesAspect = 1f;

		[HideInInspector]
		public int posStatus;

		[HideInInspector]
		public bool ismirroring;

		[HideInInspector]
		public Vector3 resetBasePos;

		[HideInInspector]
		public int trackingmode = -1;

		[HideInInspector]
		public int systemprop = -1;

		[HideInInspector]
		public bool systemFPS;

		[HideInInspector]
		public float[] headData = new float[7];

		[SerializeField]
		private bool rotfoldout;

		[SerializeField]
		private bool hmdOnlyrot;

		[SerializeField]
		private bool controllerOnlyrot;

		[SerializeField]
		private TrackingOrigin trackingOrigin;

		public bool ResetTrackerOnLoad;

		[HideInInspector]
		public Vector3 leftEyeOffset;

		[HideInInspector]
		public Vector3 rightEyeOffset;

		[HideInInspector]
		public Rect leftEyeRect;

		[HideInInspector]
		public Rect rightEyeRect;

		[HideInInspector]
		public Matrix4x4 leftEyeView;

		[HideInInspector]
		public Matrix4x4 rightEyeView;

		[HideInInspector]
		public Pvr_UnitySDKEditor pvr_UnitySDKEditor;

		[SerializeField]
		private bool vrModeEnabled = true;

		[HideInInspector]
		public Material Eyematerial;

		[HideInInspector]
		public Material Middlematerial;

		[HideInInspector]
		public bool newPicovrTriggered;

		[SerializeField]
		private bool showFPS;

		[HideInInspector]
		public Vector3 neckOffset = new Vector3(0f, 0.075f, 0.0805f);

		[SerializeField]
		private bool pVRNeck = true;

		[HideInInspector]
		public bool UseCustomNeckPara;

		[HideInInspector]
		public bool onResume;

		[HideInInspector]
		public bool isEnterVRMode;

		public bool isHasController;

		public Pvr_UnitySDKConfigProfile pvr_UnitySDKConfig;

		private GameObject calltoast;

		private GameObject msgtoast;

		private GameObject lowhmdBatterytoast;

		private GameObject lowphoneBatterytoast;

		private GameObject LowPhoneHealthtoast;

		private GameObject LowcontrollerBatterytoast;

		private bool lowControllerpowerstate;

		private float controllerpowershowtime;

		private bool UseToast = true;

		private int iPhoneHMDModeEnabled;

		private GameObject G3LiteTips;

		[SerializeField]
		private bool monoscopic;

		private bool mIsAndroid7;

		public static Func<bool> eventEnterVRMode;

		[HideInInspector]
		public bool ShowVideoSeethrough;

		public int SystemDebugFFRLevel = -1;

		public int SystemFFRLevel = -1;

		public int AppCheckResult = 100;

		public Action longPressHomeKeyAction;

		public static Pvr_UnitySDKManager SDK
		{
			get
			{
				if (sdk == null)
				{
					sdk = UnityEngine.Object.FindObjectOfType<Pvr_UnitySDKManager>();
				}
				return sdk;
			}
		}

		public bool Rotfoldout
		{
			get
			{
				return rotfoldout;
			}
			set
			{
				if (value != rotfoldout)
				{
					rotfoldout = value;
				}
			}
		}

		public bool HmdOnlyrot
		{
			get
			{
				return hmdOnlyrot;
			}
			set
			{
				if (value != hmdOnlyrot)
				{
					hmdOnlyrot = value;
				}
			}
		}

		public bool ControllerOnlyrot
		{
			get
			{
				return controllerOnlyrot;
			}
			set
			{
				if (value != controllerOnlyrot)
				{
					controllerOnlyrot = value;
				}
			}
		}

		public TrackingOrigin TrackingOrigin
		{
			get
			{
				return trackingOrigin;
			}
			set
			{
				if (value != trackingOrigin)
				{
					trackingOrigin = value;
					Sensor.UPvr_SetTrackingOriginType(value);
				}
			}
		}

		[HideInInspector]
		public bool VRModeEnabled
		{
			get
			{
				return vrModeEnabled;
			}
			set
			{
				if (value != vrModeEnabled)
				{
					vrModeEnabled = value;
				}
			}
		}

		[HideInInspector]
		public bool picovrTriggered { get; set; }

		public bool ShowFPS
		{
			get
			{
				return showFPS;
			}
			set
			{
				if (value != showFPS)
				{
					showFPS = value;
				}
			}
		}

		public bool PVRNeck
		{
			get
			{
				return pVRNeck;
			}
			set
			{
				if (value != pVRNeck)
				{
					pVRNeck = value;
				}
			}
		}

		[HideInInspector]
		public bool Monoscopic
		{
			get
			{
				return monoscopic;
			}
			set
			{
				if (value != monoscopic)
				{
					monoscopic = value;
					Render.UPvr_SetMonoMode(monoscopic);
				}
			}
		}

		public static event EntitlementCheckResult EntitlementCheckResultEvent;

		public void ChangeDefaultCustomRtSize(int w, int h)
		{
			Pvr_UnitySDKProjectSetting.GetProjectConfig().customRTSize = new Vector2(w, h);
		}

		public Vector3 EyeOffset(Eye eye)
		{
			if (eye != 0)
			{
				return rightEyeOffset;
			}
			return leftEyeOffset;
		}

		public Rect EyeRect(Eye eye)
		{
			if (eye != 0)
			{
				return rightEyeRect;
			}
			return leftEyeRect;
		}

		private bool SDKManagerInit()
		{
			if (SDKManagerInitConfigProfile())
			{
				mIsAndroid7 = SystemInfo.operatingSystem.Contains("Android OS 7.");
				PLOG.I("Android 7 = " + mIsAndroid7);
				if (SDKManagerInitCoreAbility())
				{
					return true;
				}
				return false;
			}
			return false;
		}

		private bool SDKManagerInitCoreAbility()
		{
			Sensor.UPvr_SetTrackingOriginType(trackingOrigin);
			Render.UPvr_SetMonoMode(monoscopic);
			if (Pvr_UnitySDKRender.Instance == null)
			{
				PLOG.I("pvr_UnitySDKRender init failed");
			}
			if (Pvr_UnitySDKSensor.Instance == null)
			{
				PLOG.I("pvr_UnitySDKSensor init failed");
			}
			Pvr_UnitySDKAPI.System.UPvr_StartHomeKeyReceiver(base.gameObject.name);
			return true;
		}

		public void smsReceivedCallback(string msg)
		{
			PLOG.I("PvrLog MSG" + msg);
			JsonData jsonData = JsonMapper.ToObject(msg);
			string text = "";
			if (msg.Contains("messageSender"))
			{
				text = (string)jsonData["messageSender"];
			}
			string text2 = "";
			if (msg.Contains("messageAdr"))
			{
				text2 = (string)jsonData["messageAdr"];
				if (text2.Substring(0, 3) == "+82")
				{
					text2 = "0" + text2.Remove(0, 3);
					text2 = TransformNumber(text2);
				}
				else if (text2.Substring(0, 1) != "+")
				{
					text2 = TransformNumber(text2);
				}
			}
			if (UseToast)
			{
				msgtoast.transform.Find("number").GetComponent<Text>().text = text2;
				msgtoast.transform.Find("name").GetComponent<Text>().text = text;
				if (text.Length == 0)
				{
					msgtoast.transform.Find("number").transform.localPosition = new Vector3(0f, 0f, 0f);
				}
				else
				{
					msgtoast.transform.Find("number").transform.localPosition = new Vector3(60f, 0f, 0f);
				}
				StartCoroutine(ToastManager(2, state: true, 0f));
				StartCoroutine(ToastManager(2, state: false, 5f));
			}
		}

		public void phoneStateCallback(string state)
		{
			PLOG.I("PvrLog phone" + state);
			JsonData jsonData = JsonMapper.ToObject(state);
			string text = "";
			if (state.Contains("phoneNumber"))
			{
				text = (string)jsonData["phoneNumber"];
				if (text.Substring(0, 3) == "+82")
				{
					text = "0" + text.Remove(0, 3);
					text = TransformNumber(text);
				}
				else if (text.Substring(0, 1) != "+")
				{
					text = TransformNumber(text);
				}
			}
			string text2 = "";
			if (state.Contains("contactName"))
			{
				text2 = (string)jsonData["contactName"];
			}
			if (UseToast)
			{
				calltoast.transform.Find("number").GetComponent<Text>().text = text;
				calltoast.transform.Find("name").GetComponent<Text>().text = text2;
				if (text2.Length == 0)
				{
					calltoast.transform.Find("number").transform.localPosition = new Vector3(0f, 0f, 0f);
				}
				else
				{
					calltoast.transform.Find("number").transform.localPosition = new Vector3(60f, 0f, 0f);
				}
				StartCoroutine(ToastManager(1, state: true, 0f));
				StartCoroutine(ToastManager(1, state: false, 5f));
			}
		}

		public void phoneBatteryStateCallback(string state)
		{
			PLOG.I("PvrLog phoneBatteryState" + state);
			JsonData jsonData = JsonMapper.ToObject(state);
			string value = "";
			if (state.Contains("phoneBatteryLevel"))
			{
				value = (string)jsonData["phoneBatteryLevel"];
			}
			string value2 = "";
			if (state.Contains("phoneBatteryHealth"))
			{
				value2 = (string)jsonData["phoneBatteryHealth"];
			}
			if (!UseToast)
			{
				return;
			}
			if (Convert.ToInt16(value) <= 5)
			{
				if (!lowhmdBatterytoast.activeSelf)
				{
					StartCoroutine(ToastManager(4, state: true, 0f));
					StartCoroutine(ToastManager(4, state: false, 3f));
				}
				else
				{
					StartCoroutine(ToastManager(4, state: true, 5f));
					StartCoroutine(ToastManager(4, state: false, 8f));
				}
			}
			if (Convert.ToInt16(value2) == 3)
			{
				StartCoroutine(ToastManager(5, state: true, 0f));
				StartCoroutine(ToastManager(5, state: false, 5f));
			}
		}

		public void hmdLowBatteryCallback(string level)
		{
			PLOG.I("PvrLog hmdLowBatteryCallback" + level);
			if (UseToast)
			{
				if (!lowphoneBatterytoast.activeSelf)
				{
					StartCoroutine(ToastManager(3, state: true, 0f));
					StartCoroutine(ToastManager(3, state: false, 3f));
				}
				else
				{
					StartCoroutine(ToastManager(3, state: true, 5f));
					StartCoroutine(ToastManager(3, state: false, 8f));
				}
			}
		}

		private string TransformNumber(string number)
		{
			if (number.Length == 11)
			{
				string text = number.Substring(0, 3);
				string text2 = number.Substring(3, 4);
				string text3 = number.Substring(7, 4);
				number = text + "-" + text2 + "-" + text3;
			}
			else if (number.Length == 10)
			{
				if (number.Substring(1, 1) == "1")
				{
					string text4 = number.Substring(0, 3);
					string text5 = number.Substring(3, 3);
					string text6 = number.Substring(6, 4);
					number = text4 + "-" + text5 + "-" + text6;
				}
				else
				{
					string text7 = number.Substring(0, 2);
					string text8 = number.Substring(2, 4);
					string text9 = number.Substring(6, 4);
					number = text7 + "-" + text8 + "-" + text9;
				}
			}
			else if (number.Length == 9)
			{
				if (number.Substring(1, 1) == "2")
				{
					string text10 = number.Substring(0, 2);
					string text11 = number.Substring(2, 3);
					string text12 = number.Substring(5, 4);
					number = text10 + "-" + text11 + "-" + text12;
				}
				else
				{
					number = "+82" + number.Remove(0, 1);
				}
			}
			return number;
		}

		public void onHmdOrientationReseted()
		{
		}

		private IEnumerator ToastManager(int type, bool state, float time)
		{
			yield return new WaitForSeconds(time);
			switch (type)
			{
			case 1:
				calltoast.SetActive(state);
				break;
			case 2:
				msgtoast.SetActive(state);
				break;
			case 3:
				lowhmdBatterytoast.SetActive(state);
				break;
			case 4:
				lowphoneBatterytoast.SetActive(state);
				break;
			case 5:
				LowPhoneHealthtoast.SetActive(state);
				break;
			case 6:
				LowcontrollerBatterytoast.SetActive(state);
				break;
			}
		}

		private void CheckControllerStateForG2(string state)
		{
			if (iPhoneHMDModeEnabled == 1 && Convert.ToBoolean(Convert.ToInt16(state)) && Controller.UPvr_GetControllerPower(0) == 0 && Pvr_ControllerManager.controllerlink.Controller0.Rotation.eulerAngles != Vector3.zero)
			{
				StartCoroutine(ToastManager(6, state: true, 0f));
				StartCoroutine(ToastManager(6, state: false, 3f));
			}
		}

		public void notificationCallback(string data)
		{
			JsonData jsonData = JsonMapper.ToObject(data);
			if (G3LiteTips == null)
			{
				G3LiteTips = UnityEngine.Object.Instantiate(Resources.Load("Prefabs/G3LiteTips") as GameObject, base.transform.Find("Head"), worldPositionStays: false);
			}
			JsonData jsonData2 = JsonMapper.ToObject(jsonData["str"].ToString());
			switch ((int)jsonData["type"])
			{
			case 0:
				SetProperty(0, jsonData2, "Sms");
				break;
			case 1:
				SetProperty(1, jsonData2, "Call");
				break;
			case 2:
				SetProperty(2, jsonData2, "Warnning");
				break;
			case 3:
				SetProperty(3, jsonData2, "Warnning");
				break;
			case 4:
				SetProperty(4, jsonData2, "Warnning");
				break;
			case 5:
			{
				Transform transform = G3LiteTips.transform.Find("Onlyimage");
				SetBaseProperty(transform, jsonData2["General"], "");
				SetImageProperty(transform, jsonData2["General"], "");
				transform.gameObject.SetActive(value: true);
				StartCoroutine(G3TipsManager(transform.gameObject, (int)jsonData2["General"]["time"]));
				break;
			}
			case -1:
				break;
			}
		}

		private Sprite LoadSprite(Vector2 size, string filepath)
		{
			int width = (int)size.x;
			int height = (int)size.y;
			Texture2D texture2D = new Texture2D(width, height);
			texture2D.LoadImage(ReadTex(filepath));
			return Sprite.Create(texture2D, new Rect(0f, 0f, texture2D.width, texture2D.height), new Vector2(0.5f, 0.5f));
		}

		private byte[] ReadTex(string path)
		{
			if (path == "")
			{
				return new byte[0];
			}
			FileStream fileStream = new FileStream(path, FileMode.Open, FileAccess.Read);
			fileStream.Seek(0L, SeekOrigin.Begin);
			byte[] array = new byte[fileStream.Length];
			fileStream.Read(array, 0, (int)fileStream.Length);
			fileStream.Close();
			fileStream.Dispose();
			fileStream = null;
			return array;
		}

		private void SetProperty(int type, JsonData data, string value)
		{
			Transform trans = G3LiteTips.transform.Find(value);
			SetBaseProperty(trans, data, "");
			SetImageProperty(trans, data, "");
			trans.gameObject.SetActive(value: true);
			StartCoroutine(G3TipsManager(trans.gameObject, (int)data["time"]));
			Transform transform = trans.transform.Find("icon");
			SetBaseProperty(transform, data, "icon_");
			SetImageProperty(transform, data, "icon_");
			Transform transform2 = trans.transform.Find("title");
			SetBaseProperty(transform2, data, "title_");
			SetTextProperty(transform2, data, "title_");
			if (type != 1)
			{
				Transform transform3 = trans.transform.Find("details");
				SetBaseProperty(transform3, data, "details_");
				SetTextProperty(transform3, data, "details_");
				Transform transform4 = trans.transform.Find("image1");
				SetBaseProperty(transform4, data, "image1_");
				SetImageProperty(transform4, data, "image1_");
			}
			if (type == 0 || type == 1)
			{
				Transform transform5 = trans.transform.Find("explain");
				SetBaseProperty(transform5, data, "explain_");
				SetTextProperty(transform5, data, "explain_");
				Transform transform6 = trans.transform.Find("source");
				SetBaseProperty(transform6, data, "source_");
				SetTextProperty(transform6, data, "source_");
			}
			if (type == 0)
			{
				Transform transform7 = trans.transform.Find("time");
				SetBaseProperty(transform7, data, "system_time_");
				SetTextProperty(transform7, data, "system_time_");
			}
			Transform transform8 = trans.transform.Find("Button");
			SetBaseProperty(transform8, data, "button_");
			SetImageProperty(transform8, data, "button_");
			transform8.GetComponent<Button>().onClick.AddListener(delegate
			{
				StartCoroutine(G3TipsManager(trans.gameObject, 0f));
			});
			Transform transform9 = transform8.transform.Find("Text");
			SetBaseProperty(transform9, data, "button_text_");
			SetTextProperty(transform9, data, "button_text_");
		}

		private void SetBaseProperty(Transform trans, JsonData data, string value)
		{
			string prop_name = value + "pos";
			string prop_name2 = value + "angles";
			string prop_name3 = value + "size";
			string prop_name4 = value + "scale";
			trans.GetComponent<RectTransform>().anchoredPosition3D = new Vector3(JsonToFloat(data[prop_name][0]), JsonToFloat(data[prop_name][1]), JsonToFloat(data[prop_name][2]));
			trans.GetComponent<RectTransform>().eulerAngles = new Vector3(JsonToFloat(data[prop_name2][0]), JsonToFloat(data[prop_name2][1]), JsonToFloat(data[prop_name2][2]));
			trans.GetComponent<RectTransform>().sizeDelta = new Vector2(JsonToFloat(data[prop_name3][0]), JsonToFloat(data[prop_name3][1]));
			trans.GetComponent<RectTransform>().localScale = new Vector3(JsonToFloat(data[prop_name4][0]), JsonToFloat(data[prop_name4][1]), JsonToFloat(data[prop_name4][2]));
		}

		private void SetImageProperty(Transform image, JsonData data, string value)
		{
			string prop_name = value + "sprite";
			string prop_name2 = value + "color";
			string prop_name3 = value + "size";
			image.GetComponent<Image>().sprite = LoadSprite(new Vector2(JsonToFloat(data[prop_name3][0]), JsonToFloat(data[prop_name3][1])), (string)data[prop_name]);
			image.GetComponent<Image>().color = new Color(JsonToFloat(data[prop_name2][0]), JsonToFloat(data[prop_name2][1]), JsonToFloat(data[prop_name2][2]), JsonToFloat(data[prop_name2][3]));
		}

		private void SetTextProperty(Transform text, JsonData data, string value)
		{
			string prop_name = value + "color";
			string prop_name2 = value + "font_size";
			string prop_name3 = value + "font_style";
			string prop_name4 = value + "text";
			text.GetComponent<Text>().text = (string)data[prop_name4];
			text.GetComponent<Text>().color = new Color(JsonToFloat(data[prop_name][0]), JsonToFloat(data[prop_name][1]), JsonToFloat(data[prop_name][2]), JsonToFloat(data[prop_name][3]));
			text.GetComponent<Text>().fontSize = (int)data[prop_name2];
			text.GetComponent<Text>().fontStyle = (FontStyle)(int)data[prop_name3];
		}

		private IEnumerator G3TipsManager(GameObject tip, float time)
		{
			yield return new WaitForSeconds(time);
			tip.SetActive(value: false);
		}

		private float JsonToFloat(JsonData data)
		{
			return Convert.ToSingle((string)data);
		}

		private bool SDKManagerInitFPS()
		{
			Transform[] componentsInChildren = GetComponentsInChildren<Transform>(includeInactive: true);
			GameObject gameObject = null;
			Transform[] array = componentsInChildren;
			foreach (Transform transform in array)
			{
				if (transform.gameObject.name == "FPS")
				{
					gameObject = transform.gameObject;
				}
			}
			if (gameObject != null)
			{
				if (systemFPS)
				{
					gameObject.SetActive(value: true);
					return true;
				}
				int res = 0;
				Render.UPvr_GetIntConfig(10, ref res);
				if (Convert.ToBoolean(res))
				{
					gameObject.SetActive(value: true);
					return true;
				}
				if (ShowFPS)
				{
					gameObject.SetActive(value: true);
					return true;
				}
				return false;
			}
			return false;
		}

		private bool SDKManagerInitConfigProfile()
		{
			pvr_UnitySDKConfig = Pvr_UnitySDKConfigProfile.Default;
			return true;
		}

		private bool SDKManagerInitEditor()
		{
			if (pvr_UnitySDKEditor == null)
			{
				pvr_UnitySDKEditor = base.gameObject.AddComponent<Pvr_UnitySDKEditor>();
			}
			else
			{
				pvr_UnitySDKEditor = null;
				pvr_UnitySDKEditor = base.gameObject.AddComponent<Pvr_UnitySDKEditor>();
			}
			return true;
		}

		private bool SDKManagerInitPara()
		{
			return true;
		}

		public void SDKManagerLongHomeKey()
		{
			if (Pvr_UnitySDKSensor.Instance == null)
			{
				return;
			}
			if (isHasController)
			{
				if (Controller.UPvr_GetControllerState(0) == ControllerState.Connected || Controller.UPvr_GetControllerState(1) == ControllerState.Connected)
				{
					Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(0, 1);
				}
				else
				{
					Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
				}
			}
			else
			{
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
			}
		}

		private void setLongHomeKey()
		{
			if (sdk.HmdOnlyrot)
			{
				if (Pvr_UnitySDKSensor.Instance != null)
				{
					PLOG.I(Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor() ? "Long Home Key to Reset Sensor Success!" : "Long Home Key to Reset Sensor Failed!");
				}
				return;
			}
			if (trackingmode == 4 || trackingmode == 5 || trackingmode == 6)
			{
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
			}
			else
			{
				if (trackingmode == 2 || trackingmode == 3)
				{
					if (isHasController && (Controller.UPvr_GetControllerState(0) == ControllerState.Connected || Controller.UPvr_GetControllerState(1) == ControllerState.Connected))
					{
						Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(0, 1);
					}
					else
					{
						Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
					}
				}
				if (trackingmode == 0 || trackingmode == 1)
				{
					Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
				}
			}
			if (longPressHomeKeyAction != null)
			{
				longPressHomeKeyAction();
			}
		}

		public void verifyAPPCallback(string code)
		{
			UnityEngine.Debug.Log("PvrLog verifyAPPCallback" + code);
			AppCheckResult = Convert.ToInt32(code);
			if (Pvr_UnitySDKManager.EntitlementCheckResultEvent != null)
			{
				Pvr_UnitySDKManager.EntitlementCheckResultEvent(AppCheckResult);
			}
		}

		public void IpdRefreshCallBack(string ipd)
		{
			UnityEngine.Debug.Log("PvrLog IpdRefreshCallBack");
			Pvr_UnitySDKEye[] eyes = Pvr_UnitySDKEyeManager.Instance.Eyes;
			for (int i = 0; i < eyes.Length; i++)
			{
				eyes[i].RefreshCameraPosition(Convert.ToSingle(ipd));
			}
		}

		private void Awake()
		{
			UnityEngine.Debug.Log("DISFT Unity Version:" + Application.unityVersion);
			Vector3 vector = neckOffset;
			UnityEngine.Debug.Log("DISFT Customize NeckOffset:" + vector.ToString());
			UnityEngine.Debug.Log("DISFT MSAA :" + Pvr_UnitySDKProjectSetting.GetProjectConfig().rtAntiAlising);
			if (GraphicsSettings.renderPipelineAsset != null)
			{
				UnityEngine.Debug.Log("DISFT LWRP = Enable");
			}
			UnityEngine.Debug.Log("DISFT Content Proctect :" + Pvr_UnitySDKProjectSetting.GetProjectConfig().usecontentprotect);
			int res = 0;
			LoadIsMirroringValue();
			if (!ismirroring)
			{
				Render.UPvr_GetIntConfig(18, ref res);
				if (res == 1)
				{
					UnityEngine.Debug.Log("DISFT ScreenOrientation.Portrait = Enable");
					Screen.orientation = ScreenOrientation.Portrait;
				}
			}
			else
			{
				Render.UPvr_GetIntConfig(19, ref res);
				Screen.orientation = ((res == 0) ? ScreenOrientation.Portrait : ScreenOrientation.LandscapeLeft);
			}
			new AndroidJavaClass("com.psmart.vrlib.VrActivity");
			new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
			Pvr_ControllerManager pvr_ControllerManager = UnityEngine.Object.FindObjectOfType<Pvr_ControllerManager>();
			isHasController = pvr_ControllerManager != null;
			PLOG.getConfigTraceLevel();
			Render.UPvr_GetIntConfig(5, ref trackingmode);
			Application.targetFrameRate = 61;
			int res2 = 0;
			Render.UPvr_GetIntConfig(3, ref res2);
			if (res2 == 0)
			{
				SDK.HmdOnlyrot = true;
			}
			int res3 = -1;
			Render.UPvr_GetIntConfig(9, ref res3);
			float res4 = 0f;
			Render.UPvr_GetFloatConfig(6, ref res4);
			Application.targetFrameRate = ((res3 > 0) ? res3 : ((int)res4));
			if (!Pvr_UnitySDKProjectSetting.GetProjectConfig().usedefaultfps)
			{
				if ((float)Pvr_UnitySDKProjectSetting.GetProjectConfig().customfps <= res4)
				{
					Application.targetFrameRate = Pvr_UnitySDKProjectSetting.GetProjectConfig().customfps;
				}
				else
				{
					Application.targetFrameRate = (int)res4;
				}
			}
			UnityEngine.Debug.Log("DISFT Customize FPS :" + Application.targetFrameRate);
			if (!UseCustomNeckPara)
			{
				float res5 = 0f;
				float res6 = 0f;
				float res7 = 0f;
				int configsenum = 4;
				int configsenum2 = 5;
				Render.UPvr_GetFloatConfig(3, ref res5);
				Render.UPvr_GetFloatConfig(configsenum, ref res6);
				Render.UPvr_GetFloatConfig(configsenum2, ref res7);
				if (res5 != 0f || res6 != 0f || res7 != 0f)
				{
					neckOffset = new Vector3(res5, res6, res7);
				}
			}
			Render.UPvr_GetIntConfig(16, ref iPhoneHMDModeEnabled);
			Pvr_ControllerManager.ControllerStatusChangeEvent += CheckControllerStateForG2;
			InitUI();
			RefreshTextByLanguage();
		}

		private IEnumerator Start()
		{
			if (SDKManagerInit())
			{
				PLOG.I("SDK Init success.");
			}
			else
			{
				PLOG.E("SDK Init Failed.");
				Application.Quit();
			}
			if (Pvr_UnitySDKRender.Instance != null)
			{
				Pvr_UnitySDKRender.Instance.ReInit();
			}
			SDKManagerInitFPS();
			if (Pvr_UnitySDKPlatformSetting.StartTimeEntitlementCheck)
			{
				if (PlatformSettings.UPvr_IsCurrentDeviceValid() != Pvr_UnitySDKPlatformSetting.simulationType.Valid)
				{
					UnityEngine.Debug.Log("DISFT Entitlement Check Simulation DO NOT PASS");
					string appID = Pvr_UnitySDKPlatformSetting.Instance.appID;
					UnityEngine.Debug.Log("DISFT Start-time Entitlement Check Enable");
					PLOG.I("DISFT Start-time Entitlement Check APPID :" + appID);
					PlatformSettings.UPvr_AppEntitlementCheckExtra(appID);
				}
				else
				{
					UnityEngine.Debug.Log("DISFT Entitlement Check Simulation PASS");
				}
			}
			yield return StartCoroutine(InitRenderThreadRoutine());
		}

		private IEnumerator InitRenderThreadRoutine()
		{
			PLOG.I("InitRenderThreadRoutine begin");
			int i = 0;
			while (i < 2)
			{
				yield return null;
				int num = i + 1;
				i = num;
			}
			UnityEngine.Debug.Log("InitRenderThreadRoutine after a wait");
			if (Pvr_UnitySDKRender.Instance != null)
			{
				Pvr_UnitySDKRender.Instance.IssueRenderThread();
			}
			else
			{
				UnityEngine.Debug.Log("InitRenderThreadRoutine pvr_UnitySDKRender == null");
			}
			UnityEngine.Debug.Log("InitRenderThreadRoutine end");
		}

		private void Update()
		{
			if (isHasController && iPhoneHMDModeEnabled == 1 && Controller.UPvr_GetControllerPower(0) == 0 && Pvr_ControllerManager.controllerlink.controller0Connected && Pvr_ControllerManager.controllerlink.Controller0.Rotation.eulerAngles != Vector3.zero)
			{
				if (!lowControllerpowerstate)
				{
					StartCoroutine(ToastManager(6, state: true, 0f));
					StartCoroutine(ToastManager(6, state: false, 3f));
					lowControllerpowerstate = true;
				}
				controllerpowershowtime += Time.deltaTime;
				if (controllerpowershowtime >= 3600f)
				{
					lowControllerpowerstate = false;
					controllerpowershowtime = 0f;
				}
			}
			if (Input.touchCount == 1 && Input.touches[0].phase == TouchPhase.Began)
			{
				newPicovrTriggered = true;
			}
			if (Input.GetKeyDown(KeyCode.JoystickButton0))
			{
				newPicovrTriggered = true;
			}
			if (Pvr_UnitySDKSensor.Instance != null)
			{
				Pvr_UnitySDKSensor.Instance.SensorUpdate();
			}
			picovrTriggered = newPicovrTriggered;
			newPicovrTriggered = false;
		}

		private void OnDestroy()
		{
			if (sdk == this)
			{
				sdk = null;
			}
			RenderTexture.active = null;
			Resources.UnloadUnusedAssets();
			GC.Collect();
			Pvr_ControllerManager.ControllerStatusChangeEvent -= CheckControllerStateForG2;
		}

		private void OnEnable()
		{
			if (sdk == null)
			{
				sdk = this;
			}
			else if (sdk != this)
			{
				sdk = this;
			}
		}

		private void OnDisable()
		{
			StopAllCoroutines();
		}

		private void OnPause()
		{
			Pvr_UnitySDKAPI.System.UPvr_StopHomeKeyReceiver();
			LeaveVRMode();
			if (Pvr_UnitySDKSensor.Instance != null)
			{
				Pvr_UnitySDKSensor.Instance.StopUnitySDKSensor();
			}
		}

		private void OnApplicationPause(bool pause)
		{
			bool flag = pause;
			UnityEngine.Debug.Log("OnApplicationPause-------------------------" + (flag ? "true" : "false"));
			if (Pvr_UnitySDKAPI.System.UPvr_IsPicoActivity() && !Pvr_UnitySDKRender.Instance.isShellMode)
			{
				bool flag2 = Pvr_UnitySDKAPI.System.UPvr_GetMainActivityPauseStatus();
				UnityEngine.Debug.Log("OnApplicationPause-------------------------Activity Pause State:" + flag2);
				pause = flag2;
			}
			if (flag == pause)
			{
				if (pause)
				{
					onResume = false;
					OnPause();
				}
				else
				{
					onResume = true;
					GL.InvalidateState();
					StartCoroutine(OnResume());
				}
			}
			else if (pause)
			{
				UnityEngine.Debug.Log("OnApplicationPause-------------------------Activity pause Unity resume");
				GL.InvalidateState();
				StartCoroutine(OnResume());
				onResume = false;
				OnPause();
			}
			else
			{
				UnityEngine.Debug.Log("OnApplicationPause-------------------------Activity resume Unity pause");
				OnPause();
				onResume = true;
				GL.InvalidateState();
				StartCoroutine(OnResume());
			}
		}

		public void EnterVRMode()
		{
			Pvr_UnitySDKPluginEvent.Issue(RenderEventType.Resume);
			isEnterVRMode = true;
			if (eventEnterVRMode != null)
			{
				eventEnterVRMode();
			}
		}

		public void LeaveVRMode()
		{
			Pvr_UnitySDKPluginEvent.Issue(RenderEventType.Pause);
			isEnterVRMode = false;
		}

		public void SixDofForceQuit()
		{
			Application.Quit();
		}

		private void InitUI()
		{
			if (iPhoneHMDModeEnabled == 1)
			{
				Transform transform = UnityEngine.Object.Instantiate(Resources.Load("Prefabs/flamingo2Tips") as GameObject, base.transform.Find("Head"), worldPositionStays: false).transform;
				calltoast = transform.Find("Call").gameObject;
				msgtoast = transform.Find("Msg").gameObject;
				lowhmdBatterytoast = transform.Find("LowHmdBattery").gameObject;
				lowphoneBatterytoast = transform.Find("LowPhoneBattery").gameObject;
				LowPhoneHealthtoast = transform.Find("LowPhoneHealth").gameObject;
				LowcontrollerBatterytoast = transform.Find("LowControllerBattery").gameObject;
			}
		}

		private void RefreshTextByLanguage()
		{
			if (msgtoast != null)
			{
				msgtoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("msgtoast0");
				msgtoast.transform.Find("string").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("msgtoast1");
				calltoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("calltoast0");
				calltoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("calltoast1");
				lowhmdBatterytoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("lowhmdBatterytoast");
				lowphoneBatterytoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("lowphoneBatterytoast");
				LowPhoneHealthtoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("LowPhoneHealthtoast");
				LowcontrollerBatterytoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("LowcontrollerBatterytoast");
			}
		}

		private void LoadIsMirroringValue()
		{
			AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
			AndroidJavaObject androidJavaObject = @static.Call<AndroidJavaObject>("getPackageManager", Array.Empty<object>());
			string text = @static.Call<string>("getPackageName", Array.Empty<object>());
			AndroidJavaObject androidJavaObject2 = androidJavaObject.Call<AndroidJavaObject>("getApplicationInfo", new object[2] { text, 128 }).Get<AndroidJavaObject>("metaData");
			ismirroring = Convert.ToBoolean(androidJavaObject2.Call<int>("getInt", new object[2] { "bypass_presentation", 0 }));
		}

		private IEnumerator OnResume()
		{
			int ability6dof = 0;
			Render.UPvr_GetIntConfig(3, ref ability6dof);
			RefreshTextByLanguage();
			if (Pvr_UnitySDKSensor.Instance != null)
			{
				Pvr_UnitySDKSensor.Instance.StartUnitySDKSensor();
				int res = -1;
				Render.UPvr_GetIntConfig(8, ref res);
				if (res != 1)
				{
					int res2 = -1;
					Render.UPvr_GetIntConfig(11, ref res2);
					if (res2 != 8)
					{
						Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
					}
				}
			}
			if (Pvr_UnitySDKAPI.System.UPvr_IsPicoActivity())
			{
				PLOG.I("onresume set monoPresentation success ?-------------" + Pvr_UnitySDKAPI.System.UPvr_SetMonoPresentation());
				PLOG.I("onresume presentation existed ?-------------" + Pvr_UnitySDKAPI.System.UPvr_IsPresentationExisted());
			}
			for (int j = 0; j < Pvr_UnitySDKEyeManager.Instance.Eyes.Length; j++)
			{
				Pvr_UnitySDKEyeManager.Instance.Eyes[j].RefreshCameraPosition(Pvr_UnitySDKAPI.System.UPvr_GetIPD());
			}
			int waitNum = 15;
			Render.UPvr_GetIntConfig(20, ref waitNum);
			int resetNum = 10;
			Render.UPvr_GetIntConfig(21, ref resetNum);
			for (int i = 0; i < waitNum; i++)
			{
				if (i == resetNum && ResetTrackerOnLoad && ability6dof == 1)
				{
					UnityEngine.Debug.Log("Reset Tracker OnLoad");
					Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
				}
				yield return null;
			}
			EnterVRMode();
			Pvr_UnitySDKAPI.System.UPvr_StartHomeKeyReceiver(base.gameObject.name);
			Pvr_UnitySDKEye.setLevel = false;
			if (longPressHomeKeyAction != null)
			{
				longPressHomeKeyAction();
			}
			if (Render.UPvr_GetIntSysProc("pvrsist.foveation.level", ref SystemDebugFFRLevel))
			{
				Render.SetFoveatedRenderingLevel((EFoveationLevel)SystemDebugFFRLevel);
				UnityEngine.Debug.Log("DISFT OnResume Get System Debug ffr level is : " + SystemDebugFFRLevel);
			}
			else
			{
				UnityEngine.Debug.Log("DISFT OnResume Get System Debug ffr level Error,ffr level is : " + SystemDebugFFRLevel);
			}
			if (SystemDebugFFRLevel == -1)
			{
				Render.UPvr_GetIntConfig(22, ref SystemFFRLevel);
				if (SystemFFRLevel != -1)
				{
					Render.SetFoveatedRenderingLevel((EFoveationLevel)SystemFFRLevel);
					UnityEngine.Debug.Log("DISFT OnResume Get System ffr level is : " + SystemFFRLevel);
				}
			}
		}
	}
	public class QuitGame : MonoBehaviour
	{
		private void Start()
		{
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.Escape))
			{
				Application.Quit();
			}
		}
	}
	public class Pvr_UnityEyeMask : MonoBehaviour
	{
		private class EyeMaskData
		{
			public Eye eyeSide;

			public Camera camera;

			public CommandBuffer cmdBuf;
		}

		private Shader eyeMaskShader;

		private Material eyeMaskMaterial;

		private Mesh eyeMaskMeshLeft;

		private Mesh eyeMaskMeshRight;

		private Mesh eyeMaskMeshBoth;

		private float zDir = -1f;

		private Color eyeMaskColor = Color.black;

		private List<EyeMaskData> cameraDataList = new List<EyeMaskData>();

		private void Awake()
		{
			UnityEngine.Debug.Log("DISFT EyeMask = Enable");
			if (SystemInfo.graphicsDeviceType == GraphicsDeviceType.OpenGLES3 || SystemInfo.graphicsDeviceType == GraphicsDeviceType.OpenGLES2)
			{
				zDir = -1f;
			}
			else if (SystemInfo.usesReversedZBuffer)
			{
				zDir = 1f;
			}
			else
			{
				zDir = 0f;
			}
		}

		private void OnEnable()
		{
			if (eyeMaskShader == null)
			{
				eyeMaskShader = Shader.Find("Pvr_UnitySDK/Pvr_EyeMask");
			}
			if (eyeMaskMaterial == null && eyeMaskShader != null)
			{
				eyeMaskMaterial = new Material(eyeMaskShader);
				eyeMaskMaterial.SetColor("_Color", eyeMaskColor);
			}
			if (eyeMaskMaterial == null)
			{
				base.enabled = false;
				UnityEngine.Debug.LogWarning("EyeMask materil is null or EyeMask shader not found!");
			}
			else
			{
				PrepareCameras();
				Camera.onPreRender = (Camera.CameraCallback)Delegate.Combine(Camera.onPreRender, new Camera.CameraCallback(OnCustomPreRender));
				CreateCommandBuffer();
			}
		}

		private void OnDisable()
		{
			Camera.onPreRender = (Camera.CameraCallback)Delegate.Remove(Camera.onPreRender, new Camera.CameraCallback(OnCustomPreRender));
			foreach (EyeMaskData cameraData in cameraDataList)
			{
				if (cameraData.camera != null && cameraData.cmdBuf != null)
				{
					RemoveCameraCommandBuffer(cameraData);
				}
			}
			CleanEyeMask();
		}

		private void CreateCommandBuffer()
		{
			if (VerifyCommadBuffer())
			{
				return;
			}
			if (eyeMaskMeshLeft == null || eyeMaskMeshRight == null)
			{
				eyeMaskMeshLeft = GetStencilMesh(Eye.LeftEye);
				eyeMaskMeshRight = GetStencilMesh(Eye.RightEye);
				if (eyeMaskMeshLeft == null || eyeMaskMeshRight == null)
				{
					UnityEngine.Debug.LogWarning("Stencil Mesh is not exist, disable EyeMask.");
					base.enabled = false;
					return;
				}
			}
			foreach (EyeMaskData cameraData in cameraDataList)
			{
				if (cameraData.eyeSide == Eye.LeftEye)
				{
					CommandBuffer commandBuffer = new CommandBuffer();
					commandBuffer.name = "EyeMaskLeft";
					commandBuffer.DrawMesh(eyeMaskMeshLeft, Matrix4x4.identity, eyeMaskMaterial, 0, 0);
					cameraData.cmdBuf = commandBuffer;
				}
				else if (cameraData.eyeSide == Eye.RightEye)
				{
					CommandBuffer commandBuffer2 = new CommandBuffer();
					commandBuffer2.name = "EyeMaskRight";
					commandBuffer2.DrawMesh(eyeMaskMeshRight, Matrix4x4.identity, eyeMaskMaterial, 0, 0);
					cameraData.cmdBuf = commandBuffer2;
				}
				else if (cameraData.eyeSide == Eye.BothEye)
				{
					if (eyeMaskMeshBoth == null)
					{
						eyeMaskMeshBoth = GetStencilMeshBoth(eyeMaskMeshLeft, eyeMaskMeshRight);
						float value = Mathf.Max(Mathf.Abs(eyeMaskMeshLeft.bounds.max.x), Mathf.Abs(eyeMaskMeshRight.bounds.min.x));
						eyeMaskMaterial.SetFloat("_MeshOffsetX", value);
					}
					CommandBuffer commandBuffer3 = new CommandBuffer();
					commandBuffer3.name = "EyeMaskBoth";
					commandBuffer3.DrawMesh(eyeMaskMeshBoth, Matrix4x4.identity, eyeMaskMaterial, 0, 1);
					cameraData.cmdBuf = commandBuffer3;
				}
			}
		}

		private void OnCustomPreRender(Camera cam)
		{
			if (!VerifyCommadBuffer())
			{
				UnityEngine.Debug.LogWarning("Verify CommandBuffer failed!");
				return;
			}
			foreach (EyeMaskData cameraData in cameraDataList)
			{
				if (!(cameraData.camera != cam))
				{
					RemoveCameraCommandBuffer(cameraData);
					AddCameraCommandBuffer(cameraData);
				}
			}
		}

		private Mesh GetStencilMesh(Eye eyeSide)
		{
			int vertexCount = 0;
			int triangleCount = 0;
			IntPtr vertexDataPtr = IntPtr.Zero;
			IntPtr indexDataPtr = IntPtr.Zero;
			Render.UPvr_GetStencilMesh((int)eyeSide, ref vertexCount, ref triangleCount, ref vertexDataPtr, ref indexDataPtr);
			if (vertexCount <= 0 || triangleCount <= 0 || vertexDataPtr == IntPtr.Zero || indexDataPtr == IntPtr.Zero)
			{
				return null;
			}
			Vector3[] array = new Vector3[vertexCount];
			int[] array2 = new int[triangleCount * 3];
			float[] array3 = new float[vertexCount * 3];
			int[] array4 = new int[triangleCount * 3];
			Marshal.Copy(vertexDataPtr, array3, 0, vertexCount * 3);
			Marshal.Copy(indexDataPtr, array4, 0, triangleCount * 3);
			for (int i = 0; i < vertexCount; i++)
			{
				array[i] = new Vector3(array3[3 * i], array3[3 * i + 1], zDir);
			}
			for (int j = 0; j < triangleCount; j++)
			{
				array2[3 * j] = array4[3 * j + 2];
				array2[3 * j + 1] = array4[3 * j + 1];
				array2[3 * j + 2] = array4[3 * j];
			}
			Mesh mesh = new Mesh();
			mesh.name = "EyeMaskMesh";
			mesh.vertices = array;
			mesh.SetIndices(array2, MeshTopology.Triangles, 0);
			return mesh;
		}

		private Mesh GetStencilMeshBoth(Mesh leftMesh, Mesh rightMesh)
		{
			float num = Mathf.Max(Mathf.Abs(leftMesh.bounds.max.x), Mathf.Abs(rightMesh.bounds.min.x));
			Mesh mesh = new Mesh();
			mesh.name = "EyeMaskBoth";
			CombineInstance combineInstance = default(CombineInstance);
			combineInstance.mesh = leftMesh;
			Matrix4x4 identity = Matrix4x4.identity;
			identity.SetTRS(Vector3.left * num, Quaternion.identity, Vector3.one);
			combineInstance.transform = identity;
			CombineInstance combineInstance2 = default(CombineInstance);
			combineInstance2.mesh = rightMesh;
			Matrix4x4 identity2 = Matrix4x4.identity;
			identity2.SetTRS(Vector3.right * num, Quaternion.identity, Vector3.one);
			combineInstance2.transform = identity2;
			CombineInstance[] combine = new CombineInstance[2] { combineInstance, combineInstance2 };
			mesh.CombineMeshes(combine);
			return mesh;
		}

		private bool VerifyCommadBuffer()
		{
			if (cameraDataList == null || cameraDataList.Count <= 0)
			{
				return false;
			}
			foreach (EyeMaskData cameraData in cameraDataList)
			{
				if (cameraData == null || cameraData.cmdBuf == null)
				{
					return false;
				}
			}
			return true;
		}

		private void PrepareCameras()
		{
			cameraDataList.Clear();
			if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
			{
				if (Pvr_UnitySDKEyeManager.Instance.BothEyeCamera == null)
				{
					UnityEngine.Debug.LogWarning("BothEye Camera is null!");
					return;
				}
				EyeMaskData eyeMaskData = new EyeMaskData();
				eyeMaskData.eyeSide = Eye.BothEye;
				eyeMaskData.camera = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
				cameraDataList.Add(eyeMaskData);
			}
			else if (Pvr_UnitySDKEyeManager.Instance.LeftEyeCamera == null || Pvr_UnitySDKEyeManager.Instance.RightEyeCamera == null)
			{
				UnityEngine.Debug.LogWarning("LeftEye or RightEye Camera is null!");
			}
			else
			{
				EyeMaskData eyeMaskData2 = new EyeMaskData();
				eyeMaskData2.eyeSide = Eye.LeftEye;
				eyeMaskData2.camera = Pvr_UnitySDKEyeManager.Instance.LeftEyeCamera;
				eyeMaskData2.cmdBuf = null;
				cameraDataList.Add(eyeMaskData2);
				EyeMaskData eyeMaskData3 = new EyeMaskData();
				eyeMaskData3.eyeSide = Eye.RightEye;
				eyeMaskData3.camera = Pvr_UnitySDKEyeManager.Instance.RightEyeCamera;
				eyeMaskData3.cmdBuf = null;
				cameraDataList.Add(eyeMaskData3);
			}
		}

		private void AddCameraCommandBuffer(EyeMaskData data)
		{
			data.camera.AddCommandBuffer(CameraEvent.BeforeForwardOpaque, data.cmdBuf);
		}

		private void RemoveCameraCommandBuffer(EyeMaskData data)
		{
			data.camera.RemoveCommandBuffer(CameraEvent.BeforeForwardOpaque, data.cmdBuf);
		}

		private void CleanEyeMask()
		{
			cameraDataList.Clear();
			eyeMaskMeshLeft = null;
			eyeMaskMeshRight = null;
			eyeMaskMeshBoth = null;
			eyeMaskShader = null;
			eyeMaskMaterial = null;
		}
	}
	[RequireComponent(typeof(Camera))]
	public class Pvr_UnitySDKEye : MonoBehaviour
	{
		public static List<Pvr_UnitySDKEye> Instances = new List<Pvr_UnitySDKEye>();

		public Eye eyeSide;

		private int eyeCameraOriginCullingMask;

		private CameraClearFlags eyeCameraOriginClearFlag;

		private Color eyeCameraOriginBackgroundColor;

		private int lastBoundaryState;

		private Matrix4x4 realProj = Matrix4x4.identity;

		private const int bufferSize = 3;

		private int IDIndex;

		private RenderEventType eventType;

		private int previousId;

		public static bool setLevel = false;

		private Material mat_Vignette;

		public Camera eyecamera { get; private set; }

		private void Awake()
		{
			Instances.Add(this);
			eyecamera = GetComponent<Camera>();
		}

		private void Start()
		{
			Setup(eyeSide);
			SetupUpdate();
			if (eyecamera != null)
			{
				eyeCameraOriginCullingMask = eyecamera.cullingMask;
				eyeCameraOriginClearFlag = eyecamera.clearFlags;
				eyeCameraOriginBackgroundColor = eyecamera.backgroundColor;
			}
		}

		private void Update()
		{
			if (!(eyecamera != null) || !eyecamera.enabled)
			{
				return;
			}
			int num = BoundarySystem.UPvr_GetSeeThroughState();
			if (num == lastBoundaryState)
			{
				return;
			}
			switch (num)
			{
			case 2:
				eyeCameraOriginCullingMask = eyecamera.cullingMask;
				eyeCameraOriginClearFlag = eyecamera.clearFlags;
				eyeCameraOriginBackgroundColor = eyecamera.backgroundColor;
				eyecamera.cullingMask = 0;
				eyecamera.clearFlags = CameraClearFlags.Color;
				eyecamera.backgroundColor = Color.black;
				break;
			case 1:
				if (lastBoundaryState == 2)
				{
					if (eyecamera.cullingMask == 0)
					{
						eyecamera.cullingMask = eyeCameraOriginCullingMask;
					}
					if (eyecamera.clearFlags == CameraClearFlags.Color)
					{
						eyecamera.clearFlags = eyeCameraOriginClearFlag;
					}
					if (eyecamera.backgroundColor == Color.black)
					{
						eyecamera.backgroundColor = eyeCameraOriginBackgroundColor;
					}
				}
				break;
			default:
				if (lastBoundaryState == 2 || lastBoundaryState == 1)
				{
					if (eyecamera.cullingMask == 0)
					{
						eyecamera.cullingMask = eyeCameraOriginCullingMask;
					}
					if (eyecamera.clearFlags == CameraClearFlags.Color)
					{
						eyecamera.clearFlags = eyeCameraOriginClearFlag;
					}
					if (eyecamera.backgroundColor == Color.black)
					{
						eyecamera.backgroundColor = eyeCameraOriginBackgroundColor;
					}
				}
				break;
			}
			lastBoundaryState = num;
		}

		private void OnEnable()
		{
			if (GraphicsSettings.renderPipelineAsset != null)
			{
				RenderPipelineManager.beginCameraRendering += MyPreRender;
				RenderPipelineManager.endCameraRendering += MyPostRender;
			}
		}

		private void OnDisable()
		{
			if (GraphicsSettings.renderPipelineAsset != null)
			{
				RenderPipelineManager.beginCameraRendering -= MyPreRender;
				RenderPipelineManager.endCameraRendering -= MyPostRender;
			}
		}

		private void OnDestroy()
		{
			Instances.Remove(this);
		}

		public void MyPreRender(Camera camera)
		{
			if (!(camera.gameObject != base.gameObject))
			{
				OnPreRender();
			}
		}

		public void MyPreRender(ScriptableRenderContext context, Camera camera)
		{
			if (!(camera.gameObject != base.gameObject))
			{
				OnPreRender();
			}
		}

		public void MyPostRender(ScriptableRenderContext context, Camera camera)
		{
			if (!(camera.gameObject != base.gameObject))
			{
				OnPostRender();
			}
		}

		private void OnPreRender()
		{
			if (!eyecamera.enabled)
			{
				return;
			}
			if (Pvr_UnitySDKRender.Instance.StereoRendering != null)
			{
				if (Pvr_UnitySDKRender.Instance.isSwitchSDK)
				{
					return;
				}
				Pvr_UnitySDKRender.Instance.StereoRendering.OnSDKPreRender();
			}
			SetFFRParameter();
			Pvr_UnitySDKPluginEvent.Issue(RenderEventType.BeginEye);
		}

		private void OnPostRender()
		{
			if (!eyecamera.enabled)
			{
				return;
			}
			Pvr_UnitySDKAPI.System.UPvr_UnityEventData(Pvr_UnitySDKAPI.System.UPvr_GetEyeBufferData(Pvr_UnitySDKRender.Instance.eyeTextureIds[IDIndex]));
			Pvr_UnitySDKPluginEvent.Issue(eventType);
			if (Pvr_UnitySDKRender.Instance.StereoRendering != null)
			{
				if (Pvr_UnitySDKRender.Instance.isSwitchSDK)
				{
					return;
				}
				Pvr_UnitySDKRender.Instance.StereoRendering.OnSDKPostRender();
			}
			Pvr_UnitySDKPluginEvent.Issue(RenderEventType.EndEye);
		}

		public void EyeRender()
		{
			SetupUpdate();
			if (Pvr_UnitySDKRender.Instance.eyeTextures[IDIndex] != null)
			{
				Pvr_UnitySDKRender.Instance.eyeTextures[IDIndex].DiscardContents();
				eyecamera.targetTexture = Pvr_UnitySDKRender.Instance.eyeTextures[IDIndex];
			}
		}

		private void Setup(Eye eyeSide)
		{
			eyecamera = GetComponent<Camera>();
			switch (eyeSide)
			{
			case Eye.LeftEye:
			case Eye.RightEye:
				base.transform.localPosition = Pvr_UnitySDKManager.SDK.EyeOffset(eyeSide);
				break;
			case Eye.BothEye:
				base.transform.localPosition = Vector3.zero;
				break;
			}
			eyecamera.aspect = Pvr_UnitySDKManager.SDK.EyesAspect;
			eyecamera.rect = new Rect(0f, 0f, 1f, 1f);
			if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.MultiPass)
			{
				eventType = ((eyeSide == Eye.LeftEye) ? RenderEventType.LeftEyeEndFrame : RenderEventType.RightEyeEndFrame);
			}
			else
			{
				eventType = RenderEventType.BothEyeEndFrame;
			}
		}

		private void SetupUpdate()
		{
			if (eyeSide == Eye.LeftEye || eyeSide == Eye.RightEye)
			{
				eyecamera.enabled = !Pvr_UnitySDKManager.SDK.Monoscopic && Pvr_UnitySDKRender.Instance.StereoRenderPath != StereoRenderingPathPico.SinglePass;
			}
			else if (eyeSide == Eye.BothEye)
			{
				eyecamera.enabled = Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass;
			}
			eyecamera.fieldOfView = Pvr_UnitySDKRender.Instance.EyeVFoV;
			eyecamera.aspect = Pvr_UnitySDKManager.SDK.EyesAspect;
			if (eyeSide == Eye.LeftEye || eyeSide == Eye.RightEye)
			{
				IDIndex = Pvr_UnitySDKRender.Instance.currEyeTextureIdx + (int)eyeSide * 3;
			}
			else if (eyeSide == Eye.BothEye)
			{
				IDIndex = Pvr_UnitySDKRender.Instance.currEyeTextureIdx;
				Pvr_UnitySDKRender.Instance.isSwitchSDK = Pvr_UnitySDKRender.Instance.lastEyeTextureIdx == Pvr_UnitySDKRender.Instance.currEyeTextureIdx;
				Pvr_UnitySDKRender.Instance.lastEyeTextureIdx = Pvr_UnitySDKRender.Instance.currEyeTextureIdx;
			}
		}

		public void RefreshCameraPosition(float ipd)
		{
			Pvr_UnitySDKManager.SDK.leftEyeOffset = new Vector3((0f - ipd) / 2f, 0f, 0f);
			Pvr_UnitySDKManager.SDK.rightEyeOffset = new Vector3(ipd / 2f, 0f, 0f);
			if (eyeSide == Eye.LeftEye || eyeSide == Eye.RightEye)
			{
				base.transform.localPosition = Pvr_UnitySDKManager.SDK.EyeOffset(eyeSide);
			}
			else if (eyeSide == Eye.BothEye)
			{
				eyecamera.stereoSeparation = ipd;
			}
		}

		private void DrawVignetteLine()
		{
			if (null == mat_Vignette)
			{
				mat_Vignette = new Material(Shader.Find("Diffuse"));
				if (null == mat_Vignette)
				{
					return;
				}
			}
			GL.PushMatrix();
			mat_Vignette.SetPass(0);
			GL.LoadOrtho();
			vignette();
			GL.PopMatrix();
		}

		private void vignette()
		{
			GL.Begin(7);
			GL.Color(Color.black);
			GL.Vertex3(0f, 1f, 0f);
			GL.Vertex3(1f, 1f, 0f);
			GL.Vertex3(1f, 0.995f, 0f);
			GL.Vertex3(0f, 0.995f, 0f);
			GL.Vertex3(0f, 0f, 0f);
			GL.Vertex3(0f, 0.005f, 0f);
			GL.Vertex3(1f, 0.005f, 0f);
			GL.Vertex3(1f, 0f, 0f);
			GL.Vertex(new Vector3(0f, 1f, 0f));
			GL.Vertex(new Vector3(0.005f, 1f, 0f));
			GL.Vertex(new Vector3(0.005f, 0f, 0f));
			GL.Vertex(new Vector3(0f, 0f, 0f));
			GL.Vertex(new Vector3(0.995f, 1f, 0f));
			GL.Vertex(new Vector3(1f, 1f, 0f));
			GL.Vertex(new Vector3(1f, 0f, 0f));
			GL.Vertex(new Vector3(0.995f, 0f, 0f));
			GL.End();
		}

		private void SetFFRParameter()
		{
			Vector3 vector = Vector3.zero;
			if (Pvr_UnitySDKManager.SDK.isEnterVRMode && Pvr_UnitySDKEyeManager.supportEyeTracking && Pvr_UnitySDKEyeManager.Instance.EyeTracking)
			{
				vector = Pvr_UnitySDKAPI.System.UPvr_getEyeTrackingPos();
			}
			int textureId = Pvr_UnitySDKRender.Instance.eyeTextureIds[IDIndex];
			Render.UPvr_SetFoveationResource(textureId, previousId, vector.x, vector.y);
			previousId = textureId;
		}
	}
	public class Pvr_UnitySDKEyeManager : MonoBehaviour
	{
		private static Pvr_UnitySDKEyeManager instance;

		private Pvr_UnitySDKEye[] eyes;

		[HideInInspector]
		public Camera LeftEyeCamera;

		[HideInInspector]
		public Camera RightEyeCamera;

		[HideInInspector]
		public Camera MonoEyeCamera;

		[HideInInspector]
		public Camera BothEyeCamera;

		private int MonoEyeTextureID;

		private readonly int WaitSplashScreenFrames = 3;

		private int frameNum;

		[SerializeField]
		[HideInInspector]
		private bool foveatedRendering;

		[SerializeField]
		[HideInInspector]
		private EFoveationLevel foveationLevel;

		private int eyeTextureId;

		private RenderEventType eventType = RenderEventType.LeftEyeEndFrame;

		private Pvr_UnitySDKEyeOverlay compositeLayer;

		private int overlayLayerDepth = 1;

		private int underlayLayerDepth;

		private bool isHeadLocked;

		private int layerFlags;

		[HideInInspector]
		public bool EyeTracking;

		[HideInInspector]
		public Vector3 eyePoint;

		private EyeTrackingData eyePoseData;

		[HideInInspector]
		public static bool supportEyeTracking;

		[Tooltip("If true, specific color gradient when switching scenes.")]
		public bool screenFade;

		[Tooltip("Define the duration of screen fade.")]
		public float fadeTime = 5f;

		[Tooltip("Define the color of screen fade.")]
		public Color fadeColor = new Color(0f, 0f, 0f, 1f);

		public int renderQueue = 5000;

		private MeshRenderer fadeMeshRenderer;

		private MeshFilter fadeMeshFilter;

		private Material fadeMaterial;

		private float elapsedTime;

		private bool isFading;

		private float currentAlpha;

		private float nowFadeAlpha;

		public static Pvr_UnitySDKEyeManager Instance
		{
			get
			{
				if (instance == null)
				{
					PLOG.E("Pvr_UnitySDKEyeManager instance is not init yet...");
				}
				return instance;
			}
		}

		public Pvr_UnitySDKEye[] Eyes
		{
			get
			{
				if (eyes == null)
				{
					eyes = Pvr_UnitySDKEye.Instances.ToArray();
				}
				return eyes;
			}
		}

		[HideInInspector]
		public bool FoveatedRendering
		{
			get
			{
				return foveatedRendering;
			}
			set
			{
				if (value == foveatedRendering)
				{
					return;
				}
				foveatedRendering = value;
				if (Application.isPlaying)
				{
					Render.UPvr_EnableFoveation(enable: true);
					if (!foveatedRendering)
					{
						Render.SetFoveatedRenderingLevel((EFoveationLevel)(-1));
					}
				}
			}
		}

		[HideInInspector]
		public EFoveationLevel FoveationLevel
		{
			get
			{
				return foveationLevel;
			}
			set
			{
				if (value != foveationLevel)
				{
					foveationLevel = value;
				}
			}
		}

		private void SetCameraEnableEditor()
		{
			MonoEyeCamera.enabled = !Pvr_UnitySDKManager.SDK.VRModeEnabled || Pvr_UnitySDKManager.SDK.Monoscopic;
			for (int i = 0; i < Eyes.Length; i++)
			{
				if (Eyes[i].eyeSide == Eye.LeftEye || Eyes[i].eyeSide == Eye.RightEye)
				{
					Eyes[i].eyecamera.enabled = Pvr_UnitySDKManager.SDK.VRModeEnabled;
				}
				else if (Eyes[i].eyeSide == Eye.BothEye)
				{
					Eyes[i].eyecamera.enabled = false;
				}
			}
		}

		private void SetCamerasEnableByStereoRendering()
		{
			MonoEyeCamera.enabled = Pvr_UnitySDKManager.SDK.Monoscopic && Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.MultiPass;
		}

		private void SetupMonoCamera()
		{
			base.transform.localPosition = Vector3.zero;
			MonoEyeCamera.aspect = Pvr_UnitySDKManager.SDK.EyesAspect;
			MonoEyeCamera.rect = new Rect(0f, 0f, 1f, 1f);
		}

		private void SetupUpdate()
		{
			MonoEyeCamera.fieldOfView = Pvr_UnitySDKRender.Instance.EyeVFoV;
			MonoEyeCamera.aspect = Pvr_UnitySDKManager.SDK.EyesAspect;
			MonoEyeTextureID = Pvr_UnitySDKRender.Instance.currEyeTextureIdx;
		}

		private void MonoEyeRender()
		{
			SetupUpdate();
			if (Pvr_UnitySDKRender.Instance.eyeTextures[MonoEyeTextureID] != null)
			{
				Pvr_UnitySDKRender.Instance.eyeTextures[MonoEyeTextureID].DiscardContents();
				MonoEyeCamera.targetTexture = Pvr_UnitySDKRender.Instance.eyeTextures[MonoEyeTextureID];
			}
		}

		private void Awake()
		{
			if (MonoEyeCamera == null)
			{
				MonoEyeCamera = GetComponent<Camera>();
			}
			if (LeftEyeCamera == null)
			{
				LeftEyeCamera = base.gameObject.transform.Find("LeftEye").GetComponent<Camera>();
			}
			if (RightEyeCamera == null)
			{
				RightEyeCamera = base.gameObject.transform.Find("RightEye").GetComponent<Camera>();
			}
			if (BothEyeCamera == null)
			{
				BothEyeCamera = base.gameObject.transform.Find("BothEye").GetComponent<Camera>();
			}
			if (BothEyeCamera != null)
			{
				BothEyeCamera.transform.GetComponent<Pvr_UnitySDKEye>().eyeSide = Eye.BothEye;
			}
			CreateFadeMesh();
			SetCurrentAlpha(0f);
			Render.UPvr_EnableFoveation(enable: true);
			if (foveatedRendering)
			{
				Render.SetFoveatedRenderingLevel(foveationLevel);
			}
			else
			{
				Render.SetFoveatedRenderingLevel((EFoveationLevel)(-1));
			}
			Pvr_UnitySDKManager.eventEnterVRMode = (Func<bool>)Delegate.Combine(Pvr_UnitySDKManager.eventEnterVRMode, new Func<bool>(SetEyeTrackingMode));
		}

		private void OnEnable()
		{
			if (instance == null)
			{
				instance = this;
			}
			else if (instance != this)
			{
				instance = this;
			}
			if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
			{
				Pvr_UnitySDKRender.Instance.StereoRendering.InitEye(BothEyeCamera);
			}
			foreach (Pvr_UnitySDKEyeOverlay instance in Pvr_UnitySDKEyeOverlay.Instances)
			{
				instance.RefreshCamera();
				if (instance.overlayType == Pvr_UnitySDKEyeOverlay.OverlayType.Overlay)
				{
					if (instance.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Cylinder)
					{
						UnityEngine.Debug.Log("DISFT Cylinder OverLay = Enable");
					}
					if (instance.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Equirect)
					{
						UnityEngine.Debug.Log("DISFT 360 OverLay= Enable");
					}
					if (instance.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Quad)
					{
						UnityEngine.Debug.Log("DISFT 2D OverLay= Enable");
					}
				}
				if (instance.overlayType == Pvr_UnitySDKEyeOverlay.OverlayType.Underlay)
				{
					UnityEngine.Debug.Log("DISFT UnderLay= Enable");
				}
			}
			GfxDeviceAdvanceFrameGLES();
			StartCoroutine("EndOfFrame");
			if (screenFade)
			{
				StartCoroutine(ScreenFade(1f, 0f));
			}
		}

		private void Start()
		{
			SetCamerasEnableByStereoRendering();
			SetupMonoCamera();
		}

		private void Update()
		{
			if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
			{
				for (int i = 0; i < Eyes.Length; i++)
				{
					if (Eyes[i].isActiveAndEnabled && Eyes[i].eyeSide == Eye.BothEye)
					{
						Eyes[i].EyeRender();
					}
				}
			}
			if (Pvr_UnitySDKRender.Instance.StereoRenderPath != 0)
			{
				return;
			}
			if (!Pvr_UnitySDKManager.SDK.Monoscopic)
			{
				for (int j = 0; j < Eyes.Length; j++)
				{
					if (Eyes[j].isActiveAndEnabled && Eyes[j].eyeSide != Eye.BothEye)
					{
						Eyes[j].EyeRender();
					}
				}
			}
			else
			{
				MonoEyeRender();
			}
		}

		private void OnPause()
		{
			Pvr_UnitySDKManager.eventEnterVRMode = (Func<bool>)Delegate.Remove(Pvr_UnitySDKManager.eventEnterVRMode, new Func<bool>(SetEyeTrackingMode));
		}

		private void OnDisable()
		{
			StopAllCoroutines();
		}

		private void OnDestroy()
		{
			DestoryFadeMesh();
		}

		private void OnPostRender()
		{
			long data = Pvr_UnitySDKAPI.System.UPvr_GetEyeBufferData(Pvr_UnitySDKRender.Instance.eyeTextureIds[Pvr_UnitySDKRender.Instance.currEyeTextureIdx]);
			Pvr_UnitySDKAPI.System.UPvr_UnityEventData(data);
			Pvr_UnitySDKPluginEvent.Issue(RenderEventType.LeftEyeEndFrame);
			Pvr_UnitySDKAPI.System.UPvr_UnityEventData(data);
			Pvr_UnitySDKPluginEvent.Issue(RenderEventType.RightEyeEndFrame);
		}

		private IEnumerator EndOfFrame()
		{
			while (true)
			{
				yield return new WaitForEndOfFrame();
				if (!Pvr_UnitySDKManager.SDK.isEnterVRMode)
				{
					GL.Clear(clearDepth: false, clearColor: true, Color.black);
				}
				if (Pvr_UnitySDKRender.Instance.isFirstStartup && frameNum == WaitSplashScreenFrames)
				{
					Pvr_UnitySDKAPI.System.UPvr_RemovePlatformLogo();
					if (Pvr_UnitySDKManager.SDK.ResetTrackerOnLoad)
					{
						UnityEngine.Debug.Log("Reset Tracker OnLoad");
						Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
					}
					Pvr_UnitySDKAPI.System.UPvr_StartVRModel();
					Pvr_UnitySDKRender.Instance.isFirstStartup = false;
				}
				else if (Pvr_UnitySDKRender.Instance.isFirstStartup && frameNum < WaitSplashScreenFrames)
				{
					PLOG.I("frameNum:" + frameNum);
					frameNum++;
				}
				int num = BoundarySystem.UPvr_GetSeeThroughState();
				if (Pvr_UnitySDKEyeOverlay.Instances.Count > 0 && num != 2)
				{
					overlayLayerDepth = 1;
					underlayLayerDepth = 0;
					Pvr_UnitySDKEyeOverlay.Instances.Sort();
					for (int i = 0; i < Pvr_UnitySDKEyeOverlay.Instances.Count; i++)
					{
						compositeLayer = Pvr_UnitySDKEyeOverlay.Instances[i];
						if (!compositeLayer.isActiveAndEnabled || (compositeLayer.layerTextures[0] == null && compositeLayer.layerTextures[1] == null && !compositeLayer.isExternalAndroidSurface) || (compositeLayer.layerTransform != null && !compositeLayer.layerTransform.gameObject.activeSelf))
						{
							continue;
						}
						layerFlags = 0;
						if (compositeLayer.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Quad || compositeLayer.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Cylinder)
						{
							if (compositeLayer.overlayType == Pvr_UnitySDKEyeOverlay.OverlayType.Overlay)
							{
								isHeadLocked = false;
								if (compositeLayer.layerTransform != null && compositeLayer.layerTransform.parent == base.transform)
								{
									isHeadLocked = true;
								}
								if (compositeLayer.isExternalAndroidSurface)
								{
									layerFlags |= 1;
									CreateExternalSurface(compositeLayer, overlayLayerDepth);
								}
								Render.UPvr_SetOverlayModelViewMatrix((int)compositeLayer.overlayType, (int)compositeLayer.overlayShape, compositeLayer.layerTextureIds[0], 0, overlayLayerDepth, isHeadLocked, layerFlags, compositeLayer.MVMatrixs[0], compositeLayer.ModelScales[0], compositeLayer.ModelRotations[0], compositeLayer.ModelTranslations[0], compositeLayer.CameraRotations[0], compositeLayer.CameraTranslations[0], compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
								Render.UPvr_SetOverlayModelViewMatrix((int)compositeLayer.overlayType, (int)compositeLayer.overlayShape, compositeLayer.layerTextureIds[1], 1, overlayLayerDepth, isHeadLocked, layerFlags, compositeLayer.MVMatrixs[1], compositeLayer.ModelScales[1], compositeLayer.ModelRotations[1], compositeLayer.ModelTranslations[1], compositeLayer.CameraRotations[1], compositeLayer.CameraTranslations[1], compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
								overlayLayerDepth++;
							}
							else if (compositeLayer.overlayType == Pvr_UnitySDKEyeOverlay.OverlayType.Underlay)
							{
								if (compositeLayer.isExternalAndroidSurface)
								{
									layerFlags |= 1;
									CreateExternalSurface(compositeLayer, underlayLayerDepth);
								}
								Render.UPvr_SetOverlayModelViewMatrix((int)compositeLayer.overlayType, (int)compositeLayer.overlayShape, compositeLayer.layerTextureIds[0], 0, underlayLayerDepth, isHeadLocked: false, layerFlags, compositeLayer.MVMatrixs[0], compositeLayer.ModelScales[0], compositeLayer.ModelRotations[0], compositeLayer.ModelTranslations[0], compositeLayer.CameraRotations[0], compositeLayer.CameraTranslations[0], compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
								Render.UPvr_SetOverlayModelViewMatrix((int)compositeLayer.overlayType, (int)compositeLayer.overlayShape, compositeLayer.layerTextureIds[1], 1, underlayLayerDepth, isHeadLocked: false, layerFlags, compositeLayer.MVMatrixs[1], compositeLayer.ModelScales[1], compositeLayer.ModelRotations[1], compositeLayer.ModelTranslations[1], compositeLayer.CameraRotations[1], compositeLayer.CameraTranslations[1], compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
								underlayLayerDepth++;
							}
						}
						else if (compositeLayer.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Equirect)
						{
							if (compositeLayer.isExternalAndroidSurface)
							{
								layerFlags |= 1;
								CreateExternalSurface(compositeLayer, 0);
							}
							Render.UPvr_SetupLayerData(0, 0, compositeLayer.layerTextureIds[0], (int)compositeLayer.overlayShape, layerFlags, compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
							Render.UPvr_SetupLayerData(0, 1, compositeLayer.layerTextureIds[1], (int)compositeLayer.overlayShape, layerFlags, compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
						}
					}
				}
				Pvr_UnitySDKAPI.System.UPvr_UnityEventData(Pvr_UnitySDKAPI.System.UPvr_GetEyeBufferData(0));
				Pvr_UnitySDKPluginEvent.Issue(RenderEventType.TimeWarp);
				Pvr_UnitySDKRender.Instance.currEyeTextureIdx = Pvr_UnitySDKRender.Instance.nextEyeTextureIdx;
				Pvr_UnitySDKRender.Instance.nextEyeTextureIdx = (Pvr_UnitySDKRender.Instance.nextEyeTextureIdx + 1) % 3;
			}
		}

		private void CreateExternalSurface(Pvr_UnitySDKEyeOverlay overlayInstance, int layerDepth)
		{
			if (overlayInstance.externalAndroidSurfaceObject == IntPtr.Zero)
			{
				overlayInstance.externalAndroidSurfaceObject = Render.UPvr_CreateLayerAndroidSurface((int)overlayInstance.overlayType, layerDepth);
				UnityEngine.Debug.LogFormat("CreateExternalSurface: Overlay Type:{0}, LayerDepth:{1}, SurfaceObject:{2}", overlayInstance.overlayType, layerDepth, overlayInstance.externalAndroidSurfaceObject);
				if (overlayInstance.externalAndroidSurfaceObject != IntPtr.Zero && overlayInstance.externalAndroidSurfaceObjectCreated != null)
				{
					overlayInstance.externalAndroidSurfaceObjectCreated();
				}
			}
		}

		public bool SetEyeTrackingMode()
		{
			supportEyeTracking = (Pvr_UnitySDKAPI.System.UPvr_GetTrackingMode() & 4) != 0;
			bool result = false;
			if (EyeTracking && supportEyeTracking)
			{
				result = Pvr_UnitySDKAPI.System.UPvr_setTrackingMode(6);
			}
			UnityEngine.Debug.Log("SetEyeTrackingMode EyeTracking " + EyeTracking + " supportEyeTracking " + supportEyeTracking + " result " + result);
			return result;
		}

		public Vector3 GetEyeTrackingPos()
		{
			if (!Instance.EyeTracking)
			{
				return Vector3.zero;
			}
			bool flag = Pvr_UnitySDKAPI.System.UPvr_getEyeTrackingData(ref eyePoseData);
			if (!flag)
			{
				PLOG.E("UPvr_getEyeTrackingData failed " + flag);
				return Vector3.zero;
			}
			EyeDeviceInfo deviceInfo = GetDeviceInfo();
			Vector3 zero = Vector3.zero;
			zero.x = 0.5f * (deviceInfo.targetFrustumLeft.right - deviceInfo.targetFrustumLeft.left);
			zero.y = 0.5f * (deviceInfo.targetFrustumLeft.top - deviceInfo.targetFrustumLeft.bottom);
			zero.z = deviceInfo.targetFrustumLeft.near;
			Vector3 foveatedGazeDirection = eyePoseData.foveatedGazeDirection;
			float num = Vector3.Dot(foveatedGazeDirection, Vector3.forward);
			if (num > float.Epsilon)
			{
				eyePoint = foveatedGazeDirection * (zero.z / num);
				eyePoint.x /= zero.x;
				eyePoint.y /= zero.y;
			}
			return eyePoint;
		}

		private EyeDeviceInfo GetDeviceInfo()
		{
			float num = Mathf.Tan(Pvr_UnitySDKRender.Instance.EyeVFoV / 2f * ((float)Math.PI / 180f));
			float num2 = Mathf.Tan(Pvr_UnitySDKRender.Instance.EyeHFoV / 2f * ((float)Math.PI / 180f));
			EyeDeviceInfo result = default(EyeDeviceInfo);
			result.targetFrustumLeft.left = 0f - LeftEyeCamera.nearClipPlane * num2;
			result.targetFrustumLeft.right = LeftEyeCamera.nearClipPlane * num2;
			result.targetFrustumLeft.top = LeftEyeCamera.nearClipPlane * num;
			result.targetFrustumLeft.bottom = 0f - LeftEyeCamera.nearClipPlane * num;
			result.targetFrustumLeft.near = LeftEyeCamera.nearClipPlane;
			result.targetFrustumLeft.far = LeftEyeCamera.farClipPlane;
			result.targetFrustumRight.left = 0f - RightEyeCamera.nearClipPlane * num2;
			result.targetFrustumRight.right = RightEyeCamera.nearClipPlane * num2;
			result.targetFrustumRight.top = RightEyeCamera.nearClipPlane * num;
			result.targetFrustumRight.bottom = 0f - RightEyeCamera.nearClipPlane * num;
			result.targetFrustumRight.near = RightEyeCamera.nearClipPlane;
			result.targetFrustumRight.far = RightEyeCamera.farClipPlane;
			return result;
		}

		private void CreateFadeMesh()
		{
			fadeMaterial = new Material(Shader.Find("Pvr_UnitySDK/Fade"));
			fadeMeshFilter = base.gameObject.AddComponent<MeshFilter>();
			fadeMeshRenderer = base.gameObject.AddComponent<MeshRenderer>();
			Mesh mesh = new Mesh();
			fadeMeshFilter.mesh = mesh;
			Vector3[] array = new Vector3[4];
			float num = 2f;
			float num2 = 2f;
			float z = 1f;
			array[0] = new Vector3(0f - num, 0f - num2, z);
			array[1] = new Vector3(num, 0f - num2, z);
			array[2] = new Vector3(0f - num, num2, z);
			array[3] = new Vector3(num, num2, z);
			mesh.vertices = array;
			mesh.triangles = new int[6] { 0, 2, 1, 2, 3, 1 };
			mesh.normals = new Vector3[4]
			{
				-Vector3.forward,
				-Vector3.forward,
				-Vector3.forward,
				-Vector3.forward
			};
			mesh.uv = new Vector2[4]
			{
				new Vector2(0f, 0f),
				new Vector2(1f, 0f),
				new Vector2(0f, 1f),
				new Vector2(1f, 1f)
			};
		}

		private void DestoryFadeMesh()
		{
			if (fadeMeshRenderer != null)
			{
				UnityEngine.Object.Destroy(fadeMeshRenderer);
			}
			if (fadeMaterial != null)
			{
				UnityEngine.Object.Destroy(fadeMaterial);
			}
			if (fadeMeshFilter != null)
			{
				UnityEngine.Object.Destroy(fadeMeshFilter);
			}
		}

		public void SetCurrentAlpha(float alpha)
		{
			currentAlpha = alpha;
			SetMaterialAlpha();
		}

		private IEnumerator ScreenFade(float startAlpha, float endAlpha)
		{
			float elapsedTime = 0f;
			while (elapsedTime < fadeTime)
			{
				elapsedTime += Time.deltaTime;
				nowFadeAlpha = Mathf.Lerp(startAlpha, endAlpha, Mathf.Clamp01(elapsedTime / fadeTime));
				SetMaterialAlpha();
				yield return new WaitForEndOfFrame();
			}
		}

		private void SetMaterialAlpha()
		{
			Color color = fadeColor;
			color.a = Mathf.Max(currentAlpha, nowFadeAlpha);
			isFading = color.a > 0f;
			if (fadeMaterial != null)
			{
				fadeMaterial.color = color;
				fadeMaterial.renderQueue = renderQueue;
				fadeMeshRenderer.material = fadeMaterial;
				fadeMeshRenderer.enabled = isFading;
			}
		}

		public bool GfxDeviceAdvanceFrameGLES()
		{
			MethodInfo[] methods = typeof(AndroidDevice).GetMethods();
			foreach (MethodInfo methodInfo in methods)
			{
				if (methodInfo.Name == "VRDeviceUseOwnSurface")
				{
					PLOG.I("Use VRDeviceUseOwnSurface");
					methodInfo.Invoke(null, null);
					return true;
				}
			}
			return false;
		}
	}
	public class Pvr_UnitySDKEyeOverlay : MonoBehaviour, IComparable<Pvr_UnitySDKEyeOverlay>
	{
		public delegate void ExternalAndroidSurfaceObjectCreated();

		public enum OverlayShape
		{
			Quad,
			Cylinder,
			Equirect
		}

		public enum OverlayType
		{
			Overlay,
			Underlay
		}

		public enum OverlayTexFilterMode
		{
			NotCare,
			Nearest,
			Linear,
			Nearest_Mipmap_Nearest,
			Linear_Mipmap_Nearest,
			Nearest_Mipmap_Linear,
			Linear_Mipmap_Linear
		}

		public static List<Pvr_UnitySDKEyeOverlay> Instances = new List<Pvr_UnitySDKEyeOverlay>();

		public int layerIndex;

		public OverlayType overlayType;

		public OverlayShape overlayShape;

		public Transform layerTransform;

		public Texture[] layerTextures = new Texture[2];

		public int[] layerTextureIds = new int[2];

		public Matrix4x4[] MVMatrixs = new Matrix4x4[2];

		public Vector3[] ModelScales = new Vector3[2];

		public Quaternion[] ModelRotations = new Quaternion[2];

		public Vector3[] ModelTranslations = new Vector3[2];

		public Quaternion[] CameraRotations = new Quaternion[2];

		public Vector3[] CameraTranslations = new Vector3[2];

		public Camera[] layerEyeCamera = new Camera[2];

		public bool overrideColorScaleAndOffset;

		public Vector4 colorScale = Vector4.one;

		public Vector4 colorOffset = Vector4.zero;

		private Vector4 overlayLayerColorScaleDefault = Vector4.one;

		private Vector4 overlayLayerColorOffsetDefault = Vector4.zero;

		public bool isExternalAndroidSurface;

		public IntPtr externalAndroidSurfaceObject = IntPtr.Zero;

		public ExternalAndroidSurfaceObjectCreated externalAndroidSurfaceObjectCreated;

		public int CompareTo(Pvr_UnitySDKEyeOverlay other)
		{
			return layerIndex.CompareTo(other.layerIndex);
		}

		private void Awake()
		{
			Instances.Add(this);
			if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
			{
				layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
				layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
			}
			else if (Pvr_UnitySDKManager.SDK.Monoscopic)
			{
				layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.MonoEyeCamera;
				layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.MonoEyeCamera;
			}
			else
			{
				layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.LeftEyeCamera;
				layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.RightEyeCamera;
			}
			layerTransform = GetComponent<Transform>();
			if (layerTransform != null)
			{
				MeshRenderer component = layerTransform.GetComponent<MeshRenderer>();
				if (component != null)
				{
					component.enabled = false;
				}
			}
			InitializeBuffer();
		}

		private void LateUpdate()
		{
			UpdateCoords();
		}

		private void OnDestroy()
		{
			Instances.Remove(this);
		}

		public void RefreshCamera()
		{
			if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
			{
				layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
				layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
			}
			else if (Pvr_UnitySDKManager.SDK.Monoscopic)
			{
				layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.MonoEyeCamera;
				layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.MonoEyeCamera;
			}
			else
			{
				layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.LeftEyeCamera;
				layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.RightEyeCamera;
			}
		}

		private void InitializeBuffer()
		{
			OverlayShape overlayShape = this.overlayShape;
			if ((uint)overlayShape > 2u)
			{
				return;
			}
			for (int i = 0; i < layerTextureIds.Length; i++)
			{
				if (layerTextures[i] != null)
				{
					layerTextureIds[i] = layerTextures[i].GetNativeTexturePtr().ToInt32();
				}
				else
				{
					UnityEngine.Debug.LogWarning($"{(Eye)i} Texture is null!");
				}
			}
		}

		private void UpdateCoords()
		{
			if (layerTransform == null || !layerTransform.gameObject.activeSelf || layerEyeCamera[0] == null || layerEyeCamera[1] == null)
			{
				return;
			}
			for (int i = 0; i < MVMatrixs.Length; i++)
			{
				if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
				{
					Matrix4x4[] stereoWorldToCameraMat = Pvr_UnitySDKSinglePass.GetStereoWorldToCameraMat();
					MVMatrixs[i] = stereoWorldToCameraMat[i] * layerTransform.localToWorldMatrix;
				}
				else
				{
					MVMatrixs[i] = layerEyeCamera[i].worldToCameraMatrix * layerTransform.localToWorldMatrix;
				}
				ModelScales[i] = layerTransform.localScale;
				ModelRotations[i] = layerTransform.rotation;
				ModelTranslations[i] = layerTransform.position;
				CameraRotations[i] = layerEyeCamera[i].transform.rotation;
				CameraTranslations[i] = layerEyeCamera[i].transform.position;
			}
		}

		public void SetTexture(Texture texture)
		{
			for (int i = 0; i < layerTextures.Length; i++)
			{
				layerTextures[i] = texture;
			}
			InitializeBuffer();
		}

		public void SetLayerColorScaleAndOffset(Vector4 scale, Vector4 offset)
		{
			colorScale = scale;
			colorOffset = offset;
		}

		public Vector4 GetLayerColorScale()
		{
			if (!overrideColorScaleAndOffset)
			{
				return overlayLayerColorScaleDefault;
			}
			return colorScale;
		}

		public Vector4 GetLayerColorOffset()
		{
			if (!overrideColorScaleAndOffset)
			{
				return overlayLayerColorOffsetDefault;
			}
			return colorOffset;
		}
	}
	public class Pvr_UnitySDKRender
	{
		private static Pvr_UnitySDKRender instance;

		public AndroidJavaObject activity;

		public static AndroidJavaClass javaVrActivityClass;

		public static AndroidJavaClass javaSysActivityClass;

		public static AndroidJavaClass javaserviceClass;

		public static AndroidJavaClass javaVrActivityLongReceiver;

		public static AndroidJavaClass javaVrActivityClientClass;

		private bool canConnecttoActivity;

		private bool isInitrenderThread = true;

		private string model;

		private Vector2 prefinger1 = new Vector2(0f, 0f);

		private Vector2 prefinger2 = new Vector2(0f, 0f);

		public int eyeTextureCount = 6;

		public RenderTexture[] eyeTextures;

		public int[] eyeTextureIds;

		public int currEyeTextureIdx;

		public int nextEyeTextureIdx = 1;

		public int lastEyeTextureIdx;

		public bool isSwitchSDK;

		public int RenderviewNumber;

		public bool isFirstStartup = true;

		public bool isShellMode;

		private StereoRenderingPathPico stereoRenderPath;

		private float rtScaleFactor = 1f;

		private float eyeVFov = 90f;

		private float eyeHFov = 90f;

		public static Pvr_UnitySDKRender Instance
		{
			get
			{
				if (instance == null)
				{
					instance = new Pvr_UnitySDKRender();
				}
				return instance;
			}
			set
			{
				instance = value;
			}
		}

		public StereoRenderingPathPico StereoRenderPath => stereoRenderPath;

		public SDKStereoRendering StereoRendering { get; private set; }

		public float RtScaleFactor
		{
			get
			{
				return rtScaleFactor;
			}
			set
			{
				if (value != rtScaleFactor)
				{
					rtScaleFactor = value;
					ReCreateEyeBuffer();
				}
			}
		}

		public float EyeVFoV
		{
			get
			{
				return eyeVFov;
			}
			set
			{
				if (value != eyeVFov)
				{
					eyeVFov = value;
				}
			}
		}

		public float EyeHFoV
		{
			get
			{
				return eyeHFov;
			}
			set
			{
				if (value != eyeHFov)
				{
					eyeHFov = value;
				}
			}
		}

		public Pvr_UnitySDKRender()
		{
			if (!canConnecttoActivity)
			{
				ConnectToAndriod();
				PLOG.I("PvrLog Init Render Ability Success!");
				isInitrenderThread = false;
			}
			Init();
		}

		public void ConnectToAndriod()
		{
			try
			{
				UnityEngine.Debug.Log("PvrLog SDK Version :  " + Pvr_UnitySDKAPI.System.UPvr_GetSDKVersion().ToString() + "  Unity Script Version :" + Pvr_UnitySDKAPI.System.UPvr_GetUnitySDKVersion().ToString());
				AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
				activity = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
				javaVrActivityClass = new AndroidJavaClass("com.psmart.vrlib.VrActivity");
				javaserviceClass = new AndroidJavaClass("com.picovr.picovrlib.hummingbirdclient.UnityClient");
				javaVrActivityLongReceiver = new AndroidJavaClass("com.psmart.vrlib.HomeKeyReceiver");
				javaSysActivityClass = new AndroidJavaClass("com.psmart.aosoperation.SysActivity");
				javaVrActivityClientClass = new AndroidJavaClass("com.psmart.vrlib.PvrClient");
				Pvr_UnitySDKAPI.System.Pvr_SetInitActivity(activity.GetRawObject(), javaVrActivityClass.GetRawClass());
				model = javaVrActivityClass.CallStatic<string>("Pvr_GetBuildModel", Array.Empty<object>());
				double[] result = new double[5];
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaVrActivityClass, "getDPIParameters", activity);
				int res = -1;
				Render.UPvr_GetIntConfig(4, ref res);
				string result2 = "";
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result2, javaserviceClass, "getSysproc", "persist.pvr.debug.appfps");
				if (result2 != "")
				{
					Pvr_UnitySDKManager.SDK.systemFPS = Convert.ToBoolean(Convert.ToInt16(result2));
				}
				if (res == 0)
				{
					Render.UPvr_ChangeScreenParameters(model, (int)result[0], (int)result[1], result[2], result[3], result[4]);
					Screen.sleepTimeout = -1;
				}
				if (Pvr_UnitySDKAPI.System.UPvr_IsPicoActivity())
				{
					UnityEngine.Debug.Log("ConnectToAndriod set monoPresentation success ?-------------" + Pvr_UnitySDKAPI.System.UPvr_SetMonoPresentation());
					UnityEngine.Debug.Log("ConnectToAndriod presentation existed ?-------------" + Pvr_UnitySDKAPI.System.UPvr_IsPresentationExisted());
				}
				isShellMode = GetIsShellMode();
				UnityEngine.Debug.Log("ConnectToAndriod isShellMode ?-------------" + isShellMode);
			}
			catch (AndroidJavaException ex)
			{
				PLOG.E("ConnectToAndriod--catch" + ex.Message);
			}
			canConnecttoActivity = true;
		}

		public void Init()
		{
			if (InitRenderAbility())
			{
				UnityEngine.Debug.Log("PvrLog Init Render Ability Success!");
				isInitrenderThread = false;
			}
			else
			{
				UnityEngine.Debug.Log("PvrLog Init Render Ability Failed!");
			}
		}

		private bool InitRenderAbility()
		{
			if (UpdateRenderParaFrame() && CreateEyeBuffer())
			{
				float num = Pvr_UnitySDKAPI.System.UPvr_GetIPD();
				Pvr_UnitySDKManager.SDK.leftEyeOffset = new Vector3((0f - num) / 2f, 0f, 0f);
				Pvr_UnitySDKManager.SDK.rightEyeOffset = new Vector3(num / 2f, 0f, 0f);
				return true;
			}
			return false;
		}

		private bool UpdateRenderParaFrame()
		{
			EyeVFoV = GetEyeVFOV();
			EyeHFoV = GetEyeHFOV();
			Pvr_UnitySDKManager.SDK.EyesAspect = EyeHFoV / EyeVFoV;
			return true;
		}

		private bool CreateEyeBuffer()
		{
			Vector2 eyeBufferResolution = GetEyeBufferResolution();
			if (isFirstStartup)
			{
				InitSinglePass();
				Pvr_UnitySDKAPI.System.UPvr_SetSinglePassDepthBufferWidthHeight((int)eyeBufferResolution.x, (int)eyeBufferResolution.y);
			}
			eyeTextures = new RenderTexture[eyeTextureCount];
			eyeTextureIds = new int[eyeTextureCount];
			for (int i = 0; i < eyeTextureCount; i++)
			{
				if (null == eyeTextures[i])
				{
					try
					{
						ConfigureEyeBuffer(i, eyeBufferResolution);
					}
					catch (Exception ex)
					{
						PLOG.E("ConfigureEyeBuffer ERROR " + ex.Message);
						throw;
					}
				}
				if (!eyeTextures[i].IsCreated())
				{
					eyeTextures[i].Create();
					eyeTextureIds[i] = eyeTextures[i].GetNativeTexturePtr().ToInt32();
				}
				eyeTextureIds[i] = eyeTextures[i].GetNativeTexturePtr().ToInt32();
			}
			return true;
		}

		private void InitSinglePass()
		{
			bool flag = true;
			if (GraphicsSettings.renderPipelineAsset != null)
			{
				flag = false;
				if (!BoundarySystem.UPvr_EnableLWRP(enable: true))
				{
					UnityEngine.Debug.Log("UPvr_EnableLWRP return false");
				}
				Vector2 eyeBufferResolution = GetEyeBufferResolution();
				if (!BoundarySystem.UPvr_SetViewportSize((int)eyeBufferResolution.x, (int)eyeBufferResolution.y))
				{
					UnityEngine.Debug.Log("UPvr_SetViewportSize return false");
				}
			}
			if (Pvr_UnitySDKProjectSetting.GetProjectConfig().usesinglepass)
			{
				bool flag2 = false;
				if (flag)
				{
					flag2 = Pvr_UnitySDKAPI.System.UPvr_EnableSinglePass(enable: true);
				}
				if (flag2)
				{
					StereoRendering = new Pvr_UnitySDKSinglePass();
					stereoRenderPath = StereoRenderingPathPico.SinglePass;
					eyeTextureCount = 3;
				}
				UnityEngine.Debug.Log("EnableSinglePass supportSinglePass " + flag + " result " + flag2);
			}
		}

		public float GetEyeVFOV()
		{
			float res = 102f;
			try
			{
				Render.UPvr_GetFloatConfig(1, ref res);
				if (res <= 0f)
				{
					res = 102f;
				}
			}
			catch (Exception ex)
			{
				PLOG.E("GetEyeVFOV ERROR! " + ex.Message);
				throw;
			}
			return res;
		}

		public float GetEyeHFOV()
		{
			float res = 102f;
			try
			{
				Render.UPvr_GetFloatConfig(2, ref res);
				if (res <= 0f)
				{
					res = 102f;
				}
			}
			catch (Exception ex)
			{
				PLOG.E("GetEyeHFOV ERROR! " + ex.Message);
				throw;
			}
			return res;
		}

		private void ConfigureEyeBuffer(int eyeTextureIndex, Vector2 resolution)
		{
			int width = (int)resolution.x;
			int height = (int)resolution.y;
			eyeTextures[eyeTextureIndex] = new RenderTexture(width, height, (int)Pvr_UnitySDKProjectSetting.GetProjectConfig().rtBitDepth, Pvr_UnitySDKProjectSetting.GetProjectConfig().rtFormat);
			if (StereoRenderPath == StereoRenderingPathPico.MultiPass)
			{
				eyeTextures[eyeTextureIndex].anisoLevel = 0;
				eyeTextures[eyeTextureIndex].antiAliasing = Mathf.Max(QualitySettings.antiAliasing, (int)Pvr_UnitySDKProjectSetting.GetProjectConfig().rtAntiAlising);
				UnityEngine.Debug.Log("MultiPass ConfigureEyeBuffer eyeTextureIndex " + eyeTextureIndex);
			}
			else if (StereoRenderPath == StereoRenderingPathPico.SinglePass)
			{
				eyeTextures[eyeTextureIndex].useMipMap = false;
				eyeTextures[eyeTextureIndex].wrapMode = TextureWrapMode.Clamp;
				eyeTextures[eyeTextureIndex].filterMode = FilterMode.Bilinear;
				eyeTextures[eyeTextureIndex].anisoLevel = 1;
				eyeTextures[eyeTextureIndex].dimension = TextureDimension.Tex2DArray;
				eyeTextures[eyeTextureIndex].volumeDepth = 2;
				UnityEngine.Debug.Log("SinglePass ConfigureEyeBuffer eyeTextureIndex " + eyeTextureIndex);
			}
			eyeTextures[eyeTextureIndex].Create();
			if (eyeTextures[eyeTextureIndex].IsCreated())
			{
				eyeTextureIds[eyeTextureIndex] = eyeTextures[eyeTextureIndex].GetNativeTexturePtr().ToInt32();
				UnityEngine.Debug.Log("eyeTextureIndex : " + eyeTextureIndex);
			}
		}

		public bool ReCreateEyeBuffer()
		{
			if (!Pvr_UnitySDKProjectSetting.GetProjectConfig().usedefaultRenderTexture)
			{
				for (int i = 0; i < eyeTextureCount; i++)
				{
					if (eyeTextures[i] != null)
					{
						eyeTextures[i].Release();
					}
				}
				Array.Clear(eyeTextures, 0, eyeTextures.Length);
				return CreateEyeBuffer();
			}
			return false;
		}

		public void ReInit()
		{
			if (canConnecttoActivity && isInitrenderThread)
			{
				Init();
			}
		}

		public void IssueRenderThread()
		{
			if (canConnecttoActivity && !isInitrenderThread)
			{
				switch (QualitySettings.activeColorSpace)
				{
				case ColorSpace.Gamma:
					Render.UPvr_SetColorspaceType(0);
					break;
				case ColorSpace.Linear:
					Render.UPvr_SetColorspaceType(1);
					break;
				}
				Pvr_UnitySDKPluginEvent.Issue(RenderEventType.InitRenderThread);
				isInitrenderThread = true;
				if (StereoRendering != null)
				{
					StereoRendering.OnSDKRenderInited();
				}
				UnityEngine.Debug.Log("PvrLog IssueRenderThread end");
			}
			else
			{
				PLOG.I("PvrLog IssueRenderThread  canConnecttoActivity = " + canConnecttoActivity);
			}
		}

		private void AutoAdpatForPico1s()
		{
			Vector2 position = Input.touches[0].position;
			Vector2 position2 = Input.touches[1].position;
			if (Vector2.Distance(prefinger1, position) > 2f && Vector2.Distance(prefinger2, position2) > 2f)
			{
				float midH = (Input.touches[0].position.x + Input.touches[1].position.x) / (float)Screen.width - 1f;
				float midV = (Input.touches[0].position.y + Input.touches[1].position.y) / (float)Screen.height - 1f;
				Render.UPvr_SetRatio(midH, midV);
			}
			prefinger1 = position;
			prefinger2 = position2;
		}

		public Vector2 GetEyeBufferResolution()
		{
			int res = 1024;
			int res2 = 1024;
			if (Pvr_UnitySDKProjectSetting.GetProjectConfig().usedefaultRenderTexture)
			{
				try
				{
					Render.UPvr_GetIntConfig(0, ref res);
					Render.UPvr_GetIntConfig(1, ref res2);
				}
				catch (Exception ex)
				{
					PLOG.E("GetEyeBufferResolution ERROR! " + ex.Message);
					throw;
				}
			}
			else
			{
				res = (int)(Pvr_UnitySDKProjectSetting.GetProjectConfig().customRTSize.x * RtScaleFactor);
				res2 = (int)(Pvr_UnitySDKProjectSetting.GetProjectConfig().customRTSize.y * RtScaleFactor);
			}
			Vector2 vector = new Vector2(res, res2);
			Vector2 vector2 = vector;
			UnityEngine.Debug.Log("DISFT Customize RenderTexture:" + vector2.ToString() + ", scaleFactor: " + RtScaleFactor);
			return vector;
		}

		public bool GetUsePredictedMatrix()
		{
			return true;
		}

		public bool GetIsShellMode()
		{
			if (activity == null)
			{
				return false;
			}
			using (AndroidJavaObject androidJavaObject = activity.Call<AndroidJavaObject>("getPackageManager", Array.Empty<object>()).Call<AndroidJavaObject>("getApplicationInfo", new object[2]
			{
				activity.Call<string>("getPackageName", Array.Empty<object>()),
				128
			}))
			{
				AndroidJavaObject androidJavaObject2 = androidJavaObject.Get<AndroidJavaObject>("metaData");
				if (androidJavaObject2 != null)
				{
					if (androidJavaObject2.Call<int>("getInt", new object[1] { "shell_mode" }) == 1)
					{
						return true;
					}
					return false;
				}
			}
			return false;
		}
	}
	public class Pvr_UnitySDKSinglePass : SDKStereoRendering
	{
		private static Camera bothCamera;

		private Matrix4x4[] unity_StereoMatrixP = new Matrix4x4[2];

		private Matrix4x4[] unity_StereoMatrixInvP = new Matrix4x4[2];

		private static Matrix4x4[] unity_StereoWorldToCamera = new Matrix4x4[2];

		private Matrix4x4[] unity_StereoCameraToWorld = new Matrix4x4[2];

		private Matrix4x4[] unity_StereoMatrixVP = new Matrix4x4[2];

		private Vector3[] eyesOffset = new Vector3[2];

		private static Matrix4x4[] eyesOffsetMatrix = new Matrix4x4[2];

		private CommandBuffer commandBufferBeforeForwardOpaque;

		private CommandBuffer commandBufferBeforeSkybox;

		private CommandBuffer commandBufferAfterSkybox;

		public override void InitEye(Camera eye)
		{
			bothCamera = eye;
			bothCamera.stereoSeparation = 0.0625f;
			bothCamera.stereoConvergence = 0f;
			bothCamera.allowHDR = false;
			bothCamera.allowDynamicResolution = false;
			SetEyesPosition();
			SetEyeProjection();
			Pvr_UnitySDKSensor.EyeFovChanged = (Action)Delegate.Combine(Pvr_UnitySDKSensor.EyeFovChanged, new Action(SetEyeProjection));
			UnityEngine.Debug.Log("SinglePass Init success! CameraName = " + eye.transform.name + " eye.eyeSide " + eye.GetComponent<Pvr_UnitySDKEye>().eyeSide);
		}

		public override void OnSDKRenderInited()
		{
			OnSDKRenderInited_SinglePass();
		}

		public override void OnSDKPreRender()
		{
			SinglePassPreRender();
		}

		public override void OnSDKPostRender()
		{
			SwitchKeywordAndDeviceView(enable: false);
		}

		public void OnSDKRenderInited_SinglePass()
		{
			Shader.SetGlobalVectorArray("unity_StereoScaleOffset", new Vector4[2]
			{
				new Vector4(1f, 1f, 0f, 0f),
				new Vector4(1f, 1f, 0.5f, 0f)
			});
			SetAntiAliasing();
			UnityEngine.Debug.Log("OnSDKRenderInited_SinglePass");
		}

		private void SetAntiAliasing()
		{
			int antiAliasing = Mathf.Max(QualitySettings.antiAliasing, (int)Pvr_UnitySDKProjectSetting.GetProjectConfig().rtAntiAlising);
			Pvr_UnitySDKAPI.System.UPvr_SetAntiAliasing(antiAliasing);
			UnityEngine.Debug.Log("SetAntiAliasing  antiAliasing = " + antiAliasing);
		}

		public void SetEyesPosition()
		{
			float res = 0.0625f;
			int configsenum = 0;
			if (Render.UPvr_GetFloatConfig(configsenum, ref res) != 0)
			{
				PLOG.E("Cannot get ipd");
				res = 0.0625f;
			}
			bothCamera.stereoSeparation = res;
			Vector3 vector = new Vector3((0f - res) / 2f, 0f, 0f);
			Vector3 vector2 = new Vector3(res / 2f, 0f, 0f);
			Vector3 vector3 = (vector + vector2) / 2f;
			bothCamera.transform.localPosition = vector3;
			bothCamera.transform.localRotation = Quaternion.identity;
			Vector3 vector4 = vector - vector3;
			Vector3 vector5 = vector2 - vector3;
			eyesOffset[0] = vector4;
			eyesOffset[1] = vector5;
			eyesOffsetMatrix[0] = Matrix4x4.TRS(vector4, Quaternion.identity, Vector3.one);
			eyesOffsetMatrix[1] = Matrix4x4.TRS(vector5, Quaternion.identity, Vector3.one);
		}

		public void SetEyeProjection()
		{
			Matrix4x4 projection = GetProjection(bothCamera.nearClipPlane, bothCamera.farClipPlane);
			Matrix4x4 projection2 = GetProjection(bothCamera.nearClipPlane, bothCamera.farClipPlane);
			SetStereoProjectionMatrix(projection, projection2);
		}

		private static Matrix4x4 GetProjection(float near, float far)
		{
			if (near < 0.01f)
			{
				near = 0.01f;
			}
			if (far < 0.02f)
			{
				far = 0.02f;
			}
			_ = Matrix4x4.identity;
			return MakeProjection(near, far);
		}

		public static Matrix4x4 MakeProjection(float n, float f)
		{
			Vector2 eyeBufferResolution = Pvr_UnitySDKRender.Instance.GetEyeBufferResolution();
			float num = Mathf.Tan(Pvr_UnitySDKRender.Instance.EyeVFoV / 2f * ((float)Math.PI / 180f));
			float num2 = 1f / num;
			Matrix4x4 zero = Matrix4x4.zero;
			zero[0, 0] = num2 / (eyeBufferResolution.x / eyeBufferResolution.y);
			zero[1, 1] = num2;
			zero[2, 2] = (0f - (f + n)) / (f - n);
			zero[2, 3] = -2f * f * n / (f - n);
			zero[3, 2] = -1f;
			return zero;
		}

		public void SetStereoProjectionMatrix(Matrix4x4 left, Matrix4x4 right)
		{
			unity_StereoMatrixP[0] = left;
			unity_StereoMatrixInvP[0] = left.inverse;
			unity_StereoMatrixP[1] = right;
			unity_StereoMatrixInvP[1] = right.inverse;
		}

		private void SwitchKeywordAndDeviceView(bool enable)
		{
			if (enable)
			{
				Shader.EnableKeyword("STEREO_MULTIVIEW_ON");
				Shader.EnableKeyword("UNITY_SINGLE_PASS_STEREO");
				XRSettings.showDeviceView = false;
			}
			else
			{
				XRSettings.showDeviceView = true;
				Shader.DisableKeyword("UNITY_SINGLE_PASS_STEREO");
				Shader.DisableKeyword("STEREO_MULTIVIEW_ON");
			}
		}

		public static Matrix4x4[] GetStereoWorldToCameraMat()
		{
			Matrix4x4 worldToCameraMatrix = bothCamera.worldToCameraMatrix;
			unity_StereoWorldToCamera[0] = eyesOffsetMatrix[0].inverse * worldToCameraMatrix;
			unity_StereoWorldToCamera[1] = eyesOffsetMatrix[1].inverse * worldToCameraMatrix;
			return unity_StereoWorldToCamera;
		}

		public void SinglePassPreRender()
		{
			SwitchKeywordAndDeviceView(enable: true);
			Shader.SetGlobalMatrixArray("unity_StereoCameraProjection", unity_StereoMatrixP);
			Shader.SetGlobalMatrixArray("unity_StereoCameraInvProjection", unity_StereoMatrixInvP);
			Shader.SetGlobalMatrixArray("unity_StereoMatrixP", unity_StereoMatrixP);
			Matrix4x4 worldToCameraMatrix = bothCamera.worldToCameraMatrix;
			Matrix4x4 cameraToWorldMatrix = bothCamera.cameraToWorldMatrix;
			unity_StereoCameraToWorld[0] = cameraToWorldMatrix * eyesOffsetMatrix[0];
			unity_StereoCameraToWorld[1] = cameraToWorldMatrix * eyesOffsetMatrix[1];
			Shader.SetGlobalMatrixArray("unity_StereoCameraToWorld", unity_StereoCameraToWorld);
			unity_StereoWorldToCamera[0] = eyesOffsetMatrix[0].inverse * worldToCameraMatrix;
			unity_StereoWorldToCamera[1] = eyesOffsetMatrix[1].inverse * worldToCameraMatrix;
			Shader.SetGlobalMatrixArray("unity_StereoWorldToCamera", unity_StereoWorldToCamera);
			Vector4[] values = new Vector4[2]
			{
				bothCamera.transform.position + eyesOffset[0],
				bothCamera.transform.position + eyesOffset[1]
			};
			Shader.SetGlobalVectorArray("unity_StereoWorldSpaceCameraPos", values);
			Shader.SetGlobalMatrixArray("unity_StereoMatrixV", unity_StereoWorldToCamera);
			Shader.SetGlobalMatrixArray("unity_StereoMatrixInvV", unity_StereoCameraToWorld);
			unity_StereoMatrixVP[0] = unity_StereoMatrixP[0] * unity_StereoWorldToCamera[0];
			unity_StereoMatrixVP[1] = unity_StereoMatrixP[1] * unity_StereoWorldToCamera[1];
			Shader.SetGlobalMatrixArray("unity_StereoMatrixVP", unity_StereoMatrixVP);
			SetRenderTextureWithDepth();
			SetCommandBuffers();
		}

		private void SetCommandBuffers()
		{
			if (commandBufferBeforeForwardOpaque == null)
			{
				commandBufferBeforeForwardOpaque = new CommandBuffer();
				Pvr_UnitySDKPluginEvent.SetSinglePassBeforeForwardOpaque(commandBufferBeforeForwardOpaque);
				commandBufferBeforeForwardOpaque.ClearRenderTarget(clearDepth: true, clearColor: true, bothCamera.backgroundColor);
				commandBufferBeforeForwardOpaque.name = "SinglePassPrepare";
			}
			bothCamera.RemoveCommandBuffer(CameraEvent.BeforeForwardOpaque, commandBufferBeforeForwardOpaque);
			bothCamera.AddCommandBuffer(CameraEvent.BeforeForwardOpaque, commandBufferBeforeForwardOpaque);
			if (commandBufferAfterSkybox == null)
			{
				commandBufferAfterSkybox = new CommandBuffer();
			}
			bothCamera.RemoveCommandBuffer(CameraEvent.AfterSkybox, commandBufferAfterSkybox);
			commandBufferAfterSkybox.Clear();
			commandBufferAfterSkybox.SetGlobalMatrixArray("unity_StereoMatrixVP", unity_StereoMatrixVP);
			commandBufferAfterSkybox.name = "SinglePassAfterSkyBox";
			bothCamera.AddCommandBuffer(CameraEvent.AfterSkybox, commandBufferAfterSkybox);
			if (commandBufferBeforeSkybox == null)
			{
				commandBufferBeforeSkybox = new CommandBuffer();
			}
			Matrix4x4 transpose = (Matrix4x4.LookAt(Vector3.zero, bothCamera.transform.forward, bothCamera.transform.up) * Matrix4x4.Scale(new Vector3(1f, 1f, -1f))).transpose;
			Matrix4x4 matrix4x = unity_StereoMatrixP[0];
			Matrix4x4 matrix4x2 = unity_StereoMatrixP[1];
			matrix4x.m22 = -1f;
			matrix4x2.m22 = -1f;
			Matrix4x4[] values = new Matrix4x4[2]
			{
				matrix4x * transpose,
				matrix4x2 * transpose
			};
			bothCamera.RemoveCommandBuffer(CameraEvent.BeforeSkybox, commandBufferBeforeSkybox);
			commandBufferBeforeSkybox.Clear();
			commandBufferBeforeSkybox.SetGlobalMatrixArray("unity_StereoMatrixVP", values);
			commandBufferBeforeSkybox.name = "SinglePassAfterSkybox";
			bothCamera.AddCommandBuffer(CameraEvent.BeforeSkybox, commandBufferBeforeSkybox);
		}

		private void SetRenderTextureWithDepth()
		{
			Pvr_UnitySDKAPI.System.UPvr_SetCurrentRenderTexture((uint)Pvr_UnitySDKRender.Instance.eyeTextureIds[Pvr_UnitySDKRender.Instance.currEyeTextureIdx]);
		}
	}
	public abstract class SDKStereoRendering
	{
		public abstract void InitEye(Camera eye);

		public abstract void OnSDKRenderInited();

		public abstract void OnSDKPreRender();

		public abstract void OnSDKPostRender();
	}
	public class HighlightAtGaze : MonoBehaviour
	{
		public Color HighlightColor = Color.red;

		public float AnimationTime = 0.1f;

		private Renderer myRenderer;

		private Color originalColor;

		private Color targetColor;

		private EyeTrackingGazeRay gazeRay;

		private void Start()
		{
			myRenderer = GetComponent<Renderer>();
			originalColor = myRenderer.material.color;
			targetColor = originalColor;
		}

		private void Update()
		{
			Pvr_UnitySDKAPI.System.UPvr_getEyeTrackingGazeRay(ref gazeRay);
			if (Physics.Raycast(new Ray(gazeRay.Origin, gazeRay.Direction), out var hitInfo))
			{
				if (hitInfo.transform.name == base.transform.name)
				{
					if (targetColor != HighlightColor)
					{
						targetColor = HighlightColor;
					}
				}
				else if (targetColor != originalColor)
				{
					targetColor = originalColor;
				}
			}
			else if (targetColor != originalColor)
			{
				targetColor = originalColor;
			}
			myRenderer.material.color = Color.Lerp(myRenderer.material.color, targetColor, Time.deltaTime * (1f / AnimationTime));
		}
	}
	public class RayVisualizer : MonoBehaviour
	{
		private LineRenderer _line;

		private EyeTrackingGazeRay gazeRay;

		private void Start()
		{
			_line = base.gameObject.GetComponent<LineRenderer>();
			_line.startWidth = 0.002f;
			_line.endWidth = 0.002f;
		}

		private void Update()
		{
			Matrix4x4 matrix = Pvr_UnitySDKSensor.Instance.HeadPose.Matrix;
			Pvr_UnitySDKAPI.System.UPvr_getEyeTrackingGazeRay(ref gazeRay);
			_line.SetPosition(0, matrix.MultiplyPoint(new Vector3(0f, -0.05f, 0.2f)));
			_line.SetPosition(1, gazeRay.Origin + gazeRay.Direction * 20f);
		}
	}
	public class GetSeeThroughImage : MonoBehaviour
	{
		public RawImage viewImage_left;

		public RawImage viewImage_right;

		private int width;

		private int height;

		private RenderTexture cameraTex_left;

		private RenderTexture cameraTex_right;

		private bool cameraPreview;

		private void Start()
		{
			CreateTexture();
		}

		private void Update()
		{
			if (Input.GetKey(KeyCode.JoystickButton0))
			{
				DrawTexture();
			}
		}

		private void OnDestory()
		{
			if (cameraPreview)
			{
				cameraPreview = false;
				BoundarySystem.UPvr_StopCameraFrame();
			}
		}

		private void CreateTexture()
		{
			width = 600;
			height = 600;
			BoundarySystem.UPvr_BoundarySetCameraImageRect(width, height);
			cameraTex_left = new RenderTexture(width, height, 24, RenderTextureFormat.Default);
			cameraTex_right = new RenderTexture(width, height, 24, RenderTextureFormat.Default);
			cameraTex_left.Create();
			cameraTex_right.Create();
			viewImage_left.texture = cameraTex_left;
			viewImage_right.texture = cameraTex_right;
		}

		private void DrawTexture()
		{
			if (!cameraPreview)
			{
				cameraPreview = true;
				BoundarySystem.UPvr_StartCameraFrame();
			}
			BoundarySystem.UPvr_BoundaryGetSeeThroughData(0, cameraTex_left);
			BoundarySystem.UPvr_BoundaryGetSeeThroughData(1, cameraTex_right);
		}
	}
	public class OverlayExternalSurfaceDemo : MonoBehaviour
	{
		public string movieName;

		public Pvr_UnitySDKEyeOverlay.OverlayType overlayType;

		public Pvr_UnitySDKEyeOverlay.OverlayShape overlayShape;

		private Pvr_UnitySDKEyeOverlay overlay;

		private const string TAG = "[ExternalSurface]>>>>>>";

		private void Awake()
		{
			overlay = GetComponent<Pvr_UnitySDKEyeOverlay>();
			if (overlay == null)
			{
				UnityEngine.Debug.LogError("[ExternalSurface]>>>>>>Overlay is null!");
				overlay = base.gameObject.AddComponent<Pvr_UnitySDKEyeOverlay>();
			}
			overlay.overlayType = overlayType;
			overlay.overlayShape = overlayShape;
			overlay.isExternalAndroidSurface = true;
		}

		private void Start()
		{
			if (!string.IsNullOrEmpty(movieName))
			{
				StartPlay(Application.streamingAssetsPath + "/" + movieName, null);
			}
		}

		private void StartPlay(string moviePath, string licenceUrl)
		{
			if (moviePath != string.Empty)
			{
				if (overlay.isExternalAndroidSurface)
				{
					Pvr_UnitySDKEyeOverlay.ExternalAndroidSurfaceObjectCreated externalAndroidSurfaceObjectCreated = delegate
					{
						UnityEngine.Debug.Log("[ExternalSurface]>>>>>>SurfaceObject created callback is Invoke().");
					};
					if (overlay.externalAndroidSurfaceObject == IntPtr.Zero)
					{
						UnityEngine.Debug.Log("[ExternalSurface]>>>>>>Register surfaceObject crreated callback");
						overlay.externalAndroidSurfaceObjectCreated = externalAndroidSurfaceObjectCreated;
					}
					else
					{
						UnityEngine.Debug.Log("[ExternalSurface]>>>>>>SurfaceObject is already created! Invoke callback");
						externalAndroidSurfaceObjectCreated();
					}
				}
			}
			else
			{
				UnityEngine.Debug.LogError("[ExternalSurface]>>>>>>Movie path is null!");
			}
		}
	}
	public class MoveCylinder : MonoBehaviour
	{
		private Vector3 startingPosition;

		private Quaternion startingRotation;

		private void Start()
		{
			startingPosition = base.transform.localPosition;
			startingRotation = base.transform.rotation;
		}

		public void Reset()
		{
			base.transform.localPosition = startingPosition;
			base.transform.rotation = startingRotation;
		}
	}
	[RequireComponent(typeof(Collider))]
	public class MoveSphere : MonoBehaviour
	{
		private Vector3 startingPosition;

		private void Start()
		{
			startingPosition = base.transform.localPosition;
			SetGazedAt(gazedAt: false);
			base.gameObject.GetComponent<Rigidbody>().AddForce(Vector3.right * 120f);
		}

		private void OnTriggerEnter(Collider other)
		{
		}

		public void SetGazedAt(bool gazedAt)
		{
			GetComponent<Renderer>().material.color = (gazedAt ? Color.yellow : Color.blue);
		}

		public void Reset()
		{
			base.transform.localPosition = startingPosition;
			SetGazedAt(gazedAt: false);
			base.gameObject.GetComponent<Rigidbody>().Sleep();
			base.gameObject.GetComponent<Rigidbody>().AddForce(Vector3.right * 120f);
		}

		public void TeleportRandomly()
		{
			Vector3 onUnitSphere = UnityEngine.Random.onUnitSphere;
			onUnitSphere.y = Mathf.Clamp(onUnitSphere.y, 0.5f, 1f);
			float num = 2f * UnityEngine.Random.value + 1.5f;
			base.transform.localPosition = onUnitSphere * num;
		}
	}
	public class Resetbutton : MonoBehaviour
	{
		public void DemoResetTracking()
		{
			if (Pvr_UnitySDKSensor.Instance != null)
			{
				Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
			}
		}
	}
	public class UserEntitlementCheck : MonoBehaviour
	{
		private void OnEnable()
		{
			Pvr_UnitySDKManager.EntitlementCheckResultEvent += HandelEntitlementCheckResult;
		}

		private void OnDisable()
		{
			Pvr_UnitySDKManager.EntitlementCheckResultEvent -= HandelEntitlementCheckResult;
		}

		private void HandelEntitlementCheckResult(int resultCode)
		{
			UnityEngine.Debug.Log("The User Entitlement Check Result is :" + resultCode);
			switch (resultCode)
			{
			case 0:
				UnityEngine.Debug.Log("The User Entitlement Check Result is: success");
				break;
			case -1:
				UnityEngine.Debug.Log("The User Entitlement Check Result is: invalid params");
				break;
			case -2:
				UnityEngine.Debug.Log("The User Entitlement Check Result is: service not exist");
				break;
			case -3:
				UnityEngine.Debug.Log("The User Entitlement Check Result is: bind failed");
				break;
			case -4:
				UnityEngine.Debug.Log("The User Entitlement Check Result is: exception");
				break;
			case -5:
				UnityEngine.Debug.Log("The User Entitlement Check Result is: timeout");
				break;
			case 10:
				UnityEngine.Debug.Log("The User Entitlement Check Result is: missing package name");
				break;
			case 11:
				UnityEngine.Debug.Log("The User Entitlement Check Result is: missing appid");
				break;
			case 13:
				UnityEngine.Debug.Log("The User Entitlement Check Result is: appid and package name not match");
				break;
			case 20:
				UnityEngine.Debug.Log("The User Entitlement Check Result is: not login");
				break;
			case 21:
				UnityEngine.Debug.Log("The User Entitlement Check Result is: not pay");
				break;
			case 31:
				UnityEngine.Debug.Log("The User Entitlement Check Result is: invalid sn");
				break;
			default:
				UnityEngine.Debug.Log("The User Entitlement Check Result is: unknown");
				break;
			}
		}
	}
	public class Pvr_UnitySDKHeadTrack : MonoBehaviour
	{
		[Tooltip("If true, head tracking will affect the rotation of each Pvr_UnitySDK's cameras.")]
		public bool trackRotation = true;

		[Tooltip("If true, head tracking will affect the position of each Pvr_UnitySDK's cameras.")]
		public bool trackPosition = true;

		public Transform target;

		private bool updated;

		private bool dataClock;

		public Ray Gaze
		{
			get
			{
				UpdateHead();
				return new Ray(base.transform.position, base.transform.forward);
			}
		}

		private void Update()
		{
			updated = false;
			UpdateHead();
		}

		private void UpdateHead()
		{
			if (updated)
			{
				return;
			}
			updated = true;
			if (Pvr_UnitySDKManager.SDK == null)
			{
				return;
			}
			if (trackRotation)
			{
				Quaternion orientation = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation;
				if (target == null)
				{
					base.transform.localRotation = orientation;
				}
				else
				{
					base.transform.rotation = orientation * target.rotation;
				}
			}
			else
			{
				Quaternion orientation2 = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation;
				if (target == null)
				{
					base.transform.localRotation = Quaternion.identity;
				}
				else
				{
					base.transform.rotation = orientation2 * target.rotation;
				}
			}
			if (trackPosition)
			{
				Vector3 position = Pvr_UnitySDKSensor.Instance.HeadPose.Position;
				if (target == null)
				{
					base.transform.localPosition = position;
				}
				else
				{
					base.transform.position = target.position + target.rotation * position;
				}
			}
		}
	}
	public class Pvr_UnitySDKPose
	{
		protected static readonly Matrix4x4 flipZ = Matrix4x4.Scale(new Vector3(1f, 1f, -1f));

		public Matrix4x4 RightHandedMatrix => flipZ * Matrix * flipZ;

		public Vector3 Position { get; protected set; }

		public Quaternion Orientation { get; protected set; }

		public Matrix4x4 Matrix { get; protected set; }

		public Pvr_UnitySDKPose(Matrix4x4 matrix)
		{
			Set(matrix);
		}

		public Pvr_UnitySDKPose(Vector3 position, Quaternion orientation)
		{
			Set(position, orientation);
		}

		public void Set(Vector3 position, Quaternion orientation)
		{
			Position = position;
			Orientation = orientation;
			Matrix = Matrix4x4.TRS(position, orientation, Vector3.one);
		}

		protected void Set(Matrix4x4 matrix)
		{
			Matrix = matrix;
			Position = matrix.GetColumn(3);
			Orientation = Quaternion.LookRotation(matrix.GetColumn(2), matrix.GetColumn(1));
		}

		private Quaternion NormalizeQuaternion(ref Quaternion q)
		{
			float num = 0f;
			for (int i = 0; i < 4; i++)
			{
				num += q[i] * q[i];
			}
			float num2 = 1f / Mathf.Sqrt(num);
			for (int j = 0; j < 4; j++)
			{
				q[j] *= num2;
			}
			return q;
		}
	}
	public class Pvr_UnitySDKSensor
	{
		public delegate void Enter3DofModel();

		public delegate void Exit3DofModel();

		private static Pvr_UnitySDKSensor instance;

		private bool SensorStart;

		private bool SensorInit;

		private Quaternion UnityQuaternion = Quaternion.identity;

		private Vector3 UnityPosition = Vector3.zero;

		private Sensorindex sensorIndex;

		private bool dofClock;

		public static Action EyeFovChanged;

		public Pvr_UnitySDKPose HeadPose;

		private float vfov = 102f;

		private float hfov = 102f;

		private float w;

		private float x;

		private float y;

		private float z;

		private float px;

		private float py;

		private float pz;

		public static Pvr_UnitySDKSensor Instance
		{
			get
			{
				if (instance == null)
				{
					instance = new Pvr_UnitySDKSensor();
				}
				return instance;
			}
			set
			{
				instance = value;
			}
		}

		public static event Enter3DofModel Enter3DofModelEvent;

		public static event Exit3DofModel Exit3DofModelEvent;

		public Pvr_UnitySDKSensor()
		{
			Init();
		}

		public void Init()
		{
			InitUnitySDK6DofSensor();
			SensorInit = InitUnitySDKSensor();
			SensorStart = StartUnitySDKSensor();
			HeadPose = new Pvr_UnitySDKPose(Vector3.zero, Quaternion.identity);
		}

		public void SensorUpdate()
		{
			if (GetUnitySDKSensorState())
			{
				HeadPose.Set(UnityPosition, UnityQuaternion);
			}
		}

		public bool InitUnitySDKSensor()
		{
			bool result = false;
			try
			{
				if (Sensor.UPvr_Init((int)sensorIndex) == 0)
				{
					result = true;
				}
			}
			catch (Exception ex)
			{
				PLOG.E("InitUnitySDKSensor ERROR! " + ex.Message);
				throw;
			}
			return result;
		}

		public bool InitUnitySDK6DofSensor()
		{
			bool result = false;
			try
			{
				int res = 0;
				Render.UPvr_GetIntConfig(3, ref res);
				if (res == 1)
				{
					if (Sensor.UPvr_Enable6DofModule(!Pvr_UnitySDKManager.SDK.HmdOnlyrot) == 0 && !Pvr_UnitySDKManager.SDK.HmdOnlyrot)
					{
						result = true;
						Pvr_UnitySDKManager.SDK.PVRNeck = false;
					}
				}
				else
				{
					UnityEngine.Debug.LogWarning("This platform does not support 6 Dof !");
				}
			}
			catch (Exception ex)
			{
				PLOG.E("InitUnity6DofSDKSensor ERROR! " + ex.Message);
				throw;
			}
			return result;
		}

		public bool StartUnitySDKSensor()
		{
			bool result = false;
			try
			{
				if (Sensor.UPvr_StartSensor((int)sensorIndex) == 0)
				{
					result = true;
				}
			}
			catch (Exception ex)
			{
				PLOG.E("StartUnitySDKSensor ERROR! " + ex.Message);
				throw;
			}
			return result;
		}

		public bool StopUnitySDKSensor()
		{
			bool result = false;
			try
			{
				if (Sensor.UPvr_StopSensor((int)sensorIndex) == 0)
				{
					result = true;
				}
			}
			catch (Exception ex)
			{
				PLOG.E("StopUnitySDKSensor ERROR! " + ex.Message);
				throw;
			}
			return result;
		}

		public bool ResetUnitySDKSensor()
		{
			bool result = false;
			try
			{
				if (Sensor.UPvr_ResetSensor((int)sensorIndex) == 0)
				{
					result = true;
					PLOG.E("ResetUnitySDKSensor OK! ");
				}
			}
			catch (Exception ex)
			{
				PLOG.E("ResetUnitySDKSensor ERROR! " + ex.Message);
				throw;
			}
			return result;
		}

		public bool OptionalResetUnitySDKSensor(int resetRot, int resetPos)
		{
			bool result = false;
			try
			{
				if (Sensor.UPvr_OptionalResetSensor((int)sensorIndex, resetRot, resetPos) == 0)
				{
					result = true;
					UnityEngine.Debug.Log("PvrLog OptionalResetUnitySDKSensor OK!" + resetRot + resetPos);
				}
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogError("OptionalResetUnitySDKSensor ERROR! " + ex.Message);
				throw;
			}
			return result;
		}

		public bool GetUnitySDKSensorState()
		{
			bool result = false;
			if (SensorInit && SensorStart)
			{
				try
				{
					int num = -1;
					if (Pvr_UnitySDKManager.SDK.ShowVideoSeethrough)
					{
						Pvr_BoundarySystem.Instance.CameraFramePtr = Pvr_BoundaryAPI.UPvr_GetCameraData_Ext();
						num = Pvr_BoundaryAPI.UPvr_GetMainSensorStateExt(ref x, ref y, ref z, ref w, ref px, ref py, ref pz, ref vfov, ref hfov, ref Pvr_UnitySDKRender.Instance.RenderviewNumber);
					}
					else
					{
						num = Sensor.UPvr_GetMainSensorState(ref x, ref y, ref z, ref w, ref px, ref py, ref pz, ref vfov, ref hfov, ref Pvr_UnitySDKRender.Instance.RenderviewNumber);
					}
					Pvr_UnitySDKManager.SDK.posStatus = Sensor.UPvr_Get6DofSensorQualityStatus();
					if (num == 0)
					{
						if (!Convert.ToBoolean(Pvr_UnitySDKManager.SDK.posStatus & 2))
						{
							if (!dofClock)
							{
								if (Pvr_UnitySDKSensor.Enter3DofModelEvent != null)
								{
									Pvr_UnitySDKSensor.Enter3DofModelEvent();
								}
								dofClock = true;
							}
						}
						else if (dofClock)
						{
							if (Pvr_UnitySDKSensor.Exit3DofModelEvent != null)
							{
								Pvr_UnitySDKSensor.Exit3DofModelEvent();
							}
							dofClock = false;
						}
						RefreshHeadData(x, y, z, w, px, py, pz);
						UnityQuaternion.Set(x, y, 0f - z, 0f - w);
						if (Pvr_UnitySDKRender.Instance.EyeVFoV != vfov)
						{
							Pvr_UnitySDKRender.Instance.EyeVFoV = vfov;
							if (EyeFovChanged != null)
							{
								EyeFovChanged();
							}
						}
						Pvr_UnitySDKRender.Instance.EyeHFoV = hfov;
						Pvr_UnitySDKManager.SDK.EyesAspect = hfov / vfov;
						result = true;
						if (Pvr_UnitySDKManager.SDK.HmdOnlyrot)
						{
							if (Pvr_UnitySDKManager.SDK.PVRNeck)
							{
								if (Pvr_UnitySDKManager.SDK.TrackingOrigin == TrackingOrigin.FloorLevel)
								{
									UnityPosition.Set(0f, py, 0f);
									UnityPosition += UnityQuaternion * Pvr_UnitySDKManager.SDK.neckOffset - Pvr_UnitySDKManager.SDK.neckOffset.y * Vector3.up;
								}
								else
								{
									UnityPosition = UnityQuaternion * Pvr_UnitySDKManager.SDK.neckOffset - Pvr_UnitySDKManager.SDK.neckOffset.y * Vector3.up;
								}
							}
						}
						else
						{
							UnityPosition.Set(px, py, 0f - pz);
						}
						if (PLOG.logLevel > 2)
						{
							PLOG.D("posStatus=" + Pvr_UnitySDKManager.SDK.posStatus);
							PLOG.D("PvrLog 6DoFHeadRotation:" + x + "," + y + "," + (0f - z) + "," + (0f - w) + ",Position:" + px + "," + py + "," + (0f - pz) + ",eulerAngles:" + UnityQuaternion.eulerAngles.ToString());
						}
					}
					if (num == -1)
					{
						PLOG.I("PvrLog Sensor update --- GetUnitySDKSensorState  -1 ");
					}
				}
				catch (Exception ex)
				{
					PLOG.E("GetUnitySDKSensorState ERROR! " + ex.Message);
					throw;
				}
			}
			return result;
		}

		public bool GetUnitySDKPSensorState()
		{
			bool result = false;
			try
			{
				if (Sensor.UPvr_ResetSensor((int)sensorIndex) == 0)
				{
					result = true;
				}
			}
			catch (Exception ex)
			{
				PLOG.E("GetUnitySDKPSensorState ERROR! " + ex.Message);
				throw;
			}
			return result;
		}

		private void RefreshHeadData(float x, float y, float z, float w, float px, float py, float pz)
		{
			Pvr_UnitySDKManager.SDK.headData[0] = x;
			Pvr_UnitySDKManager.SDK.headData[1] = y;
			Pvr_UnitySDKManager.SDK.headData[2] = z;
			Pvr_UnitySDKManager.SDK.headData[3] = w;
			Pvr_UnitySDKManager.SDK.headData[4] = px;
			Pvr_UnitySDKManager.SDK.headData[5] = py;
			Pvr_UnitySDKManager.SDK.headData[6] = pz;
		}
	}
	public class CLoadingAsset : ScriptableObject
	{
		public int SplashScreenType;

		public List<Texture2D> splashImage = new List<Texture2D>();

		public Texture2D Inside_background;

		public bool UseSplashText;

		public string DefaultText;

		public string ChineseText;

		public string EnglishText;

		public string JapaneseText;

		public string KoreanText;

		public string FontSize;

		public Color FontColor;

		public string TextHeight;

		public bool UseCarousel;

		public int SplashTextAlignment;
	}
	[Serializable]
	public class Pvr_UnitySDKConfigProfile
	{
		public struct Lenses
		{
			public float separation;

			public float offset;

			public float distance;

			public int alignment;

			public const int AlignTop = -1;

			public const int AlignCenter = 0;

			public const int AlignBottom = 1;
		}

		public struct MaxFOV
		{
			public float upper;

			public float lower;

			public float inner;

			public float outer;
		}

		public struct Distortion
		{
			public float k1;

			public float k2;

			public float k3;

			public float k4;

			public float k5;

			public float k6;

			public float distort(float r)
			{
				return 0f;
			}

			public float distort(float r, float dist)
			{
				float num = r * dist * 1000f;
				return (k1 * Mathf.Pow(num, 5f) + k2 * Mathf.Pow(num, 4f) + k3 * Mathf.Pow(num, 3f) + k4 * Mathf.Pow(num, 2f) + k5 * num + k6) / 1000f / dist;
			}

			public float diatortInv(float radious)
			{
				return 0f;
			}
		}

		public struct Device
		{
			public Lenses devLenses;

			public MaxFOV devMaxFov;

			public Distortion devDistortion;

			public Distortion devDistortionInv;
		}

		public static readonly Device SimulateDevice = new Device
		{
			devLenses = 
			{
				separation = 0.062f,
				offset = 0f,
				distance = 0.0403196f,
				alignment = 0
			},
			devMaxFov = 
			{
				upper = 40f,
				lower = 40f,
				inner = 40f,
				outer = 40f
			},
			devDistortion = 
			{
				k1 = 2.333E-06f,
				k2 = -0.000126f,
				k3 = 0.002978f,
				k4 = -0.02615f,
				k5 = 1.089f,
				k6 = -0.0337f
			},
			devDistortionInv = 
			{
				k1 = 1.342E-08f,
				k2 = 1.665E-06f,
				k3 = -0.0002797f,
				k4 = 0.001166f,
				k5 = 0.9945f,
				k6 = 0.004805f
			}
		};

		public Device device;

		public static readonly Pvr_UnitySDKConfigProfile Default = new Pvr_UnitySDKConfigProfile
		{
			device = SimulateDevice
		};

		public Pvr_UnitySDKConfigProfile Clone()
		{
			return new Pvr_UnitySDKConfigProfile
			{
				device = device
			};
		}

		public static Pvr_UnitySDKConfigProfile GetPicoProfile()
		{
			return new Pvr_UnitySDKConfigProfile
			{
				device = SimulateDevice
			};
		}

		public float[] GetLeftEyeVisibleTanAngles(float width, float height)
		{
			float val = (float)Math.Tan((double)(0f - device.devMaxFov.outer) * Math.PI / 180.0);
			float val2 = (float)Math.Tan((double)device.devMaxFov.upper * Math.PI / 180.0);
			float val3 = (float)Math.Tan((double)device.devMaxFov.inner * Math.PI / 180.0);
			float val4 = (float)Math.Tan((double)(0f - device.devMaxFov.lower) * Math.PI / 180.0);
			float num = width / 4f;
			float num2 = height / 2f;
			float num3 = device.devLenses.separation / 2f - num;
			float num4 = 0f;
			float distance = device.devLenses.distance;
			float val5 = device.devDistortion.distort((num3 - num) / distance, device.devLenses.distance);
			float val6 = device.devDistortion.distort((num4 + num2) / distance, device.devLenses.distance);
			float val7 = device.devDistortion.distort((num3 + num) / distance, device.devLenses.distance);
			float val8 = device.devDistortion.distort((num4 - num) / distance, device.devLenses.distance);
			float num5 = Math.Max(val, val5);
			float num6 = Math.Min(val2, val6);
			float num7 = Math.Min(val3, val7);
			float num8 = Math.Max(val4, val8);
			return new float[4] { num5, num6, num7, num8 };
		}

		public float[] GetLeftEyeNoLensTanAngles(float width, float height)
		{
			float val = device.devDistortionInv.distort((float)Math.Tan((double)(0f - device.devMaxFov.outer) * Math.PI / 180.0), device.devLenses.distance);
			float val2 = device.devDistortionInv.distort((float)Math.Tan((double)device.devMaxFov.upper * Math.PI / 180.0), device.devLenses.distance);
			float val3 = device.devDistortionInv.distort((float)Math.Tan((double)device.devMaxFov.inner * Math.PI / 180.0), device.devLenses.distance);
			float val4 = device.devDistortionInv.distort((float)Math.Tan((double)(0f - device.devMaxFov.lower) * Math.PI / 180.0), device.devLenses.distance);
			float num = width / 4f;
			float num2 = height / 2f;
			float num3 = device.devLenses.separation / 2f - num;
			float num4 = 0f;
			float distance = device.devLenses.distance;
			float val5 = (num3 - num) / distance;
			float val6 = (num4 + num2) / distance;
			float val7 = (num3 + num) / distance;
			float val8 = (num4 - num) / distance;
			float num5 = Math.Min(val, val5);
			float num6 = Math.Min(val2, val6);
			float num7 = Math.Min(val3, val7);
			float num8 = Math.Max(val4, val8);
			return new float[4] { num5, num6, num7, num8 };
		}

		public Rect GetLeftEyeVisibleScreenRect(float[] undistortedFrustum, float width, float height)
		{
			float distance = device.devLenses.distance;
			float num = (width - device.devLenses.separation) / 2f;
			float num2 = height / 2f;
			float num3 = (undistortedFrustum[0] * distance + num) / width;
			float num4 = (undistortedFrustum[1] * distance + num2) / height;
			float num5 = (undistortedFrustum[2] * distance + num) / width;
			float num6 = (undistortedFrustum[3] * distance + num2) / height;
			return new Rect(num3, num6, num5 - num3, num4 - num6);
		}
	}
	[RequireComponent(typeof(Text))]
	public class Pvr_UnitySDKFPS : MonoBehaviour
	{
		public Text fpsText;

		private float updateInterval = 0.5f;

		private float accum;

		private int frames;

		private float timeLeft;

		private string strFps;

		private void Update()
		{
			if (fpsText != null)
			{
				ShowFps();
			}
		}

		private void ShowFps()
		{
			timeLeft -= Time.unscaledDeltaTime;
			accum += Time.unscaledDeltaTime;
			frames++;
			if ((double)timeLeft <= 0.0)
			{
				float num = (float)frames / accum;
				strFps = $"FPS: {num:f0}";
				fpsText.text = strFps;
				timeLeft += updateInterval;
				accum = 0f;
				frames = 0;
			}
		}
	}
	public class Pvr_GazeFuse : MonoBehaviour
	{
		public GameObject gazeGameObject;

		private Image image;

		private void Start()
		{
			image = GetComponent<Image>();
		}

		private void Update()
		{
			if (gazeGameObject == null || Pvr_GazeInputModule.gazeGameObject == gazeGameObject)
			{
				FuseAmountChanged(Pvr_GazeInputModule.gazeFraction);
			}
		}

		private void FuseAmountChanged(float fuseAmount)
		{
			if (image != null)
			{
				image.fillAmount = fuseAmount;
			}
		}
	}
	public class Pvr_GazeInputModule : PointerInputModule
	{
		public enum Mode
		{
			Click,
			Gaze
		}

		public Mode mode;

		[Header("Click Settings")]
		public string ClickInputName = "Submit";

		[Header("Gaze Settings")]
		public float GazeTimeInSeconds = 2f;

		public RaycastResult CurrentRaycast;

		private PointerEventData pointerEventData;

		private GameObject currentLookAtHandler;

		private float currentLookAtHandlerClickTime;

		public static float gazeFraction { get; private set; }

		public static GameObject gazeGameObject { get; private set; }

		public override void Process()
		{
			HandleLook();
			HandleSelection();
		}

		private void HandleLook()
		{
			if (pointerEventData == null)
			{
				pointerEventData = new PointerEventData(base.eventSystem);
			}
			pointerEventData.position = new Vector2(Screen.width / 2, Screen.height / 2);
			pointerEventData.delta = Vector2.zero;
			List<RaycastResult> list = new List<RaycastResult>();
			base.eventSystem.RaycastAll(pointerEventData, list);
			RaycastResult currentRaycast = (pointerEventData.pointerCurrentRaycast = BaseInputModule.FindFirstRaycast(list));
			CurrentRaycast = currentRaycast;
			ProcessMove(pointerEventData);
		}

		private void HandleSelection()
		{
			gazeFraction = 0f;
			if (pointerEventData.pointerEnter != null)
			{
				GameObject eventHandler = ExecuteEvents.GetEventHandler<IPointerClickHandler>(pointerEventData.pointerEnter);
				if (currentLookAtHandler != eventHandler)
				{
					gazeGameObject = (currentLookAtHandler = eventHandler);
					currentLookAtHandlerClickTime = Time.realtimeSinceStartup + GazeTimeInSeconds;
				}
				if (mode == Mode.Gaze && currentLookAtHandler != null)
				{
					gazeFraction = Mathf.Clamp01(1f - (currentLookAtHandlerClickTime - Time.realtimeSinceStartup) / GazeTimeInSeconds);
				}
				if ((currentLookAtHandler != null && mode == Mode.Gaze && Time.realtimeSinceStartup > currentLookAtHandlerClickTime) || (mode == Mode.Click && Input.GetButtonDown(ClickInputName)))
				{
					_ = EventSystem.current.currentSelectedGameObject != null;
					EventSystem.current.SetSelectedGameObject(currentLookAtHandler);
					gazeFraction = 0f;
					ExecuteEvents.ExecuteHierarchy(currentLookAtHandler, pointerEventData, ExecuteEvents.pointerClickHandler);
					currentLookAtHandlerClickTime = float.MaxValue;
					ExecuteEvents.ExecuteHierarchy(EventSystem.current.currentSelectedGameObject, pointerEventData, ExecuteEvents.deselectHandler);
				}
			}
			else
			{
				gazeGameObject = (currentLookAtHandler = null);
			}
		}
	}
	[RequireComponent(typeof(Pvr_GazeInputModule))]
	public class Pvr_GazeInputModuleCrosshair : MonoBehaviour
	{
		public static bool DisplayCrosshair = true;

		[Tooltip("Crosshair GameObject attached to your VR Camera")]
		public Transform Crosshair;

		private Pvr_GazeInputModule gazeInputModule;

		private Vector3 CrosshairOriginalScale;

		private float CrosshairOriginalDistance;

		private void Awake()
		{
			gazeInputModule = GetComponent<Pvr_GazeInputModule>();
		}

		private void Start()
		{
			CrosshairOriginalScale = Crosshair.localScale;
			CrosshairOriginalDistance = Crosshair.localPosition.z;
			Crosshair.gameObject.SetActive(value: false);
		}

		private void Update()
		{
			Crosshair.gameObject.SetActive(DisplayCrosshair);
			if (DisplayCrosshair)
			{
				float crossHairAtDistance = CrosshairOriginalDistance;
				if (gazeInputModule.CurrentRaycast.isValid)
				{
					crossHairAtDistance = gazeInputModule.CurrentRaycast.distance * 0.8f - 0.5f;
				}
				SetCrossHairAtDistance(crossHairAtDistance);
			}
		}

		private void SetCrossHairAtDistance(float dist)
		{
			Vector3 localPosition = Crosshair.localPosition;
			Crosshair.localPosition = new Vector3(localPosition.x, localPosition.y, dist);
			Crosshair.localScale = CrosshairOriginalScale * dist;
		}
	}
	public enum RenderEventType
	{
		InitRenderThread = 1024,
		Pause,
		Resume,
		LeftEyeEndFrame,
		RightEyeEndFrame,
		TimeWarp,
		ResetVrModeParms,
		ShutdownRenderThread,
		BeginEye,
		EndEye,
		BoundaryRenderLeft,
		BoundaryRenderRight,
		BothEyeEndFrame,
		CameraFrameLeft,
		CameraFrameRight,
		StartCameraFrame,
		StopCameraFrame
	}
	public static class Pvr_UnitySDKPluginEvent
	{
		private delegate void RenderEventDelegate(int eventId);

		private const uint IS_DATA_FLAG = 2147483648u;

		private const uint DATA_POS_MASK = 1073741824u;

		private const int DATA_POS_SHIFT = 30;

		private const uint EVENT_TYPE_MASK = 1056899072u;

		private const int EVENT_TYPE_SHIFT = 17;

		private const uint PAYLOAD_MASK = 65535u;

		private const int PAYLOAD_SHIFT = 16;

		private static RenderEventDelegate SetSinglePassBeforeForwardOpaqueHandle = SetSinglePassBeforeForwardOpaque;

		private static IntPtr SetSinglePassBeforeForwardOpaquePtr = Marshal.GetFunctionPointerForDelegate(SetSinglePassBeforeForwardOpaqueHandle);

		public static void Issue(RenderEventType eventType)
		{
			GL.IssuePluginEvent(Pvr_UnitySDKAPI.System.GetRenderEventFunc(), (int)eventType);
		}

		private static int EncodeType(int eventType)
		{
			return eventType & 0x7FFFFFFF;
		}

		private static int EncodeData(int eventId, int eventData, int pos)
		{
			return int.MinValue | ((pos << 30) & 0x40000000) | ((eventId << 17) & 0x3EFF0000) | ((eventData >>> pos * 16) & 0xFFFF);
		}

		private static int DecodeData(int eventData)
		{
			uint num = (uint)(eventData & 0x40000000) >> 30;
			return (eventData & 0xFFFF) << (int)(16 * num);
		}

		[MonoPInvokeCallback(typeof(RenderEventDelegate))]
		private static void SetSinglePassBeforeForwardOpaque(int eventId)
		{
			Pvr_UnitySDKAPI.System.UPvr_SinglePassBeforeForwardOpaque();
		}

		public static void SetSinglePassBeforeForwardOpaque(CommandBuffer cmd)
		{
			cmd.IssuePluginEvent(SetSinglePassBeforeForwardOpaquePtr, 0);
		}
	}
	public class Pvr_UnitySDKSightInputModule : BaseInputModule
	{
		[Tooltip("Optional object to place at raycast intersections as a 3D cursor. Be sure it is on a layer that raycasts will ignore.")]
		public GameObject cursor;

		public int trigger;

		[HideInInspector]
		public float clickTime = 0.1f;

		[HideInInspector]
		public Vector2 hotspot = new Vector2(0.5f, 0.5f);

		private PointerEventData pointerData;

		public override bool ShouldActivateModule()
		{
			if (!base.ShouldActivateModule())
			{
				return false;
			}
			return Pvr_UnitySDKManager.SDK.VRModeEnabled;
		}

		public override void DeactivateModule()
		{
			base.DeactivateModule();
			if (pointerData != null)
			{
				HandlePendingClick();
				HandlePointerExitAndEnter(pointerData, null);
				pointerData = null;
			}
			base.eventSystem.SetSelectedGameObject(null, GetBaseEventData());
			if (cursor != null)
			{
				cursor.SetActive(value: false);
			}
		}

		public override bool IsPointerOverGameObject(int pointerId)
		{
			if (pointerData != null)
			{
				return pointerData.pointerEnter != null;
			}
			return false;
		}

		public override void Process()
		{
			CastRayFromGaze();
			UpdateCurrentObject();
			PlaceCursor();
			HandlePendingClick();
			HandleTrigger();
		}

		private void CastRayFromGaze()
		{
			if (pointerData == null)
			{
				pointerData = new PointerEventData(base.eventSystem);
			}
			pointerData.Reset();
			pointerData.position = new Vector2(hotspot.x * (float)Screen.width, hotspot.y * (float)Screen.height);
			base.eventSystem.RaycastAll(pointerData, m_RaycastResultCache);
			pointerData.pointerCurrentRaycast = BaseInputModule.FindFirstRaycast(m_RaycastResultCache);
			m_RaycastResultCache.Clear();
		}

		private void UpdateCurrentObject()
		{
			GameObject gameObject = pointerData.pointerCurrentRaycast.gameObject;
			HandlePointerExitAndEnter(pointerData, gameObject);
			if (ExecuteEvents.GetEventHandler<ISelectHandler>(gameObject) == base.eventSystem.currentSelectedGameObject)
			{
				ExecuteEvents.Execute(base.eventSystem.currentSelectedGameObject, GetBaseEventData(), ExecuteEvents.updateSelectedHandler);
			}
			else
			{
				base.eventSystem.SetSelectedGameObject(null, pointerData);
			}
		}

		private void PlaceCursor()
		{
			if (!(cursor == null))
			{
				GameObject gameObject = pointerData.pointerCurrentRaycast.gameObject;
				cursor.SetActive(gameObject != null);
				if (cursor.activeInHierarchy)
				{
					Camera enterEventCamera = pointerData.enterEventCamera;
					float num = pointerData.pointerCurrentRaycast.distance + enterEventCamera.nearClipPlane - 0.1f;
					cursor.transform.position = enterEventCamera.transform.position + enterEventCamera.transform.forward * num;
				}
			}
		}

		private void HandlePendingClick()
		{
			if (pointerData.eligibleForClick && (Pvr_UnitySDKManager.SDK.picovrTriggered || !(Time.unscaledTime - pointerData.clickTime < clickTime)))
			{
				ExecuteEvents.Execute(pointerData.pointerPress, pointerData, ExecuteEvents.pointerUpHandler);
				ExecuteEvents.Execute(pointerData.pointerPress, pointerData, ExecuteEvents.pointerClickHandler);
				pointerData.pointerPress = null;
				pointerData.rawPointerPress = null;
				pointerData.eligibleForClick = false;
				pointerData.clickCount = 0;
			}
		}

		private void HandleTrigger()
		{
			if (Pvr_UnitySDKManager.SDK.picovrTriggered)
			{
				GameObject gameObject = pointerData.pointerCurrentRaycast.gameObject;
				if (!(gameObject == null) && !(ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject) == null))
				{
					pointerData.pointerPress = ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject);
					pointerData.pressPosition = pointerData.position;
					pointerData.pointerPressRaycast = pointerData.pointerCurrentRaycast;
					pointerData.pointerPress = ExecuteEvents.ExecuteHierarchy(gameObject, pointerData, ExecuteEvents.pointerDownHandler) ?? ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject);
					pointerData.rawPointerPress = gameObject;
					pointerData.eligibleForClick = true;
					pointerData.clickCount = 1;
					pointerData.clickTime = Time.unscaledTime;
				}
			}
		}
	}
	public class Pvr_ObjImporter
	{
		private static Pvr_ObjImporter _instance;

		private List<int> triangles;

		private List<Vector3> vertices;

		private List<Vector2> uv;

		private List<Vector3> normals;

		private List<PvrVector3Int> faceData;

		private List<int> intArray;

		private const int MIN_POW_10 = -16;

		private const int MAX_POW_10 = 16;

		private const int NUM_POWS_10 = 33;

		private static readonly float[] pow10 = GenerateLookupTable();

		public static Pvr_ObjImporter Instance => _instance ?? (_instance = new Pvr_ObjImporter());

		public Mesh ImportFile(string filePath)
		{
			triangles = new List<int>();
			vertices = new List<Vector3>();
			uv = new List<Vector2>();
			normals = new List<Vector3>();
			faceData = new List<PvrVector3Int>();
			intArray = new List<int>();
			LoadMeshData(filePath);
			Vector3[] array = new Vector3[faceData.Count];
			Vector2[] array2 = new Vector2[faceData.Count];
			Vector3[] array3 = new Vector3[faceData.Count];
			for (int i = 0; i < faceData.Count; i++)
			{
				array[i] = vertices[faceData[i].x - 1];
				if (faceData[i].y >= 1)
				{
					array2[i] = uv[faceData[i].y - 1];
				}
				if (faceData[i].z >= 1)
				{
					array3[i] = normals[faceData[i].z - 1];
				}
			}
			Mesh mesh = new Mesh();
			mesh.vertices = array;
			mesh.uv = array2;
			mesh.normals = array3;
			mesh.triangles = triangles.ToArray();
			mesh.RecalculateBounds();
			return mesh;
		}

		private void LoadMeshData(string fileName)
		{
			StringBuilder stringBuilder = new StringBuilder();
			string text = File.ReadAllText(fileName);
			int num = 0;
			string text2 = null;
			int num2 = 0;
			StringBuilder sbInt = new StringBuilder();
			for (int i = 0; i < text.Length; i++)
			{
				if (text[i] != '\n')
				{
					continue;
				}
				stringBuilder.Remove(0, stringBuilder.Length);
				stringBuilder.Append(text, num + 1, i - num);
				num = i;
				if (stringBuilder[0] == 'o' && stringBuilder[1] == ' ')
				{
					sbInt.Remove(0, sbInt.Length);
					for (int j = 2; j < stringBuilder.Length; j++)
					{
						text2 += stringBuilder[j];
					}
				}
				else if (stringBuilder[0] == 'v' && stringBuilder[1] == ' ')
				{
					int start = 2;
					vertices.Add(new Vector3(GetFloat(stringBuilder, ref start, ref sbInt), GetFloat(stringBuilder, ref start, ref sbInt), GetFloat(stringBuilder, ref start, ref sbInt)));
				}
				else if (stringBuilder[0] == 'v' && stringBuilder[1] == 't' && stringBuilder[2] == ' ')
				{
					int start2 = 3;
					uv.Add(new Vector2(GetFloat(stringBuilder, ref start2, ref sbInt), GetFloat(stringBuilder, ref start2, ref sbInt)));
				}
				else if (stringBuilder[0] == 'v' && stringBuilder[1] == 'n' && stringBuilder[2] == ' ')
				{
					int start3 = 3;
					normals.Add(new Vector3(GetFloat(stringBuilder, ref start3, ref sbInt), GetFloat(stringBuilder, ref start3, ref sbInt), GetFloat(stringBuilder, ref start3, ref sbInt)));
				}
				else if (stringBuilder[0] == 'f' && stringBuilder[1] == ' ')
				{
					int start4 = 2;
					int num3 = 1;
					intArray.Clear();
					int num4 = 0;
					while (start4 < stringBuilder.Length && char.IsDigit(stringBuilder[start4]))
					{
						faceData.Add(new PvrVector3Int(GetInt(stringBuilder, ref start4, ref sbInt), GetInt(stringBuilder, ref start4, ref sbInt), GetInt(stringBuilder, ref start4, ref sbInt)));
						num3++;
						intArray.Add(num2);
						num2++;
					}
					num4 += num3;
					for (num3 = 1; num3 + 2 < num4; num3++)
					{
						triangles.Add(intArray[0]);
						triangles.Add(intArray[num3]);
						triangles.Add(intArray[num3 + 1]);
					}
				}
			}
		}

		private float GetFloat(StringBuilder sb, ref int start, ref StringBuilder sbFloat)
		{
			sbFloat.Remove(0, sbFloat.Length);
			while (start < sb.Length && (char.IsDigit(sb[start]) || sb[start] == '-' || sb[start] == '.'))
			{
				sbFloat.Append(sb[start]);
				start++;
			}
			start++;
			return ParseFloat(sbFloat);
		}

		private int GetInt(StringBuilder sb, ref int start, ref StringBuilder sbInt)
		{
			sbInt.Remove(0, sbInt.Length);
			while (start < sb.Length && char.IsDigit(sb[start]))
			{
				sbInt.Append(sb[start]);
				start++;
			}
			start++;
			return IntParseFast(sbInt);
		}

		private static float[] GenerateLookupTable()
		{
			float[] array = new float[320];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = (float)(i / 33) * Mathf.Pow(10f, i % 33 + -16);
			}
			return array;
		}

		private float ParseFloat(StringBuilder value)
		{
			float num = 0f;
			bool flag = false;
			int length = value.Length;
			int num2 = value.Length;
			for (int num3 = length - 1; num3 >= 0; num3--)
			{
				if (value[num3] == '.')
				{
					num2 = num3;
					break;
				}
			}
			int num4 = 16 + num2;
			for (int i = 0; i < num2; i++)
			{
				if (i != num2 && value[i] != '-')
				{
					num += pow10[(value[i] - 48) * 33 + num4 - i - 1];
				}
				else if (value[i] == '-')
				{
					flag = true;
				}
			}
			for (int j = num2 + 1; j < length; j++)
			{
				if (j != num2)
				{
					num += pow10[(value[j] - 48) * 33 + num4 - j];
				}
			}
			if (flag)
			{
				num = 0f - num;
			}
			return num;
		}

		private int IntParseFast(StringBuilder value)
		{
			int num = 0;
			for (int i = 0; i < value.Length; i++)
			{
				num = 10 * num + (value[i] - 48);
			}
			return num;
		}
	}
	public sealed class PvrVector3Int
	{
		public int x { get; set; }

		public int y { get; set; }

		public int z { get; set; }

		public PvrVector3Int()
		{
		}

		public PvrVector3Int(int x, int y, int z)
		{
			this.x = x;
			this.y = y;
			this.z = z;
		}
	}
	public class Pvr_EnumFlags : PropertyAttribute
	{
	}
	public enum ConfirmBtn
	{
		App = 1,
		TouchPad = 2,
		Trigger = 4
	}
	public class Pvr_InputModule : PointerInputModule
	{
		public static List<Pvr_UIPointer> pointers = new List<Pvr_UIPointer>();

		[Pvr_EnumFlags]
		public ConfirmBtn confirmBtn = ConfirmBtn.TouchPad;

		private List<RaycastResult> rayCasts = new List<RaycastResult>();

		private RaycastResult rayCastResult;

		public virtual void Initialise()
		{
			pointers.Clear();
		}

		public static void AddPoint(Pvr_UIPointer point)
		{
			if (!pointers.Contains(point))
			{
				pointers.Add(point);
			}
		}

		public static void RemovePoint(Pvr_UIPointer point)
		{
			if (pointers.Contains(point))
			{
				pointers.Remove(point);
			}
		}

		public override void Process()
		{
			if (Pvr_UnitySDKManager.SDK.isHasController)
			{
				if ((confirmBtn & ConfirmBtn.App) == ConfirmBtn.App)
				{
					Pvr_UIPointer.AppBtnValue = Controller.UPvr_GetKey(Pvr_ControllerManager.controllerlink.mainHandID, Pvr_KeyCode.APP);
				}
				if ((confirmBtn & ConfirmBtn.TouchPad) == ConfirmBtn.TouchPad)
				{
					Pvr_UIPointer.TouchBtnValue = Controller.UPvr_GetKey(Pvr_ControllerManager.controllerlink.mainHandID, Pvr_KeyCode.TOUCHPAD);
				}
				if ((confirmBtn & ConfirmBtn.Trigger) == ConfirmBtn.Trigger)
				{
					Pvr_UIPointer.TriggerBtnValue = Controller.UPvr_GetKey(Pvr_ControllerManager.controllerlink.mainHandID, Pvr_KeyCode.TRIGGER);
				}
			}
			for (int i = 0; i < pointers.Count; i++)
			{
				Pvr_UIPointer pvr_UIPointer = pointers[i];
				if (pvr_UIPointer.gameObject.activeInHierarchy && pvr_UIPointer.enabled)
				{
					List<RaycastResult> results = new List<RaycastResult>();
					if (pvr_UIPointer.PointerActive())
					{
						results = CheckRaycasts(pvr_UIPointer);
					}
					Hover(pvr_UIPointer, results);
					Click(pvr_UIPointer, results);
					Drag(pvr_UIPointer, results);
				}
			}
		}

		protected virtual List<RaycastResult> CheckRaycasts(Pvr_UIPointer pointer)
		{
			rayCastResult.worldPosition = pointer.GetOriginPosition();
			rayCastResult.worldNormal = pointer.GetOriginForward();
			pointer.pointerEventData.pointerCurrentRaycast = rayCastResult;
			base.eventSystem.RaycastAll(pointer.pointerEventData, rayCasts);
			return rayCasts;
		}

		protected virtual bool CheckTransformTree(Transform target, Transform source)
		{
			if (target == null)
			{
				return false;
			}
			if (target.Equals(source))
			{
				return true;
			}
			return CheckTransformTree(target.transform.parent, source);
		}

		protected virtual bool NoValidCollision(Pvr_UIPointer pointer, List<RaycastResult> results)
		{
			if (results.Count != 0)
			{
				return !CheckTransformTree(results[0].gameObject.transform, pointer.pointerEventData.pointerEnter.transform);
			}
			return true;
		}

		protected virtual bool IsHovering(Pvr_UIPointer pointer)
		{
			foreach (GameObject item in pointer.pointerEventData.hovered)
			{
				if ((bool)pointer.pointerEventData.pointerEnter && (bool)item && CheckTransformTree(item.transform, pointer.pointerEventData.pointerEnter.transform))
				{
					return true;
				}
			}
			return false;
		}

		protected virtual bool ValidElement(GameObject obj)
		{
			Pvr_UICanvas componentInParent = obj.GetComponentInParent<Pvr_UICanvas>();
			if (!componentInParent || !componentInParent.enabled)
			{
				return false;
			}
			return true;
		}

		protected virtual void CheckPointerHoverClick(Pvr_UIPointer pointer, List<RaycastResult> results)
		{
			if (pointer.hoverDurationTimer > 0f)
			{
				pointer.hoverDurationTimer -= Time.deltaTime;
			}
			if (pointer.canClickOnHover && pointer.hoverDurationTimer <= 0f)
			{
				pointer.canClickOnHover = false;
				ClickOnDown(pointer, results, forceClick: true);
			}
		}

		protected virtual void Hover(Pvr_UIPointer pointer, List<RaycastResult> results)
		{
			if ((bool)pointer.pointerEventData.pointerEnter)
			{
				CheckPointerHoverClick(pointer, results);
				if (!ValidElement(pointer.pointerEventData.pointerEnter))
				{
					pointer.pointerEventData.pointerEnter = null;
					return;
				}
				if (NoValidCollision(pointer, results))
				{
					ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerEnter, pointer.pointerEventData, ExecuteEvents.pointerExitHandler);
					pointer.pointerEventData.hovered.Remove(pointer.pointerEventData.pointerEnter);
					pointer.pointerEventData.pointerEnter = null;
				}
				if (results.Count <= 0 || !(pointer.pointerEventData.pointerEnter != results[0].gameObject))
				{
					return;
				}
				{
					foreach (RaycastResult result in results)
					{
						if (!ValidElement(result.gameObject))
						{
							continue;
						}
						GameObject gameObject = ExecuteEvents.ExecuteHierarchy(result.gameObject, pointer.pointerEventData, ExecuteEvents.pointerEnterHandler);
						if (gameObject != null)
						{
							Selectable component = gameObject.GetComponent<Selectable>();
							if ((bool)component)
							{
								Navigation navigation = default(Navigation);
								navigation.mode = Navigation.Mode.None;
								component.navigation = navigation;
							}
							pointer.pointerEventData.hovered.Remove(pointer.pointerEventData.pointerEnter);
							pointer.OnUIPointerElementEnter(pointer.SetUIPointerEvent(result, gameObject, pointer.hoveringElement));
							pointer.hoveringElement = gameObject;
							pointer.pointerEventData.pointerCurrentRaycast = result;
							pointer.pointerEventData.pointerEnter = gameObject;
							pointer.pointerEventData.hovered.Add(pointer.pointerEventData.pointerEnter);
							break;
						}
						if (result.gameObject != pointer.hoveringElement)
						{
							pointer.OnUIPointerElementEnter(pointer.SetUIPointerEvent(result, result.gameObject, pointer.hoveringElement));
						}
						pointer.hoveringElement = result.gameObject;
					}
					return;
				}
			}
			foreach (RaycastResult result2 in results)
			{
				if (!ValidElement(result2.gameObject))
				{
					continue;
				}
				GameObject gameObject2 = ExecuteEvents.ExecuteHierarchy(result2.gameObject, pointer.pointerEventData, ExecuteEvents.pointerEnterHandler);
				if (gameObject2 != null)
				{
					Selectable component2 = gameObject2.GetComponent<Selectable>();
					if ((bool)component2)
					{
						Navigation navigation2 = default(Navigation);
						navigation2.mode = Navigation.Mode.None;
						component2.navigation = navigation2;
					}
					pointer.OnUIPointerElementEnter(pointer.SetUIPointerEvent(result2, gameObject2, pointer.hoveringElement));
					pointer.hoveringElement = gameObject2;
					pointer.pointerEventData.pointerCurrentRaycast = result2;
					pointer.pointerEventData.pointerEnter = gameObject2;
					pointer.pointerEventData.hovered.Add(pointer.pointerEventData.pointerEnter);
					break;
				}
				if (result2.gameObject != pointer.hoveringElement)
				{
					pointer.OnUIPointerElementEnter(pointer.SetUIPointerEvent(result2, result2.gameObject, pointer.hoveringElement));
				}
				pointer.hoveringElement = result2.gameObject;
			}
			if ((bool)pointer.hoveringElement && results.Count == 0)
			{
				pointer.OnUIPointerElementExit(pointer.SetUIPointerEvent(default(RaycastResult), null, pointer.hoveringElement));
				pointer.hoveringElement = null;
			}
		}

		protected virtual void Click(Pvr_UIPointer pointer, List<RaycastResult> results)
		{
			switch (pointer.clickMethod)
			{
			case Pvr_UIPointer.ClickMethods.ClickOnButtonUp:
				ClickOnUp(pointer, results);
				break;
			case Pvr_UIPointer.ClickMethods.ClickOnButtonDown:
				ClickOnDown(pointer, results);
				break;
			}
		}

		protected virtual void ClickOnUp(Pvr_UIPointer pointer, List<RaycastResult> results)
		{
			pointer.pointerEventData.eligibleForClick = pointer.ValidClick(checkLastClick: false);
			if (!AttemptClick(pointer))
			{
				IsEligibleClick(pointer, results);
			}
		}

		protected virtual void ClickOnDown(Pvr_UIPointer pointer, List<RaycastResult> results, bool forceClick = false)
		{
			pointer.pointerEventData.eligibleForClick = forceClick || pointer.ValidClick(checkLastClick: true);
			if (IsEligibleClick(pointer, results))
			{
				pointer.pointerEventData.eligibleForClick = false;
				AttemptClick(pointer);
			}
		}

		protected virtual bool IsEligibleClick(Pvr_UIPointer pointer, List<RaycastResult> results)
		{
			if (pointer.pointerEventData.eligibleForClick)
			{
				foreach (RaycastResult result in results)
				{
					if (ValidElement(result.gameObject))
					{
						GameObject gameObject = ExecuteEvents.ExecuteHierarchy(result.gameObject, pointer.pointerEventData, ExecuteEvents.pointerDownHandler);
						if (gameObject != null)
						{
							pointer.pointerEventData.pressPosition = pointer.pointerEventData.position;
							pointer.pointerEventData.pointerPressRaycast = result;
							pointer.pointerEventData.pointerPress = gameObject;
							return true;
						}
					}
				}
			}
			return false;
		}

		protected virtual bool AttemptClick(Pvr_UIPointer pointer)
		{
			if ((bool)pointer.pointerEventData.pointerPress)
			{
				if (!ValidElement(pointer.pointerEventData.pointerPress))
				{
					pointer.pointerEventData.pointerPress = null;
					return true;
				}
				if (pointer.pointerEventData.eligibleForClick)
				{
					if (!IsHovering(pointer))
					{
						ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerPress, pointer.pointerEventData, ExecuteEvents.pointerUpHandler);
						pointer.pointerEventData.pointerPress = null;
					}
				}
				else
				{
					pointer.OnUIPointerElementClick(pointer.SetUIPointerEvent(pointer.pointerEventData.pointerPressRaycast, pointer.pointerEventData.pointerPress));
					ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerPress, pointer.pointerEventData, ExecuteEvents.pointerClickHandler);
					ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerPress, pointer.pointerEventData, ExecuteEvents.pointerUpHandler);
					pointer.pointerEventData.pointerPress = null;
				}
				return true;
			}
			return false;
		}

		protected virtual void Drag(Pvr_UIPointer pointer, List<RaycastResult> results)
		{
			pointer.pointerEventData.dragging = pointer.IsSelectionButtonPressed() && pointer.pointerEventData.delta != Vector2.zero;
			if ((bool)pointer.pointerEventData.pointerDrag)
			{
				if (!ValidElement(pointer.pointerEventData.pointerDrag))
				{
					pointer.pointerEventData.pointerDrag = null;
					return;
				}
				if (pointer.pointerEventData.dragging)
				{
					if (IsHovering(pointer))
					{
						ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerDrag, pointer.pointerEventData, ExecuteEvents.dragHandler);
					}
					return;
				}
				ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerDrag, pointer.pointerEventData, ExecuteEvents.dragHandler);
				ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerDrag, pointer.pointerEventData, ExecuteEvents.endDragHandler);
				foreach (RaycastResult result in results)
				{
					ExecuteEvents.ExecuteHierarchy(result.gameObject, pointer.pointerEventData, ExecuteEvents.dropHandler);
				}
				pointer.pointerEventData.pointerDrag = null;
			}
			else
			{
				if (!pointer.pointerEventData.dragging)
				{
					return;
				}
				foreach (RaycastResult result2 in results)
				{
					if (ValidElement(result2.gameObject))
					{
						ExecuteEvents.ExecuteHierarchy(result2.gameObject, pointer.pointerEventData, ExecuteEvents.initializePotentialDrag);
						ExecuteEvents.ExecuteHierarchy(result2.gameObject, pointer.pointerEventData, ExecuteEvents.beginDragHandler);
						GameObject gameObject = ExecuteEvents.ExecuteHierarchy(result2.gameObject, pointer.pointerEventData, ExecuteEvents.dragHandler);
						if (gameObject != null)
						{
							pointer.pointerEventData.pointerDrag = gameObject;
							break;
						}
					}
				}
			}
		}
	}
	public class Pvr_UICanvas : MonoBehaviour
	{
		public bool clickOnPointerCollision;

		public float autoActivateWithinDistance;

		protected BoxCollider canvasBoxCollider;

		protected Rigidbody canvasRigidBody;

		protected Coroutine draggablePanelCreation;

		protected const string CANVAS_DRAGGABLE_PANEL = "UICANVAS_DRAGGABLE_PANEL";

		protected virtual void OnEnable()
		{
			SetupCanvas();
		}

		protected virtual void OnDisable()
		{
			RemoveCanvas();
		}

		protected virtual void OnDestroy()
		{
			RemoveCanvas();
		}

		protected virtual void SetupCanvas()
		{
			Canvas component = GetComponent<Canvas>();
			if ((bool)component && component.renderMode == RenderMode.WorldSpace)
			{
				RectTransform component2 = component.GetComponent<RectTransform>();
				Vector2 sizeDelta = component2.sizeDelta;
				GraphicRaycaster component3 = component.gameObject.GetComponent<GraphicRaycaster>();
				Pvr_UIGraphicRaycaster pvr_UIGraphicRaycaster = component.gameObject.GetComponent<Pvr_UIGraphicRaycaster>();
				if (!pvr_UIGraphicRaycaster)
				{
					pvr_UIGraphicRaycaster = component.gameObject.AddComponent<Pvr_UIGraphicRaycaster>();
				}
				if ((bool)component3 && component3.enabled)
				{
					pvr_UIGraphicRaycaster.ignoreReversedGraphics = component3.ignoreReversedGraphics;
					pvr_UIGraphicRaycaster.blockingObjects = component3.blockingObjects;
					component3.enabled = false;
				}
				if (!component.gameObject.GetComponent<BoxCollider>())
				{
					float z = 0.1f / component2.localScale.z;
					canvasBoxCollider = component.gameObject.AddComponent<BoxCollider>();
					canvasBoxCollider.size = new Vector3(sizeDelta.x, sizeDelta.y, z);
					canvasBoxCollider.isTrigger = true;
				}
				if (!component.gameObject.GetComponent<Rigidbody>())
				{
					canvasRigidBody = component.gameObject.AddComponent<Rigidbody>();
					canvasRigidBody.isKinematic = true;
				}
				draggablePanelCreation = StartCoroutine(CreateDraggablePanel(component, sizeDelta));
			}
		}

		protected virtual IEnumerator CreateDraggablePanel(Canvas canvas, Vector2 canvasSize)
		{
			if ((bool)canvas && !canvas.transform.Find("UICANVAS_DRAGGABLE_PANEL"))
			{
				yield return null;
				GameObject obj = new GameObject("UICANVAS_DRAGGABLE_PANEL", typeof(RectTransform));
				obj.AddComponent<LayoutElement>().ignoreLayout = true;
				obj.AddComponent<Image>().color = Color.clear;
				obj.AddComponent<EventTrigger>();
				obj.transform.SetParent(canvas.transform);
				obj.GetComponent<RectTransform>().sizeDelta = canvasSize;
				obj.transform.localPosition = Vector3.zero;
				obj.transform.localRotation = Quaternion.identity;
				obj.transform.localScale = Vector3.one;
				obj.transform.SetAsFirstSibling();
			}
		}

		protected virtual void RemoveCanvas()
		{
			Canvas component = GetComponent<Canvas>();
			if ((bool)component)
			{
				GraphicRaycaster component2 = component.gameObject.GetComponent<GraphicRaycaster>();
				Pvr_UIGraphicRaycaster component3 = component.gameObject.GetComponent<Pvr_UIGraphicRaycaster>();
				if ((bool)component3)
				{
					UnityEngine.Object.Destroy(component3);
				}
				if ((bool)component2 && !component2.enabled)
				{
					component2.enabled = true;
				}
				if ((bool)canvasBoxCollider)
				{
					UnityEngine.Object.Destroy(canvasBoxCollider);
				}
				if ((bool)canvasRigidBody)
				{
					UnityEngine.Object.Destroy(canvasRigidBody);
				}
				StopCoroutine(draggablePanelCreation);
				Transform transform = component.transform.Find("UICANVAS_DRAGGABLE_PANEL");
				if ((bool)transform)
				{
					UnityEngine.Object.Destroy(transform.gameObject);
				}
			}
		}
	}
	public struct UIDraggableItemEventArgs
	{
		public GameObject target;
	}
	public delegate void UIDraggableItemEventHandler(object sender, UIDraggableItemEventArgs e);
	public class Pvr_UIDraggableItem : MonoBehaviour, IBeginDragHandler, IEventSystemHandler, IDragHandler, IEndDragHandler
	{
		public bool restrictToDropZone;

		public bool restrictToOriginalCanvas;

		public float moveOffset = 0.1f;

		[HideInInspector]
		public GameObject validDropZone;

		protected RectTransform dragTransform;

		protected Vector3 startPosition;

		protected Quaternion startRotation;

		protected GameObject startDropZone;

		protected Transform startParent;

		protected Canvas startCanvas;

		protected CanvasGroup canvasGroup;

		protected Pvr_InputModule currentInputmodule;

		public event UIDraggableItemEventHandler DraggableItemDropped;

		public event UIDraggableItemEventHandler DraggableItemReset;

		public virtual void OnDraggableItemDropped(UIDraggableItemEventArgs e)
		{
			if (this.DraggableItemDropped != null)
			{
				this.DraggableItemDropped(this, e);
			}
		}

		public virtual void OnDraggableItemReset(UIDraggableItemEventArgs e)
		{
			if (this.DraggableItemReset != null)
			{
				this.DraggableItemReset(this, e);
			}
		}

		public void OnBeginDrag(PointerEventData eventData)
		{
			startPosition = base.transform.position;
			startRotation = base.transform.rotation;
			startParent = base.transform.parent;
			startCanvas = GetComponentInParent<Canvas>();
			canvasGroup.blocksRaycasts = false;
			if (restrictToDropZone)
			{
				startDropZone = GetComponentInParent<Pvr_UIDropZone>().gameObject;
				validDropZone = startDropZone;
			}
			SetDragPosition(eventData);
			Pvr_UIPointer pointer = GetPointer();
			if (pointer != null)
			{
				pointer.OnUIPointerElementDragStart(pointer.SetUIPointerEvent(pointer.pointerEventData.pointerPressRaycast, base.gameObject));
			}
		}

		public void OnDrag(PointerEventData eventData)
		{
			SetDragPosition(eventData);
		}

		public void OnEndDrag(PointerEventData eventData)
		{
			canvasGroup.blocksRaycasts = true;
			dragTransform = null;
			base.transform.position += base.transform.forward * moveOffset;
			bool flag = true;
			if (restrictToDropZone)
			{
				if (validDropZone != null && validDropZone != startDropZone)
				{
					base.transform.SetParent(validDropZone.transform);
				}
				else
				{
					ResetElement();
					flag = false;
				}
			}
			Canvas canvas = ((eventData.pointerEnter != null) ? eventData.pointerEnter.GetComponentInParent<Canvas>() : null);
			if (restrictToOriginalCanvas && canvas != null && canvas != startCanvas)
			{
				ResetElement();
				flag = false;
			}
			if (canvas == null)
			{
				ResetElement();
				flag = false;
			}
			if (flag)
			{
				Pvr_UIPointer pointer = GetPointer();
				if (pointer != null)
				{
					pointer.OnUIPointerElementDragEnd(pointer.SetUIPointerEvent(pointer.pointerEventData.pointerPressRaycast, base.gameObject));
				}
				OnDraggableItemDropped(SetEventPayload(validDropZone));
			}
			validDropZone = null;
			startParent = null;
			startCanvas = null;
		}

		protected virtual void OnEnable()
		{
			canvasGroup = GetComponent<CanvasGroup>();
			if (restrictToDropZone && GetComponentInParent<Pvr_UIDropZone>() == null)
			{
				base.enabled = false;
			}
			currentInputmodule = UnityEngine.Object.FindObjectOfType<Pvr_InputModule>();
		}

		protected virtual Pvr_UIPointer GetPointer()
		{
			foreach (Pvr_UIPointer pointer in Pvr_InputModule.pointers)
			{
				if (pointer.gameObject.activeInHierarchy && (bool)pointer)
				{
					return pointer;
				}
			}
			return null;
		}

		protected virtual void SetDragPosition(PointerEventData eventData)
		{
			if (eventData.pointerEnter != null && eventData.pointerEnter.transform as RectTransform != null)
			{
				dragTransform = eventData.pointerEnter.transform as RectTransform;
			}
			if (dragTransform != null && RectTransformUtility.ScreenPointToWorldPointInRectangle(dragTransform, eventData.position, eventData.pressEventCamera, out var worldPoint))
			{
				base.transform.position = worldPoint - base.transform.forward * moveOffset;
				base.transform.rotation = dragTransform.rotation;
			}
		}

		protected virtual void ResetElement()
		{
			base.transform.position = startPosition;
			base.transform.rotation = startRotation;
			base.transform.SetParent(startParent);
			OnDraggableItemReset(SetEventPayload(startParent.gameObject));
		}

		protected virtual UIDraggableItemEventArgs SetEventPayload(GameObject target)
		{
			UIDraggableItemEventArgs result = default(UIDraggableItemEventArgs);
			result.target = target;
			return result;
		}
	}
	public class Pvr_UIDropZone : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler
	{
		protected Pvr_UIDraggableItem droppableItem;

		public void OnPointerEnter(PointerEventData eventData)
		{
			if ((bool)eventData.pointerDrag)
			{
				Pvr_UIDraggableItem component = eventData.pointerDrag.GetComponent<Pvr_UIDraggableItem>();
				if ((bool)component && component.restrictToDropZone)
				{
					component.validDropZone = base.gameObject;
					droppableItem = component;
				}
			}
		}

		public void OnPointerExit(PointerEventData eventData)
		{
			if ((bool)droppableItem)
			{
				droppableItem.validDropZone = null;
			}
			droppableItem = null;
		}
	}
	public class Pvr_UIGraphicRaycaster : GraphicRaycaster
	{
		protected Canvas currentCanvas;

		protected Vector2 lastKnownPosition;

		protected const float UI_CONTROL_OFFSET = 1E-05f;

		[NonSerialized]
		private static List<RaycastResult> s_RaycastResults = new List<RaycastResult>();

		protected virtual Canvas canvas
		{
			get
			{
				if (currentCanvas != null)
				{
					return currentCanvas;
				}
				currentCanvas = base.gameObject.GetComponent<Canvas>();
				return currentCanvas;
			}
		}

		public override void Raycast(PointerEventData eventData, List<RaycastResult> resultAppendList)
		{
			if (!(canvas == null))
			{
				Raycast(ray: new Ray(eventData.pointerCurrentRaycast.worldPosition, eventData.pointerCurrentRaycast.worldNormal), canvas: canvas, eventCamera: eventCamera, results: ref s_RaycastResults);
				SetNearestRaycast(ref eventData, ref resultAppendList, ref s_RaycastResults);
				s_RaycastResults.Clear();
			}
		}

		protected virtual void SetNearestRaycast(ref PointerEventData eventData, ref List<RaycastResult> resultAppendList, ref List<RaycastResult> raycastResults)
		{
			RaycastResult? raycastResult = null;
			for (int i = 0; i < raycastResults.Count; i++)
			{
				RaycastResult raycastResult2 = raycastResults[i];
				raycastResult2.index = resultAppendList.Count;
				if (!raycastResult.HasValue || raycastResult2.distance < raycastResult.Value.distance)
				{
					raycastResult = raycastResult2;
				}
				resultAppendList.Add(raycastResult2);
			}
			if (raycastResult.HasValue)
			{
				eventData.position = raycastResult.Value.screenPosition;
				eventData.delta = eventData.position - lastKnownPosition;
				lastKnownPosition = eventData.position;
				eventData.pointerCurrentRaycast = raycastResult.Value;
			}
		}

		protected virtual float GetHitDistance(Ray ray)
		{
			float result = float.MaxValue;
			if (canvas.renderMode != 0 && base.blockingObjects != 0)
			{
				float num = Vector3.Distance(ray.origin, canvas.transform.position);
				if (base.blockingObjects == BlockingObjects.ThreeD || base.blockingObjects == BlockingObjects.All)
				{
					Physics.Raycast(ray, out var hitInfo, num);
					if ((bool)hitInfo.collider)
					{
						result = hitInfo.distance;
					}
				}
				if (base.blockingObjects == BlockingObjects.TwoD || base.blockingObjects == BlockingObjects.All)
				{
					RaycastHit2D raycastHit2D = Physics2D.Raycast(ray.origin, ray.direction, num);
					if (raycastHit2D.collider != null)
					{
						result = raycastHit2D.fraction * num;
					}
				}
			}
			return result;
		}

		protected virtual void Raycast(Canvas canvas, Camera eventCamera, Ray ray, ref List<RaycastResult> results)
		{
			float hitDistance = GetHitDistance(ray);
			IList<Graphic> graphicsForCanvas = GraphicRegistry.GetGraphicsForCanvas(canvas);
			for (int i = 0; i < graphicsForCanvas.Count; i++)
			{
				Graphic graphic = graphicsForCanvas[i];
				if (graphic.depth == -1 || !graphic.raycastTarget)
				{
					continue;
				}
				Transform transform = graphic.transform;
				Vector3 forward = transform.forward;
				float num = Vector3.Dot(forward, transform.position - ray.origin) / Vector3.Dot(forward, ray.direction);
				if (!(num < 0f) && !(num - 1E-05f > hitDistance))
				{
					Vector3 point = ray.GetPoint(num);
					Vector2 vector = eventCamera.WorldToScreenPoint(point);
					if (RectTransformUtility.RectangleContainsScreenPoint(graphic.rectTransform, vector, eventCamera) && graphic.Raycast(vector, eventCamera))
					{
						RaycastResult raycastResult = default(RaycastResult);
						raycastResult.gameObject = graphic.gameObject;
						raycastResult.module = this;
						raycastResult.distance = num;
						raycastResult.screenPosition = vector;
						raycastResult.worldPosition = point;
						raycastResult.depth = graphic.depth;
						raycastResult.sortingLayer = canvas.sortingLayerID;
						raycastResult.sortingOrder = canvas.sortingOrder;
						RaycastResult item = raycastResult;
						results.Add(item);
					}
				}
			}
			results.Sort((RaycastResult g1, RaycastResult g2) => g2.depth.CompareTo(g1.depth));
		}
	}
	public struct UIPointerEventArgs
	{
		public bool isActive;

		public GameObject currentTarget;

		public GameObject previousTarget;

		public RaycastResult raycastResult;
	}
	public delegate void UIPointerEventHandler(object sender, UIPointerEventArgs e);
	public class Pvr_UIPointer : MonoBehaviour
	{
		public enum ClickMethods
		{
			ClickOnButtonUp,
			ClickOnButtonDown
		}

		public ClickMethods clickMethod;

		[HideInInspector]
		public bool collisionClick;

		[HideInInspector]
		public bool pressToDrag;

		[HideInInspector]
		public GameObject autoActivatingCanvas;

		[HideInInspector]
		public PointerEventData pointerEventData;

		[HideInInspector]
		public GameObject hoveringElement;

		[HideInInspector]
		public float hoverDurationTimer;

		[HideInInspector]
		public bool canClickOnHover;

		public Transform pointerOriginTransform;

		protected bool pointerClicked;

		protected bool beamEnabledState;

		protected bool lastPointerPressState;

		protected bool lastPointerClickState;

		protected GameObject currentTarget;

		protected EventSystem cachedEventSystem;

		protected Pvr_InputModule cachedVRInputModule;

		protected Transform originalPointerOriginTransform;

		public static bool TouchBtnValue;

		public static bool AppBtnValue;

		public static bool TriggerBtnValue;

		public event UIPointerEventHandler UIPointerElementEnter;

		public event UIPointerEventHandler UIPointerElementExit;

		public event UIPointerEventHandler UIPointerElementClick;

		public event UIPointerEventHandler UIPointerElementDragStart;

		public event UIPointerEventHandler UIPointerElementDragEnd;

		public virtual bool PointerActive()
		{
			return true;
		}

		public virtual bool IsSelectionButtonPressed()
		{
			if (!Input.GetMouseButton(0) && !Input.GetKey(KeyCode.JoystickButton0) && !TouchBtnValue && !AppBtnValue)
			{
				return TriggerBtnValue;
			}
			return true;
		}

		public virtual Vector3 GetOriginPosition()
		{
			if (!pointerOriginTransform)
			{
				return base.transform.position;
			}
			return pointerOriginTransform.position;
		}

		public virtual Vector3 GetOriginForward()
		{
			if (!pointerOriginTransform)
			{
				return base.transform.forward;
			}
			return pointerOriginTransform.forward;
		}

		public virtual bool ValidClick(bool checkLastClick, bool lastClickState = false)
		{
			bool result = (collisionClick ? collisionClick : IsSelectionButtonPressed());
			if (!checkLastClick)
			{
				return result;
			}
			return result;
		}

		protected virtual void ResetHoverTimer()
		{
			hoverDurationTimer = 0f;
			canClickOnHover = false;
		}

		public virtual void OnUIPointerElementEnter(UIPointerEventArgs e)
		{
			if (e.currentTarget != currentTarget)
			{
				ResetHoverTimer();
			}
			currentTarget = e.currentTarget;
			if (this.UIPointerElementEnter != null)
			{
				this.UIPointerElementEnter(this, e);
			}
		}

		public virtual void OnUIPointerElementExit(UIPointerEventArgs e)
		{
			if (e.previousTarget == currentTarget)
			{
				ResetHoverTimer();
			}
			if (this.UIPointerElementExit != null)
			{
				this.UIPointerElementExit(this, e);
			}
		}

		public virtual void OnUIPointerElementClick(UIPointerEventArgs e)
		{
			if (e.currentTarget == currentTarget)
			{
				ResetHoverTimer();
			}
			if (this.UIPointerElementClick != null)
			{
				this.UIPointerElementClick(this, e);
			}
		}

		public virtual void OnUIPointerElementDragStart(UIPointerEventArgs e)
		{
			if (this.UIPointerElementDragStart != null)
			{
				this.UIPointerElementDragStart(this, e);
			}
		}

		public virtual void OnUIPointerElementDragEnd(UIPointerEventArgs e)
		{
			if (this.UIPointerElementDragEnd != null)
			{
				this.UIPointerElementDragEnd(this, e);
			}
		}

		public virtual UIPointerEventArgs SetUIPointerEvent(RaycastResult currentRaycastResult, GameObject currentTarget, GameObject lastTarget = null)
		{
			UIPointerEventArgs result = default(UIPointerEventArgs);
			result.isActive = PointerActive();
			result.currentTarget = currentTarget;
			result.previousTarget = lastTarget;
			result.raycastResult = currentRaycastResult;
			return result;
		}

		protected virtual void Awake()
		{
			originalPointerOriginTransform = pointerOriginTransform;
		}

		protected virtual void OnEnable()
		{
			pointerOriginTransform = originalPointerOriginTransform;
			ConfigureEventSystem();
			pointerClicked = false;
			lastPointerPressState = false;
			lastPointerClickState = false;
			beamEnabledState = false;
		}

		protected virtual void OnDisable()
		{
			Pvr_InputModule.RemovePoint(this);
		}

		protected virtual void ConfigureEventSystem()
		{
			if (!cachedEventSystem)
			{
				cachedEventSystem = UnityEngine.Object.FindObjectOfType<EventSystem>();
			}
			if (!cachedVRInputModule)
			{
				cachedVRInputModule = cachedEventSystem.GetComponent<Pvr_InputModule>();
			}
			if ((bool)cachedEventSystem && (bool)cachedVRInputModule && pointerEventData == null)
			{
				pointerEventData = new PointerEventData(cachedEventSystem);
			}
			Pvr_InputModule.AddPoint(this);
		}
	}
	[ExecuteInEditMode]
	public class Pvr_UnitySDKEditor : MonoBehaviour
	{
		private bool vrModeEnabled = true;

		private float mouseX;

		private float mouseY;

		private float mouseZ;

		private float neckModelScale;

		private bool autoUntiltHead;

		private static readonly Vector3 neckOffset = new Vector3(0f, 0.075f, 0.0805f);

		[HideInInspector]
		public Matrix4x4 headView;

		[HideInInspector]
		public Matrix4x4 leftEyeUndistortedProj;

		[HideInInspector]
		public Matrix4x4 rightEyeUndistortedProj;

		[HideInInspector]
		public Matrix4x4 leftEyeProj;

		[HideInInspector]
		public Matrix4x4 rightEyeProj;

		private const float TOUCH_TIME_LIMIT = 0.2f;

		private float touchStartTime;

		public Matrix4x4 UndistortedProjection(Eye eye)
		{
			if (eye != 0)
			{
				return rightEyeUndistortedProj;
			}
			return leftEyeUndistortedProj;
		}

		public Matrix4x4 Projection(Eye eye)
		{
			if (eye != 0)
			{
				return rightEyeProj;
			}
			return leftEyeProj;
		}

		private void Awake()
		{
			InitEyePara();
			InitEditorSensorPara();
		}

		private void Update()
		{
			SimulateInput();
			Pvr_UnitySDKManager.SDK.picovrTriggered = Pvr_UnitySDKManager.SDK.newPicovrTriggered;
			Pvr_UnitySDKManager.SDK.newPicovrTriggered = false;
		}

		public void InitEyePara()
		{
			ComputeEyesFromProfile();
			InitForEye(ref Pvr_UnitySDKManager.SDK.Eyematerial, ref Pvr_UnitySDKManager.SDK.Middlematerial);
			if (Pvr_UnitySDKRender.Instance == null)
			{
				PLOG.I("pvr_UnitySDKRender init failed");
			}
			if (Pvr_UnitySDKSensor.Instance == null)
			{
				PLOG.I("pvr_UnitySDKSensor init failed");
			}
			FovAdjust();
		}

		private void InitEditorSensorPara()
		{
			Pvr_UnitySDKManager.SDK.picovrTriggered = Pvr_UnitySDKManager.SDK.newPicovrTriggered;
			Pvr_UnitySDKManager.SDK.newPicovrTriggered = false;
		}

		public static Matrix4x4 MakeProjection(float l, float t, float r, float b, float n, float f)
		{
			Matrix4x4 zero = Matrix4x4.zero;
			zero[0, 0] = 2f * n / (r - l);
			zero[1, 1] = 2f * n / (t - b);
			zero[0, 2] = (r + l) / (r - l);
			zero[1, 2] = (t + b) / (t - b);
			zero[2, 2] = (n + f) / (n - f);
			zero[2, 3] = 2f * n * f / (n - f);
			zero[3, 2] = -1f;
			return zero;
		}

		public bool UpdateStatesensor()
		{
			UpdateSimulatedSensor();
			return true;
		}

		public void ComputeEyesFromProfile()
		{
			Vector2 vector = new Vector2(0.11f, 0.062f);
			Pvr_UnitySDKManager.SDK.leftEyeView = Matrix4x4.identity;
			Pvr_UnitySDKManager.SDK.leftEyeView[0, 3] = (0f - Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.device.devLenses.separation) / 2f;
			float[] leftEyeVisibleTanAngles = Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.GetLeftEyeVisibleTanAngles(vector.x, vector.y);
			leftEyeProj = MakeProjection(leftEyeVisibleTanAngles[0], leftEyeVisibleTanAngles[1], leftEyeVisibleTanAngles[2], leftEyeVisibleTanAngles[3], 1f, 1000f);
			leftEyeVisibleTanAngles = Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.GetLeftEyeNoLensTanAngles(vector.x, vector.y);
			leftEyeUndistortedProj = MakeProjection(leftEyeVisibleTanAngles[0], leftEyeVisibleTanAngles[1], leftEyeVisibleTanAngles[2], leftEyeVisibleTanAngles[3], 1f, 1000f);
			Pvr_UnitySDKManager.SDK.leftEyeRect = Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.GetLeftEyeVisibleScreenRect(leftEyeVisibleTanAngles, vector.x, vector.y);
			Pvr_UnitySDKManager.SDK.rightEyeView = Pvr_UnitySDKManager.SDK.leftEyeView;
			Pvr_UnitySDKManager.SDK.rightEyeView[0, 3] *= -1f;
			rightEyeProj = leftEyeProj;
			rightEyeProj[0, 2] *= -1f;
			rightEyeUndistortedProj = leftEyeUndistortedProj;
			rightEyeUndistortedProj[0, 2] *= -1f;
			Rect leftEyeRect = new Rect(0f, 0f, 0.5f, 1f);
			Rect rightEyeRect = new Rect(0.5f, 0f, 0.5f, 1f);
			Pvr_UnitySDKManager.SDK.leftEyeRect = leftEyeRect;
			Pvr_UnitySDKManager.SDK.rightEyeRect = rightEyeRect;
			Pvr_UnitySDKManager.SDK.leftEyeOffset = new Vector3((0f - Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.device.devLenses.separation) / 2f, 0f, 0f);
			Pvr_UnitySDKManager.SDK.rightEyeOffset = new Vector3(Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.device.devLenses.separation / 2f, 0f, 0f);
		}

		public bool ResetUnitySDKSensor()
		{
			mouseX = (mouseY = (mouseZ = 0f));
			return true;
		}

		private void SimulateInput()
		{
			if (Input.GetMouseButtonDown(0) && (Input.GetKey(KeyCode.LeftAlt) || Input.GetKey(KeyCode.RightAlt)))
			{
				EnableVEmodel();
			}
			if (Input.GetMouseButtonDown(0))
			{
				touchStartTime = Time.time;
			}
			else if (Input.GetMouseButtonUp(0))
			{
				if (Time.time - touchStartTime <= 0.2f)
				{
					Pvr_UnitySDKManager.SDK.newPicovrTriggered = true;
				}
				touchStartTime = 0f;
			}
			UpdateSimulatedSensor();
		}

		private void FovAdjust()
		{
			Pvr_UnitySDKRender.Instance.EyeVFoV = 2f * Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.device.devMaxFov.upper;
		}

		private Rect RectAdjust(Rect eyeRect)
		{
			Rect result = new Rect(0f, 0f, 0.5f, 1f);
			result.width *= 2f * eyeRect.width;
			result.x = eyeRect.x + 2f * result.x * eyeRect.width;
			result.height *= eyeRect.height;
			result.y = eyeRect.y + result.y * eyeRect.height;
			return result;
		}

		private void UpdateSimulatedSensor()
		{
			bool flag = false;
			if (Input.GetKey(KeyCode.LeftAlt) || Input.GetKey(KeyCode.RightAlt))
			{
				mouseX += Input.GetAxis("Mouse X") * 5f;
				if (mouseX <= -180f)
				{
					mouseX += 360f;
				}
				else if (mouseX > 180f)
				{
					mouseX -= 360f;
				}
				mouseY -= Input.GetAxis("Mouse Y") * 2.4f;
				mouseY = Mathf.Clamp(mouseY, -91f, 91f);
			}
			else if (Input.GetKey(KeyCode.LeftControl) || Input.GetKey(KeyCode.RightControl))
			{
				flag = true;
				mouseZ += Input.GetAxis("Mouse X") * 5f;
				mouseZ = Mathf.Clamp(mouseZ, -91f, 91f);
			}
			if (!flag && autoUntiltHead)
			{
				mouseZ = Mathf.Lerp(mouseZ, 0f, Time.deltaTime / (Time.deltaTime + 0.1f));
			}
			Quaternion quaternion = Quaternion.Euler(mouseY, mouseX, mouseZ);
			Matrix4x4 matrix = Matrix4x4.TRS((quaternion * neckOffset - neckOffset.y * Vector3.up) * neckModelScale, quaternion, Vector3.one);
			Pvr_UnitySDKSensor.Instance.HeadPose = new Pvr_UnitySDKPose(matrix);
		}

		private void InitForEye(ref Material mat, ref Material mat1)
		{
			Shader shader = Shader.Find("Pvr_UnitySDK/Undistortion");
			Shader shader2 = Shader.Find("Pvr_UnitySDK/FillColor");
			if (shader == null || shader2 == null)
			{
				PLOG.E("Ths Shader Missing ！");
				return;
			}
			mat = new Material(shader);
			mat1 = new Material(shader2);
		}

		private void EnableVEmodel()
		{
			vrModeEnabled = !vrModeEnabled;
			Pvr_UnitySDKManager.SDK.VRModeEnabled = vrModeEnabled;
		}
	}
	public class Pvr_VolumePowerBrightness : MonoBehaviour
	{
		private bool VolEnable;

		private bool BattEnable;

		public Text showResult;

		public Text setVolumnum;

		public Text setBrightnum;

		public string MusicPath;

		private void Awake()
		{
			InitBatteryVolClass();
			string startreceivre = base.gameObject.name;
			StartBatteryReceiver(startreceivre);
			StartAudioReceiver(startreceivre);
		}

		private void OnDisable()
		{
			if (VolEnable)
			{
				StopAudioReceiver();
			}
			if (BattEnable)
			{
				StopBatteryReceiver();
			}
		}

		public void GetMaxVolumeNumber()
		{
			int num = 0;
			num = VolumePowerBrightness.UPvr_GetMaxVolumeNumber();
			showResult.text = "Maximum volume: " + num;
		}

		public void GetCurrentVolumeNumber()
		{
			int num = 0;
			num = VolumePowerBrightness.UPvr_GetCurrentVolumeNumber();
			showResult.text = "Current volume：" + num;
		}

		public void VolumeUp()
		{
			if (!VolumePowerBrightness.UPvr_VolumeUp())
			{
				PLOG.E("VolumeUp Error");
			}
		}

		public void VolumeDown()
		{
			if (!VolumePowerBrightness.UPvr_VolumeDown())
			{
				PLOG.E("VolumeDown Error");
			}
		}

		public void SetVolumeNum()
		{
			int volume = new System.Random().Next(0, 15);
			setVolumnum.text = "Random number：" + volume;
			if (!VolumePowerBrightness.UPvr_SetVolumeNum(volume))
			{
				PLOG.E("SetVolumeNum Error");
			}
		}

		public void SetBrightness()
		{
			int brightness = new System.Random().Next(0, 255);
			setBrightnum.text = "Random number：" + brightness;
			if (!VolumePowerBrightness.UPvr_SetCommonBrightness(brightness))
			{
				PLOG.E("SetBrightness Error");
			}
		}

		public void GetCurrentBrightness()
		{
			int num = 0;
			num = VolumePowerBrightness.UPvr_GetCommonBrightness();
			showResult.text = "Current brightness：" + num;
		}

		public bool setAudio(string s)
		{
			PLOG.I(s.ToString());
			return true;
		}

		public bool setBattery(string s)
		{
			PLOG.I(s.ToString());
			return true;
		}

		private bool InitBatteryVolClass()
		{
			return VolumePowerBrightness.UPvr_InitBatteryVolClass();
		}

		private bool StartBatteryReceiver(string startreceivre)
		{
			BattEnable = VolumePowerBrightness.UPvr_StartBatteryReceiver(startreceivre);
			return BattEnable;
		}

		private bool StopBatteryReceiver()
		{
			return VolumePowerBrightness.UPvr_StopBatteryReceiver();
		}

		private bool StartAudioReceiver(string startreceivre)
		{
			VolEnable = VolumePowerBrightness.UPvr_StartAudioReceiver(startreceivre);
			return VolEnable;
		}

		private bool StopAudioReceiver()
		{
			return VolumePowerBrightness.UPvr_StopAudioReceiver();
		}
	}
	public class Swapper : MonoBehaviour
	{
		public GameObject[] character;

		public int index;

		public Texture btn_tex;

		private void Awake()
		{
			GameObject[] array = character;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SetActive(value: false);
			}
			character[0].SetActive(value: true);
		}

		private void OnGUI()
		{
			if (GUI.Button(new Rect(Screen.width - 100, 0f, 100f, 100f), btn_tex))
			{
				character[index].SetActive(value: false);
				index++;
				index %= character.Length;
				character[index].SetActive(value: true);
			}
		}
	}
	[DisallowMultipleComponent]
	public class SteamManager : MonoBehaviour
	{
		private static SteamManager s_instance;

		private static bool s_EverInialized;

		private bool m_bInitialized;

		private static SteamManager Instance
		{
			get
			{
				if (s_instance == null)
				{
					return new GameObject("SteamManager").AddComponent<SteamManager>();
				}
				return s_instance;
			}
		}

		public static bool Initialized => Instance.m_bInitialized;
	}
	public class BalloonFXSceneSelect : MonoBehaviour
	{
		public void LoadBallonDemo01()
		{
			SceneManager.LoadScene("BalloonFX01");
		}

		public void LoadBallonDemo02()
		{
			SceneManager.LoadScene("BalloonFX02");
		}

		public void LoadBallonDemo03()
		{
			SceneManager.LoadScene("BalloonFX03");
		}

		public void LoadBallonDemo04()
		{
			SceneManager.LoadScene("BalloonFX04");
		}
	}
	public class DemoToonVFX : MonoBehaviour
	{
		public struct SVA
		{
			public float S;

			public float V;

			public float A;
		}

		public Transform Holder;

		public float currDistance = 5f;

		public float xRotate = 250f;

		public float yRotate = 120f;

		public float yMinLimit = -20f;

		public float yMaxLimit = 80f;

		public float prevDistance;

		private float x;

		private float y;

		[Header("GUI")]
		private float windowDpi;

		public GameObject[] Prefabs;

		private int Prefab;

		private GameObject Instance;

		private float StartColor;

		private float HueColor;

		public Texture HueTexture;

		public float[] activationTime;

		public Animator animObject;

		private ParticleSystem[] particleSystems = new ParticleSystem[0];

		private List<SVA> svList = new List<SVA>();

		private float H;

		public bool useAnimation;

		private void Start()
		{
			if (Screen.dpi < 1f)
			{
				windowDpi = 1f;
			}
			if (Screen.dpi < 200f)
			{
				windowDpi = 1f;
			}
			else
			{
				windowDpi = Screen.dpi / 200f;
			}
			Vector3 eulerAngles = base.transform.eulerAngles;
			x = eulerAngles.y;
			y = eulerAngles.x;
			Counter(0);
			animObject.GetComponent<Animator>();
		}

		private void OnGUI()
		{
			if (GUI.Button(new Rect(5f * windowDpi, 5f * windowDpi, 110f * windowDpi, 35f * windowDpi), "Previous effect"))
			{
				Counter(-1);
			}
			if (GUI.Button(new Rect(120f * windowDpi, 5f * windowDpi, 110f * windowDpi, 35f * windowDpi), "Play again"))
			{
				Counter(0);
			}
			if (GUI.Button(new Rect(235f * windowDpi, 5f * windowDpi, 110f * windowDpi, 35f * windowDpi), "Next effect"))
			{
				Counter(1);
			}
			StartColor = HueColor;
			HueColor = GUI.HorizontalSlider(new Rect(5f * windowDpi, 45f * windowDpi, 340f * windowDpi, 35f * windowDpi), HueColor, 0f, 1f);
			GUI.DrawTexture(new Rect(5f * windowDpi, 65f * windowDpi, 340f * windowDpi, 15f * windowDpi), HueTexture, ScaleMode.StretchToFill, alphaBlend: false, 0f);
			if (HueColor != StartColor)
			{
				int num = 0;
				ParticleSystem[] array = particleSystems;
				for (int i = 0; i < array.Length; i++)
				{
					ParticleSystem.MainModule main = array[i].main;
					Color color = Color.HSVToRGB(HueColor + H * 0f, svList[num].S, svList[num].V);
					main.startColor = new Color(color.r, color.g, color.b, svList[num].A);
					num++;
				}
			}
		}

		private void Counter(int count)
		{
			Prefab += count;
			if (Prefab > Prefabs.Length - 1)
			{
				Prefab = 0;
			}
			else if (Prefab < 0)
			{
				Prefab = Prefabs.Length - 1;
			}
			if (Instance != null)
			{
				UnityEngine.Object.Destroy(Instance);
			}
			Instance = UnityEngine.Object.Instantiate(Prefabs[Prefab]);
			Instance.SetActive(value: false);
			if (activationTime.Length == Prefabs.Length)
			{
				CancelInvoke();
				if (activationTime[Prefab] > 0.01f)
				{
					Invoke("Activate", activationTime[Prefab]);
				}
				if (activationTime[Prefab] == 0f)
				{
					Instance.SetActive(value: true);
				}
			}
			particleSystems = Instance.GetComponentsInChildren<ParticleSystem>();
			svList.Clear();
			ParticleSystem[] array = particleSystems;
			for (int i = 0; i < array.Length; i++)
			{
				Color color = array[i].main.startColor.color;
				SVA item = default(SVA);
				Color.RGBToHSV(color, out H, out item.S, out item.V);
				item.A = color.a;
				svList.Add(item);
			}
			if (useAnimation)
			{
				animObject.SetInteger("toDo", Prefab);
			}
		}

		private void Activate()
		{
			Instance.SetActive(value: true);
		}

		private void LateUpdate()
		{
			if (currDistance < 2f)
			{
				currDistance = 2f;
			}
			currDistance -= Input.GetAxis("Mouse ScrollWheel") * 2f;
			if ((bool)Holder && (Input.GetMouseButton(0) || Input.GetMouseButton(1)))
			{
				Vector3 mousePosition = Input.mousePosition;
				float num = 1f;
				if (Screen.dpi < 1f)
				{
					num = 1f;
				}
				num = ((!(Screen.dpi < 200f)) ? (Screen.dpi / 200f) : 1f);
				if (mousePosition.x < 380f * num && (float)Screen.height - mousePosition.y < 250f * num)
				{
					return;
				}
				Cursor.visible = false;
				Cursor.lockState = CursorLockMode.Locked;
				x += (float)((double)(Input.GetAxis("Mouse X") * xRotate) * 0.02);
				y -= (float)((double)(Input.GetAxis("Mouse Y") * yRotate) * 0.02);
				y = ClampAngle(y, yMinLimit, yMaxLimit);
				Quaternion quaternion = Quaternion.Euler(y, x, 0f);
				Vector3 position = quaternion * new Vector3(0f, 0f, 0f - currDistance) + Holder.position;
				base.transform.rotation = quaternion;
				base.transform.position = position;
			}
			else
			{
				Cursor.visible = true;
				Cursor.lockState = CursorLockMode.None;
			}
			if (prevDistance != currDistance)
			{
				prevDistance = currDistance;
				Quaternion quaternion2 = Quaternion.Euler(y, x, 0f);
				Vector3 position2 = quaternion2 * new Vector3(0f, 0f, 0f - currDistance) + Holder.position;
				base.transform.rotation = quaternion2;
				base.transform.position = position2;
			}
		}

		private static float ClampAngle(float angle, float min, float max)
		{
			if (angle < -360f)
			{
				angle += 360f;
			}
			if (angle > 360f)
			{
				angle -= 360f;
			}
			return Mathf.Clamp(angle, min, max);
		}
	}
	public class Slashes_MobileBloom : MonoBehaviour
	{
		[Range(0.2f, 1f)]
		[Tooltip("Camera render texture resolution")]
		public float RenderTextureResolutoinFactor = 0.5f;

		[Range(0.05f, 2f)]
		[Tooltip("Blend factor of the result image.")]
		public float Intensity = 0.5f;

		private static float Threshold = 1.3f;

		private const string shaderName = "Hidden/KriptoFX/PostEffects/Slashes_Bloom";

		private const int kMaxIterations = 16;

		private readonly RenderTexture[] m_blurBuffer1 = new RenderTexture[16];

		private readonly RenderTexture[] m_blurBuffer2 = new RenderTexture[16];

		private RenderTexture Source;

		private Material _bloomMaterial;

		private Material bloomMaterial
		{
			get
			{
				if (_bloomMaterial == null)
				{
					Shader shader = Shader.Find("Hidden/KriptoFX/PostEffects/Slashes_Bloom");
					if (shader == null)
					{
						UnityEngine.Debug.LogError("Can't find shader Hidden/KriptoFX/PostEffects/Slashes_Bloom");
					}
					_bloomMaterial = new Material(shader);
				}
				return _bloomMaterial;
			}
		}

		private void Start()
		{
		}

		private void OnPreRender()
		{
			Source = RenderTexture.GetTemporary(Screen.width, Screen.height, 24, SupportedHdrFormat());
			Camera.main.targetTexture = Source;
		}

		private void OnPostRender()
		{
			Camera.main.targetTexture = null;
			UpdateBloom(Source, null);
			RenderTexture.ReleaseTemporary(Source);
		}

		private RenderTextureFormat SupportedHdrFormat()
		{
			if (SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.RGB111110Float))
			{
				return RenderTextureFormat.RGB111110Float;
			}
			return RenderTextureFormat.DefaultHDR;
		}

		private void UpdateBloom(RenderTexture source, RenderTexture dest)
		{
			int num = Screen.width / 2;
			int num2 = Screen.height / 2;
			RenderTextureFormat format = RenderTextureFormat.Default;
			int width = (int)((float)num * RenderTextureResolutoinFactor);
			num2 = (int)((float)num2 * RenderTextureResolutoinFactor);
			float num3 = Mathf.Log(num2, 2f) - 1f;
			int num4 = (int)num3;
			int num5 = Mathf.Clamp(num4, 1, 16);
			float value = Mathf.GammaToLinearSpace(Threshold);
			bloomMaterial.SetFloat("_Threshold", value);
			float num6 = 0.5f + num3 - (float)num4;
			bloomMaterial.SetFloat("_SampleScale", num6 * 0.5f);
			bloomMaterial.SetFloat("_Intensity", Mathf.Max(0f, Intensity));
			RenderTexture temporary = RenderTexture.GetTemporary(width, num2, 0, format);
			Graphics.Blit(source, temporary, bloomMaterial, 0);
			RenderTexture renderTexture = temporary;
			for (int i = 0; i < num5; i++)
			{
				m_blurBuffer1[i] = RenderTexture.GetTemporary(renderTexture.width / 2, renderTexture.height / 2, 0, format);
				Graphics.Blit(renderTexture, m_blurBuffer1[i], bloomMaterial, 1);
				renderTexture = m_blurBuffer1[i];
			}
			for (int num7 = num5 - 2; num7 >= 0; num7--)
			{
				RenderTexture renderTexture2 = m_blurBuffer1[num7];
				bloomMaterial.SetTexture("_BaseTex", renderTexture2);
				m_blurBuffer2[num7] = RenderTexture.GetTemporary(renderTexture2.width, renderTexture2.height, 0, format);
				Graphics.Blit(renderTexture, m_blurBuffer2[num7], bloomMaterial, 2);
				renderTexture = m_blurBuffer2[num7];
			}
			RenderTexture temporary2 = RenderTexture.GetTemporary(renderTexture.width, renderTexture.height, 0, renderTexture.format);
			Graphics.Blit(renderTexture, temporary2, bloomMaterial, 3);
			bloomMaterial.SetTexture("_BaseTex", source);
			Graphics.Blit(temporary2, dest, bloomMaterial, 4);
			for (int j = 0; j < 16; j++)
			{
				if (m_blurBuffer1[j] != null)
				{
					RenderTexture.ReleaseTemporary(m_blurBuffer1[j]);
				}
				if (m_blurBuffer2[j] != null)
				{
					RenderTexture.ReleaseTemporary(m_blurBuffer2[j]);
				}
				m_blurBuffer1[j] = null;
				m_blurBuffer2[j] = null;
			}
			RenderTexture.ReleaseTemporary(temporary2);
			RenderTexture.ReleaseTemporary(temporary);
		}
	}
	public class Slash_DemoGUI : MonoBehaviour
	{
		public GameObject[] Prefabs;

		public float[] ReactivationTimes;

		public Light Sun;

		public ReflectionProbe ReflectionProbe;

		public Light[] NightLights = new Light[0];

		public Texture HUETexture;

		public bool isDay;

		private int currentNomber;

		private GameObject currentInstance;

		private GUIStyle guiStyleHeader = new GUIStyle();

		private GUIStyle guiStyleHeaderMobile = new GUIStyle();

		private float dpiScale;

		private float colorHUE;

		private float startSunIntensity;

		private Quaternion startSunRotation;

		private Color startAmbientLight;

		private float startAmbientIntencity;

		private float startReflectionIntencity;

		private LightShadows startLightShadows;

		private bool isButtonPressed;

		private void Start()
		{
			if (Screen.dpi < 1f)
			{
				dpiScale = 1f;
			}
			if (Screen.dpi < 200f)
			{
				dpiScale = 1f;
			}
			else
			{
				dpiScale = Screen.dpi / 200f;
			}
			guiStyleHeader.fontSize = (int)(15f * dpiScale);
			guiStyleHeaderMobile.fontSize = (int)(17f * dpiScale);
			ChangeCurrent(0);
			startSunIntensity = Sun.intensity;
			startSunRotation = Sun.transform.rotation;
			startAmbientLight = RenderSettings.ambientLight;
			startAmbientIntencity = RenderSettings.ambientIntensity;
			startReflectionIntencity = RenderSettings.reflectionIntensity;
			startLightShadows = Sun.shadows;
			ChangeDayNight();
		}

		private void OnGUI()
		{
			if (Input.GetKeyUp(KeyCode.LeftArrow) || Input.GetKeyUp(KeyCode.RightArrow) || Input.GetKeyUp(KeyCode.DownArrow))
			{
				isButtonPressed = false;
			}
			if (GUI.Button(new Rect(10f * dpiScale, 15f * dpiScale, 135f * dpiScale, 37f * dpiScale), "PREVIOUS EFFECT") || (!isButtonPressed && Input.GetKeyDown(KeyCode.LeftArrow)))
			{
				isButtonPressed = true;
				ChangeCurrent(-1);
			}
			if (GUI.Button(new Rect(160f * dpiScale, 15f * dpiScale, 135f * dpiScale, 37f * dpiScale), "NEXT EFFECT") || (!isButtonPressed && Input.GetKeyDown(KeyCode.RightArrow)))
			{
				isButtonPressed = true;
				ChangeCurrent(1);
			}
			float num = 0f;
			if (GUI.Button(new Rect(10f * dpiScale, 63f * dpiScale + num, 285f * dpiScale, 37f * dpiScale), "Day / Night") || (!isButtonPressed && Input.GetKeyDown(KeyCode.DownArrow)))
			{
				ChangeDayNight();
			}
			GUI.Label(new Rect(350f * dpiScale, 15f * dpiScale + num / 2f, 500f * dpiScale, 20f * dpiScale), "press left mouse button for the camera rotating and scroll wheel for zooming", guiStyleHeader);
			GUI.Label(new Rect(350f * dpiScale, 35f * dpiScale + num / 2f, 160f * dpiScale, 20f * dpiScale), "prefab name is: " + Prefabs[currentNomber].name, guiStyleHeader);
		}

		private void ChangeDayNight()
		{
			isButtonPressed = true;
			if (ReflectionProbe != null)
			{
				ReflectionProbe.RenderProbe();
			}
			Sun.intensity = ((!isDay) ? 0.05f : startSunIntensity);
			Sun.shadows = (isDay ? startLightShadows : LightShadows.None);
			Light[] nightLights = NightLights;
			foreach (Light light in nightLights)
			{
				if (light != null)
				{
					light.shadows = ((!isDay) ? startLightShadows : LightShadows.None);
				}
			}
			Sun.transform.rotation = (isDay ? startSunRotation : Quaternion.Euler(350f, 30f, 90f));
			RenderSettings.ambientLight = ((!isDay) ? new Color(0.1f, 0.1f, 0.1f) : startAmbientLight);
			RenderSettings.ambientIntensity = (isDay ? startAmbientIntencity : 1f);
			RenderSettings.reflectionIntensity = (isDay ? startReflectionIntencity : 0.2f);
			isDay = !isDay;
		}

		private void ChangeCurrent(int delta)
		{
			currentNomber += delta;
			if (currentNomber > Prefabs.Length - 1)
			{
				currentNomber = 0;
			}
			else if (currentNomber < 0)
			{
				currentNomber = Prefabs.Length - 1;
			}
			if (currentInstance != null)
			{
				UnityEngine.Object.Destroy(currentInstance);
				RemoveClones();
			}
			currentInstance = UnityEngine.Object.Instantiate(Prefabs[currentNomber]);
			if (ReactivationTimes.Length == Prefabs.Length)
			{
				CancelInvoke();
				if (ReactivationTimes[currentNomber] > 0.1f)
				{
					InvokeRepeating("Reactivate", ReactivationTimes[currentNomber], ReactivationTimes[currentNomber]);
				}
			}
		}

		private void RemoveClones()
		{
			GameObject[] array = UnityEngine.Object.FindObjectsOfType<GameObject>();
			foreach (GameObject gameObject in array)
			{
				if (gameObject.name.Contains("(Clone)"))
				{
					UnityEngine.Object.Destroy(gameObject);
				}
			}
		}

		private void Reactivate()
		{
			currentInstance.SetActive(value: false);
			currentInstance.SetActive(value: true);
		}
	}
	public class Slash_MouseOrbit : MonoBehaviour
	{
		public GameObject target;

		public float distance = 10f;

		public float xSpeed = 250f;

		public float ySpeed = 120f;

		public float yMinLimit = -20f;

		public float yMaxLimit = 80f;

		private float x;

		private float y;

		private float prevDistance;

		private void Start()
		{
			Vector3 eulerAngles = base.transform.eulerAngles;
			x = eulerAngles.y;
			y = eulerAngles.x;
		}

		private void LateUpdate()
		{
			if (distance < 2f)
			{
				distance = 2f;
			}
			distance -= Input.GetAxis("Mouse ScrollWheel") * 2f;
			if ((bool)target && (Input.GetMouseButton(0) || Input.GetMouseButton(1)))
			{
				Vector3 mousePosition = Input.mousePosition;
				float num = 1f;
				if (Screen.dpi < 1f)
				{
					num = 1f;
				}
				num = ((!(Screen.dpi < 200f)) ? (Screen.dpi / 200f) : 1f);
				if (mousePosition.x < 380f * num && (float)Screen.height - mousePosition.y < 250f * num)
				{
					return;
				}
				Cursor.visible = false;
				Cursor.lockState = CursorLockMode.Locked;
				x += Input.GetAxis("Mouse X") * xSpeed * 0.02f;
				y -= Input.GetAxis("Mouse Y") * ySpeed * 0.02f;
				y = ClampAngle(y, yMinLimit, yMaxLimit);
				Quaternion quaternion = Quaternion.Euler(y, x, 0f);
				Vector3 position = quaternion * new Vector3(0f, 0f, 0f - distance) + target.transform.position;
				base.transform.rotation = quaternion;
				base.transform.position = position;
			}
			else
			{
				Cursor.visible = true;
				Cursor.lockState = CursorLockMode.None;
			}
			if (Math.Abs(prevDistance - distance) > 0.001f)
			{
				prevDistance = distance;
				Quaternion quaternion2 = Quaternion.Euler(y, x, 0f);
				Vector3 position2 = quaternion2 * new Vector3(0f, 0f, 0f - distance) + target.transform.position;
				base.transform.rotation = quaternion2;
				base.transform.position = position2;
			}
		}

		private static float ClampAngle(float angle, float min, float max)
		{
			if (angle < -360f)
			{
				angle += 360f;
			}
			if (angle > 360f)
			{
				angle -= 360f;
			}
			return Mathf.Clamp(angle, min, max);
		}
	}
	public class AnimationEventEffects : MonoBehaviour
	{
		[Serializable]
		public class EffectInfo
		{
			public GameObject Effect;

			public Transform StartPositionRotation;

			public float DestroyAfter = 10f;

			public bool UseLocalPosition = true;
		}

		public EffectInfo[] Effects;

		private void Start()
		{
		}

		private void InstantiateEffect(int EffectNumber)
		{
			if (Effects == null || Effects.Length <= EffectNumber)
			{
				UnityEngine.Debug.LogError("Incorrect effect number or effect is null");
			}
			GameObject gameObject = UnityEngine.Object.Instantiate(Effects[EffectNumber].Effect, Effects[EffectNumber].StartPositionRotation.position, Effects[EffectNumber].StartPositionRotation.rotation);
			if (Effects[EffectNumber].UseLocalPosition)
			{
				gameObject.transform.parent = Effects[EffectNumber].StartPositionRotation.transform;
				gameObject.transform.localPosition = Vector3.zero;
				gameObject.transform.localRotation = default(Quaternion);
			}
			UnityEngine.Object.Destroy(gameObject, Effects[EffectNumber].DestroyAfter);
		}
	}
	[ExecuteInEditMode]
	public class Slash_AxisRotateByTime : MonoBehaviour
	{
		public Vector3 RotateAxis = new Vector3(0f, 0f, 0f);

		private void Start()
		{
		}

		private void Update()
		{
			base.transform.Rotate(RotateAxis * Time.deltaTime);
		}
	}
	[ExecuteInEditMode]
	public class Slash_GrvityPoint : MonoBehaviour
	{
		public Transform Target;

		public float Force = 1f;

		public float StopDistance;

		private ParticleSystem ps;

		private ParticleSystem.Particle[] particles;

		private ParticleSystem.MainModule mainModule;

		private void Start()
		{
			ps = GetComponent<ParticleSystem>();
			mainModule = ps.main;
		}

		private void LateUpdate()
		{
			if (Target == null)
			{
				return;
			}
			int maxParticles = mainModule.maxParticles;
			if (particles == null || particles.Length < maxParticles)
			{
				particles = new ParticleSystem.Particle[maxParticles];
			}
			int num = ps.GetParticles(particles);
			Vector3 vector = Vector3.zero;
			if (mainModule.simulationSpace == ParticleSystemSimulationSpace.Local)
			{
				vector = base.transform.InverseTransformPoint(Target.position);
			}
			if (mainModule.simulationSpace == ParticleSystemSimulationSpace.World)
			{
				vector = Target.position;
			}
			float num2 = Time.deltaTime * Force;
			for (int i = 0; i < num; i++)
			{
				Vector3 value = vector - particles[i].position;
				if (StopDistance > 0.001f && value.magnitude < StopDistance)
				{
					particles[i].velocity = Vector3.zero;
					continue;
				}
				Vector3 vector2 = Vector3.Normalize(value) * num2;
				particles[i].velocity += vector2;
			}
			ps.SetParticles(particles, num);
		}
	}
	public class Slash_Light : MonoBehaviour
	{
		public AnimationCurve LightCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

		public Gradient LightColor = new Gradient();

		public float GraphTimeMultiplier = 1f;

		public float GraphIntensityMultiplier = 1f;

		public bool IsLoop;

		[HideInInspector]
		public bool canUpdate;

		private float startTime;

		private Color startColor;

		private Light lightSource;

		public void SetStartColor(Color color)
		{
			startColor = color;
		}

		private void Awake()
		{
			lightSource = GetComponent<Light>();
			startColor = lightSource.color;
			lightSource.intensity = LightCurve.Evaluate(0f) * GraphIntensityMultiplier;
			lightSource.color = startColor * LightColor.Evaluate(0f);
			startTime = Time.time;
			canUpdate = true;
		}

		private void OnEnable()
		{
			startTime = Time.time;
			canUpdate = true;
			if (lightSource != null)
			{
				lightSource.intensity = LightCurve.Evaluate(0f) * GraphIntensityMultiplier;
				lightSource.color = startColor * LightColor.Evaluate(0f);
			}
		}

		private void Update()
		{
			float num = Time.time - startTime;
			if (canUpdate)
			{
				float intensity = LightCurve.Evaluate(num / GraphTimeMultiplier) * GraphIntensityMultiplier;
				lightSource.intensity = intensity;
				lightSource.color = startColor * LightColor.Evaluate(num / GraphTimeMultiplier);
			}
			if (num >= GraphTimeMultiplier)
			{
				if (IsLoop)
				{
					startTime = Time.time;
				}
				else
				{
					canUpdate = false;
				}
			}
		}
	}
	public class Slash_UIEffectList : MonoBehaviour
	{
		public GameObject[] Prefabs;

		private int currentNomber;

		private GameObject currentInstance;

		private void Start()
		{
		}

		private void Update()
		{
		}

		public void ChangeCurrent(int delta)
		{
			currentNomber += delta;
			if (currentNomber > Prefabs.Length - 1)
			{
				currentNomber = 0;
			}
			else if (currentNomber < 0)
			{
				currentNomber = Prefabs.Length - 1;
			}
			if (currentInstance != null)
			{
				UnityEngine.Object.Destroy(currentInstance);
				RemoveClones();
			}
			currentInstance = UnityEngine.Object.Instantiate(Prefabs[currentNomber]);
		}

		private void RemoveClones()
		{
			GameObject[] array = UnityEngine.Object.FindObjectsOfType<GameObject>();
			foreach (GameObject gameObject in array)
			{
				if (gameObject.name.Contains("(Clone)"))
				{
					UnityEngine.Object.Destroy(gameObject);
				}
			}
		}
	}
	public class Slash_WroomWroom : MonoBehaviour
	{
		public float Speed = 1f;

		public GameObject Target;

		private void OnEnable()
		{
			base.transform.localPosition = new Vector3(0f, 0f, 0f);
		}

		private void Update()
		{
			base.transform.position = Vector3.MoveTowards(base.transform.position, Target.transform.position, Speed * Time.deltaTime);
		}
	}
	public class Teleport : MonoBehaviour
	{
		public Vector3 Range;

		private Vector3 startPos;

		private void Awake()
		{
			startPos = base.transform.position;
		}

		private void OnEnable()
		{
			base.transform.position = startPos;
		}

		public void CustomTeleport()
		{
			Renderer[] componentsInChildren = GetComponentsInChildren<Renderer>();
			Renderer[] array = componentsInChildren;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enabled = false;
			}
			base.transform.position += Range;
			array = componentsInChildren;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enabled = true;
			}
		}
	}
	public class NextPrefab : MonoBehaviour
	{
		public GameObject[] m_PrefabList;

		private int m_CurrentElementIndex = -1;

		private int m_CurrentParticleIndex = -1;

		private GameObject[] m_CurrentElementList;

		private GameObject m_CurrentParticle;

		public Text m_ParticleName;

		private void Start()
		{
			if (m_PrefabList.Length != 0)
			{
				m_CurrentElementIndex = 0;
				m_CurrentParticleIndex = 0;
				ShowParticle();
			}
		}

		private void Update()
		{
			if (m_CurrentElementIndex != -1 && m_CurrentParticleIndex != -1)
			{
				if (Input.GetKeyUp(KeyCode.Z))
				{
					m_CurrentParticleIndex--;
					ShowParticle();
				}
				else if (Input.GetKeyUp(KeyCode.X))
				{
					m_CurrentParticleIndex++;
					ShowParticle();
				}
			}
		}

		private void ShowParticle()
		{
			if (m_CurrentElementIndex == 0)
			{
				m_CurrentElementList = m_PrefabList;
			}
			if (m_CurrentParticleIndex >= m_CurrentElementList.Length)
			{
				m_CurrentParticleIndex = 0;
			}
			else if (m_CurrentParticleIndex < 0)
			{
				m_CurrentParticleIndex = m_CurrentElementList.Length - 1;
			}
			m_ParticleName.text = m_CurrentElementList[m_CurrentParticleIndex].name;
			if (m_CurrentParticle != null)
			{
				UnityEngine.Object.Destroy(m_CurrentParticle);
			}
			m_CurrentParticle = UnityEngine.Object.Instantiate(m_CurrentElementList[m_CurrentParticleIndex]);
		}
	}
	public class Rotation : MonoBehaviour
	{
		[Range(-1f, 1f)]
		public float xForceDirection;

		[Range(-1f, 1f)]
		public float yForceDirection;

		[Range(-1f, 1f)]
		public float zForceDirection;

		public float speedMultiplier = 1f;

		public bool worldPivote;

		private Space spacePivot = Space.Self;

		private void Start()
		{
			if (worldPivote)
			{
				spacePivot = Space.World;
			}
		}

		private void Update()
		{
			base.transform.Rotate(xForceDirection * speedMultiplier, yForceDirection * speedMultiplier, zForceDirection * speedMultiplier, spacePivot);
		}
	}
	public class UserCamera : MonoBehaviour
	{
		public Transform target;

		public float targetHeight = 1.7f;

		public float distance = 12f;

		public float offsetFromWall = 0.1f;

		public float maxDistance = 20f;

		public float minDistance = 0.6f;

		public float xSpeed = 200f;

		public float ySpeed = 200f;

		public float yMinLimit = -80f;

		public float yMaxLimit = 80f;

		public float zoomRate = 40f;

		public float rotationDampening = 3f;

		public float zoomDampening = 5f;

		private LayerMask collisionLayers = -1;

		public bool lockToRearOfTarget;

		public bool allowMouseInputX = true;

		public bool allowMouseInputY = true;

		private float xDeg;

		private float yDeg;

		private float currentDistance;

		public float desiredDistance;

		private float correctedDistance;

		public GameObject userModel;

		public bool inFirstPerson;

		private void Start()
		{
			Vector3 eulerAngles = base.transform.eulerAngles;
			xDeg = eulerAngles.x;
			yDeg = eulerAngles.y;
			currentDistance = distance;
			desiredDistance = distance;
			correctedDistance = distance;
			if ((bool)GetComponent<Rigidbody>())
			{
				GetComponent<Rigidbody>().freezeRotation = true;
			}
		}

		private void Update()
		{
			if (Input.GetAxis("Mouse ScrollWheel") < 0f && inFirstPerson)
			{
				minDistance = 10f;
				desiredDistance = 15f;
				userModel.SetActive(value: true);
				inFirstPerson = false;
			}
			if (desiredDistance == 10f)
			{
				minDistance = 0f;
				desiredDistance = 0f;
				userModel.SetActive(value: false);
				inFirstPerson = true;
			}
		}

		private void LateUpdate()
		{
			if (!target)
			{
				return;
			}
			if (GUIUtility.hotControl == 0 && !Input.GetKey(KeyCode.LeftControl) && (Input.GetMouseButton(0) || Input.GetMouseButton(1)))
			{
				if (allowMouseInputX)
				{
					xDeg += Input.GetAxis("Mouse X") * xSpeed * 0.02f;
				}
				if (allowMouseInputY)
				{
					yDeg -= Input.GetAxis("Mouse Y") * ySpeed * 0.02f;
				}
			}
			ClampAngle(yDeg);
			Quaternion quaternion = Quaternion.Euler(yDeg, xDeg, 0f);
			desiredDistance -= Input.GetAxis("Mouse ScrollWheel") * Time.deltaTime * zoomRate * Mathf.Abs(desiredDistance);
			desiredDistance = Mathf.Clamp(desiredDistance, minDistance, maxDistance);
			correctedDistance = desiredDistance;
			Vector3 vector = new Vector3(0f, 0f - targetHeight, 0f);
			Vector3 end = target.position - (quaternion * Vector3.forward * desiredDistance + vector);
			Vector3 vector2 = new Vector3(target.position.x, target.position.y + targetHeight, target.position.z);
			bool flag = false;
			if (Physics.Linecast(vector2, end, out var hitInfo, collisionLayers))
			{
				correctedDistance = Vector3.Distance(vector2, hitInfo.point) - offsetFromWall;
				flag = true;
			}
			currentDistance = ((!flag || correctedDistance > currentDistance) ? Mathf.Lerp(currentDistance, correctedDistance, Time.deltaTime * zoomDampening) : correctedDistance);
			currentDistance = Mathf.Clamp(currentDistance, minDistance, maxDistance);
			end = target.position - (quaternion * Vector3.forward * currentDistance + vector);
			base.transform.rotation = quaternion;
			base.transform.position = end;
		}

		private void ClampAngle(float angle)
		{
			if (angle < -360f)
			{
				angle += 360f;
			}
			if (angle > 360f)
			{
				angle -= 360f;
			}
			yDeg = Mathf.Clamp(angle, -60f, 80f);
		}
	}
	[ExecuteInEditMode]
	public class CameraTarget : MonoBehaviour
	{
		public Transform m_TargetOffset;

		private void LateUpdate()
		{
			base.transform.LookAt(m_TargetOffset);
		}
	}
	[Serializable]
	public class EffectData
	{
		public bool m_bFoldoutOpen = true;

		public float m_fTimeSec;

		public GameObject m_goEffect;

		public bool m_bTransformFoldout = true;

		public Vector3 m_goPos = new Vector3(0f, 0f, 0f);

		public Vector3 m_goRotation = new Vector3(0f, 0f, 0f);

		public Vector3 m_goScale = new Vector3(1f, 1f, 1f);

		public bool m_bSortingFoldout = true;

		public int m_SortingLayerID;

		public int m_SortingOrder;
	}
	public class EffectController : MonoBehaviour
	{
		public int m_nNumOfEffects;

		public bool m_bLockNums;

		public List<EffectData> m_kEffectGenList = new List<EffectData>();

		private int m_nNowIndex;

		private void Awake()
		{
			for (int i = 0; i < m_kEffectGenList.Count; i++)
			{
				Invoke("GenEffect", m_kEffectGenList[i].m_fTimeSec);
			}
			Comp comparer = new Comp();
			m_kEffectGenList.Sort(comparer);
		}

		private void Update()
		{
			CheckTransfromUpdate();
		}

		private void GenEffect()
		{
			EffectData effectData = m_kEffectGenList[m_nNowIndex];
			if (effectData != null)
			{
				if (effectData.m_goEffect != null)
				{
					GameObject obj = UnityEngine.Object.Instantiate(effectData.m_goEffect);
					obj.transform.parent = base.transform;
					obj.name = m_nNowIndex.ToString();
					UpdateEffectTransformByIndex(m_nNowIndex);
					UPdateRenderLayerByIndex(m_nNowIndex);
				}
				m_nNowIndex++;
			}
		}

		private void CheckTransfromUpdate()
		{
			foreach (Transform item in base.transform)
			{
				int index = int.Parse(item.name);
				EffectData effectData = m_kEffectGenList[index];
				if (effectData == null)
				{
					break;
				}
				if (item.position != effectData.m_goPos)
				{
					effectData.m_goPos = item.position;
				}
				if (item.localRotation.eulerAngles != effectData.m_goRotation)
				{
					effectData.m_goRotation = item.localRotation.eulerAngles;
				}
				if (item.localScale != effectData.m_goScale)
				{
					effectData.m_goScale = item.localScale;
				}
			}
		}

		public void UpdateEffectTransformByIndex(int nIndex)
		{
			Transform transform = base.transform.Find(nIndex.ToString());
			if (!(transform == null))
			{
				EffectData effectData = m_kEffectGenList[nIndex];
				if (effectData != null)
				{
					transform.position = effectData.m_goPos;
					Quaternion localRotation = default(Quaternion);
					localRotation.eulerAngles = effectData.m_goRotation;
					transform.localRotation = localRotation;
					transform.localScale = effectData.m_goScale;
				}
			}
		}

		public ParticleSystem CheckHasParticleSystem(int nIndex)
		{
			Transform transform = base.transform.Find(nIndex.ToString());
			if (transform == null)
			{
				return null;
			}
			return transform.gameObject.GetComponent<ParticleSystem>();
		}

		public RenderEffect CheckHasRenderEffectScript(int nIndex)
		{
			Transform transform = base.transform.Find(nIndex.ToString());
			if (transform == null)
			{
				return null;
			}
			return transform.gameObject.GetComponent<RenderEffect>();
		}

		public void UPdateRenderLayerByIndex(int nIndex)
		{
			Transform transform = base.transform.Find(nIndex.ToString());
			if (!(transform == null))
			{
				EffectData effectData = m_kEffectGenList[nIndex];
				if (effectData != null)
				{
					Renderer component = transform.gameObject.GetComponent<Renderer>();
					component.sortingLayerID = effectData.m_SortingLayerID;
					component.sortingOrder = effectData.m_SortingOrder;
				}
			}
		}
	}
	public class Comp : IComparer<EffectData>
	{
		public int Compare(EffectData x, EffectData y)
		{
			if (x == null)
			{
				if (y == null)
				{
					return 0;
				}
				return 1;
			}
			if (y == null)
			{
				return -1;
			}
			float num = x.m_fTimeSec.CompareTo(y.m_fTimeSec);
			if (num > 0f)
			{
				return 1;
			}
			if (num < 0f)
			{
				return -1;
			}
			return 0;
		}
	}
	[ExecuteInEditMode]
	public class EffectDemo : MonoBehaviour
	{
		public const string EFFECT_ASSET_PATH = "Assets/Prefab/";

		public List<GameObject> m_EffectPrefabList = new List<GameObject>();

		public bool m_LookAtEffect = true;

		private GameObject m_NowShowEffect;

		private int m_NowIndex;

		private string m_NowEffectName;

		private void Awake()
		{
			if (Application.isPlaying)
			{
				m_NowIndex = 1;
				GenPrevEffect();
			}
		}

		private void OnDestroy()
		{
			UnityEngine.Object.DestroyImmediate(m_NowShowEffect);
		}

		private void LateUpdate()
		{
			if (Application.isPlaying && m_LookAtEffect && (bool)m_NowShowEffect)
			{
				base.transform.LookAt(m_NowShowEffect.transform.position);
			}
		}

		private void OnGUI()
		{
			if (Application.isPlaying)
			{
				if (GUI.Button(new Rect(0f, 25f, 80f, 50f), "Prev"))
				{
					GenPrevEffect();
				}
				if (GUI.Button(new Rect(90f, 25f, 80f, 50f), "Next"))
				{
					GenNextEffect();
				}
				GUI.Label(new Rect(5f, 0f, 350f, 50f), m_NowEffectName);
			}
		}

		private void GenPrevEffect()
		{
			m_NowIndex--;
			if (m_NowIndex < 0)
			{
				m_NowIndex = 0;
				return;
			}
			if (m_NowShowEffect != null)
			{
				UnityEngine.Object.Destroy(m_NowShowEffect);
			}
			m_NowShowEffect = UnityEngine.Object.Instantiate(m_EffectPrefabList[m_NowIndex]);
			m_NowEffectName = m_NowShowEffect.name;
		}

		private void GenNextEffect()
		{
			m_NowIndex++;
			if (m_NowIndex >= m_EffectPrefabList.Count)
			{
				m_NowIndex = m_EffectPrefabList.Count - 1;
				return;
			}
			if (m_NowShowEffect != null)
			{
				UnityEngine.Object.Destroy(m_NowShowEffect);
			}
			m_NowShowEffect = UnityEngine.Object.Instantiate(m_EffectPrefabList[m_NowIndex]);
			m_NowEffectName = m_NowShowEffect.name;
		}
	}
	public class EffectShaderPropertyStr
	{
		public const string ColorStr = "_TintColor";

		public const string MainTexStr = "_MainTex";

		public const string CutTexStr = "_CutTex";

		public const string CutOffStr = "_Cutoff";

		public const string MainRotationStr = "_MainRotation";

		public const string CutRotationStr = "_CutRotation";

		public const string UVScrollX = "_UVScrollX";

		public const string UVScrollY = "_UVScrollY";

		public const string UVCutScrollX = "_UVCutScrollX";

		public const string UVCutScrollY = "_UVCutScrollY";

		public const string CutParticleSoftValue = "_InvFade";

		public const string UVMirrorX = "_UVMirrorX";

		public const string UVMirrorY = "_UVMirrorY";

		public const string DissolveSrc = "_DissolveSrc";

		public const string SpecColor = "_SpecColor";

		public const string Shininess = "_Shininess";

		public const string Amount = "_Amount";

		public const string StartAmount = "_StartAmount";

		public const string DissColor = "_DissColor";

		public const string Illuminate = "_Illuminate";

		public const string EmissionGain = "_EmissionGain";

		public const string ShadowColor = "_ShadowColor";

		public const string SpecularPower = "_SpecularPower";

		public const string EdgeThickness = "_EdgeThickness";

		public const string EdgeSaturtion = "_EdgeSaturtion";

		public const string EdgeBrightness = "_EdgeBrightness";

		public const string FalloffSampler = "_FalloffSampler";

		public const string RimLightSampler = "_RimLightSampler";

		public const string ColorFactor = "_ColorFactor";

		public const string EnableAlphaMaskStr = "Enable_AlphaMask";

		public const string EnableUVRotationStr = "Enable_UVRotation";

		public const string EnableUVScrollStr = "Enable_UVScroll";

		public const string EnableUVMirror = "Enable_UVMirror";

		public const string EnableBloom = "Enable_Bloom";

		public static readonly int Material_Color = Shader.PropertyToID("_TintColor");

		public static readonly int Material_Color_Factor = Shader.PropertyToID("_ColorFactor");
	}
	public enum RenderBillBoardType
	{
		Normal,
		Horizontal,
		Vertical
	}
	[Serializable]
	public class MaterialEffect
	{
		public Material m_EffectMaterial;

		public bool m_EnableAlphaAnimation;

		public float m_AlphaAnimationTimeScale = 1f;

		public AnimationCurve m_AlphaCurve = new AnimationCurve();

		public Texture m_MainTexture;

		public Texture m_MaskTexutre;

		public TextureWrapMode m_MainTexWrapMode;

		public TextureWrapMode m_MaskTexWrapMode;

		public bool m_EnableUVScroll;

		public Vector2 m_UVScrollMainTex;

		public Vector2 m_UVScrollCutTex;

		public MaterialEffect(Material material)
		{
		}

		public void ReInitMaterial(Material material)
		{
			if (!(material == null))
			{
				m_EffectMaterial = material;
				if (material.HasProperty("_MainTex"))
				{
					m_MainTexture = material.GetTexture("_MainTex");
				}
				if (material.HasProperty("_CutTex"))
				{
					m_MaskTexutre = material.GetTexture("_CutTex");
				}
			}
		}

		public void UpdateEffect(float execueTime)
		{
			if (m_MainTexture != null && m_MainTexWrapMode != m_MainTexture.wrapMode)
			{
				m_MainTexture.wrapMode = m_MainTexWrapMode;
			}
			if (m_MaskTexutre != null && m_MaskTexWrapMode != m_MaskTexutre.wrapMode)
			{
				m_MaskTexutre.wrapMode = m_MaskTexWrapMode;
			}
			if (m_EnableUVScroll)
			{
				if ((bool)m_MainTexture)
				{
					m_EffectMaterial.SetTextureOffset("_MainTex", m_UVScrollMainTex * execueTime);
				}
				if ((bool)m_MaskTexutre)
				{
					m_EffectMaterial.SetTextureOffset("_CutTex", m_UVScrollCutTex * execueTime);
				}
			}
		}

		private void SetAlpha(float value)
		{
			Color color = m_EffectMaterial.color;
			color.a = value;
			m_EffectMaterial.color = color;
		}
	}
	[ExecuteInEditMode]
	public class RenderEffect : MonoBehaviour
	{
		public RenderBillBoardType m_BillBoardType;

		private Camera m_ReferenceCamera;

		public bool m_EnableBillBoard;

		public bool m_EnableSetSortLayer = true;

		public Renderer m_Render;

		public List<MaterialEffect> m_MaterialEffects = new List<MaterialEffect>();

		private float m_TimeLine;

		[HideInInspector]
		public int m_SortingLayerID;

		[HideInInspector]
		public int m_SortingOrder;

		private void Awake()
		{
			m_ReferenceCamera = Camera.main;
			m_Render = GetComponent<Renderer>();
			_ = m_Render == null;
		}

		private void OnEnable()
		{
			RefreshMaterial();
		}

		public void UpdateRenderLayer()
		{
			if (m_EnableSetSortLayer)
			{
				m_Render.sortingLayerID = m_SortingLayerID;
				m_Render.sortingOrder = m_SortingOrder;
			}
		}

		public void RefreshMaterial()
		{
			if (m_Render == null)
			{
				m_Render = GetComponent<Renderer>();
				if (m_Render == null)
				{
					return;
				}
			}
			int num = 0;
			for (num = 0; num < m_Render.sharedMaterials.Length; num++)
			{
				if (m_MaterialEffects.Count <= num)
				{
					MaterialEffect item = new MaterialEffect(m_Render.sharedMaterials[num]);
					m_MaterialEffects.Add(item);
				}
				else
				{
					m_MaterialEffects[num].ReInitMaterial(m_Render.sharedMaterials[num]);
				}
			}
			int num2 = m_MaterialEffects.Count - 1;
			while (num <= num2)
			{
				m_MaterialEffects.RemoveAt(num2);
				num2--;
			}
			UpdateRenderLayer();
		}

		private void UpdateBillBoard()
		{
			if (m_EnableBillBoard)
			{
				if (m_ReferenceCamera == null)
				{
					m_ReferenceCamera = Camera.main;
				}
				if (m_BillBoardType == RenderBillBoardType.Normal)
				{
					Vector3 worldPosition = base.transform.position + m_ReferenceCamera.transform.rotation * Vector3.forward;
					Vector3 worldUp = m_ReferenceCamera.transform.rotation * Vector3.up;
					base.transform.LookAt(worldPosition, worldUp);
				}
				else if (m_BillBoardType == RenderBillBoardType.Vertical)
				{
					Vector3 forward = m_ReferenceCamera.transform.forward;
					forward.y = 0f;
					base.transform.rotation = Quaternion.LookRotation(forward, Vector3.up);
				}
				else if (m_BillBoardType == RenderBillBoardType.Horizontal)
				{
					Vector3 worldPosition2 = base.transform.position + m_ReferenceCamera.transform.rotation * Vector3.down;
					Vector3 worldUp2 = m_ReferenceCamera.transform.rotation * Vector3.up;
					base.transform.LookAt(worldPosition2, worldUp2);
					Vector3 eulerAngles = base.transform.rotation.eulerAngles;
					eulerAngles.x = 90f;
					base.transform.rotation = Quaternion.Euler(eulerAngles);
				}
			}
		}

		private void Update()
		{
			m_TimeLine += Time.deltaTime;
			foreach (MaterialEffect materialEffect in m_MaterialEffects)
			{
				materialEffect.UpdateEffect(m_TimeLine);
			}
		}

		private void LateUpdate()
		{
			UpdateBillBoard();
		}

		public void Sim(float timer)
		{
			UpdateBillBoard();
			foreach (MaterialEffect materialEffect in m_MaterialEffects)
			{
				materialEffect.UpdateEffect(timer);
			}
		}
	}
	public static class TransformExtension
	{
		public static Transform FindChildByRecursive(this Transform aParent, string aName)
		{
			Transform transform = aParent.Find(aName);
			if (transform != null)
			{
				return transform;
			}
			foreach (Transform item in aParent)
			{
				transform = item.FindChildByRecursive(aName);
				if (transform != null)
				{
					return transform;
				}
			}
			return null;
		}
	}
	public class DemoScene : MonoBehaviour
	{
		public GameObject[] prefabs;

		public Text txtLabel;

		public void ShowEffect1()
		{
			prefabs[0].SetActive(value: true);
			prefabs[1].SetActive(value: false);
			txtLabel.text = "Petals Prefab 1";
		}

		public void ShowEffect2()
		{
			prefabs[0].SetActive(value: false);
			prefabs[1].SetActive(value: true);
			txtLabel.text = "Petals Prefab 2";
		}

		public void ShowEffect3()
		{
			prefabs[0].SetActive(value: true);
			prefabs[1].SetActive(value: true);
			txtLabel.text = "Petals Prefab 1+2";
		}
	}
	public class ExampleWheelController : MonoBehaviour
	{
		private static class Uniforms
		{
			internal static readonly int _MotionAmount = Shader.PropertyToID("_MotionAmount");
		}

		public float acceleration;

		public Renderer motionVectorRenderer;

		private Rigidbody m_Rigidbody;

		private void Start()
		{
			m_Rigidbody = GetComponent<Rigidbody>();
			m_Rigidbody.maxAngularVelocity = 100f;
		}

		private void Update()
		{
			if (Input.GetKey(KeyCode.UpArrow))
			{
				m_Rigidbody.AddRelativeTorque(new Vector3(-1f * acceleration, 0f, 0f), ForceMode.Acceleration);
			}
			else if (Input.GetKey(KeyCode.DownArrow))
			{
				m_Rigidbody.AddRelativeTorque(new Vector3(1f * acceleration, 0f, 0f), ForceMode.Acceleration);
			}
			float value = (0f - m_Rigidbody.angularVelocity.x) / 100f;
			if ((bool)motionVectorRenderer)
			{
				motionVectorRenderer.material.SetFloat(Uniforms._MotionAmount, Mathf.Clamp(value, -0.25f, 0.25f));
			}
		}
	}
	[Serializable]
	[PostProcess(typeof(SunShaftsHDRPRenderer), PostProcessEvent.AfterStack, "Custom/SunShaftsHDRP", true)]
	public sealed class SunShaftsHDRP : PostProcessEffectSettings
	{
		public enum SunShaftsResolution
		{
			Low,
			Normal,
			High
		}

		public enum ShaftsScreenBlendMode
		{
			Screen,
			Add
		}

		[Range(0f, 1f)]
		[Tooltip("SunShafts effect intensity.")]
		public FloatParameter blend = new FloatParameter
		{
			value = 0.5f
		};

		public SunShaftsResolution resolution = SunShaftsResolution.Normal;

		public ShaftsScreenBlendMode screenBlendMode;

		public Vector3Parameter sunTransform = new Vector3Parameter
		{
			value = new Vector3(0f, 0f, 0f)
		};

		public IntParameter radialBlurIterations = new IntParameter
		{
			value = 2
		};

		public ColorParameter sunColor = new ColorParameter
		{
			value = Color.white
		};

		public ColorParameter sunThreshold = new ColorParameter
		{
			value = new Color(0.87f, 0.74f, 0.65f)
		};

		public FloatParameter sunShaftBlurRadius = new FloatParameter
		{
			value = 2.5f
		};

		public FloatParameter sunShaftIntensity = new FloatParameter
		{
			value = 1.15f
		};

		public FloatParameter maxRadius = new FloatParameter
		{
			value = 0.75f
		};

		public BoolParameter useDepthTexture = new BoolParameter
		{
			value = true
		};
	}
	public sealed class SunShaftsHDRPRenderer : PostProcessEffectRenderer<SunShaftsHDRP>
	{
		private RenderTexture lrColorB;

		private RenderTexture lrDepthBuffer;

		private void onEnable()
		{
		}

		public override void Render(PostProcessRenderContext context)
		{
			PropertySheet propertySheet = context.propertySheets.Get(Shader.Find("Hidden/Custom/GrayscaleShafts"));
			propertySheet.properties.SetFloat("_Blend", base.settings.blend);
			Camera main = Camera.main;
			if ((bool)base.settings.useDepthTexture)
			{
				main.depthTextureMode |= DepthTextureMode.Depth;
			}
			Vector3 vector = Vector3.one * 0.5f;
			vector = ((!(base.settings.sunTransform != Vector3.zero)) ? new Vector3(0.5f, 0.5f, 0f) : main.WorldToViewportPoint(base.settings.sunTransform));
			int width = context.width;
			int width2 = context.width;
			lrDepthBuffer = RenderTexture.GetTemporary(width, width2, 0);
			propertySheet.properties.SetVector("_BlurRadius4", new Vector4(1f, 1f, 0f, 0f) * base.settings.sunShaftBlurRadius);
			propertySheet.properties.SetVector("_SunPosition", new Vector4(vector.x, vector.y, vector.z, base.settings.maxRadius));
			propertySheet.properties.SetVector("_SunThreshold", base.settings.sunThreshold);
			if (!base.settings.useDepthTexture)
			{
				RenderTextureFormat format = (main.allowHDR ? RenderTextureFormat.DefaultHDR : RenderTextureFormat.Default);
				RenderTexture renderTexture = (RenderTexture.active = RenderTexture.GetTemporary(context.width, context.height, 0, format));
				GL.ClearWithSkybox(clearDepth: false, main);
				propertySheet.properties.SetTexture("_Skybox", renderTexture);
				context.command.BlitFullscreenTriangle(context.source, lrDepthBuffer, propertySheet, 3);
				RenderTexture.ReleaseTemporary(renderTexture);
			}
			else
			{
				context.command.BlitFullscreenTriangle(context.source, lrDepthBuffer, propertySheet, 2);
			}
			int num = Mathf.Clamp(base.settings.radialBlurIterations, 1, 4);
			float num2 = (float)base.settings.sunShaftBlurRadius * 0.0013020834f;
			propertySheet.properties.SetVector("_BlurRadius4", new Vector4(num2, num2, 0f, 0f));
			propertySheet.properties.SetVector("_SunPosition", new Vector4(vector.x, vector.y, vector.z, base.settings.maxRadius));
			for (int i = 0; i < num; i++)
			{
				lrColorB = RenderTexture.GetTemporary(width, width2, 0);
				context.command.BlitFullscreenTriangle(lrDepthBuffer, lrColorB, propertySheet, 1);
				RenderTexture.ReleaseTemporary(lrDepthBuffer);
				num2 = (float)base.settings.sunShaftBlurRadius * (((float)i * 2f + 1f) * 6f) / 768f;
				propertySheet.properties.SetVector("_BlurRadius4", new Vector4(num2, num2, 0f, 0f));
				lrDepthBuffer = RenderTexture.GetTemporary(width, width2, 0);
				context.command.BlitFullscreenTriangle(lrColorB, lrDepthBuffer, propertySheet, 1);
				RenderTexture.ReleaseTemporary(lrColorB);
				num2 = (float)base.settings.sunShaftBlurRadius * (((float)i * 2f + 2f) * 6f) / 768f;
				propertySheet.properties.SetVector("_BlurRadius4", new Vector4(num2, num2, 0f, 0f));
			}
			if (vector.z >= 0f)
			{
				propertySheet.properties.SetVector("_SunColor", new Vector4(base.settings.sunColor.value.r, base.settings.sunColor.value.g, base.settings.sunColor.value.b, base.settings.sunColor.value.a) * base.settings.sunShaftIntensity);
			}
			else
			{
				propertySheet.properties.SetVector("_SunColor", Vector4.zero);
			}
			propertySheet.properties.SetTexture("_ColorBuffer", lrDepthBuffer);
			context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, (base.settings.screenBlendMode != 0) ? 4 : 0);
			RenderTexture.ReleaseTemporary(lrDepthBuffer);
		}
	}
	[ExecuteInEditMode]
	public class connectSuntoSunShaftsPOSTFX : MonoBehaviour
	{
		public Transform sun;

		private PostProcessProfile postProfile;

		private void Start()
		{
			postProfile = GetComponent<PostProcessVolume>().profile;
		}

		private void Update()
		{
			if (sun != null)
			{
				SunShaftsHDRP setting = postProfile.GetSetting<SunShaftsHDRP>();
				if (setting != null)
				{
					setting.sunTransform.value = sun.transform.position;
				}
			}
		}
	}
	public class CameraHolder : MonoBehaviour
	{
		public struct SVA
		{
			public float S;

			public float V;

			public float A;
		}

		public Transform Holder;

		public float currDistance = 5f;

		public float xRotate = 250f;

		public float yRotate = 120f;

		public float yMinLimit = -20f;

		public float yMaxLimit = 80f;

		public float prevDistance;

		private float x;

		private float y;

		[Header("GUI")]
		private float windowDpi;

		public GameObject[] Prefabs;

		private int Prefab;

		private GameObject Instance;

		private float StartColor;

		private float HueColor;

		public Texture HueTexture;

		private ParticleSystem[] particleSystems = new ParticleSystem[0];

		private List<SVA> svList = new List<SVA>();

		private float H;

		private void Start()
		{
			if (Screen.dpi < 1f)
			{
				windowDpi = 1f;
			}
			if (Screen.dpi < 200f)
			{
				windowDpi = 1f;
			}
			else
			{
				windowDpi = Screen.dpi / 200f;
			}
			Vector3 eulerAngles = base.transform.eulerAngles;
			x = eulerAngles.y;
			y = eulerAngles.x;
			Counter(0);
		}

		private void OnGUI()
		{
			if (GUI.Button(new Rect(5f * windowDpi, 5f * windowDpi, 110f * windowDpi, 35f * windowDpi), "Previous effect"))
			{
				Counter(-1);
			}
			if (GUI.Button(new Rect(120f * windowDpi, 5f * windowDpi, 110f * windowDpi, 35f * windowDpi), "Play again"))
			{
				Counter(0);
			}
			if (GUI.Button(new Rect(235f * windowDpi, 5f * windowDpi, 110f * windowDpi, 35f * windowDpi), "Next effect"))
			{
				Counter(1);
			}
			StartColor = HueColor;
			HueColor = GUI.HorizontalSlider(new Rect(5f * windowDpi, 45f * windowDpi, 340f * windowDpi, 35f * windowDpi), HueColor, 0f, 1f);
			GUI.DrawTexture(new Rect(5f * windowDpi, 65f * windowDpi, 340f * windowDpi, 15f * windowDpi), HueTexture, ScaleMode.StretchToFill, alphaBlend: false, 0f);
			if (HueColor != StartColor)
			{
				int num = 0;
				ParticleSystem[] array = particleSystems;
				for (int i = 0; i < array.Length; i++)
				{
					ParticleSystem.MainModule main = array[i].main;
					Color color = Color.HSVToRGB(HueColor + H * 0f, svList[num].S, svList[num].V);
					main.startColor = new Color(color.r, color.g, color.b, svList[num].A);
					num++;
				}
			}
		}

		private void Counter(int count)
		{
			Prefab += count;
			if (Prefab > Prefabs.Length - 1)
			{
				Prefab = 0;
			}
			else if (Prefab < 0)
			{
				Prefab = Prefabs.Length - 1;
			}
			if (Instance != null)
			{
				UnityEngine.Object.Destroy(Instance);
			}
			Instance = UnityEngine.Object.Instantiate(Prefabs[Prefab]);
			particleSystems = Instance.GetComponentsInChildren<ParticleSystem>();
			svList.Clear();
			ParticleSystem[] array = particleSystems;
			for (int i = 0; i < array.Length; i++)
			{
				Color color = array[i].main.startColor.color;
				SVA item = default(SVA);
				Color.RGBToHSV(color, out H, out item.S, out item.V);
				item.A = color.a;
				svList.Add(item);
			}
		}

		private void LateUpdate()
		{
			if (currDistance < 2f)
			{
				currDistance = 2f;
			}
			currDistance -= Input.GetAxis("Mouse ScrollWheel") * 2f;
			if ((bool)Holder && (Input.GetMouseButton(0) || Input.GetMouseButton(1)))
			{
				Vector3 mousePosition = Input.mousePosition;
				float num = 1f;
				if (Screen.dpi < 1f)
				{
					num = 1f;
				}
				num = ((!(Screen.dpi < 200f)) ? (Screen.dpi / 200f) : 1f);
				if (mousePosition.x < 380f * num && (float)Screen.height - mousePosition.y < 250f * num)
				{
					return;
				}
				Cursor.visible = false;
				Cursor.lockState = CursorLockMode.Locked;
				x += (float)((double)(Input.GetAxis("Mouse X") * xRotate) * 0.02);
				y -= (float)((double)(Input.GetAxis("Mouse Y") * yRotate) * 0.02);
				y = ClampAngle(y, yMinLimit, yMaxLimit);
				Quaternion quaternion = Quaternion.Euler(y, x, 0f);
				Vector3 position = quaternion * new Vector3(0f, 0f, 0f - currDistance) + Holder.position;
				base.transform.rotation = quaternion;
				base.transform.position = position;
			}
			else
			{
				Cursor.visible = true;
				Cursor.lockState = CursorLockMode.None;
			}
			if (prevDistance != currDistance)
			{
				prevDistance = currDistance;
				Quaternion quaternion2 = Quaternion.Euler(y, x, 0f);
				Vector3 position2 = quaternion2 * new Vector3(0f, 0f, 0f - currDistance) + Holder.position;
				base.transform.rotation = quaternion2;
				base.transform.position = position2;
			}
		}

		private static float ClampAngle(float angle, float min, float max)
		{
			if (angle < -360f)
			{
				angle += 360f;
			}
			if (angle > 360f)
			{
				angle -= 360f;
			}
			return Mathf.Clamp(angle, min, max);
		}
	}
	[RequireComponent(typeof(Collider))]
	public class EpiActivator : MonoBehaviour
	{
		public string activationTag = "Player";

		public UnityEvent onTriggerEnter;

		public UnityEvent onTriggerExit;

		private void OnTriggerEnter(Collider other)
		{
			if (other.tag == activationTag)
			{
				onTriggerEnter.Invoke();
			}
		}

		private void OnTriggerExit(Collider other)
		{
			if (other.tag == activationTag)
			{
				onTriggerExit.Invoke();
			}
		}
	}
	public class GolfBall : MonoBehaviour
	{
		public GameObject tee;

		private Rigidbody rb;

		private void Start()
		{
			rb = GetComponent<Rigidbody>();
			rb.isKinematic = true;
		}

		public void Activate()
		{
			tee.SetActive(value: false);
			rb.isKinematic = false;
		}
	}
	public class GolfBat : MonoBehaviour
	{
		public bool useOnTriggerEnter = true;

		public bool useOnCollision;

		public bool useRaycast;

		public GameObject hitParticles;

		public float strength = 10f;

		public float upwardsModifier;

		private Vector3 prevPos;

		private Vector3 newPos;

		private Vector3 manualVelocity;

		private float coolDownCounter;

		private void Start()
		{
			prevPos = base.transform.position;
			newPos = base.transform.position;
		}

		private void Update()
		{
		}

		private void FixedUpdate()
		{
			prevPos = newPos;
			newPos = base.transform.position;
			manualVelocity = (newPos - prevPos) / Time.fixedDeltaTime;
			if (coolDownCounter > 0f)
			{
				coolDownCounter -= Time.fixedDeltaTime;
			}
			if (coolDownCounter < 0f)
			{
				coolDownCounter = 0f;
			}
			if (useRaycast)
			{
				float num = (prevPos - newPos).magnitude;
				if (num < 0f)
				{
					num *= -1f;
				}
				if (Physics.SphereCast(newPos, 0.05f, newPos - prevPos, out var hitInfo, num))
				{
					UnityEngine.Debug.LogError("Found Hit: " + hitInfo.transform.gameObject.name);
					Hit(hitInfo.transform.gameObject);
				}
			}
		}

		public void OnCollisionEnter(Collision collision)
		{
			if (useOnCollision)
			{
				Hit(collision.transform.gameObject);
			}
		}

		public void OnTriggerEnter(Collider other)
		{
			if (useOnTriggerEnter)
			{
				Hit(other.gameObject);
			}
		}

		public void Hit(GameObject ball)
		{
			if (!(coolDownCounter > 0f) && ball.tag == "Ball")
			{
				coolDownCounter = 0.2f;
				ball.gameObject.GetComponent<GolfBall>().Activate();
				ball.gameObject.GetComponent<Rigidbody>().AddForce((manualVelocity + new Vector3(0f, upwardsModifier, 0f)) * strength, ForceMode.VelocityChange);
				GameObject obj = UnityEngine.Object.Instantiate(hitParticles, hitParticles.transform.position, hitParticles.transform.rotation, null);
				obj.SetActive(value: true);
				UnityEngine.Object.Destroy(obj, 1.5f);
			}
		}
	}
	public class EasyBullet : MonoBehaviour
	{
		public float lifetime = 5f;

		public float speed = 1f;

		private void Start()
		{
			UnityEngine.Object.Destroy(this, lifetime);
			GetComponent<Rigidbody>().velocity = base.gameObject.transform.forward * speed;
		}
	}
	public class EasyGun : MonoBehaviour
	{
		[Header("Input")]
		public string axisName;

		public string axisName_switch;

		[Header("Gun Defenition")]
		public GameObject spawnPoint;

		public GameObject bullet;

		public float cooldown = 0.5f;

		private float counter;

		private void Update()
		{
			if (counter == 0f)
			{
				if (Controller.UPvr_GetKey(1, Pvr_KeyCode.TRIGGER))
				{
					UnityEngine.Object.Instantiate(bullet, spawnPoint.transform.position, spawnPoint.transform.rotation, null);
					counter = cooldown;
				}
			}
			else
			{
				counter -= Time.deltaTime;
				if (counter < 0f)
				{
					counter = 0f;
				}
			}
		}
	}
	public class EpiCountDown : MonoBehaviour
	{
		[Header("Input")]
		public string axisName;

		public string axisName_switch;

		[Header("Representation")]
		public TextMeshPro label;

		public AudioSource beepAudio;

		public AudioSource startAudio;

		public Rigidbody player;

		public GameObject ui;

		public GameObject activationObject;

		private bool used;

		private int iteration;

		public void Update()
		{
			if (!used && player.GetComponent<Player>().menuState != Player.MenuState.InMenu && (Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.TRIGGER) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TRIGGER) || Input.GetKeyDown(KeyCode.A)))
			{
				StartCoroutine(CountDown());
				ui.SetActive(value: true);
				used = true;
			}
		}

		public IEnumerator CountDown()
		{
			iteration++;
			if (iteration == 1)
			{
				label.text = "3";
			}
			if (iteration == 2)
			{
				label.text = "2";
			}
			if (iteration == 3)
			{
				label.text = "1";
			}
			if (iteration == 4)
			{
				if (LocalizationManager.CurrentLanguageCode == "zh")
				{
					label.text = "!!!";
				}
				else if (LocalizationManager.CurrentLanguageCode == "ja")
				{
					label.text = "!!!";
				}
				else if (LocalizationManager.CurrentLanguageCode == "ko")
				{
					label.text = "!!!";
				}
				else
				{
					label.text = "START";
				}
			}
			if (iteration == 5)
			{
				player.GetComponent<EpiScoreController>().racing = true;
				label.transform.parent.gameObject.SetActive(value: false);
				player.constraints = RigidbodyConstraints.None;
				player.constraints = RigidbodyConstraints.FreezeRotation;
				activationObject.SetActive(value: true);
				startAudio.Play();
			}
			if (iteration < 5)
			{
				beepAudio.Play();
			}
			yield return new WaitForSeconds(1f);
			if (iteration < 5)
			{
				StartCoroutine(CountDown());
			}
		}
	}
	public class EpiEndTrigger : MonoBehaviour
	{
		public int triggerIndex = 1;

		public GameObject audio;

		public GameObject text;

		public GameObject image;

		public void OnTriggerEnter(Collider other)
		{
			if (other.tag == "Player")
			{
				if (triggerIndex == 1)
				{
					Invoke("Audio", 2f);
					Invoke("Text", 4f);
				}
				if (triggerIndex == 2)
				{
					Image();
					Invoke("Scene", 2f);
				}
			}
		}

		public void Audio()
		{
			audio.SetActive(value: true);
		}

		public void Text()
		{
			text.SetActive(value: true);
		}

		public void Image()
		{
			image.SetActive(value: true);
		}

		public void Scene()
		{
			SceneManager.LoadSceneAsync(0);
		}
	}
	public class EpiGoal : MonoBehaviour
	{
		[Header("Input")]
		public string acceptAxisName;

		public string acceptAxisName_switch;

		public string updownAxisName;

		[Header("Representation")]
		public GameObject goal;

		public GameObject effects;

		public GameObject stats;

		public GameObject nextMenu;

		public EpiScoreController scoreController;

		public GameObject ui;

		public TextMeshPro timeLabel;

		public TextMeshPro scoreLabel;

		public TextMeshPro highscoreLabel;

		public Rigidbody player;

		public SpriteRenderer[] buttons;

		private int selectedIndex;

		private int state;

		private bool triggerUsed;

		private bool inputReady_accept;

		private bool inputReady_updown;

		private GameObject savedPlayer;

		private Vector3 savedMenuPos;

		private void OnTriggerEnter(Collider other)
		{
			if (!triggerUsed && other.tag == "Player")
			{
				scoreController.racing = false;
				triggerUsed = true;
				state = 1;
				goal.SetActive(value: false);
				effects.SetActive(value: true);
				stats.SetActive(value: true);
				savedPlayer = other.gameObject;
				savedMenuPos = stats.transform.position;
				SetScores();
			}
		}

		private void Update()
		{
			if (state == 0)
			{
				return;
			}
			float num = 1f;
			_ = player.GetComponent<Player>().jetPackL.rocketModifier;
			num = 5f;
			if (player.GetComponent<Player>().jetPackR.gameObject.activeSelf)
			{
				num *= 4.5f - num;
			}
			player.mass += 30f * num;
			if (player.mass > 1600f)
			{
				player.constraints = RigidbodyConstraints.FreezeAll;
				player.mass = 1600f;
			}
			stats.transform.position = savedPlayer.transform.position + (savedMenuPos - savedPlayer.transform.position).normalized * 4f;
			nextMenu.transform.position = savedPlayer.transform.position + (savedMenuPos - savedPlayer.transform.position).normalized * 4f;
			stats.transform.position = new Vector3(stats.transform.position.x, savedPlayer.transform.position.y + 1f, stats.transform.position.z);
			nextMenu.transform.position = new Vector3(nextMenu.transform.position.x, savedPlayer.transform.position.y + 1f, nextMenu.transform.position.z);
			if (Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TRIGGER) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.A))
			{
				inputReady_accept = false;
				if (state == 1)
				{
					stats.SetActive(value: false);
					nextMenu.SetActive(value: true);
					state = 2;
				}
				else
				{
					state = 0;
					if (selectedIndex == 0)
					{
						OVPlayerPrefs.SetInt("Level", OVPlayerPrefs.GetInt("Level") + 1);
						OVPlayerPrefs.Save();
						SceneManager.LoadSceneAsync(SceneManager.GetActiveScene().buildIndex);
					}
					else if (selectedIndex == 1)
					{
						SceneManager.LoadSceneAsync(SceneManager.GetActiveScene().buildIndex);
					}
					else if (selectedIndex == 2)
					{
						SceneManager.LoadSceneAsync(1);
					}
				}
			}
			if (state == 2)
			{
				if (inputReady_updown)
				{
					if (Controller.UPvr_GetAxis2D(1).y < -0.5f)
					{
						inputReady_updown = false;
						selectedIndex++;
						if (selectedIndex > 2)
						{
							selectedIndex = 2;
						}
					}
					else if (Controller.UPvr_GetAxis2D(1).y > 0.5f)
					{
						inputReady_updown = false;
						selectedIndex--;
						if (selectedIndex < 0)
						{
							selectedIndex = 0;
						}
					}
				}
				buttons[0].color = Color.white;
				buttons[1].color = Color.white;
				buttons[2].color = Color.white;
				buttons[selectedIndex].color = Color.yellow;
				if (Controller.UPvr_GetAxis2D(1).y < 0.1f && Controller.UPvr_GetAxis2D(1).y > -0.1f)
				{
					inputReady_updown = true;
				}
			}
			if (Input.GetAxis(acceptAxisName) < 0.1f)
			{
				inputReady_accept = true;
			}
		}

		public void SetScores()
		{
			float num = OVPlayerPrefs.GetFloat("HighScore" + OVPlayerPrefs.GetInt("Level"));
			if (num < scoreController.score)
			{
				num = scoreController.score;
				OVPlayerPrefs.SetFloat("HighScore" + OVPlayerPrefs.GetInt("Level"), num);
				OVPlayerPrefs.Save();
			}
			timeLabel.text += scoreController.time.ToString("00.00");
			scoreLabel.text += (int)scoreController.score;
			highscoreLabel.text += (int)num;
		}
	}
	public class EpiItemActivator : MonoBehaviour
	{
		public GameObject item;

		private void Start()
		{
			item.SetActive(value: true);
		}
	}
	public class EpiLevelActivator : MonoBehaviour
	{
		public bool use = true;

		public GameObject[] levels;

		public GameObject[] additionalitems;

		private void Awake()
		{
			if (!use)
			{
				return;
			}
			int @int = OVPlayerPrefs.GetInt("Level");
			GameObject[] array = levels;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SetActive(value: false);
			}
			levels[@int].SetActive(value: true);
			array = additionalitems;
			foreach (GameObject gameObject in array)
			{
				if (gameObject != null)
				{
					gameObject.SetActive(value: false);
				}
			}
			if (additionalitems[@int] != null)
			{
				additionalitems[@int].SetActive(value: true);
			}
		}
	}
	public class EpiScoreController : MonoBehaviour
	{
		[HideInInspector]
		public float time;

		[HideInInspector]
		public float score = 20000f;

		public Text scoreText;

		public Text highscoreText;

		public Text timeText;

		[HideInInspector]
		public bool racing;

		private void Start()
		{
			time = 0f;
			score = 20000f;
			int num = (int)OVPlayerPrefs.GetFloat("HighScore" + OVPlayerPrefs.GetInt("Level"));
			if (num == 0)
			{
				highscoreText.gameObject.SetActive(value: false);
			}
			else
			{
				highscoreText.text = num.ToString() ?? "";
			}
			scoreText.text = 20000.ToString() ?? "";
		}

		private void Update()
		{
			if (racing)
			{
				time += Time.deltaTime;
				score -= Time.deltaTime * 100f;
				if (score < 0f)
				{
					score = 0f;
				}
				scoreText.text = ((int)score).ToString() ?? "";
				timeText.text = time.ToString("00.00");
			}
		}

		public void AddScore(int x)
		{
			score += x;
		}
	}
	public class EpiSkyboxChanger : MonoBehaviour
	{
		public Material skybox;

		private void Start()
		{
			RenderSettings.skybox = skybox;
		}
	}
	public class EpiSpawnPoint : MonoBehaviour
	{
		private void Start()
		{
			Transform obj = GameObject.FindGameObjectWithTag("Player").transform;
			obj.position = base.transform.position;
			obj.rotation = base.transform.rotation;
		}
	}
	public class EpiSpeedPortal : MonoBehaviour
	{
		private bool used;

		public JetPack lJet;

		public JetPack rJet;

		public void OnTriggerEnter(Collider other)
		{
			if (!(other.tag != "Player"))
			{
				lJet.StartPassiveBoost();
				rJet.StartPassiveBoost();
				GetComponent<AudioSource>().Play();
				if (!used)
				{
					other.GetComponent<EpiScoreController>().AddScore(500);
				}
			}
		}
	}
	public class EpiTrigger : MonoBehaviour
	{
		public bool onlyOnce = true;

		public string activatorTag = "Bullet";

		public UnityEvent onEnter;

		private bool used;

		private void OnTriggerEnter(Collider other)
		{
			if (!used && other.tag == activatorTag)
			{
				onEnter.Invoke();
				if (onlyOnce)
				{
					used = true;
				}
			}
		}
	}
	public class JetPack : MonoBehaviour
	{
		[Header("Input")]
		public string axisName;

		public string axisName_switch;

		public string speedAxisName;

		public string speedAxisName_switch;

		[Header("Speed Values")]
		public bool loadSpeed = true;

		public bool canFly;

		public Rigidbody _rigidbody;

		public Transform target;

		public float rocketModifier = -1f;

		public float upwardMultiplier = 1f;

		public float boosterStrength = 1f;

		public float boosterCounterSpeed = 1f;

		[Header("Visual Representation")]
		public Image speedImage;

		public Text speedText;

		public float maxSpeed = 10f;

		public float maxBoost = 100f;

		public float passivBoostMultiplier = 1.2f;

		public float passivBoostDuration = 1f;

		private float passivCurrentBoost = 1f;

		private bool fly;

		private bool speedFly;

		private float currentBoost;

		private bool boostCooldown;

		[HideInInspector]
		public bool useFixedSpeed;

		private AudioSource audio;

		private void Start()
		{
			if (loadSpeed)
			{
				int @int = OVPlayerPrefs.GetInt("Speed");
				rocketModifier = (70 + @int * 35) * -1;
			}
			audio = GetComponent<AudioSource>();
		}

		private void Update()
		{
			if (Controller.UPvr_GetKey(0, Pvr_KeyCode.TRIGGER) || Controller.UPvr_GetKey(1, Pvr_KeyCode.TRIGGER) || Input.GetKey(KeyCode.A))
			{
				audio.volume = 0.1f;
				fly = true;
				if (Controller.UPvr_GetKey(0, Pvr_KeyCode.Right) || Controller.UPvr_GetKey(1, Pvr_KeyCode.Left))
				{
					speedFly = true;
				}
				else
				{
					speedFly = false;
				}
			}
			else
			{
				audio.volume = 0f;
				fly = false;
				speedFly = false;
			}
			if (currentBoost <= 0f)
			{
				speedFly = false;
			}
			if (fly)
			{
				GetComponentInChildren<ParticleSystem>().Play();
			}
			else
			{
				GetComponentInChildren<ParticleSystem>().Stop();
			}
		}

		private void FixedUpdate()
		{
			if (!boostCooldown)
			{
				if (speedFly)
				{
					currentBoost -= boosterCounterSpeed * Time.deltaTime * 2f;
					if (currentBoost > 0f)
					{
						speedFly = true;
					}
					else
					{
						boostCooldown = true;
						Invoke("ResetCooldown", 4f);
					}
				}
				else
				{
					currentBoost += boosterCounterSpeed * Time.deltaTime;
					if (currentBoost > maxBoost)
					{
						currentBoost = maxBoost;
					}
				}
			}
			float num = 1f;
			if (speedFly)
			{
				num = boosterStrength;
			}
			if (fly)
			{
				Vector3 vector = Vector3.up * upwardMultiplier + target.forward * rocketModifier * num * passivCurrentBoost;
				if (!canFly)
				{
					vector.y = 0f;
				}
				_rigidbody.AddForce(vector);
				Vector3 vector2 = vector;
				UnityEngine.Debug.Log("Move with Force: " + vector2.ToString());
			}
			if (speedText != null)
			{
				speedText.text = ((int)(_rigidbody.velocity.magnitude * 10f)).ToString() ?? "";
			}
			if (speedImage != null)
			{
				speedImage.fillAmount = _rigidbody.velocity.magnitude / (maxSpeed * 1.05f);
			}
		}

		public void StartPassiveBoost()
		{
			passivCurrentBoost = passivBoostMultiplier;
			CancelInvoke("EndPassiveBoost");
			Invoke("EndPassiveBoost", passivBoostDuration);
		}

		public void EndPassiveBoost()
		{
			passivCurrentBoost = 1f;
		}

		public void ResetCooldown()
		{
			boostCooldown = false;
		}
	}
	public class MainMenu : MonoBehaviour
	{
		[Header("Input")]
		public string acceptAxisName;

		public string acceptAxisName_switch;

		public string updownAxisName;

		public string leftRightAxisName;

		public string menuButtonName;

		[Header("Representation")]
		public LanguageChangerProxy languageChangerProxy;

		public GameObject languageMenu;

		public GameObject speedMenu;

		public GameObject levelMenu;

		public SpriteRenderer[] languageButtons;

		public SpriteRenderer[] speedButtons;

		public SpriteRenderer[] levelButtons;

		public SpriteRenderer[] levelLocks;

		public TextMeshPro[] levelTexts;

		public GameObject leftArrow;

		public GameObject rightArrow;

		private bool loading;

		private int selectedIndex;

		private int pageIndex;

		private int state;

		private bool inputReady_accept;

		private bool inputReady_updown;

		private bool inputReady_leftRight;

		private void Start()
		{
			state = 0;
			languageMenu.SetActive(value: true);
			speedMenu.SetActive(value: false);
			levelMenu.SetActive(value: false);
		}

		private void Update()
		{
			if (loading)
			{
				return;
			}
			if (Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.A) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TRIGGER))
			{
				inputReady_accept = false;
				if (state == 0)
				{
					languageChangerProxy.ChangeLanguage(selectedIndex);
					state = 1;
					selectedIndex = 0;
					languageMenu.SetActive(value: false);
					speedMenu.SetActive(value: true);
				}
				else if (state == 1)
				{
					OVPlayerPrefs.SetInt("Speed", selectedIndex);
					OVPlayerPrefs.Save();
					pageIndex = 0;
					for (int i = 0; i < levelLocks.Length; i++)
					{
						if (i == 0)
						{
							levelLocks[i].gameObject.SetActive(value: false);
						}
						else if (OVPlayerPrefs.GetFloat("HighScore" + (i - 1)) != 0f)
						{
							levelLocks[i].gameObject.SetActive(value: false);
						}
						else
						{
							levelLocks[i].gameObject.SetActive(value: true);
						}
					}
					state = 2;
					selectedIndex = 0;
					speedMenu.SetActive(value: false);
					levelMenu.SetActive(value: true);
				}
				else if (state == 2)
				{
					UnityEngine.Debug.LogError(selectedIndex);
					if (!levelLocks[selectedIndex].gameObject.activeSelf)
					{
						OVPlayerPrefs.SetInt("Level", selectedIndex + pageIndex * 5);
						OVPlayerPrefs.Save();
						loading = true;
						SceneManager.LoadSceneAsync(1);
					}
				}
			}
			if (inputReady_updown)
			{
				if (Controller.UPvr_GetAxis2D(1).y < -0.5f)
				{
					inputReady_updown = false;
					selectedIndex++;
					if (state == 0 && selectedIndex > 3)
					{
						selectedIndex = 3;
					}
					if (state == 1 && selectedIndex > 2)
					{
						selectedIndex = 2;
					}
					if (state == 2 && selectedIndex > 4)
					{
						selectedIndex = 4;
					}
				}
				else if (Controller.UPvr_GetAxis2D(1).y > 0.5f)
				{
					inputReady_updown = false;
					selectedIndex--;
					if (selectedIndex < 0)
					{
						selectedIndex = 0;
					}
				}
			}
			if (state == 2 && inputReady_leftRight)
			{
				if (Controller.UPvr_GetAxis2D(1).x > 0.5f)
				{
					inputReady_leftRight = false;
					pageIndex++;
					if (pageIndex > 4)
					{
						pageIndex = 4;
					}
				}
				else if (Controller.UPvr_GetAxis2D(1).x < -0.5f)
				{
					inputReady_leftRight = false;
					pageIndex--;
					if (pageIndex < 0)
					{
						pageIndex = 0;
					}
				}
				for (int j = 0; j < levelTexts.Length; j++)
				{
					if (LocalizationManager.CurrentLanguageCode == "zh")
					{
						levelTexts[j].text = "关卡 " + (j + pageIndex * 5 + 1);
					}
					else if (LocalizationManager.CurrentLanguageCode == "ja")
					{
						levelTexts[j].text = "レベル " + (j + pageIndex * 5 + 1);
					}
					else if (LocalizationManager.CurrentLanguageCode == "ko")
					{
						levelTexts[j].text = j + pageIndex * 5 + 1 + "레벨";
					}
					else
					{
						levelTexts[j].text = "Level " + (j + pageIndex * 5 + 1);
					}
				}
				for (int k = 0; k < levelLocks.Length; k++)
				{
					if (k == 0 && pageIndex == 0)
					{
						levelLocks[k].gameObject.SetActive(value: false);
					}
					else if (OVPlayerPrefs.GetFloat("HighScore" + (k - 1 + pageIndex * 5)) != 0f)
					{
						levelLocks[k].gameObject.SetActive(value: false);
					}
					else
					{
						levelLocks[k].gameObject.SetActive(value: true);
					}
				}
			}
			if (Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.B) || Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.Y) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.B) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.Y) || Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.APP) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.APP))
			{
				if (state == 1)
				{
					state = 0;
					selectedIndex = 0;
					languageMenu.SetActive(value: true);
					speedMenu.SetActive(value: false);
					levelMenu.SetActive(value: false);
				}
				else if (state == 2)
				{
					state = 1;
					selectedIndex = 0;
					languageMenu.SetActive(value: false);
					speedMenu.SetActive(value: true);
					levelMenu.SetActive(value: false);
				}
			}
			if (state == 0)
			{
				SpriteRenderer[] array = languageButtons;
				for (int l = 0; l < array.Length; l++)
				{
					array[l].color = Color.white;
				}
				languageButtons[selectedIndex].color = Color.yellow;
			}
			else if (state == 1)
			{
				SpriteRenderer[] array = speedButtons;
				for (int l = 0; l < array.Length; l++)
				{
					array[l].color = Color.white;
				}
				speedButtons[selectedIndex].color = Color.yellow;
			}
			else if (state == 2)
			{
				SpriteRenderer[] array = levelButtons;
				for (int l = 0; l < array.Length; l++)
				{
					array[l].color = Color.white;
				}
				levelButtons[selectedIndex].color = Color.yellow;
			}
			if (state == 2)
			{
				if (pageIndex == 0)
				{
					leftArrow.SetActive(value: false);
				}
				else
				{
					leftArrow.SetActive(value: true);
				}
				if (pageIndex == 4)
				{
					rightArrow.SetActive(value: false);
				}
				else
				{
					rightArrow.SetActive(value: true);
				}
			}
			if (Input.GetAxis(acceptAxisName) < 0.1f)
			{
				inputReady_accept = true;
			}
			if (Controller.UPvr_GetAxis2D(1).y < 0.1f && Controller.UPvr_GetAxis2D(1).y > -0.1f)
			{
				inputReady_updown = true;
			}
			if (Controller.UPvr_GetAxis2D(1).x < 0.1f && Controller.UPvr_GetAxis2D(1).x > -0.1f)
			{
				inputReady_leftRight = true;
			}
		}
	}
	public class EnableOne : MonoBehaviour
	{
		public GameObject[] objects;

		private void Start()
		{
			objects[UnityEngine.Random.Range(0, objects.Length)].SetActive(value: true);
		}
	}
	public class EpiTextureRandomizer : MonoBehaviour
	{
		public bool randomizeTexture;

		public Texture2D[] textures;

		public bool randomizeMaterial;

		public Material[] materials;

		private void Start()
		{
			if (randomizeTexture)
			{
				GetComponent<Renderer>().material.SetTexture("_MainTex", textures[UnityEngine.Random.Range(0, textures.Length)]);
			}
			if (randomizeMaterial)
			{
				GetComponent<Renderer>().material = materials[UnityEngine.Random.Range(0, materials.Length)];
			}
		}
	}
	public class PlayerPrefsManager : MonoBehaviour
	{
		[Button(null)]
		public void DeleteAll()
		{
			OVPlayerPrefs.DeleteAll();
		}
	}
	public class Rotate : MonoBehaviour
	{
		public float speed = 50f;

		private void Update()
		{
			base.transform.Rotate(Vector3.up, speed);
		}
	}
	public class TriggerActivator : MonoBehaviour
	{
		public new string tag = "Player";

		public bool onlyActivateOnButton;

		public UnityEvent collectTrigger;

		public UnityEvent onTriggerExit;

		private void OnTriggerEnter(Collider other)
		{
			if (other.tag == tag)
			{
				if (onlyActivateOnButton)
				{
					other.GetComponent<Player>().currentActivator = this;
				}
				else
				{
					Activate();
				}
			}
		}

		private void OnTriggerExit(Collider other)
		{
			if (other.tag == tag)
			{
				onTriggerExit.Invoke();
				if (onlyActivateOnButton)
				{
					other.GetComponent<Player>().currentActivator = null;
				}
			}
		}

		public void Activate()
		{
			collectTrigger.Invoke();
		}
	}
	public class Player : MonoBehaviour
	{
		public enum MenuState
		{
			Normal,
			InMenu
		}

		[Header("Input")]
		public string acceptAxisName;

		public string acceptAxisName_switch;

		public string updownAxisName;

		public string menuButtonName;

		public string editorAcceptBtnName;

		[Header("Representation")]
		public JetPack jetPackL;

		public JetPack jetPackR;

		public GameObject hud;

		public GameObject menu;

		public Image[] buttons;

		[HideInInspector]
		public MenuState menuState;

		private bool loading;

		private int selectedIndex;

		private bool inputReady_accept;

		private bool inputReady_updown;

		[HideInInspector]
		public TriggerActivator currentActivator;

		private void Start()
		{
			menuState = MenuState.Normal;
			menu.SetActive(value: false);
		}

		private void Update()
		{
			if (loading)
			{
				return;
			}
			if (Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.B) || Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.Y) || Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.APP) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.APP))
			{
				if (menuState == MenuState.Normal)
				{
					if (menu != null)
					{
						menu.SetActive(value: true);
					}
					if (hud != null)
					{
						hud.SetActive(value: false);
					}
					menuState = MenuState.InMenu;
					Time.timeScale = 0f;
				}
				else
				{
					if (menu != null)
					{
						menu.SetActive(value: false);
					}
					if (hud != null)
					{
						hud.SetActive(value: true);
					}
					menuState = MenuState.Normal;
					Time.timeScale = 1f;
				}
			}
			if (menuState != MenuState.InMenu)
			{
				return;
			}
			UnityEngine.Debug.LogError("PICO");
			if (Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.A) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TRIGGER))
			{
				inputReady_accept = false;
				if (selectedIndex == 0)
				{
					if (menu != null)
					{
						menu.SetActive(value: false);
					}
					if (hud != null)
					{
						hud.SetActive(value: true);
					}
					menuState = MenuState.Normal;
					Time.timeScale = 1f;
				}
				else if (selectedIndex == 1)
				{
					loading = true;
					Time.timeScale = 1f;
					SceneManager.LoadSceneAsync(SceneManager.GetActiveScene().buildIndex);
				}
				else if (selectedIndex == 2)
				{
					loading = true;
					Time.timeScale = 1f;
					SceneManager.LoadSceneAsync(0);
				}
			}
			if (inputReady_updown)
			{
				if (Controller.UPvr_GetAxis2D(1).y < -0.5f)
				{
					inputReady_updown = false;
					selectedIndex++;
					if (selectedIndex > 2)
					{
						selectedIndex = 2;
					}
				}
				else if (Controller.UPvr_GetAxis2D(1).y > 0.5f)
				{
					inputReady_updown = false;
					selectedIndex--;
					if (selectedIndex < 0)
					{
						selectedIndex = 0;
					}
				}
			}
			buttons[0].color = Color.white;
			buttons[1].color = Color.white;
			buttons[2].color = Color.white;
			buttons[selectedIndex].color = Color.yellow;
			if (Controller.UPvr_GetAxis2D(1).y < 0.1f && Controller.UPvr_GetAxis2D(1).y > -0.1f)
			{
				inputReady_updown = true;
			}
			if (Input.GetAxis(acceptAxisName) < 0.1f || Input.GetButtonUp(editorAcceptBtnName))
			{
				inputReady_accept = true;
			}
		}

		public void TriggerBoost()
		{
		}
	}
	public class CinemaController : MonoBehaviour
	{
		public GameObject text;

		public float textSpeed;

		public float delayBeforeText;

		public float delayBeforeSceneChange;

		private float counter;

		private bool used;

		private void Update()
		{
			float num = 1f;
			counter += Time.deltaTime;
			if (counter > delayBeforeText / num)
			{
				text.transform.position = text.transform.position + Vector3.up * textSpeed * num;
			}
			if (counter > delayBeforeSceneChange / num && !used)
			{
				used = true;
				SceneManager.LoadSceneAsync(0);
			}
		}
	}
	public class EpiAnimatorHelper : MonoBehaviour
	{
		public Animator[] animators;

		private void Update()
		{
			Animator[] array = animators;
			foreach (Animator animator in array)
			{
				if (animator.GetBool("FadeIn"))
				{
					animator.gameObject.SetActive(value: true);
				}
				else
				{
					animator.gameObject.SetActive(value: false);
				}
			}
		}
	}
	public class EpiLevelLoader : MonoBehaviour
	{
		public Animator fadeOver;

		public void LoadLevel(int ID)
		{
			FadeIn();
			StartCoroutine(LoadLevelAsync(ID, 1f));
		}

		public IEnumerator LoadLevelAsync(int ID, float delay)
		{
			yield return new WaitForSeconds(delay);
			UnityEngine.AsyncOperation AO = SceneManager.LoadSceneAsync(ID, LoadSceneMode.Single);
			AO.allowSceneActivation = false;
			while (AO.progress < 0.9f)
			{
				yield return null;
			}
			AO.allowSceneActivation = true;
		}

		public void FadeIn()
		{
			fadeOver.SetBool("FadeIn", value: true);
		}
	}
	public class EpiVRMenu : MonoBehaviour
	{
		[ReadOnly]
		public SelectionBox activeBox;

		public AudioMixer mainMixer;

		public Text volume;

		public Text sfx;

		public Text music;

		public Text quality;

		private int currentQuality;

		private void Start()
		{
		}

		private void Update()
		{
			if ((OVRInput.GetDown(OVRInput.Button.One, OVRInput.Controller.All) || Input.GetKeyDown(KeyCode.JoystickButton1) || Input.GetKeyDown(KeyCode.Joystick1Button1) || Input.GetAxis("PointerFingerR") > 0.3f || OVRInput.GetDown(OVRInput.Button.Two, OVRInput.Controller.RTouch)) && activeBox != null)
			{
				activeBox.Activate();
			}
		}

		public void LoadScene(int i)
		{
			SceneManager.LoadSceneAsync(i);
		}

		public void Quit()
		{
			Application.Quit();
		}

		public void Disable()
		{
			base.enabled = false;
		}

		public void ChangeVolume(float value)
		{
			float value2 = 0f;
			mainMixer.GetFloat("Volume", out value2);
			value2 += value;
			mainMixer.SetFloat("Volume", value2);
			volume.text = (100f + value2).ToString() ?? "";
		}

		public void ChangeSfx(float value)
		{
			float value2 = 0f;
			mainMixer.GetFloat("Sfx", out value2);
			value2 += value;
			mainMixer.SetFloat("Sfx", value2);
			sfx.text = (100f + value2).ToString() ?? "";
		}

		public void ChangeMusic(float value)
		{
			float value2 = 0f;
			mainMixer.GetFloat("Music", out value2);
			value2 += value;
			mainMixer.SetFloat("Music", value2);
			music.text = (100f + value2).ToString() ?? "";
		}

		public void ChangeQuality(int i)
		{
			currentQuality += i;
			if (currentQuality >= QualitySettings.names.Length)
			{
				currentQuality = 0;
			}
			else if (currentQuality < 0)
			{
				currentQuality = QualitySettings.names.Length - 1;
			}
			QualitySettings.SetQualityLevel(currentQuality);
			quality.text = QualitySettings.names[currentQuality];
		}
	}
	public class LanguageChanger : EpiGenericSingleton<LanguageChanger>
	{
		private bool languageSelected;

		private string language;

		public void ChooseLanguage(int i)
		{
			if (i == 0)
			{
				LocalizationManager.CurrentLanguageCode = "en";
				language = "en";
			}
			if (i == 1)
			{
				LocalizationManager.CurrentLanguageCode = "zh";
				language = "zh";
			}
			if (i == 2)
			{
				LocalizationManager.CurrentLanguageCode = "ja";
				language = "ja";
			}
			if (i == 3)
			{
				LocalizationManager.CurrentLanguageCode = "ko";
				language = "ko";
			}
			languageSelected = true;
		}
	}
	public class LanguageChangerProxy : MonoBehaviour
	{
		public void ChangeLanguage(int i)
		{
			UnityEngine.Object.FindObjectOfType<LanguageChanger>().ChooseLanguage(i);
		}
	}
	public class SelectionBox : MonoBehaviour
	{
		public EpiVRMenu controller;

		public string activationTag = "Selector";

		public bool onlyOnce;

		public UnityEvent hoverTrigger;

		public UnityEvent hoverExitTrigger;

		public UnityEvent clickTrigger;

		private bool used;

		private void OnTriggerEnter(Collider other)
		{
			if (other.tag == activationTag)
			{
				controller.activeBox = this;
				hoverTrigger.Invoke();
			}
		}

		private void OnTriggerExit(Collider other)
		{
			if (other.tag == activationTag)
			{
				if (controller.activeBox == this)
				{
					controller.activeBox = null;
				}
				hoverExitTrigger.Invoke();
			}
		}

		public void Activate()
		{
			if (!onlyOnce || (onlyOnce && !used))
			{
				used = true;
				clickTrigger.Invoke();
			}
		}
	}
	public class TestLevelLoading_Pico : MonoBehaviour
	{
		private bool used;

		private void Update()
		{
			if (!used)
			{
				if (Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.Y) || Input.GetKeyDown(KeyCode.N))
				{
					used = true;
					OVPlayerPrefs.SetInt("Level", OVPlayerPrefs.GetInt("Level") + 1);
					OVPlayerPrefs.Save();
					SceneManager.LoadSceneAsync(SceneManager.GetActiveScene().buildIndex);
				}
				else if (Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.X) || Input.GetKeyDown(KeyCode.R))
				{
					used = true;
					SceneManager.LoadSceneAsync(SceneManager.GetActiveScene().buildIndex);
				}
				else if (Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.Right))
				{
					used = true;
					SceneManager.LoadSceneAsync(1);
				}
			}
		}
	}
	public class RotationController : MonoBehaviour
	{
		public GameObject left;

		public GameObject right;

		public bool simulateMovement = true;

		public float movementSpeed = 1f;

		private void Start()
		{
		}

		private void Update()
		{
			float num = 1f;
			float num2 = 0f - Input.GetAxis("Vertical");
			float axis = Input.GetAxis("Horizontal");
			float num3 = 0f - Input.GetAxis("HorizontalRight");
			base.gameObject.transform.Rotate(new Vector3(num2 * num, axis * num, num3 * num));
			if (!simulateMovement)
			{
				return;
			}
			if (axis < -0.5f)
			{
				if (left.transform.localPosition.z < 1f)
				{
					left.transform.localPosition = left.transform.localPosition + Vector3.forward * movementSpeed * Time.deltaTime;
				}
				if (right.transform.localPosition.z > -1f)
				{
					right.transform.localPosition = right.transform.localPosition - Vector3.forward * movementSpeed * Time.deltaTime;
				}
			}
			else if (axis > 0.5f)
			{
				if (left.transform.localPosition.z > -1f)
				{
					left.transform.localPosition = left.transform.localPosition - Vector3.forward * movementSpeed * Time.deltaTime;
				}
				if (right.transform.localPosition.z < 1f)
				{
					right.transform.localPosition = right.transform.localPosition + Vector3.forward * movementSpeed * Time.deltaTime;
				}
			}
			else
			{
				if (left.transform.localPosition.z > 0.1f)
				{
					left.transform.localPosition = left.transform.localPosition - Vector3.forward * (movementSpeed / 3f) * Time.deltaTime;
				}
				if (left.transform.localPosition.z < 0.1f)
				{
					left.transform.localPosition = left.transform.localPosition + Vector3.forward * (movementSpeed / 3f) * Time.deltaTime;
				}
				if (right.transform.localPosition.z > 0.1f)
				{
					right.transform.localPosition = right.transform.localPosition - Vector3.forward * (movementSpeed / 3f) * Time.deltaTime;
				}
				if (right.transform.localPosition.z < 0.1f)
				{
					right.transform.localPosition = right.transform.localPosition + Vector3.forward * (movementSpeed / 3f) * Time.deltaTime;
				}
			}
			if (num2 > 0.5f)
			{
				if (left.transform.localPosition.x > -1f)
				{
					left.transform.localPosition = left.transform.localPosition - Vector3.right * movementSpeed * Time.deltaTime;
				}
				if (right.transform.localPosition.x > -1f)
				{
					right.transform.localPosition = right.transform.localPosition - Vector3.right * movementSpeed * Time.deltaTime;
				}
			}
			else if (num2 < -0.5f)
			{
				if (left.transform.localPosition.x < 1f)
				{
					left.transform.localPosition = left.transform.localPosition + Vector3.right * movementSpeed * Time.deltaTime;
				}
				if (right.transform.localPosition.x < 1f)
				{
					right.transform.localPosition = right.transform.localPosition + Vector3.right * movementSpeed * Time.deltaTime;
				}
			}
			else
			{
				if (left.transform.localPosition.x > 0.1f)
				{
					left.transform.localPosition = left.transform.localPosition - Vector3.right * (movementSpeed / 3f) * Time.deltaTime;
				}
				if (left.transform.localPosition.x < 0.1f)
				{
					left.transform.localPosition = left.transform.localPosition + Vector3.right * (movementSpeed / 3f) * Time.deltaTime;
				}
				if (right.transform.localPosition.x > 0.1f)
				{
					right.transform.localPosition = right.transform.localPosition - Vector3.right * (movementSpeed / 3f) * Time.deltaTime;
				}
				if (right.transform.localPosition.x < 0.1f)
				{
					right.transform.localPosition = right.transform.localPosition + Vector3.right * (movementSpeed / 3f) * Time.deltaTime;
				}
			}
			if (num3 > 0.5f || num3 < -0.5f)
			{
				if (left.transform.localPosition.y < 1f)
				{
					left.transform.localPosition = left.transform.localPosition + Vector3.up * movementSpeed * Time.deltaTime;
				}
				if (right.transform.localPosition.y > -1f)
				{
					right.transform.localPosition = right.transform.localPosition - Vector3.up * movementSpeed * Time.deltaTime;
				}
			}
			else
			{
				if (left.transform.localPosition.y > 0f)
				{
					left.transform.localPosition = left.transform.localPosition - Vector3.up * (movementSpeed / 3f) * Time.deltaTime;
				}
				if (right.transform.localPosition.y < 0f)
				{
					right.transform.localPosition = right.transform.localPosition + Vector3.up * (movementSpeed / 3f) * Time.deltaTime;
				}
			}
		}
	}
	public class EpiStickyFeed : MonoBehaviour
	{
		public PhysicMaterial normal;

		public PhysicMaterial sticky;

		private void OnTriggerEnter(Collider other)
		{
			if (other.GetComponent<Collider>() != null)
			{
				other.GetComponent<Collider>().material = sticky;
			}
		}

		private void OnTriggerExit(Collider other)
		{
			if (other.GetComponent<Collider>() != null)
			{
				other.GetComponent<Collider>().material = normal;
			}
		}
	}
	public class OVRAdditionalSettings : MonoBehaviour
	{
		public bool useFixedFiceatedRenderinglevels;

		private void Start()
		{
			if (useFixedFiceatedRenderinglevels)
			{
				OVRManager.fixedFoveatedRenderingLevel = OVRManager.FixedFoveatedRenderingLevel.High;
			}
		}
	}
	public class OVRDisablePP : MonoBehaviour
	{
		private void Start()
		{
			GetComponent<PostProcessLayer>().enabled = false;
		}
	}
	public class OculusController : MonoBehaviour
	{
		public GameObject controllerL;

		public GameObject controllerR;

		private bool lastInputFocus;

		private bool lastPresent;
	}
	public class OculusStarter : EpiGenericSingleton<OculusStarter>
	{
	}
	public class ViveModifier : MonoBehaviour
	{
		public GameObject cam;

		private void Start()
		{
			Invoke("AdjustHeight", 0.1f);
		}

		public void AdjustHeight()
		{
		}
	}
	public class ViveObjectExchanger : MonoBehaviour
	{
		public GameObject oculusObject;

		public GameObject viveObject;

		public void Start()
		{
			if (oculusObject != null)
			{
				oculusObject.SetActive(value: true);
			}
			if (viveObject != null)
			{
				viveObject.SetActive(value: false);
			}
		}
	}
	public class EpiAchievementsController_PS : EpiGenericSingleton<EpiAchievementsController_PS>
	{
		public void Unlock(string ID)
		{
			UnityEngine.Debug.Log("OVAchievementController_SWITCH is called but SWITCH was not defined as scripting define symbol in the player settings.");
		}
	}
	public class EpiAchievementsController_STEAM : EpiGenericSingleton<EpiAchievementsController_STEAM>
	{
		public void Unlock(string ID)
		{
			UnityEngine.Debug.Log("OVAchievement_PC is called but STEAM was not defined as scripting define symbol in the player settings.");
		}
	}
	public class EpiAchievementsController_SWITCH : EpiGenericSingleton<EpiAchievementsController_SWITCH>
	{
		public void Unlock(string ID)
		{
			UnityEngine.Debug.Log("OVAchievementController_SWITCH is called but SWITCH was not defined as scripting define symbol in the player settings.");
		}
	}
	public class EpiAchievementsController_XBOX : EpiGenericSingleton<EpiAchievementsController_XBOX>
	{
		private bool firstTime = true;

		private bool haveRequestedSignIn;

		private void Start()
		{
		}

		private bool SanityCheckApplicationSetup()
		{
			return true;
		}

		private void Update()
		{
		}

		public void Unlock(string ID)
		{
		}
	}
	public class EpiAchievement
	{
		public static void Unlock(string ID)
		{
			EpiGenericSingleton<EpiAchievementsController_STEAM>.Instance.Unlock(ID);
		}
	}
	public class EpiXboxLiveManager : EpiGenericSingleton<EpiXboxLiveManager>
	{
		private void Start()
		{
		}
	}
	public class InfoAttribute : PropertyAttribute
	{
	}
	public class ReadOnlyAttribute : PropertyAttribute
	{
	}
	[AddComponentMenu("WTF/OVNote")]
	public class EpiNote : MonoBehaviour
	{
		[Space(10f)]
		[SerializeField]
		[TextArea(7, 7)]
		private string note;

		[ContextMenu("Clear Text")]
		private void Clear()
		{
			note = "";
		}
	}
	public class EpiGenericSingleton<T> : MonoBehaviour where T : UnityEngine.Component
	{
		private static T instance;

		public static T Instance
		{
			get
			{
				if (instance == null)
				{
					instance = UnityEngine.Object.FindObjectOfType<T>();
					if (instance == null)
					{
						instance = new GameObject
						{
							name = typeof(T).Name
						}.AddComponent<T>();
					}
				}
				return instance;
			}
		}

		public virtual void Awake()
		{
			if (instance == null)
			{
				instance = this as T;
				UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
			}
			else
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}
	}
	public class FPSCounter : MonoBehaviour
	{
		[SerializeField]
		private Text _fpsText;

		[SerializeField]
		private float _hudRefreshRate = 1f;

		private float _timer;

		private void Update()
		{
			if (Time.unscaledTime > _timer)
			{
				int num = (int)(1f / Time.unscaledDeltaTime);
				_fpsText.text = "FPS: " + num;
				_timer = Time.unscaledTime + _hudRefreshRate;
			}
		}
	}
	public class WTFGenericSingleton<T> : MonoBehaviour where T : UnityEngine.Component
	{
		private static T instance;

		public static T Instance
		{
			get
			{
				if (instance == null)
				{
					instance = UnityEngine.Object.FindObjectOfType<T>();
					if (instance == null)
					{
						instance = new GameObject
						{
							name = typeof(T).Name
						}.AddComponent<T>();
					}
				}
				return instance;
			}
		}

		public virtual void Awake()
		{
			if (instance == null)
			{
				instance = this as T;
				UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
			}
			else
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}
	}
	public class EpiMenuController : EpiGenericSingleton<EpiMenuController>
	{
		public enum State
		{
			MainMenu,
			PauseMenu,
			NoMenu
		}

		private State state;

		public int firstScene;

		[Header("Event System")]
		public EventSystem eventSystem;

		public Animator loadingCanvas;

		public Animator mainMenuCanvas;

		public Animator pauseMenuCanvas;

		public GameObject firstMainMenuResponder;

		public GameObject firstPauseMenuResponder;

		[Header("Audio")]
		public AudioMixer mixer;

		public AudioSource hoverAudio;

		public AudioSource clickAudio;

		public Slider volumeSlider;

		public Slider sfxSlider;

		public Slider musicSlider;

		[Header("Resolution")]
		public Text resolutionText;

		public Text qualityText;

		private int currentResolution;

		private int currentQuality;

		[Header("Mouse Settings")]
		public Slider mouseSlider;

		public Toggle mouseInvertToggle;

		private void OnEnable()
		{
			SceneManager.sceneLoaded += OnSceneLoaded;
		}

		private void OnSceneLoaded(Scene scene, LoadSceneMode mode)
		{
			if (SceneManager.GetActiveScene().Equals(SceneManager.GetSceneByBuildIndex(firstScene)))
			{
				state = State.MainMenu;
				FadeIn(mainMenuCanvas);
				Select(firstMainMenuResponder);
			}
			else
			{
				state = State.NoMenu;
			}
			FadeOut(loadingCanvas);
		}

		private void Start()
		{
			Load();
			if (Input.GetJoystickNames().Length != 0)
			{
				eventSystem.GetComponent<StandaloneInputModule>().forceModuleActive = true;
				eventSystem.SetSelectedGameObject(firstMainMenuResponder);
			}
		}

		private void OnDisable()
		{
			SceneManager.sceneLoaded -= OnSceneLoaded;
		}

		private void Update()
		{
			if (pauseMenuCanvas.GetComponent<CanvasGroup>().alpha.Equals(0f))
			{
				loadingCanvas.GetComponent<CanvasGroup>().alpha.Equals(0f);
			}
			if (!SceneManager.GetActiveScene().Equals(SceneManager.GetSceneByBuildIndex(firstScene)) && (Input.GetKeyDown(KeyCode.Escape) || Input.GetKeyDown(KeyCode.JoystickButton7) || Input.GetKeyDown(KeyCode.Joystick1Button7)))
			{
				Pause();
				Resume();
			}
		}

		public void Load()
		{
			if (OVPlayerPrefs.GetInt("LAUNCHEDBEFORE") == 1)
			{
				SetSlider(volumeSlider, OVPlayerPrefs.GetFloat("VOLUME"));
				SetSlider(musicSlider, OVPlayerPrefs.GetFloat("MUSIC"));
				SetSlider(sfxSlider, OVPlayerPrefs.GetFloat("SFX"));
				currentResolution = OVPlayerPrefs.GetInt("RESOLUTION");
				currentQuality = OVPlayerPrefs.GetInt("QUALITY");
			}
			else
			{
				OVPlayerPrefs.SetInt("LAUNCHEDBEFORE", 1);
				SetSlider(volumeSlider, 0f);
				SetSlider(musicSlider, 0f);
				SetSlider(sfxSlider, 0f);
				OVPlayerPrefs.SetInt("RESOLUTION", Screen.resolutions.Length - 1);
				currentResolution = Screen.resolutions.Length - 1;
				OVPlayerPrefs.SetInt("QUALITY", Screen.resolutions.Length - 1);
				currentQuality = Screen.resolutions.Length - 1;
				OVPlayerPrefs.Save();
			}
			if (currentResolution >= Screen.resolutions.Length)
			{
				currentResolution = Screen.resolutions.Length - 1;
			}
			ChangeResolution(0);
			if (currentQuality >= QualitySettings.names.Length)
			{
				currentQuality = QualitySettings.names.Length - 1;
			}
			ChangeQuality(0);
		}

		public void SetSlider(Slider slider, float value)
		{
			slider.value = value;
		}

		public void SetVolume(float value)
		{
			mixer.SetFloat("Volume", value);
			OVPlayerPrefs.SetFloat("VOLUME", value);
			OVPlayerPrefs.Save();
		}

		public void SetSfx(float value)
		{
			mixer.SetFloat("Sfx", value);
			OVPlayerPrefs.SetFloat("SFX", value);
			OVPlayerPrefs.Save();
		}

		public void SetMusic(float value)
		{
			mixer.SetFloat("Music", value);
			OVPlayerPrefs.SetFloat("MUSIC", value);
			OVPlayerPrefs.Save();
		}

		public void SetMouseSens(float value)
		{
			OVPlayerPrefs.SetFloat("MOUSE", value);
			OVPlayerPrefs.Save();
		}

		public void SetMouseInvert(bool value)
		{
			int value2 = 0;
			if (value)
			{
				value2 = 1;
			}
			OVPlayerPrefs.SetInt("INVERT", value2);
			OVPlayerPrefs.Save();
		}

		public void ChangeResolution(int i)
		{
			currentResolution += i;
			if (currentResolution >= Screen.resolutions.Length)
			{
				currentResolution = 0;
			}
			else if (currentResolution < 0)
			{
				currentResolution = Screen.resolutions.Length - 1;
			}
			Screen.SetResolution(Screen.resolutions[currentResolution].width, Screen.resolutions[currentResolution].height, fullscreen: true);
			resolutionText.text = Screen.resolutions[currentResolution].ToString();
			OVPlayerPrefs.SetInt("RESOLUTION", currentResolution);
			OVPlayerPrefs.Save();
		}

		public void ChangeQuality(int i)
		{
			currentQuality += i;
			if (currentQuality >= QualitySettings.names.Length)
			{
				currentQuality = 0;
			}
			else if (currentQuality < 0)
			{
				currentQuality = QualitySettings.names.Length - 1;
			}
			QualitySettings.SetQualityLevel(currentQuality);
			qualityText.text = QualitySettings.names[currentQuality];
			OVPlayerPrefs.SetInt("QUALITY", currentQuality);
			OVPlayerPrefs.Save();
		}

		public void LoadLevel(int i)
		{
			FadeIn(loadingCanvas);
			Time.timeScale = 0f;
			SceneManager.LoadScene(i);
		}

		public void Quit(bool sure)
		{
			Application.Quit();
		}

		public void Resume()
		{
			if (pauseMenuCanvas.GetComponent<CanvasGroup>().alpha.Equals(1f))
			{
				Unselect();
				state = State.NoMenu;
				FadeOut(pauseMenuCanvas);
			}
		}

		public void Pause()
		{
			if (pauseMenuCanvas.GetComponent<CanvasGroup>().alpha.Equals(0f))
			{
				Select(firstPauseMenuResponder);
				state = State.PauseMenu;
				FadeIn(pauseMenuCanvas);
				Time.timeScale = 0f;
			}
		}

		private void StopKeyBlock(CanvasGroup canvasGroup)
		{
			canvasGroup.blocksRaycasts = false;
		}

		public void FadeIn(Animator animator)
		{
			animator.SetBool("FadeIn", value: true);
		}

		public void FadeOut(Animator animator)
		{
			animator.SetBool("FadeIn", value: false);
		}

		public void FadeInFirstMenu()
		{
			if (state == State.MainMenu)
			{
				FadeIn(mainMenuCanvas);
				Select(firstMainMenuResponder);
			}
			else
			{
				FadeIn(pauseMenuCanvas);
				Select(firstPauseMenuResponder);
			}
		}

		public void Unselect()
		{
			if (Input.GetJoystickNames().Length != 0)
			{
				BaseEventData eventData = new BaseEventData(eventSystem);
				if (eventSystem != null && eventSystem.currentSelectedGameObject != null && eventSystem.currentSelectedGameObject.GetComponent<Selectable>() != null)
				{
					eventSystem.currentSelectedGameObject.GetComponent<Selectable>().OnDeselect(eventData);
				}
			}
		}

		public void Select(GameObject g)
		{
			if (Input.GetJoystickNames().Length != 0)
			{
				Unselect();
				StartCoroutine(SelectDelayed(g));
			}
		}

		private IEnumerator SelectDelayed(GameObject g)
		{
			yield return new WaitForSeconds(0.05f);
			eventSystem.SetSelectedGameObject(g);
			BaseEventData eventData = new BaseEventData(eventSystem);
			g.GetComponent<Selectable>().OnSelect(eventData);
		}

		public void SetEventSystem(GameObject g)
		{
			eventSystem.SetSelectedGameObject(g);
		}

		public void PlayHoverSound()
		{
			if (!hoverAudio.isPlaying)
			{
				hoverAudio.Play();
			}
		}

		public void PlayClickSound()
		{
			if (!clickAudio.isPlaying)
			{
				clickAudio.Play();
			}
		}
	}
	public class EpiPlatformDependance : MonoBehaviour
	{
		[Header("Editor")]
		public bool editor;

		[Header("PC Setup")]
		public bool pc;

		public bool steam;

		[Header("Console Setup")]
		public bool xbox;

		public bool nintendoSwitch;

		public bool playstation;

		public bool uwp;

		[Header("VR Setup")]
		public bool oculus;

		public bool vive;

		public bool springboardvr;

		[Header("Mobile Setup")]
		public bool ios;

		public bool android;

		[Header("Additional Event Trigger")]
		public UnityEvent triggerEvents;

		private void Awake()
		{
			bool flag = false;
			base.gameObject.SetActive(flag);
			if (flag)
			{
				triggerEvents.Invoke();
			}
		}
	}
	public class EpiPlatformDependantSpawner : MonoBehaviour
	{
		public bool spawnOnAwake = true;

		[Header("Editor Setup")]
		public GameObject[] editor;

		[Header("PC Setup")]
		public GameObject[] pc;

		public GameObject[] steam;

		[Header("Console Setup")]
		public GameObject[] xbox;

		public GameObject[] nintendoSwitch;

		public GameObject[] playstation;

		public GameObject[] uwp;

		[Header("VR Setup")]
		public GameObject[] oculus;

		public GameObject[] vive;

		public GameObject[] springboardvr;

		[Header("Mobile Setup")]
		public GameObject[] ios;

		public GameObject[] android;

		private void Awake()
		{
			Spawn();
		}

		public void Spawn()
		{
			List<GameObject> list = new List<GameObject>();
			if (list.Count != 0)
			{
				foreach (GameObject item in list)
				{
					UnityEngine.Object.Instantiate(item, null).name = item.name;
				}
			}
			base.gameObject.SetActive(value: false);
		}
	}
	public class EpiPSInitializer : EpiGenericSingleton<EpiPSInitializer>
	{
		public override void Awake()
		{
			base.Awake();
			EpiPlayerPrefs.Initialize();
		}
	}
	public class EpiSwitchController : EpiGenericSingleton<EpiSwitchController>
	{
		private void Start()
		{
		}

		public void Save()
		{
		}

		public void Load()
		{
		}

		private void OnDestroy()
		{
		}
	}
	public static class EpiSwitchSaveManager
	{
		private static string buildTitle = "ASCENDANCE";

		private static string dataPath = Application.persistentDataPath + "/SavesDir/";

		private static bool loadedData = false;

		private static bool initialized = false;

		public static SaveData data = new SaveData();

		public static bool HasKey(string key)
		{
			bool result = false;
			if (data.SavedFloat.ContainsKey(key))
			{
				result = true;
			}
			if (data.SavedInt.ContainsKey(key))
			{
				result = true;
			}
			if (data.SavedString.ContainsKey(key))
			{
				result = true;
			}
			if (data.SavedBool.ContainsKey(key))
			{
				result = true;
			}
			if (data.SavedVector2.ContainsKey(key))
			{
				result = true;
			}
			if (data.SavedVector3.ContainsKey(key))
			{
				result = true;
			}
			if (data.SavedQuaternion.ContainsKey(key))
			{
				result = true;
			}
			if (data.SavedColor.ContainsKey(key))
			{
				result = true;
			}
			return result;
		}

		public static void Initialize()
		{
		}

		public static void Unmount()
		{
		}

		public static int GetInt(string key, int defaultValue = 0)
		{
			if (!initialized)
			{
				Initialize();
			}
			if (!loadedData)
			{
				LoadData();
			}
			int value = defaultValue;
			if (!data.SavedInt.TryGetValue(key, out value))
			{
				value = PlayerPrefs.GetInt(key, defaultValue);
			}
			return value;
		}

		public static float GetFloat(string key, float defaultValue = 0f)
		{
			if (!initialized)
			{
				Initialize();
			}
			if (!loadedData)
			{
				LoadData();
			}
			float value = defaultValue;
			if (!data.SavedFloat.TryGetValue(key, out value))
			{
				value = PlayerPrefs.GetFloat(key, defaultValue);
			}
			return value;
		}

		public static string GetString(string key, string defaultValue = "")
		{
			if (!initialized)
			{
				Initialize();
			}
			if (!loadedData)
			{
				LoadData();
			}
			string value = defaultValue;
			if (!data.SavedString.TryGetValue(key, out value))
			{
				value = PlayerPrefs.GetString(key, defaultValue);
			}
			return value;
		}

		public static bool GetBool(string key, bool defaultValue = false)
		{
			if (!initialized)
			{
				Initialize();
			}
			if (!loadedData)
			{
				LoadData();
			}
			bool value = defaultValue;
			data.SavedBool.TryGetValue(key, out value);
			return value;
		}

		public static Vector2 GetVector2(string key)
		{
			if (!initialized)
			{
				Initialize();
			}
			if (!loadedData)
			{
				LoadData();
			}
			Vector2 value = Vector2.zero;
			data.SavedVector2.TryGetValue(key, out value);
			return value;
		}

		public static Vector3 GetVector3(string key)
		{
			if (!initialized)
			{
				Initialize();
			}
			if (!loadedData)
			{
				LoadData();
			}
			Vector3 value = Vector3.zero;
			data.SavedVector3.TryGetValue(key, out value);
			return value;
		}

		public static Color GetColor(string key)
		{
			if (!initialized)
			{
				Initialize();
			}
			if (!loadedData)
			{
				LoadData();
			}
			Color value = Color.white;
			data.SavedColor.TryGetValue(key, out value);
			return value;
		}

		public static Quaternion GetQuaternion(string key)
		{
			if (!initialized)
			{
				Initialize();
			}
			if (!loadedData)
			{
				LoadData();
			}
			Quaternion value = Quaternion.identity;
			data.SavedQuaternion.TryGetValue(key, out value);
			return value;
		}

		public static void SetInt(string key, int setValue)
		{
			data.SavedInt[key] = setValue;
		}

		public static void SetFloat(string key, float setValue)
		{
			data.SavedFloat[key] = setValue;
		}

		public static void SetString(string key, string setValue)
		{
			data.SavedString[key] = setValue;
		}

		public static void SetBool(string key, bool setValue)
		{
			data.SavedBool[key] = setValue;
		}

		public static void SetVector2(string key, Vector2 setValue)
		{
			data.SavedVector2[key] = setValue;
		}

		public static void SetVector3(string key, Vector3 setValue)
		{
			data.SavedVector3[key] = setValue;
		}

		public static void SetQuaternion(string key, Quaternion setValue)
		{
			data.SavedQuaternion[key] = setValue;
		}

		public static void SetColor(string key, Color setValue)
		{
			data.SavedColor[key] = setValue;
		}

		public static void Save()
		{
		}

		public static void DeleteAll()
		{
			data.SavedInt.Clear();
			data.SavedFloat.Clear();
			data.SavedString.Clear();
			data.SavedBool.Clear();
			data.SavedVector2.Clear();
			data.SavedVector3.Clear();
			data.SavedQuaternion.Clear();
			data.SavedColor.Clear();
			Save();
		}

		public static bool LoadData()
		{
			loadedData = true;
			data.SavedInt.Clear();
			data.SavedFloat.Clear();
			data.SavedString.Clear();
			data.SavedBool.Clear();
			data.SavedVector2.Clear();
			data.SavedVector3.Clear();
			data.SavedQuaternion.Clear();
			data.SavedColor.Clear();
			UnityEngine.Debug.Log("Data Loaded");
			return true;
		}

		public static void DeleteKey(string keyToDel)
		{
			if (data.SavedInt.ContainsKey(keyToDel))
			{
				data.SavedInt.Remove(keyToDel);
			}
			if (data.SavedFloat.ContainsKey(keyToDel))
			{
				data.SavedFloat.Remove(keyToDel);
			}
			if (data.SavedString.ContainsKey(keyToDel))
			{
				data.SavedString.Remove(keyToDel);
			}
			if (data.SavedBool.ContainsKey(keyToDel))
			{
				data.SavedBool.Remove(keyToDel);
			}
			if (data.SavedVector2.ContainsKey(keyToDel))
			{
				data.SavedVector2.Remove(keyToDel);
			}
			if (data.SavedVector3.ContainsKey(keyToDel))
			{
				data.SavedVector3.Remove(keyToDel);
			}
			if (data.SavedQuaternion.ContainsKey(keyToDel))
			{
				data.SavedQuaternion.Remove(keyToDel);
			}
			if (data.SavedColor.ContainsKey(keyToDel))
			{
				data.SavedColor.Remove(keyToDel);
			}
		}
	}
	public class EpiSwitchUnmountHelper : EpiGenericSingleton<EpiSwitchUnmountHelper>
	{
		private void OnApplicationQuit()
		{
		}
	}
	public class EpiXboxSaveManager : EpiGenericSingleton<EpiXboxSaveManager>
	{
	}
	[Serializable]
	public class SaveData
	{
		public Dictionary<string, int> SavedInt = new Dictionary<string, int>();

		public Dictionary<string, float> SavedFloat = new Dictionary<string, float>();

		public Dictionary<string, string> SavedString = new Dictionary<string, string>();

		public Dictionary<string, bool> SavedBool = new Dictionary<string, bool>();

		public Dictionary<string, Vector2> SavedVector2 = new Dictionary<string, Vector2>();

		public Dictionary<string, Vector3> SavedVector3 = new Dictionary<string, Vector3>();

		public Dictionary<string, Quaternion> SavedQuaternion = new Dictionary<string, Quaternion>();

		public Dictionary<string, Color> SavedColor = new Dictionary<string, Color>();
	}
	public class EpiPlayerPrefs
	{
		private const string SaveFileName = "SavedGameData.txt";

		private const bool AutoSaveData = false;

		private static EpiPlayerPrefsSaveFile _latestData;

		private const string String_Empty = "";

		public static void DeleteID(string ID)
		{
			GetSaveFile().DeleteID(ID);
			SaveSaveFile();
		}

		public static void DeleteAll()
		{
			WriteToSaveFile(JsonUtility.ToJson(new EpiPlayerPrefsSaveFile()));
			_latestData = new EpiPlayerPrefsSaveFile();
		}

		public static void Initialize()
		{
		}

		public static bool HasID(string ID)
		{
			return GetSaveFile().HasKey(ID);
		}

		public static void OverwriteLocalSaveFile(string data)
		{
			WriteToSaveFile(data);
			_latestData = null;
			UnityEngine.Debug.Log("File Saved and overwritten: " + GetSaveFileAsJson());
		}

		public static void Save()
		{
			SaveSaveFile();
		}

		public static void SetInt(string ID, int value = 0)
		{
			AddDataToSaveFile(ID, value);
		}

		public static void AddInt(string ID, int value = 0)
		{
			AddDataToSaveFile(ID, GetInt(ID) + value);
		}

		public static int GetInt(string ID, int defaultValue = 0)
		{
			return (int)GetDataFromSaveFile(ID, defaultValue);
		}

		public static void SetFloat(string ID, float value = 0f)
		{
			AddDataToSaveFile(ID, value);
		}

		public static float GetFloat(string ID, float defaultValue = 0f)
		{
			return (float)GetDataFromSaveFile(ID, defaultValue);
		}

		public static void SetString(string ID, string value = "")
		{
			AddDataToSaveFile(ID, value);
		}

		public static string GetString(string ID, string defaultValue = "")
		{
			return (string)GetDataFromSaveFile(ID, defaultValue);
		}

		public static void SetBool(string ID, bool value = false)
		{
			AddDataToSaveFile(ID, value);
		}

		public static bool GetBool(string ID, bool defaultValue = false)
		{
			return (bool)GetDataFromSaveFile(ID, defaultValue);
		}

		public static void SetVector2(string ID, Vector2 vector)
		{
			SetFloatArray(ID, new float[2] { vector.x, vector.y });
		}

		public static Vector2 GetVector2(string ID)
		{
			float[] floatArray = GetFloatArray(ID, 2);
			return new Vector2(floatArray[0], floatArray[1]);
		}

		public static void SetVector3(string ID, Vector3 vector)
		{
			SetFloatArray(ID, new float[3] { vector.x, vector.y, vector.z });
		}

		public static Vector3 GetVector3(string ID)
		{
			float[] floatArray = GetFloatArray(ID, 3);
			return new Vector3(floatArray[0], floatArray[1], floatArray[2]);
		}

		public static void SetQuaternion(string ID, Quaternion vector)
		{
			SetFloatArray(ID, new float[4] { vector.x, vector.y, vector.z, vector.w });
		}

		public static Quaternion GetQuaternion(string ID)
		{
			float[] floatArray = GetFloatArray(ID, 4);
			return new Quaternion(floatArray[0], floatArray[1], floatArray[2], floatArray[3]);
		}

		public static void SetColor(string ID, Color color)
		{
			SetFloatArray(ID, new float[4] { color.r, color.g, color.b, color.a });
		}

		public static Color GetColor(string ID)
		{
			float[] floatArray = GetFloatArray(ID, 4);
			return new Color(floatArray[0], floatArray[1], floatArray[2], floatArray[3]);
		}

		private static void AddDataToSaveFile(string ID, object value)
		{
			GetSaveFile().UpdateOrAddData(ID, value);
			SaveSaveFile();
		}

		private static void SaveSaveFile()
		{
			WriteToSaveFile(JsonUtility.ToJson(GetSaveFile()));
			SendSaveData();
		}

		private static void SendSaveData()
		{
		}

		private static void WriteToSaveFile(string data)
		{
			StreamWriter streamWriter = new StreamWriter(GetSaveFilePath());
			streamWriter.Write(data);
			streamWriter.Close();
		}

		public static string GetSaveFilePath()
		{
			return Path.Combine(Application.persistentDataPath, "SavedGameData.txt");
		}

		public static string GetSaveFileAsJson()
		{
			CheckSaveFileExists();
			return File.ReadAllText(GetSaveFilePath());
		}

		private static EpiPlayerPrefsSaveFile GetSaveFile()
		{
			CheckSaveFileExists();
			if (_latestData == null)
			{
				_latestData = JsonUtility.FromJson<EpiPlayerPrefsSaveFile>(File.ReadAllText(GetSaveFilePath()));
			}
			return _latestData;
		}

		private static object GetDataFromSaveFile(string ID, object defaultValue)
		{
			return GetSaveFile().GetValueFromKey(ID, defaultValue);
		}

		private static void SetFloatArray(string ID, float[] floatArray)
		{
			for (int i = 0; i < floatArray.Length; i++)
			{
				SetFloat("FloatArray" + ID + i, floatArray[i]);
			}
		}

		private static float[] GetFloatArray(string ID, int length)
		{
			float[] array = new float[length];
			for (int i = 0; i < length; i++)
			{
				array[i] = GetFloat("FloatArray" + ID + i);
			}
			return array;
		}

		private static void CheckSaveFileExists()
		{
			if (!DoesSaveFileExist())
			{
				CreateNewSaveFile();
			}
		}

		private static bool DoesSaveFileExist()
		{
			return File.Exists(GetSaveFilePath());
		}

		private static void CreateNewSaveFile()
		{
			WriteToSaveFile(JsonUtility.ToJson(new EpiPlayerPrefsSaveFile()));
		}
	}
	[Serializable]
	public class EpiPlayerPrefsSaveFile
	{
		[Serializable]
		public class StringItem
		{
			public string Key;

			public string Value;

			public StringItem(string K, string V)
			{
				Key = K;
				Value = V;
			}
		}

		[Serializable]
		public class IntItem
		{
			public string Key;

			public int Value;

			public IntItem(string K, int V)
			{
				Key = K;
				Value = V;
			}
		}

		[Serializable]
		public class FloatItem
		{
			public string Key;

			public float Value;

			public FloatItem(string K, float V)
			{
				Key = K;
				Value = V;
			}
		}

		[Serializable]
		public class BoolItem
		{
			public string Key;

			public bool Value;

			public BoolItem(string K, bool V)
			{
				Key = K;
				Value = V;
			}
		}

		public StringItem[] StringData = new StringItem[0];

		public IntItem[] IntData = new IntItem[0];

		public FloatItem[] FloatData = new FloatItem[0];

		public BoolItem[] BoolData = new BoolItem[0];

		public object GetValueFromKey(string ID, object defaultValue)
		{
			if (defaultValue is string)
			{
				for (int i = 0; i < StringData.Length; i++)
				{
					if (StringData[i].Key.Equals(ID))
					{
						return StringData[i].Value;
					}
				}
			}
			if (defaultValue is int)
			{
				for (int j = 0; j < IntData.Length; j++)
				{
					if (IntData[j].Key.Equals(ID))
					{
						return IntData[j].Value;
					}
				}
			}
			if (defaultValue is float)
			{
				for (int k = 0; k < FloatData.Length; k++)
				{
					if (FloatData[k].Key.Equals(ID))
					{
						return FloatData[k].Value;
					}
				}
			}
			if (defaultValue is bool)
			{
				for (int l = 0; l < BoolData.Length; l++)
				{
					if (BoolData[l].Key.Equals(ID))
					{
						return BoolData[l].Value;
					}
				}
			}
			return defaultValue;
		}

		public void UpdateOrAddData(string ID, object value)
		{
			if (HasKeyFromObject(ID, value))
			{
				SetValueForExistingKey(ID, value);
			}
			else
			{
				SetValueForNewKey(ID, value);
			}
		}

		private void SetValueForNewKey(string ID, object value)
		{
			if (value is string)
			{
				List<StringItem> list = StringData.ToList();
				list.Add(new StringItem(ID, (string)value));
				StringData = list.ToArray();
			}
			if (value is int)
			{
				List<IntItem> list2 = IntData.ToList();
				list2.Add(new IntItem(ID, (int)value));
				IntData = list2.ToArray();
			}
			if (value is float)
			{
				List<FloatItem> list3 = FloatData.ToList();
				list3.Add(new FloatItem(ID, (float)value));
				FloatData = list3.ToArray();
			}
			if (value is bool)
			{
				List<BoolItem> list4 = BoolData.ToList();
				list4.Add(new BoolItem(ID, (bool)value));
				BoolData = list4.ToArray();
			}
		}

		private void SetValueForExistingKey(string ID, object value)
		{
			if (value is string)
			{
				for (int i = 0; i < StringData.Length; i++)
				{
					if (StringData[i].Key.Equals(ID))
					{
						StringData[i].Value = (string)value;
					}
				}
			}
			if (value is int)
			{
				for (int j = 0; j < IntData.Length; j++)
				{
					if (IntData[j].Key.Equals(ID))
					{
						IntData[j].Value = (int)value;
					}
				}
			}
			if (value is float)
			{
				for (int k = 0; k < FloatData.Length; k++)
				{
					if (FloatData[k].Key.Equals(ID))
					{
						FloatData[k].Value = (float)value;
					}
				}
			}
			if (!(value is bool))
			{
				return;
			}
			for (int l = 0; l < BoolData.Length; l++)
			{
				if (BoolData[l].Key.Equals(ID))
				{
					BoolData[l].Value = (bool)value;
				}
			}
		}

		public bool HasKeyFromObject(string ID, object value)
		{
			if (value is string)
			{
				for (int i = 0; i < StringData.Length; i++)
				{
					if (StringData[i].Key.Equals(ID))
					{
						return true;
					}
				}
			}
			if (value is int)
			{
				for (int j = 0; j < IntData.Length; j++)
				{
					if (IntData[j].Key.Equals(ID))
					{
						return true;
					}
				}
			}
			if (value is float)
			{
				for (int k = 0; k < FloatData.Length; k++)
				{
					if (FloatData[k].Key.Equals(ID))
					{
						return true;
					}
				}
			}
			if (value is bool)
			{
				for (int l = 0; l < BoolData.Length; l++)
				{
					if (BoolData[l].Key.Equals(ID))
					{
						return true;
					}
				}
			}
			return false;
		}

		public void DeleteID(string ID)
		{
			for (int i = 0; i < StringData.Length; i++)
			{
				if (StringData[i].Key.Equals(ID))
				{
					List<StringItem> list = StringData.ToList();
					list.RemoveAt(i);
					StringData = list.ToArray();
				}
			}
			for (int j = 0; j < IntData.Length; j++)
			{
				if (IntData[j].Key.Equals(ID))
				{
					List<IntItem> list2 = IntData.ToList();
					list2.RemoveAt(j);
					IntData = list2.ToArray();
				}
			}
			for (int k = 0; k < FloatData.Length; k++)
			{
				if (FloatData[k].Key.Equals(ID))
				{
					List<FloatItem> list3 = FloatData.ToList();
					list3.RemoveAt(k);
					FloatData = list3.ToArray();
				}
			}
			for (int l = 0; l < BoolData.Length; l++)
			{
				if (BoolData[l].Key.Equals(ID))
				{
					List<BoolItem> list4 = BoolData.ToList();
					list4.RemoveAt(l);
					BoolData = list4.ToArray();
				}
			}
		}

		public void DeleteString(string ID)
		{
			for (int i = 0; i < StringData.Length; i++)
			{
				if (StringData[i].Key.Equals(ID))
				{
					List<StringItem> list = StringData.ToList();
					list.RemoveAt(i);
					StringData = list.ToArray();
				}
			}
		}

		public void DeleteInt(string ID)
		{
			for (int i = 0; i < IntData.Length; i++)
			{
				if (IntData[i].Key.Equals(ID))
				{
					List<IntItem> list = IntData.ToList();
					list.RemoveAt(i);
					IntData = list.ToArray();
				}
			}
		}

		public void DeleteFloat(string ID)
		{
			for (int i = 0; i < FloatData.Length; i++)
			{
				if (FloatData[i].Key.Equals(ID))
				{
					List<FloatItem> list = FloatData.ToList();
					list.RemoveAt(i);
					FloatData = list.ToArray();
				}
			}
		}

		public void DeleteBool(string ID)
		{
			for (int i = 0; i < BoolData.Length; i++)
			{
				if (BoolData[i].Key.Equals(ID))
				{
					List<BoolItem> list = BoolData.ToList();
					list.RemoveAt(i);
					BoolData = list.ToArray();
				}
			}
		}

		public bool HasKey(string ID)
		{
			for (int i = 0; i < StringData.Length; i++)
			{
				if (StringData[i].Key.Equals(ID))
				{
					return true;
				}
			}
			for (int j = 0; j < IntData.Length; j++)
			{
				if (IntData[j].Key.Equals(ID))
				{
					return true;
				}
			}
			for (int k = 0; k < FloatData.Length; k++)
			{
				if (FloatData[k].Key.Equals(ID))
				{
					return true;
				}
			}
			for (int l = 0; l < BoolData.Length; l++)
			{
				if (BoolData[l].Key.Equals(ID))
				{
					return true;
				}
			}
			return false;
		}
	}
	public class WTFPlatformDependance : MonoBehaviour
	{
		[Header("Enable for following Platforms")]
		public bool editor;

		public bool standalone;

		public bool mobile;

		public bool consoles;

		[Header("Console Specific")]
		public bool xbox;

		public bool nintendoSwitch;

		public bool ps;

		private void Awake()
		{
			if (mobile)
			{
				base.gameObject.SetActive(value: true);
			}
			else
			{
				base.gameObject.SetActive(value: false);
			}
		}
	}
	public class WTFPlatformDependantSpawner : MonoBehaviour
	{
		public bool spawnOnAwake = true;

		[Header("Main Spawns")]
		public GameObject[] pc;

		public GameObject[] xbox;

		public GameObject[] nintendoSwitch;

		public GameObject[] playstation;

		public GameObject[] uwp;

		[Header("Additional PC Spawns")]
		public GameObject[] oculus;

		public GameObject[] vive;

		private void Awake()
		{
			Spawn();
		}

		public void Spawn()
		{
			GameObject[] array = pc;
			if (array.Length != 0)
			{
				GameObject[] array2 = array;
				foreach (GameObject gameObject in array2)
				{
					UnityEngine.Object.Instantiate(gameObject, null).name = gameObject.name;
				}
			}
			base.gameObject.SetActive(value: false);
		}
	}
	public class OVGenericSingleton<T> : MonoBehaviour where T : UnityEngine.Component
	{
		private static T instance;

		public static T Instance
		{
			get
			{
				if (instance == null)
				{
					instance = UnityEngine.Object.FindObjectOfType<T>();
					if (instance == null)
					{
						instance = new GameObject
						{
							name = typeof(T).Name
						}.AddComponent<T>();
					}
				}
				return instance;
			}
		}

		public virtual void Awake()
		{
			if (instance == null)
			{
				instance = this as T;
				UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
			}
			else
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}
	}
	public class OVAchievementsController_PS : OVGenericSingleton<OVAchievementsController_PS>
	{
		public void Unlock(string ID)
		{
			UnityEngine.Debug.Log("OVAchievementController_SWITCH is called but SWITCH was not defined as scripting define symbol in the player settings.");
		}
	}
	public class OVAchievementsController_STEAM : OVGenericSingleton<OVAchievementsController_STEAM>
	{
		public void Unlock(string ID)
		{
			UnityEngine.Debug.Log("OVAchievement_PC is called but STEAM was not defined as scripting define symbol in the player settings.");
		}
	}
	public class OVAchievementsController_SWITCH : OVGenericSingleton<OVAchievementsController_SWITCH>
	{
		public void Unlock(string ID)
		{
			UnityEngine.Debug.Log("OVAchievementController_SWITCH is called but SWITCH was not defined as scripting define symbol in the player settings.");
		}
	}
	public class OVAchievementsController_XBOX : OVGenericSingleton<OVAchievementsController_XBOX>
	{
		private bool firstTime = true;

		private bool haveRequestedSignIn;

		private void Start()
		{
		}

		private bool SanityCheckApplicationSetup()
		{
			return true;
		}

		private void Update()
		{
		}

		public void Unlock(string ID)
		{
		}
	}
	public class OVAchievement
	{
		public static void Unlock(string ID)
		{
			OVGenericSingleton<OVAchievementsController_STEAM>.Instance.Unlock(ID);
		}
	}
	public class OVEnums : MonoBehaviour
	{
		public enum DataType_PP
		{
			Integer,
			Float,
			String
		}

		public enum KeyType
		{
			Primary,
			Secondary,
			Controller
		}

		public enum TriggerType
		{
			OnAwake,
			OnStart,
			OnEnable,
			OnTriggerEnter,
			OnTriggerExit,
			OnCollisionEnter,
			OnCollisionExit,
			OnDisable,
			OnDestroy,
			OnSceneLoaded,
			ViaScript,
			ViaTriggerActivator
		}

		public enum ConditionEvaluationType
		{
			AnyCondition,
			AllConditions
		}

		public enum CurrencyConditionType
		{
			CheckForAmount,
			CheckAndSpendAmount
		}

		public enum NoteType
		{
			Idea,
			Info,
			Note,
			Question,
			TodoList,
			Task
		}

		public enum VelocityCalulation
		{
			GetFromRigidBody,
			CalculateVelocity
		}

		public enum FadeState
		{
			FadedOut,
			FadedIn
		}

		public enum LoadingOptions
		{
			LoadSavedLevelName,
			LoadNewLevelName
		}

		public enum LabelIcon
		{
			Gray,
			Blue,
			Teal,
			Green,
			Yellow,
			Orange,
			Red,
			Purple,
			None
		}

		public enum Icon
		{
			CircleGray,
			CircleBlue,
			CircleTeal,
			CircleGreen,
			CircleYellow,
			CircleOrange,
			CircleRed,
			CirclePurple,
			DiamondGray,
			DiamondBlue,
			DiamondTeal,
			DiamondGreen,
			DiamondYellow,
			DiamondOrange,
			DiamondRed,
			DiamondPurple,
			None
		}

		public enum Layout
		{
			Axis,
			Cube,
			Sphere,
			Mesh
		}

		public enum Axis
		{
			X,
			Y,
			Z
		}
	}
	public class OVStrings : MonoBehaviour
	{
		public static string MAXWEAPONS = "MaxWeapons";

		public static string UNLOCKED_PREFIX = "Unlocked";

		public static string UNLOCKNOW_PREFIX = "UnlockNow";

		public static string FINISHED_PREFIX = "Finished";

		public static string CLUSTER_PREFIX = "Cluster";

		public static string CURRENCYAMOUNT_PREFIX = "CurrencyAmount";

		public static string NEXTLEVEL = "NextLevelID";

		public static string PERSISTVALUE_PREFIX = "PersistValues";

		public static string FLOATARRAY_PREFIX = "FloatArray";
	}
	public class OVDisableHDR : MonoBehaviour
	{
		[Header("Console Specific")]
		public bool xbox;

		public bool nintendoSwitch;

		public bool ps;

		private void Awake()
		{
		}
	}
	public class OVPlatformDependance : MonoBehaviour
	{
		[Header("Enable for following Platforms")]
		public bool editor;

		public bool standalone;

		public bool mobile;

		public bool consoles;

		[Header("Console Specific")]
		public bool xbox;

		public bool nintendoSwitch;

		public bool ps;

		private void Awake()
		{
			if (mobile)
			{
				base.gameObject.SetActive(value: true);
			}
			else
			{
				base.gameObject.SetActive(value: false);
			}
		}
	}
	public class OVPlatformDependantSpawner : MonoBehaviour
	{
		public bool spawnOnAwake = true;

		public GameObject[] pc;

		public GameObject[] xbox;

		public GameObject[] nintendoSwitch;

		public GameObject[] playstation;

		private void Awake()
		{
			Spawn();
		}

		public void Spawn()
		{
			GameObject[] array = pc;
			if (array.Length != 0)
			{
				GameObject[] array2 = array;
				foreach (GameObject gameObject in array2)
				{
					UnityEngine.Object.Instantiate(gameObject, null).name = gameObject.name;
				}
			}
			base.gameObject.SetActive(value: false);
		}
	}
	public class OVPSInitializer : OVGenericSingleton<OVPSInitializer>
	{
		private void Start()
		{
			OVPlayerPrefs.Initialize();
		}
	}
	public static class SaveManager_SWITCH
	{
		private static string buildTitle = "ASCENDANCE";

		private static string dataPath = Application.persistentDataPath + "/SavesDir/";

		private static bool loadedData = false;

		private static bool initialized = false;

		public static SaveData data = new SaveData();

		public static bool HasKey(string key)
		{
			bool result = false;
			if (data.SavedFloat.ContainsKey(key))
			{
				result = true;
			}
			if (data.SavedInt.ContainsKey(key))
			{
				result = true;
			}
			if (data.SavedString.ContainsKey(key))
			{
				result = true;
			}
			if (data.SavedBool.ContainsKey(key))
			{
				result = true;
			}
			if (data.SavedVector2.ContainsKey(key))
			{
				result = true;
			}
			if (data.SavedVector3.ContainsKey(key))
			{
				result = true;
			}
			if (data.SavedQuaternion.ContainsKey(key))
			{
				result = true;
			}
			if (data.SavedColor.ContainsKey(key))
			{
				result = true;
			}
			return result;
		}

		public static void Initialize()
		{
		}

		public static void Unmount()
		{
		}

		public static int GetInt(string key, int defaultValue = 0)
		{
			if (!initialized)
			{
				Initialize();
			}
			if (!loadedData)
			{
				LoadData();
			}
			int value = defaultValue;
			if (!data.SavedInt.TryGetValue(key, out value))
			{
				value = PlayerPrefs.GetInt(key, defaultValue);
			}
			return value;
		}

		public static float GetFloat(string key, float defaultValue = 0f)
		{
			if (!initialized)
			{
				Initialize();
			}
			if (!loadedData)
			{
				LoadData();
			}
			float value = defaultValue;
			if (!data.SavedFloat.TryGetValue(key, out value))
			{
				value = PlayerPrefs.GetFloat(key, defaultValue);
			}
			return value;
		}

		public static string GetString(string key, string defaultValue = "")
		{
			if (!initialized)
			{
				Initialize();
			}
			if (!loadedData)
			{
				LoadData();
			}
			string value = defaultValue;
			if (!data.SavedString.TryGetValue(key, out value))
			{
				value = PlayerPrefs.GetString(key, defaultValue);
			}
			return value;
		}

		public static bool GetBool(string key, bool defaultValue = false)
		{
			if (!initialized)
			{
				Initialize();
			}
			if (!loadedData)
			{
				LoadData();
			}
			bool value = defaultValue;
			data.SavedBool.TryGetValue(key, out value);
			return value;
		}

		public static Vector2 GetVector2(string key)
		{
			if (!initialized)
			{
				Initialize();
			}
			if (!loadedData)
			{
				LoadData();
			}
			Vector2 value = Vector2.zero;
			data.SavedVector2.TryGetValue(key, out value);
			return value;
		}

		public static Vector3 GetVector3(string key)
		{
			if (!initialized)
			{
				Initialize();
			}
			if (!loadedData)
			{
				LoadData();
			}
			Vector3 value = Vector3.zero;
			data.SavedVector3.TryGetValue(key, out value);
			return value;
		}

		public static Color GetColor(string key)
		{
			if (!initialized)
			{
				Initialize();
			}
			if (!loadedData)
			{
				LoadData();
			}
			Color value = Color.white;
			data.SavedColor.TryGetValue(key, out value);
			return value;
		}

		public static Quaternion GetQuaternion(string key)
		{
			if (!initialized)
			{
				Initialize();
			}
			if (!loadedData)
			{
				LoadData();
			}
			Quaternion value = Quaternion.identity;
			data.SavedQuaternion.TryGetValue(key, out value);
			return value;
		}

		public static void SetInt(string key, int setValue)
		{
			data.SavedInt[key] = setValue;
		}

		public static void SetFloat(string key, float setValue)
		{
			data.SavedFloat[key] = setValue;
		}

		public static void SetString(string key, string setValue)
		{
			data.SavedString[key] = setValue;
		}

		public static void SetBool(string key, bool setValue)
		{
			data.SavedBool[key] = setValue;
		}

		public static void SetVector2(string key, Vector2 setValue)
		{
			data.SavedVector2[key] = setValue;
		}

		public static void SetVector3(string key, Vector3 setValue)
		{
			data.SavedVector3[key] = setValue;
		}

		public static void SetQuaternion(string key, Quaternion setValue)
		{
			data.SavedQuaternion[key] = setValue;
		}

		public static void SetColor(string key, Color setValue)
		{
			data.SavedColor[key] = setValue;
		}

		public static void Save()
		{
		}

		public static void DeleteAll()
		{
			data.SavedInt.Clear();
			data.SavedFloat.Clear();
			data.SavedString.Clear();
			data.SavedBool.Clear();
			data.SavedVector2.Clear();
			data.SavedVector3.Clear();
			data.SavedQuaternion.Clear();
			data.SavedColor.Clear();
			Save();
		}

		public static bool LoadData()
		{
			loadedData = true;
			data.SavedInt.Clear();
			data.SavedFloat.Clear();
			data.SavedString.Clear();
			data.SavedBool.Clear();
			data.SavedVector2.Clear();
			data.SavedVector3.Clear();
			data.SavedQuaternion.Clear();
			data.SavedColor.Clear();
			UnityEngine.Debug.Log("Data Loaded");
			return true;
		}

		public static void DeleteKey(string keyToDel)
		{
			if (data.SavedInt.ContainsKey(keyToDel))
			{
				data.SavedInt.Remove(keyToDel);
			}
			if (data.SavedFloat.ContainsKey(keyToDel))
			{
				data.SavedFloat.Remove(keyToDel);
			}
			if (data.SavedString.ContainsKey(keyToDel))
			{
				data.SavedString.Remove(keyToDel);
			}
			if (data.SavedBool.ContainsKey(keyToDel))
			{
				data.SavedBool.Remove(keyToDel);
			}
			if (data.SavedVector2.ContainsKey(keyToDel))
			{
				data.SavedVector2.Remove(keyToDel);
			}
			if (data.SavedVector3.ContainsKey(keyToDel))
			{
				data.SavedVector3.Remove(keyToDel);
			}
			if (data.SavedQuaternion.ContainsKey(keyToDel))
			{
				data.SavedQuaternion.Remove(keyToDel);
			}
			if (data.SavedColor.ContainsKey(keyToDel))
			{
				data.SavedColor.Remove(keyToDel);
			}
		}
	}
	public class OVPlayerPrefs
	{
		private const string SaveFileName = "SavedGameData.txt";

		private const bool AutoSaveData = false;

		private static OVPlayerPrefsSaveFile _latestData;

		private const string String_Empty = "";

		public static void DeleteID(string ID)
		{
			GetSaveFile().DeleteID(ID);
			SaveSaveFile();
		}

		public static void DeleteAll()
		{
			WriteToSaveFile(JsonUtility.ToJson(new OVPlayerPrefsSaveFile()));
			_latestData = new OVPlayerPrefsSaveFile();
		}

		public static void Initialize()
		{
		}

		public static bool HasID(string ID)
		{
			return GetSaveFile().HasKey(ID);
		}

		public static void OverwriteLocalSaveFile(string data)
		{
			WriteToSaveFile(data);
			_latestData = null;
			UnityEngine.Debug.Log("File Saved and overwritten: " + GetSaveFileAsJson());
		}

		public static void Save()
		{
			SaveSaveFile();
		}

		public static void SetInt(string ID, int value = 0)
		{
			AddDataToSaveFile(ID, value);
		}

		public static void AddInt(string ID, int value = 0)
		{
			AddDataToSaveFile(ID, GetInt(ID) + value);
		}

		public static int GetInt(string ID, int defaultValue = 0)
		{
			return (int)GetDataFromSaveFile(ID, defaultValue);
		}

		public static void SetFloat(string ID, float value = 0f)
		{
			AddDataToSaveFile(ID, value);
		}

		public static float GetFloat(string ID, float defaultValue = 0f)
		{
			return (float)GetDataFromSaveFile(ID, defaultValue);
		}

		public static void SetString(string ID, string value = "")
		{
			AddDataToSaveFile(ID, value);
		}

		public static string GetString(string ID, string defaultValue = "")
		{
			return (string)GetDataFromSaveFile(ID, defaultValue);
		}

		public static void SetBool(string ID, bool value = false)
		{
			AddDataToSaveFile(ID, value);
		}

		public static bool GetBool(string ID, bool defaultValue = false)
		{
			return (bool)GetDataFromSaveFile(ID, defaultValue);
		}

		public static void SetVector2(string ID, Vector2 vector)
		{
			SetFloatArray(ID, new float[2] { vector.x, vector.y });
		}

		public static Vector2 GetVector2(string ID)
		{
			float[] floatArray = GetFloatArray(ID, 2);
			return new Vector2(floatArray[0], floatArray[1]);
		}

		public static void SetVector3(string ID, Vector3 vector)
		{
			SetFloatArray(ID, new float[3] { vector.x, vector.y, vector.z });
		}

		public static Vector3 GetVector3(string ID)
		{
			float[] floatArray = GetFloatArray(ID, 3);
			return new Vector3(floatArray[0], floatArray[1], floatArray[2]);
		}

		public static void SetQuaternion(string ID, Quaternion vector)
		{
			SetFloatArray(ID, new float[4] { vector.x, vector.y, vector.z, vector.w });
		}

		public static Quaternion GetQuaternion(string ID)
		{
			float[] floatArray = GetFloatArray(ID, 4);
			return new Quaternion(floatArray[0], floatArray[1], floatArray[2], floatArray[3]);
		}

		public static void SetColor(string ID, Color color)
		{
			SetFloatArray(ID, new float[4] { color.r, color.g, color.b, color.a });
		}

		public static Color GetColor(string ID)
		{
			float[] floatArray = GetFloatArray(ID, 4);
			return new Color(floatArray[0], floatArray[1], floatArray[2], floatArray[3]);
		}

		private static void AddDataToSaveFile(string ID, object value)
		{
			GetSaveFile().UpdateOrAddData(ID, value);
			SaveSaveFile();
		}

		private static void SaveSaveFile()
		{
			WriteToSaveFile(JsonUtility.ToJson(GetSaveFile()));
			SendSaveData();
		}

		private static void SendSaveData()
		{
		}

		private static void WriteToSaveFile(string data)
		{
			StreamWriter streamWriter = new StreamWriter(GetSaveFilePath());
			streamWriter.Write(data);
			streamWriter.Close();
		}

		public static string GetSaveFilePath()
		{
			return Path.Combine(Application.persistentDataPath, "SavedGameData.txt");
		}

		public static string GetSaveFileAsJson()
		{
			CheckSaveFileExists();
			return File.ReadAllText(GetSaveFilePath());
		}

		private static OVPlayerPrefsSaveFile GetSaveFile()
		{
			CheckSaveFileExists();
			if (_latestData == null)
			{
				_latestData = JsonUtility.FromJson<OVPlayerPrefsSaveFile>(File.ReadAllText(GetSaveFilePath()));
			}
			return _latestData;
		}

		private static object GetDataFromSaveFile(string ID, object defaultValue)
		{
			return GetSaveFile().GetValueFromKey(ID, defaultValue);
		}

		private static void SetFloatArray(string ID, float[] floatArray)
		{
			for (int i = 0; i < floatArray.Length; i++)
			{
				SetFloat(OVStrings.FLOATARRAY_PREFIX + ID + i, floatArray[i]);
			}
		}

		private static float[] GetFloatArray(string ID, int length)
		{
			float[] array = new float[length];
			for (int i = 0; i < length; i++)
			{
				array[i] = GetFloat(OVStrings.FLOATARRAY_PREFIX + ID + i);
			}
			return array;
		}

		private static void CheckSaveFileExists()
		{
			if (!DoesSaveFileExist())
			{
				CreateNewSaveFile();
			}
		}

		private static bool DoesSaveFileExist()
		{
			return File.Exists(GetSaveFilePath());
		}

		private static void CreateNewSaveFile()
		{
			WriteToSaveFile(JsonUtility.ToJson(new OVPlayerPrefsSaveFile()));
		}
	}
	[Serializable]
	public class OVPlayerPrefsSaveFile
	{
		[Serializable]
		public class StringItem
		{
			public string Key;

			public string Value;

			public StringItem(string K, string V)
			{
				Key = K;
				Value = V;
			}
		}

		[Serializable]
		public class IntItem
		{
			public string Key;

			public int Value;

			public IntItem(string K, int V)
			{
				Key = K;
				Value = V;
			}
		}

		[Serializable]
		public class FloatItem
		{
			public string Key;

			public float Value;

			public FloatItem(string K, float V)
			{
				Key = K;
				Value = V;
			}
		}

		[Serializable]
		public class BoolItem
		{
			public string Key;

			public bool Value;

			public BoolItem(string K, bool V)
			{
				Key = K;
				Value = V;
			}
		}

		public StringItem[] StringData = new StringItem[0];

		public IntItem[] IntData = new IntItem[0];

		public FloatItem[] FloatData = new FloatItem[0];

		public BoolItem[] BoolData = new BoolItem[0];

		public object GetValueFromKey(string ID, object defaultValue)
		{
			if (defaultValue is string)
			{
				for (int i = 0; i < StringData.Length; i++)
				{
					if (StringData[i].Key.Equals(ID))
					{
						return StringData[i].Value;
					}
				}
			}
			if (defaultValue is int)
			{
				for (int j = 0; j < IntData.Length; j++)
				{
					if (IntData[j].Key.Equals(ID))
					{
						return IntData[j].Value;
					}
				}
			}
			if (defaultValue is float)
			{
				for (int k = 0; k < FloatData.Length; k++)
				{
					if (FloatData[k].Key.Equals(ID))
					{
						return FloatData[k].Value;
					}
				}
			}
			if (defaultValue is bool)
			{
				for (int l = 0; l < BoolData.Length; l++)
				{
					if (BoolData[l].Key.Equals(ID))
					{
						return BoolData[l].Value;
					}
				}
			}
			return defaultValue;
		}

		public void UpdateOrAddData(string ID, object value)
		{
			if (HasKeyFromObject(ID, value))
			{
				SetValueForExistingKey(ID, value);
			}
			else
			{
				SetValueForNewKey(ID, value);
			}
		}

		private void SetValueForNewKey(string ID, object value)
		{
			if (value is string)
			{
				List<StringItem> list = StringData.ToList();
				list.Add(new StringItem(ID, (string)value));
				StringData = list.ToArray();
			}
			if (value is int)
			{
				List<IntItem> list2 = IntData.ToList();
				list2.Add(new IntItem(ID, (int)value));
				IntData = list2.ToArray();
			}
			if (value is float)
			{
				List<FloatItem> list3 = FloatData.ToList();
				list3.Add(new FloatItem(ID, (float)value));
				FloatData = list3.ToArray();
			}
			if (value is bool)
			{
				List<BoolItem> list4 = BoolData.ToList();
				list4.Add(new BoolItem(ID, (bool)value));
				BoolData = list4.ToArray();
			}
		}

		private void SetValueForExistingKey(string ID, object value)
		{
			if (value is string)
			{
				for (int i = 0; i < StringData.Length; i++)
				{
					if (StringData[i].Key.Equals(ID))
					{
						StringData[i].Value = (string)value;
					}
				}
			}
			if (value is int)
			{
				for (int j = 0; j < IntData.Length; j++)
				{
					if (IntData[j].Key.Equals(ID))
					{
						IntData[j].Value = (int)value;
					}
				}
			}
			if (value is float)
			{
				for (int k = 0; k < FloatData.Length; k++)
				{
					if (FloatData[k].Key.Equals(ID))
					{
						FloatData[k].Value = (float)value;
					}
				}
			}
			if (!(value is bool))
			{
				return;
			}
			for (int l = 0; l < BoolData.Length; l++)
			{
				if (BoolData[l].Key.Equals(ID))
				{
					BoolData[l].Value = (bool)value;
				}
			}
		}

		public bool HasKeyFromObject(string ID, object value)
		{
			if (value is string)
			{
				for (int i = 0; i < StringData.Length; i++)
				{
					if (StringData[i].Key.Equals(ID))
					{
						return true;
					}
				}
			}
			if (value is int)
			{
				for (int j = 0; j < IntData.Length; j++)
				{
					if (IntData[j].Key.Equals(ID))
					{
						return true;
					}
				}
			}
			if (value is float)
			{
				for (int k = 0; k < FloatData.Length; k++)
				{
					if (FloatData[k].Key.Equals(ID))
					{
						return true;
					}
				}
			}
			if (value is bool)
			{
				for (int l = 0; l < BoolData.Length; l++)
				{
					if (BoolData[l].Key.Equals(ID))
					{
						return true;
					}
				}
			}
			return false;
		}

		public void DeleteID(string ID)
		{
			for (int i = 0; i < StringData.Length; i++)
			{
				if (StringData[i].Key.Equals(ID))
				{
					List<StringItem> list = StringData.ToList();
					list.RemoveAt(i);
					StringData = list.ToArray();
				}
			}
			for (int j = 0; j < IntData.Length; j++)
			{
				if (IntData[j].Key.Equals(ID))
				{
					List<IntItem> list2 = IntData.ToList();
					list2.RemoveAt(j);
					IntData = list2.ToArray();
				}
			}
			for (int k = 0; k < FloatData.Length; k++)
			{
				if (FloatData[k].Key.Equals(ID))
				{
					List<FloatItem> list3 = FloatData.ToList();
					list3.RemoveAt(k);
					FloatData = list3.ToArray();
				}
			}
			for (int l = 0; l < BoolData.Length; l++)
			{
				if (BoolData[l].Key.Equals(ID))
				{
					List<BoolItem> list4 = BoolData.ToList();
					list4.RemoveAt(l);
					BoolData = list4.ToArray();
				}
			}
		}

		public void DeleteString(string ID)
		{
			for (int i = 0; i < StringData.Length; i++)
			{
				if (StringData[i].Key.Equals(ID))
				{
					List<StringItem> list = StringData.ToList();
					list.RemoveAt(i);
					StringData = list.ToArray();
				}
			}
		}

		public void DeleteInt(string ID)
		{
			for (int i = 0; i < IntData.Length; i++)
			{
				if (IntData[i].Key.Equals(ID))
				{
					List<IntItem> list = IntData.ToList();
					list.RemoveAt(i);
					IntData = list.ToArray();
				}
			}
		}

		public void DeleteFloat(string ID)
		{
			for (int i = 0; i < FloatData.Length; i++)
			{
				if (FloatData[i].Key.Equals(ID))
				{
					List<FloatItem> list = FloatData.ToList();
					list.RemoveAt(i);
					FloatData = list.ToArray();
				}
			}
		}

		public void DeleteBool(string ID)
		{
			for (int i = 0; i < BoolData.Length; i++)
			{
				if (BoolData[i].Key.Equals(ID))
				{
					List<BoolItem> list = BoolData.ToList();
					list.RemoveAt(i);
					BoolData = list.ToArray();
				}
			}
		}

		public bool HasKey(string ID)
		{
			for (int i = 0; i < StringData.Length; i++)
			{
				if (StringData[i].Key.Equals(ID))
				{
					return true;
				}
			}
			for (int j = 0; j < IntData.Length; j++)
			{
				if (IntData[j].Key.Equals(ID))
				{
					return true;
				}
			}
			for (int k = 0; k < FloatData.Length; k++)
			{
				if (FloatData[k].Key.Equals(ID))
				{
					return true;
				}
			}
			for (int l = 0; l < BoolData.Length; l++)
			{
				if (BoolData[l].Key.Equals(ID))
				{
					return true;
				}
			}
			return false;
		}
	}
	namespace NaughtyAttributes
	{
		[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
		public class AllowNestingAttribute : DrawerAttribute
		{
		}
		public class DrawerAttribute : PropertyAttribute, INaughtyAttribute
		{
		}
		[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
		public class DropdownAttribute : DrawerAttribute
		{
			public string ValuesName { get; private set; }

			public DropdownAttribute(string valuesName)
			{
				ValuesName = valuesName;
			}
		}
		public interface IDropdownList : IEnumerable<KeyValuePair<string, object>>, IEnumerable
		{
		}
		public class DropdownList<T> : IDropdownList, IEnumerable<KeyValuePair<string, object>>, IEnumerable
		{
			private List<KeyValuePair<string, object>> _values;

			public DropdownList()
			{
				_values = new List<KeyValuePair<string, object>>();
			}

			public void Add(string displayName, T value)
			{
				_values.Add(new KeyValuePair<string, object>(displayName, value));
			}

			public IEnumerator<KeyValuePair<string, object>> GetEnumerator()
			{
				return _values.GetEnumerator();
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}

			public static explicit operator DropdownList<object>(DropdownList<T> target)
			{
				DropdownList<object> dropdownList = new DropdownList<object>();
				foreach (KeyValuePair<string, object> item in target)
				{
					dropdownList.Add(item.Key, item.Value);
				}
				return dropdownList;
			}
		}
		[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
		public class EnumFlagsAttribute : DrawerAttribute
		{
		}
		[AttributeUsage(AttributeTargets.Field, AllowMultiple = true, Inherited = true)]
		public class HorizontalLineAttribute : DrawerAttribute
		{
			public const float DefaultHeight = 2f;

			public const EColor DefaultColor = EColor.Gray;

			public float Height { get; private set; }

			public EColor Color { get; private set; }

			public HorizontalLineAttribute(float height = 2f, EColor color = EColor.Gray)
			{
				Height = height;
				Color = color;
			}
		}
		public enum EInfoBoxType
		{
			Normal,
			Warning,
			Error
		}
		[AttributeUsage(AttributeTargets.Field, AllowMultiple = true, Inherited = true)]
		public class InfoBoxAttribute : DrawerAttribute
		{
			public string Text { get; private set; }

			public EInfoBoxType Type { get; private set; }

			public InfoBoxAttribute(string text, EInfoBoxType type = EInfoBoxType.Normal)
			{
				Text = text;
				Type = type;
			}
		}
		[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
		public class InputAxisAttribute : DrawerAttribute
		{
		}
		[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
		public class MinMaxSliderAttribute : DrawerAttribute
		{
			public float MinValue { get; private set; }

			public float MaxValue { get; private set; }

			public MinMaxSliderAttribute(float minValue, float maxValue)
			{
				MinValue = minValue;
				MaxValue = maxValue;
			}
		}
		[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
		public class ProgressBarAttribute : DrawerAttribute
		{
			public string Name { get; private set; }

			public float MaxValue { get; private set; }

			public EColor Color { get; private set; }

			public ProgressBarAttribute(string name = "", float maxValue = 100f, EColor color = EColor.Blue)
			{
				Name = name;
				MaxValue = maxValue;
				Color = color;
			}
		}
		[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
		public class ReadOnlyAttribute : DrawerAttribute
		{
		}
		[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
		public class ResizableTextAreaAttribute : DrawerAttribute
		{
		}
		[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
		public class SceneAttribute : DrawerAttribute
		{
		}
		[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
		public class ShowAssetPreviewAttribute : DrawerAttribute
		{
			public int Width { get; private set; }

			public int Height { get; private set; }

			public ShowAssetPreviewAttribute(int width = 64, int height = 64)
			{
				Width = width;
				Height = height;
			}
		}
		[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
		public class TagAttribute : DrawerAttribute
		{
		}
		[AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = true)]
		public class ButtonAttribute : SpecialCaseDrawerAttribute
		{
			public string Text { get; private set; }

			public ButtonAttribute(string text = null)
			{
				Text = text;
			}
		}
		[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
		public class ReorderableListAttribute : SpecialCaseDrawerAttribute
		{
		}
		[AttributeUsage(AttributeTargets.Property, AllowMultiple = false, Inherited = true)]
		public class ShowNativePropertyAttribute : SpecialCaseDrawerAttribute
		{
		}
		[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
		public class ShowNonSerializedFieldAttribute : SpecialCaseDrawerAttribute
		{
		}
		public class SpecialCaseDrawerAttribute : Attribute, INaughtyAttribute
		{
		}
		public interface INaughtyAttribute
		{
		}
		[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
		public class BoxGroupAttribute : MetaAttribute
		{
			public string Name { get; private set; }

			public BoxGroupAttribute(string name = "")
			{
				Name = name;
			}
		}
		[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
		public class DisableIfAttribute : EnableIfAttributeBase
		{
			public DisableIfAttribute(string condition)
				: base(condition)
			{
				base.Inverted = true;
			}

			public DisableIfAttribute(EConditionOperator conditionOperator, params string[] conditions)
				: base(conditionOperator, conditions)
			{
				base.Inverted = true;
			}
		}
		[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
		public class EnableIfAttribute : EnableIfAttributeBase
		{
			public EnableIfAttribute(string condition)
				: base(condition)
			{
				base.Inverted = false;
			}

			public EnableIfAttribute(EConditionOperator conditionOperator, params string[] conditions)
				: base(conditionOperator, conditions)
			{
				base.Inverted = false;
			}
		}
		public abstract class EnableIfAttributeBase : MetaAttribute
		{
			public string[] Conditions { get; private set; }

			public EConditionOperator ConditionOperator { get; private set; }

			public bool Inverted { get; protected set; }

			public EnableIfAttributeBase(string condition)
			{
				ConditionOperator = EConditionOperator.And;
				Conditions = new string[1] { condition };
			}

			public EnableIfAttributeBase(EConditionOperator conditionOperator, params string[] conditions)
			{
				ConditionOperator = conditionOperator;
				Conditions = conditions;
			}
		}
		[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
		public class HideIfAttribute : ShowIfAttributeBase
		{
			public HideIfAttribute(string condition)
				: base(condition)
			{
				base.Inverted = true;
			}

			public HideIfAttribute(EConditionOperator conditionOperator, params string[] conditions)
				: base(conditionOperator, conditions)
			{
				base.Inverted = true;
			}
		}
		[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
		public class LabelAttribute : MetaAttribute
		{
			public string Label { get; private set; }

			public LabelAttribute(string label)
			{
				Label = label;
			}
		}
		public class MetaAttribute : Attribute, INaughtyAttribute
		{
		}
		[AttributeUsage(AttributeTargets.Field, AllowMultiple = true, Inherited = true)]
		public class OnValueChangedAttribute : MetaAttribute
		{
			public string CallbackName { get; private set; }

			public OnValueChangedAttribute(string callbackName)
			{
				CallbackName = callbackName;
			}
		}
		[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
		public class ShowIfAttribute : ShowIfAttributeBase
		{
			public ShowIfAttribute(string condition)
				: base(condition)
			{
				base.Inverted = false;
			}

			public ShowIfAttribute(EConditionOperator conditionOperator, params string[] conditions)
				: base(conditionOperator, conditions)
			{
				base.Inverted = false;
			}
		}
		public class ShowIfAttributeBase : MetaAttribute
		{
			public string[] Conditions { get; private set; }

			public EConditionOperator ConditionOperator { get; private set; }

			public bool Inverted { get; protected set; }

			public ShowIfAttributeBase(string condition)
			{
				ConditionOperator = EConditionOperator.And;
				Conditions = new string[1] { condition };
			}

			public ShowIfAttributeBase(EConditionOperator conditionOperator, params string[] conditions)
			{
				ConditionOperator = conditionOperator;
				Conditions = conditions;
			}
		}
		public enum EColor
		{
			White,
			Black,
			Gray,
			Red,
			Pink,
			Orange,
			Yellow,
			Green,
			Blue,
			Indigo,
			Violet
		}
		public static class EColorExtensions
		{
			public static Color GetColor(this EColor color)
			{
				return color switch
				{
					EColor.White => new Color32(byte.MaxValue, byte.MaxValue, byte.MaxValue, byte.MaxValue), 
					EColor.Black => new Color32(0, 0, 0, byte.MaxValue), 
					EColor.Gray => new Color32(128, 128, 128, byte.MaxValue), 
					EColor.Red => new Color32(byte.MaxValue, 0, 63, byte.MaxValue), 
					EColor.Pink => new Color32(byte.MaxValue, 152, 203, byte.MaxValue), 
					EColor.Orange => new Color32(byte.MaxValue, 128, 0, byte.MaxValue), 
					EColor.Yellow => new Color32(byte.MaxValue, 211, 0, byte.MaxValue), 
					EColor.Green => new Color32(98, 200, 79, byte.MaxValue), 
					EColor.Blue => new Color32(0, 135, 189, byte.MaxValue), 
					EColor.Indigo => new Color32(75, 0, 130, byte.MaxValue), 
					EColor.Violet => new Color32(128, 0, byte.MaxValue, byte.MaxValue), 
					_ => new Color32(0, 0, 0, byte.MaxValue), 
				};
			}
		}
		public enum EConditionOperator
		{
			And,
			Or
		}
		[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
		public class MaxValueAttribute : ValidatorAttribute
		{
			public float MaxValue { get; private set; }

			public MaxValueAttribute(float maxValue)
			{
				MaxValue = maxValue;
			}

			public MaxValueAttribute(int maxValue)
			{
				MaxValue = maxValue;
			}
		}
		[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
		public class MinValueAttribute : ValidatorAttribute
		{
			public float MinValue { get; private set; }

			public MinValueAttribute(float minValue)
			{
				MinValue = minValue;
			}

			public MinValueAttribute(int minValue)
			{
				MinValue = minValue;
			}
		}
		[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
		public class RequiredAttribute : ValidatorAttribute
		{
			public string Message { get; private set; }

			public RequiredAttribute(string message = null)
			{
				Message = message;
			}
		}
		[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
		public class ValidateInputAttribute : ValidatorAttribute
		{
			public string CallbackName { get; private set; }

			public string Message { get; private set; }

			public ValidateInputAttribute(string callbackName, string message = null)
			{
				CallbackName = callbackName;
				Message = message;
			}
		}
		public class ValidatorAttribute : Attribute, INaughtyAttribute
		{
		}
	}
	namespace NaughtyAttributes.Test
	{
		public class BoxGroupTest : MonoBehaviour
		{
			[BoxGroup("Integers")]
			public int int0;

			[BoxGroup("Integers")]
			public int int1;

			[BoxGroup("Floats")]
			public float float0;

			[BoxGroup("Floats")]
			public float float1;

			[BoxGroup("Sliders")]
			[MinMaxSlider(0f, 1f)]
			public Vector2 slider0;

			[BoxGroup("Sliders")]
			[MinMaxSlider(0f, 1f)]
			public Vector2 slider1;

			public string str0;

			public string str1;

			[BoxGroup("")]
			public Transform trans0;

			[BoxGroup("")]
			public Transform trans1;
		}
		public class ButtonTest : MonoBehaviour
		{
			public int myInt;

			[Button(null)]
			private void IncrementMyInt()
			{
				myInt++;
			}

			[Button("Decrement My Int")]
			private void DecrementMyInt()
			{
				myInt--;
			}
		}
		public class DisableIfTest : MonoBehaviour
		{
			public bool disable1;

			public bool disable2;

			[DisableIf(EConditionOperator.And, new string[] { "disable1", "disable2" })]
			[ReorderableList]
			public int[] disableIfAll;

			[DisableIf(EConditionOperator.Or, new string[] { "disable1", "disable2" })]
			[ReorderableList]
			public int[] disableIfAny;

			public DisableIfNest1 nest1;
		}
		[Serializable]
		public class DisableIfNest1
		{
			public bool disable1;

			public bool disable2;

			[DisableIf(EConditionOperator.And, new string[] { "Disable1", "Disable2" })]
			[AllowNesting]
			public int disableIfAll = 1;

			[DisableIf(EConditionOperator.Or, new string[] { "Disable1", "Disable2" })]
			[AllowNesting]
			public int disableIfAny = 2;

			public DisableIfNest2 nest2;

			public bool Disable1 => disable1;

			public bool Disable2 => disable2;
		}
		[Serializable]
		public class DisableIfNest2
		{
			public bool disable1;

			public bool disable2;

			[DisableIf(EConditionOperator.And, new string[] { "GetDisable1", "GetDisable2" })]
			[MinMaxSlider(0f, 1f)]
			public Vector2 enableIfAll = new Vector2(0.25f, 0.75f);

			[DisableIf(EConditionOperator.Or, new string[] { "GetDisable1", "GetDisable2" })]
			[MinMaxSlider(0f, 1f)]
			public Vector2 enableIfAny = new Vector2(0.25f, 0.75f);

			public bool GetDisable1()
			{
				return disable1;
			}

			public bool GetDisable2()
			{
				return disable2;
			}
		}
		public class DropdownTest : MonoBehaviour
		{
			[Dropdown("intValues")]
			public int intValue;

			private int[] intValues = new int[3] { 1, 2, 3 };

			public DropdownNest1 nest1;
		}
		[Serializable]
		public class DropdownNest1
		{
			[Dropdown("StringValues")]
			public string stringValue;

			public DropdownNest2 nest2;

			private List<string> StringValues => new List<string> { "A", "B", "C" };
		}
		[Serializable]
		public class DropdownNest2
		{
			[Dropdown("GetVectorValues")]
			public Vector3 vectorValue;

			private DropdownList<Vector3> GetVectorValues()
			{
				return new DropdownList<Vector3>
				{
					{
						"Right",
						Vector3.right
					},
					{
						"Up",
						Vector3.up
					},
					{
						"Forward",
						Vector3.forward
					}
				};
			}
		}
		public class EnableIfTest : MonoBehaviour
		{
			public bool enable1;

			public bool enable2;

			[EnableIf(EConditionOperator.And, new string[] { "enable1", "enable2" })]
			[ReorderableList]
			public int[] enableIfAll;

			[EnableIf(EConditionOperator.Or, new string[] { "enable1", "enable2" })]
			[ReorderableList]
			public int[] enableIfAny;

			public EnableIfNest1 nest1;
		}
		[Serializable]
		public class EnableIfNest1
		{
			public bool enable1;

			public bool enable2;

			[EnableIf(EConditionOperator.And, new string[] { "Enable1", "Enable2" })]
			[AllowNesting]
			public int enableIfAll = 1;

			[EnableIf(EConditionOperator.Or, new string[] { "Enable1", "Enable2" })]
			[AllowNesting]
			public int enableIfAny = 2;

			public EnableIfNest2 nest2;

			public bool Enable1 => enable1;

			public bool Enable2 => enable2;
		}
		[Serializable]
		public class EnableIfNest2
		{
			public bool enable1;

			public bool enable2;

			[EnableIf(EConditionOperator.And, new string[] { "GetEnable1", "GetEnable2" })]
			[MinMaxSlider(0f, 1f)]
			public Vector2 enableIfAll = new Vector2(0.25f, 0.75f);

			[EnableIf(EConditionOperator.Or, new string[] { "GetEnable1", "GetEnable2" })]
			[MinMaxSlider(0f, 1f)]
			public Vector2 enableIfAny = new Vector2(0.25f, 0.75f);

			public bool GetEnable1()
			{
				return enable1;
			}

			public bool GetEnable2()
			{
				return enable2;
			}
		}
		public enum TestEnum
		{
			None = 0,
			B = 1,
			C = 2,
			D = 4,
			E = 8,
			F = 16,
			All = -1
		}
		public class EnumFlagsTest : MonoBehaviour
		{
			[EnumFlags]
			public TestEnum flags0;

			public EnumFlagsNest1 nest1;
		}
		[Serializable]
		public class EnumFlagsNest1
		{
			[EnumFlags]
			public TestEnum flags1;

			public EnumFlagsNest2 nest2;
		}
		[Serializable]
		public class EnumFlagsNest2
		{
			[EnumFlags]
			public TestEnum flags2;
		}
		public class HideIfTest : MonoBehaviour
		{
			public bool hide1;

			public bool hide2;

			[HideIf(EConditionOperator.And, new string[] { "hide1", "hide2" })]
			[ReorderableList]
			public int[] hideIfAll;

			[HideIf(EConditionOperator.Or, new string[] { "hide1", "hide2" })]
			[ReorderableList]
			public int[] hideIfAny;

			public HideIfNest1 nest1;
		}
		[Serializable]
		public class HideIfNest1
		{
			public bool hide1;

			public bool hide2;

			[HideIf(EConditionOperator.And, new string[] { "Hide1", "Hide2" })]
			[AllowNesting]
			public int hideIfAll;

			[HideIf(EConditionOperator.Or, new string[] { "Hide1", "Hide2" })]
			[AllowNesting]
			public int hideIfAny;

			public HideIfNest2 nest2;

			public bool Hide1 => hide1;

			public bool Hide2 => hide2;
		}
		[Serializable]
		public class HideIfNest2
		{
			public bool hide1;

			public bool hide2;

			[HideIf(EConditionOperator.And, new string[] { "GetHide1", "GetHide2" })]
			[MinMaxSlider(0f, 1f)]
			public Vector2 hideIfAll = new Vector2(0.25f, 0.75f);

			[HideIf(EConditionOperator.Or, new string[] { "GetHide1", "GetHide2" })]
			[MinMaxSlider(0f, 1f)]
			public Vector2 hideIfAny = new Vector2(0.25f, 0.75f);

			public bool GetHide1()
			{
				return hide1;
			}

			public bool GetHide2()
			{
				return hide2;
			}
		}
		public class HorizontalLineTest : MonoBehaviour
		{
			[HorizontalLine(2f, EColor.Black)]
			[Header("Black")]
			[HorizontalLine(2f, EColor.Blue)]
			[Header("Blue")]
			[HorizontalLine(2f, EColor.Gray)]
			[Header("Gray")]
			[HorizontalLine(2f, EColor.Green)]
			[Header("Green")]
			[HorizontalLine(2f, EColor.Indigo)]
			[Header("Indigo")]
			[HorizontalLine(2f, EColor.Orange)]
			[Header("Orange")]
			[HorizontalLine(2f, EColor.Pink)]
			[Header("Pink")]
			[HorizontalLine(2f, EColor.Red)]
			[Header("Red")]
			[HorizontalLine(2f, EColor.Violet)]
			[Header("Violet")]
			[HorizontalLine(2f, EColor.White)]
			[Header("White")]
			[HorizontalLine(2f, EColor.Yellow)]
			[Header("Yellow")]
			[HorizontalLine(10f, EColor.Gray)]
			[Header("Thick")]
			public int line0;

			public HorizontalLineNest1 nest1;
		}
		[Serializable]
		public class HorizontalLineNest1
		{
			[HorizontalLine(2f, EColor.Gray)]
			public int line1;

			public HorizontalLineNest2 nest2;
		}
		[Serializable]
		public class HorizontalLineNest2
		{
			[HorizontalLine(2f, EColor.Gray)]
			public int line2;
		}
		public class InfoBoxTest : MonoBehaviour
		{
			[InfoBox("Normal", EInfoBoxType.Normal)]
			public int normal;

			public InfoBoxNest1 nest1;
		}
		[Serializable]
		public class InfoBoxNest1
		{
			[InfoBox("Warning", EInfoBoxType.Warning)]
			public int warning;

			public InfoBoxNest2 nest2;
		}
		[Serializable]
		public class InfoBoxNest2
		{
			[InfoBox("Error", EInfoBoxType.Error)]
			public int error;
		}
		public class InputAxisTest : MonoBehaviour
		{
			[InputAxis]
			public string inputAxis0;

			public InputAxisNest1 nest1;

			[Button(null)]
			private void LogInputAxis0()
			{
				UnityEngine.Debug.Log(inputAxis0);
			}
		}
		[Serializable]
		public class InputAxisNest1
		{
			[InputAxis]
			public string inputAxis1;

			public InputAxisNest2 nest2;
		}
		[Serializable]
		public struct InputAxisNest2
		{
			[InputAxis]
			public string inputAxis2;
		}
		public class LabelTest : MonoBehaviour
		{
			[Label("Label 0")]
			public int int0;

			public LabelNest1 nest1;
		}
		[Serializable]
		public class LabelNest1
		{
			[Label("Label 1")]
			[AllowNesting]
			public int int1;

			public LabelNest2 nest2;
		}
		[Serializable]
		public class LabelNest2
		{
			[Label("Label 2")]
			[MinMaxSlider(0f, 1f)]
			public Vector2 vector2;
		}
		public class MinMaxSliderTest : MonoBehaviour
		{
			[MinMaxSlider(0f, 1f)]
			public Vector2 minMaxSlider0 = new Vector2(0.25f, 0.75f);

			public MinMaxSliderNest1 nest1;
		}
		[Serializable]
		public class MinMaxSliderNest1
		{
			[MinMaxSlider(0f, 1f)]
			public Vector2 minMaxSlider1 = new Vector2(0.25f, 0.75f);

			public MinMaxSliderNest2 nest2;
		}
		[Serializable]
		public class MinMaxSliderNest2
		{
			[MinMaxSlider(0f, 1f)]
			public Vector2 minMaxSlider2 = new Vector2(0.25f, 0.75f);
		}
		public class MinMaxValueTest : MonoBehaviour
		{
			[MinValue(0)]
			public int min0;

			[MaxValue(0)]
			public int max0;

			[MinValue(0)]
			[MaxValue(1)]
			public float range01;

			public MinMaxValueNest1 nest1;
		}
		[Serializable]
		public class MinMaxValueNest1
		{
			[MinValue(0)]
			[AllowNesting]
			public int min0;

			[MaxValue(0)]
			[AllowNesting]
			public int max0;

			[MinValue(0)]
			[MaxValue(1)]
			[AllowNesting]
			public float range01;

			public MinMaxValueNest2 nest2;
		}
		[Serializable]
		public class MinMaxValueNest2
		{
			[MinValue(0)]
			[AllowNesting]
			public int min0;

			[MaxValue(0)]
			[AllowNesting]
			public int max0;

			[MinValue(0)]
			[MaxValue(1)]
			[AllowNesting]
			public float range01;
		}
		public class OnValueChangedTest : MonoBehaviour
		{
			[OnValueChanged("OnValueChangedMethod1")]
			[OnValueChanged("OnValueChangedMethod2")]
			public int int0;

			public OnValueChangedNest1 nest1;

			private void OnValueChangedMethod1(int oldValue, int newValue)
			{
				UnityEngine.Debug.LogFormat("First - old: {0}, new: {1}, int0: {2}", oldValue, newValue, int0);
			}

			private void OnValueChangedMethod2(int oldValue, int newValue)
			{
				UnityEngine.Debug.LogFormat("Second - old: {0}, new: {1}, int0: {2}", oldValue, newValue, int0);
			}
		}
		[Serializable]
		public class OnValueChangedNest1
		{
			[OnValueChanged("OnValueChangedMethod")]
			[AllowNesting]
			public int int1;

			public OnValueChangedNest2 nest2;

			private void OnValueChangedMethod(int oldValue, int newValue)
			{
				UnityEngine.Debug.LogFormat("old: {0}, new: {1}, int1: {2}", oldValue, newValue, int1);
			}
		}
		[Serializable]
		public class OnValueChangedNest2
		{
			[OnValueChanged("OnValueChangedMethod")]
			[AllowNesting]
			public int int2;

			private void OnValueChangedMethod(int oldValue, int newValue)
			{
				UnityEngine.Debug.LogFormat("old: {0}, new: {1}, int2: {2}", oldValue, newValue, int2);
			}
		}
		public class ProgressBarTest : MonoBehaviour
		{
			[ProgressBar("Health", 100f, EColor.Red)]
			public float health = 50f;

			public ProgressBarNest1 nest1;
		}
		[Serializable]
		public class ProgressBarNest1
		{
			[ProgressBar("Mana", 100f, EColor.Blue)]
			public float mana = 25f;

			public ProgressBarNest2 nest2;
		}
		[Serializable]
		public class ProgressBarNest2
		{
			[ProgressBar("Stamina", 100f, EColor.Green)]
			public float mana = 75f;
		}
		public class ReadOnlyTest : MonoBehaviour
		{
			[ReadOnly]
			public int readOnlyInt = 5;

			public ReadOnlyNest1 nest1;
		}
		[Serializable]
		public class ReadOnlyNest1
		{
			[ReadOnly]
			public float readOnlyFloat = 3.14f;

			public ReadOnlyNest2 nest2;
		}
		[Serializable]
		public struct ReadOnlyNest2
		{
			[ReadOnly]
			public string readOnlyString;
		}
		public class ReorderableListTest : MonoBehaviour
		{
			[ReorderableList]
			public int[] intArray;

			[ReorderableList]
			public List<Vector3> vectorList;

			[ReorderableList]
			public List<SomeStruct> structList;
		}
		[Serializable]
		public struct SomeStruct
		{
			public int Int;

			public float Float;

			public Vector3 Vector;
		}
		public class RequiredTest : MonoBehaviour
		{
			[Required(null)]
			public Transform trans0;

			public RequiredNest1 nest1;
		}
		[Serializable]
		public class RequiredNest1
		{
			[Required(null)]
			[AllowNesting]
			public Transform trans1;

			public RequiredNest2 nest2;
		}
		[Serializable]
		public class RequiredNest2
		{
			[Required("trans2 is invalid custom message - hohoho")]
			[AllowNesting]
			public Transform trans2;
		}
		public class ResizableTextAreaTest : MonoBehaviour
		{
			[ResizableTextArea]
			public string text0;

			public ResizableTextAreaNest1 nest1;
		}
		[Serializable]
		public class ResizableTextAreaNest1
		{
			[ResizableTextArea]
			public string text1;

			public ResizableTextAreaNest2 nest2;
		}
		[Serializable]
		public class ResizableTextAreaNest2
		{
			[ResizableTextArea]
			public string text2;
		}
		public class SceneTest : MonoBehaviour
		{
			[Scene]
			public string scene0;

			public SceneNest1 nest1;
		}
		[Serializable]
		public class SceneNest1
		{
			[Scene]
			public string scene1;

			public SceneNest2 nest2;
		}
		[Serializable]
		public struct SceneNest2
		{
			[Scene]
			public string scene2;
		}
		public class ShowAssetPreviewTest : MonoBehaviour
		{
			[ShowAssetPreview(64, 64)]
			public Sprite sprite0;

			[ShowAssetPreview(96, 96)]
			public GameObject prefab0;

			public ShowAssetPreviewNest1 nest1;
		}
		[Serializable]
		public class ShowAssetPreviewNest1
		{
			[ShowAssetPreview(64, 64)]
			public Sprite sprite1;

			[ShowAssetPreview(96, 96)]
			public GameObject prefab1;

			public ShowAssetPreviewNest2 nest2;
		}
		[Serializable]
		public class ShowAssetPreviewNest2
		{
			[ShowAssetPreview(64, 64)]
			public Sprite sprite2;

			[ShowAssetPreview(96, 96)]
			public GameObject prefab2;
		}
		public class ShowIfTest : MonoBehaviour
		{
			public bool show1;

			public bool show2;

			[ShowIf(EConditionOperator.And, new string[] { "show1", "show2" })]
			[ReorderableList]
			public int[] showIfAll;

			[ShowIf(EConditionOperator.Or, new string[] { "show1", "show2" })]
			[ReorderableList]
			public int[] showIfAny;

			public ShowIfNest1 nest1;
		}
		[Serializable]
		public class ShowIfNest1
		{
			public bool show1;

			public bool show2;

			[ShowIf(EConditionOperator.And, new string[] { "Show1", "Show2" })]
			[AllowNesting]
			public int showIfAll;

			[ShowIf(EConditionOperator.Or, new string[] { "Show1", "Show2" })]
			[AllowNesting]
			public int showIfAny;

			public ShowIfNest2 nest2;

			public bool Show1 => show1;

			public bool Show2 => show2;
		}
		[Serializable]
		public class ShowIfNest2
		{
			public bool show1;

			public bool show2;

			[ShowIf(EConditionOperator.And, new string[] { "GetShow1", "GetShow2" })]
			[MinMaxSlider(0f, 1f)]
			public Vector2 showIfAll = new Vector2(0.25f, 0.75f);

			[ShowIf(EConditionOperator.Or, new string[] { "GetShow1", "GetShow2" })]
			[MinMaxSlider(0f, 1f)]
			public Vector2 showIfAny = new Vector2(0.25f, 0.75f);

			public bool GetShow1()
			{
				return show1;
			}

			public bool GetShow2()
			{
				return show2;
			}
		}
		public class ShowNativePropertyTest : MonoBehaviour
		{
			[ShowNativeProperty]
			private Transform Transform => base.transform;

			[ShowNativeProperty]
			private Transform ParentTransform => base.transform.parent;
		}
		public class ShowNonSerializedFieldTest : MonoBehaviour
		{
			[ShowNonSerializedField]
			private int myInt = 10;

			[ShowNonSerializedField]
			private const float PI = 3.14159f;

			[ShowNonSerializedField]
			private static readonly Vector3 CONST_VECTOR = Vector3.one;
		}
		public class TagTest : MonoBehaviour
		{
			[Tag]
			public string tag0;

			public TagNest1 nest1;

			[Button(null)]
			private void LogTag0()
			{
				UnityEngine.Debug.Log(tag0);
			}
		}
		[Serializable]
		public class TagNest1
		{
			[Tag]
			public string tag1;

			public TagNest2 nest2;
		}
		[Serializable]
		public struct TagNest2
		{
			[Tag]
			public string tag2;
		}
		public class ValidateInputTest : MonoBehaviour
		{
			[ValidateInput("NotZero0", "int0 must not be zero")]
			public int int0;

			public ValidateInputNest1 nest1;

			private bool NotZero0(int value)
			{
				return value != 0;
			}
		}
		[Serializable]
		public class ValidateInputNest1
		{
			[ValidateInput("NotZero1", null)]
			[AllowNesting]
			public int int1;

			public ValidateInputNest2 nest2;

			private bool NotZero1(int value)
			{
				return value != 0;
			}
		}
		[Serializable]
		public class ValidateInputNest2
		{
			[ValidateInput("NotZero2", null)]
			[AllowNesting]
			public int int2;

			private bool NotZero2(int value)
			{
				return value != 0;
			}
		}
		public class _NaughtyComponent : MonoBehaviour
		{
			public bool flag0 = true;

			public bool flag1 = true;

			[BoxGroup("Sliders")]
			[MinMaxSlider(0f, 1f)]
			[ShowIf("flag0")]
			public Vector2 slider0;

			[BoxGroup("Sliders")]
			[MinMaxSlider(0f, 1f)]
			[ShowIf("flag1")]
			public Vector2 slider1;
		}
		public class _NaughtyScriptableObject : ScriptableObject
		{
			public int myInt;

			[Button(null)]
			private void IncrementMyInt()
			{
				myInt++;
			}

			[Button("Decrement My Int")]
			private void DecrementMyInt()
			{
				myInt--;
			}
		}
	}
	namespace Battlehub.UIControls
	{
		public delegate void ItemEventHandler(ItemContainer sender, PointerEventData eventData);
		[RequireComponent(typeof(RectTransform), typeof(LayoutElement))]
		public class ItemContainer : MonoBehaviour, IPointerDownHandler, IEventSystemHandler, IPointerUpHandler, IPointerEnterHandler, IPointerExitHandler, IBeginDragHandler, IDragHandler, IDropHandler, IEndDragHandler
		{
			public bool CanDrag = true;

			private LayoutElement m_layoutElement;

			private RectTransform m_rectTransform;

			private bool m_isSelected;

			public LayoutElement LayoutElement => m_layoutElement;

			public RectTransform RectTransform => m_rectTransform;

			public virtual bool IsSelected
			{
				get
				{
					return m_isSelected;
				}
				set
				{
					if (m_isSelected == value)
					{
						return;
					}
					m_isSelected = value;
					if (m_isSelected)
					{
						if (ItemContainer.Selected != null)
						{
							ItemContainer.Selected(this, EventArgs.Empty);
						}
					}
					else if (ItemContainer.Unselected != null)
					{
						ItemContainer.Unselected(this, EventArgs.Empty);
					}
				}
			}

			public object Item { get; set; }

			public static event EventHandler Selected;

			public static event EventHandler Unselected;

			public static event ItemEventHandler PointerDown;

			public static event ItemEventHandler PointerUp;

			public static event ItemEventHandler PointerEnter;

			public static event ItemEventHandler PointerExit;

			public static event ItemEventHandler BeginDrag;

			public static event ItemEventHandler Drag;

			public static event ItemEventHandler Drop;

			public static event ItemEventHandler EndDrag;

			private void Awake()
			{
				m_rectTransform = GetComponent<RectTransform>();
				m_layoutElement = GetComponent<LayoutElement>();
				AwakeOverride();
			}

			protected virtual void AwakeOverride()
			{
			}

			private void Start()
			{
				StartOverride();
			}

			protected virtual void StartOverride()
			{
			}

			void IPointerDownHandler.OnPointerDown(PointerEventData eventData)
			{
				if (ItemContainer.PointerDown != null)
				{
					ItemContainer.PointerDown(this, eventData);
				}
			}

			void IPointerUpHandler.OnPointerUp(PointerEventData eventData)
			{
				if (ItemContainer.PointerUp != null)
				{
					ItemContainer.PointerUp(this, eventData);
				}
			}

			void IBeginDragHandler.OnBeginDrag(PointerEventData eventData)
			{
				if (CanDrag && ItemContainer.BeginDrag != null)
				{
					ItemContainer.BeginDrag(this, eventData);
				}
			}

			void IDropHandler.OnDrop(PointerEventData eventData)
			{
				if (CanDrag && ItemContainer.Drop != null)
				{
					ItemContainer.Drop(this, eventData);
				}
			}

			void IDragHandler.OnDrag(PointerEventData eventData)
			{
				if (CanDrag && ItemContainer.Drag != null)
				{
					ItemContainer.Drag(this, eventData);
				}
			}

			void IEndDragHandler.OnEndDrag(PointerEventData eventData)
			{
				if (CanDrag && ItemContainer.EndDrag != null)
				{
					ItemContainer.EndDrag(this, eventData);
				}
			}

			void IPointerEnterHandler.OnPointerEnter(PointerEventData eventData)
			{
				if (ItemContainer.PointerEnter != null)
				{
					ItemContainer.PointerEnter(this, eventData);
				}
			}

			void IPointerExitHandler.OnPointerExit(PointerEventData eventData)
			{
				if (ItemContainer.PointerExit != null)
				{
					ItemContainer.PointerExit(this, eventData);
				}
			}
		}
		public enum ItemDropAction
		{
			None,
			SetLastChild,
			SetPrevSibling,
			SetNextSibling
		}
		[RequireComponent(typeof(RectTransform))]
		public class ItemDropMarker : MonoBehaviour
		{
			private Canvas m_parentCanvas;

			private ItemsControl m_itemsControl;

			public GameObject SiblingGraphics;

			private ItemDropAction m_action;

			private RectTransform m_rectTransform;

			private ItemContainer m_item;

			protected Canvas ParentCanvas => m_parentCanvas;

			public virtual ItemDropAction Action
			{
				get
				{
					return m_action;
				}
				set
				{
					m_action = value;
				}
			}

			public RectTransform RectTransform => m_rectTransform;

			protected ItemContainer Item => m_item;

			private void Awake()
			{
				m_rectTransform = GetComponent<RectTransform>();
				SiblingGraphics.SetActive(value: true);
				m_parentCanvas = GetComponentInParent<Canvas>();
				m_itemsControl = GetComponentInParent<ItemsControl>();
				AwakeOverride();
			}

			protected virtual void AwakeOverride()
			{
			}

			public virtual void SetTraget(ItemContainer item)
			{
				base.gameObject.SetActive(item != null);
				m_item = item;
				if (m_item == null)
				{
					Action = ItemDropAction.None;
				}
			}

			public virtual void SetPosition(Vector2 position)
			{
				if (m_item == null)
				{
					return;
				}
				RectTransform rectTransform = Item.RectTransform;
				Camera cam = null;
				if (ParentCanvas.renderMode == RenderMode.WorldSpace)
				{
					cam = m_itemsControl.Camera;
				}
				if (RectTransformUtility.ScreenPointToLocalPointInRectangle(rectTransform, position, cam, out var localPoint))
				{
					if (localPoint.y > (0f - rectTransform.rect.height) / 2f)
					{
						Action = ItemDropAction.SetPrevSibling;
						RectTransform.position = rectTransform.position;
					}
					else
					{
						Action = ItemDropAction.SetNextSibling;
						RectTransform.position = rectTransform.position - new Vector3(0f, rectTransform.rect.height, 0f);
					}
				}
			}
		}
		public class SelectionChangedEventArgs : EventArgs
		{
			public object[] OldItems { get; private set; }

			public object[] NewItems { get; private set; }

			public object OldItem
			{
				get
				{
					if (OldItems == null)
					{
						return null;
					}
					return OldItems[0];
				}
			}

			public object NewItem
			{
				get
				{
					if (NewItems == null)
					{
						return null;
					}
					return NewItems[0];
				}
			}

			public SelectionChangedEventArgs(object[] oldItems, object[] newItems)
			{
				OldItems = oldItems;
				NewItems = newItems;
			}

			public SelectionChangedEventArgs(object oldItem, object newItem)
			{
				OldItems = new object[1] { oldItem };
				NewItems = new object[1] { newItem };
			}
		}
		public class ItemAddEventArgs : EventArgs
		{
			public int Index { get; private set; }

			public ItemAddEventArgs(int index)
			{
				Index = index;
			}
		}
		public class ItemsRemovedArgs : EventArgs
		{
			public object[] Items { get; private set; }

			public ItemsRemovedArgs(object[] items)
			{
				Items = items;
			}
		}
		public class ItemDataBindingArgs : EventArgs
		{
			public object Item { get; set; }

			public GameObject ItemPresenter { get; set; }
		}
		public class ItemDragArgs : EventArgs
		{
			public object DragItem { get; private set; }

			public ItemDragArgs(object[] dragItem)
			{
				DragItem = dragItem;
			}
		}
		public class ItemDropArgs : EventArgs
		{
			public object[] DragItems { get; private set; }

			public object DropTarget { get; private set; }

			public ItemDropAction Action { get; private set; }

			public bool IsExternal { get; private set; }

			public ItemDropArgs(object[] dragItems, object dropTarget, ItemDropAction action, bool isExternal)
			{
				DragItems = dragItems;
				DropTarget = dropTarget;
				Action = action;
				IsExternal = isExternal;
			}
		}
		public class CancelEventArgs : EventArgs
		{
			public bool Cancel { get; set; }
		}
		public class ItemsControl : ItemsControl<ItemDataBindingArgs>
		{
		}
		public class ItemsControl<TDataBindingArgs> : MonoBehaviour, IPointerDownHandler, IEventSystemHandler, IDropHandler where TDataBindingArgs : ItemDataBindingArgs, new()
		{
			private enum ScrollDir
			{
				None,
				Up,
				Down,
				Left,
				Right
			}

			public KeyCode MultiselectKey = KeyCode.LeftControl;

			public KeyCode RangeselectKey = KeyCode.LeftShift;

			public KeyCode RemoveKey = KeyCode.Delete;

			private bool m_prevCanDrag;

			public bool CanDrag = true;

			private bool m_isDropInProgress;

			[SerializeField]
			private GameObject ItemContainerPrefab;

			public Transform Panel;

			private float m_width;

			private Canvas m_canvas;

			public Camera Camera;

			public float ScrollSpeed = 100f;

			private ScrollDir m_scrollDir;

			private ScrollRect m_scrollRect;

			private List<ItemContainer> m_itemContainers;

			private ItemDropMarker m_dropMarker;

			private ItemContainer m_dropTarget;

			private ItemContainer[] m_dragItems;

			private IList<object> m_items;

			private bool m_selectionLocked;

			private List<object> m_selectedItems;

			private ItemContainer m_selectedItem;

			private int m_selectedIndex = -1;

			public bool IsDropInProgress => m_isDropInProgress;

			protected ItemDropMarker DropMarker => m_dropMarker;

			public IEnumerable Items
			{
				get
				{
					return m_items;
				}
				set
				{
					m_items = value.OfType<object>().ToList();
					DataBind();
				}
			}

			public int ItemsCount
			{
				get
				{
					if (m_items == null)
					{
						return 0;
					}
					return m_items.Count;
				}
			}

			public int SelectedItemsCount
			{
				get
				{
					if (m_selectedItems == null)
					{
						return 0;
					}
					return m_selectedItems.Count;
				}
			}

			public IEnumerable SelectedItems
			{
				get
				{
					return m_selectedItems;
				}
				set
				{
					if (m_selectionLocked)
					{
						return;
					}
					m_selectionLocked = true;
					IList selectedItems = m_selectedItems;
					if (value != null)
					{
						m_selectedItems = value.OfType<object>().ToList();
						for (int num = m_selectedItems.Count - 1; num >= 0; num--)
						{
							object obj = m_selectedItems[num];
							ItemContainer itemContainer = GetItemContainer(obj);
							if (itemContainer == null)
							{
								m_selectedItems.Remove(obj);
							}
							else
							{
								itemContainer.IsSelected = true;
							}
						}
						if (m_selectedItems.Count == 0)
						{
							m_selectedItem = null;
							m_selectedIndex = -1;
						}
						else
						{
							m_selectedItem = GetItemContainer(m_selectedItems[0]);
							m_selectedIndex = IndexOf(m_selectedItem.Item);
						}
					}
					else
					{
						m_selectedItems = null;
						m_selectedItem = null;
						m_selectedIndex = -1;
					}
					List<object> list = new List<object>();
					if (selectedItems != null)
					{
						if (m_selectedItems != null)
						{
							for (int i = 0; i < selectedItems.Count; i++)
							{
								object obj2 = selectedItems[i];
								if (!m_selectedItems.Contains(obj2))
								{
									list.Add(obj2);
									GetItemContainer(obj2).IsSelected = false;
								}
							}
						}
						else
						{
							list.AddRange(selectedItems.OfType<object>());
						}
					}
					if (this.SelectionChanged != null)
					{
						object[] newItems = ((m_selectedItems == null) ? new object[0] : m_selectedItems.ToArray());
						this.SelectionChanged(this, new SelectionChangedEventArgs(list.ToArray(), newItems));
					}
					m_selectionLocked = false;
				}
			}

			public object SelectedItem
			{
				get
				{
					if (m_selectedItem == null)
					{
						return null;
					}
					return m_selectedItem.Item;
				}
				set
				{
					SelectedIndex = IndexOf(value);
				}
			}

			public int SelectedIndex
			{
				get
				{
					if (m_selectedItem == null)
					{
						return -1;
					}
					return m_selectedIndex;
				}
				set
				{
					if (m_selectedIndex == value)
					{
						return;
					}
					ItemContainer selectedItem = m_selectedItem;
					if (selectedItem != null)
					{
						selectedItem.IsSelected = false;
					}
					m_selectedIndex = value;
					object obj = null;
					if (m_selectedIndex >= 0 && m_selectedIndex < m_items.Count)
					{
						obj = m_items[m_selectedIndex];
						m_selectedItem = GetItemContainer(obj);
						if (m_selectedItem != null)
						{
							m_selectedItem.IsSelected = true;
						}
					}
					object[] array = ((obj == null) ? new object[0] : new object[1] { obj });
					object[] array2 = ((m_selectedItems == null) ? new object[0] : m_selectedItems.Except(array).ToArray());
					foreach (object obj2 in array2)
					{
						GetItemContainer(obj2).IsSelected = false;
					}
					m_selectedItems = array.ToList();
					if (this.SelectionChanged != null)
					{
						this.SelectionChanged(this, new SelectionChangedEventArgs(array2, array));
					}
				}
			}

			public event EventHandler<ItemDragArgs> ItemBeginDrag;

			public event EventHandler<ItemDropArgs> ItemDrop;

			public event EventHandler<ItemDragArgs> ItemEndDrag;

			public event EventHandler<TDataBindingArgs> ItemDataBinding;

			public event EventHandler<SelectionChangedEventArgs> SelectionChanged;

			public event EventHandler<ItemsRemovedArgs> ItemsRemoved;

			protected void RemoveItemAt(int index)
			{
				m_items.RemoveAt(index);
			}

			protected void RemoveItemContainerAt(int index)
			{
				m_itemContainers.RemoveAt(index);
			}

			protected void InsertItem(int index, object value)
			{
				m_items.Insert(index, value);
			}

			protected void InsertItemContainerAt(int index, ItemContainer container)
			{
				m_itemContainers.Insert(index, container);
			}

			public int IndexOf(object obj)
			{
				if (m_items == null)
				{
					return -1;
				}
				if (obj == null)
				{
					return -1;
				}
				return m_items.IndexOf(obj);
			}

			public ItemContainer GetItemContainer(object obj)
			{
				return m_itemContainers.Where((ItemContainer ic) => ic.Item == obj).FirstOrDefault();
			}

			public ItemContainer LastItemContainer()
			{
				if (m_itemContainers == null || m_itemContainers.Count == 0)
				{
					return null;
				}
				return m_itemContainers[m_itemContainers.Count - 1];
			}

			public ItemContainer GetItemContainer(int siblingIndex)
			{
				if (siblingIndex < 0 || siblingIndex >= m_itemContainers.Count)
				{
					return null;
				}
				return m_itemContainers[siblingIndex];
			}

			public ItemContainer Add(object item)
			{
				if (m_items == null)
				{
					m_items = new List<object>();
					m_itemContainers = new List<ItemContainer>();
				}
				return Insert(m_items.Count, item);
			}

			public ItemContainer Insert(int index, object item)
			{
				if (m_items == null)
				{
					m_items = new List<object>();
					m_itemContainers = new List<ItemContainer>();
				}
				object obj = m_items.ElementAtOrDefault(index);
				ItemContainer itemContainer = GetItemContainer(obj);
				int siblingIndex = ((!(itemContainer != null)) ? m_itemContainers.Count : m_itemContainers.IndexOf(itemContainer));
				m_items.Insert(index, item);
				itemContainer = InstantiateItemContainer(siblingIndex);
				if (itemContainer != null)
				{
					itemContainer.Item = item;
					DataBindItem(item, itemContainer);
				}
				return itemContainer;
			}

			public void Remove(object item)
			{
				if (item != null && m_items != null && m_items.Contains(item))
				{
					DestroyItem(item);
				}
			}

			public void RemoveAt(int index)
			{
				if (m_items != null)
				{
					if (index >= m_items.Count || index < 0)
					{
						throw new ArgumentOutOfRangeException("index");
					}
					Remove(m_items[index]);
				}
			}

			private void Awake()
			{
				if (Panel == null)
				{
					Panel = base.transform;
				}
				m_itemContainers = GetComponentsInChildren<ItemContainer>().ToList();
				m_dropMarker = GetComponentInChildren<ItemDropMarker>(includeInactive: true);
				m_scrollRect = GetComponent<ScrollRect>();
				if (Camera == null)
				{
					Camera = Camera.main;
				}
				m_prevCanDrag = CanDrag;
				OnCanDragChanged();
				AwakeOverride();
			}

			private void Start()
			{
				m_canvas = GetComponentInParent<Canvas>();
				StartOverride();
			}

			private void Update()
			{
				if (m_scrollDir != 0)
				{
					float num = m_scrollRect.content.rect.height - m_scrollRect.viewport.rect.height;
					float num2 = 0f;
					if (num > 0f)
					{
						num2 = ScrollSpeed / 10f * (1f / num);
					}
					float num3 = m_scrollRect.content.rect.width - m_scrollRect.viewport.rect.width;
					float num4 = 0f;
					if (num3 > 0f)
					{
						num4 = ScrollSpeed / 10f * (1f / num3);
					}
					if (m_scrollDir == ScrollDir.Up)
					{
						m_scrollRect.verticalNormalizedPosition += num2;
						if (m_scrollRect.verticalNormalizedPosition > 1f)
						{
							m_scrollRect.verticalNormalizedPosition = 1f;
							m_scrollDir = ScrollDir.None;
						}
					}
					else if (m_scrollDir == ScrollDir.Down)
					{
						m_scrollRect.verticalNormalizedPosition -= num2;
						if (m_scrollRect.verticalNormalizedPosition < 0f)
						{
							m_scrollRect.verticalNormalizedPosition = 0f;
							m_scrollDir = ScrollDir.None;
						}
					}
					else if (m_scrollDir == ScrollDir.Left)
					{
						m_scrollRect.horizontalNormalizedPosition -= num4;
						if (m_scrollRect.horizontalNormalizedPosition < 0f)
						{
							m_scrollRect.horizontalNormalizedPosition = 0f;
							m_scrollDir = ScrollDir.None;
						}
					}
					if (m_scrollDir == ScrollDir.Right)
					{
						m_scrollRect.horizontalNormalizedPosition += num4;
						if (m_scrollRect.horizontalNormalizedPosition > 1f)
						{
							m_scrollRect.horizontalNormalizedPosition = 1f;
							m_scrollDir = ScrollDir.None;
						}
					}
				}
				if (Input.GetKeyDown(RemoveKey))
				{
					DestroySelectedItems();
				}
				if (m_scrollRect.viewport.rect.width != m_width)
				{
					m_width = m_scrollRect.viewport.rect.width;
					if (m_itemContainers != null)
					{
						for (int i = 0; i < m_itemContainers.Count; i++)
						{
							ItemContainer itemContainer = m_itemContainers[i];
							if (itemContainer != null)
							{
								itemContainer.LayoutElement.minWidth = m_width;
							}
						}
					}
				}
				if (m_prevCanDrag != CanDrag)
				{
					OnCanDragChanged();
					m_prevCanDrag = CanDrag;
				}
				UpdateOverride();
			}

			private void OnEnable()
			{
				ItemContainer.Selected += OnItemSelected;
				ItemContainer.Unselected += OnItemUnselected;
				ItemContainer.PointerUp += OnItemPointerUp;
				ItemContainer.PointerDown += OnItemPointerDown;
				ItemContainer.PointerEnter += OnPointerEnter;
				ItemContainer.PointerExit += OnPointerExit;
				ItemContainer.BeginDrag += OnItemBeginDrag;
				ItemContainer.Drag += OnItemDrag;
				ItemContainer.Drop += OnItemDrop;
				ItemContainer.EndDrag += OnItemEndDrag;
				OnEnableOverride();
			}

			private void OnDisable()
			{
				ItemContainer.Selected -= OnItemSelected;
				ItemContainer.Unselected -= OnItemUnselected;
				ItemContainer.PointerUp -= OnItemPointerUp;
				ItemContainer.PointerDown -= OnItemPointerDown;
				ItemContainer.PointerEnter -= OnPointerEnter;
				ItemContainer.PointerExit -= OnPointerExit;
				ItemContainer.BeginDrag -= OnItemBeginDrag;
				ItemContainer.Drag -= OnItemDrag;
				ItemContainer.Drop -= OnItemDrop;
				ItemContainer.EndDrag -= OnItemEndDrag;
				OnDisableOverride();
			}

			protected virtual void AwakeOverride()
			{
			}

			protected virtual void StartOverride()
			{
			}

			protected virtual void UpdateOverride()
			{
			}

			protected virtual void OnEnableOverride()
			{
			}

			protected virtual void OnDisableOverride()
			{
			}

			private void OnCanDragChanged()
			{
				for (int i = 0; i < m_itemContainers.Count; i++)
				{
					ItemContainer itemContainer = m_itemContainers[i];
					if (itemContainer != null)
					{
						itemContainer.CanDrag = CanDrag;
					}
				}
			}

			protected bool CanHandleEvent(object sender)
			{
				ItemContainer itemContainer = sender as ItemContainer;
				if (!itemContainer)
				{
					return false;
				}
				return itemContainer.transform.IsChildOf(Panel);
			}

			private void OnItemSelected(object sender, EventArgs e)
			{
				if (!m_selectionLocked && CanHandleEvent(sender))
				{
					if (Input.GetKey(MultiselectKey))
					{
						IList list = ((m_selectedItems != null) ? m_selectedItems.ToList() : new List<object>());
						list.Add(((ItemContainer)sender).Item);
						SelectedItems = list;
					}
					else if (Input.GetKey(RangeselectKey))
					{
						SelectRange((ItemContainer)sender);
					}
					else
					{
						SelectedIndex = IndexOf(((ItemContainer)sender).Item);
					}
				}
			}

			private void SelectRange(ItemContainer itemContainer)
			{
				if (m_selectedItems != null && m_selectedItems.Count > 0)
				{
					List<object> list = new List<object>();
					int num = IndexOf(m_selectedItems[0]);
					object item = itemContainer.Item;
					int num2 = IndexOf(item);
					int num3 = Mathf.Min(num, num2);
					int num4 = Math.Max(num, num2);
					list.Add(m_selectedItems[0]);
					for (int i = num3; i < num; i++)
					{
						list.Add(m_items[i]);
					}
					for (int j = num + 1; j <= num4; j++)
					{
						list.Add(m_items[j]);
					}
					SelectedItems = list;
				}
				else
				{
					SelectedIndex = IndexOf(itemContainer.Item);
				}
			}

			private void OnItemUnselected(object sender, EventArgs e)
			{
				if (!m_selectionLocked && CanHandleEvent(sender))
				{
					IList list = ((m_selectedItems != null) ? m_selectedItems.ToList() : new List<object>());
					list.Remove(((ItemContainer)sender).Item);
					SelectedItems = list;
				}
			}

			private void OnItemPointerDown(ItemContainer sender, PointerEventData e)
			{
				if (CanHandleEvent(sender))
				{
					if (Input.GetKey(RangeselectKey))
					{
						SelectRange(sender);
					}
					else if (Input.GetKey(MultiselectKey))
					{
						sender.IsSelected = !sender.IsSelected;
					}
					else
					{
						sender.IsSelected = true;
					}
				}
			}

			private void OnItemPointerUp(ItemContainer sender, PointerEventData e)
			{
				if (CanHandleEvent(sender) && m_dragItems == null && !Input.GetKey(MultiselectKey) && !Input.GetKey(RangeselectKey) && m_selectedItems != null && m_selectedItems.Count > 1)
				{
					SelectedItem = sender.Item;
				}
			}

			private void OnPointerEnter(ItemContainer sender, PointerEventData eventData)
			{
				if (CanHandleEvent(sender))
				{
					m_dropTarget = sender;
					if (m_dragItems != null && m_scrollDir == ScrollDir.None)
					{
						m_dropMarker.SetTraget(m_dropTarget);
					}
				}
			}

			private void OnPointerExit(ItemContainer sender, PointerEventData eventData)
			{
				if (CanHandleEvent(sender))
				{
					m_dropTarget = null;
					if (m_dragItems != null)
					{
						m_dropMarker.SetTraget(null);
					}
				}
			}

			private void OnItemBeginDrag(ItemContainer sender, PointerEventData eventData)
			{
				eventData.Reset();
				if (!CanHandleEvent(sender))
				{
					return;
				}
				if (m_dropTarget != null)
				{
					m_dropMarker.SetTraget(m_dropTarget);
					m_dropMarker.SetPosition(eventData.position);
				}
				m_dragItems = GetDragItems();
				if (this.ItemBeginDrag != null)
				{
					this.ItemBeginDrag(this, new ItemDragArgs(m_dragItems.Select((ItemContainer di) => di.Item).ToArray()));
				}
			}

			private void OnItemDrag(ItemContainer sender, PointerEventData eventData)
			{
				if (!CanHandleEvent(sender))
				{
					return;
				}
				if (m_dropTarget != null)
				{
					m_dropMarker.SetPosition(eventData.position);
				}
				float height = m_scrollRect.viewport.rect.height;
				float width = m_scrollRect.viewport.rect.width;
				Camera cam = null;
				if (m_canvas.renderMode == RenderMode.WorldSpace)
				{
					cam = Camera;
				}
				if (RectTransformUtility.ScreenPointToLocalPointInRectangle(m_scrollRect.viewport, eventData.position, cam, out var localPoint))
				{
					if (localPoint.y >= 0f)
					{
						m_scrollDir = ScrollDir.Up;
						m_dropMarker.SetTraget(null);
					}
					else if (localPoint.y < 0f - height)
					{
						m_scrollDir = ScrollDir.Down;
						m_dropMarker.SetTraget(null);
					}
					else if (localPoint.x <= 0f)
					{
						m_scrollDir = ScrollDir.Left;
					}
					else if (localPoint.x >= width)
					{
						m_scrollDir = ScrollDir.Right;
					}
					else
					{
						m_scrollDir = ScrollDir.None;
					}
				}
			}

			private void OnItemDrop(ItemContainer sender, PointerEventData eventData)
			{
				if (!CanHandleEvent(sender))
				{
					return;
				}
				m_isDropInProgress = true;
				try
				{
					if (CanDrop(m_dragItems, m_dropTarget))
					{
						Drop(m_dragItems, m_dropTarget, m_dropMarker.Action);
						if (this.ItemDrop != null)
						{
							this.ItemDrop(this, new ItemDropArgs(m_dragItems.Select((ItemContainer di) => di.Item).ToArray(), m_dropTarget.Item, m_dropMarker.Action, isExternal: false));
						}
					}
					RaiseEndDrag();
				}
				finally
				{
					m_isDropInProgress = false;
				}
			}

			private void OnItemEndDrag(ItemContainer sender, PointerEventData eventData)
			{
				if (CanHandleEvent(sender))
				{
					RaiseEndDrag();
				}
			}

			private void RaiseEndDrag()
			{
				if (m_dragItems == null)
				{
					return;
				}
				if (this.ItemEndDrag != null)
				{
					this.ItemEndDrag(this, new ItemDragArgs(m_dragItems.Select((ItemContainer di) => di.Item).ToArray()));
				}
				m_dropMarker.SetTraget(null);
				m_dragItems = null;
				m_scrollDir = ScrollDir.None;
			}

			void IDropHandler.OnDrop(PointerEventData eventData)
			{
				if (m_dragItems == null)
				{
					GameObject pointerDrag = eventData.pointerDrag;
					if (!(pointerDrag != null))
					{
						return;
					}
					ItemContainer component = pointerDrag.GetComponent<ItemContainer>();
					if (component != null && component.Item != null)
					{
						object item = component.Item;
						if (this.ItemDrop != null)
						{
							this.ItemDrop(this, new ItemDropArgs(new object[1] { item }, null, ItemDropAction.SetLastChild, isExternal: true));
						}
					}
					return;
				}
				if (m_itemContainers != null && m_itemContainers.Count > 0)
				{
					m_dropTarget = m_itemContainers.Last();
					m_dropMarker.Action = ItemDropAction.SetNextSibling;
				}
				m_isDropInProgress = true;
				try
				{
					if (CanDrop(m_dragItems, m_dropTarget))
					{
						if (this.ItemDrop != null)
						{
							this.ItemDrop(this, new ItemDropArgs(m_dragItems.Select((ItemContainer di) => di.Item).ToArray(), m_dropTarget.Item, m_dropMarker.Action, isExternal: false));
						}
						Drop(m_dragItems, m_dropTarget, m_dropMarker.Action);
					}
					m_dropMarker.SetTraget(null);
					m_dragItems = null;
				}
				finally
				{
					m_isDropInProgress = false;
				}
			}

			void IPointerDownHandler.OnPointerDown(PointerEventData eventData)
			{
				SelectedIndex = -1;
			}

			protected virtual bool CanDrop(ItemContainer[] dragItems, ItemContainer dropTarget)
			{
				if (dropTarget == null)
				{
					return true;
				}
				if (dragItems == null)
				{
					return false;
				}
				if (dragItems.Contains(dropTarget.Item))
				{
					return false;
				}
				return true;
			}

			protected ItemContainer[] GetDragItems()
			{
				ItemContainer[] array = new ItemContainer[m_selectedItems.Count];
				if (m_selectedItems != null)
				{
					for (int i = 0; i < m_selectedItems.Count; i++)
					{
						array[i] = GetItemContainer(m_selectedItems[i]);
					}
				}
				return array.OrderBy((ItemContainer di) => di.transform.GetSiblingIndex()).ToArray();
			}

			protected virtual void DropItemAfter(ItemContainer dropTarget, ItemContainer dragItem)
			{
				int num = IndexOf(dragItem.Item);
				int num2 = IndexOf(dropTarget.Item);
				RemoveItemAt(num);
				if (num < num2)
				{
					num2--;
				}
				InsertItem(num2 + 1, dragItem.Item);
				int num3 = dropTarget.transform.GetSiblingIndex();
				int siblingIndex = dragItem.transform.GetSiblingIndex();
				RemoveItemContainerAt(siblingIndex);
				if (siblingIndex > num3)
				{
					num3++;
				}
				dragItem.transform.SetSiblingIndex(num3);
				InsertItemContainerAt(num3, dragItem);
			}

			protected virtual void DropItemBefore(ItemContainer dropTarget, ItemContainer dragItem)
			{
				int num = IndexOf(dragItem.Item);
				int num2 = IndexOf(dropTarget.Item);
				RemoveItemAt(num);
				if (num < num2)
				{
					num2--;
				}
				InsertItem(num2, dragItem.Item);
				int num3 = dropTarget.transform.GetSiblingIndex();
				int siblingIndex = dragItem.transform.GetSiblingIndex();
				RemoveItemContainerAt(siblingIndex);
				if (siblingIndex < num3)
				{
					num3--;
				}
				dragItem.transform.SetSiblingIndex(num3);
				InsertItemContainerAt(num3, dragItem);
			}

			protected virtual void Drop(ItemContainer[] dragItems, ItemContainer dropTarget, ItemDropAction action)
			{
				switch (action)
				{
				case ItemDropAction.SetPrevSibling:
					foreach (ItemContainer dragItem2 in dragItems)
					{
						DropItemBefore(dropTarget, dragItem2);
					}
					break;
				case ItemDropAction.SetNextSibling:
					foreach (ItemContainer dragItem in dragItems)
					{
						DropItemAfter(dropTarget, dragItem);
					}
					break;
				}
				UpdateSelectedItemIndex();
			}

			protected void UpdateSelectedItemIndex()
			{
				m_selectedIndex = IndexOf(SelectedItem);
			}

			protected virtual void DataBind()
			{
				m_itemContainers = GetComponentsInChildren<ItemContainer>().ToList();
				if (m_items == null)
				{
					for (int i = 0; i < m_itemContainers.Count; i++)
					{
						UnityEngine.Object.Destroy(m_itemContainers[i].gameObject);
					}
				}
				else
				{
					int num = m_items.Count - m_itemContainers.Count;
					if (num > 0)
					{
						for (int j = 0; j < num; j++)
						{
							InstantiateItemContainer(m_itemContainers.Count);
						}
					}
					else
					{
						int num2 = m_itemContainers.Count + num;
						for (int num3 = m_itemContainers.Count - 1; num3 >= num2; num3--)
						{
							DestroyItemContainer(num3);
						}
					}
				}
				for (int k = 0; k < m_items.Count; k++)
				{
					object item = m_items[k];
					ItemContainer itemContainer = m_itemContainers[k];
					itemContainer.CanDrag = CanDrag;
					if (itemContainer != null)
					{
						itemContainer.Item = item;
						DataBindItem(item, itemContainer);
					}
				}
			}

			protected virtual void DataBindItem(object item, ItemContainer itemContainer)
			{
				RaiseItemDataBinding(new TDataBindingArgs
				{
					Item = item,
					ItemPresenter = itemContainer.gameObject
				});
			}

			protected void RaiseItemDataBinding(TDataBindingArgs args)
			{
				if (this.ItemDataBinding != null)
				{
					this.ItemDataBinding(this, args);
				}
			}

			protected ItemContainer InstantiateItemContainer(int siblingIndex)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(ItemContainerPrefab);
				gameObject.name = "ItemContainer";
				gameObject.transform.SetParent(Panel, worldPositionStays: false);
				gameObject.transform.SetSiblingIndex(siblingIndex);
				ItemContainer itemContainer = InstantiateItemContainerOverride(gameObject);
				itemContainer.CanDrag = CanDrag;
				itemContainer.LayoutElement.minWidth = m_width;
				m_itemContainers.Insert(siblingIndex, itemContainer);
				return itemContainer;
			}

			protected void DestroyItemContainer(int siblingIndex)
			{
				if (m_itemContainers != null && siblingIndex >= 0 && siblingIndex < m_itemContainers.Count)
				{
					UnityEngine.Object.DestroyImmediate(m_itemContainers[siblingIndex].gameObject);
					m_itemContainers.RemoveAt(siblingIndex);
				}
			}

			protected virtual ItemContainer InstantiateItemContainerOverride(GameObject container)
			{
				ItemContainer itemContainer = container.GetComponent<ItemContainer>();
				if (itemContainer == null)
				{
					itemContainer = container.AddComponent<ItemContainer>();
				}
				return itemContainer;
			}

			private void DestroySelectedItems()
			{
				if (m_selectedItems == null)
				{
					return;
				}
				object[] array = m_selectedItems.ToArray();
				if (array.Length != 0)
				{
					SelectedItems = null;
					foreach (object item in array)
					{
						DestroyItem(item);
					}
					if (this.ItemsRemoved != null)
					{
						this.ItemsRemoved(this, new ItemsRemovedArgs(array));
					}
				}
			}

			protected virtual void DestroyItem(object item)
			{
				if (m_selectedItems != null && m_selectedItems.Contains(item))
				{
					m_selectedItems.Remove(item);
					if (m_selectedItems.Count == 0)
					{
						m_selectedItem = null;
						m_selectedIndex = -1;
					}
					else
					{
						m_selectedItem = GetItemContainer(m_selectedItems[0]);
						m_selectedIndex = IndexOf(m_selectedItem.Item);
					}
				}
				ItemContainer itemContainer = GetItemContainer(item);
				if (itemContainer != null)
				{
					int siblingIndex = itemContainer.transform.GetSiblingIndex();
					DestroyItemContainer(siblingIndex);
					m_items.Remove(item);
				}
			}
		}
		public class ListBox : ItemsControl
		{
		}
		public class ListBoxItem : ItemContainer
		{
			private Toggle m_toggle;

			public override bool IsSelected
			{
				get
				{
					return base.IsSelected;
				}
				set
				{
					if (base.IsSelected != value)
					{
						m_toggle.isOn = value;
						base.IsSelected = value;
					}
				}
			}

			protected override void AwakeOverride()
			{
				m_toggle = GetComponent<Toggle>();
				m_toggle.interactable = false;
				m_toggle.isOn = IsSelected;
			}
		}
		public class ItemExpandingArgs : EventArgs
		{
			public object Item { get; private set; }

			public IEnumerable Children { get; set; }

			public ItemExpandingArgs(object item)
			{
				Item = item;
			}
		}
		public class TreeViewItemDataBindingArgs : ItemDataBindingArgs
		{
			public bool HasChildren { get; set; }
		}
		public class TreeView : ItemsControl<TreeViewItemDataBindingArgs>
		{
			public int Indent = 20;

			private bool m_expandSilently;

			public event EventHandler<ItemExpandingArgs> ItemExpanding;

			protected override void OnEnableOverride()
			{
				base.OnEnableOverride();
				TreeViewItem.ParentChanged += OnTreeViewItemParentChanged;
			}

			protected override void OnDisableOverride()
			{
				base.OnDisableOverride();
				TreeViewItem.ParentChanged -= OnTreeViewItemParentChanged;
			}

			public void AddChild(object parent, object item)
			{
				if (parent == null)
				{
					Add(item);
					return;
				}
				TreeViewItem treeViewItem = (TreeViewItem)GetItemContainer(parent);
				if (treeViewItem == null)
				{
					return;
				}
				int num = -1;
				if (treeViewItem.IsExpanded)
				{
					if (treeViewItem.HasChildren)
					{
						TreeViewItem treeViewItem2 = treeViewItem.LastChild();
						num = IndexOf(treeViewItem2.Item) + 1;
					}
					else
					{
						num = IndexOf(treeViewItem.Item) + 1;
					}
				}
				else
				{
					treeViewItem.CanExpand = true;
				}
				if (num > -1)
				{
					((TreeViewItem)Insert(num, item)).Parent = treeViewItem;
				}
			}

			public void ChangeParent(object parent, object item)
			{
				if (base.IsDropInProgress)
				{
					return;
				}
				ItemContainer itemContainer = GetItemContainer(item);
				if (!(itemContainer == null))
				{
					ItemContainer itemContainer2 = GetItemContainer(parent);
					ItemContainer[] dragItems = new ItemContainer[1] { itemContainer };
					if (CanDrop(dragItems, itemContainer2))
					{
						Drop(dragItems, itemContainer2, ItemDropAction.SetLastChild);
					}
				}
			}

			public void Expand(TreeViewItem item)
			{
				if (m_expandSilently || this.ItemExpanding == null)
				{
					return;
				}
				ItemExpandingArgs itemExpandingArgs = new ItemExpandingArgs(item.Item);
				this.ItemExpanding(this, itemExpandingArgs);
				IEnumerable children = itemExpandingArgs.Children;
				int num = item.transform.GetSiblingIndex();
				int num2 = IndexOf(item.Item);
				item.CanExpand = children != null;
				if (!item.CanExpand)
				{
					return;
				}
				foreach (object item2 in children)
				{
					num++;
					num2++;
					TreeViewItem treeViewItem = (TreeViewItem)InstantiateItemContainer(num);
					treeViewItem.Parent = item;
					treeViewItem.Item = item2;
					InsertItem(num2, item2);
					DataBindItem(item2, treeViewItem);
				}
				UpdateSelectedItemIndex();
			}

			public void Collapse(TreeViewItem item)
			{
				int siblingIndex = item.transform.GetSiblingIndex();
				int num = IndexOf(item.Item);
				if (base.SelectedItems != null)
				{
					List<object> selectedItems = base.SelectedItems.OfType<object>().ToList();
					int containerIndex = siblingIndex + 1;
					int itemIndex = num + 1;
					Unselect(selectedItems, item, ref containerIndex, ref itemIndex);
					base.SelectedItems = selectedItems;
				}
				Collapse(item, siblingIndex + 1, num + 1);
			}

			private void Unselect(List<object> selectedItems, TreeViewItem item, ref int containerIndex, ref int itemIndex)
			{
				while (true)
				{
					TreeViewItem treeViewItem = (TreeViewItem)GetItemContainer(containerIndex);
					if (!(treeViewItem == null) && !(treeViewItem.Parent != item))
					{
						containerIndex++;
						itemIndex++;
						selectedItems.Remove(treeViewItem.Item);
						Unselect(selectedItems, treeViewItem, ref containerIndex, ref itemIndex);
						continue;
					}
					break;
				}
			}

			private void Collapse(TreeViewItem item, int containerIndex, int itemIndex)
			{
				while (true)
				{
					TreeViewItem treeViewItem = (TreeViewItem)GetItemContainer(containerIndex);
					if (!(treeViewItem == null) && !(treeViewItem.Parent != item))
					{
						Collapse(treeViewItem, containerIndex + 1, itemIndex + 1);
						RemoveItemAt(itemIndex);
						DestroyItemContainer(containerIndex);
						continue;
					}
					break;
				}
			}

			protected override ItemContainer InstantiateItemContainerOverride(GameObject container)
			{
				TreeViewItem treeViewItem = container.GetComponent<TreeViewItem>();
				if (treeViewItem == null)
				{
					treeViewItem = container.AddComponent<TreeViewItem>();
					treeViewItem.gameObject.name = "TreeViewItem";
				}
				return treeViewItem;
			}

			protected override void DestroyItem(object item)
			{
				TreeViewItem treeViewItem = (TreeViewItem)GetItemContainer(item);
				if (treeViewItem != null)
				{
					Collapse(treeViewItem);
					base.DestroyItem(item);
					if (treeViewItem.Parent != null && !treeViewItem.Parent.HasChildren)
					{
						treeViewItem.Parent.CanExpand = false;
					}
				}
			}

			protected override void DataBindItem(object item, ItemContainer itemContainer)
			{
				TreeViewItemDataBindingArgs treeViewItemDataBindingArgs = new TreeViewItemDataBindingArgs();
				treeViewItemDataBindingArgs.Item = item;
				treeViewItemDataBindingArgs.ItemPresenter = itemContainer.gameObject;
				RaiseItemDataBinding(treeViewItemDataBindingArgs);
				((TreeViewItem)itemContainer).CanExpand = treeViewItemDataBindingArgs.HasChildren;
			}

			protected override bool CanDrop(ItemContainer[] dragItems, ItemContainer dropTarget)
			{
				if (!base.CanDrop(dragItems, dropTarget))
				{
					return false;
				}
				TreeViewItem treeViewItem = (TreeViewItem)dropTarget;
				if (treeViewItem == null)
				{
					return true;
				}
				for (int i = 0; i < dragItems.Length; i++)
				{
					TreeViewItem parent = (TreeViewItem)dragItems[i];
					if (treeViewItem.IsDescendantOf(parent))
					{
						return false;
					}
				}
				return true;
			}

			private void OnTreeViewItemParentChanged(object sender, ParentChangedEventArgs e)
			{
				TreeViewItem treeViewItem = (TreeViewItem)sender;
				if (!CanHandleEvent(treeViewItem))
				{
					return;
				}
				TreeViewItem oldParent = e.OldParent;
				if (oldParent != null && !oldParent.HasChildren)
				{
					oldParent.CanExpand = false;
				}
				if (base.DropMarker.Action != ItemDropAction.SetLastChild && base.DropMarker.Action != 0)
				{
					return;
				}
				TreeViewItem newParent = e.NewParent;
				if (newParent != null)
				{
					if (newParent.CanExpand)
					{
						newParent.IsExpanded = true;
					}
					else
					{
						newParent.CanExpand = true;
						m_expandSilently = true;
						newParent.IsExpanded = true;
						m_expandSilently = false;
					}
				}
				TreeViewItem treeViewItem2 = treeViewItem.FirstChild();
				TreeViewItem treeViewItem3 = null;
				if (newParent != null)
				{
					treeViewItem3 = newParent.LastChild();
					if (treeViewItem3 == null)
					{
						treeViewItem3 = newParent;
					}
				}
				else
				{
					treeViewItem3 = (TreeViewItem)LastItemContainer();
				}
				if (treeViewItem3 != treeViewItem)
				{
					DropItemAfter(treeViewItem3, treeViewItem);
				}
				if (treeViewItem2 != null)
				{
					MoveSubtree(treeViewItem, treeViewItem2);
				}
			}

			private void MoveSubtree(TreeViewItem parent, TreeViewItem child)
			{
				int siblingIndex = parent.transform.GetSiblingIndex();
				int num = child.transform.GetSiblingIndex();
				bool flag = false;
				if (siblingIndex < num)
				{
					flag = true;
				}
				TreeViewItem treeViewItem = parent;
				while (child != null && child.IsDescendantOf(parent) && !(treeViewItem == child))
				{
					DropItemAfter(treeViewItem, child);
					treeViewItem = child;
					if (flag)
					{
						num++;
					}
					child = (TreeViewItem)GetItemContainer(num);
				}
			}

			protected override void Drop(ItemContainer[] dragItems, ItemContainer dropTarget, ItemDropAction action)
			{
				TreeViewItem treeViewItem = (TreeViewItem)dropTarget;
				switch (action)
				{
				case ItemDropAction.SetLastChild:
				{
					for (int i = 0; i < dragItems.Length; i++)
					{
						((TreeViewItem)dragItems[i]).Parent = treeViewItem;
					}
					break;
				}
				case ItemDropAction.SetPrevSibling:
				{
					for (int j = 0; j < dragItems.Length; j++)
					{
						TreeViewItem treeViewItem4 = (TreeViewItem)dragItems[j];
						TreeViewItem treeViewItem5 = treeViewItem4.FirstChild();
						DropItemBefore(treeViewItem, treeViewItem4);
						if (treeViewItem5 != null)
						{
							MoveSubtree(treeViewItem4, treeViewItem5);
						}
						treeViewItem4.Parent = treeViewItem.Parent;
					}
					break;
				}
				case ItemDropAction.SetNextSibling:
				{
					for (int num = dragItems.Length - 1; num >= 0; num--)
					{
						TreeViewItem treeViewItem2 = (TreeViewItem)dragItems[num];
						TreeViewItem treeViewItem3 = treeViewItem2.FirstChild();
						DropItemAfter(treeViewItem, treeViewItem2);
						if (treeViewItem3 != null)
						{
							MoveSubtree(treeViewItem2, treeViewItem3);
						}
						treeViewItem2.Parent = treeViewItem.Parent;
					}
					break;
				}
				}
				UpdateSelectedItemIndex();
			}
		}
		[RequireComponent(typeof(RectTransform))]
		public class TreeViewDropMarker : ItemDropMarker
		{
			private TreeView m_treeView;

			private RectTransform m_siblingGraphicsRectTransform;

			public GameObject ChildGraphics;

			public override ItemDropAction Action
			{
				get
				{
					return base.Action;
				}
				set
				{
					base.Action = value;
					ChildGraphics.SetActive(base.Action == ItemDropAction.SetLastChild);
					SiblingGraphics.SetActive(base.Action != ItemDropAction.SetLastChild);
				}
			}

			protected override void AwakeOverride()
			{
				base.AwakeOverride();
				m_treeView = GetComponentInParent<TreeView>();
				m_siblingGraphicsRectTransform = SiblingGraphics.GetComponent<RectTransform>();
			}

			public override void SetTraget(ItemContainer item)
			{
				base.SetTraget(item);
				if (!(item == null))
				{
					TreeViewItem treeViewItem = (TreeViewItem)item;
					if (treeViewItem != null)
					{
						m_siblingGraphicsRectTransform.offsetMin = new Vector2(treeViewItem.Indent, m_siblingGraphicsRectTransform.offsetMin.y);
					}
					else
					{
						m_siblingGraphicsRectTransform.offsetMin = new Vector2(0f, m_siblingGraphicsRectTransform.offsetMin.y);
					}
				}
			}

			public override void SetPosition(Vector2 position)
			{
				if (base.Item == null)
				{
					return;
				}
				RectTransform rectTransform = base.Item.RectTransform;
				TreeViewItem treeViewItem = (TreeViewItem)base.Item;
				Camera cam = null;
				if (base.ParentCanvas.renderMode == RenderMode.WorldSpace)
				{
					cam = m_treeView.Camera;
				}
				if (RectTransformUtility.ScreenPointToLocalPointInRectangle(rectTransform, position, cam, out var localPoint))
				{
					if (localPoint.y > (0f - rectTransform.rect.height) / 4f)
					{
						Action = ItemDropAction.SetPrevSibling;
						base.RectTransform.position = rectTransform.position;
					}
					else if (localPoint.y < rectTransform.rect.height / 4f - rectTransform.rect.height && !treeViewItem.HasChildren)
					{
						Action = ItemDropAction.SetNextSibling;
						base.RectTransform.position = rectTransform.position - new Vector3(0f, rectTransform.rect.height, 0f);
					}
					else
					{
						Action = ItemDropAction.SetLastChild;
						base.RectTransform.position = rectTransform.position;
					}
				}
			}
		}
		[RequireComponent(typeof(Toggle))]
		public class TreeViewExpander : MonoBehaviour
		{
			public Graphic OffGraphic;

			private Toggle m_toggle;

			private bool m_canExpand;

			public bool CanExpand
			{
				get
				{
					return m_canExpand;
				}
				set
				{
					m_canExpand = value;
					if (!m_canExpand)
					{
						if (m_toggle != null)
						{
							m_toggle.isOn = false;
							m_toggle.enabled = false;
						}
					}
					else if (m_toggle != null)
					{
						m_toggle.enabled = true;
						if (!IsOn)
						{
							OffGraphic.enabled = true;
						}
					}
				}
			}

			public bool IsOn
			{
				get
				{
					return m_toggle.isOn;
				}
				set
				{
					m_toggle.isOn = value && m_canExpand;
				}
			}

			private void Start()
			{
				m_toggle = GetComponent<Toggle>();
				if (!m_canExpand)
				{
					m_toggle.isOn = false;
					m_toggle.enabled = false;
				}
				if (OffGraphic != null)
				{
					OffGraphic.enabled = !m_toggle.isOn && m_canExpand;
				}
				m_toggle.onValueChanged.AddListener(OnValueChanged);
			}

			private void OnEnable()
			{
				if (m_toggle != null)
				{
					if (OffGraphic != null)
					{
						OffGraphic.enabled = !m_toggle.isOn && m_canExpand;
					}
					if (!m_canExpand)
					{
						m_toggle.onValueChanged.RemoveListener(OnValueChanged);
						m_toggle.isOn = true;
						m_toggle.isOn = false;
						m_toggle.onValueChanged.AddListener(OnValueChanged);
						m_toggle.enabled = false;
					}
				}
			}

			private void OnDestroy()
			{
				if (m_toggle != null)
				{
					m_toggle.onValueChanged.RemoveListener(OnValueChanged);
				}
			}

			private void OnValueChanged(bool value)
			{
				if (!m_canExpand)
				{
					m_toggle.isOn = false;
					m_toggle.enabled = false;
				}
				if (OffGraphic != null)
				{
					OffGraphic.enabled = !value && m_canExpand;
				}
			}
		}
		public class ParentChangedEventArgs : EventArgs
		{
			public TreeViewItem OldParent { get; private set; }

			public TreeViewItem NewParent { get; private set; }

			public ParentChangedEventArgs(TreeViewItem oldParent, TreeViewItem newParent)
			{
				OldParent = oldParent;
				NewParent = newParent;
			}
		}
		public class TreeViewItem : ItemContainer
		{
			private TreeViewExpander m_expander;

			[SerializeField]
			private HorizontalLayoutGroup m_itemLayout;

			private Toggle m_toggle;

			private TreeView m_treeView;

			private int m_indent;

			private TreeViewItem m_parent;

			private bool m_canExpand;

			private bool m_isExpanded;

			public int Indent => m_indent;

			public TreeViewItem Parent
			{
				get
				{
					return m_parent;
				}
				set
				{
					if (m_parent == value)
					{
						return;
					}
					TreeViewItem parent = m_parent;
					m_parent = value;
					if (m_parent != null && m_treeView != null && m_itemLayout != null)
					{
						m_indent = m_parent.m_indent + m_treeView.Indent;
						m_itemLayout.padding = new RectOffset(m_indent, m_itemLayout.padding.right, m_itemLayout.padding.top, m_itemLayout.padding.bottom);
						int siblingIndex = base.transform.GetSiblingIndex();
						SetIndent(this, ref siblingIndex);
					}
					else
					{
						m_indent = 0;
						if (m_itemLayout != null)
						{
							m_itemLayout.padding = new RectOffset(m_indent, m_itemLayout.padding.right, m_itemLayout.padding.top, m_itemLayout.padding.bottom);
						}
					}
					if (m_treeView != null && TreeViewItem.ParentChanged != null)
					{
						TreeViewItem.ParentChanged(this, new ParentChangedEventArgs(parent, m_parent));
					}
				}
			}

			public override bool IsSelected
			{
				get
				{
					return base.IsSelected;
				}
				set
				{
					if (base.IsSelected != value)
					{
						m_toggle.isOn = value;
						base.IsSelected = value;
					}
				}
			}

			public bool CanExpand
			{
				get
				{
					return m_canExpand;
				}
				set
				{
					if (m_canExpand != value)
					{
						m_canExpand = value;
						if (m_expander != null)
						{
							m_expander.CanExpand = m_canExpand;
						}
						if (!m_canExpand)
						{
							IsExpanded = false;
						}
					}
				}
			}

			public bool IsExpanded
			{
				get
				{
					return m_isExpanded;
				}
				set
				{
					if (m_isExpanded == value)
					{
						return;
					}
					m_isExpanded = value && m_canExpand;
					if (m_expander != null)
					{
						m_expander.IsOn = value && m_canExpand;
					}
					if (m_treeView != null)
					{
						if (m_isExpanded)
						{
							m_treeView.Expand(this);
						}
						else
						{
							m_treeView.Collapse(this);
						}
					}
				}
			}

			public bool HasChildren
			{
				get
				{
					int siblingIndex = base.transform.GetSiblingIndex();
					TreeViewItem treeViewItem = (TreeViewItem)m_treeView.GetItemContainer(siblingIndex + 1);
					if (treeViewItem != null)
					{
						return treeViewItem.Parent == this;
					}
					return false;
				}
			}

			public static event EventHandler<ParentChangedEventArgs> ParentChanged;

			private void SetIndent(TreeViewItem parent, ref int siblingIndex)
			{
				while (true)
				{
					TreeViewItem treeViewItem = (TreeViewItem)m_treeView.GetItemContainer(siblingIndex + 1);
					if (treeViewItem == null || treeViewItem.Parent != parent)
					{
						break;
					}
					treeViewItem.m_indent = parent.m_indent + m_treeView.Indent;
					treeViewItem.m_itemLayout.padding.left = treeViewItem.m_indent;
					siblingIndex++;
					SetIndent(treeViewItem, ref siblingIndex);
				}
			}

			public bool IsDescendantOf(TreeViewItem parent)
			{
				if (parent == null)
				{
					return true;
				}
				TreeViewItem treeViewItem = this;
				while (treeViewItem != null)
				{
					if (parent == treeViewItem)
					{
						return true;
					}
					treeViewItem = treeViewItem.Parent;
				}
				return false;
			}

			public TreeViewItem FirstChild()
			{
				if (!HasChildren)
				{
					return null;
				}
				int siblingIndex = base.transform.GetSiblingIndex();
				siblingIndex++;
				return (TreeViewItem)m_treeView.GetItemContainer(siblingIndex);
			}

			public TreeViewItem NextChild(TreeViewItem currentChild)
			{
				if (currentChild == null)
				{
					throw new ArgumentNullException("currentChild");
				}
				int siblingIndex = currentChild.transform.GetSiblingIndex();
				siblingIndex++;
				TreeViewItem treeViewItem = (TreeViewItem)m_treeView.GetItemContainer(siblingIndex);
				while (treeViewItem != null && treeViewItem.IsDescendantOf(this))
				{
					if (treeViewItem.Parent == this)
					{
						return treeViewItem;
					}
					siblingIndex++;
					treeViewItem = (TreeViewItem)m_treeView.GetItemContainer(siblingIndex);
				}
				return null;
			}

			public TreeViewItem LastChild()
			{
				if (!HasChildren)
				{
					return null;
				}
				int num = base.transform.GetSiblingIndex();
				TreeViewItem result = null;
				while (true)
				{
					num++;
					TreeViewItem treeViewItem = (TreeViewItem)m_treeView.GetItemContainer(num);
					if (treeViewItem == null || treeViewItem.Parent != this)
					{
						break;
					}
					result = treeViewItem;
				}
				return result;
			}

			protected override void AwakeOverride()
			{
				m_toggle = GetComponent<Toggle>();
				m_toggle.interactable = false;
				m_toggle.isOn = IsSelected;
				m_expander = GetComponentInChildren<TreeViewExpander>();
				if (m_expander != null)
				{
					m_expander.CanExpand = m_canExpand;
				}
			}

			protected override void StartOverride()
			{
				m_treeView = GetComponentInParent<TreeView>();
				if (IsExpanded)
				{
					m_treeView.Expand(this);
				}
				if (Parent != null)
				{
					m_indent = Parent.m_indent + m_treeView.Indent;
					m_itemLayout.padding.left = m_indent;
				}
			}
		}
	}
	namespace Battlehub.Utils
	{
		[ExecuteInEditMode]
		public class SaveInPlayMode : MonoBehaviour
		{
		}
		public class EditorStopwatch
		{
			public static EditorStopwatch Main;

			static EditorStopwatch()
			{
				Main = new EditorStopwatch();
			}

			public void Start()
			{
			}

			public void Stop(string output)
			{
			}
		}
		[AttributeUsage(AttributeTargets.Property)]
		public class ExposePropertyAttribute : Attribute
		{
		}
		public class QuaternionAnimationInfo : AnimationInfo<object, Quaternion>
		{
			public QuaternionAnimationInfo(Quaternion from, Quaternion to, float duration, Func<float, float> easingFunction, AnimationCallback<object, Quaternion> callback, object target = null)
				: base(from, to, duration, easingFunction, callback, target)
			{
			}

			protected override Quaternion Lerp(Quaternion from, Quaternion to, float t)
			{
				return Quaternion.Lerp(from, to, t);
			}
		}
		public class Vector3SlerpAnimationInfo : AnimationInfo<object, Vector3>
		{
			public Vector3SlerpAnimationInfo(Vector3 from, Vector3 to, float duration, Func<float, float> easingFunction, AnimationCallback<object, Vector3> callback, object target = null)
				: base(from, to, duration, easingFunction, callback, target)
			{
			}

			protected override Vector3 Lerp(Vector3 from, Vector3 to, float t)
			{
				return Vector3.Slerp(from, to, t);
			}
		}
		public class Vector3AnimationInfo : AnimationInfo<object, Vector3>
		{
			public Vector3AnimationInfo(Vector3 from, Vector3 to, float duration, Func<float, float> easingFunction, AnimationCallback<object, Vector3> callback, object target = null)
				: base(from, to, duration, easingFunction, callback, target)
			{
			}

			protected override Vector3 Lerp(Vector3 from, Vector3 to, float t)
			{
				return Vector3.Lerp(from, to, t);
			}
		}
		public class FloatAnimationInfo : AnimationInfo<object, float>
		{
			public FloatAnimationInfo(float from, float to, float duration, Func<float, float> easingFunction, AnimationCallback<object, float> callback, object target = null)
				: base(from, to, duration, easingFunction, callback, target)
			{
			}

			protected override float Lerp(float from, float to, float t)
			{
				return to * t + from * (1f - t);
			}
		}
		public delegate void AnimationCallback<TObj, TValue>(TObj obj, TValue value, float t, bool completed);
		public abstract class AnimationInfo<TObj, TValue> : IAnimationInfo
		{
			private float m_duration;

			private float m_t;

			private TObj m_target;

			private TValue m_from;

			private TValue m_to;

			private AnimationCallback<TObj, TValue> m_callback;

			private Func<float, float> m_easingFunction;

			float IAnimationInfo.Duration => m_duration;

			float IAnimationInfo.T
			{
				get
				{
					return m_t;
				}
				set
				{
					m_t = value;
					if (m_t < 0f)
					{
						m_t = 0f;
					}
					if (!float.IsNaN(m_t))
					{
						bool flag = m_t >= m_duration;
						float t = (flag ? 1f : m_easingFunction(m_t / m_duration));
						TValue value2 = Lerp(m_from, m_to, t);
						m_callback(m_target, value2, m_t, flag);
					}
				}
			}

			public bool InProgress
			{
				get
				{
					if (m_t > 0f)
					{
						return m_t < m_duration;
					}
					return false;
				}
			}

			public static float EaseLinear(float t)
			{
				return t;
			}

			public static float EaseInQuad(float t)
			{
				return t * t;
			}

			public static float EaseOutQuad(float t)
			{
				return t * (2f - t);
			}

			public static float EaseInOutQuad(float t)
			{
				if (!((double)t < 0.5))
				{
					return -1f + (4f - 2f * t) * t;
				}
				return 2f * t * t;
			}

			public static float EaseInCubic(float t)
			{
				return t * t * t;
			}

			public static float EaseOutCubic(float t)
			{
				return (t -= 1f) * t * t + 1f;
			}

			public static float EaseInOutCubic(float t)
			{
				if (!((double)t < 0.5))
				{
					return (t - 1f) * (2f * t - 2f) * (2f * t - 2f) + 1f;
				}
				return 4f * t * t * t;
			}

			public static float EaseInQuart(float t)
			{
				return t * t * t * t;
			}

			public static float EaseOutQuart(float t)
			{
				return 1f - (t -= 1f) * t * t * t;
			}

			public static float EaseInOutQuart(float t)
			{
				if (!((double)t < 0.5))
				{
					return 1f - 8f * (t -= 1f) * t * t * t;
				}
				return 8f * t * t * t * t;
			}

			public static float ElasticEaseIn(float t)
			{
				return Mathf.Sin((float)Math.PI * 26f * t) * Mathf.Pow(2f, 10f * (t - 1f));
			}

			public static float ElasticEaseOut(float t)
			{
				return Mathf.Sin((float)Math.PI * -26f * (t + 1f)) * Mathf.Pow(2f, -10f * t) + 1f;
			}

			public static float ElasticEaseInOut(float t)
			{
				if ((double)t < 0.5)
				{
					return 0.5f * Mathf.Sin((float)Math.PI * 26f * (2f * t)) * Mathf.Pow(2f, 10f * (2f * t - 1f));
				}
				return 0.5f * (Mathf.Sin((float)Math.PI * -26f * (2f * t - 1f + 1f)) * Mathf.Pow(2f, -10f * (2f * t - 1f)) + 2f);
			}

			protected abstract TValue Lerp(TValue from, TValue to, float t);

			public void Abort()
			{
				m_t = float.NaN;
			}

			public AnimationInfo(TValue from, TValue to, float duration, Func<float, float> easingFunction, AnimationCallback<TObj, TValue> callback, TObj target)
			{
				if (callback == null)
				{
					throw new ArgumentNullException("callback");
				}
				if (easingFunction == null)
				{
					throw new ArgumentNullException("easingFunction");
				}
				m_target = target;
				m_from = from;
				m_to = to;
				m_duration = duration;
				m_callback = callback;
				m_easingFunction = easingFunction;
			}
		}
		public interface IAnimationInfo
		{
			float Duration { get; }

			float T { get; set; }

			bool InProgress { get; }

			void Abort();
		}
		[ExecuteInEditMode]
		public class Run : MonoBehaviour
		{
			private static Run m_instance;

			private List<IAnimationInfo> m_animations;

			public static Run Instance => m_instance;

			public void Animation(IAnimationInfo animation)
			{
				if (!m_animations.Contains(animation))
				{
					m_animations.Add(animation);
				}
			}

			public void Remove(IAnimationInfo animation)
			{
				m_animations.Remove(animation);
			}

			private void Awake()
			{
				if (m_instance != null)
				{
					UnityEngine.Debug.LogWarning("Another instance of Animation already exist");
				}
				m_instance = this;
				m_animations = new List<IAnimationInfo>();
			}

			private void Update()
			{
				for (int i = 0; i < m_animations.Count; i++)
				{
					IAnimationInfo animationInfo = m_animations[i];
					animationInfo.T += Time.deltaTime;
					if (animationInfo.T >= animationInfo.Duration)
					{
						m_animations.Remove(animationInfo);
					}
				}
			}
		}
	}
	namespace Battlehub.RTHandles
	{
		public enum RuntimeTool
		{
			None,
			Move,
			Rotate,
			Scale,
			View
		}
		public enum RuntimePivotRotation
		{
			Local,
			Global
		}
		public delegate void RuntimeToolChanged();
		public delegate void RuntimePivotRotationChanged();
		public static class RuntimeTools
		{
			private static RuntimeTool m_current;

			private static RuntimePivotRotation m_pivotRotation;

			public static bool IsLocked { get; set; }

			public static bool IsDragDrop { get; set; }

			public static bool IsSceneGizmoSelected { get; set; }

			public static RuntimeTool Current
			{
				get
				{
					return m_current;
				}
				set
				{
					if (m_current != value)
					{
						m_current = value;
						if (RuntimeTools.ToolChanged != null)
						{
							RuntimeTools.ToolChanged();
						}
					}
				}
			}

			public static RuntimePivotRotation PivotRotation
			{
				get
				{
					return m_pivotRotation;
				}
				set
				{
					if (m_pivotRotation != value)
					{
						m_pivotRotation = value;
						if (RuntimeTools.PivotRotationChanged != null)
						{
							RuntimeTools.PivotRotationChanged();
						}
					}
				}
			}

			public static event RuntimeToolChanged ToolChanged;

			public static event RuntimePivotRotationChanged PivotRotationChanged;
		}
		public abstract class BaseHandle : MonoBehaviour, IGL
		{
			public KeyCode SnapToGridKey = KeyCode.LeftControl;

			public Camera Camera;

			public float SelectionMargin = 10f;

			public Transform[] Targets;

			private static BaseHandle m_draggingTool;

			private RuntimeHandleAxis m_selectedAxis;

			private bool m_isDragging;

			private Plane m_dragPlane;

			protected float EffectiveGridSize { get; private set; }

			public Transform Target => Targets[0];

			public bool IsDragging => m_isDragging;

			protected abstract RuntimeTool Tool { get; }

			protected Quaternion Rotation
			{
				get
				{
					if (Targets == null || Targets.Length == 0 || Target == null)
					{
						return Quaternion.identity;
					}
					if (RuntimeTools.PivotRotation != 0)
					{
						return Quaternion.identity;
					}
					return Target.rotation;
				}
			}

			protected RuntimeHandleAxis SelectedAxis
			{
				get
				{
					return m_selectedAxis;
				}
				set
				{
					m_selectedAxis = value;
				}
			}

			protected Plane DragPlane
			{
				get
				{
					return m_dragPlane;
				}
				set
				{
					m_dragPlane = value;
				}
			}

			protected abstract float CurrentGridSize { get; }

			private void Start()
			{
				if (Camera == null)
				{
					Camera = Camera.main;
				}
				if (GLRenderer.Instance == null)
				{
					GameObject obj = new GameObject();
					obj.name = "GLRenderer";
					obj.AddComponent<GLRenderer>();
				}
				if (Camera != null && !Camera.GetComponent<GLCamera>())
				{
					Camera.gameObject.AddComponent<GLCamera>();
				}
				if (Targets == null || Targets.Length == 0)
				{
					Targets = new Transform[1] { base.transform };
				}
				if (GLRenderer.Instance != null)
				{
					GLRenderer.Instance.Add(this);
				}
				if (Targets[0].position != base.transform.position)
				{
					base.transform.position = Targets[0].position;
				}
				StartOverride();
			}

			protected virtual void StartOverride()
			{
			}

			private void OnEnable()
			{
				if (GLRenderer.Instance != null)
				{
					GLRenderer.Instance.Add(this);
				}
				OnEnableOverride();
			}

			protected virtual void OnEnableOverride()
			{
			}

			private void OnDisable()
			{
				if (GLRenderer.Instance != null)
				{
					GLRenderer.Instance.Remove(this);
				}
				OnDisableOverride();
			}

			protected virtual void OnDisableOverride()
			{
			}

			private void OnDestroy()
			{
				if (GLRenderer.Instance != null)
				{
					GLRenderer.Instance.Remove(this);
				}
				OnDestroyOverride();
			}

			protected virtual void OnDestroyOverride()
			{
			}

			private void Update()
			{
				if (Input.GetMouseButtonDown(0))
				{
					if ((RuntimeTools.Current != Tool && RuntimeTools.Current != 0) || RuntimeTools.IsLocked)
					{
						return;
					}
					if (Camera == null)
					{
						UnityEngine.Debug.LogError("Camera is null");
						return;
					}
					if (m_draggingTool != null)
					{
						return;
					}
					m_isDragging = OnBeginDrag();
					if (m_isDragging)
					{
						m_draggingTool = this;
					}
				}
				else if (Input.GetMouseButtonUp(0))
				{
					OnDrop();
					m_isDragging = false;
					m_draggingTool = null;
				}
				else if (m_isDragging)
				{
					if (Input.GetKey(SnapToGridKey))
					{
						EffectiveGridSize = CurrentGridSize;
					}
					else
					{
						EffectiveGridSize = 0f;
					}
					OnDrag();
				}
				UpdateOverride();
			}

			protected virtual bool OnBeginDrag()
			{
				return false;
			}

			protected virtual void OnDrag()
			{
			}

			protected virtual void OnDrop()
			{
			}

			protected virtual void UpdateOverride()
			{
				if (Targets == null || Targets.Length == 0 || !(Targets[0] != null) || !(Targets[0].position != base.transform.position))
				{
					return;
				}
				if (IsDragging)
				{
					Vector3 vector = base.transform.position - Targets[0].position;
					Targets[0].position = base.transform.position;
					for (int i = 1; i < Targets.Length; i++)
					{
						Targets[i].position += vector;
					}
				}
				else
				{
					base.transform.position = Targets[0].position;
					base.transform.rotation = Targets[0].rotation;
				}
			}

			protected bool HitCenter()
			{
				Vector2 vector = Camera.WorldToScreenPoint(base.transform.position);
				return ((Vector2)Input.mousePosition - vector).magnitude <= SelectionMargin;
			}

			protected bool HitAxis(Vector3 axis, Matrix4x4 matrix, out float distanceToAxis)
			{
				axis = matrix.MultiplyVector(axis);
				Vector2 vector = Camera.WorldToScreenPoint(base.transform.position);
				Vector3 vector2 = (Vector2)Camera.WorldToScreenPoint(axis + base.transform.position) - vector;
				float magnitude = vector2.magnitude;
				vector2.Normalize();
				if (vector2 != Vector3.zero)
				{
					Vector2 normalized = PerpendicularClockwise(vector2).normalized;
					Vector2 vector3 = (Vector2)Input.mousePosition - vector;
					distanceToAxis = Mathf.Abs(Vector2.Dot(normalized, vector3));
					Vector2 rhs = vector3 - normalized * distanceToAxis;
					float num = Vector2.Dot(vector2, rhs);
					int num2;
					if (num <= magnitude + SelectionMargin && num >= 0f - SelectionMargin)
					{
						num2 = ((distanceToAxis <= SelectionMargin) ? 1 : 0);
						if (num2 != 0)
						{
							if (magnitude < SelectionMargin)
							{
								distanceToAxis = 0f;
							}
							return (byte)num2 != 0;
						}
					}
					else
					{
						num2 = 0;
					}
					distanceToAxis = float.PositiveInfinity;
					return (byte)num2 != 0;
				}
				Vector2 vector4 = Input.mousePosition;
				distanceToAxis = (vector - vector4).magnitude;
				bool num3 = distanceToAxis <= SelectionMargin;
				if (!num3)
				{
					distanceToAxis = float.PositiveInfinity;
					return num3;
				}
				distanceToAxis = 0f;
				return num3;
			}

			protected Plane GetDragPlane(Matrix4x4 matrix, Vector3 axis)
			{
				return new Plane(matrix.MultiplyVector(axis).normalized, matrix.MultiplyPoint(Vector3.zero));
			}

			protected Plane GetDragPlane()
			{
				return new Plane(Camera.cameraToWorldMatrix.MultiplyVector(Vector3.forward).normalized, base.transform.position);
			}

			protected bool GetPointOnDragPlane(Vector3 screenPos, out Vector3 point)
			{
				return GetPointOnDragPlane(m_dragPlane, screenPos, out point);
			}

			protected bool GetPointOnDragPlane(Plane dragPlane, Vector3 screenPos, out Vector3 point)
			{
				Ray ray = Camera.ScreenPointToRay(screenPos);
				if (dragPlane.Raycast(ray, out var enter))
				{
					point = ray.GetPoint(enter);
					return true;
				}
				point = Vector3.zero;
				return false;
			}

			private static Vector2 PerpendicularClockwise(Vector2 vector2)
			{
				return new Vector2(0f - vector2.y, vector2.x);
			}

			void IGL.Draw()
			{
				DrawOverride();
			}

			protected virtual void DrawOverride()
			{
			}
		}
		[ExecuteInEditMode]
		public class GLCamera : MonoBehaviour
		{
			public int CullingMask = -1;

			private Camera m_camera;

			private void Awake()
			{
				m_camera = GetComponent<Camera>();
				RenderPipelineManager.endCameraRendering += OnEndCameraRendering;
			}

			private void OnDestroy()
			{
				RenderPipelineManager.endCameraRendering -= OnEndCameraRendering;
			}

			private void OnEndCameraRendering(ScriptableRenderContext context, Camera camera)
			{
				if (m_camera == camera)
				{
					Camera.SetupCurrent(camera);
					if (GLRenderer.Instance != null)
					{
						GLRenderer.Instance.Draw();
					}
				}
			}

			private void OnPostRender()
			{
				if (GLRenderer.Instance != null)
				{
					GLRenderer.Instance.Draw();
				}
			}
		}
		public interface IGL
		{
			void Draw();
		}
		[ExecuteInEditMode]
		public class GLRenderer : MonoBehaviour
		{
			private static GLRenderer m_instance;

			private List<IGL> m_renderObjects;

			public static GLRenderer Instance => m_instance;

			public void Add(IGL gl)
			{
				if (!m_renderObjects.Contains(gl))
				{
					m_renderObjects.Add(gl);
				}
			}

			public void Remove(IGL line)
			{
				m_renderObjects.Remove(line);
			}

			private void Awake()
			{
				if (m_instance != null)
				{
					UnityEngine.Debug.LogWarning("Another instance of GLLinesRenderer aleready exist");
				}
				m_instance = this;
				m_renderObjects = new List<IGL>();
			}

			private void OnDestroy()
			{
				m_instance = null;
			}

			public void Draw()
			{
				if (m_renderObjects == null)
				{
					return;
				}
				GL.PushMatrix();
				try
				{
					for (int i = 0; i < m_renderObjects.Count; i++)
					{
						m_renderObjects[i].Draw();
					}
				}
				finally
				{
					GL.PopMatrix();
				}
			}
		}
		[RequireComponent(typeof(Camera))]
		public class Grid : MonoBehaviour
		{
			private Camera m_camera;

			public Camera Camera;

			private void Start()
			{
				m_camera = GetComponent<Camera>();
				if (Camera == null)
				{
					Camera = Camera.main;
				}
				m_camera.clearFlags = CameraClearFlags.Nothing;
				m_camera.renderingPath = RenderingPath.Forward;
				m_camera.cullingMask = 0;
				SetupCamera();
			}

			private void OnPreRender()
			{
				m_camera.farClipPlane = RuntimeHandles.GetGridFarPlane();
			}

			private void OnPostRender()
			{
				RuntimeHandles.DrawGrid();
			}

			private void Update()
			{
				SetupCamera();
			}

			private void SetupCamera()
			{
				m_camera.transform.position = Camera.transform.position;
				m_camera.transform.rotation = Camera.transform.rotation;
				m_camera.transform.localScale = Camera.transform.localScale;
				if (m_camera.fieldOfView != Camera.fieldOfView)
				{
					m_camera.fieldOfView = Camera.fieldOfView;
				}
				if (m_camera.orthographic != Camera.orthographic)
				{
					m_camera.orthographic = Camera.orthographic;
				}
				if (m_camera.orthographicSize != Camera.orthographicSize)
				{
					m_camera.orthographicSize = Camera.orthographicSize;
				}
				if (m_camera.rect != Camera.rect)
				{
					m_camera.rect = Camera.rect;
				}
			}
		}
		public class PositionHandle : BaseHandle
		{
			public float GridSize = 1f;

			private Vector3 m_cursorPosition;

			private Vector3 m_currentPosition;

			private Vector3 m_prevPoint;

			private Matrix4x4 m_matrix;

			private Matrix4x4 m_inverse;

			public static PositionHandle Current { get; private set; }

			protected override RuntimeTool Tool => RuntimeTool.Move;

			protected override float CurrentGridSize => GridSize;

			protected override void StartOverride()
			{
				Current = this;
			}

			protected override void OnDestroyOverride()
			{
				if (Current == this)
				{
					Current = null;
				}
			}

			private bool HitQuad(Vector3 axis, Matrix4x4 matrix, float size)
			{
				Ray ray = Camera.ScreenPointToRay(Input.mousePosition);
				Plane plane = new Plane(matrix.MultiplyVector(axis).normalized, matrix.MultiplyPoint(Vector3.zero));
				if (!plane.Raycast(ray, out var enter))
				{
					return false;
				}
				Vector3 point = ray.GetPoint(enter);
				point = matrix.inverse.MultiplyPoint(point);
				Vector3 lhs = Camera.transform.position - base.transform.position;
				float num = Mathf.Sign(Vector3.Dot(lhs, Vector3.right));
				float num2 = Mathf.Sign(Vector3.Dot(lhs, Vector3.up));
				float num3 = Mathf.Sign(Vector3.Dot(lhs, Vector3.forward));
				point.x *= num;
				point.y *= num2;
				point.z *= num3;
				float num4 = -0.01f;
				int num5;
				if (point.x >= num4 && point.x <= size && point.y >= num4 && point.y <= size && point.z >= num4)
				{
					num5 = ((point.z <= size) ? 1 : 0);
					if (num5 != 0)
					{
						base.DragPlane = GetDragPlane(matrix, axis);
					}
				}
				else
				{
					num5 = 0;
				}
				return (byte)num5 != 0;
			}

			protected override bool OnBeginDrag()
			{
				m_cursorPosition = base.transform.position;
				m_currentPosition = m_cursorPosition;
				float screenScale = RuntimeHandles.GetScreenScale(base.transform.position, Camera);
				m_matrix = Matrix4x4.TRS(base.transform.position, base.Rotation, Vector3.one);
				m_inverse = m_matrix.inverse;
				Matrix4x4 matrix = Matrix4x4.TRS(base.transform.position, base.Rotation, new Vector3(screenScale, screenScale, screenScale));
				float size = 0.3f * screenScale;
				if (HitQuad(Vector3.up, m_matrix, size))
				{
					base.SelectedAxis = RuntimeHandleAxis.XZ;
					return GetPointOnDragPlane(Input.mousePosition, out m_prevPoint);
				}
				if (HitQuad(Vector3.right, m_matrix, size))
				{
					base.SelectedAxis = RuntimeHandleAxis.YZ;
					return GetPointOnDragPlane(Input.mousePosition, out m_prevPoint);
				}
				if (HitQuad(Vector3.forward, m_matrix, size))
				{
					base.SelectedAxis = RuntimeHandleAxis.XY;
					return GetPointOnDragPlane(Input.mousePosition, out m_prevPoint);
				}
				if (HitAxis(Vector3.up, matrix, out var distanceToAxis) | HitAxis(Vector3.forward, matrix, out var distanceToAxis2) | HitAxis(Vector3.right, matrix, out var distanceToAxis3))
				{
					if (distanceToAxis <= distanceToAxis2 && distanceToAxis <= distanceToAxis3)
					{
						base.SelectedAxis = RuntimeHandleAxis.Y;
					}
					else if (distanceToAxis3 <= distanceToAxis && distanceToAxis3 <= distanceToAxis2)
					{
						base.SelectedAxis = RuntimeHandleAxis.X;
					}
					else
					{
						base.SelectedAxis = RuntimeHandleAxis.Z;
					}
					base.DragPlane = GetDragPlane();
					return GetPointOnDragPlane(Input.mousePosition, out m_prevPoint);
				}
				base.SelectedAxis = RuntimeHandleAxis.None;
				return false;
			}

			protected override void OnDrag()
			{
				if (!GetPointOnDragPlane(Input.mousePosition, out var point))
				{
					return;
				}
				Vector3 vector = m_inverse.MultiplyVector(point - m_prevPoint);
				float magnitude = vector.magnitude;
				if (base.SelectedAxis == RuntimeHandleAxis.X)
				{
					vector.y = (vector.z = 0f);
				}
				else if (base.SelectedAxis == RuntimeHandleAxis.Y)
				{
					vector.x = (vector.z = 0f);
				}
				else if (base.SelectedAxis == RuntimeHandleAxis.Z)
				{
					vector.x = (vector.y = 0f);
				}
				if ((double)base.EffectiveGridSize == 0.0)
				{
					vector = m_matrix.MultiplyVector(vector).normalized * magnitude;
					base.transform.position += vector;
					m_prevPoint = point;
					return;
				}
				vector = m_matrix.MultiplyVector(vector).normalized * magnitude;
				m_cursorPosition += vector;
				Vector3 vector2 = m_cursorPosition - m_currentPosition;
				if (vector2.magnitude * 1.5f >= base.EffectiveGridSize)
				{
					m_currentPosition += vector2.normalized * base.EffectiveGridSize;
					base.transform.position = m_currentPosition;
				}
				m_prevPoint = point;
			}

			protected override void DrawOverride()
			{
				RuntimeHandles.DoPositionHandle(base.transform.position, base.Rotation, base.SelectedAxis);
			}
		}
		public class RotationHandle : BaseHandle
		{
			public float GridSize = 15f;

			public float XSpeed = 10f;

			public float YSpeed = 10f;

			private Matrix4x4 m_targetInverse;

			private Matrix4x4 m_matrix;

			private Matrix4x4 m_inverse;

			private const float innerRadius = 1f;

			private const float outerRadius = 1.2f;

			private const float hitDot = 0.2f;

			private float m_deltaX;

			private float m_deltaY;

			public static RotationHandle Current { get; private set; }

			protected override RuntimeTool Tool => RuntimeTool.Rotate;

			protected override float CurrentGridSize => GridSize;

			protected override void StartOverride()
			{
				Current = this;
			}

			protected override void OnDestroyOverride()
			{
				if (Current == this)
				{
					Current = null;
				}
			}

			protected override void OnEnableOverride()
			{
				base.OnEnableOverride();
			}

			private bool Intersect(Ray r, Vector3 sphereCenter, float sphereRadius, out float hit1Distance, out float hit2Distance)
			{
				hit1Distance = 0f;
				hit2Distance = 0f;
				Vector3 vector = sphereCenter - r.origin;
				float num = Vector3.Dot(vector, r.direction);
				if ((double)num < 0.0)
				{
					return false;
				}
				float num2 = Vector3.Dot(vector, vector) - num * num;
				float num3 = sphereRadius * sphereRadius;
				if (num2 > num3)
				{
					return false;
				}
				float num4 = Mathf.Sqrt(num3 - num2);
				hit1Distance = num - num4;
				hit2Distance = num + num4;
				return true;
			}

			private RuntimeHandleAxis Hit()
			{
				Ray r = Camera.ScreenPointToRay(Input.mousePosition);
				float screenScale = RuntimeHandles.GetScreenScale(base.Target.position, Camera);
				if (Intersect(r, base.Target.position, 1.2f * screenScale, out var hit1Distance, out var hit2Distance))
				{
					GetPointOnDragPlane(GetDragPlane(), Input.mousePosition, out var point);
					if ((point - base.Target.position).magnitude <= 1f * screenScale)
					{
						Intersect(r, base.Target.position, 1f * screenScale, out hit1Distance, out hit2Distance);
						Vector3 normalized = m_targetInverse.MultiplyPoint(r.GetPoint(hit1Distance)).normalized;
						float num = Mathf.Abs(Vector3.Dot(normalized, Vector3.right));
						float num2 = Mathf.Abs(Vector3.Dot(normalized, Vector3.up));
						float num3 = Mathf.Abs(Vector3.Dot(normalized, Vector3.forward));
						if (num < 0.2f)
						{
							return RuntimeHandleAxis.X;
						}
						if (num2 < 0.2f)
						{
							return RuntimeHandleAxis.Y;
						}
						if (num3 < 0.2f)
						{
							return RuntimeHandleAxis.Z;
						}
						return RuntimeHandleAxis.Free;
					}
					return RuntimeHandleAxis.Screen;
				}
				return RuntimeHandleAxis.None;
			}

			protected override bool OnBeginDrag()
			{
				m_targetInverse = Matrix4x4.TRS(base.Target.position, base.Target.rotation, Vector3.one).inverse;
				base.SelectedAxis = Hit();
				m_deltaX = 0f;
				m_deltaY = 0f;
				if (base.SelectedAxis == RuntimeHandleAxis.Screen)
				{
					Vector2 vector = Camera.WorldToScreenPoint(base.Target.position);
					Vector2 vector2 = Input.mousePosition;
					float num = Mathf.Atan2(vector2.y - vector.y, vector2.x - vector.x);
					m_matrix = Matrix4x4.TRS(Vector3.zero, Quaternion.AngleAxis(57.29578f * num, Vector3.forward), Vector3.one);
				}
				else
				{
					m_matrix = Matrix4x4.TRS(Vector3.zero, base.Target.rotation, Vector3.one);
				}
				m_inverse = m_matrix.inverse;
				return base.SelectedAxis != RuntimeHandleAxis.None;
			}

			protected override void OnDrag()
			{
				float axis = Input.GetAxis("Mouse X");
				float axis2 = Input.GetAxis("Mouse Y");
				axis *= XSpeed;
				axis2 *= YSpeed;
				m_deltaX += axis;
				m_deltaY += axis2;
				Vector3 vector = m_inverse.MultiplyVector(Camera.cameraToWorldMatrix.MultiplyVector(new Vector3(m_deltaY, 0f - m_deltaX, 0f)));
				Quaternion quaternion;
				if (base.SelectedAxis == RuntimeHandleAxis.X)
				{
					if (base.EffectiveGridSize != 0f)
					{
						if (Mathf.Abs(vector.x) >= base.EffectiveGridSize)
						{
							vector.x = Mathf.Sign(vector.x) * base.EffectiveGridSize;
							m_deltaX = 0f;
							m_deltaY = 0f;
						}
						else
						{
							vector.x = 0f;
						}
					}
					quaternion = Quaternion.Euler(vector.x, 0f, 0f);
				}
				else if (base.SelectedAxis == RuntimeHandleAxis.Y)
				{
					if (base.EffectiveGridSize != 0f)
					{
						if (Mathf.Abs(vector.y) >= base.EffectiveGridSize)
						{
							vector.y = Mathf.Sign(vector.y) * base.EffectiveGridSize;
							m_deltaX = 0f;
							m_deltaY = 0f;
						}
						else
						{
							vector.y = 0f;
						}
					}
					quaternion = Quaternion.Euler(0f, vector.y, 0f);
				}
				else if (base.SelectedAxis == RuntimeHandleAxis.Z)
				{
					if (base.EffectiveGridSize != 0f)
					{
						if (Mathf.Abs(vector.z) >= base.EffectiveGridSize)
						{
							vector.z = Mathf.Sign(vector.z) * base.EffectiveGridSize;
							m_deltaX = 0f;
							m_deltaY = 0f;
						}
						else
						{
							vector.z = 0f;
						}
					}
					quaternion = Quaternion.Euler(0f, 0f, vector.z);
				}
				else if (base.SelectedAxis == RuntimeHandleAxis.Free)
				{
					quaternion = Quaternion.Euler(vector.x, vector.y, vector.z);
					m_deltaX = 0f;
					m_deltaY = 0f;
				}
				else
				{
					vector = m_inverse.MultiplyVector(new Vector3(m_deltaY, 0f - m_deltaX, 0f));
					if (base.EffectiveGridSize != 0f)
					{
						if (Mathf.Abs(vector.x) >= base.EffectiveGridSize)
						{
							vector.x = Mathf.Sign(vector.x) * base.EffectiveGridSize;
							m_deltaX = 0f;
							m_deltaY = 0f;
						}
						else
						{
							vector.x = 0f;
						}
					}
					Vector3 axis3 = m_targetInverse.MultiplyVector(Camera.cameraToWorldMatrix.MultiplyVector(-Vector3.forward));
					quaternion = Quaternion.AngleAxis(vector.x, axis3);
				}
				if (base.EffectiveGridSize == 0f)
				{
					m_deltaX = 0f;
					m_deltaY = 0f;
				}
				for (int i = 0; i < Targets.Length; i++)
				{
					Targets[i].rotation *= quaternion;
				}
			}

			protected override void DrawOverride()
			{
				RuntimeHandles.DoRotationHandle(base.Target.rotation, base.Target.position, base.SelectedAxis);
			}
		}
		public enum RuntimeHandleAxis
		{
			None,
			X,
			Y,
			Z,
			XY,
			XZ,
			YZ,
			Screen,
			Free
		}
		public static class RuntimeHandles
		{
			public static readonly Color32 XColor;

			public static readonly Color32 XColorTransparent;

			public static readonly Color32 YColor;

			public static readonly Color32 YColorTransparent;

			public static readonly Color32 ZColor;

			public static readonly Color32 ZColorTransparent;

			public static readonly Color32 AltColor;

			public static readonly Color32 SelectionColor;

			private static readonly Mesh Arrows;

			private static readonly Mesh SelectionArrowY;

			private static readonly Mesh SelectionArrowX;

			private static readonly Mesh SelectionArrowZ;

			private static readonly Mesh SelectionCube;

			private static readonly Mesh CubeX;

			private static readonly Mesh CubeY;

			private static readonly Mesh CubeZ;

			private static readonly Mesh CubeUniform;

			private static readonly Mesh SceneGizmoSelectedAxis;

			private static readonly Mesh SceneGizmoXAxis;

			private static readonly Mesh SceneGizmoYAxis;

			private static readonly Mesh SceneGizmoZAxis;

			private static readonly Mesh SceneGizmoCube;

			private static readonly Mesh SceneGizmoSelectedCube;

			private static readonly Mesh SceneGizmoQuad;

			private static readonly Material ShapesMaterialZTest;

			private static readonly Material ShapesMaterialZTest2;

			private static readonly Material ShapesMaterialZTest3;

			private static readonly Material ShapesMaterialZTest4;

			private static readonly Material ShapesMaterialZTestOffset;

			private static readonly Material ShapesMaterial;

			private static readonly Material LinesMaterial;

			private static readonly Material LinesClipMaterial;

			private static readonly Material LinesBillboardMaterial;

			private static readonly Material XMaterial;

			private static readonly Material YMaterial;

			private static readonly Material ZMaterial;

			private static readonly Material GridMaterial;

			static RuntimeHandles()
			{
				XColor = new Color32(187, 70, 45, byte.MaxValue);
				XColorTransparent = new Color32(187, 70, 45, 128);
				YColor = new Color32(139, 206, 74, byte.MaxValue);
				YColorTransparent = new Color32(139, 206, 74, 128);
				ZColor = new Color32(55, 115, 244, byte.MaxValue);
				ZColorTransparent = new Color32(55, 115, 244, 128);
				AltColor = new Color32(192, 192, 192, 224);
				SelectionColor = new Color32(239, 238, 64, byte.MaxValue);
				LinesMaterial = new Material(Shader.Find("Battlehub/RTHandles/VertexColor"));
				LinesMaterial.color = Color.white;
				LinesClipMaterial = new Material(Shader.Find("Battlehub/RTHandles/VertexColorClip"));
				LinesClipMaterial.color = Color.white;
				LinesBillboardMaterial = new Material(Shader.Find("Battlehub/RTHandles/VertexColorBillboard"));
				LinesBillboardMaterial.color = Color.white;
				ShapesMaterial = new Material(Shader.Find("Battlehub/RTHandles/Shape"));
				ShapesMaterial.color = Color.white;
				ShapesMaterialZTest = new Material(Shader.Find("Battlehub/RTHandles/Shape"));
				ShapesMaterialZTest.color = new Color(1f, 1f, 1f, 0f);
				ShapesMaterialZTest.SetFloat("_ZTest", 4f);
				ShapesMaterialZTest.SetFloat("_ZWrite", 1f);
				ShapesMaterialZTestOffset = new Material(Shader.Find("Battlehub/RTHandles/Shape"));
				ShapesMaterialZTestOffset.color = new Color(1f, 1f, 1f, 1f);
				ShapesMaterialZTestOffset.SetFloat("_ZTest", 4f);
				ShapesMaterialZTestOffset.SetFloat("_ZWrite", 1f);
				ShapesMaterialZTestOffset.SetFloat("_OFactors", -1f);
				ShapesMaterialZTestOffset.SetFloat("_OUnits", -1f);
				ShapesMaterialZTest2 = new Material(Shader.Find("Battlehub/RTHandles/Shape"));
				ShapesMaterialZTest2.color = new Color(1f, 1f, 1f, 0f);
				ShapesMaterialZTest2.SetFloat("_ZTest", 4f);
				ShapesMaterialZTest2.SetFloat("_ZWrite", 1f);
				ShapesMaterialZTest3 = new Material(Shader.Find("Battlehub/RTHandles/Shape"));
				ShapesMaterialZTest3.color = new Color(1f, 1f, 1f, 0f);
				ShapesMaterialZTest3.SetFloat("_ZTest", 4f);
				ShapesMaterialZTest3.SetFloat("_ZWrite", 1f);
				ShapesMaterialZTest4 = new Material(Shader.Find("Battlehub/RTHandles/Shape"));
				ShapesMaterialZTest4.color = new Color(1f, 1f, 1f, 0f);
				ShapesMaterialZTest4.SetFloat("_ZTest", 4f);
				ShapesMaterialZTest4.SetFloat("_ZWrite", 1f);
				XMaterial = new Material(Shader.Find("Battlehub/RTHandles/Billboard"));
				XMaterial.color = Color.white;
				XMaterial.mainTexture = Resources.Load<Texture>("Battlehub.RuntimeHandles.x");
				YMaterial = new Material(Shader.Find("Battlehub/RTHandles/Billboard"));
				YMaterial.color = Color.white;
				YMaterial.mainTexture = Resources.Load<Texture>("Battlehub.RuntimeHandles.y");
				ZMaterial = new Material(Shader.Find("Battlehub/RTHandles/Billboard"));
				ZMaterial.color = Color.white;
				ZMaterial.mainTexture = Resources.Load<Texture>("Battlehub.RuntimeHandles.z");
				GridMaterial = new Material(Shader.Find("Battlehub/RTHandles/Grid"));
				GridMaterial.color = Color.white;
				Mesh mesh = CreateConeMesh(SelectionColor);
				CombineInstance combineInstance = new CombineInstance
				{
					mesh = mesh,
					transform = Matrix4x4.TRS(Vector3.up, Quaternion.identity, Vector3.one)
				};
				SelectionArrowY = new Mesh();
				SelectionArrowY.CombineMeshes(new CombineInstance[1] { combineInstance }, mergeSubMeshes: true);
				SelectionArrowY.RecalculateNormals();
				CombineInstance combineInstance2 = new CombineInstance
				{
					mesh = mesh,
					transform = Matrix4x4.TRS(Vector3.right, Quaternion.AngleAxis(-90f, Vector3.forward), Vector3.one)
				};
				SelectionArrowX = new Mesh();
				SelectionArrowX.CombineMeshes(new CombineInstance[1] { combineInstance2 }, mergeSubMeshes: true);
				SelectionArrowX.RecalculateNormals();
				CombineInstance combineInstance3 = new CombineInstance
				{
					mesh = mesh,
					transform = Matrix4x4.TRS(Vector3.forward, Quaternion.AngleAxis(90f, Vector3.right), Vector3.one)
				};
				SelectionArrowZ = new Mesh();
				SelectionArrowZ.CombineMeshes(new CombineInstance[1] { combineInstance3 }, mergeSubMeshes: true);
				SelectionArrowZ.RecalculateNormals();
				combineInstance.mesh = CreateConeMesh(YColor);
				combineInstance2.mesh = CreateConeMesh(XColor);
				combineInstance3.mesh = CreateConeMesh(ZColor);
				Arrows = new Mesh();
				Arrows.CombineMeshes(new CombineInstance[3] { combineInstance, combineInstance2, combineInstance3 }, mergeSubMeshes: true);
				Arrows.RecalculateNormals();
				SelectionCube = CreateCubeMesh(SelectionColor, 0.1f, 0.1f, 0.1f);
				CubeX = CreateCubeMesh(XColor, 0.1f, 0.1f, 0.1f);
				CubeY = CreateCubeMesh(YColor, 0.1f, 0.1f, 0.1f);
				CubeZ = CreateCubeMesh(ZColor, 0.1f, 0.1f, 0.1f);
				CubeUniform = CreateCubeMesh(AltColor, 0.1f, 0.1f, 0.1f);
				SceneGizmoSelectedAxis = CreateSceneGizmoHalfAxis(SelectionColor, Quaternion.AngleAxis(90f, Vector3.right));
				SceneGizmoXAxis = CreateSceneGizmoAxis(XColor, AltColor, Quaternion.AngleAxis(-90f, Vector3.forward));
				SceneGizmoYAxis = CreateSceneGizmoAxis(YColor, AltColor, Quaternion.identity);
				SceneGizmoZAxis = CreateSceneGizmoAxis(ZColor, AltColor, Quaternion.AngleAxis(90f, Vector3.right));
				SceneGizmoCube = CreateCubeMesh(AltColor);
				SceneGizmoSelectedCube = CreateCubeMesh(SelectionColor);
				SceneGizmoQuad = CreateQuadMesh();
			}

			private static Mesh CreateQuadMesh(float quadWidth = 1f, float cubeHeight = 1f)
			{
				Vector3 vector = new Vector3((0f - quadWidth) * 0.5f, (0f - cubeHeight) * 0.5f, 0f);
				Vector3 vector2 = new Vector3(quadWidth * 0.5f, (0f - cubeHeight) * 0.5f, 0f);
				Vector3 vector3 = new Vector3((0f - quadWidth) * 0.5f, cubeHeight * 0.5f, 0f);
				Vector3 vector4 = new Vector3(quadWidth * 0.5f, cubeHeight * 0.5f, 0f);
				Vector3[] vertices = new Vector3[4] { vector3, vector4, vector2, vector };
				int[] triangles = new int[6] { 3, 1, 0, 3, 2, 1 };
				Vector2[] uv = new Vector2[4]
				{
					new Vector2(1f, 0f),
					new Vector2(0f, 0f),
					new Vector2(0f, 1f),
					new Vector2(1f, 1f)
				};
				Mesh mesh = new Mesh();
				mesh.name = "quad";
				mesh.vertices = vertices;
				mesh.triangles = triangles;
				mesh.uv = uv;
				mesh.RecalculateNormals();
				return mesh;
			}

			private static Mesh CreateCubeMesh(Color color, float cubeLength = 1f, float cubeWidth = 1f, float cubeHeight = 1f)
			{
				Vector3 vector = new Vector3((0f - cubeLength) * 0.5f, (0f - cubeWidth) * 0.5f, cubeHeight * 0.5f);
				Vector3 vector2 = new Vector3(cubeLength * 0.5f, (0f - cubeWidth) * 0.5f, cubeHeight * 0.5f);
				Vector3 vector3 = new Vector3(cubeLength * 0.5f, (0f - cubeWidth) * 0.5f, (0f - cubeHeight) * 0.5f);
				Vector3 vector4 = new Vector3((0f - cubeLength) * 0.5f, (0f - cubeWidth) * 0.5f, (0f - cubeHeight) * 0.5f);
				Vector3 vector5 = new Vector3((0f - cubeLength) * 0.5f, cubeWidth * 0.5f, cubeHeight * 0.5f);
				Vector3 vector6 = new Vector3(cubeLength * 0.5f, cubeWidth * 0.5f, cubeHeight * 0.5f);
				Vector3 vector7 = new Vector3(cubeLength * 0.5f, cubeWidth * 0.5f, (0f - cubeHeight) * 0.5f);
				Vector3 vector8 = new Vector3((0f - cubeLength) * 0.5f, cubeWidth * 0.5f, (0f - cubeHeight) * 0.5f);
				Vector3[] array = new Vector3[24]
				{
					vector, vector2, vector3, vector4, vector8, vector5, vector, vector4, vector5, vector6,
					vector2, vector, vector7, vector8, vector4, vector3, vector6, vector7, vector3, vector2,
					vector8, vector7, vector6, vector5
				};
				int[] triangles = new int[36]
				{
					3, 1, 0, 3, 2, 1, 7, 5, 4, 7,
					6, 5, 11, 9, 8, 11, 10, 9, 15, 13,
					12, 15, 14, 13, 19, 17, 16, 19, 18, 17,
					23, 21, 20, 23, 22, 21
				};
				Color[] array2 = new Color[array.Length];
				for (int i = 0; i < array2.Length; i++)
				{
					array2[i] = color;
				}
				Mesh mesh = new Mesh();
				mesh.name = "cube";
				mesh.vertices = array;
				mesh.triangles = triangles;
				mesh.colors = array2;
				mesh.RecalculateNormals();
				return mesh;
			}

			private static Mesh CreateConeMesh(Color color)
			{
				int num = 12;
				float num2 = 0.2f;
				Vector3[] array = new Vector3[num * 3 + 1];
				int[] array2 = new int[num * 6];
				Color[] array3 = new Color[array.Length];
				for (int i = 0; i < array3.Length; i++)
				{
					array3[i] = color;
				}
				float num3 = num2 / 2.6f;
				float num4 = num2;
				float num5 = (float)Math.PI * 2f / (float)num;
				float y = 0f - num4;
				array[array.Length - 1] = new Vector3(0f, 0f - num4, 0f);
				for (int j = 0; j < num; j++)
				{
					float f = (float)j * num5;
					float x = Mathf.Cos(f) * num3;
					float z = Mathf.Sin(f) * num3;
					array[j] = new Vector3(x, y, z);
					array[num + j] = new Vector3(0f, 0.01f, 0f);
					array[2 * num + j] = array[j];
				}
				for (int k = 0; k < num; k++)
				{
					array2[k * 6] = k;
					array2[k * 6 + 1] = num + k;
					array2[k * 6 + 2] = (k + 1) % num;
					array2[k * 6 + 3] = array.Length - 1;
					array2[k * 6 + 4] = 2 * num + k;
					array2[k * 6 + 5] = 2 * num + (k + 1) % num;
				}
				return new Mesh
				{
					name = "Cone",
					vertices = array,
					triangles = array2,
					colors = array3
				};
			}

			private static Mesh CreateSceneGizmoHalfAxis(Color color, Quaternion rotation)
			{
				Mesh mesh = CreateConeMesh(color);
				CombineInstance combineInstance = default(CombineInstance);
				combineInstance.mesh = mesh;
				combineInstance.transform = Matrix4x4.TRS(Vector3.up * 0.1f, Quaternion.AngleAxis(180f, Vector3.right), Vector3.one);
				Mesh mesh2 = new Mesh();
				mesh2.CombineMeshes(new CombineInstance[1] { combineInstance }, mergeSubMeshes: true);
				CombineInstance combineInstance2 = default(CombineInstance);
				combineInstance2.mesh = mesh2;
				combineInstance2.transform = Matrix4x4.TRS(Vector3.zero, rotation, Vector3.one);
				mesh2 = new Mesh();
				mesh2.CombineMeshes(new CombineInstance[1] { combineInstance2 }, mergeSubMeshes: true);
				mesh2.RecalculateNormals();
				return mesh2;
			}

			private static Mesh CreateSceneGizmoAxis(Color axisColor, Color altColor, Quaternion rotation)
			{
				Mesh mesh = CreateConeMesh(axisColor);
				Mesh mesh2 = CreateConeMesh(altColor);
				CombineInstance combineInstance = default(CombineInstance);
				combineInstance.mesh = mesh;
				combineInstance.transform = Matrix4x4.TRS(Vector3.up * 0.1f, Quaternion.AngleAxis(180f, Vector3.right), Vector3.one);
				CombineInstance combineInstance2 = default(CombineInstance);
				combineInstance2.mesh = mesh2;
				combineInstance2.transform = Matrix4x4.TRS(Vector3.down * 0.1f, Quaternion.identity, Vector3.one);
				Mesh mesh3 = new Mesh();
				mesh3.CombineMeshes(new CombineInstance[2] { combineInstance, combineInstance2 }, mergeSubMeshes: true);
				CombineInstance combineInstance3 = default(CombineInstance);
				combineInstance3.mesh = mesh3;
				combineInstance3.transform = Matrix4x4.TRS(Vector3.zero, rotation, Vector3.one);
				mesh3 = new Mesh();
				mesh3.CombineMeshes(new CombineInstance[1] { combineInstance3 }, mergeSubMeshes: true);
				mesh3.RecalculateNormals();
				return mesh3;
			}

			public static float GetScreenScale(Vector3 position, Camera camera)
			{
				float num = camera.pixelHeight;
				if (camera.orthographic)
				{
					return camera.orthographicSize * 2f / num * 90f;
				}
				Transform transform = camera.transform;
				float num2 = Vector3.Dot(position - transform.position, transform.forward);
				return 2f * num2 * Mathf.Tan(camera.fieldOfView * 0.5f * ((float)Math.PI / 180f)) / num * 90f;
			}

			private static void DoAxes(Vector3 position, Matrix4x4 transform, RuntimeHandleAxis selectedAxis)
			{
				Vector3 right = Vector3.right;
				Vector3 up = Vector3.up;
				Vector3 forward = Vector3.forward;
				right = transform.MultiplyVector(right);
				up = transform.MultiplyVector(up);
				forward = transform.MultiplyVector(forward);
				GL.Color((selectedAxis != RuntimeHandleAxis.X) ? XColor : SelectionColor);
				GL.Vertex(position);
				GL.Vertex(position + right);
				GL.Color((selectedAxis != RuntimeHandleAxis.Y) ? YColor : SelectionColor);
				GL.Vertex(position);
				GL.Vertex(position + up);
				GL.Color((selectedAxis != RuntimeHandleAxis.Z) ? ZColor : SelectionColor);
				GL.Vertex(position);
				GL.Vertex(position + forward);
			}

			public static void DoPositionHandle(Vector3 position, Quaternion rotation, RuntimeHandleAxis selectedAxis = RuntimeHandleAxis.None)
			{
				float screenScale = GetScreenScale(position, Camera.current);
				Matrix4x4 matrix4x = Matrix4x4.TRS(position, rotation, new Vector3(screenScale, screenScale, screenScale));
				LinesMaterial.SetPass(0);
				GL.Begin(1);
				DoAxes(position, matrix4x, selectedAxis);
				Vector3 vector = Vector3.right * 0.2f;
				Vector3 vector2 = Vector3.up * 0.2f;
				Vector3 vector3 = Vector3.forward * 0.2f;
				Vector3 lhs = Camera.current.transform.position - position;
				float num = Mathf.Sign(Vector3.Dot(lhs, vector));
				float num2 = Mathf.Sign(Vector3.Dot(lhs, vector2));
				float num3 = Mathf.Sign(Vector3.Dot(lhs, vector3));
				vector.x *= num;
				vector2.y *= num2;
				vector3.z *= num3;
				Vector3 point = vector + vector2;
				Vector3 point2 = vector + vector3;
				Vector3 point3 = vector2 + vector3;
				vector = matrix4x.MultiplyPoint(vector);
				vector2 = matrix4x.MultiplyPoint(vector2);
				vector3 = matrix4x.MultiplyPoint(vector3);
				point = matrix4x.MultiplyPoint(point);
				point2 = matrix4x.MultiplyPoint(point2);
				point3 = matrix4x.MultiplyPoint(point3);
				GL.Color((selectedAxis != RuntimeHandleAxis.XZ) ? YColor : SelectionColor);
				GL.Vertex(position);
				GL.Vertex(vector3);
				GL.Vertex(vector3);
				GL.Vertex(point2);
				GL.Vertex(point2);
				GL.Vertex(vector);
				GL.Vertex(vector);
				GL.Vertex(position);
				GL.Color((selectedAxis != RuntimeHandleAxis.XY) ? ZColor : SelectionColor);
				GL.Vertex(position);
				GL.Vertex(vector2);
				GL.Vertex(vector2);
				GL.Vertex(point);
				GL.Vertex(point);
				GL.Vertex(vector);
				GL.Vertex(vector);
				GL.Vertex(position);
				GL.Color((selectedAxis != RuntimeHandleAxis.YZ) ? XColor : SelectionColor);
				GL.Vertex(position);
				GL.Vertex(vector2);
				GL.Vertex(vector2);
				GL.Vertex(point3);
				GL.Vertex(point3);
				GL.Vertex(vector3);
				GL.Vertex(vector3);
				GL.Vertex(position);
				GL.End();
				GL.Begin(7);
				GL.Color(YColorTransparent);
				GL.Vertex(position);
				GL.Vertex(vector3);
				GL.Vertex(point2);
				GL.Vertex(vector);
				GL.Color(ZColorTransparent);
				GL.Vertex(position);
				GL.Vertex(vector2);
				GL.Vertex(point);
				GL.Vertex(vector);
				GL.Color(XColorTransparent);
				GL.Vertex(position);
				GL.Vertex(vector2);
				GL.Vertex(point3);
				GL.Vertex(vector3);
				GL.End();
				ShapesMaterial.SetPass(0);
				Graphics.DrawMeshNow(Arrows, matrix4x);
				switch (selectedAxis)
				{
				case RuntimeHandleAxis.X:
					Graphics.DrawMeshNow(SelectionArrowX, matrix4x);
					break;
				case RuntimeHandleAxis.Y:
					Graphics.DrawMeshNow(SelectionArrowY, matrix4x);
					break;
				case RuntimeHandleAxis.Z:
					Graphics.DrawMeshNow(SelectionArrowZ, matrix4x);
					break;
				}
			}

			public static void DoRotationHandle(Quaternion rotation, Vector3 position, RuntimeHandleAxis selectedAxis = RuntimeHandleAxis.None)
			{
				float screenScale = GetScreenScale(position, Camera.current);
				float num = 1f;
				Vector3 s = new Vector3(screenScale, screenScale, screenScale);
				Matrix4x4 transform = Matrix4x4.TRS(Vector3.zero, rotation * Quaternion.AngleAxis(-90f, Vector3.up), Vector3.one);
				Matrix4x4 transform2 = Matrix4x4.TRS(Vector3.zero, rotation * Quaternion.AngleAxis(-90f, Vector3.right), Vector3.one);
				Matrix4x4 transform3 = Matrix4x4.TRS(Vector3.zero, rotation, Vector3.one);
				Matrix4x4 m = Matrix4x4.TRS(position, Quaternion.identity, s);
				LinesClipMaterial.SetPass(0);
				GL.PushMatrix();
				GL.MultMatrix(m);
				GL.Begin(1);
				GL.Color((selectedAxis != RuntimeHandleAxis.X) ? XColor : SelectionColor);
				DrawCircle(transform, num);
				GL.Color((selectedAxis != RuntimeHandleAxis.Y) ? YColor : SelectionColor);
				DrawCircle(transform2, num);
				GL.Color((selectedAxis != RuntimeHandleAxis.Z) ? ZColor : SelectionColor);
				DrawCircle(transform3, num);
				GL.End();
				GL.PopMatrix();
				LinesBillboardMaterial.SetPass(0);
				GL.PushMatrix();
				GL.MultMatrix(m);
				GL.Begin(1);
				GL.Color((selectedAxis != RuntimeHandleAxis.Free) ? AltColor : SelectionColor);
				DrawCircle(Matrix4x4.identity, num);
				GL.Color((selectedAxis != RuntimeHandleAxis.Screen) ? AltColor : SelectionColor);
				DrawCircle(Matrix4x4.identity, num * 1.1f);
				GL.End();
				GL.PopMatrix();
			}

			private static void DrawCircle(Matrix4x4 transform, float radius)
			{
				float num = 0f;
				float z = 0f;
				Vector3 v = transform.MultiplyPoint(new Vector3(radius, 0f, z));
				for (int i = 0; i < 32; i++)
				{
					GL.Vertex(v);
					num += (float)Math.PI / 16f;
					float x = radius * Mathf.Cos(num);
					float y = radius * Mathf.Sin(num);
					Vector3 vector = transform.MultiplyPoint(new Vector3(x, y, z));
					GL.Vertex(vector);
					v = vector;
				}
			}

			public static void DoScaleHandle(Vector3 scale, Vector3 position, Quaternion rotation, RuntimeHandleAxis selectedAxis = RuntimeHandleAxis.None)
			{
				float screenScale = GetScreenScale(position, Camera.current);
				Matrix4x4 transform = Matrix4x4.TRS(position, rotation, scale * screenScale);
				LinesMaterial.SetPass(0);
				GL.Begin(1);
				DoAxes(position, transform, selectedAxis);
				GL.End();
				Matrix4x4 matrix4x = Matrix4x4.TRS(Vector3.zero, rotation, scale);
				ShapesMaterial.SetPass(0);
				Vector3 vector = new Vector3(screenScale, screenScale, screenScale);
				Vector3 vector2 = matrix4x.MultiplyVector(Vector3.right) * screenScale;
				Vector3 vector3 = matrix4x.MultiplyVector(Vector3.up) * screenScale;
				Vector3 vector4 = matrix4x.MultiplyVector(Vector3.forward) * screenScale;
				switch (selectedAxis)
				{
				case RuntimeHandleAxis.X:
					Graphics.DrawMeshNow(SelectionCube, Matrix4x4.TRS(position + vector2, rotation, vector));
					Graphics.DrawMeshNow(CubeY, Matrix4x4.TRS(position + vector3, rotation, vector));
					Graphics.DrawMeshNow(CubeZ, Matrix4x4.TRS(position + vector4, rotation, vector));
					Graphics.DrawMeshNow(CubeUniform, Matrix4x4.TRS(position, rotation, vector * 1.35f));
					break;
				case RuntimeHandleAxis.Y:
					Graphics.DrawMeshNow(CubeX, Matrix4x4.TRS(position + vector2, rotation, vector));
					Graphics.DrawMeshNow(SelectionCube, Matrix4x4.TRS(position + vector3, rotation, vector));
					Graphics.DrawMeshNow(CubeZ, Matrix4x4.TRS(position + vector4, rotation, vector));
					Graphics.DrawMeshNow(CubeUniform, Matrix4x4.TRS(position, rotation, vector * 1.35f));
					break;
				case RuntimeHandleAxis.Z:
					Graphics.DrawMeshNow(CubeX, Matrix4x4.TRS(position + vector2, rotation, vector));
					Graphics.DrawMeshNow(CubeY, Matrix4x4.TRS(position + vector3, rotation, vector));
					Graphics.DrawMeshNow(SelectionCube, Matrix4x4.TRS(position + vector4, rotation, vector));
					Graphics.DrawMeshNow(CubeUniform, Matrix4x4.TRS(position, rotation, vector * 1.35f));
					break;
				case RuntimeHandleAxis.Free:
					Graphics.DrawMeshNow(CubeX, Matrix4x4.TRS(position + vector2, rotation, vector));
					Graphics.DrawMeshNow(CubeY, Matrix4x4.TRS(position + vector3, rotation, vector));
					Graphics.DrawMeshNow(CubeZ, Matrix4x4.TRS(position + vector4, rotation, vector));
					Graphics.DrawMeshNow(SelectionCube, Matrix4x4.TRS(position, rotation, vector * 1.35f));
					break;
				default:
					Graphics.DrawMeshNow(CubeX, Matrix4x4.TRS(position + vector2, rotation, vector));
					Graphics.DrawMeshNow(CubeY, Matrix4x4.TRS(position + vector3, rotation, vector));
					Graphics.DrawMeshNow(CubeZ, Matrix4x4.TRS(position + vector4, rotation, vector));
					Graphics.DrawMeshNow(CubeUniform, Matrix4x4.TRS(position, rotation, vector * 1.35f));
					break;
				}
			}

			public static void DoSceneGizmo(Vector3 position, Quaternion rotation, Vector3 selection, float gizmoScale, float xAlpha = 1f, float yAlpha = 1f, float zAlpha = 1f)
			{
				float num = GetScreenScale(position, Camera.current) * gizmoScale;
				Vector3 vector = new Vector3(num, num, num);
				float billboardOffset = 0.4f;
				if (Camera.current.orthographic)
				{
					billboardOffset = 0.42f;
				}
				if (selection != Vector3.zero)
				{
					if (selection == Vector3.one)
					{
						ShapesMaterialZTestOffset.SetPass(0);
						Graphics.DrawMeshNow(SceneGizmoSelectedCube, Matrix4x4.TRS(position, rotation, vector * 0.15f));
					}
					else if ((xAlpha == 1f || xAlpha == 0f) && (yAlpha == 1f || yAlpha == 0f) && (zAlpha == 1f || zAlpha == 0f))
					{
						ShapesMaterialZTestOffset.SetPass(0);
						Graphics.DrawMeshNow(SceneGizmoSelectedAxis, Matrix4x4.TRS(position, rotation * Quaternion.LookRotation(selection, Vector3.up), vector));
					}
				}
				ShapesMaterialZTest.SetPass(0);
				ShapesMaterialZTest.color = Color.white;
				Graphics.DrawMeshNow(SceneGizmoCube, Matrix4x4.TRS(position, rotation, vector * 0.15f));
				if (xAlpha == 1f && yAlpha == 1f && zAlpha == 1f)
				{
					Graphics.DrawMeshNow(SceneGizmoXAxis, Matrix4x4.TRS(position, rotation, vector));
					Graphics.DrawMeshNow(SceneGizmoYAxis, Matrix4x4.TRS(position, rotation, vector));
					Graphics.DrawMeshNow(SceneGizmoZAxis, Matrix4x4.TRS(position, rotation, vector));
				}
				else if (xAlpha < 1f)
				{
					ShapesMaterialZTest3.SetPass(0);
					ShapesMaterialZTest3.color = new Color(1f, 1f, 1f, yAlpha);
					Graphics.DrawMeshNow(SceneGizmoYAxis, Matrix4x4.TRS(position, rotation, vector));
					ShapesMaterialZTest4.SetPass(0);
					ShapesMaterialZTest4.color = new Color(1f, 1f, 1f, zAlpha);
					Graphics.DrawMeshNow(SceneGizmoZAxis, Matrix4x4.TRS(position, rotation, vector));
					ShapesMaterialZTest2.SetPass(0);
					ShapesMaterialZTest2.color = new Color(1f, 1f, 1f, xAlpha);
					Graphics.DrawMeshNow(SceneGizmoXAxis, Matrix4x4.TRS(position, rotation, vector));
					XMaterial.SetPass(0);
				}
				else if (yAlpha < 1f)
				{
					ShapesMaterialZTest4.SetPass(0);
					ShapesMaterialZTest4.color = new Color(1f, 1f, 1f, zAlpha);
					Graphics.DrawMeshNow(SceneGizmoZAxis, Matrix4x4.TRS(position, rotation, vector));
					ShapesMaterialZTest2.SetPass(0);
					ShapesMaterialZTest2.color = new Color(1f, 1f, 1f, xAlpha);
					Graphics.DrawMeshNow(SceneGizmoXAxis, Matrix4x4.TRS(position, rotation, vector));
					ShapesMaterialZTest3.SetPass(0);
					ShapesMaterialZTest3.color = new Color(1f, 1f, 1f, yAlpha);
					Graphics.DrawMeshNow(SceneGizmoYAxis, Matrix4x4.TRS(position, rotation, vector));
				}
				else
				{
					ShapesMaterialZTest2.SetPass(0);
					ShapesMaterialZTest2.color = new Color(1f, 1f, 1f, xAlpha);
					Graphics.DrawMeshNow(SceneGizmoXAxis, Matrix4x4.TRS(position, rotation, vector));
					ShapesMaterialZTest3.SetPass(0);
					ShapesMaterialZTest3.color = new Color(1f, 1f, 1f, yAlpha);
					Graphics.DrawMeshNow(SceneGizmoYAxis, Matrix4x4.TRS(position, rotation, vector));
					ShapesMaterialZTest4.SetPass(0);
					ShapesMaterialZTest4.color = new Color(1f, 1f, 1f, zAlpha);
					Graphics.DrawMeshNow(SceneGizmoZAxis, Matrix4x4.TRS(position, rotation, vector));
				}
				XMaterial.SetPass(0);
				XMaterial.color = new Color(1f, 1f, 1f, xAlpha);
				DragSceneGizmoAxis(position, rotation, Vector3.right, gizmoScale, 0.125f, billboardOffset, num);
				YMaterial.SetPass(0);
				YMaterial.color = new Color(1f, 1f, 1f, yAlpha);
				DragSceneGizmoAxis(position, rotation, Vector3.up, gizmoScale, 0.125f, billboardOffset, num);
				ZMaterial.SetPass(0);
				ZMaterial.color = new Color(1f, 1f, 1f, zAlpha);
				DragSceneGizmoAxis(position, rotation, Vector3.forward, gizmoScale, 0.125f, billboardOffset, num);
			}

			private static void DragSceneGizmoAxis(Vector3 position, Quaternion rotation, Vector3 axis, float gizmoScale, float billboardScale, float billboardOffset, float sScale)
			{
				Vector3 vector = Vector3.Reflect(Camera.current.transform.forward, axis) * 0.1f;
				float num = Vector3.Dot(Camera.current.transform.forward, axis);
				if (num > 0f)
				{
					if (Camera.current.orthographic)
					{
						vector += axis * num * 0.4f;
					}
					else
					{
						vector = axis * num * 0.7f;
					}
				}
				else if (Camera.current.orthographic)
				{
					vector -= axis * num * 0.1f;
				}
				else
				{
					vector = Vector3.zero;
				}
				Vector3 vector2 = position + (axis + vector) * billboardOffset * sScale;
				float num2 = GetScreenScale(vector2, Camera.current) * gizmoScale;
				Graphics.DrawMeshNow(matrix: Matrix4x4.TRS(vector2, rotation, new Vector3(num2, num2, num2) * billboardScale), mesh: SceneGizmoQuad);
			}

			public static float GetGridFarPlane()
			{
				float num = CountOfDigits(Camera.current.transform.position.y);
				return Mathf.Pow(10f, num - 1f) * 150f;
			}

			public static void DrawGrid()
			{
				Vector3 position = Camera.current.transform.position;
				float y = position.y;
				y = Mathf.Abs(y);
				y = Mathf.Max(1f, y);
				float num = CountOfDigits(y);
				float num2 = Mathf.Pow(10f, num - 1f);
				float num3 = Mathf.Pow(10f, num);
				float num4 = Mathf.Pow(10f, num + 1f);
				float alpha = 1f - (y - num2) / (num3 - num2);
				float alpha2 = (y * 10f - num3) / (num4 - num3);
				DrawGrid(position, num2, alpha, y * 20f);
				DrawGrid(position, num3, alpha2, y * 20f);
			}

			private static void DrawGrid(Vector3 cameraPosition, float spacing, float alpha, float fadeDisance)
			{
				cameraPosition.y = 0f;
				GridMaterial.SetFloat("_FadeDistance", fadeDisance);
				GridMaterial.SetPass(0);
				GL.Begin(1);
				GL.Color(new Color(1f, 1f, 1f, 0.1f * alpha));
				cameraPosition.x = Mathf.Floor(cameraPosition.x / spacing) * spacing;
				cameraPosition.z = Mathf.Floor(cameraPosition.z / spacing) * spacing;
				for (int i = -150; i < 150; i++)
				{
					GL.Vertex(cameraPosition + new Vector3((float)i * spacing, 0f, -150f * spacing));
					GL.Vertex(cameraPosition + new Vector3((float)i * spacing, 0f, 150f * spacing));
					GL.Vertex(cameraPosition + new Vector3(-150f * spacing, 0f, (float)i * spacing));
					GL.Vertex(cameraPosition + new Vector3(150f * spacing, 0f, (float)i * spacing));
				}
				GL.End();
			}

			public static float CountOfDigits(float number)
			{
				if (number != 0f)
				{
					return Mathf.Ceil(Mathf.Log10(Mathf.Abs(number) + 0.5f));
				}
				return 1f;
			}
		}
		public class ScaleHandle : BaseHandle
		{
			public float GridSize = 0.1f;

			private Vector3 m_prevPoint;

			private Matrix4x4 m_matrix;

			private Matrix4x4 m_inverse;

			private Vector3 m_roundedScale;

			private Vector3 m_scale;

			private Vector3[] m_refScales;

			private float m_screenScale;

			public static ScaleHandle Current { get; private set; }

			protected override RuntimeTool Tool => RuntimeTool.Scale;

			protected override float CurrentGridSize => GridSize;

			protected override void StartOverride()
			{
				Current = this;
				m_scale = Vector3.one;
				m_roundedScale = m_scale;
			}

			protected override void OnDestroyOverride()
			{
				if (Current == this)
				{
					Current = null;
				}
			}

			protected override bool OnBeginDrag()
			{
				m_screenScale = RuntimeHandles.GetScreenScale(base.transform.position, Camera);
				m_matrix = Matrix4x4.TRS(base.transform.position, base.Rotation, Vector3.one);
				m_inverse = m_matrix.inverse;
				Matrix4x4 matrix = Matrix4x4.TRS(base.transform.position, base.Rotation, new Vector3(m_screenScale, m_screenScale, m_screenScale));
				if (HitCenter())
				{
					base.SelectedAxis = RuntimeHandleAxis.Free;
					base.DragPlane = GetDragPlane();
				}
				else
				{
					if (!(HitAxis(Vector3.up, matrix, out var distanceToAxis) | HitAxis(Vector3.forward, matrix, out var distanceToAxis2) | HitAxis(Vector3.right, matrix, out var distanceToAxis3)))
					{
						base.SelectedAxis = RuntimeHandleAxis.None;
						return false;
					}
					if (distanceToAxis <= distanceToAxis2 && distanceToAxis <= distanceToAxis3)
					{
						base.SelectedAxis = RuntimeHandleAxis.Y;
					}
					else if (distanceToAxis3 <= distanceToAxis && distanceToAxis3 <= distanceToAxis2)
					{
						base.SelectedAxis = RuntimeHandleAxis.X;
					}
					else
					{
						base.SelectedAxis = RuntimeHandleAxis.Z;
					}
				}
				m_refScales = new Vector3[Targets.Length];
				for (int i = 0; i < m_refScales.Length; i++)
				{
					Quaternion quaternion = ((RuntimeTools.PivotRotation == RuntimePivotRotation.Global) ? Targets[i].rotation : Quaternion.identity);
					m_refScales[i] = quaternion * base.Target.localScale;
				}
				base.DragPlane = GetDragPlane();
				return GetPointOnDragPlane(Input.mousePosition, out m_prevPoint);
			}

			protected override void OnDrag()
			{
				if (GetPointOnDragPlane(Input.mousePosition, out var point))
				{
					Vector3 vector = m_inverse.MultiplyVector((point - m_prevPoint) / m_screenScale);
					float magnitude = vector.magnitude;
					if (base.SelectedAxis == RuntimeHandleAxis.X)
					{
						vector.y = (vector.z = 0f);
						m_scale.x += Mathf.Sign(vector.x) * magnitude;
					}
					else if (base.SelectedAxis == RuntimeHandleAxis.Y)
					{
						vector.x = (vector.z = 0f);
						m_scale.y += Mathf.Sign(vector.y) * magnitude;
					}
					else if (base.SelectedAxis == RuntimeHandleAxis.Z)
					{
						vector.x = (vector.y = 0f);
						m_scale.z += Mathf.Sign(vector.z) * magnitude;
					}
					if (base.SelectedAxis == RuntimeHandleAxis.Free)
					{
						float num = Mathf.Sign(vector.x + vector.y);
						m_scale.x += num * magnitude;
						m_scale.y += num * magnitude;
						m_scale.z += num * magnitude;
					}
					m_roundedScale = m_scale;
					if ((double)base.EffectiveGridSize > 0.01)
					{
						m_roundedScale.x = (float)Mathf.RoundToInt(m_roundedScale.x / base.EffectiveGridSize) * base.EffectiveGridSize;
						m_roundedScale.y = (float)Mathf.RoundToInt(m_roundedScale.y / base.EffectiveGridSize) * base.EffectiveGridSize;
						m_roundedScale.z = (float)Mathf.RoundToInt(m_roundedScale.z / base.EffectiveGridSize) * base.EffectiveGridSize;
					}
					for (int i = 0; i < m_refScales.Length; i++)
					{
						Quaternion rotation = ((RuntimeTools.PivotRotation == RuntimePivotRotation.Global) ? Targets[i].rotation : Quaternion.identity);
						Targets[i].localScale = Quaternion.Inverse(rotation) * Vector3.Scale(m_refScales[i], m_roundedScale);
					}
					m_prevPoint = point;
				}
			}

			protected override void OnDrop()
			{
				m_scale = Vector3.one;
				m_roundedScale = m_scale;
			}

			protected override void DrawOverride()
			{
				RuntimeHandles.DoScaleHandle(m_roundedScale, base.transform.position, base.Rotation, base.SelectedAxis);
			}
		}
		[RequireComponent(typeof(Camera))]
		public class SceneGizmo : MonoBehaviour
		{
			public Camera SceneCamera;

			public Transform Pivot;

			public Vector2 Size = new Vector2(96f, 96f);

			public UnityEvent OrientationChanging;

			public UnityEvent OrientationChanged;

			public UnityEvent ProjectionChanged;

			private float m_aspect;

			private Camera m_camera;

			private float m_xAlpha = 1f;

			private float m_yAlpha = 1f;

			private float m_zAlpha = 1f;

			private float m_animationDuration = 0.2f;

			private GUIStyle m_buttonStyle;

			private GUIStyle m_oldButtonStyle;

			private Rect m_buttonRect;

			private bool m_mouseOver;

			private Vector3 m_selectedAxis;

			private GameObject m_collidersGO;

			private BoxCollider m_colliderProj;

			private BoxCollider m_colliderUp;

			private BoxCollider m_colliderDown;

			private BoxCollider m_colliderForward;

			private BoxCollider m_colliderBackward;

			private BoxCollider m_colliderLeft;

			private BoxCollider m_colliderRight;

			private Collider[] m_colliders;

			private Vector3 m_position;

			private Quaternion m_rotation;

			private Vector3 m_gizmoPosition;

			private IAnimationInfo m_rotateAnimation;

			private IAnimationInfo m_positionAnimation;

			private float m_screenHeight;

			private float m_screenWidth;

			private bool IsOrthographic
			{
				get
				{
					return m_camera.orthographic;
				}
				set
				{
					m_camera.orthographic = value;
					SceneCamera.orthographic = value;
					if (ProjectionChanged != null)
					{
						ProjectionChanged.Invoke();
						InitColliders();
					}
				}
			}

			private void Awake()
			{
				if (SceneCamera == null)
				{
					SceneCamera = Camera.main;
				}
				if (Pivot == null)
				{
					Pivot = base.transform;
				}
				m_collidersGO = new GameObject();
				m_collidersGO.transform.SetParent(base.transform, worldPositionStays: false);
				m_collidersGO.transform.position = GetGizmoPosition();
				m_collidersGO.transform.rotation = Quaternion.identity;
				m_collidersGO.name = "Colliders";
				m_colliderProj = m_collidersGO.AddComponent<BoxCollider>();
				m_colliderUp = m_collidersGO.AddComponent<BoxCollider>();
				m_colliderDown = m_collidersGO.AddComponent<BoxCollider>();
				m_colliderLeft = m_collidersGO.AddComponent<BoxCollider>();
				m_colliderRight = m_collidersGO.AddComponent<BoxCollider>();
				m_colliderForward = m_collidersGO.AddComponent<BoxCollider>();
				m_colliderBackward = m_collidersGO.AddComponent<BoxCollider>();
				Collider[] colliders = new BoxCollider[7] { m_colliderProj, m_colliderUp, m_colliderDown, m_colliderRight, m_colliderLeft, m_colliderForward, m_colliderBackward };
				m_colliders = colliders;
				DisableColliders();
				m_camera = GetComponent<Camera>();
				m_camera.clearFlags = CameraClearFlags.Depth;
				m_camera.renderingPath = RenderingPath.Forward;
				m_camera.cullingMask = 0;
				SceneCamera.orthographic = m_camera.orthographic;
				m_screenHeight = Screen.height;
				m_screenWidth = Screen.width;
				UpdateLayout();
				InitColliders();
				UpdateAlpha(ref m_xAlpha, Vector3.right, 1f);
				UpdateAlpha(ref m_yAlpha, Vector3.up, 1f);
				UpdateAlpha(ref m_zAlpha, Vector3.forward, 1f);
			}

			private void Start()
			{
				if (Run.Instance == null)
				{
					GameObject obj = new GameObject();
					obj.name = "Run";
					obj.AddComponent<Run>();
				}
			}

			public void UpdateLayout()
			{
				if (!(m_camera == null))
				{
					m_aspect = m_camera.aspect;
					m_camera.pixelRect = new Rect(SceneCamera.pixelRect.min.x + (float)SceneCamera.pixelWidth - Size.x, SceneCamera.pixelRect.min.y + (float)SceneCamera.pixelHeight - Size.y, Size.x, Size.y);
					m_camera.depth = SceneCamera.depth + 1f;
					m_aspect = m_camera.aspect;
					m_buttonRect = new Rect(SceneCamera.pixelRect.min.x + (float)SceneCamera.pixelWidth - Size.x / 2f - 20f, (float)Screen.height - SceneCamera.pixelRect.yMax + Size.y - 5f, 40f, 30f);
					m_buttonStyle = new GUIStyle();
					m_buttonStyle.alignment = TextAnchor.MiddleCenter;
					m_buttonStyle.normal.textColor = new Color(0.8f, 0.8f, 0.8f, 0.8f);
					m_buttonStyle.fontSize = 12;
				}
			}

			private Vector3 GetGizmoPosition()
			{
				return base.transform.TransformPoint(Vector3.forward * 5f);
			}

			private void OnPostRender()
			{
				RuntimeHandles.DoSceneGizmo(GetGizmoPosition(), Quaternion.identity, m_selectedAxis, Size.y / 96f, m_xAlpha, m_yAlpha, m_zAlpha);
			}

			private void OnGUI()
			{
				if (SceneCamera.orthographic)
				{
					if (GUI.Button(m_buttonRect, "Iso", m_buttonStyle))
					{
						IsOrthographic = false;
					}
				}
				else if (GUI.Button(m_buttonRect, "Persp", m_buttonStyle))
				{
					IsOrthographic = true;
				}
			}

			private void Update()
			{
				if (m_position != base.transform.position || m_rotation != base.transform.rotation)
				{
					InitColliders();
					m_position = base.transform.position;
					m_rotation = base.transform.rotation;
				}
				if (m_screenHeight != (float)Screen.height || m_screenWidth != (float)Screen.width)
				{
					m_screenHeight = Screen.height;
					m_screenWidth = Screen.width;
					UpdateLayout();
				}
				if (m_aspect != m_camera.aspect)
				{
					m_camera.pixelRect = new Rect((float)SceneCamera.pixelWidth - Size.x, (float)SceneCamera.pixelHeight - Size.y, Size.x, Size.y);
					m_aspect = m_camera.aspect;
				}
				float delta = Time.deltaTime / m_animationDuration;
				bool flag = UpdateAlpha(ref m_xAlpha, Vector3.right, delta);
				flag |= UpdateAlpha(ref m_yAlpha, Vector3.up, delta);
				flag |= UpdateAlpha(ref m_zAlpha, Vector3.forward, delta);
				m_camera.transform.rotation = SceneCamera.transform.rotation;
				Vector2 vector = Input.mousePosition;
				vector.y = (float)Screen.height - vector.y;
				bool flag3 = (RuntimeTools.IsSceneGizmoSelected = m_buttonRect.Contains(vector, allowInverse: true));
				if (m_camera.pixelRect.Contains(Input.mousePosition))
				{
					if (!m_mouseOver || flag)
					{
						EnableColliders();
					}
					Collider collider = HitTest();
					if (collider == null || (m_rotateAnimation != null && m_rotateAnimation.InProgress))
					{
						m_selectedAxis = Vector3.zero;
					}
					else if (collider == m_colliderProj)
					{
						m_selectedAxis = Vector3.one;
					}
					else if (collider == m_colliderUp)
					{
						m_selectedAxis = Vector3.up;
					}
					else if (collider == m_colliderDown)
					{
						m_selectedAxis = Vector3.down;
					}
					else if (collider == m_colliderForward)
					{
						m_selectedAxis = Vector3.forward;
					}
					else if (collider == m_colliderBackward)
					{
						m_selectedAxis = Vector3.back;
					}
					else if (collider == m_colliderRight)
					{
						m_selectedAxis = Vector3.right;
					}
					else if (collider == m_colliderLeft)
					{
						m_selectedAxis = Vector3.left;
					}
					if (m_selectedAxis != Vector3.zero || flag3)
					{
						RuntimeTools.IsSceneGizmoSelected = true;
					}
					else
					{
						RuntimeTools.IsSceneGizmoSelected = false;
					}
					if (Input.GetMouseButtonUp(0) && m_selectedAxis != Vector3.zero)
					{
						if (m_selectedAxis == Vector3.one)
						{
							IsOrthographic = !IsOrthographic;
						}
						else
						{
							if ((m_rotateAnimation == null || !m_rotateAnimation.InProgress) && OrientationChanging != null)
							{
								OrientationChanging.Invoke();
							}
							if (m_rotateAnimation != null)
							{
								m_rotateAnimation.Abort();
							}
							Vector3 pivot = Pivot.transform.position;
							Vector3 radiusVector = Vector3.back * (SceneCamera.transform.position - pivot).magnitude;
							Quaternion to = Quaternion.LookRotation(-m_selectedAxis, Vector3.up);
							m_rotateAnimation = new QuaternionAnimationInfo(SceneCamera.transform.rotation, to, 0.4f, AnimationInfo<object, Quaternion>.EaseOutCubic, delegate(object target, Quaternion value, float t, bool completed)
							{
								SceneCamera.transform.position = pivot + value * radiusVector;
								SceneCamera.transform.rotation = value;
								if (completed)
								{
									DisableColliders();
									EnableColliders();
									if (OrientationChanged != null)
									{
										OrientationChanged.Invoke();
									}
								}
							});
							Run.Instance.Animation(m_rotateAnimation);
						}
					}
					m_mouseOver = true;
				}
				else
				{
					if (m_mouseOver)
					{
						DisableColliders();
						RuntimeTools.IsSceneGizmoSelected = false;
					}
					m_mouseOver = false;
				}
			}

			private void EnableColliders()
			{
				m_colliderProj.enabled = true;
				if (m_zAlpha == 1f)
				{
					m_colliderForward.enabled = true;
					m_colliderBackward.enabled = true;
				}
				if (m_yAlpha == 1f)
				{
					m_colliderUp.enabled = true;
					m_colliderDown.enabled = true;
				}
				if (m_xAlpha == 1f)
				{
					m_colliderRight.enabled = true;
					m_colliderLeft.enabled = true;
				}
			}

			private void DisableColliders()
			{
				for (int i = 0; i < m_colliders.Length; i++)
				{
					m_colliders[i].enabled = false;
				}
			}

			private Collider HitTest()
			{
				Ray ray = m_camera.ScreenPointToRay(Input.mousePosition);
				float num = float.MaxValue;
				Collider result = null;
				for (int i = 0; i < m_colliders.Length; i++)
				{
					if (m_colliders[i].Raycast(ray, out var hitInfo, m_gizmoPosition.magnitude * 5f) && hitInfo.distance < num)
					{
						num = hitInfo.distance;
						result = hitInfo.collider;
					}
				}
				return result;
			}

			private void InitColliders()
			{
				m_gizmoPosition = GetGizmoPosition();
				float num = RuntimeHandles.GetScreenScale(m_gizmoPosition, m_camera) * Size.y / 96f;
				m_collidersGO.transform.rotation = Quaternion.identity;
				m_collidersGO.transform.position = GetGizmoPosition();
				m_colliderProj.size = new Vector3(0.15f, 0.15f, 0.15f) * num;
				m_colliderUp.size = new Vector3(0.15f, 0.3f, 0.15f) * num;
				m_colliderUp.center = new Vector3(0f, 0.22500001f, 0f) * num;
				m_colliderDown.size = new Vector3(0.15f, 0.3f, 0.15f) * num;
				m_colliderDown.center = new Vector3(0f, -0.22500001f, 0f) * num;
				m_colliderForward.size = new Vector3(0.15f, 0.15f, 0.3f) * num;
				m_colliderForward.center = new Vector3(0f, 0f, 0.22500001f) * num;
				m_colliderBackward.size = new Vector3(0.15f, 0.15f, 0.3f) * num;
				m_colliderBackward.center = new Vector3(0f, 0f, -0.22500001f) * num;
				m_colliderRight.size = new Vector3(0.3f, 0.15f, 0.15f) * num;
				m_colliderRight.center = new Vector3(0.22500001f, 0f, 0f) * num;
				m_colliderLeft.size = new Vector3(0.3f, 0.15f, 0.15f) * num;
				m_colliderLeft.center = new Vector3(-0.22500001f, 0f, 0f) * num;
			}

			private bool UpdateAlpha(ref float alpha, Vector3 axis, float delta)
			{
				if ((double)Math.Abs(Vector3.Dot(SceneCamera.transform.forward, axis)) > 0.9)
				{
					if (alpha > 0f)
					{
						alpha -= delta;
						if (alpha < 0f)
						{
							alpha = 0f;
						}
						return true;
					}
				}
				else if (alpha < 1f)
				{
					alpha += delta;
					if (alpha > 1f)
					{
						alpha = 1f;
					}
					return true;
				}
				return false;
			}
		}
	}
	namespace Battlehub.RTEditor
	{
		public class DragField : MonoBehaviour, IDragHandler, IEventSystemHandler, IBeginDragHandler, IDropHandler, IEndDragHandler, IPointerEnterHandler, IPointerExitHandler
		{
			public InputField Field;

			public float IncrementFactor = 0.1f;

			public Texture2D DragCursor;

			private void Start()
			{
				if (Field == null)
				{
					UnityEngine.Debug.LogWarning("Set Field");
				}
			}

			void IBeginDragHandler.OnBeginDrag(PointerEventData eventData)
			{
			}

			void IDropHandler.OnDrop(PointerEventData eventData)
			{
			}

			void IEndDragHandler.OnEndDrag(PointerEventData eventData)
			{
			}

			void IDragHandler.OnDrag(PointerEventData eventData)
			{
				if (!(Field == null) && Field.contentType == InputField.ContentType.DecimalNumber && float.TryParse(Field.text, out var result))
				{
					result += IncrementFactor * eventData.delta.x;
					Field.text = result.ToString();
				}
			}

			void IPointerEnterHandler.OnPointerEnter(PointerEventData eventData)
			{
				Cursor.SetCursor(DragCursor, new Vector2(24f, 24f), CursorMode.Auto);
			}

			void IPointerExitHandler.OnPointerExit(PointerEventData eventData)
			{
				Cursor.SetCursor(null, Vector2.zero, CursorMode.Auto);
			}
		}
		public delegate void ExposeToEditorChangeEvent<T>(ExposeToEditor obj, T oldValue, T newValue);
		public delegate void ExposeToEditorEvent(ExposeToEditor obj);
		[DisallowMultipleComponent]
		public class ExposeToEditor : MonoBehaviour
		{
			public bool AddColliders;

			public bool DisableOnAwake;

			private bool m_applicationQuit;

			private Collider[] m_colliders;

			private HierarchyItem m_hierarchyItem;

			private List<ExposeToEditor> m_children = new List<ExposeToEditor>();

			private ExposeToEditor m_parent;

			public int ChildCount => m_children.Count;

			public ExposeToEditor Parent
			{
				get
				{
					return m_parent;
				}
				set
				{
					if (m_parent != value)
					{
						ExposeToEditor parent = m_parent;
						m_parent = value;
						if (parent != null)
						{
							parent.m_children.Remove(this);
						}
						if (m_parent != null)
						{
							m_parent.m_children.Add(this);
						}
						if (ExposeToEditor.ParentChanged != null)
						{
							ExposeToEditor.ParentChanged(this, parent, m_parent);
						}
					}
				}
			}

			public static event ExposeToEditorEvent NameChanged;

			public static event ExposeToEditorEvent TransformChanged;

			public static event ExposeToEditorEvent Awaked;

			public static event ExposeToEditorEvent Started;

			public static event ExposeToEditorEvent Enabled;

			public static event ExposeToEditorEvent Disabled;

			public static event ExposeToEditorEvent Destroyed;

			public static event ExposeToEditorChangeEvent<ExposeToEditor> ParentChanged;

			public ExposeToEditor GetChild(int index)
			{
				return m_children[index];
			}

			public ExposeToEditor[] GetChildren()
			{
				return m_children.OrderBy((ExposeToEditor c) => c.transform.GetSiblingIndex()).ToArray();
			}

			private void Awake()
			{
				if (DisableOnAwake)
				{
					base.gameObject.SetActive(value: false);
				}
				List<Collider> list = new List<Collider>();
				MeshFilter component = GetComponent<MeshFilter>();
				bool flag = GetComponent<Rigidbody>() != null;
				if (component != null && !flag && AddColliders)
				{
					MeshCollider meshCollider = base.gameObject.AddComponent<MeshCollider>();
					meshCollider.convex = flag;
					meshCollider.sharedMesh = component.mesh;
					list.Add(meshCollider);
				}
				SkinnedMeshRenderer component2 = GetComponent<SkinnedMeshRenderer>();
				if (component2 != null && !flag && AddColliders)
				{
					MeshCollider meshCollider2 = base.gameObject.AddComponent<MeshCollider>();
					meshCollider2.convex = flag;
					meshCollider2.sharedMesh = component2.sharedMesh;
					list.Add(meshCollider2);
				}
				m_colliders = list.ToArray();
				if (base.transform.parent != null)
				{
					ExposeToEditor componentInParent = base.transform.parent.GetComponentInParent<ExposeToEditor>();
					if (m_parent != componentInParent)
					{
						m_parent = componentInParent;
						if (m_parent != null)
						{
							m_parent.m_children.Add(this);
						}
					}
				}
				m_hierarchyItem = base.gameObject.GetComponent<HierarchyItem>();
				if (m_hierarchyItem == null)
				{
					m_hierarchyItem = base.gameObject.AddComponent<HierarchyItem>();
				}
				if (ExposeToEditor.Awaked != null)
				{
					ExposeToEditor.Awaked(this);
				}
			}

			private void Start()
			{
				if (ExposeToEditor.Started != null)
				{
					ExposeToEditor.Started(this);
				}
			}

			private void OnEnable()
			{
				if (ExposeToEditor.Enabled != null)
				{
					ExposeToEditor.Enabled(this);
				}
			}

			private void OnDisable()
			{
				if (ExposeToEditor.Disabled != null)
				{
					ExposeToEditor.Disabled(this);
				}
			}

			private void OnApplicationQuit()
			{
				m_applicationQuit = true;
			}

			private void OnDestroy()
			{
				if (m_applicationQuit)
				{
					return;
				}
				Parent = null;
				for (int i = 0; i < m_colliders.Length; i++)
				{
					Collider collider = m_colliders[i];
					if (collider != null)
					{
						UnityEngine.Object.Destroy(collider);
					}
				}
				if (m_hierarchyItem != null)
				{
					UnityEngine.Object.Destroy(m_hierarchyItem);
				}
				if (ExposeToEditor.Destroyed != null)
				{
					ExposeToEditor.Destroyed(this);
				}
			}

			private void Update()
			{
				if (ExposeToEditor.TransformChanged != null && base.transform.hasChanged)
				{
					base.transform.hasChanged = false;
					if (ExposeToEditor.TransformChanged != null)
					{
						ExposeToEditor.TransformChanged(this);
					}
				}
			}

			public void SetName(string name)
			{
				base.gameObject.name = name;
				if (ExposeToEditor.NameChanged != null)
				{
					ExposeToEditor.NameChanged(this);
				}
			}
		}
		public class HierarchyItem : MonoBehaviour
		{
			private ExposeToEditor m_parentExp;

			private ExposeToEditor m_exposeToEditor;

			private Transform m_parentTransform;

			private bool m_isAwaked;

			private void Awake()
			{
				m_exposeToEditor = GetComponent<ExposeToEditor>();
				if (base.transform.parent != null)
				{
					m_parentExp = CreateChainToParent(base.transform.parent);
					m_parentTransform = base.transform.parent;
				}
				m_isAwaked = true;
			}

			private ExposeToEditor CreateChainToParent(Transform parent)
			{
				ExposeToEditor exposeToEditor = null;
				if (parent != null)
				{
					exposeToEditor = parent.GetComponentInParent<ExposeToEditor>();
				}
				if (exposeToEditor == null)
				{
					return null;
				}
				while (parent != null && parent.gameObject != exposeToEditor.gameObject)
				{
					if (!parent.GetComponent<ExposeToEditor>() && !parent.GetComponent<HierarchyItem>())
					{
						parent.gameObject.AddComponent<HierarchyItem>();
					}
					parent = parent.parent;
				}
				return exposeToEditor;
			}

			private void TryDestroyChainToParent(Transform parent, ExposeToEditor parentExp)
			{
				if (parentExp == null)
				{
					return;
				}
				while (parent != null && parent.gameObject != parentExp.gameObject)
				{
					if (!parent.GetComponent<ExposeToEditor>())
					{
						HierarchyItem component = parent.GetComponent<HierarchyItem>();
						if ((bool)component && !HasExposeToEditorChildren(parent))
						{
							UnityEngine.Object.Destroy(component);
						}
					}
					parent = parent.parent;
				}
			}

			private bool HasExposeToEditorChildren(Transform parentTransform)
			{
				int childCount = parentTransform.childCount;
				if (childCount == 0)
				{
					return false;
				}
				for (int i = 0; i < childCount; i++)
				{
					Transform child = parentTransform.GetChild(i);
					if (child.GetComponent<ExposeToEditor>() != null)
					{
						return true;
					}
					if (child.GetComponent<HierarchyItem>() != null && HasExposeToEditorChildren(child))
					{
						return true;
					}
				}
				return false;
			}

			private void UpdateChildren(Transform parentTransform, ExposeToEditor parentExp)
			{
				int childCount = parentTransform.childCount;
				if (childCount == 0)
				{
					return;
				}
				for (int i = 0; i < childCount; i++)
				{
					Transform child = parentTransform.GetChild(i);
					ExposeToEditor component = child.GetComponent<ExposeToEditor>();
					HierarchyItem component2 = child.GetComponent<HierarchyItem>();
					if (component != null)
					{
						component.Parent = parentExp;
						component2.m_parentExp = parentExp;
					}
					else if (component2 != null)
					{
						UpdateChildren(child, parentExp);
					}
				}
			}

			private void OnTransformParentChanged()
			{
				if (!m_isAwaked || !(base.transform.parent != m_parentTransform))
				{
					return;
				}
				if (m_parentTransform != null && m_parentExp != null)
				{
					TryDestroyChainToParent(m_parentTransform, m_parentExp);
				}
				ExposeToEditor exposeToEditor = CreateChainToParent(base.transform.parent);
				if (exposeToEditor != m_parentExp)
				{
					if (m_exposeToEditor == null)
					{
						UpdateChildren(base.transform, exposeToEditor);
					}
					else
					{
						m_exposeToEditor.Parent = exposeToEditor;
					}
					m_parentExp = exposeToEditor;
				}
				m_parentTransform = base.transform.parent;
			}
		}
		[AddComponentMenu("Camera-Control/Mouse Orbit with zoom")]
		public class MouseOrbit : MonoBehaviour
		{
			private Camera m_camera;

			public Transform Target;

			public float Distance = 5f;

			public float XSpeed = 5f;

			public float YSpeed = 5f;

			public float YMinLimit = -360f;

			public float YMaxLimit = 360f;

			public float DistanceMin = 0.5f;

			public float DistanceMax = 5000f;

			private float m_x;

			private float m_y;

			private void Awake()
			{
				m_camera = GetComponent<Camera>();
			}

			private void Start()
			{
				SyncAngles();
			}

			public void SyncAngles()
			{
				Vector3 eulerAngles = base.transform.eulerAngles;
				m_x = eulerAngles.y;
				m_y = eulerAngles.x;
			}

			private void LateUpdate()
			{
				float axis = Input.GetAxis("Mouse X");
				float axis2 = Input.GetAxis("Mouse Y");
				axis *= XSpeed;
				axis2 *= YSpeed;
				m_x += axis;
				m_y -= axis2;
				m_y = ClampAngle(m_y, YMinLimit, YMaxLimit);
				Zoom();
			}

			public void Zoom()
			{
				Quaternion quaternion = Quaternion.Euler(m_y, m_x, 0f);
				base.transform.rotation = quaternion;
				float axis = Input.GetAxis("Mouse ScrollWheel");
				if (m_camera.orthographic)
				{
					m_camera.orthographicSize -= axis * m_camera.orthographicSize;
					if (m_camera.orthographicSize < 0.01f)
					{
						m_camera.orthographicSize = 0.01f;
					}
				}
				Distance = Mathf.Clamp(Distance - axis * Distance, DistanceMin, DistanceMax);
				Vector3 vector = new Vector3(0f, 0f, 0f - Distance);
				Vector3 position = quaternion * vector + Target.position;
				base.transform.position = position;
			}

			public static float ClampAngle(float angle, float min, float max)
			{
				if (angle < -360f)
				{
					angle += 360f;
				}
				if (angle > 360f)
				{
					angle -= 360f;
				}
				return Mathf.Clamp(angle, min, max);
			}
		}
		public class Placeholder : MonoBehaviour
		{
			public static string CommandsPlaceholder = "Commands";

			public string Id;
		}
		public class RuntimeEditor : MonoBehaviour
		{
			public UnityEvent Opened;

			public UnityEvent Closed;

			public GameObject[] Prefabs;

			public GameObject Grid;

			public GameObject SceneGizmo;

			public GameObject EditButton;

			public GameObject CloseButton;

			public GameObject EditorRoot;

			public Camera SceneCamera;

			public RuntimeSceneView SceneView;

			public KeyCode MultiselectKey = KeyCode.LeftControl;

			public KeyCode RangeSelectKey = KeyCode.LeftShift;

			public KeyCode DuplicateKey = KeyCode.D;

			public KeyCode DuplicateKey2 = KeyCode.LeftShift;

			private LayerMask m_raycastLayerMask = int.MinValue;

			private int m_raycastLayer = 31;

			private bool m_isOn;

			private static RuntimeEditor m_instance;

			public int RaycastLayer
			{
				get
				{
					return m_raycastLayer;
				}
				set
				{
					m_raycastLayer = value;
					m_raycastLayerMask = 1 << value;
				}
			}

			public bool IsOn
			{
				get
				{
					return m_isOn;
				}
				set
				{
					if (m_isOn != value)
					{
						m_isOn = value;
						if (m_isOn)
						{
							ShowEditor();
						}
						else
						{
							CloseEditor();
						}
					}
				}
			}

			public static RuntimeEditor Instance => m_instance;

			private void Awake()
			{
				ExposeToEditor.Started += OnObjectStarted;
				if (m_instance != null)
				{
					UnityEngine.Debug.LogWarning("Another instance of RuntimeEditor exists");
				}
				m_instance = this;
				if (SceneCamera == null)
				{
					SceneCamera = Camera.main;
				}
				SceneView.Camera = SceneCamera;
			}

			private void Start()
			{
				ShowEditor();
				CloseEditor();
				ExposeToEditor.Awaked += OnObjectAwaked;
				ExposeToEditor.Enabled += OnObjectEnabled;
				ExposeToEditor.Disabled += OnObjectDisabled;
				ExposeToEditor.Destroyed += OnObjectDestroyed;
				if (m_isOn)
				{
					ShowEditor();
				}
				else
				{
					CloseEditor();
				}
			}

			private void LateUpdate()
			{
				if (Input.GetKeyDown(DuplicateKey) && Input.GetKey(DuplicateKey2))
				{
					UnityEngine.Object[] objects = RuntimeSelection.objects;
					if (objects != null && objects.Length != 0)
					{
						UnityEngine.Object[] array = new UnityEngine.Object[objects.Length];
						for (int i = 0; i < array.Length; i++)
						{
							GameObject gameObject = objects[i] as GameObject;
							UnityEngine.Object @object = UnityEngine.Object.Instantiate(objects[i]);
							GameObject gameObject2 = @object as GameObject;
							if (gameObject != null && gameObject2 != null && gameObject.transform.parent != null)
							{
								gameObject2.transform.SetParent(gameObject.transform.parent, worldPositionStays: true);
							}
							array[i] = @object;
						}
						RuntimeSelection.objects = array;
					}
				}
				if (!Input.GetMouseButtonDown(0) || (PositionHandle.Current != null && PositionHandle.Current.IsDragging) || (ScaleHandle.Current != null && ScaleHandle.Current.IsDragging) || (RotationHandle.Current != null && RotationHandle.Current.IsDragging) || (!SceneView.IsPointerOver && EventSystem.current != null && EventSystem.current.IsPointerOverGameObject()) || RuntimeTools.IsLocked || RuntimeTools.IsSceneGizmoSelected)
				{
					return;
				}
				bool key = Input.GetKey(RangeSelectKey);
				bool flag = Input.GetKey(MultiselectKey) || key;
				if (Physics.Raycast(SceneCamera.ScreenPointToRay(Input.mousePosition), out var hitInfo, float.MaxValue, m_raycastLayerMask.value))
				{
					ExposeToEditor component = hitInfo.collider.gameObject.GetComponent<ExposeToEditor>();
					if (component != null)
					{
						if (flag)
						{
							List<UnityEngine.Object> list = ((RuntimeSelection.objects == null) ? new List<UnityEngine.Object>() : RuntimeSelection.objects.ToList());
							if (list.Contains(component.gameObject))
							{
								list.Remove(component.gameObject);
								if (key)
								{
									list.Insert(0, component.gameObject);
								}
							}
							else
							{
								list.Insert(0, component.gameObject);
							}
							RuntimeSelection.Select(component.gameObject, list.ToArray());
						}
						else
						{
							RuntimeSelection.activeObject = component.gameObject;
						}
					}
					else if (!flag)
					{
						RuntimeSelection.activeObject = null;
					}
				}
				else if (!flag)
				{
					RuntimeSelection.activeObject = null;
				}
			}

			private void Destroy()
			{
				ExposeToEditor.Awaked -= OnObjectAwaked;
				ExposeToEditor.Started -= OnObjectStarted;
				ExposeToEditor.Enabled -= OnObjectEnabled;
				ExposeToEditor.Disabled -= OnObjectDisabled;
				ExposeToEditor.Destroyed -= OnObjectDestroyed;
			}

			private void OnApplicationQuit()
			{
				ExposeToEditor.Awaked -= OnObjectAwaked;
				ExposeToEditor.Started -= OnObjectStarted;
				ExposeToEditor.Enabled -= OnObjectEnabled;
				ExposeToEditor.Disabled -= OnObjectDisabled;
				ExposeToEditor.Destroyed -= OnObjectDestroyed;
			}

			private void OnObjectAwaked(ExposeToEditor obj)
			{
			}

			private void OnObjectStarted(ExposeToEditor obj)
			{
				obj.gameObject.layer = m_raycastLayer;
			}

			private void OnObjectEnabled(ExposeToEditor obj)
			{
				obj.gameObject.layer = m_raycastLayer;
			}

			private void OnObjectDisabled(ExposeToEditor obj)
			{
			}

			private void OnObjectDestroyed(ExposeToEditor obj)
			{
			}

			private void ShowEditor()
			{
				if (SceneGizmo != null)
				{
					SceneGizmo.SetActive(value: true);
				}
				if (Grid != null)
				{
					Grid.SetActive(value: true);
				}
				EditButton.SetActive(value: false);
				EditorRoot.SetActive(value: true);
				Opened.Invoke();
			}

			private void CloseEditor()
			{
				if (SceneGizmo != null)
				{
					SceneGizmo.SetActive(value: false);
				}
				if (Grid != null)
				{
					Grid.SetActive(value: false);
				}
				EditButton.SetActive(value: true);
				EditorRoot.SetActive(value: false);
				Closed.Invoke();
			}
		}
		public class RuntimeHierarchy : MonoBehaviour
		{
			public GameObject TreeViewPrefab;

			private TreeView m_treeView;

			public Type TypeCriteria = typeof(GameObject);

			public Color DisabledItemColor = new Color(0.5f, 0.5f, 0.5f);

			public Color EnabledItemColor = new Color(0.2f, 0.2f, 0.2f);

			private bool m_lockSelection;

			private void Start()
			{
				if (!TreeViewPrefab)
				{
					UnityEngine.Debug.LogError("Set TreeViewPrefab field");
					return;
				}
				m_treeView = UnityEngine.Object.Instantiate(TreeViewPrefab).GetComponent<TreeView>();
				m_treeView.transform.SetParent(base.transform, worldPositionStays: false);
				m_treeView.ItemDataBinding += OnItemDataBinding;
				m_treeView.SelectionChanged += OnSelectionChanged;
				m_treeView.ItemsRemoved += OnItemsRemoved;
				m_treeView.ItemExpanding += OnItemExpanding;
				m_treeView.ItemBeginDrag += OnItemBeginDrag;
				m_treeView.ItemDrop += OnItemDrop;
				m_treeView.ItemEndDrag += OnItemEndDrag;
				RuntimeSelection.SelectionChanged += OnRuntimeSelectionChanged;
				HashSet<GameObject> hashSet = new HashSet<GameObject>();
				GameObject[] array = Resources.FindObjectsOfTypeAll<GameObject>();
				foreach (GameObject gameObject in array)
				{
					if (gameObject == null || RuntimePrefabs.IsPrefab(gameObject.transform))
					{
						continue;
					}
					if (TypeCriteria == typeof(GameObject))
					{
						hashSet.Add(gameObject);
						continue;
					}
					UnityEngine.Component component = gameObject.GetComponent(TypeCriteria);
					if ((bool)component && !hashSet.Contains(component.gameObject))
					{
						hashSet.Add(component.gameObject);
					}
				}
				m_treeView.Items = from f in hashSet
					where f.transform.parent == null && CanExposeToEditor(f)
					select f into t
					orderby t.transform.GetSiblingIndex()
					select t;
				ExposeToEditor.Awaked += OnObjectAwaked;
				ExposeToEditor.Started += OnObjectStarted;
				ExposeToEditor.Enabled += OnObjectEnabled;
				ExposeToEditor.Disabled += OnObjectDisabled;
				ExposeToEditor.Destroyed += OnObjectDestroyed;
				ExposeToEditor.ParentChanged += OnParentChanged;
				ExposeToEditor.NameChanged += OnNameChanged;
			}

			private bool CanExposeToEditor(GameObject go)
			{
				return go.GetComponent<ExposeToEditor>() != null;
			}

			private void OnDestroy()
			{
				if ((bool)m_treeView)
				{
					m_treeView.ItemDataBinding -= OnItemDataBinding;
					m_treeView.SelectionChanged -= OnSelectionChanged;
					m_treeView.ItemsRemoved -= OnItemsRemoved;
					m_treeView.ItemExpanding -= OnItemExpanding;
					m_treeView.ItemBeginDrag -= OnItemBeginDrag;
					m_treeView.ItemDrop -= OnItemDrop;
					m_treeView.ItemEndDrag -= OnItemEndDrag;
					RuntimeSelection.SelectionChanged -= OnRuntimeSelectionChanged;
					ExposeToEditor.Awaked -= OnObjectAwaked;
					ExposeToEditor.Started -= OnObjectStarted;
					ExposeToEditor.Enabled -= OnObjectEnabled;
					ExposeToEditor.Disabled -= OnObjectDisabled;
					ExposeToEditor.Destroyed -= OnObjectDestroyed;
					ExposeToEditor.ParentChanged -= OnParentChanged;
					ExposeToEditor.NameChanged -= OnNameChanged;
				}
			}

			private void OnApplicationQuit()
			{
				ExposeToEditor.Awaked -= OnObjectAwaked;
				ExposeToEditor.Started -= OnObjectStarted;
				ExposeToEditor.Enabled -= OnObjectEnabled;
				ExposeToEditor.Disabled -= OnObjectDisabled;
				ExposeToEditor.Destroyed -= OnObjectDestroyed;
				ExposeToEditor.ParentChanged -= OnParentChanged;
				ExposeToEditor.NameChanged -= OnNameChanged;
			}

			private void OnItemExpanding(object sender, ItemExpandingArgs e)
			{
				ExposeToEditor component = ((GameObject)e.Item).GetComponent<ExposeToEditor>();
				if (component.ChildCount > 0)
				{
					e.Children = from obj in component.GetChildren()
						select obj.gameObject;
					OnTreeViewSelectionChanged(m_treeView.SelectedItems, m_treeView.SelectedItems);
				}
			}

			private void OnEditorSelectionChanged()
			{
				if (!m_lockSelection)
				{
					m_lockSelection = true;
					m_lockSelection = false;
				}
			}

			private void OnRuntimeSelectionChanged(UnityEngine.Object[] unselected)
			{
				if (!m_lockSelection)
				{
					m_lockSelection = true;
					m_treeView.SelectedItems = RuntimeSelection.gameObjects;
					m_lockSelection = false;
				}
			}

			private void OnSelectionChanged(object sender, SelectionChangedEventArgs e)
			{
				OnTreeViewSelectionChanged(e.OldItems, e.NewItems);
			}

			private void OnTreeViewSelectionChanged(IEnumerable oldItems, IEnumerable newItems)
			{
				if (!m_lockSelection)
				{
					m_lockSelection = true;
					if (newItems == null)
					{
						newItems = new GameObject[0];
					}
					UnityEngine.Object[] objects = newItems.OfType<GameObject>().ToArray();
					RuntimeSelection.objects = objects;
					m_lockSelection = false;
				}
			}

			private void OnItemsRemoved(object sender, ItemsRemovedArgs e)
			{
				for (int i = 0; i < e.Items.Length; i++)
				{
					GameObject gameObject = (GameObject)e.Items[i];
					if (gameObject != null)
					{
						UnityEngine.Object.Destroy(gameObject);
					}
				}
			}

			private void OnItemDataBinding(object sender, TreeViewItemDataBindingArgs e)
			{
				GameObject gameObject = e.Item as GameObject;
				if (gameObject != null)
				{
					Text componentInChildren = e.ItemPresenter.GetComponentInChildren<Text>(includeInactive: true);
					componentInChildren.text = gameObject.name;
					if (gameObject.activeInHierarchy)
					{
						componentInChildren.color = EnabledItemColor;
					}
					else
					{
						componentInChildren.color = DisabledItemColor;
					}
					e.HasChildren = gameObject.GetComponent<ExposeToEditor>().ChildCount > 0;
				}
			}

			private void OnItemBeginDrag(object sender, ItemDragArgs e)
			{
			}

			private void OnItemDrop(object sender, ItemDropArgs e)
			{
				if (e.IsExternal)
				{
					if (e.DragItems == null)
					{
						return;
					}
					for (int i = 0; i < e.DragItems.Length; i++)
					{
						GameObject gameObject = e.DragItems[i] as GameObject;
						if (gameObject != null && RuntimePrefabs.IsPrefab(gameObject.transform))
						{
							GameObject obj = UnityEngine.Object.Instantiate(gameObject);
							ExposeToEditor component = obj.GetComponent<ExposeToEditor>();
							if (component != null)
							{
								component.SetName(gameObject.name);
							}
							obj.transform.position = gameObject.transform.position;
							obj.transform.rotation = gameObject.transform.rotation;
							obj.transform.localScale = gameObject.transform.localScale;
							RuntimeSelection.activeGameObject = obj;
						}
					}
					return;
				}
				Transform transform = ((GameObject)e.DropTarget).transform;
				if (e.Action == ItemDropAction.SetLastChild)
				{
					for (int j = 0; j < e.DragItems.Length; j++)
					{
						Transform obj2 = ((GameObject)e.DragItems[j]).transform;
						obj2.SetParent(transform, worldPositionStays: true);
						obj2.SetAsLastSibling();
					}
				}
				else if (e.Action == ItemDropAction.SetNextSibling)
				{
					for (int k = 0; k < e.DragItems.Length; k++)
					{
						Transform transform2 = ((GameObject)e.DragItems[k]).transform;
						if (transform2.parent != transform.parent)
						{
							transform2.SetParent(transform.parent, worldPositionStays: true);
						}
						int siblingIndex = transform.GetSiblingIndex();
						transform2.SetSiblingIndex(siblingIndex + 1);
					}
				}
				else
				{
					if (e.Action != ItemDropAction.SetPrevSibling)
					{
						return;
					}
					for (int l = 0; l < e.DragItems.Length; l++)
					{
						Transform transform3 = ((GameObject)e.DragItems[l]).transform;
						if (transform3.parent != transform.parent)
						{
							transform3.SetParent(transform.parent, worldPositionStays: true);
						}
						int siblingIndex2 = transform.GetSiblingIndex();
						transform3.SetSiblingIndex(siblingIndex2);
					}
				}
			}

			private void OnItemEndDrag(object sender, ItemDragArgs e)
			{
			}

			private void OnObjectAwaked(ExposeToEditor obj)
			{
				GameObject parent = null;
				if (obj.Parent != null)
				{
					parent = obj.Parent.gameObject;
				}
				m_treeView.AddChild(parent, obj.gameObject);
			}

			private void OnObjectStarted(ExposeToEditor obj)
			{
			}

			private void OnObjectEnabled(ExposeToEditor obj)
			{
				TreeViewItem treeViewItem = (TreeViewItem)m_treeView.GetItemContainer(obj.gameObject);
				if (!(treeViewItem == null))
				{
					treeViewItem.GetComponentInChildren<Text>().color = EnabledItemColor;
				}
			}

			private void OnObjectDisabled(ExposeToEditor obj)
			{
				TreeViewItem treeViewItem = (TreeViewItem)m_treeView.GetItemContainer(obj.gameObject);
				if (!(treeViewItem == null))
				{
					treeViewItem.GetComponentInChildren<Text>().color = DisabledItemColor;
				}
			}

			private void OnObjectDestroyed(ExposeToEditor obj)
			{
				m_treeView.Remove(obj.gameObject);
			}

			private void OnParentChanged(ExposeToEditor obj, ExposeToEditor oldParent, ExposeToEditor newParent)
			{
				GameObject parent = null;
				if (newParent != null)
				{
					parent = newParent.gameObject;
				}
				m_treeView.ChangeParent(parent, obj.gameObject);
			}

			private void OnNameChanged(ExposeToEditor obj)
			{
				TreeViewItem treeViewItem = (TreeViewItem)m_treeView.GetItemContainer(obj.gameObject);
				if (!(treeViewItem == null))
				{
					treeViewItem.GetComponentInChildren<Text>().text = obj.gameObject.name;
				}
			}
		}
		public class RuntimePrefabs : MonoBehaviour
		{
			public GameObject ListBoxPrefab;

			private ListBox m_listBox;

			public Type TypeCriteria = typeof(GameObject);

			public RuntimeEditor Editor;

			private bool m_lockSelection;

			public static bool IsPrefab(Transform This)
			{
				if (Application.isEditor && !Application.isPlaying)
				{
					throw new InvalidOperationException("Does not work in edit mode");
				}
				return This.gameObject.scene.buildIndex < 0;
			}

			private void Start()
			{
				if (!ListBoxPrefab)
				{
					UnityEngine.Debug.LogError("Set ListBoxPrefab field");
					return;
				}
				m_listBox = UnityEngine.Object.Instantiate(ListBoxPrefab).GetComponent<ListBox>();
				m_listBox.CanDrag = false;
				m_listBox.MultiselectKey = KeyCode.None;
				m_listBox.RangeselectKey = KeyCode.None;
				m_listBox.RemoveKey = KeyCode.None;
				m_listBox.transform.SetParent(base.transform, worldPositionStays: false);
				m_listBox.ItemDataBinding += OnItemDataBinding;
				m_listBox.SelectionChanged += OnSelectionChanged;
				m_listBox.ItemsRemoved += OnItemsRemoved;
				m_listBox.ItemBeginDrag += OnItemBeginDrag;
				m_listBox.ItemDrop += OnItemDrop;
				m_listBox.ItemEndDrag += OnItemEndDrag;
				RuntimeSelection.SelectionChanged += OnRuntimeSelectionChanged;
				if (Editor != null)
				{
					if (Editor.Prefabs != null)
					{
						for (int i = 0; i < Editor.Prefabs.Length; i++)
						{
							GameObject gameObject = Editor.Prefabs[i];
							if (gameObject != null && !gameObject.GetComponent<ExposeToEditor>())
							{
								gameObject.AddComponent<ExposeToEditor>();
							}
						}
					}
					m_listBox.Items = Editor.Prefabs;
				}
				ExposeToEditor.Destroyed += OnObjectDestroyed;
			}

			private void OnDestroy()
			{
				if ((bool)m_listBox)
				{
					m_listBox.ItemDataBinding -= OnItemDataBinding;
					m_listBox.SelectionChanged -= OnSelectionChanged;
					m_listBox.ItemsRemoved -= OnItemsRemoved;
					m_listBox.ItemBeginDrag -= OnItemBeginDrag;
					m_listBox.ItemDrop -= OnItemDrop;
					m_listBox.ItemEndDrag -= OnItemEndDrag;
					RuntimeSelection.SelectionChanged -= OnRuntimeSelectionChanged;
					ExposeToEditor.Destroyed -= OnObjectDestroyed;
				}
			}

			private void OnApplicationQuit()
			{
				ExposeToEditor.Destroyed -= OnObjectDestroyed;
			}

			private void OnEditorSelectionChanged()
			{
				if (!m_lockSelection)
				{
					m_lockSelection = true;
					m_lockSelection = false;
				}
			}

			private void OnRuntimeSelectionChanged(UnityEngine.Object[] unselected)
			{
				if (!m_lockSelection)
				{
					m_lockSelection = true;
					m_listBox.SelectedItems = RuntimeSelection.gameObjects;
					m_lockSelection = false;
				}
			}

			private void OnSelectionChanged(object sender, SelectionChangedEventArgs e)
			{
				OnListBoxSelectionChanged(e.OldItems, e.NewItems);
			}

			private void OnListBoxSelectionChanged(IEnumerable oldItems, IEnumerable newItems)
			{
				if (!m_lockSelection)
				{
					m_lockSelection = true;
					if (newItems == null)
					{
						newItems = new GameObject[0];
					}
					UnityEngine.Object[] objects = newItems.OfType<GameObject>().ToArray();
					RuntimeSelection.objects = objects;
					m_lockSelection = false;
				}
			}

			private void OnItemsRemoved(object sender, ItemsRemovedArgs e)
			{
				for (int i = 0; i < e.Items.Length; i++)
				{
					GameObject gameObject = (GameObject)e.Items[i];
					if (gameObject != null)
					{
						UnityEngine.Object.Destroy(gameObject);
					}
				}
			}

			private void OnItemDataBinding(object sender, ItemDataBindingArgs e)
			{
				GameObject gameObject = e.Item as GameObject;
				if (gameObject != null)
				{
					e.ItemPresenter.GetComponentInChildren<Text>(includeInactive: true).text = gameObject.name;
				}
			}

			private void OnItemBeginDrag(object sender, ItemDragArgs e)
			{
			}

			private void OnItemDrop(object sender, ItemDropArgs e)
			{
				Transform transform = ((GameObject)e.DropTarget).transform;
				if (e.Action == ItemDropAction.SetLastChild)
				{
					for (int i = 0; i < e.DragItems.Length; i++)
					{
						Transform obj = ((GameObject)e.DragItems[i]).transform;
						obj.SetParent(transform, worldPositionStays: true);
						obj.SetAsLastSibling();
					}
				}
				else if (e.Action == ItemDropAction.SetNextSibling)
				{
					for (int j = 0; j < e.DragItems.Length; j++)
					{
						Transform transform2 = ((GameObject)e.DragItems[j]).transform;
						if (transform2.parent != transform.parent)
						{
							transform2.SetParent(transform.parent, worldPositionStays: true);
						}
						int siblingIndex = transform.GetSiblingIndex();
						transform2.SetSiblingIndex(siblingIndex + 1);
					}
				}
				else
				{
					if (e.Action != ItemDropAction.SetPrevSibling)
					{
						return;
					}
					for (int k = 0; k < e.DragItems.Length; k++)
					{
						Transform transform3 = ((GameObject)e.DragItems[k]).transform;
						if (transform3.parent != transform.parent)
						{
							transform3.SetParent(transform.parent, worldPositionStays: true);
						}
						int siblingIndex2 = transform.GetSiblingIndex();
						transform3.SetSiblingIndex(siblingIndex2);
					}
				}
			}

			private void OnItemEndDrag(object sender, ItemDragArgs e)
			{
			}

			private void OnObjectDestroyed(ExposeToEditor obj)
			{
				m_listBox.Remove(obj.gameObject);
			}
		}
		public delegate void UnityEditorToolChanged();
		public class UnityEditorToolsListener
		{
			public static event UnityEditorToolChanged ToolChanged;

			public static void Update()
			{
			}
		}
		public delegate void RuntimeSelectionChanged(UnityEngine.Object[] unselectedObjects);
		public static class RuntimeSelection
		{
			private static UnityEngine.Object m_activeObject;

			private static UnityEngine.Object[] m_objects;

			public static GameObject activeGameObject
			{
				get
				{
					return activeObject as GameObject;
				}
				set
				{
					activeObject = value;
				}
			}

			public static UnityEngine.Object activeObject
			{
				get
				{
					return m_activeObject;
				}
				set
				{
					if (m_activeObject != value)
					{
						m_activeObject = value;
						UnityEngine.Object[] unselectedObjects = m_objects;
						if (m_activeObject != null)
						{
							m_objects = new UnityEngine.Object[1] { value };
						}
						else
						{
							m_objects = new UnityEngine.Object[0];
						}
						if (RuntimeSelection.SelectionChanged != null)
						{
							RuntimeSelection.SelectionChanged(unselectedObjects);
						}
					}
				}
			}

			public static UnityEngine.Object[] objects
			{
				get
				{
					return m_objects;
				}
				set
				{
					UnityEngine.Object[] array = m_objects;
					if (value == null)
					{
						m_objects = null;
						m_activeObject = null;
					}
					else
					{
						m_objects = value.ToArray();
						if (m_activeObject == null || !m_objects.Contains(m_activeObject))
						{
							m_activeObject = m_objects.OfType<GameObject>().FirstOrDefault();
						}
					}
					if (array == m_objects || RuntimeSelection.SelectionChanged == null)
					{
						return;
					}
					if (array == null || m_objects == null)
					{
						RuntimeSelection.SelectionChanged(array);
						return;
					}
					if (array.Length != m_objects.Length)
					{
						RuntimeSelection.SelectionChanged(array);
						return;
					}
					for (int i = 0; i < m_objects.Length; i++)
					{
						if (m_objects[i] != array[i])
						{
							RuntimeSelection.SelectionChanged(array);
							break;
						}
					}
				}
			}

			public static GameObject[] gameObjects
			{
				get
				{
					if (m_objects == null)
					{
						return null;
					}
					return m_objects.OfType<GameObject>().ToArray();
				}
			}

			public static Transform activeTransform
			{
				get
				{
					if (m_activeObject == null)
					{
						return null;
					}
					if (m_activeObject is GameObject)
					{
						return ((GameObject)m_activeObject).transform;
					}
					return null;
				}
				set
				{
					if ((bool)value)
					{
						m_activeObject = value.gameObject;
					}
					else
					{
						m_activeObject = null;
					}
				}
			}

			public static event RuntimeSelectionChanged SelectionChanged;

			public static void Select(UnityEngine.Object activeGameObject, UnityEngine.Object[] selection)
			{
				m_activeObject = activeGameObject;
				objects = selection;
			}
		}
		public class RuntimeSceneView : MonoBehaviour, IDropHandler, IEventSystemHandler, IPointerEnterHandler, IPointerExitHandler
		{
			private bool m_isPointerOverSceneView;

			public Texture2D ViewTexture;

			public Texture2D MoveTexture;

			public Camera Camera;

			public Transform Pivot;

			private bool m_pan;

			private bool m_rotate;

			private bool m_handleInput;

			private bool m_lockInput;

			private Vector3 m_lastMousePosition;

			private MouseOrbit m_mouseOrbit;

			public float RotationSensitivity = 1f;

			public float ZoomSensitivity = 8f;

			public float PanSensitivity = 100f;

			private PositionHandle m_positionHandle;

			private RotationHandle m_rotationHandle;

			private ScaleHandle m_scaleHandle;

			public bool IsPointerOver => m_isPointerOverSceneView;

			private void Awake()
			{
				if (Camera == null)
				{
					Camera = Camera.main;
				}
				if (Run.Instance == null)
				{
					GameObject obj = new GameObject();
					obj.name = "Run";
					obj.AddComponent<Run>();
				}
				RuntimeTools.Current = RuntimeTool.View;
				GameObject gameObject = new GameObject();
				gameObject.name = "PositionHandle";
				gameObject.transform.SetParent(base.transform, worldPositionStays: false);
				m_positionHandle = gameObject.AddComponent<PositionHandle>();
				gameObject.SetActive(value: false);
				GameObject gameObject2 = new GameObject();
				gameObject2.name = "RotationHandle";
				gameObject2.transform.SetParent(base.transform, worldPositionStays: false);
				m_rotationHandle = gameObject2.AddComponent<RotationHandle>();
				gameObject2.SetActive(value: false);
				GameObject gameObject3 = new GameObject();
				gameObject3.name = "ScaleHandle";
				gameObject3.transform.SetParent(base.transform, worldPositionStays: false);
				m_scaleHandle = gameObject3.AddComponent<ScaleHandle>();
				gameObject3.SetActive(value: false);
				RuntimeSelection.SelectionChanged += OnRuntimeSelectionChanged;
				RuntimeTools.ToolChanged += OnRuntimeToolChanged;
				UnityEditorToolsListener.ToolChanged += OnUnityEditorToolChanged;
				RuntimeTools.Current = RuntimeTool.Move;
				Camera.fieldOfView = 60f;
				OnProjectionChanged();
			}

			private void OnDestroy()
			{
				RuntimeTools.Current = RuntimeTool.None;
				RuntimeSelection.SelectionChanged -= OnRuntimeSelectionChanged;
				RuntimeTools.ToolChanged -= OnRuntimeToolChanged;
				UnityEditorToolsListener.ToolChanged -= OnUnityEditorToolChanged;
			}

			private void Start()
			{
				m_mouseOrbit = Camera.gameObject.GetComponent<MouseOrbit>();
				if (m_mouseOrbit == null)
				{
					m_mouseOrbit = Camera.gameObject.AddComponent<MouseOrbit>();
				}
				UnlockInput();
				m_mouseOrbit.enabled = false;
			}

			private void Update()
			{
				HandleInput();
			}

			public void LockInput()
			{
				m_lockInput = true;
			}

			public void UnlockInput()
			{
				m_lockInput = false;
				if (m_mouseOrbit != null)
				{
					Pivot.position = Camera.transform.position + Camera.transform.forward * m_mouseOrbit.Distance;
					m_mouseOrbit.Target = Pivot;
					m_mouseOrbit.SyncAngles();
				}
			}

			public void OnProjectionChanged()
			{
				float num = Camera.fieldOfView * ((float)Math.PI / 180f);
				float orthographicSize = (Camera.transform.position - Pivot.position).magnitude * Mathf.Sin(num / 2f);
				Camera.orthographicSize = orthographicSize;
			}

			private void OnRuntimeToolChanged()
			{
				SetCursor();
				if (RuntimeSelection.activeTransform == null)
				{
					return;
				}
				if (m_positionHandle != null)
				{
					m_positionHandle.gameObject.SetActive(value: false);
					if (RuntimeTools.Current == RuntimeTool.Move)
					{
						m_positionHandle.transform.position = RuntimeSelection.activeTransform.position;
						m_positionHandle.Targets = (from g in RuntimeSelection.gameObjects
							where g.GetComponent<ExposeToEditor>()
							select g.transform into g
							orderby RuntimeSelection.activeTransform == g descending
							select g).ToArray();
						m_positionHandle.gameObject.SetActive(m_positionHandle.Targets.Length != 0);
					}
				}
				if (m_rotationHandle != null)
				{
					m_rotationHandle.gameObject.SetActive(value: false);
					if (RuntimeTools.Current == RuntimeTool.Rotate)
					{
						m_rotationHandle.transform.position = RuntimeSelection.activeTransform.position;
						m_rotationHandle.Targets = (from g in RuntimeSelection.gameObjects
							where g.GetComponent<ExposeToEditor>()
							select g.transform into g
							orderby RuntimeSelection.activeTransform == g descending
							select g).ToArray();
						m_rotationHandle.gameObject.SetActive(m_rotationHandle.Targets.Length != 0);
					}
				}
				if (!(m_scaleHandle != null))
				{
					return;
				}
				m_scaleHandle.gameObject.SetActive(value: false);
				if (RuntimeTools.Current == RuntimeTool.Scale)
				{
					m_scaleHandle.transform.position = RuntimeSelection.activeTransform.position;
					m_scaleHandle.Targets = (from g in RuntimeSelection.gameObjects
						where g.GetComponent<ExposeToEditor>()
						select g.transform into g
						orderby RuntimeSelection.activeTransform == g descending
						select g).ToArray();
					m_scaleHandle.gameObject.SetActive(m_scaleHandle.Targets.Length != 0);
				}
			}

			private void OnUnityEditorToolChanged()
			{
			}

			private void OnRuntimeSelectionChanged(UnityEngine.Object[] unselected)
			{
				if (RuntimeSelection.activeGameObject == null || RuntimePrefabs.IsPrefab(RuntimeSelection.activeGameObject.transform))
				{
					if (m_positionHandle != null)
					{
						m_positionHandle.gameObject.SetActive(value: false);
					}
					if (m_rotationHandle != null)
					{
						m_rotationHandle.gameObject.SetActive(value: false);
					}
					if (m_scaleHandle != null)
					{
						m_scaleHandle.gameObject.SetActive(value: false);
					}
				}
				else
				{
					OnRuntimeToolChanged();
				}
			}

			private void HandleInput()
			{
				if (Input.GetMouseButtonUp(0) || Input.GetMouseButtonUp(1) || Input.GetMouseButtonUp(2))
				{
					m_handleInput = false;
					m_mouseOrbit.enabled = false;
					m_rotate = false;
					SetCursor();
				}
				else
				{
					if (m_lockInput)
					{
						return;
					}
					if (Input.GetKeyDown(KeyCode.F))
					{
						Focus();
					}
					bool flag = Input.GetMouseButton(2) || Input.GetMouseButton(1) || (Input.GetMouseButton(0) && RuntimeTools.Current == RuntimeTool.View);
					bool flag2 = Input.GetKey(KeyCode.AltGr) || Input.GetKey(KeyCode.LeftAlt) || Input.GetKey(KeyCode.RightAlt);
					if (flag != m_pan)
					{
						m_pan = flag;
						if (m_pan && RuntimeTools.Current != RuntimeTool.View)
						{
							m_rotate = false;
						}
						SetCursor();
					}
					else if (flag2 != m_rotate)
					{
						m_rotate = flag2;
						SetCursor();
					}
					bool flag4 = (RuntimeTools.IsLocked = m_rotate || flag);
					if (!flag4)
					{
						if (Input.GetKeyDown(KeyCode.Q))
						{
							RuntimeTools.Current = RuntimeTool.View;
						}
						else if (Input.GetKeyDown(KeyCode.W))
						{
							RuntimeTools.Current = RuntimeTool.Move;
						}
						else if (Input.GetKeyDown(KeyCode.E))
						{
							RuntimeTools.Current = RuntimeTool.Rotate;
						}
						else if (Input.GetKeyDown(KeyCode.R))
						{
							RuntimeTools.Current = RuntimeTool.Scale;
						}
					}
					if (!m_isPointerOverSceneView)
					{
						return;
					}
					if (Input.GetKeyDown(KeyCode.X))
					{
						if (RuntimeTools.PivotRotation == RuntimePivotRotation.Local)
						{
							RuntimeTools.PivotRotation = RuntimePivotRotation.Global;
						}
						else
						{
							RuntimeTools.PivotRotation = RuntimePivotRotation.Local;
						}
					}
					if (Input.GetMouseButtonDown(0) || Input.GetMouseButtonDown(1) || Input.GetMouseButtonDown(2))
					{
						m_handleInput = !m_positionHandle.IsDragging;
						m_lastMousePosition = Input.mousePosition;
						if (m_rotate)
						{
							m_mouseOrbit.enabled = true;
						}
					}
					if (Input.GetAxis("Mouse ScrollWheel") != 0f && (!EventSystem.current || !EventSystem.current.IsPointerOverGameObject() || m_isPointerOverSceneView))
					{
						m_mouseOrbit.Zoom();
					}
					if (m_handleInput && flag4 && m_pan && (!m_rotate || RuntimeTools.Current != RuntimeTool.View))
					{
						Pan();
					}
				}
			}

			private void Focus()
			{
				if (RuntimeSelection.activeTransform == null)
				{
					return;
				}
				Bounds bounds = CalculateBounds(RuntimeSelection.activeTransform);
				float num = Camera.fieldOfView * ((float)Math.PI / 180f);
				float num2 = Mathf.Max(bounds.extents.y, bounds.extents.x, bounds.extents.z) * 2f;
				float num3 = Mathf.Abs(num2 / Mathf.Sin(num / 2f));
				Pivot.position = bounds.center;
				Run.Instance.Animation(new Vector3AnimationInfo(Camera.transform.position, Pivot.position - num3 * Camera.transform.forward, 0.5f, AnimationInfo<object, Vector3>.EaseOutCubic, delegate(object target, Vector3 value, float t, bool completed)
				{
					if ((bool)Camera)
					{
						Camera.transform.position = value;
					}
				}));
				Run.Instance.Animation(new FloatAnimationInfo(m_mouseOrbit.Distance, num3, 0.5f, AnimationInfo<object, Vector3>.EaseOutCubic, delegate(object target, float value, float t, bool completed)
				{
					if ((bool)m_mouseOrbit)
					{
						m_mouseOrbit.Distance = value;
					}
				}));
				Run.Instance.Animation(new FloatAnimationInfo(Camera.orthographicSize, num2, 0.5f, AnimationInfo<object, Vector3>.EaseOutCubic, delegate(object target, float value, float t, bool completed)
				{
					if ((bool)Camera)
					{
						Camera.orthographicSize = value;
					}
				}));
			}

			private Bounds CalculateBounds(Transform t)
			{
				Renderer componentInChildren = t.GetComponentInChildren<Renderer>();
				if ((bool)componentInChildren)
				{
					Bounds totalBounds = componentInChildren.bounds;
					if (totalBounds.size == Vector3.zero && totalBounds.center != componentInChildren.transform.position)
					{
						totalBounds = TransformBounds(componentInChildren.transform.localToWorldMatrix, totalBounds);
					}
					CalculateBounds(t, ref totalBounds);
					if (totalBounds.extents == Vector3.zero)
					{
						totalBounds.extents = new Vector3(0.5f, 0.5f, 0.5f);
					}
					return totalBounds;
				}
				return new Bounds(t.position, new Vector3(0.5f, 0.5f, 0.5f));
			}

			private void CalculateBounds(Transform t, ref Bounds totalBounds)
			{
				foreach (Transform item in t)
				{
					Renderer component = item.GetComponent<Renderer>();
					if ((bool)component)
					{
						Bounds bounds = component.bounds;
						if (bounds.size == Vector3.zero && bounds.center != component.transform.position)
						{
							bounds = TransformBounds(component.transform.localToWorldMatrix, bounds);
						}
						totalBounds.Encapsulate(bounds.min);
						totalBounds.Encapsulate(bounds.max);
					}
					CalculateBounds(item, ref totalBounds);
				}
			}

			public static Bounds TransformBounds(Matrix4x4 matrix, Bounds bounds)
			{
				Vector3 center = matrix.MultiplyPoint(bounds.center);
				Vector3 extents = bounds.extents;
				Vector3 vector = matrix.MultiplyVector(new Vector3(extents.x, 0f, 0f));
				Vector3 vector2 = matrix.MultiplyVector(new Vector3(0f, extents.y, 0f));
				Vector3 vector3 = matrix.MultiplyVector(new Vector3(0f, 0f, extents.z));
				extents.x = Mathf.Abs(vector.x) + Mathf.Abs(vector2.x) + Mathf.Abs(vector3.x);
				extents.y = Mathf.Abs(vector.y) + Mathf.Abs(vector2.y) + Mathf.Abs(vector3.y);
				extents.z = Mathf.Abs(vector.z) + Mathf.Abs(vector2.z) + Mathf.Abs(vector3.z);
				Bounds result = default(Bounds);
				result.center = center;
				result.extents = extents;
				return result;
			}

			private void Pan()
			{
				Vector3 vector = m_lastMousePosition - Input.mousePosition;
				vector /= Mathf.Sqrt(Camera.pixelHeight * Camera.pixelHeight + Camera.pixelWidth * Camera.pixelWidth);
				vector *= PanSensitivity;
				vector = Camera.cameraToWorldMatrix.MultiplyVector(vector);
				Camera.transform.position += vector;
				Pivot.position += vector;
				m_lastMousePosition = Input.mousePosition;
			}

			void IDropHandler.OnDrop(PointerEventData eventData)
			{
				GameObject pointerDrag = eventData.pointerDrag;
				if (!(pointerDrag != null))
				{
					return;
				}
				ItemContainer component = pointerDrag.GetComponent<ItemContainer>();
				if (!(component != null) || component.Item == null)
				{
					return;
				}
				object item = component.Item;
				if (item == null || !(item is GameObject))
				{
					return;
				}
				GameObject gameObject = item as GameObject;
				if (RuntimePrefabs.IsPrefab(gameObject.transform))
				{
					Ray ray = Camera.ScreenPointToRay(Input.mousePosition);
					float distance = 15f;
					Vector3 point = ray.GetPoint(distance);
					GameObject obj = UnityEngine.Object.Instantiate(gameObject);
					ExposeToEditor component2 = obj.GetComponent<ExposeToEditor>();
					if (component2 != null)
					{
						component2.SetName(gameObject.name);
					}
					obj.transform.position = point;
					obj.transform.rotation = gameObject.transform.rotation;
					obj.transform.localScale = gameObject.transform.localScale;
					RuntimeSelection.activeGameObject = obj;
				}
			}

			void IPointerEnterHandler.OnPointerEnter(PointerEventData eventData)
			{
				m_isPointerOverSceneView = true;
				SetCursor();
			}

			private void SetCursor()
			{
				if (!m_isPointerOverSceneView)
				{
					Cursor.SetCursor(null, Vector2.zero, CursorMode.Auto);
				}
				else if (m_pan)
				{
					if (m_rotate && RuntimeTools.Current == RuntimeTool.View)
					{
						Cursor.SetCursor(ViewTexture, Vector2.zero, CursorMode.Auto);
					}
					else
					{
						Cursor.SetCursor(MoveTexture, Vector2.zero, CursorMode.Auto);
					}
				}
				else if (m_rotate)
				{
					Cursor.SetCursor(ViewTexture, Vector2.zero, CursorMode.Auto);
				}
				else if (RuntimeTools.Current == RuntimeTool.View)
				{
					Cursor.SetCursor(MoveTexture, Vector2.zero, CursorMode.Auto);
				}
				else
				{
					Cursor.SetCursor(null, Vector2.zero, CursorMode.Auto);
				}
			}

			void IPointerExitHandler.OnPointerExit(PointerEventData eventData)
			{
				Cursor.SetCursor(null, Vector2.zero, CursorMode.Auto);
				m_isPointerOverSceneView = false;
			}
		}
		public class RuntimeToolsPanel : MonoBehaviour
		{
			private bool m_handleValueChange = true;

			public Toggle ViewToggle;

			public Toggle MoveToggle;

			public Toggle RotateToggle;

			public Toggle ScaleToggle;

			public Toggle PivotRotationToggle;

			public Toggle WireframeToggle;

			private void OnEnable()
			{
				OnRuntimeToolChanged();
				OnPivotRotationChanged();
				RuntimeTools.ToolChanged += OnRuntimeToolChanged;
				RuntimeTools.PivotRotationChanged += OnPivotRotationChanged;
				if (ViewToggle != null)
				{
					ViewToggle.onValueChanged.AddListener(OnViewToggleValueChanged);
				}
				if (MoveToggle != null)
				{
					MoveToggle.onValueChanged.AddListener(OnMoveToggleValueChanged);
				}
				if (RotateToggle != null)
				{
					RotateToggle.onValueChanged.AddListener(OnRotateToggleValueChanged);
				}
				if (ScaleToggle != null)
				{
					ScaleToggle.onValueChanged.AddListener(OnScaleToggleValueChanged);
				}
				if (PivotRotationToggle != null)
				{
					PivotRotationToggle.onValueChanged.AddListener(OnPivotRotationToggleValueChanged);
				}
				if (WireframeToggle != null)
				{
					WireframeToggle.onValueChanged.AddListener(OnWireframeToggleValueChanged);
				}
			}

			private void OnDisable()
			{
				RuntimeTools.ToolChanged -= OnRuntimeToolChanged;
				RuntimeTools.PivotRotationChanged -= OnPivotRotationChanged;
				if (ViewToggle != null)
				{
					ViewToggle.onValueChanged.RemoveListener(OnViewToggleValueChanged);
				}
				if (MoveToggle != null)
				{
					MoveToggle.onValueChanged.RemoveListener(OnMoveToggleValueChanged);
				}
				if (RotateToggle != null)
				{
					RotateToggle.onValueChanged.RemoveListener(OnRotateToggleValueChanged);
				}
				if (ScaleToggle != null)
				{
					ScaleToggle.onValueChanged.RemoveListener(OnScaleToggleValueChanged);
				}
				if (PivotRotationToggle != null)
				{
					PivotRotationToggle.onValueChanged.RemoveListener(OnPivotRotationToggleValueChanged);
				}
				if (WireframeToggle != null)
				{
					WireframeToggle.onValueChanged.RemoveListener(OnWireframeToggleValueChanged);
				}
			}

			private void OnViewToggleValueChanged(bool value)
			{
				if (m_handleValueChange)
				{
					if (value)
					{
						RuntimeTools.Current = RuntimeTool.View;
						m_handleValueChange = false;
						RotateToggle.isOn = false;
						ScaleToggle.isOn = false;
						MoveToggle.isOn = false;
						m_handleValueChange = true;
					}
					else if (RuntimeTools.Current == RuntimeTool.View)
					{
						ViewToggle.isOn = true;
					}
				}
			}

			private void OnMoveToggleValueChanged(bool value)
			{
				if (m_handleValueChange)
				{
					if (value)
					{
						RuntimeTools.Current = RuntimeTool.Move;
						m_handleValueChange = false;
						RotateToggle.isOn = false;
						ScaleToggle.isOn = false;
						ViewToggle.isOn = false;
						m_handleValueChange = true;
					}
					else if (RuntimeTools.Current == RuntimeTool.Move)
					{
						MoveToggle.isOn = true;
					}
				}
			}

			private void OnRotateToggleValueChanged(bool value)
			{
				if (m_handleValueChange)
				{
					if (value)
					{
						RuntimeTools.Current = RuntimeTool.Rotate;
						m_handleValueChange = false;
						ViewToggle.isOn = false;
						ScaleToggle.isOn = false;
						MoveToggle.isOn = false;
						m_handleValueChange = true;
					}
					else if (RuntimeTools.Current == RuntimeTool.Rotate)
					{
						RotateToggle.isOn = true;
					}
				}
			}

			private void OnScaleToggleValueChanged(bool value)
			{
				if (m_handleValueChange)
				{
					if (value)
					{
						RuntimeTools.Current = RuntimeTool.Scale;
						m_handleValueChange = false;
						ViewToggle.isOn = false;
						RotateToggle.isOn = false;
						MoveToggle.isOn = false;
						m_handleValueChange = true;
					}
					else if (RuntimeTools.Current == RuntimeTool.Scale)
					{
						ScaleToggle.isOn = true;
					}
				}
			}

			private void OnPivotRotationToggleValueChanged(bool value)
			{
				if (value)
				{
					RuntimeTools.PivotRotation = RuntimePivotRotation.Global;
				}
				else
				{
					RuntimeTools.PivotRotation = RuntimePivotRotation.Local;
				}
			}

			private void OnWireframeToggleValueChanged(bool value)
			{
			}

			private void OnPivotRotationChanged()
			{
				if (PivotRotationToggle != null)
				{
					if (RuntimeTools.PivotRotation == RuntimePivotRotation.Global)
					{
						PivotRotationToggle.isOn = true;
					}
					else
					{
						PivotRotationToggle.isOn = false;
					}
				}
			}

			private void OnRuntimeToolChanged()
			{
				if (m_handleValueChange)
				{
					if (ViewToggle != null)
					{
						ViewToggle.isOn = RuntimeTools.Current == RuntimeTool.View;
					}
					if (MoveToggle != null)
					{
						MoveToggle.isOn = RuntimeTools.Current == RuntimeTool.Move;
					}
					if (RotateToggle != null)
					{
						RotateToggle.isOn = RuntimeTools.Current == RuntimeTool.Rotate;
					}
					if (ScaleToggle != null)
					{
						ScaleToggle.isOn = RuntimeTools.Current == RuntimeTool.Scale;
					}
				}
			}
		}
		public class TransformComponent : MonoBehaviour
		{
			public Toggle EnableDisableToggle;

			public GameObject TransformComponentUI;

			public InputField PositionX;

			public InputField PositionY;

			public InputField PositionZ;

			public InputField RotationX;

			public InputField RotationY;

			public InputField RotationZ;

			public InputField ScaleX;

			public InputField ScaleY;

			public InputField ScaleZ;

			public Button Reset;

			private Transform[] m_transforms;

			private HashSet<GameObject> m_selectedGameObjects = new HashSet<GameObject>();

			private bool m_handleTransformChange = true;

			private void Awake()
			{
				RuntimeSelection.SelectionChanged += OnRuntimeSelectionChanged;
			}

			private void OnDestroy()
			{
				RuntimeSelection.SelectionChanged -= OnRuntimeSelectionChanged;
			}

			private void OnEnable()
			{
				ExposeToEditor.TransformChanged += OnTransformChanged;
				PositionX.onValueChanged.AddListener(OnPositionXChanged);
				PositionY.onValueChanged.AddListener(OnPositionYChanged);
				PositionZ.onValueChanged.AddListener(OnPositionZChanged);
				RotationX.onValueChanged.AddListener(OnRotationXChanged);
				RotationY.onValueChanged.AddListener(OnRotationYChanged);
				RotationZ.onValueChanged.AddListener(OnRotationZChanged);
				ScaleX.onValueChanged.AddListener(OnScaleXChanged);
				ScaleY.onValueChanged.AddListener(OnScaleYChanged);
				ScaleZ.onValueChanged.AddListener(OnScaleZChanged);
				PositionX.onEndEdit.AddListener(OnEndEdit);
				PositionY.onEndEdit.AddListener(OnEndEdit);
				PositionZ.onEndEdit.AddListener(OnEndEdit);
				RotationX.onEndEdit.AddListener(OnEndEdit);
				RotationY.onEndEdit.AddListener(OnEndEdit);
				RotationZ.onEndEdit.AddListener(OnEndEdit);
				ScaleX.onEndEdit.AddListener(OnEndEdit);
				ScaleY.onEndEdit.AddListener(OnEndEdit);
				ScaleZ.onEndEdit.AddListener(OnEndEdit);
				Reset.onClick.AddListener(OnResetClick);
				EnableDisableToggle.onValueChanged.AddListener(OnEnableDisableValueChanged);
				OnRuntimeSelectionChanged(null);
			}

			private void OnDisable()
			{
				ExposeToEditor.TransformChanged -= OnTransformChanged;
				PositionX.onValueChanged.RemoveListener(OnPositionXChanged);
				PositionY.onValueChanged.RemoveListener(OnPositionYChanged);
				PositionZ.onValueChanged.RemoveListener(OnPositionZChanged);
				RotationX.onValueChanged.RemoveListener(OnRotationXChanged);
				RotationY.onValueChanged.RemoveListener(OnRotationYChanged);
				RotationZ.onValueChanged.RemoveListener(OnRotationZChanged);
				ScaleX.onValueChanged.RemoveListener(OnScaleXChanged);
				ScaleY.onValueChanged.RemoveListener(OnScaleYChanged);
				ScaleZ.onValueChanged.RemoveListener(OnScaleZChanged);
				PositionX.onEndEdit.RemoveListener(OnEndEdit);
				PositionY.onEndEdit.RemoveListener(OnEndEdit);
				PositionZ.onEndEdit.RemoveListener(OnEndEdit);
				RotationX.onEndEdit.RemoveListener(OnEndEdit);
				RotationY.onEndEdit.RemoveListener(OnEndEdit);
				RotationZ.onEndEdit.RemoveListener(OnEndEdit);
				ScaleX.onEndEdit.RemoveListener(OnEndEdit);
				ScaleY.onEndEdit.RemoveListener(OnEndEdit);
				ScaleZ.onEndEdit.RemoveListener(OnEndEdit);
				Reset.onClick.RemoveListener(OnResetClick);
				EnableDisableToggle.onValueChanged.RemoveListener(OnEnableDisableValueChanged);
			}

			private void HandlePositionChanged()
			{
				if (m_handleTransformChange && m_transforms != null && m_transforms.Length != 0 && float.TryParse(PositionX.text, out var result) && float.TryParse(PositionY.text, out var result2) && float.TryParse(PositionZ.text, out var result3))
				{
					for (int i = 0; i < m_transforms.Length; i++)
					{
						m_transforms[i].position = new Vector3(result, result2, result3);
					}
				}
			}

			private void HandleRotationChanged()
			{
				if (m_handleTransformChange && m_transforms != null && m_transforms.Length != 0 && float.TryParse(RotationX.text, out var result) && float.TryParse(RotationY.text, out var result2) && float.TryParse(RotationZ.text, out var result3))
				{
					for (int i = 0; i < m_transforms.Length; i++)
					{
						m_transforms[i].rotation = Quaternion.Euler(result, result2, result3);
					}
				}
			}

			private void HandleScaleChanged()
			{
				if (m_handleTransformChange && m_transforms != null && m_transforms.Length != 0 && float.TryParse(ScaleX.text, out var result) && float.TryParse(ScaleY.text, out var result2) && float.TryParse(ScaleZ.text, out var result3))
				{
					for (int i = 0; i < m_transforms.Length; i++)
					{
						m_transforms[i].localScale = new Vector3(result, result2, result3);
					}
				}
			}

			private void EndEditField(InputField field)
			{
				if (!float.TryParse(field.text, out var _))
				{
					field.text = "0";
				}
			}

			private void OnEndEdit(string value)
			{
				EndEditField(PositionX);
				EndEditField(PositionY);
				EndEditField(PositionZ);
				EndEditField(RotationX);
				EndEditField(RotationY);
				EndEditField(RotationZ);
				EndEditField(ScaleX);
				EndEditField(ScaleY);
				EndEditField(ScaleZ);
			}

			private void OnPositionXChanged(string value)
			{
				HandlePositionChanged();
			}

			private void OnPositionYChanged(string value)
			{
				HandlePositionChanged();
			}

			private void OnPositionZChanged(string value)
			{
				HandlePositionChanged();
			}

			private void OnRotationXChanged(string value)
			{
				HandleRotationChanged();
			}

			private void OnRotationYChanged(string value)
			{
				HandleRotationChanged();
			}

			private void OnRotationZChanged(string value)
			{
				HandleRotationChanged();
			}

			private void OnScaleXChanged(string value)
			{
				HandleScaleChanged();
			}

			private void OnScaleYChanged(string value)
			{
				HandleScaleChanged();
			}

			private void OnScaleZChanged(string value)
			{
				HandleScaleChanged();
			}

			private void OnTransformChanged(ExposeToEditor obj)
			{
				if (m_selectedGameObjects.Contains(obj.gameObject))
				{
					m_handleTransformChange = false;
					UpdateAllFields();
					m_handleTransformChange = true;
				}
			}

			private void OnRuntimeSelectionChanged(UnityEngine.Object[] unselected)
			{
				GameObject[] gameObjects = RuntimeSelection.gameObjects;
				if (gameObjects == null)
				{
					m_selectedGameObjects.Clear();
					EnableDisableToggle.gameObject.SetActive(value: false);
					TransformComponentUI.gameObject.SetActive(value: false);
					m_transforms = null;
					return;
				}
				m_selectedGameObjects.Clear();
				m_transforms = (from g in gameObjects
					where g.GetComponent<ExposeToEditor>()
					select g.GetComponent<Transform>() into t
					where t.GetType() == typeof(Transform)
					select t).ToArray();
				for (int i = 0; i < m_transforms.Length; i++)
				{
					m_selectedGameObjects.Add(m_transforms[i].gameObject);
				}
				if (m_transforms.Length != 0)
				{
					EnableDisableToggle.gameObject.SetActive(value: true);
					TransformComponentUI.gameObject.SetActive(value: true);
					m_handleTransformChange = false;
					UpdateAllFields();
					m_handleTransformChange = true;
				}
				else
				{
					EnableDisableToggle.gameObject.SetActive(value: false);
					TransformComponentUI.gameObject.SetActive(value: false);
				}
			}

			private void UpdateAllFields()
			{
				IEnumerable<float> values = m_transforms.Select((Transform t) => t.position.x);
				IEnumerable<float> values2 = m_transforms.Select((Transform t) => t.position.y);
				IEnumerable<float> values3 = m_transforms.Select((Transform t) => t.position.z);
				IEnumerable<float> values4 = m_transforms.Select((Transform t) => t.rotation.eulerAngles.x);
				IEnumerable<float> values5 = m_transforms.Select((Transform t) => t.rotation.eulerAngles.y);
				IEnumerable<float> values6 = m_transforms.Select((Transform t) => t.rotation.eulerAngles.z);
				IEnumerable<float> values7 = m_transforms.Select((Transform t) => t.localScale.x);
				IEnumerable<float> values8 = m_transforms.Select((Transform t) => t.localScale.y);
				IEnumerable<float> values9 = m_transforms.Select((Transform t) => t.localScale.z);
				SetFieldValue(PositionX, values);
				SetFieldValue(PositionY, values2);
				SetFieldValue(PositionZ, values3);
				SetFieldValue(RotationX, values4);
				SetFieldValue(RotationY, values5);
				SetFieldValue(RotationZ, values6);
				SetFieldValue(ScaleX, values7);
				SetFieldValue(ScaleY, values8);
				SetFieldValue(ScaleZ, values9);
				EnableDisableToggle.isOn = m_transforms.All((Transform t) => t.gameObject.activeSelf);
			}

			private void SetFieldValue(InputField field, IEnumerable<float> values)
			{
				if (values.Any((float p) => p != values.First()))
				{
					field.text = string.Empty;
				}
				else
				{
					field.text = values.First().ToString();
				}
			}

			private void OnResetClick()
			{
				float num = 0f;
				float num2 = 1f;
				PositionX.text = num.ToString();
				PositionY.text = num.ToString();
				PositionZ.text = num.ToString();
				RotationX.text = num.ToString();
				RotationY.text = num.ToString();
				RotationZ.text = num.ToString();
				ScaleX.text = num2.ToString();
				ScaleY.text = num2.ToString();
				ScaleZ.text = num2.ToString();
			}

			private void OnEnableDisableValueChanged(bool value)
			{
				for (int i = 0; i < m_transforms.Length; i++)
				{
					m_transforms[i].gameObject.SetActive(value);
				}
			}
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(RectTransform))]
		public class ViewportFitter : MonoBehaviour
		{
			public UnityEvent ViewportRectChanged;

			private RectTransform m_viewport;

			private Vector3 m_viewportPosition;

			private float m_viewportWidth;

			private float m_viewportHeight;

			public Camera Camera;

			private void Awake()
			{
				m_viewport = GetComponent<RectTransform>();
				if (Camera == null)
				{
					Camera = Camera.main;
				}
				if (Camera == null)
				{
					UnityEngine.Debug.LogWarning("Set Camera");
					return;
				}
				Canvas componentInParent = m_viewport.GetComponentInParent<Canvas>();
				if (componentInParent == null)
				{
					base.gameObject.SetActive(value: false);
				}
				else if (componentInParent.renderMode != 0)
				{
					base.gameObject.SetActive(value: false);
					UnityEngine.Debug.LogWarning("ViewportFitter requires canvas.renderMode -> RenderMode.ScreenSpaceOverlay");
				}
				else
				{
					Camera.pixelRect = new Rect(new Vector2(0f, 0f), new Vector2(Screen.width, Screen.height));
				}
			}

			private void OnEnable()
			{
				Rect rect = m_viewport.rect;
				UpdateViewport();
				m_viewportHeight = rect.height;
				m_viewportWidth = rect.width;
				m_viewportPosition = m_viewport.position;
			}

			private void Start()
			{
				Rect rect = m_viewport.rect;
				UpdateViewport();
				m_viewportHeight = rect.height;
				m_viewportWidth = rect.width;
				m_viewportPosition = m_viewport.position;
			}

			private void OnDisable()
			{
				if (Camera != null)
				{
					Camera.rect = new Rect(0f, 0f, 1f, 1f);
					ViewportRectChanged.Invoke();
				}
			}

			private void OnGUI()
			{
				if (m_viewport != null)
				{
					Rect rect = m_viewport.rect;
					if (m_viewportHeight != rect.height || m_viewportWidth != rect.width || m_viewportPosition != m_viewport.position)
					{
						UpdateViewport();
						m_viewportHeight = rect.height;
						m_viewportWidth = rect.width;
						m_viewportPosition = m_viewport.position;
					}
				}
			}

			private void UpdateViewport()
			{
				if (!(Camera == null))
				{
					Vector3[] array = new Vector3[4];
					m_viewport.GetWorldCorners(array);
					Camera.pixelRect = new Rect(array[0], new Vector2(array[2].x - array[0].x, array[1].y - array[0].y));
					ViewportRectChanged.Invoke();
				}
			}
		}
	}
	namespace Battlehub.SplineEditor
	{
		public class EpiSplineHelper : MonoBehaviour
		{
			public SplineFollow splineFollow;

			public float speedMultiplier = 5f;

			public float speedUpTime = 5f;

			private float initialSpeed;

			private void Start()
			{
				initialSpeed = splineFollow.Speed;
			}

			public void SpeedUp()
			{
				splineFollow.Speed = initialSpeed * speedMultiplier;
				Invoke("ResetSpeed", speedUpTime);
			}

			public void ResetSpeed()
			{
				splineFollow.Speed = initialSpeed;
			}
		}
		public class EpiSplineObject : MonoBehaviour
		{
			public SplineBase spline;

			public GameObject spawnObject;

			public float offset;

			public bool test;

			public void Update()
			{
				if (test)
				{
					Spawn();
					test = false;
				}
			}

			public void Spawn()
			{
				int num = 0;
				int index = num + 1;
				Twist twist = spline.GetTwist(num);
				Vector3 controlPoint = spline.GetControlPoint(num);
				Vector3 controlPoint2 = spline.GetControlPoint(index);
				SplineFollow component = UnityEngine.Object.Instantiate(spawnObject, spline.GetPoint(0f), Quaternion.AngleAxis(twist.Data, controlPoint2 - controlPoint) * Quaternion.LookRotation(controlPoint2 - controlPoint)).GetComponent<SplineFollow>();
				component.Spline = spline;
				component.Offset = offset;
			}
		}
		public class Greedy : MonoBehaviour
		{
			public void OnFork(ForkEventArgs args)
			{
				float num = float.MaxValue;
				int selectBranchIndex = -1;
				if (args.NextCurveIndex != -1)
				{
					num = args.Spline.EvalCurveLength(args.NextCurveIndex);
				}
				for (int i = 0; i < args.Branches.Length; i++)
				{
					float num2 = args.Branches[i].EvalCurveLength(0);
					if (num2 < num)
					{
						num = num2;
						selectBranchIndex = i;
					}
				}
				args.SelectBranchIndex = selectBranchIndex;
			}
		}
		public class MapGen : MonoBehaviour
		{
			public GameObject BuildingPrefab;

			public int Rows = 10;

			public int Cols = 10;

			public float Density = 0.2f;

			public float Width = 2f;

			public float Length = 2f;

			public float MinHeight = 8f;

			public float MaxHeight = 16f;

			public void Generate()
			{
				for (int num = base.transform.childCount - 1; num >= 0; num--)
				{
					UnityEngine.Object.DestroyImmediate(base.transform.GetChild(num).gameObject);
				}
				for (int i = 0; i < Rows; i++)
				{
					for (int j = 0; j < Cols; j++)
					{
						if (UnityEngine.Random.value < Density)
						{
							float x = (float)(-Rows) * Width / 2f + (float)i * Width;
							float z = (float)(-Cols) * Length / 2f + (float)j * Length;
							float y = MinHeight + UnityEngine.Random.value * (MaxHeight - MinHeight);
							GameObject obj = UnityEngine.Object.Instantiate(BuildingPrefab, new Vector3(x, 0f, z), Quaternion.identity);
							obj.transform.localScale = new Vector3(Width / 2f, y, Length / 2f);
							obj.transform.SetParent(base.transform, worldPositionStays: true);
						}
					}
				}
			}
		}
		public class Paperplane : MonoBehaviour
		{
			public GameObject ExplosionPrefab;

			public void Destroy()
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}

			private void Update()
			{
				if (Input.GetMouseButtonDown(0) && Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out var hitInfo) && hitInfo.transform == base.transform)
				{
					Explode();
				}
			}

			private void OnTriggerEnter(Collider collision)
			{
				Explode();
			}

			private void Explode()
			{
				if (ExplosionPrefab != null)
				{
					UnityEngine.Object.Destroy(UnityEngine.Object.Instantiate(ExplosionPrefab, base.transform.position, base.transform.rotation), 3f);
				}
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}
		public class PaperplaneSpawn : MonoBehaviour
		{
			public float Interval = 2f;

			private float m_timeElapsed;

			public SmoothFollow SmoothFollow;

			public GameObject PaperplanePrefab;

			private SplineBase m_spline;

			public string SplineName = "Spline";

			private void Start()
			{
				if (m_spline == null)
				{
					GameObject gameObject = GameObject.Find(SplineName);
					if (gameObject != null)
					{
						m_spline = gameObject.GetComponent<SplineBase>();
					}
					if (m_spline == null)
					{
						UnityEngine.Debug.LogError("Unable to find spline " + m_spline);
						base.enabled = false;
						return;
					}
				}
				Spawn();
			}

			private void Update()
			{
				m_timeElapsed += Time.deltaTime;
				if (m_timeElapsed >= Interval)
				{
					Spawn();
					m_timeElapsed = 0f;
				}
			}

			private void Spawn()
			{
				int num = 0;
				int index = num + 1;
				Twist twist = m_spline.GetTwist(num);
				Vector3 controlPoint = m_spline.GetControlPoint(num);
				Vector3 controlPoint2 = m_spline.GetControlPoint(index);
				GameObject gameObject = UnityEngine.Object.Instantiate(PaperplanePrefab, m_spline.GetPoint(0f), Quaternion.AngleAxis(twist.Data, controlPoint2 - controlPoint) * Quaternion.LookRotation(controlPoint2 - controlPoint));
				gameObject.GetComponent<SplineFollow>().Spline = m_spline;
				if (!SmoothFollow.enabled)
				{
					SmoothFollow.SetTarget(gameObject.transform);
					SmoothFollow.enabled = true;
				}
			}
		}
		public class Rand : MonoBehaviour
		{
			public void OnFork(ForkEventArgs args)
			{
				int selectBranchIndex = UnityEngine.Random.Range((args.NextCurveIndex != -1) ? (-1) : 0, args.Branches.Length);
				args.SelectBranchIndex = selectBranchIndex;
			}
		}
		public class SmoothFollow : MonoBehaviour
		{
			private bool m_wait;

			private Transform target;

			[SerializeField]
			private float distance = 10f;

			[SerializeField]
			private float height = 5f;

			[SerializeField]
			private float rotationDamping;

			[SerializeField]
			private float heightDamping;

			private void Start()
			{
			}

			public void SetTarget(Transform tr)
			{
				target = tr;
			}

			private IEnumerator ChangeTaget()
			{
				yield return new WaitForSeconds(1f);
				m_wait = false;
				if (!target)
				{
					Paperplane paperplane = UnityEngine.Object.FindObjectOfType<Paperplane>();
					if (paperplane != null)
					{
						SetTarget(paperplane.transform);
					}
					else
					{
						base.enabled = false;
					}
				}
			}

			private void LateUpdate()
			{
				if (RuntimeEditor.Instance != null && RuntimeEditor.Instance.IsOn)
				{
					return;
				}
				if (!target)
				{
					if (!m_wait)
					{
						StartCoroutine(ChangeTaget());
						m_wait = true;
					}
					return;
				}
				float y = target.eulerAngles.y;
				float b = target.position.y + height;
				float y2 = base.transform.eulerAngles.y;
				float y3 = base.transform.position.y;
				y2 = Mathf.LerpAngle(y2, y, rotationDamping * Time.deltaTime);
				y3 = Mathf.Lerp(y3, b, heightDamping * Time.deltaTime);
				Quaternion quaternion = Quaternion.Euler(0f, y2, 0f);
				base.transform.position = target.position;
				base.transform.position -= quaternion * Vector3.forward * distance;
				base.transform.position = new Vector3(base.transform.position.x, y3, base.transform.position.z);
				base.transform.LookAt(target);
			}
		}
		[Serializable]
		public class ForkEventArgs
		{
			private SplineBase[] m_branches;

			private SplineBase m_spline;

			private int m_nextCurveIndex;

			public SplineBase[] Branches => m_branches;

			public SplineBase Spline => m_spline;

			public int NextCurveIndex => m_nextCurveIndex;

			public int SelectBranchIndex { get; set; }

			public ForkEventArgs(SplineBase spline, int pointIndex)
			{
				m_spline = spline;
				m_nextCurveIndex = pointIndex / 3;
				SplineBranch[] branches = spline.GetBranches(pointIndex);
				if (branches == null || branches.Length == 0)
				{
					m_branches = new SplineBase[0];
				}
				else
				{
					List<SplineBase> list = new List<SplineBase>();
					for (int i = 0; i < branches.Length; i++)
					{
						SplineBranch branch = branches[i];
						if (!branch.Inbound)
						{
							list.Add(spline.BranchToSpline(branch));
						}
					}
					m_branches = list.ToArray();
				}
				if (m_nextCurveIndex >= spline.CurveCount)
				{
					if (m_branches.Length != 0)
					{
						SelectBranchIndex = 0;
					}
					SelectBranchIndex = -1;
					m_nextCurveIndex = -1;
				}
				else
				{
					SelectBranchIndex = -1;
				}
			}
		}
		[Serializable]
		public class ForkEvent : UnityEvent<ForkEventArgs>
		{
		}
		public class SplineFollow : MonoBehaviour
		{
			public float Speed = 5f;

			public SplineBase Spline;

			public float Offset;

			public bool IsRunning = true;

			public bool IsLoop;

			public ForkEvent Fork;

			public UnityEvent Completed;

			private SplineBase m_spline;

			private bool m_isRunning;

			private bool m_isCompleted;

			private float m_t;

			private int m_curveIndex;

			private void Start()
			{
				if (!Spline)
				{
					UnityEngine.Debug.LogError("Set Spline Field!");
					base.enabled = false;
				}
				else
				{
					m_isCompleted = true;
				}
			}

			private void Update()
			{
				if (IsRunning != m_isRunning)
				{
					if (m_isCompleted)
					{
						Restart();
					}
					m_isRunning = IsRunning;
				}
				if (IsRunning)
				{
					Move();
				}
			}

			private void Restart()
			{
				m_spline = Spline;
				m_t = Offset % 1f;
				m_curveIndex = Spline.ToCurveIndex(m_t);
				m_isCompleted = false;
				IsRunning = true;
			}

			private void Move()
			{
				int num = m_spline.ToCurveIndex(m_t);
				if (m_curveIndex != num || m_t >= 1f)
				{
					CheckBranches(num);
				}
				float t = m_t;
				UpdatePosition(t);
				float magnitude = m_spline.GetVelocity(t).magnitude;
				magnitude *= (float)m_spline.CurveCount;
				if (m_t >= 1f)
				{
					if (m_spline.NextSpline != null)
					{
						int nextControlPointIndex = m_spline.NextControlPointIndex;
						m_curveIndex = nextControlPointIndex / 3;
						m_spline = m_spline.NextSpline;
						if (m_spline.NextControlPointIndex > 0)
						{
							m_t = (float)m_curveIndex / (float)m_spline.CurveCount;
							m_curveIndex++;
						}
						else
						{
							m_t = (float)m_curveIndex / (float)m_spline.CurveCount;
						}
						UnityEngine.Debug.Log("Next Spline " + m_curveIndex);
						CheckBranches(m_curveIndex);
						return;
					}
					m_t = m_t - 1f + Time.deltaTime * Speed / magnitude;
					if (!m_spline.Loop && !IsLoop)
					{
						m_t = 1f;
						m_isCompleted = true;
						IsRunning = false;
						m_isRunning = false;
						Completed.Invoke();
					}
					if (IsLoop && m_spline != Spline)
					{
						Restart();
					}
				}
				else
				{
					m_t += Time.deltaTime * Speed / magnitude;
				}
			}

			private void CheckBranches(int curveIndex)
			{
				int num = curveIndex * 3;
				if (m_t >= 1f)
				{
					num += 3;
				}
				m_curveIndex = curveIndex;
				if (m_spline.HasBranches(num))
				{
					ForkEventArgs forkEventArgs = new ForkEventArgs(m_spline, num);
					Fork.Invoke(forkEventArgs);
					if (forkEventArgs.SelectBranchIndex > -1 && forkEventArgs.SelectBranchIndex < forkEventArgs.Branches.Length)
					{
						UnityEngine.Debug.Log("CurveIndex " + m_curveIndex);
						UnityEngine.Debug.Log("Selected Branch " + forkEventArgs.SelectBranchIndex);
						m_spline = forkEventArgs.Branches[forkEventArgs.SelectBranchIndex];
						m_t = 0f;
						m_curveIndex = 0;
					}
				}
			}

			private void UpdatePosition(float t)
			{
				Vector3 point = m_spline.GetPoint(t);
				Vector3 direction = m_spline.GetDirection(t);
				float twist = m_spline.GetTwist(t);
				base.transform.position = point;
				base.transform.LookAt(point + direction);
				base.transform.RotateAround(point, direction, twist);
			}
		}
		public static class CurveUtils
		{
			public static float GetT(this SplineBase spline, int curveIndex, Vector3 testPoint, float eps = 0.01f)
			{
				float num = 1f / (float)spline.CurveCount * (float)curveIndex;
				float tEnd = num + 1f / (float)spline.CurveCount;
				int iter = 0;
				return spline.GetT(num, tEnd, testPoint, ref iter, eps);
			}

			private static float GetT(this SplineBase spline, float tStart, float tEnd, Vector3 testPoint, ref int iter, float eps = 0.01f)
			{
				iter++;
				float num = eps * eps;
				Vector3 point = spline.GetPoint(tStart);
				Vector3 point2 = spline.GetPoint(tEnd);
				Vector3 vector = point - testPoint;
				Vector3 vector2 = point2 - testPoint;
				if (vector.sqrMagnitude < vector2.sqrMagnitude)
				{
					if ((point2 - point).sqrMagnitude <= num)
					{
						return tStart;
					}
					return spline.GetT(tStart, (tStart + tEnd) / 2f, testPoint, ref iter, eps);
				}
				if ((point2 - point).sqrMagnitude <= num)
				{
					return tEnd;
				}
				return spline.GetT((tStart + tEnd) / 2f, tEnd, testPoint, ref iter, eps);
			}

			public static Vector3 GetPoint(Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3, float t)
			{
				t = Mathf.Clamp01(t);
				float num = 1f - t;
				return num * num * num * p0 + 3f * num * num * t * p1 + 3f * num * t * t * p2 + t * t * t * p3;
			}

			public static Vector3 GetFirstDerivative(Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3, float t)
			{
				t = Mathf.Clamp01(t);
				float num = 1f - t;
				return 3f * num * num * (p1 - p0) + 6f * num * t * (p2 - p1) + 3f * t * t * (p3 - p2);
			}
		}
		[ExecuteInEditMode]
		public class Spline : SplineBase
		{
			private const float Mag = 5f;

			public void Append()
			{
				AppendCurve(5f, enforceNeighbour: false);
			}

			public void AppendThorugh(Transform t)
			{
				Vector3[] array = new Vector3[3];
				AlignWithEnding(array, base.CurveCount - 1, 5f);
				Vector3 pointLocal = GetPointLocal(1f);
				Vector3 vector = (array[2] = base.transform.InverseTransformPoint(t.position - t.forward));
				array[1] = vector - base.transform.InverseTransformVector(t.forward).normalized * (vector - pointLocal).magnitude * (1f / 3f);
				array[0] = vector - base.transform.InverseTransformVector(t.forward).normalized * (vector - pointLocal).magnitude * (2f / 3f);
				AppendCurve(array, enforceNeighbour: false);
			}

			public void Insert(int curveIndex)
			{
				PrependCurve(5f, curveIndex, enforceNeighbour: false, shrinkPreceding: true);
			}

			public void Prepend()
			{
				if (!Loop)
				{
					PrependCurve(5f, 0, enforceNeighbour: false, shrinkPreceding: false);
				}
				else
				{
					AppendCurve(5f, enforceNeighbour: false);
				}
			}

			public void PrependThrough(Transform t)
			{
				if (!Loop)
				{
					Vector3[] array = new Vector3[3];
					AlignWithBeginning(array, 0, 5f);
					Vector3 pointLocal = GetPointLocal(0f);
					Vector3 vector = (array[0] = base.transform.InverseTransformPoint(t.position + t.forward));
					array[1] = vector + base.transform.InverseTransformVector(t.forward).normalized * (vector - pointLocal).magnitude * (1f / 3f);
					array[2] = vector + base.transform.InverseTransformVector(t.forward).normalized * (vector - pointLocal).magnitude * (2f / 3f);
					PrependCurve(array, 0, 5f, enforceNeighbour: false, shrinkPreceding: false);
				}
				else
				{
					AppendThorugh(t);
				}
			}

			public bool Remove(int curveIndex)
			{
				return RemoveCurve(curveIndex);
			}

			public override void Load(SplineSnapshot snapshot)
			{
				LoadSpline(snapshot);
			}

			protected override void OnCurveChanged()
			{
			}

			protected override float GetMag()
			{
				return 5f;
			}

			private void AppendCurve(float mag, bool enforceNeighbour)
			{
				Vector3[] points = new Vector3[3];
				AlignWithEnding(points, base.CurveCount - 1, mag);
				AppendCurve(points, enforceNeighbour);
			}

			private void PrependCurve(float mag, int curveIndex, bool enforceNeighbour, bool shrinkPreceding)
			{
				Vector3[] points = new Vector3[3];
				if (!shrinkPreceding)
				{
					AlignWithBeginning(points, curveIndex, mag);
				}
				PrependCurve(points, curveIndex, mag, enforceNeighbour, shrinkPreceding);
			}
		}
		public enum ControlPointMode
		{
			Free,
			Aligned,
			Mirrored
		}
		public enum ExtendAction
		{
			Append,
			Prepend,
			Insert
		}
		[Serializable]
		public struct Vector3Serialziable
		{
			public float X;

			public float Y;

			public float Z;

			public Vector3Serialziable(float x, float y, float z)
			{
				X = x;
				Y = y;
				Z = z;
			}

			public static implicit operator Vector3(Vector3Serialziable v)
			{
				return new Vector3(v.X, v.Y, v.Z);
			}

			public static implicit operator Vector3Serialziable(Vector3 v)
			{
				return new Vector3Serialziable(v.x, v.y, v.z);
			}
		}
		[Serializable]
		public struct SplineSnapshot
		{
			[SerializeField]
			private Vector3[] m_points;

			[SerializeField]
			private ControlPointSetting[] m_controlPointSettings;

			[SerializeField]
			private ControlPointMode[] m_modes;

			[SerializeField]
			private bool m_loop;

			public int CurveCount => (m_points.Length - 1) / 3;

			public Vector3[] Points => m_points;

			public ControlPointSetting[] ControlPointSettings => m_controlPointSettings;

			public ControlPointMode[] Modes => m_modes;

			public bool Loop => m_loop;

			public SplineSnapshot(Vector3[] points, ControlPointSetting[] settings, ControlPointMode[] modes, bool loop)
			{
				int num = (points.Length - 1) / 3;
				int num2 = (points.Length - 1) / 2;
				int num3 = num * 3 + 1;
				num++;
				if (num < 1)
				{
					throw new ArgumentException("too few points. at least 4 required");
				}
				m_points = points;
				if (num3 != m_points.Length)
				{
					Array.Resize(ref points, num3);
				}
				m_controlPointSettings = settings;
				if (num2 != m_controlPointSettings.Length)
				{
					Array.Resize(ref settings, num2);
				}
				m_modes = modes;
				if (num != m_modes.Length)
				{
					Array.Resize(ref m_modes, num);
				}
				m_loop = loop;
			}
		}
		public delegate void ControlPointChanged(int pointIndex);
		[Serializable]
		public struct Twist
		{
			public static readonly Twist Null;

			public float Data;

			public float T1;

			public float T2;

			public Twist(float data, float t1, float t2)
			{
				Data = data;
				T1 = t1;
				T2 = t2;
			}
		}
		[Serializable]
		public struct Thickness
		{
			public static readonly Thickness Null;

			public Vector3Serialziable Data;

			public float T1;

			public float T2;

			public Thickness(Vector3 data, float t1, float t2)
			{
				Data = data;
				T1 = t1;
				T2 = t2;
			}
		}
		[Serializable]
		public struct SplineBranch
		{
			public int SplineIndex;

			public bool Inbound;

			public SplineBranch(int splineIndex, bool inbound)
			{
				SplineIndex = splineIndex;
				Inbound = inbound;
			}
		}
		[Serializable]
		public struct ControlPointSetting
		{
			public Twist Twist;

			public Thickness Thickness;

			public SplineBranch[] Branches;

			public ControlPointSetting(Twist twist, Thickness thickness, SplineBranch[] connections)
			{
				Twist = twist;
				Thickness = thickness;
				Branches = connections;
			}

			public ControlPointSetting(Twist twist, Thickness thickness)
			{
				Twist = twist;
				Thickness = thickness;
				Branches = null;
			}
		}
		[ExecuteInEditMode]
		public class SplineBase : MonoBehaviour, IGL
		{
			private static readonly Color SplineColor = Color.green;

			private static float Smoothness = 5f;

			private static Material m_splineMaterial;

			private static SplineBase m_convergingSpline;

			private static SplineBase m_activeSpline;

			private static int m_activeControlPointIndex = -1;

			[SerializeField]
			[HideInInspector]
			private ControlPointMode[] m_modes;

			[SerializeField]
			[HideInInspector]
			private Vector3[] m_points;

			[SerializeField]
			[HideInInspector]
			private ControlPointSetting[] m_settings;

			[SerializeField]
			[HideInInspector]
			private bool m_loop;

			private bool m_isSelected;

			[SerializeField]
			[HideInInspector]
			private SplineBase m_prevSpline;

			[SerializeField]
			[HideInInspector]
			private int m_prevControlPointIndex;

			[SerializeField]
			[HideInInspector]
			private SplineBase m_nextSpline;

			[SerializeField]
			[HideInInspector]
			private int m_nextControlPointIndex;

			[SerializeField]
			[HideInInspector]
			private SplineBase[] m_branches;

			[SerializeField]
			[HideInInspector]
			private SplineBase m_parent;

			[SerializeField]
			[HideInInspector]
			private SplineBase[] m_children;

			private bool m_isApplicationQuit;

			public static SplineBase ActiveSpline
			{
				get
				{
					return m_activeSpline;
				}
				set
				{
					m_activeSpline = value;
				}
			}

			public static int ActiveControlPointIndex
			{
				get
				{
					return m_activeControlPointIndex;
				}
				set
				{
					m_activeControlPointIndex = value;
				}
			}

			public static SplineBase ConvergingSpline
			{
				get
				{
					return m_convergingSpline;
				}
				set
				{
					if (m_convergingSpline != value)
					{
						m_convergingSpline = value;
						if (SplineBase.ConvergingSplineChanged != null)
						{
							SplineBase.ConvergingSplineChanged(null, EventArgs.Empty);
						}
					}
				}
			}

			public static Material SplineMaterial => m_splineMaterial;

			public static bool SplineMaterialZTest
			{
				get
				{
					return OVPlayerPrefs.GetInt("Battehub.SplineEditor.SplineMaterialZTest") == 1;
				}
				set
				{
					if (SplineMaterial != null)
					{
						SetSplieMaterialZTest(value);
					}
					OVPlayerPrefs.SetInt("Battehub.SplineEditor.SplineMaterialZTest", value ? 1 : 0);
				}
			}

			public int NextControlPointIndex => m_nextControlPointIndex;

			public SplineBase NextSpline => m_nextSpline;

			public int PrevControlPointIndex => m_prevControlPointIndex;

			public SplineBase PrevSpline => m_prevSpline;

			public bool IsSelected => m_isSelected;

			public virtual bool Loop
			{
				get
				{
					return m_loop;
				}
				set
				{
					m_loop = value;
					if (m_loop)
					{
						Disconnect(0);
						Disconnect(ControlPointCount - 1);
						if (PrevSpline != null)
						{
							PrevSpline.Disconnect(this, isInbound: false);
						}
						if (NextSpline != null)
						{
							NextSpline.Disconnect(this, isInbound: true);
						}
						ControlPointSetting controlPointSetting = m_settings[m_settings.Length - 1];
						m_settings[0] = new ControlPointSetting(controlPointSetting.Twist, controlPointSetting.Thickness, m_settings[0].Branches);
						m_modes[m_modes.Length - 1] = m_modes[0];
						RaiseControlPointModeChanged(m_modes.Length - 1);
						_SetControlPointLocalUnchecked(m_points.Length - 1, m_points[0]);
					}
				}
			}

			public int CurveCount => (m_points.Length - 1) / 3;

			public int ControlPointCount => m_points.Length;

			public SplineBase Root
			{
				get
				{
					SplineBase splineBase = this;
					while (splineBase.Parent != null)
					{
						splineBase = splineBase.Parent;
					}
					return splineBase;
				}
			}

			public SplineBase Parent => m_parent;

			public SplineBase[] Children => m_children;

			public static event EventHandler ConvergingSplineChanged;

			public event ControlPointChanged ControlPointPositionChanged;

			public event ControlPointChanged ControlPointModeChanged;

			public event ControlPointChanged ControlPointConnectionChanged;

			public event ControlPointChanged ControlPointThicknessChanged;

			public event ControlPointChanged ControlPointTwistChanged;

			private static void SetSplieMaterialZTest(bool value)
			{
				if (value)
				{
					SplineMaterial.SetInt("_ZTest", 4);
				}
				else
				{
					SplineMaterial.SetInt("_ZTest", 8);
				}
			}

			private static void InitSplineMaterial()
			{
				m_splineMaterial = new Material(Shader.Find("Battlehub/SplineEditor/Spline"));
				m_splineMaterial.name = "SplineMaterial";
				m_splineMaterial.color = SplineColor;
				SetSplieMaterialZTest(SplineMaterialZTest);
				if (UnityEngine.Object.FindObjectOfType<GLRenderer>() == null)
				{
					GameObject obj = new GameObject();
					obj.name = "GLRenderer";
					obj.AddComponent<GLRenderer>();
				}
			}

			void IGL.Draw()
			{
				if (m_points.Length < 2)
				{
					return;
				}
				if (m_splineMaterial == null)
				{
					InitSplineMaterial();
				}
				m_splineMaterial.SetPass(0);
				GL.PushMatrix();
				GL.MultMatrix(base.transform.localToWorldMatrix);
				GL.Begin(1);
				Vector3 v = m_points[0];
				for (int i = 1; i < m_points.Length; i += 3)
				{
					Vector3 v2 = m_points[i];
					Vector3 v3 = m_points[i + 1];
					Vector3 vector = m_points[i + 2];
					if (!ConvergingSpline)
					{
						GL.Color(SplineRuntimeEditor.ControlPointLineColor);
						GL.Vertex(v);
						GL.Vertex(v2);
						GL.Color(SplineRuntimeEditor.ControlPointLineColor);
						GL.Vertex(v3);
						GL.Vertex(vector);
					}
					v = vector;
				}
				GL.End();
				GL.Begin(1);
				GL.Color(SplineColor);
				v = m_points[0];
				for (int j = 1; j < m_points.Length; j += 3)
				{
					Vector3 vector2 = m_points[j];
					Vector3 vector3 = m_points[j + 1];
					Vector3 vector4 = m_points[j + 2];
					float num = (v - vector2).magnitude + (vector2 - vector3).magnitude + (vector3 - vector4).magnitude;
					int num2 = Mathf.CeilToInt(Smoothness * num);
					if (num2 <= 0)
					{
						num2 = 1;
					}
					for (int k = 0; k < num2; k++)
					{
						float t = (float)k / (float)num2;
						GL.Vertex(CurveUtils.GetPoint(v, vector2, vector3, vector4, t));
						t = ((float)k + 1f) / (float)num2;
						GL.Vertex(CurveUtils.GetPoint(v, vector2, vector3, vector4, t));
					}
					v = vector4;
				}
				ShowTwistAngles();
				GL.End();
				GL.PopMatrix();
			}

			protected virtual void ShowTwistAngles()
			{
				GL.Color(SplineRuntimeEditor.ControlPointLineColor);
				int num = GetStepsPerCurve() * CurveCount;
				for (int i = 0; i <= num; i++)
				{
					DrawTwistAngle(i, num);
				}
				if (m_activeSpline == this && m_activeControlPointIndex > -1 && m_activeControlPointIndex < m_activeSpline.ControlPointCount)
				{
					GL.Color(SplineColor);
					int val = (m_activeControlPointIndex + 1) / 3;
					val = Math.Min(val, CurveCount - 1);
					num = GetStepsPerCurve() * 5;
					Twist twist = GetTwist(m_activeControlPointIndex);
					int num2 = Mathf.CeilToInt(twist.T1 * (float)num);
					int num3 = Mathf.CeilToInt(twist.T2 * (float)num);
					for (int j = num2; j <= num3; j++)
					{
						DrawTwistAngle(val, j, num);
					}
				}
			}

			private void DrawTwistAngle(int i, int steps)
			{
				float t = (float)i / (float)steps;
				Vector3 direction = GetDirection(t);
				Vector3 pointLocal = GetPointLocal(t);
				float twist = GetTwist(t);
				Vector3 upVector = GetUpVector();
				Vector3 forward = ((!(Math.Abs(Vector3.Dot(direction, upVector)) < 1f)) ? Vector3.Cross(direction, GetSideVector()).normalized : Vector3.Cross(direction, upVector).normalized);
				if (!(direction == Vector3.zero))
				{
					GL.Vertex(pointLocal);
					GL.Vertex(pointLocal + Quaternion.AngleAxis(twist, direction) * Quaternion.LookRotation(forward, upVector) * Vector3.forward * 0.5f);
				}
			}

			private void DrawTwistAngle(int curveIndex, int i, int steps)
			{
				float t = (float)i / (float)steps;
				Vector3 direction = GetDirection(t, curveIndex);
				Vector3 pointLocal = GetPointLocal(t, curveIndex);
				float twist = GetTwist(t, curveIndex);
				Vector3 upVector = GetUpVector();
				Vector3 forward = ((!(Math.Abs(Vector3.Dot(direction, upVector)) < 1f)) ? Vector3.Cross(direction, GetSideVector()).normalized : Vector3.Cross(direction, upVector).normalized);
				if (!(direction == Vector3.zero))
				{
					GL.Vertex(pointLocal);
					GL.Vertex(pointLocal + Quaternion.AngleAxis(twist, direction) * Quaternion.LookRotation(forward, upVector) * Vector3.forward * 0.5f);
				}
			}

			protected virtual int GetStepsPerCurve()
			{
				return 5;
			}

			protected virtual Vector3 GetUpVector()
			{
				return Vector3.up;
			}

			protected virtual Vector3 GetSideVector()
			{
				return Vector3.forward;
			}

			private void RaiseControlPointThicknessChanged(int index)
			{
				if (this.ControlPointThicknessChanged != null)
				{
					this.ControlPointThicknessChanged(index);
				}
			}

			private void RaisControlPointTwistChanged(int index)
			{
				if (this.ControlPointTwistChanged != null)
				{
					this.ControlPointTwistChanged(index);
				}
			}

			private void RaiseControlPointChanged(int index)
			{
				if (this.ControlPointPositionChanged != null)
				{
					this.ControlPointPositionChanged(index);
				}
			}

			private void RaiseControlPointModeChanged(int modeIndex)
			{
				if (this.ControlPointModeChanged != null)
				{
					int num = modeIndex * 3 - 1;
					this.ControlPointModeChanged(num);
					this.ControlPointModeChanged(num + 1);
					this.ControlPointModeChanged(num + 2);
				}
			}

			private void RaiseControlPointConnectionChanged(int index)
			{
				if (this.ControlPointConnectionChanged != null)
				{
					this.ControlPointConnectionChanged(index);
				}
			}

			private void Awake()
			{
				if (m_splineMaterial == null)
				{
					InitSplineMaterial();
				}
				if (m_branches == null)
				{
					m_branches = new SplineBase[0];
				}
				UpdateChildrenAndParent();
				SplineRuntimeEditor.Created += OnRuntimeEditorCreated;
				SplineRuntimeEditor.Destroyed += OnRuntimeEditorDestroyed;
				if (SplineRuntimeEditor.Instance != null && !GetComponent<ExposeToEditor>())
				{
					base.gameObject.AddComponent<ExposeToEditor>();
				}
				SyncArrays();
				AwakeOverride();
			}

			private void OnApplicationQuit()
			{
				m_isApplicationQuit = true;
			}

			private void OnDestroy()
			{
				SplineRuntimeEditor.Created -= OnRuntimeEditorCreated;
				SplineRuntimeEditor.Destroyed -= OnRuntimeEditorDestroyed;
				bool flag = false;
				if (!m_isApplicationQuit && !flag)
				{
					UnselectRecursive(Root);
					if (m_prevSpline != null)
					{
						m_prevSpline.Disconnect(this);
					}
					if (m_nextSpline != null)
					{
						m_nextSpline.Disconnect(this);
					}
				}
				OnDestroyOverride();
			}

			private void OnEnable()
			{
				if (m_isSelected && GLRenderer.Instance != null)
				{
					GLRenderer.Instance.Add(this);
				}
				OnEnableOverride();
			}

			private void OnDisable()
			{
				if (GLRenderer.Instance != null)
				{
					GLRenderer.Instance.Remove(this);
				}
				OnDisableOverride();
			}

			private void Start()
			{
				StartOverride();
				if (PrevSpline != null && (PrevSpline.m_branches == null || !PrevSpline.m_branches.Contains(this)))
				{
					PrevSpline.Connect(this, PrevControlPointIndex, isInbound: false);
				}
				if (NextSpline != null && (NextSpline.m_branches == null || !NextSpline.m_branches.Contains(this)))
				{
					NextSpline.Connect(this, NextControlPointIndex, isInbound: true);
				}
			}

			private void OnTransformChildrenChanged()
			{
				UpdateChildrenAndParent();
			}

			private void OnTransformParentChanged()
			{
				UpdateChildrenAndParent();
			}

			private void Update()
			{
				UpdateOverride();
			}

			private void Reset()
			{
				SplineBase[] branches = m_branches;
				SplineBase nextSpline = m_nextSpline;
				SplineBase prevSpline = m_prevSpline;
				if (branches != null)
				{
					foreach (SplineBase splineBase in branches)
					{
						if (splineBase != null)
						{
							splineBase.Disconnect(this);
						}
					}
				}
				if (nextSpline != null)
				{
					nextSpline.Disconnect(this);
				}
				if (prevSpline != null)
				{
					prevSpline.Disconnect(this);
				}
				m_branches = new SplineBase[0];
				m_nextSpline = null;
				m_nextControlPointIndex = -1;
				m_prevSpline = null;
				m_prevControlPointIndex = -1;
				m_points = new Vector3[4]
				{
					new Vector3(0f, 0f, 0f),
					new Vector3(1f / 3f * GetMag(), 0f, 0f),
					new Vector3(2f / 3f * GetMag(), 0f, 0f),
					new Vector3(1f * GetMag(), 0f, 0f)
				};
				m_settings = new ControlPointSetting[2]
				{
					new ControlPointSetting(new Twist(0f, 0f, 1f), new Thickness(Vector3.one, 0f, 1f), new SplineBranch[0]),
					new ControlPointSetting(new Twist(0f, 0f, 1f), new Thickness(Vector3.one, 0f, 1f), new SplineBranch[0])
				};
				m_modes = new ControlPointMode[2];
				ResetOverride();
				SyncCtrlPoints();
			}

			protected virtual float GetMag()
			{
				return 1f;
			}

			protected virtual void AwakeOverride()
			{
			}

			protected virtual void OnDestroyOverride()
			{
			}

			protected virtual void OnEnableOverride()
			{
			}

			protected virtual void OnDisableOverride()
			{
			}

			protected virtual void StartOverride()
			{
			}

			protected virtual void UpdateOverride()
			{
			}

			protected virtual void ResetOverride()
			{
			}

			private void OnRuntimeEditorCreated(object sender, EventArgs e)
			{
				if (m_isSelected && GLRenderer.Instance != null)
				{
					GLRenderer.Instance.Add(this);
				}
				if ((bool)this && !GetComponent<ExposeToEditor>())
				{
					base.gameObject.AddComponent<ExposeToEditor>();
				}
			}

			private void OnRuntimeEditorDestroyed(object sender, EventArgs e)
			{
				if (GLRenderer.Instance != null)
				{
					GLRenderer.Instance.Remove(this);
				}
				if ((bool)this)
				{
					ExposeToEditor component = GetComponent<ExposeToEditor>();
					if ((bool)component)
					{
						UnityEngine.Object.DestroyImmediate(component);
					}
				}
			}

			private void SyncArrays()
			{
				if (m_points == null || m_points.Length == 0)
				{
					return;
				}
				int num = m_points.Length / 3 + 1;
				if (m_modes.Length != num)
				{
					UnityEngine.Debug.Log("Synchronize modes");
					Array.Resize(ref m_modes, num);
				}
				if (m_settings == null)
				{
					m_settings = new ControlPointSetting[0];
				}
				if (m_settings.Length != num)
				{
					UnityEngine.Debug.Log("Synchronize settings");
					int num2 = m_settings.Length;
					Array.Resize(ref m_settings, num);
					for (int i = num2; i < m_settings.Length; i++)
					{
						m_settings[i].Thickness = new Thickness(Vector3.one, 0f, 1f);
						m_settings[i].Twist = new Twist(0f, 0f, 1f);
					}
				}
			}

			public void Select()
			{
				if (!m_isSelected)
				{
					SelectRecursive(Root);
				}
			}

			private void SelectRecursive(SplineBase spline)
			{
				if (GLRenderer.Instance != null)
				{
					GLRenderer.Instance.Add(spline);
				}
				SplineControlPoint[] splineControlPoints = spline.GetSplineControlPoints();
				for (int i = 0; i < splineControlPoints.Length; i++)
				{
					splineControlPoints[i].gameObject.SetActive(value: true);
				}
				spline.m_isSelected = true;
				for (int j = 0; j < spline.m_children.Length; j++)
				{
					SelectRecursive(spline.m_children[j]);
				}
			}

			public void Unselect()
			{
				if (m_isSelected)
				{
					UnselectRecursive(Root);
				}
			}

			private void UnselectRecursive(SplineBase spline)
			{
				if (GLRenderer.Instance != null)
				{
					GLRenderer.Instance.Remove(spline);
				}
				SplineControlPoint[] splineControlPoints = spline.GetSplineControlPoints();
				foreach (SplineControlPoint splineControlPoint in splineControlPoints)
				{
					if ((bool)splineControlPoint)
					{
						splineControlPoint.gameObject.SetActive(value: false);
					}
				}
				spline.m_isSelected = false;
				for (int j = 0; j < spline.m_children.Length; j++)
				{
					UnselectRecursive(spline.m_children[j]);
				}
			}

			public Vector3 GetPoint(float t, int curveIndex)
			{
				curveIndex *= 3;
				return base.transform.TransformPoint(CurveUtils.GetPoint(m_points[curveIndex], m_points[curveIndex + 1], m_points[curveIndex + 2], m_points[curveIndex + 3], t));
			}

			public Vector3 GetPointLocal(float t, int curveIndex)
			{
				curveIndex *= 3;
				return CurveUtils.GetPoint(m_points[curveIndex], m_points[curveIndex + 1], m_points[curveIndex + 2], m_points[curveIndex + 3], t);
			}

			public int ToCurveIndex(ref float t)
			{
				int num;
				if (t >= 1f)
				{
					t = 1f;
					num = (m_points.Length - 1) / 3 - 1;
				}
				else
				{
					t = Mathf.Clamp01(t) * (float)CurveCount;
					num = (int)t;
					t -= num;
				}
				return num;
			}

			public int ToCurveIndex(float t)
			{
				int num;
				if (t >= 1f)
				{
					t = 1f;
					num = (m_points.Length - 1) / 3 - 1;
				}
				else
				{
					t = Mathf.Clamp01(t) * (float)CurveCount;
					num = (int)t;
					t -= (float)num;
				}
				return num;
			}

			public Vector3 GetPoint(float t)
			{
				int curveIndex = ToCurveIndex(ref t);
				return GetPoint(t, curveIndex);
			}

			public Vector3 GetPointLocal(float t)
			{
				int curveIndex = ToCurveIndex(ref t);
				return GetPointLocal(t, curveIndex);
			}

			public float GetTwist(float t, int curveIndex)
			{
				Twist twist = m_settings[curveIndex].Twist;
				Twist twist2 = m_settings[curveIndex + 1].Twist;
				float num = Mathf.Clamp01(twist.T1);
				float num2 = Mathf.Clamp01(twist.T2);
				t = ((t <= num) ? 0f : ((!(t >= num2)) ? Mathf.Clamp01((t - num) / (num2 - num)) : 1f));
				return Mathf.Lerp(twist.Data, twist2.Data, t);
			}

			public float GetTwist(float t)
			{
				int curveIndex = ToCurveIndex(ref t);
				return GetTwist(t, curveIndex);
			}

			public Vector3 GetThickness(float t, int curveIndex)
			{
				Thickness thickness = m_settings[curveIndex].Thickness;
				Thickness thickness2 = m_settings[curveIndex + 1].Thickness;
				float num = Mathf.Clamp01(thickness.T1);
				float num2 = Mathf.Clamp01(thickness.T2);
				t = ((t <= num) ? 0f : ((!(t >= num2)) ? Mathf.Clamp01((t - num) / (num2 - num)) : 1f));
				return Vector3.Lerp(thickness.Data, thickness2.Data, t);
			}

			public Vector3 GetThickness(float t)
			{
				int curveIndex = ToCurveIndex(ref t);
				return GetThickness(t, curveIndex);
			}

			public Vector3 GetControlPoint(int index)
			{
				return base.transform.TransformPoint(m_points[index]);
			}

			public Vector3 GetControlPointLocal(int index)
			{
				return m_points[index];
			}

			public ControlPointSetting GetSetting(int index)
			{
				return m_settings[(index + 1) / 3];
			}

			public SplineBranch[] GetBranches(int index)
			{
				return m_settings[(index + 1) / 3].Branches;
			}

			public bool HasBranches(int index)
			{
				int num = (index + 1) / 3;
				if (num >= m_settings.Length || num < 0)
				{
					return false;
				}
				ControlPointSetting controlPointSetting = m_settings[num];
				if (controlPointSetting.Branches == null)
				{
					return false;
				}
				return controlPointSetting.Branches.Length != 0;
			}

			public SplineBase BranchToSpline(SplineBranch branch)
			{
				return m_branches[branch.SplineIndex];
			}

			public Twist GetTwist(int index)
			{
				return m_settings[(index + 1) / 3].Twist;
			}

			public Thickness GetThickness(int index)
			{
				return m_settings[(index + 1) / 3].Thickness;
			}

			public void SetTwist(int index, Twist twist)
			{
				SetValue(index, twist, delegate(int i, Twist val, bool r)
				{
					int num2 = (index + 1) / 3;
					m_settings[num2].Twist = val;
				}, delegate(int i, Twist val, SplineBase branch, bool r)
				{
					branch.SetTwist(i, val);
				}, GetTwist);
				if (m_loop)
				{
					int num = (index + 1) / 3;
					if (num == m_settings.Length - 1)
					{
						ControlPointSetting controlPointSetting = m_settings[m_settings.Length - 1];
						m_settings[0] = new ControlPointSetting(controlPointSetting.Twist, controlPointSetting.Thickness, m_settings[0].Branches);
					}
					else if (num == 0)
					{
						ControlPointSetting controlPointSetting2 = m_settings[0];
						m_settings[m_settings.Length - 1] = new ControlPointSetting(controlPointSetting2.Twist, controlPointSetting2.Thickness, m_settings[m_settings.Length - 1].Branches);
					}
				}
				RaisControlPointTwistChanged(index);
				OnCurveChanged(index, Math.Max(0, (index - 1) / 3));
			}

			public void SetThickness(int index, Thickness thickness)
			{
				SetValue(index, thickness, delegate(int i, Thickness val, bool r)
				{
					int num2 = (index + 1) / 3;
					m_settings[num2].Thickness = val;
				}, delegate(int i, Thickness val, SplineBase branch, bool r)
				{
					branch.SetThickness(i, val);
				}, GetThickness);
				if (m_loop)
				{
					int num = (index + 1) / 3;
					if (num == m_settings.Length - 1)
					{
						ControlPointSetting controlPointSetting = m_settings[m_settings.Length - 1];
						m_settings[0] = new ControlPointSetting(controlPointSetting.Twist, controlPointSetting.Thickness, m_settings[0].Branches);
					}
					else if (num == 0)
					{
						ControlPointSetting controlPointSetting2 = m_settings[0];
						m_settings[m_settings.Length - 1] = new ControlPointSetting(controlPointSetting2.Twist, controlPointSetting2.Thickness, m_settings[m_settings.Length - 1].Branches);
					}
				}
				RaiseControlPointThicknessChanged(index);
				OnCurveChanged(index, Math.Max(0, (index - 1) / 3));
			}

			public bool SetControlPoint(int index, Vector3 point)
			{
				return SetControlPointLocal(index, base.transform.InverseTransformPoint(point));
			}

			private bool _SetControlPointUnchecked(int index, Vector3 point)
			{
				return _SetControlPointLocalUnchecked(index, base.transform.InverseTransformPoint(point));
			}

			public bool SetControlPointLocal(int index, Vector3 point)
			{
				if (IsControlPointLocked(index))
				{
					return false;
				}
				return _SetControlPointLocalUnchecked(index, point);
			}

			private bool _SetControlPointLocalUnchecked(int index, Vector3 point)
			{
				if (index % 3 == 0)
				{
					Vector3 delta = point - m_points[index];
					if (m_loop)
					{
						if (index == 0)
						{
							JustChangeControlPointValue(1, delta);
							RaiseControlPointChanged(1);
							JustChangeControlPointValue(m_points.Length - 2, delta);
							RaiseControlPointChanged(m_points.Length - 2);
							SetControlPointValue(m_points.Length - 1, point);
							RaiseControlPointChanged(m_points.Length - 1);
						}
						else if (index == m_points.Length - 1)
						{
							SetControlPointValue(0, point);
							RaiseControlPointChanged(0);
							JustChangeControlPointValue(1, delta);
							RaiseControlPointChanged(1);
							JustChangeControlPointValue(index - 1, delta);
							RaiseControlPointChanged(index - 1);
						}
						else
						{
							JustChangeControlPointValue(index - 1, delta);
							RaiseControlPointChanged(index - 1);
							JustChangeControlPointValue(index + 1, delta);
							RaiseControlPointChanged(index + 1);
						}
					}
					else
					{
						if (index > 0)
						{
							JustChangeControlPointValue(index - 1, delta);
							RaiseControlPointChanged(index - 1);
						}
						if (index + 1 < m_points.Length)
						{
							JustChangeControlPointValue(index + 1, delta);
							RaiseControlPointChanged(index + 1);
						}
					}
				}
				SetControlPointValue(index, point);
				RaiseControlPointChanged(index);
				EnforceMode(index);
				OnCurveChanged(index, Math.Max(0, (index - 1) / 3));
				return true;
			}

			public ControlPointMode GetControlPointMode(int index)
			{
				return m_modes[(index + 1) / 3];
			}

			public void SetControlPointMode(ControlPointMode mode)
			{
				SetControlPointModeRecursive(this, mode);
			}

			private void SetControlPointModeRecursive(SplineBase spline, ControlPointMode mode)
			{
				for (int i = 0; i <= spline.CurveCount; i++)
				{
					spline.SetControlPointMode(i * 3, mode);
				}
				if (spline.Children != null)
				{
					for (int j = 0; j < spline.Children.Length; j++)
					{
						SetControlPointModeRecursive(spline.Children[j], mode);
					}
				}
			}

			public void SetControlPointMode(int index, ControlPointMode mode, bool raiseCurveChanged = true)
			{
				SetControlPointModeValue(index, mode, raiseCurveChanged);
				int num = (index + 1) / 3;
				RaiseControlPointModeChanged(num);
				if (m_loop)
				{
					if (num == 0)
					{
						SetControlPointModeValue(ControlPointCount - 1, mode, raiseCurveChanged);
						RaiseControlPointModeChanged(m_modes.Length - 1);
					}
					else if (num == m_modes.Length - 1)
					{
						SetControlPointModeValue(0, mode, raiseCurveChanged);
						RaiseControlPointModeChanged(0);
					}
				}
				EnforceMode(index);
				if (raiseCurveChanged)
				{
					OnCurveChanged(index, Math.Max(0, (index - 1) / 3));
				}
			}

			private void SetControlPointModeValue(int index, ControlPointMode mode, bool raiseCurveChanged)
			{
				int num = (index + 1) / 3;
				if (m_modes[num] != mode)
				{
					m_modes[num] = mode;
					SetBranchControlPointModes(index, mode, raiseCurveChanged);
				}
			}

			private void SetBranchControlPointModes(int index, ControlPointMode mode, bool raiseCurveChanged)
			{
				int num = (index + 1) / 3;
				SplineBranch[] branches = m_settings[num].Branches;
				if (branches != null)
				{
					for (int i = 0; i < branches.Length; i++)
					{
						SplineBranch splineBranch = branches[i];
						SplineBase splineBase = m_branches[splineBranch.SplineIndex];
						if (splineBase != null)
						{
							if (splineBranch.Inbound)
							{
								splineBase.SetControlPointMode(splineBase.ControlPointCount - 1, mode, raiseCurveChanged);
							}
							else
							{
								splineBase.SetControlPointMode(0, mode, raiseCurveChanged);
							}
						}
					}
				}
				if (num == 0 && PrevSpline != null)
				{
					PrevSpline.SetControlPointMode(PrevControlPointIndex, mode, raiseCurveChanged);
				}
				if (num == m_settings.Length - 1 && NextSpline != null)
				{
					NextSpline.SetControlPointMode(NextControlPointIndex, mode, raiseCurveChanged);
				}
			}

			public Vector3 GetVelocity(float t, int curveIndex)
			{
				int num = curveIndex * 3;
				return base.transform.TransformVector(CurveUtils.GetFirstDerivative(m_points[num], m_points[num + 1], m_points[num + 2], m_points[num + 3], t));
			}

			public Vector3 GetVelocity(float t)
			{
				int num;
				if (t >= 1f)
				{
					t = 1f;
					num = (m_points.Length - 1) / 3 - 1;
				}
				else
				{
					t = Mathf.Clamp01(t) * (float)CurveCount;
					num = (int)t;
					t -= (float)num;
				}
				return GetVelocity(t, num);
			}

			public Vector3 GetDirection(float t, int curveIndex)
			{
				return GetVelocity(t, curveIndex).normalized;
			}

			public Vector3 GetDirection(float t)
			{
				return GetVelocity(t).normalized;
			}

			public virtual SplineControlPoint[] GetSplineControlPoints()
			{
				List<SplineControlPoint> list = new List<SplineControlPoint>(base.transform.childCount);
				foreach (Transform item in base.transform)
				{
					SplineControlPoint component = item.GetComponent<SplineControlPoint>();
					if (component != null)
					{
						list.Add(component);
					}
				}
				return list.ToArray();
			}

			public void AlignWithNextSpline()
			{
				if (!(NextSpline == null))
				{
					if (m_nextControlPointIndex == 0)
					{
						NextSpline.AlignWithBeginning(m_points, (m_nextControlPointIndex - 1) / 3, GetMag());
					}
					else
					{
						NextSpline.AlignWithBeginning(m_points, (m_nextControlPointIndex - 1) / 3, GetMag(), 1f);
					}
					for (int i = 0; i < m_points.Length; i++)
					{
						m_points[i] = base.transform.InverseTransformPoint(NextSpline.transform.TransformPoint(m_points[i]));
					}
					EnforceMode(ControlPointCount - 1);
				}
			}

			public void AlignWithPrevSpline()
			{
				if (!(PrevSpline == null))
				{
					if (m_prevControlPointIndex == 0)
					{
						PrevSpline.AlignWithEnding(m_points, (m_prevControlPointIndex - 1) / 3, GetMag(), 0f);
					}
					else
					{
						PrevSpline.AlignWithEnding(m_points, (m_prevControlPointIndex - 1) / 3, GetMag());
					}
					for (int i = 0; i < m_points.Length; i++)
					{
						m_points[i] = base.transform.InverseTransformPoint(PrevSpline.transform.TransformPoint(m_points[i]));
					}
					EnforceMode(0);
				}
			}

			public bool IsControlPointLocked(int index)
			{
				if (index >= 2 && index <= ControlPointCount - 3)
				{
					return false;
				}
				if (index % 3 != 0 && GetControlPointMode(index) == ControlPointMode.Free)
				{
					return false;
				}
				if (PrevSpline != null)
				{
					if (PrevControlPointIndex == PrevSpline.ControlPointCount - 1)
					{
						SplineBranch[] branches = PrevSpline.GetBranches(PrevControlPointIndex);
						SplineBase splineBase = null;
						for (int i = 0; i < branches.Length; i++)
						{
							if (!branches[i].Inbound)
							{
								splineBase = PrevSpline.BranchToSpline(branches[i]);
							}
						}
						if (splineBase == this)
						{
							if (index < 1)
							{
								return true;
							}
							if (Loop && index > ControlPointCount - 2)
							{
								return true;
							}
						}
						else
						{
							if (index < 2)
							{
								return true;
							}
							if (Loop && index > ControlPointCount - 3)
							{
								return true;
							}
						}
					}
					else
					{
						if (index < 2)
						{
							return true;
						}
						if (Loop && index > ControlPointCount - 3)
						{
							return true;
						}
					}
				}
				if (NextSpline != null)
				{
					if (NextControlPointIndex == 0)
					{
						SplineBranch[] branches2 = NextSpline.GetBranches(NextControlPointIndex);
						SplineBase splineBase2 = null;
						for (int j = 0; j < branches2.Length; j++)
						{
							if (branches2[j].Inbound)
							{
								splineBase2 = NextSpline.BranchToSpline(branches2[j]);
							}
						}
						if (splineBase2 == this)
						{
							if (index > ControlPointCount - 2)
							{
								return true;
							}
							if (Loop && index < 1)
							{
								return true;
							}
						}
						else
						{
							if (index > ControlPointCount - 3)
							{
								return true;
							}
							if (Loop && index < 2)
							{
								return true;
							}
						}
					}
					else
					{
						if (index > ControlPointCount - 3)
						{
							return true;
						}
						if (Loop && index < 2)
						{
							return true;
						}
					}
				}
				return false;
			}

			public void SetBranch(SplineBase branch, int connectionPointIndex, bool isInbound)
			{
				if (branch == this)
				{
					throw new InvalidOperationException("branch == this");
				}
				if (branch.Loop)
				{
					throw new InvalidOperationException("Unable to connect branch. Branch has loop");
				}
				SplineBranch[] branches = GetBranches(connectionPointIndex);
				SplineBranch[] branches2 = branch.GetBranches(isInbound ? (branch.ControlPointCount - 1) : 0);
				if (branches != null && branches2 != null)
				{
					for (int i = 0; i < branches.Length; i++)
					{
						SplineBase splineBase = m_branches[branches[i].SplineIndex];
						for (int j = 0; j < branches2.Length; j++)
						{
							if (branch.m_branches[branches2[j].SplineIndex] == splineBase)
							{
								UnityEngine.Debug.LogError("Unable to connect branch. Connection will lead to illegal structure");
								return;
							}
						}
					}
				}
				connectionPointIndex = (connectionPointIndex + 1) / 3 * 3;
				Vector3 controlPoint = GetControlPoint(connectionPointIndex);
				branch.transform.SetParent(base.transform, worldPositionStays: true);
				Vector3 vector = branch.transform.InverseTransformPoint(controlPoint);
				Thickness thickness = GetThickness(connectionPointIndex);
				thickness.T1 = 0f;
				thickness.T2 = 1f;
				Twist twist = GetTwist(connectionPointIndex);
				twist.T1 = 0f;
				twist.T2 = 1f;
				if (isInbound)
				{
					branch.SetThickness(branch.ControlPointCount - 1, thickness);
					branch.SetTwist(branch.ControlPointCount - 1, twist);
					branch.SetControlPointValue(branch.ControlPointCount - 1, vector);
					branch.RaiseControlPointChanged(branch.ControlPointCount - 1);
					ControlPointMode controlPointMode = GetControlPointMode(connectionPointIndex);
					if (controlPointMode == ControlPointMode.Free || (connectionPointIndex == 0 && controlPointMode != ControlPointMode.Mirrored))
					{
						Vector3 delta = vector - branch.GetControlPointLocal(branch.ControlPointCount - 1);
						branch.ChangeControlPointValue(branch.ControlPointCount - 2, delta);
						branch.RaiseControlPointChanged(branch.ControlPointCount - 2);
					}
					else if (controlPointMode == ControlPointMode.Aligned)
					{
						branch.SetControlPointValue(branch.ControlPointCount - 2, branch.transform.InverseTransformPoint(GetControlPoint(connectionPointIndex - 1)));
						branch.RaiseControlPointChanged(branch.ControlPointCount - 2);
					}
				}
				else
				{
					branch.SetThickness(0, thickness);
					branch.SetTwist(0, twist);
					branch.SetControlPointValue(0, vector);
					branch.RaiseControlPointChanged(0);
					ControlPointMode controlPointMode2 = GetControlPointMode(connectionPointIndex);
					if (controlPointMode2 == ControlPointMode.Free || (connectionPointIndex == ControlPointCount - 1 && controlPointMode2 != ControlPointMode.Mirrored))
					{
						Vector3 delta2 = vector - branch.GetControlPointLocal(0);
						branch.ChangeControlPointValue(1, delta2);
						branch.RaiseControlPointChanged(1);
					}
					else if (controlPointMode2 == ControlPointMode.Aligned)
					{
						branch.SetControlPointValue(1, branch.transform.InverseTransformPoint(GetControlPoint(connectionPointIndex + 1)));
						branch.RaiseControlPointChanged(1);
					}
				}
				Reconnect(branch, connectionPointIndex, isInbound);
				if (isInbound)
				{
					branch.SetControlPointMode(branch.ControlPointCount - 1, GetControlPointMode(connectionPointIndex));
				}
				else
				{
					branch.SetControlPointMode(0, GetControlPointMode(connectionPointIndex));
				}
				if (m_isSelected)
				{
					branch.Select();
				}
			}

			private void Reconnect(SplineBase branch, int connectionPointIndex, bool isInbound)
			{
				if (isInbound)
				{
					if (branch.m_nextSpline != null)
					{
						branch.m_nextSpline.Disconnect(branch, isInbound);
					}
					branch.m_nextSpline = this;
					branch.m_nextControlPointIndex = connectionPointIndex;
				}
				else
				{
					if (branch.m_prevSpline != null)
					{
						branch.m_prevSpline.Disconnect(branch, isInbound);
					}
					branch.m_prevSpline = this;
					branch.m_prevControlPointIndex = connectionPointIndex;
				}
				Connect(branch, connectionPointIndex, isInbound);
				EnforceBranchModes(connectionPointIndex);
			}

			private void Connect(SplineBase branch, int connectionPointIndex, bool isInbound)
			{
				int num = Array.IndexOf(m_branches, branch);
				if (num < 0)
				{
					Array.Resize(ref m_branches, m_branches.Length + 1);
					num = m_branches.Length - 1;
					m_branches[num] = branch;
				}
				int num2 = (connectionPointIndex + 1) / 3;
				ControlPointSetting controlPointSetting = m_settings[num2];
				if (controlPointSetting.Branches == null)
				{
					controlPointSetting.Branches = new SplineBranch[1];
				}
				else
				{
					Array.Resize(ref controlPointSetting.Branches, controlPointSetting.Branches.Length + 1);
				}
				controlPointSetting.Branches[controlPointSetting.Branches.Length - 1] = new SplineBranch(num, isInbound);
				m_settings[num2] = controlPointSetting;
				RaiseControlPointConnectionChanged(connectionPointIndex);
				if (isInbound)
				{
					branch.RaiseControlPointConnectionChanged(branch.ControlPointCount - 1);
					branch.RaiseControlPointConnectionChanged(branch.ControlPointCount - 2);
				}
				else
				{
					branch.RaiseControlPointConnectionChanged(0);
					branch.RaiseControlPointConnectionChanged(1);
				}
			}

			public void Disconnect(int index)
			{
				SplineBranch[] branches = GetBranches(index);
				if (branches != null && branches.Length != 0)
				{
					for (int num = branches.Length - 1; num >= 0; num--)
					{
						SplineBranch splineBranch = branches[num];
						SplineBase branch = m_branches[splineBranch.SplineIndex];
						Disconnect(branch, splineBranch.Inbound);
					}
				}
			}

			public void Disconnect(SplineBase spline)
			{
				Disconnect(spline, isInbound: true);
				Disconnect(spline, isInbound: false);
			}

			public void Disconnect(SplineBase branch, bool isInbound)
			{
				int num = Array.IndexOf(m_branches, branch);
				if (num < 0)
				{
					return;
				}
				int num2;
				if (isInbound)
				{
					num2 = (branch.m_nextControlPointIndex + 1) / 3;
					branch.m_nextSpline = null;
					branch.m_nextControlPointIndex = -1;
				}
				else
				{
					num2 = (branch.m_prevControlPointIndex + 1) / 3;
					branch.m_prevSpline = null;
					branch.m_prevControlPointIndex = -1;
				}
				if (num2 >= m_settings.Length)
				{
					return;
				}
				ControlPointSetting controlPointSetting = m_settings[num2];
				int num3 = -1;
				for (int i = 0; i < controlPointSetting.Branches.Length; i++)
				{
					SplineBranch splineBranch = controlPointSetting.Branches[i];
					if (splineBranch.SplineIndex == num && splineBranch.Inbound == isInbound)
					{
						num3 = i;
					}
				}
				if (num3 >= 0)
				{
					for (int j = num3; j < controlPointSetting.Branches.Length - 1; j++)
					{
						controlPointSetting.Branches[j] = controlPointSetting.Branches[j + 1];
					}
					Array.Resize(ref controlPointSetting.Branches, controlPointSetting.Branches.Length - 1);
					m_settings[num2] = controlPointSetting;
				}
				if (branch.m_nextSpline == null && branch.m_prevSpline == null)
				{
					for (int k = num; k < m_branches.Length - 1; k++)
					{
						m_branches[k] = m_branches[k + 1];
					}
					Array.Resize(ref m_branches, m_branches.Length - 1);
					CleanupSplineConnections(num);
				}
				RaiseControlPointConnectionChanged(num2 * 3);
				if (isInbound)
				{
					branch.RaiseControlPointConnectionChanged(branch.ControlPointCount - 1);
					branch.RaiseControlPointConnectionChanged(branch.ControlPointCount - 2);
				}
				else
				{
					branch.RaiseControlPointConnectionChanged(0);
					branch.RaiseControlPointConnectionChanged(1);
				}
			}

			private void UpdateChildrenAndParent()
			{
				if (base.transform.parent != null)
				{
					m_parent = base.transform.parent.GetComponentInParent<SplineBase>();
				}
				else
				{
					m_parent = null;
				}
				List<SplineBase> list = new List<SplineBase>();
				foreach (Transform item in base.transform)
				{
					SplineBase component = item.GetComponent<SplineBase>();
					if (component != null)
					{
						list.Add(component);
					}
				}
				m_children = list.ToArray();
			}

			private void ShiftConnectionIndices(int settingIndex, int offset)
			{
				for (int i = 0; i < m_branches.Length; i++)
				{
					SplineBase splineBase = m_branches[i];
					if (splineBase.PrevSpline == this && splineBase.m_prevControlPointIndex >= settingIndex * 3)
					{
						splineBase.m_prevControlPointIndex += offset;
					}
					if (splineBase.NextSpline == this && splineBase.m_nextControlPointIndex >= settingIndex * 3)
					{
						splineBase.m_nextControlPointIndex += offset;
					}
				}
			}

			private void CleanupSplineConnections(int splineIndex)
			{
				for (int i = 0; i < m_settings.Length; i++)
				{
					ControlPointSetting controlPointSetting = m_settings[i];
					if (controlPointSetting.Branches == null)
					{
						continue;
					}
					for (int j = 0; j < controlPointSetting.Branches.Length; j++)
					{
						SplineBranch splineBranch = controlPointSetting.Branches[j];
						if (splineBranch.SplineIndex == splineIndex)
						{
							throw new InvalidOperationException("connection.SplineIndex == splineIndex. SplineConnection with index " + splineIndex + " should be removed");
						}
						if (splineBranch.SplineIndex > splineIndex)
						{
							splineBranch.SplineIndex--;
							controlPointSetting.Branches[j] = splineBranch;
						}
					}
					m_settings[i] = controlPointSetting;
				}
			}

			public void Smooth()
			{
				Vector3 vector = m_points[0];
				ShiftPoints(-vector);
				int num = m_points.Length / 3;
				float[] array = new float[num];
				float[] array2 = new float[num];
				float[] array3 = new float[num];
				Vector3[] array4 = new Vector3[num];
				array[0] = 0f;
				array2[0] = 2f;
				array3[0] = 1f;
				array4[0] = m_points[0] + 2f * m_points[3];
				for (int i = 1; i < num - 1; i++)
				{
					array[i] = 1f;
					array2[i] = 4f;
					array3[i] = 1f;
					array4[i] = 4f * m_points[i * 3] + 2f * m_points[(i + 1) * 3];
				}
				array[num - 1] = 2f;
				array2[num - 1] = 7f;
				array3[num - 1] = 0f;
				array4[num - 1] = 8f * m_points[(num - 1) * 3] + m_points[num * 3];
				for (int j = 1; j < num; j++)
				{
					float num2 = array[j] / array2[j - 1];
					array2[j] -= num2 * array3[j - 1];
					array4[j] -= num2 * array4[j - 1];
				}
				m_points[(num - 1) * 3 + 1] = array4[num - 1] / array2[num - 1];
				for (int num3 = num - 2; num3 >= 0; num3--)
				{
					m_points[num3 * 3 + 1] = (array4[num3] - array3[num3] * m_points[(num3 + 1) * 3 + 1]) / array2[num3];
				}
				for (int k = 0; k < num - 1; k++)
				{
					m_points[k * 3 + 2] = 2f * m_points[(k + 1) * 3] - m_points[(k + 1) * 3 + 1];
				}
				m_points[(num - 1) * 3 + 2] = 0.5f * (m_points[num * 3] + m_points[(num - 1) * 3 + 1]);
				ShiftPoints(vector);
				if (Loop)
				{
					EnforceMode(m_points.Length - 2);
				}
				SyncCtrlPoints();
				OnCurveChanged();
				if (Children != null)
				{
					for (int l = 0; l < Children.Length; l++)
					{
						Children[l].Smooth();
					}
				}
				EnforceModeRecursive();
			}

			private void EnforceModeRecursive()
			{
				EnforceMode(1);
				if (Children != null)
				{
					for (int i = 0; i < Children.Length; i++)
					{
						Children[i].EnforceModeRecursive();
					}
				}
			}

			private void ShiftPoints(Vector3 offset)
			{
				for (int i = 0; i < m_points.Length; i++)
				{
					m_points[i] += offset;
				}
			}

			public float EvalDistance(int curveIndex)
			{
				Vector3 point = GetPoint(0f, curveIndex);
				return (GetPoint(1f, curveIndex) - point).magnitude;
			}

			public float EvalDistance()
			{
				Vector3 point = GetPoint(0f);
				return (GetPoint(1f) - point).magnitude;
			}

			public float EvalCurveLength(int curveIndex, int steps = 4)
			{
				if (steps < 1)
				{
					steps = 1;
				}
				float num = 0f;
				Vector3 vector = GetPoint(0f, curveIndex);
				for (int i = 1; i <= steps; i++)
				{
					float num2 = i;
					num2 /= 3f;
					Vector3 point = GetPoint(num2, curveIndex);
					num += (point - vector).magnitude;
					vector = point;
				}
				return num;
			}

			public float EvalSplineLength(int steps = 4)
			{
				if (steps < 1)
				{
					steps = 1;
				}
				float num = 0f;
				for (int i = 0; i < CurveCount; i++)
				{
					num += EvalCurveLength(i, steps);
				}
				return num;
			}

			public virtual SplineSnapshot Save()
			{
				return new SplineSnapshot(m_points, m_settings, m_modes, m_loop);
			}

			public virtual void Load(SplineSnapshot snapshot)
			{
				LoadSpline(snapshot);
			}

			protected void LoadSpline(SplineSnapshot settings)
			{
				m_points = settings.Points;
				m_settings = settings.ControlPointSettings;
				m_modes = settings.Modes;
				m_loop = settings.Loop;
				SyncCtrlPoints();
			}

			protected void SetPoints(int curveIndex, Vector3[] points, ControlPointMode mode, bool raiseCurveChanged)
			{
				int num = curveIndex * 3;
				for (int i = 0; i < points.Length; i++)
				{
					SetControlPointValue(num, points[i]);
					RaiseControlPointChanged(num);
					SetControlPointMode(num, mode, raiseCurveChanged);
					num++;
				}
				EnforceMode(num);
				if (raiseCurveChanged)
				{
					OnCurveChanged(num, Math.Max(0, (num - 1) / 3));
				}
			}

			private void JustChangeControlPointValue(int index, Vector3 delta)
			{
				m_points[index] += delta;
			}

			private void ChangeControlPointValue(int index, Vector3 delta)
			{
				SetControlPointValue(index, m_points[index] + delta);
			}

			private void JustSetControlPointValue(int index, Vector3 point)
			{
				m_points[index] = point;
			}

			private void SetControlPointValue(int index, Vector3 point)
			{
				if (!(m_points[index] == point))
				{
					m_points[index] = point;
					SetBranchControlPoints(index, point);
				}
			}

			private void SetBranchControlPoints(int index, Vector3 point)
			{
				int num = (index + 1) / 3;
				int num2 = num * 3;
				SplineBranch[] branches = m_settings[num].Branches;
				if (branches == null)
				{
					return;
				}
				for (int i = 0; i < branches.Length; i++)
				{
					SplineBranch splineBranch = branches[i];
					SplineBase splineBase = m_branches[splineBranch.SplineIndex];
					if (!(splineBase != null))
					{
						continue;
					}
					if (splineBranch.Inbound)
					{
						if ((splineBase.m_nextControlPointIndex + 1) / 3 == num)
						{
							if (index == num2)
							{
								splineBase._SetControlPointUnchecked(splineBase.ControlPointCount - 1, base.transform.TransformPoint(point));
							}
							else if (index == num2 - 1 && GetControlPointMode(index) != 0)
							{
								splineBase._SetControlPointUnchecked(splineBase.ControlPointCount - 2, base.transform.TransformPoint(point));
							}
						}
					}
					else if ((splineBase.m_prevControlPointIndex + 1) / 3 == num)
					{
						if (index == num2)
						{
							splineBase._SetControlPointUnchecked(0, base.transform.TransformPoint(point));
						}
						else if (index == num2 + 1 && GetControlPointMode(index) != 0)
						{
							splineBase._SetControlPointUnchecked(1, base.transform.TransformPoint(point));
						}
					}
				}
			}

			private void EnforceMode(int index)
			{
				int num = (index + 1) / 3;
				ControlPointMode controlPointMode = m_modes[num];
				bool flag = num == 0 || num == m_modes.Length - 1;
				if (controlPointMode == ControlPointMode.Free || (!m_loop && flag))
				{
					if (flag)
					{
						EnforceBranchModes(index);
					}
					return;
				}
				int num2 = num * 3;
				int num3;
				int num4;
				if (index <= num2)
				{
					num3 = num2 - 1;
					if (num3 < 0)
					{
						num3 = m_points.Length - 2;
					}
					num4 = num2 + 1;
					if (num4 >= m_points.Length)
					{
						num4 = 1;
					}
				}
				else
				{
					num3 = num2 + 1;
					if (num3 >= m_points.Length)
					{
						num3 = 1;
					}
					num4 = num2 - 1;
					if (num4 < 0)
					{
						num4 = m_points.Length - 2;
					}
				}
				Vector3 vector = m_points[num2];
				Vector3 vector2 = vector - m_points[num3];
				if (controlPointMode == ControlPointMode.Aligned)
				{
					vector2 = vector2.normalized * Vector3.Distance(vector, m_points[num4]);
				}
				SetControlPointValue(num4, vector + vector2);
				RaiseControlPointChanged(num4);
				if (flag)
				{
					EnforceBranchModes(index);
					EnforceBranchModes(num4);
				}
			}

			private void EnforceBranchModes(int index)
			{
				int num = (index + 1) / 3;
				ControlPointMode controlPointMode = m_modes[num];
				if (controlPointMode == ControlPointMode.Free)
				{
					return;
				}
				ControlPointSetting controlPointSetting = m_settings[num];
				if (controlPointSetting.Branches == null)
				{
					return;
				}
				int num2 = num * 3;
				for (int i = 0; i < controlPointSetting.Branches.Length; i++)
				{
					SplineBranch splineBranch = controlPointSetting.Branches[i];
					SplineBase splineBase = m_branches[splineBranch.SplineIndex];
					int fixedIndex;
					int enforcedIndex;
					if (splineBranch.Inbound)
					{
						fixedIndex = num2 + 1;
						enforcedIndex = splineBase.ControlPointCount - 2;
					}
					else
					{
						fixedIndex = num2 - 1;
						enforcedIndex = 1;
					}
					EnforceBranchMode(controlPointMode, num2, splineBase, fixedIndex, enforcedIndex);
				}
				if (num == 0)
				{
					if (PrevSpline != null)
					{
						EnforceBranchMode(controlPointMode, num2, PrevSpline, num2 + 1, m_prevControlPointIndex - 1);
					}
					else if (NextSpline != null && Loop)
					{
						int num3 = (m_modes.Length - 1) * 3;
						EnforceBranchMode(controlPointMode, num3, NextSpline, num3 - 1, m_nextControlPointIndex + 1);
					}
				}
				else if (num == m_modes.Length - 1)
				{
					if (NextSpline != null)
					{
						EnforceBranchMode(controlPointMode, num2, NextSpline, num2 - 1, m_nextControlPointIndex + 1);
					}
					else if (PrevSpline != null && Loop)
					{
						int num4 = 0;
						EnforceBranchMode(controlPointMode, num4, PrevSpline, num4 + 1, m_prevControlPointIndex - 1);
					}
				}
			}

			private void EnforceBranchMode(ControlPointMode mode, int middleIndex, SplineBase branch, int fixedIndex, int enforcedIndex)
			{
				if (fixedIndex < 0 || fixedIndex >= m_points.Length)
				{
					fixedIndex = ((fixedIndex < 0) ? 1 : (m_points.Length - 2));
					Vector3 vector = branch.transform.InverseTransformPoint(base.transform.TransformPoint(m_points[fixedIndex]));
					if (branch.m_points[enforcedIndex] != vector)
					{
						branch._SetControlPointLocalUnchecked(enforcedIndex, vector);
					}
					return;
				}
				if (enforcedIndex < 0 || enforcedIndex >= branch.m_points.Length)
				{
					enforcedIndex = ((enforcedIndex < 0) ? 1 : (branch.m_points.Length - 2));
					Vector3 vector2 = branch.transform.InverseTransformPoint(base.transform.TransformPoint(m_points[fixedIndex]));
					if (branch.m_points[enforcedIndex] != vector2)
					{
						branch._SetControlPointLocalUnchecked(enforcedIndex, vector2);
					}
					return;
				}
				Vector3 vector3 = m_points[middleIndex];
				Vector3 vector4 = vector3 - m_points[fixedIndex];
				if (mode == ControlPointMode.Aligned)
				{
					Vector3 b = base.transform.InverseTransformPoint(branch.transform.TransformPoint(branch.m_points[enforcedIndex]));
					vector4 = vector4.normalized * Vector3.Distance(vector3, b);
				}
				Vector3 vector5 = branch.transform.InverseTransformPoint(base.transform.TransformPoint(vector3 + vector4));
				if (branch.m_points[enforcedIndex] != vector5)
				{
					branch._SetControlPointLocalUnchecked(enforcedIndex, vector5);
				}
			}

			protected void AlignCurve(int curveIndex, float length, bool toLast = true)
			{
				int num = curveIndex * 3;
				int num2 = num + 3;
				Vector3 vector = m_points[num2];
				Vector3 vector2 = m_points[num];
				Vector3 vector3 = ((!toLast) ? base.transform.InverseTransformDirection(GetDirection(0f, curveIndex)) : base.transform.InverseTransformDirection(GetDirection(1f, curveIndex)));
				if (toLast)
				{
					for (int num3 = num2 - 1; num3 >= num; num3--)
					{
						vector -= vector3 * length / 3f;
						SetControlPointValue(num3, vector);
						RaiseControlPointChanged(num3);
					}
					Vector3 vector4 = vector2 - m_points[num];
					for (int num4 = num - 1; num4 >= 0; num4--)
					{
						ChangeControlPointValue(num4, -vector4);
						RaiseControlPointChanged(num4);
					}
				}
				else
				{
					for (int i = num + 1; i <= num2; i++)
					{
						vector2 += vector3 * length / 3f;
						SetControlPointValue(i, vector2);
						RaiseControlPointChanged(i);
					}
					Vector3 vector5 = vector - m_points[num2];
					for (int j = num2 + 1; j < m_points.Length; j++)
					{
						ChangeControlPointValue(j, -vector5);
						RaiseControlPointChanged(j);
					}
				}
				EnforceMode(num - 1);
				EnforceMode(num2 + 1);
			}

			protected bool RemoveCurve(int curveIndex)
			{
				if (m_points.Length <= 4)
				{
					return false;
				}
				if (curveIndex >= CurveCount || curveIndex < 0)
				{
					throw new ArgumentOutOfRangeException("curveIndex");
				}
				if (curveIndex == 0)
				{
					if (m_prevSpline != null)
					{
						m_prevSpline.Disconnect(this, isInbound: false);
					}
				}
				else if (curveIndex == CurveCount - 1 && m_nextSpline != null)
				{
					m_nextSpline.Disconnect(this, isInbound: true);
				}
				int num = curveIndex * 3;
				bool flag = true;
				if (curveIndex == CurveCount - 1)
				{
					flag = false;
					num += 3;
				}
				for (int i = num; i < m_points.Length - 3; i++)
				{
					JustSetControlPointValue(i, m_points[i + 3]);
				}
				if (curveIndex == 0)
				{
					Disconnect(0);
					ShiftConnectionIndices(0, -3);
				}
				if (curveIndex == CurveCount - 1)
				{
					int num2 = curveIndex + 1;
					Disconnect(num2 * 3);
				}
				else
				{
					Disconnect(curveIndex * 3);
					ShiftConnectionIndices(curveIndex * 3, -3);
				}
				for (int j = (num + 1) / 3; j < m_modes.Length - 1; j++)
				{
					m_settings[j] = m_settings[j + 1];
					m_modes[j] = m_modes[j + 1];
					RaiseControlPointModeChanged(j);
				}
				Array.Resize(ref m_points, m_points.Length - 3);
				Array.Resize(ref m_settings, m_settings.Length - 1);
				Array.Resize(ref m_modes, m_modes.Length - 1);
				if (flag)
				{
					EnforceMode(num + 1);
				}
				if (m_loop)
				{
					SetControlPointValue(m_points.Length - 1, m_points[0]);
					ControlPointSetting controlPointSetting = m_settings[m_settings.Length - 1];
					m_settings[0] = new ControlPointSetting(controlPointSetting.Twist, controlPointSetting.Thickness, m_settings[0].Branches);
					m_modes[m_modes.Length - 1] = m_modes[0];
					RaiseControlPointModeChanged(m_modes.Length - 1);
					EnforceMode(1);
				}
				SyncCtrlPoints();
				return true;
			}

			protected void Subdivide(int firstCurveIndex, int lastCurveIndex, int curveCount)
			{
				int num = firstCurveIndex * 3;
				int num2 = lastCurveIndex * 3 + 3;
				int num3 = m_points.Length;
				int num4 = num2 - num - 1;
				int num5 = curveCount * 3 - 1;
				int num6 = num5 - num4;
				Vector3[] array = new Vector3[num5];
				Vector3 a = m_points[num];
				Vector3 b = m_points[num2];
				ControlPointSetting controlPointSetting = m_settings[(num + 1) / 3];
				ControlPointSetting controlPointSetting2 = new ControlPointSetting(controlPointSetting.Twist, controlPointSetting.Thickness);
				ControlPointMode controlPointMode = m_modes[(num + 1) / 3];
				float num7 = 1f / (float)(num5 + 1);
				float num8 = 0f;
				for (int i = 0; i < num5; i++)
				{
					num8 += num7;
					array[i] = Vector3.Lerp(a, b, num8);
				}
				if (num6 > 0)
				{
					Array.Resize(ref m_points, m_points.Length + num6);
					Array.Resize(ref m_settings, m_settings.Length + num6 / 3);
					Array.Resize(ref m_modes, m_modes.Length + num6 / 3);
					for (int num9 = num3 - 1; num9 >= num2; num9--)
					{
						SetControlPointValue(num9 + num6, m_points[num9]);
					}
					for (int num10 = num3 / 3; num10 >= (num2 + 1) / 3; num10--)
					{
						m_settings[num10 + num6 / 3] = m_settings[num10];
						m_modes[num10 + num6 / 3] = m_modes[num10];
						RaiseControlPointModeChanged(num10 + num6 / 3);
					}
				}
				else if (num6 < 0)
				{
					for (int j = num2; j < num3; j++)
					{
						SetControlPointValue(j + num6, m_points[j]);
					}
					for (int k = (num2 + 1) / 3; k < (num3 + 1) / 3; k++)
					{
						m_settings[k + num6 / 3] = m_settings[k];
						m_modes[k + num6 / 3] = m_modes[k];
						RaiseControlPointModeChanged(k + num6 / 3);
					}
					Array.Resize(ref m_points, m_points.Length + num6);
					Array.Resize(ref m_settings, m_settings.Length + num6 / 3);
					Array.Resize(ref m_modes, m_modes.Length + num6 / 3);
				}
				for (int l = 0; l < num5; l++)
				{
					SetControlPointValue(num + l + 1, array[l]);
				}
				for (int m = 0; m < num5 / 3; m++)
				{
					m_settings[(num + 1) / 3 + m + 1] = controlPointSetting2;
					m_modes[(num + 1) / 3 + m + 1] = controlPointMode;
					RaiseControlPointModeChanged((num + 1) / 3 + m + 1);
				}
				int num11 = num - 1;
				int num12 = num + num5 + 2;
				if (m_loop)
				{
					if (num11 == -1)
					{
						num11 = m_points.Length - 1;
					}
					if (num12 == m_points.Length)
					{
						num12 = 0;
					}
				}
				if (num12 < m_points.Length)
				{
					EnforceMode(num12);
				}
				if (num11 >= 0)
				{
					EnforceMode(num11);
				}
				SyncCtrlPoints();
			}

			private void InsertCurve(Vector3[] points, ControlPointSetting setting, ControlPointMode mode, int curveIndex, float length, bool enforceNeighbour, bool shrinkPreceding)
			{
				if (curveIndex == 0 && shrinkPreceding)
				{
					curveIndex = ((!Loop) ? 1 : CurveCount);
				}
				int num = curveIndex * 3;
				int num2 = curveIndex - 1;
				int num3 = num2 * 3;
				Array.Resize(ref m_points, m_points.Length + points.Length);
				Array.Resize(ref m_settings, m_settings.Length + points.Length / 3);
				Array.Resize(ref m_modes, m_modes.Length + points.Length / 3);
				int num4 = (num + 1) / 3;
				ShiftConnectionIndices(num4, points.Length);
				for (int num5 = m_modes.Length - 1; num5 >= num4 + points.Length / 3; num5--)
				{
					m_settings[num5] = m_settings[num5 - points.Length / 3];
					m_modes[num5] = m_modes[num5 - points.Length / 3];
				}
				for (int num6 = m_points.Length - 1; num6 >= num + points.Length; num6--)
				{
					JustSetControlPointValue(num6, m_points[num6 - points.Length]);
				}
				if (shrinkPreceding)
				{
					float num7 = points.Length + 3;
					for (int num8 = points.Length - 1; num8 >= 0; num8--)
					{
						points[num8] = GetPointLocal((float)(num8 + 4) / num7, num2);
					}
					Vector3[] array = new Vector3[3];
					for (int num9 = 2; num9 >= 0; num9--)
					{
						array[num9] = GetPointLocal((float)(num9 + 1) / num7, num2);
					}
					for (int num10 = num; num10 >= num - 2; num10--)
					{
						SetControlPointValue(num10, array[2 + num10 - num]);
					}
				}
				for (int num11 = m_modes.Length - 1; num11 >= num4 + points.Length / 3; num11--)
				{
					RaiseControlPointModeChanged(num11);
				}
				for (int i = num4; i < num4 + points.Length / 3; i++)
				{
					m_settings[i] = setting;
					m_modes[i] = mode;
				}
				if (shrinkPreceding)
				{
					for (int j = num; j < num + points.Length; j++)
					{
						SetControlPointValue(j + 1, points[j - num]);
					}
				}
				else
				{
					for (int k = num; k < num + points.Length; k++)
					{
						SetControlPointValue(k, points[k - num]);
					}
					Vector3 vector = base.transform.InverseTransformDirection(GetDirection(0f, curveIndex));
					for (int num12 = num - 1; num12 >= 0; num12--)
					{
						ChangeControlPointValue(num12, -vector * length);
					}
				}
				for (int l = num4; l < num4 + points.Length / 3; l++)
				{
					RaiseControlPointModeChanged(l);
				}
				if (shrinkPreceding)
				{
					EnforceMode(num + points.Length + 1);
					EnforceMode(num - 1);
					EnforceMode(num3 - 1);
				}
				else if (enforceNeighbour)
				{
					EnforceMode(num + points.Length + 1);
				}
				else
				{
					EnforceMode(num + points.Length - 1);
				}
				if (m_loop)
				{
					ControlPointSetting controlPointSetting = m_settings[m_settings.Length - 1];
					m_settings[0] = new ControlPointSetting(controlPointSetting.Twist, controlPointSetting.Thickness, m_settings[0].Branches);
					m_modes[m_modes.Length - 1] = m_modes[0];
					SetControlPointValue(m_points.Length - 1, m_points[0]);
					RaiseControlPointModeChanged(m_modes.Length - 1);
					EnforceMode(1);
				}
				SyncCtrlPoints();
			}

			protected void PrependCurve(Vector3[] points, int curveIndex, float length, bool enforceNeighbour, bool shrinkPreceding)
			{
				if (m_prevSpline != null && curveIndex == 0)
				{
					throw new InvalidOperationException("Can't prepend curve to the connected end of the spline. Previous spline " + m_prevSpline.name);
				}
				ControlPointSetting setting = GetSetting(curveIndex * 3);
				setting.Branches = new SplineBranch[0];
				InsertCurve(points, setting, GetControlPointMode(curveIndex * 3), curveIndex, length, enforceNeighbour, shrinkPreceding);
			}

			protected void AppendCurve(Vector3[] points, bool enforceNeighbour)
			{
				ControlPointSetting setting = GetSetting(m_points.Length - 1);
				AppendCurve(points, new ControlPointSetting(setting.Twist, setting.Thickness), GetControlPointMode(m_points.Length - 1), enforceNeighbour);
			}

			private void AppendCurve(Vector3[] points, ControlPointSetting setting, ControlPointMode mode, bool enforceNeighbour)
			{
				if (m_nextSpline != null)
				{
					throw new InvalidOperationException("Can't append curve to the connected end of the spline. Next spline " + m_nextSpline.name);
				}
				Array.Resize(ref m_points, m_points.Length + points.Length);
				Array.Resize(ref m_settings, m_settings.Length + points.Length / 3);
				Array.Resize(ref m_modes, m_modes.Length + points.Length / 3);
				for (int i = 0; i < points.Length / 3; i++)
				{
					m_settings[m_settings.Length - points.Length / 3 + i] = setting;
					m_modes[m_modes.Length - points.Length / 3 + i] = mode;
				}
				for (int j = 0; j < points.Length; j++)
				{
					SetControlPointValue(m_points.Length - points.Length + j, points[j]);
				}
				for (int k = 0; k < points.Length / 3; k++)
				{
					RaiseControlPointModeChanged(m_modes.Length - points.Length / 3 + k);
				}
				if (enforceNeighbour)
				{
					EnforceMode(m_points.Length - points.Length - 2);
				}
				else
				{
					EnforceMode(m_points.Length - points.Length);
				}
				if (m_loop)
				{
					ControlPointSetting controlPointSetting = m_settings[m_settings.Length - 1];
					m_settings[0] = new ControlPointSetting(controlPointSetting.Twist, controlPointSetting.Thickness, m_settings[0].Branches);
					m_modes[0] = m_modes[m_modes.Length - 1];
					SetControlPointValue(0, m_points[m_points.Length - 1]);
					RaiseControlPointModeChanged(0);
					EnforceMode(m_points.Length - 1);
				}
				SyncCtrlPoints();
			}

			protected void AlignWithEnding(Vector3[] points, int curveIndex, float mag, float offset = 1f)
			{
				if (points.Length != 0)
				{
					Vector3 vector = base.transform.InverseTransformDirection(GetDirection(offset, curveIndex));
					Vector3 pointLocal = GetPointLocal(offset, curveIndex);
					float num = 1f / 3f;
					float num2 = num;
					if (points.Length % 2 == 0)
					{
						num2 = 0f;
					}
					for (int i = 0; i < points.Length; i++)
					{
						points[i] = pointLocal + vector * mag * num2;
						num2 += num;
					}
				}
			}

			protected void AlignWithBeginning(Vector3[] points, int curveIndex, float mag, float offset = 0f)
			{
				if (points.Length != 0)
				{
					Vector3 direction = GetDirection(offset, curveIndex);
					Vector3 pointLocal = GetPointLocal(offset, curveIndex);
					direction = base.transform.InverseTransformDirection(direction);
					float num = 1f / 3f;
					float num2 = 1f;
					for (int i = 0; i < points.Length; i++)
					{
						points[i] = pointLocal - direction * mag * num2;
						num2 -= num;
					}
				}
			}

			protected virtual void OnCurveChanged(int pointIndex, int curveIndex)
			{
			}

			protected virtual void OnCurveChanged()
			{
			}

			protected virtual void AddControlPointComponent(GameObject ctrlPoint)
			{
				ctrlPoint.AddComponent<SplineControlPoint>();
			}

			private void SyncCtrlPoints(bool silent = false)
			{
				SplineRuntimeEditor instance = SplineRuntimeEditor.Instance;
				SplineControlPoint[] splineControlPoints = GetSplineControlPoints();
				int num = ControlPointCount - splineControlPoints.Length;
				if (num > 0)
				{
					for (int i = 0; i < num; i++)
					{
						GameObject gameObject = new GameObject();
						gameObject.SetActive(m_isSelected);
						gameObject.transform.parent = base.transform;
						gameObject.transform.rotation = Quaternion.identity;
						gameObject.transform.localScale = Vector3.one;
						if (instance != null)
						{
							MeshRenderer meshRenderer = gameObject.AddComponent<MeshRenderer>();
							gameObject.AddComponent<MeshFilter>().sharedMesh = instance.ControlPointMesh;
							meshRenderer.sharedMaterial = instance.NormalMaterial;
							meshRenderer.enabled = true;
						}
						gameObject.name = "ctrl point";
						AddControlPointComponent(gameObject);
					}
					splineControlPoints = GetSplineControlPoints();
				}
				else if (num < 0)
				{
					num = -num;
					for (int j = 0; j < num; j++)
					{
						SplineControlPoint splineControlPoint = splineControlPoints[j];
						if (splineControlPoint.gameObject != null)
						{
							UnityEngine.Object.DestroyImmediate(splineControlPoint.gameObject);
						}
					}
					splineControlPoints = GetSplineControlPoints();
				}
				for (int k = 0; k < ControlPointCount; k++)
				{
					splineControlPoints[k].Index = k;
					RaiseControlPointChanged(k);
					RaiseControlPointModeChanged(k);
				}
			}

			private void SetValue<T>(int controlPointIndex, T value, Action<int, T, bool> setter, Action<int, T, SplineBase, bool> branchSetter, Func<int, T> getter, bool raiseCurveChanged = true)
			{
				if (!getter(controlPointIndex).Equals(value))
				{
					setter(controlPointIndex, value, raiseCurveChanged);
					SetBranchValues(controlPointIndex, value, branchSetter, raiseCurveChanged);
				}
			}

			private void SetBranchValues<T>(int controlPointIndex, T value, Action<int, T, SplineBase, bool> branchSetter, bool raiseCurveChanged)
			{
				int num = (controlPointIndex + 1) / 3;
				SplineBranch[] branches = m_settings[num].Branches;
				if (branches != null)
				{
					for (int i = 0; i < branches.Length; i++)
					{
						SplineBranch splineBranch = branches[i];
						SplineBase splineBase = m_branches[splineBranch.SplineIndex];
						if (splineBase != null)
						{
							if (splineBranch.Inbound)
							{
								branchSetter(splineBase.ControlPointCount - 1, value, splineBase, raiseCurveChanged);
							}
							else
							{
								branchSetter(0, value, splineBase, raiseCurveChanged);
							}
						}
					}
				}
				if (num == 0 && PrevSpline != null)
				{
					branchSetter(PrevControlPointIndex, value, PrevSpline, raiseCurveChanged);
				}
				if (num == m_settings.Length - 1 && NextSpline != null)
				{
					branchSetter(NextControlPointIndex, value, NextSpline, raiseCurveChanged);
				}
			}
		}
		[ExecuteInEditMode]
		public class SplineControlPoint : MonoBehaviour
		{
			private MeshRenderer m_renderer;

			private SplineBase m_spline;

			private Vector3 m_localPosition;

			private Quaternion m_rotation;

			private bool m_updateAngle = true;

			[SerializeField]
			[HideInInspector]
			private int m_index;

			public int Index
			{
				get
				{
					return m_index;
				}
				set
				{
					m_index = value;
					UpdateMaterial();
				}
			}

			private void OnEnable()
			{
				m_spline = GetComponentInParent<SplineBase>();
				if (!(m_spline == null))
				{
					m_spline.ControlPointTwistChanged -= OnControlPointTwistChanged;
					m_spline.ControlPointTwistChanged += OnControlPointTwistChanged;
					m_spline.ControlPointThicknessChanged -= OnControlPointThicknessChanged;
					m_spline.ControlPointThicknessChanged += OnControlPointThicknessChanged;
					m_spline.ControlPointModeChanged -= OnControlPointModeChanged;
					m_spline.ControlPointModeChanged += OnControlPointModeChanged;
					m_spline.ControlPointPositionChanged -= OnControlPointPositionChanged;
					m_spline.ControlPointPositionChanged += OnControlPointPositionChanged;
					m_spline.ControlPointConnectionChanged -= OnControlPointConnectionChanged;
					m_spline.ControlPointConnectionChanged += OnControlPointConnectionChanged;
					UpdateRenderersState();
				}
			}

			private void Start()
			{
				SplineRuntimeEditor.Created += OnRuntimeEditorCreated;
				SplineBase.ConvergingSplineChanged += OnIsConvergingChanged;
				CreateRuntimeComponents();
				if (m_spline == null)
				{
					m_spline = GetComponentInParent<SplineBase>();
					if (m_spline == null)
					{
						UnityEngine.Debug.LogError("Is not a child of gameobject with Spline or MeshDeformer component");
						return;
					}
					m_spline.ControlPointTwistChanged -= OnControlPointTwistChanged;
					m_spline.ControlPointTwistChanged += OnControlPointTwistChanged;
					m_spline.ControlPointThicknessChanged -= OnControlPointThicknessChanged;
					m_spline.ControlPointThicknessChanged += OnControlPointThicknessChanged;
					m_spline.ControlPointModeChanged -= OnControlPointModeChanged;
					m_spline.ControlPointModeChanged += OnControlPointModeChanged;
					m_spline.ControlPointPositionChanged -= OnControlPointPositionChanged;
					m_spline.ControlPointPositionChanged += OnControlPointPositionChanged;
					m_spline.ControlPointConnectionChanged -= OnControlPointConnectionChanged;
					m_spline.ControlPointConnectionChanged += OnControlPointConnectionChanged;
				}
				m_localPosition = m_spline.GetControlPointLocal(m_index);
				base.transform.localPosition = m_localPosition;
				UpdateRenderersState();
				UpdateAngle(forceUpdateAngle: true);
				m_rotation = base.transform.rotation;
				Thickness thickness = m_spline.GetThickness(m_index);
				base.transform.localScale = thickness.Data;
				if (!m_spline.IsSelected)
				{
					base.gameObject.SetActive(value: false);
				}
			}

			protected void OnDestroy()
			{
				if (m_spline != null)
				{
					m_spline.ControlPointTwistChanged -= OnControlPointTwistChanged;
					m_spline.ControlPointThicknessChanged -= OnControlPointThicknessChanged;
					m_spline.ControlPointModeChanged -= OnControlPointModeChanged;
					m_spline.ControlPointPositionChanged -= OnControlPointPositionChanged;
					m_spline.ControlPointConnectionChanged -= OnControlPointConnectionChanged;
				}
				SplineBase.ConvergingSplineChanged -= OnIsConvergingChanged;
				SplineRuntimeEditor.Created -= OnRuntimeEditorCreated;
			}

			private void Update()
			{
				if (m_spline == null)
				{
					return;
				}
				if (base.transform.localPosition != m_localPosition)
				{
					if (m_spline.SetControlPointLocal(m_index, base.transform.localPosition))
					{
						m_localPosition = base.transform.localPosition;
					}
					else
					{
						base.transform.localPosition = m_localPosition;
					}
				}
				if (base.transform.rotation != m_rotation)
				{
					if (m_index % 3 == 0)
					{
						Vector3 vector = Vector3.back;
						int num = m_index - 1;
						if (num < 0)
						{
							num = m_index + 1;
							vector = Vector3.forward;
						}
						Vector3 controlPoint = m_spline.GetControlPoint(num);
						Vector3 controlPoint2 = m_spline.GetControlPoint(m_index);
						Vector3 vector2 = (base.transform.rotation * vector).normalized * (controlPoint2 - controlPoint).magnitude;
						Twist twist = m_spline.GetTwist(m_index);
						m_rotation = base.transform.rotation;
						twist.Data = base.transform.eulerAngles.z;
						m_updateAngle = false;
						m_spline.SetTwist(m_index, twist);
						m_spline.SetControlPoint(num, controlPoint2 + vector2);
						m_updateAngle = true;
					}
					else
					{
						base.transform.rotation = m_rotation;
					}
				}
				Thickness thickness = m_spline.GetThickness(m_index);
				Vector3 vector3 = thickness.Data;
				if (base.transform.localScale != vector3)
				{
					thickness.Data = base.transform.localScale;
					m_spline.SetThickness(m_index, thickness);
				}
			}

			private void OnControlPointThicknessChanged(int pointIndex)
			{
				if ((m_index + 1) / 3 == (pointIndex + 1) / 3)
				{
					base.transform.localScale = m_spline.GetThickness(pointIndex).Data;
				}
			}

			private void OnControlPointTwistChanged(int pointIndex)
			{
				if (m_updateAngle && (m_index + 1) % 3 == (pointIndex + 1) % 3)
				{
					UpdateAngle();
				}
			}

			private void OnRuntimeEditorCreated(object sender, EventArgs e)
			{
				CreateRuntimeComponents();
			}

			private void OnIsConvergingChanged(object sender, EventArgs e)
			{
				if (m_spline.IsSelected)
				{
					UpdateRenderersState();
				}
			}

			private void OnControlPointModeChanged(int pointIndex)
			{
				if (pointIndex == m_index)
				{
					UpdateRenderersState();
				}
			}

			private void OnControlPointPositionChanged(int pointIndex)
			{
				if (!(m_spline == null) && m_updateAngle)
				{
					if (pointIndex == m_index)
					{
						m_localPosition = m_spline.GetControlPointLocal(pointIndex);
						base.transform.localPosition = m_localPosition;
						UpdateAngle();
					}
					else if (pointIndex == m_index - 1 || pointIndex == m_index + 1)
					{
						UpdateAngle();
					}
				}
			}

			private void OnControlPointConnectionChanged(int pointIndex)
			{
				if (pointIndex == m_index)
				{
					UpdateRenderersState();
				}
			}

			public void UpdateAngle(bool forceUpdateAngle = false)
			{
				if (m_spline == null)
				{
					return;
				}
				Twist twist = m_spline.GetTwist(m_index);
				int num = m_index % 3;
				if (num == 0)
				{
					int num2 = m_index - 1;
					if (num2 > 0)
					{
						Vector3 controlPoint = m_spline.GetControlPoint(num2);
						Vector3 controlPoint2 = m_spline.GetControlPoint(m_index);
						m_rotation = Quaternion.AngleAxis(twist.Data, controlPoint2 - controlPoint) * Quaternion.LookRotation(controlPoint2 - controlPoint);
						base.transform.rotation = m_rotation;
					}
					else
					{
						int index = m_index + 1;
						Vector3 controlPoint3 = m_spline.GetControlPoint(m_index);
						Vector3 controlPoint4 = m_spline.GetControlPoint(index);
						m_rotation = Quaternion.AngleAxis(twist.Data, controlPoint4 - controlPoint3) * Quaternion.LookRotation(controlPoint4 - controlPoint3);
						base.transform.rotation = m_rotation;
					}
				}
				else if (true || forceUpdateAngle)
				{
					if (num == 1)
					{
						int index2 = m_index - 1;
						Vector3 controlPoint5 = m_spline.GetControlPoint(index2);
						Vector3 controlPoint6 = m_spline.GetControlPoint(m_index);
						m_rotation = Quaternion.AngleAxis(twist.Data, controlPoint6 - controlPoint5) * Quaternion.LookRotation(controlPoint6 - controlPoint5);
						base.transform.rotation = m_rotation;
					}
					else
					{
						int index3 = m_index + 1;
						Vector3 controlPoint7 = m_spline.GetControlPoint(m_index);
						Vector3 controlPoint8 = m_spline.GetControlPoint(index3);
						m_rotation = Quaternion.AngleAxis(twist.Data, controlPoint8 - controlPoint7) * Quaternion.LookRotation(controlPoint8 - controlPoint7);
						base.transform.rotation = m_rotation;
					}
				}
			}

			private void UpdateRenderersState()
			{
				if (m_index == 0 || m_index == 1)
				{
					if (m_spline.PrevSpline != null)
					{
						if (m_renderer != null)
						{
							m_renderer.enabled = !m_spline.IsControlPointLocked(m_index);
						}
					}
					else if (m_renderer != null && !m_renderer.enabled)
					{
						m_renderer.enabled = true;
					}
				}
				else if (m_index == m_spline.ControlPointCount - 1 || m_index == m_spline.ControlPointCount - 2)
				{
					if (m_spline.NextSpline != null)
					{
						if (m_renderer != null)
						{
							m_renderer.enabled = !m_spline.IsControlPointLocked(m_index);
						}
					}
					else if (m_renderer != null && !m_renderer.enabled)
					{
						m_renderer.enabled = true;
					}
				}
				else if (m_renderer != null && !m_renderer.enabled)
				{
					m_renderer.enabled = true;
				}
				if ((bool)SplineBase.ConvergingSpline)
				{
					if (m_spline.Loop && (m_index == 0 || m_index == m_spline.ControlPointCount - 1) && m_renderer != null)
					{
						m_renderer.enabled = false;
					}
					if ((m_index % 3 != 0 || m_spline == SplineBase.ConvergingSpline) && m_renderer != null)
					{
						m_renderer.enabled = false;
					}
				}
				UpdateMaterial();
			}

			private void UpdateMaterial()
			{
				if (!(m_renderer != null))
				{
					return;
				}
				SplineRuntimeEditor instance = SplineRuntimeEditor.Instance;
				if (!(instance != null))
				{
					return;
				}
				if (m_index % 3 == 0)
				{
					if (m_spline.HasBranches(m_index))
					{
						m_renderer.sharedMaterial = instance.ConnectedMaterial;
					}
					else
					{
						m_renderer.sharedMaterial = instance.NormalMaterial;
					}
				}
				else if (m_index < m_spline.ControlPointCount)
				{
					switch (m_spline.GetControlPointMode(m_index))
					{
					case ControlPointMode.Mirrored:
						m_renderer.sharedMaterial = instance.MirroredModeMaterial;
						break;
					case ControlPointMode.Aligned:
						m_renderer.sharedMaterial = instance.AlignedModeMaterial;
						break;
					default:
						m_renderer.sharedMaterial = instance.FreeModeMaterial;
						break;
					}
				}
			}

			private void CreateRuntimeComponents()
			{
				SplineRuntimeEditor instance = SplineRuntimeEditor.Instance;
				if (instance != null)
				{
					m_renderer = GetComponent<MeshRenderer>();
					if (!m_renderer)
					{
						m_renderer = base.gameObject.AddComponent<MeshRenderer>();
					}
					MeshFilter meshFilter = GetComponent<MeshFilter>();
					if (!meshFilter)
					{
						meshFilter = base.gameObject.AddComponent<MeshFilter>();
					}
					if (!meshFilter.sharedMesh)
					{
						meshFilter.sharedMesh = instance.ControlPointMesh;
						UpdateMaterial();
					}
					if (!base.gameObject.GetComponent<ExposeToEditor>())
					{
						base.gameObject.AddComponent<ExposeToEditor>();
					}
				}
			}

			public void DestroyRuntimeComponents()
			{
				MeshRenderer component = GetComponent<MeshRenderer>();
				if ((bool)component)
				{
					UnityEngine.Object.DestroyImmediate(component);
				}
				MeshFilter component2 = GetComponent<MeshFilter>();
				if ((bool)component2)
				{
					UnityEngine.Object.DestroyImmediate(component2);
				}
				ExposeToEditor component3 = base.gameObject.GetComponent<ExposeToEditor>();
				if ((bool)component3)
				{
					UnityEngine.Object.DestroyImmediate(component3);
				}
			}
		}
		public class SplineRuntimeCmd : MonoBehaviour
		{
			[Serializable]
			public class SplineSnapshots
			{
				public SplineSnapshot[] Data;

				public SplineSnapshots()
				{
					Data = new SplineSnapshot[0];
				}
			}

			public Spline m_spline;

			public SplineControlPoint m_controlPoint;

			private Spline GetSelectedSpline()
			{
				if (RuntimeSelection.activeGameObject == null)
				{
					return null;
				}
				return RuntimeSelection.activeGameObject.GetComponentInParent<Spline>();
			}

			private SplineControlPoint GetSelectedControlPoint()
			{
				if (RuntimeSelection.activeGameObject == null)
				{
					return null;
				}
				return RuntimeSelection.activeGameObject.GetComponentInParent<SplineControlPoint>();
			}

			public void Awake()
			{
				m_spline = GetSelectedSpline();
				RuntimeSelection.SelectionChanged += OnRuntimeSelectionChanged;
			}

			public void OnDestroy()
			{
				SplineBase.ConvergingSpline = null;
				RuntimeSelection.SelectionChanged -= OnRuntimeSelectionChanged;
			}

			private void OnRuntimeSelectionChanged(UnityEngine.Object[] unselectedObjects)
			{
				if ((bool)SplineBase.ConvergingSpline)
				{
					SplineControlPoint selectedControlPoint = GetSelectedControlPoint();
					Spline selectedSpline = GetSelectedSpline();
					if (selectedControlPoint == null || m_controlPoint == null || m_spline == null)
					{
						SplineBase.ConvergingSpline = null;
					}
					else if (Converge(selectedSpline, m_spline, selectedControlPoint.Index, m_controlPoint.Index))
					{
						SplineBase.ConvergingSpline = null;
						m_spline = selectedSpline;
						m_controlPoint = selectedControlPoint;
					}
					else
					{
						SplineBase.ConvergingSpline = null;
					}
				}
				else
				{
					m_controlPoint = GetSelectedControlPoint();
					m_spline = GetSelectedSpline();
				}
			}

			public void RunAction<T>(Action<T, GameObject> action)
			{
				GameObject[] gameObjects = RuntimeSelection.gameObjects;
				if (gameObjects == null)
				{
					return;
				}
				foreach (GameObject gameObject in gameObjects)
				{
					if (!(gameObject == null))
					{
						T componentInParent = gameObject.GetComponentInParent<T>();
						if (componentInParent != null)
						{
							action?.Invoke(componentInParent, gameObject);
						}
					}
				}
			}

			public virtual void Append()
			{
				RunAction(delegate(Spline spline, GameObject go)
				{
					if (spline.NextSpline == null)
					{
						spline.Append();
					}
				});
			}

			public virtual void Insert()
			{
				RunAction(delegate(Spline spline, GameObject go)
				{
					if (go != null)
					{
						SplineControlPoint component = go.GetComponent<SplineControlPoint>();
						if (component != null)
						{
							spline.Insert((component.Index + 2) / 3);
						}
					}
				});
			}

			public virtual void Prepend()
			{
				RunAction(delegate(Spline spline, GameObject go)
				{
					if (spline.PrevSpline == null)
					{
						spline.Prepend();
					}
				});
			}

			public virtual void Remove()
			{
				RunAction(delegate(Spline spline, GameObject go)
				{
					if (go != null)
					{
						SplineControlPoint component = go.GetComponent<SplineControlPoint>();
						if (component != null)
						{
							int curveIndex = Mathf.Min((component.Index + 1) / 3, spline.CurveCount - 1);
							spline.Remove(curveIndex);
						}
						RuntimeSelection.activeObject = spline.gameObject;
					}
				});
			}

			public virtual void Smooth()
			{
				RunAction(delegate(SplineBase spline, GameObject go)
				{
					spline.Root.Smooth();
				});
			}

			public virtual void SetMirroredMode()
			{
				RunAction(delegate(SplineBase spline, GameObject go)
				{
					spline.Root.SetControlPointMode(ControlPointMode.Mirrored);
				});
			}

			public virtual void SetAlignedMode()
			{
				RunAction(delegate(SplineBase spline, GameObject go)
				{
					spline.Root.SetControlPointMode(ControlPointMode.Aligned);
				});
			}

			public virtual void SetFreeMode()
			{
				RunAction(delegate(SplineBase spline, GameObject go)
				{
					spline.Root.SetControlPointMode(ControlPointMode.Free);
				});
			}

			public virtual void OutBranch()
			{
				throw new NotImplementedException("Implement after Save/Load enchancements");
			}

			public virtual void BranchIn()
			{
				throw new NotImplementedException("Implement after Save/Load enchancements");
			}

			public virtual void Converge()
			{
				SplineBase.ConvergingSpline = m_spline;
			}

			public virtual void Separate()
			{
				if (m_spline != null && m_controlPoint != null)
				{
					Separate(m_spline, m_controlPoint.Index);
				}
			}

			public static bool Converge(SplineBase spline, SplineBase branch, int splineIndex, int branchIndex)
			{
				if (spline == branch)
				{
					return false;
				}
				if (branch.PrevSpline != null && branch.NextSpline != null)
				{
					return false;
				}
				if (branchIndex == 0)
				{
					if (branch.PrevSpline != null)
					{
						return false;
					}
					spline.SetBranch(branch, splineIndex, isInbound: false);
					return true;
				}
				if (branchIndex == branch.ControlPointCount - 1)
				{
					if (branch.NextSpline != null)
					{
						return false;
					}
					spline.SetBranch(branch, splineIndex, isInbound: true);
					return true;
				}
				UnityEngine.Debug.LogError("branchIndex should be equal to 0 or branch.ControlPointCount - 1");
				return false;
			}

			public static void Separate(SplineBase spline, int controlPointIndex)
			{
				spline.Unselect();
				spline.Disconnect(controlPointIndex);
				spline.Select();
			}

			public virtual void Load()
			{
				string @string = OVPlayerPrefs.GetString("SplineEditorSave");
				if (string.IsNullOrEmpty(@string))
				{
					return;
				}
				SplineBase[] array = UnityEngine.Object.FindObjectsOfType<SplineBase>();
				SplineSnapshots splineSnapshots = DeserializeFromString<SplineSnapshots>(@string);
				if (array.Length != splineSnapshots.Data.Length)
				{
					UnityEngine.Debug.LogError("Wrong data in save file");
					return;
				}
				for (int i = 0; i < splineSnapshots.Data.Length; i++)
				{
					array[i].Load(splineSnapshots.Data[i]);
				}
			}

			public virtual void Save()
			{
				SplineBase[] array = UnityEngine.Object.FindObjectsOfType<SplineBase>();
				SplineSnapshots splineSnapshots = new SplineSnapshots
				{
					Data = new SplineSnapshot[array.Length]
				};
				for (int i = 0; i < splineSnapshots.Data.Length; i++)
				{
					splineSnapshots.Data[i] = array[i].Save();
				}
				string value = SerializeToString(splineSnapshots);
				OVPlayerPrefs.SetString("SplineEditorSave", value);
			}

			private static TData DeserializeFromString<TData>(string settings)
			{
				return (TData)JsonUtility.FromJson(settings, typeof(TData));
			}

			private static string SerializeToString<TData>(TData settings)
			{
				return JsonUtility.ToJson(settings, prettyPrint: false);
			}
		}
		[ExecuteInEditMode]
		public class SplineRuntimeEditor : MonoBehaviour
		{
			public Camera Camera;

			public float SelectionMargin = 20f;

			public static readonly Color MirroredModeColor = Color.red;

			public static readonly Color AlignedModeColor = Color.blue;

			public static readonly Color FreeModeColor = Color.yellow;

			public static readonly Color ControlPointLineColor = Color.gray;

			private Material m_connectedMaterial;

			private Material m_normalMaterial;

			private Material m_mirroredModeMaterial;

			private Material m_alignedModeMaterial;

			private Material m_freeModeMaterial;

			private Mesh m_controlPointMesh;

			private bool m_isApplicationQuit;

			private static SplineRuntimeEditor m_instance;

			public Mesh ControlPointMesh => m_controlPointMesh;

			public Material ConnectedMaterial => m_connectedMaterial;

			public Material MirroredModeMaterial => m_mirroredModeMaterial;

			public Material AlignedModeMaterial => m_alignedModeMaterial;

			public Material FreeModeMaterial => m_freeModeMaterial;

			public Material NormalMaterial => m_normalMaterial;

			public static SplineRuntimeEditor Instance => m_instance;

			public static event EventHandler Created;

			public static event EventHandler Destroyed;

			private void Awake()
			{
				if (Camera == null)
				{
					Camera = Camera.main;
					if (Camera.main == null)
					{
						UnityEngine.Debug.LogError("Add Camera with MainCamera Tag");
					}
				}
				if (m_instance != null)
				{
					UnityEngine.Debug.LogWarning("Another instance of SplineEditorSettings already exist");
				}
				if (m_mirroredModeMaterial == null)
				{
					Shader shader = Shader.Find("Battlehub/SplineEditor/SSBillboard");
					m_mirroredModeMaterial = new Material(shader);
					m_mirroredModeMaterial.name = "MirroredModeMaterial";
					m_mirroredModeMaterial.color = MirroredModeColor;
					m_mirroredModeMaterial.SetInt("_Cull", 0);
					m_mirroredModeMaterial.SetInt("_ZWrite", 1);
					m_mirroredModeMaterial.SetInt("_ZTest", 8);
				}
				if (m_alignedModeMaterial == null)
				{
					m_alignedModeMaterial = UnityEngine.Object.Instantiate(m_mirroredModeMaterial);
					m_alignedModeMaterial.name = "AlignedModeMaterial";
					m_alignedModeMaterial.color = AlignedModeColor;
				}
				if (m_freeModeMaterial == null)
				{
					m_freeModeMaterial = UnityEngine.Object.Instantiate(m_mirroredModeMaterial);
					m_freeModeMaterial.name = "FreeModeMaterial";
					m_freeModeMaterial.color = FreeModeColor;
				}
				if (m_normalMaterial == null)
				{
					m_normalMaterial = UnityEngine.Object.Instantiate(m_mirroredModeMaterial);
					m_normalMaterial.name = "SplineMaterial";
					m_normalMaterial.color = Color.green;
				}
				if (m_connectedMaterial == null)
				{
					m_connectedMaterial = UnityEngine.Object.Instantiate(m_mirroredModeMaterial);
					m_connectedMaterial.name = "BranchMaterial";
					m_connectedMaterial.color = new Color32(165, 0, byte.MaxValue, byte.MaxValue);
				}
				if (m_controlPointMesh == null)
				{
					m_controlPointMesh = new Mesh();
					m_controlPointMesh.name = "control point mesh";
					m_controlPointMesh.vertices = new Vector3[4]
					{
						new Vector3(0f, 0f, 0f),
						new Vector3(0f, 0f, 0f),
						new Vector3(0f, 0f, 0f),
						new Vector3(0f, 0f, 0f)
					};
					m_controlPointMesh.triangles = new int[6] { 0, 1, 2, 0, 2, 3 };
					m_controlPointMesh.uv = new Vector2[4]
					{
						new Vector2(-1f, -1f),
						new Vector2(1f, -1f),
						new Vector2(1f, 1f),
						new Vector2(-1f, 1f)
					};
					m_controlPointMesh.RecalculateBounds();
				}
				m_instance = this;
				EnableRuntimeEditing();
				RuntimeSelection.SelectionChanged += OnRuntimeSelectionChanged;
			}

			private void Start()
			{
				if (SplineRuntimeEditor.Created != null)
				{
					SplineRuntimeEditor.Created(this, EventArgs.Empty);
				}
			}

			private void OnApplicationQuit()
			{
				m_isApplicationQuit = true;
			}

			private void OnDestroy()
			{
				if (!Application.isPlaying)
				{
					DisableRuntimeEditing();
				}
				bool flag = false;
				if (!m_isApplicationQuit && !flag)
				{
					SplineControlPoint[] array = Resources.FindObjectsOfTypeAll<SplineControlPoint>();
					foreach (SplineControlPoint splineControlPoint in array)
					{
						if (splineControlPoint != null)
						{
							splineControlPoint.DestroyRuntimeComponents();
						}
					}
				}
				if (SplineRuntimeEditor.Destroyed != null)
				{
					SplineRuntimeEditor.Destroyed(this, EventArgs.Empty);
				}
				RuntimeSelection.SelectionChanged -= OnRuntimeSelectionChanged;
				m_instance = null;
			}

			private void DisableRuntimeEditing()
			{
				if (Camera != null)
				{
					GLCamera component = Camera.GetComponent<GLCamera>();
					if (component != null)
					{
						UnityEngine.Object.DestroyImmediate(component);
					}
				}
			}

			private void EnableRuntimeEditing()
			{
				if (!(Camera == null) && !Camera.GetComponent<GLCamera>())
				{
					Camera.gameObject.AddComponent<GLCamera>();
				}
			}

			private void LateUpdate()
			{
				if (!(m_instance == null))
				{
					return;
				}
				m_instance = this;
				SplineBase[] array = UnityEngine.Object.FindObjectsOfType<SplineBase>();
				foreach (SplineBase splineBase in array)
				{
					if (splineBase.IsSelected)
					{
						splineBase.Select();
					}
				}
			}

			private void OnRuntimeSelectionChanged(UnityEngine.Object[] unselected)
			{
				SplineBase splineBase = null;
				int minIndex = -1;
				float num = float.PositiveInfinity;
				if (unselected != null)
				{
					GameObject[] array = unselected.OfType<GameObject>().ToArray();
					foreach (GameObject gameObject in array)
					{
						if (gameObject == null)
						{
							continue;
						}
						SplineBase componentInParent = gameObject.GetComponentInParent<SplineBase>();
						if (!(componentInParent == null))
						{
							componentInParent.Select();
							float resultDistance = num;
							SplineBase resultSpline;
							int num2 = HitTestRecursive(componentInParent.Root, num, out resultSpline, out resultDistance);
							if (resultDistance < num && num2 != -1)
							{
								num = resultDistance;
								minIndex = num2;
								splineBase = resultSpline;
							}
							componentInParent.Unselect();
						}
					}
					if (splineBase != null)
					{
						SplineControlPoint splineControlPoint = (from p in splineBase.GetSplineControlPoints()
							where p.Index == minIndex
							select p).FirstOrDefault();
						if (splineControlPoint != null)
						{
							RuntimeSelection.activeObject = splineControlPoint.gameObject;
						}
						splineBase.Select();
						return;
					}
				}
				if (RuntimeSelection.gameObjects == null)
				{
					return;
				}
				GameObject[] gameObjects = RuntimeSelection.gameObjects;
				if (gameObjects == null)
				{
					return;
				}
				for (int j = 0; j < gameObjects.Length; j++)
				{
					SplineBase componentInParent2 = gameObjects[j].GetComponentInParent<SplineBase>();
					if (componentInParent2 != null)
					{
						componentInParent2.Select();
					}
				}
			}

			private int HitTestRecursive(SplineBase spline, float distance, out SplineBase resultSpline, out float resultDistance)
			{
				resultSpline = null;
				resultDistance = float.MaxValue;
				int result = -1;
				float minDistance;
				int num = HitTest(spline, out minDistance);
				if (num > -1 && minDistance < distance)
				{
					resultSpline = spline;
					resultDistance = minDistance;
					distance = minDistance;
					result = num;
				}
				if (spline.Children != null)
				{
					for (int i = 0; i < spline.Children.Length; i++)
					{
						SplineBase spline2 = spline.Children[i];
						SplineBase resultSpline2;
						float resultDistance2;
						int num2 = HitTestRecursive(spline2, distance, out resultSpline2, out resultDistance2);
						if (num2 > -1)
						{
							resultSpline = resultSpline2;
							resultDistance = resultDistance2;
							distance = minDistance;
							result = num2;
						}
					}
				}
				return result;
			}

			private int HitTest(SplineBase spline, out float minDistance)
			{
				minDistance = float.PositiveInfinity;
				if (Camera == null)
				{
					UnityEngine.Debug.LogError("Camera is null");
					return -1;
				}
				if (RuntimeSelection.gameObjects == null)
				{
					return -1;
				}
				Vector3[] array = new Vector3[spline.ControlPointCount];
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = spline.GetControlPoint(i);
				}
				minDistance = SelectionMargin * SelectionMargin;
				int result = -1;
				Vector2 vector = Input.mousePosition;
				for (int j = 0; j < array.Length; j++)
				{
					Vector3 position = array[j];
					if (!spline.IsControlPointLocked(j))
					{
						float sqrMagnitude = ((Vector2)Camera.WorldToScreenPoint(position) - vector).sqrMagnitude;
						if (sqrMagnitude < minDistance)
						{
							minDistance = sqrMagnitude;
							result = j;
						}
					}
				}
				return result;
			}

			public void OnClosed()
			{
				if (RuntimeSelection.gameObjects == null)
				{
					return;
				}
				GameObject[] array = RuntimeSelection.gameObjects.OfType<GameObject>().ToArray();
				foreach (GameObject gameObject in array)
				{
					if (!(gameObject == null))
					{
						SplineBase componentInParent = gameObject.GetComponentInParent<SplineBase>();
						if (!(componentInParent == null))
						{
							componentInParent.Unselect();
						}
					}
				}
			}

			public void OnOpened()
			{
			}
		}
	}
	namespace SCPE
	{
		[Serializable]
		[PostProcess(typeof(AmbientOcclusion2DRenderer), PostProcessEvent.AfterStack, "SC Post Effects/Rendering/Ambient Occlusion 2D", true)]
		public sealed class AmbientOcclusion2D : PostProcessEffectSettings
		{
			[UnityEngine.Rendering.PostProcessing.DisplayName("Debug")]
			[Tooltip("Shows only the effect, to alow for finetuning")]
			public BoolParameter aoOnly = new BoolParameter
			{
				value = false
			};

			[Header("Luminance-Based Amient Occlusion")]
			[Range(0f, 1f)]
			[Tooltip("Intensity")]
			public FloatParameter intensity = new FloatParameter
			{
				value = 0.5f
			};

			[Range(0.01f, 1f)]
			[Tooltip("Luminance threshold, pixels above this threshold will contribute to the effect")]
			public FloatParameter luminanceThreshold = new FloatParameter
			{
				value = 0.05f
			};

			[Range(0f, 3f)]
			[Tooltip("Distance")]
			public FloatParameter distance = new FloatParameter
			{
				value = 1f
			};

			[Header("Blur")]
			[Range(0f, 3f)]
			[UnityEngine.Rendering.PostProcessing.DisplayName("Blur")]
			[Tooltip("The amount of blurring that must be performed")]
			public FloatParameter blurAmount = new FloatParameter
			{
				value = 3f
			};

			[Range(1f, 8f)]
			[Tooltip("The number of times the effect is blurred. More iterations provide a smoother effect but induce more drawcalls.")]
			public IntParameter iterations = new IntParameter
			{
				value = 4
			};

			[Range(1f, 8f)]
			[Tooltip("Every step halfs the resolution of the blur effect. Lower resolution provides a smoother blur but may induce flickering.")]
			public IntParameter downscaling = new IntParameter
			{
				value = 2
			};

			public override bool IsEnabledAndSupported(PostProcessRenderContext context)
			{
				if (enabled.value)
				{
					if ((float)intensity == 0f)
					{
						return false;
					}
					return true;
				}
				return false;
			}
		}
		internal sealed class AmbientOcclusion2DRenderer : PostProcessEffectRenderer<AmbientOcclusion2D>
		{
			private enum Pass
			{
				LuminanceDiff,
				Blur,
				Blend,
				Debug
			}

			private Shader shader;

			private int aoTexID;

			private int screenCopyID;

			private RenderTexture aoRT;

			public override void Init()
			{
				shader = Shader.Find("Hidden/SC Post Effects/Ambient Occlusion 2D");
				aoTexID = Shader.PropertyToID("_AO");
			}

			public override void Release()
			{
				base.Release();
			}

			public override void Render(PostProcessRenderContext context)
			{
				PropertySheet propertySheet = context.propertySheets.Get(shader);
				CommandBuffer command = context.command;
				propertySheet.properties.SetFloat("_SampleDistance", base.settings.distance);
				float value = ((QualitySettings.activeColorSpace == ColorSpace.Gamma) ? Mathf.GammaToLinearSpace(base.settings.luminanceThreshold.value) : base.settings.luminanceThreshold.value);
				propertySheet.properties.SetFloat("_Threshold", value);
				propertySheet.properties.SetFloat("_Blur", base.settings.blurAmount);
				propertySheet.properties.SetFloat("_Intensity", base.settings.intensity);
				context.command.GetTemporaryRT(aoTexID, context.width, context.height, 0, FilterMode.Bilinear, context.sourceFormat);
				context.command.BlitFullscreenTriangle(context.source, aoTexID, propertySheet, 0);
				int num = Shader.PropertyToID("_Temp1");
				int num2 = Shader.PropertyToID("_Temp2");
				command.GetTemporaryRT(num, context.screenWidth / (int)base.settings.downscaling, context.screenHeight / (int)base.settings.downscaling, 0, FilterMode.Bilinear);
				command.GetTemporaryRT(num2, context.screenWidth / (int)base.settings.downscaling, context.screenHeight / (int)base.settings.downscaling, 0, FilterMode.Bilinear);
				command.Blit(aoTexID, num);
				for (int i = 0; i < (int)base.settings.iterations; i++)
				{
					command.SetGlobalVector("_BlurOffsets", new Vector4((float)base.settings.blurAmount / (float)context.screenWidth, 0f, 0f, 0f));
					context.command.BlitFullscreenTriangle(num, num2, propertySheet, 1);
					command.SetGlobalVector("_BlurOffsets", new Vector4(0f, (float)base.settings.blurAmount / (float)context.screenHeight, 0f, 0f));
					context.command.BlitFullscreenTriangle(num2, num, propertySheet, 1);
				}
				context.command.SetGlobalTexture("_AO", num);
				context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, base.settings.aoOnly ? 3 : 2);
				context.command.ReleaseTemporaryRT(num);
				context.command.ReleaseTemporaryRT(num2);
				context.command.ReleaseTemporaryRT(aoTexID);
			}
		}
		[Serializable]
		[PostProcess(typeof(BlackBarsRenderer), PostProcessEvent.AfterStack, "SC Post Effects/Screen/Black Bars", true)]
		public sealed class BlackBars : PostProcessEffectSettings
		{
			public enum Direction
			{
				Horizontal,
				Vertical
			}

			[Serializable]
			public sealed class DirectionParam : ParameterOverride<Direction>
			{
			}

			[UnityEngine.Rendering.PostProcessing.DisplayName("Direction")]
			[Tooltip("")]
			public DirectionParam mode = new DirectionParam
			{
				value = Direction.Horizontal
			};

			[Range(0f, 1f)]
			[Tooltip("Size")]
			public FloatParameter size = new FloatParameter
			{
				value = 1f
			};

			[Range(0f, 1f)]
			[Tooltip("Max Size")]
			public FloatParameter maxSize = new FloatParameter
			{
				value = 0.33f
			};

			public override bool IsEnabledAndSupported(PostProcessRenderContext context)
			{
				if (enabled.value)
				{
					if ((float)size == 0f || (float)maxSize == 0f)
					{
						return false;
					}
					return true;
				}
				return false;
			}
		}
		internal sealed class BlackBarsRenderer : PostProcessEffectRenderer<BlackBars>
		{
			private Shader shader;

			public override void Init()
			{
				shader = Shader.Find("Hidden/SC Post Effects/Black Bars");
			}

			public override void Release()
			{
				base.Release();
			}

			public override void Render(PostProcessRenderContext context)
			{
				PropertySheet propertySheet = context.propertySheets.Get(shader);
				propertySheet.properties.SetVector("_Size", new Vector2((float)base.settings.size / 10f, (float)base.settings.maxSize * 5f));
				context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, (int)base.settings.mode.value);
			}
		}
		[Serializable]
		[PostProcess(typeof(BlurRenderer), PostProcessEvent.AfterStack, "SC Post Effects/Blurring/Blur", true)]
		public sealed class Blur : PostProcessEffectSettings
		{
			public enum BlurMethod
			{
				Gaussian,
				Box
			}

			[Serializable]
			public sealed class BlurMethodParameter : ParameterOverride<BlurMethod>
			{
			}

			[UnityEngine.Rendering.PostProcessing.DisplayName("Method")]
			[Tooltip("Box blurring uses fewer texture samples but has a limited blur range")]
			public BlurMethodParameter mode = new BlurMethodParameter
			{
				value = BlurMethod.Gaussian
			};

			[Tooltip("When enabled, the amount of blur passes is doubled")]
			public BoolParameter highQuality = new BoolParameter
			{
				value = false
			};

			[Space]
			[Range(0f, 5f)]
			[Tooltip("The amount of blurring that must be performed")]
			public FloatParameter amount = new FloatParameter
			{
				value = 3f
			};

			[Range(1f, 12f)]
			[Tooltip("The number of times the effect is blurred. More iterations provide a smoother effect but induce more drawcalls.")]
			public IntParameter iterations = new IntParameter
			{
				value = 6
			};

			[Range(1f, 8f)]
			[Tooltip("Every step halfs the resolution of the blur effect. Lower resolution provides a smoother blur but may induce flickering.")]
			public IntParameter downscaling = new IntParameter
			{
				value = 2
			};

			public override bool IsEnabledAndSupported(PostProcessRenderContext context)
			{
				if (enabled.value && (float)amount > 0f)
				{
					return true;
				}
				return false;
			}
		}
		internal sealed class BlurRenderer : PostProcessEffectRenderer<Blur>
		{
			private enum Pass
			{
				Blend,
				Gaussian,
				Box
			}

			private Shader shader;

			private int screenCopyID;

			public override void Init()
			{
				shader = Shader.Find("Hidden/SC Post Effects/Blur");
				screenCopyID = Shader.PropertyToID("_ScreenCopyTexture");
			}

			public override void Render(PostProcessRenderContext context)
			{
				PropertySheet propertySheet = context.propertySheets.Get(shader);
				CommandBuffer command = context.command;
				command.GetTemporaryRT(screenCopyID, context.width, context.height, 0, FilterMode.Bilinear, context.sourceFormat);
				command.BlitFullscreenTriangle(context.source, screenCopyID, propertySheet, 0);
				int num = Shader.PropertyToID("_Temp1");
				int num2 = Shader.PropertyToID("_Temp2");
				command.GetTemporaryRT(num, context.screenWidth / (int)base.settings.downscaling, context.screenHeight / (int)base.settings.downscaling, 0, FilterMode.Bilinear);
				command.GetTemporaryRT(num2, context.screenWidth / (int)base.settings.downscaling, context.screenHeight / (int)base.settings.downscaling, 0, FilterMode.Bilinear);
				command.Blit(screenCopyID, num);
				command.ReleaseTemporaryRT(screenCopyID);
				int pass = (((Blur.BlurMethod)base.settings.mode == Blur.BlurMethod.Gaussian) ? 1 : 2);
				for (int i = 0; i < (int)base.settings.iterations; i++)
				{
					if ((int)base.settings.iterations > 12)
					{
						return;
					}
					command.SetGlobalVector("_BlurOffsets", new Vector4((float)base.settings.amount / (float)context.screenWidth, 0f, 0f, 0f));
					context.command.BlitFullscreenTriangle(num, num2, propertySheet, pass);
					command.SetGlobalVector("_BlurOffsets", new Vector4(0f, (float)base.settings.amount / (float)context.screenHeight, 0f, 0f));
					context.command.BlitFullscreenTriangle(num2, num, propertySheet, pass);
					if ((bool)base.settings.highQuality)
					{
						command.SetGlobalVector("_BlurOffsets", new Vector4((float)base.settings.amount / (float)context.screenWidth, 0f, 0f, 0f));
						context.command.BlitFullscreenTriangle(num, num2, propertySheet, pass);
						command.SetGlobalVector("_BlurOffsets", new Vector4(0f, (float)base.settings.amount / (float)context.screenHeight, 0f, 0f));
						context.command.BlitFullscreenTriangle(num2, num, propertySheet, pass);
					}
				}
				command.BlitFullscreenTriangle(num, context.destination, propertySheet, 0);
				command.ReleaseTemporaryRT(num);
				command.ReleaseTemporaryRT(num2);
			}
		}
		[Serializable]
		[PostProcess(typeof(CloudShadowsRenderer), PostProcessEvent.BeforeStack, "SC Post Effects/Environment/Cloud Shadows", true)]
		public sealed class CloudShadows : PostProcessEffectSettings
		{
			[UnityEngine.Rendering.PostProcessing.DisplayName("Texture (R)")]
			[Tooltip("The red channel of this texture is used to sample the clouds")]
			public TextureParameter texture = new TextureParameter
			{
				value = null
			};

			[Space]
			[Range(0f, 1f)]
			[UnityEngine.Rendering.PostProcessing.DisplayName("Size")]
			public FloatParameter size = new FloatParameter
			{
				value = 0.5f
			};

			[Range(0f, 1f)]
			[UnityEngine.Rendering.PostProcessing.DisplayName("Density")]
			public FloatParameter density = new FloatParameter
			{
				value = 0.5f
			};

			[Range(0f, 1f)]
			[UnityEngine.Rendering.PostProcessing.DisplayName("Speed")]
			public FloatParameter speed = new FloatParameter
			{
				value = 0.5f
			};

			[UnityEngine.Rendering.PostProcessing.DisplayName("Direction")]
			[Tooltip("Set the X and Z world-space direction the clouds should move in")]
			public Vector2Parameter direction = new Vector2Parameter
			{
				value = new Vector2(0f, 1f)
			};

			public static bool isOrtho;

			public override bool IsEnabledAndSupported(PostProcessRenderContext context)
			{
				if (enabled.value)
				{
					if ((float)density == 0f || texture.value == null)
					{
						return false;
					}
					return true;
				}
				return false;
			}
		}
		internal sealed class CloudShadowsRenderer : PostProcessEffectRenderer<CloudShadows>
		{
			private Shader shader;

			public override void Init()
			{
				shader = Shader.Find("Hidden/SC Post Effects/Cloud Shadows");
			}

			public override void Release()
			{
				base.Release();
			}

			public override void Render(PostProcessRenderContext context)
			{
				PropertySheet propertySheet = context.propertySheets.Get(shader);
				_ = context.command;
				Camera camera = context.camera;
				CloudShadows.isOrtho = context.camera.orthographic;
				Texture value = ((base.settings.texture.value == null) ? RuntimeUtilities.whiteTexture : base.settings.texture.value);
				propertySheet.properties.SetTexture("_NoiseTex", value);
				Matrix4x4 gPUProjectionMatrix = GL.GetGPUProjectionMatrix(camera.projectionMatrix, renderIntoTexture: false);
				float value2 = (gPUProjectionMatrix[3, 2] = 0f);
				gPUProjectionMatrix[2, 3] = value2;
				gPUProjectionMatrix[3, 3] = 1f;
				Matrix4x4 value3 = Matrix4x4.Inverse(gPUProjectionMatrix * camera.worldToCameraMatrix) * Matrix4x4.TRS(new Vector3(0f, 0f, 0f - gPUProjectionMatrix[2, 2]), Quaternion.identity, Vector3.one);
				propertySheet.properties.SetMatrix("clipToWorld", value3);
				float num2 = (float)base.settings.speed * 0.1f;
				propertySheet.properties.SetVector("_CloudParams", new Vector4((float)base.settings.size * 0.01f, base.settings.direction.value.x * num2, base.settings.direction.value.y * num2, base.settings.density));
				context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0);
			}

			public override DepthTextureMode GetCameraFlags()
			{
				return DepthTextureMode.Depth;
			}
		}
		[Serializable]
		[PostProcess(typeof(ColorSplitRenderer), PostProcessEvent.AfterStack, "SC Post Effects/Retro/Color Split", true)]
		public sealed class ColorSplit : PostProcessEffectSettings
		{
			public enum SplitMode
			{
				Single,
				SingleBoxFiltered,
				Double,
				DoubleBoxFiltered
			}

			[Serializable]
			public sealed class SplitModeParam : ParameterOverride<SplitMode>
			{
			}

			[UnityEngine.Rendering.PostProcessing.DisplayName("Method")]
			[Tooltip("Box filtered methods provide a subtle blur effect and are less efficient")]
			public SplitModeParam mode = new SplitModeParam
			{
				value = SplitMode.Single
			};

			[Range(0f, 1f)]
			[Tooltip("The amount by which the color channels offset")]
			public FloatParameter offset = new FloatParameter
			{
				value = 1f
			};

			public override bool IsEnabledAndSupported(PostProcessRenderContext context)
			{
				if (enabled.value)
				{
					if ((float)offset == 0f)
					{
						return false;
					}
					return true;
				}
				return false;
			}
		}
		internal sealed class ColorSplitRenderer : PostProcessEffectRenderer<ColorSplit>
		{
			private Shader shader;

			public override void Init()
			{
				shader = Shader.Find("Hidden/SC Post Effects/Color Split");
			}

			public override void Release()
			{
				base.Release();
			}

			public override void Render(PostProcessRenderContext context)
			{
				PropertySheet propertySheet = context.propertySheets.Get(shader);
				propertySheet.properties.SetFloat("_Offset", (float)base.settings.offset / 100f);
				context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, (int)base.settings.mode.value);
			}
		}
		[Serializable]
		[PostProcess(typeof(ColorizeRenderer), PostProcessEvent.AfterStack, "SC Post Effects/Image/Colorize", true)]
		public sealed class Colorize : PostProcessEffectSettings
		{
			public enum BlendMode
			{
				Linear,
				Additive,
				Multiply,
				Screen
			}

			[Serializable]
			public sealed class BlendModeParameter : ParameterOverride<BlendMode>
			{
			}

			[Tooltip("Blends the gradient through various Photoshop-like blending modes")]
			public BlendModeParameter mode = new BlendModeParameter
			{
				value = BlendMode.Linear
			};

			[Range(0f, 1f)]
			[Tooltip("Fades the effect in or out")]
			public FloatParameter intensity = new FloatParameter
			{
				value = 1f
			};

			[Tooltip("Supply a gradient texture.\n\nLuminance values are colorized from left to right")]
			public TextureParameter colorRamp = new TextureParameter
			{
				value = null
			};

			public override bool IsEnabledAndSupported(PostProcessRenderContext context)
			{
				if (enabled.value)
				{
					if ((float)intensity == 0f || !colorRamp.value)
					{
						return false;
					}
					return true;
				}
				return false;
			}
		}
		internal sealed class ColorizeRenderer : PostProcessEffectRenderer<Colorize>
		{
			private Shader shader;

			public override void Init()
			{
				shader = Shader.Find("Hidden/SC Post Effects/Colorize");
			}

			public override void Release()
			{
				base.Release();
			}

			public override void Render(PostProcessRenderContext context)
			{
				PropertySheet propertySheet = context.propertySheets.Get(shader);
				if ((bool)base.settings.colorRamp.value)
				{
					propertySheet.properties.SetTexture("_ColorRamp", base.settings.colorRamp);
				}
				propertySheet.properties.SetFloat("_Intensity", base.settings.intensity);
				propertySheet.properties.SetFloat("_BlendMode", (float)base.settings.mode.value);
				context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0);
			}
		}
		[Serializable]
		[PostProcess(typeof(DangerRenderer), PostProcessEvent.AfterStack, "SC Post Effects/Screen/Danger", true)]
		public sealed class Danger : PostProcessEffectSettings
		{
			public TextureParameter overlayTex = new TextureParameter
			{
				value = null
			};

			public ColorParameter color = new ColorParameter
			{
				value = new Color(0.66f, 0f, 0f)
			};

			[Range(0f, 1f)]
			[UnityEngine.Rendering.PostProcessing.DisplayName("Opacity")]
			public FloatParameter intensity = new FloatParameter
			{
				value = 1f
			};

			[Range(0f, 1f)]
			[Tooltip("Size")]
			public FloatParameter size = new FloatParameter
			{
				value = 1f
			};

			public override bool IsEnabledAndSupported(PostProcessRenderContext context)
			{
				if (enabled.value)
				{
					if ((float)size == 0f || (float)intensity == 0f)
					{
						return false;
					}
					return true;
				}
				return false;
			}
		}
		internal sealed class DangerRenderer : PostProcessEffectRenderer<Danger>
		{
			private Shader shader;

			public override void Init()
			{
				shader = Shader.Find("Hidden/SC Post Effects/Danger");
			}

			public override void Release()
			{
				base.Release();
			}

			public override void Render(PostProcessRenderContext context)
			{
				PropertySheet propertySheet = context.propertySheets.Get(shader);
				propertySheet.properties.SetVector("_Params", new Vector4(base.settings.intensity, base.settings.size, 0f, 0f));
				propertySheet.properties.SetColor("_Color", base.settings.color);
				Texture value = ((base.settings.overlayTex.value == null) ? RuntimeUtilities.blackTexture : base.settings.overlayTex.value);
				propertySheet.properties.SetTexture("_Overlay", value);
				context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0);
			}
		}
		[Serializable]
		[PostProcess(typeof(DitheringRenderer), PostProcessEvent.AfterStack, "SC Post Effects/Retro/Dithering", true)]
		public sealed class Dithering : PostProcessEffectSettings
		{
			[UnityEngine.Rendering.PostProcessing.DisplayName("Pattern")]
			[Tooltip("Note that the texture's filter mode (Point or Bilinear) greatly affects the behavior of the pattern")]
			public TextureParameter lut = new TextureParameter
			{
				value = null
			};

			[Range(0f, 1f)]
			[Tooltip("The screen's luminance values control the density of the dithering matrix")]
			public FloatParameter luminanceThreshold = new FloatParameter
			{
				value = 0.5f
			};

			[Range(0f, 1f)]
			[Tooltip("Fades the effect in or out")]
			public FloatParameter intensity = new FloatParameter
			{
				value = 0.5f
			};

			[Range(0f, 2f)]
			[UnityEngine.Rendering.PostProcessing.DisplayName("Tiling")]
			public FloatParameter tiling = new FloatParameter
			{
				value = 1f
			};

			public override bool IsEnabledAndSupported(PostProcessRenderContext context)
			{
				if (enabled.value)
				{
					if ((float)intensity == 0f)
					{
						return false;
					}
					return true;
				}
				return false;
			}
		}
		internal sealed class DitheringRenderer : PostProcessEffectRenderer<Dithering>
		{
			private Shader shader;

			public override void Init()
			{
				shader = Shader.Find("Hidden/SC Post Effects/Dithering");
			}

			public override void Release()
			{
				base.Release();
			}

			public override void Render(PostProcessRenderContext context)
			{
				PropertySheet propertySheet = context.propertySheets.Get(shader);
				Texture value = ((base.settings.lut.value == null) ? RuntimeUtilities.blackTexture : base.settings.lut.value);
				propertySheet.properties.SetTexture("_LUT", value);
				float z = ((QualitySettings.activeColorSpace == ColorSpace.Gamma) ? Mathf.LinearToGammaSpace(base.settings.luminanceThreshold.value) : base.settings.luminanceThreshold.value);
				Vector4 value2 = new Vector4(0f, base.settings.tiling, z, base.settings.intensity);
				propertySheet.properties.SetVector("_Dithering_Coords", value2);
				context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0);
			}
		}
		[Serializable]
		[PostProcess(typeof(DoubleVisionRenderer), PostProcessEvent.AfterStack, "SC Post Effects/Blurring/Double Vision", true)]
		public sealed class DoubleVision : PostProcessEffectSettings
		{
			public enum Mode
			{
				FullScreen,
				Edges
			}

			[Serializable]
			public sealed class DoubleVisionMode : ParameterOverride<Mode>
			{
			}

			[UnityEngine.Rendering.PostProcessing.DisplayName("Method")]
			[Tooltip("Choose to apply the effect over the entire screen or just the edges")]
			public DoubleVisionMode mode = new DoubleVisionMode
			{
				value = Mode.FullScreen
			};

			[Range(0f, 1f)]
			[Tooltip("Intensity")]
			public FloatParameter intensity = new FloatParameter
			{
				value = 0.1f
			};

			public override bool IsEnabledAndSupported(PostProcessRenderContext context)
			{
				if (enabled.value)
				{
					if ((float)intensity == 0f)
					{
						return false;
					}
					return true;
				}
				return false;
			}
		}
		internal sealed class DoubleVisionRenderer : PostProcessEffectRenderer<DoubleVision>
		{
			private Shader DoubleVisionShader;

			public override void Init()
			{
				DoubleVisionShader = Shader.Find("Hidden/SC Post Effects/Double Vision");
			}

			public override void Release()
			{
				base.Release();
			}

			public override void Render(PostProcessRenderContext context)
			{
				PropertySheet propertySheet = context.propertySheets.Get(DoubleVisionShader);
				propertySheet.properties.SetFloat("_Amount", (float)base.settings.intensity / 10f);
				context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, (int)base.settings.mode.value);
			}
		}
		[Serializable]
		[PostProcess(typeof(EdgeDetectionRenderer), PostProcessEvent.BeforeStack, "SC Post Effects/Stylized/Edge Detection", true)]
		public sealed class EdgeDetection : PostProcessEffectSettings
		{
			public enum EdgeDetectMode
			{
				DepthNormals,
				CrossDepthNormals,
				SobelDepth,
				LuminanceBased
			}

			[Serializable]
			public sealed class EdgeDetectionMode : ParameterOverride<EdgeDetectMode>
			{
			}

			[Range(0f, 1f)]
			[UnityEngine.Rendering.PostProcessing.DisplayName("Edges Only")]
			[Tooltip("Shows only the effect, to alow for finetuning")]
			public BoolParameter debug = new BoolParameter
			{
				value = false
			};

			[Space]
			[Tooltip("Choose one of the different edge solvers")]
			public EdgeDetectionMode mode = new EdgeDetectionMode
			{
				value = EdgeDetectMode.DepthNormals
			};

			public BoolParameter invertFadeDistance = new BoolParameter
			{
				value = false
			};

			[UnityEngine.Rendering.PostProcessing.Min(0.01f)]
			[Range(0.01f, 10000f)]
			[Tooltip("Fades out the effect between the cameras near and far clipping plane")]
			public FloatParameter fadeDistance = new FloatParameter
			{
				value = 1000f
			};

			[Header("Sensitivity")]
			[UnityEngine.Rendering.PostProcessing.DisplayName("Depth")]
			[Range(0f, 1f)]
			[Tooltip("Sets how much difference in depth between pixels contribute to drawing an edge")]
			public FloatParameter sensitivityDepth = new FloatParameter
			{
				value = 0f
			};

			[UnityEngine.Rendering.PostProcessing.DisplayName("Normals")]
			[Range(0f, 1f)]
			[Tooltip("Sets how much difference in normals between pixels contribute to drawing an edge")]
			public FloatParameter sensitivityNormals = new FloatParameter
			{
				value = 1f
			};

			[Range(0.01f, 1f)]
			[UnityEngine.Rendering.PostProcessing.DisplayName("Luminance Threshold")]
			[Tooltip("Luminance threshold, pixels above this threshold will contribute to the effect")]
			public FloatParameter lumThreshold = new FloatParameter
			{
				value = 0.01f
			};

			[Header("Edges")]
			[UnityEngine.Rendering.PostProcessing.DisplayName("Color")]
			[Tooltip("")]
			public ColorParameter edgeColor = new ColorParameter
			{
				value = Color.black
			};

			[Range(1f, 50f)]
			[Tooltip("Edge Exponent")]
			public FloatParameter edgeExp = new FloatParameter
			{
				value = 1f
			};

			[UnityEngine.Rendering.PostProcessing.DisplayName("Size")]
			[Range(1f, 4f)]
			[Tooltip("Edge Distance")]
			public IntParameter edgeSize = new IntParameter
			{
				value = 1
			};

			[UnityEngine.Rendering.PostProcessing.DisplayName("Opacity")]
			[Range(0f, 1f)]
			[Tooltip("Opacity")]
			public FloatParameter edgeOpacity = new FloatParameter
			{
				value = 1f
			};

			[UnityEngine.Rendering.PostProcessing.DisplayName("Thin")]
			[Tooltip("Limit the effect to inward edges only")]
			public BoolParameter sobelThin = new BoolParameter
			{
				value = false
			};

			public override bool IsEnabledAndSupported(PostProcessRenderContext context)
			{
				if (enabled.value && (float)edgeOpacity > 0f)
				{
					return true;
				}
				return false;
			}
		}
		internal sealed class EdgeDetectionRenderer : PostProcessEffectRenderer<EdgeDetection>
		{
			private Shader shader;

			public override void Init()
			{
				shader = Shader.Find("Hidden/SC Post Effects/Edge Detection");
			}

			public override void Release()
			{
				base.Release();
			}

			public override void Render(PostProcessRenderContext context)
			{
				PropertySheet propertySheet = context.propertySheets.Get(shader);
				_ = context.command;
				Vector2 vector = new Vector2(base.settings.sensitivityDepth, base.settings.sensitivityNormals);
				propertySheet.properties.SetVector("_Sensitivity", vector);
				propertySheet.properties.SetFloat("_BackgroundFade", base.settings.debug ? 1f : 0f);
				propertySheet.properties.SetFloat("_EdgeSize", (int)base.settings.edgeSize);
				propertySheet.properties.SetFloat("_Exponent", base.settings.edgeExp);
				propertySheet.properties.SetFloat("_Threshold", base.settings.lumThreshold);
				propertySheet.properties.SetColor("_EdgeColor", base.settings.edgeColor);
				float x = (context.camera.orthographic ? ((float)base.settings.fadeDistance * 1E-10f) : ((float)base.settings.fadeDistance));
				propertySheet.properties.SetVector("_DistanceParams", new Vector4(x, base.settings.invertFadeDistance ? 1 : 0, 0f, 0f));
				propertySheet.properties.SetVector("_SobelParams", new Vector4(base.settings.sobelThin ? 1 : 0, 0f, 0f, 0f));
				context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, (int)base.settings.mode.value);
			}

			public override DepthTextureMode GetCameraFlags()
			{
				return DepthTextureMode.DepthNormals;
			}
		}
		[Serializable]
		[PostProcess(typeof(FogRenderer), PostProcessEvent.BeforeStack, "SC Post Effects/Environment/Screen-Space Fog", true)]
		public sealed class Fog : PostProcessEffectSettings
		{
			[Serializable]
			public sealed class FogModeParameter : ParameterOverride<FogMode>
			{
			}

			public enum FogColorSource
			{
				UniformColor,
				GradientTexture,
				SkyboxColor
			}

			[Serializable]
			public sealed class FogColorSourceParameter : ParameterOverride<FogColorSource>
			{
			}

			public TextureParameter skyboxTex = new TextureParameter
			{
				value = null
			};

			[UnityEngine.Rendering.PostProcessing.DisplayName("Use scene's settings")]
			[Tooltip("Use the settings of the current active scene found under the Lighting tab\n\nThis is also advisable for third-party scripts that modify fog settings\n\nThis will force the effect to use the scene's fog color")]
			public BoolParameter useSceneSettings = new BoolParameter
			{
				value = false
			};

			[UnityEngine.Rendering.PostProcessing.DisplayName("Mode")]
			[Tooltip("Sets how the fog distance is calculated")]
			public FogModeParameter fogMode = new FogModeParameter
			{
				value = FogMode.Exponential
			};

			[Range(0f, 1f)]
			public FloatParameter globalDensity = new FloatParameter
			{
				value = 0.2f
			};

			[UnityEngine.Rendering.PostProcessing.DisplayName("Start")]
			public FloatParameter fogStartDistance = new FloatParameter
			{
				value = 170f
			};

			[UnityEngine.Rendering.PostProcessing.DisplayName("End")]
			public FloatParameter fogEndDistance = new FloatParameter
			{
				value = 600f
			};

			[Space]
			[Tooltip("Color: use a uniform color for the fog\n\nGradient: sample a gradient texture to control the fog color over distance, the alpha channel controls the density\n\nSkybox: Sample the skybox's color for the fog, only works well with low detail skies")]
			public FogColorSourceParameter colorSource = new FogColorSourceParameter
			{
				value = FogColorSource.UniformColor
			};

			[UnityEngine.Rendering.PostProcessing.DisplayName("Mipmap")]
			[Tooltip("Set the mipmap level for the skybox texture")]
			[Range(0f, 8f)]
			public FloatParameter skyboxMipLevel = new FloatParameter
			{
				value = 0f
			};

			[UnityEngine.Rendering.PostProcessing.DisplayName("Color")]
			[ColorUsage(true, true)]
			public ColorParameter fogColor = new ColorParameter
			{
				value = new Color(0.76f, 0.94f, 1f, 1f)
			};

			[UnityEngine.Rendering.PostProcessing.DisplayName("Texture")]
			public TextureParameter fogColorGradient = new TextureParameter
			{
				value = null
			};

			[Tooltip("Automatic mode uses the current camera's far clipping plane to set the max distance\n\nOtherwise, a fixed value may be used instead")]
			public FloatParameter gradientDistance = new FloatParameter
			{
				value = 1000f
			};

			public BoolParameter gradientUseFarClipPlane = new BoolParameter
			{
				value = true
			};

			[Header("Distance")]
			[UnityEngine.Rendering.PostProcessing.DisplayName("Enable")]
			public BoolParameter distanceFog = new BoolParameter
			{
				value = true
			};

			[Range(0.001f, 1f)]
			[UnityEngine.Rendering.PostProcessing.DisplayName("Density")]
			public FloatParameter distanceDensity = new FloatParameter
			{
				value = 1f
			};

			[Tooltip("Distance based on radial distance from viewer, rather than parrallel")]
			public BoolParameter useRadialDistance = new BoolParameter
			{
				value = true
			};

			[Header("Skybox")]
			[Range(0f, 1f)]
			[Tooltip("Determines how much the fog influences the skybox")]
			public FloatParameter skyboxInfluence = new FloatParameter
			{
				value = 1f
			};

			[Header("Height")]
			[UnityEngine.Rendering.PostProcessing.DisplayName("Enable")]
			[Tooltip("Enable vertical height fog")]
			public BoolParameter heightFog = new BoolParameter
			{
				value = true
			};

			[Tooltip("Height relative to 0 world height position")]
			public FloatParameter height = new FloatParameter
			{
				value = 10f
			};

			[Range(0.001f, 1f)]
			[UnityEngine.Rendering.PostProcessing.DisplayName("Density")]
			public FloatParameter heightDensity = new FloatParameter
			{
				value = 0.75f
			};

			[Header("Height noise (2D)")]
			[UnityEngine.Rendering.PostProcessing.DisplayName("Enable")]
			[Tooltip("Enables height fog density variation through the use of a texture")]
			public BoolParameter heightFogNoise = new BoolParameter
			{
				value = false
			};

			[UnityEngine.Rendering.PostProcessing.DisplayName("Texture (R)")]
			[Tooltip("The density is read from this texture's red color channel")]
			public TextureParameter heightNoiseTex = new TextureParameter
			{
				value = null
			};

			[Range(0f, 1f)]
			[UnityEngine.Rendering.PostProcessing.DisplayName("Size")]
			public FloatParameter heightNoiseSize = new FloatParameter
			{
				value = 0.25f
			};

			[Range(0f, 1f)]
			[UnityEngine.Rendering.PostProcessing.DisplayName("Strength")]
			public FloatParameter heightNoiseStrength = new FloatParameter
			{
				value = 1f
			};

			[Range(0f, 10f)]
			[UnityEngine.Rendering.PostProcessing.DisplayName("Speed")]
			public FloatParameter heightNoiseSpeed = new FloatParameter
			{
				value = 2f
			};

			[Header("Light scattering")]
			[UnityEngine.Rendering.PostProcessing.DisplayName("Enable")]
			[Tooltip("Execute a bloom pass to diffuse light in dense fog")]
			public BoolParameter lightScattering = new BoolParameter
			{
				value = false
			};

			[Space]
			[UnityEngine.Rendering.PostProcessing.Min(0f)]
			[UnityEngine.Rendering.PostProcessing.DisplayName("Intensity")]
			public FloatParameter scatterIntensity = new FloatParameter
			{
				value = 10f
			};

			[UnityEngine.Rendering.PostProcessing.Min(0f)]
			[UnityEngine.Rendering.PostProcessing.DisplayName("Threshold")]
			[Tooltip("Filters out pixels under this level of brightness. Value is in gamma-space.")]
			public FloatParameter scatterThreshold = new FloatParameter
			{
				value = 1f
			};

			[Range(1f, 10f)]
			[UnityEngine.Rendering.PostProcessing.DisplayName("Diffusion")]
			public FloatParameter scatterDiffusion = new FloatParameter
			{
				value = 10f
			};

			[Range(0f, 1f)]
			[UnityEngine.Rendering.PostProcessing.DisplayName("Smoothness")]
			[Tooltip("Makes transitions between under/over-threshold gradual. 0 for a hard threshold, 1 for a soft threshold).")]
			public FloatParameter scatterSoftKnee = new FloatParameter
			{
				value = 0.5f
			};

			public override bool IsEnabledAndSupported(PostProcessRenderContext context)
			{
				return enabled.value;
			}
		}
		internal sealed class FogRenderer : PostProcessEffectRenderer<Fog>
		{
			private struct MipLevel
			{
				internal int down;

				internal int up;
			}

			private enum Pass
			{
				Prefilter,
				Downsample,
				Upsample,
				Blend,
				BlendScattering
			}

			private Shader shader;

			private MipLevel[] m_Pyramid;

			private const int k_MaxPyramidSize = 16;

			public static Dictionary<Camera, RenderScreenSpaceSkybox> skyboxCams = new Dictionary<Camera, RenderScreenSpaceSkybox>();

			public override void Init()
			{
				shader = Shader.Find("Hidden/SC Post Effects/Fog");
				m_Pyramid = new MipLevel[16];
				for (int i = 0; i < 16; i++)
				{
					m_Pyramid[i] = new MipLevel
					{
						down = Shader.PropertyToID("_BloomMipDown" + i),
						up = Shader.PropertyToID("_BloomMipUp" + i)
					};
				}
			}

			public override void Release()
			{
				base.Release();
			}

			public override void Render(PostProcessRenderContext context)
			{
				PropertySheet propertySheet = context.propertySheets.Get(shader);
				CommandBuffer command = context.command;
				Camera camera = context.camera;
				if (base.settings.colorSource.value == Fog.FogColorSource.SkyboxColor)
				{
					if (camera.hideFlags != 0 && camera.name != "SceneCamera")
					{
						return;
					}
					if (!skyboxCams.ContainsKey(camera))
					{
						skyboxCams[camera] = camera.gameObject.GetComponent<RenderScreenSpaceSkybox>();
						if (!skyboxCams[camera])
						{
							skyboxCams[camera] = camera.gameObject.AddComponent<RenderScreenSpaceSkybox>();
						}
						skyboxCams[camera].manuallyAdded = false;
					}
				}
				Matrix4x4 gPUProjectionMatrix = GL.GetGPUProjectionMatrix(camera.projectionMatrix, renderIntoTexture: false);
				float value = (gPUProjectionMatrix[3, 2] = 0f);
				gPUProjectionMatrix[2, 3] = value;
				gPUProjectionMatrix[3, 3] = 1f;
				Matrix4x4 value2 = Matrix4x4.Inverse(gPUProjectionMatrix * camera.worldToCameraMatrix) * Matrix4x4.TRS(new Vector3(0f, 0f, 0f - gPUProjectionMatrix[2, 2]), Quaternion.identity, Vector3.one);
				propertySheet.properties.SetMatrix("clipToWorld", value2);
				float num2 = camera.transform.position.y - (float)base.settings.height;
				float z = ((num2 <= 0f) ? 1f : 0f);
				float x = (base.settings.lightScattering ? 1f : ((float)base.settings.skyboxInfluence));
				float z2 = (base.settings.distanceFog ? 1f : 0f);
				float w = (base.settings.heightFog ? 1f : 0f);
				int num3 = (int)((!base.settings.useSceneSettings) ? base.settings.colorSource.value : Fog.FogColorSource.UniformColor);
				FogMode fogMode = (base.settings.useSceneSettings ? RenderSettings.fogMode : ((FogMode)base.settings.fogMode));
				float num4 = (base.settings.useSceneSettings ? RenderSettings.fogDensity : ((float)base.settings.globalDensity / 100f));
				float num5 = (base.settings.useSceneSettings ? RenderSettings.fogStartDistance : ((float)base.settings.fogStartDistance));
				float num6 = (base.settings.useSceneSettings ? RenderSettings.fogEndDistance : ((float)base.settings.fogEndDistance));
				bool flag = fogMode == FogMode.Linear;
				float num7 = (flag ? (num6 - num5) : 0f);
				float num8 = ((Mathf.Abs(num7) > 0.0001f) ? (1f / num7) : 0f);
				Vector4 value3 = default(Vector4);
				value3.x = num4 * 1.2011224f;
				value3.y = num4 * 1.442695f;
				value3.z = (flag ? (0f - num8) : 0f);
				value3.w = (flag ? (num6 * num8) : 0f);
				float value4 = (base.settings.gradientUseFarClipPlane.value ? ((float)base.settings.gradientDistance) : context.camera.farClipPlane);
				if ((bool)base.settings.heightNoiseTex.value)
				{
					propertySheet.properties.SetTexture("_NoiseTex", base.settings.heightNoiseTex);
				}
				if ((bool)base.settings.fogColorGradient.value)
				{
					propertySheet.properties.SetTexture("_ColorGradient", base.settings.fogColorGradient);
				}
				propertySheet.properties.SetFloat("_FarClippingPlane", value4);
				propertySheet.properties.SetVector("_SceneFogParams", value3);
				propertySheet.properties.SetVector("_SceneFogMode", new Vector4((float)fogMode, base.settings.useRadialDistance ? 1 : 0, num3, base.settings.heightFogNoise ? 1 : 0));
				propertySheet.properties.SetVector("_NoiseParams", new Vector4((float)base.settings.heightNoiseSize * 0.01f, (float)base.settings.heightNoiseSpeed * 0.01f, base.settings.heightNoiseStrength, 0f));
				propertySheet.properties.SetVector("_DensityParams", new Vector4(base.settings.distanceDensity, base.settings.heightNoiseStrength, base.settings.skyboxMipLevel, 0f));
				propertySheet.properties.SetVector("_HeightParams", new Vector4(base.settings.height, num2, z, (float)base.settings.heightDensity * 0.5f));
				propertySheet.properties.SetVector("_DistanceParams", new Vector4(0f - num5, 0f, z2, w));
				propertySheet.properties.SetColor("_FogColor", base.settings.useSceneSettings ? RenderSettings.fogColor : ((Color)base.settings.fogColor));
				propertySheet.properties.SetVector("_SkyboxParams", new Vector4(x, base.settings.skyboxMipLevel, 0f, 0f));
				bool flag2 = (base.settings.lightScattering ? true : false);
				if (flag2)
				{
					int num9 = Mathf.FloorToInt((float)context.screenWidth / 2f);
					int num10 = Mathf.FloorToInt((float)context.screenHeight / 2f);
					bool flag3 = context.stereoActive && context.stereoRenderingMode == PostProcessRenderContext.StereoRenderingMode.SinglePass && context.camera.stereoTargetEye == StereoTargetEyeMask.Both;
					int num11 = (flag3 ? (num9 * 2) : num9);
					float num12 = Mathf.Log(Mathf.Max(num9, num10), 2f) + Mathf.Min(base.settings.scatterDiffusion.value, 10f) - 10f;
					int num13 = Mathf.FloorToInt(num12);
					int num14 = Mathf.Clamp(num13, 1, 16);
					float num15 = 0.5f + num12 - (float)num13;
					propertySheet.properties.SetFloat("_SampleScale", num15);
					float num16 = Mathf.GammaToLinearSpace(base.settings.scatterThreshold.value);
					float num17 = num16 * base.settings.scatterSoftKnee.value + 1E-05f;
					Vector4 value5 = new Vector4(num16, num16 - num17, num17 * 2f, 0.25f / num17);
					propertySheet.properties.SetVector("_Threshold", value5);
					RenderTargetIdentifier source = context.source;
					for (int i = 0; i < num14; i++)
					{
						int down = m_Pyramid[i].down;
						int up = m_Pyramid[i].up;
						int pass = ((i != 0) ? 1 : 0);
						context.GetScreenSpaceTemporaryRT(command, down, 0, context.sourceFormat, RenderTextureReadWrite.Default, FilterMode.Bilinear, num11, num10);
						context.GetScreenSpaceTemporaryRT(command, up, 0, context.sourceFormat, RenderTextureReadWrite.Default, FilterMode.Bilinear, num11, num10);
						command.BlitFullscreenTriangle(source, down, propertySheet, pass);
						source = down;
						num11 = ((flag3 && num11 / 2 % 2 > 0) ? (1 + num11 / 2) : (num11 / 2));
						num11 = Mathf.Max(num11, 1);
						num10 = Mathf.Max(num10 / 2, 1);
					}
					int num18 = m_Pyramid[num14 - 1].down;
					for (int num19 = num14 - 2; num19 >= 0; num19--)
					{
						int down2 = m_Pyramid[num19].down;
						int up2 = m_Pyramid[num19].up;
						command.SetGlobalTexture("_BloomTex", down2);
						command.BlitFullscreenTriangle(num18, up2, propertySheet, 2);
						num18 = up2;
					}
					float y = RuntimeUtilities.Exp2(base.settings.scatterIntensity.value / 10f) - 1f;
					Vector4 value6 = new Vector4(num15, y, 0f, num14);
					propertySheet.properties.SetVector("_ScatteringParams", value6);
					command.SetGlobalTexture("_BloomTex", num18);
					for (int j = 0; j < num14; j++)
					{
						if (m_Pyramid[j].down != num18)
						{
							command.ReleaseTemporaryRT(m_Pyramid[j].down);
						}
						if (m_Pyramid[j].up != num18)
						{
							command.ReleaseTemporaryRT(m_Pyramid[j].up);
						}
					}
				}
				context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, flag2 ? 4 : 3);
			}

			public override DepthTextureMode GetCameraFlags()
			{
				return DepthTextureMode.Depth;
			}
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(Camera))]
		public class RenderScreenSpaceSkybox : MonoBehaviour
		{
			private Camera thisCam;

			private Camera skyboxCam;

			private RenderTexture skyboxRT;

			private const string RENDER_TAG = "[SCPE] Render skybox to texture";

			private CommandBuffer cmd;

			private int skyboxTexID;

			private const string texName = "_SkyboxTex";

			private const int downsamples = 2;

			public bool manuallyAdded = true;

			private void OnEnable()
			{
				cmd = new CommandBuffer();
				cmd.name = "[SCPE] Render skybox to texture";
				if (!thisCam)
				{
					thisCam = GetComponent<Camera>();
				}
				if (!skyboxCam)
				{
					CreateSkyboxCamera();
				}
			}

			private void Update()
			{
				if ((bool)thisCam)
				{
					CopyCameraSettings(thisCam, skyboxCam);
				}
			}

			private void CreateSkyboxCamera()
			{
				GameObject gameObject = new GameObject("Skybox renderer for " + thisCam.name);
				skyboxCam = gameObject.AddComponent<Camera>();
				gameObject.hideFlags = HideFlags.HideAndDontSave;
				skyboxCam.hideFlags = HideFlags.NotEditable;
				skyboxCam.useOcclusionCulling = false;
				skyboxCam.depth = -100f;
				skyboxCam.allowMSAA = false;
				skyboxCam.cullingMask = 0;
				skyboxCam.clearFlags = CameraClearFlags.Skybox;
				skyboxCam.nearClipPlane = 0.01f;
				skyboxCam.farClipPlane = 1f;
				CreateSkyboxRT();
				skyboxCam.AddCommandBuffer(CameraEvent.AfterSkybox, cmd);
				skyboxCam.targetTexture = skyboxRT;
			}

			private void CreateSkyboxRT()
			{
				skyboxRT = new RenderTexture(thisCam.pixelWidth / 2, thisCam.pixelHeight / 2, 0, RenderTextureFormat.ARGB32);
				skyboxRT.filterMode = FilterMode.Trilinear;
				skyboxRT.useMipMap = true;
				skyboxRT.autoGenerateMips = true;
				skyboxRT.Create();
				cmd.Blit(BuiltinRenderTextureType.CurrentActive, skyboxRT);
				cmd.SetGlobalTexture("_SkyboxTex", skyboxRT);
			}

			public void OnDestroy()
			{
				if ((bool)skyboxCam)
				{
					skyboxCam.RemoveCommandBuffer(CameraEvent.AfterSkybox, cmd);
				}
			}

			private static void CopyCameraSettings(Camera src, Camera dest)
			{
				if (!(dest == null))
				{
					dest.transform.position = src.transform.position;
					dest.transform.rotation = src.transform.rotation;
					dest.fieldOfView = src.fieldOfView;
					dest.aspect = src.aspect;
					dest.orthographic = src.orthographic;
					dest.orthographicSize = src.orthographicSize;
					dest.renderingPath = src.renderingPath;
					dest.targetDisplay = src.targetDisplay;
				}
			}
		}
		[Serializable]
		[PostProcess(typeof(GradientRenderer), PostProcessEvent.AfterStack, "SC Post Effects/Screen/Gradient", true)]
		public sealed class Gradient : PostProcessEffectSettings
		{
			public enum Mode
			{
				ColorFields,
				Texture
			}

			[Serializable]
			public sealed class GradientModeParameter : ParameterOverride<Mode>
			{
			}

			public enum BlendMode
			{
				Linear,
				Additive,
				Multiply,
				Screen
			}

			[Serializable]
			public sealed class BlendModeParameter : ParameterOverride<BlendMode>
			{
			}

			[Range(0f, 1f)]
			[UnityEngine.Rendering.PostProcessing.DisplayName("Opacity")]
			public FloatParameter intensity = new FloatParameter
			{
				value = 1f
			};

			[Space]
			[Tooltip("Set the color either through 2 color fields, or a gradient texture")]
			public GradientModeParameter input = new GradientModeParameter
			{
				value = Mode.ColorFields
			};

			[Tooltip("The color's alpha channel controls its opacity")]
			public ColorParameter color1 = new ColorParameter
			{
				value = new Color(0f, 0.8f, 0.56f, 0.5f)
			};

			[Tooltip("The color's alpha channel controls its opacity")]
			public ColorParameter color2 = new ColorParameter
			{
				value = new Color(0.81f, 0.37f, 1f, 0.5f)
			};

			[Range(0f, 1f)]
			[Space]
			[Tooltip("Controls the rotation of the gradient")]
			public FloatParameter rotation = new FloatParameter
			{
				value = 0f
			};

			[UnityEngine.Rendering.PostProcessing.DisplayName("Gradient")]
			[Tooltip("")]
			public TextureParameter gradientTex = new TextureParameter
			{
				value = null
			};

			[Tooltip("Blends the gradient through various Photoshop-like blending modes")]
			public BlendModeParameter mode = new BlendModeParameter
			{
				value = BlendMode.Linear
			};

			private const int RESOLUTION = 64;

			public override bool IsEnabledAndSupported(PostProcessRenderContext context)
			{
				if (enabled.value)
				{
					if ((float)intensity == 0f || (input.value == Mode.Texture && gradientTex.value == null))
					{
						return false;
					}
					return true;
				}
				return false;
			}
		}
		internal sealed class GradientRenderer : PostProcessEffectRenderer<Gradient>
		{
			private Shader shader;

			public override void Init()
			{
				shader = Shader.Find("Hidden/SC Post Effects/Gradient");
			}

			public override void Release()
			{
				base.Release();
			}

			public override void Render(PostProcessRenderContext context)
			{
				PropertySheet propertySheet = context.propertySheets.Get(shader);
				if ((bool)base.settings.gradientTex.value)
				{
					propertySheet.properties.SetTexture("_Gradient", base.settings.gradientTex);
				}
				propertySheet.properties.SetColor("_Color1", base.settings.color1);
				propertySheet.properties.SetColor("_Color2", base.settings.color2);
				propertySheet.properties.SetFloat("_Rotation", (float)base.settings.rotation * 6f);
				propertySheet.properties.SetFloat("_Intensity", base.settings.intensity);
				propertySheet.properties.SetFloat("_BlendMode", (float)base.settings.mode.value);
				context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, (int)base.settings.input.value);
			}
		}
		[Serializable]
		[PostProcess(typeof(HueShift3DRenderer), PostProcessEvent.AfterStack, "SC Post Effects/Image/3D Hue Shift", true)]
		public sealed class HueShift3D : PostProcessEffectSettings
		{
			[Range(0f, 1f)]
			[UnityEngine.Rendering.PostProcessing.DisplayName("Opacity")]
			public FloatParameter intensity = new FloatParameter
			{
				value = 0.33f
			};

			[Range(0f, 1f)]
			[Tooltip("Speed")]
			public FloatParameter speed = new FloatParameter
			{
				value = 0.3f
			};

			[Range(0f, 3f)]
			[Tooltip("Size")]
			public FloatParameter size = new FloatParameter
			{
				value = 1f
			};

			[UnityEngine.Rendering.PostProcessing.DisplayName("Geometry normal influence")]
			[Range(0f, 10f)]
			[Tooltip("Bends the effect over the scene's geometry normals\n\nHigh values may induce banding artifacts")]
			public FloatParameter geoInfluence = new FloatParameter
			{
				value = 5f
			};

			public static bool isOrtho;

			public override bool IsEnabledAndSupported(PostProcessRenderContext context)
			{
				if (enabled.value)
				{
					if ((float)intensity == 0f)
					{
						return false;
					}
					return true;
				}
				return false;
			}
		}
		internal sealed class HueShift3DRenderer : PostProcessEffectRenderer<HueShift3D>
		{
			private Shader shader;

			public override void Init()
			{
				shader = Shader.Find("Hidden/SC Post Effects/3D Hue Shift");
			}

			public override void Release()
			{
				base.Release();
			}

			public override void Render(PostProcessRenderContext context)
			{
				PropertySheet propertySheet = context.propertySheets.Get(shader);
				HueShift3D.isOrtho = context.camera.orthographic;
				propertySheet.properties.SetVector("_Params", new Vector4(base.settings.speed, base.settings.size, base.settings.geoInfluence, base.settings.intensity));
				context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0);
			}

			public override DepthTextureMode GetCameraFlags()
			{
				return DepthTextureMode.DepthNormals;
			}
		}
		[Serializable]
		[PostProcess(typeof(InvertRenderer), PostProcessEvent.AfterStack, "SC Post Effects/Misc/Invert", true)]
		public sealed class Invert : PostProcessEffectSettings
		{
			[Range(0f, 1f)]
			public FloatParameter amount = new FloatParameter
			{
				value = 1f
			};

			public override bool IsEnabledAndSupported(PostProcessRenderContext context)
			{
				if (enabled.value)
				{
					if ((float)amount == 0f)
					{
						return false;
					}
					return true;
				}
				return false;
			}
		}
		internal sealed class InvertRenderer : PostProcessEffectRenderer<Invert>
		{
			private Shader shader;

			public override void Init()
			{
				shader = Shader.Find("Hidden/SC Post Effects/Invert");
			}

			public override void Release()
			{
				base.Release();
			}

			public override void Render(PostProcessRenderContext context)
			{
				PropertySheet propertySheet = context.propertySheets.Get(shader);
				propertySheet.properties.SetFloat("_Amount", base.settings.amount);
				context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0);
			}
		}
		[Serializable]
		[PostProcess(typeof(KaleidoscopeRenderer), PostProcessEvent.AfterStack, "SC Post Effects/Misc/Kaleidoscope", true)]
		public sealed class Kaleidoscope : PostProcessEffectSettings
		{
			[Range(0f, 10f)]
			[Tooltip("The number of times the screen is split up")]
			public IntParameter splits = new IntParameter
			{
				value = 5
			};

			public override bool IsEnabledAndSupported(PostProcessRenderContext context)
			{
				if (enabled.value)
				{
					if ((int)splits == 0)
					{
						return false;
					}
					return true;
				}
				return false;
			}
		}
		internal sealed class KaleidoscopeRenderer : PostProcessEffectRenderer<Kaleidoscope>
		{
			private Shader shader;

			public override void Init()
			{
				shader = Shader.Find("Hidden/SC Post Effects/Kaleidoscope");
			}

			public override void Release()
			{
				base.Release();
			}

			public override void Render(PostProcessRenderContext context)
			{
				PropertySheet propertySheet = context.propertySheets.Get(shader);
				propertySheet.properties.SetFloat("_Splits", (float)Math.PI * 2f / (float)Mathf.Max(1, base.settings.splits));
				context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0);
			}
		}
		[Serializable]
		[PostProcess(typeof(KuwaharaRenderer), PostProcessEvent.AfterStack, "SC Post Effects/Stylized/Kuwahara", true)]
		public sealed class Kuwahara : PostProcessEffectSettings
		{
			public enum KuwaharaMode
			{
				Regular,
				DepthFade
			}

			[Serializable]
			public sealed class KuwaharaModeParam : ParameterOverride<KuwaharaMode>
			{
			}

			[UnityEngine.Rendering.PostProcessing.DisplayName("Method")]
			[Tooltip("Choose to apply the effect to the entire screen, or fade in/out over a distance")]
			public KuwaharaModeParam mode = new KuwaharaModeParam
			{
				value = KuwaharaMode.Regular
			};

			[Range(0f, 8f)]
			[UnityEngine.Rendering.PostProcessing.DisplayName("Radius")]
			public IntParameter radius = new IntParameter
			{
				value = 5
			};

			public BoolParameter invertFadeDistance = new BoolParameter
			{
				value = false
			};

			[UnityEngine.Rendering.PostProcessing.DisplayName("Fade distance")]
			public FloatParameter fadeDistance = new FloatParameter
			{
				value = 1000f
			};

			public override bool IsEnabledAndSupported(PostProcessRenderContext context)
			{
				if (enabled.value)
				{
					if ((int)radius == 0)
					{
						return false;
					}
					return true;
				}
				return false;
			}
		}
		internal sealed class KuwaharaRenderer : PostProcessEffectRenderer<Kuwahara>
		{
			private Shader KuwaharaShader;

			public override void Init()
			{
				KuwaharaShader = Shader.Find("Hidden/SC Post Effects/Kuwahara");
			}

			public override void Release()
			{
				base.Release();
			}

			public override void Render(PostProcessRenderContext context)
			{
				if (context.camera.orthographic)
				{
					base.settings.mode.value = Kuwahara.KuwaharaMode.Regular;
				}
				PropertySheet propertySheet = context.propertySheets.Get(KuwaharaShader);
				propertySheet.properties.SetFloat("_Radius", (int)base.settings.radius);
				propertySheet.properties.SetFloat("_FadeDistance", base.settings.fadeDistance);
				propertySheet.properties.SetVector("_DistanceParams", new Vector4(base.settings.fadeDistance, base.settings.invertFadeDistance ? 1 : 0, 0f, 0f));
				context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, (int)base.settings.mode.value);
			}

			public override DepthTextureMode GetCameraFlags()
			{
				if (base.settings.mode.value == Kuwahara.KuwaharaMode.DepthFade)
				{
					return DepthTextureMode.Depth;
				}
				return DepthTextureMode.None;
			}
		}
		[Serializable]
		[PostProcess(typeof(LUTRenderer), PostProcessEvent.AfterStack, "SC Post Effects/Image/Color Grading LUT", true)]
		public sealed class LUT : PostProcessEffectSettings
		{
			public enum Mode
			{
				Single,
				DistanceBased
			}

			[Serializable]
			public sealed class ModeParam : ParameterOverride<Mode>
			{
			}

			[UnityEngine.Rendering.PostProcessing.DisplayName("Mode")]
			[Tooltip("Distance-based mode blends two LUTs over a distance")]
			public ModeParam mode = new ModeParam
			{
				value = Mode.Single
			};

			[Range(1f, 3000f)]
			public FloatParameter distance = new FloatParameter
			{
				value = 1000f
			};

			[Range(0f, 1f)]
			[Tooltip("Fades the effect in or out")]
			public FloatParameter intensity = new FloatParameter
			{
				value = 1f
			};

			[Tooltip("Supply a LUT strip texture.")]
			public TextureParameter lutNear = new TextureParameter
			{
				value = null
			};

			[UnityEngine.Rendering.PostProcessing.DisplayName("Far")]
			public TextureParameter lutFar = new TextureParameter
			{
				value = null
			};

			public override bool IsEnabledAndSupported(PostProcessRenderContext context)
			{
				if (enabled.value)
				{
					if ((float)intensity == 0f || !lutNear.value)
					{
						return false;
					}
					return true;
				}
				return false;
			}
		}
		internal sealed class LUTRenderer : PostProcessEffectRenderer<LUT>
		{
			private Shader shader;

			public override void Init()
			{
				shader = Shader.Find("Hidden/SC Post Effects/LUT");
			}

			public override void Release()
			{
				base.Release();
			}

			public override void Render(PostProcessRenderContext context)
			{
				PropertySheet propertySheet = context.propertySheets.Get(shader);
				if ((bool)base.settings.lutNear.value)
				{
					propertySheet.properties.SetTexture("_LUT_Near", base.settings.lutNear);
					propertySheet.properties.SetVector("_LUT_Params", new Vector4(1f / (float)base.settings.lutNear.value.width, 1f / (float)base.settings.lutNear.value.height, (float)base.settings.lutNear.value.height - 1f, base.settings.intensity));
				}
				if (base.settings.mode.value == LUT.Mode.DistanceBased)
				{
					propertySheet.properties.SetFloat("_Distance", base.settings.distance);
					if ((bool)base.settings.lutFar.value)
					{
						propertySheet.properties.SetTexture("_LUT_Far", base.settings.lutFar);
					}
				}
				context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, (int)base.settings.mode.value);
			}
		}
		[Serializable]
		[PostProcess(typeof(LensFlaresRenderer), PostProcessEvent.BeforeStack, "SC Post Effects/Rendering/Lens Flares", true)]
		public sealed class LensFlares : PostProcessEffectSettings
		{
			public BoolParameter debug = new BoolParameter
			{
				value = false
			};

			[Space]
			[Range(0f, 1f)]
			[UnityEngine.Rendering.PostProcessing.DisplayName("Intensity")]
			public FloatParameter intensity = new FloatParameter
			{
				value = 0.5f
			};

			[Range(0.01f, 5f)]
			[UnityEngine.Rendering.PostProcessing.DisplayName("Threshold")]
			[Tooltip("Luminance threshold, pixels above this threshold will contribute to the effect")]
			public FloatParameter luminanceThreshold = new FloatParameter
			{
				value = 1f
			};

			[Header("Flares")]
			[Range(1f, 4f)]
			[UnityEngine.Rendering.PostProcessing.DisplayName("Number")]
			public IntParameter iterations = new IntParameter
			{
				value = 2
			};

			[Range(1f, 2f)]
			[UnityEngine.Rendering.PostProcessing.DisplayName("Distance")]
			[Tooltip("Offsets the Flares towards the edge of the screen")]
			public FloatParameter distance = new FloatParameter
			{
				value = 1.5f
			};

			[Range(1f, 10f)]
			[UnityEngine.Rendering.PostProcessing.DisplayName("Falloff")]
			[Tooltip("Fades out the Flares towards the edge of the screen")]
			public FloatParameter falloff = new FloatParameter
			{
				value = 10f
			};

			[Header("Halo")]
			[Tooltip("Creates a halo at the center of the screen when looking directly at a bright spot")]
			[Range(0f, 1f)]
			[UnityEngine.Rendering.PostProcessing.DisplayName("Size")]
			public FloatParameter haloSize = new FloatParameter
			{
				value = 0f
			};

			[Range(0f, 100f)]
			[UnityEngine.Rendering.PostProcessing.DisplayName("Width")]
			public FloatParameter haloWidth = new FloatParameter
			{
				value = 70f
			};

			[Header("Colors and masking")]
			[UnityEngine.Rendering.PostProcessing.DisplayName("Mask")]
			[Tooltip("Use a texture to mask out the effect")]
			public TextureParameter maskTex = new TextureParameter
			{
				value = null
			};

			[Range(0f, 20f)]
			[UnityEngine.Rendering.PostProcessing.DisplayName("Chromatic Abberation")]
			[Tooltip("Refracts the color channels")]
			public FloatParameter chromaticAbberation = new FloatParameter
			{
				value = 10f
			};

			[UnityEngine.Rendering.PostProcessing.DisplayName("Gradient")]
			[Tooltip("Color the flares from the center of the screen to the outer edges")]
			public TextureParameter colorTex = new TextureParameter
			{
				value = null
			};

			[Header("Blur")]
			[Range(1f, 8f)]
			[UnityEngine.Rendering.PostProcessing.DisplayName("Blur")]
			[Tooltip("The amount of blurring that must be performed")]
			public FloatParameter blur = new FloatParameter
			{
				value = 2f
			};

			[Range(1f, 12f)]
			[UnityEngine.Rendering.PostProcessing.DisplayName("Iterations")]
			[Tooltip("The number of times the effect is blurred. More iterations provide a smoother effect but induce more drawcalls.")]
			public IntParameter passes = new IntParameter
			{
				value = 3
			};
		}
		public sealed class LensFlaresRenderer : PostProcessEffectRenderer<LensFlares>
		{
			private enum Pass
			{
				LuminanceDiff,
				Ghosting,
				Blur,
				Blend,
				Debug
			}

			private Shader shader;

			private int emissionTex;

			private int flaresTex;

			private RenderTexture aoRT;

			public override void Init()
			{
				shader = Shader.Find("Hidden/SC Post Effects/Lensflares");
				emissionTex = Shader.PropertyToID("_BloomTex");
				flaresTex = Shader.PropertyToID("_FlaresTex");
			}

			public override void Release()
			{
				base.Release();
			}

			public override void Render(PostProcessRenderContext context)
			{
				PropertySheet propertySheet = context.propertySheets.Get(shader);
				CommandBuffer command = context.command;
				propertySheet.properties.SetFloat("_Intensity", base.settings.intensity);
				float value = Mathf.GammaToLinearSpace(base.settings.luminanceThreshold.value);
				propertySheet.properties.SetFloat("_Threshold", value);
				propertySheet.properties.SetFloat("_Distance", base.settings.distance);
				propertySheet.properties.SetFloat("_Falloff", base.settings.falloff);
				propertySheet.properties.SetFloat("_Ghosts", (int)base.settings.iterations);
				propertySheet.properties.SetFloat("_HaloSize", base.settings.haloSize);
				propertySheet.properties.SetFloat("_HaloWidth", base.settings.haloWidth);
				propertySheet.properties.SetFloat("_ChromaticAbberation", base.settings.chromaticAbberation);
				propertySheet.properties.SetTexture("_ColorTex", base.settings.colorTex.value ? ((Texture)base.settings.colorTex) : Texture2D.whiteTexture);
				propertySheet.properties.SetTexture("_MaskTex", base.settings.maskTex.value ? ((Texture)base.settings.maskTex) : Texture2D.whiteTexture);
				context.command.GetTemporaryRT(emissionTex, context.width, context.height, 0, FilterMode.Bilinear, RenderTextureFormat.DefaultHDR);
				context.command.BlitFullscreenTriangle(context.source, emissionTex, propertySheet, 0);
				context.command.SetGlobalTexture("_BloomTex", emissionTex);
				context.command.GetTemporaryRT(flaresTex, context.width, context.height, 0, FilterMode.Bilinear, RenderTextureFormat.DefaultHDR);
				context.command.BlitFullscreenTriangle(emissionTex, flaresTex, propertySheet, 1);
				context.command.SetGlobalTexture("_FlaresTex", flaresTex);
				int num = Shader.PropertyToID("_Temp1");
				int num2 = Shader.PropertyToID("_Temp2");
				command.GetTemporaryRT(num, context.width / 2, context.height / 2, 0, FilterMode.Bilinear);
				command.GetTemporaryRT(num2, context.width / 2, context.height / 2, 0, FilterMode.Bilinear);
				command.Blit(flaresTex, num);
				command.ReleaseTemporaryRT(flaresTex);
				for (int i = 0; i < (int)base.settings.passes; i++)
				{
					command.SetGlobalVector("_BlurOffsets", new Vector4((float)base.settings.blur / (float)context.screenWidth, 0f, 0f, 0f));
					context.command.BlitFullscreenTriangle(num, num2, propertySheet, 2);
					command.SetGlobalVector("_BlurOffsets", new Vector4(0f, (float)base.settings.blur / (float)context.screenHeight, 0f, 0f));
					context.command.BlitFullscreenTriangle(num2, num, propertySheet, 2);
				}
				context.command.SetGlobalTexture("_FlaresTex", num);
				context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, base.settings.debug ? 4 : 3);
				context.command.ReleaseTemporaryRT(emissionTex);
				context.command.ReleaseTemporaryRT(flaresTex);
				context.command.ReleaseTemporaryRT(num);
				context.command.ReleaseTemporaryRT(num2);
			}
		}
		[Serializable]
		[PostProcess(typeof(LightStreaksRenderer), PostProcessEvent.BeforeStack, "SC Post Effects/Rendering/Light Streaks", true)]
		public sealed class LightStreaks : PostProcessEffectSettings
		{
			public enum Quality
			{
				Performance,
				Appearance
			}

			[Serializable]
			public sealed class BlurMethodParameter : ParameterOverride<Quality>
			{
			}

			[UnityEngine.Rendering.PostProcessing.DisplayName("Quality")]
			[Tooltip("Choose between Box and Gaussian blurring methods.\n\nBox blurring is more efficient but has a limited blur range")]
			public BlurMethodParameter quality = new BlurMethodParameter
			{
				value = Quality.Appearance
			};

			[Range(0f, 1f)]
			[UnityEngine.Rendering.PostProcessing.DisplayName("Streaks Only")]
			[Tooltip("Shows only the effect, to allow for finetuning")]
			public BoolParameter debug = new BoolParameter
			{
				value = false
			};

			[Header("Anamorphic Lensfares")]
			[Range(0f, 1f)]
			[Tooltip("Intensity")]
			public FloatParameter intensity = new FloatParameter
			{
				value = 1f
			};

			[Range(0.01f, 5f)]
			[Tooltip("Luminance threshold, pixels above this threshold (material's emission value) will contribute to the effect")]
			public FloatParameter luminanceThreshold = new FloatParameter
			{
				value = 1f
			};

			[Range(-1f, 1f)]
			[Tooltip("Negative values become horizontal whereas postive values are vertical")]
			public FloatParameter direction = new FloatParameter
			{
				value = -1f
			};

			[Header("Blur")]
			[Range(0f, 10f)]
			[UnityEngine.Rendering.PostProcessing.DisplayName("Amount")]
			[Tooltip("The amount of blurring that must be performed")]
			public FloatParameter blur = new FloatParameter
			{
				value = 1f
			};

			[Range(1f, 8f)]
			[Tooltip("The number of times the effect is blurred. More iterations provide a smoother effect but induce more drawcalls.")]
			public IntParameter iterations = new IntParameter
			{
				value = 2
			};

			[Range(1f, 4f)]
			[Tooltip("Every step halfs the resolution of the blur effect. Lower resolution provides a smoother blur but may induce flickering")]
			public IntParameter downscaling = new IntParameter
			{
				value = 2
			};

			public override bool IsEnabledAndSupported(PostProcessRenderContext context)
			{
				if (enabled.value)
				{
					if ((float)blur == 0f || (float)intensity == 0f || (float)direction == 0f)
					{
						return false;
					}
					return true;
				}
				return false;
			}
		}
		public sealed class LightStreaksRenderer : PostProcessEffectRenderer<LightStreaks>
		{
			private enum Pass
			{
				LuminanceDiff,
				BlurFast,
				Blur,
				Blend,
				Debug
			}

			private Shader shader;

			private int emissionTex;

			private RenderTexture aoRT;

			public override void Init()
			{
				shader = Shader.Find("Hidden/SC Post Effects/Light Streaks");
				emissionTex = Shader.PropertyToID("_BloomTex");
			}

			public override void Release()
			{
				base.Release();
			}

			public override void Render(PostProcessRenderContext context)
			{
				PropertySheet propertySheet = context.propertySheets.Get(shader);
				CommandBuffer command = context.command;
				int pass = ((base.settings.quality.value == LightStreaks.Quality.Performance) ? 1 : 2);
				float x = Mathf.GammaToLinearSpace(base.settings.luminanceThreshold.value);
				propertySheet.properties.SetVector("_Params", new Vector4(x, base.settings.intensity, 0f, 0f));
				context.command.GetTemporaryRT(emissionTex, context.width, context.height, 0, FilterMode.Bilinear, context.sourceFormat);
				context.command.BlitFullscreenTriangle(context.source, emissionTex, propertySheet, 0);
				int num = (int)base.settings.downscaling + 1;
				int num2 = Shader.PropertyToID("_Temp1");
				int num3 = Shader.PropertyToID("_Temp2");
				command.GetTemporaryRT(num2, context.width / num, context.height / num, 0, FilterMode.Bilinear);
				command.GetTemporaryRT(num3, context.width / num, context.height / num, 0, FilterMode.Bilinear);
				command.Blit(emissionTex, num2);
				float num4 = Mathf.Clamp(base.settings.direction, -1f, 1f);
				float num5 = ((num4 < 0f) ? ((0f - num4) * 16f) : 0f);
				float num6 = ((num4 > 0f) ? (num4 * 8f) : 0f);
				int num7 = ((base.settings.quality.value == LightStreaks.Quality.Performance) ? ((int)base.settings.iterations * 3) : ((int)base.settings.iterations));
				for (int i = 0; i < num7; i++)
				{
					command.SetGlobalVector("_BlurOffsets", new Vector4(num5 * (float)base.settings.blur / (float)context.screenWidth, num6 / (float)context.screenHeight, 0f, 0f));
					context.command.BlitFullscreenTriangle(num2, num3, propertySheet, pass);
					command.SetGlobalVector("_BlurOffsets", new Vector4(num5 * (float)base.settings.blur * 2f / (float)context.screenWidth, num6 * 2f / (float)context.screenHeight, 0f, 0f));
					context.command.BlitFullscreenTriangle(num3, num2, propertySheet, pass);
				}
				context.command.SetGlobalTexture("_BloomTex", num2);
				context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, base.settings.debug ? 4 : 3);
				context.command.ReleaseTemporaryRT(num2);
				context.command.ReleaseTemporaryRT(num3);
				context.command.ReleaseTemporaryRT(emissionTex);
			}
		}
		[Serializable]
		[PostProcess(typeof(MosaicRenderer), PostProcessEvent.AfterStack, "SC Post Effects/Stylized/Mosaic", true)]
		public sealed class Mosaic : PostProcessEffectSettings
		{
			public enum MosaicMode
			{
				Triangles,
				Hexagons,
				Circles
			}

			[Serializable]
			public sealed class MosaicModeParam : ParameterOverride<MosaicMode>
			{
			}

			[UnityEngine.Rendering.PostProcessing.DisplayName("Method")]
			[Tooltip("")]
			public MosaicModeParam mode = new MosaicModeParam
			{
				value = MosaicMode.Hexagons
			};

			[Range(0f, 1f)]
			[Tooltip("Size")]
			public FloatParameter size = new FloatParameter
			{
				value = 0.075f
			};

			public override bool IsEnabledAndSupported(PostProcessRenderContext context)
			{
				if (enabled.value)
				{
					if ((float)size == 0f)
					{
						return false;
					}
					return true;
				}
				return false;
			}
		}
		internal sealed class MosaicRenderer : PostProcessEffectRenderer<Mosaic>
		{
			private Shader shader;

			public override void Init()
			{
				shader = Shader.Find("Hidden/SC Post Effects/Mosaic");
			}

			public override void Release()
			{
				base.Release();
			}

			public override void Render(PostProcessRenderContext context)
			{
				PropertySheet propertySheet = context.propertySheets.Get(shader);
				float num = base.settings.size;
				switch (base.settings.mode)
				{
				case 0L:
					num = 10f / (float)base.settings.size;
					break;
				case 1L:
					num = (float)base.settings.size / 10f;
					break;
				case 2L:
					num = (1f - (float)base.settings.size) * 300f;
					break;
				}
				Vector4 value = new Vector4(num, (float)(context.screenWidth * 2 / context.screenHeight) * num / Mathf.Sqrt(3f), 0f, 0f);
				propertySheet.properties.SetVector("_Params", value);
				context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, (int)base.settings.mode.value);
			}
		}
		[Serializable]
		[PostProcess(typeof(OverlayRenderer), PostProcessEvent.AfterStack, "SC Post Effects/Screen/Overlay", true)]
		public sealed class Overlay : PostProcessEffectSettings
		{
			public enum BlendMode
			{
				Linear,
				Additive,
				Multiply,
				Screen
			}

			[Serializable]
			public sealed class BlendModeParameter : ParameterOverride<BlendMode>
			{
			}

			[Tooltip("The texture's alpha channel controls its opacity")]
			public TextureParameter overlayTex = new TextureParameter
			{
				value = null
			};

			[Tooltip("Maintains the image aspect ratio, regardless of the screen width")]
			public BoolParameter autoAspect = new BoolParameter
			{
				value = false
			};

			[Tooltip("Blends the gradient through various Photoshop-like blending modes")]
			public BlendModeParameter blendMode = new BlendModeParameter
			{
				value = BlendMode.Linear
			};

			[Range(0f, 1f)]
			public FloatParameter intensity = new FloatParameter
			{
				value = 1f
			};

			[Range(0f, 1f)]
			public FloatParameter tiling = new FloatParameter
			{
				value = 0f
			};

			public override bool IsEnabledAndSupported(PostProcessRenderContext context)
			{
				if (enabled.value)
				{
					if (overlayTex.value == null || (float)intensity == 0f)
					{
						return false;
					}
					return true;
				}
				return false;
			}
		}
		internal sealed class OverlayRenderer : PostProcessEffectRenderer<Overlay>
		{
			private Shader shader;

			public override void Init()
			{
				shader = Shader.Find("Hidden/SC Post Effects/Overlay");
			}

			public override void Release()
			{
				base.Release();
			}

			public override void Render(PostProcessRenderContext context)
			{
				PropertySheet propertySheet = context.propertySheets.Get(shader);
				if ((bool)base.settings.overlayTex.value)
				{
					propertySheet.properties.SetTexture("_OverlayTex", base.settings.overlayTex);
				}
				propertySheet.properties.SetVector("_Params", new Vector4(base.settings.intensity, Mathf.Pow((float)base.settings.tiling + 1f, 2f), base.settings.autoAspect ? 1f : 0f, (float)base.settings.blendMode.value));
				context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0);
			}
		}
		[Serializable]
		[PostProcess(typeof(PixelizeRenderer), PostProcessEvent.BeforeStack, "SC Post Effects/Retro/Pixelize", true)]
		public sealed class Pixelize : PostProcessEffectSettings
		{
			[Range(0f, 1f)]
			[Tooltip("Amount")]
			public FloatParameter amount = new FloatParameter
			{
				value = 0.05f
			};

			public override bool IsEnabledAndSupported(PostProcessRenderContext context)
			{
				if (enabled.value)
				{
					if ((float)amount == 0f)
					{
						return false;
					}
					return true;
				}
				return false;
			}
		}
		internal sealed class PixelizeRenderer : PostProcessEffectRenderer<Pixelize>
		{
			private Shader shader;

			public override void Init()
			{
				shader = Shader.Find("Hidden/SC Post Effects/Pixelize");
			}

			public override void Release()
			{
				base.Release();
			}

			public override void Render(PostProcessRenderContext context)
			{
				PropertySheet propertySheet = context.propertySheets.Get(shader);
				propertySheet.properties.SetFloat("_Resolution", (float)base.settings.amount / 10f);
				context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0);
			}
		}
		[Serializable]
		[PostProcess(typeof(PosterizeRenderer), PostProcessEvent.BeforeStack, "SC Post Effects/Retro/Posterize", true)]
		public sealed class Posterize : PostProcessEffectSettings
		{
			[Range(0f, 1f)]
			public FloatParameter amount = new FloatParameter
			{
				value = 0.5f
			};

			public override bool IsEnabledAndSupported(PostProcessRenderContext context)
			{
				if (enabled.value)
				{
					if ((float)amount == 0f)
					{
						return false;
					}
					return true;
				}
				return false;
			}
		}
		internal sealed class PosterizeRenderer : PostProcessEffectRenderer<Posterize>
		{
			private Shader shader;

			public override void Init()
			{
				shader = Shader.Find("Hidden/SC Post Effects/Posterize");
			}

			public override void Release()
			{
				base.Release();
			}

			public override void Render(PostProcessRenderContext context)
			{
				PropertySheet propertySheet = context.propertySheets.Get(shader);
				propertySheet.properties.SetFloat("_Depth", (1f - (float)base.settings.amount) * 8f);
				context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0);
			}
		}
		[Serializable]
		[PostProcess(typeof(RadialBlurRenderer), PostProcessEvent.AfterStack, "SC Post Effects/Blurring/Radial Blur", true)]
		public sealed class RadialBlur : PostProcessEffectSettings
		{
			[Range(0f, 1f)]
			public FloatParameter amount = new FloatParameter
			{
				value = 0.5f
			};

			[Range(3f, 12f)]
			public IntParameter iterations = new IntParameter
			{
				value = 6
			};

			public override bool IsEnabledAndSupported(PostProcessRenderContext context)
			{
				if (enabled.value)
				{
					if ((float)amount == 0f)
					{
						return false;
					}
					return true;
				}
				return false;
			}
		}
		internal sealed class RadialBlurRenderer : PostProcessEffectRenderer<RadialBlur>
		{
			private Shader shader;

			public override void Init()
			{
				shader = Shader.Find("Hidden/SC Post Effects/Radial Blur");
			}

			public override void Release()
			{
				base.Release();
			}

			public override void Render(PostProcessRenderContext context)
			{
				PropertySheet propertySheet = context.propertySheets.Get(shader);
				_ = context.command;
				propertySheet.properties.SetFloat("_Amount", (float)base.settings.amount / 50f);
				propertySheet.properties.SetFloat("_Iterations", (int)base.settings.iterations);
				context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0);
			}
		}
		[Serializable]
		[PostProcess(typeof(RefractionRenderer), PostProcessEvent.AfterStack, "SC Post Effects/Screen/Refraction", true)]
		public sealed class Refraction : PostProcessEffectSettings
		{
			[Tooltip("Takes a DUDV map (normal map without a blue channel) to perturb the image")]
			public TextureParameter refractionTex = new TextureParameter
			{
				value = null
			};

			[UnityEngine.Rendering.PostProcessing.DisplayName("Using normal map")]
			[Tooltip("In the absense of a DUDV map, the supplied normal map can be converted in the shader")]
			public BoolParameter convertNormalMap = new BoolParameter
			{
				value = false
			};

			[Range(0f, 1f)]
			[Tooltip("Amount")]
			public FloatParameter amount = new FloatParameter
			{
				value = 1f
			};

			public override bool IsEnabledAndSupported(PostProcessRenderContext context)
			{
				if (enabled.value)
				{
					if ((float)amount == 0f || refractionTex.value == null)
					{
						return false;
					}
					return true;
				}
				return false;
			}
		}
		internal sealed class RefractionRenderer : PostProcessEffectRenderer<Refraction>
		{
			private Shader shader;

			public override void Init()
			{
				shader = Shader.Find("Hidden/SC Post Effects/Refraction");
			}

			public override void Release()
			{
				base.Release();
			}

			public override void Render(PostProcessRenderContext context)
			{
				PropertySheet propertySheet = context.propertySheets.Get(shader);
				propertySheet.properties.SetFloat("_Amount", base.settings.amount);
				if ((bool)base.settings.refractionTex.value)
				{
					propertySheet.properties.SetTexture("_RefractionTex", base.settings.refractionTex);
				}
				context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, base.settings.convertNormalMap ? 1 : 0);
			}
		}
		[Serializable]
		[PostProcess(typeof(RipplesRenderer), PostProcessEvent.AfterStack, "SC Post Effects/Screen/Ripples", true)]
		public sealed class Ripples : PostProcessEffectSettings
		{
			public enum RipplesMode
			{
				Radial,
				OmniDirectional
			}

			[Serializable]
			public sealed class RipplesModeParam : ParameterOverride<RipplesMode>
			{
			}

			[UnityEngine.Rendering.PostProcessing.DisplayName("Method")]
			public RipplesModeParam mode = new RipplesModeParam
			{
				value = RipplesMode.Radial
			};

			[Range(0f, 10f)]
			[UnityEngine.Rendering.PostProcessing.DisplayName("Intensity")]
			public FloatParameter strength = new FloatParameter
			{
				value = 2f
			};

			[Range(1f, 10f)]
			[Tooltip("The frequency of the waves")]
			public FloatParameter distance = new FloatParameter
			{
				value = 5f
			};

			[Range(0f, 10f)]
			[Tooltip("Speed")]
			public FloatParameter speed = new FloatParameter
			{
				value = 3f
			};

			[Range(0f, 5f)]
			[Tooltip("Width")]
			public FloatParameter width = new FloatParameter
			{
				value = 1.5f
			};

			[Range(0f, 5f)]
			[Tooltip("Height")]
			public FloatParameter height = new FloatParameter
			{
				value = 1f
			};

			public override bool IsEnabledAndSupported(PostProcessRenderContext context)
			{
				if (enabled.value)
				{
					if ((float)strength == 0f)
					{
						return false;
					}
					return true;
				}
				return false;
			}
		}
		internal sealed class RipplesRenderer : PostProcessEffectRenderer<Ripples>
		{
			private Shader shader;

			public override void Init()
			{
				shader = Shader.Find("Hidden/SC Post Effects/Ripples");
			}

			public override void Release()
			{
				base.Release();
			}

			public override void Render(PostProcessRenderContext context)
			{
				PropertySheet propertySheet = context.propertySheets.Get(shader);
				propertySheet.properties.SetFloat("_Strength", (float)base.settings.strength * 0.01f);
				propertySheet.properties.SetFloat("_Distance", (float)base.settings.distance * 0.01f);
				propertySheet.properties.SetFloat("_Speed", base.settings.speed);
				propertySheet.properties.SetVector("_Size", new Vector2(base.settings.width, base.settings.height));
				context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, (int)base.settings.mode.value);
			}
		}
		[Serializable]
		[PostProcess(typeof(ScanlinesRenderer), PostProcessEvent.AfterStack, "SC Post Effects/Retro/Scanlines", true)]
		public sealed class Scanlines : PostProcessEffectSettings
		{
			[Range(0f, 1f)]
			[Tooltip("Intensity")]
			public FloatParameter intensity = new FloatParameter
			{
				value = 0.5f
			};

			[Range(0f, 2048f)]
			[UnityEngine.Rendering.PostProcessing.DisplayName("Lines")]
			public FloatParameter amount = new FloatParameter
			{
				value = 700f
			};

			[Range(0f, 1f)]
			[Tooltip("Animation speed")]
			public FloatParameter speed = new FloatParameter
			{
				value = 0f
			};

			public override bool IsEnabledAndSupported(PostProcessRenderContext context)
			{
				if (enabled.value)
				{
					if (intensity.value == 0f)
					{
						return false;
					}
					return true;
				}
				return false;
			}
		}
		internal sealed class ScanlinesRenderer : PostProcessEffectRenderer<Scanlines>
		{
			private Shader shader;

			public override void Init()
			{
				shader = Shader.Find("Hidden/SC Post Effects/Scanlines");
			}

			public override void Release()
			{
				base.Release();
			}

			public override void Render(PostProcessRenderContext context)
			{
				PropertySheet propertySheet = context.propertySheets.Get(shader);
				propertySheet.properties.SetVector("_Params", new Vector4(base.settings.amount, (float)base.settings.intensity / 1000f, (float)base.settings.speed * 8f, 0f));
				context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0);
			}
		}
		[Serializable]
		[PostProcess(typeof(SharpenRenderer), PostProcessEvent.AfterStack, "SC Post Effects/Image/Sharpen", true)]
		public sealed class Sharpen : PostProcessEffectSettings
		{
			[Range(0f, 1f)]
			[Tooltip("Amount")]
			public FloatParameter amount = new FloatParameter
			{
				value = 0.5f
			};

			public override bool IsEnabledAndSupported(PostProcessRenderContext context)
			{
				if (enabled.value)
				{
					if ((float)amount == 0f)
					{
						return false;
					}
					return true;
				}
				return false;
			}
		}
		internal sealed class SharpenRenderer : PostProcessEffectRenderer<Sharpen>
		{
			private Shader shader;

			public override void Init()
			{
				shader = Shader.Find("Hidden/SC Post Effects/Sharpen");
			}

			public override void Release()
			{
				base.Release();
			}

			public override void Render(PostProcessRenderContext context)
			{
				PropertySheet propertySheet = context.propertySheets.Get(shader);
				propertySheet.properties.SetFloat("_Amount", base.settings.amount);
				context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0);
			}
		}
		[Serializable]
		[PostProcess(typeof(SketchRenderer), PostProcessEvent.BeforeStack, "SC Post Effects/Stylized/Sketch", true)]
		public sealed class Sketch : PostProcessEffectSettings
		{
			public enum SketchProjectionMode
			{
				WorldSpace,
				ScreenSpace
			}

			[Serializable]
			public sealed class SketchProjectioParameter : ParameterOverride<SketchProjectionMode>
			{
			}

			public enum SketchMode
			{
				EffectOnly,
				Multiply,
				Add
			}

			[Serializable]
			public sealed class SketchModeParameter : ParameterOverride<SketchMode>
			{
			}

			[Tooltip("The Red channel is used for darker shades, whereas the Green channel is for lighter.")]
			public TextureParameter strokeTex = new TextureParameter
			{
				value = null
			};

			[Space]
			[Tooltip("Choose the type of UV space being used")]
			public SketchProjectioParameter projectionMode = new SketchProjectioParameter
			{
				value = SketchProjectionMode.WorldSpace
			};

			[Tooltip("Choose one of the different modes")]
			public SketchModeParameter blendMode = new SketchModeParameter
			{
				value = SketchMode.EffectOnly
			};

			[Space]
			[Range(0f, 1f)]
			public FloatParameter intensity = new FloatParameter
			{
				value = 1f
			};

			public Vector2Parameter brightness = new Vector2Parameter
			{
				value = new Vector2(0f, 1f)
			};

			[Range(1f, 32f)]
			public FloatParameter tiling = new FloatParameter
			{
				value = 8f
			};

			public override bool IsEnabledAndSupported(PostProcessRenderContext context)
			{
				if (enabled.value)
				{
					if ((float)intensity == 0f || strokeTex.value == null)
					{
						return false;
					}
					return true;
				}
				return false;
			}
		}
		internal sealed class SketchRenderer : PostProcessEffectRenderer<Sketch>
		{
			private Shader shader;

			public override void Init()
			{
				shader = Shader.Find("Hidden/SC Post Effects/Sketch");
			}

			public override void Release()
			{
				base.Release();
			}

			public override void Render(PostProcessRenderContext context)
			{
				PropertySheet propertySheet = context.propertySheets.Get(shader);
				Matrix4x4 gPUProjectionMatrix = GL.GetGPUProjectionMatrix(context.camera.projectionMatrix, renderIntoTexture: false);
				float value = (gPUProjectionMatrix[3, 2] = 0f);
				gPUProjectionMatrix[2, 3] = value;
				gPUProjectionMatrix[3, 3] = 1f;
				Matrix4x4 value2 = Matrix4x4.Inverse(gPUProjectionMatrix * context.camera.worldToCameraMatrix) * Matrix4x4.TRS(new Vector3(0f, 0f, 0f - gPUProjectionMatrix[2, 2]), Quaternion.identity, Vector3.one);
				propertySheet.properties.SetMatrix("clipToWorld", value2);
				if ((bool)base.settings.strokeTex.value)
				{
					propertySheet.properties.SetTexture("_Strokes", base.settings.strokeTex);
				}
				propertySheet.properties.SetVector("_Params", new Vector4(0f, (float)base.settings.blendMode.value, base.settings.intensity, (base.settings.projectionMode.value == Sketch.SketchProjectionMode.ScreenSpace) ? ((float)base.settings.tiling * 0.1f) : ((float)base.settings.tiling)));
				propertySheet.properties.SetVector("_Brightness", base.settings.brightness);
				context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, (int)base.settings.projectionMode.value);
			}
		}
		[Serializable]
		[PostProcess(typeof(SpeedLinesRenderer), PostProcessEvent.AfterStack, "SC Post Effects/Screen/Speed Lines", true)]
		public sealed class SpeedLines : PostProcessEffectSettings
		{
			[Range(0f, 1f)]
			public FloatParameter intensity = new FloatParameter
			{
				value = 1f
			};

			[Range(0f, 1f)]
			[Tooltip("Determines the radial tiling of the noise texture")]
			public FloatParameter size = new FloatParameter
			{
				value = 0.5f
			};

			[Range(0f, 1f)]
			public FloatParameter falloff = new FloatParameter
			{
				value = 0.25f
			};

			[Tooltip("Assign any grayscale texture with a vertically repeating pattern and a falloff from left to right")]
			public TextureParameter noiseTex = new TextureParameter
			{
				value = null
			};

			public override bool IsEnabledAndSupported(PostProcessRenderContext context)
			{
				if (enabled.value)
				{
					if ((float)intensity == 0f || noiseTex.value == null)
					{
						return false;
					}
					return true;
				}
				return false;
			}
		}
		internal sealed class SpeedLinesRenderer : PostProcessEffectRenderer<SpeedLines>
		{
			private Shader shader;

			public override void Init()
			{
				shader = Shader.Find("Hidden/SC Post Effects/SpeedLines");
			}

			public override void Release()
			{
				base.Release();
			}

			public override void Render(PostProcessRenderContext context)
			{
				PropertySheet propertySheet = context.propertySheets.Get(shader);
				float y = 2f + ((float)base.settings.falloff - 0f) * 14f / 1f;
				propertySheet.properties.SetVector("_Params", new Vector4(base.settings.intensity, y, (float)base.settings.size * 2f, 0f));
				if ((bool)base.settings.noiseTex.value)
				{
					propertySheet.properties.SetTexture("_NoiseTex", base.settings.noiseTex);
				}
				context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0);
			}
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(Light))]
		internal sealed class SunshaftCaster : MonoBehaviour
		{
			[Range(0f, 10000f)]
			public float distance = 10000f;

			[Tooltip("Use this to match the casting position to a skybox sun")]
			public bool infiniteDistance;

			[Tooltip("This light will be used to sample the intensity if color")]
			public Light sunLight;

			private Vector3 sunPosition;

			public static Color color;

			public static float intensity;

			private void OnEnable()
			{
				sunPosition = base.transform.position;
				if (!sunLight)
				{
					sunLight = GetComponent<Light>();
					if ((bool)sunLight)
					{
						color = sunLight.color;
						intensity = sunLight.intensity;
					}
				}
			}

			private void OnDisable()
			{
				sunPosition = Vector3.zero;
				Sunshafts.sunPosition = Vector3.zero;
			}

			private void OnDrawGizmos()
			{
				Gizmos.DrawIcon(Sunshafts.sunPosition, "LensFlare Icon", allowScaling: true);
			}

			private void OnDrawGizmosSelected()
			{
				Gizmos.color = new Color(1f, 1f, 0f, 0.5f);
				Gizmos.DrawRay(base.transform.position, sunPosition);
			}

			private void Update()
			{
				sunPosition = -base.transform.forward * (infiniteDistance ? 1E+10f : distance);
				Sunshafts.sunPosition = sunPosition;
				if ((bool)sunLight)
				{
					color = sunLight.color;
					intensity = sunLight.intensity;
				}
			}
		}
		[Serializable]
		[PostProcess(typeof(SunshaftsRenderer), PostProcessEvent.AfterStack, "SC Post Effects/Environment/Sun Shafts", true)]
		public sealed class Sunshafts : PostProcessEffectSettings
		{
			public enum BlendMode
			{
				Additive,
				Screen
			}

			[Serializable]
			public sealed class SunShaftsSourceParameter : ParameterOverride<BlendMode>
			{
			}

			public enum SunShaftsResolution
			{
				High = 1,
				Normal,
				Low
			}

			[Serializable]
			public sealed class SunShaftsResolutionParameter : ParameterOverride<SunShaftsResolution>
			{
			}

			[Tooltip("Use the color of the Directional Light that's set as the caster")]
			public BoolParameter useCasterColor = new BoolParameter
			{
				value = true
			};

			[Tooltip("Use the intensity of the Directional Light that's set as the caster")]
			public BoolParameter useCasterIntensity = new BoolParameter
			{
				value = false
			};

			[Tooltip("Additive mode adds the sunshaft color to the image, while Screen mode perserves color values")]
			public SunShaftsSourceParameter blendMode = new SunShaftsSourceParameter
			{
				value = BlendMode.Screen
			};

			[UnityEngine.Rendering.PostProcessing.DisplayName("Resolution")]
			[Tooltip("Low, quater resolution\n\nNormal, half resolution\n\nHigh, full resolution\n\nLower resolutions may induce jittering")]
			public SunShaftsResolutionParameter resolution = new SunShaftsResolutionParameter
			{
				value = SunShaftsResolution.Normal
			};

			[Tooltip("Enabling this option doubles the amount of blurring performed. Resulting in smoother sunshafts at a higher performance cost.")]
			public BoolParameter highQuality = new BoolParameter
			{
				value = false
			};

			[Tooltip("Any color values over this threshold will contribute to the sunshafts effect")]
			[UnityEngine.Rendering.PostProcessing.DisplayName("Sky color threshold")]
			public ColorParameter sunThreshold = new ColorParameter
			{
				value = Color.black
			};

			[UnityEngine.Rendering.PostProcessing.DisplayName("Color")]
			public ColorParameter sunColor = new ColorParameter
			{
				value = new Color(1f, 1f, 1f)
			};

			[UnityEngine.Rendering.PostProcessing.DisplayName("Intensity")]
			public FloatParameter sunShaftIntensity = new FloatParameter
			{
				value = 1f
			};

			[Range(0.1f, 1f)]
			[Tooltip("The degree to which the shafts’ brightness diminishes with distance from the caster")]
			public FloatParameter falloff = new FloatParameter
			{
				value = 0.5f
			};

			[Tooltip("The length of the sunrays from the caster's position to the camera")]
			[UnityEngine.Rendering.PostProcessing.Min(0f)]
			public FloatParameter length = new FloatParameter
			{
				value = 10f
			};

			[Range(0f, 1f)]
			public FloatParameter noiseStrength = new FloatParameter
			{
				value = 0f
			};

			public static Vector3 sunPosition = Vector3.zero;

			public override bool IsEnabledAndSupported(PostProcessRenderContext context)
			{
				if (enabled.value)
				{
					if ((float)sunShaftIntensity == 0f || (float)length == 0f)
					{
						return false;
					}
					return true;
				}
				return false;
			}

			public static void AddShaftCaster()
			{
				GameObject gameObject = null;
				if ((bool)GameObject.Find("Directional Light"))
				{
					gameObject = GameObject.Find("Directional Light");
				}
				if (!gameObject && (bool)GameObject.Find("Directional light"))
				{
					gameObject = GameObject.Find("Directional light");
				}
				if (!gameObject)
				{
					UnityEngine.Debug.LogError("<b>Sunshafts:</b> No object with the name 'Directional Light' or 'Directional light' could be found");
					return;
				}
				SunshaftCaster sunshaftCaster = gameObject.GetComponent<SunshaftCaster>();
				if (!sunshaftCaster)
				{
					sunshaftCaster = gameObject.AddComponent<SunshaftCaster>();
					UnityEngine.Debug.Log("\"SunshaftCaster\" component was added to the <b>" + sunshaftCaster.gameObject.name + "</b> GameObject");
				}
				if (!sunshaftCaster.enabled)
				{
					sunshaftCaster.enabled = true;
				}
			}
		}
		internal sealed class SunshaftsRenderer : PostProcessEffectRenderer<Sunshafts>
		{
			private enum Pass
			{
				SkySource,
				RadialBlur,
				Blend
			}

			private Shader shader;

			private int skyboxBufferID;

			public override void Init()
			{
				shader = Shader.Find("Hidden/SC Post Effects/Sun Shafts");
				skyboxBufferID = Shader.PropertyToID("_SkyboxBuffer");
			}

			public override void Release()
			{
				base.Release();
			}

			public override void Render(PostProcessRenderContext context)
			{
				PropertySheet propertySheet = context.propertySheets.Get(shader);
				CommandBuffer command = context.command;
				float z = (base.settings.useCasterIntensity ? SunshaftCaster.intensity : base.settings.sunShaftIntensity.value);
				Vector3 vector = Vector3.one * 0.5f;
				vector = ((!(Sunshafts.sunPosition != Vector3.zero)) ? new Vector3(0.5f, 0.5f, 0f) : context.camera.WorldToViewportPoint(Sunshafts.sunPosition));
				propertySheet.properties.SetVector("_SunPosition", new Vector4(vector.x, vector.y, z, base.settings.falloff));
				Color color = (base.settings.useCasterColor ? SunshaftCaster.color : base.settings.sunColor.value);
				propertySheet.properties.SetFloat("_BlendMode", (float)base.settings.blendMode.value);
				propertySheet.properties.SetColor("_SunColor", (vector.z >= 0f) ? color : new Color(0f, 0f, 0f, 0f));
				propertySheet.properties.SetColor("_SunThreshold", base.settings.sunThreshold);
				int value = (int)base.settings.resolution.value;
				context.command.GetTemporaryRT(skyboxBufferID, context.width / 2, context.height / 2, 0, FilterMode.Bilinear, context.sourceFormat);
				context.command.BlitFullscreenTriangle(context.source, skyboxBufferID, propertySheet, 0);
				command.SetGlobalTexture("_SunshaftBuffer", skyboxBufferID);
				command.BeginSample("Sunshafts blur");
				int num = Shader.PropertyToID("_Temp1");
				int num2 = Shader.PropertyToID("_Temp2");
				command.GetTemporaryRT(num, context.width / value, context.height / value, 0, FilterMode.Bilinear);
				command.GetTemporaryRT(num2, context.width / value, context.height / value, 0, FilterMode.Bilinear);
				command.Blit(skyboxBufferID, num);
				float num3 = (float)base.settings.length * 0.0013020834f;
				int num4 = ((!base.settings.highQuality) ? 1 : 2);
				float num5 = (base.settings.highQuality ? ((float)base.settings.length / 2.5f) : ((float)base.settings.length));
				for (int i = 0; i < num4; i++)
				{
					context.command.BlitFullscreenTriangle(num, num2, propertySheet, 1);
					num3 = num5 * (((float)i * 2f + 1f) * 6f) / (float)context.screenWidth;
					propertySheet.properties.SetFloat("_BlurRadius", num3);
					context.command.BlitFullscreenTriangle(num2, num, propertySheet, 1);
					num3 = num5 * (((float)i * 2f + 2f) * 6f) / (float)context.screenWidth;
					propertySheet.properties.SetFloat("_BlurRadius", num3);
				}
				command.EndSample("Sunshafts blur");
				command.SetGlobalTexture("_SunshaftBuffer", num);
				context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 2);
				command.ReleaseTemporaryRT(num);
				command.ReleaseTemporaryRT(num2);
				command.ReleaseTemporaryRT(skyboxBufferID);
			}
		}
		[Serializable]
		[PostProcess(typeof(TiltShiftRenderer), PostProcessEvent.AfterStack, "SC Post Effects/Blurring/Tilt Shift", true)]
		public class TiltShift : PostProcessEffectSettings
		{
			public enum TiltShiftMethod
			{
				Horizontal,
				Radial
			}

			[Serializable]
			public sealed class TiltShifMethodParameter : ParameterOverride<TiltShiftMethod>
			{
			}

			[UnityEngine.Rendering.PostProcessing.DisplayName("Method")]
			public TiltShifMethodParameter mode = new TiltShifMethodParameter
			{
				value = TiltShiftMethod.Horizontal
			};

			[Space]
			[Range(0f, 1f)]
			public FloatParameter areaSize = new FloatParameter
			{
				value = 1f
			};

			[Range(0f, 1f)]
			[Tooltip("The amount of blurring that must be performed")]
			public FloatParameter amount = new FloatParameter
			{
				value = 0.5f
			};

			public override bool IsEnabledAndSupported(PostProcessRenderContext context)
			{
				if (enabled.value)
				{
					if ((float)amount == 0f || (float)areaSize == 0f)
					{
						return false;
					}
					return true;
				}
				return false;
			}
		}
		internal sealed class TiltShiftRenderer : PostProcessEffectRenderer<TiltShift>
		{
			private Shader shader;

			private int screenCopyID;

			public override void Init()
			{
				shader = Shader.Find("Hidden/SC Post Effects/Tilt Shift");
				screenCopyID = Shader.PropertyToID("_ScreenCopyTexture");
			}

			public override void Render(PostProcessRenderContext context)
			{
				PropertySheet propertySheet = context.propertySheets.Get(shader);
				CommandBuffer command = context.command;
				propertySheet.properties.SetFloat("_Size", base.settings.areaSize);
				propertySheet.properties.SetFloat("_Amount", base.settings.amount);
				context.command.GetTemporaryRT(screenCopyID, context.width, context.height, 0, FilterMode.Bilinear, context.sourceFormat);
				command.BlitFullscreenTriangle(context.source, screenCopyID, propertySheet, (int)base.settings.mode.value);
				command.SetGlobalTexture("_BlurredTex", screenCopyID);
				command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 2);
				command.ReleaseTemporaryRT(screenCopyID);
			}
		}
		[Serializable]
		[PostProcess(typeof(TubeDistortionRenderer), PostProcessEvent.AfterStack, "SC Post Effects/Screen/Tube Distortion", true)]
		public sealed class TubeDistortion : PostProcessEffectSettings
		{
			public enum DistortionMode
			{
				Buldged,
				Pinched,
				Beveled
			}

			[Serializable]
			public sealed class DistortionModeParam : ParameterOverride<DistortionMode>
			{
			}

			public DistortionModeParam mode = new DistortionModeParam
			{
				value = DistortionMode.Buldged
			};

			[Range(0f, 1f)]
			public FloatParameter amount = new FloatParameter
			{
				value = 0.5f
			};

			public override bool IsEnabledAndSupported(PostProcessRenderContext context)
			{
				if (enabled.value)
				{
					if ((float)amount == 0f)
					{
						return false;
					}
					return true;
				}
				return false;
			}
		}
		internal sealed class TubeDistortionRenderer : PostProcessEffectRenderer<TubeDistortion>
		{
			private Shader shader;

			public override void Init()
			{
				shader = Shader.Find("Hidden/SC Post Effects/Tube Distortion");
			}

			public override void Release()
			{
				base.Release();
			}

			public override void Render(PostProcessRenderContext context)
			{
				PropertySheet propertySheet = context.propertySheets.Get(shader);
				propertySheet.properties.SetFloat("_Amount", base.settings.amount);
				context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, (int)base.settings.mode.value);
			}
		}
		public class CharacterMovement : MonoBehaviour
		{
			public float walkSpeed = 6f;

			public float runSpeed = 8f;

			public float gravity = 20f;

			private float speed = 5f;

			private Vector3 moveDirection = Vector3.zero;

			private Rigidbody rbody;

			private void Awake()
			{
				rbody = GetComponent<Rigidbody>();
				rbody.freezeRotation = true;
			}

			private void Update()
			{
				moveDirection = new Vector3(Input.GetAxis("Horizontal"), 0f, Input.GetAxis("Vertical"));
				moveDirection = base.transform.TransformDirection(moveDirection);
				moveDirection.y = 0f;
				if (Input.GetKey(KeyCode.LeftShift))
				{
					speed = runSpeed;
				}
				else
				{
					speed = walkSpeed;
				}
				moveDirection *= speed;
				rbody.velocity = moveDirection;
			}
		}
		[RequireComponent(typeof(CharacterController))]
		public class FirstPersonController : MonoBehaviour
		{
			private bool m_IsWalking;

			private float walkSpeed = 10f;

			private float runSpeed = 32f;

			public MouseLook mouseLook;

			private Camera m_Camera;

			private Vector2 m_Input;

			private Vector3 m_MoveDir = Vector3.zero;

			private CharacterController m_CharacterController;

			private CollisionFlags m_CollisionFlags;

			private void Start()
			{
				m_CharacterController = GetComponent<CharacterController>();
				m_Camera = Camera.main;
				mouseLook.Init(base.transform, m_Camera.transform);
			}

			private void Update()
			{
				RotateView();
				if (Input.GetKeyDown(KeyCode.Escape))
				{
					Application.Quit();
				}
			}

			private void OnGUI()
			{
				GUILayout.BeginArea(new Rect(10f, 10f, 250f, 50f));
				GUI.color = Color.black;
				GUILayout.Label("Press ESC to quit");
				GUILayout.EndArea();
			}

			private void FixedUpdate()
			{
				GetInput(out var speed);
				Vector3 vector = base.transform.forward * m_Input.y + base.transform.right * m_Input.x;
				Physics.SphereCast(base.transform.position, m_CharacterController.radius, Vector3.down, out var hitInfo, m_CharacterController.height / 2f, -1, QueryTriggerInteraction.Ignore);
				vector = Vector3.ProjectOnPlane(vector, hitInfo.normal).normalized;
				m_MoveDir.x = vector.x * speed;
				m_MoveDir.z = vector.z * speed;
				m_CollisionFlags = m_CharacterController.Move(m_MoveDir * Time.fixedDeltaTime);
				mouseLook.UpdateCursorLock();
			}

			private void GetInput(out float speed)
			{
				float axis = Input.GetAxis("Horizontal");
				float axis2 = Input.GetAxis("Vertical");
				m_Input = new Vector2(axis, axis2);
				if (m_Input.sqrMagnitude > 1f)
				{
					m_Input.Normalize();
				}
				m_IsWalking = !Input.GetKey(KeyCode.LeftShift);
				speed = (m_IsWalking ? walkSpeed : runSpeed);
			}

			private void RotateView()
			{
				mouseLook.LookRotation(base.transform, m_Camera.transform);
			}

			private void OnControllerColliderHit(ControllerColliderHit hit)
			{
				Rigidbody attachedRigidbody = hit.collider.attachedRigidbody;
				if (m_CollisionFlags != CollisionFlags.Below && !(attachedRigidbody == null) && !attachedRigidbody.isKinematic)
				{
					attachedRigidbody.AddForceAtPosition(m_CharacterController.velocity * 0.1f, hit.point, ForceMode.Impulse);
				}
			}
		}
		public class MouseLook : MonoBehaviour
		{
			public float XSensitivity = 2f;

			public float YSensitivity = 2f;

			public bool clampVerticalRotation = true;

			public float MinimumX = -90f;

			public float MaximumX = 90f;

			public bool lockCursor = true;

			private Quaternion m_CharacterTargetRot;

			private Quaternion m_CameraTargetRot;

			private bool m_cursorIsLocked = true;

			public void Init(Transform character, Transform camera)
			{
				m_CharacterTargetRot = character.localRotation;
				m_CameraTargetRot = camera.localRotation;
			}

			public void LookRotation(Transform character, Transform camera)
			{
				float y = Input.GetAxis("Mouse X") * XSensitivity;
				float num = Input.GetAxis("Mouse Y") * YSensitivity;
				m_CharacterTargetRot *= Quaternion.Euler(0f, y, 0f);
				m_CameraTargetRot *= Quaternion.Euler(0f - num, 0f, 0f);
				if (clampVerticalRotation)
				{
					m_CameraTargetRot = ClampRotationAroundXAxis(m_CameraTargetRot);
				}
				character.localRotation = m_CharacterTargetRot;
				camera.localRotation = m_CameraTargetRot;
				UpdateCursorLock();
			}

			public void SetCursorLock(bool value)
			{
				lockCursor = value;
				if (!lockCursor)
				{
					Cursor.lockState = CursorLockMode.None;
					Cursor.visible = true;
				}
			}

			public void UpdateCursorLock()
			{
				if (lockCursor)
				{
					InternalLockUpdate();
				}
			}

			private void InternalLockUpdate()
			{
				if (Input.GetKeyUp(KeyCode.Escape))
				{
					m_cursorIsLocked = false;
				}
				else if (Input.GetMouseButtonUp(0))
				{
					m_cursorIsLocked = true;
				}
				if (m_cursorIsLocked)
				{
					Cursor.lockState = CursorLockMode.Locked;
					Cursor.visible = false;
				}
				else if (!m_cursorIsLocked)
				{
					Cursor.lockState = CursorLockMode.None;
					Cursor.visible = true;
				}
			}

			private Quaternion ClampRotationAroundXAxis(Quaternion q)
			{
				q.x /= q.w;
				q.y /= q.w;
				q.z /= q.w;
				q.w = 1f;
				float value = 114.59156f * Mathf.Atan(q.x);
				value = Mathf.Clamp(value, MinimumX, MaximumX);
				q.x = Mathf.Tan((float)Math.PI / 360f * value);
				return q;
			}
		}
	}
	namespace UnityEngine.PostProcessing
	{
		public sealed class GetSetAttribute : PropertyAttribute
		{
			public readonly string name;

			public bool dirty;

			public GetSetAttribute(string name)
			{
				this.name = name;
			}
		}
		public sealed class TrackballAttribute : PropertyAttribute
		{
			public readonly string method;

			public TrackballAttribute(string method)
			{
				this.method = method;
			}
		}
		public sealed class TrackballGroupAttribute : PropertyAttribute
		{
		}
		public sealed class AmbientOcclusionComponent : PostProcessingComponentCommandBuffer<AmbientOcclusionModel>
		{
			private static class Uniforms
			{
				internal static readonly int _Intensity = Shader.PropertyToID("_Intensity");

				internal static readonly int _Radius = Shader.PropertyToID("_Radius");

				internal static readonly int _FogParams = Shader.PropertyToID("_FogParams");

				internal static readonly int _Downsample = Shader.PropertyToID("_Downsample");

				internal static readonly int _SampleCount = Shader.PropertyToID("_SampleCount");

				internal static readonly int _OcclusionTexture1 = Shader.PropertyToID("_OcclusionTexture1");

				internal static readonly int _OcclusionTexture2 = Shader.PropertyToID("_OcclusionTexture2");

				internal static readonly int _OcclusionTexture = Shader.PropertyToID("_OcclusionTexture");

				internal static readonly int _MainTex = Shader.PropertyToID("_MainTex");

				internal static readonly int _TempRT = Shader.PropertyToID("_TempRT");
			}

			private enum OcclusionSource
			{
				DepthTexture,
				DepthNormalsTexture,
				GBuffer
			}

			private const string k_BlitShaderString = "Hidden/Post FX/Blit";

			private const string k_ShaderString = "Hidden/Post FX/Ambient Occlusion";

			private readonly RenderTargetIdentifier[] m_MRT = new RenderTargetIdentifier[2]
			{
				BuiltinRenderTextureType.GBuffer0,
				BuiltinRenderTextureType.CameraTarget
			};

			private OcclusionSource occlusionSource
			{
				get
				{
					if (context.isGBufferAvailable && !base.model.settings.forceForwardCompatibility)
					{
						return OcclusionSource.GBuffer;
					}
					if (base.model.settings.highPrecision && (!context.isGBufferAvailable || base.model.settings.forceForwardCompatibility))
					{
						return OcclusionSource.DepthTexture;
					}
					return OcclusionSource.DepthNormalsTexture;
				}
			}

			private bool ambientOnlySupported
			{
				get
				{
					if (context.isHdr && base.model.settings.ambientOnly && context.isGBufferAvailable)
					{
						return !base.model.settings.forceForwardCompatibility;
					}
					return false;
				}
			}

			public override bool active
			{
				get
				{
					if (base.model.enabled && base.model.settings.intensity > 0f)
					{
						return !context.interrupted;
					}
					return false;
				}
			}

			public override DepthTextureMode GetCameraFlags()
			{
				DepthTextureMode depthTextureMode = DepthTextureMode.None;
				if (occlusionSource == OcclusionSource.DepthTexture)
				{
					depthTextureMode |= DepthTextureMode.Depth;
				}
				if (occlusionSource != OcclusionSource.GBuffer)
				{
					depthTextureMode |= DepthTextureMode.DepthNormals;
				}
				return depthTextureMode;
			}

			public override string GetName()
			{
				return "Ambient Occlusion";
			}

			public override CameraEvent GetCameraEvent()
			{
				if (!ambientOnlySupported || context.profile.debugViews.IsModeActive(BuiltinDebugViewsModel.Mode.AmbientOcclusion))
				{
					return CameraEvent.BeforeImageEffectsOpaque;
				}
				return CameraEvent.BeforeReflections;
			}

			public override void PopulateCommandBuffer(CommandBuffer cb)
			{
				AmbientOcclusionModel.Settings settings = base.model.settings;
				Material mat = context.materialFactory.Get("Hidden/Post FX/Blit");
				Material material = context.materialFactory.Get("Hidden/Post FX/Ambient Occlusion");
				material.shaderKeywords = null;
				material.SetFloat(Uniforms._Intensity, settings.intensity);
				material.SetFloat(Uniforms._Radius, settings.radius);
				material.SetFloat(Uniforms._Downsample, settings.downsampling ? 0.5f : 1f);
				material.SetInt(Uniforms._SampleCount, (int)settings.sampleCount);
				if (!context.isGBufferAvailable && RenderSettings.fog)
				{
					material.SetVector(Uniforms._FogParams, new Vector3(RenderSettings.fogDensity, RenderSettings.fogStartDistance, RenderSettings.fogEndDistance));
					switch (RenderSettings.fogMode)
					{
					case FogMode.Linear:
						material.EnableKeyword("FOG_LINEAR");
						break;
					case FogMode.Exponential:
						material.EnableKeyword("FOG_EXP");
						break;
					case FogMode.ExponentialSquared:
						material.EnableKeyword("FOG_EXP2");
						break;
					}
				}
				else
				{
					material.EnableKeyword("FOG_OFF");
				}
				int width = context.width;
				int height = context.height;
				int num = ((!settings.downsampling) ? 1 : 2);
				int occlusionTexture = Uniforms._OcclusionTexture1;
				cb.GetTemporaryRT(occlusionTexture, width / num, height / num, 0, FilterMode.Bilinear, RenderTextureFormat.ARGB32, RenderTextureReadWrite.Linear);
				cb.Blit(null, occlusionTexture, material, (int)occlusionSource);
				int occlusionTexture2 = Uniforms._OcclusionTexture2;
				cb.GetTemporaryRT(occlusionTexture2, width, height, 0, FilterMode.Bilinear, RenderTextureFormat.ARGB32, RenderTextureReadWrite.Linear);
				cb.SetGlobalTexture(Uniforms._MainTex, occlusionTexture);
				cb.Blit(occlusionTexture, occlusionTexture2, material, (occlusionSource == OcclusionSource.GBuffer) ? 4 : 3);
				cb.ReleaseTemporaryRT(occlusionTexture);
				occlusionTexture = Uniforms._OcclusionTexture;
				cb.GetTemporaryRT(occlusionTexture, width, height, 0, FilterMode.Bilinear, RenderTextureFormat.ARGB32, RenderTextureReadWrite.Linear);
				cb.SetGlobalTexture(Uniforms._MainTex, occlusionTexture2);
				cb.Blit(occlusionTexture2, occlusionTexture, material, 5);
				cb.ReleaseTemporaryRT(occlusionTexture2);
				if (context.profile.debugViews.IsModeActive(BuiltinDebugViewsModel.Mode.AmbientOcclusion))
				{
					cb.SetGlobalTexture(Uniforms._MainTex, occlusionTexture);
					cb.Blit(occlusionTexture, BuiltinRenderTextureType.CameraTarget, material, 8);
					context.Interrupt();
				}
				else if (ambientOnlySupported)
				{
					cb.SetRenderTarget(m_MRT, BuiltinRenderTextureType.CameraTarget);
					cb.DrawMesh(GraphicsUtils.quad, Matrix4x4.identity, material, 0, 7);
				}
				else
				{
					RenderTextureFormat format = (context.isHdr ? RenderTextureFormat.DefaultHDR : RenderTextureFormat.Default);
					int tempRT = Uniforms._TempRT;
					cb.GetTemporaryRT(tempRT, context.width, context.height, 0, FilterMode.Bilinear, format);
					cb.Blit(BuiltinRenderTextureType.CameraTarget, tempRT, mat, 0);
					cb.SetGlobalTexture(Uniforms._MainTex, tempRT);
					cb.Blit(tempRT, BuiltinRenderTextureType.CameraTarget, material, 6);
					cb.ReleaseTemporaryRT(tempRT);
				}
				cb.ReleaseTemporaryRT(occlusionTexture);
			}
		}
		public sealed class BloomComponent : PostProcessingComponentRenderTexture<BloomModel>
		{
			private static class Uniforms
			{
				internal static readonly int _AutoExposure = Shader.PropertyToID("_AutoExposure");

				internal static readonly int _Threshold = Shader.PropertyToID("_Threshold");

				internal static readonly int _Curve = Shader.PropertyToID("_Curve");

				internal static readonly int _PrefilterOffs = Shader.PropertyToID("_PrefilterOffs");

				internal static readonly int _SampleScale = Shader.PropertyToID("_SampleScale");

				internal static readonly int _BaseTex = Shader.PropertyToID("_BaseTex");

				internal static readonly int _BloomTex = Shader.PropertyToID("_BloomTex");

				internal static readonly int _Bloom_Settings = Shader.PropertyToID("_Bloom_Settings");

				internal static readonly int _Bloom_DirtTex = Shader.PropertyToID("_Bloom_DirtTex");

				internal static readonly int _Bloom_DirtIntensity = Shader.PropertyToID("_Bloom_DirtIntensity");
			}

			private const int k_MaxPyramidBlurLevel = 16;

			private readonly RenderTexture[] m_BlurBuffer1 = new RenderTexture[16];

			private readonly RenderTexture[] m_BlurBuffer2 = new RenderTexture[16];

			public override bool active
			{
				get
				{
					if (base.model.enabled && base.model.settings.bloom.intensity > 0f)
					{
						return !context.interrupted;
					}
					return false;
				}
			}

			public void Prepare(RenderTexture source, Material uberMaterial, Texture autoExposure)
			{
				BloomModel.BloomSettings bloom = base.model.settings.bloom;
				BloomModel.LensDirtSettings lensDirt = base.model.settings.lensDirt;
				Material material = context.materialFactory.Get("Hidden/Post FX/Bloom");
				material.shaderKeywords = null;
				material.SetTexture(Uniforms._AutoExposure, autoExposure);
				int width = context.width / 2;
				int num = context.height / 2;
				bool isMobilePlatform = Application.isMobilePlatform;
				bool flag = SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.RGB111110Float);
				RenderTextureFormat format = (isMobilePlatform ? RenderTextureFormat.Default : (flag ? RenderTextureFormat.RGB111110Float : RenderTextureFormat.DefaultHDR));
				float num2 = Mathf.Log(num, 2f) + bloom.radius - 8f;
				int num3 = (int)num2;
				int num4 = Mathf.Clamp(num3, 1, 16);
				float thresholdLinear = bloom.thresholdLinear;
				material.SetFloat(Uniforms._Threshold, thresholdLinear);
				float num5 = thresholdLinear * bloom.softKnee + 1E-05f;
				material.SetVector(value: new Vector3(thresholdLinear - num5, num5 * 2f, 0.25f / num5), nameID: Uniforms._Curve);
				material.SetFloat(Uniforms._PrefilterOffs, bloom.antiFlicker ? (-0.5f) : 0f);
				float num6 = 0.5f + num2 - (float)num3;
				material.SetFloat(Uniforms._SampleScale, num6);
				if (bloom.antiFlicker)
				{
					material.EnableKeyword("ANTI_FLICKER");
				}
				RenderTexture renderTexture = context.renderTextureFactory.Get(width, num, 0, format);
				Graphics.Blit(source, renderTexture, material, 0);
				RenderTexture renderTexture2 = renderTexture;
				for (int i = 0; i < num4; i++)
				{
					m_BlurBuffer1[i] = context.renderTextureFactory.Get(renderTexture2.width / 2, renderTexture2.height / 2, 0, format);
					int pass = ((i == 0) ? 1 : 2);
					Graphics.Blit(renderTexture2, m_BlurBuffer1[i], material, pass);
					renderTexture2 = m_BlurBuffer1[i];
				}
				for (int num7 = num4 - 2; num7 >= 0; num7--)
				{
					RenderTexture renderTexture3 = m_BlurBuffer1[num7];
					material.SetTexture(Uniforms._BaseTex, renderTexture3);
					m_BlurBuffer2[num7] = context.renderTextureFactory.Get(renderTexture3.width, renderTexture3.height, 0, format);
					Graphics.Blit(renderTexture2, m_BlurBuffer2[num7], material, 3);
					renderTexture2 = m_BlurBuffer2[num7];
				}
				RenderTexture renderTexture4 = renderTexture2;
				for (int j = 0; j < 16; j++)
				{
					if (m_BlurBuffer1[j] != null)
					{
						context.renderTextureFactory.Release(m_BlurBuffer1[j]);
					}
					if (m_BlurBuffer2[j] != null && m_BlurBuffer2[j] != renderTexture4)
					{
						context.renderTextureFactory.Release(m_BlurBuffer2[j]);
					}
					m_BlurBuffer1[j] = null;
					m_BlurBuffer2[j] = null;
				}
				context.renderTextureFactory.Release(renderTexture);
				uberMaterial.SetTexture(Uniforms._BloomTex, renderTexture4);
				uberMaterial.SetVector(Uniforms._Bloom_Settings, new Vector2(num6, bloom.intensity));
				if (lensDirt.intensity > 0f && lensDirt.texture != null)
				{
					uberMaterial.SetTexture(Uniforms._Bloom_DirtTex, lensDirt.texture);
					uberMaterial.SetFloat(Uniforms._Bloom_DirtIntensity, lensDirt.intensity);
					uberMaterial.EnableKeyword("BLOOM_LENS_DIRT");
				}
				else
				{
					uberMaterial.EnableKeyword("BLOOM");
				}
			}
		}
		public sealed class BuiltinDebugViewsComponent : PostProcessingComponentCommandBuffer<BuiltinDebugViewsModel>
		{
			private static class Uniforms
			{
				internal static readonly int _DepthScale = Shader.PropertyToID("_DepthScale");

				internal static readonly int _TempRT = Shader.PropertyToID("_TempRT");

				internal static readonly int _Opacity = Shader.PropertyToID("_Opacity");

				internal static readonly int _MainTex = Shader.PropertyToID("_MainTex");

				internal static readonly int _TempRT2 = Shader.PropertyToID("_TempRT2");

				internal static readonly int _Amplitude = Shader.PropertyToID("_Amplitude");

				internal static readonly int _Scale = Shader.PropertyToID("_Scale");
			}

			private enum Pass
			{
				Depth,
				Normals,
				MovecOpacity,
				MovecImaging,
				MovecArrows
			}

			private class ArrowArray
			{
				public Mesh mesh { get; private set; }

				public int columnCount { get; private set; }

				public int rowCount { get; private set; }

				public void BuildMesh(int columns, int rows)
				{
					Vector3[] array = new Vector3[6]
					{
						new Vector3(0f, 0f, 0f),
						new Vector3(0f, 1f, 0f),
						new Vector3(0f, 1f, 0f),
						new Vector3(-1f, 1f, 0f),
						new Vector3(0f, 1f, 0f),
						new Vector3(1f, 1f, 0f)
					};
					int num = 6 * columns * rows;
					List<Vector3> list = new List<Vector3>(num);
					List<Vector2> list2 = new List<Vector2>(num);
					for (int i = 0; i < rows; i++)
					{
						for (int j = 0; j < columns; j++)
						{
							Vector2 item = new Vector2((0.5f + (float)j) / (float)columns, (0.5f + (float)i) / (float)rows);
							for (int k = 0; k < 6; k++)
							{
								list.Add(array[k]);
								list2.Add(item);
							}
						}
					}
					int[] array2 = new int[num];
					for (int l = 0; l < num; l++)
					{
						array2[l] = l;
					}
					mesh = new Mesh
					{
						hideFlags = HideFlags.DontSave
					};
					mesh.SetVertices(list);
					mesh.SetUVs(0, list2);
					mesh.SetIndices(array2, MeshTopology.Lines, 0);
					mesh.UploadMeshData(markNoLongerReadable: true);
					columnCount = columns;
					rowCount = rows;
				}

				public void Release()
				{
					GraphicsUtils.Destroy(mesh);
					mesh = null;
				}
			}

			private const string k_ShaderString = "Hidden/Post FX/Builtin Debug Views";

			private ArrowArray m_Arrows;

			public override bool active
			{
				get
				{
					if (!base.model.IsModeActive(BuiltinDebugViewsModel.Mode.Depth) && !base.model.IsModeActive(BuiltinDebugViewsModel.Mode.Normals))
					{
						return base.model.IsModeActive(BuiltinDebugViewsModel.Mode.MotionVectors);
					}
					return true;
				}
			}

			public override DepthTextureMode GetCameraFlags()
			{
				BuiltinDebugViewsModel.Mode mode = base.model.settings.mode;
				DepthTextureMode depthTextureMode = DepthTextureMode.None;
				switch (mode)
				{
				case BuiltinDebugViewsModel.Mode.Normals:
					depthTextureMode |= DepthTextureMode.DepthNormals;
					break;
				case BuiltinDebugViewsModel.Mode.MotionVectors:
					depthTextureMode |= DepthTextureMode.Depth | DepthTextureMode.MotionVectors;
					break;
				case BuiltinDebugViewsModel.Mode.Depth:
					depthTextureMode |= DepthTextureMode.Depth;
					break;
				}
				return depthTextureMode;
			}

			public override CameraEvent GetCameraEvent()
			{
				if (base.model.settings.mode != BuiltinDebugViewsModel.Mode.MotionVectors)
				{
					return CameraEvent.BeforeImageEffectsOpaque;
				}
				return CameraEvent.BeforeImageEffects;
			}

			public override string GetName()
			{
				return "Builtin Debug Views";
			}

			public override void PopulateCommandBuffer(CommandBuffer cb)
			{
				BuiltinDebugViewsModel.Settings settings = base.model.settings;
				Material material = context.materialFactory.Get("Hidden/Post FX/Builtin Debug Views");
				material.shaderKeywords = null;
				if (context.isGBufferAvailable)
				{
					material.EnableKeyword("SOURCE_GBUFFER");
				}
				switch (settings.mode)
				{
				case BuiltinDebugViewsModel.Mode.Depth:
					DepthPass(cb);
					break;
				case BuiltinDebugViewsModel.Mode.Normals:
					DepthNormalsPass(cb);
					break;
				case BuiltinDebugViewsModel.Mode.MotionVectors:
					MotionVectorsPass(cb);
					break;
				}
				context.Interrupt();
			}

			private void DepthPass(CommandBuffer cb)
			{
				Material mat = context.materialFactory.Get("Hidden/Post FX/Builtin Debug Views");
				BuiltinDebugViewsModel.DepthSettings depth = base.model.settings.depth;
				cb.SetGlobalFloat(Uniforms._DepthScale, 1f / depth.scale);
				cb.Blit(null, BuiltinRenderTextureType.CameraTarget, mat, 0);
			}

			private void DepthNormalsPass(CommandBuffer cb)
			{
				Material mat = context.materialFactory.Get("Hidden/Post FX/Builtin Debug Views");
				cb.Blit(null, BuiltinRenderTextureType.CameraTarget, mat, 1);
			}

			private void MotionVectorsPass(CommandBuffer cb)
			{
				Material material = context.materialFactory.Get("Hidden/Post FX/Builtin Debug Views");
				BuiltinDebugViewsModel.MotionVectorsSettings motionVectors = base.model.settings.motionVectors;
				int num = Uniforms._TempRT;
				cb.GetTemporaryRT(num, context.width, context.height, 0, FilterMode.Bilinear);
				cb.SetGlobalFloat(Uniforms._Opacity, motionVectors.sourceOpacity);
				cb.SetGlobalTexture(Uniforms._MainTex, BuiltinRenderTextureType.CameraTarget);
				cb.Blit(BuiltinRenderTextureType.CameraTarget, num, material, 2);
				if (motionVectors.motionImageOpacity > 0f && motionVectors.motionImageAmplitude > 0f)
				{
					int tempRT = Uniforms._TempRT2;
					cb.GetTemporaryRT(tempRT, context.width, context.height, 0, FilterMode.Bilinear);
					cb.SetGlobalFloat(Uniforms._Opacity, motionVectors.motionImageOpacity);
					cb.SetGlobalFloat(Uniforms._Amplitude, motionVectors.motionImageAmplitude);
					cb.SetGlobalTexture(Uniforms._MainTex, num);
					cb.Blit(num, tempRT, material, 3);
					cb.ReleaseTemporaryRT(num);
					num = tempRT;
				}
				if (motionVectors.motionVectorsOpacity > 0f && motionVectors.motionVectorsAmplitude > 0f)
				{
					PrepareArrows();
					float num2 = 1f / (float)motionVectors.motionVectorsResolution;
					float x = num2 * (float)context.height / (float)context.width;
					cb.SetGlobalVector(Uniforms._Scale, new Vector2(x, num2));
					cb.SetGlobalFloat(Uniforms._Opacity, motionVectors.motionVectorsOpacity);
					cb.SetGlobalFloat(Uniforms._Amplitude, motionVectors.motionVectorsAmplitude);
					cb.DrawMesh(m_Arrows.mesh, Matrix4x4.identity, material, 0, 4);
				}
				cb.SetGlobalTexture(Uniforms._MainTex, num);
				cb.Blit(num, BuiltinRenderTextureType.CameraTarget);
				cb.ReleaseTemporaryRT(num);
			}

			private void PrepareArrows()
			{
				int motionVectorsResolution = base.model.settings.motionVectors.motionVectorsResolution;
				int num = motionVectorsResolution * Screen.width / Screen.height;
				if (m_Arrows == null)
				{
					m_Arrows = new ArrowArray();
				}
				if (m_Arrows.columnCount != num || m_Arrows.rowCount != motionVectorsResolution)
				{
					m_Arrows.Release();
					m_Arrows.BuildMesh(num, motionVectorsResolution);
				}
			}

			public override void OnDisable()
			{
				if (m_Arrows != null)
				{
					m_Arrows.Release();
				}
				m_Arrows = null;
			}
		}
		public sealed class ChromaticAberrationComponent : PostProcessingComponentRenderTexture<ChromaticAberrationModel>
		{
			private static class Uniforms
			{
				internal static readonly int _ChromaticAberration_Amount = Shader.PropertyToID("_ChromaticAberration_Amount");

				internal static readonly int _ChromaticAberration_Spectrum = Shader.PropertyToID("_ChromaticAberration_Spectrum");
			}

			private Texture2D m_SpectrumLut;

			public override bool active
			{
				get
				{
					if (base.model.enabled && base.model.settings.intensity > 0f)
					{
						return !context.interrupted;
					}
					return false;
				}
			}

			public override void OnDisable()
			{
				GraphicsUtils.Destroy(m_SpectrumLut);
				m_SpectrumLut = null;
			}

			public override void Prepare(Material uberMaterial)
			{
				ChromaticAberrationModel.Settings settings = base.model.settings;
				Texture2D texture2D = settings.spectralTexture;
				if (texture2D == null)
				{
					if (m_SpectrumLut == null)
					{
						m_SpectrumLut = new Texture2D(3, 1, TextureFormat.RGB24, mipChain: false)
						{
							name = "Chromatic Aberration Spectrum Lookup",
							filterMode = FilterMode.Bilinear,
							wrapMode = TextureWrapMode.Clamp,
							anisoLevel = 0,
							hideFlags = HideFlags.DontSave
						};
						Color[] pixels = new Color[3]
						{
							new Color(1f, 0f, 0f),
							new Color(0f, 1f, 0f),
							new Color(0f, 0f, 1f)
						};
						m_SpectrumLut.SetPixels(pixels);
						m_SpectrumLut.Apply();
					}
					texture2D = m_SpectrumLut;
				}
				uberMaterial.EnableKeyword("CHROMATIC_ABERRATION");
				uberMaterial.SetFloat(Uniforms._ChromaticAberration_Amount, settings.intensity * 0.03f);
				uberMaterial.SetTexture(Uniforms._ChromaticAberration_Spectrum, texture2D);
			}
		}
		public sealed class ColorGradingComponent : PostProcessingComponentRenderTexture<ColorGradingModel>
		{
			private static class Uniforms
			{
				internal static readonly int _LutParams = Shader.PropertyToID("_LutParams");

				internal static readonly int _NeutralTonemapperParams1 = Shader.PropertyToID("_NeutralTonemapperParams1");

				internal static readonly int _NeutralTonemapperParams2 = Shader.PropertyToID("_NeutralTonemapperParams2");

				internal static readonly int _HueShift = Shader.PropertyToID("_HueShift");

				internal static readonly int _Saturation = Shader.PropertyToID("_Saturation");

				internal static readonly int _Contrast = Shader.PropertyToID("_Contrast");

				internal static readonly int _Balance = Shader.PropertyToID("_Balance");

				internal static readonly int _Lift = Shader.PropertyToID("_Lift");

				internal static readonly int _InvGamma = Shader.PropertyToID("_InvGamma");

				internal static readonly int _Gain = Shader.PropertyToID("_Gain");

				internal static readonly int _Slope = Shader.PropertyToID("_Slope");

				internal static readonly int _Power = Shader.PropertyToID("_Power");

				internal static readonly int _Offset = Shader.PropertyToID("_Offset");

				internal static readonly int _ChannelMixerRed = Shader.PropertyToID("_ChannelMixerRed");

				internal static readonly int _ChannelMixerGreen = Shader.PropertyToID("_ChannelMixerGreen");

				internal static readonly int _ChannelMixerBlue = Shader.PropertyToID("_ChannelMixerBlue");

				internal static readonly int _Curves = Shader.PropertyToID("_Curves");

				internal static readonly int _LogLut = Shader.PropertyToID("_LogLut");

				internal static readonly int _LogLut_Params = Shader.PropertyToID("_LogLut_Params");

				internal static readonly int _ExposureEV = Shader.PropertyToID("_ExposureEV");
			}

			private const int k_InternalLogLutSize = 32;

			private const int k_CurvePrecision = 128;

			private const float k_CurveStep = 1f / 128f;

			private Texture2D m_GradingCurves;

			private Color[] m_pixels = new Color[256];

			public override bool active
			{
				get
				{
					if (base.model.enabled)
					{
						return !context.interrupted;
					}
					return false;
				}
			}

			private float StandardIlluminantY(float x)
			{
				return 2.87f * x - 3f * x * x - 0.27509508f;
			}

			private Vector3 CIExyToLMS(float x, float y)
			{
				float num = 1f;
				float num2 = num * x / y;
				float num3 = num * (1f - x - y) / y;
				float x2 = 0.7328f * num2 + 0.4296f * num - 0.1624f * num3;
				float y2 = -0.7036f * num2 + 1.6975f * num + 0.0061f * num3;
				float z = 0.003f * num2 + 0.0136f * num + 0.9834f * num3;
				return new Vector3(x2, y2, z);
			}

			private Vector3 CalculateColorBalance(float temperature, float tint)
			{
				float num = temperature / 55f;
				float num2 = tint / 55f;
				float x = 0.31271f - num * ((num < 0f) ? 0.1f : 0.05f);
				float y = StandardIlluminantY(x) + num2 * 0.05f;
				Vector3 vector = new Vector3(0.949237f, 1.03542f, 1.08728f);
				Vector3 vector2 = CIExyToLMS(x, y);
				return new Vector3(vector.x / vector2.x, vector.y / vector2.y, vector.z / vector2.z);
			}

			private static Color NormalizeColor(Color c)
			{
				float num = (c.r + c.g + c.b) / 3f;
				if (Mathf.Approximately(num, 0f))
				{
					return new Color(1f, 1f, 1f, c.a);
				}
				Color result = default(Color);
				result.r = c.r / num;
				result.g = c.g / num;
				result.b = c.b / num;
				result.a = c.a;
				return result;
			}

			private static Vector3 ClampVector(Vector3 v, float min, float max)
			{
				return new Vector3(Mathf.Clamp(v.x, min, max), Mathf.Clamp(v.y, min, max), Mathf.Clamp(v.z, min, max));
			}

			public static Vector3 GetLiftValue(Color lift)
			{
				Color color = NormalizeColor(lift);
				float num = (color.r + color.g + color.b) / 3f;
				float x = (color.r - num) * 0.1f + lift.a;
				float y = (color.g - num) * 0.1f + lift.a;
				float z = (color.b - num) * 0.1f + lift.a;
				return ClampVector(new Vector3(x, y, z), -1f, 1f);
			}

			public static Vector3 GetGammaValue(Color gamma)
			{
				Color color = NormalizeColor(gamma);
				float num = (color.r + color.g + color.b) / 3f;
				gamma.a *= ((gamma.a < 0f) ? 0.8f : 5f);
				float b = Mathf.Pow(2f, (color.r - num) * 0.5f) + gamma.a;
				float b2 = Mathf.Pow(2f, (color.g - num) * 0.5f) + gamma.a;
				float b3 = Mathf.Pow(2f, (color.b - num) * 0.5f) + gamma.a;
				float x = 1f / Mathf.Max(0.01f, b);
				float y = 1f / Mathf.Max(0.01f, b2);
				float z = 1f / Mathf.Max(0.01f, b3);
				return ClampVector(new Vector3(x, y, z), 0f, 5f);
			}

			public static Vector3 GetGainValue(Color gain)
			{
				Color color = NormalizeColor(gain);
				float num = (color.r + color.g + color.b) / 3f;
				gain.a *= ((gain.a > 0f) ? 3f : 1f);
				float x = Mathf.Pow(2f, (color.r - num) * 0.5f) + gain.a;
				float y = Mathf.Pow(2f, (color.g - num) * 0.5f) + gain.a;
				float z = Mathf.Pow(2f, (color.b - num) * 0.5f) + gain.a;
				return ClampVector(new Vector3(x, y, z), 0f, 4f);
			}

			public static void CalculateLiftGammaGain(Color lift, Color gamma, Color gain, out Vector3 outLift, out Vector3 outGamma, out Vector3 outGain)
			{
				outLift = GetLiftValue(lift);
				outGamma = GetGammaValue(gamma);
				outGain = GetGainValue(gain);
			}

			public static Vector3 GetSlopeValue(Color slope)
			{
				Color color = NormalizeColor(slope);
				float num = (color.r + color.g + color.b) / 3f;
				slope.a *= 0.5f;
				float x = (color.r - num) * 0.1f + slope.a + 1f;
				float y = (color.g - num) * 0.1f + slope.a + 1f;
				float z = (color.b - num) * 0.1f + slope.a + 1f;
				return ClampVector(new Vector3(x, y, z), 0f, 2f);
			}

			public static Vector3 GetPowerValue(Color power)
			{
				Color color = NormalizeColor(power);
				float num = (color.r + color.g + color.b) / 3f;
				power.a *= 0.5f;
				float b = (color.r - num) * 0.1f + power.a + 1f;
				float b2 = (color.g - num) * 0.1f + power.a + 1f;
				float b3 = (color.b - num) * 0.1f + power.a + 1f;
				float x = 1f / Mathf.Max(0.01f, b);
				float y = 1f / Mathf.Max(0.01f, b2);
				float z = 1f / Mathf.Max(0.01f, b3);
				return ClampVector(new Vector3(x, y, z), 0.5f, 2.5f);
			}

			public static Vector3 GetOffsetValue(Color offset)
			{
				Color color = NormalizeColor(offset);
				float num = (color.r + color.g + color.b) / 3f;
				offset.a *= 0.5f;
				float x = (color.r - num) * 0.05f + offset.a;
				float y = (color.g - num) * 0.05f + offset.a;
				float z = (color.b - num) * 0.05f + offset.a;
				return ClampVector(new Vector3(x, y, z), -0.8f, 0.8f);
			}

			public static void CalculateSlopePowerOffset(Color slope, Color power, Color offset, out Vector3 outSlope, out Vector3 outPower, out Vector3 outOffset)
			{
				outSlope = GetSlopeValue(slope);
				outPower = GetPowerValue(power);
				outOffset = GetOffsetValue(offset);
			}

			private TextureFormat GetCurveFormat()
			{
				if (SystemInfo.SupportsTextureFormat(TextureFormat.RGBAHalf))
				{
					return TextureFormat.RGBAHalf;
				}
				return TextureFormat.RGBA32;
			}

			private Texture2D GetCurveTexture()
			{
				if (m_GradingCurves == null)
				{
					m_GradingCurves = new Texture2D(128, 2, GetCurveFormat(), mipChain: false, linear: true)
					{
						name = "Internal Curves Texture",
						hideFlags = HideFlags.DontSave,
						anisoLevel = 0,
						wrapMode = TextureWrapMode.Clamp,
						filterMode = FilterMode.Bilinear
					};
				}
				ColorGradingModel.CurvesSettings curves = base.model.settings.curves;
				curves.hueVShue.Cache();
				curves.hueVSsat.Cache();
				for (int i = 0; i < 128; i++)
				{
					float t = (float)i * (1f / 128f);
					float r = curves.hueVShue.Evaluate(t);
					float g = curves.hueVSsat.Evaluate(t);
					float b = curves.satVSsat.Evaluate(t);
					float a = curves.lumVSsat.Evaluate(t);
					m_pixels[i] = new Color(r, g, b, a);
					float a2 = curves.master.Evaluate(t);
					float r2 = curves.red.Evaluate(t);
					float g2 = curves.green.Evaluate(t);
					float b2 = curves.blue.Evaluate(t);
					m_pixels[i + 128] = new Color(r2, g2, b2, a2);
				}
				m_GradingCurves.SetPixels(m_pixels);
				m_GradingCurves.Apply(updateMipmaps: false, makeNoLongerReadable: false);
				return m_GradingCurves;
			}

			private bool IsLogLutValid(RenderTexture lut)
			{
				if (lut != null && lut.IsCreated())
				{
					return lut.height == 32;
				}
				return false;
			}

			private RenderTextureFormat GetLutFormat()
			{
				if (SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.ARGBHalf))
				{
					return RenderTextureFormat.ARGBHalf;
				}
				return RenderTextureFormat.ARGB32;
			}

			private void GenerateLut()
			{
				ColorGradingModel.Settings settings = base.model.settings;
				if (!IsLogLutValid(base.model.bakedLut))
				{
					GraphicsUtils.Destroy(base.model.bakedLut);
					base.model.bakedLut = new RenderTexture(1024, 32, 0, GetLutFormat())
					{
						name = "Color Grading Log LUT",
						hideFlags = HideFlags.DontSave,
						filterMode = FilterMode.Bilinear,
						wrapMode = TextureWrapMode.Clamp,
						anisoLevel = 0
					};
				}
				Material material = context.materialFactory.Get("Hidden/Post FX/Lut Generator");
				material.SetVector(Uniforms._LutParams, new Vector4(32f, 0.00048828125f, 1f / 64f, 1.032258f));
				material.shaderKeywords = null;
				ColorGradingModel.TonemappingSettings tonemapping = settings.tonemapping;
				switch (tonemapping.tonemapper)
				{
				case ColorGradingModel.Tonemapper.Neutral:
				{
					material.EnableKeyword("TONEMAPPING_NEUTRAL");
					float num = tonemapping.neutralBlackIn * 20f + 1f;
					float num2 = tonemapping.neutralBlackOut * 10f + 1f;
					float num3 = tonemapping.neutralWhiteIn / 20f;
					float num4 = 1f - tonemapping.neutralWhiteOut / 20f;
					float t = num / num2;
					float t2 = num3 / num4;
					float y = Mathf.Max(0f, Mathf.LerpUnclamped(0.57f, 0.37f, t));
					float z = Mathf.LerpUnclamped(0.01f, 0.24f, t2);
					float w = Mathf.Max(0f, Mathf.LerpUnclamped(0.02f, 0.2f, t));
					material.SetVector(Uniforms._NeutralTonemapperParams1, new Vector4(0.2f, y, z, w));
					material.SetVector(Uniforms._NeutralTonemapperParams2, new Vector4(0.02f, 0.3f, tonemapping.neutralWhiteLevel, tonemapping.neutralWhiteClip / 10f));
					break;
				}
				case ColorGradingModel.Tonemapper.ACES:
					material.EnableKeyword("TONEMAPPING_FILMIC");
					break;
				}
				material.SetFloat(Uniforms._HueShift, settings.basic.hueShift / 360f);
				material.SetFloat(Uniforms._Saturation, settings.basic.saturation);
				material.SetFloat(Uniforms._Contrast, settings.basic.contrast);
				material.SetVector(Uniforms._Balance, CalculateColorBalance(settings.basic.temperature, settings.basic.tint));
				CalculateLiftGammaGain(settings.colorWheels.linear.lift, settings.colorWheels.linear.gamma, settings.colorWheels.linear.gain, out var outLift, out var outGamma, out var outGain);
				material.SetVector(Uniforms._Lift, outLift);
				material.SetVector(Uniforms._InvGamma, outGamma);
				material.SetVector(Uniforms._Gain, outGain);
				CalculateSlopePowerOffset(settings.colorWheels.log.slope, settings.colorWheels.log.power, settings.colorWheels.log.offset, out var outSlope, out var outPower, out var outOffset);
				material.SetVector(Uniforms._Slope, outSlope);
				material.SetVector(Uniforms._Power, outPower);
				material.SetVector(Uniforms._Offset, outOffset);
				material.SetVector(Uniforms._ChannelMixerRed, settings.channelMixer.red);
				material.SetVector(Uniforms._ChannelMixerGreen, settings.channelMixer.green);
				material.SetVector(Uniforms._ChannelMixerBlue, settings.channelMixer.blue);
				material.SetTexture(Uniforms._Curves, GetCurveTexture());
				Graphics.Blit(null, base.model.bakedLut, material, 0);
			}

			public override void Prepare(Material uberMaterial)
			{
				if (base.model.isDirty || !IsLogLutValid(base.model.bakedLut))
				{
					GenerateLut();
					base.model.isDirty = false;
				}
				uberMaterial.EnableKeyword(context.profile.debugViews.IsModeActive(BuiltinDebugViewsModel.Mode.PreGradingLog) ? "COLOR_GRADING_LOG_VIEW" : "COLOR_GRADING");
				RenderTexture bakedLut = base.model.bakedLut;
				uberMaterial.SetTexture(Uniforms._LogLut, bakedLut);
				uberMaterial.SetVector(Uniforms._LogLut_Params, new Vector3(1f / (float)bakedLut.width, 1f / (float)bakedLut.height, (float)bakedLut.height - 1f));
				float value = Mathf.Exp(base.model.settings.basic.postExposure * 0.6931472f);
				uberMaterial.SetFloat(Uniforms._ExposureEV, value);
			}

			public void OnGUI()
			{
				RenderTexture bakedLut = base.model.bakedLut;
				GUI.DrawTexture(new Rect(context.viewport.x * (float)Screen.width + 8f, 8f, bakedLut.width, bakedLut.height), bakedLut);
			}

			public override void OnDisable()
			{
				GraphicsUtils.Destroy(m_GradingCurves);
				GraphicsUtils.Destroy(base.model.bakedLut);
				m_GradingCurves = null;
				base.model.bakedLut = null;
			}
		}
		public sealed class DepthOfFieldComponent : PostProcessingComponentRenderTexture<DepthOfFieldModel>
		{
			private static class Uniforms
			{
				internal static readonly int _DepthOfFieldTex = Shader.PropertyToID("_DepthOfFieldTex");

				internal static readonly int _DepthOfFieldCoCTex = Shader.PropertyToID("_DepthOfFieldCoCTex");

				internal static readonly int _Distance = Shader.PropertyToID("_Distance");

				internal static readonly int _LensCoeff = Shader.PropertyToID("_LensCoeff");

				internal static readonly int _MaxCoC = Shader.PropertyToID("_MaxCoC");

				internal static readonly int _RcpMaxCoC = Shader.PropertyToID("_RcpMaxCoC");

				internal static readonly int _RcpAspect = Shader.PropertyToID("_RcpAspect");

				internal static readonly int _MainTex = Shader.PropertyToID("_MainTex");

				internal static readonly int _CoCTex = Shader.PropertyToID("_CoCTex");

				internal static readonly int _TaaParams = Shader.PropertyToID("_TaaParams");

				internal static readonly int _DepthOfFieldParams = Shader.PropertyToID("_DepthOfFieldParams");
			}

			private const string k_ShaderString = "Hidden/Post FX/Depth Of Field";

			private RenderTexture m_CoCHistory;

			private const float k_FilmHeight = 0.024f;

			public override bool active
			{
				get
				{
					if (base.model.enabled)
					{
						return !context.interrupted;
					}
					return false;
				}
			}

			public override DepthTextureMode GetCameraFlags()
			{
				return DepthTextureMode.Depth;
			}

			private float CalculateFocalLength()
			{
				DepthOfFieldModel.Settings settings = base.model.settings;
				if (!settings.useCameraFov)
				{
					return settings.focalLength / 1000f;
				}
				float num = context.camera.fieldOfView * ((float)Math.PI / 180f);
				return 0.012f / Mathf.Tan(0.5f * num);
			}

			private float CalculateMaxCoCRadius(int screenHeight)
			{
				float num = (float)base.model.settings.kernelSize * 4f + 6f;
				return Mathf.Min(0.05f, num / (float)screenHeight);
			}

			private bool CheckHistory(int width, int height)
			{
				if (m_CoCHistory != null && m_CoCHistory.IsCreated() && m_CoCHistory.width == width)
				{
					return m_CoCHistory.height == height;
				}
				return false;
			}

			private RenderTextureFormat SelectFormat(RenderTextureFormat primary, RenderTextureFormat secondary)
			{
				if (SystemInfo.SupportsRenderTextureFormat(primary))
				{
					return primary;
				}
				if (SystemInfo.SupportsRenderTextureFormat(secondary))
				{
					return secondary;
				}
				return RenderTextureFormat.Default;
			}

			public void Prepare(RenderTexture source, Material uberMaterial, bool antialiasCoC, Vector2 taaJitter, float taaBlending)
			{
				DepthOfFieldModel.Settings settings = base.model.settings;
				RenderTextureFormat format = RenderTextureFormat.DefaultHDR;
				RenderTextureFormat format2 = SelectFormat(RenderTextureFormat.R8, RenderTextureFormat.RHalf);
				float num = CalculateFocalLength();
				float num2 = Mathf.Max(settings.focusDistance, num);
				float num3 = (float)source.width / (float)source.height;
				float num4 = num * num / (settings.aperture * (num2 - num) * 0.024f * 2f);
				float num5 = CalculateMaxCoCRadius(source.height);
				Material material = context.materialFactory.Get("Hidden/Post FX/Depth Of Field");
				material.SetFloat(Uniforms._Distance, num2);
				material.SetFloat(Uniforms._LensCoeff, num4);
				material.SetFloat(Uniforms._MaxCoC, num5);
				material.SetFloat(Uniforms._RcpMaxCoC, 1f / num5);
				material.SetFloat(Uniforms._RcpAspect, 1f / num3);
				RenderTexture renderTexture = context.renderTextureFactory.Get(context.width, context.height, 0, format2, RenderTextureReadWrite.Linear);
				Graphics.Blit(null, renderTexture, material, 0);
				if (antialiasCoC)
				{
					material.SetTexture(Uniforms._CoCTex, renderTexture);
					float z = (CheckHistory(context.width, context.height) ? taaBlending : 0f);
					material.SetVector(Uniforms._TaaParams, new Vector3(taaJitter.x, taaJitter.y, z));
					RenderTexture temporary = RenderTexture.GetTemporary(context.width, context.height, 0, format2);
					Graphics.Blit(m_CoCHistory, temporary, material, 1);
					context.renderTextureFactory.Release(renderTexture);
					if (m_CoCHistory != null)
					{
						RenderTexture.ReleaseTemporary(m_CoCHistory);
					}
					renderTexture = (m_CoCHistory = temporary);
				}
				RenderTexture renderTexture2 = context.renderTextureFactory.Get(context.width / 2, context.height / 2, 0, format);
				material.SetTexture(Uniforms._CoCTex, renderTexture);
				Graphics.Blit(source, renderTexture2, material, 2);
				RenderTexture renderTexture3 = context.renderTextureFactory.Get(context.width / 2, context.height / 2, 0, format);
				Graphics.Blit(renderTexture2, renderTexture3, material, (int)(3 + settings.kernelSize));
				Graphics.Blit(renderTexture3, renderTexture2, material, 7);
				uberMaterial.SetVector(Uniforms._DepthOfFieldParams, new Vector3(num2, num4, num5));
				if (context.profile.debugViews.IsModeActive(BuiltinDebugViewsModel.Mode.FocusPlane))
				{
					uberMaterial.EnableKeyword("DEPTH_OF_FIELD_COC_VIEW");
					context.Interrupt();
				}
				else
				{
					uberMaterial.SetTexture(Uniforms._DepthOfFieldTex, renderTexture2);
					uberMaterial.SetTexture(Uniforms._DepthOfFieldCoCTex, renderTexture);
					uberMaterial.EnableKeyword("DEPTH_OF_FIELD");
				}
				context.renderTextureFactory.Release(renderTexture3);
			}

			public override void OnDisable()
			{
				if (m_CoCHistory != null)
				{
					RenderTexture.ReleaseTemporary(m_CoCHistory);
				}
				m_CoCHistory = null;
			}
		}
		public sealed class DitheringComponent : PostProcessingComponentRenderTexture<DitheringModel>
		{
			private static class Uniforms
			{
				internal static readonly int _DitheringTex = Shader.PropertyToID("_DitheringTex");

				internal static readonly int _DitheringCoords = Shader.PropertyToID("_DitheringCoords");
			}

			private Texture2D[] noiseTextures;

			private int textureIndex;

			private const int k_TextureCount = 64;

			public override bool active
			{
				get
				{
					if (base.model.enabled)
					{
						return !context.interrupted;
					}
					return false;
				}
			}

			public override void OnDisable()
			{
				noiseTextures = null;
			}

			private void LoadNoiseTextures()
			{
				noiseTextures = new Texture2D[64];
				for (int i = 0; i < 64; i++)
				{
					noiseTextures[i] = Resources.Load<Texture2D>("Bluenoise64/LDR_LLL1_" + i);
				}
			}

			public override void Prepare(Material uberMaterial)
			{
				if (++textureIndex >= 64)
				{
					textureIndex = 0;
				}
				float value = Random.value;
				float value2 = Random.value;
				if (noiseTextures == null)
				{
					LoadNoiseTextures();
				}
				Texture2D texture2D = noiseTextures[textureIndex];
				uberMaterial.EnableKeyword("DITHERING");
				uberMaterial.SetTexture(Uniforms._DitheringTex, texture2D);
				uberMaterial.SetVector(Uniforms._DitheringCoords, new Vector4((float)context.width / (float)texture2D.width, (float)context.height / (float)texture2D.height, value, value2));
			}
		}
		public sealed class EyeAdaptationComponent : PostProcessingComponentRenderTexture<EyeAdaptationModel>
		{
			private static class Uniforms
			{
				internal static readonly int _Params = Shader.PropertyToID("_Params");

				internal static readonly int _Speed = Shader.PropertyToID("_Speed");

				internal static readonly int _ExposureCompensation = Shader.PropertyToID("_ExposureCompensation");

				internal static readonly int _AutoExposure = Shader.PropertyToID("_AutoExposure");

				internal static readonly int _DebugWidth = Shader.PropertyToID("_DebugWidth");

				internal static readonly int _Histogram = Shader.PropertyToID("_Histogram");

				internal static readonly int _Source = Shader.PropertyToID("_Source");

				internal static readonly int _ScaleOffsetRes = Shader.PropertyToID("_ScaleOffsetRes");
			}

			private ComputeShader m_EyeCompute;

			private ComputeBuffer m_HistogramBuffer;

			private readonly RenderTexture[] m_AutoExposurePool = new RenderTexture[2];

			private int m_AutoExposurePingPing;

			private RenderTexture m_CurrentAutoExposure;

			private RenderTexture m_DebugHistogram;

			private int m_FrameCount;

			private const int k_HistogramBins = 64;

			private const int k_HistogramThreadX = 16;

			private const int k_HistogramThreadY = 16;

			public override bool active
			{
				get
				{
					if (base.model.enabled && SystemInfo.supportsComputeShaders)
					{
						return !context.interrupted;
					}
					return false;
				}
			}

			public void ResetHistory()
			{
				m_FrameCount = 0;
			}

			public override void OnEnable()
			{
				m_FrameCount = 0;
			}

			public override void OnDisable()
			{
				RenderTexture[] autoExposurePool = m_AutoExposurePool;
				for (int i = 0; i < autoExposurePool.Length; i++)
				{
					GraphicsUtils.Destroy(autoExposurePool[i]);
				}
				if (m_HistogramBuffer != null)
				{
					m_HistogramBuffer.Release();
				}
				m_HistogramBuffer = null;
				if (m_DebugHistogram != null)
				{
					m_DebugHistogram.Release();
				}
				m_DebugHistogram = null;
			}

			private Vector4 GetHistogramScaleOffsetRes()
			{
				EyeAdaptationModel.Settings settings = base.model.settings;
				float num = settings.logMax - settings.logMin;
				float num2 = 1f / num;
				float y = (float)(-settings.logMin) * num2;
				return new Vector4(num2, y, Mathf.Floor((float)context.width / 2f), Mathf.Floor((float)context.height / 2f));
			}

			public Texture Prepare(RenderTexture source, Material uberMaterial)
			{
				EyeAdaptationModel.Settings settings = base.model.settings;
				if (m_EyeCompute == null)
				{
					m_EyeCompute = Resources.Load<ComputeShader>("Shaders/EyeHistogram");
				}
				Material material = context.materialFactory.Get("Hidden/Post FX/Eye Adaptation");
				material.shaderKeywords = null;
				if (m_HistogramBuffer == null)
				{
					m_HistogramBuffer = new ComputeBuffer(64, 4);
				}
				Vector4 histogramScaleOffsetRes = GetHistogramScaleOffsetRes();
				RenderTexture renderTexture = context.renderTextureFactory.Get((int)histogramScaleOffsetRes.z, (int)histogramScaleOffsetRes.w, 0, source.format);
				Graphics.Blit(source, renderTexture);
				if (m_AutoExposurePool[0] == null || !m_AutoExposurePool[0].IsCreated())
				{
					m_AutoExposurePool[0] = new RenderTexture(1, 1, 0, RenderTextureFormat.RFloat);
				}
				if (m_AutoExposurePool[1] == null || !m_AutoExposurePool[1].IsCreated())
				{
					m_AutoExposurePool[1] = new RenderTexture(1, 1, 0, RenderTextureFormat.RFloat);
				}
				int kernelIndex = m_EyeCompute.FindKernel("KEyeHistogramClear");
				m_EyeCompute.SetBuffer(kernelIndex, Uniforms._Histogram, m_HistogramBuffer);
				m_EyeCompute.Dispatch(kernelIndex, Mathf.CeilToInt(4f), 1, 1);
				kernelIndex = m_EyeCompute.FindKernel("KEyeHistogram");
				m_EyeCompute.SetBuffer(kernelIndex, Uniforms._Histogram, m_HistogramBuffer);
				m_EyeCompute.SetTexture(kernelIndex, Uniforms._Source, renderTexture);
				m_EyeCompute.SetVector(Uniforms._ScaleOffsetRes, histogramScaleOffsetRes);
				m_EyeCompute.Dispatch(kernelIndex, Mathf.CeilToInt((float)renderTexture.width / 16f), Mathf.CeilToInt((float)renderTexture.height / 16f), 1);
				context.renderTextureFactory.Release(renderTexture);
				settings.highPercent = Mathf.Clamp(settings.highPercent, 1.01f, 99f);
				settings.lowPercent = Mathf.Clamp(settings.lowPercent, 1f, settings.highPercent - 0.01f);
				material.SetBuffer(Uniforms._Histogram, m_HistogramBuffer);
				material.SetVector(Uniforms._Params, new Vector4(settings.lowPercent * 0.01f, settings.highPercent * 0.01f, Mathf.Exp(settings.minLuminance * 0.6931472f), Mathf.Exp(settings.maxLuminance * 0.6931472f)));
				material.SetVector(Uniforms._Speed, new Vector2(settings.speedDown, settings.speedUp));
				material.SetVector(Uniforms._ScaleOffsetRes, histogramScaleOffsetRes);
				material.SetFloat(Uniforms._ExposureCompensation, settings.keyValue);
				if (settings.dynamicKeyValue)
				{
					material.EnableKeyword("AUTO_KEY_VALUE");
				}
				if (m_FrameCount < 2 || !Application.isPlaying)
				{
					m_CurrentAutoExposure = m_AutoExposurePool[0];
					Graphics.Blit(null, m_CurrentAutoExposure, material, 1);
					Graphics.Blit(m_AutoExposurePool[0], m_AutoExposurePool[1]);
				}
				else
				{
					int autoExposurePingPing = m_AutoExposurePingPing;
					RenderTexture source2 = m_AutoExposurePool[++autoExposurePingPing % 2];
					RenderTexture renderTexture2 = m_AutoExposurePool[++autoExposurePingPing % 2];
					Graphics.Blit(source2, renderTexture2, material, (int)settings.adaptationType);
					m_AutoExposurePingPing = ++autoExposurePingPing % 2;
					m_CurrentAutoExposure = renderTexture2;
				}
				if (context.profile.debugViews.IsModeActive(BuiltinDebugViewsModel.Mode.EyeAdaptation))
				{
					if (m_DebugHistogram == null || !m_DebugHistogram.IsCreated())
					{
						m_DebugHistogram = new RenderTexture(256, 128, 0, RenderTextureFormat.ARGB32)
						{
							filterMode = FilterMode.Point,
							wrapMode = TextureWrapMode.Clamp
						};
					}
					material.SetFloat(Uniforms._DebugWidth, m_DebugHistogram.width);
					Graphics.Blit(null, m_DebugHistogram, material, 2);
				}
				m_FrameCount++;
				return m_CurrentAutoExposure;
			}

			public void OnGUI()
			{
				if (!(m_DebugHistogram == null) && m_DebugHistogram.IsCreated())
				{
					GUI.DrawTexture(new Rect(context.viewport.x * (float)Screen.width + 8f, 8f, m_DebugHistogram.width, m_DebugHistogram.height), m_DebugHistogram);
				}
			}
		}
		public sealed class FogComponent : PostProcessingComponentCommandBuffer<FogModel>
		{
			private static class Uniforms
			{
				internal static readonly int _FogColor = Shader.PropertyToID("_FogColor");

				internal static readonly int _Density = Shader.PropertyToID("_Density");

				internal static readonly int _Start = Shader.PropertyToID("_Start");

				internal static readonly int _End = Shader.PropertyToID("_End");

				internal static readonly int _TempRT = Shader.PropertyToID("_TempRT");
			}

			private const string k_ShaderString = "Hidden/Post FX/Fog";

			public override bool active
			{
				get
				{
					if (base.model.enabled && context.isGBufferAvailable && RenderSettings.fog)
					{
						return !context.interrupted;
					}
					return false;
				}
			}

			public override string GetName()
			{
				return "Fog";
			}

			public override DepthTextureMode GetCameraFlags()
			{
				return DepthTextureMode.Depth;
			}

			public override CameraEvent GetCameraEvent()
			{
				return CameraEvent.AfterImageEffectsOpaque;
			}

			public override void PopulateCommandBuffer(CommandBuffer cb)
			{
				FogModel.Settings settings = base.model.settings;
				Material material = context.materialFactory.Get("Hidden/Post FX/Fog");
				material.shaderKeywords = null;
				Color value = (GraphicsUtils.isLinearColorSpace ? RenderSettings.fogColor.linear : RenderSettings.fogColor);
				material.SetColor(Uniforms._FogColor, value);
				material.SetFloat(Uniforms._Density, RenderSettings.fogDensity);
				material.SetFloat(Uniforms._Start, RenderSettings.fogStartDistance);
				material.SetFloat(Uniforms._End, RenderSettings.fogEndDistance);
				switch (RenderSettings.fogMode)
				{
				case FogMode.Linear:
					material.EnableKeyword("FOG_LINEAR");
					break;
				case FogMode.Exponential:
					material.EnableKeyword("FOG_EXP");
					break;
				case FogMode.ExponentialSquared:
					material.EnableKeyword("FOG_EXP2");
					break;
				}
				RenderTextureFormat format = (context.isHdr ? RenderTextureFormat.DefaultHDR : RenderTextureFormat.Default);
				cb.GetTemporaryRT(Uniforms._TempRT, context.width, context.height, 24, FilterMode.Bilinear, format);
				cb.Blit(BuiltinRenderTextureType.CameraTarget, Uniforms._TempRT);
				cb.Blit(Uniforms._TempRT, BuiltinRenderTextureType.CameraTarget, material, settings.excludeSkybox ? 1 : 0);
				cb.ReleaseTemporaryRT(Uniforms._TempRT);
			}
		}
		public sealed class FxaaComponent : PostProcessingComponentRenderTexture<AntialiasingModel>
		{
			private static class Uniforms
			{
				internal static readonly int _QualitySettings = Shader.PropertyToID("_QualitySettings");

				internal static readonly int _ConsoleSettings = Shader.PropertyToID("_ConsoleSettings");
			}

			public override bool active
			{
				get
				{
					if (base.model.enabled && base.model.settings.method == AntialiasingModel.Method.Fxaa)
					{
						return !context.interrupted;
					}
					return false;
				}
			}

			public void Render(RenderTexture source, RenderTexture destination)
			{
				AntialiasingModel.FxaaSettings fxaaSettings = base.model.settings.fxaaSettings;
				Material material = context.materialFactory.Get("Hidden/Post FX/FXAA");
				AntialiasingModel.FxaaQualitySettings fxaaQualitySettings = AntialiasingModel.FxaaQualitySettings.presets[(int)fxaaSettings.preset];
				AntialiasingModel.FxaaConsoleSettings fxaaConsoleSettings = AntialiasingModel.FxaaConsoleSettings.presets[(int)fxaaSettings.preset];
				material.SetVector(Uniforms._QualitySettings, new Vector3(fxaaQualitySettings.subpixelAliasingRemovalAmount, fxaaQualitySettings.edgeDetectionThreshold, fxaaQualitySettings.minimumRequiredLuminance));
				material.SetVector(Uniforms._ConsoleSettings, new Vector4(fxaaConsoleSettings.subpixelSpreadAmount, fxaaConsoleSettings.edgeSharpnessAmount, fxaaConsoleSettings.edgeDetectionThreshold, fxaaConsoleSettings.minimumRequiredLuminance));
				Graphics.Blit(source, destination, material, 0);
			}
		}
		public sealed class GrainComponent : PostProcessingComponentRenderTexture<GrainModel>
		{
			private static class Uniforms
			{
				internal static readonly int _Grain_Params1 = Shader.PropertyToID("_Grain_Params1");

				internal static readonly int _Grain_Params2 = Shader.PropertyToID("_Grain_Params2");

				internal static readonly int _GrainTex = Shader.PropertyToID("_GrainTex");

				internal static readonly int _Phase = Shader.PropertyToID("_Phase");
			}

			private RenderTexture m_GrainLookupRT;

			public override bool active
			{
				get
				{
					if (base.model.enabled && base.model.settings.intensity > 0f && SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.ARGBHalf))
					{
						return !context.interrupted;
					}
					return false;
				}
			}

			public override void OnDisable()
			{
				GraphicsUtils.Destroy(m_GrainLookupRT);
				m_GrainLookupRT = null;
			}

			public override void Prepare(Material uberMaterial)
			{
				GrainModel.Settings settings = base.model.settings;
				uberMaterial.EnableKeyword("GRAIN");
				float realtimeSinceStartup = Time.realtimeSinceStartup;
				float value = Random.value;
				float value2 = Random.value;
				if (m_GrainLookupRT == null || !m_GrainLookupRT.IsCreated())
				{
					GraphicsUtils.Destroy(m_GrainLookupRT);
					m_GrainLookupRT = new RenderTexture(192, 192, 0, RenderTextureFormat.ARGBHalf)
					{
						filterMode = FilterMode.Bilinear,
						wrapMode = TextureWrapMode.Repeat,
						anisoLevel = 0,
						name = "Grain Lookup Texture"
					};
					m_GrainLookupRT.Create();
				}
				Material material = context.materialFactory.Get("Hidden/Post FX/Grain Generator");
				material.SetFloat(Uniforms._Phase, realtimeSinceStartup / 20f);
				Graphics.Blit(null, m_GrainLookupRT, material, settings.colored ? 1 : 0);
				uberMaterial.SetTexture(Uniforms._GrainTex, m_GrainLookupRT);
				uberMaterial.SetVector(Uniforms._Grain_Params1, new Vector2(settings.luminanceContribution, settings.intensity * 20f));
				uberMaterial.SetVector(Uniforms._Grain_Params2, new Vector4((float)context.width / (float)m_GrainLookupRT.width / settings.size, (float)context.height / (float)m_GrainLookupRT.height / settings.size, value, value2));
			}
		}
		public sealed class MotionBlurComponent : PostProcessingComponentCommandBuffer<MotionBlurModel>
		{
			private static class Uniforms
			{
				internal static readonly int _VelocityScale = Shader.PropertyToID("_VelocityScale");

				internal static readonly int _MaxBlurRadius = Shader.PropertyToID("_MaxBlurRadius");

				internal static readonly int _RcpMaxBlurRadius = Shader.PropertyToID("_RcpMaxBlurRadius");

				internal static readonly int _VelocityTex = Shader.PropertyToID("_VelocityTex");

				internal static readonly int _MainTex = Shader.PropertyToID("_MainTex");

				internal static readonly int _Tile2RT = Shader.PropertyToID("_Tile2RT");

				internal static readonly int _Tile4RT = Shader.PropertyToID("_Tile4RT");

				internal static readonly int _Tile8RT = Shader.PropertyToID("_Tile8RT");

				internal static readonly int _TileMaxOffs = Shader.PropertyToID("_TileMaxOffs");

				internal static readonly int _TileMaxLoop = Shader.PropertyToID("_TileMaxLoop");

				internal static readonly int _TileVRT = Shader.PropertyToID("_TileVRT");

				internal static readonly int _NeighborMaxTex = Shader.PropertyToID("_NeighborMaxTex");

				internal static readonly int _LoopCount = Shader.PropertyToID("_LoopCount");

				internal static readonly int _TempRT = Shader.PropertyToID("_TempRT");

				internal static readonly int _History1LumaTex = Shader.PropertyToID("_History1LumaTex");

				internal static readonly int _History2LumaTex = Shader.PropertyToID("_History2LumaTex");

				internal static readonly int _History3LumaTex = Shader.PropertyToID("_History3LumaTex");

				internal static readonly int _History4LumaTex = Shader.PropertyToID("_History4LumaTex");

				internal static readonly int _History1ChromaTex = Shader.PropertyToID("_History1ChromaTex");

				internal static readonly int _History2ChromaTex = Shader.PropertyToID("_History2ChromaTex");

				internal static readonly int _History3ChromaTex = Shader.PropertyToID("_History3ChromaTex");

				internal static readonly int _History4ChromaTex = Shader.PropertyToID("_History4ChromaTex");

				internal static readonly int _History1Weight = Shader.PropertyToID("_History1Weight");

				internal static readonly int _History2Weight = Shader.PropertyToID("_History2Weight");

				internal static readonly int _History3Weight = Shader.PropertyToID("_History3Weight");

				internal static readonly int _History4Weight = Shader.PropertyToID("_History4Weight");
			}

			private enum Pass
			{
				VelocitySetup,
				TileMax1,
				TileMax2,
				TileMaxV,
				NeighborMax,
				Reconstruction,
				FrameCompression,
				FrameBlendingChroma,
				FrameBlendingRaw
			}

			public class ReconstructionFilter
			{
				private RenderTextureFormat m_VectorRTFormat = RenderTextureFormat.RGHalf;

				private RenderTextureFormat m_PackedRTFormat = RenderTextureFormat.ARGB2101010;

				public ReconstructionFilter()
				{
					CheckTextureFormatSupport();
				}

				private void CheckTextureFormatSupport()
				{
					if (!SystemInfo.SupportsRenderTextureFormat(m_PackedRTFormat))
					{
						m_PackedRTFormat = RenderTextureFormat.ARGB32;
					}
				}

				public bool IsSupported()
				{
					return SystemInfo.supportsMotionVectors;
				}

				public void ProcessImage(PostProcessingContext context, CommandBuffer cb, ref MotionBlurModel.Settings settings, RenderTargetIdentifier source, RenderTargetIdentifier destination, Material material)
				{
					int num = (int)(5f * (float)context.height / 100f);
					int num2 = ((num - 1) / 8 + 1) * 8;
					float value = settings.shutterAngle / 360f;
					cb.SetGlobalFloat(Uniforms._VelocityScale, value);
					cb.SetGlobalFloat(Uniforms._MaxBlurRadius, num);
					cb.SetGlobalFloat(Uniforms._RcpMaxBlurRadius, 1f / (float)num);
					int velocityTex = Uniforms._VelocityTex;
					cb.GetTemporaryRT(velocityTex, context.width, context.height, 0, FilterMode.Point, m_PackedRTFormat, RenderTextureReadWrite.Linear);
					cb.Blit(null, velocityTex, material, 0);
					int tile2RT = Uniforms._Tile2RT;
					cb.GetTemporaryRT(tile2RT, context.width / 2, context.height / 2, 0, FilterMode.Point, m_VectorRTFormat, RenderTextureReadWrite.Linear);
					cb.SetGlobalTexture(Uniforms._MainTex, velocityTex);
					cb.Blit(velocityTex, tile2RT, material, 1);
					int tile4RT = Uniforms._Tile4RT;
					cb.GetTemporaryRT(tile4RT, context.width / 4, context.height / 4, 0, FilterMode.Point, m_VectorRTFormat, RenderTextureReadWrite.Linear);
					cb.SetGlobalTexture(Uniforms._MainTex, tile2RT);
					cb.Blit(tile2RT, tile4RT, material, 2);
					cb.ReleaseTemporaryRT(tile2RT);
					int tile8RT = Uniforms._Tile8RT;
					cb.GetTemporaryRT(tile8RT, context.width / 8, context.height / 8, 0, FilterMode.Point, m_VectorRTFormat, RenderTextureReadWrite.Linear);
					cb.SetGlobalTexture(Uniforms._MainTex, tile4RT);
					cb.Blit(tile4RT, tile8RT, material, 2);
					cb.ReleaseTemporaryRT(tile4RT);
					Vector2 vector = Vector2.one * ((float)num2 / 8f - 1f) * -0.5f;
					cb.SetGlobalVector(Uniforms._TileMaxOffs, vector);
					cb.SetGlobalFloat(Uniforms._TileMaxLoop, (int)((float)num2 / 8f));
					int tileVRT = Uniforms._TileVRT;
					cb.GetTemporaryRT(tileVRT, context.width / num2, context.height / num2, 0, FilterMode.Point, m_VectorRTFormat, RenderTextureReadWrite.Linear);
					cb.SetGlobalTexture(Uniforms._MainTex, tile8RT);
					cb.Blit(tile8RT, tileVRT, material, 3);
					cb.ReleaseTemporaryRT(tile8RT);
					int neighborMaxTex = Uniforms._NeighborMaxTex;
					int width = context.width / num2;
					int height = context.height / num2;
					cb.GetTemporaryRT(neighborMaxTex, width, height, 0, FilterMode.Point, m_VectorRTFormat, RenderTextureReadWrite.Linear);
					cb.SetGlobalTexture(Uniforms._MainTex, tileVRT);
					cb.Blit(tileVRT, neighborMaxTex, material, 4);
					cb.ReleaseTemporaryRT(tileVRT);
					cb.SetGlobalFloat(Uniforms._LoopCount, Mathf.Clamp(settings.sampleCount / 2, 1, 64));
					cb.SetGlobalTexture(Uniforms._MainTex, source);
					cb.Blit(source, destination, material, 5);
					cb.ReleaseTemporaryRT(velocityTex);
					cb.ReleaseTemporaryRT(neighborMaxTex);
				}
			}

			public class FrameBlendingFilter
			{
				private struct Frame
				{
					public RenderTexture lumaTexture;

					public RenderTexture chromaTexture;

					private float m_Time;

					private RenderTargetIdentifier[] m_MRT;

					public float CalculateWeight(float strength, float currentTime)
					{
						if (Mathf.Approximately(m_Time, 0f))
						{
							return 0f;
						}
						float num = Mathf.Lerp(80f, 16f, strength);
						return Mathf.Exp((m_Time - currentTime) * num);
					}

					public void Release()
					{
						if (lumaTexture != null)
						{
							RenderTexture.ReleaseTemporary(lumaTexture);
						}
						if (chromaTexture != null)
						{
							RenderTexture.ReleaseTemporary(chromaTexture);
						}
						lumaTexture = null;
						chromaTexture = null;
					}

					public void MakeRecord(CommandBuffer cb, RenderTargetIdentifier source, int width, int height, Material material)
					{
						Release();
						lumaTexture = RenderTexture.GetTemporary(width, height, 0, RenderTextureFormat.R8, RenderTextureReadWrite.Linear);
						chromaTexture = RenderTexture.GetTemporary(width, height, 0, RenderTextureFormat.R8, RenderTextureReadWrite.Linear);
						lumaTexture.filterMode = FilterMode.Point;
						chromaTexture.filterMode = FilterMode.Point;
						if (m_MRT == null)
						{
							m_MRT = new RenderTargetIdentifier[2];
						}
						m_MRT[0] = lumaTexture;
						m_MRT[1] = chromaTexture;
						cb.SetGlobalTexture(Uniforms._MainTex, source);
						cb.SetRenderTarget(m_MRT, lumaTexture);
						cb.DrawMesh(GraphicsUtils.quad, Matrix4x4.identity, material, 0, 6);
						m_Time = Time.time;
					}

					public void MakeRecordRaw(CommandBuffer cb, RenderTargetIdentifier source, int width, int height, RenderTextureFormat format)
					{
						Release();
						lumaTexture = RenderTexture.GetTemporary(width, height, 0, format);
						lumaTexture.filterMode = FilterMode.Point;
						cb.SetGlobalTexture(Uniforms._MainTex, source);
						cb.Blit(source, lumaTexture);
						m_Time = Time.time;
					}
				}

				private bool m_UseCompression;

				private RenderTextureFormat m_RawTextureFormat;

				private Frame[] m_FrameList;

				private int m_LastFrameCount;

				public FrameBlendingFilter()
				{
					m_UseCompression = CheckSupportCompression();
					m_RawTextureFormat = GetPreferredRenderTextureFormat();
					m_FrameList = new Frame[4];
				}

				public void Dispose()
				{
					Frame[] frameList = m_FrameList;
					foreach (Frame frame in frameList)
					{
						frame.Release();
					}
				}

				public void PushFrame(CommandBuffer cb, RenderTargetIdentifier source, int width, int height, Material material)
				{
					int frameCount = Time.frameCount;
					if (frameCount != m_LastFrameCount)
					{
						int num = frameCount % m_FrameList.Length;
						if (m_UseCompression)
						{
							m_FrameList[num].MakeRecord(cb, source, width, height, material);
						}
						else
						{
							m_FrameList[num].MakeRecordRaw(cb, source, width, height, m_RawTextureFormat);
						}
						m_LastFrameCount = frameCount;
					}
				}

				public void BlendFrames(CommandBuffer cb, float strength, RenderTargetIdentifier source, RenderTargetIdentifier destination, Material material)
				{
					float time = Time.time;
					Frame frameRelative = GetFrameRelative(-1);
					Frame frameRelative2 = GetFrameRelative(-2);
					Frame frameRelative3 = GetFrameRelative(-3);
					Frame frameRelative4 = GetFrameRelative(-4);
					cb.SetGlobalTexture(Uniforms._History1LumaTex, frameRelative.lumaTexture);
					cb.SetGlobalTexture(Uniforms._History2LumaTex, frameRelative2.lumaTexture);
					cb.SetGlobalTexture(Uniforms._History3LumaTex, frameRelative3.lumaTexture);
					cb.SetGlobalTexture(Uniforms._History4LumaTex, frameRelative4.lumaTexture);
					cb.SetGlobalTexture(Uniforms._History1ChromaTex, frameRelative.chromaTexture);
					cb.SetGlobalTexture(Uniforms._History2ChromaTex, frameRelative2.chromaTexture);
					cb.SetGlobalTexture(Uniforms._History3ChromaTex, frameRelative3.chromaTexture);
					cb.SetGlobalTexture(Uniforms._History4ChromaTex, frameRelative4.chromaTexture);
					cb.SetGlobalFloat(Uniforms._History1Weight, frameRelative.CalculateWeight(strength, time));
					cb.SetGlobalFloat(Uniforms._History2Weight, frameRelative2.CalculateWeight(strength, time));
					cb.SetGlobalFloat(Uniforms._History3Weight, frameRelative3.CalculateWeight(strength, time));
					cb.SetGlobalFloat(Uniforms._History4Weight, frameRelative4.CalculateWeight(strength, time));
					cb.SetGlobalTexture(Uniforms._MainTex, source);
					cb.Blit(source, destination, material, m_UseCompression ? 7 : 8);
				}

				private static bool CheckSupportCompression()
				{
					if (SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.R8))
					{
						return SystemInfo.supportedRenderTargetCount > 1;
					}
					return false;
				}

				private static RenderTextureFormat GetPreferredRenderTextureFormat()
				{
					RenderTextureFormat[] array = new RenderTextureFormat[3]
					{
						RenderTextureFormat.RGB565,
						RenderTextureFormat.ARGB1555,
						RenderTextureFormat.ARGB4444
					};
					foreach (RenderTextureFormat renderTextureFormat in array)
					{
						if (SystemInfo.SupportsRenderTextureFormat(renderTextureFormat))
						{
							return renderTextureFormat;
						}
					}
					return RenderTextureFormat.Default;
				}

				private Frame GetFrameRelative(int offset)
				{
					int num = (Time.frameCount + m_FrameList.Length + offset) % m_FrameList.Length;
					return m_FrameList[num];
				}
			}

			private ReconstructionFilter m_ReconstructionFilter;

			private FrameBlendingFilter m_FrameBlendingFilter;

			private int m_FrameCount;

			public ReconstructionFilter reconstructionFilter
			{
				get
				{
					if (m_ReconstructionFilter == null)
					{
						m_ReconstructionFilter = new ReconstructionFilter();
					}
					return m_ReconstructionFilter;
				}
			}

			public FrameBlendingFilter frameBlendingFilter
			{
				get
				{
					if (m_FrameBlendingFilter == null)
					{
						m_FrameBlendingFilter = new FrameBlendingFilter();
					}
					return m_FrameBlendingFilter;
				}
			}

			public override bool active
			{
				get
				{
					MotionBlurModel.Settings settings = base.model.settings;
					if (base.model.enabled && ((settings.shutterAngle > 0f && reconstructionFilter.IsSupported()) || settings.frameBlending > 0f) && SystemInfo.graphicsDeviceType != GraphicsDeviceType.OpenGLES2)
					{
						return !context.interrupted;
					}
					return false;
				}
			}

			public override string GetName()
			{
				return "Motion Blur";
			}

			public void ResetHistory()
			{
				if (m_FrameBlendingFilter != null)
				{
					m_FrameBlendingFilter.Dispose();
				}
				m_FrameBlendingFilter = null;
				m_FrameCount = 0;
			}

			public override DepthTextureMode GetCameraFlags()
			{
				return DepthTextureMode.Depth | DepthTextureMode.MotionVectors;
			}

			public override CameraEvent GetCameraEvent()
			{
				return CameraEvent.BeforeImageEffects;
			}

			public override void OnEnable()
			{
				m_FrameCount = 0;
			}

			public override void PopulateCommandBuffer(CommandBuffer cb)
			{
				if (m_FrameCount < 2)
				{
					m_FrameCount++;
					return;
				}
				Material material = context.materialFactory.Get("Hidden/Post FX/Motion Blur");
				Material mat = context.materialFactory.Get("Hidden/Post FX/Blit");
				MotionBlurModel.Settings settings = base.model.settings;
				RenderTextureFormat format = (context.isHdr ? RenderTextureFormat.DefaultHDR : RenderTextureFormat.Default);
				int tempRT = Uniforms._TempRT;
				cb.GetTemporaryRT(tempRT, context.width, context.height, 0, FilterMode.Point, format);
				if (settings.shutterAngle > 0f && settings.frameBlending > 0f)
				{
					reconstructionFilter.ProcessImage(context, cb, ref settings, BuiltinRenderTextureType.CameraTarget, tempRT, material);
					frameBlendingFilter.BlendFrames(cb, settings.frameBlending, tempRT, BuiltinRenderTextureType.CameraTarget, material);
					frameBlendingFilter.PushFrame(cb, tempRT, context.width, context.height, material);
				}
				else if (settings.shutterAngle > 0f)
				{
					cb.SetGlobalTexture(Uniforms._MainTex, BuiltinRenderTextureType.CameraTarget);
					cb.Blit(BuiltinRenderTextureType.CameraTarget, tempRT, mat, 0);
					reconstructionFilter.ProcessImage(context, cb, ref settings, tempRT, BuiltinRenderTextureType.CameraTarget, material);
				}
				else if (settings.frameBlending > 0f)
				{
					cb.SetGlobalTexture(Uniforms._MainTex, BuiltinRenderTextureType.CameraTarget);
					cb.Blit(BuiltinRenderTextureType.CameraTarget, tempRT, mat, 0);
					frameBlendingFilter.BlendFrames(cb, settings.frameBlending, tempRT, BuiltinRenderTextureType.CameraTarget, material);
					frameBlendingFilter.PushFrame(cb, tempRT, context.width, context.height, material);
				}
				cb.ReleaseTemporaryRT(tempRT);
			}

			public override void OnDisable()
			{
				if (m_FrameBlendingFilter != null)
				{
					m_FrameBlendingFilter.Dispose();
				}
			}
		}
		public sealed class ScreenSpaceReflectionComponent : PostProcessingComponentCommandBuffer<ScreenSpaceReflectionModel>
		{
			private static class Uniforms
			{
				internal static readonly int _RayStepSize = Shader.PropertyToID("_RayStepSize");

				internal static readonly int _AdditiveReflection = Shader.PropertyToID("_AdditiveReflection");

				internal static readonly int _BilateralUpsampling = Shader.PropertyToID("_BilateralUpsampling");

				internal static readonly int _TreatBackfaceHitAsMiss = Shader.PropertyToID("_TreatBackfaceHitAsMiss");

				internal static readonly int _AllowBackwardsRays = Shader.PropertyToID("_AllowBackwardsRays");

				internal static readonly int _TraceBehindObjects = Shader.PropertyToID("_TraceBehindObjects");

				internal static readonly int _MaxSteps = Shader.PropertyToID("_MaxSteps");

				internal static readonly int _FullResolutionFiltering = Shader.PropertyToID("_FullResolutionFiltering");

				internal static readonly int _HalfResolution = Shader.PropertyToID("_HalfResolution");

				internal static readonly int _HighlightSuppression = Shader.PropertyToID("_HighlightSuppression");

				internal static readonly int _PixelsPerMeterAtOneMeter = Shader.PropertyToID("_PixelsPerMeterAtOneMeter");

				internal static readonly int _ScreenEdgeFading = Shader.PropertyToID("_ScreenEdgeFading");

				internal static readonly int _ReflectionBlur = Shader.PropertyToID("_ReflectionBlur");

				internal static readonly int _MaxRayTraceDistance = Shader.PropertyToID("_MaxRayTraceDistance");

				internal static readonly int _FadeDistance = Shader.PropertyToID("_FadeDistance");

				internal static readonly int _LayerThickness = Shader.PropertyToID("_LayerThickness");

				internal static readonly int _SSRMultiplier = Shader.PropertyToID("_SSRMultiplier");

				internal static readonly int _FresnelFade = Shader.PropertyToID("_FresnelFade");

				internal static readonly int _FresnelFadePower = Shader.PropertyToID("_FresnelFadePower");

				internal static readonly int _ReflectionBufferSize = Shader.PropertyToID("_ReflectionBufferSize");

				internal static readonly int _ScreenSize = Shader.PropertyToID("_ScreenSize");

				internal static readonly int _InvScreenSize = Shader.PropertyToID("_InvScreenSize");

				internal static readonly int _ProjInfo = Shader.PropertyToID("_ProjInfo");

				internal static readonly int _CameraClipInfo = Shader.PropertyToID("_CameraClipInfo");

				internal static readonly int _ProjectToPixelMatrix = Shader.PropertyToID("_ProjectToPixelMatrix");

				internal static readonly int _WorldToCameraMatrix = Shader.PropertyToID("_WorldToCameraMatrix");

				internal static readonly int _CameraToWorldMatrix = Shader.PropertyToID("_CameraToWorldMatrix");

				internal static readonly int _Axis = Shader.PropertyToID("_Axis");

				internal static readonly int _CurrentMipLevel = Shader.PropertyToID("_CurrentMipLevel");

				internal static readonly int _NormalAndRoughnessTexture = Shader.PropertyToID("_NormalAndRoughnessTexture");

				internal static readonly int _HitPointTexture = Shader.PropertyToID("_HitPointTexture");

				internal static readonly int _BlurTexture = Shader.PropertyToID("_BlurTexture");

				internal static readonly int _FilteredReflections = Shader.PropertyToID("_FilteredReflections");

				internal static readonly int _FinalReflectionTexture = Shader.PropertyToID("_FinalReflectionTexture");

				internal static readonly int _TempTexture = Shader.PropertyToID("_TempTexture");
			}

			private enum PassIndex
			{
				RayTraceStep,
				CompositeFinal,
				Blur,
				CompositeSSR,
				MinMipGeneration,
				HitPointToReflections,
				BilateralKeyPack,
				BlitDepthAsCSZ,
				PoissonBlur
			}

			private bool k_HighlightSuppression;

			private bool k_TraceBehindObjects = true;

			private bool k_TreatBackfaceHitAsMiss;

			private bool k_BilateralUpsample = true;

			private readonly int[] m_ReflectionTextures = new int[5];

			public override bool active
			{
				get
				{
					if (base.model.enabled && context.isGBufferAvailable)
					{
						return !context.interrupted;
					}
					return false;
				}
			}

			public override DepthTextureMode GetCameraFlags()
			{
				return DepthTextureMode.Depth;
			}

			public override void OnEnable()
			{
				m_ReflectionTextures[0] = Shader.PropertyToID("_ReflectionTexture0");
				m_ReflectionTextures[1] = Shader.PropertyToID("_ReflectionTexture1");
				m_ReflectionTextures[2] = Shader.PropertyToID("_ReflectionTexture2");
				m_ReflectionTextures[3] = Shader.PropertyToID("_ReflectionTexture3");
				m_ReflectionTextures[4] = Shader.PropertyToID("_ReflectionTexture4");
			}

			public override string GetName()
			{
				return "Screen Space Reflection";
			}

			public override CameraEvent GetCameraEvent()
			{
				return CameraEvent.AfterFinalPass;
			}

			public override void PopulateCommandBuffer(CommandBuffer cb)
			{
				ScreenSpaceReflectionModel.Settings settings = base.model.settings;
				Camera camera = context.camera;
				int num = ((settings.reflection.reflectionQuality == ScreenSpaceReflectionModel.SSRResolution.High) ? 1 : 2);
				int num2 = context.width / num;
				int num3 = context.height / num;
				float num4 = context.width;
				float num5 = context.height;
				float num6 = num4 / 2f;
				float num7 = num5 / 2f;
				Material material = context.materialFactory.Get("Hidden/Post FX/Screen Space Reflection");
				material.SetInt(Uniforms._RayStepSize, settings.reflection.stepSize);
				material.SetInt(Uniforms._AdditiveReflection, (settings.reflection.blendType == ScreenSpaceReflectionModel.SSRReflectionBlendType.Additive) ? 1 : 0);
				material.SetInt(Uniforms._BilateralUpsampling, k_BilateralUpsample ? 1 : 0);
				material.SetInt(Uniforms._TreatBackfaceHitAsMiss, k_TreatBackfaceHitAsMiss ? 1 : 0);
				material.SetInt(Uniforms._AllowBackwardsRays, settings.reflection.reflectBackfaces ? 1 : 0);
				material.SetInt(Uniforms._TraceBehindObjects, k_TraceBehindObjects ? 1 : 0);
				material.SetInt(Uniforms._MaxSteps, settings.reflection.iterationCount);
				material.SetInt(Uniforms._FullResolutionFiltering, 0);
				material.SetInt(Uniforms._HalfResolution, (settings.reflection.reflectionQuality != 0) ? 1 : 0);
				material.SetInt(Uniforms._HighlightSuppression, k_HighlightSuppression ? 1 : 0);
				float value = num4 / (-2f * Mathf.Tan(camera.fieldOfView / 180f * (float)Math.PI * 0.5f));
				material.SetFloat(Uniforms._PixelsPerMeterAtOneMeter, value);
				material.SetFloat(Uniforms._ScreenEdgeFading, settings.screenEdgeMask.intensity);
				material.SetFloat(Uniforms._ReflectionBlur, settings.reflection.reflectionBlur);
				material.SetFloat(Uniforms._MaxRayTraceDistance, settings.reflection.maxDistance);
				material.SetFloat(Uniforms._FadeDistance, settings.intensity.fadeDistance);
				material.SetFloat(Uniforms._LayerThickness, settings.reflection.widthModifier);
				material.SetFloat(Uniforms._SSRMultiplier, settings.intensity.reflectionMultiplier);
				material.SetFloat(Uniforms._FresnelFade, settings.intensity.fresnelFade);
				material.SetFloat(Uniforms._FresnelFadePower, settings.intensity.fresnelFadePower);
				Matrix4x4 projectionMatrix = camera.projectionMatrix;
				Vector4 value2 = new Vector4(-2f / (num4 * projectionMatrix[0]), -2f / (num5 * projectionMatrix[5]), (1f - projectionMatrix[2]) / projectionMatrix[0], (1f + projectionMatrix[6]) / projectionMatrix[5]);
				Vector3 vector = (float.IsPositiveInfinity(camera.farClipPlane) ? new Vector3(camera.nearClipPlane, -1f, 1f) : new Vector3(camera.nearClipPlane * camera.farClipPlane, camera.nearClipPlane - camera.farClipPlane, camera.farClipPlane));
				material.SetVector(Uniforms._ReflectionBufferSize, new Vector2(num2, num3));
				material.SetVector(Uniforms._ScreenSize, new Vector2(num4, num5));
				material.SetVector(Uniforms._InvScreenSize, new Vector2(1f / num4, 1f / num5));
				material.SetVector(Uniforms._ProjInfo, value2);
				material.SetVector(Uniforms._CameraClipInfo, vector);
				Matrix4x4 matrix4x = default(Matrix4x4);
				matrix4x.SetRow(0, new Vector4(num6, 0f, 0f, num6));
				matrix4x.SetRow(1, new Vector4(0f, num7, 0f, num7));
				matrix4x.SetRow(2, new Vector4(0f, 0f, 1f, 0f));
				matrix4x.SetRow(3, new Vector4(0f, 0f, 0f, 1f));
				Matrix4x4 value3 = matrix4x * projectionMatrix;
				material.SetMatrix(Uniforms._ProjectToPixelMatrix, value3);
				material.SetMatrix(Uniforms._WorldToCameraMatrix, camera.worldToCameraMatrix);
				material.SetMatrix(Uniforms._CameraToWorldMatrix, camera.worldToCameraMatrix.inverse);
				RenderTextureFormat format = (context.isHdr ? RenderTextureFormat.ARGBHalf : RenderTextureFormat.ARGB32);
				int normalAndRoughnessTexture = Uniforms._NormalAndRoughnessTexture;
				int hitPointTexture = Uniforms._HitPointTexture;
				int blurTexture = Uniforms._BlurTexture;
				int filteredReflections = Uniforms._FilteredReflections;
				int finalReflectionTexture = Uniforms._FinalReflectionTexture;
				int tempTexture = Uniforms._TempTexture;
				cb.GetTemporaryRT(normalAndRoughnessTexture, -1, -1, 0, FilterMode.Point, RenderTextureFormat.ARGB32, RenderTextureReadWrite.Linear);
				cb.GetTemporaryRT(hitPointTexture, num2, num3, 0, FilterMode.Bilinear, RenderTextureFormat.ARGBHalf, RenderTextureReadWrite.Linear);
				for (int i = 0; i < 5; i++)
				{
					cb.GetTemporaryRT(m_ReflectionTextures[i], num2 >> i, num3 >> i, 0, FilterMode.Bilinear, format);
				}
				cb.GetTemporaryRT(filteredReflections, num2, num3, 0, (!k_BilateralUpsample) ? FilterMode.Bilinear : FilterMode.Point, format);
				cb.GetTemporaryRT(finalReflectionTexture, num2, num3, 0, FilterMode.Point, format);
				cb.Blit(BuiltinRenderTextureType.CameraTarget, normalAndRoughnessTexture, material, 6);
				cb.Blit(BuiltinRenderTextureType.CameraTarget, hitPointTexture, material, 0);
				cb.Blit(BuiltinRenderTextureType.CameraTarget, filteredReflections, material, 5);
				cb.Blit(filteredReflections, m_ReflectionTextures[0], material, 8);
				for (int j = 1; j < 5; j++)
				{
					int num8 = m_ReflectionTextures[j - 1];
					int num9 = j;
					cb.GetTemporaryRT(blurTexture, num2 >> num9, num3 >> num9, 0, FilterMode.Bilinear, format);
					cb.SetGlobalVector(Uniforms._Axis, new Vector4(1f, 0f, 0f, 0f));
					cb.SetGlobalFloat(Uniforms._CurrentMipLevel, (float)j - 1f);
					cb.Blit(num8, blurTexture, material, 2);
					cb.SetGlobalVector(Uniforms._Axis, new Vector4(0f, 1f, 0f, 0f));
					num8 = m_ReflectionTextures[j];
					cb.Blit(blurTexture, num8, material, 2);
					cb.ReleaseTemporaryRT(blurTexture);
				}
				cb.Blit(m_ReflectionTextures[0], finalReflectionTexture, material, 3);
				cb.GetTemporaryRT(tempTexture, camera.pixelWidth, camera.pixelHeight, 0, FilterMode.Bilinear, format);
				cb.Blit(BuiltinRenderTextureType.CameraTarget, tempTexture, material, 1);
				cb.Blit(tempTexture, BuiltinRenderTextureType.CameraTarget);
				cb.ReleaseTemporaryRT(tempTexture);
			}
		}
		public sealed class TaaComponent : PostProcessingComponentRenderTexture<AntialiasingModel>
		{
			private static class Uniforms
			{
				internal static int _Jitter = Shader.PropertyToID("_Jitter");

				internal static int _SharpenParameters = Shader.PropertyToID("_SharpenParameters");

				internal static int _FinalBlendParameters = Shader.PropertyToID("_FinalBlendParameters");

				internal static int _HistoryTex = Shader.PropertyToID("_HistoryTex");

				internal static int _MainTex = Shader.PropertyToID("_MainTex");
			}

			private const string k_ShaderString = "Hidden/Post FX/Temporal Anti-aliasing";

			private const int k_SampleCount = 8;

			private readonly RenderBuffer[] m_MRT = new RenderBuffer[2];

			private int m_SampleIndex;

			private bool m_ResetHistory = true;

			private RenderTexture m_HistoryTexture;

			public override bool active
			{
				get
				{
					if (base.model.enabled && base.model.settings.method == AntialiasingModel.Method.Taa && SystemInfo.supportsMotionVectors && SystemInfo.supportedRenderTargetCount >= 2)
					{
						return !context.interrupted;
					}
					return false;
				}
			}

			public Vector2 jitterVector { get; private set; }

			public override DepthTextureMode GetCameraFlags()
			{
				return DepthTextureMode.Depth | DepthTextureMode.MotionVectors;
			}

			public void ResetHistory()
			{
				m_ResetHistory = true;
			}

			public void SetProjectionMatrix(Func<Vector2, Matrix4x4> jitteredFunc)
			{
				AntialiasingModel.TaaSettings taaSettings = base.model.settings.taaSettings;
				Vector2 vector = GenerateRandomOffset();
				vector *= taaSettings.jitterSpread;
				context.camera.nonJitteredProjectionMatrix = context.camera.projectionMatrix;
				if (jitteredFunc != null)
				{
					context.camera.projectionMatrix = jitteredFunc(vector);
				}
				else
				{
					context.camera.projectionMatrix = (context.camera.orthographic ? GetOrthographicProjectionMatrix(vector) : GetPerspectiveProjectionMatrix(vector));
				}
				context.camera.useJitteredProjectionMatrixForTransparentRendering = false;
				vector.x /= context.width;
				vector.y /= context.height;
				context.materialFactory.Get("Hidden/Post FX/Temporal Anti-aliasing").SetVector(Uniforms._Jitter, vector);
				jitterVector = vector;
			}

			public void Render(RenderTexture source, RenderTexture destination)
			{
				Material material = context.materialFactory.Get("Hidden/Post FX/Temporal Anti-aliasing");
				material.shaderKeywords = null;
				AntialiasingModel.TaaSettings taaSettings = base.model.settings.taaSettings;
				if (m_ResetHistory || m_HistoryTexture == null || m_HistoryTexture.width != source.width || m_HistoryTexture.height != source.height)
				{
					if ((bool)m_HistoryTexture)
					{
						RenderTexture.ReleaseTemporary(m_HistoryTexture);
					}
					m_HistoryTexture = RenderTexture.GetTemporary(source.width, source.height, 0, source.format);
					m_HistoryTexture.name = "TAA History";
					Graphics.Blit(source, m_HistoryTexture, material, 2);
				}
				material.SetVector(Uniforms._SharpenParameters, new Vector4(taaSettings.sharpen, 0f, 0f, 0f));
				material.SetVector(Uniforms._FinalBlendParameters, new Vector4(taaSettings.stationaryBlending, taaSettings.motionBlending, 6000f, 0f));
				material.SetTexture(Uniforms._MainTex, source);
				material.SetTexture(Uniforms._HistoryTex, m_HistoryTexture);
				RenderTexture temporary = RenderTexture.GetTemporary(source.width, source.height, 0, source.format);
				temporary.name = "TAA History";
				m_MRT[0] = destination.colorBuffer;
				m_MRT[1] = temporary.colorBuffer;
				Graphics.SetRenderTarget(m_MRT, source.depthBuffer);
				GraphicsUtils.Blit(material, context.camera.orthographic ? 1 : 0);
				RenderTexture.ReleaseTemporary(m_HistoryTexture);
				m_HistoryTexture = temporary;
				m_ResetHistory = false;
			}

			private float GetHaltonValue(int index, int radix)
			{
				float num = 0f;
				float num2 = 1f / (float)radix;
				while (index > 0)
				{
					num += (float)(index % radix) * num2;
					index /= radix;
					num2 /= (float)radix;
				}
				return num;
			}

			private Vector2 GenerateRandomOffset()
			{
				Vector2 result = new Vector2(GetHaltonValue(m_SampleIndex & 0x3FF, 2), GetHaltonValue(m_SampleIndex & 0x3FF, 3));
				if (++m_SampleIndex >= 8)
				{
					m_SampleIndex = 0;
				}
				return result;
			}

			private Matrix4x4 GetPerspectiveProjectionMatrix(Vector2 offset)
			{
				float num = Mathf.Tan((float)Math.PI / 360f * context.camera.fieldOfView);
				float num2 = num * context.camera.aspect;
				offset.x *= num2 / (0.5f * (float)context.width);
				offset.y *= num / (0.5f * (float)context.height);
				float num3 = (offset.x - num2) * context.camera.nearClipPlane;
				float num4 = (offset.x + num2) * context.camera.nearClipPlane;
				float num5 = (offset.y + num) * context.camera.nearClipPlane;
				float num6 = (offset.y - num) * context.camera.nearClipPlane;
				Matrix4x4 result = default(Matrix4x4);
				result[0, 0] = 2f * context.camera.nearClipPlane / (num4 - num3);
				result[0, 1] = 0f;
				result[0, 2] = (num4 + num3) / (num4 - num3);
				result[0, 3] = 0f;
				result[1, 0] = 0f;
				result[1, 1] = 2f * context.camera.nearClipPlane / (num5 - num6);
				result[1, 2] = (num5 + num6) / (num5 - num6);
				result[1, 3] = 0f;
				result[2, 0] = 0f;
				result[2, 1] = 0f;
				result[2, 2] = (0f - (context.camera.farClipPlane + context.camera.nearClipPlane)) / (context.camera.farClipPlane - context.camera.nearClipPlane);
				result[2, 3] = (0f - 2f * context.camera.farClipPlane * context.camera.nearClipPlane) / (context.camera.farClipPlane - context.camera.nearClipPlane);
				result[3, 0] = 0f;
				result[3, 1] = 0f;
				result[3, 2] = -1f;
				result[3, 3] = 0f;
				return result;
			}

			private Matrix4x4 GetOrthographicProjectionMatrix(Vector2 offset)
			{
				float orthographicSize = context.camera.orthographicSize;
				float num = orthographicSize * context.camera.aspect;
				offset.x *= num / (0.5f * (float)context.width);
				offset.y *= orthographicSize / (0.5f * (float)context.height);
				float left = offset.x - num;
				float right = offset.x + num;
				float top = offset.y + orthographicSize;
				float bottom = offset.y - orthographicSize;
				return Matrix4x4.Ortho(left, right, bottom, top, context.camera.nearClipPlane, context.camera.farClipPlane);
			}

			public override void OnDisable()
			{
				if (m_HistoryTexture != null)
				{
					RenderTexture.ReleaseTemporary(m_HistoryTexture);
				}
				context.camera.useJitteredProjectionMatrixForTransparentRendering = true;
				m_HistoryTexture = null;
				m_SampleIndex = 0;
				ResetHistory();
			}
		}
		public sealed class UserLutComponent : PostProcessingComponentRenderTexture<UserLutModel>
		{
			private static class Uniforms
			{
				internal static readonly int _UserLut = Shader.PropertyToID("_UserLut");

				internal static readonly int _UserLut_Params = Shader.PropertyToID("_UserLut_Params");
			}

			public override bool active
			{
				get
				{
					UserLutModel.Settings settings = base.model.settings;
					if (base.model.enabled && settings.lut != null && settings.contribution > 0f && settings.lut.height == (int)Mathf.Sqrt(settings.lut.width))
					{
						return !context.interrupted;
					}
					return false;
				}
			}

			public override void Prepare(Material uberMaterial)
			{
				UserLutModel.Settings settings = base.model.settings;
				uberMaterial.EnableKeyword("USER_LUT");
				uberMaterial.SetTexture(Uniforms._UserLut, settings.lut);
				uberMaterial.SetVector(Uniforms._UserLut_Params, new Vector4(1f / (float)settings.lut.width, 1f / (float)settings.lut.height, (float)settings.lut.height - 1f, settings.contribution));
			}

			public void OnGUI()
			{
				UserLutModel.Settings settings = base.model.settings;
				GUI.DrawTexture(new Rect(context.viewport.x * (float)Screen.width + 8f, 8f, settings.lut.width, settings.lut.height), settings.lut);
			}
		}
		public sealed class VignetteComponent : PostProcessingComponentRenderTexture<VignetteModel>
		{
			private static class Uniforms
			{
				internal static readonly int _Vignette_Color = Shader.PropertyToID("_Vignette_Color");

				internal static readonly int _Vignette_Center = Shader.PropertyToID("_Vignette_Center");

				internal static readonly int _Vignette_Settings = Shader.PropertyToID("_Vignette_Settings");

				internal static readonly int _Vignette_Mask = Shader.PropertyToID("_Vignette_Mask");

				internal static readonly int _Vignette_Opacity = Shader.PropertyToID("_Vignette_Opacity");
			}

			public override bool active
			{
				get
				{
					if (base.model.enabled)
					{
						return !context.interrupted;
					}
					return false;
				}
			}

			public override void Prepare(Material uberMaterial)
			{
				VignetteModel.Settings settings = base.model.settings;
				uberMaterial.SetColor(Uniforms._Vignette_Color, settings.color);
				if (settings.mode == VignetteModel.Mode.Classic)
				{
					uberMaterial.SetVector(Uniforms._Vignette_Center, settings.center);
					uberMaterial.EnableKeyword("VIGNETTE_CLASSIC");
					float z = (1f - settings.roundness) * 6f + settings.roundness;
					uberMaterial.SetVector(Uniforms._Vignette_Settings, new Vector4(settings.intensity * 3f, settings.smoothness * 5f, z, settings.rounded ? 1f : 0f));
				}
				else if (settings.mode == VignetteModel.Mode.Masked && settings.mask != null && settings.opacity > 0f)
				{
					uberMaterial.EnableKeyword("VIGNETTE_MASKED");
					uberMaterial.SetTexture(Uniforms._Vignette_Mask, settings.mask);
					uberMaterial.SetFloat(Uniforms._Vignette_Opacity, settings.opacity);
				}
			}
		}
		[Serializable]
		public class AmbientOcclusionModel : PostProcessingModel
		{
			public enum SampleCount
			{
				Lowest = 3,
				Low = 6,
				Medium = 10,
				High = 16
			}

			[Serializable]
			public struct Settings
			{
				[Range(0f, 4f)]
				[Tooltip("Degree of darkness produced by the effect.")]
				public float intensity;

				[Min(0.0001f)]
				[Tooltip("Radius of sample points, which affects extent of darkened areas.")]
				public float radius;

				[Tooltip("Number of sample points, which affects quality and performance.")]
				public SampleCount sampleCount;

				[Tooltip("Halves the resolution of the effect to increase performance at the cost of visual quality.")]
				public bool downsampling;

				[Tooltip("Forces compatibility with Forward rendered objects when working with the Deferred rendering path.")]
				public bool forceForwardCompatibility;

				[Tooltip("Enables the ambient-only mode in that the effect only affects ambient lighting. This mode is only available with the Deferred rendering path and HDR rendering.")]
				public bool ambientOnly;

				[Tooltip("Toggles the use of a higher precision depth texture with the forward rendering path (may impact performances). Has no effect with the deferred rendering path.")]
				public bool highPrecision;

				public static Settings defaultSettings
				{
					get
					{
						Settings result = default(Settings);
						result.intensity = 1f;
						result.radius = 0.3f;
						result.sampleCount = SampleCount.Medium;
						result.downsampling = true;
						result.forceForwardCompatibility = false;
						result.ambientOnly = false;
						result.highPrecision = false;
						return result;
					}
				}
			}

			[SerializeField]
			private Settings m_Settings = Settings.defaultSettings;

			public Settings settings
			{
				get
				{
					return m_Settings;
				}
				set
				{
					m_Settings = value;
				}
			}

			public override void Reset()
			{
				m_Settings = Settings.defaultSettings;
			}
		}
		[Serializable]
		public class AntialiasingModel : PostProcessingModel
		{
			public enum Method
			{
				Fxaa,
				Taa
			}

			public enum FxaaPreset
			{
				ExtremePerformance,
				Performance,
				Default,
				Quality,
				ExtremeQuality
			}

			[Serializable]
			public struct FxaaQualitySettings
			{
				[Tooltip("The amount of desired sub-pixel aliasing removal. Effects the sharpeness of the output.")]
				[Range(0f, 1f)]
				public float subpixelAliasingRemovalAmount;

				[Tooltip("The minimum amount of local contrast required to qualify a region as containing an edge.")]
				[Range(0.063f, 0.333f)]
				public float edgeDetectionThreshold;

				[Tooltip("Local contrast adaptation value to disallow the algorithm from executing on the darker regions.")]
				[Range(0f, 0.0833f)]
				public float minimumRequiredLuminance;

				public static FxaaQualitySettings[] presets = new FxaaQualitySettings[5]
				{
					new FxaaQualitySettings
					{
						subpixelAliasingRemovalAmount = 0f,
						edgeDetectionThreshold = 0.333f,
						minimumRequiredLuminance = 0.0833f
					},
					new FxaaQualitySettings
					{
						subpixelAliasingRemovalAmount = 0.25f,
						edgeDetectionThreshold = 0.25f,
						minimumRequiredLuminance = 0.0833f
					},
					new FxaaQualitySettings
					{
						subpixelAliasingRemovalAmount = 0.75f,
						edgeDetectionThreshold = 0.166f,
						minimumRequiredLuminance = 0.0833f
					},
					new FxaaQualitySettings
					{
						subpixelAliasingRemovalAmount = 1f,
						edgeDetectionThreshold = 0.125f,
						minimumRequiredLuminance = 0.0625f
					},
					new FxaaQualitySettings
					{
						subpixelAliasingRemovalAmount = 1f,
						edgeDetectionThreshold = 0.063f,
						minimumRequiredLuminance = 0.0312f
					}
				};
			}

			[Serializable]
			public struct FxaaConsoleSettings
			{
				[Tooltip("The amount of spread applied to the sampling coordinates while sampling for subpixel information.")]
				[Range(0.33f, 0.5f)]
				public float subpixelSpreadAmount;

				[Tooltip("This value dictates how sharp the edges in the image are kept; a higher value implies sharper edges.")]
				[Range(2f, 8f)]
				public float edgeSharpnessAmount;

				[Tooltip("The minimum amount of local contrast required to qualify a region as containing an edge.")]
				[Range(0.125f, 0.25f)]
				public float edgeDetectionThreshold;

				[Tooltip("Local contrast adaptation value to disallow the algorithm from executing on the darker regions.")]
				[Range(0.04f, 0.06f)]
				public float minimumRequiredLuminance;

				public static FxaaConsoleSettings[] presets = new FxaaConsoleSettings[5]
				{
					new FxaaConsoleSettings
					{
						subpixelSpreadAmount = 0.33f,
						edgeSharpnessAmount = 8f,
						edgeDetectionThreshold = 0.25f,
						minimumRequiredLuminance = 0.06f
					},
					new FxaaConsoleSettings
					{
						subpixelSpreadAmount = 0.33f,
						edgeSharpnessAmount = 8f,
						edgeDetectionThreshold = 0.125f,
						minimumRequiredLuminance = 0.06f
					},
					new FxaaConsoleSettings
					{
						subpixelSpreadAmount = 0.5f,
						edgeSharpnessAmount = 8f,
						edgeDetectionThreshold = 0.125f,
						minimumRequiredLuminance = 0.05f
					},
					new FxaaConsoleSettings
					{
						subpixelSpreadAmount = 0.5f,
						edgeSharpnessAmount = 4f,
						edgeDetectionThreshold = 0.125f,
						minimumRequiredLuminance = 0.04f
					},
					new FxaaConsoleSettings
					{
						subpixelSpreadAmount = 0.5f,
						edgeSharpnessAmount = 2f,
						edgeDetectionThreshold = 0.125f,
						minimumRequiredLuminance = 0.04f
					}
				};
			}

			[Serializable]
			public struct FxaaSettings
			{
				public FxaaPreset preset;

				public static FxaaSettings defaultSettings
				{
					get
					{
						FxaaSettings result = default(FxaaSettings);
						result.preset = FxaaPreset.Default;
						return result;
					}
				}
			}

			[Serializable]
			public struct TaaSettings
			{
				[Tooltip("The diameter (in texels) inside which jitter samples are spread. Smaller values result in crisper but more aliased output, while larger values result in more stable but blurrier output.")]
				[Range(0.1f, 1f)]
				public float jitterSpread;

				[Tooltip("Controls the amount of sharpening applied to the color buffer.")]
				[Range(0f, 3f)]
				public float sharpen;

				[Tooltip("The blend coefficient for a stationary fragment. Controls the percentage of history sample blended into the final color.")]
				[Range(0f, 0.99f)]
				public float stationaryBlending;

				[Tooltip("The blend coefficient for a fragment with significant motion. Controls the percentage of history sample blended into the final color.")]
				[Range(0f, 0.99f)]
				public float motionBlending;

				public static TaaSettings defaultSettings
				{
					get
					{
						TaaSettings result = default(TaaSettings);
						result.jitterSpread = 0.75f;
						result.sharpen = 0.3f;
						result.stationaryBlending = 0.95f;
						result.motionBlending = 0.85f;
						return result;
					}
				}
			}

			[Serializable]
			public struct Settings
			{
				public Method method;

				public FxaaSettings fxaaSettings;

				public TaaSettings taaSettings;

				public static Settings defaultSettings
				{
					get
					{
						Settings result = default(Settings);
						result.method = Method.Fxaa;
						result.fxaaSettings = FxaaSettings.defaultSettings;
						result.taaSettings = TaaSettings.defaultSettings;
						return result;
					}
				}
			}

			[SerializeField]
			private Settings m_Settings = Settings.defaultSettings;

			public Settings settings
			{
				get
				{
					return m_Settings;
				}
				set
				{
					m_Settings = value;
				}
			}

			public override void Reset()
			{
				m_Settings = Settings.defaultSettings;
			}
		}
		[Serializable]
		public class BloomModel : PostProcessingModel
		{
			[Serializable]
			public struct BloomSettings
			{
				[Min(0f)]
				[Tooltip("Strength of the bloom filter.")]
				public float intensity;

				[Min(0f)]
				[Tooltip("Filters out pixels under this level of brightness.")]
				public float threshold;

				[Range(0f, 1f)]
				[Tooltip("Makes transition between under/over-threshold gradual (0 = hard threshold, 1 = soft threshold).")]
				public float softKnee;

				[Range(1f, 7f)]
				[Tooltip("Changes extent of veiling effects in a screen resolution-independent fashion.")]
				public float radius;

				[Tooltip("Reduces flashing noise with an additional filter.")]
				public bool antiFlicker;

				public float thresholdLinear
				{
					get
					{
						return Mathf.GammaToLinearSpace(threshold);
					}
					set
					{
						threshold = Mathf.LinearToGammaSpace(value);
					}
				}

				public static BloomSettings defaultSettings
				{
					get
					{
						BloomSettings result = default(BloomSettings);
						result.intensity = 0.5f;
						result.threshold = 1.1f;
						result.softKnee = 0.5f;
						result.radius = 4f;
						result.antiFlicker = false;
						return result;
					}
				}
			}

			[Serializable]
			public struct LensDirtSettings
			{
				[Tooltip("Dirtiness texture to add smudges or dust to the lens.")]
				public Texture texture;

				[Min(0f)]
				[Tooltip("Amount of lens dirtiness.")]
				public float intensity;

				public static LensDirtSettings defaultSettings
				{
					get
					{
						LensDirtSettings result = default(LensDirtSettings);
						result.texture = null;
						result.intensity = 3f;
						return result;
					}
				}
			}

			[Serializable]
			public struct Settings
			{
				public BloomSettings bloom;

				public LensDirtSettings lensDirt;

				public static Settings defaultSettings
				{
					get
					{
						Settings result = default(Settings);
						result.bloom = BloomSettings.defaultSettings;
						result.lensDirt = LensDirtSettings.defaultSettings;
						return result;
					}
				}
			}

			[SerializeField]
			private Settings m_Settings = Settings.defaultSettings;

			public Settings settings
			{
				get
				{
					return m_Settings;
				}
				set
				{
					m_Settings = value;
				}
			}

			public override void Reset()
			{
				m_Settings = Settings.defaultSettings;
			}
		}
		[Serializable]
		public class BuiltinDebugViewsModel : PostProcessingModel
		{
			[Serializable]
			public struct DepthSettings
			{
				[Range(0f, 1f)]
				[Tooltip("Scales the camera far plane before displaying the depth map.")]
				public float scale;

				public static DepthSettings defaultSettings
				{
					get
					{
						DepthSettings result = default(DepthSettings);
						result.scale = 1f;
						return result;
					}
				}
			}

			[Serializable]
			public struct MotionVectorsSettings
			{
				[Range(0f, 1f)]
				[Tooltip("Opacity of the source render.")]
				public float sourceOpacity;

				[Range(0f, 1f)]
				[Tooltip("Opacity of the per-pixel motion vector colors.")]
				public float motionImageOpacity;

				[Min(0f)]
				[Tooltip("Because motion vectors are mainly very small vectors, you can use this setting to make them more visible.")]
				public float motionImageAmplitude;

				[Range(0f, 1f)]
				[Tooltip("Opacity for the motion vector arrows.")]
				public float motionVectorsOpacity;

				[Range(8f, 64f)]
				[Tooltip("The arrow density on screen.")]
				public int motionVectorsResolution;

				[Min(0f)]
				[Tooltip("Tweaks the arrows length.")]
				public float motionVectorsAmplitude;

				public static MotionVectorsSettings defaultSettings
				{
					get
					{
						MotionVectorsSettings result = default(MotionVectorsSettings);
						result.sourceOpacity = 1f;
						result.motionImageOpacity = 0f;
						result.motionImageAmplitude = 16f;
						result.motionVectorsOpacity = 1f;
						result.motionVectorsResolution = 24;
						result.motionVectorsAmplitude = 64f;
						return result;
					}
				}
			}

			public enum Mode
			{
				None,
				Depth,
				Normals,
				MotionVectors,
				AmbientOcclusion,
				EyeAdaptation,
				FocusPlane,
				PreGradingLog,
				LogLut,
				UserLut
			}

			[Serializable]
			public struct Settings
			{
				public Mode mode;

				public DepthSettings depth;

				public MotionVectorsSettings motionVectors;

				public static Settings defaultSettings
				{
					get
					{
						Settings result = default(Settings);
						result.mode = Mode.None;
						result.depth = DepthSettings.defaultSettings;
						result.motionVectors = MotionVectorsSettings.defaultSettings;
						return result;
					}
				}
			}

			[SerializeField]
			private Settings m_Settings = Settings.defaultSettings;

			public Settings settings
			{
				get
				{
					return m_Settings;
				}
				set
				{
					m_Settings = value;
				}
			}

			public bool willInterrupt
			{
				get
				{
					if (!IsModeActive(Mode.None) && !IsModeActive(Mode.EyeAdaptation) && !IsModeActive(Mode.PreGradingLog) && !IsModeActive(Mode.LogLut))
					{
						return !IsModeActive(Mode.UserLut);
					}
					return false;
				}
			}

			public override void Reset()
			{
				settings = Settings.defaultSettings;
			}

			public bool IsModeActive(Mode mode)
			{
				return m_Settings.mode == mode;
			}
		}
		[Serializable]
		public class ChromaticAberrationModel : PostProcessingModel
		{
			[Serializable]
			public struct Settings
			{
				[Tooltip("Shift the hue of chromatic aberrations.")]
				public Texture2D spectralTexture;

				[Range(0f, 1f)]
				[Tooltip("Amount of tangential distortion.")]
				public float intensity;

				public static Settings defaultSettings
				{
					get
					{
						Settings result = default(Settings);
						result.spectralTexture = null;
						result.intensity = 0.1f;
						return result;
					}
				}
			}

			[SerializeField]
			private Settings m_Settings = Settings.defaultSettings;

			public Settings settings
			{
				get
				{
					return m_Settings;
				}
				set
				{
					m_Settings = value;
				}
			}

			public override void Reset()
			{
				m_Settings = Settings.defaultSettings;
			}
		}
		[Serializable]
		public class ColorGradingModel : PostProcessingModel
		{
			public enum Tonemapper
			{
				None,
				ACES,
				Neutral
			}

			[Serializable]
			public struct TonemappingSettings
			{
				[Tooltip("Tonemapping algorithm to use at the end of the color grading process. Use \"Neutral\" if you need a customizable tonemapper or \"Filmic\" to give a standard filmic look to your scenes.")]
				public Tonemapper tonemapper;

				[Range(-0.1f, 0.1f)]
				public float neutralBlackIn;

				[Range(1f, 20f)]
				public float neutralWhiteIn;

				[Range(-0.09f, 0.1f)]
				public float neutralBlackOut;

				[Range(1f, 19f)]
				public float neutralWhiteOut;

				[Range(0.1f, 20f)]
				public float neutralWhiteLevel;

				[Range(1f, 10f)]
				public float neutralWhiteClip;

				public static TonemappingSettings defaultSettings
				{
					get
					{
						TonemappingSettings result = default(TonemappingSettings);
						result.tonemapper = Tonemapper.Neutral;
						result.neutralBlackIn = 0.02f;
						result.neutralWhiteIn = 10f;
						result.neutralBlackOut = 0f;
						result.neutralWhiteOut = 10f;
						result.neutralWhiteLevel = 5.3f;
						result.neutralWhiteClip = 10f;
						return result;
					}
				}
			}

			[Serializable]
			public struct BasicSettings
			{
				[Tooltip("Adjusts the overall exposure of the scene in EV units. This is applied after HDR effect and right before tonemapping so it won't affect previous effects in the chain.")]
				public float postExposure;

				[Range(-100f, 100f)]
				[Tooltip("Sets the white balance to a custom color temperature.")]
				public float temperature;

				[Range(-100f, 100f)]
				[Tooltip("Sets the white balance to compensate for a green or magenta tint.")]
				public float tint;

				[Range(-180f, 180f)]
				[Tooltip("Shift the hue of all colors.")]
				public float hueShift;

				[Range(0f, 2f)]
				[Tooltip("Pushes the intensity of all colors.")]
				public float saturation;

				[Range(0f, 2f)]
				[Tooltip("Expands or shrinks the overall range of tonal values.")]
				public float contrast;

				public static BasicSettings defaultSettings
				{
					get
					{
						BasicSettings result = default(BasicSettings);
						result.postExposure = 0f;
						result.temperature = 0f;
						result.tint = 0f;
						result.hueShift = 0f;
						result.saturation = 1f;
						result.contrast = 1f;
						return result;
					}
				}
			}

			[Serializable]
			public struct ChannelMixerSettings
			{
				public Vector3 red;

				public Vector3 green;

				public Vector3 blue;

				[HideInInspector]
				public int currentEditingChannel;

				public static ChannelMixerSettings defaultSettings
				{
					get
					{
						ChannelMixerSettings result = default(ChannelMixerSettings);
						result.red = new Vector3(1f, 0f, 0f);
						result.green = new Vector3(0f, 1f, 0f);
						result.blue = new Vector3(0f, 0f, 1f);
						result.currentEditingChannel = 0;
						return result;
					}
				}
			}

			[Serializable]
			public struct LogWheelsSettings
			{
				[Trackball("GetSlopeValue")]
				public Color slope;

				[Trackball("GetPowerValue")]
				public Color power;

				[Trackball("GetOffsetValue")]
				public Color offset;

				public static LogWheelsSettings defaultSettings
				{
					get
					{
						LogWheelsSettings result = default(LogWheelsSettings);
						result.slope = Color.clear;
						result.power = Color.clear;
						result.offset = Color.clear;
						return result;
					}
				}
			}

			[Serializable]
			public struct LinearWheelsSettings
			{
				[Trackball("GetLiftValue")]
				public Color lift;

				[Trackball("GetGammaValue")]
				public Color gamma;

				[Trackball("GetGainValue")]
				public Color gain;

				public static LinearWheelsSettings defaultSettings
				{
					get
					{
						LinearWheelsSettings result = default(LinearWheelsSettings);
						result.lift = Color.clear;
						result.gamma = Color.clear;
						result.gain = Color.clear;
						return result;
					}
				}
			}

			public enum ColorWheelMode
			{
				Linear,
				Log
			}

			[Serializable]
			public struct ColorWheelsSettings
			{
				public ColorWheelMode mode;

				[TrackballGroup]
				public LogWheelsSettings log;

				[TrackballGroup]
				public LinearWheelsSettings linear;

				public static ColorWheelsSettings defaultSettings
				{
					get
					{
						ColorWheelsSettings result = default(ColorWheelsSettings);
						result.mode = ColorWheelMode.Log;
						result.log = LogWheelsSettings.defaultSettings;
						result.linear = LinearWheelsSettings.defaultSettings;
						return result;
					}
				}
			}

			[Serializable]
			public struct CurvesSettings
			{
				public ColorGradingCurve master;

				public ColorGradingCurve red;

				public ColorGradingCurve green;

				public ColorGradingCurve blue;

				public ColorGradingCurve hueVShue;

				public ColorGradingCurve hueVSsat;

				public ColorGradingCurve satVSsat;

				public ColorGradingCurve lumVSsat;

				[HideInInspector]
				public int e_CurrentEditingCurve;

				[HideInInspector]
				public bool e_CurveY;

				[HideInInspector]
				public bool e_CurveR;

				[HideInInspector]
				public bool e_CurveG;

				[HideInInspector]
				public bool e_CurveB;

				public static CurvesSettings defaultSettings
				{
					get
					{
						CurvesSettings result = default(CurvesSettings);
						result.master = new ColorGradingCurve(new AnimationCurve(new Keyframe(0f, 0f, 1f, 1f), new Keyframe(1f, 1f, 1f, 1f)), 0f, loop: false, new Vector2(0f, 1f));
						result.red = new ColorGradingCurve(new AnimationCurve(new Keyframe(0f, 0f, 1f, 1f), new Keyframe(1f, 1f, 1f, 1f)), 0f, loop: false, new Vector2(0f, 1f));
						result.green = new ColorGradingCurve(new AnimationCurve(new Keyframe(0f, 0f, 1f, 1f), new Keyframe(1f, 1f, 1f, 1f)), 0f, loop: false, new Vector2(0f, 1f));
						result.blue = new ColorGradingCurve(new AnimationCurve(new Keyframe(0f, 0f, 1f, 1f), new Keyframe(1f, 1f, 1f, 1f)), 0f, loop: false, new Vector2(0f, 1f));
						result.hueVShue = new ColorGradingCurve(new AnimationCurve(), 0.5f, loop: true, new Vector2(0f, 1f));
						result.hueVSsat = new ColorGradingCurve(new AnimationCurve(), 0.5f, loop: true, new Vector2(0f, 1f));
						result.satVSsat = new ColorGradingCurve(new AnimationCurve(), 0.5f, loop: false, new Vector2(0f, 1f));
						result.lumVSsat = new ColorGradingCurve(new AnimationCurve(), 0.5f, loop: false, new Vector2(0f, 1f));
						result.e_CurrentEditingCurve = 0;
						result.e_CurveY = true;
						result.e_CurveR = false;
						result.e_CurveG = false;
						result.e_CurveB = false;
						return result;
					}
				}
			}

			[Serializable]
			public struct Settings
			{
				public TonemappingSettings tonemapping;

				public BasicSettings basic;

				public ChannelMixerSettings channelMixer;

				public ColorWheelsSettings colorWheels;

				public CurvesSettings curves;

				public static Settings defaultSettings
				{
					get
					{
						Settings result = default(Settings);
						result.tonemapping = TonemappingSettings.defaultSettings;
						result.basic = BasicSettings.defaultSettings;
						result.channelMixer = ChannelMixerSettings.defaultSettings;
						result.colorWheels = ColorWheelsSettings.defaultSettings;
						result.curves = CurvesSettings.defaultSettings;
						return result;
					}
				}
			}

			[SerializeField]
			private Settings m_Settings = Settings.defaultSettings;

			public Settings settings
			{
				get
				{
					return m_Settings;
				}
				set
				{
					m_Settings = value;
					OnValidate();
				}
			}

			public bool isDirty { get; internal set; }

			public RenderTexture bakedLut { get; internal set; }

			public override void Reset()
			{
				m_Settings = Settings.defaultSettings;
				OnValidate();
			}

			public override void OnValidate()
			{
				isDirty = true;
			}
		}
		[Serializable]
		public class DepthOfFieldModel : PostProcessingModel
		{
			public enum KernelSize
			{
				Small,
				Medium,
				Large,
				VeryLarge
			}

			[Serializable]
			public struct Settings
			{
				[Min(0.1f)]
				[Tooltip("Distance to the point of focus.")]
				public float focusDistance;

				[Range(0.05f, 32f)]
				[Tooltip("Ratio of aperture (known as f-stop or f-number). The smaller the value is, the shallower the depth of field is.")]
				public float aperture;

				[Range(1f, 300f)]
				[Tooltip("Distance between the lens and the film. The larger the value is, the shallower the depth of field is.")]
				public float focalLength;

				[Tooltip("Calculate the focal length automatically from the field-of-view value set on the camera. Using this setting isn't recommended.")]
				public bool useCameraFov;

				[Tooltip("Convolution kernel size of the bokeh filter, which determines the maximum radius of bokeh. It also affects the performance (the larger the kernel is, the longer the GPU time is required).")]
				public KernelSize kernelSize;

				public static Settings defaultSettings
				{
					get
					{
						Settings result = default(Settings);
						result.focusDistance = 10f;
						result.aperture = 5.6f;
						result.focalLength = 50f;
						result.useCameraFov = false;
						result.kernelSize = KernelSize.Medium;
						return result;
					}
				}
			}

			[SerializeField]
			private Settings m_Settings = Settings.defaultSettings;

			public Settings settings
			{
				get
				{
					return m_Settings;
				}
				set
				{
					m_Settings = value;
				}
			}

			public override void Reset()
			{
				m_Settings = Settings.defaultSettings;
			}
		}
		[Serializable]
		public class DitheringModel : PostProcessingModel
		{
			[Serializable]
			[StructLayout(LayoutKind.Sequential, Size = 1)]
			public struct Settings
			{
				public static Settings defaultSettings => default(Settings);
			}

			[SerializeField]
			private Settings m_Settings = Settings.defaultSettings;

			public Settings settings
			{
				get
				{
					return m_Settings;
				}
				set
				{
					m_Settings = value;
				}
			}

			public override void Reset()
			{
				m_Settings = Settings.defaultSettings;
			}
		}
		[Serializable]
		public class EyeAdaptationModel : PostProcessingModel
		{
			public enum EyeAdaptationType
			{
				Progressive,
				Fixed
			}

			[Serializable]
			public struct Settings
			{
				[Range(1f, 99f)]
				[Tooltip("Filters the dark part of the histogram when computing the average luminance to avoid very dark pixels from contributing to the auto exposure. Unit is in percent.")]
				public float lowPercent;

				[Range(1f, 99f)]
				[Tooltip("Filters the bright part of the histogram when computing the average luminance to avoid very dark pixels from contributing to the auto exposure. Unit is in percent.")]
				public float highPercent;

				[Tooltip("Minimum average luminance to consider for auto exposure (in EV).")]
				public float minLuminance;

				[Tooltip("Maximum average luminance to consider for auto exposure (in EV).")]
				public float maxLuminance;

				[Min(0f)]
				[Tooltip("Exposure bias. Use this to offset the global exposure of the scene.")]
				public float keyValue;

				[Tooltip("Set this to true to let Unity handle the key value automatically based on average luminance.")]
				public bool dynamicKeyValue;

				[Tooltip("Use \"Progressive\" if you want the auto exposure to be animated. Use \"Fixed\" otherwise.")]
				public EyeAdaptationType adaptationType;

				[Min(0f)]
				[Tooltip("Adaptation speed from a dark to a light environment.")]
				public float speedUp;

				[Min(0f)]
				[Tooltip("Adaptation speed from a light to a dark environment.")]
				public float speedDown;

				[Range(-16f, -1f)]
				[Tooltip("Lower bound for the brightness range of the generated histogram (in EV). The bigger the spread between min & max, the lower the precision will be.")]
				public int logMin;

				[Range(1f, 16f)]
				[Tooltip("Upper bound for the brightness range of the generated histogram (in EV). The bigger the spread between min & max, the lower the precision will be.")]
				public int logMax;

				public static Settings defaultSettings
				{
					get
					{
						Settings result = default(Settings);
						result.lowPercent = 45f;
						result.highPercent = 95f;
						result.minLuminance = -5f;
						result.maxLuminance = 1f;
						result.keyValue = 0.25f;
						result.dynamicKeyValue = true;
						result.adaptationType = EyeAdaptationType.Progressive;
						result.speedUp = 2f;
						result.speedDown = 1f;
						result.logMin = -8;
						result.logMax = 4;
						return result;
					}
				}
			}

			[SerializeField]
			private Settings m_Settings = Settings.defaultSettings;

			public Settings settings
			{
				get
				{
					return m_Settings;
				}
				set
				{
					m_Settings = value;
				}
			}

			public override void Reset()
			{
				m_Settings = Settings.defaultSettings;
			}
		}
		[Serializable]
		public class FogModel : PostProcessingModel
		{
			[Serializable]
			public struct Settings
			{
				[Tooltip("Should the fog affect the skybox?")]
				public bool excludeSkybox;

				public static Settings defaultSettings
				{
					get
					{
						Settings result = default(Settings);
						result.excludeSkybox = true;
						return result;
					}
				}
			}

			[SerializeField]
			private Settings m_Settings = Settings.defaultSettings;

			public Settings settings
			{
				get
				{
					return m_Settings;
				}
				set
				{
					m_Settings = value;
				}
			}

			public override void Reset()
			{
				m_Settings = Settings.defaultSettings;
			}
		}
		[Serializable]
		public class GrainModel : PostProcessingModel
		{
			[Serializable]
			public struct Settings
			{
				[Tooltip("Enable the use of colored grain.")]
				public bool colored;

				[Range(0f, 1f)]
				[Tooltip("Grain strength. Higher means more visible grain.")]
				public float intensity;

				[Range(0.3f, 3f)]
				[Tooltip("Grain particle size.")]
				public float size;

				[Range(0f, 1f)]
				[Tooltip("Controls the noisiness response curve based on scene luminance. Lower values mean less noise in dark areas.")]
				public float luminanceContribution;

				public static Settings defaultSettings
				{
					get
					{
						Settings result = default(Settings);
						result.colored = true;
						result.intensity = 0.5f;
						result.size = 1f;
						result.luminanceContribution = 0.8f;
						return result;
					}
				}
			}

			[SerializeField]
			private Settings m_Settings = Settings.defaultSettings;

			public Settings settings
			{
				get
				{
					return m_Settings;
				}
				set
				{
					m_Settings = value;
				}
			}

			public override void Reset()
			{
				m_Settings = Settings.defaultSettings;
			}
		}
		[Serializable]
		public class MotionBlurModel : PostProcessingModel
		{
			[Serializable]
			public struct Settings
			{
				[Range(0f, 360f)]
				[Tooltip("The angle of rotary shutter. Larger values give longer exposure.")]
				public float shutterAngle;

				[Range(4f, 32f)]
				[Tooltip("The amount of sample points, which affects quality and performances.")]
				public int sampleCount;

				[Range(0f, 1f)]
				[Tooltip("The strength of multiple frame blending. The opacity of preceding frames are determined from this coefficient and time differences.")]
				public float frameBlending;

				public static Settings defaultSettings
				{
					get
					{
						Settings result = default(Settings);
						result.shutterAngle = 270f;
						result.sampleCount = 10;
						result.frameBlending = 0f;
						return result;
					}
				}
			}

			[SerializeField]
			private Settings m_Settings = Settings.defaultSettings;

			public Settings settings
			{
				get
				{
					return m_Settings;
				}
				set
				{
					m_Settings = value;
				}
			}

			public override void Reset()
			{
				m_Settings = Settings.defaultSettings;
			}
		}
		[Serializable]
		public class ScreenSpaceReflectionModel : PostProcessingModel
		{
			public enum SSRResolution
			{
				High = 0,
				Low = 2
			}

			public enum SSRReflectionBlendType
			{
				PhysicallyBased,
				Additive
			}

			[Serializable]
			public struct IntensitySettings
			{
				[Tooltip("Nonphysical multiplier for the SSR reflections. 1.0 is physically based.")]
				[Range(0f, 2f)]
				public float reflectionMultiplier;

				[Tooltip("How far away from the maxDistance to begin fading SSR.")]
				[Range(0f, 1000f)]
				public float fadeDistance;

				[Tooltip("Amplify Fresnel fade out. Increase if floor reflections look good close to the surface and bad farther 'under' the floor.")]
				[Range(0f, 1f)]
				public float fresnelFade;

				[Tooltip("Higher values correspond to a faster Fresnel fade as the reflection changes from the grazing angle.")]
				[Range(0.1f, 10f)]
				public float fresnelFadePower;
			}

			[Serializable]
			public struct ReflectionSettings
			{
				[Tooltip("How the reflections are blended into the render.")]
				public SSRReflectionBlendType blendType;

				[Tooltip("Half resolution SSRR is much faster, but less accurate.")]
				public SSRResolution reflectionQuality;

				[Tooltip("Maximum reflection distance in world units.")]
				[Range(0.1f, 300f)]
				public float maxDistance;

				[Tooltip("Max raytracing length.")]
				[Range(16f, 1024f)]
				public int iterationCount;

				[Tooltip("Log base 2 of ray tracing coarse step size. Higher traces farther, lower gives better quality silhouettes.")]
				[Range(1f, 16f)]
				public int stepSize;

				[Tooltip("Typical thickness of columns, walls, furniture, and other objects that reflection rays might pass behind.")]
				[Range(0.01f, 10f)]
				public float widthModifier;

				[Tooltip("Blurriness of reflections.")]
				[Range(0.1f, 8f)]
				public float reflectionBlur;

				[Tooltip("Disable for a performance gain in scenes where most glossy objects are horizontal, like floors, water, and tables. Leave on for scenes with glossy vertical objects.")]
				public bool reflectBackfaces;
			}

			[Serializable]
			public struct ScreenEdgeMask
			{
				[Tooltip("Higher = fade out SSRR near the edge of the screen so that reflections don't pop under camera motion.")]
				[Range(0f, 1f)]
				public float intensity;
			}

			[Serializable]
			public struct Settings
			{
				public ReflectionSettings reflection;

				public IntensitySettings intensity;

				public ScreenEdgeMask screenEdgeMask;

				public static Settings defaultSettings
				{
					get
					{
						Settings result = default(Settings);
						result.reflection = new ReflectionSettings
						{
							blendType = SSRReflectionBlendType.PhysicallyBased,
							reflectionQuality = SSRResolution.Low,
							maxDistance = 100f,
							iterationCount = 256,
							stepSize = 3,
							widthModifier = 0.5f,
							reflectionBlur = 1f,
							reflectBackfaces = false
						};
						result.intensity = new IntensitySettings
						{
							reflectionMultiplier = 1f,
							fadeDistance = 100f,
							fresnelFade = 1f,
							fresnelFadePower = 1f
						};
						result.screenEdgeMask = new ScreenEdgeMask
						{
							intensity = 0.03f
						};
						return result;
					}
				}
			}

			[SerializeField]
			private Settings m_Settings = Settings.defaultSettings;

			public Settings settings
			{
				get
				{
					return m_Settings;
				}
				set
				{
					m_Settings = value;
				}
			}

			public override void Reset()
			{
				m_Settings = Settings.defaultSettings;
			}
		}
		[Serializable]
		public class UserLutModel : PostProcessingModel
		{
			[Serializable]
			public struct Settings
			{
				[Tooltip("Custom lookup texture (strip format, e.g. 256x16).")]
				public Texture2D lut;

				[Range(0f, 1f)]
				[Tooltip("Blending factor.")]
				public float contribution;

				public static Settings defaultSettings
				{
					get
					{
						Settings result = default(Settings);
						result.lut = null;
						result.contribution = 1f;
						return result;
					}
				}
			}

			[SerializeField]
			private Settings m_Settings = Settings.defaultSettings;

			public Settings settings
			{
				get
				{
					return m_Settings;
				}
				set
				{
					m_Settings = value;
				}
			}

			public override void Reset()
			{
				m_Settings = Settings.defaultSettings;
			}
		}
		[Serializable]
		public class VignetteModel : PostProcessingModel
		{
			public enum Mode
			{
				Classic,
				Masked
			}

			[Serializable]
			public struct Settings
			{
				[Tooltip("Use the \"Classic\" mode for parametric controls. Use the \"Masked\" mode to use your own texture mask.")]
				public Mode mode;

				[ColorUsage(false)]
				[Tooltip("Vignette color. Use the alpha channel for transparency.")]
				public Color color;

				[Tooltip("Sets the vignette center point (screen center is [0.5,0.5]).")]
				public Vector2 center;

				[Range(0f, 1f)]
				[Tooltip("Amount of vignetting on screen.")]
				public float intensity;

				[Range(0.01f, 1f)]
				[Tooltip("Smoothness of the vignette borders.")]
				public float smoothness;

				[Range(0f, 1f)]
				[Tooltip("Lower values will make a square-ish vignette.")]
				public float roundness;

				[Tooltip("A black and white mask to use as a vignette.")]
				public Texture mask;

				[Range(0f, 1f)]
				[Tooltip("Mask opacity.")]
				public float opacity;

				[Tooltip("Should the vignette be perfectly round or be dependent on the current aspect ratio?")]
				public bool rounded;

				public static Settings defaultSettings
				{
					get
					{
						Settings result = default(Settings);
						result.mode = Mode.Classic;
						result.color = new Color(0f, 0f, 0f, 1f);
						result.center = new Vector2(0.5f, 0.5f);
						result.intensity = 0.45f;
						result.smoothness = 0.2f;
						result.roundness = 1f;
						result.mask = null;
						result.opacity = 1f;
						result.rounded = false;
						return result;
					}
				}
			}

			[SerializeField]
			private Settings m_Settings = Settings.defaultSettings;

			public Settings settings
			{
				get
				{
					return m_Settings;
				}
				set
				{
					m_Settings = value;
				}
			}

			public override void Reset()
			{
				m_Settings = Settings.defaultSettings;
			}
		}
		[ImageEffectAllowedInSceneView]
		[RequireComponent(typeof(Camera))]
		[DisallowMultipleComponent]
		[ExecuteInEditMode]
		[AddComponentMenu("Effects/Post-Processing Behaviour", -1)]
		public class PostProcessingBehaviour : MonoBehaviour
		{
			public PostProcessingProfile profile;

			public Func<Vector2, Matrix4x4> jitteredMatrixFunc;

			private Dictionary<Type, KeyValuePair<CameraEvent, CommandBuffer>> m_CommandBuffers;

			private List<PostProcessingComponentBase> m_Components;

			private Dictionary<PostProcessingComponentBase, bool> m_ComponentStates;

			private MaterialFactory m_MaterialFactory;

			private RenderTextureFactory m_RenderTextureFactory;

			private PostProcessingContext m_Context;

			private Camera m_Camera;

			private PostProcessingProfile m_PreviousProfile;

			private bool m_RenderingInSceneView;

			private BuiltinDebugViewsComponent m_DebugViews;

			private AmbientOcclusionComponent m_AmbientOcclusion;

			private ScreenSpaceReflectionComponent m_ScreenSpaceReflection;

			private FogComponent m_FogComponent;

			private MotionBlurComponent m_MotionBlur;

			private TaaComponent m_Taa;

			private EyeAdaptationComponent m_EyeAdaptation;

			private DepthOfFieldComponent m_DepthOfField;

			private BloomComponent m_Bloom;

			private ChromaticAberrationComponent m_ChromaticAberration;

			private ColorGradingComponent m_ColorGrading;

			private UserLutComponent m_UserLut;

			private GrainComponent m_Grain;

			private VignetteComponent m_Vignette;

			private DitheringComponent m_Dithering;

			private FxaaComponent m_Fxaa;

			private List<PostProcessingComponentBase> m_ComponentsToEnable = new List<PostProcessingComponentBase>();

			private List<PostProcessingComponentBase> m_ComponentsToDisable = new List<PostProcessingComponentBase>();

			private void OnEnable()
			{
				m_CommandBuffers = new Dictionary<Type, KeyValuePair<CameraEvent, CommandBuffer>>();
				m_MaterialFactory = new MaterialFactory();
				m_RenderTextureFactory = new RenderTextureFactory();
				m_Context = new PostProcessingContext();
				m_Components = new List<PostProcessingComponentBase>();
				m_DebugViews = AddComponent(new BuiltinDebugViewsComponent());
				m_AmbientOcclusion = AddComponent(new AmbientOcclusionComponent());
				m_ScreenSpaceReflection = AddComponent(new ScreenSpaceReflectionComponent());
				m_FogComponent = AddComponent(new FogComponent());
				m_MotionBlur = AddComponent(new MotionBlurComponent());
				m_Taa = AddComponent(new TaaComponent());
				m_EyeAdaptation = AddComponent(new EyeAdaptationComponent());
				m_DepthOfField = AddComponent(new DepthOfFieldComponent());
				m_Bloom = AddComponent(new BloomComponent());
				m_ChromaticAberration = AddComponent(new ChromaticAberrationComponent());
				m_ColorGrading = AddComponent(new ColorGradingComponent());
				m_UserLut = AddComponent(new UserLutComponent());
				m_Grain = AddComponent(new GrainComponent());
				m_Vignette = AddComponent(new VignetteComponent());
				m_Dithering = AddComponent(new DitheringComponent());
				m_Fxaa = AddComponent(new FxaaComponent());
				m_ComponentStates = new Dictionary<PostProcessingComponentBase, bool>();
				foreach (PostProcessingComponentBase component in m_Components)
				{
					m_ComponentStates.Add(component, value: false);
				}
				base.useGUILayout = false;
			}

			private void OnPreCull()
			{
				m_Camera = GetComponent<Camera>();
				if (profile == null || m_Camera == null)
				{
					return;
				}
				PostProcessingContext postProcessingContext = m_Context.Reset();
				postProcessingContext.profile = profile;
				postProcessingContext.renderTextureFactory = m_RenderTextureFactory;
				postProcessingContext.materialFactory = m_MaterialFactory;
				postProcessingContext.camera = m_Camera;
				m_DebugViews.Init(postProcessingContext, profile.debugViews);
				m_AmbientOcclusion.Init(postProcessingContext, profile.ambientOcclusion);
				m_ScreenSpaceReflection.Init(postProcessingContext, profile.screenSpaceReflection);
				m_FogComponent.Init(postProcessingContext, profile.fog);
				m_MotionBlur.Init(postProcessingContext, profile.motionBlur);
				m_Taa.Init(postProcessingContext, profile.antialiasing);
				m_EyeAdaptation.Init(postProcessingContext, profile.eyeAdaptation);
				m_DepthOfField.Init(postProcessingContext, profile.depthOfField);
				m_Bloom.Init(postProcessingContext, profile.bloom);
				m_ChromaticAberration.Init(postProcessingContext, profile.chromaticAberration);
				m_ColorGrading.Init(postProcessingContext, profile.colorGrading);
				m_UserLut.Init(postProcessingContext, profile.userLut);
				m_Grain.Init(postProcessingContext, profile.grain);
				m_Vignette.Init(postProcessingContext, profile.vignette);
				m_Dithering.Init(postProcessingContext, profile.dithering);
				m_Fxaa.Init(postProcessingContext, profile.antialiasing);
				if (m_PreviousProfile != profile)
				{
					DisableComponents();
					m_PreviousProfile = profile;
				}
				CheckObservers();
				DepthTextureMode depthTextureMode = postProcessingContext.camera.depthTextureMode;
				foreach (PostProcessingComponentBase component in m_Components)
				{
					if (component.active)
					{
						depthTextureMode |= component.GetCameraFlags();
					}
				}
				postProcessingContext.camera.depthTextureMode = depthTextureMode;
				if (!m_RenderingInSceneView && m_Taa.active && !profile.debugViews.willInterrupt)
				{
					m_Taa.SetProjectionMatrix(jitteredMatrixFunc);
				}
			}

			private void OnPreRender()
			{
				if (!(profile == null))
				{
					TryExecuteCommandBuffer(m_DebugViews);
					TryExecuteCommandBuffer(m_AmbientOcclusion);
					TryExecuteCommandBuffer(m_ScreenSpaceReflection);
					TryExecuteCommandBuffer(m_FogComponent);
					if (!m_RenderingInSceneView)
					{
						TryExecuteCommandBuffer(m_MotionBlur);
					}
				}
			}

			private void OnPostRender()
			{
				if (!(profile == null) && !(m_Camera == null) && !m_RenderingInSceneView && m_Taa.active && !profile.debugViews.willInterrupt)
				{
					m_Context.camera.ResetProjectionMatrix();
				}
			}

			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (profile == null || m_Camera == null)
				{
					Graphics.Blit(source, destination);
					return;
				}
				bool flag = false;
				bool active = m_Fxaa.active;
				bool flag2 = m_Taa.active && !m_RenderingInSceneView;
				bool num = m_DepthOfField.active && !m_RenderingInSceneView;
				Material material = m_MaterialFactory.Get("Hidden/Post FX/Uber Shader");
				material.shaderKeywords = null;
				RenderTexture renderTexture = source;
				if (flag2)
				{
					RenderTexture renderTexture2 = m_RenderTextureFactory.Get(renderTexture);
					m_Taa.Render(renderTexture, renderTexture2);
					renderTexture = renderTexture2;
				}
				Texture texture = GraphicsUtils.whiteTexture;
				if (m_EyeAdaptation.active)
				{
					flag = true;
					texture = m_EyeAdaptation.Prepare(renderTexture, material);
				}
				material.SetTexture("_AutoExposure", texture);
				if (num)
				{
					flag = true;
					m_DepthOfField.Prepare(renderTexture, material, flag2, m_Taa.jitterVector, m_Taa.model.settings.taaSettings.motionBlending);
				}
				if (m_Bloom.active)
				{
					flag = true;
					m_Bloom.Prepare(renderTexture, material, texture);
				}
				flag |= TryPrepareUberImageEffect(m_ChromaticAberration, material);
				flag |= TryPrepareUberImageEffect(m_ColorGrading, material);
				flag |= TryPrepareUberImageEffect(m_Vignette, material);
				flag |= TryPrepareUberImageEffect(m_UserLut, material);
				Material material2 = (active ? m_MaterialFactory.Get("Hidden/Post FX/FXAA") : null);
				if (active)
				{
					material2.shaderKeywords = null;
					TryPrepareUberImageEffect(m_Grain, material2);
					TryPrepareUberImageEffect(m_Dithering, material2);
					if (flag)
					{
						RenderTexture renderTexture3 = m_RenderTextureFactory.Get(renderTexture);
						Graphics.Blit(renderTexture, renderTexture3, material, 0);
						renderTexture = renderTexture3;
					}
					m_Fxaa.Render(renderTexture, destination);
				}
				else
				{
					flag |= TryPrepareUberImageEffect(m_Grain, material);
					flag |= TryPrepareUberImageEffect(m_Dithering, material);
					if (flag)
					{
						if (!GraphicsUtils.isLinearColorSpace)
						{
							material.EnableKeyword("UNITY_COLORSPACE_GAMMA");
						}
						Graphics.Blit(renderTexture, destination, material, 0);
					}
				}
				if (!flag && !active)
				{
					Graphics.Blit(renderTexture, destination);
				}
				m_RenderTextureFactory.ReleaseAll();
			}

			private void OnGUI()
			{
				if (Event.current.type == EventType.Repaint && !(profile == null) && !(m_Camera == null))
				{
					if (m_EyeAdaptation.active && profile.debugViews.IsModeActive(BuiltinDebugViewsModel.Mode.EyeAdaptation))
					{
						m_EyeAdaptation.OnGUI();
					}
					else if (m_ColorGrading.active && profile.debugViews.IsModeActive(BuiltinDebugViewsModel.Mode.LogLut))
					{
						m_ColorGrading.OnGUI();
					}
					else if (m_UserLut.active && profile.debugViews.IsModeActive(BuiltinDebugViewsModel.Mode.UserLut))
					{
						m_UserLut.OnGUI();
					}
				}
			}

			private void OnDisable()
			{
				foreach (KeyValuePair<CameraEvent, CommandBuffer> value in m_CommandBuffers.Values)
				{
					m_Camera.RemoveCommandBuffer(value.Key, value.Value);
					value.Value.Dispose();
				}
				m_CommandBuffers.Clear();
				if (profile != null)
				{
					DisableComponents();
				}
				m_Components.Clear();
				m_MaterialFactory.Dispose();
				m_RenderTextureFactory.Dispose();
				GraphicsUtils.Dispose();
			}

			public void ResetTemporalEffects()
			{
				m_Taa.ResetHistory();
				m_MotionBlur.ResetHistory();
				m_EyeAdaptation.ResetHistory();
			}

			private void CheckObservers()
			{
				foreach (KeyValuePair<PostProcessingComponentBase, bool> componentState in m_ComponentStates)
				{
					PostProcessingComponentBase key = componentState.Key;
					bool flag = key.GetModel().enabled;
					if (flag != componentState.Value)
					{
						if (flag)
						{
							m_ComponentsToEnable.Add(key);
						}
						else
						{
							m_ComponentsToDisable.Add(key);
						}
					}
				}
				for (int i = 0; i < m_ComponentsToDisable.Count; i++)
				{
					PostProcessingComponentBase postProcessingComponentBase = m_ComponentsToDisable[i];
					m_ComponentStates[postProcessingComponentBase] = false;
					postProcessingComponentBase.OnDisable();
				}
				for (int j = 0; j < m_ComponentsToEnable.Count; j++)
				{
					PostProcessingComponentBase postProcessingComponentBase2 = m_ComponentsToEnable[j];
					m_ComponentStates[postProcessingComponentBase2] = true;
					postProcessingComponentBase2.OnEnable();
				}
				m_ComponentsToDisable.Clear();
				m_ComponentsToEnable.Clear();
			}

			private void DisableComponents()
			{
				foreach (PostProcessingComponentBase component in m_Components)
				{
					PostProcessingModel model = component.GetModel();
					if (model != null && model.enabled)
					{
						component.OnDisable();
					}
				}
			}

			private CommandBuffer AddCommandBuffer<T>(CameraEvent evt, string name) where T : PostProcessingModel
			{
				CommandBuffer value = new CommandBuffer
				{
					name = name
				};
				KeyValuePair<CameraEvent, CommandBuffer> value2 = new KeyValuePair<CameraEvent, CommandBuffer>(evt, value);
				m_CommandBuffers.Add(typeof(T), value2);
				m_Camera.AddCommandBuffer(evt, value2.Value);
				return value2.Value;
			}

			private void RemoveCommandBuffer<T>() where T : PostProcessingModel
			{
				Type typeFromHandle = typeof(T);
				if (m_CommandBuffers.TryGetValue(typeFromHandle, out var value))
				{
					m_Camera.RemoveCommandBuffer(value.Key, value.Value);
					m_CommandBuffers.Remove(typeFromHandle);
					value.Value.Dispose();
				}
			}

			private CommandBuffer GetCommandBuffer<T>(CameraEvent evt, string name) where T : PostProcessingModel
			{
				if (!m_CommandBuffers.TryGetValue(typeof(T), out var value))
				{
					return AddCommandBuffer<T>(evt, name);
				}
				if (value.Key != evt)
				{
					RemoveCommandBuffer<T>();
					return AddCommandBuffer<T>(evt, name);
				}
				return value.Value;
			}

			private void TryExecuteCommandBuffer<T>(PostProcessingComponentCommandBuffer<T> component) where T : PostProcessingModel
			{
				if (component.active)
				{
					CommandBuffer commandBuffer = GetCommandBuffer<T>(component.GetCameraEvent(), component.GetName());
					commandBuffer.Clear();
					component.PopulateCommandBuffer(commandBuffer);
				}
				else
				{
					RemoveCommandBuffer<T>();
				}
			}

			private bool TryPrepareUberImageEffect<T>(PostProcessingComponentRenderTexture<T> component, Material material) where T : PostProcessingModel
			{
				if (!component.active)
				{
					return false;
				}
				component.Prepare(material);
				return true;
			}

			private T AddComponent<T>(T component) where T : PostProcessingComponentBase
			{
				m_Components.Add(component);
				return component;
			}
		}
		public abstract class PostProcessingComponentBase
		{
			public PostProcessingContext context;

			public abstract bool active { get; }

			public virtual DepthTextureMode GetCameraFlags()
			{
				return DepthTextureMode.None;
			}

			public virtual void OnEnable()
			{
			}

			public virtual void OnDisable()
			{
			}

			public abstract PostProcessingModel GetModel();
		}
		public abstract class PostProcessingComponent<T> : PostProcessingComponentBase where T : PostProcessingModel
		{
			public T model { get; internal set; }

			public virtual void Init(PostProcessingContext pcontext, T pmodel)
			{
				context = pcontext;
				model = pmodel;
			}

			public override PostProcessingModel GetModel()
			{
				return model;
			}
		}
		public abstract class PostProcessingComponentCommandBuffer<T> : PostProcessingComponent<T> where T : PostProcessingModel
		{
			public abstract CameraEvent GetCameraEvent();

			public abstract string GetName();

			public abstract void PopulateCommandBuffer(CommandBuffer cb);
		}
		public abstract class PostProcessingComponentRenderTexture<T> : PostProcessingComponent<T> where T : PostProcessingModel
		{
			public virtual void Prepare(Material material)
			{
			}
		}
		public class PostProcessingContext
		{
			public PostProcessingProfile profile;

			public Camera camera;

			public MaterialFactory materialFactory;

			public RenderTextureFactory renderTextureFactory;

			public bool interrupted { get; private set; }

			public bool isGBufferAvailable => camera.actualRenderingPath == RenderingPath.DeferredShading;

			public bool isHdr => camera.allowHDR;

			public int width => camera.pixelWidth;

			public int height => camera.pixelHeight;

			public Rect viewport => camera.rect;

			public void Interrupt()
			{
				interrupted = true;
			}

			public PostProcessingContext Reset()
			{
				profile = null;
				camera = null;
				materialFactory = null;
				renderTextureFactory = null;
				interrupted = false;
				return this;
			}
		}
		[Serializable]
		public abstract class PostProcessingModel
		{
			[SerializeField]
			[GetSet("enabled")]
			private bool m_Enabled;

			public bool enabled
			{
				get
				{
					return m_Enabled;
				}
				set
				{
					m_Enabled = value;
					if (value)
					{
						OnValidate();
					}
				}
			}

			public abstract void Reset();

			public virtual void OnValidate()
			{
			}
		}
		public class PostProcessingProfile : ScriptableObject
		{
			public BuiltinDebugViewsModel debugViews = new BuiltinDebugViewsModel();

			public FogModel fog = new FogModel();

			public AntialiasingModel antialiasing = new AntialiasingModel();

			public AmbientOcclusionModel ambientOcclusion = new AmbientOcclusionModel();

			public ScreenSpaceReflectionModel screenSpaceReflection = new ScreenSpaceReflectionModel();

			public DepthOfFieldModel depthOfField = new DepthOfFieldModel();

			public MotionBlurModel motionBlur = new MotionBlurModel();

			public EyeAdaptationModel eyeAdaptation = new EyeAdaptationModel();

			public BloomModel bloom = new BloomModel();

			public ColorGradingModel colorGrading = new ColorGradingModel();

			public UserLutModel userLut = new UserLutModel();

			public ChromaticAberrationModel chromaticAberration = new ChromaticAberrationModel();

			public GrainModel grain = new GrainModel();

			public VignetteModel vignette = new VignetteModel();

			public DitheringModel dithering = new DitheringModel();
		}
		[Serializable]
		public sealed class ColorGradingCurve
		{
			public AnimationCurve curve;

			[SerializeField]
			private bool m_Loop;

			[SerializeField]
			private float m_ZeroValue;

			[SerializeField]
			private float m_Range;

			private AnimationCurve m_InternalLoopingCurve;

			public ColorGradingCurve(AnimationCurve curve, float zeroValue, bool loop, Vector2 bounds)
			{
				this.curve = curve;
				m_ZeroValue = zeroValue;
				m_Loop = loop;
				m_Range = bounds.magnitude;
			}

			public void Cache()
			{
				if (!m_Loop)
				{
					return;
				}
				int length = curve.length;
				if (length >= 2)
				{
					if (m_InternalLoopingCurve == null)
					{
						m_InternalLoopingCurve = new AnimationCurve();
					}
					Keyframe key = curve[length - 1];
					key.time -= m_Range;
					Keyframe key2 = curve[0];
					key2.time += m_Range;
					m_InternalLoopingCurve.keys = curve.keys;
					m_InternalLoopingCurve.AddKey(key);
					m_InternalLoopingCurve.AddKey(key2);
				}
			}

			public float Evaluate(float t)
			{
				if (curve.length == 0)
				{
					return m_ZeroValue;
				}
				if (!m_Loop || curve.length == 1)
				{
					return curve.Evaluate(t);
				}
				return m_InternalLoopingCurve.Evaluate(t);
			}
		}
		public static class GraphicsUtils
		{
			private static Texture2D s_WhiteTexture;

			private static Mesh s_Quad;

			public static bool isLinearColorSpace => QualitySettings.activeColorSpace == ColorSpace.Linear;

			public static bool supportsDX11
			{
				get
				{
					if (SystemInfo.graphicsShaderLevel >= 50)
					{
						return SystemInfo.supportsComputeShaders;
					}
					return false;
				}
			}

			public static Texture2D whiteTexture
			{
				get
				{
					if (s_WhiteTexture != null)
					{
						return s_WhiteTexture;
					}
					s_WhiteTexture = new Texture2D(1, 1, TextureFormat.ARGB32, mipChain: false);
					s_WhiteTexture.SetPixel(0, 0, new Color(1f, 1f, 1f, 1f));
					s_WhiteTexture.Apply();
					return s_WhiteTexture;
				}
			}

			public static Mesh quad
			{
				get
				{
					if (s_Quad != null)
					{
						return s_Quad;
					}
					Vector3[] vertices = new Vector3[4]
					{
						new Vector3(-1f, -1f, 0f),
						new Vector3(1f, 1f, 0f),
						new Vector3(1f, -1f, 0f),
						new Vector3(-1f, 1f, 0f)
					};
					Vector2[] uv = new Vector2[4]
					{
						new Vector2(0f, 0f),
						new Vector2(1f, 1f),
						new Vector2(1f, 0f),
						new Vector2(0f, 1f)
					};
					int[] triangles = new int[6] { 0, 1, 2, 1, 0, 3 };
					s_Quad = new Mesh
					{
						vertices = vertices,
						uv = uv,
						triangles = triangles
					};
					s_Quad.RecalculateNormals();
					s_Quad.RecalculateBounds();
					return s_Quad;
				}
			}

			public static void Blit(Material material, int pass)
			{
				GL.PushMatrix();
				GL.LoadOrtho();
				material.SetPass(pass);
				GL.Begin(5);
				GL.TexCoord2(0f, 0f);
				GL.Vertex3(0f, 0f, 0.1f);
				GL.TexCoord2(1f, 0f);
				GL.Vertex3(1f, 0f, 0.1f);
				GL.TexCoord2(0f, 1f);
				GL.Vertex3(0f, 1f, 0.1f);
				GL.TexCoord2(1f, 1f);
				GL.Vertex3(1f, 1f, 0.1f);
				GL.End();
				GL.PopMatrix();
			}

			public static void ClearAndBlit(Texture source, RenderTexture destination, Material material, int pass, bool clearColor = true, bool clearDepth = false)
			{
				RenderTexture active = RenderTexture.active;
				RenderTexture.active = destination;
				GL.Clear(clearDepth: false, clearColor, Color.clear);
				GL.PushMatrix();
				GL.LoadOrtho();
				material.SetTexture("_MainTex", source);
				material.SetPass(pass);
				GL.Begin(5);
				GL.TexCoord2(0f, 0f);
				GL.Vertex3(0f, 0f, 0.1f);
				GL.TexCoord2(1f, 0f);
				GL.Vertex3(1f, 0f, 0.1f);
				GL.TexCoord2(0f, 1f);
				GL.Vertex3(0f, 1f, 0.1f);
				GL.TexCoord2(1f, 1f);
				GL.Vertex3(1f, 1f, 0.1f);
				GL.End();
				GL.PopMatrix();
				RenderTexture.active = active;
			}

			public static void Destroy(Object obj)
			{
				if (obj != null)
				{
					Object.Destroy(obj);
				}
			}

			public static void Dispose()
			{
				Destroy(s_Quad);
			}
		}
		public sealed class MaterialFactory : IDisposable
		{
			private Dictionary<string, Material> m_Materials;

			public MaterialFactory()
			{
				m_Materials = new Dictionary<string, Material>();
			}

			public Material Get(string shaderName)
			{
				if (!m_Materials.TryGetValue(shaderName, out var value))
				{
					Shader shader = Shader.Find(shaderName);
					if (shader == null)
					{
						throw new ArgumentException($"Shader not found ({shaderName})");
					}
					value = new Material(shader)
					{
						name = string.Format("PostFX - {0}", shaderName.Substring(shaderName.LastIndexOf("/") + 1)),
						hideFlags = HideFlags.DontSave
					};
					m_Materials.Add(shaderName, value);
				}
				return value;
			}

			public void Dispose()
			{
				Dictionary<string, Material>.Enumerator enumerator = m_Materials.GetEnumerator();
				while (enumerator.MoveNext())
				{
					GraphicsUtils.Destroy(enumerator.Current.Value);
				}
				m_Materials.Clear();
			}
		}
		public sealed class RenderTextureFactory : IDisposable
		{
			private HashSet<RenderTexture> m_TemporaryRTs;

			public RenderTextureFactory()
			{
				m_TemporaryRTs = new HashSet<RenderTexture>();
			}

			public RenderTexture Get(RenderTexture baseRenderTexture)
			{
				return Get(baseRenderTexture.width, baseRenderTexture.height, baseRenderTexture.depth, baseRenderTexture.format, (!baseRenderTexture.sRGB) ? RenderTextureReadWrite.Linear : RenderTextureReadWrite.sRGB, baseRenderTexture.filterMode, baseRenderTexture.wrapMode);
			}

			public RenderTexture Get(int width, int height, int depthBuffer = 0, RenderTextureFormat format = RenderTextureFormat.ARGBHalf, RenderTextureReadWrite rw = RenderTextureReadWrite.Default, FilterMode filterMode = FilterMode.Bilinear, TextureWrapMode wrapMode = TextureWrapMode.Clamp, string name = "FactoryTempTexture")
			{
				RenderTexture temporary = RenderTexture.GetTemporary(width, height, depthBuffer, format, rw);
				temporary.filterMode = filterMode;
				temporary.wrapMode = wrapMode;
				temporary.name = name;
				m_TemporaryRTs.Add(temporary);
				return temporary;
			}

			public void Release(RenderTexture rt)
			{
				if (!(rt == null))
				{
					if (!m_TemporaryRTs.Contains(rt))
					{
						throw new ArgumentException($"Attempting to remove a RenderTexture that was not allocated: {rt}");
					}
					m_TemporaryRTs.Remove(rt);
					RenderTexture.ReleaseTemporary(rt);
				}
			}

			public void ReleaseAll()
			{
				HashSet<RenderTexture>.Enumerator enumerator = m_TemporaryRTs.GetEnumerator();
				while (enumerator.MoveNext())
				{
					RenderTexture.ReleaseTemporary(enumerator.Current);
				}
				m_TemporaryRTs.Clear();
			}

			public void Dispose()
			{
				ReleaseAll();
			}
		}
	}
	namespace BNG
	{
		public class LinkedSet<T> : IEnumerable<T>, IEnumerable
		{
			private LinkedList<T> list;

			private Dictionary<T, LinkedListNode<T>> dictionary;

			public int Count => list.Count;

			public LinkedSet()
			{
				list = new LinkedList<T>();
				dictionary = new Dictionary<T, LinkedListNode<T>>();
			}

			public LinkedSet(IEqualityComparer<T> comparer)
			{
				list = new LinkedList<T>();
				dictionary = new Dictionary<T, LinkedListNode<T>>(comparer);
			}

			public bool Add(T t)
			{
				if (dictionary.ContainsKey(t))
				{
					return false;
				}
				LinkedListNode<T> value = list.AddLast(t);
				dictionary.Add(t, value);
				return true;
			}

			public bool Remove(T t)
			{
				if (dictionary.TryGetValue(t, out var value))
				{
					dictionary.Remove(t);
					list.Remove(value);
					return true;
				}
				return false;
			}

			public void Clear()
			{
				list.Clear();
				dictionary.Clear();
			}

			public bool Contains(T t)
			{
				return dictionary.ContainsKey(t);
			}

			public IEnumerator<T> GetEnumerator()
			{
				return list.GetEnumerator();
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return list.GetEnumerator();
			}
		}
		[RequireComponent(typeof(Renderer))]
		public class Outline : MonoBehaviour
		{
			public int color;

			public bool eraseRenderer;

			private Material[] _SharedMaterials;

			public Renderer Renderer { get; private set; }

			public SkinnedMeshRenderer SkinnedMeshRenderer { get; private set; }

			public MeshFilter MeshFilter { get; private set; }

			public Material[] SharedMaterials
			{
				get
				{
					if (_SharedMaterials == null)
					{
						_SharedMaterials = Renderer.sharedMaterials;
					}
					return _SharedMaterials;
				}
			}

			private void Awake()
			{
				Renderer = GetComponent<Renderer>();
				SkinnedMeshRenderer = GetComponent<SkinnedMeshRenderer>();
				MeshFilter = GetComponent<MeshFilter>();
			}

			private void OnEnable()
			{
				OutlineEffect.Instance?.AddOutline(this);
			}

			private void OnDisable()
			{
				OutlineEffect.Instance?.RemoveOutline(this);
			}
		}
		[DisallowMultipleComponent]
		[RequireComponent(typeof(Camera))]
		[ExecuteInEditMode]
		public class OutlineEffect : MonoBehaviour
		{
			private readonly LinkedSet<Outline> outlines = new LinkedSet<Outline>();

			[Range(1f, 6f)]
			public float lineThickness = 1.25f;

			[Range(0f, 10f)]
			public float lineIntensity = 0.5f;

			[Range(0f, 1f)]
			public float fillAmount = 0.2f;

			public Color lineColor0 = Color.red;

			public Color lineColor1 = Color.green;

			public Color lineColor2 = Color.blue;

			public Color lineColor3 = Color.cyan;

			public bool additiveRendering;

			public bool backfaceCulling = true;

			[Header("These settings can affect performance!")]
			public bool cornerOutlines;

			public bool addLinesBetweenColors;

			[Header("Advanced settings")]
			public bool scaleWithScreenSize = true;

			[Range(0.1f, 0.9f)]
			public float alphaCutoff = 0.5f;

			public bool flipY;

			public Camera sourceCamera;

			public bool autoEnableOutlines = true;

			[HideInInspector]
			public Camera outlineCamera;

			private Material outline1Material;

			private Material outline2Material;

			private Material outline3Material;

			private Material outline4Material;

			private Material outlineEraseMaterial;

			private Shader outlineShader;

			private Shader outlineBufferShader;

			[HideInInspector]
			public Material outlineShaderMaterial;

			[HideInInspector]
			public RenderTexture renderTexture;

			[HideInInspector]
			public RenderTexture extraRenderTexture;

			private CommandBuffer commandBuffer;

			private List<Material> materialBuffer = new List<Material>();

			private bool RenderTheNextFrame;

			public static OutlineEffect Instance { get; private set; }

			private Material GetMaterialFromID(int ID)
			{
				return ID switch
				{
					0 => outline1Material, 
					1 => outline2Material, 
					2 => outline3Material, 
					3 => outline4Material, 
					_ => outline1Material, 
				};
			}

			private Material CreateMaterial(Color emissionColor)
			{
				Material material = new Material(outlineBufferShader);
				material.SetColor("_Color", emissionColor);
				material.SetInt("_SrcBlend", 5);
				material.SetInt("_DstBlend", 10);
				material.SetInt("_ZWrite", 0);
				material.DisableKeyword("_ALPHATEST_ON");
				material.EnableKeyword("_ALPHABLEND_ON");
				material.DisableKeyword("_ALPHAPREMULTIPLY_ON");
				material.renderQueue = 3000;
				return material;
			}

			private void Awake()
			{
				if (Instance != null)
				{
					UnityEngine.Object.Destroy(this);
					throw new Exception("you can only have one outline camera in the scene");
				}
				Instance = this;
			}

			private void Start()
			{
				CreateMaterialsIfNeeded();
				UpdateMaterialsPublicProperties();
				if (sourceCamera == null)
				{
					sourceCamera = GetComponent<Camera>();
					if (sourceCamera == null)
					{
						sourceCamera = Camera.main;
					}
				}
				if (outlineCamera == null)
				{
					Camera[] componentsInChildren = GetComponentsInChildren<Camera>();
					foreach (Camera camera in componentsInChildren)
					{
						if (camera.name == "Outline Camera")
						{
							outlineCamera = camera;
							camera.enabled = false;
							break;
						}
					}
					if (outlineCamera == null)
					{
						GameObject gameObject = new GameObject("Outline Camera");
						gameObject.transform.parent = sourceCamera.transform;
						outlineCamera = gameObject.AddComponent<Camera>();
						outlineCamera.enabled = false;
					}
				}
				renderTexture = new RenderTexture(sourceCamera.pixelWidth, sourceCamera.pixelHeight, 16, RenderTextureFormat.Default);
				extraRenderTexture = new RenderTexture(sourceCamera.pixelWidth, sourceCamera.pixelHeight, 16, RenderTextureFormat.Default);
				UpdateOutlineCameraFromSource();
				commandBuffer = new CommandBuffer();
				outlineCamera.AddCommandBuffer(CameraEvent.BeforeImageEffects, commandBuffer);
			}

			public void OnPreRender()
			{
				if (commandBuffer == null)
				{
					return;
				}
				if (outlines.Count == 0)
				{
					if (!RenderTheNextFrame)
					{
						return;
					}
					RenderTheNextFrame = false;
				}
				else
				{
					RenderTheNextFrame = true;
				}
				CreateMaterialsIfNeeded();
				if (renderTexture == null || renderTexture.width != sourceCamera.pixelWidth || renderTexture.height != sourceCamera.pixelHeight)
				{
					renderTexture = new RenderTexture(sourceCamera.pixelWidth, sourceCamera.pixelHeight, 16, RenderTextureFormat.Default);
					extraRenderTexture = new RenderTexture(sourceCamera.pixelWidth, sourceCamera.pixelHeight, 16, RenderTextureFormat.Default);
					outlineCamera.targetTexture = renderTexture;
				}
				UpdateMaterialsPublicProperties();
				UpdateOutlineCameraFromSource();
				outlineCamera.targetTexture = renderTexture;
				commandBuffer.SetRenderTarget(renderTexture);
				commandBuffer.Clear();
				foreach (Outline outline in outlines)
				{
					LayerMask layerMask = sourceCamera.cullingMask;
					if (!(outline != null) || (int)layerMask != ((int)layerMask | (1 << outline.gameObject.layer)))
					{
						continue;
					}
					for (int i = 0; i < outline.SharedMaterials.Length; i++)
					{
						Material material = null;
						if (!(outline.SharedMaterials[i].mainTexture != null) || !outline.SharedMaterials[i])
						{
							material = ((!outline.eraseRenderer) ? GetMaterialFromID(outline.color) : outlineEraseMaterial);
						}
						else
						{
							foreach (Material item in materialBuffer)
							{
								if (item.mainTexture == outline.SharedMaterials[i].mainTexture)
								{
									if (outline.eraseRenderer && item.color == outlineEraseMaterial.color)
									{
										material = item;
									}
									else if (item.color == GetMaterialFromID(outline.color).color)
									{
										material = item;
									}
								}
							}
							if (material == null)
							{
								material = ((!outline.eraseRenderer) ? new Material(GetMaterialFromID(outline.color)) : new Material(outlineEraseMaterial));
								material.mainTexture = outline.SharedMaterials[i].mainTexture;
								materialBuffer.Add(material);
							}
						}
						if (backfaceCulling)
						{
							material.SetInt("_Culling", 2);
						}
						else
						{
							material.SetInt("_Culling", 0);
						}
						commandBuffer.DrawRenderer(outline.Renderer, material, 0, 0);
						MeshFilter meshFilter = outline.MeshFilter;
						if ((bool)meshFilter && meshFilter.sharedMesh != null)
						{
							for (int j = 1; j < meshFilter.sharedMesh.subMeshCount; j++)
							{
								commandBuffer.DrawRenderer(outline.Renderer, material, j, 0);
							}
						}
						SkinnedMeshRenderer skinnedMeshRenderer = outline.SkinnedMeshRenderer;
						if ((bool)skinnedMeshRenderer && skinnedMeshRenderer.sharedMesh != null)
						{
							for (int k = 1; k < skinnedMeshRenderer.sharedMesh.subMeshCount; k++)
							{
								commandBuffer.DrawRenderer(outline.Renderer, material, k, 0);
							}
						}
					}
				}
				outlineCamera.Render();
			}

			private void OnEnable()
			{
				if (autoEnableOutlines)
				{
					Outline[] array = UnityEngine.Object.FindObjectsOfType<Outline>();
					foreach (Outline obj in array)
					{
						obj.enabled = false;
						obj.enabled = true;
					}
				}
			}

			private void OnDestroy()
			{
				if (renderTexture != null)
				{
					renderTexture.Release();
				}
				if (extraRenderTexture != null)
				{
					extraRenderTexture.Release();
				}
				DestroyMaterials();
			}

			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (outlineShaderMaterial != null)
				{
					outlineShaderMaterial.SetTexture("_OutlineSource", renderTexture);
					if (addLinesBetweenColors)
					{
						Graphics.Blit(source, extraRenderTexture, outlineShaderMaterial, 0);
						outlineShaderMaterial.SetTexture("_OutlineSource", extraRenderTexture);
					}
					Graphics.Blit(source, destination, outlineShaderMaterial, 1);
				}
			}

			private void CreateMaterialsIfNeeded()
			{
				if (outlineShader == null)
				{
					outlineShader = Resources.Load<Shader>("OutlineShader");
				}
				if (outlineBufferShader == null)
				{
					outlineBufferShader = Resources.Load<Shader>("OutlineBufferShader");
				}
				if (outlineShaderMaterial == null)
				{
					outlineShaderMaterial = new Material(outlineShader);
					outlineShaderMaterial.hideFlags = HideFlags.HideAndDontSave;
					UpdateMaterialsPublicProperties();
				}
				if (outlineEraseMaterial == null)
				{
					outlineEraseMaterial = CreateMaterial(new Color(0f, 0f, 0f, 0f));
				}
				if (outline1Material == null)
				{
					outline1Material = CreateMaterial(new Color(1f, 0f, 0f, 0f));
				}
				if (outline2Material == null)
				{
					outline2Material = CreateMaterial(new Color(0f, 1f, 0f, 0f));
				}
				if (outline3Material == null)
				{
					outline3Material = CreateMaterial(new Color(0f, 0f, 1f, 0f));
				}
				if (outline4Material == null)
				{
					outline4Material = CreateMaterial(new Color(0f, 0f, 0f, 1f));
				}
			}

			private void DestroyMaterials()
			{
				foreach (Material item in materialBuffer)
				{
					UnityEngine.Object.DestroyImmediate(item);
				}
				materialBuffer.Clear();
				UnityEngine.Object.DestroyImmediate(outlineShaderMaterial);
				UnityEngine.Object.DestroyImmediate(outlineEraseMaterial);
				UnityEngine.Object.DestroyImmediate(outline1Material);
				UnityEngine.Object.DestroyImmediate(outline2Material);
				UnityEngine.Object.DestroyImmediate(outline3Material);
				outlineShader = null;
				outlineBufferShader = null;
				outlineShaderMaterial = null;
				outlineEraseMaterial = null;
				outline1Material = null;
				outline2Material = null;
				outline3Material = null;
				outline4Material = null;
			}

			public void UpdateMaterialsPublicProperties()
			{
				if (!outlineShaderMaterial)
				{
					return;
				}
				float num = 1f;
				if (scaleWithScreenSize)
				{
					num = (float)Screen.height / 360f;
				}
				if (scaleWithScreenSize && num < 1f)
				{
					if (XRSettings.isDeviceActive && sourceCamera.stereoTargetEye != 0)
					{
						outlineShaderMaterial.SetFloat("_LineThicknessX", 0.001f * (1f / (float)XRSettings.eyeTextureWidth) * 1000f);
						outlineShaderMaterial.SetFloat("_LineThicknessY", 0.001f * (1f / (float)XRSettings.eyeTextureHeight) * 1000f);
					}
					else
					{
						outlineShaderMaterial.SetFloat("_LineThicknessX", 0.001f * (1f / (float)Screen.width) * 1000f);
						outlineShaderMaterial.SetFloat("_LineThicknessY", 0.001f * (1f / (float)Screen.height) * 1000f);
					}
				}
				else if (XRSettings.isDeviceActive && sourceCamera.stereoTargetEye != 0)
				{
					outlineShaderMaterial.SetFloat("_LineThicknessX", num * (lineThickness / 1000f) * (1f / (float)XRSettings.eyeTextureWidth) * 1000f);
					outlineShaderMaterial.SetFloat("_LineThicknessY", num * (lineThickness / 1000f) * (1f / (float)XRSettings.eyeTextureHeight) * 1000f);
				}
				else
				{
					outlineShaderMaterial.SetFloat("_LineThicknessX", num * (lineThickness / 1000f) * (1f / (float)Screen.width) * 1000f);
					outlineShaderMaterial.SetFloat("_LineThicknessY", num * (lineThickness / 1000f) * (1f / (float)Screen.height) * 1000f);
				}
				outlineShaderMaterial.SetFloat("_LineIntensity", lineIntensity);
				outlineShaderMaterial.SetFloat("_FillAmount", fillAmount);
				outlineShaderMaterial.SetColor("_LineColor1", lineColor0 * lineColor0);
				outlineShaderMaterial.SetColor("_LineColor2", lineColor1 * lineColor1);
				outlineShaderMaterial.SetColor("_LineColor3", lineColor2 * lineColor2);
				outlineShaderMaterial.SetColor("_LineColor4", lineColor3 * lineColor3);
				if (flipY)
				{
					outlineShaderMaterial.SetInt("_FlipY", 1);
				}
				else
				{
					outlineShaderMaterial.SetInt("_FlipY", 0);
				}
				if (!additiveRendering)
				{
					outlineShaderMaterial.SetInt("_Dark", 1);
				}
				else
				{
					outlineShaderMaterial.SetInt("_Dark", 0);
				}
				if (cornerOutlines)
				{
					outlineShaderMaterial.SetInt("_CornerOutlines", 1);
				}
				else
				{
					outlineShaderMaterial.SetInt("_CornerOutlines", 0);
				}
				Shader.SetGlobalFloat("_OutlineAlphaCutoff", alphaCutoff);
			}

			private void UpdateOutlineCameraFromSource()
			{
				outlineCamera.CopyFrom(sourceCamera);
				outlineCamera.renderingPath = RenderingPath.Forward;
				outlineCamera.backgroundColor = new Color(0f, 0f, 0f, 0f);
				outlineCamera.clearFlags = CameraClearFlags.Color;
				outlineCamera.rect = new Rect(0f, 0f, 1f, 1f);
				outlineCamera.cullingMask = 0;
				outlineCamera.targetTexture = renderTexture;
				outlineCamera.enabled = false;
				outlineCamera.allowHDR = false;
			}

			public void AddOutline(Outline outline)
			{
				outlines.Add(outline);
			}

			public void RemoveOutline(Outline outline)
			{
				outlines.Remove(outline);
			}
		}
		public class DemoScript : MonoBehaviour
		{
			public int DefaultHandsModel = 1;

			public bool LoadHandSelectionFromPrefs = true;

			public float DefaultLocomotion;

			public bool LoadLocomotionFromPrefs = true;

			public Grabber LeftGrabber;

			public Grabber RightGrabber;

			public Transform LeftHandGFXHolder;

			public Transform RightHandGFXHolder;

			private int _selectedHandGFX;

			public GameObject DebugMenu;

			public Text LabelToUpdate;

			public Text JoystickText;

			private InputBridge input;

			private BNGPlayerController player;

			private PlayerTeleport teleport;

			public CharacterIK IKBody;

			public GameObject AmmoObject;

			private UIPointer uiPoint;

			public Transform ItemsHolder;

			private Dictionary<Grabbable, PosRot> _initalGrabbables;

			private List<Grabbable> demoClips;

			private void Start()
			{
				input = GetComponent<InputBridge>();
				player = GetComponent<BNGPlayerController>();
				teleport = GetComponent<PlayerTeleport>();
				uiPoint = GetComponentInChildren<UIPointer>();
				if (LoadHandSelectionFromPrefs)
				{
					ChangeHandsModel(PlayerPrefs.GetInt("HandSelection", DefaultHandsModel));
				}
				if (LoadLocomotionFromPrefs)
				{
					ChangeLocomotion(PlayerPrefs.GetInt("LocomotionSelection", 0), save: false);
				}
				VRUtils.Instance.Log("Output text here by using VRUtils.Log(\"Message Here\");");
				VRUtils.Instance.Log("Click the Menu button to toggle this menu.");
				if ((bool)ItemsHolder)
				{
					_initalGrabbables = new Dictionary<Grabbable, PosRot>();
					Grabbable[] componentsInChildren = ItemsHolder.GetComponentsInChildren<Grabbable>();
					foreach (Grabbable grabbable in componentsInChildren)
					{
						_initalGrabbables.Add(grabbable, new PosRot
						{
							Position = grabbable.transform.position,
							Rotation = grabbable.transform.rotation
						});
					}
				}
			}

			private void Update()
			{
				if (input.LeftThumbstickDown)
				{
					ChangeLocomotion((player.SelectedLocomotion != LocomotionType.SmoothLocomotion) ? 1 : 0, LoadLocomotionFromPrefs);
				}
				teleport.enabled = player.SelectedLocomotion == LocomotionType.Teleport;
				if (input.RightThumbstickDown || Input.GetKeyDown(KeyCode.N))
				{
					ChangeHandsModel(_selectedHandGFX + 1, LoadLocomotionFromPrefs);
				}
				if (input.StartButtonDown)
				{
					DebugMenu.SetActive(!DebugMenu.activeSelf);
				}
			}

			public void ChangeHandsModel(int childIndex, bool save = false)
			{
				LeftHandGFXHolder.GetChild(_selectedHandGFX).gameObject.SetActive(value: false);
				RightHandGFXHolder.GetChild(_selectedHandGFX).gameObject.SetActive(value: false);
				_selectedHandGFX = childIndex;
				if (_selectedHandGFX > LeftHandGFXHolder.childCount - 1)
				{
					_selectedHandGFX = 0;
				}
				GameObject gameObject = LeftHandGFXHolder.GetChild(_selectedHandGFX).gameObject;
				GameObject gameObject2 = RightHandGFXHolder.GetChild(_selectedHandGFX).gameObject;
				gameObject.SetActive(value: true);
				gameObject2.SetActive(value: true);
				HandController component = LeftHandGFXHolder.parent.GetComponent<HandController>();
				HandController component2 = RightHandGFXHolder.parent.GetComponent<HandController>();
				if ((bool)component && (bool)component2)
				{
					component.HandAnimator = gameObject.GetComponentInChildren<Animator>();
					component2.HandAnimator = gameObject2.GetComponentInChildren<Animator>();
				}
				if (IKBody != null)
				{
					IKBody.gameObject.SetActive(gameObject.transform.name.Contains("IK"));
				}
				if (_selectedHandGFX == 0 && uiPoint != null)
				{
					uiPoint.PointerObject.localPosition = new Vector3(0f, 0f, 0.0462f);
					uiPoint.PointerObject.localEulerAngles = new Vector3(0f, -4.5f, 0f);
				}
				else if (_selectedHandGFX != 0 && uiPoint != null)
				{
					uiPoint.PointerObject.localPosition = new Vector3(0.045f, 0.07f, 0.12f);
					uiPoint.PointerObject.localEulerAngles = new Vector3(-9.125f, 4.65f, 0f);
				}
				if (save)
				{
					PlayerPrefs.SetInt("HandSelection", _selectedHandGFX);
				}
			}

			public void ChangeLocomotion(int locomotionType, bool save)
			{
				switch (locomotionType)
				{
				case 0:
					player.ChangeLocomotionType(LocomotionType.Teleport);
					break;
				case 1:
					player.ChangeLocomotionType(LocomotionType.SmoothLocomotion);
					break;
				}
				if (save)
				{
					PlayerPrefs.SetInt("LocomotionSelection", locomotionType);
				}
			}

			public void UpdateSliderText(float sliderValue)
			{
				if (LabelToUpdate != null)
				{
					LabelToUpdate.text = (int)sliderValue + "%";
				}
			}

			public void UpdateJoystickText(float leverX, float leverY)
			{
				if (JoystickText != null)
				{
					JoystickText.text = "X : " + (int)leverX + "\nY: " + (int)leverY;
				}
			}

			public void ResetGrabbables()
			{
				foreach (KeyValuePair<Grabbable, PosRot> initalGrabbable in _initalGrabbables)
				{
					if (initalGrabbable.Key != null && initalGrabbable.Key.transform.parent == ItemsHolder)
					{
						initalGrabbable.Key.transform.position = initalGrabbable.Value.Position;
						initalGrabbable.Key.transform.rotation = initalGrabbable.Value.Rotation;
					}
				}
			}

			public void GrabAmmo(Grabber grabber)
			{
				if (demoClips == null)
				{
					demoClips = new List<Grabbable>();
				}
				if (demoClips.Count > 0 && demoClips[0] == null)
				{
					demoClips.RemoveAt(0);
				}
				if (AmmoObject != null)
				{
					if (demoClips.Count > 4 && demoClips[0] != null && demoClips[0].transform.parent == null)
					{
						UnityEngine.Object.Destroy(demoClips[0].gameObject);
					}
					GameObject obj = UnityEngine.Object.Instantiate(AmmoObject, grabber.transform.position, grabber.transform.rotation);
					Grabbable component = obj.GetComponent<Grabbable>();
					UnityEngine.Object.Destroy(obj.GetComponentInChildren<GrabbableRingHelper>());
					UnityEngine.Object.Destroy(obj.GetComponentInChildren<RingHelper>().gameObject);
					obj.transform.parent = grabber.transform;
					obj.transform.localPosition = -component.GrabPositionOffset;
					obj.transform.parent = null;
					if (component != null)
					{
						demoClips.Add(component);
					}
					grabber.GrabGrabbable(component);
				}
			}
		}
		public class PosRot
		{
			public Vector3 Position;

			public Quaternion Rotation;
		}
		public class HandTrackingDemo : MonoBehaviour
		{
			public HandTracking HandTrackingController;

			private Transform lastDrawPointLeft;

			private Transform lastDrawPointRight;

			public Text DebugText;

			public bool DrawMode;

			private float MinDrawDistance = 0.02f;

			private float LineWidth = 0.02f;

			public Material DrawMaterial;

			private Transform root;

			private void Start()
			{
				root = new GameObject().transform;
			}

			private void Update()
			{
				if (DrawMode)
				{
					doDrawMode();
				}
				updateDebugText();
			}

			private void doDrawMode()
			{
				if (HandTrackingController.IsRightIndexPinching)
				{
					if (lastDrawPointRight == null)
					{
						lastDrawPointRight = new GameObject().transform;
						lastDrawPointRight.position = HandTrackingController.RightIndexPosition;
					}
					else if (Vector3.Distance(lastDrawPointRight.position, HandTrackingController.RightIndexPosition) > MinDrawDistance)
					{
						lastDrawPointRight = drawPoint(lastDrawPointRight, HandTrackingController.RightIndexPosition, LineWidth, Color.cyan);
					}
				}
				else
				{
					lastDrawPointRight = null;
				}
				if (HandTrackingController.IsLeftIndexPinching)
				{
					if (lastDrawPointLeft == null)
					{
						lastDrawPointLeft = new GameObject().transform;
						lastDrawPointLeft.position = HandTrackingController.LeftIndexPosition;
					}
					else if (Vector3.Distance(lastDrawPointLeft.position, HandTrackingController.LeftIndexPosition) > MinDrawDistance)
					{
						lastDrawPointLeft = drawPoint(lastDrawPointLeft, HandTrackingController.LeftIndexPosition, LineWidth, Color.red);
					}
				}
				else
				{
					lastDrawPointLeft = null;
				}
			}

			private Transform drawPoint(Transform lastDrawPoint, Vector3 endPosition, float lineWidth, Color lineColor)
			{
				if ((bool)lastDrawPoint)
				{
					Transform obj = new GameObject().transform;
					obj.parent = root;
					obj.position = endPosition;
					LineRenderer lineRenderer = obj.gameObject.AddComponent<LineRenderer>();
					lineRenderer.startColor = lineColor;
					lineRenderer.endColor = lineColor;
					lineRenderer.startWidth = lineWidth;
					lineRenderer.endWidth = lineWidth;
					if ((bool)DrawMaterial)
					{
						lineRenderer.material = DrawMaterial;
					}
					lineRenderer.numCapVertices = 5;
					lineRenderer.useWorldSpace = true;
					lineRenderer.SetPosition(0, lastDrawPoint.position);
					lineRenderer.SetPosition(1, endPosition);
					return obj;
				}
				return null;
			}

			public void TogglePinchMode()
			{
				DrawMode = !DrawMode;
				HandTrackingController.DoPinchToGrab = !DrawMode;
			}

			public void ClearDrawing()
			{
				LineRenderer[] componentsInChildren = root.GetComponentsInChildren<LineRenderer>();
				for (int i = 0; i < componentsInChildren.Length; i++)
				{
					UnityEngine.Object.Destroy(componentsInChildren[i].gameObject);
				}
			}

			private void updateDebugText()
			{
				if (DebugText != null)
				{
					DebugText.text = "Tracking Hands : " + HandTrackingController.IsHandTracking;
					Text debugText = DebugText;
					debugText.text = debugText.text + "\nPinch Action : " + (DrawMode ? "Draw" : "Grab");
					Text debugText2 = DebugText;
					debugText2.text = debugText2.text + "\nLeft Pinch Strength : " + HandTrackingController.LeftIndexPinchStrength;
					Text debugText3 = DebugText;
					debugText3.text = debugText3.text + "\nRight Pinch Strength : " + HandTrackingController.RightIndexPinchStrength;
					Text debugText4 = DebugText;
					debugText4.text = debugText4.text + "\nLeft Tracked : " + HandTrackingController.LeftHand.IsTracked;
					Text debugText5 = DebugText;
					debugText5.text = debugText5.text + "\nRight Tracked : " + HandTrackingController.RightHand.IsTracked;
					Text debugText6 = DebugText;
					debugText6.text = debugText6.text + "\nConnected Controller Type : " + OVRInput.GetActiveController();
				}
			}
		}
		public class CharacterConstraint : MonoBehaviour
		{
			public float CurrentDistance;

			public float CapsuleClimbingHeight = 0.75f;

			public float CapsuleClimbingCenter = -0.125f;

			public float MinimumCapsuleHeight = 0.4f;

			public float MaximumCapsuleHeight = 3f;

			private Action cameraUpdateAction;

			private Action preCharacterMovementAction;

			private OVRCameraRig cameraRig;

			private OVRPlayerController playerController;

			private BNGPlayerController bngController;

			private CharacterController character;

			private CharacterConstraint()
			{
				cameraUpdateAction = CameraUpdate;
				preCharacterMovementAction = PreCharacterMovement;
			}

			private void Awake()
			{
				character = GetComponent<CharacterController>();
				playerController = GetComponent<OVRPlayerController>();
				cameraRig = GetComponentInChildren<OVRCameraRig>();
				bngController = base.transform.parent.GetComponent<BNGPlayerController>();
			}

			private void OnEnable()
			{
				playerController.PreCharacterMove += preCharacterMovementAction;
			}

			private void OnDisable()
			{
				playerController.CameraUpdated -= cameraUpdateAction;
			}

			private void Update()
			{
				CameraUpdate();
				checkClimbing();
			}

			private void checkClimbing()
			{
				bool isGrounded = character.isGrounded;
				if (bngController != null && bngController.GrippingClimbable && !isGrounded)
				{
					character.height = CapsuleClimbingHeight;
					character.center = new Vector3(0f, CapsuleClimbingCenter, 0f);
				}
				else
				{
					character.center = new Vector3(0f, -0.25f, 0f);
				}
			}

			private void CameraUpdate()
			{
				float cameraHeight = playerController.CameraHeight;
				if (cameraHeight <= character.height)
				{
					character.height = Mathf.Clamp(cameraHeight - character.skinWidth, MinimumCapsuleHeight, MaximumCapsuleHeight);
					return;
				}
				Vector3 position = character.transform.position;
				position += character.center;
				position.y -= character.height / 2f + character.radius;
				character.height = Mathf.Clamp(cameraHeight - character.skinWidth, MinimumCapsuleHeight, MaximumCapsuleHeight);
			}

			private void PreCharacterMovement()
			{
				if (playerController.Teleported)
				{
					return;
				}
				Vector3 position = cameraRig.transform.position;
				Vector3 position2 = cameraRig.centerEyeAnchor.position;
				Vector3 motion = position2 - base.transform.position;
				motion.y = 0f;
				if (motion.magnitude > 0f)
				{
					character.Move(motion);
					Vector3 vector = base.transform.position - position2;
					vector.y = 0f;
					CurrentDistance = vector.magnitude;
					cameraRig.transform.position = position;
				}
				else
				{
					CurrentDistance = 0f;
				}
				Vector3 position3 = base.transform.position;
				position3 += character.center;
				position3.y -= character.height / 2f;
				float cameraHeight = playerController.CameraHeight;
				if (Physics.SphereCast(position3, character.radius, Vector3.up, out var hitInfo, cameraHeight, base.gameObject.layer, QueryTriggerInteraction.Ignore))
				{
					float distance = hitInfo.distance;
					distance = cameraHeight - distance;
					if (distance > CurrentDistance)
					{
						CurrentDistance = distance;
					}
				}
			}
		}
		public class CharacterIK : MonoBehaviour
		{
			public Transform FollowLeftController;

			public Transform FollowRightController;

			public Transform FollowLeftFoot;

			public Transform FollowRightFoot;

			public Transform FollowHead;

			public float FootYPosition;

			public bool IKActive = true;

			public bool IKFeetActive = true;

			public bool HideHead = true;

			public bool HideLeftArm;

			public bool HideRightArm;

			public bool HideLeftHand;

			public bool HideRightHand;

			public bool HideLegs;

			public Transform HipsJoint;

			public CharacterController FollowPlayer;

			private Transform headBone;

			private Transform leftShoulderJoint;

			private Transform rightShoulderJoint;

			private Transform leftHandJoint;

			private Transform rightHandJoint;

			private Animator animator;

			public float HipOffset;

			public Vector3 hideBoneScale = new Vector3(0.0001f, 0.0001f, 0.0001f);

			private void Start()
			{
				animator = GetComponent<Animator>();
				headBone = animator.GetBoneTransform(HumanBodyBones.Head);
				leftHandJoint = animator.GetBoneTransform(HumanBodyBones.LeftHand);
				rightHandJoint = animator.GetBoneTransform(HumanBodyBones.RightHand);
				leftShoulderJoint = animator.GetBoneTransform(HumanBodyBones.LeftShoulder);
				rightShoulderJoint = animator.GetBoneTransform(HumanBodyBones.RightShoulder);
			}

			private void Update()
			{
				if (headBone != null)
				{
					headBone.localScale = (HideHead ? Vector3.zero : Vector3.one);
				}
				if (leftShoulderJoint != null)
				{
					leftShoulderJoint.localScale = (HideLeftArm ? hideBoneScale : Vector3.one);
				}
				if (rightShoulderJoint != null)
				{
					rightShoulderJoint.localScale = (HideRightArm ? hideBoneScale : Vector3.one);
				}
				if (leftHandJoint != null)
				{
					leftHandJoint.localScale = (HideLeftHand ? Vector3.zero : Vector3.one);
				}
				if (rightHandJoint != null)
				{
					rightHandJoint.localScale = (HideRightHand ? Vector3.zero : Vector3.one);
				}
				if ((bool)HipsJoint)
				{
					HipsJoint.localScale = (HideLegs ? Vector3.zero : Vector3.one);
				}
				animator.GetBoneTransform(HumanBodyBones.RightShoulder);
			}

			private void OnAnimatorIK()
			{
				if (!animator)
				{
					return;
				}
				if (IKActive)
				{
					if (FollowHead != null)
					{
						animator.SetLookAtWeight(1f);
						animator.SetLookAtPosition(FollowHead.position);
					}
					if (FollowLeftController != null)
					{
						animator.SetIKPositionWeight(AvatarIKGoal.LeftHand, 1f);
						animator.SetIKRotationWeight(AvatarIKGoal.LeftHand, 1f);
						animator.SetIKPosition(AvatarIKGoal.LeftHand, FollowLeftController.position);
						animator.SetIKRotation(AvatarIKGoal.LeftHand, FollowLeftController.rotation);
					}
					if (FollowRightController != null)
					{
						animator.SetIKPositionWeight(AvatarIKGoal.RightHand, 1f);
						animator.SetIKRotationWeight(AvatarIKGoal.RightHand, 1f);
						animator.SetIKPosition(AvatarIKGoal.RightHand, FollowRightController.position);
						animator.SetIKRotation(AvatarIKGoal.RightHand, FollowRightController.rotation);
					}
					if (IKFeetActive)
					{
						if (FollowLeftFoot != null)
						{
							animator.SetIKPositionWeight(AvatarIKGoal.LeftFoot, 1f);
							animator.SetIKPosition(AvatarIKGoal.LeftFoot, new Vector3(FollowLeftFoot.position.x, FootYPosition, FollowLeftFoot.position.z));
						}
						if (FollowRightFoot != null)
						{
							animator.SetIKPositionWeight(AvatarIKGoal.RightFoot, 1f);
							animator.SetIKPosition(AvatarIKGoal.RightFoot, new Vector3(FollowRightFoot.position.x, FootYPosition, FollowRightFoot.position.z));
						}
					}
					else
					{
						if (FollowLeftFoot != null)
						{
							animator.SetIKPositionWeight(AvatarIKGoal.LeftFoot, 0f);
						}
						if (FollowRightFoot != null)
						{
							animator.SetIKPositionWeight(AvatarIKGoal.RightFoot, 0f);
						}
					}
				}
				else
				{
					animator.SetIKPositionWeight(AvatarIKGoal.LeftHand, 0f);
					animator.SetIKRotationWeight(AvatarIKGoal.LeftHand, 0f);
					animator.SetIKPositionWeight(AvatarIKGoal.RightHand, 0f);
					animator.SetIKRotationWeight(AvatarIKGoal.RightHand, 0f);
					animator.SetLookAtWeight(0f);
				}
			}
		}
		public class Climbable : Grabbable
		{
			private BNGPlayerController bngController;

			private void Start()
			{
				SecondaryGrabBehavior = OtherGrabBehavior.DualGrab;
				GrabPhysics = GrabPhysics.None;
			}

			public override void GrabItem(Grabber grabbedBy)
			{
				UnityEngine.Debug.Log("Grabbed by " + grabbedBy.HandSide);
				if (bngController == null)
				{
					bngController = GameObject.FindGameObjectWithTag("Player").GetComponent<BNGPlayerController>();
				}
				bngController.AddClimber(this, grabbedBy);
				base.GrabItem(grabbedBy);
			}

			public override void DropItem(Grabber droppedBy)
			{
				if (droppedBy != null)
				{
					UnityEngine.Debug.Log("Dropping " + droppedBy.HandSide);
					bngController.RemoveClimber(droppedBy);
				}
				base.DropItem(droppedBy);
			}
		}
		public class CollisionSound : MonoBehaviour
		{
			public AudioClip CollisionAudio;

			private AudioSource audioSource;

			private float startTime;

			private Collider col;

			private void Start()
			{
				audioSource = GetComponent<AudioSource>();
				startTime = Time.time;
				col = GetComponent<Collider>();
			}

			private void OnCollisionEnter(Collision collision)
			{
				if (!(Time.time - startTime < 0.1f) && col.enabled && (bool)audioSource && (bool)CollisionAudio)
				{
					if (audioSource.isPlaying)
					{
						audioSource.Stop();
					}
					audioSource.clip = CollisionAudio;
					audioSource.pitch = Time.timeScale;
					audioSource.Play();
				}
			}
		}
		public class ConstrainLocalPosition : MonoBehaviour
		{
			public bool ConstrainLocalX;

			public float LocalXMin = -1f;

			public float LocalXMax = 1f;

			public bool ConstrainLocalY;

			public float LocalYMin = -1f;

			public float LocalYMax = 1f;

			public bool ConstrainLocalZ;

			public float LocalZMin = -1f;

			public float LocalZMax = 1f;

			private void Update()
			{
				if (ConstrainLocalX || ConstrainLocalY || ConstrainLocalZ)
				{
					Vector3 localPosition = base.transform.localPosition;
					float x = (ConstrainLocalX ? Mathf.Clamp(localPosition.x, LocalXMin, LocalXMax) : localPosition.x);
					float y = (ConstrainLocalX ? Mathf.Clamp(localPosition.x, LocalXMin, LocalXMax) : localPosition.x);
					float z = (ConstrainLocalX ? Mathf.Clamp(localPosition.x, LocalXMin, LocalXMax) : localPosition.x);
					base.transform.localPosition = new Vector3(x, y, z);
				}
			}
		}
		public class DamageCollider : MonoBehaviour
		{
			public float Damage = 25f;

			private Rigidbody damageRigidbody;

			public float MinForce = 0.1f;

			public float LastRelativeVelocity;

			public float LastDamageForce;

			private void Start()
			{
				damageRigidbody = GetComponent<Rigidbody>();
			}

			private void OnCollisionEnter(Collision collision)
			{
				LastDamageForce = collision.impulse.magnitude;
				LastRelativeVelocity = collision.relativeVelocity.magnitude;
				if (LastDamageForce >= MinForce)
				{
					Damageable component = collision.gameObject.GetComponent<Damageable>();
					if ((bool)component)
					{
						component.DealDamage(Damage);
					}
				}
			}
		}
		public class Damageable : MonoBehaviour
		{
			public float Health = 100f;

			private float _startingHealth;

			public List<GameObject> ActivateGameObjectsOnDeath;

			public List<GameObject> DeactivateGameObjectsOnDeath;

			public List<Collider> DeactivateCollidersOnDeath;

			public bool DestroyOnDeath = true;

			public float DestroyDelay;

			public bool Respawn;

			public float RespawnTime = 10f;

			public bool RemoveBulletHolesOnDeath = true;

			private bool destroyed;

			private void Start()
			{
				_startingHealth = Health;
			}

			public void DealDamage(float damageAmount)
			{
				if (!destroyed)
				{
					Health -= damageAmount;
					if (Health < 0f)
					{
						DestroyThis();
					}
				}
			}

			public void DestroyThis()
			{
				Health = 0f;
				destroyed = true;
				foreach (GameObject item in ActivateGameObjectsOnDeath)
				{
					item.SetActive(value: true);
				}
				foreach (GameObject item2 in DeactivateGameObjectsOnDeath)
				{
					item2.SetActive(value: false);
				}
				foreach (Collider item3 in DeactivateCollidersOnDeath)
				{
					item3.enabled = false;
				}
				if (DestroyOnDeath)
				{
					UnityEngine.Object.Destroy(base.gameObject, DestroyDelay);
				}
				else if (Respawn)
				{
					StartCoroutine(RespawnRoutine(RespawnTime));
				}
				if (RemoveBulletHolesOnDeath)
				{
					BulletHole[] componentsInChildren = GetComponentsInChildren<BulletHole>();
					for (int i = 0; i < componentsInChildren.Length; i++)
					{
						UnityEngine.Object.Destroy(componentsInChildren[i].gameObject);
					}
					Transform transform = base.transform.Find("Decal");
					if ((bool)transform)
					{
						UnityEngine.Object.Destroy(transform.gameObject);
					}
				}
			}

			private IEnumerator RespawnRoutine(float seconds)
			{
				yield return new WaitForSeconds(seconds);
				Health = _startingHealth;
				destroyed = false;
				foreach (GameObject item in ActivateGameObjectsOnDeath)
				{
					item.SetActive(value: false);
				}
				foreach (GameObject item2 in DeactivateGameObjectsOnDeath)
				{
					item2.SetActive(value: true);
				}
				foreach (Collider item3 in DeactivateCollidersOnDeath)
				{
					item3.enabled = true;
				}
			}
		}
		public class FollowTransform : MonoBehaviour
		{
			public Transform FollowTarget;

			public bool MatchRotation = true;

			private void Update()
			{
				if ((bool)FollowTarget)
				{
					base.transform.position = FollowTarget.position;
					if (MatchRotation)
					{
						base.transform.rotation = FollowTarget.rotation;
					}
				}
			}
		}
		public class GrabAction : GrabbableEvents
		{
			public GrabberEvent OnGrabEvent;

			private Grabbable g;

			private float lastGrabTime;

			private float minTimeBetweenGrabs = 0.2f;

			public override void OnGrab(Grabber grabber)
			{
				if (g == null)
				{
					g = GetComponent<Grabbable>();
				}
				g.DropItem(grabber, resetVelocity: false, resetParent: false);
				if (!grabber.RemoteGrabbingItem && !grabber.HoldingItem && OnGrabEvent != null && Time.time - lastGrabTime >= minTimeBetweenGrabs)
				{
					OnGrabEvent.Invoke(grabber);
					lastGrabTime = Time.time;
				}
			}
		}
		public class GrabbableHaptics : GrabbableEvents
		{
			public bool HapticsOnValidPickup = true;

			public bool HapticsOnValidRemotePickup = true;

			public bool HapticsOnCollision = true;

			public float VibrateFrequency = 0.3f;

			public float VibrateAmplitude = 0.1f;

			public float VibrateDuration = 0.1f;

			private Grabber currentGrabber;

			public override void OnGrab(Grabber grabber)
			{
				currentGrabber = grabber;
			}

			public override void OnRelease()
			{
				currentGrabber = null;
			}

			public override void OnBecomesClosestGrabbable(ControllerHand touchingHand)
			{
				if (HapticsOnValidPickup)
				{
					doHaptics(touchingHand);
				}
			}

			public override void OnBecomesClosestRemoteGrabbable(ControllerHand touchingHand)
			{
				if (HapticsOnValidRemotePickup)
				{
					doHaptics(touchingHand);
				}
			}

			private void doHaptics(ControllerHand touchingHand)
			{
				if ((bool)input)
				{
					input.VibrateController(VibrateFrequency, VibrateAmplitude, VibrateDuration, touchingHand);
				}
			}

			private void OnCollisionEnter(Collision collision)
			{
				if (HapticsOnCollision && currentGrabber != null && input != null && grab != null && grab.BeingHeld)
				{
					input.VibrateController(0.1f, 0.1f, 0.1f, currentGrabber.HandSide);
				}
			}
		}
		public class GrabbableHighlight : GrabbableEvents
		{
			public bool HighlightOnGrabbable = true;

			public bool HighlightOnRemoteGrabbable = true;

			private Outline outline;

			private void Start()
			{
				outline = GetComponent<Outline>();
				if ((HighlightOnGrabbable || HighlightOnRemoteGrabbable) && outline == null)
				{
					if ((bool)GetComponent<Renderer>())
					{
						outline = base.gameObject.AddComponent<Outline>();
						outline.eraseRenderer = false;
						outline.enabled = false;
					}
					else
					{
						Renderer componentInChildren = GetComponentInChildren<Renderer>();
						if (componentInChildren != null)
						{
							outline = componentInChildren.gameObject.AddComponent<Outline>();
							outline.eraseRenderer = false;
							outline.enabled = false;
						}
					}
				}
				if (Camera.main.GetComponent<OutlineEffect>() == null)
				{
					OutlineEffect outlineEffect = Camera.main.gameObject.AddComponent<OutlineEffect>();
					outlineEffect.lineThickness = 2f;
					outlineEffect.lineIntensity = 1f;
					outlineEffect.fillAmount = 0f;
					outlineEffect.lineColor0 = Color.white;
					outlineEffect.cornerOutlines = true;
					outlineEffect.scaleWithScreenSize = false;
				}
			}

			public override void OnGrab(Grabber grabber)
			{
				UnhighlightItem();
			}

			public override void OnBecomesClosestGrabbable(ControllerHand touchingHand)
			{
				if (HighlightOnGrabbable)
				{
					HighlightItem();
				}
			}

			public override void OnNoLongerClosestGrabbable(ControllerHand touchingHand)
			{
				if (HighlightOnGrabbable)
				{
					UnhighlightItem();
				}
			}

			public override void OnBecomesClosestRemoteGrabbable(ControllerHand touchingHand)
			{
				if (HighlightOnRemoteGrabbable)
				{
					HighlightItem();
				}
			}

			public override void OnNoLongerClosestRemoteGrabbable(ControllerHand touchingHand)
			{
				if (HighlightOnRemoteGrabbable)
				{
					UnhighlightItem();
				}
			}

			public void HighlightItem()
			{
				if (outline != null)
				{
					outline.enabled = true;
				}
			}

			public void UnhighlightItem()
			{
				if (outline != null)
				{
					outline.enabled = false;
				}
			}
		}
		public class GrabbableRingHelper : GrabbableEvents
		{
			public bool RingOnValidPickup = true;

			public bool RingOnValidRemotePickup = true;

			public float RingHelperScale = 0.2f;

			private void Start()
			{
				if (RingOnValidPickup && GetComponentInChildren<RingHelper>() == null)
				{
					GameObject obj = UnityEngine.Object.Instantiate(Resources.Load("RingHelper", typeof(GameObject))) as GameObject;
					obj.transform.SetParent(base.transform, worldPositionStays: false);
					obj.transform.name = "Ring Helper";
					obj.transform.localPosition = grab.GrabPositionOffset;
					obj.GetComponent<RectTransform>().localScale = new Vector3(RingHelperScale, RingHelperScale, RingHelperScale);
				}
			}
		}
		public class LineToTransform : MonoBehaviour
		{
			public Transform ConnectTo;

			private LineRenderer line;

			private void Start()
			{
				line = GetComponent<LineRenderer>();
				if ((bool)line)
				{
					line.useWorldSpace = false;
				}
			}

			private void LateUpdate()
			{
				line.SetPosition(0, Vector3.zero);
				line.SetPosition(1, base.transform.InverseTransformPoint(ConnectTo.position));
			}
		}
		public class LookAtTransform : MonoBehaviour
		{
			public Transform LookAt;

			public bool UseLerp = true;

			public float Speed = 20f;

			public bool UseUpdate;

			public bool UseLateUpdate = true;

			private void Update()
			{
				if (UseUpdate)
				{
					lookAt();
				}
			}

			private void LateUpdate()
			{
				if (UseLateUpdate)
				{
					lookAt();
				}
			}

			private void lookAt()
			{
				if (LookAt != null)
				{
					if (UseLerp)
					{
						Quaternion b = Quaternion.LookRotation(LookAt.position - base.transform.position);
						base.transform.rotation = Quaternion.Slerp(base.transform.rotation, b, Time.deltaTime * Speed);
					}
					else
					{
						base.transform.LookAt(LookAt, base.transform.forward);
					}
				}
			}
		}
		public class RotateWithHMD : MonoBehaviour
		{
			public Transform HMDTransform;

			public CharacterController Character;

			public Vector3 Offset = new Vector3(0f, -0.25f, 0f);

			public Vector3 DebugVector;

			private void Update()
			{
				updateBodyPosition();
			}

			private void updateBodyPosition()
			{
				if (HMDTransform != null)
				{
					base.transform.position = HMDTransform.position;
					if (Character != null)
					{
						base.transform.rotation = Quaternion.Lerp(base.transform.rotation, Character.transform.rotation, Time.deltaTime * 5f);
						base.transform.localPosition -= Character.transform.TransformVector(Offset);
					}
				}
			}
		}
		public class ScaleBetweenPoints : MonoBehaviour
		{
			public Transform Begin;

			public Transform End;

			public bool DoUpdate = true;

			public bool DoLateUpdate;

			public bool LookAtTarget;

			private void Update()
			{
				if (DoUpdate)
				{
					doScale();
				}
			}

			private void LateUpdate()
			{
				if (DoLateUpdate)
				{
					doScale();
				}
			}

			private void doScale()
			{
				if (LookAtTarget)
				{
					base.transform.position = Begin.position;
					base.transform.LookAt(End, base.transform.up);
				}
				Vector3 localScale = base.transform.localScale;
				float z = Vector3.Distance(Begin.position, End.position);
				Vector3 localScale2 = new Vector3(localScale.x, localScale.y, z);
				base.transform.localScale = localScale2;
				base.transform.position = (Begin.position + End.position) / 2f;
			}
		}
		public class SnapZoneRingHelper : MonoBehaviour
		{
			public SnapZone Snap;

			public Color RestingColor = Color.gray;

			public Color ValidSnapColor = Color.white;

			public float RestingScale = 1000f;

			public float ValidSnapScale = 800f;

			private CanvasScaler ringCanvas;

			private Text ringText;

			private GrabbablesInTrigger nearbyGrabbables;

			private bool validSnap;

			public float ScaleSpeed = 50f;

			private void Start()
			{
				ringCanvas = GetComponent<CanvasScaler>();
				ringText = GetComponent<Text>();
				nearbyGrabbables = Snap.GetComponent<GrabbablesInTrigger>();
			}

			private void Update()
			{
				validSnap = checkIsValidSnap();
				float b = (validSnap ? ValidSnapScale : RestingScale);
				ringCanvas.dynamicPixelsPerUnit = Mathf.Lerp(ringCanvas.dynamicPixelsPerUnit, b, Time.deltaTime * ScaleSpeed);
				ringText.color = (validSnap ? ValidSnapColor : RestingColor);
			}

			private bool checkIsValidSnap()
			{
				if (nearbyGrabbables != null)
				{
					if (Snap.HeldItem != null)
					{
						return false;
					}
					if (Snap.ClosestGrabbable != null)
					{
						return true;
					}
				}
				return false;
			}
		}
		public class UIPointer : MonoBehaviour
		{
			public Transform PointerObject;

			private LineRenderer uiLiner;

			private OVRGazePointer uiCursor;

			public float MaxDistance = 5f;

			public float LineDistanceModifier = 0.8f;

			public float PointerLocalScale = 0.01f;

			private void Start()
			{
				uiCursor = GetComponent<OVRGazePointer>();
				if ((bool)PointerObject)
				{
					uiLiner = PointerObject.GetComponent<LineRenderer>();
					uiLiner.useWorldSpace = false;
				}
			}

			private void LateUpdate()
			{
				base.transform.localScale = new Vector3(PointerLocalScale, PointerLocalScale, PointerLocalScale);
				if (!uiLiner)
				{
					return;
				}
				if (uiCursor.visibilityStrength > 0.1f)
				{
					uiLiner.enabled = true;
					float num = Vector3.Distance(base.transform.position, PointerObject.position);
					if (num > MaxDistance)
					{
						uiLiner.enabled = false;
					}
					else
					{
						uiLiner.SetPosition(1, new Vector3(0f, 0f, num * LineDistanceModifier));
					}
				}
				else
				{
					uiLiner.enabled = false;
				}
			}
		}
		public enum LocomotionType
		{
			Teleport,
			SmoothLocomotion
		}
		public class BNGPlayerController : MonoBehaviour
		{
			[SerializeField]
			private LocomotionType selectedLocomotion;

			public bool GrippingClimbable;

			public LayerMask GroundedLayers;

			private Vector3 moveDirection = Vector3.zero;

			public float DistanceFromGround;

			public float MinElevation = -5000f;

			public float MaxElevation = 5000f;

			private List<Grabber> climbers;

			private CharacterController characterController;

			private OVRPlayerController pControl;

			private PlayerTeleport teleport;

			private float _initialGravityModifier;

			private Vector3 _initialPosition;

			public LocomotionType SelectedLocomotion => selectedLocomotion;

			private void Start()
			{
				characterController = GetComponentInChildren<CharacterController>();
				pControl = GetComponentInChildren<OVRPlayerController>();
				_initialGravityModifier = pControl.GravityModifier;
				_initialPosition = characterController.transform.position;
				float y = _initialPosition.y;
				if (y < MinElevation)
				{
					UnityEngine.Debug.LogWarning("Initial Starting Position is lower than Minimum Elevation. Increasing Min Elevation to " + y);
					MinElevation = y;
				}
				if (y > MaxElevation)
				{
					UnityEngine.Debug.LogWarning("Initial Starting Position is greater than Maximum Elevation. Reducing Max Elevation to " + y);
					MaxElevation = y;
				}
				teleport = GetComponent<PlayerTeleport>();
				climbers = new List<Grabber>();
				ChangeLocomotionType(selectedLocomotion);
			}

			private void Update()
			{
				pControl.EnableLinearMovement = selectedLocomotion == LocomotionType.SmoothLocomotion;
				checkClimbing();
			}

			private void FixedUpdate()
			{
				if (characterController.transform.position.y < MinElevation || characterController.transform.position.y > MaxElevation)
				{
					characterController.transform.position = _initialPosition;
				}
				DistanceFromGround = 9999f;
				if (Physics.Raycast(characterController.transform.position, -characterController.transform.up, out var hitInfo, 20f, GroundedLayers, QueryTriggerInteraction.Ignore))
				{
					DistanceFromGround = Vector3.Distance(characterController.transform.position, hitInfo.point);
					DistanceFromGround -= characterController.height / 2f;
				}
			}

			private bool grippingAtLeastOneClimbable()
			{
				if (climbers != null && climbers.Count > 0)
				{
					for (int i = 0; i < climbers.Count; i++)
					{
						if (climbers[i] != null && climbers[i].HoldingItem)
						{
							return true;
						}
					}
					climbers = new List<Grabber>();
				}
				return false;
			}

			private void checkClimbing()
			{
				GrippingClimbable = grippingAtLeastOneClimbable();
				if (GrippingClimbable)
				{
					pControl.enabled = false;
					moveDirection = Vector3.zero;
					int num = 0;
					foreach (Grabber climber in climbers)
					{
						if (climber != null && climber.HoldingItem)
						{
							Vector3 vector = climber.PreviousPosition - climber.transform.position;
							if (num == 0)
							{
								moveDirection += vector;
							}
							else
							{
								moveDirection += vector - moveDirection;
							}
							num++;
						}
					}
					characterController.Move(moveDirection);
				}
				else
				{
					pControl.enabled = true;
				}
				foreach (Grabber climber2 in climbers)
				{
					if (climber2 != null && climber2.HoldingItem)
					{
						if (climber2.DummyTransform != null)
						{
							climber2.PreviousPosition = climber2.DummyTransform.position;
						}
						else
						{
							climber2.PreviousPosition = climber2.transform.position;
						}
					}
				}
			}

			public void ChangeLocomotionType(LocomotionType loc)
			{
				selectedLocomotion = loc;
				if (teleport == null)
				{
					teleport = GetComponent<PlayerTeleport>();
				}
				if (selectedLocomotion == LocomotionType.Teleport)
				{
					teleport.EnableTeleportation();
				}
				else
				{
					teleport.DisableTeleportation();
				}
			}

			public void ToggleLocomotionType()
			{
				if (selectedLocomotion == LocomotionType.SmoothLocomotion)
				{
					ChangeLocomotionType(LocomotionType.Teleport);
				}
				else
				{
					ChangeLocomotionType(LocomotionType.SmoothLocomotion);
				}
			}

			public void ToggleGravity(bool gravityOn)
			{
				if (gravityOn)
				{
					pControl.GravityModifier = _initialGravityModifier;
				}
				else
				{
					pControl.GravityModifier = 0f;
				}
			}

			public void AddClimber(Climbable climbable, Grabber grab)
			{
				if (!climbers.Contains(grab))
				{
					if (grab.DummyTransform == null)
					{
						GameObject gameObject = new GameObject();
						gameObject.transform.name = "DummyTransform";
						gameObject.transform.parent = grab.transform;
						gameObject.transform.position = grab.transform.position;
						gameObject.transform.localEulerAngles = Vector3.zero;
						grab.DummyTransform = gameObject.transform;
					}
					grab.DummyTransform.parent = climbable.transform;
					grab.PreviousPosition = grab.DummyTransform.position;
					climbers.Add(grab);
				}
			}

			public void RemoveClimber(Grabber grab)
			{
				if (climbers.Contains(grab))
				{
					grab.DummyTransform.parent = grab.transform;
					grab.DummyTransform.localPosition = Vector3.zero;
					climbers.Remove(grab);
				}
			}
		}
		public class Button : MonoBehaviour
		{
			public float MinLocalY = 0.25f;

			public float MaxLocalY = 0.55f;

			public float ClickTolerance = 0.01f;

			private List<Grabber> grabbers;

			private SpringJoint joint;

			private bool clickingDown;

			public AudioClip ButtonClick;

			public AudioClip ButtonClickUp;

			public UnityEvent onButtonDown;

			public UnityEvent onButtonUp;

			private AudioSource audioSource;

			private float ButtonSpeed = 15f;

			private float SpringForce = 1500f;

			private void Start()
			{
				grabbers = new List<Grabber>();
				joint = GetComponent<SpringJoint>();
				base.transform.localPosition = new Vector3(base.transform.localPosition.x, MaxLocalY, base.transform.localPosition.z);
				audioSource = GetComponent<AudioSource>();
			}

			private void Update()
			{
				Vector3 vector = new Vector3(base.transform.localPosition.x, MinLocalY, base.transform.localPosition.z);
				Vector3 localPosition = new Vector3(base.transform.localPosition.x, MaxLocalY, base.transform.localPosition.z);
				if (grabbers.Count > 0)
				{
					float buttonSpeed = ButtonSpeed;
					base.transform.localPosition = Vector3.Lerp(base.transform.localPosition, vector, buttonSpeed * Time.deltaTime);
					joint.spring = 0f;
				}
				else
				{
					joint.spring = SpringForce;
				}
				if (base.transform.localPosition.y < MinLocalY)
				{
					base.transform.localPosition = vector;
				}
				else if (base.transform.localPosition.y > MaxLocalY)
				{
					base.transform.localPosition = localPosition;
				}
				if (base.transform.localPosition.y - vector.y <= ClickTolerance && !clickingDown)
				{
					clickingDown = true;
					OnButtonDown();
				}
				if (localPosition.y - base.transform.localPosition.y <= ClickTolerance && clickingDown)
				{
					clickingDown = false;
					OnButtonUp();
				}
			}

			public virtual void OnButtonDown()
			{
				if ((bool)audioSource && (bool)ButtonClick)
				{
					audioSource.clip = ButtonClick;
					audioSource.Play();
				}
				if (onButtonDown != null)
				{
					onButtonDown.Invoke();
				}
			}

			public virtual void OnButtonUp()
			{
				if ((bool)audioSource && (bool)ButtonClickUp)
				{
					audioSource.clip = ButtonClickUp;
					audioSource.Play();
				}
				if (onButtonUp != null)
				{
					onButtonUp.Invoke();
				}
			}

			private void OnTriggerEnter(Collider other)
			{
				Grabber component = other.GetComponent<Grabber>();
				if (component != null)
				{
					if (grabbers == null)
					{
						grabbers = new List<Grabber>();
					}
					if (!grabbers.Contains(component))
					{
						grabbers.Add(component);
					}
				}
			}

			private void OnTriggerExit(Collider other)
			{
				Grabber component = other.GetComponent<Grabber>();
				if (component != null && grabbers.Contains(component))
				{
					grabbers.Remove(component);
				}
			}
		}
		public enum GrabType
		{
			Snap,
			Precise
		}
		public enum HoldType
		{
			HoldDown,
			Toggle
		}
		public enum GrabPhysics
		{
			PhysicsJoint,
			Kinematic,
			None
		}
		public enum OtherGrabBehavior
		{
			None,
			SwapHands,
			DualGrab
		}
		public class Grabbable : MonoBehaviour
		{
			[HideInInspector]
			public bool BeingHeld;

			private List<Grabber> validGrabbers;

			public bool RemoteGrabbable;

			public float RemoteGrabDistance = 2f;

			protected List<Grabber> heldByGrabbers;

			private Collider col;

			private Rigidbody rigid;

			private bool wasKinematic;

			private bool usedGravity;

			private bool remoteGrabbing;

			public GrabButton GrabButton;

			public HoldType Grabtype;

			public GrabPhysics GrabPhysics;

			public GrabType GrabMechanic;

			public float GrabSpeed = 7.5f;

			public float ThrowForceMultiplier = 2f;

			public float ThrowForceMultiplierAngular = 1.5f;

			public float BreakDistance = 1f;

			public bool HideHandGraphics;

			public bool ParentToHands = true;

			public bool ParentHandModel;

			public OtherGrabBehavior SecondaryGrabBehavior;

			public Grabbable OtherGrabbableMustBeGrabbed;

			public float CollisionSpring = 3000f;

			public float CollisionSlerp = 500f;

			protected float grabTime;

			public bool CanBeDropped = true;

			public float LastDropTime;

			private float journeyLength;

			private float _originalScale;

			private List<Collider> collisions;

			public Vector3 GrabPositionOffset = Vector3.zero;

			private Vector3 _grabPositionOffset = Vector3.zero;

			public Vector3 GrabRotationOffset = Vector3.zero;

			public bool MirrorOffsetForOtherHand = true;

			private ConfigurableJoint connectedJoint;

			private Transform _grabTransform;

			private Transform originalParent;

			protected InputBridge input;

			protected GrabbableEvents events;

			private bool didParentHands;

			private Grabber flyingTo;

			public bool IsGrabbable => isGrabbable();

			public float OriginalScale => _originalScale;

			private int collisionCount => getCollisionCount();

			protected Transform grabTransform
			{
				get
				{
					if (_grabTransform != null)
					{
						return _grabTransform;
					}
					_grabTransform = new GameObject().transform;
					_grabTransform.parent = base.transform;
					_grabTransform.name = "Grab Transform";
					_grabTransform.localPosition = Vector3.zero;
					return _grabTransform;
				}
			}

			private void Awake()
			{
				col = GetComponent<Collider>();
				rigid = GetComponent<Rigidbody>();
				if ((bool)GameObject.FindGameObjectWithTag("Player"))
				{
					input = GameObject.FindGameObjectWithTag("Player").GetComponent<InputBridge>();
				}
				events = GetComponent<GrabbableEvents>();
				collisions = new List<Collider>();
				if (rigid == null && base.transform.parent != null)
				{
					rigid = base.transform.parent.GetComponent<Rigidbody>();
				}
				wasKinematic = rigid != null && rigid.isKinematic;
				usedGravity = rigid != null && rigid.useGravity;
				originalParent = base.transform.parent;
				validGrabbers = new List<Grabber>();
				_grabPositionOffset = GrabPositionOffset;
				_originalScale = base.transform.localScale.x;
			}

			private void Update()
			{
				if (!remoteGrabbing)
				{
					return;
				}
				base.transform.position = Vector3.Lerp(base.transform.position, grabTransform.position, Time.deltaTime * GrabSpeed);
				base.transform.rotation = Quaternion.Lerp(base.transform.rotation, grabTransform.rotation, Time.deltaTime * GrabSpeed);
				if ((double)Vector3.Distance(base.transform.position, grabTransform.position) < 0.01)
				{
					base.transform.position = grabTransform.position;
					base.transform.rotation = grabTransform.rotation;
					if (flyingTo != null)
					{
						flyingTo.GrabGrabbable(this);
					}
				}
			}

			private void updateJoints(Grabber g)
			{
				if (GrabPhysics == GrabPhysics.PhysicsJoint)
				{
					if (collisions.Count == 0)
					{
						connectedJoint.rotationDriveMode = RotationDriveMode.XYAndZ;
						connectedJoint.xMotion = ConfigurableJointMotion.Locked;
						connectedJoint.yMotion = ConfigurableJointMotion.Locked;
						connectedJoint.zMotion = ConfigurableJointMotion.Locked;
						connectedJoint.angularXMotion = ConfigurableJointMotion.Limited;
						connectedJoint.angularYMotion = ConfigurableJointMotion.Limited;
						connectedJoint.angularZMotion = ConfigurableJointMotion.Limited;
						JointDrive xDrive = connectedJoint.xDrive;
						xDrive.positionSpring = 9001f;
						JointDrive slerpDrive = connectedJoint.slerpDrive;
						slerpDrive.positionSpring = 1000f;
						if (ParentToHands && base.transform.parent != g.transform)
						{
							base.transform.parent = g.transform;
						}
					}
					else
					{
						connectedJoint.rotationDriveMode = RotationDriveMode.Slerp;
						connectedJoint.xMotion = ConfigurableJointMotion.Free;
						connectedJoint.yMotion = ConfigurableJointMotion.Free;
						connectedJoint.zMotion = ConfigurableJointMotion.Free;
						connectedJoint.angularXMotion = ConfigurableJointMotion.Free;
						connectedJoint.angularYMotion = ConfigurableJointMotion.Free;
						connectedJoint.angularZMotion = ConfigurableJointMotion.Free;
						JointDrive xDrive2 = connectedJoint.xDrive;
						xDrive2.positionSpring = CollisionSpring;
						JointDrive slerpDrive2 = connectedJoint.slerpDrive;
						slerpDrive2.positionSpring = CollisionSlerp;
						if (ParentToHands)
						{
							base.transform.parent = null;
						}
					}
				}
				if (GrabPhysics == GrabPhysics.Kinematic)
				{
					float t = (Time.time - grabTime) * GrabSpeed / journeyLength;
					if (GrabMechanic == GrabType.Snap)
					{
						base.transform.position = Vector3.Lerp(base.transform.position, grabTransform.position, t);
						base.transform.localRotation = Quaternion.Lerp(base.transform.localRotation, grabTransform.localRotation, Time.deltaTime * 10f);
					}
					else if (GrabMechanic == GrabType.Precise)
					{
						base.transform.position = grabTransform.position;
						base.transform.eulerAngles = grabTransform.eulerAngles;
					}
				}
				if (ParentHandModel && !didParentHands && (Vector3.Distance(base.transform.position, grabTransform.position) < 0.002f || GrabMechanic == GrabType.Precise))
				{
					parentHandGraphics(g);
				}
			}

			private void FixedUpdate()
			{
				if (!BeingHeld)
				{
					return;
				}
				if (heldByGrabbers == null)
				{
					DropItem(null, resetVelocity: true, resetParent: true);
					return;
				}
				filterCollisions();
				foreach (Grabber heldByGrabber in heldByGrabbers)
				{
					if (Vector3.Distance(base.transform.position, heldByGrabber.transform.position) > BreakDistance)
					{
						DropItem(heldByGrabber, resetVelocity: true, resetParent: true);
						break;
					}
				}
				foreach (Grabber heldByGrabber2 in heldByGrabbers)
				{
					updateJoints(heldByGrabber2);
					callEvents(heldByGrabber2);
				}
			}

			private void callEvents(Grabber g)
			{
				if (!events)
				{
					return;
				}
				ControllerHand handSide = g.HandSide;
				if (handSide == ControllerHand.Right)
				{
					events.OnGrip(input.RightGrip);
					events.OnTrigger(input.RightTrigger);
					if (input.RightTriggerDown)
					{
						events.OnTriggerDown();
					}
					if (input.AButton)
					{
						events.OnButton1();
					}
					if (input.AButtonDown)
					{
						events.OnButton1Down();
					}
					if (input.BButton)
					{
						events.OnButton2();
					}
					if (input.BButtonDown)
					{
						events.OnButton2Down();
					}
				}
				if (handSide == ControllerHand.Left)
				{
					events.OnGrip(input.LeftGrip);
					events.OnTrigger(input.LeftTrigger);
					if (input.LeftTriggerDown)
					{
						events.OnTriggerDown();
					}
					if (input.XButton)
					{
						events.OnButton1();
					}
					if (input.XButtonDown)
					{
						events.OnButton1Down();
					}
					if (input.YButton)
					{
						events.OnButton2();
					}
					if (input.YButtonDown)
					{
						events.OnButton2Down();
					}
				}
			}

			public void AddValidGrabber(Grabber grabber)
			{
				if (validGrabbers == null)
				{
					validGrabbers = new List<Grabber>();
				}
				if (!validGrabbers.Contains(grabber))
				{
					validGrabbers.Add(grabber);
				}
			}

			public void RemoveValidGrabber(Grabber grabber)
			{
				if (validGrabbers != null && validGrabbers.Contains(grabber))
				{
					validGrabbers.Remove(grabber);
				}
			}

			private bool isGrabbable()
			{
				if (IsValidGrabbable())
				{
					return validGrabbers.Count > 0;
				}
				return false;
			}

			public bool IsValidGrabbable()
			{
				if (!base.isActiveAndEnabled)
				{
					return false;
				}
				if (BeingHeld && SecondaryGrabBehavior == OtherGrabBehavior.None)
				{
					return false;
				}
				if (OtherGrabbableMustBeGrabbed != null && !OtherGrabbableMustBeGrabbed.BeingHeld)
				{
					return false;
				}
				return true;
			}

			private void setupConfigJoint(Grabber g)
			{
				connectedJoint = g.GetComponent<ConfigurableJoint>();
				connectedJoint.autoConfigureConnectedAnchor = false;
				connectedJoint.connectedBody = rigid;
				_ = 1f / g.transform.localScale.x;
				connectedJoint.anchor = Vector3.zero;
				connectedJoint.connectedAnchor = _grabPositionOffset;
			}

			private void removeConfigJoint()
			{
				if (connectedJoint != null)
				{
					connectedJoint.anchor = Vector3.zero;
					connectedJoint.connectedBody = null;
				}
			}

			private void addGrabber(Grabber g)
			{
				if (heldByGrabbers == null)
				{
					heldByGrabbers = new List<Grabber>();
				}
				if (!heldByGrabbers.Contains(g))
				{
					heldByGrabbers.Add(g);
				}
			}

			private void removeGrabber(Grabber g)
			{
				if (heldByGrabbers == null)
				{
					heldByGrabbers = new List<Grabber>();
				}
				else if (heldByGrabbers.Contains(g))
				{
					heldByGrabbers.Remove(g);
				}
			}

			public virtual void GrabItem(Grabber grabbedBy)
			{
				ResetGrabbing();
				BeingHeld = true;
				grabTime = Time.time;
				addGrabber(grabbedBy);
				grabTransform.parent = grabbedBy.transform;
				_grabPositionOffset = GrabPositionOffset;
				if (MirrorOffsetForOtherHand && grabbedBy.HandSide == ControllerHand.Left)
				{
					float x = _grabPositionOffset.x * -1f;
					_grabPositionOffset = new Vector3(x, _grabPositionOffset.y, _grabPositionOffset.z);
				}
				grabbedBy.transform.localEulerAngles = GrabRotationOffset;
				if (HideHandGraphics)
				{
					grabbedBy.HideHandGraphics();
				}
				if (GrabMechanic == GrabType.Snap)
				{
					grabTransform.localEulerAngles = Vector3.zero;
					grabTransform.localPosition = Vector3.zero - _grabPositionOffset;
				}
				else if (GrabMechanic == GrabType.Precise)
				{
					grabTransform.position = base.transform.position;
					grabTransform.rotation = base.transform.rotation;
				}
				if (GrabPhysics == GrabPhysics.PhysicsJoint && GrabMechanic == GrabType.Precise)
				{
					connectedJoint = grabbedBy.GetComponent<ConfigurableJoint>();
					connectedJoint.connectedBody = rigid;
					connectedJoint.autoConfigureConnectedAnchor = true;
				}
				if (GrabPhysics == GrabPhysics.PhysicsJoint && GrabMechanic == GrabType.Snap)
				{
					base.transform.rotation = grabTransform.rotation;
					setupConfigJoint(grabbedBy);
				}
				if (GrabPhysics == GrabPhysics.Kinematic)
				{
					if (ParentToHands)
					{
						base.transform.parent = grabbedBy.transform;
					}
					if (rigid != null)
					{
						rigid.isKinematic = true;
					}
				}
				GrabbableEvents[] components = GetComponents<GrabbableEvents>();
				for (int i = 0; i < components.Length; i++)
				{
					components[i].OnGrab(grabbedBy);
				}
				journeyLength = Vector3.Distance(base.transform.position, grabbedBy.transform.position);
			}

			private void parentHandGraphics(Grabber g)
			{
				if (g.HandsGraphics != null)
				{
					g.HandsGraphics.transform.parent = base.transform;
					didParentHands = true;
				}
			}

			public virtual void GrabRemoteItem(Grabber grabbedBy)
			{
				flyingTo = grabbedBy;
				grabTransform.parent = grabbedBy.transform;
				grabTransform.localEulerAngles = Vector3.zero;
				grabTransform.localPosition = Vector3.zero - GrabPositionOffset;
				grabTransform.transform.localEulerAngles = GrabRotationOffset;
				if ((bool)rigid)
				{
					rigid.collisionDetectionMode = CollisionDetectionMode.Discrete;
					rigid.isKinematic = true;
				}
				remoteGrabbing = true;
			}

			public void ResetGrabbing()
			{
				if ((bool)rigid)
				{
					rigid.isKinematic = wasKinematic;
				}
				flyingTo = null;
				remoteGrabbing = false;
				collisions = new List<Collider>();
			}

			public virtual void DropItem(Grabber droppedBy, bool resetVelocity, bool resetParent)
			{
				if (heldByGrabbers == null)
				{
					BeingHeld = false;
					return;
				}
				if (resetParent)
				{
					ResetParent();
				}
				removeConfigJoint();
				if ((bool)droppedBy)
				{
					droppedBy.DidDrop();
				}
				if (rigid != null)
				{
					rigid.isKinematic = wasKinematic;
					rigid.useGravity = usedGravity;
					GameObject gameObject = GameObject.Find("TrackingSpace");
					Quaternion quaternion = Quaternion.identity;
					if ((bool)gameObject)
					{
						quaternion = gameObject.transform.rotation;
					}
					if (resetVelocity && (bool)droppedBy)
					{
						Vector3 velocity = quaternion * droppedBy.GetGrabberAveragedVelocity() + droppedBy.GetComponent<Rigidbody>().velocity;
						Vector3 angularVelocity = quaternion * droppedBy.GetGrabberAveragedAngularVelocity() + droppedBy.GetComponent<Rigidbody>().angularVelocity;
						StartCoroutine(Release(velocity, angularVelocity));
					}
				}
				if ((bool)events)
				{
					events.OnRelease();
				}
				removeGrabber(droppedBy);
				BeingHeld = false;
				didParentHands = false;
				LastDropTime = Time.time;
			}

			public virtual void DropItem(Grabber droppedBy)
			{
				DropItem(droppedBy, resetVelocity: true, resetParent: true);
			}

			public virtual void DropItem(bool resetVelocity, bool resetParent)
			{
				DropItem(GetPrimaryGrabber(), resetVelocity, resetParent);
			}

			public void ResetScale()
			{
				base.transform.localScale = new Vector3(OriginalScale, OriginalScale, OriginalScale);
			}

			public void ResetParent()
			{
				base.transform.parent = originalParent;
			}

			public ControllerHand GetControllerHand(Grabber g)
			{
				if (g != null)
				{
					return g.HandSide;
				}
				return ControllerHand.None;
			}

			public Grabber GetPrimaryGrabber()
			{
				if (heldByGrabbers != null)
				{
					return heldByGrabbers.FirstOrDefault();
				}
				return null;
			}

			public Grabber GetClosestGrabber()
			{
				Grabber result = null;
				float num = 9999f;
				if (validGrabbers != null)
				{
					foreach (Grabber validGrabber in validGrabbers)
					{
						if (validGrabber != null && Vector3.Distance(base.transform.position, validGrabber.transform.position) < num)
						{
							result = validGrabber;
						}
					}
				}
				return result;
			}

			private IEnumerator Release(Vector3 velocity, Vector3 angularVelocity)
			{
				yield return new WaitForFixedUpdate();
				rigid.velocity = velocity * ThrowForceMultiplier;
				rigid.angularVelocity = angularVelocity * -1f;
			}

			public virtual bool IsValidCollision(Collision collision)
			{
				if (collision.transform.name.Contains("Projectile") || collision.transform.name.Contains("Bullet") || collision.transform.name.Contains("Clip"))
				{
					return false;
				}
				CharacterController component = collision.gameObject.GetComponent<CharacterController>();
				if ((bool)component)
				{
					Physics.IgnoreCollision(col, component, ignore: true);
					return false;
				}
				return true;
			}

			private void filterCollisions()
			{
				foreach (Collider collision in collisions)
				{
					if (collision == null || !collision.enabled)
					{
						collisions.Remove(collision);
						break;
					}
				}
			}

			private int getCollisionCount()
			{
				if (collisions == null)
				{
					return 0;
				}
				int num = 0;
				foreach (Collider collision in collisions)
				{
					if (collision != null && collision.enabled)
					{
						num++;
					}
				}
				return collisions.Count;
			}

			private void OnCollisionEnter(Collision collision)
			{
				if (BeingHeld && IsValidCollision(collision) && !collisions.Contains(collision.collider))
				{
					collisions.Add(collision.collider);
				}
			}

			private void OnCollisionExit(Collision collision)
			{
				if (BeingHeld && IsValidCollision(collision) && collisions.Contains(collision.collider))
				{
					collisions.Remove(collision.collider);
				}
			}

			private void OnDrawGizmosSelected()
			{
				Gizmos.color = Color.green;
				Gizmos.DrawSphere(base.transform.TransformPoint(GrabPositionOffset), 0.025f);
			}

			private void OnDestroy()
			{
			}
		}
		[RequireComponent(typeof(Grabbable))]
		public abstract class GrabbableEvents : MonoBehaviour
		{
			protected Grabbable grab;

			protected Grabber thisGrabber;

			protected InputBridge input;

			private void Awake()
			{
				grab = GetComponent<Grabbable>();
				if ((bool)GameObject.FindGameObjectWithTag("Player"))
				{
					input = GameObject.FindGameObjectWithTag("Player").GetComponent<InputBridge>();
				}
			}

			public virtual void OnGrab(Grabber grabber)
			{
				thisGrabber = grabber;
			}

			public virtual void OnRelease()
			{
			}

			public virtual void OnBecomesClosestGrabbable(ControllerHand touchingHand)
			{
			}

			public virtual void OnNoLongerClosestGrabbable(ControllerHand touchingHand)
			{
			}

			public virtual void OnBecomesClosestRemoteGrabbable(ControllerHand touchingHand)
			{
			}

			public virtual void OnNoLongerClosestRemoteGrabbable(ControllerHand touchingHand)
			{
			}

			public virtual void OnGrip(float gripValue)
			{
			}

			public virtual void OnTrigger(float triggerValue)
			{
			}

			public virtual void OnTriggerDown()
			{
			}

			public virtual void OnTriggerUp()
			{
			}

			public virtual void OnButton1()
			{
			}

			public virtual void OnButton1Down()
			{
			}

			public virtual void OnButton1Up()
			{
			}

			public virtual void OnButton2()
			{
			}

			public virtual void OnButton2Down()
			{
			}

			public virtual void OnButton2Up()
			{
			}
		}
		public class GrabbablesInTrigger : MonoBehaviour
		{
			public Dictionary<Collider, Grabbable> NearbyGrabbables;

			public Dictionary<Collider, Grabbable> ValidGrabbables;

			public Grabbable ClosestGrabbable;

			public Dictionary<Collider, Grabbable> ValidRemoteGrabbables;

			public Grabbable ClosestRemoteGrabbable;

			public bool FireGrabbableEvents = true;

			private Grabbable _closest;

			private float _lastDistance;

			private float _thisDistance;

			private Dictionary<Collider, Grabbable> _valids;

			private Dictionary<Collider, Grabbable> _filtered;

			private void Start()
			{
				NearbyGrabbables = new Dictionary<Collider, Grabbable>();
				ValidGrabbables = new Dictionary<Collider, Grabbable>();
				ValidRemoteGrabbables = new Dictionary<Collider, Grabbable>();
			}

			private void Update()
			{
				updateClosestGrabbable();
				updateClosestRemoteGrabbables();
			}

			private void updateClosestGrabbable()
			{
				NearbyGrabbables = sanitizeGrabbables(NearbyGrabbables);
				ValidGrabbables = getValidGrabbables(NearbyGrabbables);
				ClosestGrabbable = GetClosestGrabbable(ValidGrabbables);
			}

			private void updateClosestRemoteGrabbables()
			{
				ClosestRemoteGrabbable = GetClosestGrabbable(ValidRemoteGrabbables, remoteOnly: true);
				if (ClosestGrabbable != null)
				{
					ClosestRemoteGrabbable = null;
				}
			}

			public Grabbable GetClosestGrabbable(Dictionary<Collider, Grabbable> grabbables, bool remoteOnly = false)
			{
				_closest = null;
				_lastDistance = 9999f;
				foreach (KeyValuePair<Collider, Grabbable> grabbable in grabbables)
				{
					if (!(grabbable.Value == null) && grabbable.Value.IsValidGrabbable())
					{
						_thisDistance = Vector3.Distance(grabbable.Value.transform.position, base.transform.position);
						if (_thisDistance < _lastDistance && grabbable.Value.isActiveAndEnabled && _thisDistance < grabbable.Value.RemoteGrabDistance && (!remoteOnly || grabbable.Value.RemoteGrabbable))
						{
							_lastDistance = _thisDistance;
							_closest = grabbable.Value;
						}
					}
				}
				return _closest;
			}

			private Dictionary<Collider, Grabbable> getValidGrabbables(Dictionary<Collider, Grabbable> grabs)
			{
				_valids = new Dictionary<Collider, Grabbable>();
				if (grabs == null)
				{
					return _valids;
				}
				foreach (KeyValuePair<Collider, Grabbable> grab in grabs)
				{
					if (isValidGrabbale(grab.Key, grab.Value) && !_valids.ContainsKey(grab.Key))
					{
						_valids.Add(grab.Key, grab.Value);
					}
				}
				return _valids;
			}

			private bool isValidGrabbale(Collider col, Grabbable grab)
			{
				if (col == null || grab == null || !grab.isActiveAndEnabled || !col.enabled)
				{
					return false;
				}
				if (!grab.IsValidGrabbable())
				{
					return false;
				}
				if (grab.GetComponent<SnapZone>() != null && grab.GetComponent<SnapZone>().HeldItem == null)
				{
					return false;
				}
				if (grab == ClosestGrabbable && Vector3.Distance(grab.transform.position, base.transform.position) > grab.BreakDistance)
				{
					return false;
				}
				return true;
			}

			private Dictionary<Collider, Grabbable> sanitizeGrabbables(Dictionary<Collider, Grabbable> grabs)
			{
				_filtered = new Dictionary<Collider, Grabbable>();
				if (grabs == null)
				{
					return _filtered;
				}
				foreach (KeyValuePair<Collider, Grabbable> grab in grabs)
				{
					if (grab.Key != null && grab.Key.enabled && grab.Value.isActiveAndEnabled && !(Vector3.Distance(grab.Key.transform.position, base.transform.position) > grab.Value.BreakDistance))
					{
						_filtered.Add(grab.Key, grab.Value);
					}
				}
				return _filtered;
			}

			public void AddNearbyGrabbable(Collider col, Grabbable grabObject)
			{
				if (grabObject != null && !NearbyGrabbables.ContainsKey(col))
				{
					NearbyGrabbables.Add(col, grabObject);
				}
			}

			public void RemoveNearbyGrabbable(Collider col, Grabbable grabObject)
			{
				if (grabObject != null && NearbyGrabbables.ContainsKey(col))
				{
					NearbyGrabbables.Remove(col);
				}
			}

			public void RemoveNearbyGrabbable(Grabbable grabObject)
			{
				if (!(grabObject != null))
				{
					return;
				}
				foreach (KeyValuePair<Collider, Grabbable> nearbyGrabbable in NearbyGrabbables)
				{
					if (nearbyGrabbable.Value == grabObject)
					{
						NearbyGrabbables.Remove(nearbyGrabbable.Key);
						break;
					}
				}
			}

			public void AddValidRemoteGrabbable(Collider col, Grabbable grabObject)
			{
				if (grabObject != null && grabObject.RemoteGrabbable && !ValidRemoteGrabbables.ContainsKey(col))
				{
					ValidRemoteGrabbables.Add(col, grabObject);
				}
			}

			public void RemoveValidRemoteGrabbable(Collider col, Grabbable grabObject)
			{
				if (grabObject != null && ValidRemoteGrabbables != null && ValidRemoteGrabbables.ContainsKey(col))
				{
					ValidRemoteGrabbables.Remove(col);
				}
			}

			private void OnTriggerEnter(Collider other)
			{
				Grabbable component = other.GetComponent<Grabbable>();
				if (component != null)
				{
					AddNearbyGrabbable(other, component);
				}
			}

			private void OnTriggerExit(Collider other)
			{
				Grabbable component = other.GetComponent<Grabbable>();
				if (component != null)
				{
					RemoveNearbyGrabbable(other, component);
				}
			}
		}
		public class Grabber : MonoBehaviour
		{
			public ControllerHand HandSide;

			public float GripAmount = 0.9f;

			public float ReleaseGripAmount = 0.1f;

			public Grabbable HeldGrabbable;

			private Grabbable previousClosest;

			private Grabbable previousClosestRemote;

			private GrabbablesInTrigger grabsInTrigger;

			private Grabbable flyingGrabbable;

			private float flyingTime;

			public Transform HandsGraphics;

			private Transform handsGraphicsParent;

			private Vector3 handsGraphicsPosition;

			private Quaternion handsGraphicsRotation;

			public Grabbable EquipGrabbableOnStart;

			public bool ForceGrab;

			public bool ForceRelease;

			public Vector3 PreviousPosition;

			public Transform DummyTransform;

			private float averageVelocityCount = 3f;

			private List<Vector3> previousVelocities;

			private List<Vector3> previousAngularVelocities;

			private Rigidbody rb;

			private InputBridge input;

			private bool freshGrab = true;

			public bool HoldingItem => HeldGrabbable != null;

			public bool RemoteGrabbingItem => flyingGrabbable != null;

			private void Start()
			{
				rb = GetComponent<Rigidbody>();
				grabsInTrigger = GetComponent<GrabbablesInTrigger>();
				if ((bool)GameObject.FindGameObjectWithTag("Player"))
				{
					input = GameObject.FindGameObjectWithTag("Player").GetComponent<InputBridge>();
				}
				if ((bool)HandsGraphics)
				{
					handsGraphicsParent = HandsGraphics.transform.parent;
					handsGraphicsPosition = HandsGraphics.transform.localPosition;
					handsGraphicsRotation = HandsGraphics.transform.localRotation;
				}
				previousVelocities = new List<Vector3>();
				previousAngularVelocities = new List<Vector3>();
				if ((bool)rb && rb.isKinematic)
				{
					rb.collisionDetectionMode = CollisionDetectionMode.ContinuousSpeculative;
				}
				if (EquipGrabbableOnStart != null)
				{
					GrabGrabbable(EquipGrabbableOnStart);
				}
			}

			private void Update()
			{
				if (flyingGrabbable != null)
				{
					flyingTime += Time.deltaTime;
					float num = 5f;
					if (flyingTime > num)
					{
						resetFlyingGrabbable();
					}
				}
				checkGrabbableEvents();
				if (getGrabInput(GrabButton.Grip) <= ReleaseGripAmount)
				{
					freshGrab = true;
				}
				if ((inputCheckGrab() && !HoldingItem) || ForceGrab)
				{
					tryGrab();
				}
				else if ((HoldingItem && inputCheckRelease()) || ForceRelease)
				{
					tryRelease();
				}
			}

			private void checkGrabbableEvents()
			{
				if (previousClosest != grabsInTrigger.ClosestGrabbable)
				{
					if (previousClosest != null)
					{
						GrabbableEvents[] components = previousClosest.GetComponents<GrabbableEvents>();
						if (components != null)
						{
							for (int i = 0; i < components.Length; i++)
							{
								components[i].OnNoLongerClosestGrabbable(HandSide);
							}
						}
						previousClosest.RemoveValidGrabber(this);
					}
					if (grabsInTrigger.ClosestGrabbable != null && !HoldingItem)
					{
						GrabbableEvents[] components2 = grabsInTrigger.ClosestGrabbable.GetComponents<GrabbableEvents>();
						if (components2 != null)
						{
							for (int j = 0; j < components2.Length; j++)
							{
								components2[j].OnBecomesClosestGrabbable(HandSide);
							}
						}
						grabsInTrigger.ClosestGrabbable.AddValidGrabber(this);
					}
				}
				if (grabsInTrigger.ClosestGrabbable != null && !HoldingItem)
				{
					grabsInTrigger.ClosestGrabbable.AddValidGrabber(this);
				}
				if (previousClosestRemote != grabsInTrigger.ClosestRemoteGrabbable)
				{
					if (previousClosestRemote != null)
					{
						GrabbableEvents[] components3 = previousClosestRemote.GetComponents<GrabbableEvents>();
						if (components3 != null)
						{
							for (int k = 0; k < components3.Length; k++)
							{
								components3[k].OnNoLongerClosestRemoteGrabbable(HandSide);
							}
						}
						previousClosestRemote.RemoveValidGrabber(this);
					}
					if (grabsInTrigger.ClosestRemoteGrabbable != null && !HoldingItem)
					{
						GrabbableEvents[] components4 = grabsInTrigger.ClosestRemoteGrabbable.GetComponents<GrabbableEvents>();
						if (components4 != null)
						{
							for (int l = 0; l < components4.Length; l++)
							{
								components4[l].OnBecomesClosestRemoteGrabbable(HandSide);
							}
						}
						grabsInTrigger.ClosestRemoteGrabbable.AddValidGrabber(this);
					}
				}
				previousClosest = grabsInTrigger.ClosestGrabbable;
				previousClosestRemote = grabsInTrigger.ClosestRemoteGrabbable;
			}

			private void FixedUpdate()
			{
				updateVelocities();
			}

			private void updateVelocities()
			{
				previousVelocities.Add(GetGrabberVelocity());
				if ((float)previousVelocities.Count >= averageVelocityCount)
				{
					previousVelocities.RemoveAt(0);
				}
				previousAngularVelocities.Add(GetGrabberAngularVelocity());
				if ((float)previousAngularVelocities.Count >= averageVelocityCount)
				{
					previousAngularVelocities.RemoveAt(0);
				}
			}

			private bool inputCheckGrab()
			{
				if (HeldGrabbable != null)
				{
					return false;
				}
				Grabbable closestOrRemote = getClosestOrRemote();
				if (closestOrRemote == null)
				{
					return false;
				}
				if (closestOrRemote.Grabtype == HoldType.HoldDown)
				{
					if (getGrabInput(closestOrRemote.GrabButton) >= GripAmount)
					{
						return freshGrab;
					}
					return false;
				}
				if (closestOrRemote.Grabtype == HoldType.Toggle)
				{
					return getToggleInput(closestOrRemote.GrabButton);
				}
				return false;
			}

			private GrabButton getGrabButton()
			{
				if (grabsInTrigger.ClosestGrabbable != null)
				{
					return grabsInTrigger.ClosestGrabbable.GrabButton;
				}
				if (grabsInTrigger.ClosestRemoteGrabbable != null)
				{
					return grabsInTrigger.ClosestRemoteGrabbable.GrabButton;
				}
				return GrabButton.Grip;
			}

			private Grabbable getClosestOrRemote()
			{
				if (grabsInTrigger.ClosestGrabbable != null)
				{
					return grabsInTrigger.ClosestGrabbable;
				}
				if (grabsInTrigger.ClosestRemoteGrabbable != null)
				{
					return grabsInTrigger.ClosestRemoteGrabbable;
				}
				return null;
			}

			private bool inputCheckRelease()
			{
				if (HeldGrabbable == null)
				{
					return false;
				}
				if (HeldGrabbable.Grabtype == HoldType.HoldDown)
				{
					return getGrabInput(HeldGrabbable.GrabButton) <= ReleaseGripAmount;
				}
				if (HeldGrabbable.Grabtype == HoldType.Toggle)
				{
					return getToggleInput(HeldGrabbable.GrabButton);
				}
				return false;
			}

			private float getGrabInput(GrabButton btn)
			{
				float result = 0f;
				if (input == null)
				{
					return 0f;
				}
				if (HandSide == ControllerHand.Left)
				{
					switch (btn)
					{
					case GrabButton.Grip:
						result = input.LeftGrip;
						break;
					case GrabButton.Trigger:
						result = input.LeftTrigger;
						break;
					}
				}
				else if (HandSide == ControllerHand.Right)
				{
					switch (btn)
					{
					case GrabButton.Grip:
						result = input.RightGrip;
						break;
					case GrabButton.Trigger:
						result = input.RightTrigger;
						break;
					}
				}
				return result;
			}

			private bool getToggleInput(GrabButton btn)
			{
				if (input == null)
				{
					return false;
				}
				if (HandSide == ControllerHand.Left)
				{
					switch (btn)
					{
					case GrabButton.Grip:
						return input.LeftGripDown;
					case GrabButton.Trigger:
						return input.LeftTriggerDown;
					}
				}
				else if (HandSide == ControllerHand.Right)
				{
					switch (btn)
					{
					case GrabButton.Grip:
						return input.RightGripDown;
					case GrabButton.Trigger:
						return input.RightTriggerDown;
					}
				}
				return false;
			}

			private bool tryGrab()
			{
				if (HeldGrabbable != null)
				{
					return false;
				}
				if (grabsInTrigger.ClosestGrabbable != null)
				{
					GrabGrabbable(grabsInTrigger.ClosestGrabbable);
					return true;
				}
				if (grabsInTrigger.ClosestRemoteGrabbable != null && flyingGrabbable == null)
				{
					flyingGrabbable = grabsInTrigger.ClosestRemoteGrabbable;
					flyingGrabbable.GrabRemoteItem(this);
				}
				return false;
			}

			public void GrabGrabbable(Grabbable item)
			{
				if (!(flyingGrabbable != null) || !(item != flyingGrabbable))
				{
					resetFlyingGrabbable();
					if (HeldGrabbable != null)
					{
						tryRelease();
					}
					HeldGrabbable = item;
					freshGrab = false;
					item.GrabItem(this);
				}
			}

			public void HideHandGraphics()
			{
				if (HandsGraphics != null)
				{
					HandsGraphics.gameObject.SetActive(value: false);
				}
			}

			public void DidDrop()
			{
				HeldGrabbable = null;
				base.transform.localEulerAngles = Vector3.zero;
				resetFlyingGrabbable();
				ResetHandGraphics();
			}

			public void ResetHandGraphics()
			{
				if (HandsGraphics != null)
				{
					HandsGraphics.gameObject.SetActive(value: true);
					HandsGraphics.transform.parent = handsGraphicsParent;
					HandsGraphics.transform.localPosition = handsGraphicsPosition;
					HandsGraphics.transform.localRotation = handsGraphicsRotation;
				}
			}

			private void tryRelease()
			{
				if (HeldGrabbable != null && HeldGrabbable.CanBeDropped)
				{
					HeldGrabbable.DropItem(this);
				}
				resetFlyingGrabbable();
			}

			private void resetFlyingGrabbable()
			{
				if (flyingGrabbable != null)
				{
					flyingGrabbable.ResetGrabbing();
					flyingGrabbable = null;
					flyingTime = 0f;
				}
			}

			public Vector3 GetGrabberVelocity()
			{
				if (HandSide == ControllerHand.Left)
				{
					return OVRInput.GetLocalControllerVelocity(OVRInput.Controller.LTouch);
				}
				if (HandSide == ControllerHand.Right)
				{
					return OVRInput.GetLocalControllerVelocity(OVRInput.Controller.RTouch);
				}
				return Vector3.zero;
			}

			public Vector3 GetGrabberAveragedVelocity()
			{
				return GetAveragedVector(previousVelocities);
			}

			public Vector3 GetGrabberAveragedAngularVelocity()
			{
				return GetAveragedVector(previousAngularVelocities);
			}

			private Vector3 GetAveragedVector(List<Vector3> vectors)
			{
				if (vectors != null)
				{
					int count = vectors.Count;
					float num = 0f;
					float num2 = 0f;
					float num3 = 0f;
					foreach (Vector3 vector in vectors)
					{
						num += vector.x;
						num2 += vector.y;
						num3 += vector.z;
					}
					return new Vector3(num / (float)count, num2 / (float)count, num3 / (float)count);
				}
				return Vector3.zero;
			}

			public Vector3 GetGrabberAngularVelocity()
			{
				if (HandSide == ControllerHand.Left)
				{
					return OVRInput.GetLocalControllerAngularVelocity(OVRInput.Controller.LTouch);
				}
				if (HandSide == ControllerHand.Right)
				{
					return OVRInput.GetLocalControllerAngularVelocity(OVRInput.Controller.RTouch);
				}
				return Vector3.zero;
			}
		}
		public enum ControllerHand
		{
			Left,
			Right,
			None
		}
		public enum HandControl
		{
			LeftGrip,
			RightGrip,
			LeftTrigger,
			RightTrigger,
			None
		}
		public enum GrabButton
		{
			Grip,
			Trigger
		}
		public class InputBridge : MonoBehaviour
		{
			public float LeftGrip;

			public bool LeftGripDown;

			public float RightGrip;

			public bool RightGripDown;

			public float LeftTrigger;

			public bool LeftTriggerNear;

			public bool LeftTriggerDown;

			public float RightTrigger;

			public bool RightTriggerDown;

			public bool RightTriggerNear;

			public bool LeftThumbNear;

			public bool RightThumbNear;

			public bool LeftThumbstickDown;

			public bool RightThumbstickDown;

			public bool AButton;

			public bool AButtonDown;

			public bool BButton;

			public bool BButtonDown;

			public bool XButton;

			public bool XButtonDown;

			public bool YButton;

			public bool YButtonDown;

			public bool StartButton;

			public bool StartButtonDown;

			public bool BackButton;

			public bool BackButtonDown;

			public Vector2 LeftThumbstickAxis;

			public Vector2 RightThumbstickAxis;

			private void Update()
			{
				LeftGrip = OVRInput.Get(OVRInput.Axis1D.PrimaryHandTrigger, OVRInput.Controller.LTouch);
				LeftGripDown = OVRInput.GetDown(OVRInput.Button.PrimaryHandTrigger, OVRInput.Controller.LTouch);
				RightGrip = OVRInput.Get(OVRInput.Axis1D.PrimaryHandTrigger, OVRInput.Controller.RTouch);
				RightGripDown = OVRInput.GetDown(OVRInput.Button.PrimaryHandTrigger, OVRInput.Controller.RTouch);
				LeftTrigger = OVRInput.Get(OVRInput.Axis1D.PrimaryIndexTrigger, OVRInput.Controller.LTouch);
				LeftTriggerDown = OVRInput.GetDown(OVRInput.Button.PrimaryIndexTrigger);
				LeftTriggerNear = OVRInput.Get(OVRInput.NearTouch.PrimaryIndexTrigger, OVRInput.Controller.LTouch);
				LeftThumbNear = OVRInput.Get(OVRInput.NearTouch.PrimaryThumbButtons, OVRInput.Controller.LTouch);
				RightThumbNear = OVRInput.Get(OVRInput.NearTouch.PrimaryThumbButtons, OVRInput.Controller.RTouch);
				RightTrigger = OVRInput.Get(OVRInput.Axis1D.PrimaryIndexTrigger, OVRInput.Controller.RTouch);
				RightTriggerDown = OVRInput.GetDown(OVRInput.Button.SecondaryIndexTrigger);
				RightTriggerNear = OVRInput.Get(OVRInput.NearTouch.PrimaryIndexTrigger, OVRInput.Controller.RTouch);
				AButton = OVRInput.Get(OVRInput.Button.One, OVRInput.Controller.RTouch);
				AButtonDown = OVRInput.GetDown(OVRInput.Button.One, OVRInput.Controller.RTouch);
				BButton = OVRInput.Get(OVRInput.Button.Two);
				BButtonDown = OVRInput.GetDown(OVRInput.Button.Two);
				XButton = OVRInput.Get(OVRInput.Button.Three);
				XButtonDown = OVRInput.GetDown(OVRInput.Button.Three);
				YButton = OVRInput.Get(OVRInput.Button.Four);
				YButtonDown = OVRInput.GetDown(OVRInput.Button.Four);
				StartButton = OVRInput.Get(OVRInput.Button.Start);
				StartButtonDown = OVRInput.GetDown(OVRInput.Button.Start);
				BackButton = OVRInput.Get(OVRInput.Button.Back);
				BackButtonDown = OVRInput.GetDown(OVRInput.Button.Back);
				LeftThumbstickAxis = OVRInput.Get(OVRInput.Axis2D.PrimaryThumbstick);
				RightThumbstickAxis = OVRInput.Get(OVRInput.Axis2D.SecondaryThumbstick);
				LeftThumbstickDown = OVRInput.GetDown(OVRInput.Button.PrimaryThumbstick);
				RightThumbstickDown = OVRInput.GetDown(OVRInput.Button.SecondaryThumbstick);
			}

			public void VibrateController(float frequency, float amplitude, float duration, ControllerHand hand)
			{
				StartCoroutine(Vibrate(frequency, amplitude, duration, hand));
			}

			private IEnumerator Vibrate(float frequency, float amplitude, float duration, ControllerHand hand)
			{
				switch (hand)
				{
				case ControllerHand.Right:
					OVRInput.SetControllerVibration(frequency, amplitude, OVRInput.Controller.RTouch);
					break;
				case ControllerHand.Left:
					OVRInput.SetControllerVibration(frequency, amplitude, OVRInput.Controller.LTouch);
					break;
				}
				yield return new WaitForSeconds(duration);
				switch (hand)
				{
				case ControllerHand.Right:
					OVRInput.SetControllerVibration(0f, 0f, OVRInput.Controller.RTouch);
					break;
				case ControllerHand.Left:
					OVRInput.SetControllerVibration(0f, 0f, OVRInput.Controller.LTouch);
					break;
				}
			}
		}
		public class JoystickControl : MonoBehaviour
		{
			public float MinDegrees = -45f;

			public float MaxDegrees = 45f;

			public float LeverPercentageX;

			public float LeverPercentageZ;

			public FloatFloatEvent onJoystickChange;

			private Vector3 currentRotation;

			private float angleX;

			private float angleZ;

			private void Update()
			{
				currentRotation = base.transform.localEulerAngles;
				angleX = Mathf.Floor(currentRotation.x);
				angleX = ((angleX > 180f) ? (angleX - 360f) : angleX);
				angleZ = Mathf.Floor(currentRotation.z);
				angleZ = ((angleZ > 180f) ? (angleZ - 360f) : angleZ);
				if (angleX > MaxDegrees)
				{
					base.transform.localEulerAngles = new Vector3(MaxDegrees, currentRotation.y, currentRotation.z);
				}
				else if (angleX < MinDegrees)
				{
					base.transform.localEulerAngles = new Vector3(MinDegrees, currentRotation.y, currentRotation.z);
				}
				if (angleZ > MaxDegrees)
				{
					base.transform.localEulerAngles = new Vector3(base.transform.localEulerAngles.x, currentRotation.y, MaxDegrees);
				}
				else if (angleZ < MinDegrees)
				{
					base.transform.localEulerAngles = new Vector3(base.transform.localEulerAngles.x, currentRotation.y, MinDegrees);
				}
				LeverPercentageX = (angleX - MinDegrees) / (MaxDegrees - MinDegrees) * 100f;
				LeverPercentageZ = (angleZ - MinDegrees) / (MaxDegrees - MinDegrees) * 100f;
				OnJoystickChange(LeverPercentageX, LeverPercentageZ);
			}

			public virtual void OnJoystickChange(float leverX, float leverY)
			{
				if (onJoystickChange != null)
				{
					onJoystickChange.Invoke(leverX, leverY);
				}
			}
		}
		public class Lever : MonoBehaviour
		{
			public AudioClip SwitchOnSound;

			public AudioClip SwitchOffSound;

			public float MinDegrees = -45f;

			public float MaxDegrees = 45f;

			public float SwitchTolerance = 1.25f;

			public float LeverPercentage;

			public UnityEvent onLeverDown;

			public UnityEvent onLeverUp;

			public FloatEvent onLeverChange;

			private Grabbable grab;

			private HingeJoint hinge;

			private AudioSource audioSource;

			private bool switchedOn;

			public Vector3 lookDirection;

			public Vector3 LookOffset = new Vector3(90f, 0f, 0f);

			public float DebugVal;

			private void Start()
			{
				grab = GetComponent<Grabbable>();
				hinge = GetComponent<HingeJoint>();
				if (hinge != null)
				{
					JointLimits limits = hinge.limits;
					limits.min = MinDegrees;
					limits.max = MaxDegrees;
					hinge.limits = limits;
				}
				audioSource = GetComponent<AudioSource>();
				if (audioSource == null && (SwitchOnSound != null || SwitchOffSound != null))
				{
					audioSource = base.gameObject.AddComponent<AudioSource>();
				}
			}

			private void Update()
			{
				Vector3 localEulerAngles = base.transform.localEulerAngles;
				float num = Mathf.Floor(localEulerAngles.x);
				num = ((num > 180f) ? (num - 360f) : num);
				if (num > MaxDegrees)
				{
					base.transform.localEulerAngles = new Vector3(MaxDegrees, localEulerAngles.y, localEulerAngles.z);
				}
				else if (num < MinDegrees)
				{
					base.transform.localEulerAngles = new Vector3(MinDegrees, localEulerAngles.y, localEulerAngles.z);
				}
				LeverPercentage = (num - MinDegrees) / (MaxDegrees - MinDegrees) * 100f;
				OnLeverChange(LeverPercentage);
				if (LeverPercentage > 99f && !switchedOn)
				{
					OnLeverUp();
				}
				else if (LeverPercentage < 1f && switchedOn)
				{
					OnLeverDown();
				}
			}

			private void doLeverLook()
			{
				if (grab != null && grab.BeingHeld)
				{
					base.transform.LookAt(grab.GetPrimaryGrabber().transform, lookDirection);
					base.transform.localEulerAngles += LookOffset;
					DebugVal = base.transform.localEulerAngles.x;
				}
			}

			public virtual void OnLeverChange(float percentage)
			{
				if (onLeverChange != null)
				{
					onLeverChange.Invoke(percentage);
				}
			}

			public virtual void OnLeverDown()
			{
				if (SwitchOffSound != null)
				{
					audioSource.clip = SwitchOffSound;
					audioSource.Play();
				}
				if (onLeverDown != null)
				{
					onLeverDown.Invoke();
				}
				switchedOn = false;
			}

			public virtual void OnLeverUp()
			{
				if (SwitchOnSound != null)
				{
					audioSource.clip = SwitchOnSound;
					audioSource.Play();
				}
				if (onLeverUp != null)
				{
					onLeverUp.Invoke();
				}
				switchedOn = true;
			}
		}
		[Serializable]
		public class FloatEvent : UnityEvent<float>
		{
		}
		[Serializable]
		public class FloatFloatEvent : UnityEvent<float, float>
		{
		}
		[Serializable]
		public class GrabberEvent : UnityEvent<Grabber>
		{
		}
		[Serializable]
		public class GrabbableEvent : UnityEvent<Grabbable>
		{
		}
		public enum TeleportControls
		{
			Thumbstick,
			BButton
		}
		public class PlayerTeleport : MonoBehaviour
		{
			public Color ValidTeleport = Color.green;

			public Color InvalidTeleport = Color.red;

			public Grabber LeftHandGrabber;

			public Grabber RightHandGrabber;

			public Transform TeleportBeginTransform;

			public Transform TeleportDestination;

			public GameObject TeleportMarker;

			public Transform DirectionIndicator;

			public float MaxRange = 20f;

			public int SegmentCount = 100;

			public float simulationVelocity = 500f;

			public float segmentScale = 0.5f;

			public LayerMask CollisionLayers;

			public LayerMask ValidLayers;

			public TeleportControls ControlType;

			public bool AllowTeleportRotation = true;

			private bool _reachThumbThreshold;

			public float MaxSlope = 60f;

			private CharacterController controller;

			private InputBridge input;

			private bool aimingTeleport;

			private bool validTeleport;

			private bool teleportationEnabled = true;

			public LineRenderer TeleportLine;

			private Collider _hitObject;

			private Vector3 _hitVector;

			private float _hitAngle;

			private void Start()
			{
				input = GetComponent<InputBridge>();
				controller = GetComponentInChildren<CharacterController>();
				if (TeleportLine != null)
				{
					TeleportLine.transform.parent = null;
				}
				if ((int)CollisionLayers == 0)
				{
					UnityEngine.Debug.Log("Teleport layer not set. Setting Default.");
					CollisionLayers = 1;
				}
			}

			private void Update()
			{
				aimingTeleport = keyDownForTeleport();
				if (aimingTeleport)
				{
					updateTeleport();
				}
				else if (keyUpFromTeleport())
				{
					if (validTeleport)
					{
						tryTeleport();
					}
					else
					{
						hideTeleport();
					}
				}
			}

			private void FixedUpdate()
			{
				if (aimingTeleport)
				{
					calculateParabola();
				}
			}

			public void EnableTeleportation()
			{
				teleportationEnabled = true;
			}

			public void DisableTeleportation()
			{
				teleportationEnabled = false;
				validTeleport = false;
				aimingTeleport = false;
				hideTeleport();
			}

			private void calculateParabola()
			{
				validTeleport = false;
				bool flag = false;
				Vector3[] array = new Vector3[SegmentCount];
				array[0] = TeleportBeginTransform.position;
				Vector3 vector = TeleportBeginTransform.forward * simulationVelocity * Time.deltaTime;
				_hitObject = null;
				for (int i = 1; i < SegmentCount; i++)
				{
					if (_hitObject != null)
					{
						array[i] = _hitVector;
						continue;
					}
					float num = ((vector.sqrMagnitude != 0f) ? (segmentScale / vector.magnitude) : 0f);
					vector += Physics.gravity * num;
					if (Physics.Raycast(array[i - 1], vector, out var hitInfo, segmentScale, CollisionLayers))
					{
						_hitObject = hitInfo.collider;
						array[i] = array[i - 1] + vector.normalized * hitInfo.distance;
						vector -= Physics.gravity * (segmentScale - hitInfo.distance) / vector.magnitude;
						vector = Vector3.Reflect(vector, hitInfo.normal);
						_hitAngle = Vector3.Angle(base.transform.up, hitInfo.normal);
						TeleportMarker.transform.position = array[i];
						TeleportMarker.transform.rotation = Quaternion.FromToRotation(TeleportMarker.transform.up, hitInfo.normal) * TeleportMarker.transform.rotation;
						TeleportDestination component = _hitObject.GetComponent<TeleportDestination>();
						if (component != null)
						{
							flag = true;
							TeleportMarker.transform.position = component.transform.position;
							TeleportMarker.transform.rotation = component.transform.rotation;
						}
						_hitVector = array[i];
					}
					else
					{
						array[i] = array[i - 1] + vector * num;
					}
				}
				validTeleport = _hitObject != null;
				if (validTeleport && !flag)
				{
					if (_hitAngle > MaxSlope)
					{
						validTeleport = false;
					}
					if (_hitObject.GetComponent<Grabbable>() != null)
					{
						validTeleport = false;
					}
					if (_hitObject.GetComponent<InvalidTeleportArea>() != null)
					{
						validTeleport = false;
					}
					if (!teleportClear())
					{
						validTeleport = false;
					}
				}
				TeleportLine.positionCount = SegmentCount;
				for (int j = 0; j < SegmentCount; j++)
				{
					TeleportLine.SetPosition(j, array[j]);
				}
			}

			private bool teleportClear()
			{
				if (Physics.OverlapSphere(TeleportDestination.position, controller.radius, CollisionLayers, QueryTriggerInteraction.Ignore).Length != 0)
				{
					return false;
				}
				if (Physics.Raycast(TeleportMarker.transform.position, TeleportMarker.transform.up, out var _, controller.height, CollisionLayers, QueryTriggerInteraction.Ignore))
				{
					return false;
				}
				return (int)ValidLayers == ((int)ValidLayers | (1 << _hitObject.gameObject.layer));
			}

			private void hideTeleport()
			{
				TeleportLine.enabled = false;
				if (TeleportMarker.activeSelf)
				{
					TeleportMarker.SetActive(value: false);
				}
			}

			private void updateTeleport()
			{
				if (validTeleport)
				{
					TeleportLine.enabled = true;
					rotateMarker();
				}
				TeleportMarker.SetActive(validTeleport);
				Color startColor = (validTeleport ? ValidTeleport : InvalidTeleport);
				Color endColor = (validTeleport ? ValidTeleport : InvalidTeleport);
				startColor.a = 1f;
				endColor.a = 0f;
				TeleportLine.startColor = startColor;
				TeleportLine.endColor = endColor;
			}

			private void rotateMarker()
			{
				if (AllowTeleportRotation)
				{
					if (DirectionIndicator != null && !DirectionIndicator.gameObject.activeSelf)
					{
						DirectionIndicator.gameObject.SetActive(value: true);
					}
					Vector3 direction = new Vector3(input.LeftThumbstickAxis.x, 0f, input.LeftThumbstickAxis.y);
					direction = controller.transform.TransformDirection(direction);
					Vector3 forward = TeleportMarker.transform.forward;
					float angle = Vector2.SignedAngle(new Vector2(direction.x, direction.z), new Vector2(forward.x, forward.z));
					TeleportMarker.transform.Rotate(Vector3.up, angle, Space.Self);
				}
				else if (DirectionIndicator != null && DirectionIndicator.gameObject.activeSelf)
				{
					DirectionIndicator.gameObject.SetActive(value: false);
				}
			}

			private IEnumerator doTeleport()
			{
				OVRPlayerController o = GetComponentInChildren<OVRPlayerController>();
				o.enabled = false;
				controller.enabled = false;
				Vector3 position = TeleportDestination.position;
				bool flag = false;
				TeleportDestination component = _hitObject.GetComponent<TeleportDestination>();
				if (component != null)
				{
					position = component.DestinationTransform.position;
					flag = component.ForcePlayerRotation;
					if (flag)
					{
						controller.transform.rotation = component.DestinationTransform.rotation;
					}
				}
				controller.transform.position = position;
				if (AllowTeleportRotation && !flag)
				{
					controller.transform.rotation = Quaternion.identity;
					controller.transform.localEulerAngles = new Vector3(controller.transform.localEulerAngles.x, TeleportMarker.transform.localEulerAngles.y, controller.transform.localEulerAngles.z);
					controller.transform.rotation = TeleportMarker.transform.rotation;
					controller.transform.eulerAngles = new Vector3(0f, controller.transform.eulerAngles.y, 0f);
				}
				yield return new WaitForEndOfFrame();
				o.enabled = true;
				controller.enabled = true;
			}

			private void tryTeleport()
			{
				if (validTeleport)
				{
					UnityEngine.Debug.Log("Teleport to" + TeleportDestination.position.ToString());
					StartCoroutine(doTeleport());
				}
				validTeleport = false;
				aimingTeleport = false;
				hideTeleport();
			}

			private bool keyDownForTeleport()
			{
				if (!teleportationEnabled)
				{
					return false;
				}
				if (ControlType == TeleportControls.Thumbstick)
				{
					if ((double)Math.Abs(input.LeftThumbstickAxis.x) >= 0.75 || (double)Math.Abs(input.LeftThumbstickAxis.y) >= 0.75)
					{
						_reachThumbThreshold = true;
						return true;
					}
					if (_reachThumbThreshold && ((double)Math.Abs(input.LeftThumbstickAxis.x) > 0.25 || (double)Math.Abs(input.LeftThumbstickAxis.y) > 0.25))
					{
						return true;
					}
				}
				else if (ControlType == TeleportControls.BButton)
				{
					return input.BButton;
				}
				return false;
			}

			private bool keyUpFromTeleport()
			{
				if (ControlType == TeleportControls.Thumbstick)
				{
					if ((double)Math.Abs(input.LeftThumbstickAxis.x) <= 0.25 && (double)Math.Abs(input.LeftThumbstickAxis.y) <= 0.25)
					{
						_reachThumbThreshold = false;
						return true;
					}
					return false;
				}
				if (ControlType == TeleportControls.BButton)
				{
					return !input.BButton;
				}
				return true;
			}

			public bool IsAiming()
			{
				return aimingTeleport;
			}

			private void OnDrawGizmosSelected()
			{
				if (controller != null && TeleportDestination.gameObject.activeSelf)
				{
					Color red = Color.red;
					red.a = 0.9f;
					Gizmos.color = red;
					Gizmos.DrawSphere(TeleportDestination.position, controller.radius);
				}
			}
		}
		public class RemoteGrabber : MonoBehaviour
		{
			public GrabbablesInTrigger ParentGrabber;

			private void OnTriggerEnter(Collider other)
			{
				if (!(ParentGrabber == null) && other.gameObject.layer != 2)
				{
					Grabbable component = other.GetComponent<Grabbable>();
					if (component != null && ParentGrabber != null)
					{
						ParentGrabber.AddValidRemoteGrabbable(other, component);
					}
				}
			}

			private void OnTriggerExit(Collider other)
			{
				Grabbable component = other.GetComponent<Grabbable>();
				if (component != null && ParentGrabber != null)
				{
					ParentGrabber.RemoveValidRemoteGrabbable(other, component);
				}
			}
		}
		public class Slider : MonoBehaviour
		{
			private float _slidePercentage;

			public FloatEvent onSliderChange;

			private float lastSliderPercentage;

			private float slideRangeLow = -0.15f;

			private float slideRangeHigh = 0.15f;

			private float slideRange;

			public float SlidePercentage => _slidePercentage;

			private void Start()
			{
				ConfigurableJoint component = GetComponent<ConfigurableJoint>();
				if ((bool)component)
				{
					slideRangeLow = component.linearLimit.limit * -1f;
					slideRangeHigh = component.linearLimit.limit;
				}
				slideRange = slideRangeHigh - slideRangeLow;
			}

			private void Update()
			{
				_slidePercentage = (base.transform.localPosition.x - 0.001f + slideRangeHigh) / slideRange;
				_slidePercentage = Mathf.Ceil(_slidePercentage * 100f);
				if (_slidePercentage != lastSliderPercentage)
				{
					OnSliderChange(_slidePercentage);
				}
				lastSliderPercentage = _slidePercentage;
			}

			public virtual void OnSliderChange(float percentage)
			{
				if (onSliderChange != null)
				{
					onSliderChange.Invoke(percentage);
				}
			}
		}
		public class SnapZone : MonoBehaviour
		{
			public bool CanDropItem = true;

			public bool CanSwapItem = true;

			public float ScaleItem = 1f;

			public bool DisableColliders = true;

			private List<Collider> disabledColliders;

			public float MaxDropTime = 0.1f;

			public List<string> OnlyAllowNames;

			public List<string> ExcludeTransformNames;

			public AudioClip SoundOnSnap;

			public AudioClip SoundOnUnsnap;

			public GrabbableEvent OnSnapEvent;

			public GrabbableEvent OnDetachEvent;

			private GrabbablesInTrigger gZone;

			public Grabbable HeldItem;

			private Grabbable trackedItem;

			public Grabbable ClosestGrabbable;

			private void Start()
			{
				gZone = GetComponent<GrabbablesInTrigger>();
				if (HeldItem != null)
				{
					GrabGrabbable(HeldItem);
				}
			}

			private void Update()
			{
				ClosestGrabbable = getClosestGrabbable();
				if (HeldItem == null && ClosestGrabbable != null && Time.time - ClosestGrabbable.LastDropTime < MaxDropTime)
				{
					GrabGrabbable(ClosestGrabbable);
				}
				if (HeldItem != null)
				{
					if (HeldItem.BeingHeld || HeldItem.transform.parent != base.transform)
					{
						ReleaseAll();
					}
					else
					{
						if (ScaleItem != 1f)
						{
							float num = HeldItem.OriginalScale * ScaleItem;
							HeldItem.transform.localScale = Vector3.Lerp(HeldItem.transform.localScale, new Vector3(num, num, num), Time.deltaTime * 30f);
						}
						if (HeldItem.enabled || (disabledColliders[0] != null && disabledColliders[0].enabled))
						{
							disableGrabbable(HeldItem);
						}
						HeldItem.transform.localPosition = Vector3.zero;
						HeldItem.transform.localEulerAngles = Vector3.zero;
					}
				}
				if (!CanDropItem && trackedItem != null && HeldItem == null && !trackedItem.BeingHeld)
				{
					GrabGrabbable(trackedItem);
				}
			}

			private Grabbable getClosestGrabbable()
			{
				Grabbable result = null;
				float num = 9999f;
				foreach (KeyValuePair<Collider, Grabbable> nearbyGrabbable in gZone.NearbyGrabbables)
				{
					float num2 = Vector3.Distance(base.transform.position, nearbyGrabbable.Value.transform.position);
					if (!(num2 < num) || nearbyGrabbable.Value.OtherGrabbableMustBeGrabbed != null || nearbyGrabbable.Value.GetComponent<SnapZone>() != null)
					{
						continue;
					}
					if (OnlyAllowNames != null && OnlyAllowNames.Count > 0)
					{
						string text = nearbyGrabbable.Value.transform.name;
						bool flag = false;
						foreach (string onlyAllowName in OnlyAllowNames)
						{
							if (text.Contains(onlyAllowName))
							{
								flag = true;
							}
						}
						if (!flag)
						{
							continue;
						}
					}
					if (ExcludeTransformNames != null)
					{
						string text2 = nearbyGrabbable.Value.transform.name;
						foreach (string excludeTransformName in ExcludeTransformNames)
						{
							text2.Contains(excludeTransformName);
						}
					}
					if (nearbyGrabbable.Value.BeingHeld || Time.time - nearbyGrabbable.Value.LastDropTime < MaxDropTime)
					{
						result = nearbyGrabbable.Value;
						num = num2;
					}
				}
				return result;
			}

			public void GrabGrabbable(Grabbable grab)
			{
				if (!(grab.transform.parent != null) || !(grab.transform.parent.GetComponent<SnapZone>() != null))
				{
					if (HeldItem != null)
					{
						ReleaseAll();
					}
					HeldItem = grab;
					disableGrabbable(grab);
					grab.transform.parent = base.transform;
					if (OnSnapEvent != null)
					{
						OnSnapEvent.Invoke(grab);
					}
					if ((bool)SoundOnSnap)
					{
						VRUtils.Instance.PlaySpatialClipAt(SoundOnSnap, base.transform.position, 0.75f);
					}
				}
			}

			private void disableGrabbable(Grabbable grab)
			{
				if (DisableColliders)
				{
					disabledColliders = grab.GetComponentsInChildren<Collider>(includeInactive: false).ToList();
					foreach (Collider disabledCollider in disabledColliders)
					{
						disabledCollider.enabled = false;
					}
				}
				grab.enabled = false;
			}

			public void GrabEquipped(Grabber grabber)
			{
				if (grabber != null && (bool)HeldItem)
				{
					Grabbable heldItem = HeldItem;
					ReleaseAll();
					if (Vector3.Distance(heldItem.transform.position, grabber.transform.position) > 0.2f)
					{
						heldItem.transform.position = grabber.transform.position;
					}
					grabber.GrabGrabbable(heldItem);
				}
			}

			public void ReleaseAll()
			{
				if (HeldItem == null)
				{
					return;
				}
				if (!CanDropItem && HeldItem != null)
				{
					trackedItem = HeldItem;
				}
				HeldItem.ResetScale();
				if (DisableColliders && disabledColliders != null)
				{
					foreach (Collider disabledCollider in disabledColliders)
					{
						if ((bool)disabledCollider)
						{
							disabledCollider.enabled = true;
						}
					}
				}
				disabledColliders = null;
				HeldItem.enabled = true;
				HeldItem.transform.parent = null;
				if (HeldItem != null)
				{
					if ((bool)SoundOnSnap)
					{
						VRUtils.Instance.PlaySpatialClipAt(SoundOnUnsnap, base.transform.position, 0.75f);
					}
					if (OnDetachEvent != null)
					{
						OnDetachEvent.Invoke(HeldItem);
					}
				}
				HeldItem = null;
			}
		}
		public class SnapZoneEvents : MonoBehaviour
		{
			private void Start()
			{
			}

			private void Update()
			{
			}
		}
		public class Arrow : MonoBehaviour
		{
			private Rigidbody rb;

			private Grabbable grab;

			public bool Flying;

			public float ZVel;

			public Collider ShaftCollider;

			private AudioSource impactSound;

			private float flightTime;

			private float destroyTime = 10f;

			private Coroutine queueDestroy;

			public Projectile ProjectileObject;

			private void Start()
			{
				rb = GetComponent<Rigidbody>();
				impactSound = GetComponent<AudioSource>();
				ShaftCollider = GetComponent<Collider>();
				grab = GetComponent<Grabbable>();
				if (ProjectileObject == null)
				{
					ProjectileObject = base.gameObject.AddComponent<Projectile>();
					ProjectileObject.Damage = 50f;
					ProjectileObject.StickToObject = true;
					ProjectileObject.enabled = false;
				}
			}

			private void FixedUpdate()
			{
				if ((!(grab != null) || !grab.BeingHeld) && rb != null && rb.velocity != Vector3.zero && Flying && (double)ZVel > 0.02)
				{
					rb.rotation = Quaternion.LookRotation(rb.velocity);
				}
				ZVel = base.transform.InverseTransformDirection(rb.velocity).z;
				if (Flying)
				{
					flightTime += Time.fixedDeltaTime;
				}
				if (queueDestroy != null && grab != null && grab.BeingHeld)
				{
					StopCoroutine(queueDestroy);
				}
			}

			public void ShootArrow(Vector3 shotForce)
			{
				flightTime = 0f;
				Flying = true;
				base.transform.parent = null;
				rb.isKinematic = false;
				rb.useGravity = true;
				rb.collisionDetectionMode = CollisionDetectionMode.Continuous;
				rb.constraints = RigidbodyConstraints.None;
				rb.AddForce(shotForce, ForceMode.VelocityChange);
				StartCoroutine(ReEnableCollider());
				queueDestroy = StartCoroutine(QueueDestroy());
			}

			private IEnumerator QueueDestroy()
			{
				yield return new WaitForSeconds(destroyTime);
				if (grab != null && !grab.BeingHeld && base.transform.parent == null)
				{
					UnityEngine.Object.Destroy(base.gameObject);
				}
			}

			private IEnumerator ReEnableCollider()
			{
				int waitFrames = 3;
				for (int x = 0; x < waitFrames; x++)
				{
					yield return new WaitForFixedUpdate();
				}
				ShaftCollider.enabled = true;
			}

			private void OnCollisionEnter(Collision collision)
			{
				if ((base.transform.parent != null && collision.transform == base.transform.parent) || (grab != null && grab.BeingHeld) || collision.collider.isTrigger)
				{
					return;
				}
				string text = collision.transform.name.ToLower();
				if (flightTime < 1f && (text.Contains("arrow") || text.Contains("bow")))
				{
					Physics.IgnoreCollision(collision.collider, ShaftCollider, ignore: true);
					return;
				}
				if (flightTime < 1f && collision.transform.name.ToLower().Contains("player"))
				{
					Physics.IgnoreCollision(collision.collider, ShaftCollider, ignore: true);
					return;
				}
				float num = Math.Abs(base.transform.InverseTransformDirection(rb.velocity).z);
				bool flag = true;
				if (num > 0.02f && !rb.isKinematic)
				{
					Damageable component = collision.gameObject.GetComponent<Damageable>();
					if ((bool)component)
					{
						component.DealDamage(20f);
					}
					if (component != null && component.Health <= 0f)
					{
						flag = false;
					}
				}
				if (!rb.isKinematic && Flying && num > 0.02f)
				{
					if (grab != null && grab.BeingHeld)
					{
						grab.DropItem(resetVelocity: false, resetParent: false);
					}
					if (flag)
					{
						tryStickArrow(collision);
					}
					Flying = false;
					playSoundInterval(2.462f, 2.68f);
				}
			}

			private void tryStickArrow(Collision collision)
			{
				Rigidbody component = collision.collider.GetComponent<Rigidbody>();
				base.transform.parent = null;
				if (collision.gameObject.isStatic)
				{
					rb.collisionDetectionMode = CollisionDetectionMode.Discrete;
					rb.isKinematic = true;
				}
				else if (component != null && !component.isKinematic)
				{
					FixedJoint fixedJoint = base.gameObject.AddComponent<FixedJoint>();
					fixedJoint.connectedBody = component;
					fixedJoint.enableCollision = false;
					fixedJoint.breakForce = float.MaxValue;
					fixedJoint.breakTorque = float.MaxValue;
				}
				else if (collision.transform.localScale == Vector3.one)
				{
					base.transform.parent = collision.transform;
					rb.constraints = RigidbodyConstraints.FreezeAll;
				}
				else
				{
					rb.collisionDetectionMode = CollisionDetectionMode.Discrete;
					rb.isKinematic = true;
				}
			}

			private void playSoundInterval(float fromSeconds, float toSeconds)
			{
				if ((bool)impactSound)
				{
					if (impactSound.isPlaying)
					{
						impactSound.Stop();
					}
					impactSound.time = fromSeconds;
					impactSound.pitch = Time.timeScale;
					impactSound.Play();
					impactSound.SetScheduledEndTime(AudioSettings.dspTime + (double)(toSeconds - fromSeconds));
				}
			}
		}
		public class ArrowGrabArea : MonoBehaviour
		{
			private Bow theBow;

			private void Start()
			{
				theBow = base.transform.parent.GetComponent<Bow>();
			}

			private void OnTriggerEnter(Collider other)
			{
				Grabber component = other.GetComponent<Grabber>();
				if (!(component != null))
				{
					return;
				}
				theBow.ClosestGrabber = component;
				if (!component.HoldingItem)
				{
					theBow.CanGrabArrow = true;
				}
				else if (component.HoldingItem && component.HeldGrabbable != null)
				{
					Arrow component2 = component.HeldGrabbable.GetComponent<Arrow>();
					if (component2 != null && theBow.GrabbedArrow == null)
					{
						theBow.GrabArrow(component2);
					}
				}
			}

			private void OnTriggerExit(Collider other)
			{
				Grabber component = other.GetComponent<Grabber>();
				if (theBow.ClosestGrabber != null && component != null && theBow.ClosestGrabber == component)
				{
					theBow.CanGrabArrow = false;
					theBow.ClosestGrabber = null;
				}
			}
		}
		public class Bow : MonoBehaviour
		{
			public float BowForce = 50f;

			public bool CanGrabArrowFromKnock = true;

			public Transform ArrowRest;

			public Transform ArrowKnock;

			private InputBridge input;

			public bool CanGrabArrow;

			public Grabber ClosestGrabber;

			public Arrow GrabbedArrow;

			private Grabbable arrowGrabbable;

			public Grabber arrowGrabber;

			public Vector3 LastValidPosition;

			public float MaxStringDistance = 0.3f;

			public float StringDistance;

			private float _lastDrawPercent;

			private float _lastDrawHaptic;

			private float _lastDrawHapticTime;

			private bool playedDrawSound;

			private Vector3 initialKnockPosition;

			private bool holdingArrow;

			private Grabbable bowGrabbable;

			public Text PercentageUI;

			private List<DrawDefinition> drawDefs;

			private AudioSource audioSource;

			public float DrawPercent { get; private set; }

			private void Start()
			{
				input = GameObject.FindGameObjectWithTag("Player").GetComponent<InputBridge>();
				initialKnockPosition = ArrowKnock.localPosition;
				bowGrabbable = GetComponent<Grabbable>();
				audioSource = GetComponent<AudioSource>();
				drawDefs = new List<DrawDefinition>
				{
					new DrawDefinition
					{
						DrawPercentage = 30f,
						HapticAmplitude = 0.1f,
						HapticFrequency = 0.1f
					},
					new DrawDefinition
					{
						DrawPercentage = 40f,
						HapticAmplitude = 0.1f,
						HapticFrequency = 0.1f
					},
					new DrawDefinition
					{
						DrawPercentage = 50f,
						HapticAmplitude = 0.1f,
						HapticFrequency = 0.1f
					},
					new DrawDefinition
					{
						DrawPercentage = 60f,
						HapticAmplitude = 0.1f,
						HapticFrequency = 0.1f
					},
					new DrawDefinition
					{
						DrawPercentage = 70f,
						HapticAmplitude = 0.1f,
						HapticFrequency = 0.1f
					},
					new DrawDefinition
					{
						DrawPercentage = 80f,
						HapticAmplitude = 0.1f,
						HapticFrequency = 0.1f
					},
					new DrawDefinition
					{
						DrawPercentage = 90f,
						HapticAmplitude = 0.1f,
						HapticFrequency = 0.9f
					},
					new DrawDefinition
					{
						DrawPercentage = 100f,
						HapticAmplitude = 0.1f,
						HapticFrequency = 1f
					}
				};
			}

			private void Update()
			{
				updateDrawDistance();
				checkBowHaptics();
				if (!bowGrabbable.BeingHeld)
				{
					if (holdingArrow)
					{
						ReleaseArrow();
					}
					resetStringPosition();
					return;
				}
				holdingArrow = GrabbedArrow != null;
				if (canGrabArrowFromKnock())
				{
					GameObject gameObject = UnityEngine.Object.Instantiate(Resources.Load("Arrow", typeof(GameObject))) as GameObject;
					gameObject.transform.position = ArrowKnock.transform.position;
					gameObject.transform.LookAt(ArrowRest);
					gameObject.GetComponent<Grabbable>().GrabButton = GrabButton.Trigger;
					GrabArrow(gameObject.GetComponent<Arrow>());
				}
				if (GrabbedArrow == null)
				{
					resetStringPosition();
				}
				if (arrowGrabber != null)
				{
					StringDistance = Vector3.Distance(base.transform.position, arrowGrabber.transform.position);
				}
				else
				{
					StringDistance = 0f;
				}
				if (holdingArrow)
				{
					setKnockPosition();
					alignArrow();
					checkDrawSound();
					checkBowHaptics();
					if (getGrabArrowInput() <= 0.2f)
					{
						ReleaseArrow();
					}
				}
			}

			private bool canGrabArrowFromKnock()
			{
				if (!CanGrabArrowFromKnock)
				{
					return false;
				}
				ControllerHand handSide = ((bowGrabbable.GetControllerHand(bowGrabbable.GetPrimaryGrabber()) == ControllerHand.Left) ? ControllerHand.Right : ControllerHand.Left);
				if (CanGrabArrow && getTriggerInput(handSide) > 0.75f)
				{
					return !holdingArrow;
				}
				return false;
			}

			private float getGrabArrowInput()
			{
				if (arrowGrabber != null && arrowGrabbable != null)
				{
					if (arrowGrabbable.GrabButton == GrabButton.Grip)
					{
						return getGripInput(arrowGrabber.HandSide);
					}
					if (arrowGrabbable.GrabButton == GrabButton.Trigger)
					{
						return getTriggerInput(arrowGrabber.HandSide);
					}
				}
				return 0f;
			}

			private float getGripInput(ControllerHand handSide)
			{
				return handSide switch
				{
					ControllerHand.Left => input.LeftGrip, 
					ControllerHand.Right => input.RightGrip, 
					_ => 0f, 
				};
			}

			private float getTriggerInput(ControllerHand handSide)
			{
				return handSide switch
				{
					ControllerHand.Left => input.LeftTrigger, 
					ControllerHand.Right => input.RightTrigger, 
					_ => 0f, 
				};
			}

			private void setKnockPosition()
			{
				if (StringDistance <= MaxStringDistance)
				{
					ArrowKnock.position = arrowGrabber.transform.position;
					return;
				}
				ArrowKnock.localPosition = initialKnockPosition;
				ArrowKnock.LookAt(arrowGrabber.transform, ArrowKnock.forward);
				ArrowKnock.position += ArrowKnock.forward * (MaxStringDistance * 0.65f);
			}

			private void checkDrawSound()
			{
				if (holdingArrow && !playedDrawSound && DrawPercent > 30f)
				{
					playBowDraw();
					playedDrawSound = true;
				}
			}

			private void updateDrawDistance()
			{
				_lastDrawPercent = DrawPercent;
				float num = Math.Abs(Vector3.Distance(ArrowKnock.localPosition, initialKnockPosition));
				DrawPercent = num / MaxStringDistance * 100f;
				if (PercentageUI != null)
				{
					PercentageUI.text = (int)DrawPercent + "%";
				}
			}

			private void checkBowHaptics()
			{
				if (!(DrawPercent < _lastDrawPercent) && !((double)(Time.time - _lastDrawHapticTime) < 0.11))
				{
					DrawDefinition drawDefinition = drawDefs.FirstOrDefault((DrawDefinition x) => x.DrawPercentage <= DrawPercent && x.DrawPercentage != _lastDrawHaptic);
					if (drawDefinition != null && arrowGrabber != null)
					{
						input.VibrateController(drawDefinition.HapticFrequency, drawDefinition.HapticAmplitude, 0.1f, arrowGrabber.HandSide);
						_lastDrawHaptic = drawDefinition.DrawPercentage;
						_lastDrawHapticTime = Time.time;
					}
				}
			}

			private void resetStringPosition()
			{
				ArrowKnock.localPosition = Vector3.Lerp(ArrowKnock.localPosition, initialKnockPosition, Time.deltaTime * 100f);
			}

			private void alignArrow()
			{
				GrabbedArrow.transform.parent = base.transform;
				GrabbedArrow.GetComponent<Rigidbody>().collisionDetectionMode = CollisionDetectionMode.Discrete;
				GrabbedArrow.GetComponent<Rigidbody>().isKinematic = true;
				GrabbedArrow.transform.position = ArrowKnock.transform.position;
				GrabbedArrow.transform.LookAt(ArrowRest);
			}

			public void GrabArrow(Arrow arrow)
			{
				arrowGrabber = ClosestGrabber;
				GrabbedArrow = arrow.GetComponent<Arrow>();
				GrabbedArrow.ShaftCollider.enabled = false;
				arrowGrabbable = arrow.GetComponent<Grabbable>();
				if ((bool)arrowGrabbable)
				{
					arrowGrabbable.GrabItem(arrowGrabber);
				}
				Collider componentInChildren = GameObject.FindGameObjectWithTag("Player").GetComponentInChildren<Collider>();
				if ((bool)componentInChildren)
				{
					Physics.IgnoreCollision(GrabbedArrow.ShaftCollider, componentInChildren);
				}
				holdingArrow = true;
			}

			public void ReleaseArrow()
			{
				playBowRelease();
				if ((bool)arrowGrabbable)
				{
					arrowGrabbable.GrabButton = GrabButton.Grip;
					arrowGrabbable.DropItem(resetVelocity: false, resetParent: true);
				}
				float num = BowForce * StringDistance;
				GrabbedArrow.ShootArrow(GrabbedArrow.transform.forward * num);
				resetArrowValues();
			}

			private void resetArrowValues()
			{
				GrabbedArrow = null;
				arrowGrabbable = null;
				arrowGrabber = null;
				holdingArrow = false;
				playedDrawSound = false;
			}

			private void playSoundInterval(float fromSeconds, float toSeconds, float volume)
			{
				if ((bool)audioSource)
				{
					if (audioSource.isPlaying)
					{
						audioSource.Stop();
					}
					audioSource.pitch = Time.timeScale;
					audioSource.time = fromSeconds;
					audioSource.volume = volume;
					audioSource.Play();
					audioSource.SetScheduledEndTime(AudioSettings.dspTime + (double)(toSeconds - fromSeconds));
				}
			}

			private void playBowDraw()
			{
				playSoundInterval(0f, 1.66f, 0.4f);
			}

			private void playBowRelease()
			{
				playSoundInterval(1.67f, 2.2f, 0.3f);
			}
		}
		public class DrawDefinition
		{
			public float DrawPercentage { get; set; }

			public float HapticAmplitude { get; set; }

			public float HapticFrequency { get; set; }
		}
		public class BowArm : MonoBehaviour
		{
			public Bow BowItem;

			public float BowPercentStart = 50f;

			public float RotateDegrees = 10f;

			public float Speed = 50f;

			private Quaternion _startRotation;

			private Quaternion _endRotation;

			private void Start()
			{
				_startRotation = Quaternion.Euler(base.transform.localEulerAngles);
				_endRotation = Quaternion.Euler(new Vector3(_startRotation.x + RotateDegrees, base.transform.localEulerAngles.y, base.transform.localEulerAngles.z));
			}

			private void Update()
			{
				if (BowItem.DrawPercent >= BowPercentStart)
				{
					base.transform.localRotation = Quaternion.RotateTowards(base.transform.localRotation, _endRotation, Speed * Time.deltaTime);
				}
				else if (BowItem.DrawPercent < BowPercentStart && BowItem.DrawPercent > 5f)
				{
					base.transform.localRotation = Quaternion.RotateTowards(base.transform.localRotation, _startRotation, Speed * Time.deltaTime);
				}
				else
				{
					base.transform.localRotation = _startRotation;
				}
			}
		}
		public class BulletHole : MonoBehaviour
		{
			public Transform BulletHoleDecal;

			public float MaxScale = 1f;

			public float MinScale = 0.75f;

			public bool RandomYRotation = true;

			public float DestroyTime = 10f;

			private void Start()
			{
				base.transform.localScale = Vector3.one * UnityEngine.Random.Range(0.75f, 1.5f);
				if (BulletHoleDecal != null && RandomYRotation)
				{
					Vector3 localEulerAngles = BulletHoleDecal.transform.localEulerAngles;
					BulletHoleDecal.transform.localEulerAngles = new Vector3(localEulerAngles.x, localEulerAngles.y, UnityEngine.Random.Range(0f, 90f));
				}
				GetComponent<AudioSource>().pitch = Time.timeScale;
				Invoke("DestroySelf", DestroyTime);
			}

			public void TryAttachTo(Collider col)
			{
				if (transformIsEqualScale(col.transform))
				{
					BulletHoleDecal.parent = col.transform;
					UnityEngine.Object.Destroy(BulletHoleDecal.gameObject, DestroyTime);
				}
				else if (col.gameObject.isStatic)
				{
					UnityEngine.Object.Destroy(BulletHoleDecal.gameObject, DestroyTime);
				}
				else
				{
					UnityEngine.Object.Destroy(BulletHoleDecal.gameObject, 0.1f);
				}
			}

			private bool transformIsEqualScale(Transform theTransform)
			{
				if (theTransform.localScale.x == theTransform.localScale.y)
				{
					return theTransform.localScale.x == theTransform.localScale.z;
				}
				return false;
			}

			private void DestroySelf()
			{
				base.transform.parent = null;
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}
		public class FPSText : MonoBehaviour
		{
			private Text text;

			private float deltaTime;

			private void Start()
			{
				text = GetComponent<Text>();
			}

			private void Update()
			{
				deltaTime += (Time.unscaledDeltaTime - deltaTime) * 0.1f;
			}

			private void OnGUI()
			{
				text.text = Math.Ceiling(1f / deltaTime) + " FPS";
			}
		}
		public class Flashlight : GrabbableEvents
		{
			public Light SpotLight;

			public Transform LightSwitch;

			private Vector3 originalSwitchPosition;

			private void Start()
			{
				originalSwitchPosition = LightSwitch.transform.localPosition;
			}

			public override void OnTrigger(float triggerValue)
			{
				SpotLight.enabled = triggerValue > 0.2f;
				LightSwitch.localPosition = new Vector3(originalSwitchPosition.x * triggerValue, originalSwitchPosition.y, originalSwitchPosition.z);
				base.OnTrigger(triggerValue);
			}

			public override void OnTriggerUp()
			{
				SpotLight.enabled = false;
				LightSwitch.localPosition = originalSwitchPosition;
				base.OnTriggerUp();
			}
		}
		public class GrappleShot : GrabbableEvents
		{
			public float MaxRange = 100f;

			public float GrappleReelForce = 0.5f;

			public float MinReelDistance = 0.25f;

			public LayerMask GrappleLayers;

			public Transform MuzzleTransform;

			public Transform HitTargetPrefab;

			public LineRenderer GrappleLine;

			public LineRenderer HelperLine;

			public AudioClip GrappleShotSound;

			private bool grappling;

			private bool wasGrappling;

			private bool gravityEnabled = true;

			private float initialGravityModifier;

			private OVRPlayerController pControl;

			private CharacterController characterController;

			private BNGPlayerController bngController;

			private AudioSource audioSource;

			public float currentGrappleDistance;

			private bool validTargetFound;

			private bool isDynamic;

			private Rigidbody grappleTargetRigid;

			private Transform grappleTargetParent;

			private bool requireRelease;

			private bool climbing;

			public Climbable ClimbHelper;

			private void Start()
			{
				pControl = GameObject.FindGameObjectWithTag("Player").GetComponentInChildren<OVRPlayerController>();
				characterController = GameObject.FindGameObjectWithTag("Player").GetComponentInChildren<CharacterController>();
				bngController = GameObject.FindGameObjectWithTag("Player").GetComponentInChildren<BNGPlayerController>();
				initialGravityModifier = pControl.GravityModifier;
				audioSource = GetComponent<AudioSource>();
			}

			private void LateUpdate()
			{
				if (!grappling && grab.BeingHeld && !requireRelease)
				{
					drawGrappleHelper();
				}
				else
				{
					hideGrappleHelper();
				}
				if (grappling && validTargetFound && grab.BeingHeld)
				{
					drawGrappleLine();
				}
				else
				{
					hideGrappleLine();
				}
			}

			public override void OnTrigger(float triggerValue)
			{
				updateGrappleDistance();
				if (triggerValue >= 0.25f)
				{
					if (grappling)
					{
						reelInGrapple(triggerValue);
					}
					else
					{
						shootGrapple();
					}
				}
				else
				{
					grappling = false;
					requireRelease = false;
				}
				if (!grappling && wasGrappling)
				{
					onReleaseGrapple();
				}
				base.OnTrigger(triggerValue);
			}

			private void updateGrappleDistance()
			{
				if (grappling)
				{
					currentGrappleDistance = Vector3.Distance(MuzzleTransform.position, HitTargetPrefab.position);
				}
				else
				{
					currentGrappleDistance = 0f;
				}
			}

			public override void OnGrab(Grabber grabber)
			{
				base.OnGrab(grabber);
			}

			public override void OnRelease()
			{
				onReleaseGrapple();
				base.OnRelease();
			}

			private void onReleaseGrapple()
			{
				changeGravity(gravityOn: true);
				if ((bool)grappleTargetRigid && isDynamic)
				{
					grappleTargetRigid.useGravity = true;
					grappleTargetRigid.isKinematic = false;
					grappleTargetRigid.transform.parent = grappleTargetParent;
					if ((bool)grappleTargetRigid.GetComponent<Grabbable>())
					{
						grappleTargetRigid.GetComponent<Grabbable>().ResetParent();
					}
				}
				ClimbHelper.transform.localPosition = Vector3.zero;
				bngController.RemoveClimber(thisGrabber);
				climbing = false;
				grappling = false;
				validTargetFound = false;
				isDynamic = false;
				wasGrappling = false;
			}

			private void drawGrappleHelper()
			{
				if (!HitTargetPrefab)
				{
					return;
				}
				if (Physics.Raycast(MuzzleTransform.position, MuzzleTransform.forward, out var hitInfo, MaxRange, GrappleLayers, QueryTriggerInteraction.Ignore))
				{
					if (hitInfo.transform.name.Contains("GrappleGun"))
					{
						hideGrappleHelper();
						validTargetFound = false;
						isDynamic = false;
						return;
					}
					showGrappleHelper(hitInfo.point, Quaternion.FromToRotation(Vector3.forward, hitInfo.normal));
					grappleTargetRigid = hitInfo.collider.GetComponent<Rigidbody>();
					isDynamic = grappleTargetRigid != null && !grappleTargetRigid.isKinematic && grappleTargetRigid.useGravity;
					if (hitInfo.collider.transform.localScale.x == hitInfo.collider.transform.localScale.y || isDynamic)
					{
						HitTargetPrefab.parent = null;
						HitTargetPrefab.localScale = Vector3.one;
						HitTargetPrefab.transform.parent = hitInfo.collider.transform;
					}
					else
					{
						HitTargetPrefab.parent = null;
						HitTargetPrefab.localScale = Vector3.one;
					}
					validTargetFound = true;
					if (isDynamic)
					{
						grappleTargetParent = grappleTargetRigid.transform.parent;
					}
					else
					{
						grappleTargetParent = null;
					}
				}
				else
				{
					hideGrappleHelper();
					validTargetFound = false;
					isDynamic = false;
				}
			}

			private void drawGrappleLine()
			{
				GrappleLine.gameObject.SetActive(value: true);
				GrappleLine.SetPosition(0, MuzzleTransform.position);
				GrappleLine.SetPosition(1, HitTargetPrefab.position);
			}

			private void hideGrappleLine()
			{
				if ((bool)GrappleLine && GrappleLine.gameObject.activeSelf)
				{
					GrappleLine.gameObject.SetActive(value: false);
				}
			}

			private void showGrappleHelper(Vector3 pos, Quaternion rot)
			{
				HitTargetPrefab.gameObject.SetActive(value: true);
				HitTargetPrefab.position = pos;
				HitTargetPrefab.rotation = rot;
				HitTargetPrefab.localScale = Vector3.one;
				if ((bool)HelperLine)
				{
					HelperLine.gameObject.SetActive(value: true);
					HelperLine.SetPosition(0, MuzzleTransform.position);
					HelperLine.SetPosition(1, pos);
				}
			}

			private void hideGrappleHelper()
			{
				if ((bool)HitTargetPrefab && HitTargetPrefab.gameObject.activeSelf)
				{
					HitTargetPrefab.gameObject.SetActive(value: false);
				}
				if ((bool)HelperLine && HelperLine.gameObject.activeSelf)
				{
					HelperLine.gameObject.SetActive(value: false);
				}
			}

			private void reelInGrapple(float triggerValue)
			{
				if (validTargetFound && currentGrappleDistance > MinReelDistance)
				{
					if (isDynamic)
					{
						grappleTargetRigid.isKinematic = false;
						grappleTargetRigid.transform.parent = grappleTargetParent;
						grappleTargetRigid.useGravity = false;
						grappleTargetRigid.AddForce((MuzzleTransform.position - grappleTargetRigid.transform.position) * 0.1f, ForceMode.VelocityChange);
					}
					else
					{
						Vector3 vector = (HitTargetPrefab.position - MuzzleTransform.position) * GrappleReelForce;
						changeGravity(gravityOn: false);
						characterController.Move(vector * Time.deltaTime * triggerValue);
					}
				}
				else if (validTargetFound && currentGrappleDistance <= MinReelDistance)
				{
					if (isDynamic)
					{
						grappleTargetRigid.velocity = Vector3.zero;
						grappleTargetRigid.isKinematic = true;
						grappleTargetRigid.transform.parent = base.transform;
					}
					if (!climbing && !isDynamic)
					{
						ClimbHelper.transform.localPosition = Vector3.zero;
						bngController.AddClimber(ClimbHelper, thisGrabber);
						climbing = true;
					}
				}
			}

			private void shootGrapple()
			{
				if (validTargetFound)
				{
					if ((bool)GrappleShotSound && (bool)audioSource)
					{
						audioSource.clip = GrappleShotSound;
						audioSource.pitch = Time.timeScale;
						audioSource.Play();
					}
					grappling = true;
					wasGrappling = true;
					requireRelease = true;
				}
			}

			private void changeGravity(bool gravityOn)
			{
				gravityEnabled = gravityOn;
				pControl.GravityModifier = (gravityEnabled ? initialGravityModifier : 0f);
				pControl.enabled = gravityOn;
			}
		}
		public class HandJet : GrabbableEvents
		{
			public float JetForce = 10f;

			public ParticleSystem JetFX;

			private OVRPlayerController pControl;

			private CharacterController characterController;

			private AudioSource audioSource;

			private bool GravityEnabled = true;

			private float _initialGravityModifier;

			private void Start()
			{
				pControl = GameObject.FindGameObjectWithTag("Player").GetComponentInChildren<OVRPlayerController>();
				characterController = GameObject.FindGameObjectWithTag("Player").GetComponentInChildren<CharacterController>();
				_initialGravityModifier = pControl.GravityModifier;
				audioSource = GetComponent<AudioSource>();
			}

			public override void OnTrigger(float triggerValue)
			{
				if (triggerValue > 0.25f)
				{
					doJet(triggerValue);
				}
				else
				{
					stopJet();
				}
				base.OnTrigger(triggerValue);
			}

			public override void OnButton2()
			{
				ChangeGravity(!GravityEnabled);
			}

			public override void OnGrab(Grabber grabber)
			{
				ChangeGravity(gravityOn: false);
			}

			public void ChangeGravity(bool gravityOn)
			{
				GravityEnabled = gravityOn;
				pControl.GravityModifier = (GravityEnabled ? _initialGravityModifier : 0f);
			}

			public override void OnRelease()
			{
				stopJet();
				ChangeGravity(gravityOn: true);
			}

			private void doJet(float triggerValue)
			{
				Vector3 vector = base.transform.forward * JetForce;
				characterController.Move(vector * Time.deltaTime * triggerValue);
				ChangeGravity(gravityOn: false);
				if (!audioSource.isPlaying)
				{
					audioSource.pitch = Time.timeScale;
					audioSource.Play();
				}
				if (JetFX != null && !JetFX.isPlaying)
				{
					JetFX.Play();
				}
				if ((bool)input && thisGrabber != null)
				{
					input.VibrateController(0.1f, 0.5f, 0.2f, thisGrabber.HandSide);
				}
			}

			private void stopJet()
			{
				if (audioSource.isPlaying)
				{
					audioSource.Stop();
				}
				if (JetFX != null && JetFX.isPlaying)
				{
					JetFX.Stop();
				}
			}

			public override void OnTriggerUp()
			{
				stopJet();
				base.OnTriggerUp();
			}
		}
		public class IKDummy : MonoBehaviour
		{
			public Transform PlayerTransform;

			public Transform HeadFollow;

			public Transform RightHandFollow;

			public Transform LeftHandFollow;

			public Vector3 HandRotationOffset = Vector3.zero;

			private Animator animator;

			private Transform headBone;

			private Transform leftHandDummy;

			private Transform rightHandDummy;

			private Transform lookatDummy;

			private void Start()
			{
				animator = GetComponent<Animator>();
				headBone = animator.GetBoneTransform(HumanBodyBones.Head);
				leftHandDummy = new GameObject().transform;
				rightHandDummy = new GameObject().transform;
				lookatDummy = new GameObject().transform;
			}

			private void Update()
			{
				base.transform.LookAt(Camera.main.transform);
				base.transform.localEulerAngles = new Vector3(0f, base.transform.localEulerAngles.y, 0f);
			}

			private void OnAnimatorIK()
			{
				animator.SetLookAtWeight(1f);
				lookatDummy.position = HeadFollow.position;
				lookatDummy.parent = PlayerTransform;
				Vector3 localPosition = lookatDummy.localPosition;
				lookatDummy.parent = base.transform;
				lookatDummy.localPosition = localPosition;
				animator.SetLookAtPosition(Camera.main.transform.position);
				animator.SetLookAtPosition(lookatDummy.position);
				leftHandDummy.position = LeftHandFollow.position;
				leftHandDummy.rotation = LeftHandFollow.rotation;
				leftHandDummy.parent = PlayerTransform;
				localPosition = leftHandDummy.localPosition;
				Quaternion localRotation = leftHandDummy.localRotation;
				leftHandDummy.parent = base.transform;
				leftHandDummy.localPosition = localPosition;
				leftHandDummy.localRotation = localRotation;
				leftHandDummy.localEulerAngles += HandRotationOffset;
				animator.SetIKPositionWeight(AvatarIKGoal.LeftHand, 1f);
				animator.SetIKRotationWeight(AvatarIKGoal.LeftHand, 1f);
				animator.SetIKPosition(AvatarIKGoal.LeftHand, leftHandDummy.position);
				animator.SetIKRotation(AvatarIKGoal.LeftHand, leftHandDummy.rotation);
				rightHandDummy.position = RightHandFollow.position;
				rightHandDummy.rotation = RightHandFollow.rotation;
				rightHandDummy.parent = PlayerTransform;
				localPosition = rightHandDummy.localPosition;
				localRotation = rightHandDummy.localRotation;
				rightHandDummy.parent = base.transform;
				rightHandDummy.localPosition = localPosition;
				rightHandDummy.localRotation = localRotation;
				rightHandDummy.localEulerAngles -= HandRotationOffset;
				animator.SetIKPositionWeight(AvatarIKGoal.RightHand, 1f);
				animator.SetIKRotationWeight(AvatarIKGoal.RightHand, 1f);
				animator.SetIKPosition(AvatarIKGoal.RightHand, rightHandDummy.position);
				animator.SetIKRotation(AvatarIKGoal.RightHand, rightHandDummy.rotation);
			}
		}
		public class LaserPointer : MonoBehaviour
		{
			public float MaxRange = 25f;

			public LayerMask ValidLayers;

			public Transform LaserEnd;

			public bool Active = true;

			private LineRenderer line;

			private void Start()
			{
				line = GetComponent<LineRenderer>();
			}

			private void LateUpdate()
			{
				if (Active)
				{
					line.enabled = true;
					if (Physics.Raycast(base.transform.position, base.transform.forward, out var hitInfo, MaxRange, ValidLayers, QueryTriggerInteraction.Ignore))
					{
						line.useWorldSpace = true;
						line.SetPosition(0, base.transform.position);
						line.SetPosition(1, hitInfo.point);
						LaserEnd.gameObject.SetActive(value: true);
						LaserEnd.position = hitInfo.point;
						LaserEnd.rotation = Quaternion.FromToRotation(Vector3.forward, hitInfo.normal);
					}
					else
					{
						line.useWorldSpace = false;
						line.SetPosition(0, base.transform.localPosition);
						line.SetPosition(1, new Vector3(0f, 0f, MaxRange));
						LaserEnd.gameObject.SetActive(value: false);
					}
				}
				else
				{
					LaserEnd.gameObject.SetActive(value: false);
					if ((bool)line)
					{
						line.enabled = false;
					}
				}
			}
		}
		public class LaserSword : GrabbableEvents
		{
			private Grabbable grabbable;

			public Transform BladeTransform;

			public Transform RaycastTransform;

			public LayerMask LaserCollision;

			public ParticleSystem CollisionParticle;

			public bool BladeEnabled;

			public float LaserLength = 1f;

			public float LaserActivateSpeed = 10f;

			public AudioSource CollisionAudio;

			public bool Colliding;

			private void Start()
			{
				grabbable = GetComponent<Grabbable>();
				if (CollisionParticle != null)
				{
					CollisionParticle.Stop();
				}
			}

			private void Update()
			{
				if (BladeEnabled)
				{
					BladeTransform.localScale = Vector3.Lerp(BladeTransform.localScale, Vector3.one, Time.deltaTime * LaserActivateSpeed);
				}
				else
				{
					BladeTransform.localScale = Vector3.Lerp(BladeTransform.localScale, new Vector3(1f, 0f, 1f), Time.deltaTime * LaserActivateSpeed);
				}
				BladeTransform.gameObject.SetActive((double)BladeTransform.localScale.y >= 0.01);
				checkCollision();
				if (Colliding)
				{
					CollisionAudio.pitch = 2f;
				}
				else
				{
					CollisionAudio.pitch = 1f;
				}
			}

			public override void OnTrigger(float triggerValue)
			{
				BladeEnabled = triggerValue > 0.2f;
				base.OnTrigger(triggerValue);
			}

			private void checkCollision()
			{
				Colliding = false;
				if (!BladeEnabled)
				{
					CollisionParticle.Pause();
					return;
				}
				Physics.Raycast(RaycastTransform.position, RaycastTransform.up, out var hitInfo, LaserLength, LaserCollision, QueryTriggerInteraction.Ignore);
				if (hitInfo.collider != null)
				{
					if (CollisionParticle != null)
					{
						float y = Vector3.Distance(hitInfo.point, RaycastTransform.transform.position) / LaserLength;
						BladeTransform.localScale = new Vector3(BladeTransform.localScale.x, y, BladeTransform.localScale.z);
						CollisionParticle.transform.parent.position = hitInfo.point;
						CollisionParticle.transform.parent.rotation = Quaternion.FromToRotation(Vector3.up, hitInfo.normal);
						if (!CollisionParticle.isPlaying)
						{
							CollisionParticle.Play();
						}
						input.VibrateController(0.2f, 0.1f, 0.1f, thisGrabber.HandSide);
						Colliding = true;
					}
				}
				else if (CollisionParticle != null)
				{
					CollisionParticle.Pause();
				}
			}

			private void OnDrawGizmosSelected()
			{
				if (RaycastTransform != null)
				{
					Gizmos.color = Color.blue;
					Gizmos.DrawLine(RaycastTransform.position, RaycastTransform.position + RaycastTransform.up * LaserLength);
				}
			}
		}
		public class PlayerScaler : MonoBehaviour
		{
			public List<Transform> ScaleObjects;

			public float Scale = 1f;

			public float scaleSpeed = 0.1f;

			private InputBridge input;

			private void Start()
			{
				input = GetComponent<InputBridge>();
			}

			private void Update()
			{
				if (input.RightThumbstickAxis.y < -0.5f || Input.GetKey(KeyCode.H))
				{
					Scale -= Time.deltaTime * 1f;
				}
				else if (input.RightThumbstickAxis.y > 0.5f || Input.GetKey(KeyCode.J))
				{
					Scale += Time.deltaTime * 1f;
				}
				Scale = Mathf.Clamp(Scale, 0.1f, 2f);
				foreach (Transform scaleObject in ScaleObjects)
				{
					scaleObject.localScale = new Vector3(Scale, Scale, Scale);
				}
			}
		}
		public class TimeController : MonoBehaviour
		{
			public float SlowTimeScale = 0.5f;

			public bool YKeySlowsTime = true;

			public AudioClip SlowTimeClip;

			public AudioClip SpeedupTimeClip;

			public bool SetFixedDelta;

			private bool _slowingTime;

			private bool routineRunning;

			private float originalFixedDelta;

			private AudioSource audioSource;

			private InputBridge input;

			public bool ForceTimeScale;

			private IEnumerator resumeRoutine;

			public bool TimeSlowing => _slowingTime;

			private void Start()
			{
				originalFixedDelta = Time.fixedDeltaTime;
				if (SetFixedDelta)
				{
					originalFixedDelta = Time.timeScale / XRDevice.refreshRate;
				}
				audioSource = GetComponent<AudioSource>();
				input = GameObject.FindGameObjectWithTag("Player").GetComponent<InputBridge>();
			}

			private void Update()
			{
				if (input.YButton || ForceTimeScale)
				{
					SlowTime();
				}
				else
				{
					ResumeTime();
				}
			}

			public void SlowTime()
			{
				if (!_slowingTime)
				{
					if (resumeRoutine != null)
					{
						StopCoroutine(resumeRoutine);
					}
					audioSource.clip = SlowTimeClip;
					audioSource.Play();
					input.VibrateController(0.1f, 0.2f, SpeedupTimeClip.length, ControllerHand.Left);
					Time.timeScale = SlowTimeScale;
					Time.fixedDeltaTime = originalFixedDelta * Time.timeScale;
					_slowingTime = true;
				}
			}

			public void ResumeTime()
			{
				if (_slowingTime && !audioSource.isPlaying && !routineRunning)
				{
					resumeRoutine = resumeTimeRoutine();
					StartCoroutine(resumeRoutine);
				}
			}

			private IEnumerator resumeTimeRoutine()
			{
				routineRunning = true;
				audioSource.clip = SpeedupTimeClip;
				audioSource.Play();
				input.VibrateController(0.1f, 0.2f, SpeedupTimeClip.length, ControllerHand.Left);
				yield return new WaitForSeconds(0.35f);
				Time.timeScale = 1f;
				Time.fixedDeltaTime = originalFixedDelta;
				_slowingTime = false;
				routineRunning = false;
			}
		}
		public class Zipline : GrabbableEvents
		{
			public Transform ZiplineStart;

			public Transform ZiplineEnd;

			public float ZiplineSpeed = 1f;

			public bool UseLinearMovement = true;

			private float lastMoveTime = -1f;

			private bool movingForward = true;

			private AudioSource audioSource;

			private void Start()
			{
				if (ZiplineEnd != null)
				{
					base.transform.LookAt(ZiplineEnd.position);
				}
				audioSource = GetComponent<AudioSource>();
			}

			private void Update()
			{
				if (Time.time - lastMoveTime < 0.1f)
				{
					if (movingForward)
					{
						audioSource.pitch = Time.timeScale * 1f;
					}
					else
					{
						audioSource.pitch = Time.timeScale * 0.95f;
					}
					if (!audioSource.isPlaying)
					{
						audioSource.Play();
					}
				}
				else if (audioSource.isPlaying)
				{
					audioSource.Stop();
				}
			}

			private void OnDrawGizmosSelected()
			{
				if (ZiplineStart != null && ZiplineEnd != null)
				{
					Gizmos.color = Color.green;
					Gizmos.DrawLine(ZiplineStart.position, ZiplineEnd.position);
				}
			}

			public override void OnTrigger(float triggerValue)
			{
				if (triggerValue > 0.5f)
				{
					moveTowards(ZiplineEnd.position, forwardDirection: true);
				}
				base.OnTrigger(triggerValue);
			}

			public override void OnButton1()
			{
				moveTowards(ZiplineStart.position, forwardDirection: false);
				base.OnButton1();
			}

			public override void OnButton2()
			{
				moveTowards(ZiplineEnd.position, forwardDirection: true);
				base.OnButton2();
			}

			private void moveTowards(Vector3 pos, bool forwardDirection)
			{
				lastMoveTime = Time.time;
				movingForward = forwardDirection;
				if (forwardDirection)
				{
					base.transform.LookAt(pos);
				}
				else
				{
					base.transform.LookAt(2f * base.transform.position - pos);
				}
				if (UseLinearMovement)
				{
					base.transform.position = Vector3.MoveTowards(base.transform.position, pos, ZiplineSpeed * Time.fixedDeltaTime);
				}
				else
				{
					base.transform.position = Vector3.Lerp(base.transform.position, pos, ZiplineSpeed * Time.deltaTime);
				}
				if ((bool)input && (bool)thisGrabber)
				{
					input.VibrateController(0.1f, 0.1f, 0.1f, thisGrabber.HandSide);
				}
			}
		}
		public class GrabberArea : MonoBehaviour
		{
			public Grabber InArea;

			public List<Grabber> grabbersInArea;

			private void Update()
			{
				InArea = GetOpenGrabber();
			}

			public Grabber GetOpenGrabber()
			{
				if (grabbersInArea != null && grabbersInArea.Count > 0)
				{
					foreach (Grabber item in grabbersInArea)
					{
						if (!item.HoldingItem)
						{
							return item;
						}
					}
				}
				return null;
			}

			private void OnTriggerEnter(Collider other)
			{
				Grabber component = other.GetComponent<Grabber>();
				if (component != null)
				{
					if (grabbersInArea == null)
					{
						grabbersInArea = new List<Grabber>();
					}
					if (!grabbersInArea.Contains(component))
					{
						grabbersInArea.Add(component);
					}
				}
			}

			private void OnTriggerExit(Collider other)
			{
				Grabber component = other.GetComponent<Grabber>();
				if (component != null && grabbersInArea != null && grabbersInArea.Contains(component))
				{
					grabbersInArea.Remove(component);
				}
			}
		}
		public class HandCollision : MonoBehaviour
		{
			public HandController HandControl;

			public Grabber HandGrabber;

			public bool EnableHandCollision = true;

			public bool EnableCollisionOnPoint = true;

			public bool EnableCollisionOnFist = true;

			public bool EnableCollisionOnAllPoses;

			public bool EnableCollisionDuringGrab;

			private List<Collider> handColliders;

			private void Start()
			{
				handColliders = new List<Collider>();
				Collider[] componentsInChildren = GetComponentsInChildren<Collider>(includeInactive: true);
				foreach (Collider collider in componentsInChildren)
				{
					if (!collider.isTrigger)
					{
						handColliders.Add(collider);
					}
				}
			}

			private void Update()
			{
				if (!EnableHandCollision)
				{
					return;
				}
				bool flag = HandGrabber != null && HandGrabber.HoldingItem;
				bool flag2 = HandControl.GripAmount > 0.9f && HandControl.PointAmount == 0f;
				bool flag3 = HandControl.PointAmount > 0.9f && HandControl.GripAmount > 0.9f;
				foreach (Collider handCollider in handColliders)
				{
					if (!EnableCollisionDuringGrab && flag)
					{
						handCollider.enabled = false;
						continue;
					}
					bool flag4 = false;
					if (EnableCollisionDuringGrab && flag)
					{
						flag4 = true;
					}
					else if (EnableCollisionOnPoint && flag3)
					{
						flag4 = true;
					}
					else if (EnableCollisionOnFist && flag2)
					{
						flag4 = true;
					}
					else if (EnableCollisionOnAllPoses)
					{
						flag4 = true;
					}
					handCollider.enabled = flag4;
				}
			}
		}
		public class HandController : MonoBehaviour
		{
			public Transform HandAnchor;

			public Animator HandAnimator;

			private Grabber grabber;

			public float GripAmount;

			public float PointAmount;

			public float ThumbAmount;

			private InputBridge input;

			private void Start()
			{
				base.transform.parent = HandAnchor;
				base.transform.localPosition = Vector3.zero;
				base.transform.localRotation = Quaternion.identity;
				grabber = GetComponentInChildren<Grabber>();
				input = GameObject.FindGameObjectWithTag("Player").GetComponent<InputBridge>();
			}

			private void Update()
			{
				if (grabber == null || !grabber.isActiveAndEnabled)
				{
					GripAmount = 0f;
					PointAmount = 0f;
					ThumbAmount = 0f;
					return;
				}
				if (grabber.HandSide == ControllerHand.Left)
				{
					GripAmount = input.LeftGrip;
					PointAmount = 1f - input.LeftTrigger;
					PointAmount *= 0.5f;
					if (!input.LeftTriggerNear && PointAmount != 0f)
					{
						PointAmount = 1f;
					}
					ThumbAmount = ((!input.LeftThumbNear) ? 1 : 0);
				}
				else if (grabber.HandSide == ControllerHand.Right)
				{
					GripAmount = input.RightGrip;
					PointAmount = 1f - input.RightTrigger;
					PointAmount *= 0.5f;
					if (!input.RightTriggerNear && PointAmount != 0f)
					{
						PointAmount = 1f;
					}
					ThumbAmount = ((!input.RightThumbNear) ? 1 : 0);
				}
				if (grabber.HoldingItem)
				{
					GripAmount = 1f;
					PointAmount = 0f;
					ThumbAmount = 0f;
				}
				if (HandAnimator == null || !HandAnimator.isActiveAndEnabled)
				{
					HandAnimator = GetComponentInChildren<Animator>();
				}
				if (HandAnimator != null)
				{
					updateAnimimationStates();
				}
			}

			private void updateAnimimationStates()
			{
				if (HandAnimator != null && HandAnimator.isActiveAndEnabled && HandAnimator.runtimeAnimatorController != null)
				{
					HandAnimator.SetFloat("Flex", GripAmount);
					HandAnimator.SetLayerWeight(1, ThumbAmount);
					HandAnimator.SetLayerWeight(2, PointAmount);
				}
			}
		}
		public class HandTracking : MonoBehaviour
		{
			public OVRHand LeftHand;

			public OVRHand RightHand;

			public Grabber LeftGrabber;

			public Grabber RightGrabber;

			public Transform LeftModelHolder;

			public Transform RightModelHolder;

			public bool IsHandTracking;

			private bool wasHandTracking;

			public OVRHand.TrackingConfidence LeftHandConfidence;

			public OVRHand.TrackingConfidence RightHandConfidence;

			public bool IsLeftIndexPinching;

			public float LeftIndexPinchStrength;

			public bool IsRightIndexPinching;

			public float RightIndexPinchStrength;

			public Vector3 RightIndexPosition;

			public Vector3 LeftIndexPosition;

			public bool DoPinchToGrab = true;

			private OVRSkeleton leftSkele;

			private OVRSkeleton rightSkele;

			private OVRBone leftIndexBone;

			private OVRBone rightIndexBone;

			private void Start()
			{
				leftSkele = LeftHand.GetComponent<OVRSkeleton>();
				rightSkele = RightHand.GetComponent<OVRSkeleton>();
			}

			private void Update()
			{
				updateHandTracking(IsHandTracking);
				if (IsHandTracking)
				{
					LeftHandConfidence = LeftHand.GetFingerConfidence(OVRHand.HandFinger.Index);
					RightHandConfidence = RightHand.GetFingerConfidence(OVRHand.HandFinger.Index);
					leftIndexBone = leftSkele.Bones.FirstOrDefault((OVRBone x) => x.Id == OVRSkeleton.BoneId.Hand_IndexTip);
					if (leftIndexBone != null)
					{
						LeftIndexPosition = leftIndexBone.Transform.position;
					}
					IsLeftIndexPinching = LeftHand.GetFingerIsPinching(OVRHand.HandFinger.Index) && LeftHandConfidence == OVRHand.TrackingConfidence.High;
					LeftIndexPinchStrength = LeftHand.GetFingerPinchStrength(OVRHand.HandFinger.Index);
					rightIndexBone = rightSkele.Bones.FirstOrDefault((OVRBone x) => x.Id == OVRSkeleton.BoneId.Hand_IndexTip);
					RightIndexPosition = rightIndexBone.Transform.position;
					IsRightIndexPinching = RightHand.GetFingerIsPinching(OVRHand.HandFinger.Index) && RightHandConfidence == OVRHand.TrackingConfidence.High;
					RightIndexPinchStrength = RightHand.GetFingerPinchStrength(OVRHand.HandFinger.Index);
				}
				updateGrabbers();
			}

			private void updateHandTracking(bool handTrackingEnabled)
			{
				IsHandTracking = OVRInput.GetActiveController() == OVRInput.Controller.Hands;
				if (IsHandTracking != wasHandTracking)
				{
					onHandTrackingChange(IsHandTracking);
				}
				wasHandTracking = IsHandTracking;
			}

			private void onHandTrackingChange(bool handTrackingEnabled)
			{
				LeftModelHolder.gameObject.SetActive(!handTrackingEnabled);
				RightModelHolder.gameObject.SetActive(!handTrackingEnabled);
			}

			private void updateGrabbers()
			{
				if ((bool)LeftGrabber)
				{
					LeftGrabber.gameObject.SetActive(IsHandTracking);
					if (IsHandTracking)
					{
						LeftGrabber.transform.position = LeftIndexPosition;
						LeftGrabber.ForceGrab = DoPinchToGrab && IsLeftIndexPinching;
						LeftGrabber.ForceRelease = DoPinchToGrab && !IsLeftIndexPinching;
					}
					LeftGrabber.ForceGrab = IsLeftIndexPinching;
				}
				if ((bool)RightGrabber)
				{
					RightGrabber.gameObject.SetActive(IsHandTracking);
					if (IsHandTracking)
					{
						RightGrabber.transform.position = RightIndexPosition;
						RightGrabber.ForceGrab = DoPinchToGrab && IsRightIndexPinching;
						RightGrabber.ForceRelease = DoPinchToGrab && !IsRightIndexPinching;
					}
				}
			}
		}
		public class InvalidTeleportArea : MonoBehaviour
		{
		}
		public class JointHelper : MonoBehaviour
		{
			public bool LockXPosition;

			public bool LockYPosition;

			public bool LockZPosition;

			public bool LockXScale = true;

			public bool LockYScale = true;

			public bool LockZScale = true;

			public bool LockXRotation;

			public bool LockYRotation;

			public bool LockZRotation;

			private Vector3 initialPosition;

			private Vector3 initialRotation;

			private Vector3 initialScale;

			private void Start()
			{
				initialPosition = base.transform.localPosition;
				initialRotation = base.transform.localEulerAngles;
				initialScale = base.transform.localScale;
			}

			private void Update()
			{
				if (LockXPosition || LockYPosition || LockZPosition)
				{
					Vector3 localPosition = base.transform.localPosition;
					base.transform.localPosition = new Vector3(LockXPosition ? initialPosition.x : localPosition.x, LockYPosition ? initialPosition.y : localPosition.y, LockZPosition ? initialPosition.z : localPosition.z);
				}
				if (LockXScale || LockYScale || LockZScale)
				{
					Vector3 localScale = base.transform.localScale;
					base.transform.localScale = new Vector3(LockXScale ? initialScale.x : localScale.x, LockYScale ? initialScale.y : localScale.y, LockZScale ? initialScale.z : localScale.z);
				}
				if (LockXRotation || LockYRotation || LockZRotation)
				{
					Vector3 localEulerAngles = base.transform.localEulerAngles;
					base.transform.localEulerAngles = new Vector3(LockXRotation ? initialRotation.x : localEulerAngles.x, LockYRotation ? initialRotation.y : localEulerAngles.y, LockZRotation ? initialRotation.z : localEulerAngles.z);
				}
			}
		}
		public class RingHelper : MonoBehaviour
		{
			public Color RingColor = Color.white;

			public Color RingSelectedColor = Color.white;

			public Color RingSecondarySelectedColor = Color.white;

			public float ringSizeInRange = 1500f;

			public float ringSizeGrabbable = 1100f;

			public bool HideIfHandsAreFull = true;

			public float RingFadeSpeed = 5f;

			private Canvas canvas;

			private Text text;

			private Grabbable grabbable;

			private CanvasScaler scaler;

			private Grabber leftGrabber;

			private Grabber rightGrabber;

			private bool handsFull;

			private float _initalOpacity;

			private float _currentOpacity;

			private void Start()
			{
				grabbable = base.transform.parent.GetComponent<Grabbable>();
				canvas = GetComponent<Canvas>();
				scaler = GetComponent<CanvasScaler>();
				text = GetComponent<Text>();
				_initalOpacity = text.color.a;
				_currentOpacity = _initalOpacity;
				Grabber[] componentsInChildren = GameObject.FindGameObjectWithTag("Player").GetComponentsInChildren<Grabber>();
				foreach (Grabber grabber in componentsInChildren)
				{
					if (grabber.HandSide == ControllerHand.Left)
					{
						leftGrabber = grabber;
					}
					else if (grabber.HandSide == ControllerHand.Right)
					{
						rightGrabber = grabber;
					}
				}
			}

			private void Update()
			{
				handsFull = leftGrabber != null && rightGrabber != null && leftGrabber.HoldingItem && rightGrabber.HoldingItem;
				bool flag = handsFull;
				if (grabbable.BeingHeld || !grabbable.isActiveAndEnabled)
				{
					canvas.enabled = false;
					return;
				}
				float num = Vector3.Distance(base.transform.position, Camera.main.transform.position);
				if ((!handsFull && num <= grabbable.RemoteGrabDistance) ? true : false)
				{
					canvas.enabled = true;
					canvas.transform.LookAt(Camera.main.transform);
					text.text = "o";
					if (grabbable.IsGrabbable)
					{
						scaler.dynamicPixelsPerUnit = ringSizeGrabbable;
						Color selectedColor = getSelectedColor();
						text.color = selectedColor;
					}
					else
					{
						scaler.dynamicPixelsPerUnit = ringSizeInRange;
						text.color = RingColor;
					}
					_currentOpacity += Time.deltaTime * RingFadeSpeed;
					if (_currentOpacity > _initalOpacity)
					{
						_currentOpacity = _initalOpacity;
					}
					Color color = text.color;
					color.a = _currentOpacity;
					text.color = color;
				}
				else
				{
					_currentOpacity -= Time.deltaTime * RingFadeSpeed;
					if (_currentOpacity <= 0f)
					{
						_currentOpacity = 0f;
						canvas.enabled = false;
						return;
					}
					canvas.enabled = true;
					Color color2 = text.color;
					color2.a = _currentOpacity;
					text.color = color2;
				}
			}

			private Color getSelectedColor()
			{
				Grabber closestGrabber = grabbable.GetClosestGrabber();
				if (grabbable != null && closestGrabber != null && closestGrabber.HandSide == ControllerHand.Left)
				{
					return RingSecondarySelectedColor;
				}
				return RingSelectedColor;
			}
		}
		public class StaticBatch : MonoBehaviour
		{
			public Material CombineMaterial;

			private void Start()
			{
				if (CombineMaterial == null)
				{
					UnityEngine.Debug.Log("No material specified for mesh combine. Forget to assign it in the inspector?");
					return;
				}
				Vector3 position = base.transform.position;
				Quaternion rotation = base.transform.rotation;
				base.transform.position = Vector3.zero;
				base.transform.rotation = Quaternion.identity;
				if (base.gameObject.GetComponent<MeshRenderer>() == null)
				{
					MeshRenderer meshRenderer = base.gameObject.AddComponent<MeshRenderer>();
					MeshRenderer componentInChildren = base.transform.GetComponentInChildren<MeshRenderer>();
					meshRenderer.sharedMaterial = componentInChildren.material;
					meshRenderer.sharedMaterial = CombineMaterial;
				}
				MeshFilter[] componentsInChildren = GetComponentsInChildren<MeshFilter>();
				List<MeshFilter> list = new List<MeshFilter>();
				for (int i = 1; i < componentsInChildren.Length; i++)
				{
					list.Add(componentsInChildren[i]);
				}
				CombineInstance[] array = new CombineInstance[list.Count];
				for (int j = 0; j < list.Count; j++)
				{
					array[j].mesh = list[j].sharedMesh;
					array[j].transform = list[j].transform.localToWorldMatrix;
					list[j].gameObject.SetActive(value: false);
				}
				MeshFilter meshFilter = base.gameObject.GetComponent<MeshFilter>();
				if (meshFilter == null)
				{
					meshFilter = base.gameObject.AddComponent<MeshFilter>();
				}
				meshFilter.mesh = new Mesh();
				meshFilter.mesh.CombineMeshes(array, mergeSubMeshes: true, useMatrices: true);
				base.transform.gameObject.SetActive(value: true);
				base.transform.position = position;
				base.transform.rotation = rotation;
			}
		}
		public class TeleportDestination : MonoBehaviour
		{
			public Transform DestinationTransform;

			public bool ForcePlayerRotation;
		}
		public class VRUtils : MonoBehaviour
		{
			public static VRUtils Instance;

			public Color DebugTextColor = Color.white;

			public Transform DebugTextHolder;

			private float MaxTextEntries = 10f;

			private void Awake()
			{
				Instance = this;
			}

			public void Log(string msg)
			{
				UnityEngine.Debug.Log(msg);
				if (DebugTextHolder != null)
				{
					GameObject obj = new GameObject();
					obj.transform.parent = DebugTextHolder;
					obj.transform.localPosition = Vector3.zero;
					obj.transform.localScale = Vector3.one;
					obj.transform.name = "Debug Text";
					Text text = obj.AddComponent<Text>();
					text.text = msg;
					text.horizontalOverflow = HorizontalWrapMode.Wrap;
					text.verticalOverflow = VerticalWrapMode.Overflow;
					text.color = DebugTextColor;
					text.fontSize = 32;
					text.font = Resources.GetBuiltinResource(typeof(Font), "Arial.ttf") as Font;
					text.raycastTarget = false;
					RectTransform component = obj.GetComponent<RectTransform>();
					component.localScale = Vector3.one;
					component.localRotation = Quaternion.identity;
					if ((float)DebugTextHolder.childCount > MaxTextEntries)
					{
						UnityEngine.Object.DestroyImmediate(DebugTextHolder.GetChild(0).gameObject);
					}
				}
			}

			public AudioSource PlaySpatialClipAt(AudioClip clip, Vector3 pos, float volume, float spatialBlend = 1f)
			{
				if (clip == null)
				{
					return null;
				}
				GameObject gameObject = new GameObject("SpatialAudio - Temp");
				gameObject.transform.position = pos;
				AudioSource audioSource = gameObject.AddComponent<AudioSource>();
				audioSource.clip = clip;
				audioSource.spatialize = true;
				audioSource.pitch = Time.timeScale;
				audioSource.spatialBlend = spatialBlend;
				audioSource.volume = volume;
				audioSource.Play();
				UnityEngine.Object.Destroy(gameObject, clip.length);
				return audioSource;
			}
		}
		public class AmmoDispenser : MonoBehaviour
		{
			public Grabber LeftGrabber;

			public Grabber RightGrabber;

			public GameObject AmmoDispenserObject;

			public GameObject PistolClip;

			public GameObject ShotgunShell;

			private void Update()
			{
				bool flag = false;
				if (grabberHasWeapon(LeftGrabber) || grabberHasWeapon(RightGrabber))
				{
					flag = true;
				}
				if (AmmoDispenserObject.activeSelf != flag)
				{
					AmmoDispenserObject.SetActive(flag);
				}
			}

			private bool grabberHasWeapon(Grabber g)
			{
				if (g != null && g.HeldGrabbable != null && (g.HeldGrabbable.transform.name.Contains("Shotgun") || g.HeldGrabbable.transform.name.Contains("Pistol")))
				{
					return true;
				}
				return false;
			}

			private GameObject getAmmo()
			{
				if (LeftGrabber != null && LeftGrabber.HeldGrabbable != null && LeftGrabber.HeldGrabbable.transform.name.Contains("Shotgun"))
				{
					return ShotgunShell;
				}
				if (RightGrabber != null && RightGrabber.HeldGrabbable != null && RightGrabber.HeldGrabbable.transform.name.Contains("Shotgun"))
				{
					return ShotgunShell;
				}
				return PistolClip;
			}

			public void GrabAmmo(Grabber grabber)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(getAmmo(), grabber.transform.position, grabber.transform.rotation);
				Grabbable component = gameObject.GetComponent<Grabbable>();
				GrabbableRingHelper componentInChildren = gameObject.GetComponentInChildren<GrabbableRingHelper>();
				if ((bool)componentInChildren)
				{
					UnityEngine.Object.Destroy(componentInChildren);
					UnityEngine.Object.Destroy(gameObject.GetComponentInChildren<RingHelper>().gameObject);
				}
				gameObject.transform.parent = grabber.transform;
				gameObject.transform.localPosition = -component.GrabPositionOffset;
				gameObject.transform.parent = null;
				grabber.GrabGrabbable(component);
			}
		}
		public class AmmoDisplay : MonoBehaviour
		{
			public RaycastWeapon Weapon;

			public Text AmmoLabel;

			private void OnGUI()
			{
				string text = (Weapon.BulletInChamber ? "1" : "0");
				AmmoLabel.text = text + " / " + Weapon.GetBulletCount();
			}
		}
		public class Bullet : MonoBehaviour
		{
		}
		public class BulletInsert : MonoBehaviour
		{
			public RaycastWeapon Weapon;

			public string AcceptBulletName = "Bullet";

			public AudioClip InsertSound;

			private void OnTriggerEnter(Collider other)
			{
				Grabbable component = other.GetComponent<Grabbable>();
				if (component != null && component.transform.name.Contains(AcceptBulletName) && !((float)Weapon.GetBulletCount() >= Weapon.MaxInternalAmmo))
				{
					component.DropItem(resetVelocity: false, resetParent: true);
					component.transform.parent = null;
					UnityEngine.Object.Destroy(component.gameObject);
					GameObject obj = new GameObject();
					obj.AddComponent<Bullet>();
					obj.transform.parent = Weapon.transform;
					if ((bool)InsertSound)
					{
						VRUtils.Instance.PlaySpatialClipAt(InsertSound, base.transform.position, 1f, 0.5f);
					}
				}
			}
		}
		public class MagazineSlide : MonoBehaviour
		{
			public string AcceptableMagazineName = "Clip";

			public Grabbable AttachedWeapon;

			public float ClipSnapDistance = 0.075f;

			public float ClipUnsnapDistance = 0.15f;

			public float EjectForce = 1f;

			public Grabbable HeldMagazine;

			private Collider HeldCollider;

			public float MagazineDistance;

			private bool magazineInPlace;

			private bool lockedInPlace;

			public AudioClip ClipAttachSound;

			public AudioClip ClipDetachSound;

			private RaycastWeapon parentWeapon;

			private GrabberArea grabClipArea;

			private InputBridge input;

			private float lastEjectTime;

			private void Start()
			{
				if ((bool)GameObject.FindGameObjectWithTag("Player"))
				{
					input = GameObject.FindGameObjectWithTag("Player").GetComponent<InputBridge>();
				}
				grabClipArea = GetComponentInChildren<GrabberArea>();
				if (base.transform.parent != null)
				{
					parentWeapon = base.transform.parent.GetComponent<RaycastWeapon>();
				}
			}

			private void LateUpdate()
			{
				checkGrabClipInput();
				if (!(HeldMagazine != null))
				{
					return;
				}
				HeldMagazine.transform.parent = base.transform;
				if (lockedInPlace)
				{
					HeldMagazine.transform.localPosition = Vector3.zero;
					HeldMagazine.transform.localEulerAngles = Vector3.zero;
					return;
				}
				Vector3 localPosition = HeldMagazine.transform.localPosition;
				HeldMagazine.transform.localEulerAngles = Vector3.zero;
				float num = localPosition.y;
				if (num > 0f)
				{
					num = 0f;
				}
				moveMagazine(new Vector3(0f, num, 0f));
				MagazineDistance = Vector3.Distance(base.transform.position, HeldMagazine.transform.position);
				float num2 = Time.time - lastEjectTime;
				if (MagazineDistance < ClipSnapDistance)
				{
					if (!magazineInPlace && num2 > 0.75f)
					{
						attachMagazine();
					}
					if (!HeldMagazine.BeingHeld)
					{
						moveMagazine(Vector3.zero);
					}
				}
				else if (MagazineDistance >= ClipUnsnapDistance)
				{
					UnityEngine.Debug.Log("Exceeded Distance " + MagazineDistance);
					detachMagazine();
				}
			}

			private void moveMagazine(Vector3 localPosition)
			{
				HeldMagazine.transform.localPosition = localPosition;
			}

			private void checkGrabClipInput()
			{
				if (HeldMagazine == null || grabClipArea == null || (AttachedWeapon != null && !AttachedWeapon.BeingHeld))
				{
					return;
				}
				Grabber openGrabber = grabClipArea.GetOpenGrabber();
				if (grabClipArea != null && openGrabber != null)
				{
					if (openGrabber.HandSide == ControllerHand.Left && input.LeftGripDown)
					{
						OnGrabClipArea(openGrabber);
					}
					else if (openGrabber.HandSide == ControllerHand.Right && input.RightGripDown)
					{
						OnGrabClipArea(openGrabber);
					}
				}
			}

			private void attachMagazine()
			{
				Grabber primaryGrabber = HeldMagazine.GetPrimaryGrabber();
				HeldMagazine.DropItem(primaryGrabber, resetVelocity: false, resetParent: false);
				VRUtils.Instance.PlaySpatialClipAt(ClipAttachSound, base.transform.position, 1f);
				moveMagazine(Vector3.zero);
				if (base.transform.parent != null)
				{
					Rigidbody component = base.transform.parent.GetComponent<Rigidbody>();
					if ((bool)component)
					{
						FixedJoint fixedJoint = HeldMagazine.gameObject.AddComponent<FixedJoint>();
						fixedJoint.autoConfigureConnectedAnchor = true;
						fixedJoint.axis = new Vector3(0f, 1f, 0f);
						fixedJoint.connectedBody = component;
					}
					if ((bool)parentWeapon)
					{
						parentWeapon.OnAttachedAmmo();
					}
				}
				HeldMagazine.enabled = false;
				lockedInPlace = true;
				magazineInPlace = true;
			}

			private Grabbable detachMagazine()
			{
				if (HeldMagazine == null)
				{
					return null;
				}
				VRUtils.Instance.PlaySpatialClipAt(ClipDetachSound, base.transform.position, 1f, 0.9f);
				HeldMagazine.transform.parent = null;
				if (base.transform.parent != null && (bool)base.transform.parent.GetComponent<Rigidbody>())
				{
					FixedJoint component = HeldMagazine.gameObject.GetComponent<FixedJoint>();
					if ((bool)component)
					{
						component.connectedBody = null;
						UnityEngine.Object.Destroy(component);
					}
				}
				if (HeldCollider != null)
				{
					HeldCollider.enabled = true;
					HeldCollider = null;
				}
				if ((bool)parentWeapon)
				{
					parentWeapon.OnDetachedAmmo();
				}
				HeldMagazine.enabled = true;
				magazineInPlace = false;
				lockedInPlace = false;
				lastEjectTime = Time.time;
				Grabbable heldMagazine = HeldMagazine;
				HeldMagazine = null;
				return heldMagazine;
			}

			public void EjectMagazine()
			{
				Grabbable ejectedMag = detachMagazine();
				StartCoroutine(EjectMagRoutine(ejectedMag));
			}

			private IEnumerator EjectMagRoutine(Grabbable ejectedMag)
			{
				if (ejectedMag != null && ejectedMag.GetComponent<Rigidbody>() != null)
				{
					Rigidbody ejectRigid = ejectedMag.GetComponent<Rigidbody>();
					yield return new WaitForFixedUpdate();
					ejectedMag.transform.parent = base.transform;
					if (ejectedMag.transform.localPosition.y > 0f - ClipSnapDistance)
					{
						ejectedMag.transform.localPosition = new Vector3(0f, -0.2f, 0f);
					}
					ejectedMag.transform.parent = null;
					ejectRigid.AddForce(-ejectedMag.transform.up * EjectForce, ForceMode.VelocityChange);
				}
				yield return null;
			}

			public void OnGrabClipArea(Grabber grabbedBy)
			{
				UnityEngine.Debug.Log("OnGrabClipArea");
				if (HeldMagazine != null)
				{
					Grabbable heldMagazine = HeldMagazine;
					HeldMagazine.enabled = true;
					detachMagazine();
					heldMagazine.enabled = true;
					grabbedBy.GrabGrabbable(heldMagazine);
				}
			}

			private void OnTriggerEnter(Collider other)
			{
				Grabbable component = other.GetComponent<Grabbable>();
				if (HeldMagazine == null && component != null && component.transform.name.Contains(AcceptableMagazineName))
				{
					HeldMagazine = component;
					HeldMagazine.transform.parent = base.transform;
					HeldCollider = other;
					if (HeldCollider != null)
					{
						HeldCollider.enabled = false;
					}
				}
			}
		}
		public class Projectile : MonoBehaviour
		{
			public GameObject HitFXPrefab;

			private bool _checkRaycast;

			public float Damage = 25f;

			public float AddRigidForce = 5f;

			public LayerMask ValidLayers;

			public bool StickToObject;

			public float MinForceHit = 0.02f;

			private void OnCollisionEnter(Collision collision)
			{
				if (collision.collider.isTrigger)
				{
					return;
				}
				Rigidbody component = GetComponent<Rigidbody>();
				if (!component || MinForceHit == 0f || !(Math.Abs(base.transform.InverseTransformDirection(component.velocity).z) < MinForceHit))
				{
					Vector3 point = collision.contacts[0].point;
					Vector3 normal = collision.contacts[0].normal;
					Quaternion rot = Quaternion.FromToRotation(Vector3.forward, normal);
					DoHitFX(point, rot, collision.collider);
					if (!StickToObject)
					{
						UnityEngine.Object.Destroy(base.gameObject);
					}
				}
			}

			private void DoHitFX(Vector3 pos, Quaternion rot, Collider col)
			{
				if ((bool)HitFXPrefab)
				{
					BulletHole component = UnityEngine.Object.Instantiate(HitFXPrefab, pos, rot).GetComponent<BulletHole>();
					if ((bool)component)
					{
						component.TryAttachTo(col);
					}
				}
				Rigidbody attachedRigidbody = col.attachedRigidbody;
				if (attachedRigidbody != null)
				{
					attachedRigidbody.AddForceAtPosition(base.transform.forward * AddRigidForce, pos, ForceMode.VelocityChange);
				}
				Damageable component2 = col.GetComponent<Damageable>();
				if ((bool)component2)
				{
					component2.DealDamage(Damage);
				}
			}

			public void MarkAsRaycastBullet()
			{
				_checkRaycast = true;
				StartCoroutine(CheckForRaycast());
			}

			private void doRayCastProjectile()
			{
				if (Physics.Raycast(base.transform.position, base.transform.forward, out var hitInfo, 25f, ValidLayers, QueryTriggerInteraction.Ignore))
				{
					Quaternion rot = Quaternion.FromToRotation(Vector3.forward, hitInfo.normal);
					DoHitFX(hitInfo.point, rot, hitInfo.collider);
				}
				_checkRaycast = false;
				UnityEngine.Object.Destroy(base.gameObject);
			}

			private IEnumerator CheckForRaycast()
			{
				while (base.gameObject.activeSelf && _checkRaycast)
				{
					if (Time.timeScale >= 1f)
					{
						doRayCastProjectile();
					}
					yield return new WaitForEndOfFrame();
				}
			}
		}
		public class RaycastWeapon : GrabbableEvents
		{
			public float MaxRange = 25f;

			public float Damage = 25f;

			public FiringType FiringMethod;

			public ReloadType ReloadMethod;

			public float FiringRate = 0.2f;

			private float lastShotTime;

			public float MaxInternalAmmo = 10f;

			public bool AutoChamberRounds = true;

			public bool MustChamberRounds;

			public Vector3 RecoilForce = Vector3.zero;

			private Rigidbody weaponRigid;

			public LayerMask ValidLayers;

			public Transform TriggerTransform;

			public Transform SlideTransform;

			public Transform MuzzlePointTransform;

			public Transform EjectPointTransform;

			public Transform ChamberedBullet;

			public GameObject MuzzleFlashObject;

			public GameObject BulletCasingPrefab;

			public GameObject ProjectilePrefab;

			public GameObject HitFXPrefab;

			public AudioClip GunShotSound;

			public AudioClip EmptySound;

			public float SlideDistance = -0.028f;

			public bool BulletInChamber;

			public bool EmptyBulletInChamber;

			public bool ForceSlideBackOnLastShot = true;

			public Grabbable SecondHandGrabbable;

			private bool slideForcedBack;

			private WeaponSlide ws;

			private float originalTriggerX;

			private bool readyToShoot = true;

			private Vector3 initialSecondaryOffset;

			private float yOffset;

			public float ShotForce = 10f;

			private IEnumerator shotRoutine;

			public float slideSpeed = 1f;

			public float minSlideDistance = 0.001f;

			private void Start()
			{
				weaponRigid = GetComponent<Rigidbody>();
				if ((bool)TriggerTransform)
				{
					originalTriggerX = TriggerTransform.localEulerAngles.x;
				}
				if ((bool)MuzzleFlashObject)
				{
					MuzzleFlashObject.SetActive(value: false);
				}
				ws = GetComponentInChildren<WeaponSlide>();
				updateChamberedBullet();
			}

			public override void OnTrigger(float triggerValue)
			{
				if ((bool)TriggerTransform)
				{
					float num = originalTriggerX + 20f;
					TriggerTransform.localEulerAngles = new Vector3(originalTriggerX + triggerValue * num, 0f, 0f);
				}
				if ((double)triggerValue <= 0.5)
				{
					readyToShoot = true;
				}
				if (readyToShoot && triggerValue >= 0.75f)
				{
					Shoot();
					readyToShoot = FiringMethod == FiringType.Automatic;
				}
				updateChamberedBullet();
				checkSecondaryWeaponLook();
				base.OnTrigger(triggerValue);
			}

			private void LateUpdate()
			{
				checkSecondaryWeaponLook();
			}

			private void checkSecondaryWeaponLook()
			{
				if (SecondHandGrabbable != null && SecondHandGrabbable.BeingHeld)
				{
					if (thisGrabber != null)
					{
						Vector3 localEulerAngles = thisGrabber.transform.localEulerAngles;
						Grabber primaryGrabber = SecondHandGrabbable.GetPrimaryGrabber();
						if (initialSecondaryOffset == Vector3.zero)
						{
							float num = SecondHandGrabbable.transform.position.y - primaryGrabber.transform.position.y;
							initialSecondaryOffset = SecondHandGrabbable.transform.position - primaryGrabber.transform.position;
							UnityEngine.Debug.Log(num);
						}
						Quaternion b = Quaternion.LookRotation(primaryGrabber.transform.position - thisGrabber.transform.position);
						thisGrabber.transform.rotation = Quaternion.Slerp(thisGrabber.transform.rotation, b, Time.deltaTime * 35f);
						thisGrabber.transform.localEulerAngles = new Vector3(thisGrabber.transform.localEulerAngles.x, thisGrabber.transform.localEulerAngles.y, localEulerAngles.z);
					}
				}
				else if (SecondHandGrabbable != null)
				{
					if (thisGrabber != null)
					{
						thisGrabber.transform.localRotation = Quaternion.Slerp(thisGrabber.transform.localRotation, Quaternion.identity, Time.deltaTime * 20f);
					}
					initialSecondaryOffset = Vector3.zero;
				}
			}

			public override void OnButton1Down()
			{
				if (ws != null)
				{
					ws.UnlockBack();
				}
				base.OnButton1Down();
			}

			public override void OnButton2Down()
			{
				MagazineSlide componentInChildren = GetComponentInChildren<MagazineSlide>();
				if (componentInChildren != null)
				{
					componentInChildren.EjectMagazine();
				}
				base.OnButton2Down();
			}

			public void Shoot()
			{
				float num = ((Time.timeScale < 1f) ? 0.3f : FiringRate);
				if (Time.time - lastShotTime < num)
				{
					return;
				}
				if (!BulletInChamber && MustChamberRounds)
				{
					VRUtils.Instance.PlaySpatialClipAt(EmptySound, base.transform.position, 1f, 0.5f);
					return;
				}
				if (ws != null && ws.LockedBack)
				{
					VRUtils.Instance.PlaySpatialClipAt(EmptySound, base.transform.position, 1f, 0.5f);
					return;
				}
				VRUtils.Instance.PlaySpatialClipAt(GunShotSound, base.transform.position, 1f);
				if (thisGrabber != null)
				{
					input.VibrateController(0.1f, 0.2f, 0.1f, thisGrabber.HandSide);
				}
				RaycastHit hitInfo;
				if (Time.timeScale < 1f)
				{
					GameObject obj = UnityEngine.Object.Instantiate(ProjectilePrefab, MuzzlePointTransform.position, MuzzlePointTransform.rotation);
					obj.GetComponent<Rigidbody>().AddForce(MuzzlePointTransform.forward * ShotForce, ForceMode.VelocityChange);
					Projectile component = obj.GetComponent<Projectile>();
					if ((bool)component)
					{
						component.MarkAsRaycastBullet();
					}
					UnityEngine.Object.Destroy(obj, 20f);
				}
				else if (Physics.Raycast(MuzzlePointTransform.position, MuzzlePointTransform.forward, out hitInfo, MaxRange, ValidLayers, QueryTriggerInteraction.Ignore))
				{
					Quaternion rotation = Quaternion.FromToRotation(Vector3.forward, hitInfo.normal);
					BulletHole component2 = UnityEngine.Object.Instantiate(HitFXPrefab, hitInfo.point, rotation).GetComponent<BulletHole>();
					if ((bool)component2)
					{
						component2.TryAttachTo(hitInfo.collider);
					}
					Rigidbody attachedRigidbody = hitInfo.collider.attachedRigidbody;
					if (attachedRigidbody != null)
					{
						float num2 = 1000f;
						attachedRigidbody.AddForceAtPosition(num2 * MuzzlePointTransform.forward, hitInfo.point);
					}
					Damageable component3 = hitInfo.collider.GetComponent<Damageable>();
					if ((bool)component3)
					{
						component3.DealDamage(Damage);
					}
				}
				if (weaponRigid != null && RecoilForce != Vector3.zero)
				{
					weaponRigid.AddForceAtPosition(RecoilForce, MuzzlePointTransform.position, ForceMode.VelocityChange);
				}
				BulletInChamber = false;
				if (AutoChamberRounds)
				{
					chamberRound();
				}
				else
				{
					EmptyBulletInChamber = true;
				}
				if (!BulletInChamber)
				{
					slideForcedBack = ForceSlideBackOnLastShot;
					if (slideForcedBack && ws != null)
					{
						ws.LockBack();
					}
				}
				lastShotTime = Time.time;
				if (shotRoutine != null)
				{
					StopCoroutine(shotRoutine);
				}
				if (AutoChamberRounds)
				{
					shotRoutine = animateSlideAndEject();
					StartCoroutine(shotRoutine);
				}
				else
				{
					shotRoutine = doMuzzleFlash();
					StartCoroutine(shotRoutine);
				}
			}

			public void OnAttachedAmmo()
			{
				updateChamberedBullet();
			}

			public void OnDetachedAmmo()
			{
				updateChamberedBullet();
			}

			public int GetBulletCount()
			{
				if (ReloadMethod == ReloadType.InfiniteAmmo)
				{
					return 9999;
				}
				return GetComponentsInChildren<Bullet>(includeInactive: false).Length;
			}

			private void removeBullet()
			{
				if (ReloadMethod != 0)
				{
					Bullet componentInChildren = GetComponentInChildren<Bullet>(includeInactive: false);
					if (componentInChildren != null)
					{
						UnityEngine.Object.Destroy(componentInChildren.gameObject);
					}
					updateChamberedBullet();
				}
			}

			private void updateChamberedBullet()
			{
				if (ChamberedBullet != null)
				{
					ChamberedBullet.gameObject.SetActive(BulletInChamber || EmptyBulletInChamber);
				}
			}

			private void chamberRound()
			{
				if (GetBulletCount() > 0)
				{
					removeBullet();
					BulletInChamber = true;
				}
				else
				{
					BulletInChamber = false;
				}
			}

			private void randomizeMuzzleFlashScaleRotation()
			{
				MuzzleFlashObject.transform.localScale = Vector3.one * UnityEngine.Random.Range(0.75f, 1.5f);
				MuzzleFlashObject.transform.localEulerAngles = new Vector3(0f, 0f, UnityEngine.Random.Range(0f, 90f));
			}

			public void OnWeaponCharged(bool allowCasingEject)
			{
				if (BulletInChamber && allowCasingEject)
				{
					ejectCasing();
				}
				else if (EmptyBulletInChamber && allowCasingEject)
				{
					ejectCasing();
					EmptyBulletInChamber = false;
				}
				chamberRound();
				slideForcedBack = false;
			}

			private void ejectCasing()
			{
				GameObject obj = UnityEngine.Object.Instantiate(BulletCasingPrefab, EjectPointTransform.position, EjectPointTransform.rotation);
				Rigidbody component = obj.GetComponent<Rigidbody>();
				if ((bool)component)
				{
					component.AddRelativeForce(Vector3.right * 3f, ForceMode.VelocityChange);
				}
				UnityEngine.Object.Destroy(obj, 5f);
			}

			private IEnumerator doMuzzleFlash()
			{
				MuzzleFlashObject.SetActive(value: true);
				yield return new WaitForEndOfFrame();
				randomizeMuzzleFlashScaleRotation();
				yield return new WaitForEndOfFrame();
				MuzzleFlashObject.SetActive(value: false);
			}

			private IEnumerator animateSlideAndEject()
			{
				MuzzleFlashObject.SetActive(value: true);
				int frames2 = 0;
				bool slideEndReached = false;
				Vector3 slideDestination = new Vector3(0f, 0f, SlideDistance);
				if ((bool)SlideTransform)
				{
					while (!slideEndReached)
					{
						SlideTransform.localPosition = Vector3.MoveTowards(SlideTransform.localPosition, slideDestination, Time.deltaTime * slideSpeed);
						if (Vector3.Distance(SlideTransform.localPosition, slideDestination) <= minSlideDistance)
						{
							slideEndReached = true;
						}
						frames2++;
						if (frames2 < 2)
						{
							randomizeMuzzleFlashScaleRotation();
						}
						else
						{
							slideEndReached = true;
							MuzzleFlashObject.SetActive(value: false);
						}
						yield return new WaitForEndOfFrame();
					}
				}
				else
				{
					yield return new WaitForEndOfFrame();
					randomizeMuzzleFlashScaleRotation();
					yield return new WaitForEndOfFrame();
					MuzzleFlashObject.SetActive(value: false);
				}
				if ((bool)SlideTransform)
				{
					SlideTransform.localPosition = slideDestination;
				}
				yield return new WaitForEndOfFrame();
				ejectCasing();
				yield return new WaitForEndOfFrame();
				if (slideForcedBack || !(SlideTransform != null))
				{
					yield break;
				}
				frames2 = 0;
				bool slideBeginningReached = false;
				while (!slideBeginningReached)
				{
					SlideTransform.localPosition = Vector3.MoveTowards(SlideTransform.localPosition, Vector3.zero, Time.deltaTime * slideSpeed);
					if (Vector3.Distance(SlideTransform.localPosition, Vector3.zero) <= minSlideDistance)
					{
						slideBeginningReached = true;
					}
					if (frames2 > 2)
					{
						slideBeginningReached = true;
					}
					yield return new WaitForEndOfFrame();
				}
			}
		}
		public enum FiringType
		{
			Semi,
			Automatic
		}
		public enum ReloadType
		{
			InfiniteAmmo,
			ManualClip
		}
		public class WeaponSlide : MonoBehaviour
		{
			public float MinLocalZ = -0.03f;

			public float MaxLocalZ;

			private bool slidingBack = true;

			public bool LockedBack;

			public AudioClip SlideReleaseSound;

			public AudioClip LockedBackSound;

			private RaycastWeapon parentWeapon;

			private Grabbable parentGrabbable;

			private Vector3 initialLocalPos;

			private Grabbable thisGrabbable;

			private AudioSource audioSource;

			private Rigidbody rigid;

			private void Start()
			{
				initialLocalPos = base.transform.localPosition;
				audioSource = GetComponent<AudioSource>();
				parentWeapon = base.transform.parent.GetComponent<RaycastWeapon>();
				parentGrabbable = base.transform.parent.GetComponent<Grabbable>();
				thisGrabbable = GetComponent<Grabbable>();
				rigid = GetComponent<Rigidbody>();
				if (parentWeapon != null)
				{
					Physics.IgnoreCollision(GetComponent<Collider>(), parentWeapon.GetComponent<Collider>());
				}
			}

			private void Update()
			{
				float z = base.transform.localPosition.z;
				if (LockedBack)
				{
					base.transform.localPosition = new Vector3(initialLocalPos.x, initialLocalPos.y, MinLocalZ);
					if (thisGrabbable != null && thisGrabbable.BeingHeld)
					{
						UnlockBack();
					}
				}
				if (LockedBack)
				{
					return;
				}
				if (z <= MinLocalZ)
				{
					base.transform.localPosition = new Vector3(initialLocalPos.x, initialLocalPos.y, MinLocalZ);
					if (slidingBack)
					{
						onSlideBack();
					}
				}
				else if (z >= MaxLocalZ)
				{
					base.transform.localPosition = new Vector3(initialLocalPos.x, initialLocalPos.y, MaxLocalZ);
					if (!slidingBack)
					{
						onSlideForward();
					}
				}
			}

			public void LockBack()
			{
				if (!LockedBack)
				{
					if (thisGrabbable.BeingHeld || parentGrabbable.BeingHeld)
					{
						VRUtils.Instance.PlaySpatialClipAt(LockedBackSound, base.transform.position, 1f, 0.8f);
					}
					LockedBack = true;
				}
			}

			public void UnlockBack()
			{
				if (LockedBack)
				{
					if (thisGrabbable.BeingHeld || parentGrabbable.BeingHeld)
					{
						VRUtils.Instance.PlaySpatialClipAt(SlideReleaseSound, base.transform.position, 1f, 0.9f);
					}
					LockedBack = false;
					if (parentWeapon != null)
					{
						parentWeapon.OnWeaponCharged(allowCasingEject: false);
					}
				}
			}

			private void onSlideBack()
			{
				if (thisGrabbable.BeingHeld || parentGrabbable.BeingHeld)
				{
					playSoundInterval(0f, 0.2f, 0.9f);
				}
				if (parentWeapon != null)
				{
					parentWeapon.OnWeaponCharged(allowCasingEject: true);
				}
				slidingBack = false;
			}

			private void onSlideForward()
			{
				if (thisGrabbable.BeingHeld || parentGrabbable.BeingHeld)
				{
					playSoundInterval(0.2f, 0.35f, 1f);
				}
				slidingBack = true;
			}

			private void playSoundInterval(float fromSeconds, float toSeconds, float volume)
			{
				if ((bool)audioSource)
				{
					if (audioSource.isPlaying)
					{
						audioSource.Stop();
					}
					audioSource.pitch = Time.timeScale;
					audioSource.time = fromSeconds;
					audioSource.volume = volume;
					audioSource.Play();
					audioSource.SetScheduledEndTime(AudioSettings.dspTime + (double)(toSeconds - fromSeconds));
				}
			}
		}
	}
	namespace PrimitivePlus
	{
		public static class PrimitivePlusConstants
		{
			public const string PRIMITIVE_PLUS_RESOURCES = "Assets/PrimitivePlus/Resources/";

			public const string PRIMITIVE_PLUS_MATERIALS = "Materials/";

			public const string PRIMITIVE_PLUS_MESHES = "Meshes/";
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(MeshRenderer))]
		public class PrimitivePlusMaterial : MonoBehaviour
		{
			private MeshRenderer m_Renderer;

			private Material m_Material;

			private void Awake()
			{
				m_Renderer = GetComponent<MeshRenderer>();
			}

			private void OnDestroy()
			{
				m_Material = null;
				m_Renderer = null;
			}

			public void SetNewMaterial()
			{
				m_Material = new Material(m_Renderer.sharedMaterial);
				m_Renderer.sharedMaterial = m_Material;
				m_Material.name = "New Material";
			}

			public void SetSharedMaterial(Material material)
			{
				m_Material = material;
				m_Renderer.sharedMaterial = m_Material;
			}
		}
		public class PrimitivePlusMeshes
		{
			private static Mesh m_Circle2D;

			private static Mesh m_CircleHalf2D;

			private static Mesh m_Cone;

			private static Mesh m_ConeHalf;

			private static Mesh m_ConeHexagon;

			private static Mesh m_ConePentagon;

			private static Mesh m_Cross;

			private static Mesh m_Cross2D;

			private static Mesh m_Cube;

			private static Mesh m_CubeCorner;

			private static Mesh m_CubeCornerThin;

			private static Mesh m_CubeEdgeIn;

			private static Mesh m_CubeEdgeOut;

			private static Mesh m_CubeHollow;

			private static Mesh m_CubeHollowThin;

			private static Mesh m_CubeTube;

			private static Mesh m_Cylinder;

			private static Mesh m_CylinderHalf;

			private static Mesh m_CylinderTube;

			private static Mesh m_CylinderTubeThin;

			private static Mesh m_Diamond;

			private static Mesh m_DiamondThick;

			private static Mesh m_Heart;

			private static Mesh m_Heart2D;

			private static Mesh m_Hexagon2D;

			private static Mesh m_Icosphere;

			private static Mesh m_IcosphereSmall;

			private static Mesh m_Plane;

			private static Mesh m_PrismHexagon;

			private static Mesh m_PrismOctagon;

			private static Mesh m_PrismPentagon;

			private static Mesh m_PrismTriangle;

			private static Mesh m_Pyramid;

			private static Mesh m_PyramidCorner;

			private static Mesh m_PyramidTri;

			private static Mesh m_Rhombus2D;

			private static Mesh m_Sphere;

			private static Mesh m_SphereHalf;

			private static Mesh m_Star;

			private static Mesh m_Star2D;

			private static Mesh m_Torus;

			private static Mesh m_TorusHalf;

			private static Mesh m_Triangle2D;

			private static Mesh m_Wedge;

			public static Mesh GetMeshType(PrimitivePlusType type)
			{
				switch (type)
				{
				case PrimitivePlusType.Circle2D:
					if (!(m_Circle2D == null))
					{
						return m_Circle2D;
					}
					return Circle2D();
				case PrimitivePlusType.CircleHalf2D:
					if (!(m_CircleHalf2D == null))
					{
						return m_CircleHalf2D;
					}
					return CircleHalf2D();
				case PrimitivePlusType.Cone:
					if (!(m_Cone == null))
					{
						return m_Cone;
					}
					return Cone();
				case PrimitivePlusType.ConeHalf:
					if (!(m_ConeHalf == null))
					{
						return m_ConeHalf;
					}
					return ConeHalf();
				case PrimitivePlusType.ConeHexagon:
					if (!(m_ConeHexagon == null))
					{
						return m_ConeHexagon;
					}
					return ConeHexagon();
				case PrimitivePlusType.ConePentagon:
					if (!(m_ConePentagon == null))
					{
						return m_ConePentagon;
					}
					return ConePentagon();
				case PrimitivePlusType.Cross:
					if (!(m_Cross == null))
					{
						return m_Cross;
					}
					return Cross();
				case PrimitivePlusType.Cross2D:
					if (!(m_Cross2D == null))
					{
						return m_Cross2D;
					}
					return Cross2D();
				case PrimitivePlusType.Cube:
					if (!(m_Cube == null))
					{
						return m_Cube;
					}
					return Cube();
				case PrimitivePlusType.CubeCorner:
					if (!(m_CubeCorner == null))
					{
						return m_CubeCorner;
					}
					return CubeCorner();
				case PrimitivePlusType.CubeCornerThin:
					if (!(m_CubeCornerThin == null))
					{
						return m_CubeCornerThin;
					}
					return CubeCornerThin();
				case PrimitivePlusType.CubeEdgeIn:
					if (!(m_CubeEdgeIn == null))
					{
						return m_CubeEdgeIn;
					}
					return CubeEdgeIn();
				case PrimitivePlusType.CubeEdgeOut:
					if (!(m_CubeEdgeOut == null))
					{
						return m_CubeEdgeOut;
					}
					return CubeEdgeOut();
				case PrimitivePlusType.CubeHollow:
					if (!(m_CubeHollow == null))
					{
						return m_CubeHollow;
					}
					return CubeHollow();
				case PrimitivePlusType.CubeHollowThin:
					if (!(m_CubeHollowThin == null))
					{
						return m_CubeHollowThin;
					}
					return CubeHollowThin();
				case PrimitivePlusType.CubeTube:
					if (!(m_CubeTube == null))
					{
						return m_CubeTube;
					}
					return CubeTube();
				case PrimitivePlusType.Cylinder:
					if (!(m_Cylinder == null))
					{
						return m_Cylinder;
					}
					return Cylinder();
				case PrimitivePlusType.CylinderHalf:
					if (!(m_CylinderHalf == null))
					{
						return m_CylinderHalf;
					}
					return CylinderHalf();
				case PrimitivePlusType.CylinderTube:
					if (!(m_CylinderTube == null))
					{
						return m_CylinderTube;
					}
					return CylinderTube();
				case PrimitivePlusType.CylinderTubeThin:
					if (!(m_CylinderTubeThin == null))
					{
						return m_CylinderTubeThin;
					}
					return CylinderTubeThin();
				case PrimitivePlusType.Diamond:
					if (!(m_Diamond == null))
					{
						return m_Diamond;
					}
					return Diamond();
				case PrimitivePlusType.DiamondThick:
					if (!(m_DiamondThick == null))
					{
						return m_DiamondThick;
					}
					return DiamondThick();
				case PrimitivePlusType.Heart:
					if (!(m_Heart == null))
					{
						return m_Heart;
					}
					return Heart();
				case PrimitivePlusType.Heart2D:
					if (!(m_Heart2D == null))
					{
						return m_Heart2D;
					}
					return Heart2D();
				case PrimitivePlusType.Hexagon2D:
					if (!(m_Hexagon2D == null))
					{
						return m_Hexagon2D;
					}
					return Hexagon2D();
				case PrimitivePlusType.Icosphere:
					if (!(m_Icosphere == null))
					{
						return m_Icosphere;
					}
					return Icosphere();
				case PrimitivePlusType.IcosphereSmall:
					if (!(m_IcosphereSmall == null))
					{
						return m_IcosphereSmall;
					}
					return IcosphereSmall();
				case PrimitivePlusType.Plane:
					if (!(m_Plane == null))
					{
						return m_Plane;
					}
					return Plane();
				case PrimitivePlusType.PrismHexagon:
					if (!(m_PrismHexagon == null))
					{
						return m_PrismHexagon;
					}
					return PrismHexagon();
				case PrimitivePlusType.PrismOctagon:
					if (!(m_PrismOctagon == null))
					{
						return m_PrismOctagon;
					}
					return PrismOctagon();
				case PrimitivePlusType.PrismPentagon:
					if (!(m_PrismPentagon == null))
					{
						return m_PrismPentagon;
					}
					return PrismPentagon();
				case PrimitivePlusType.PrismTriangle:
					if (!(m_PrismTriangle == null))
					{
						return m_PrismTriangle;
					}
					return PrismTriangle();
				case PrimitivePlusType.Pyramid:
					if (!(m_Pyramid == null))
					{
						return m_Pyramid;
					}
					return Pyramid();
				case PrimitivePlusType.PyramidCorner:
					if (!(m_PyramidCorner == null))
					{
						return m_PyramidCorner;
					}
					return PyramidCorner();
				case PrimitivePlusType.PyramidTri:
					if (!(m_PyramidTri == null))
					{
						return m_PyramidTri;
					}
					return PyramidTri();
				case PrimitivePlusType.Rhombus2D:
					if (!(m_Rhombus2D == null))
					{
						return m_Rhombus2D;
					}
					return Rhombus2D();
				case PrimitivePlusType.Sphere:
					if (!(m_Sphere == null))
					{
						return m_Sphere;
					}
					return Sphere();
				case PrimitivePlusType.SphereHalf:
					if (!(m_SphereHalf == null))
					{
						return m_SphereHalf;
					}
					return SphereHalf();
				case PrimitivePlusType.Star:
					if (!(m_Star == null))
					{
						return m_Star;
					}
					return Star();
				case PrimitivePlusType.Star2D:
					if (!(m_Star2D == null))
					{
						return m_Star2D;
					}
					return Star2D();
				case PrimitivePlusType.Torus:
					if (!(m_Torus == null))
					{
						return m_Torus;
					}
					return Torus();
				case PrimitivePlusType.TorusHalf:
					if (!(m_TorusHalf == null))
					{
						return m_TorusHalf;
					}
					return TorusHalf();
				case PrimitivePlusType.Triangle2D:
					if (!(m_Triangle2D == null))
					{
						return m_Triangle2D;
					}
					return Triangle2D();
				case PrimitivePlusType.Wedge:
					if (!(m_Wedge == null))
					{
						return m_Wedge;
					}
					return Wedge();
				default:
					return null;
				}
			}

			private static Mesh Circle2D()
			{
				m_Circle2D = Resources.Load<Mesh>("Meshes/Circle2D");
				return m_Circle2D;
			}

			private static Mesh CircleHalf2D()
			{
				m_CircleHalf2D = Resources.Load<Mesh>("Meshes/CircleHalf2D");
				return m_CircleHalf2D;
			}

			private static Mesh Cone()
			{
				m_Cone = Resources.Load<Mesh>("Meshes/Cone");
				return m_Cone;
			}

			private static Mesh ConeHalf()
			{
				m_ConeHalf = Resources.Load<Mesh>("Meshes/ConeHalf");
				return m_ConeHalf;
			}

			private static Mesh ConeHexagon()
			{
				m_ConeHexagon = Resources.Load<Mesh>("Meshes/ConeHexagon");
				return m_ConeHexagon;
			}

			private static Mesh ConePentagon()
			{
				m_ConePentagon = Resources.Load<Mesh>("Meshes/ConePentagon");
				return m_ConePentagon;
			}

			private static Mesh Cross()
			{
				m_Cross = Resources.Load<Mesh>("Meshes/Cross");
				return m_Cross;
			}

			private static Mesh Cross2D()
			{
				m_Cross2D = Resources.Load<Mesh>("Meshes/Cross2D");
				return m_Cross2D;
			}

			private static Mesh Cube()
			{
				m_Cube = Resources.Load<Mesh>("Meshes/Cube");
				return m_Cube;
			}

			private static Mesh CubeCorner()
			{
				m_CubeCorner = Resources.Load<Mesh>("Meshes/CubeCorner");
				return m_CubeCorner;
			}

			private static Mesh CubeCornerThin()
			{
				m_CubeCornerThin = Resources.Load<Mesh>("Meshes/CubeCornerThin");
				return m_CubeCornerThin;
			}

			private static Mesh CubeEdgeIn()
			{
				m_CubeEdgeIn = Resources.Load<Mesh>("Meshes/CubeEdgeIn");
				return m_CubeEdgeIn;
			}

			private static Mesh CubeEdgeOut()
			{
				m_CubeEdgeOut = Resources.Load<Mesh>("Meshes/CubeEdgeOut");
				return m_CubeEdgeOut;
			}

			private static Mesh CubeHollow()
			{
				m_CubeHollow = Resources.Load<Mesh>("Meshes/CubeHollow");
				return m_CubeHollow;
			}

			private static Mesh CubeHollowThin()
			{
				m_CubeHollowThin = Resources.Load<Mesh>("Meshes/CubeHollowThin");
				return m_CubeHollowThin;
			}

			private static Mesh CubeTube()
			{
				m_CubeTube = Resources.Load<Mesh>("Meshes/CubeTube");
				return m_CubeTube;
			}

			private static Mesh Cylinder()
			{
				m_Cylinder = Resources.Load<Mesh>("Meshes/Cylinder");
				return m_Cylinder;
			}

			private static Mesh CylinderHalf()
			{
				m_CylinderHalf = Resources.Load<Mesh>("Meshes/CylinderHalf");
				return m_CylinderHalf;
			}

			private static Mesh CylinderTube()
			{
				m_CylinderTube = Resources.Load<Mesh>("Meshes/CylinderTube");
				return m_CylinderTube;
			}

			private static Mesh CylinderTubeThin()
			{
				m_CylinderTubeThin = Resources.Load<Mesh>("Meshes/CylinderTubeThin");
				return m_CylinderTubeThin;
			}

			private static Mesh Diamond()
			{
				m_Diamond = Resources.Load<Mesh>("Meshes/Diamond");
				return m_Diamond;
			}

			private static Mesh DiamondThick()
			{
				m_DiamondThick = Resources.Load<Mesh>("Meshes/DiamondThick");
				return m_DiamondThick;
			}

			private static Mesh Heart()
			{
				m_Heart = Resources.Load<Mesh>("Meshes/Heart");
				return m_Heart;
			}

			private static Mesh Heart2D()
			{
				m_Heart2D = Resources.Load<Mesh>("Meshes/Heart2D");
				return m_Heart2D;
			}

			private static Mesh Hexagon2D()
			{
				m_Hexagon2D = Resources.Load<Mesh>("Meshes/Hexagon2D");
				return m_Hexagon2D;
			}

			private static Mesh Icosphere()
			{
				m_Icosphere = Resources.Load<Mesh>("Meshes/Icosphere");
				return m_Icosphere;
			}

			private static Mesh IcosphereSmall()
			{
				m_IcosphereSmall = Resources.Load<Mesh>("Meshes/IcosphereSmall");
				return m_IcosphereSmall;
			}

			private static Mesh Plane()
			{
				m_Plane = Resources.Load<Mesh>("Meshes/Plane");
				return m_Plane;
			}

			private static Mesh PrismHexagon()
			{
				m_PrismHexagon = Resources.Load<Mesh>("Meshes/PrismHexagon");
				return m_PrismHexagon;
			}

			private static Mesh PrismOctagon()
			{
				m_PrismOctagon = Resources.Load<Mesh>("Meshes/PrismOctagon");
				return m_PrismOctagon;
			}

			private static Mesh PrismPentagon()
			{
				m_PrismPentagon = Resources.Load<Mesh>("Meshes/PrismPentagon");
				return m_PrismPentagon;
			}

			private static Mesh PrismTriangle()
			{
				m_PrismTriangle = Resources.Load<Mesh>("Meshes/PrismTriangle");
				return m_PrismTriangle;
			}

			private static Mesh Pyramid()
			{
				m_Pyramid = Resources.Load<Mesh>("Meshes/Pyramid");
				return m_Pyramid;
			}

			private static Mesh PyramidCorner()
			{
				m_PyramidCorner = Resources.Load<Mesh>("Meshes/PyramidCorner");
				return m_PyramidCorner;
			}

			private static Mesh PyramidTri()
			{
				m_PyramidTri = Resources.Load<Mesh>("Meshes/PyramidTri");
				return m_PyramidTri;
			}

			private static Mesh Rhombus2D()
			{
				m_Rhombus2D = Resources.Load<Mesh>("Meshes/Rhombus2D");
				return m_Rhombus2D;
			}

			private static Mesh Sphere()
			{
				m_Sphere = Resources.Load<Mesh>("Meshes/Sphere");
				return m_Sphere;
			}

			private static Mesh SphereHalf()
			{
				m_SphereHalf = Resources.Load<Mesh>("Meshes/SphereHalf");
				return m_SphereHalf;
			}

			private static Mesh Star()
			{
				m_Star = Resources.Load<Mesh>("Meshes/Star");
				return m_Star;
			}

			private static Mesh Star2D()
			{
				m_Star2D = Resources.Load<Mesh>("Meshes/Star2D");
				return m_Star2D;
			}

			private static Mesh Torus()
			{
				m_Torus = Resources.Load<Mesh>("Meshes/Torus");
				return m_Torus;
			}

			private static Mesh TorusHalf()
			{
				m_TorusHalf = Resources.Load<Mesh>("Meshes/TorusHalf");
				return m_TorusHalf;
			}

			private static Mesh Triangle2D()
			{
				m_Triangle2D = Resources.Load<Mesh>("Meshes/Triangle2D");
				return m_Triangle2D;
			}

			private static Mesh Wedge()
			{
				m_Wedge = Resources.Load<Mesh>("Meshes/Wedge");
				return m_Wedge;
			}

			private static Mesh GetMesh(Vector3[] vertices, Vector3[] normals, Vector2[] uv, int[] triangles)
			{
				Mesh mesh = new Mesh();
				mesh.vertices = vertices;
				mesh.normals = normals;
				mesh.uv = uv;
				mesh.triangles = triangles;
				mesh.RecalculateBounds();
				mesh.Optimize();
				return mesh;
			}
		}
		public static class PrimitivePlusObject
		{
			public static GameObject CreatePrimitivePlus(PrimitivePlusType type)
			{
				string text = type.ToString();
				GameObject gameObject = new GameObject(text);
				MeshFilter meshFilter = gameObject.AddComponent<MeshFilter>();
				meshFilter.sharedMesh = PrimitivePlusMeshes.GetMeshType(type);
				meshFilter.sharedMesh.name = text;
				Material sharedMaterial = new Material(Shader.Find("Diffuse"));
				gameObject.AddComponent<MeshRenderer>().sharedMaterial = sharedMaterial;
				switch (text)
				{
				case "Cube":
					gameObject.AddComponent<BoxCollider>();
					break;
				case "Sphere":
				case "Heart":
					gameObject.AddComponent<SphereCollider>();
					break;
				default:
					if (meshFilter.sharedMesh.triangles.Length / 3 < 255)
					{
						gameObject.AddComponent<MeshCollider>();
					}
					break;
				}
				gameObject.AddComponent<PrimitivePlusMaterial>();
				return gameObject;
			}
		}
		public enum PrimitivePlusType
		{
			Circle2D,
			CircleHalf2D,
			Cone,
			ConeHalf,
			ConeHexagon,
			ConePentagon,
			Cross,
			Cross2D,
			Cube,
			CubeCorner,
			CubeCornerThin,
			CubeEdgeIn,
			CubeEdgeOut,
			CubeHollow,
			CubeHollowThin,
			CubeTube,
			Cylinder,
			CylinderHalf,
			CylinderTube,
			CylinderTubeThin,
			Diamond,
			DiamondThick,
			Heart,
			Heart2D,
			Hexagon2D,
			Icosphere,
			IcosphereSmall,
			Plane,
			PrismHexagon,
			PrismOctagon,
			PrismPentagon,
			PrismTriangle,
			Pyramid,
			PyramidCorner,
			PyramidTri,
			Rhombus2D,
			Sphere,
			SphereHalf,
			Star,
			Star2D,
			Torus,
			TorusHalf,
			Triangle2D,
			Wedge
		}
	}
	namespace BoundarySystem_Ext
	{
		internal static class Pvr_BoundaryAPI
		{
			private const string LibFileName = "Pvr_UnitySDK";

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			public static extern void Pvr_StartSDKBoundary();

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			public static extern void Pvr_ShutdownSDKBoundary();

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern int Pvr_GetMainSensorStateExt(ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz, ref float vfov, ref float hfov, ref int viewNumber);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern IntPtr Pvr_GetCameraData_Ext();

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			public static extern void Pvr_ResetVrModebyForce();

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern bool Pvr_ResumeBoundaryForSTS();

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern void Pvr_PauseBoundaryForSTS();

			public static int UPvr_GetMainSensorStateExt(ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz, ref float vfov, ref float hfov, ref int viewNumber)
			{
				return Pvr_GetMainSensorStateExt(ref x, ref y, ref z, ref w, ref px, ref py, ref pz, ref vfov, ref hfov, ref viewNumber);
			}

			public static IntPtr UPvr_GetCameraData_Ext()
			{
				_ = IntPtr.Zero;
				return Pvr_GetCameraData_Ext();
			}

			public static bool UPvr_ResumeBoundaryForSTS()
			{
				return Pvr_ResumeBoundaryForSTS();
			}

			public static void UPvr_PauseBoundaryForSTS()
			{
				Pvr_PauseBoundaryForSTS();
			}

			public static IntPtr StructToIntPtr<T>(T info)
			{
				IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(info));
				Marshal.StructureToPtr(info, intPtr, fDeleteOld: true);
				return intPtr;
			}

			public static T IntPtrToStruct<T>(IntPtr info)
			{
				return (T)Marshal.PtrToStructure(info, typeof(T));
			}
		}
		internal static class Pvr_SafeAreaAlgoAPI
		{
			[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
			public delegate void SafeAreaCallback(IntPtr lineCollectionPtr, IntPtr safeAreaRectPtr);

			[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
			public delegate void SafeAreaCallbackShrink(IntPtr lineCollectionPtr, IntPtr safeAreaDetailRectPtr);

			public struct GSAPoint3i
			{
				public int x;

				public int y;

				public int z;
			}

			public struct GSALine
			{
				public IntPtr pointArray;

				public int pointCount;
			}

			public struct GSALineCollection
			{
				public IntPtr lineArray;

				public int lineCount;
			}

			public struct GSALegalData
			{
				public int overMaxRange;

				public int includeBigGrap;

				public int bigGapNum;

				public int centerOut;

				public int removeNarrow;

				public int overMaxRange_more;

				public int validShrinkArea;
			}

			public struct GSARect
			{
				public GSAPoint3i leftup;

				public GSAPoint3i leftdown;

				public GSAPoint3i rightup;

				public GSAPoint3i rightdown;

				public GSAPoint3i center;

				public uint width;

				public uint height;

				public int isLegal;

				public GSALegalData legalData;
			}

			private const string LibFileName = "SafetyArea";

			[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
			private static extern int GSAInit(int width, int height);

			[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
			private static extern int GSAShutDown();

			[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
			private static extern int GSASetCallback(SafeAreaCallback cb);

			[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
			private static extern int GSASetCallbackShrink(SafeAreaCallbackShrink cb);

			[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
			private static extern int GSAUpDateData(IntPtr lineCollectionPtr);

			[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
			private static extern int GSASetConfigFilePath(IntPtr configPath);

			[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
			private static extern bool GSAGetClosedAreaUpdateFlag();

			[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
			private static extern int GSALoadSafetyArea(IntPtr lineCollectionPtr);

			[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
			private static extern double GSABoundaryDetector(ref GSAPoint3i pointPtr);

			[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
			private static extern int GSALoadSafetyArea2(IntPtr lineCollectionPtr, bool isPlayArea);

			[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
			private static extern double GSABoundaryDetector2(ref GSAPoint3i point, bool isPlayArea, ref GSAPoint3i closestPoint, ref GSAPoint3i normalDir);

			public static int Pvr_GSAInit(int width, int height)
			{
				return GSAInit(width, height);
			}

			public static int Pvr_GSASetCallback(SafeAreaCallback cb)
			{
				return GSASetCallback(cb);
			}

			public static int Pvr_GSASetCallbackShrink(SafeAreaCallbackShrink cb)
			{
				return GSASetCallbackShrink(cb);
			}

			public static int Pvr_GSAUpDateData(IntPtr lineCollectionPtr)
			{
				return GSAUpDateData(lineCollectionPtr);
			}

			public static bool Pvr_GSAGetClosedAreaUpdateFlag()
			{
				return GSAGetClosedAreaUpdateFlag();
			}

			public static int Pvr_GSASetConfigFilePath(string configPath)
			{
				int num = -1;
				IntPtr intPtr = Marshal.StringToHGlobalAnsi(configPath);
				num = GSASetConfigFilePath(intPtr);
				Marshal.FreeHGlobal(intPtr);
				return num;
			}

			public static int Pvr_GSALoadSafetyArea(IntPtr lineCollectionPtr)
			{
				return GSALoadSafetyArea(lineCollectionPtr);
			}

			public static double Pvr_GSABoundaryDetector(ref GSAPoint3i point)
			{
				return GSABoundaryDetector(ref point);
			}

			public static int Pvr_GSAShutDown()
			{
				return GSAShutDown();
			}

			public static int Pvr_GSALoadSafetyArea2(IntPtr lineCollectionPtr, bool isPlayArea)
			{
				return GSALoadSafetyArea2(lineCollectionPtr, isPlayArea);
			}

			public static double Pvr_GSABoundaryDetector2(ref GSAPoint3i point, bool isPlayArea, ref GSAPoint3i closestPoint, ref GSAPoint3i normalDir)
			{
				return GSABoundaryDetector2(ref point, isPlayArea, ref closestPoint, ref normalDir);
			}
		}
		public class Pvr_BoundarySystem
		{
			private static Pvr_BoundarySystem instance;

			public const int CameraImageWidth = 1280;

			public const int CameraImageHeight = 400;

			public IntPtr CameraFramePtr = IntPtr.Zero;

			public static Pvr_BoundarySystem Instance
			{
				get
				{
					if (instance == null)
					{
						instance = new Pvr_BoundarySystem();
					}
					return instance;
				}
			}

			public void OpenBoundary()
			{
				Pvr_BoundaryAPI.Pvr_StartSDKBoundary();
			}

			public void CloseBoundary()
			{
				Pvr_BoundaryAPI.Pvr_ShutdownSDKBoundary();
			}

			public void Reset6Dof()
			{
				Pvr_BoundaryAPI.Pvr_ResetVrModebyForce();
			}

			public float[] GetControllerFixedPoseData(int hand)
			{
				float[] result = new float[7] { 0f, 0f, 0f, 1f, 0f, 0f, 0f };
				if (Pvr_ControllerManager.controllerlink != null)
				{
					Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, Pvr_ControllerManager.controllerlink.javaCVClass, "getControllerFixedSensorState", hand);
				}
				result[2] = 0f - result[2];
				result[3] = 0f - result[3];
				return result;
			}
		}
		public class Pvr_SafeAreaAlgoModule
		{
			public struct ExtraInfo
			{
				public bool overMaxRange;

				public bool includeBigGap;

				public int bigGapNum;

				public bool centerOut;

				public bool removeNarrow;

				public bool overMaxRange_more;

				public int validShrinkArea;
			}

			public struct BoundaryPlayerArea
			{
				public Vector3 lowerleft;

				public Vector3 upperleft;

				public Vector3 upperRight;

				public Vector3 lowerRight;

				public Vector3 center;

				public uint width;

				public uint height;

				public bool isLegal;

				public ExtraInfo extraInfo;
			}

			public delegate void BoundarySystemCallback(BoundaryPlayerArea playAreaInfo, List<Vector3> boundaryPoints, List<List<Vector3>> unusedLines);

			public delegate void BoundarySystemCallbackShrink(List<Vector3> rectPoints, List<Vector3> boundaryPoints, List<List<Vector3>> unusedLines);

			private static Pvr_SafeAreaAlgoModule instance;

			private BoundarySystemCallback boundarySystemCallback;

			private BoundarySystemCallbackShrink boundarySystemCallbackShrink;

			public static Pvr_SafeAreaAlgoModule Instance
			{
				get
				{
					if (instance == null)
					{
						instance = new Pvr_SafeAreaAlgoModule();
					}
					return instance;
				}
			}

			public void RegisterCallBack(BoundarySystemCallback callback)
			{
				boundarySystemCallback = callback;
			}

			public void RegisterCallBackShrink(BoundarySystemCallbackShrink callback)
			{
				boundarySystemCallbackShrink = callback;
			}

			public bool Start()
			{
				int num = Pvr_SafeAreaAlgoAPI.Pvr_GSASetCallback(_SafeAreaCallback);
				int num2 = Pvr_SafeAreaAlgoAPI.Pvr_GSASetCallbackShrink(_SafeAreaCallbackShrink);
				if (num != 0 || num2 != 0)
				{
					UnityEngine.Debug.LogError("BoundarySystem register callback failed!");
					return false;
				}
				if (Pvr_SafeAreaAlgoAPI.Pvr_GSAInit(300, 300) != 0)
				{
					UnityEngine.Debug.LogError("BoundarySystem init failed!");
					return false;
				}
				return true;
			}

			public bool CommitNewLineData(bool isFistLine, Vector3[] points)
			{
				Pvr_SafeAreaAlgoAPI.GSALineCollection info = default(Pvr_SafeAreaAlgoAPI.GSALineCollection);
				info.lineCount = 2;
				Pvr_SafeAreaAlgoAPI.GSALine[] array = new Pvr_SafeAreaAlgoAPI.GSALine[2];
				if (isFistLine)
				{
					array[0].pointArray = IntPtr.Zero;
					array[0].pointCount = 0;
				}
				else
				{
					Pvr_SafeAreaAlgoAPI.GSAPoint3i[] arr = new Pvr_SafeAreaAlgoAPI.GSAPoint3i[1]
					{
						new Pvr_SafeAreaAlgoAPI.GSAPoint3i
						{
							x = 0,
							y = 0,
							z = 0
						}
					};
					array[0].pointArray = Marshal.UnsafeAddrOfPinnedArrayElement(arr, 0);
					array[0].pointCount = 1;
				}
				Pvr_SafeAreaAlgoAPI.GSAPoint3i[] array2 = new Pvr_SafeAreaAlgoAPI.GSAPoint3i[points.Length];
				for (int i = 0; i < points.Length; i++)
				{
					Pvr_SafeAreaAlgoAPI.GSAPoint3i gSAPoint3i = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
					gSAPoint3i.x = (int)(points[i].x * 1000f);
					gSAPoint3i.y = (int)(points[i].y * 1000f);
					gSAPoint3i.z = (int)(points[i].z * 1000f);
					array2[i] = gSAPoint3i;
				}
				array[1].pointArray = Marshal.UnsafeAddrOfPinnedArrayElement(array2, 0);
				array[1].pointCount = array2.Length;
				info.lineArray = Marshal.UnsafeAddrOfPinnedArrayElement(array, 0);
				IntPtr intPtr = Pvr_BoundaryAPI.StructToIntPtr(info);
				int num = Pvr_SafeAreaAlgoAPI.Pvr_GSAUpDateData(intPtr);
				Marshal.FreeHGlobal(intPtr);
				if (num != 0)
				{
					UnityEngine.Debug.LogError("BoundarySystem commit new line data failed!");
					return false;
				}
				return true;
			}

			public bool Shutdown()
			{
				if (Pvr_SafeAreaAlgoAPI.Pvr_GSAShutDown() != 0)
				{
					UnityEngine.Debug.LogError("BoundarySystem shutdown failed!");
					return false;
				}
				return true;
			}

			public double QueryDistanceOfPoint(Vector3 point)
			{
				Pvr_SafeAreaAlgoAPI.GSAPoint3i point2 = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
				point2.x = (int)(point.x * 1000f);
				point2.y = (int)(point.y * 1000f);
				point2.z = (int)(point.z * 1000f);
				return Pvr_SafeAreaAlgoAPI.Pvr_GSABoundaryDetector(ref point2) / 1000.0;
			}

			public double QueryDistanceOfPoint(Vector3 point, bool isPlayArea, ref Vector3 closestPoint, ref Vector3 normalDir)
			{
				Pvr_SafeAreaAlgoAPI.GSAPoint3i point2 = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
				point2.x = (int)(point.x * 1000f);
				point2.y = (int)(point.y * 1000f);
				point2.z = (int)(point.z * 1000f);
				Pvr_SafeAreaAlgoAPI.GSAPoint3i closestPoint2 = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
				Pvr_SafeAreaAlgoAPI.GSAPoint3i normalDir2 = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
				double num = Pvr_SafeAreaAlgoAPI.Pvr_GSABoundaryDetector2(ref point2, isPlayArea, ref closestPoint2, ref normalDir2);
				closestPoint.x = (float)closestPoint2.x / 1000f;
				closestPoint.y = (float)closestPoint2.y / 1000f;
				closestPoint.z = (float)closestPoint2.z / 1000f;
				normalDir.x = (float)normalDir2.x / 1000f;
				normalDir.y = (float)normalDir2.y / 1000f;
				normalDir.z = (float)normalDir2.z / 1000f;
				return num / 1000.0;
			}

			[MonoPInvokeCallback(typeof(Pvr_SafeAreaAlgoAPI.SafeAreaCallback))]
			private static void _SafeAreaCallback(IntPtr lineCollectionPtr, IntPtr safeAreaRectPtr)
			{
				if (lineCollectionPtr == IntPtr.Zero || safeAreaRectPtr == IntPtr.Zero)
				{
					UnityEngine.Debug.LogError("BoundarySystem callback is inValid!");
				}
				else
				{
					if (instance.boundarySystemCallback == null)
					{
						return;
					}
					List<Vector3> boundaryPoints = new List<Vector3>();
					List<List<Vector3>> list = new List<List<Vector3>>();
					int num = Marshal.SizeOf(typeof(Pvr_SafeAreaAlgoAPI.GSALine));
					int num2 = Marshal.SizeOf(typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
					Pvr_SafeAreaAlgoAPI.GSALineCollection gSALineCollection = Pvr_BoundaryAPI.IntPtrToStruct<Pvr_SafeAreaAlgoAPI.GSALineCollection>(lineCollectionPtr);
					for (int i = 0; i < gSALineCollection.lineCount; i++)
					{
						Pvr_SafeAreaAlgoAPI.GSALine gSALine = (Pvr_SafeAreaAlgoAPI.GSALine)Marshal.PtrToStructure(new IntPtr(gSALineCollection.lineArray.ToInt64() + num * i), typeof(Pvr_SafeAreaAlgoAPI.GSALine));
						List<Vector3> list2 = new List<Vector3>();
						for (int j = 0; j < gSALine.pointCount; j++)
						{
							Pvr_SafeAreaAlgoAPI.GSAPoint3i gSAPoint3i = (Pvr_SafeAreaAlgoAPI.GSAPoint3i)Marshal.PtrToStructure(new IntPtr(gSALine.pointArray.ToInt64() + num2 * j), typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
							list2.Add(new Vector3((float)gSAPoint3i.x / 1000f, (float)gSAPoint3i.y / 1000f, (float)gSAPoint3i.z / 1000f));
						}
						if (i == 0)
						{
							boundaryPoints = list2;
						}
						else
						{
							list.Add(list2);
						}
					}
					Pvr_SafeAreaAlgoAPI.GSARect gSARect = Pvr_BoundaryAPI.IntPtrToStruct<Pvr_SafeAreaAlgoAPI.GSARect>(safeAreaRectPtr);
					BoundaryPlayerArea playAreaInfo = default(BoundaryPlayerArea);
					playAreaInfo.lowerleft = new Vector3((float)gSARect.leftup.x / 1000f, (float)gSARect.leftup.y / 1000f, (float)gSARect.leftup.z / 1000f);
					playAreaInfo.upperleft = new Vector3((float)gSARect.leftdown.x / 1000f, (float)gSARect.leftdown.y / 1000f, (float)gSARect.leftdown.z / 1000f);
					playAreaInfo.upperRight = new Vector3((float)gSARect.rightdown.x / 1000f, (float)gSARect.rightdown.y / 1000f, (float)gSARect.rightdown.z / 1000f);
					playAreaInfo.lowerRight = new Vector3((float)gSARect.rightup.x / 1000f, (float)gSARect.rightup.y / 1000f, (float)gSARect.rightup.z / 1000f);
					playAreaInfo.center = new Vector3((float)gSARect.center.x / 1000f, (float)gSARect.center.y / 1000f, (float)gSARect.center.z / 1000f);
					playAreaInfo.width = gSARect.width;
					playAreaInfo.height = gSARect.height;
					playAreaInfo.isLegal = ((gSARect.isLegal != 0) ? true : false);
					playAreaInfo.extraInfo.overMaxRange = ((gSARect.legalData.overMaxRange != 0) ? true : false);
					playAreaInfo.extraInfo.includeBigGap = ((gSARect.legalData.includeBigGrap != 0) ? true : false);
					playAreaInfo.extraInfo.bigGapNum = gSARect.legalData.bigGapNum;
					playAreaInfo.extraInfo.centerOut = ((gSARect.legalData.centerOut != 0) ? true : false);
					playAreaInfo.extraInfo.removeNarrow = ((gSARect.legalData.removeNarrow != 0) ? true : false);
					playAreaInfo.extraInfo.overMaxRange_more = ((gSARect.legalData.overMaxRange_more != 0) ? true : false);
					playAreaInfo.extraInfo.validShrinkArea = gSARect.legalData.validShrinkArea;
					instance.boundarySystemCallback(playAreaInfo, boundaryPoints, list);
				}
			}

			[MonoPInvokeCallback(typeof(Pvr_SafeAreaAlgoAPI.SafeAreaCallbackShrink))]
			private static void _SafeAreaCallbackShrink(IntPtr lineCollectionPtr, IntPtr safeAreaDetailRectPtr)
			{
				if (lineCollectionPtr == IntPtr.Zero || safeAreaDetailRectPtr == IntPtr.Zero)
				{
					UnityEngine.Debug.LogError("BoundarySystem callback is inValid!");
				}
				else
				{
					if (instance.boundarySystemCallbackShrink == null)
					{
						return;
					}
					List<Vector3> boundaryPoints = new List<Vector3>();
					List<List<Vector3>> list = new List<List<Vector3>>();
					int num = Marshal.SizeOf(typeof(Pvr_SafeAreaAlgoAPI.GSALine));
					int num2 = Marshal.SizeOf(typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
					Pvr_SafeAreaAlgoAPI.GSALineCollection gSALineCollection = Pvr_BoundaryAPI.IntPtrToStruct<Pvr_SafeAreaAlgoAPI.GSALineCollection>(lineCollectionPtr);
					for (int i = 0; i < gSALineCollection.lineCount; i++)
					{
						Pvr_SafeAreaAlgoAPI.GSALine gSALine = (Pvr_SafeAreaAlgoAPI.GSALine)Marshal.PtrToStructure(new IntPtr(gSALineCollection.lineArray.ToInt64() + num * i), typeof(Pvr_SafeAreaAlgoAPI.GSALine));
						List<Vector3> list2 = new List<Vector3>();
						for (int j = 0; j < gSALine.pointCount; j++)
						{
							Pvr_SafeAreaAlgoAPI.GSAPoint3i gSAPoint3i = (Pvr_SafeAreaAlgoAPI.GSAPoint3i)Marshal.PtrToStructure(new IntPtr(gSALine.pointArray.ToInt64() + num2 * j), typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
							list2.Add(new Vector3((float)gSAPoint3i.x / 1000f, (float)gSAPoint3i.y / 1000f, (float)gSAPoint3i.z / 1000f));
						}
						if (i == 0)
						{
							boundaryPoints = list2;
						}
						else
						{
							list.Add(list2);
						}
					}
					List<Vector3> list3 = new List<Vector3>();
					Pvr_SafeAreaAlgoAPI.GSALineCollection gSALineCollection2 = Pvr_BoundaryAPI.IntPtrToStruct<Pvr_SafeAreaAlgoAPI.GSALineCollection>(safeAreaDetailRectPtr);
					for (int k = 0; k < gSALineCollection2.lineCount; k++)
					{
						Pvr_SafeAreaAlgoAPI.GSALine gSALine2 = (Pvr_SafeAreaAlgoAPI.GSALine)Marshal.PtrToStructure(new IntPtr(gSALineCollection2.lineArray.ToInt64() + num * k), typeof(Pvr_SafeAreaAlgoAPI.GSALine));
						for (int l = 0; l < gSALine2.pointCount; l++)
						{
							Pvr_SafeAreaAlgoAPI.GSAPoint3i gSAPoint3i2 = (Pvr_SafeAreaAlgoAPI.GSAPoint3i)Marshal.PtrToStructure(new IntPtr(gSALine2.pointArray.ToInt64() + num2 * l), typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
							list3.Add(new Vector3((float)gSAPoint3i2.x / 1000f, (float)gSAPoint3i2.y / 1000f, (float)gSAPoint3i2.z / 1000f));
						}
					}
					instance.boundarySystemCallbackShrink(list3, boundaryPoints, list);
				}
			}
		}
	}
	namespace Pvr_UnitySDKAPI
	{
		public class PvrControllerKey
		{
			public bool State;

			public bool PressedDown;

			public bool PressedUp;

			public bool LongPressed;

			public bool Click;

			public bool Touch;

			public bool TouchDown;

			public bool TouchUp;

			public PvrControllerKey()
			{
				State = false;
				PressedDown = false;
				PressedUp = false;
				LongPressed = false;
				Click = false;
				Touch = false;
				TouchDown = false;
				TouchUp = false;
			}
		}
		public class ControllerHand
		{
			public PvrControllerKey App;

			public PvrControllerKey Touch;

			public PvrControllerKey Home;

			public PvrControllerKey VolumeDown;

			public PvrControllerKey VolumeUp;

			public PvrControllerKey Trigger;

			public PvrControllerKey X;

			public PvrControllerKey Y;

			public PvrControllerKey A;

			public PvrControllerKey B;

			public PvrControllerKey Left;

			public PvrControllerKey Right;

			public PvrControllerKey Thumbrest;

			public Vector2 TouchPadPosition;

			public int TriggerNum;

			public int GripValue;

			public Quaternion Rotation;

			public Vector3 Position;

			public int Battery;

			public ControllerState ConnectState;

			public SwipeDirection SwipeDirection;

			public TouchPadClick TouchPadClick;

			public bool isShowBoundary;

			public ControllerHand()
			{
				App = new PvrControllerKey();
				Touch = new PvrControllerKey();
				Home = new PvrControllerKey();
				VolumeDown = new PvrControllerKey();
				VolumeUp = new PvrControllerKey();
				Trigger = new PvrControllerKey();
				A = new PvrControllerKey();
				B = new PvrControllerKey();
				X = new PvrControllerKey();
				Y = new PvrControllerKey();
				Left = new PvrControllerKey();
				Right = new PvrControllerKey();
				Thumbrest = new PvrControllerKey();
				TouchPadPosition = default(Vector2);
				Rotation = default(Quaternion);
				Position = default(Vector3);
				Battery = 0;
				TriggerNum = 0;
				GripValue = 0;
				ConnectState = ControllerState.Error;
				SwipeDirection = SwipeDirection.No;
				TouchPadClick = TouchPadClick.No;
				isShowBoundary = false;
			}
		}
		public enum ControllerState
		{
			Error = -1,
			DisConnected,
			Connected
		}
		public enum Pvr_KeyCode
		{
			APP = 1,
			TOUCHPAD,
			HOME,
			VOLUMEUP,
			VOLUMEDOWN,
			TRIGGER,
			A,
			B,
			X,
			Y,
			Left,
			Right,
			Thumbrest
		}
		public enum SwipeDirection
		{
			No,
			SwipeUp,
			SwipeDown,
			SwipeLeft,
			SwipeRight
		}
		public enum TouchPadClick
		{
			No,
			ClickUp,
			ClickDown,
			ClickLeft,
			ClickRight
		}
		[StructLayout(LayoutKind.Sequential, Size = 1)]
		public struct Controller
		{
			public const string LibFileName = "Pvr_UnitySDK";

			public static Vector2 UPvr_GetTouchPadPosition(int hand)
			{
				return hand switch
				{
					0 => Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition, 
					1 => Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition, 
					_ => new Vector2(0f, 0f), 
				};
			}

			public static float UPvr_GetAxis1D(int hand, Pvr_KeyCode key)
			{
				return hand switch
				{
					0 => key switch
					{
						Pvr_KeyCode.TRIGGER => (float)Pvr_ControllerManager.controllerlink.Controller0.TriggerNum / 255f, 
						Pvr_KeyCode.Left => (float)Pvr_ControllerManager.controllerlink.Controller0.GripValue / 255f, 
						_ => 0f, 
					}, 
					1 => key switch
					{
						Pvr_KeyCode.TRIGGER => (float)Pvr_ControllerManager.controllerlink.Controller1.TriggerNum / 255f, 
						Pvr_KeyCode.Right => (float)Pvr_ControllerManager.controllerlink.Controller1.GripValue / 255f, 
						_ => 0f, 
					}, 
					_ => 0f, 
				};
			}

			public static Vector2 UPvr_GetAxis2D(int hand)
			{
				switch (hand)
				{
				case 0:
					if (Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition != Vector2.zero)
					{
						return new Vector2(Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.x / 128f - 1f, Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.y / 128f - 1f);
					}
					return Vector2.zero;
				case 1:
					if (Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition != Vector2.zero)
					{
						return new Vector2(Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.x / 128f - 1f, Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.y / 128f - 1f);
					}
					return Vector2.zero;
				default:
					return Vector2.zero;
				}
			}

			public static ControllerState UPvr_GetControllerState(int hand)
			{
				return hand switch
				{
					0 => (ControllerState)Convert.ToInt16(Pvr_ControllerManager.controllerlink.controller0Connected), 
					1 => (ControllerState)Convert.ToInt16(Pvr_ControllerManager.controllerlink.controller1Connected), 
					_ => ControllerState.Error, 
				};
			}

			public static Quaternion UPvr_GetControllerQUA(int hand)
			{
				return hand switch
				{
					0 => Pvr_ControllerManager.controllerlink.Controller0.Rotation, 
					1 => Pvr_ControllerManager.controllerlink.Controller1.Rotation, 
					_ => new Quaternion(0f, 0f, 0f, 1f), 
				};
			}

			public static Vector3 UPvr_GetControllerPOS(int hand)
			{
				return hand switch
				{
					0 => Pvr_ControllerManager.controllerlink.Controller0.Position, 
					1 => Pvr_ControllerManager.controllerlink.Controller1.Position, 
					_ => new Vector3(0f, 0f, 0f), 
				};
			}

			public static int UPvr_GetControllerTriggerValue(int hand)
			{
				return hand switch
				{
					0 => Pvr_ControllerManager.controllerlink.Controller0.TriggerNum, 
					1 => Pvr_ControllerManager.controllerlink.Controller1.TriggerNum, 
					_ => 0, 
				};
			}

			public static int UPvr_GetControllerPower(int hand)
			{
				return hand switch
				{
					0 => Pvr_ControllerManager.controllerlink.Controller0.Battery, 
					1 => Pvr_ControllerManager.controllerlink.Controller1.Battery, 
					_ => 0, 
				};
			}

			public static SwipeDirection UPvr_GetSwipeDirection(int hand)
			{
				return hand switch
				{
					0 => Pvr_ControllerManager.controllerlink.Controller0.SwipeDirection, 
					1 => Pvr_ControllerManager.controllerlink.Controller1.SwipeDirection, 
					_ => SwipeDirection.No, 
				};
			}

			public static TouchPadClick UPvr_GetTouchPadClick(int hand)
			{
				return hand switch
				{
					0 => Pvr_ControllerManager.controllerlink.Controller0.TouchPadClick, 
					1 => Pvr_ControllerManager.controllerlink.Controller1.TouchPadClick, 
					_ => TouchPadClick.No, 
				};
			}

			public static bool UPvr_GetKey(int hand, Pvr_KeyCode key)
			{
				return hand switch
				{
					0 => key switch
					{
						Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller0.App.State, 
						Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller0.Home.State, 
						Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.State, 
						Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.State, 
						Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.State, 
						Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.State, 
						Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.State, 
						Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.State, 
						Pvr_KeyCode.Left => Pvr_ControllerManager.controllerlink.Controller0.Left.State, 
						_ => false, 
					}, 
					1 => key switch
					{
						Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller1.App.State, 
						Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller1.Home.State, 
						Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.State, 
						Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.State, 
						Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.State, 
						Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.State, 
						Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.State, 
						Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.State, 
						Pvr_KeyCode.Right => Pvr_ControllerManager.controllerlink.Controller1.Right.State, 
						_ => false, 
					}, 
					_ => false, 
				};
			}

			public static bool UPvr_GetKeyDown(int hand, Pvr_KeyCode key)
			{
				return hand switch
				{
					0 => key switch
					{
						Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller0.App.PressedDown, 
						Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller0.Home.PressedDown, 
						Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.PressedDown, 
						Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.PressedDown, 
						Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.PressedDown, 
						Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.PressedDown, 
						Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.PressedDown, 
						Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.PressedDown, 
						Pvr_KeyCode.Left => Pvr_ControllerManager.controllerlink.Controller0.Left.PressedDown, 
						_ => false, 
					}, 
					1 => key switch
					{
						Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller1.App.PressedDown, 
						Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller1.Home.PressedDown, 
						Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.PressedDown, 
						Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.PressedDown, 
						Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.PressedDown, 
						Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.PressedDown, 
						Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.PressedDown, 
						Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.PressedDown, 
						Pvr_KeyCode.Right => Pvr_ControllerManager.controllerlink.Controller1.Right.PressedDown, 
						_ => false, 
					}, 
					_ => false, 
				};
			}

			public static bool UPvr_GetKeyUp(int hand, Pvr_KeyCode key)
			{
				return hand switch
				{
					0 => key switch
					{
						Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller0.App.PressedUp, 
						Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller0.Home.PressedUp, 
						Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.PressedUp, 
						Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.PressedUp, 
						Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.PressedUp, 
						Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.PressedUp, 
						Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.PressedUp, 
						Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.PressedUp, 
						Pvr_KeyCode.Left => Pvr_ControllerManager.controllerlink.Controller0.Left.PressedUp, 
						_ => false, 
					}, 
					1 => key switch
					{
						Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller1.App.PressedUp, 
						Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller1.Home.PressedUp, 
						Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.PressedUp, 
						Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.PressedUp, 
						Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.PressedUp, 
						Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.PressedUp, 
						Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.PressedUp, 
						Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.PressedUp, 
						Pvr_KeyCode.Right => Pvr_ControllerManager.controllerlink.Controller1.Right.PressedUp, 
						_ => false, 
					}, 
					_ => false, 
				};
			}

			public static bool UPvr_GetTouch(int hand, Pvr_KeyCode key)
			{
				return hand switch
				{
					0 => key switch
					{
						Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.Touch, 
						Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.Touch, 
						Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.Touch, 
						Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.Touch, 
						Pvr_KeyCode.Thumbrest => Pvr_ControllerManager.controllerlink.Controller0.Thumbrest.Touch, 
						_ => false, 
					}, 
					1 => key switch
					{
						Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.Touch, 
						Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.Touch, 
						Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.Touch, 
						Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.Touch, 
						Pvr_KeyCode.Thumbrest => Pvr_ControllerManager.controllerlink.Controller1.Thumbrest.Touch, 
						_ => false, 
					}, 
					_ => false, 
				};
			}

			public static bool UPvr_GetTouchDown(int hand, Pvr_KeyCode key)
			{
				return hand switch
				{
					0 => key switch
					{
						Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.TouchDown, 
						Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.TouchDown, 
						Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.TouchDown, 
						Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.TouchDown, 
						Pvr_KeyCode.Thumbrest => Pvr_ControllerManager.controllerlink.Controller0.Thumbrest.TouchDown, 
						_ => false, 
					}, 
					1 => key switch
					{
						Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.TouchDown, 
						Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.TouchDown, 
						Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.TouchDown, 
						Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.TouchDown, 
						Pvr_KeyCode.Thumbrest => Pvr_ControllerManager.controllerlink.Controller1.Thumbrest.TouchDown, 
						_ => false, 
					}, 
					_ => false, 
				};
			}

			public static bool UPvr_GetTouchUp(int hand, Pvr_KeyCode key)
			{
				return hand switch
				{
					0 => key switch
					{
						Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.TouchUp, 
						Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.TouchUp, 
						Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.TouchUp, 
						Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.TouchUp, 
						Pvr_KeyCode.Thumbrest => Pvr_ControllerManager.controllerlink.Controller0.Thumbrest.TouchUp, 
						_ => false, 
					}, 
					1 => key switch
					{
						Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.TouchUp, 
						Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.TouchUp, 
						Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.TouchUp, 
						Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.TouchUp, 
						Pvr_KeyCode.Thumbrest => Pvr_ControllerManager.controllerlink.Controller1.Thumbrest.TouchUp, 
						_ => false, 
					}, 
					_ => false, 
				};
			}

			public static bool UPvr_GetKeyClick(int hand, Pvr_KeyCode key)
			{
				return hand switch
				{
					0 => key switch
					{
						Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller0.App.Click, 
						Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller0.Home.Click, 
						Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.Click, 
						Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.Click, 
						Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.Click, 
						Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.Click, 
						Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.Click, 
						Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.Click, 
						Pvr_KeyCode.Left => Pvr_ControllerManager.controllerlink.Controller0.Left.Click, 
						_ => false, 
					}, 
					1 => key switch
					{
						Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller1.App.Click, 
						Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller1.Home.Click, 
						Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.Click, 
						Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.Click, 
						Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.Click, 
						Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.Click, 
						Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.Click, 
						Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.Click, 
						Pvr_KeyCode.Right => Pvr_ControllerManager.controllerlink.Controller1.Right.Click, 
						_ => false, 
					}, 
					_ => false, 
				};
			}

			public static bool UPvr_GetKeyLongPressed(int hand, Pvr_KeyCode key)
			{
				return hand switch
				{
					0 => key switch
					{
						Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller0.App.LongPressed, 
						Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller0.Home.LongPressed, 
						Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.LongPressed, 
						Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.LongPressed, 
						Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.LongPressed, 
						Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.LongPressed, 
						Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.LongPressed, 
						Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.LongPressed, 
						Pvr_KeyCode.Left => Pvr_ControllerManager.controllerlink.Controller0.Left.LongPressed, 
						_ => false, 
					}, 
					1 => key switch
					{
						Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller1.App.LongPressed, 
						Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller1.Home.LongPressed, 
						Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.LongPressed, 
						Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.LongPressed, 
						Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.LongPressed, 
						Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.LongPressed, 
						Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.LongPressed, 
						Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.LongPressed, 
						Pvr_KeyCode.Right => Pvr_ControllerManager.controllerlink.Controller1.Right.LongPressed, 
						_ => false, 
					}, 
					_ => false, 
				};
			}

			public static bool UPvr_IsTouching(int hand)
			{
				switch (hand)
				{
				case 0:
					if (!(Math.Abs(Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.x) > 0f))
					{
						return Math.Abs(Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.y) > 0f;
					}
					return true;
				case 1:
					if (!(Math.Abs(Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.x) > 0f))
					{
						return Math.Abs(Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.y) > 0f;
					}
					return true;
				default:
					return false;
				}
			}

			public static void UPvr_SetHandNess(Pvr_Controller.UserHandNess hand)
			{
				if (Pvr_ControllerManager.controllerlink.getHandness() != (int)hand)
				{
					Pvr_ControllerManager.controllerlink.setHandness((int)hand);
				}
			}

			public static Pvr_Controller.UserHandNess UPvr_GetHandNess()
			{
				return Pvr_ControllerManager.controllerlink.handness;
			}

			public static int UPvr_GetPreferenceDevice()
			{
				int trackingmode = Pvr_ControllerManager.controllerlink.trackingmode;
				int systemProp = Pvr_ControllerManager.controllerlink.systemProp;
				if (trackingmode == 0 || trackingmode == 1 || ((trackingmode == 3 || trackingmode == 5 || trackingmode == 6) && (systemProp == 1 || systemProp == 3)))
				{
					return 1;
				}
				return 2;
			}

			public static bool UPvr_IsEnbleTrigger()
			{
				return Pvr_ControllerManager.controllerlink.IsEnbleTrigger();
			}

			public static int UPvr_GetDeviceType()
			{
				return Pvr_ControllerManager.controllerlink.controllerType;
			}

			public static int UPvr_GetMainHandNess()
			{
				return Pvr_ControllerManager.controllerlink.mainHandID;
			}

			public static void UPvr_SetMainHandNess(int hand)
			{
				Pvr_ControllerManager.controllerlink.SetMainController(hand);
			}

			public static int UPvr_GetControllerAbility(int hand)
			{
				return Pvr_ControllerManager.controllerlink.GetControllerAbility(hand);
			}

			public static void UPvr_VibrateNeo2Controller(float strength, int time, int hand)
			{
				Pvr_ControllerManager.controllerlink.VibrateNeo2Controller(strength, time, hand);
			}

			public static int UPvr_GetControllerBindingState(int hand)
			{
				return Pvr_ControllerManager.controllerlink.GetControllerBindingState(hand);
			}

			public static Vector3 UPvr_GetVelocity(int hand)
			{
				return Pvr_ControllerManager.controllerlink.GetVelocity(hand);
			}

			public static Vector3 UPvr_GetAngularVelocity(int hand)
			{
				return Pvr_ControllerManager.controllerlink.GetAngularVelocity(hand);
			}

			public static Vector3 UPvr_GetAcceleration(int hand)
			{
				return Pvr_ControllerManager.controllerlink.GetAcceleration(hand);
			}

			public static void UPvr_ScanController()
			{
				Pvr_ControllerManager.controllerlink.StartScan();
			}

			public static void UPvr_StopScanController()
			{
				Pvr_ControllerManager.controllerlink.StopScan();
			}

			public static void UPvr_ConnectController(string mac)
			{
				if (mac != "")
				{
					Pvr_ControllerManager.controllerlink.hummingBirdMac = mac;
				}
				Pvr_ControllerManager.controllerlink.ConnectBLE();
			}

			public static void UPvr_DisConnectController()
			{
				Pvr_ControllerManager.controllerlink.DisConnectBLE();
			}

			public static void UPvr_ResetController(int hand)
			{
				Pvr_ControllerManager.controllerlink.ResetController(hand);
			}

			public static string UPvr_GetControllerVersion()
			{
				return Pvr_ControllerManager.controllerlink.GetControllerVersion();
			}

			public static void UPvr_GetDeviceVersion(int deviceType)
			{
				Pvr_ControllerManager.controllerlink.GetDeviceVersion(deviceType);
			}

			public static void UPvr_GetControllerSnCode(int controllerSerialNum)
			{
				Pvr_ControllerManager.controllerlink.GetControllerSnCode(controllerSerialNum);
			}

			public static void UPvr_SetControllerUnbind(int controllerSerialNum)
			{
				Pvr_ControllerManager.controllerlink.SetControllerUnbind(controllerSerialNum);
			}

			public static void UPvr_SetStationRestart()
			{
				Pvr_ControllerManager.controllerlink.SetStationRestart();
			}

			public static void UPvr_StartStationOtaUpdate()
			{
				Pvr_ControllerManager.controllerlink.StartStationOtaUpdate();
			}

			public static void UPvr_StartControllerOtaUpdate(int mode, int controllerSerialNum)
			{
				Pvr_ControllerManager.controllerlink.StartControllerOtaUpdate(mode, controllerSerialNum);
			}

			public static void UPvr_EnterPairMode(int controllerSerialNum)
			{
				Pvr_ControllerManager.controllerlink.EnterPairMode(controllerSerialNum);
			}

			public static void UPvr_SetControllerShutdown(int controllerSerialNum)
			{
				Pvr_ControllerManager.controllerlink.SetControllerShutdown(controllerSerialNum);
			}

			public static int UPvr_GetStationPairState()
			{
				return Pvr_ControllerManager.controllerlink.GetStationPairState();
			}

			public static int UPvr_GetStationOtaUpdateProgress()
			{
				return Pvr_ControllerManager.controllerlink.GetStationOtaUpdateProgress();
			}

			public static int UPvr_GetControllerOtaUpdateProgress()
			{
				return Pvr_ControllerManager.controllerlink.GetControllerOtaUpdateProgress();
			}

			public static void UPvr_GetControllerVersionAndSN(int controllerSerialNum)
			{
				Pvr_ControllerManager.controllerlink.GetControllerVersionAndSN(controllerSerialNum);
			}

			public static void UPvr_GetControllerUniqueID()
			{
				Pvr_ControllerManager.controllerlink.GetControllerUniqueID();
			}

			public void UPvr_InterruptStationPairMode()
			{
				Pvr_ControllerManager.controllerlink.InterruptStationPairMode();
			}

			public void UPvr_StartCV2PairingMode(int deviceType)
			{
				Pvr_ControllerManager.controllerlink.StartCV2PairingMode(deviceType);
			}

			public void UPvr_StopCV2PairingMode(int deviceType)
			{
				Pvr_ControllerManager.controllerlink.StopCV2PairingMode(deviceType);
			}

			public static void UPvr_SetArmModelParameters(int hand, int gazeType, float elbowHeight, float elbowDepth, float pointerTiltAngle)
			{
				Pvr_SetArmModelParameters(hand, gazeType, elbowHeight, elbowDepth, pointerTiltAngle);
			}

			public static void UPvr_CalcArmModelParameters(float[] headOrientation, float[] controllerOrientation, float[] controllerPrimary)
			{
				Pvr_CalcArmModelParameters(headOrientation, controllerOrientation, controllerPrimary);
			}

			public static void UPvr_GetPointerPose(float[] rotation, float[] position)
			{
				Pvr_GetPointerPose(rotation, position);
			}

			public static void UPvr_GetElbowPose(float[] rotation, float[] position)
			{
				Pvr_GetElbowPose(rotation, position);
			}

			public static void UPvr_GetWristPose(float[] rotation, float[] position)
			{
				Pvr_GetWristPose(rotation, position);
			}

			public static void UPvr_GetShoulderPose(float[] rotation, float[] position)
			{
				Pvr_GetShoulderPose(rotation, position);
			}

			public static void UPvr_IsEnbleHomeKey(bool state)
			{
				Pvr_ControllerManager.controllerlink.setIsEnbleHomeKey(state);
			}

			public static void UPvr_SwitchHomeKey(bool state)
			{
				Pvr_ControllerManager.controllerlink.SwitchHomeKey(state);
			}

			public static int UPvr_GetControllerSensorStatus(int id)
			{
				return Pvr_ControllerManager.controllerlink.getControllerSensorStatus(id);
			}

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern void Pvr_CalcArmModelParameters(float[] headOrientation, float[] controllerOrientation, float[] gyro);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern void Pvr_GetPointerPose(float[] rotation, float[] position);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern void Pvr_GetElbowPose(float[] rotation, float[] position);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern void Pvr_GetWristPose(float[] rotation, float[] position);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern void Pvr_GetShoulderPose(float[] rotation, float[] position);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern void Pvr_SetArmModelParameters(int hand, int gazeType, float elbowHeight, float elbowDepth, float pointerTiltAngle);
		}
		public enum ControllerVariety
		{
			Controller0,
			Controller1
		}
		public enum ControllerDevice
		{
			Goblin,
			Neo,
			G2,
			Neo2,
			Neo3,
			NewController
		}
		public enum PBS_SystemInfoEnum
		{
			ELECTRIC_QUANTITY,
			PUI_VERSION,
			EQUIPMENT_MODEL,
			EQUIPMENT_SN,
			CUSTOMER_SN,
			INTERNAL_STORAGE_SPACE_OF_THE_DEVICE,
			DEVICE_BLUETOOTH_STATUS,
			BLUETOOTH_NAME_CONNECTED,
			BLUETOOTH_MAC_ADDRESS,
			DEVICE_WIFI_STATUS,
			WIFI_NAME_CONNECTED,
			WLAN_MAC_ADDRESS,
			DEVICE_IP
		}
		public enum PBS_DeviceControlEnum
		{
			DEVICE_CONTROL_REBOOT,
			DEVICE_CONTROL_SHUTDOWN
		}
		public enum PBS_PackageControlEnum
		{
			PACKAGE_SILENCE_INSTALL,
			PACKAGE_SILENCE_UNINSTALL
		}
		public enum PBS_SwitchEnum
		{
			S_ON,
			S_OFF
		}
		public enum PBS_HomeEventEnum
		{
			SINGLE_CLICK,
			DOUBLE_CLICK,
			LONG_PRESS
		}
		public enum PBS_HomeFunctionEnum
		{
			VALUE_HOME_GO_TO_SETTING,
			VALUE_HOME_BACK,
			VALUE_HOME_RECENTER,
			VALUE_HOME_OPEN_APP,
			VALUE_HOME_DISABLE,
			VALUE_HOME_GO_TO_HOME,
			VALUE_HOME_SEND_BROADCAST,
			VALUE_HOME_CLEAN_MEMORY
		}
		public enum PBS_ScreenOffDelayTimeEnum
		{
			THREE = 3,
			TEN = 10,
			THIRTY = 30,
			SIXTY = 60,
			THREE_HUNDRED = 300,
			SIX_HUNDRED = 600,
			NEVER = -1
		}
		public enum PBS_SleepDelayTimeEnum
		{
			FIFTEEN = 15,
			THIRTY = 30,
			SIXTY = 60,
			THREE_HUNDRED = 300,
			SIX_HUNDRED = 600,
			ONE_THOUSAND_AND_EIGHT_HUNDRED = 1800,
			NEVER = -1
		}
		public enum PBS_SystemFunctionSwitchEnum
		{
			SFS_USB,
			SFS_AUTOSLEEP,
			SFS_SCREENON_CHARGING,
			SFS_OTG_CHARGING,
			SFS_RETURN_MENU_IN_2DMODE,
			SFS_COMBINATION_KEY,
			SFS_CALIBRATION_WITH_POWER_ON,
			SFS_SYSTEM_UPDATE,
			SFS_CAST_SERVICE,
			SFS_EYE_PROTECTION,
			SFS_SECURITY_ZONE_PERMANENTLY,
			SFS_GLOBAL_CALIBRATION,
			SFS_Auto_Calibration,
			SFS_USB_BOOT
		}
		public enum PBS_USBConfigModeEnum
		{
			MTP,
			CHARGE
		}
		public struct ToBService
		{
			public static Action<bool> BoolCallback;

			public static Action<int> IntCallback;

			public static Action<long> LongCallback;

			private static AndroidJavaClass unityPlayer;

			private static AndroidJavaObject currentActivity;

			private static AndroidJavaObject tobHelper;

			private static AndroidJavaClass tobHelperClass;

			public static void UPvr_InitToBService()
			{
				tobHelperClass = new AndroidJavaClass("com.pvr.tobservice.ToBServiceHelper");
				tobHelper = tobHelperClass.CallStatic<AndroidJavaObject>("getInstance", Array.Empty<object>());
				unityPlayer = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
				currentActivity = unityPlayer.GetStatic<AndroidJavaObject>("currentActivity");
			}

			public static void UPvr_SetUnityObjectName(string obj)
			{
				System.UPvr_CallMethod(tobHelper, "setUnityObjectName", obj);
			}

			public static void UPvr_BindToBService()
			{
				System.UPvr_CallMethod(tobHelper, "bindTobService", currentActivity);
			}

			public static void UPvr_UnBindToBService()
			{
				System.UPvr_CallMethod(tobHelper, "unBindTobService", currentActivity);
			}

			private static AndroidJavaObject GetEnumType(Enum enumType)
			{
				return new AndroidJavaClass("com.pvr.tobservice.enums" + enumType.GetType().ToString().Replace("Pvr_UnitySDKAPI", "")).GetStatic<AndroidJavaObject>(enumType.ToString());
			}

			public static string UPvr_StateGetDeviceInfo(PBS_SystemInfoEnum type)
			{
				string result = "";
				System.UPvr_CallMethod(ref result, tobHelper, "pbsStateGetDeviceInfo", GetEnumType(type), 0);
				return result;
			}

			public static void UPvr_ControlSetDeviceAction(PBS_DeviceControlEnum deviceControl, Action<int> callback)
			{
				if (callback != null)
				{
					IntCallback = callback;
				}
				System.UPvr_CallMethod(tobHelper, "pbsControlSetDeviceAction", GetEnumType(deviceControl), null);
			}

			public static void UPvr_ControlAPPManger(PBS_PackageControlEnum packageControl, string path, Action<int> callback)
			{
				if (callback != null)
				{
					IntCallback = callback;
				}
				System.UPvr_CallMethod(tobHelper, "pbsControlAPPManger", GetEnumType(packageControl), path, 0, null);
			}

			public static void UPvr_ControlSetAutoConnectWIFI(string ssid, string pwd, Action<bool> callback)
			{
				if (callback != null)
				{
					BoolCallback = callback;
				}
				System.UPvr_CallMethod(tobHelper, "pbsControlSetAutoConnectWIFI", ssid, pwd, 0, null);
			}

			public static void UPvr_ControlClearAutoConnectWIFI(Action<bool> callback)
			{
				if (callback != null)
				{
					BoolCallback = callback;
				}
				System.UPvr_CallMethod(tobHelper, "pbsControlClearAutoConnectWIFI", null);
			}

			public static void UPvr_PropertySetHomeKey(PBS_HomeEventEnum eventEnum, PBS_HomeFunctionEnum function, Action<bool> callback)
			{
				if (callback != null)
				{
					BoolCallback = callback;
				}
				System.UPvr_CallMethod(tobHelper, "pbsPropertySetHomeKey", GetEnumType(eventEnum), GetEnumType(function), null);
			}

			public static void UPvr_PropertySetHomeKeyAll(PBS_HomeEventEnum eventEnum, PBS_HomeFunctionEnum function, int timesetup, string pkg, string className, Action<bool> callback)
			{
				if (callback != null)
				{
					BoolCallback = callback;
				}
				System.UPvr_CallMethod(tobHelper, "pbsPropertySetHomeKeyAll", GetEnumType(eventEnum), GetEnumType(function), timesetup, pkg, className, null);
			}

			public static void UPvr_PropertyDisablePowerKey(bool isSingleTap, bool enable, Action<int> callback)
			{
				if (callback != null)
				{
					IntCallback = callback;
				}
				System.UPvr_CallMethod(tobHelper, "pbsPropertyDisablePowerKey", isSingleTap, enable, null);
			}

			public static void UPvr_PropertySetScreenOffDelay(PBS_ScreenOffDelayTimeEnum timeEnum, Action<int> callback)
			{
				if (callback != null)
				{
					IntCallback = callback;
				}
				System.UPvr_CallMethod(tobHelper, "pbsPropertySetScreenOffDelay", GetEnumType(timeEnum), null);
			}

			public static void UPvr_PropertySetSleepDelay(PBS_SleepDelayTimeEnum timeEnum)
			{
				System.UPvr_CallMethod(tobHelper, "pbsPropertySetSleepDelay", GetEnumType(timeEnum));
			}

			public static void UPvr_SwitchSystemFunction(PBS_SystemFunctionSwitchEnum systemFunction, PBS_SwitchEnum switchEnum)
			{
				System.UPvr_CallMethod(tobHelper, "pbsSwitchSystemFunction", GetEnumType(systemFunction), GetEnumType(switchEnum), 0);
			}

			public static void UPvr_SwitchSetUsbConfigurationOption(PBS_USBConfigModeEnum uSBConfigModeEnum)
			{
				System.UPvr_CallMethod(tobHelper, "pbsSwitchSetUsbConfigurationOption", GetEnumType(uSBConfigModeEnum), 0);
			}

			public static void UPvr_ScreenOn()
			{
				System.UPvr_CallMethod(tobHelper, "pbsScreenOn");
			}

			public static void UPvr_ScreenOff()
			{
				System.UPvr_CallMethod(tobHelper, "pbsScreenOff");
			}

			public static void UPvr_AcquireWakeLock()
			{
				System.UPvr_CallMethod(tobHelper, "pbsAcquireWakeLock");
			}

			public static void UPvr_ReleaseWakeLock()
			{
				System.UPvr_CallMethod(tobHelper, "pbsReleaseWakeLock");
			}

			public static void UPvr_EnableEnterKey()
			{
				System.UPvr_CallMethod(tobHelper, "pbsEnableEnterKey");
			}

			public static void UPvr_DisableEnterKey()
			{
				System.UPvr_CallMethod(tobHelper, "pbsDisableEnterKey");
			}

			public static void UPvr_EnableVolumeKey()
			{
				System.UPvr_CallMethod(tobHelper, "pbsEnableVolumeKey");
			}

			public static void UPvr_DisableVolumeKey()
			{
				System.UPvr_CallMethod(tobHelper, "pbsDisableVolumeKey");
			}

			public static void UPvr_EnableBackKey()
			{
				System.UPvr_CallMethod(tobHelper, "pbsEnableBackKey");
			}

			public static void UPvr_DisableBackKey()
			{
				System.UPvr_CallMethod(tobHelper, "pbsDisableBackKey");
			}

			public static void UPvr_WriteConfigFileToDataLocal(string path, string content, Action<bool> callback)
			{
				if (callback != null)
				{
					BoolCallback = callback;
				}
				System.UPvr_CallMethod(tobHelper, "pbsWriteConfigFileToDataLocal", path, content, null);
			}

			public static void UPvr_ResetAllKeyToDefault(Action<bool> callback)
			{
				if (callback != null)
				{
					BoolCallback = callback;
				}
				System.UPvr_CallMethod(tobHelper, "pbsResetAllKeyToDefault", null);
			}
		}
		public enum GlobalIntConfigs
		{
			EYE_TEXTURE_RESOLUTION0,
			EYE_TEXTURE_RESOLUTION1,
			SEENSOR_COUNT,
			ABILITY6DOF,
			PLATFORM_TYPE,
			TRACKING_MODE,
			LOG_LEVEL,
			ENBLE_HAND6DOF_BY_HEAD,
			ENBLE_6DOF_GLOBAL_TRACKING,
			TARGET_FRAME_RATE,
			iShowFPS,
			SensorMode,
			LOGICFLOW,
			EYE_TEXTURE_RES_HIGH,
			EYE_TEXTURE_RES_NORMAL,
			iCtrlModelLoadingPri,
			iPhoneHMDModeEnabled,
			isEnableBoundary,
			Enable_Activity_Rotation,
			GetDisplay_Orientation,
			GetWaitFrameNum,
			GetResetFrameNum,
			EnableFFRBYSYS,
			RotControllerMode
		}
		public enum GlobalFloatConfigs
		{
			IPD,
			VFOV,
			HFOV,
			NECK_MODEL_X,
			NECK_MODEL_Y,
			NECK_MODEL_Z,
			DISPLAY_REFRESH_RATE
		}
		public enum RenderTextureAntiAliasing
		{
			X_1 = 1,
			X_2 = 2,
			X_4 = 4,
			X_8 = 8
		}
		public enum PlatForm
		{
			Android = 1,
			IOS,
			Win,
			Notsupport
		}
		public enum RenderTextureDepth
		{
			BD_0 = 0,
			BD_16 = 16,
			BD_24 = 24
		}
		public enum RenderTextureLevel
		{
			Normal,
			High
		}
		public enum Sensorindex
		{
			Default,
			FirstSensor,
			SecondSensor
		}
		public enum Eye
		{
			LeftEye,
			RightEye,
			BothEye
		}
		public enum ResUtilsType
		{
			TYPE_TEXTSIZE,
			TYPE_COLOR,
			TYPE_TEXT,
			TYPE_FONT,
			TYPE_VALUE,
			TYPE_DRAWABLE,
			TYPE_OBJECT,
			TYPR_OBJECTARRAY
		}
		public enum TrackingOrigin
		{
			EyeLevel,
			FloorLevel,
			StageLevel
		}
		public enum EFoveationLevel
		{
			Low,
			Med,
			High,
			Top_High
		}
		public enum StereoRenderingPathPico
		{
			MultiPass,
			SinglePass
		}
		public enum pvrEyePoseStatus
		{
			kGazePointValid = 1,
			kGazeVectorValid = 2,
			kEyeOpennessValid = 4,
			kEyePupilDilationValid = 8,
			kEyePositionGuideValid = 0x10
		}
		public enum TrackingMode
		{
			PVR_TRACKING_MODE_ROTATION = 1,
			PVR_TRACKING_MODE_POSITION = 2,
			PVR_TRACKING_MODE_EYE = 4
		}
		public struct EyeTrackingData
		{
			public int leftEyePoseStatus;

			public int rightEyePoseStatus;

			public int combinedEyePoseStatus;

			public Vector3 leftEyeGazePoint;

			public Vector3 rightEyeGazePoint;

			public Vector3 combinedEyeGazePoint;

			public Vector3 leftEyeGazeVector;

			public Vector3 rightEyeGazeVector;

			public Vector3 combinedEyeGazeVector;

			public float leftEyeOpenness;

			public float rightEyeOpenness;

			public float leftEyePupilDilation;

			public float rightEyePupilDilation;

			public Vector3 leftEyePositionGuide;

			public Vector3 rightEyePositionGuide;

			public Vector3 foveatedGazeDirection;

			public int foveatedGazeTrackingState;

			[MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
			public byte[] reserved;
		}
		public struct EyeTrackingGazeRay
		{
			public Vector3 Direction;

			public bool IsValid;

			public Vector3 Origin;
		}
		public struct EyeDeviceInfo
		{
			public ViewFrustum targetFrustumLeft;

			public ViewFrustum targetFrustumRight;
		}
		public struct ViewFrustum
		{
			public float left;

			public float right;

			public float top;

			public float bottom;

			public float near;

			public float far;
		}
		public struct EyeSetting
		{
			public Transform eyelocalPosition;

			public Rect eyeRect;

			public float eyeFov;

			public float eyeAspect;

			public Matrix4x4 eyeProjectionMatrix;

			public Shader eyeShader;
		}
		public struct Sensor
		{
			public const string LibFileName = "Pvr_UnitySDK";

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern int Pvr_Enable6DofModule(bool enable);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern int Pvr_OptionalResetSensor(int index, int resetRot, int resetPos);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern int Pvr_Init(int index);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern int Pvr_StartSensor(int index);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern int Pvr_StopSensor(int index);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern int Pvr_ResetSensor(int index);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern int Pvr_ResetSensorAll(int index);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern int Pvr_GetSensorState(int index, ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern int Pvr_GetMainSensorState(ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz, ref float vfov, ref float hfov, ref int viewNumber);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern int Pvr_GetPsensorState();

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern int Pvr_GetHmdPSensorStatus();

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern int Pvr_GetSensorGyroscope(int index, ref float x, ref float y, ref float z);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern int Pvr_GetSensorMagnet(int index, ref float x, ref float y, ref float z);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern int Pvr_Get6DofSensorQualityStatus();

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern bool Pvr_Get6DofSafePanelFlag();

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern void Pvr_SetReinPosition(float x, float y, float z, float w, float px, float py, float pz, int hand, bool valid, int key);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern bool Pvr_SetTrackingOriginType(TrackingOrigin trackingOriginType);

			public static bool UPvr_Pvr_Get6DofSafePanelFlag()
			{
				return Pvr_Get6DofSafePanelFlag();
			}

			public static int UPvr_Init(int index)
			{
				return Pvr_Init(index);
			}

			public static void UPvr_InitPsensor()
			{
				Pvr_InitPsensor();
			}

			public static int UPvr_GetPsensorState()
			{
				int res = -1;
				Render.UPvr_GetIntConfig(4, ref res);
				if (res == 1)
				{
					return Pvr_GetPsensorState();
				}
				int num = Pvr_GetAndroidPsensorState();
				if (num != 0 && num != -1)
				{
					num = 1;
				}
				return num;
			}

			public static int UPvr_GetPSensorStatus()
			{
				return Pvr_GetHmdPSensorStatus();
			}

			public static void UPvr_UnregisterPsensor()
			{
				Pvr_UnregisterPsensor();
			}

			public static int UPvr_StartSensor(int index)
			{
				return Pvr_StartSensor(index);
			}

			public static int UPvr_StopSensor(int index)
			{
				return Pvr_StopSensor(index);
			}

			public static int UPvr_ResetSensor(int index)
			{
				Pvr_UnitySDKManager.SDK.resetBasePos = default(Vector3);
				return Pvr_ResetSensor(index);
			}

			public static int UPvr_OptionalResetSensor(int index, int resetRot, int resetPos)
			{
				return Pvr_OptionalResetSensor(index, resetRot, resetPos);
			}

			public static int UPvr_GetSensorState(int index, ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz)
			{
				return Pvr_GetSensorState(index, ref x, ref y, ref z, ref w, ref px, ref py, ref pz);
			}

			public static int UPvr_GetMainSensorState(ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz, ref float vfov, ref float hfov, ref int viewNumber)
			{
				return Pvr_GetMainSensorState(ref x, ref y, ref z, ref w, ref px, ref py, ref pz, ref vfov, ref hfov, ref viewNumber);
			}

			public static int UPvr_GetSensorGyroscope(int index, ref float x, ref float y, ref float z)
			{
				return Pvr_GetSensorGyroscope(index, ref x, ref y, ref z);
			}

			public static int UPvr_GetSensorMagnet(int index, ref float x, ref float y, ref float z)
			{
				return Pvr_GetSensorMagnet(index, ref x, ref y, ref z);
			}

			public static int UPvr_Get6DofSensorQualityStatus()
			{
				return Pvr_Get6DofSensorQualityStatus();
			}

			public static int UPvr_Enable6DofModule(bool enable)
			{
				return Pvr_Enable6DofModule(enable);
			}

			public static void Pvr_InitPsensor()
			{
				try
				{
					System.UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaSysActivityClass, "initPsensor", Pvr_UnitySDKRender.Instance.activity);
				}
				catch (Exception ex)
				{
					PLOG.E("Error :" + ex.ToString());
				}
			}

			public static bool Pvr_IsHead6dofReset()
			{
				int res = 0;
				Render.UPvr_GetIntConfig(17, ref res);
				if (res > 0)
				{
					return false;
				}
				bool result = false;
				try
				{
					System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaSysActivityClass, "isHead6dofReset", Pvr_UnitySDKRender.Instance.activity);
				}
				catch (Exception ex)
				{
					PLOG.E("Error :" + ex.ToString());
				}
				return result;
			}

			public static int Pvr_GetAndroidPsensorState()
			{
				int result = -1;
				try
				{
					System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaSysActivityClass, "getPsensorState");
				}
				catch (Exception ex)
				{
					PLOG.E("Error :" + ex.ToString());
				}
				return result;
			}

			public static void Pvr_UnregisterPsensor()
			{
				try
				{
					System.UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaSysActivityClass, "unregisterListener");
				}
				catch (Exception ex)
				{
					PLOG.E("Error :" + ex.ToString());
				}
			}

			public static int UPvr_ResetSensorAll(int index)
			{
				return Pvr_ResetSensorAll(index);
			}

			public static void UPvr_SetReinPosition(float x, float y, float z, float w, float px, float py, float pz, int hand, bool valid, int key)
			{
				if (PLOG.logLevel > 2)
				{
					PLOG.D("PvrLog UPvr_SetReinPosition" + x + y + z + w + px + py + pz + hand + valid + key);
				}
				Pvr_SetReinPosition(x, y, z, w, px, py, pz, hand, valid, key);
			}

			public static bool UPvr_SetTrackingOriginType(TrackingOrigin trackingOriginType)
			{
				return Pvr_SetTrackingOriginType(trackingOriginType);
			}
		}
		public struct Render
		{
			public const string LibFileName = "Pvr_UnitySDK";

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern void Pvr_ChangeScreenParameters(string model, int width, int height, double xppi, double yppi, double densityDpi);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern int Pvr_SetRatio(float midH, float midV);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern int Pvr_SetPupillaryPoint(bool enable);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern IntPtr Pvr_GetSupportHMDTypes();

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern void Pvr_SetCurrentHMDType([MarshalAs(UnmanagedType.LPStr)] string type);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern int Pvr_GetIntConfig(int configsenum, ref int res);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern int Pvr_GetFloatConfig(int configsenum, ref float res);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern void Pvr_SetupLayerData(int layerIndex, int sideMask, int textureId, int textureType, int layerFlags, float[] colorScaleAndOffset);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern void Pvr_SetupLayerCoords(int layerIndex, int sideMask, float[] lowerLeft, float[] lowerRight, float[] upperLeft, float[] upperRight);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern void Pvr_SetOverlayModelViewMatrix(int overlayType, int overlayShape, int texId, int eyeSide, int layerIndex, bool isHeadLocked, int layerFlags, float[] mvMatrix, float[] modelS, float[] modelR, float[] modelT, float[] cameraR, float[] cameraT, float[] colorScaleAndOffset);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern bool Pvr_EnableFoveation(bool enable);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern void Pvr_SetFoveationParameters(int textureId, int previousId, float focalPointX, float focalPointY, float foveationGainX, float foveationGainY, float foveationArea, float foveationMinimum);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern void Pvr_SetFoveationResource(int textureId, int previousId, float focalPointX, float focalPointY);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern void Pvr_SetFoveationParameters2(float foveationGainX, float foveationGainY, float foveationArea, float foveationMinimum);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern void Pvr_SetFoveationLevel(EFoveationLevel level);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern EFoveationLevel Pvr_GetFoveationLevel();

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern bool Pvr_GetIntSysProc(string property, ref int res);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern void Pvr_SetColorspaceType(int colorspaceType);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern void Pvr_SetCastingColorspaceType(int colorspaceType);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern IntPtr Pvr_CreateLayerAndroidSurface(int layerType, int layerIndex);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern IntPtr Pvr_GetLayerAndroidSurface(int layerType, int layerIndex);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern void Pvr_SetMonoMode(bool openMono);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern void Pvr_GetStencilMesh(int eye, ref int vertexCount, ref int triangleCount, ref IntPtr vertexData, ref IntPtr indexData);

			public static void UPvr_ChangeScreenParameters(string model, int width, int height, double xppi, double yppi, double densityDpi)
			{
				Pvr_ChangeScreenParameters(model, width, height, xppi, yppi, densityDpi);
			}

			public static int UPvr_SetRatio(float midH, float midV)
			{
				return Pvr_SetRatio(midH, midV);
			}

			public static void UPvr_EnableFoveation(bool enable)
			{
				if (Pvr_UnitySDKManager.SDK.SystemFFRLevel != -1 || Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel != -1)
				{
					enable = true;
				}
				Pvr_EnableFoveation(enable);
			}

			[Obsolete("This API will be removed in later versions")]
			public static void UPvr_SetFoveationParameters(int textureId, int previousId, float focalPointX, float focalPointY, float foveationGainX, float foveationGainY, float foveationArea, float foveationMinimum)
			{
				Pvr_SetFoveationParameters(textureId, previousId, focalPointX, focalPointY, foveationGainX, foveationGainY, foveationArea, foveationMinimum);
			}

			public static void UPvr_SetFoveationResource(int textureId, int previousId, float focalPointX, float focalPointY)
			{
				Pvr_SetFoveationResource(textureId, previousId, focalPointX, focalPointY);
			}

			public static void SetFoveatedRenderingLevel(EFoveationLevel level)
			{
				if (Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel != -1)
				{
					Pvr_SetFoveationLevel((EFoveationLevel)Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel);
				}
				else if (Pvr_UnitySDKManager.SDK.SystemFFRLevel != -1)
				{
					Pvr_SetFoveationLevel((EFoveationLevel)Pvr_UnitySDKManager.SDK.SystemFFRLevel);
				}
				else
				{
					Pvr_SetFoveationLevel(level);
				}
			}

			public static EFoveationLevel GetFoveatedRenderingLevel()
			{
				return Pvr_GetFoveationLevel();
			}

			public static void SetFoveatedRenderingParameters(Vector2 ffrGainValue, float ffrAreaValue, float ffrMinimumValue)
			{
				if (Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel != -1)
				{
					Pvr_SetFoveationLevel((EFoveationLevel)Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel);
				}
				else if (Pvr_UnitySDKManager.SDK.SystemFFRLevel != -1)
				{
					Pvr_SetFoveationLevel((EFoveationLevel)Pvr_UnitySDKManager.SDK.SystemFFRLevel);
				}
				else
				{
					Pvr_SetFoveationParameters2(ffrGainValue.x, ffrGainValue.y, ffrAreaValue, ffrMinimumValue);
				}
			}

			public static bool UPvr_GetIntSysProc(string property, ref int res)
			{
				return Pvr_GetIntSysProc(property, ref res);
			}

			public static int UPvr_GetIntConfig(int configsenum, ref int res)
			{
				return Pvr_GetIntConfig(configsenum, ref res);
			}

			public static int UPvr_GetFloatConfig(int configsenum, ref float res)
			{
				return Pvr_GetFloatConfig(configsenum, ref res);
			}

			public static string UPvr_GetSupportHMDTypes()
			{
				IntPtr intPtr = Pvr_GetSupportHMDTypes();
				if (intPtr != IntPtr.Zero)
				{
					return Marshal.PtrToStringAnsi(intPtr);
				}
				return null;
			}

			public static void UPvr_SetCurrentHMDType(string type)
			{
				Pvr_SetCurrentHMDType(type);
			}

			public static void UPvr_SetupLayerData(int layerIndex, int sideMask, int textureId, int textureType, int layerFlags, Vector4 colorScale, Vector4 colorOffset)
			{
				Pvr_SetupLayerData(layerIndex, sideMask, textureId, textureType, layerFlags, new float[8] { colorScale.x, colorScale.y, colorScale.z, colorScale.w, colorOffset.x, colorOffset.y, colorOffset.z, colorOffset.w });
			}

			public static void UPvr_SetupLayerCoords(int layerIndex, int sideMask, float[] lowerLeft, float[] lowerRight, float[] upperLeft, float[] upperRight)
			{
				Pvr_SetupLayerCoords(layerIndex, sideMask, lowerLeft, lowerRight, upperLeft, upperRight);
			}

			public static void UPvr_SetOverlayModelViewMatrix(int overlayType, int overlayShape, int texId, int eyeSide, int layerIndex, bool isHeadLocked, int layerFlags, Matrix4x4 mvMatrix, Vector3 modelS, Quaternion modelR, Vector3 modelT, Quaternion cameraR, Vector3 cameraT, Vector4 colorScale, Vector4 colorOffset)
			{
				Pvr_SetOverlayModelViewMatrix(overlayType, overlayShape, texId, eyeSide, layerIndex, isHeadLocked, layerFlags, new float[16]
				{
					mvMatrix.m00, mvMatrix.m01, mvMatrix.m02, mvMatrix.m03, mvMatrix.m10, mvMatrix.m11, mvMatrix.m12, mvMatrix.m13, mvMatrix.m20, mvMatrix.m21,
					mvMatrix.m22, mvMatrix.m23, mvMatrix.m30, mvMatrix.m31, mvMatrix.m32, mvMatrix.m33
				}, new float[3] { modelS.x, modelS.y, modelS.z }, new float[4] { modelR.x, modelR.y, modelR.z, modelR.w }, new float[3] { modelT.x, modelT.y, modelT.z }, new float[4] { cameraR.x, cameraR.y, cameraR.z, cameraR.w }, new float[3] { cameraT.x, cameraT.y, cameraT.z }, new float[8] { colorScale.x, colorScale.y, colorScale.z, colorScale.w, colorOffset.x, colorOffset.y, colorOffset.z, colorOffset.w });
			}

			public static void UPvr_SetColorspaceType(int colorspaceType)
			{
				Pvr_SetColorspaceType(colorspaceType);
			}

			public static void UPvr_SetCastingColorspaceType(int colorspaceType)
			{
				Pvr_SetCastingColorspaceType(colorspaceType);
			}

			public static IntPtr UPvr_CreateLayerAndroidSurface(int layerType, int layerIndex)
			{
				return Pvr_CreateLayerAndroidSurface(layerType, layerIndex);
			}

			public static IntPtr UPvr_GetLayerAndroidSurface(int layerType, int layerIndex)
			{
				return Pvr_GetLayerAndroidSurface(layerType, layerIndex);
			}

			public static void UPvr_SetMonoMode(bool openMono)
			{
				Pvr_SetMonoMode(openMono);
			}

			public static void UPvr_GetStencilMesh(int eye, ref int vertexCount, ref int triangleCount, ref IntPtr vertexDataPtr, ref IntPtr indexDataPtr)
			{
				Pvr_GetStencilMesh(eye, ref vertexCount, ref triangleCount, ref vertexDataPtr, ref indexDataPtr);
			}
		}
		public struct System
		{
			public const string LibFileName = "Pvr_UnitySDK";

			public const string UnitySDKVersion = "2.8.9.12";

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			public static extern void Pvr_SetInitActivity(IntPtr activity, IntPtr vrActivityClass);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern IntPtr Pvr_GetSDKVersion();

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			public static extern int Pvr_GetHmdHardwareVersion();

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			public static extern IntPtr Pvr_GetHmdFirmwareVersion();

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			public static extern IntPtr Pvr_GetHmdSerialNumber();

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			public static extern int PVR_GetHmdBatteryStatus();

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			public static extern float PVR_GetHmdBatteryTemperature();

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			public static extern int PVR_SetHmdAudioStatus(bool enable);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			public static extern bool Pvr_GetEyeTrackingData(ref int leftEyePoseStatus, ref int rightEyePoseStatus, ref int combinedEyePoseStatus, ref float leftEyeGazePointX, ref float leftEyeGazePointY, ref float leftEyeGazePointZ, ref float rightEyeGazePointX, ref float rightEyeGazePointY, ref float rightEyeGazePointZ, ref float combinedEyeGazePointX, ref float combinedEyeGazePointY, ref float combinedEyeGazePointZ, ref float leftEyeGazeVectorX, ref float leftEyeGazeVectorY, ref float leftEyeGazeVectorZ, ref float rightEyeGazeVectorX, ref float rightEyeGazeVectorY, ref float rightEyeGazeVectorZ, ref float combinedEyeGazeVectorX, ref float combinedEyeGazeVectorY, ref float combinedEyeGazeVectorZ, ref float leftEyeOpenness, ref float rightEyeOpenness, ref float leftEyePupilDilation, ref float rightEyePupilDilation, ref float leftEyePositionGuideX, ref float leftEyePositionGuideY, ref float leftEyePositionGuideZ, ref float rightEyePositionGuideX, ref float rightEyePositionGuideY, ref float rightEyePositionGuideZ, ref float foveatedGazeDirectionX, ref float foveatedGazeDirectionY, ref float foveatedGazeDirectionZ, ref int foveatedGazeTrackingState);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			public static extern bool Pvr_SetTrackingMode(int trackingMode);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			public static extern int Pvr_GetTrackingMode();

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			public static extern IntPtr GetRenderEventFunc();

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			public static extern void UnityEventData(long data);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			public static extern bool Pvr_EnableSinglePass(bool enable);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			public static extern void Pvr_SetAntiAliasing(int antiAliasing);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			public static extern void Pvr_SinglePassBeforeForwardOpaque();

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			public static extern void Pvr_SetCurrentRenderTexture(uint textureId);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			public static extern bool Pvr_SetSinglePassDepthBufferWidthHeight(int width, int height);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			public static extern int PVR_setPerformanceLevels(int cpuLevel, int gpuLevel);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			public static extern bool Pvr_SetIPD(float distance);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			public static extern float Pvr_GetIPD();

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			public static extern bool Pvr_SetTrackingIPDEnabled(bool enable);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			public static extern bool Pvr_GetTrackingIPDEnabled();

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			public static extern bool Pvr_GetEyeTrackingAutoIPD(ref float autoIPD);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			public static extern int PVR_GetHmdAudioStatus();

			public static bool UPvr_CallStaticMethod<T>(ref T result, AndroidJavaClass jclass, string name, params object[] args)
			{
				try
				{
					result = jclass.CallStatic<T>(name, args);
					return true;
				}
				catch (AndroidJavaException ex)
				{
					PLOG.E("Exception calling static method " + name + ": " + ex);
					return false;
				}
			}

			public static bool UPvr_CallStaticMethod(AndroidJavaObject jobj, string name, params object[] args)
			{
				try
				{
					jobj.CallStatic(name, args);
					return true;
				}
				catch (AndroidJavaException ex)
				{
					PLOG.E("CallStaticMethod  Exception calling activity method " + name + ": " + ex);
					return false;
				}
			}

			public static bool UPvr_CallMethod<T>(ref T result, AndroidJavaObject jobj, string name, params object[] args)
			{
				try
				{
					result = jobj.Call<T>(name, args);
					return true;
				}
				catch (AndroidJavaException ex)
				{
					PLOG.E("Exception calling activity method " + name + ": " + ex);
					return false;
				}
			}

			public static bool UPvr_CallMethod(AndroidJavaObject jobj, string name, params object[] args)
			{
				try
				{
					jobj.Call(name, args);
					return true;
				}
				catch (AndroidJavaException ex)
				{
					PLOG.E(" Exception calling activity method " + name + ": " + ex);
					return false;
				}
			}

			public static string UPvr_GetSDKVersion()
			{
				IntPtr intPtr = Pvr_GetSDKVersion();
				if (intPtr != IntPtr.Zero)
				{
					return Marshal.PtrToStringAnsi(intPtr);
				}
				return "";
			}

			public static string UPvr_GetUnitySDKVersion()
			{
				return "2.8.9.12";
			}

			public static string UPvr_GetDeviceMode()
			{
				return SystemInfo.deviceModel;
			}

			public static string UPvr_GetDeviceModel()
			{
				return SystemInfo.deviceModel;
			}

			public static string UPvr_GetDeviceSN()
			{
				string result = "UNKONWN";
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaSysActivityClass, "getDeviceSN");
				return result;
			}

			public static AndroidJavaObject UPvr_GetCurrentActivity()
			{
				return new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
			}

			public static bool UPvr_SetMonoPresentation()
			{
				return UPvr_CallMethod(UPvr_GetCurrentActivity(), "Pvr_setMonoPresentation");
			}

			public static bool UPvr_IsPresentationExisted()
			{
				bool result = false;
				return UPvr_CallMethod(ref result, UPvr_GetCurrentActivity(), "Pvr_isPresentationExisted") && result;
			}

			public static bool UPvr_GetMainActivityPauseStatus()
			{
				bool result = false;
				return UPvr_CallMethod(ref result, UPvr_GetCurrentActivity(), "Pvr_getMainActivityPauseStatus") && result;
			}

			public static void UPvr_Sleep()
			{
				UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaSysActivityClass, "Pvr_Sleep");
			}

			public static bool UPvr_StartHomeKeyReceiver(string startreceivre)
			{
				try
				{
					if (Pvr_UnitySDKRender.Instance != null)
					{
						UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityLongReceiver, "Pvr_StartReceiver", Pvr_UnitySDKRender.Instance.activity, startreceivre);
						PLOG.I("Start home key Receiver");
						return true;
					}
				}
				catch (Exception ex)
				{
					PLOG.E("Start home key  Receiver  Error :" + ex.ToString());
					return false;
				}
				return true;
			}

			public static bool UPvr_StopHomeKeyReceiver()
			{
				try
				{
					if (Pvr_UnitySDKRender.Instance != null)
					{
						UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityLongReceiver, "Pvr_StopReceiver", Pvr_UnitySDKRender.Instance.activity);
						PLOG.I("Stop home key Receiver");
						return true;
					}
				}
				catch (Exception ex)
				{
					PLOG.E("Stop home key Receiver Error :" + ex.ToString());
					return false;
				}
				return true;
			}

			public static void UPvr_StartVRModel()
			{
				UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClass, "startVRModel");
			}

			public static void UPvr_RemovePlatformLogo()
			{
				UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClass, "removePlatformLogo");
			}

			public static void UPvr_ShowPlatformLogo()
			{
				UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClass, "showPlatformLogo");
			}

			public static bool UPvr_IsPicoActivity()
			{
				bool result = false;
				return UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "isPicoActivity", UPvr_GetCurrentActivity()) && result;
			}

			public static void UPvr_StopVRModel()
			{
				UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClass, "stopVRModel");
			}

			public static string UPvr_GetCountryCode()
			{
				string result = "";
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getCountryCode", UPvr_GetCurrentActivity());
				return result;
			}

			public static bool UPvr_SetIPD(float distance)
			{
				bool flag = false;
				flag = Pvr_SetIPD(distance);
				if (flag)
				{
					for (int i = 0; i < Pvr_UnitySDKEyeManager.Instance.Eyes.Length; i++)
					{
						Pvr_UnitySDKEyeManager.Instance.Eyes[i].RefreshCameraPosition(distance);
					}
				}
				return flag;
			}

			public static float UPvr_GetIPD()
			{
				float result = Pvr_GetIPD();
				UnityEngine.Debug.Log("DISFT IPD:" + result);
				return result;
			}

			public static bool UPvr_SetTrackingIPDEnabled(bool enable)
			{
				return Pvr_SetTrackingIPDEnabled(enable);
			}

			public static bool UPvr_GetTrackingIPDEnabled()
			{
				return Pvr_GetTrackingIPDEnabled();
			}

			public static bool UPvr_GetEyeTrackingAutoIPD(ref float autoipd)
			{
				return Pvr_GetEyeTrackingAutoIPD(ref autoipd);
			}

			public static void UPvr_UnityEventData(long data)
			{
				UnityEventData(data);
			}

			public static long UPvr_GetEyeBufferData(int id)
			{
				return ((long)Pvr_UnitySDKRender.Instance.RenderviewNumber << 32) | id;
			}

			public static bool UPvr_checkDevice(string packagename)
			{
				bool result = false;
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "checkDevice", packagename, UPvr_GetCurrentActivity());
				return result;
			}

			public static int UPvr_GetHmdHardwareVersion()
			{
				return Pvr_GetHmdHardwareVersion();
			}

			public static string UPvr_GetHmdFirmwareVersion()
			{
				IntPtr intPtr = Pvr_GetHmdFirmwareVersion();
				if (intPtr != IntPtr.Zero)
				{
					return Marshal.PtrToStringAnsi(intPtr);
				}
				return "";
			}

			public static string UPvr_GetHmdSerialNumber()
			{
				IntPtr intPtr = Pvr_GetHmdSerialNumber();
				if (intPtr != IntPtr.Zero)
				{
					return Marshal.PtrToStringAnsi(intPtr);
				}
				return "";
			}

			public static int UPvr_GetHmdBatteryStatus()
			{
				return PVR_GetHmdBatteryStatus();
			}

			public static float UPvr_GetHmdBatteryTemperature()
			{
				return PVR_GetHmdBatteryTemperature();
			}

			public static int UPvr_SetHmdAudioStatus(bool enable)
			{
				return PVR_SetHmdAudioStatus(enable);
			}

			public static int UPvr_GetTrackingMode()
			{
				return Pvr_GetTrackingMode();
			}

			public static bool UPvr_setTrackingMode(int trackingMode)
			{
				return Pvr_SetTrackingMode(trackingMode);
			}

			public static bool UPvr_getEyeTrackingData(ref EyeTrackingData trackingData)
			{
				if (!Pvr_UnitySDKEyeManager.supportEyeTracking)
				{
					PLOG.E("The device is not supported");
					return false;
				}
				if (!Pvr_UnitySDKEyeManager.Instance.EyeTracking)
				{
					PLOG.E("Please Enable \"Pvr_UnitySDK/Head/Pvr_UnitySDKEyeManager.cs/EyeTracking\"option first.");
					return false;
				}
				bool result = Pvr_GetEyeTrackingData(ref trackingData.leftEyePoseStatus, ref trackingData.rightEyePoseStatus, ref trackingData.combinedEyePoseStatus, ref trackingData.leftEyeGazePoint.x, ref trackingData.leftEyeGazePoint.y, ref trackingData.leftEyeGazePoint.z, ref trackingData.rightEyeGazePoint.x, ref trackingData.rightEyeGazePoint.y, ref trackingData.rightEyeGazePoint.z, ref trackingData.combinedEyeGazePoint.x, ref trackingData.combinedEyeGazePoint.y, ref trackingData.combinedEyeGazePoint.z, ref trackingData.leftEyeGazeVector.x, ref trackingData.leftEyeGazeVector.y, ref trackingData.leftEyeGazeVector.z, ref trackingData.rightEyeGazeVector.x, ref trackingData.rightEyeGazeVector.y, ref trackingData.rightEyeGazeVector.z, ref trackingData.combinedEyeGazeVector.x, ref trackingData.combinedEyeGazeVector.y, ref trackingData.combinedEyeGazeVector.z, ref trackingData.leftEyeOpenness, ref trackingData.rightEyeOpenness, ref trackingData.leftEyePupilDilation, ref trackingData.rightEyePupilDilation, ref trackingData.leftEyePositionGuide.x, ref trackingData.leftEyePositionGuide.y, ref trackingData.leftEyePositionGuide.z, ref trackingData.rightEyePositionGuide.x, ref trackingData.rightEyePositionGuide.y, ref trackingData.rightEyePositionGuide.z, ref trackingData.foveatedGazeDirection.x, ref trackingData.foveatedGazeDirection.y, ref trackingData.foveatedGazeDirection.z, ref trackingData.foveatedGazeTrackingState);
				trackingData.leftEyeGazeVector.z = 0f - trackingData.leftEyeGazeVector.z;
				trackingData.rightEyeGazeVector.z = 0f - trackingData.rightEyeGazeVector.z;
				trackingData.combinedEyeGazeVector.z = 0f - trackingData.combinedEyeGazeVector.z;
				trackingData.leftEyeGazePoint.z = 0f - trackingData.leftEyeGazePoint.z;
				trackingData.rightEyeGazePoint.z = 0f - trackingData.rightEyeGazePoint.z;
				trackingData.combinedEyeGazePoint.z = 0f - trackingData.combinedEyeGazePoint.z;
				trackingData.foveatedGazeDirection.z = 0f - trackingData.foveatedGazeDirection.z;
				return result;
			}

			public static bool UPvr_getEyeTrackingGazeRay(ref EyeTrackingGazeRay gazeRay)
			{
				if (!Pvr_UnitySDKEyeManager.supportEyeTracking)
				{
					PLOG.E("The device is not supported");
					return false;
				}
				if (!Pvr_UnitySDKEyeManager.Instance.EyeTracking)
				{
					PLOG.E("Please Enable \"Pvr_UnitySDK/Head/Pvr_UnitySDKEyeManager.cs/EyeTracking\"option first.");
					return false;
				}
				EyeTrackingData trackingData = default(EyeTrackingData);
				UPvr_getEyeTrackingData(ref trackingData);
				gazeRay.IsValid = ((uint)trackingData.combinedEyePoseStatus & (true ? 1u : 0u)) != 0 && (trackingData.combinedEyePoseStatus & 2) != 0;
				if (gazeRay.IsValid)
				{
					gazeRay.Direction = trackingData.combinedEyeGazeVector;
					gazeRay.Origin = trackingData.combinedEyeGazePoint;
					gazeRay.Origin = Pvr_UnitySDKSensor.Instance.HeadPose.Matrix.MultiplyPoint(gazeRay.Origin);
					gazeRay.Direction = Pvr_UnitySDKSensor.Instance.HeadPose.Matrix.MultiplyVector(gazeRay.Direction);
					return true;
				}
				return false;
			}

			public static bool UPvr_getEyeTrackingGazeRayWorld(ref EyeTrackingGazeRay gazeRay)
			{
				if (!Pvr_UnitySDKEyeManager.supportEyeTracking)
				{
					PLOG.E("The device is not supported");
					return false;
				}
				if (!Pvr_UnitySDKEyeManager.Instance.EyeTracking)
				{
					PLOG.E("Please Enable \"Pvr_UnitySDK/Head/Pvr_UnitySDKEyeManager.cs/EyeTracking\"option first.");
					return false;
				}
				Transform transform = Pvr_UnitySDKEyeManager.Instance.transform;
				Matrix4x4 matrix4x = Matrix4x4.TRS(transform.position, transform.rotation, Vector3.one);
				EyeTrackingData trackingData = default(EyeTrackingData);
				UPvr_getEyeTrackingData(ref trackingData);
				gazeRay.IsValid = ((uint)trackingData.combinedEyePoseStatus & (true ? 1u : 0u)) != 0 && (trackingData.combinedEyePoseStatus & 2) != 0;
				if (gazeRay.IsValid)
				{
					gazeRay.Direction = trackingData.combinedEyeGazeVector;
					gazeRay.Origin = trackingData.combinedEyeGazePoint;
					gazeRay.Origin = matrix4x.MultiplyPoint(gazeRay.Origin);
					gazeRay.Direction = matrix4x.MultiplyVector(gazeRay.Direction);
					return true;
				}
				return false;
			}

			public static Vector3 UPvr_getEyeTrackingPos()
			{
				if (!Pvr_UnitySDKEyeManager.supportEyeTracking)
				{
					PLOG.E("The device is not supported");
					return Vector3.zero;
				}
				if (!Pvr_UnitySDKEyeManager.Instance.EyeTracking)
				{
					PLOG.E("Please Enable \"Pvr_UnitySDK/Head/Pvr_UnitySDKEyeManager.cs/EyeTracking\"option first.");
					return Vector3.zero;
				}
				return Pvr_UnitySDKEyeManager.Instance.GetEyeTrackingPos();
			}

			public static int UPvr_GetPhoneScreenBrightness()
			{
				int result = 0;
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClientClass, "Pvr_GetScreen_Brightness", UPvr_GetCurrentActivity());
				return result;
			}

			public static void UPvr_SetPhoneScreenBrightness(int level)
			{
				UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClientClass, "Pvr_setAPPScreen_Brightness", UPvr_GetCurrentActivity(), level);
			}

			public static bool UPvr_IsPicoDefaultActivity()
			{
				using (AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer"))
				{
					using AndroidJavaObject androidJavaObject = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
					if (androidJavaObject.Call<string>("getLocalClassName", Array.Empty<object>()) == "com.unity3d.player.UnityPlayerNativeActivityPico")
					{
						return true;
					}
				}
				return false;
			}

			public static bool UPvr_EnableSinglePass(bool enable)
			{
				return Pvr_EnableSinglePass(enable);
			}

			public static void UPvr_SetAntiAliasing(int antiAliasing)
			{
				Pvr_SetAntiAliasing(antiAliasing);
			}

			public static void UPvr_SinglePassBeforeForwardOpaque()
			{
				Pvr_SinglePassBeforeForwardOpaque();
			}

			public static void UPvr_SetCurrentRenderTexture(uint textureId)
			{
				Pvr_SetCurrentRenderTexture(textureId);
			}

			public static bool UPvr_SetSinglePassDepthBufferWidthHeight(int width, int height)
			{
				return Pvr_SetSinglePassDepthBufferWidthHeight(width, height);
			}

			public static int UPVR_setPerformanceLevels(int cpuLevel, int gpuLevel)
			{
				return PVR_setPerformanceLevels(cpuLevel, gpuLevel);
			}

			public static int UPvr_GetColorRes(string name)
			{
				int result = -1;
				try
				{
					UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getColorRes", name);
				}
				catch (Exception ex)
				{
					PLOG.E("GetColorResError :" + ex.ToString());
				}
				return result;
			}

			public static int UPvr_GetConfigInt(string name)
			{
				int result = -1;
				try
				{
					UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getConfigInt", name);
				}
				catch (Exception ex)
				{
					PLOG.E("GetConfigIntError :" + ex.ToString());
				}
				return result;
			}

			public static string UPvr_GetConfigString(string name)
			{
				string result = "";
				try
				{
					UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getConfigString", name);
				}
				catch (Exception ex)
				{
					PLOG.E("GetConfigStringError :" + ex.ToString());
				}
				return result;
			}

			public static string UPvr_GetDrawableLocation(string name)
			{
				string result = "";
				try
				{
					UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getDrawableLocation", name);
				}
				catch (Exception ex)
				{
					PLOG.E("GetDrawableLocationError :" + ex.ToString());
				}
				return result;
			}

			public static int UPvr_GetTextSize(string name)
			{
				int result = -1;
				try
				{
					UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getTextSize", name);
				}
				catch (Exception ex)
				{
					PLOG.E("GetTextSizeError :" + ex.ToString());
				}
				return result;
			}

			public static string UPvr_GetLangString(string name)
			{
				string result = "";
				try
				{
					UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getLangString", name);
				}
				catch (Exception ex)
				{
					PLOG.E("GetLangStringError :" + ex.ToString());
				}
				return result;
			}

			public static string UPvr_GetStringValue(string id, int type)
			{
				string result = "";
				try
				{
					UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getStringValue", id, type);
				}
				catch (Exception ex)
				{
					PLOG.E("GetStringValueError :" + ex.ToString());
				}
				return result;
			}

			public static int UPvr_GetIntValue(string id, int type)
			{
				int result = -1;
				try
				{
					UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getIntValue", id, type);
				}
				catch (Exception ex)
				{
					PLOG.E("GetIntValueError :" + ex.ToString());
				}
				return result;
			}

			public static float UPvr_GetFloatValue(string id)
			{
				float result = -1f;
				try
				{
					UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getFloatValue", id);
				}
				catch (Exception ex)
				{
					PLOG.E("GetFloatValueError :" + ex.ToString());
				}
				return result;
			}

			public static string UPvr_GetObjectOrArray(string id, int type)
			{
				string result = "";
				try
				{
					UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getObjectOrArray", id, type);
				}
				catch (Exception ex)
				{
					PLOG.E("GetObjectOrArrayError :" + ex.ToString());
				}
				return result;
			}

			public static int UPvr_GetCharSpace(string id)
			{
				int result = -1;
				try
				{
					UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getCharSpace", id);
				}
				catch (Exception ex)
				{
					PLOG.E("GetCharSpaceError :" + ex.ToString());
				}
				return result;
			}
		}
		public struct BoundarySystem
		{
			public enum BoundaryType
			{
				OuterBoundary,
				PlayArea
			}

			public struct BoundaryTestResult
			{
				public bool IsTriggering;

				public float ClosestDistance;

				public Vector3 ClosestPoint;

				public Vector3 ClosestPointNormal;
			}

			public enum BoundaryTrackingNode
			{
				HandLeft,
				HandRight,
				Head
			}

			public enum BoundaryTrackingState
			{
				PVR_NOREASON,
				PVRRELOCATION_IN_PROGRESS,
				PVRLOW_FEATURE_COUNT_ERROR,
				PVRLOW_LIGHT_ERROR,
				PVRBRIGHT_LIGHT_ERROR,
				PVRSTEREO_CAMERA_CALIBRATION_ERROR
			}

			public const string LibFileName = "Pvr_UnitySDK";

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern float Pvr_GetFloorHeight();

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern int Pvr_GetSeeThroughState();

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern void Pvr_BoundarySetSTBackground(bool value);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern int Pvr_GetTrackingState();

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern bool Pvr_GetFrameRateLimit();

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern bool Pvr_IsBoundaryEnable();

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern bool Pvr_BoundaryGetConfigured();

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern bool Pvr_BoundaryTestNode(int node, bool isPlayArea, ref bool isTriggering, ref float closestDistance, ref float px, ref float py, ref float pz, ref float nx, ref float ny, ref float nz);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern bool Pvr_BoundaryTestPoint(float x, float y, float z, bool isPlayArea, ref bool isTriggering, ref float closestDistance, ref float px, ref float py, ref float pz, ref float nx, ref float ny, ref float nz);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern int Pvr_BoundaryGetGeometry(out IntPtr handle, bool isPlayArea);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern int Pvr_BoundaryGetDimensions(ref float x, ref float y, ref float z, bool isPlayArea);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern bool Pvr_BoundaryGetEnabled();

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern void Pvr_BoundarySetVisible(bool value);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern bool Pvr_BoundaryGetVisible();

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern bool Pvr_EnableLWRP(bool enable);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern bool Pvr_SetViewportSize(int w, int h);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern void Pvr_BoundarySetSeeThroughVisible(bool value);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern void PVR_SetCameraImageRect(int width, int height);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern void Pvr_SetGuardianSystemDisable(bool value);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern int Pvr_GetDialogState();

			public static float UPvr_GetFloorHeight()
			{
				return Pvr_GetFloorHeight();
			}

			public static int UPvr_GetSeeThroughState()
			{
				return Pvr_GetSeeThroughState();
			}

			public static void UPvr_EnableSeeThroughManual(bool enable)
			{
				Pvr_BoundarySetSTBackground(enable);
			}

			public static BoundaryTrackingState UPvr_GetTrackingState()
			{
				return (BoundaryTrackingState)Pvr_GetTrackingState();
			}

			public static bool UPvr_GetFrameRateLimit()
			{
				return Pvr_GetFrameRateLimit();
			}

			public static bool UPvr_IsBoundaryEnable()
			{
				return Pvr_IsBoundaryEnable();
			}

			public static bool UPvr_BoundaryGetConfigured()
			{
				return Pvr_BoundaryGetConfigured();
			}

			public static BoundaryTestResult UPvr_BoundaryTestNode(BoundaryTrackingNode node, BoundaryType boundaryType)
			{
				BoundaryTestResult result = default(BoundaryTestResult);
				bool num = Pvr_BoundaryTestNode((int)node, boundaryType == BoundaryType.PlayArea, ref result.IsTriggering, ref result.ClosestDistance, ref result.ClosestPoint.x, ref result.ClosestPoint.y, ref result.ClosestPoint.z, ref result.ClosestPointNormal.x, ref result.ClosestPointNormal.y, ref result.ClosestPointNormal.z);
				result.ClosestPoint.z = 0f - result.ClosestPoint.z;
				result.ClosestPointNormal.z = 0f - result.ClosestPointNormal.z;
				if (!num)
				{
					UnityEngine.Debug.LogError($"UPvr_BoundaryTestNode({node}, {boundaryType}) API call failed!");
				}
				return result;
			}

			public static BoundaryTestResult UPvr_BoundaryTestPoint(Vector3 point, BoundaryType boundaryType)
			{
				BoundaryTestResult result = default(BoundaryTestResult);
				if (!Pvr_BoundaryTestPoint(point.x, point.y, 0f - point.z, boundaryType == BoundaryType.PlayArea, ref result.IsTriggering, ref result.ClosestDistance, ref result.ClosestPoint.x, ref result.ClosestPoint.y, ref result.ClosestPoint.z, ref result.ClosestPointNormal.x, ref result.ClosestPointNormal.y, ref result.ClosestPointNormal.z))
				{
					UnityEngine.Debug.LogError($"UPvr_BoundaryTestPoint({point}, {boundaryType}) API call failed!");
				}
				return result;
			}

			public static Vector3[] UPvr_BoundaryGetGeometry(BoundaryType boundaryType)
			{
				IntPtr handle = IntPtr.Zero;
				int num = Pvr_BoundaryGetGeometry(out handle, boundaryType == BoundaryType.PlayArea);
				if (num <= 0)
				{
					UnityEngine.Debug.LogError("Boundary geometry point count is " + num);
					return null;
				}
				int num2 = num * 3;
				float[] array = new float[num2];
				Marshal.Copy(handle, array, 0, num2);
				Vector3[] array2 = new Vector3[num];
				for (int i = 0; i < num; i++)
				{
					array2[i] = new Vector3
					{
						x = array[3 * i],
						y = array[3 * i + 1],
						z = 0f - array[3 * i + 2]
					};
				}
				return array2;
			}

			public static Vector3 UPvr_BoundaryGetDimensions(BoundaryType boundaryType)
			{
				float x = 0f;
				float y = 0f;
				float z = 0f;
				Pvr_BoundaryGetDimensions(ref x, ref y, ref z, boundaryType == BoundaryType.PlayArea);
				return new Vector3(x, y, z);
			}

			public static bool UPvr_BoundaryGetEnabled()
			{
				return Pvr_BoundaryGetEnabled();
			}

			public static void UPvr_BoundarySetVisible(bool value)
			{
				Pvr_BoundarySetVisible(value);
			}

			public static bool UPvr_BoundaryGetVisible()
			{
				return Pvr_BoundaryGetVisible();
			}

			public static bool UPvr_EnableLWRP(bool enable)
			{
				return Pvr_EnableLWRP(enable);
			}

			public static bool UPvr_SetViewportSize(int width, int height)
			{
				return Pvr_SetViewportSize(width, height);
			}

			public static void UPvr_StartCameraFrame()
			{
				try
				{
					Pvr_UnitySDKPluginEvent.Issue(RenderEventType.StartCameraFrame);
				}
				catch (Exception ex)
				{
					PLOG.E("UPvr_StartCameraFrame :" + ex.ToString());
				}
			}

			public static void UPvr_StopCameraFrame()
			{
				try
				{
					Pvr_UnitySDKPluginEvent.Issue(RenderEventType.StopCameraFrame);
				}
				catch (Exception ex)
				{
					PLOG.E("UPvr_StopCameraFrame :" + ex.ToString());
				}
			}

			public static void UPvr_BoundaryGetSeeThroughData(int cameraIndex, RenderTexture renderTexture)
			{
				try
				{
					if (renderTexture.IsCreated())
					{
						System.UPvr_UnityEventData(renderTexture.GetNativeTexturePtr().ToInt32());
						switch (cameraIndex)
						{
						case 0:
							Pvr_UnitySDKPluginEvent.Issue(RenderEventType.CameraFrameLeft);
							break;
						case 1:
							Pvr_UnitySDKPluginEvent.Issue(RenderEventType.CameraFrameRight);
							break;
						}
					}
				}
				catch (Exception ex)
				{
					PLOG.E("UPvr_BoundaryGetSeeThroughDataError :" + ex.ToString());
				}
			}

			public static void UPvr_BoundarySetCameraImageRect(int width, int height)
			{
				try
				{
					PVR_SetCameraImageRect(width, height);
				}
				catch (Exception ex)
				{
					PLOG.E("UPvr_BoundarySetCameraImageRectError :" + ex.ToString());
				}
			}

			public static void UPvr_BoundarySetSeeThroughVisible(bool value)
			{
				try
				{
					Pvr_BoundarySetSeeThroughVisible(value);
				}
				catch (Exception ex)
				{
					PLOG.E("UPvr_BoundarySetSeeThroughVisibleError :" + ex.ToString());
				}
			}

			public static void UPvr_SetGuardianSystemDisable(bool value)
			{
				try
				{
					Pvr_SetGuardianSystemDisable(value);
				}
				catch (Exception ex)
				{
					PLOG.E("UPvr_SetGuardianSystemDisableError :" + ex.ToString());
				}
			}

			public static int UPvr_GetDialogState()
			{
				int result = 0;
				try
				{
					result = Pvr_GetDialogState();
				}
				catch (Exception ex)
				{
					PLOG.E("UPvr_GetDialogStateError :" + ex.ToString());
				}
				return result;
			}
		}
		[StructLayout(LayoutKind.Sequential, Size = 1)]
		public struct PlatformSettings
		{
			public static Pvr_UnitySDKPlatformSetting.simulationType UPvr_IsCurrentDeviceValid()
			{
				if (Pvr_UnitySDKPlatformSetting.Entitlementchecksimulation)
				{
					if (Pvr_UnitySDKPlatformSetting.Instance.deviceSN.Count <= 0)
					{
						UnityEngine.Debug.Log("DISFT Entitlement Check Simulation deviceSN is Null");
						return Pvr_UnitySDKPlatformSetting.simulationType.Null;
					}
					foreach (string item in Pvr_UnitySDKPlatformSetting.Instance.deviceSN)
					{
						if (System.UPvr_GetDeviceSN() == item)
						{
							return Pvr_UnitySDKPlatformSetting.simulationType.Valid;
						}
					}
					UnityEngine.Debug.Log("DISFT Entitlement Check Simulation deviceSN is Invalid");
					return Pvr_UnitySDKPlatformSetting.simulationType.Invalid;
				}
				UnityEngine.Debug.Log("DISFT Entitlement Check Simulation DO NOT Enable");
				return Pvr_UnitySDKPlatformSetting.simulationType.Invalid;
			}

			public static bool UPvr_AppEntitlementCheck(string appid)
			{
				bool result = false;
				try
				{
					System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "verifyAPP", System.UPvr_GetCurrentActivity(), appid, "");
				}
				catch (Exception ex)
				{
					PLOG.E("Error :" + ex.ToString());
				}
				UnityEngine.Debug.Log("PvrLog UPvr_AppEntitlementCheck" + result);
				return result;
			}

			[Obsolete("This API will be removed in later versions")]
			public static bool UPvr_KeyEntitlementCheck(string publicKey)
			{
				bool result = false;
				try
				{
					System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "verifyAPP", System.UPvr_GetCurrentActivity(), "", publicKey);
				}
				catch (Exception ex)
				{
					PLOG.E("Error :" + ex.ToString());
				}
				UnityEngine.Debug.Log("PvrLog UPvr_KeyEntitlementCheck" + result);
				return result;
			}

			public static int UPvr_AppEntitlementCheckExtra(string appid)
			{
				return 0;
			}

			public static int UPvr_KeyEntitlementCheckExtra(string publicKey)
			{
				int result = -1;
				try
				{
					System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "verifyAPPExt", System.UPvr_GetCurrentActivity(), "", publicKey);
				}
				catch (Exception ex)
				{
					PLOG.E("Error :" + ex.ToString());
				}
				UnityEngine.Debug.Log("PvrLog UPvr_KeyEntitlementCheck" + result);
				return result;
			}

			public static int UPvr_GetHmdAudioStatus()
			{
				return System.PVR_GetHmdAudioStatus();
			}
		}
		public enum DeviceCommand
		{
			SET_PICO_NEO_HMD_BRIGHTNESS = 12,
			SET_PICO_NEO_HMD_SLEEPDELAY
		}
		public enum BrightnessLevel
		{
			VR_BRIGHTNESS_LEVEL_MIN = 1,
			VR_BRIGHTNESS_LEVEL_MAX = 100,
			VR_BRIGHTNESS_LEVEL_DOWN = 1000,
			VR_BRIGHTNESS_LEVEL_UP = 1001,
			VR_BRIGHTNESS_LEVEL_SCREEN_OFF = -100
		}
		public struct VolumePowerBrightness
		{
			public const string LibFileName = "Pvr_UnitySDK";

			public AndroidJavaObject activity;

			public static AndroidJavaClass javaSysActivityClass;

			private static AndroidJavaClass batteryjavaVrActivityClass;

			private static AndroidJavaClass volumejavaVrActivityClass;

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			public static extern void Pvr_SetInitActivity(IntPtr activity, IntPtr vrActivityClass);

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern bool Pvr_IsHmdExist();

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern int Pvr_GetHmdScreenBrightness();

			[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
			private static extern bool Pvr_SetHmdScreenBrightness(int brightness);

			public static bool UPvr_IsHmdExist()
			{
				return Pvr_IsHmdExist();
			}

			public static int UPvr_GetHmdScreenBrightness()
			{
				return Pvr_GetHmdScreenBrightness();
			}

			public static bool UPvr_SetHmdScreenBrightness(int brightness)
			{
				return Pvr_SetHmdScreenBrightness(brightness);
			}

			public static bool UPvr_SetCommonBrightness(int brightness)
			{
				bool flag = false;
				if (UPvr_IsHmdExist())
				{
					return UPvr_SetHmdScreenBrightness(brightness);
				}
				return UPvr_SetBrightness(brightness);
			}

			public static int UPvr_GetCommonBrightness()
			{
				int num = 0;
				if (UPvr_IsHmdExist())
				{
					return UPvr_GetHmdScreenBrightness();
				}
				return UPvr_GetCurrentBrightness();
			}

			public static int[] UPvr_GetScreenBrightnessLevel()
			{
				return Pvr_GetScreenBrightnessLevel();
			}

			public static void UPvr_SetScreenBrightnessLevel(int vrBrightness, int level)
			{
				Pvr_SetScreenBrightnessLevel(vrBrightness, level);
			}

			public static bool UPvr_SetDevicePropForUser(DeviceCommand deviceid, string number)
			{
				return setDevicePropForUser(deviceid, number);
			}

			public static string UPvr_GetDevicePropForUser(DeviceCommand deviceid)
			{
				return getDevicePropForUser(deviceid);
			}

			public static bool UPvr_InitBatteryClass()
			{
				try
				{
					if (javaSysActivityClass == null)
					{
						javaSysActivityClass = new AndroidJavaClass("com.psmart.aosoperation.SysActivity");
					}
					if (javaSysActivityClass != null && Pvr_UnitySDKRender.Instance.activity != null)
					{
						if (batteryjavaVrActivityClass == null)
						{
							batteryjavaVrActivityClass = new AndroidJavaClass("com.psmart.aosoperation.BatteryReceiver");
						}
						return true;
					}
					return false;
				}
				catch (Exception ex)
				{
					PLOG.E("startReceiver Error :" + ex.ToString());
					return false;
				}
			}

			public static bool UPvr_InitBatteryVolClass()
			{
				try
				{
					javaSysActivityClass = new AndroidJavaClass("com.psmart.aosoperation.SysActivity");
					if (javaSysActivityClass != null && Pvr_UnitySDKRender.Instance.activity != null)
					{
						batteryjavaVrActivityClass = new AndroidJavaClass("com.psmart.aosoperation.BatteryReceiver");
						volumejavaVrActivityClass = new AndroidJavaClass("com.psmart.aosoperation.AudioReceiver");
						System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_InitAudioDevice", Pvr_UnitySDKRender.Instance.activity);
						return true;
					}
					return false;
				}
				catch (Exception ex)
				{
					PLOG.E("startReceiver Error :" + ex.ToString());
					return false;
				}
			}

			public static bool UPvr_StartBatteryReceiver(string startreceivre)
			{
				try
				{
					System.UPvr_CallStaticMethod(batteryjavaVrActivityClass, "Pvr_StartReceiver", Pvr_UnitySDKRender.Instance.activity, startreceivre);
					return true;
				}
				catch (Exception ex)
				{
					PLOG.E("startReceiver Error :" + ex.ToString());
					return false;
				}
			}

			public static bool UPvr_StopBatteryReceiver()
			{
				try
				{
					System.UPvr_CallStaticMethod(batteryjavaVrActivityClass, "Pvr_StopReceiver", Pvr_UnitySDKRender.Instance.activity);
					return true;
				}
				catch (Exception ex)
				{
					PLOG.E("startReceiver Error :" + ex.ToString());
					return false;
				}
			}

			public static bool UPvr_SetBrightness(int brightness)
			{
				try
				{
					System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_SetScreen_Brightness", brightness, Pvr_UnitySDKRender.Instance.activity);
					return true;
				}
				catch (Exception ex)
				{
					PLOG.E(" Error :" + ex.ToString());
					return false;
				}
			}

			public static int UPvr_GetCurrentBrightness()
			{
				int result = 0;
				try
				{
					System.UPvr_CallStaticMethod(ref result, javaSysActivityClass, "Pvr_GetScreen_Brightness", Pvr_UnitySDKRender.Instance.activity);
				}
				catch (Exception ex)
				{
					PLOG.E(" Error :" + ex.ToString());
				}
				return result;
			}

			public static int[] Pvr_GetScreenBrightnessLevel()
			{
				int[] result = new int[1];
				try
				{
					System.UPvr_CallStaticMethod(ref result, javaSysActivityClass, "getScreenBrightnessLevel");
				}
				catch (Exception ex)
				{
					PLOG.E(" Error :" + ex.ToString());
				}
				return result;
			}

			public static void Pvr_SetScreenBrightnessLevel(int vrBrightness, int level)
			{
				try
				{
					System.UPvr_CallStaticMethod(javaSysActivityClass, "setScreenBrightnessLevel", vrBrightness, level);
				}
				catch (Exception ex)
				{
					PLOG.E(" Error :" + ex.ToString());
				}
			}

			public static bool UPvr_StartAudioReceiver(string startreceivre)
			{
				try
				{
					System.UPvr_CallStaticMethod(volumejavaVrActivityClass, "Pvr_StartReceiver", Pvr_UnitySDKRender.Instance.activity, startreceivre);
					return true;
				}
				catch (Exception ex)
				{
					PLOG.E("startReceiver Error :" + ex.ToString());
					return false;
				}
			}

			public static bool UPvr_StopAudioReceiver()
			{
				try
				{
					System.UPvr_CallStaticMethod(volumejavaVrActivityClass, "Pvr_StopReceiver", Pvr_UnitySDKRender.Instance.activity);
					return true;
				}
				catch (Exception ex)
				{
					PLOG.E("startReceiver Error :" + ex.ToString());
					return false;
				}
			}

			public static int UPvr_GetMaxVolumeNumber()
			{
				int result = 0;
				try
				{
					System.UPvr_CallStaticMethod(ref result, javaSysActivityClass, "Pvr_GetMaxAudionumber");
				}
				catch (Exception ex)
				{
					PLOG.E(" Error :" + ex.ToString());
				}
				return result;
			}

			public static int UPvr_GetCurrentVolumeNumber()
			{
				int result = 0;
				try
				{
					System.UPvr_CallStaticMethod(ref result, javaSysActivityClass, "Pvr_GetAudionumber");
				}
				catch (Exception ex)
				{
					PLOG.E(" Error :" + ex.ToString());
				}
				return result;
			}

			public static bool UPvr_VolumeUp()
			{
				try
				{
					System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_UpAudio");
					return true;
				}
				catch (Exception ex)
				{
					PLOG.E(" Error :" + ex.ToString());
					return false;
				}
			}

			public static bool UPvr_VolumeDown()
			{
				try
				{
					System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_DownAudio");
					return true;
				}
				catch (Exception ex)
				{
					PLOG.E(" Error :" + ex.ToString());
					return false;
				}
			}

			public static bool UPvr_SetVolumeNum(int volume)
			{
				try
				{
					System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_ChangeAudio", volume);
					return true;
				}
				catch (Exception ex)
				{
					PLOG.E(" Error :" + ex.ToString());
					return false;
				}
			}

			public static bool UPvr_SetAudio(string s)
			{
				return false;
			}

			public static bool UPvr_SetBattery(string s)
			{
				return false;
			}

			private static string getDevicePropForUser(DeviceCommand deviceid)
			{
				string result = "0";
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getDevicePropForUser", (int)deviceid);
				return result;
			}

			private static bool setDevicePropForUser(DeviceCommand deviceid, string number)
			{
				bool result = false;
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "setDevicePropForUser", (int)deviceid, number);
				return result;
			}
		}
	}
	namespace Pvr_UnitySDKAPI.Achievement
	{
		public sealed class AchievementCore
		{
			private static bool IsPlatformInitialized = true;

			public static bool LogMessages = false;

			public static bool IsInitialized()
			{
				return IsPlatformInitialized;
			}

			public static void Initialize()
			{
			}

			public static void RegisterNetwork()
			{
				Pvr_AchievementAPI.RegisterNetwork();
			}

			public static void UnRegisterNetwork()
			{
				Pvr_AchievementAPI.UnRegisterNetwork();
			}
		}
		public static class Achievements
		{
			public static Pvr_Request<Pvr_AchievementUpdate> Init()
			{
				if (AchievementCore.IsInitialized())
				{
					return new Pvr_Request<Pvr_AchievementUpdate>(Pvr_AchievementAPI.Init());
				}
				return null;
			}

			public static Pvr_Request<Pvr_AchievementUpdate> AddCount(string name, long count)
			{
				if (AchievementCore.IsInitialized())
				{
					return new Pvr_Request<Pvr_AchievementUpdate>(Pvr_AchievementAPI.pvr_Achievements_AddCount(name, count));
				}
				return null;
			}

			public static Pvr_Request<Pvr_AchievementUpdate> AddFields(string name, string fields)
			{
				if (AchievementCore.IsInitialized())
				{
					return new Pvr_Request<Pvr_AchievementUpdate>(Pvr_AchievementAPI.pvr_Achievements_AddFields(name, fields));
				}
				return null;
			}

			public static Pvr_Request<Pvr_AchievementDefinitionList> GetAllDefinitions()
			{
				if (AchievementCore.IsInitialized())
				{
					return new Pvr_Request<Pvr_AchievementDefinitionList>(Pvr_AchievementAPI.pvr_Achievements_GetAllDefinitions());
				}
				return null;
			}

			public static Pvr_Request<Pvr_AchievementProgressList> GetAllProgress()
			{
				if (AchievementCore.IsInitialized())
				{
					return new Pvr_Request<Pvr_AchievementProgressList>(Pvr_AchievementAPI.pvr_Achievements_GetAllProgress());
				}
				return null;
			}

			public static Pvr_Request<Pvr_AchievementDefinitionList> GetDefinitionsByName(string[] names)
			{
				if (AchievementCore.IsInitialized())
				{
					return new Pvr_Request<Pvr_AchievementDefinitionList>(Pvr_AchievementAPI.pvr_Achievements_GetDefinitionsByName(names, (names != null) ? names.Length : 0));
				}
				return null;
			}

			public static Pvr_Request<Pvr_AchievementProgressList> GetProgressByName(string[] names)
			{
				if (AchievementCore.IsInitialized())
				{
					return new Pvr_Request<Pvr_AchievementProgressList>(Pvr_AchievementAPI.pvr_Achievements_GetProgressByName(names, (names != null) ? names.Length : 0));
				}
				return null;
			}

			public static Pvr_Request<Pvr_AchievementUpdate> Unlock(string name)
			{
				if (AchievementCore.IsInitialized())
				{
					return new Pvr_Request<Pvr_AchievementUpdate>(Pvr_AchievementAPI.pvr_Achievements_Unlock(name));
				}
				return null;
			}

			public static Pvr_Request<Pvr_AchievementDefinitionList> GetNextAchievementDefinitionListPage(Pvr_AchievementDefinitionList list)
			{
				if (!list.HasNextPage)
				{
					UnityEngine.Debug.LogWarning("Platform.GetNextAchievementDefinitionListPage: List has no next page");
					return null;
				}
				if (AchievementCore.IsInitialized())
				{
					return new Pvr_Request<Pvr_AchievementDefinitionList>(Pvr_AchievementAPI.pvr_HTTP_GetWithMessageType(list.NextUrl, Pvr_Message.MessageType.Achievements_GetNextAchievementDefinitionArrayPage));
				}
				return null;
			}

			public static Pvr_Request<Pvr_AchievementProgressList> GetNextAchievementProgressListPage(Pvr_AchievementProgressList list)
			{
				if (!list.HasNextPage)
				{
					UnityEngine.Debug.LogWarning("Platform.GetNextAchievementProgressListPage: List has no next page");
					return null;
				}
				if (AchievementCore.IsInitialized())
				{
					return new Pvr_Request<Pvr_AchievementProgressList>(Pvr_AchievementAPI.pvr_HTTP_GetWithMessageType(list.NextUrl, Pvr_Message.MessageType.Achievements_GetNextAchievementProgressArrayPage));
				}
				return null;
			}
		}
		public enum AchievementType
		{
			[Description("UNKNOWN")]
			Unknown,
			[Description("SIMPLE")]
			Simple,
			[Description("BITFIELD")]
			Bitfield,
			[Description("COUNT")]
			Count
		}
		public class Pvr_AchievementAPI
		{
			private static AndroidJavaClass achievementAPI = new AndroidJavaClass("com.pico.achievenment.AchievementAPI");

			private static AndroidJavaClass definitionArrayHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementDefinitionArrayHandle");

			private static AndroidJavaClass definitionHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementDefinitionHandle");

			private static AndroidJavaClass progressArrayHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementProgressArrayHandle");

			private static AndroidJavaClass progressHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementProgressHandle");

			private static AndroidJavaClass updateHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementUpdateHandle");

			private static AndroidJavaObject errorHandle = new AndroidJavaObject("com.picovr.achievement.utils.pvrAchievementErrorHandle");

			private static AndroidJavaObject unityInterface = new AndroidJavaObject("com.pico.loginpaysdk.UnityInterface");

			private static string openId;

			private static string accessToken;

			private static string appId = Pvr_UnitySDKPlatformSetting.Instance.appID;

			internal static long Init()
			{
				AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
				unityInterface.Call("init", @static);
				unityInterface.Call("authSSO");
				AndroidJavaObject androidJavaObject = new AndroidJavaClass("com.pico.loginpaysdk.utils.PicoAccessTokenKeeper").CallStatic<AndroidJavaObject>("readAccessToken", new object[1] { @static });
				accessToken = androidJavaObject.Call<string>("getAccessToken", Array.Empty<object>());
				openId = androidJavaObject.Call<string>("getOpenId", Array.Empty<object>());
				return achievementAPI.CallStatic<long>("init", new object[3] { accessToken, openId, @static });
			}

			internal static void RegisterNetwork()
			{
				AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
				achievementAPI.CallStatic("registerNetwork", @static);
			}

			internal static void UnRegisterNetwork()
			{
				achievementAPI.CallStatic("unregisterNetwork");
			}

			internal static AndroidJavaObject PopMessage()
			{
				return achievementAPI.CallStatic<AndroidJavaObject>("pvr_PopMessage", Array.Empty<object>());
			}

			internal static string pvr_Error_GetMessage(AndroidJavaObject popMessage)
			{
				return errorHandle.CallStatic<string>("pvr_Error_GetMessage", new object[1] { popMessage });
			}

			internal static int pvr_Error_GetHttpCode(AndroidJavaObject popMessage)
			{
				return errorHandle.CallStatic<int>("pvr_Error_GetHttpCode", new object[1] { popMessage });
			}

			internal static int pvr_Error_GetCode(AndroidJavaObject popMessage)
			{
				return errorHandle.CallStatic<int>("pvr_Error_GetCode", new object[1] { popMessage });
			}

			internal static long pvr_Achievements_AddCount(string name, long count)
			{
				return achievementAPI.CallStatic<long>("pvr_Achievements_AddCount", new object[3] { name, count, accessToken });
			}

			internal static long pvr_Achievements_AddFields(string name, string fields)
			{
				return achievementAPI.CallStatic<long>("pvr_Achievements_AddFields", new object[3] { name, fields, accessToken });
			}

			internal static long pvr_Achievements_GetAllDefinitions()
			{
				AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
				return achievementAPI.CallStatic<long>("pvr_Achievements_GetAllDefinitions", new object[2] { appId, @static });
			}

			internal static long pvr_Achievements_GetAllProgress()
			{
				return achievementAPI.CallStatic<long>("pvr_Achievements_GetAllProgress", new object[1] { accessToken });
			}

			internal static long pvr_Achievements_GetDefinitionsByName(string[] names, int v)
			{
				AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
				return achievementAPI.CallStatic<long>("pvr_Achievements_GetDefinitionsByName", new object[2] { names, @static });
			}

			internal static long pvr_Achievements_GetProgressByName(string[] names, int v)
			{
				return achievementAPI.CallStatic<long>("pvr_Achievements_GetProgressByName", new object[2] { names, accessToken });
			}

			internal static long pvr_Achievements_Unlock(string name)
			{
				return achievementAPI.CallStatic<long>("pvr_Achievements_Unlock", new object[2] { name, accessToken });
			}

			internal static long pvr_HTTP_GetWithMessageType(string nextUrl, Pvr_Message.MessageType messageType)
			{
				long result = 0L;
				switch (messageType)
				{
				case Pvr_Message.MessageType.Achievements_GetNextAchievementDefinitionArrayPage:
				{
					AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
					result = achievementAPI.CallStatic<long>("pvr_Achievements_GetAllDefinitionsByUrl", new object[2] { nextUrl, @static });
					break;
				}
				case Pvr_Message.MessageType.Achievements_GetNextAchievementProgressArrayPage:
					result = achievementAPI.CallStatic<long>("pvr_Achievements_GetAllProgressByUrl", new object[1] { nextUrl });
					break;
				}
				return result;
			}

			internal static long pvr_Message_GetType(AndroidJavaObject popMessage)
			{
				return popMessage.Call<AndroidJavaObject>("getHandleType", Array.Empty<object>()).Call<long>("getIndex", Array.Empty<object>());
			}

			internal static bool pvr_Message_IsError(AndroidJavaObject popMessage)
			{
				return popMessage.Call<bool>("isMessage_IsError", Array.Empty<object>());
			}

			internal static long pvr_Message_GetRequestID(AndroidJavaObject popMessage)
			{
				return popMessage.Call<long>("getId", Array.Empty<object>());
			}

			internal static string pvr_Message_GetString(AndroidJavaObject popMessage)
			{
				return popMessage.Call<string>("getContent", Array.Empty<object>());
			}

			internal static bool pvr_AchievementUpdate_GetJustUnlocked(AndroidJavaObject popMessage)
			{
				return updateHandle.CallStatic<bool>("pvr_AchievementUpdate_GetJustUnlocked", new object[1] { popMessage });
			}

			internal static string pvr_AchievementUpdate_GetName(AndroidJavaObject popMessage)
			{
				return updateHandle.CallStatic<string>("pvr_AchievementUpdate_GetName", new object[1] { popMessage });
			}

			internal static int pvr_AchievementProgressArray_GetSize(AndroidJavaObject msg)
			{
				return progressArrayHandle.CallStatic<int>("pvr_AchievementProgressArray_GetSize", new object[1] { msg });
			}

			internal static AndroidJavaObject pvr_AchievementProgressArray_GetElement(AndroidJavaObject msg, int index)
			{
				return progressArrayHandle.CallStatic<AndroidJavaObject>("pvr_AchievementProgressArray_GetElement", new object[2] { msg, index });
			}

			internal static string pvr_AchievementProgressArray_GetNextUrl(AndroidJavaObject msg)
			{
				return progressArrayHandle.CallStatic<string>("pvr_AchievementProgressArray_GetNextUrl", new object[1] { msg });
			}

			internal static string pvr_AchievementProgress_GetBitfield(AndroidJavaObject msg)
			{
				return progressHandle.CallStatic<string>("pvr_AchievementProgress_GetBitfield", new object[1] { msg });
			}

			internal static long pvr_AchievementProgress_GetCount(AndroidJavaObject msg)
			{
				return progressHandle.CallStatic<long>("pvr_AchievementProgress_GetCount", new object[1] { msg });
			}

			internal static bool pvr_AchievementProgress_GetIsUnlocked(AndroidJavaObject msg)
			{
				return progressHandle.CallStatic<bool>("pvr_AchievementProgress_GetIsUnlocked", new object[1] { msg });
			}

			internal static string pvr_AchievementProgress_GetName(AndroidJavaObject msg)
			{
				return progressHandle.CallStatic<string>("pvr_AchievementProgress_GetName", new object[1] { msg });
			}

			internal static DateTime pvr_AchievementProgress_GetUnlockTime(AndroidJavaObject msg)
			{
				new DateTime(1970, 1, 1, 0, 0, 0, 0);
				return DateTimeFromNative(progressHandle.CallStatic<long>("pvr_AchievementProgress_GetUnlockTime", new object[1] { msg }));
			}

			internal static DateTime DateTimeFromNative(long seconds_since_the_one_true_epoch)
			{
				return new DateTime(1970, 1, 1, 0, 0, 0, 0).AddSeconds(seconds_since_the_one_true_epoch).ToLocalTime();
			}

			internal static int pvr_AchievementDefinitionArray_GetSize(AndroidJavaObject msg)
			{
				return definitionArrayHandle.CallStatic<int>("pvr_AchievementDefinitionArray_GetSize", new object[1] { msg });
			}

			internal static AndroidJavaObject pvr_AchievementDefinitionArray_GetElement(AndroidJavaObject msg, int index)
			{
				return definitionArrayHandle.CallStatic<AndroidJavaObject>("pvr_AchievementDefinitionArray_GetElement", new object[2] { msg, index });
			}

			internal static string pvr_AchievementDefinitionArray_GetNextUrl(AndroidJavaObject msg)
			{
				return definitionArrayHandle.CallStatic<string>("pvr_AchievementDefinitionArray_GetNextUrl", new object[1] { msg });
			}

			internal static AchievementType pvr_AchievementDefinition_GetType(AndroidJavaObject msg)
			{
				return (AchievementType)definitionHandle.CallStatic<AndroidJavaObject>("pvr_AchievementDefinition_GetType", new object[1] { msg }).Call<int>("getIndex", Array.Empty<object>());
			}

			internal static string pvr_AchievementDefinition_GetName(AndroidJavaObject msg)
			{
				return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetName", new object[1] { msg });
			}

			internal static int pvr_AchievementDefinition_GetBitfieldLength(AndroidJavaObject msg)
			{
				return definitionHandle.CallStatic<int>("pvr_AchievementDefinition_GetBitfieldLength", new object[1] { msg });
			}

			internal static long pvr_AchievementDefinition_GetTarget(AndroidJavaObject msg)
			{
				return definitionHandle.CallStatic<long>("pvr_AchievementDefinition_GetTarget", new object[1] { msg });
			}

			internal static string pvr_AchievementDefinition_GetTitle(AndroidJavaObject msg)
			{
				return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetTitle", new object[1] { msg });
			}

			internal static string pvr_AchievementDefinition_GetUnlockedDescription(AndroidJavaObject msg)
			{
				return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetUnlocked_description", new object[1] { msg });
			}

			internal static string pvr_AchievementDefinition_GetLockedIcon(AndroidJavaObject msg)
			{
				return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetLocked_image", new object[1] { msg });
			}

			internal static bool pvr_AchievementDefinition_GetIsSecrect(AndroidJavaObject msg)
			{
				return definitionHandle.CallStatic<bool>("pvr_AchievementDefinition_GetIs_secret", new object[1] { msg });
			}

			internal static string pvr_AchievementDefinition_GetUnlockedIcon(AndroidJavaObject msg)
			{
				return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetUnlocked_image", new object[1] { msg });
			}

			internal static string pvr_AchievementDefinition_GetDescription(AndroidJavaObject msg)
			{
				return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetDescription", new object[1] { msg });
			}
		}
		public class Pvr_AchievementDefinition
		{
			public readonly AchievementType Type;

			public readonly string Name;

			public readonly int BitfieldLength;

			public readonly long Target;

			public readonly string Title;

			public readonly string Description;

			public readonly string UnlockedDescription;

			public readonly string UnlockedIcon;

			public readonly string LockedIcon;

			public readonly bool IsSecrect;

			public Pvr_AchievementDefinition(AndroidJavaObject msg)
			{
				Type = Pvr_AchievementAPI.pvr_AchievementDefinition_GetType(msg);
				Name = Pvr_AchievementAPI.pvr_AchievementDefinition_GetName(msg);
				BitfieldLength = Pvr_AchievementAPI.pvr_AchievementDefinition_GetBitfieldLength(msg);
				Target = Pvr_AchievementAPI.pvr_AchievementDefinition_GetTarget(msg);
				Title = Pvr_AchievementAPI.pvr_AchievementDefinition_GetTitle(msg);
				Description = Pvr_AchievementAPI.pvr_AchievementDefinition_GetDescription(msg);
				UnlockedDescription = Pvr_AchievementAPI.pvr_AchievementDefinition_GetUnlockedDescription(msg);
				UnlockedIcon = Pvr_AchievementAPI.pvr_AchievementDefinition_GetUnlockedIcon(msg);
				LockedIcon = Pvr_AchievementAPI.pvr_AchievementDefinition_GetLockedIcon(msg);
				IsSecrect = Pvr_AchievementAPI.pvr_AchievementDefinition_GetIsSecrect(msg);
			}
		}
		public class Pvr_AchievementDefinitionList : Pvr_DeserializableList<Pvr_AchievementDefinition>
		{
			public Pvr_AchievementDefinitionList(AndroidJavaObject msg)
			{
				int num = Pvr_AchievementAPI.pvr_AchievementDefinitionArray_GetSize(msg);
				data = new List<Pvr_AchievementDefinition>(num);
				for (int i = 0; i < num; i++)
				{
					data.Add(new Pvr_AchievementDefinition(Pvr_AchievementAPI.pvr_AchievementDefinitionArray_GetElement(msg, i)));
				}
				nextUrl = Pvr_AchievementAPI.pvr_AchievementDefinitionArray_GetNextUrl(msg);
			}
		}
		public class Pvr_AchievementProgress
		{
			public readonly string Bitfield;

			public readonly long Count;

			public readonly bool IsUnlocked;

			public readonly string Name;

			public readonly DateTime UnlockTime;

			public Pvr_AchievementProgress(AndroidJavaObject msg)
			{
				Bitfield = Pvr_AchievementAPI.pvr_AchievementProgress_GetBitfield(msg);
				Count = Pvr_AchievementAPI.pvr_AchievementProgress_GetCount(msg);
				IsUnlocked = Pvr_AchievementAPI.pvr_AchievementProgress_GetIsUnlocked(msg);
				Name = Pvr_AchievementAPI.pvr_AchievementProgress_GetName(msg);
				UnlockTime = Pvr_AchievementAPI.pvr_AchievementProgress_GetUnlockTime(msg);
			}
		}
		public class Pvr_AchievementProgressList : Pvr_DeserializableList<Pvr_AchievementProgress>
		{
			public Pvr_AchievementProgressList(AndroidJavaObject msg)
			{
				int num = Pvr_AchievementAPI.pvr_AchievementProgressArray_GetSize(msg);
				data = new List<Pvr_AchievementProgress>(num);
				for (int i = 0; i < num; i++)
				{
					data.Add(new Pvr_AchievementProgress(Pvr_AchievementAPI.pvr_AchievementProgressArray_GetElement(msg, i)));
				}
				nextUrl = Pvr_AchievementAPI.pvr_AchievementProgressArray_GetNextUrl(msg);
			}
		}
		public class Pvr_AchievementUpdate
		{
			public readonly bool JustUnlocked;

			public readonly string Name;

			public Pvr_AchievementUpdate(AndroidJavaObject msg)
			{
				JustUnlocked = Pvr_AchievementAPI.pvr_AchievementUpdate_GetJustUnlocked(msg);
				Name = Pvr_AchievementAPI.pvr_AchievementUpdate_GetName(msg);
			}
		}
		public class Pvr_DeserializableList<T> : IList<T>, ICollection<T>, IEnumerable<T>, IEnumerable
		{
			protected List<T> data;

			protected string nextUrl;

			protected string previousUrl;

			public int Count => data.Count;

			bool ICollection<T>.IsReadOnly => ((ICollection<T>)data).IsReadOnly;

			public T this[int index]
			{
				get
				{
					return data[index];
				}
				set
				{
					data[index] = value;
				}
			}

			public bool HasNextPage => !string.IsNullOrEmpty(NextUrl);

			public bool HasPreviousPage => !string.IsNullOrEmpty(PreviousUrl);

			public string NextUrl => nextUrl;

			public string PreviousUrl => previousUrl;

			public int IndexOf(T obj)
			{
				return data.IndexOf(obj);
			}

			public void Add(T item)
			{
				data.Add(item);
			}

			public void Clear()
			{
				data.Clear();
			}

			public bool Contains(T item)
			{
				return data.Contains(item);
			}

			public void CopyTo(T[] array, int arrayIndex)
			{
				data.CopyTo(array, arrayIndex);
			}

			public IEnumerator<T> GetEnumerator()
			{
				return data.GetEnumerator();
			}

			public void Insert(int index, T item)
			{
				data.Insert(index, item);
			}

			public bool Remove(T item)
			{
				return data.Remove(item);
			}

			public void RemoveAt(int index)
			{
				data.RemoveAt(index);
			}

			private IEnumerator GetEnumerator1()
			{
				return GetEnumerator();
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator1();
			}
		}
		public static class Pvr_Callback
		{
			private class RequestCallback
			{
				private Pvr_Message.Callback messageCallback;

				public RequestCallback()
				{
				}

				public RequestCallback(Pvr_Message.Callback callback)
				{
					messageCallback = callback;
				}

				public virtual void HandleMessage(Pvr_Message msg)
				{
					if (messageCallback != null)
					{
						messageCallback(msg);
					}
				}
			}

			private sealed class RequestCallback<T> : RequestCallback
			{
				private Pvr_Message<T>.Callback callback;

				public RequestCallback(Pvr_Message<T>.Callback callback)
				{
					this.callback = callback;
				}

				public override void HandleMessage(Pvr_Message msg)
				{
					if (callback != null)
					{
						if (msg is Pvr_Message<T>)
						{
							callback((Pvr_Message<T>)msg);
						}
						else
						{
							UnityEngine.Debug.LogError("Unable to handle message: " + msg.GetType());
						}
					}
				}
			}

			private static Dictionary<long, Request> requestIDsToRequests = new Dictionary<long, Request>();

			private static Dictionary<Pvr_Message.MessageType, RequestCallback> notificationCallbacks = new Dictionary<Pvr_Message.MessageType, RequestCallback>();

			internal static void AddRequest(Request request)
			{
				if (request.RequestID <= 2)
				{
					long requestID = request.RequestID;
					if ((ulong)requestID <= 2uL)
					{
						switch (requestID)
						{
						case 0L:
							UnityEngine.Debug.LogError("An PARAM_INVALIDE error occurred. Request failed.");
							return;
						case 1L:
							UnityEngine.Debug.LogError("An NETWORK_INVALIDE error occurred. Request failed.");
							return;
						case 2L:
							UnityEngine.Debug.LogError("An NOT_INTIALIZE error occurred. Request failed.");
							return;
						}
					}
					UnityEngine.Debug.LogError("An unknown error occurred. Request failed.");
				}
				else
				{
					requestIDsToRequests[request.RequestID] = request;
				}
			}

			internal static void RunCallbacks()
			{
				while (true)
				{
					Pvr_Message pvr_Message = Pvr_Message.PopMessage();
					if (pvr_Message != null)
					{
						HandleMessage(pvr_Message);
						continue;
					}
					break;
				}
			}

			internal static void RunLimitedCallbacks(uint limit)
			{
				for (int i = 0; i < limit; i++)
				{
					Pvr_Message pvr_Message = Pvr_Message.PopMessage();
					if (pvr_Message != null)
					{
						HandleMessage(pvr_Message);
						continue;
					}
					break;
				}
			}

			internal static void OnApplicationQuit()
			{
				requestIDsToRequests.Clear();
				notificationCallbacks.Clear();
			}

			internal static void HandleMessage(Pvr_Message msg)
			{
				if (msg.RequestID != 0L && requestIDsToRequests.TryGetValue(msg.RequestID, out var value))
				{
					try
					{
						value.HandleMessage(msg);
						return;
					}
					finally
					{
						requestIDsToRequests.Remove(msg.RequestID);
					}
				}
				if (notificationCallbacks.TryGetValue(msg.Type, out var value2))
				{
					value2.HandleMessage(msg);
				}
			}
		}
		public class Pvr_CallbackRunner : MonoBehaviour
		{
			public bool IsPersistantBetweenSceneLoads = true;

			private void Awake()
			{
				if (UnityEngine.Object.FindObjectOfType<Pvr_CallbackRunner>() != this)
				{
					UnityEngine.Debug.LogWarning("You only need one instance of CallbackRunner");
				}
				if (IsPersistantBetweenSceneLoads)
				{
					UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
				}
			}

			private void Update()
			{
				Request.RunCallbacks();
			}

			private void OnApplicationQuit()
			{
				Pvr_Callback.OnApplicationQuit();
			}
		}
		public abstract class Pvr_Message<T> : Pvr_Message
		{
			public new delegate void Callback(Pvr_Message<T> message);

			private T data;

			public T Data => data;

			public Pvr_Message(AndroidJavaObject msg)
				: base(msg)
			{
				if (!base.IsError)
				{
					data = GetDataFromMessage(msg);
				}
			}

			protected abstract T GetDataFromMessage(AndroidJavaObject msg);
		}
		public class Pvr_Message
		{
			public delegate void Callback(Pvr_Message message);

			public enum MessageType : uint
			{
				Unknown = 0u,
				Achievements_AddCount = 65495601u,
				Achievements_AddFields = 346693929u,
				Achievements_GetAllDefinitions = 64177549u,
				Achievements_GetAllProgress = 1335877149u,
				Achievements_GetDefinitionsByName = 1653670332u,
				Achievements_GetNextAchievementDefinitionArrayPage = 712888917u,
				Achievements_GetNextAchievementProgressArrayPage = 792913703u,
				Achievements_GetProgressByName = 354837425u,
				Achievements_Unlock = 1497156573u,
				Achievements_WriteAchievementProgress = 121027549u,
				Achievements_VerifyAccessToken = 53284924u
			}

			internal delegate Pvr_Message ExtraMessageTypesHandler(AndroidJavaObject messageHandle, MessageType message_type);

			private MessageType type;

			private long requestID;

			private Error error;

			public MessageType Type => type;

			public bool IsError => error != null;

			public long RequestID => requestID;

			internal static ExtraMessageTypesHandler HandleExtraMessageTypes { private get; set; }

			public Pvr_Message(AndroidJavaObject msg)
			{
				type = (MessageType)Pvr_AchievementAPI.pvr_Message_GetType(msg);
				bool num = Pvr_AchievementAPI.pvr_Message_IsError(msg);
				requestID = Pvr_AchievementAPI.pvr_Message_GetRequestID(msg);
				if (num)
				{
					error = new Error(Pvr_AchievementAPI.pvr_Error_GetCode(msg), Pvr_AchievementAPI.pvr_Error_GetMessage(msg), Pvr_AchievementAPI.pvr_Error_GetHttpCode(msg));
				}
				else if (AchievementCore.LogMessages)
				{
					string text = Pvr_AchievementAPI.pvr_Message_GetString(msg);
					if (text != null)
					{
						UnityEngine.Debug.Log(text);
					}
					else
					{
						UnityEngine.Debug.Log($"null message string {msg}");
					}
				}
			}

			public virtual Error GetError()
			{
				return error;
			}

			public virtual Pvr_AchievementDefinitionList GetAchievementDefinitions()
			{
				return null;
			}

			public virtual Pvr_AchievementProgressList GetAchievementProgressList()
			{
				return null;
			}

			public virtual Pvr_AchievementUpdate GetAchievementUpdate()
			{
				return null;
			}

			public virtual string GetString()
			{
				return null;
			}

			internal static Pvr_Message ParseMessageHandle(AndroidJavaObject messageHandle)
			{
				if (messageHandle == null)
				{
					return null;
				}
				Pvr_Message result = null;
				switch ((MessageType)Pvr_AchievementAPI.pvr_Message_GetType(messageHandle))
				{
				case MessageType.Achievements_GetAllDefinitions:
				case MessageType.Achievements_GetNextAchievementDefinitionArrayPage:
				case MessageType.Achievements_GetDefinitionsByName:
					result = new MessageWithAchievementDefinitions(messageHandle);
					break;
				case MessageType.Achievements_GetProgressByName:
				case MessageType.Achievements_GetNextAchievementProgressArrayPage:
				case MessageType.Achievements_GetAllProgress:
					result = new MessageWithAchievementProgressList(messageHandle);
					break;
				case MessageType.Achievements_VerifyAccessToken:
				case MessageType.Achievements_AddCount:
				case MessageType.Achievements_AddFields:
				case MessageType.Achievements_Unlock:
					result = new MessageWithAchievementUpdate(messageHandle);
					break;
				}
				return result;
			}

			public static Pvr_Message PopMessage()
			{
				return ParseMessageHandle(Pvr_AchievementAPI.PopMessage());
			}
		}
		public class MessageWithAchievementDefinitions : Pvr_Message<Pvr_AchievementDefinitionList>
		{
			public MessageWithAchievementDefinitions(AndroidJavaObject msg)
				: base(msg)
			{
			}

			public override Pvr_AchievementDefinitionList GetAchievementDefinitions()
			{
				return base.Data;
			}

			protected override Pvr_AchievementDefinitionList GetDataFromMessage(AndroidJavaObject msg)
			{
				return new Pvr_AchievementDefinitionList(msg);
			}
		}
		public class MessageWithAchievementProgressList : Pvr_Message<Pvr_AchievementProgressList>
		{
			public MessageWithAchievementProgressList(AndroidJavaObject msg)
				: base(msg)
			{
			}

			public override Pvr_AchievementProgressList GetAchievementProgressList()
			{
				return base.Data;
			}

			protected override Pvr_AchievementProgressList GetDataFromMessage(AndroidJavaObject msg)
			{
				return new Pvr_AchievementProgressList(msg);
			}
		}
		public class MessageWithAchievementUpdate : Pvr_Message<Pvr_AchievementUpdate>
		{
			public MessageWithAchievementUpdate(AndroidJavaObject msg)
				: base(msg)
			{
			}

			public override Pvr_AchievementUpdate GetAchievementUpdate()
			{
				return base.Data;
			}

			protected override Pvr_AchievementUpdate GetDataFromMessage(AndroidJavaObject msg)
			{
				return new Pvr_AchievementUpdate(msg);
			}
		}
		public class MessageWithString : Pvr_Message<string>
		{
			public MessageWithString(AndroidJavaObject msg)
				: base(msg)
			{
			}

			public override string GetString()
			{
				return base.Data;
			}

			protected override string GetDataFromMessage(AndroidJavaObject msg)
			{
				return Pvr_AchievementAPI.pvr_Message_GetString(msg);
			}
		}
		public class Error
		{
			public readonly int Code;

			public readonly int HttpCode;

			public readonly string Message;

			public Error(int code, string message, int httpCode)
			{
				Message = message;
				Code = code;
				HttpCode = httpCode;
			}
		}
		public sealed class Pvr_Request<T> : Request
		{
			private Pvr_Message<T>.Callback callback_;

			public Pvr_Request(long requestID)
				: base(requestID)
			{
			}

			public Pvr_Request<T> OnComplete(Pvr_Message<T>.Callback callback)
			{
				if (callback_ != null)
				{
					throw new UnityException("Attempted to attach multiple handlers to a Request.  This is not allowed.");
				}
				callback_ = callback;
				Pvr_Callback.AddRequest(this);
				return this;
			}

			public override void HandleMessage(Pvr_Message msg)
			{
				if (!(msg is Pvr_Message<T>))
				{
					UnityEngine.Debug.LogError("Unable to handle message: " + msg.GetType());
					return;
				}
				if (callback_ != null)
				{
					callback_((Pvr_Message<T>)msg);
					return;
				}
				throw new UnityException("Request with no handler.  This should never happen.");
			}
		}
		public class Request
		{
			private Pvr_Message.Callback callback_;

			public long RequestID { get; set; }

			public Request(long requestID)
			{
				RequestID = requestID;
			}

			public Request OnComplete(Pvr_Message.Callback callback)
			{
				callback_ = callback;
				Pvr_Callback.AddRequest(this);
				return this;
			}

			public virtual void HandleMessage(Pvr_Message msg)
			{
				if (callback_ != null)
				{
					callback_(msg);
					return;
				}
				throw new UnityException("Request with no handler.  This should never happen.");
			}

			public static void RunCallbacks(uint limit = 0u)
			{
				if (limit == 0)
				{
					Pvr_Callback.RunCallbacks();
				}
				else
				{
					Pvr_Callback.RunLimitedCallbacks(limit);
				}
			}
		}
	}
	namespace Oculus.Spatializer.Propagation
	{
		public enum FaceType : uint
		{
			TRIANGLES,
			QUADS
		}
		public enum MaterialProperty : uint
		{
			ABSORPTION,
			TRANSMISSION,
			SCATTERING
		}
		[StructLayout(LayoutKind.Sequential, Pack = 1)]
		public struct MeshGroup
		{
			public UIntPtr indexOffset;

			public UIntPtr faceCount;

			[MarshalAs(UnmanagedType.U4)]
			public FaceType faceType;

			public IntPtr material;
		}
	}
	namespace I2.Loc
	{
		public class CallbackNotification : MonoBehaviour
		{
			public void OnModifyLocalization()
			{
				if (!string.IsNullOrEmpty(Localize.MainTranslation))
				{
					string translation = LocalizationManager.GetTranslation("Color/Red");
					Localize.MainTranslation = Localize.MainTranslation.Replace("{PLAYER_COLOR}", translation);
				}
			}
		}
		public class Example_ChangeLanguage : MonoBehaviour
		{
			public void SetLanguage_English()
			{
				SetLanguage("English");
			}

			public void SetLanguage_French()
			{
				SetLanguage("French");
			}

			public void SetLanguage_Spanish()
			{
				SetLanguage("Spanish");
			}

			public void SetLanguage(string LangName)
			{
				if (LocalizationManager.HasLanguage(LangName))
				{
					LocalizationManager.CurrentLanguage = LangName;
				}
			}
		}
		public class Example_LocalizedString : MonoBehaviour
		{
			public LocalizedString _MyLocalizedString;

			public string _NormalString;

			[TermsPopup("")]
			public string _StringWithTermPopup;

			public void Start()
			{
				UnityEngine.Debug.Log(_MyLocalizedString);
				UnityEngine.Debug.Log(LocalizationManager.GetTranslation(_NormalString));
				UnityEngine.Debug.Log(LocalizationManager.GetTranslation(_StringWithTermPopup));
				UnityEngine.Debug.Log((string)(LocalizedString)"Term2");
				UnityEngine.Debug.Log(_MyLocalizedString);
				UnityEngine.Debug.Log((LocalizedString)"Term3");
				LocalizedString localizedString = "Term3";
				localizedString.mRTL_IgnoreArabicFix = true;
				UnityEngine.Debug.Log(localizedString);
				LocalizedString localizedString2 = "Term3";
				localizedString2.mRTL_ConvertNumbers = true;
				localizedString2.mRTL_MaxLineLength = 20;
				UnityEngine.Debug.Log(localizedString2);
				UnityEngine.Debug.Log(localizedString2);
			}
		}
		public class GlobalParametersExample : RegisterGlobalParameters
		{
			public override string GetParameterValue(string ParamName)
			{
				if (ParamName == "WINNER")
				{
					return "Javier";
				}
				if (ParamName == "NUM PLAYERS")
				{
					return 5.ToString();
				}
				return null;
			}
		}
		public class RealTimeTranslation : MonoBehaviour
		{
			private string OriginalText = "This is an example showing how to use the google translator to translate chat messages within the game.\nIt also supports multiline translations.";

			private string TranslatedText = string.Empty;

			private bool IsTranslating;

			public void OnGUI()
			{
				GUILayout.Label("Translate:");
				OriginalText = GUILayout.TextArea(OriginalText, GUILayout.Width(Screen.width));
				GUILayout.Space(10f);
				GUILayout.BeginHorizontal();
				if (GUILayout.Button("English -> Español", GUILayout.Height(100f)))
				{
					StartTranslating("en", "es");
				}
				if (GUILayout.Button("Español -> English", GUILayout.Height(100f)))
				{
					StartTranslating("es", "en");
				}
				GUILayout.EndHorizontal();
				GUILayout.Space(10f);
				GUILayout.BeginHorizontal();
				GUILayout.TextArea("Multiple Translation with 1 call:\n'This is an example' -> en,zh\n'Hola' -> en");
				if (GUILayout.Button("Multi Translate", GUILayout.ExpandHeight(expand: true)))
				{
					ExampleMultiTranslations_Async();
				}
				GUILayout.EndHorizontal();
				GUILayout.TextArea(TranslatedText, GUILayout.Width(Screen.width));
				GUILayout.Space(10f);
				if (IsTranslating)
				{
					GUILayout.Label("Contacting Google....");
				}
			}

			public void StartTranslating(string fromCode, string toCode)
			{
				IsTranslating = true;
				GoogleTranslation.Translate(OriginalText, fromCode, toCode, OnTranslationReady);
			}

			private void OnTranslationReady(string Translation, string errorMsg)
			{
				IsTranslating = false;
				if (errorMsg != null)
				{
					UnityEngine.Debug.LogError(errorMsg);
				}
				else
				{
					TranslatedText = Translation;
				}
			}

			public void ExampleMultiTranslations_Blocking()
			{
				Dictionary<string, TranslationQuery> dictionary = new Dictionary<string, TranslationQuery>();
				GoogleTranslation.AddQuery("This is an example", "en", "es", dictionary);
				GoogleTranslation.AddQuery("This is an example", "auto", "zh", dictionary);
				GoogleTranslation.AddQuery("Hola", "es", "en", dictionary);
				if (GoogleTranslation.ForceTranslate(dictionary))
				{
					UnityEngine.Debug.Log(GoogleTranslation.GetQueryResult("This is an example", "en", dictionary));
					UnityEngine.Debug.Log(GoogleTranslation.GetQueryResult("This is an example", "zh", dictionary));
					UnityEngine.Debug.Log(GoogleTranslation.GetQueryResult("This is an example", "", dictionary));
					UnityEngine.Debug.Log(dictionary["Hola"].Results[0]);
				}
			}

			public void ExampleMultiTranslations_Async()
			{
				IsTranslating = true;
				Dictionary<string, TranslationQuery> dictionary = new Dictionary<string, TranslationQuery>();
				GoogleTranslation.AddQuery("This is an example", "en", "es", dictionary);
				GoogleTranslation.AddQuery("This is an example", "auto", "zh", dictionary);
				GoogleTranslation.AddQuery("Hola", "es", "en", dictionary);
				GoogleTranslation.Translate(dictionary, OnMultitranslationReady);
			}

			private void OnMultitranslationReady(Dictionary<string, TranslationQuery> dict, string errorMsg)
			{
				if (!string.IsNullOrEmpty(errorMsg))
				{
					UnityEngine.Debug.LogError(errorMsg);
					return;
				}
				IsTranslating = false;
				TranslatedText = "";
				TranslatedText = TranslatedText + GoogleTranslation.GetQueryResult("This is an example", "es", dict) + "\n";
				TranslatedText = TranslatedText + GoogleTranslation.GetQueryResult("This is an example", "zh", dict) + "\n";
				TranslatedText = TranslatedText + GoogleTranslation.GetQueryResult("This is an example", "", dict) + "\n";
				TranslatedText += dict["Hola"].Results[0];
			}

			public bool IsWaitingForTranslation()
			{
				return IsTranslating;
			}

			public string GetTranslatedText()
			{
				return TranslatedText;
			}

			public void SetOriginalText(string text)
			{
				OriginalText = text;
			}
		}
		public class RegisterBundlesManager : MonoBehaviour, IResourceManager_Bundles
		{
			public void OnEnable()
			{
				if (!ResourceManager.pInstance.mBundleManagers.Contains(this))
				{
					ResourceManager.pInstance.mBundleManagers.Add(this);
				}
			}

			public void OnDisable()
			{
				ResourceManager.pInstance.mBundleManagers.Remove(this);
			}

			public virtual UnityEngine.Object LoadFromBundle(string path, Type assetType)
			{
				return null;
			}
		}
		public class ToggleLanguage : MonoBehaviour
		{
			private void Start()
			{
				Invoke("test", 3f);
			}

			private void test()
			{
				List<string> allLanguages = LocalizationManager.GetAllLanguages();
				int num = allLanguages.IndexOf(LocalizationManager.CurrentLanguage);
				if (num < 0)
				{
					num = 0;
				}
				else
				{
					num = (num + 1) % allLanguages.Count;
				}
				Invoke("test", 3f);
			}
		}
		public static class PersistentStorage
		{
			public enum eFileType
			{
				Raw,
				Persistent,
				Temporal,
				Streaming
			}

			private static I2CustomPersistentStorage mStorage;

			public static void SetSetting_String(string key, string value)
			{
				if (mStorage == null)
				{
					mStorage = new I2CustomPersistentStorage();
				}
				mStorage.SetSetting_String(key, value);
			}

			public static string GetSetting_String(string key, string defaultValue)
			{
				if (mStorage == null)
				{
					mStorage = new I2CustomPersistentStorage();
				}
				return mStorage.GetSetting_String(key, defaultValue);
			}

			public static void DeleteSetting(string key)
			{
				if (mStorage == null)
				{
					mStorage = new I2CustomPersistentStorage();
				}
				mStorage.DeleteSetting(key);
			}

			public static bool HasSetting(string key)
			{
				if (mStorage == null)
				{
					mStorage = new I2CustomPersistentStorage();
				}
				return mStorage.HasSetting(key);
			}

			public static void ForceSaveSettings()
			{
				if (mStorage == null)
				{
					mStorage = new I2CustomPersistentStorage();
				}
				mStorage.ForceSaveSettings();
			}

			public static bool CanAccessFiles()
			{
				if (mStorage == null)
				{
					mStorage = new I2CustomPersistentStorage();
				}
				return mStorage.CanAccessFiles();
			}

			public static bool SaveFile(eFileType fileType, string fileName, string data, bool logExceptions = true)
			{
				if (mStorage == null)
				{
					mStorage = new I2CustomPersistentStorage();
				}
				return mStorage.SaveFile(fileType, fileName, data, logExceptions);
			}

			public static string LoadFile(eFileType fileType, string fileName, bool logExceptions = true)
			{
				if (mStorage == null)
				{
					mStorage = new I2CustomPersistentStorage();
				}
				return mStorage.LoadFile(fileType, fileName, logExceptions);
			}

			public static bool DeleteFile(eFileType fileType, string fileName, bool logExceptions = true)
			{
				if (mStorage == null)
				{
					mStorage = new I2CustomPersistentStorage();
				}
				return mStorage.DeleteFile(fileType, fileName, logExceptions);
			}

			public static bool HasFile(eFileType fileType, string fileName, bool logExceptions = true)
			{
				if (mStorage == null)
				{
					mStorage = new I2CustomPersistentStorage();
				}
				return mStorage.HasFile(fileType, fileName, logExceptions);
			}
		}
		public abstract class I2BasePersistentStorage
		{
			public virtual void SetSetting_String(string key, string value)
			{
				try
				{
					int length = value.Length;
					int num = 8000;
					if (length <= num)
					{
						PlayerPrefs.SetString(key, value);
						return;
					}
					int num2 = Mathf.CeilToInt((float)length / (float)num);
					for (int i = 0; i < num2; i++)
					{
						int num3 = num * i;
						PlayerPrefs.SetString($"[I2split]{i}{key}", value.Substring(num3, Mathf.Min(num, length - num3)));
					}
					PlayerPrefs.SetString(key, "[$I2#@div$]" + num2);
				}
				catch (Exception)
				{
					UnityEngine.Debug.LogError("Error saving PlayerPrefs " + key);
				}
			}

			public virtual string GetSetting_String(string key, string defaultValue)
			{
				try
				{
					string text = PlayerPrefs.GetString(key, defaultValue);
					if (!string.IsNullOrEmpty(text) && text.StartsWith("[I2split]"))
					{
						int num = int.Parse(text.Substring("[I2split]".Length));
						text = "";
						for (int i = 0; i < num; i++)
						{
							text += PlayerPrefs.GetString($"[I2split]{i}{key}", "");
						}
					}
					return text;
				}
				catch (Exception)
				{
					UnityEngine.Debug.LogError("Error loading PlayerPrefs " + key);
					return defaultValue;
				}
			}

			public virtual void DeleteSetting(string key)
			{
				try
				{
					string @string = PlayerPrefs.GetString(key, null);
					if (!string.IsNullOrEmpty(@string) && @string.StartsWith("[I2split]"))
					{
						int num = int.Parse(@string.Substring("[I2split]".Length));
						for (int i = 0; i < num; i++)
						{
							PlayerPrefs.DeleteKey($"[I2split]{i}{key}");
						}
					}
					PlayerPrefs.DeleteKey(key);
				}
				catch (Exception)
				{
					UnityEngine.Debug.LogError("Error deleting PlayerPrefs " + key);
				}
			}

			public virtual void ForceSaveSettings()
			{
				PlayerPrefs.Save();
			}

			public virtual bool HasSetting(string key)
			{
				return PlayerPrefs.HasKey(key);
			}

			public virtual bool CanAccessFiles()
			{
				return true;
			}

			private string UpdateFilename(PersistentStorage.eFileType fileType, string fileName)
			{
				switch (fileType)
				{
				case PersistentStorage.eFileType.Persistent:
					fileName = Application.persistentDataPath + "/" + fileName;
					break;
				case PersistentStorage.eFileType.Temporal:
					fileName = Application.temporaryCachePath + "/" + fileName;
					break;
				case PersistentStorage.eFileType.Streaming:
					fileName = Application.streamingAssetsPath + "/" + fileName;
					break;
				}
				return fileName;
			}

			public virtual bool SaveFile(PersistentStorage.eFileType fileType, string fileName, string data, bool logExceptions = true)
			{
				if (!CanAccessFiles())
				{
					return false;
				}
				try
				{
					fileName = UpdateFilename(fileType, fileName);
					File.WriteAllText(fileName, data, Encoding.UTF8);
					return true;
				}
				catch (Exception ex)
				{
					if (logExceptions)
					{
						UnityEngine.Debug.LogError("Error saving file '" + fileName + "'\n" + ex);
					}
					return false;
				}
			}

			public virtual string LoadFile(PersistentStorage.eFileType fileType, string fileName, bool logExceptions = true)
			{
				if (!CanAccessFiles())
				{
					return null;
				}
				try
				{
					fileName = UpdateFilename(fileType, fileName);
					return File.ReadAllText(fileName, Encoding.UTF8);
				}
				catch (Exception ex)
				{
					if (logExceptions)
					{
						UnityEngine.Debug.LogError("Error loading file '" + fileName + "'\n" + ex);
					}
					return null;
				}
			}

			public virtual bool DeleteFile(PersistentStorage.eFileType fileType, string fileName, bool logExceptions = true)
			{
				if (!CanAccessFiles())
				{
					return false;
				}
				try
				{
					fileName = UpdateFilename(fileType, fileName);
					File.Delete(fileName);
					return true;
				}
				catch (Exception ex)
				{
					if (logExceptions)
					{
						UnityEngine.Debug.LogError("Error deleting file '" + fileName + "'\n" + ex);
					}
					return false;
				}
			}

			public virtual bool HasFile(PersistentStorage.eFileType fileType, string fileName, bool logExceptions = true)
			{
				if (!CanAccessFiles())
				{
					return false;
				}
				try
				{
					fileName = UpdateFilename(fileType, fileName);
					return File.Exists(fileName);
				}
				catch (Exception ex)
				{
					if (logExceptions)
					{
						UnityEngine.Debug.LogError("Error requesting file '" + fileName + "'\n" + ex);
					}
					return false;
				}
			}
		}
		public class I2CustomPersistentStorage : I2BasePersistentStorage
		{
		}
		public class BaseSpecializationManager
		{
			public string[] mSpecializations;

			public Dictionary<string, string> mSpecializationsFallbacks;

			public virtual void InitializeSpecializations()
			{
				mSpecializations = new string[12]
				{
					"Any", "PC", "Touch", "Controller", "VR", "XBox", "PS4", "OculusVR", "ViveVR", "GearVR",
					"Android", "IOS"
				};
				mSpecializationsFallbacks = new Dictionary<string, string>
				{
					{ "XBox", "Controller" },
					{ "PS4", "Controller" },
					{ "OculusVR", "VR" },
					{ "ViveVR", "VR" },
					{ "GearVR", "VR" },
					{ "Android", "Touch" },
					{ "IOS", "Touch" }
				};
			}

			public virtual string GetCurrentSpecialization()
			{
				if (mSpecializations == null)
				{
					InitializeSpecializations();
				}
				return "Android";
			}

			public virtual string GetFallbackSpecialization(string specialization)
			{
				if (mSpecializationsFallbacks == null)
				{
					InitializeSpecializations();
				}
				if (mSpecializationsFallbacks.TryGetValue(specialization, out var value))
				{
					return value;
				}
				return "Any";
			}
		}
		public class SpecializationManager : BaseSpecializationManager
		{
			public static SpecializationManager Singleton = new SpecializationManager();

			private SpecializationManager()
			{
				InitializeSpecializations();
			}

			public static string GetSpecializedText(string text, string specialization = null)
			{
				int num = text.IndexOf("[i2s_");
				if (num < 0)
				{
					return text;
				}
				if (string.IsNullOrEmpty(specialization))
				{
					specialization = Singleton.GetCurrentSpecialization();
				}
				while (!string.IsNullOrEmpty(specialization) && specialization != "Any")
				{
					string text2 = "[i2s_" + specialization + "]";
					int num2 = text.IndexOf(text2);
					if (num2 < 0)
					{
						specialization = Singleton.GetFallbackSpecialization(specialization);
						continue;
					}
					num2 += text2.Length;
					int num3 = text.IndexOf("[i2s_", num2);
					if (num3 < 0)
					{
						num3 = text.Length;
					}
					return text.Substring(num2, num3 - num2);
				}
				return text.Substring(0, num);
			}

			public static string SetSpecializedText(string text, string newText, string specialization)
			{
				if (string.IsNullOrEmpty(specialization))
				{
					specialization = "Any";
				}
				if ((text == null || !text.Contains("[i2s_")) && specialization == "Any")
				{
					return newText;
				}
				Dictionary<string, string> specializations = GetSpecializations(text);
				specializations[specialization] = newText;
				return SetSpecializedText(specializations);
			}

			public static string SetSpecializedText(Dictionary<string, string> specializations)
			{
				if (!specializations.TryGetValue("Any", out var value))
				{
					value = string.Empty;
				}
				foreach (KeyValuePair<string, string> specialization in specializations)
				{
					if (specialization.Key != "Any" && !string.IsNullOrEmpty(specialization.Value))
					{
						value = value + "[i2s_" + specialization.Key + "]" + specialization.Value;
					}
				}
				return value;
			}

			public static Dictionary<string, string> GetSpecializations(string text, Dictionary<string, string> buffer = null)
			{
				if (buffer == null)
				{
					buffer = new Dictionary<string, string>();
				}
				else
				{
					buffer.Clear();
				}
				if (text == null)
				{
					buffer["Any"] = "";
					return buffer;
				}
				int num = 0;
				int num2 = text.IndexOf("[i2s_");
				if (num2 < 0)
				{
					num2 = text.Length;
				}
				buffer["Any"] = text.Substring(0, num2);
				for (num = num2; num < text.Length; num = num2)
				{
					num += "[i2s_".Length;
					int num3 = text.IndexOf(']', num);
					if (num3 < 0)
					{
						break;
					}
					string key = text.Substring(num, num3 - num);
					num = num3 + 1;
					num2 = text.IndexOf("[i2s_", num);
					if (num2 < 0)
					{
						num2 = text.Length;
					}
					string value = text.Substring(num, num2 - num);
					buffer[key] = value;
				}
				return buffer;
			}

			public static void AppendSpecializations(string text, List<string> list = null)
			{
				if (text == null)
				{
					return;
				}
				if (list == null)
				{
					list = new List<string>();
				}
				if (!list.Contains("Any"))
				{
					list.Add("Any");
				}
				int num = 0;
				while (num < text.Length)
				{
					num = text.IndexOf("[i2s_", num);
					if (num >= 0)
					{
						num += "[i2s_".Length;
						int num2 = text.IndexOf(']', num);
						if (num2 >= 0)
						{
							string item = text.Substring(num, num2 - num);
							if (!list.Contains(item))
							{
								list.Add(item);
							}
							continue;
						}
						break;
					}
					break;
				}
			}
		}
		[Serializable]
		public class EventCallback
		{
			public MonoBehaviour Target;

			public string MethodName = string.Empty;

			public void Execute(UnityEngine.Object Sender = null)
			{
				if (HasCallback() && Application.isPlaying)
				{
					Target.gameObject.SendMessage(MethodName, Sender, SendMessageOptions.DontRequireReceiver);
				}
			}

			public bool HasCallback()
			{
				if (Target != null)
				{
					return !string.IsNullOrEmpty(MethodName);
				}
				return false;
			}
		}
		public enum ePluralType
		{
			Zero,
			One,
			Two,
			Few,
			Many,
			Plural
		}
		public static class GoogleLanguages
		{
			public struct LanguageCodeDef
			{
				public string Code;

				public string GoogleCode;

				public bool HasJoinedWords;

				public int PluralRule;
			}

			public static Dictionary<string, LanguageCodeDef> mLanguageDef = new Dictionary<string, LanguageCodeDef>(StringComparer.Ordinal)
			{
				{
					"Abkhazian",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ab",
						GoogleCode = "-"
					}
				},
				{
					"Afar",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "aa",
						GoogleCode = "-"
					}
				},
				{
					"Afrikaans",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "af"
					}
				},
				{
					"Akan",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ak",
						GoogleCode = "-"
					}
				},
				{
					"Albanian",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "sq"
					}
				},
				{
					"Amharic",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "am"
					}
				},
				{
					"Arabic",
					new LanguageCodeDef
					{
						PluralRule = 11,
						Code = "ar"
					}
				},
				{
					"Arabic/Algeria",
					new LanguageCodeDef
					{
						PluralRule = 11,
						Code = "ar-DZ",
						GoogleCode = "ar"
					}
				},
				{
					"Arabic/Bahrain",
					new LanguageCodeDef
					{
						PluralRule = 11,
						Code = "ar-BH",
						GoogleCode = "ar"
					}
				},
				{
					"Arabic/Egypt",
					new LanguageCodeDef
					{
						PluralRule = 11,
						Code = "ar-EG",
						GoogleCode = "ar"
					}
				},
				{
					"Arabic/Iraq",
					new LanguageCodeDef
					{
						PluralRule = 11,
						Code = "ar-IQ",
						GoogleCode = "ar"
					}
				},
				{
					"Arabic/Jordan",
					new LanguageCodeDef
					{
						PluralRule = 11,
						Code = "ar-JO",
						GoogleCode = "ar"
					}
				},
				{
					"Arabic/Kuwait",
					new LanguageCodeDef
					{
						PluralRule = 11,
						Code = "ar-KW",
						GoogleCode = "ar"
					}
				},
				{
					"Arabic/Lebanon",
					new LanguageCodeDef
					{
						PluralRule = 11,
						Code = "ar-LB",
						GoogleCode = "ar"
					}
				},
				{
					"Arabic/Libya",
					new LanguageCodeDef
					{
						PluralRule = 11,
						Code = "ar-LY",
						GoogleCode = "ar"
					}
				},
				{
					"Arabic/Morocco",
					new LanguageCodeDef
					{
						PluralRule = 11,
						Code = "ar-MA",
						GoogleCode = "ar"
					}
				},
				{
					"Arabic/Oman",
					new LanguageCodeDef
					{
						PluralRule = 11,
						Code = "ar-OM",
						GoogleCode = "ar"
					}
				},
				{
					"Arabic/Qatar",
					new LanguageCodeDef
					{
						PluralRule = 11,
						Code = "ar-QA",
						GoogleCode = "ar"
					}
				},
				{
					"Arabic/Saudi Arabia",
					new LanguageCodeDef
					{
						PluralRule = 11,
						Code = "ar-SA",
						GoogleCode = "ar"
					}
				},
				{
					"Arabic/Syria",
					new LanguageCodeDef
					{
						PluralRule = 11,
						Code = "ar-SY",
						GoogleCode = "ar"
					}
				},
				{
					"Arabic/Tunisia",
					new LanguageCodeDef
					{
						PluralRule = 11,
						Code = "ar-TN",
						GoogleCode = "ar"
					}
				},
				{
					"Arabic/U.A.E.",
					new LanguageCodeDef
					{
						PluralRule = 11,
						Code = "ar-AE",
						GoogleCode = "ar"
					}
				},
				{
					"Arabic/Yemen",
					new LanguageCodeDef
					{
						PluralRule = 11,
						Code = "ar-YE",
						GoogleCode = "ar"
					}
				},
				{
					"Aragonese",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "an",
						GoogleCode = "-"
					}
				},
				{
					"Armenian",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "hy"
					}
				},
				{
					"Assamese",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "as",
						GoogleCode = "-"
					}
				},
				{
					"Avaric",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "av",
						GoogleCode = "-"
					}
				},
				{
					"Avestan",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ae",
						GoogleCode = "-"
					}
				},
				{
					"Aymara",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ay",
						GoogleCode = "-"
					}
				},
				{
					"Azerbaijani",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "az"
					}
				},
				{
					"Bambara",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "bm",
						GoogleCode = "-"
					}
				},
				{
					"Bashkir",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ba",
						GoogleCode = "-"
					}
				},
				{
					"Basque",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "eu"
					}
				},
				{
					"Basque/Spain",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "eu-ES",
						GoogleCode = "eu"
					}
				},
				{
					"Belarusian",
					new LanguageCodeDef
					{
						PluralRule = 6,
						Code = "be"
					}
				},
				{
					"Bengali",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "bn"
					}
				},
				{
					"Bihari",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "bh",
						GoogleCode = "-"
					}
				},
				{
					"Bislama",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "bi",
						GoogleCode = "-"
					}
				},
				{
					"Bosnian",
					new LanguageCodeDef
					{
						PluralRule = 6,
						Code = "bs"
					}
				},
				{
					"Breton",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "br",
						GoogleCode = "-"
					}
				},
				{
					"Bulgariaa",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "bg"
					}
				},
				{
					"Burmese",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "my"
					}
				},
				{
					"Catalan",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ca"
					}
				},
				{
					"Chamorro",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ch",
						GoogleCode = "-"
					}
				},
				{
					"Chechen",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ce",
						GoogleCode = "-"
					}
				},
				{
					"Chichewa",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ny"
					}
				},
				{
					"Chinese",
					new LanguageCodeDef
					{
						PluralRule = 0,
						Code = "zh",
						GoogleCode = "zh-CN",
						HasJoinedWords = true
					}
				},
				{
					"Chinese/Hong Kong",
					new LanguageCodeDef
					{
						PluralRule = 0,
						Code = "zh-HK",
						GoogleCode = "zh-TW",
						HasJoinedWords = true
					}
				},
				{
					"Chinese/Macau",
					new LanguageCodeDef
					{
						PluralRule = 0,
						Code = "zh-MO",
						GoogleCode = "zh-CN",
						HasJoinedWords = true
					}
				},
				{
					"Chinese/PRC",
					new LanguageCodeDef
					{
						PluralRule = 0,
						Code = "zh-CN",
						GoogleCode = "zh-CN",
						HasJoinedWords = true
					}
				},
				{
					"Chinese/Simplified",
					new LanguageCodeDef
					{
						PluralRule = 0,
						Code = "zh-CN",
						GoogleCode = "zh-CN",
						HasJoinedWords = true
					}
				},
				{
					"Chinese/Singapore",
					new LanguageCodeDef
					{
						PluralRule = 0,
						Code = "zh-SG",
						GoogleCode = "zh-CN",
						HasJoinedWords = true
					}
				},
				{
					"Chinese/Taiwan",
					new LanguageCodeDef
					{
						PluralRule = 0,
						Code = "zh-TW",
						GoogleCode = "zh-TW",
						HasJoinedWords = true
					}
				},
				{
					"Chinese/Traditional",
					new LanguageCodeDef
					{
						PluralRule = 0,
						Code = "zh-TW",
						GoogleCode = "zh-TW",
						HasJoinedWords = true
					}
				},
				{
					"Chuvash",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "cv",
						GoogleCode = "-"
					}
				},
				{
					"Cornish",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "kw",
						GoogleCode = "-"
					}
				},
				{
					"Corsican",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "co"
					}
				},
				{
					"Cree",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "cr",
						GoogleCode = "-"
					}
				},
				{
					"Croatian",
					new LanguageCodeDef
					{
						PluralRule = 6,
						Code = "hr"
					}
				},
				{
					"Croatian/Bosnia and Herzegovina",
					new LanguageCodeDef
					{
						PluralRule = 5,
						Code = "hr-BA",
						GoogleCode = "hr"
					}
				},
				{
					"Czech",
					new LanguageCodeDef
					{
						PluralRule = 7,
						Code = "cs"
					}
				},
				{
					"Danish",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "da"
					}
				},
				{
					"Divehi",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "dv",
						GoogleCode = "-"
					}
				},
				{
					"Dutch",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "nl"
					}
				},
				{
					"Dutch/Belgium",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "nl-BE",
						GoogleCode = "nl"
					}
				},
				{
					"Dutch/Netherlands",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "nl-NL",
						GoogleCode = "nl"
					}
				},
				{
					"Dzongkha",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "dz",
						GoogleCode = "-"
					}
				},
				{
					"English",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "en"
					}
				},
				{
					"English/Australia",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "en-AU",
						GoogleCode = "en"
					}
				},
				{
					"English/Belize",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "en-BZ",
						GoogleCode = "en"
					}
				},
				{
					"English/Canada",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "en-CA",
						GoogleCode = "en"
					}
				},
				{
					"English/Caribbean",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "en-CB",
						GoogleCode = "en"
					}
				},
				{
					"English/Ireland",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "en-IE",
						GoogleCode = "en"
					}
				},
				{
					"English/Jamaica",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "en-JM",
						GoogleCode = "en"
					}
				},
				{
					"English/New Zealand",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "en-NZ",
						GoogleCode = "en"
					}
				},
				{
					"English/Republic of the Philippines",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "en-PH",
						GoogleCode = "en"
					}
				},
				{
					"English/South Africa",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "en-ZA",
						GoogleCode = "en"
					}
				},
				{
					"English/Trinidad",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "en-TT",
						GoogleCode = "en"
					}
				},
				{
					"English/United Kingdom",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "en-GB",
						GoogleCode = "en"
					}
				},
				{
					"English/United States",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "en-US",
						GoogleCode = "en"
					}
				},
				{
					"English/Zimbabwe",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "en-ZW",
						GoogleCode = "en"
					}
				},
				{
					"Esperanto",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "eo"
					}
				},
				{
					"Estonian",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "et"
					}
				},
				{
					"Ewe",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ee",
						GoogleCode = "-"
					}
				},
				{
					"Faeroese",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "fo",
						GoogleCode = "-"
					}
				},
				{
					"Fijian",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "fj",
						GoogleCode = "-"
					}
				},
				{
					"Finnish",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "fi"
					}
				},
				{
					"French",
					new LanguageCodeDef
					{
						PluralRule = 2,
						Code = "fr"
					}
				},
				{
					"French/Belgium",
					new LanguageCodeDef
					{
						PluralRule = 2,
						Code = "fr-BE",
						GoogleCode = "fr"
					}
				},
				{
					"French/Canada",
					new LanguageCodeDef
					{
						PluralRule = 2,
						Code = "fr-CA",
						GoogleCode = "fr"
					}
				},
				{
					"French/France",
					new LanguageCodeDef
					{
						PluralRule = 2,
						Code = "fr-FR",
						GoogleCode = "fr"
					}
				},
				{
					"French/Luxembourg",
					new LanguageCodeDef
					{
						PluralRule = 2,
						Code = "fr-LU",
						GoogleCode = "fr"
					}
				},
				{
					"French/Principality of Monaco",
					new LanguageCodeDef
					{
						PluralRule = 2,
						Code = "fr-MC",
						GoogleCode = "fr"
					}
				},
				{
					"French/Switzerland",
					new LanguageCodeDef
					{
						PluralRule = 2,
						Code = "fr-CH",
						GoogleCode = "fr"
					}
				},
				{
					"Fulah",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ff",
						GoogleCode = "-"
					}
				},
				{
					"Galician",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "gl"
					}
				},
				{
					"Galician/Spain",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "gl-ES",
						GoogleCode = "gl"
					}
				},
				{
					"Georgian",
					new LanguageCodeDef
					{
						PluralRule = 0,
						Code = "ka"
					}
				},
				{
					"German",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "de"
					}
				},
				{
					"German/Austria",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "de-AT",
						GoogleCode = "de"
					}
				},
				{
					"German/Germany",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "de-DE",
						GoogleCode = "de"
					}
				},
				{
					"German/Liechtenstein",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "de-LI",
						GoogleCode = "de"
					}
				},
				{
					"German/Luxembourg",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "de-LU",
						GoogleCode = "de"
					}
				},
				{
					"German/Switzerland",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "de-CH",
						GoogleCode = "de"
					}
				},
				{
					"Greek",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "el"
					}
				},
				{
					"Guaraní",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "gn",
						GoogleCode = "-"
					}
				},
				{
					"Gujarati",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "gu"
					}
				},
				{
					"Haitian",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ht"
					}
				},
				{
					"Hausa",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ha"
					}
				},
				{
					"Hebrew",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "he",
						GoogleCode = "iw"
					}
				},
				{
					"Herero",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "hz",
						GoogleCode = "-"
					}
				},
				{
					"Hindi",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "hi"
					}
				},
				{
					"Hiri Motu",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ho",
						GoogleCode = "-"
					}
				},
				{
					"Hungarian",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "hu"
					}
				},
				{
					"Interlingua",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ia",
						GoogleCode = "-"
					}
				},
				{
					"Indonesian",
					new LanguageCodeDef
					{
						PluralRule = 0,
						Code = "id"
					}
				},
				{
					"Interlingue",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ie",
						GoogleCode = "-"
					}
				},
				{
					"Irish",
					new LanguageCodeDef
					{
						PluralRule = 10,
						Code = "ga"
					}
				},
				{
					"Igbo",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ig"
					}
				},
				{
					"Inupiaq",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ik",
						GoogleCode = "-"
					}
				},
				{
					"Ido",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "io",
						GoogleCode = "-"
					}
				},
				{
					"Icelandic",
					new LanguageCodeDef
					{
						PluralRule = 14,
						Code = "is"
					}
				},
				{
					"Italian",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "it"
					}
				},
				{
					"Italian/Italy",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "it-IT",
						GoogleCode = "it"
					}
				},
				{
					"Italian/Switzerland",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "it-CH",
						GoogleCode = "it"
					}
				},
				{
					"Inuktitut",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "iu",
						GoogleCode = "-"
					}
				},
				{
					"Japanese",
					new LanguageCodeDef
					{
						PluralRule = 0,
						Code = "ja",
						HasJoinedWords = true
					}
				},
				{
					"Javanese",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "jv"
					}
				},
				{
					"Kalaallisut",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "kl",
						GoogleCode = "-"
					}
				},
				{
					"Kannada",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "kn"
					}
				},
				{
					"Kanuri",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "kr",
						GoogleCode = "-"
					}
				},
				{
					"Kashmiri",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ks",
						GoogleCode = "-"
					}
				},
				{
					"Kazakh",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "kk"
					}
				},
				{
					"Central Khmer",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "km"
					}
				},
				{
					"Kikuyu",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ki",
						GoogleCode = "-"
					}
				},
				{
					"Kinyarwanda",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "rw",
						GoogleCode = "-"
					}
				},
				{
					"Kirghiz",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ky"
					}
				},
				{
					"Komi",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "kv",
						GoogleCode = "-"
					}
				},
				{
					"Kongo",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "kg",
						GoogleCode = "-"
					}
				},
				{
					"Korean",
					new LanguageCodeDef
					{
						PluralRule = 0,
						Code = "ko"
					}
				},
				{
					"Kurdish",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ku"
					}
				},
				{
					"Kuanyama",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "kj",
						GoogleCode = "-"
					}
				},
				{
					"Latin",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "la"
					}
				},
				{
					"Luxembourgish",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "lb"
					}
				},
				{
					"Ganda",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "lg",
						GoogleCode = "-"
					}
				},
				{
					"Limburgan",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "li",
						GoogleCode = "-"
					}
				},
				{
					"Lingala",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ln",
						GoogleCode = "-"
					}
				},
				{
					"Lao",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "lo"
					}
				},
				{
					"Latvian",
					new LanguageCodeDef
					{
						PluralRule = 5,
						Code = "lv"
					}
				},
				{
					"Luba-Katanga",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "lu",
						GoogleCode = "-"
					}
				},
				{
					"Lithuanian",
					new LanguageCodeDef
					{
						PluralRule = 5,
						Code = "lt"
					}
				},
				{
					"Manx",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "gv",
						GoogleCode = "-"
					}
				},
				{
					"Macedonian",
					new LanguageCodeDef
					{
						PluralRule = 13,
						Code = "mk"
					}
				},
				{
					"Malagasy",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "mg"
					}
				},
				{
					"Malay",
					new LanguageCodeDef
					{
						PluralRule = 0,
						Code = "ms"
					}
				},
				{
					"Malay/Brunei Darussalam",
					new LanguageCodeDef
					{
						PluralRule = 0,
						Code = "ms-BN",
						GoogleCode = "ms"
					}
				},
				{
					"Malay/Malaysia",
					new LanguageCodeDef
					{
						PluralRule = 0,
						Code = "ms-MY",
						GoogleCode = "ms"
					}
				},
				{
					"Malayalam",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ml"
					}
				},
				{
					"Maltese",
					new LanguageCodeDef
					{
						PluralRule = 12,
						Code = "mt"
					}
				},
				{
					"Maori",
					new LanguageCodeDef
					{
						PluralRule = 2,
						Code = "mi"
					}
				},
				{
					"Marathi",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "mr"
					}
				},
				{
					"Marshallese",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "mh",
						GoogleCode = "-"
					}
				},
				{
					"Mongolian",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "mn"
					}
				},
				{
					"Nauru",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "na",
						GoogleCode = "-"
					}
				},
				{
					"Navajo",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "nv",
						GoogleCode = "-"
					}
				},
				{
					"North Ndebele",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "nd",
						GoogleCode = "-"
					}
				},
				{
					"Nepali",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ne"
					}
				},
				{
					"Ndonga",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ng",
						GoogleCode = "-"
					}
				},
				{
					"Northern Sotho",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ns",
						GoogleCode = "st"
					}
				},
				{
					"Norwegian",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "nb",
						GoogleCode = "no"
					}
				},
				{
					"Norwegian/Nynorsk",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "nn",
						GoogleCode = "no"
					}
				},
				{
					"Sichuan Yi",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ii",
						GoogleCode = "-"
					}
				},
				{
					"South Ndebele",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "nr",
						GoogleCode = "-"
					}
				},
				{
					"Occitan",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "oc",
						GoogleCode = "-"
					}
				},
				{
					"Ojibwa",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "oj",
						GoogleCode = "-"
					}
				},
				{
					"Church\u00a0Slavic",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "cu",
						GoogleCode = "-"
					}
				},
				{
					"Oromo",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "om",
						GoogleCode = "-"
					}
				},
				{
					"Oriya",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "or",
						GoogleCode = "-"
					}
				},
				{
					"Ossetian",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "os",
						GoogleCode = "-"
					}
				},
				{
					"Pali",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "pi",
						GoogleCode = "-"
					}
				},
				{
					"Pashto",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ps"
					}
				},
				{
					"Persian",
					new LanguageCodeDef
					{
						PluralRule = 0,
						Code = "fa"
					}
				},
				{
					"Polish",
					new LanguageCodeDef
					{
						PluralRule = 8,
						Code = "pl"
					}
				},
				{
					"Portuguese",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "pt"
					}
				},
				{
					"Portuguese/Brazil",
					new LanguageCodeDef
					{
						PluralRule = 2,
						Code = "pt-BR",
						GoogleCode = "pt"
					}
				},
				{
					"Portuguese/Portugal",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "pt-PT",
						GoogleCode = "pt"
					}
				},
				{
					"Punjabi",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "pa"
					}
				},
				{
					"Quechua",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "qu",
						GoogleCode = "-"
					}
				},
				{
					"Quechua/Bolivia",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "qu-BO",
						GoogleCode = "-"
					}
				},
				{
					"Quechua/Ecuador",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "qu-EC",
						GoogleCode = "-"
					}
				},
				{
					"Quechua/Peru",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "qu-PE",
						GoogleCode = "-"
					}
				},
				{
					"Rhaeto-Romanic",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "rm",
						GoogleCode = "ro"
					}
				},
				{
					"Romanian",
					new LanguageCodeDef
					{
						PluralRule = 4,
						Code = "ro"
					}
				},
				{
					"Rundi",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "rn",
						GoogleCode = "-"
					}
				},
				{
					"Russian",
					new LanguageCodeDef
					{
						PluralRule = 6,
						Code = "ru"
					}
				},
				{
					"Russian/Republic of Moldova",
					new LanguageCodeDef
					{
						PluralRule = 6,
						Code = "ru-MO",
						GoogleCode = "ru"
					}
				},
				{
					"Sanskrit",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "sa",
						GoogleCode = "-"
					}
				},
				{
					"Sardinian",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "sc",
						GoogleCode = "-"
					}
				},
				{
					"Sindhi",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "sd"
					}
				},
				{
					"Northern Sami",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "se",
						GoogleCode = "-"
					}
				},
				{
					"Samoan",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "sm"
					}
				},
				{
					"Sango",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "sg",
						GoogleCode = "-"
					}
				},
				{
					"Serbian",
					new LanguageCodeDef
					{
						PluralRule = 6,
						Code = "sr"
					}
				},
				{
					"Serbian/Bosnia and Herzegovina",
					new LanguageCodeDef
					{
						PluralRule = 5,
						Code = "sr-BA",
						GoogleCode = "sr"
					}
				},
				{
					"Serbian/Serbia and Montenegro",
					new LanguageCodeDef
					{
						PluralRule = 5,
						Code = "sr-SP",
						GoogleCode = "sr"
					}
				},
				{
					"Scottish Gaelic",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "gd"
					}
				},
				{
					"Shona",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "sn"
					}
				},
				{
					"Sinhala",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "si"
					}
				},
				{
					"Slovak",
					new LanguageCodeDef
					{
						PluralRule = 7,
						Code = "sk"
					}
				},
				{
					"Slovenian",
					new LanguageCodeDef
					{
						PluralRule = 9,
						Code = "sl"
					}
				},
				{
					"Somali",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "so"
					}
				},
				{
					"Southern Sotho",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "st"
					}
				},
				{
					"Spanish",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "es"
					}
				},
				{
					"Spanish/Argentina",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "es-AR",
						GoogleCode = "es"
					}
				},
				{
					"Spanish/Bolivia",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "es-BO",
						GoogleCode = "es"
					}
				},
				{
					"Spanish/Castilian",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "es-ES",
						GoogleCode = "es"
					}
				},
				{
					"Spanish/Chile",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "es-CL",
						GoogleCode = "es"
					}
				},
				{
					"Spanish/Colombia",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "es-CO",
						GoogleCode = "es"
					}
				},
				{
					"Spanish/Costa Rica",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "es-CR",
						GoogleCode = "es"
					}
				},
				{
					"Spanish/Dominican Republic",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "es-DO",
						GoogleCode = "es"
					}
				},
				{
					"Spanish/Ecuador",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "es-EC",
						GoogleCode = "es"
					}
				},
				{
					"Spanish/El Salvador",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "es-SV",
						GoogleCode = "es"
					}
				},
				{
					"Spanish/Guatemala",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "es-GT",
						GoogleCode = "es"
					}
				},
				{
					"Spanish/Honduras",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "es-HN",
						GoogleCode = "es"
					}
				},
				{
					"Spanish/Mexico",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "es-MX",
						GoogleCode = "es"
					}
				},
				{
					"Spanish/Nicaragua",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "es-NI",
						GoogleCode = "es"
					}
				},
				{
					"Spanish/Panama",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "es-PA",
						GoogleCode = "es"
					}
				},
				{
					"Spanish/Paraguay",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "es-PY",
						GoogleCode = "es"
					}
				},
				{
					"Spanish/Peru",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "es-PE",
						GoogleCode = "es"
					}
				},
				{
					"Spanish/Puerto Rico",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "es-PR",
						GoogleCode = "es"
					}
				},
				{
					"Spanish/Spain",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "es-ES",
						GoogleCode = "es"
					}
				},
				{
					"Spanish/Uruguay",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "es-UY",
						GoogleCode = "es"
					}
				},
				{
					"Spanish/Venezuela",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "es-VE",
						GoogleCode = "es"
					}
				},
				{
					"Spanish/Latin Americas",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "es-US",
						GoogleCode = "es"
					}
				},
				{
					"Sundanese",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "su"
					}
				},
				{
					"Swahili",
					new LanguageCodeDef
					{
						Code = "sw"
					}
				},
				{
					"Swati",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ss",
						GoogleCode = "-"
					}
				},
				{
					"Swedish",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "sv"
					}
				},
				{
					"Swedish/Finland",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "sv-FI",
						GoogleCode = "sv"
					}
				},
				{
					"Swedish/Sweden",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "sv-SE",
						GoogleCode = "sv"
					}
				},
				{
					"Tamil",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ta"
					}
				},
				{
					"Tatar",
					new LanguageCodeDef
					{
						PluralRule = 0,
						Code = "tt",
						GoogleCode = "-"
					}
				},
				{
					"Telugu",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "te"
					}
				},
				{
					"Tajik",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "tg"
					}
				},
				{
					"Thai",
					new LanguageCodeDef
					{
						PluralRule = 0,
						Code = "th",
						HasJoinedWords = true
					}
				},
				{
					"Tigrinya",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ti",
						GoogleCode = "-"
					}
				},
				{
					"Tibetan",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "bo",
						GoogleCode = "-"
					}
				},
				{
					"Turkmen",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "tk",
						GoogleCode = "-"
					}
				},
				{
					"Tagalog",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "tl"
					}
				},
				{
					"Tswana",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "tn",
						GoogleCode = "-"
					}
				},
				{
					"Tonga",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "to",
						GoogleCode = "-"
					}
				},
				{
					"Turkish",
					new LanguageCodeDef
					{
						PluralRule = 0,
						Code = "tr"
					}
				},
				{
					"Tsonga",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ts",
						GoogleCode = "-"
					}
				},
				{
					"Twi",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "tw",
						GoogleCode = "-"
					}
				},
				{
					"Tahitian",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ty",
						GoogleCode = "-"
					}
				},
				{
					"Uighur",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ug",
						GoogleCode = "-"
					}
				},
				{
					"Ukrainian",
					new LanguageCodeDef
					{
						PluralRule = 6,
						Code = "uk"
					}
				},
				{
					"Urdu",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ur"
					}
				},
				{
					"Uzbek",
					new LanguageCodeDef
					{
						PluralRule = 2,
						Code = "uz"
					}
				},
				{
					"Venda",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ve",
						GoogleCode = "-"
					}
				},
				{
					"Vietnamese",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "vi"
					}
				},
				{
					"Volapük",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "vo",
						GoogleCode = "-"
					}
				},
				{
					"Walloon",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "wa",
						GoogleCode = "-"
					}
				},
				{
					"Welsh",
					new LanguageCodeDef
					{
						PluralRule = 16,
						Code = "cy"
					}
				},
				{
					"Wolof",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "wo",
						GoogleCode = "-"
					}
				},
				{
					"Frisian",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "fy"
					}
				},
				{
					"Xhosa",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "xh"
					}
				},
				{
					"Yiddish",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "yi"
					}
				},
				{
					"Yoruba",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "yo"
					}
				},
				{
					"Zhuang",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "za",
						GoogleCode = "-"
					}
				},
				{
					"Zulu",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "zu"
					}
				}
			};

			public static string GetLanguageCode(string Filter, bool ShowWarnings = false)
			{
				if (string.IsNullOrEmpty(Filter))
				{
					return string.Empty;
				}
				string[] filters = Filter.ToLowerInvariant().Split(" /(),".ToCharArray());
				foreach (KeyValuePair<string, LanguageCodeDef> item in mLanguageDef)
				{
					if (LanguageMatchesFilter(item.Key, filters))
					{
						return item.Value.Code;
					}
				}
				if (ShowWarnings)
				{
					UnityEngine.Debug.Log($"Language '{Filter}' not recognized. Please, add the language code to GoogleTranslation.cs");
				}
				return string.Empty;
			}

			public static List<string> GetLanguagesForDropdown(string Filter, string CodesToExclude)
			{
				string[] filters = Filter.ToLowerInvariant().Split(" /(),".ToCharArray());
				List<string> list = new List<string>();
				foreach (KeyValuePair<string, LanguageCodeDef> item in mLanguageDef)
				{
					if (string.IsNullOrEmpty(Filter) || LanguageMatchesFilter(item.Key, filters))
					{
						string text = string.Concat("[" + item.Value.Code + "]");
						if (!CodesToExclude.Contains(text))
						{
							list.Add(item.Key + " " + text);
						}
					}
				}
				for (int num = list.Count - 2; num >= 0; num--)
				{
					string text2 = list[num].Substring(0, list[num].IndexOf(" ["));
					if (list[num + 1].StartsWith(text2))
					{
						list[num] = text2 + "/" + list[num];
						list.Insert(num + 1, text2 + "/");
					}
				}
				return list;
			}

			private static bool LanguageMatchesFilter(string Language, string[] Filters)
			{
				Language = Language.ToLowerInvariant();
				int i = 0;
				for (int num = Filters.Length; i < num; i++)
				{
					if (Filters[i] != "")
					{
						if (!Language.Contains(Filters[i].ToLower()))
						{
							return false;
						}
						Language = Language.Remove(Language.IndexOf(Filters[i]), Filters[i].Length);
					}
				}
				return true;
			}

			public static string GetFormatedLanguageName(string Language)
			{
				string empty = string.Empty;
				int num = Language.IndexOf(" [");
				if (num > 0)
				{
					Language = Language.Substring(0, num);
				}
				num = Language.IndexOf('/');
				if (num > 0)
				{
					empty = Language.Substring(0, num);
					if (Language == empty + "/" + empty)
					{
						return empty;
					}
					Language = Language.Replace("/", " (") + ")";
				}
				return Language;
			}

			public static string GetCodedLanguage(string Language, string code)
			{
				string languageCode = GetLanguageCode(Language);
				if (string.Compare(code, languageCode, StringComparison.OrdinalIgnoreCase) == 0)
				{
					return Language;
				}
				return Language + " [" + code + "]";
			}

			public static void UnPackCodeFromLanguageName(string CodedLanguage, out string Language, out string code)
			{
				if (string.IsNullOrEmpty(CodedLanguage))
				{
					Language = string.Empty;
					code = string.Empty;
					return;
				}
				int num = CodedLanguage.IndexOf("[");
				if (num < 0)
				{
					Language = CodedLanguage;
					code = GetLanguageCode(Language);
				}
				else
				{
					Language = CodedLanguage.Substring(0, num).Trim();
					code = CodedLanguage.Substring(num + 1, CodedLanguage.IndexOf("]", num) - num - 1);
				}
			}

			public static string GetGoogleLanguageCode(string InternationalCode)
			{
				foreach (KeyValuePair<string, LanguageCodeDef> item in mLanguageDef)
				{
					if (InternationalCode == item.Value.Code)
					{
						if (item.Value.GoogleCode == "-")
						{
							return null;
						}
						return (!string.IsNullOrEmpty(item.Value.GoogleCode)) ? item.Value.GoogleCode : InternationalCode;
					}
				}
				return InternationalCode;
			}

			public static string GetLanguageName(string code, bool useParenthesesForRegion = false, bool allowDiscardRegion = true)
			{
				foreach (KeyValuePair<string, LanguageCodeDef> item in mLanguageDef)
				{
					if (!(code == item.Value.Code))
					{
						continue;
					}
					string text = item.Key;
					if (useParenthesesForRegion)
					{
						int num = text.IndexOf('/');
						if (num > 0)
						{
							text = text.Substring(0, num) + " (" + text.Substring(num + 1) + ")";
						}
					}
					return text;
				}
				if (allowDiscardRegion)
				{
					int num2 = code.IndexOf("-");
					if (num2 > 0)
					{
						return GetLanguageName(code.Substring(0, num2), useParenthesesForRegion, allowDiscardRegion: false);
					}
				}
				return null;
			}

			public static List<string> GetAllInternationalCodes()
			{
				HashSet<string> hashSet = new HashSet<string>();
				foreach (KeyValuePair<string, LanguageCodeDef> item in mLanguageDef)
				{
					hashSet.Add(item.Value.Code);
				}
				return new List<string>(hashSet);
			}

			public static bool LanguageCode_HasJoinedWord(string languageCode)
			{
				foreach (KeyValuePair<string, LanguageCodeDef> item in mLanguageDef)
				{
					if (languageCode == item.Value.GoogleCode || languageCode == item.Value.Code)
					{
						return item.Value.HasJoinedWords;
					}
				}
				return false;
			}

			private static int GetPluralRule(string langCode)
			{
				if (langCode.Length > 2)
				{
					langCode = langCode.Substring(0, 2);
				}
				langCode = langCode.ToLower();
				foreach (KeyValuePair<string, LanguageCodeDef> item in mLanguageDef)
				{
					if (item.Value.Code == langCode)
					{
						return item.Value.PluralRule;
					}
				}
				return 0;
			}

			public static bool LanguageHasPluralType(string langCode, string pluralType)
			{
				switch (pluralType)
				{
				case "Plural":
				case "Zero":
				case "One":
					return true;
				default:
					switch (GetPluralRule(langCode))
					{
					case 3:
						if (!(pluralType == "Two"))
						{
							return pluralType == "Few";
						}
						return true;
					case 4:
					case 5:
					case 6:
					case 7:
					case 8:
						return pluralType == "Few";
					case 9:
						if (!(pluralType == "Two"))
						{
							return pluralType == "Few";
						}
						return true;
					case 10:
					case 11:
					case 15:
					case 16:
						if (!(pluralType == "Two") && !(pluralType == "Few"))
						{
							return pluralType == "Many";
						}
						return true;
					case 12:
						if (!(pluralType == "Few"))
						{
							return pluralType == "Many";
						}
						return true;
					case 13:
						return pluralType == "Two";
					default:
						return false;
					}
				}
			}

			public static ePluralType GetPluralType(string langCode, int n)
			{
				switch (n)
				{
				case 0:
					return ePluralType.Zero;
				case 1:
					return ePluralType.One;
				default:
					switch (GetPluralRule(langCode))
					{
					case 0:
						return ePluralType.Plural;
					case 1:
						if (n != 1)
						{
							return ePluralType.Plural;
						}
						return ePluralType.One;
					case 2:
						if (n > 1)
						{
							return ePluralType.Plural;
						}
						return ePluralType.One;
					case 3:
						switch (n)
						{
						default:
							if (!inRange(n, 3, 10) && !inRange(n, 13, 19))
							{
								return ePluralType.Plural;
							}
							return ePluralType.Few;
						case 2:
						case 12:
							return ePluralType.Two;
						case 1:
						case 11:
							return ePluralType.One;
						}
					case 4:
						if (n != 1)
						{
							if (!inRange(n % 100, 1, 19))
							{
								return ePluralType.Plural;
							}
							return ePluralType.Few;
						}
						return ePluralType.One;
					case 5:
						if (n % 10 != 1 || n % 100 == 11)
						{
							if (n % 10 < 2 || (n % 100 >= 10 && n % 100 < 20))
							{
								return ePluralType.Plural;
							}
							return ePluralType.Few;
						}
						return ePluralType.One;
					case 6:
						if (n % 10 != 1 || n % 100 == 11)
						{
							if (!inRange(n % 10, 2, 4) || inRange(n % 100, 12, 14))
							{
								return ePluralType.Plural;
							}
							return ePluralType.Few;
						}
						return ePluralType.One;
					case 7:
						if (n != 1)
						{
							if (!inRange(n, 2, 4))
							{
								return ePluralType.Plural;
							}
							return ePluralType.Few;
						}
						return ePluralType.One;
					case 8:
						if (n != 1)
						{
							if (!inRange(n % 10, 2, 4) || inRange(n % 100, 12, 14))
							{
								return ePluralType.Plural;
							}
							return ePluralType.Few;
						}
						return ePluralType.One;
					case 9:
						if (n % 100 != 1)
						{
							if (n % 100 != 2)
							{
								if (!inRange(n % 100, 3, 4))
								{
									return ePluralType.Plural;
								}
								return ePluralType.Few;
							}
							return ePluralType.Two;
						}
						return ePluralType.One;
					case 10:
						switch (n)
						{
						default:
							if (!inRange(n, 3, 6))
							{
								if (!inRange(n, 7, 10))
								{
									return ePluralType.Plural;
								}
								return ePluralType.Many;
							}
							return ePluralType.Few;
						case 2:
							return ePluralType.Two;
						case 1:
							return ePluralType.One;
						}
					case 11:
						switch (n)
						{
						default:
							if (!inRange(n % 100, 3, 10))
							{
								if (n % 100 < 11)
								{
									return ePluralType.Plural;
								}
								return ePluralType.Many;
							}
							return ePluralType.Few;
						case 2:
							return ePluralType.Two;
						case 1:
							return ePluralType.One;
						case 0:
							return ePluralType.Zero;
						}
					case 12:
						if (n != 1)
						{
							if (!inRange(n % 100, 1, 10))
							{
								if (!inRange(n % 100, 11, 19))
								{
									return ePluralType.Plural;
								}
								return ePluralType.Many;
							}
							return ePluralType.Few;
						}
						return ePluralType.One;
					case 13:
						if (n % 10 != 1)
						{
							if (n % 10 != 2)
							{
								return ePluralType.Plural;
							}
							return ePluralType.Two;
						}
						return ePluralType.One;
					case 14:
						if (n % 10 != 1 || n % 100 == 11)
						{
							return ePluralType.Plural;
						}
						return ePluralType.One;
					case 15:
						if (n % 10 != 1 || n % 100 == 11 || n % 100 == 71 || n % 100 == 91)
						{
							if (n % 10 != 2 || n % 100 == 12 || n % 100 == 72 || n % 100 == 92)
							{
								if ((n % 10 != 3 && n % 10 != 4 && n % 10 != 9) || n % 100 == 13 || n % 100 == 14 || n % 100 == 19 || n % 100 == 73 || n % 100 == 74 || n % 100 == 79 || n % 100 == 93 || n % 100 == 94 || n % 100 == 99)
								{
									if (n % 1000000 != 0)
									{
										return ePluralType.Plural;
									}
									return ePluralType.Many;
								}
								return ePluralType.Few;
							}
							return ePluralType.Two;
						}
						return ePluralType.One;
					case 16:
						return n switch
						{
							6 => ePluralType.Many, 
							3 => ePluralType.Few, 
							2 => ePluralType.Two, 
							1 => ePluralType.One, 
							0 => ePluralType.Zero, 
							_ => ePluralType.Plural, 
						};
					default:
						return ePluralType.Plural;
					}
				}
			}

			public static int GetPluralTestNumber(string langCode, ePluralType pluralType)
			{
				switch (pluralType)
				{
				case ePluralType.Zero:
					return 0;
				case ePluralType.One:
					return 1;
				case ePluralType.Few:
					return 3;
				case ePluralType.Many:
					switch (GetPluralRule(langCode))
					{
					case 10:
						return 8;
					case 11:
					case 12:
						return 13;
					case 15:
						return 1000000;
					default:
						return 6;
					}
				default:
					return 936;
				}
			}

			private static bool inRange(int amount, int min, int max)
			{
				if (amount >= min)
				{
					return amount <= max;
				}
				return false;
			}
		}
		public static class GoogleTranslation
		{
			public delegate void fnOnTranslated(string Translation, string Error);

			public delegate void fnOnTranslationReady(Dictionary<string, TranslationQuery> dict, string error);

			private static List<UnityWebRequest> mCurrentTranslations = new List<UnityWebRequest>();

			private static List<TranslationJob> mTranslationJobs = new List<TranslationJob>();

			public static bool CanTranslate()
			{
				if (LocalizationManager.Sources.Count > 0)
				{
					return !string.IsNullOrEmpty(LocalizationManager.GetWebServiceURL());
				}
				return false;
			}

			public static void Translate(string text, string LanguageCodeFrom, string LanguageCodeTo, fnOnTranslated OnTranslationReady)
			{
				LocalizationManager.InitializeIfNeeded();
				if (!CanTranslate())
				{
					OnTranslationReady(null, "WebService is not set correctly or needs to be reinstalled");
					return;
				}
				if (LanguageCodeTo == LanguageCodeFrom)
				{
					OnTranslationReady(text, null);
					return;
				}
				Dictionary<string, TranslationQuery> queries = new Dictionary<string, TranslationQuery>();
				if (string.IsNullOrEmpty(LanguageCodeTo))
				{
					OnTranslationReady(string.Empty, null);
					return;
				}
				CreateQueries(text, LanguageCodeFrom, LanguageCodeTo, queries);
				Translate(queries, delegate(Dictionary<string, TranslationQuery> results, string error)
				{
					if (!string.IsNullOrEmpty(error) || results.Count == 0)
					{
						OnTranslationReady(null, error);
					}
					else
					{
						string translation = RebuildTranslation(text, queries, LanguageCodeTo);
						OnTranslationReady(translation, null);
					}
				});
			}

			public static string ForceTranslate(string text, string LanguageCodeFrom, string LanguageCodeTo)
			{
				Dictionary<string, TranslationQuery> dictionary = new Dictionary<string, TranslationQuery>();
				AddQuery(text, LanguageCodeFrom, LanguageCodeTo, dictionary);
				TranslationJob_Main translationJob_Main = new TranslationJob_Main(dictionary, null);
				while (true)
				{
					switch (translationJob_Main.GetState())
					{
					case TranslationJob.eJobState.Running:
						break;
					case TranslationJob.eJobState.Failed:
						return null;
					default:
						return GetQueryResult(text, "", dictionary);
					}
				}
			}

			public static void Translate(Dictionary<string, TranslationQuery> requests, fnOnTranslationReady OnTranslationReady, bool usePOST = true)
			{
				AddTranslationJob(new TranslationJob_Main(requests, OnTranslationReady));
			}

			public static bool ForceTranslate(Dictionary<string, TranslationQuery> requests, bool usePOST = true)
			{
				TranslationJob_Main translationJob_Main = new TranslationJob_Main(requests, null);
				while (true)
				{
					switch (translationJob_Main.GetState())
					{
					case TranslationJob.eJobState.Running:
						break;
					case TranslationJob.eJobState.Failed:
						return false;
					default:
						return true;
					}
				}
			}

			public static List<string> ConvertTranslationRequest(Dictionary<string, TranslationQuery> requests, bool encodeGET)
			{
				List<string> list = new List<string>();
				StringBuilder stringBuilder = new StringBuilder();
				foreach (KeyValuePair<string, TranslationQuery> request in requests)
				{
					TranslationQuery value = request.Value;
					if (stringBuilder.Length > 0)
					{
						stringBuilder.Append("<I2Loc>");
					}
					stringBuilder.Append(GoogleLanguages.GetGoogleLanguageCode(value.LanguageCode));
					stringBuilder.Append(":");
					for (int i = 0; i < value.TargetLanguagesCode.Length; i++)
					{
						if (i != 0)
						{
							stringBuilder.Append(",");
						}
						stringBuilder.Append(GoogleLanguages.GetGoogleLanguageCode(value.TargetLanguagesCode[i]));
					}
					stringBuilder.Append("=");
					string text = ((TitleCase(value.Text) == value.Text) ? value.Text.ToLowerInvariant() : value.Text);
					if (!encodeGET)
					{
						stringBuilder.Append(text);
						continue;
					}
					stringBuilder.Append(Uri.EscapeDataString(text));
					if (stringBuilder.Length > 4000)
					{
						list.Add(stringBuilder.ToString());
						stringBuilder.Length = 0;
					}
				}
				list.Add(stringBuilder.ToString());
				return list;
			}

			private static void AddTranslationJob(TranslationJob job)
			{
				mTranslationJobs.Add(job);
				if (mTranslationJobs.Count == 1)
				{
					CoroutineManager.Start(WaitForTranslations());
				}
			}

			private static IEnumerator WaitForTranslations()
			{
				while (mTranslationJobs.Count > 0)
				{
					TranslationJob[] array = mTranslationJobs.ToArray();
					foreach (TranslationJob translationJob in array)
					{
						if (translationJob.GetState() != 0)
						{
							mTranslationJobs.Remove(translationJob);
						}
					}
					yield return null;
				}
			}

			public static string ParseTranslationResult(string html, Dictionary<string, TranslationQuery> requests)
			{
				if (html.StartsWith("<!DOCTYPE html>") || html.StartsWith("<HTML>"))
				{
					if (html.Contains("The script completed but did not return anything"))
					{
						return "The current Google WebService is not supported.\nPlease, delete the WebService from the Google Drive and Install the latest version.";
					}
					if (html.Contains("Service invoked too many times in a short time"))
					{
						return "";
					}
					return "There was a problem contacting the WebService. Please try again later\n" + html;
				}
				string[] array = html.Split(new string[1] { "<I2Loc>" }, StringSplitOptions.None);
				string[] separator = new string[1] { "<i2>" };
				int num = 0;
				string[] array2 = requests.Keys.ToArray();
				foreach (string text in array2)
				{
					TranslationQuery value = FindQueryFromOrigText(text, requests);
					string text2 = array[num++];
					if (value.Tags != null)
					{
						for (int num2 = value.Tags.Length - 1; num2 >= 0; num2--)
						{
							text2 = text2.Replace(GetGoogleNoTranslateTag(num2), value.Tags[num2]);
						}
					}
					value.Results = text2.Split(separator, StringSplitOptions.None);
					if (TitleCase(text) == text)
					{
						for (int j = 0; j < value.Results.Length; j++)
						{
							value.Results[j] = TitleCase(value.Results[j]);
						}
					}
					requests[value.OrigText] = value;
				}
				return null;
			}

			public static bool IsTranslating()
			{
				if (mCurrentTranslations.Count <= 0)
				{
					return mTranslationJobs.Count > 0;
				}
				return true;
			}

			public static void CancelCurrentGoogleTranslations()
			{
				mCurrentTranslations.Clear();
				foreach (TranslationJob mTranslationJob in mTranslationJobs)
				{
					mTranslationJob.Dispose();
				}
				mTranslationJobs.Clear();
			}

			public static void CreateQueries(string text, string LanguageCodeFrom, string LanguageCodeTo, Dictionary<string, TranslationQuery> dict)
			{
				if (!text.Contains("[i2s_"))
				{
					CreateQueries_Plurals(text, LanguageCodeFrom, LanguageCodeTo, dict);
					return;
				}
				foreach (KeyValuePair<string, string> specialization in SpecializationManager.GetSpecializations(text))
				{
					CreateQueries_Plurals(specialization.Value, LanguageCodeFrom, LanguageCodeTo, dict);
				}
			}

			private static void CreateQueries_Plurals(string text, string LanguageCodeFrom, string LanguageCodeTo, Dictionary<string, TranslationQuery> dict)
			{
				bool flag = text.Contains("{[#");
				bool flag2 = text.Contains("[i2p_");
				if (!HasParameters(text) || (!flag && !flag2))
				{
					AddQuery(text, LanguageCodeFrom, LanguageCodeTo, dict);
					return;
				}
				bool forceTag = flag;
				for (ePluralType ePluralType2 = ePluralType.Zero; ePluralType2 <= ePluralType.Plural; ePluralType2++)
				{
					string pluralType = ePluralType2.ToString();
					if (GoogleLanguages.LanguageHasPluralType(LanguageCodeTo, pluralType))
					{
						string text2 = GetPluralText(text, pluralType);
						int pluralTestNumber = GoogleLanguages.GetPluralTestNumber(LanguageCodeTo, ePluralType2);
						string pluralParameter = GetPluralParameter(text2, forceTag);
						if (!string.IsNullOrEmpty(pluralParameter))
						{
							text2 = text2.Replace(pluralParameter, pluralTestNumber.ToString());
						}
						AddQuery(text2, LanguageCodeFrom, LanguageCodeTo, dict);
					}
				}
			}

			public static void AddQuery(string text, string LanguageCodeFrom, string LanguageCodeTo, Dictionary<string, TranslationQuery> dict)
			{
				if (string.IsNullOrEmpty(text))
				{
					return;
				}
				if (!dict.ContainsKey(text))
				{
					TranslationQuery translationQuery = default(TranslationQuery);
					translationQuery.OrigText = text;
					translationQuery.LanguageCode = LanguageCodeFrom;
					translationQuery.TargetLanguagesCode = new string[1] { LanguageCodeTo };
					TranslationQuery query = translationQuery;
					query.Text = text;
					ParseNonTranslatableElements(ref query);
					dict[text] = query;
				}
				else
				{
					TranslationQuery value = dict[text];
					if (Array.IndexOf(value.TargetLanguagesCode, LanguageCodeTo) < 0)
					{
						value.TargetLanguagesCode = value.TargetLanguagesCode.Concat(new string[1] { LanguageCodeTo }).Distinct().ToArray();
					}
					dict[text] = value;
				}
			}

			private static string GetTranslation(string text, string LanguageCodeTo, Dictionary<string, TranslationQuery> dict)
			{
				if (!dict.ContainsKey(text))
				{
					return null;
				}
				TranslationQuery translationQuery = dict[text];
				int num = Array.IndexOf(translationQuery.TargetLanguagesCode, LanguageCodeTo);
				if (num < 0)
				{
					return "";
				}
				if (translationQuery.Results == null)
				{
					return "";
				}
				return translationQuery.Results[num];
			}

			private static TranslationQuery FindQueryFromOrigText(string origText, Dictionary<string, TranslationQuery> dict)
			{
				foreach (KeyValuePair<string, TranslationQuery> item in dict)
				{
					if (item.Value.OrigText == origText)
					{
						return item.Value;
					}
				}
				return default(TranslationQuery);
			}

			public static bool HasParameters(string text)
			{
				int num = text.IndexOf("{[");
				if (num < 0)
				{
					return false;
				}
				return text.IndexOf("]}", num) > 0;
			}

			public static string GetPluralParameter(string text, bool forceTag)
			{
				int num = text.IndexOf("{[#");
				if (num < 0)
				{
					if (forceTag)
					{
						return null;
					}
					num = text.IndexOf("{[");
				}
				if (num < 0)
				{
					return null;
				}
				int num2 = text.IndexOf("]}", num + 2);
				if (num2 < 0)
				{
					return null;
				}
				return text.Substring(num, num2 - num + 2);
			}

			public static string GetPluralText(string text, string pluralType)
			{
				pluralType = "[i2p_" + pluralType + "]";
				int num = text.IndexOf(pluralType);
				if (num >= 0)
				{
					num += pluralType.Length;
					int num2 = text.IndexOf("[i2p_", num);
					if (num2 < 0)
					{
						num2 = text.Length;
					}
					return text.Substring(num, num2 - num);
				}
				num = text.IndexOf("[i2p_");
				if (num < 0)
				{
					return text;
				}
				if (num > 0)
				{
					return text.Substring(0, num);
				}
				num = text.IndexOf("]");
				if (num < 0)
				{
					return text;
				}
				num++;
				int num3 = text.IndexOf("[i2p_", num);
				if (num3 < 0)
				{
					num3 = text.Length;
				}
				return text.Substring(num, num3 - num);
			}

			private static int FindClosingTag(string tag, MatchCollection matches, int startIndex)
			{
				int i = startIndex;
				for (int count = matches.Count; i < count; i++)
				{
					string captureMatch = I2Utils.GetCaptureMatch(matches[i]);
					if (captureMatch[0] == '/' && tag.StartsWith(captureMatch.Substring(1)))
					{
						return i;
					}
				}
				return -1;
			}

			private static string GetGoogleNoTranslateTag(int tagNumber)
			{
				if (tagNumber < 70)
				{
					return "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++".Substring(0, tagNumber + 1);
				}
				string text = "";
				for (int i = -1; i < tagNumber; i++)
				{
					text += "+";
				}
				return text;
			}

			private static void ParseNonTranslatableElements(ref TranslationQuery query)
			{
				MatchCollection matchCollection = Regex.Matches(query.Text, "\\{\\[(.*?)]}|\\[(.*?)]|\\<(.*?)>");
				if (matchCollection == null || matchCollection.Count == 0)
				{
					return;
				}
				string text = query.Text;
				List<string> list = new List<string>();
				int i = 0;
				for (int count = matchCollection.Count; i < count; i++)
				{
					string captureMatch = I2Utils.GetCaptureMatch(matchCollection[i]);
					int num = FindClosingTag(captureMatch, matchCollection, i);
					if (num < 0)
					{
						string text2 = matchCollection[i].ToString();
						if (text2.StartsWith("{[") && text2.EndsWith("]}"))
						{
							text = text.Replace(text2, GetGoogleNoTranslateTag(list.Count) + " ");
							list.Add(text2);
						}
					}
					else if (captureMatch == "i2nt")
					{
						string text3 = query.Text.Substring(matchCollection[i].Index, matchCollection[num].Index - matchCollection[i].Index + matchCollection[num].Length);
						text = text.Replace(text3, GetGoogleNoTranslateTag(list.Count) + " ");
						list.Add(text3);
					}
					else
					{
						string text4 = matchCollection[i].ToString();
						text = text.Replace(text4, GetGoogleNoTranslateTag(list.Count) + " ");
						list.Add(text4);
						string text5 = matchCollection[num].ToString();
						text = text.Replace(text5, GetGoogleNoTranslateTag(list.Count) + " ");
						list.Add(text5);
					}
				}
				query.Text = text;
				query.Tags = list.ToArray();
			}

			public static string GetQueryResult(string text, string LanguageCodeTo, Dictionary<string, TranslationQuery> dict)
			{
				if (!dict.ContainsKey(text))
				{
					return null;
				}
				TranslationQuery translationQuery = dict[text];
				if (translationQuery.Results == null || translationQuery.Results.Length < 0)
				{
					return null;
				}
				if (string.IsNullOrEmpty(LanguageCodeTo))
				{
					return translationQuery.Results[0];
				}
				int num = Array.IndexOf(translationQuery.TargetLanguagesCode, LanguageCodeTo);
				if (num < 0)
				{
					return null;
				}
				return translationQuery.Results[num];
			}

			public static string RebuildTranslation(string text, Dictionary<string, TranslationQuery> dict, string LanguageCodeTo)
			{
				if (!text.Contains("[i2s_"))
				{
					return RebuildTranslation_Plural(text, dict, LanguageCodeTo);
				}
				Dictionary<string, string> specializations = SpecializationManager.GetSpecializations(text);
				Dictionary<string, string> dictionary = new Dictionary<string, string>();
				foreach (KeyValuePair<string, string> item in specializations)
				{
					dictionary[item.Key] = RebuildTranslation_Plural(item.Value, dict, LanguageCodeTo);
				}
				return SpecializationManager.SetSpecializedText(dictionary);
			}

			private static string RebuildTranslation_Plural(string text, Dictionary<string, TranslationQuery> dict, string LanguageCodeTo)
			{
				bool flag = text.Contains("{[#");
				bool flag2 = text.Contains("[i2p_");
				if (!HasParameters(text) || (!flag && !flag2))
				{
					return GetTranslation(text, LanguageCodeTo, dict);
				}
				StringBuilder stringBuilder = new StringBuilder();
				string text2 = null;
				bool forceTag = flag;
				for (ePluralType ePluralType2 = ePluralType.Plural; ePluralType2 >= ePluralType.Zero; ePluralType2--)
				{
					string text3 = ePluralType2.ToString();
					if (!GoogleLanguages.LanguageHasPluralType(LanguageCodeTo, text3))
					{
						continue;
					}
					string text4 = GetPluralText(text, text3);
					int pluralTestNumber = GoogleLanguages.GetPluralTestNumber(LanguageCodeTo, ePluralType2);
					string pluralParameter = GetPluralParameter(text4, forceTag);
					if (!string.IsNullOrEmpty(pluralParameter))
					{
						text4 = text4.Replace(pluralParameter, pluralTestNumber.ToString());
					}
					string text5 = GetTranslation(text4, LanguageCodeTo, dict);
					if (!string.IsNullOrEmpty(pluralParameter))
					{
						text5 = text5.Replace(pluralTestNumber.ToString(), pluralParameter);
					}
					if (ePluralType2 == ePluralType.Plural)
					{
						text2 = text5;
					}
					else
					{
						if (text5 == text2)
						{
							continue;
						}
						stringBuilder.AppendFormat("[i2p_{0}]", text3);
					}
					stringBuilder.Append(text5);
				}
				return stringBuilder.ToString();
			}

			public static string UppercaseFirst(string s)
			{
				if (string.IsNullOrEmpty(s))
				{
					return string.Empty;
				}
				char[] array = s.ToLower().ToCharArray();
				array[0] = char.ToUpper(array[0]);
				return new string(array);
			}

			public static string TitleCase(string s)
			{
				if (string.IsNullOrEmpty(s))
				{
					return string.Empty;
				}
				return CultureInfo.CurrentCulture.TextInfo.ToTitleCase(s);
			}
		}
		public struct TranslationQuery
		{
			public string OrigText;

			public string Text;

			public string LanguageCode;

			public string[] TargetLanguagesCode;

			public string[] Results;

			public string[] Tags;
		}
		public class TranslationJob : IDisposable
		{
			public enum eJobState
			{
				Running,
				Succeeded,
				Failed
			}

			public eJobState mJobState;

			public virtual eJobState GetState()
			{
				return mJobState;
			}

			public virtual void Dispose()
			{
			}
		}
		public class TranslationJob_WWW : TranslationJob
		{
			public UnityWebRequest www;

			public override void Dispose()
			{
				if (www != null)
				{
					www.Dispose();
				}
				www = null;
			}
		}
		public class TranslationJob_GET : TranslationJob_WWW
		{
			private Dictionary<string, TranslationQuery> _requests;

			private GoogleTranslation.fnOnTranslationReady _OnTranslationReady;

			private List<string> mQueries;

			public string mErrorMessage;

			public TranslationJob_GET(Dictionary<string, TranslationQuery> requests, GoogleTranslation.fnOnTranslationReady OnTranslationReady)
			{
				_requests = requests;
				_OnTranslationReady = OnTranslationReady;
				mQueries = GoogleTranslation.ConvertTranslationRequest(requests, encodeGET: true);
				GetState();
			}

			private void ExecuteNextQuery()
			{
				if (mQueries.Count == 0)
				{
					mJobState = eJobState.Succeeded;
					return;
				}
				int index = mQueries.Count - 1;
				string arg = mQueries[index];
				mQueries.RemoveAt(index);
				string uri = $"{LocalizationManager.GetWebServiceURL()}?action=Translate&list={arg}";
				www = UnityWebRequest.Get(uri);
				I2Utils.SendWebRequest(www);
			}

			public override eJobState GetState()
			{
				if (www != null && www.isDone)
				{
					ProcessResult(www.downloadHandler.data, www.error);
					www.Dispose();
					www = null;
				}
				if (www == null)
				{
					ExecuteNextQuery();
				}
				return mJobState;
			}

			public void ProcessResult(byte[] bytes, string errorMsg)
			{
				if (string.IsNullOrEmpty(errorMsg))
				{
					errorMsg = GoogleTranslation.ParseTranslationResult(Encoding.UTF8.GetString(bytes, 0, bytes.Length), _requests);
					if (string.IsNullOrEmpty(errorMsg))
					{
						if (_OnTranslationReady != null)
						{
							_OnTranslationReady(_requests, null);
						}
						return;
					}
				}
				mJobState = eJobState.Failed;
				mErrorMessage = errorMsg;
			}
		}
		public class TranslationJob_Main : TranslationJob
		{
			private TranslationJob_WEB mWeb;

			private TranslationJob_POST mPost;

			private TranslationJob_GET mGet;

			private Dictionary<string, TranslationQuery> _requests;

			private GoogleTranslation.fnOnTranslationReady _OnTranslationReady;

			public string mErrorMessage;

			public TranslationJob_Main(Dictionary<string, TranslationQuery> requests, GoogleTranslation.fnOnTranslationReady OnTranslationReady)
			{
				_requests = requests;
				_OnTranslationReady = OnTranslationReady;
				mPost = new TranslationJob_POST(requests, OnTranslationReady);
			}

			public override eJobState GetState()
			{
				if (mWeb != null)
				{
					switch (mWeb.GetState())
					{
					case eJobState.Running:
						return eJobState.Running;
					case eJobState.Succeeded:
						mJobState = eJobState.Succeeded;
						break;
					case eJobState.Failed:
						mWeb.Dispose();
						mWeb = null;
						mPost = new TranslationJob_POST(_requests, _OnTranslationReady);
						break;
					}
				}
				if (mPost != null)
				{
					switch (mPost.GetState())
					{
					case eJobState.Running:
						return eJobState.Running;
					case eJobState.Succeeded:
						mJobState = eJobState.Succeeded;
						break;
					case eJobState.Failed:
						mPost.Dispose();
						mPost = null;
						mGet = new TranslationJob_GET(_requests, _OnTranslationReady);
						break;
					}
				}
				if (mGet != null)
				{
					switch (mGet.GetState())
					{
					case eJobState.Running:
						return eJobState.Running;
					case eJobState.Succeeded:
						mJobState = eJobState.Succeeded;
						break;
					case eJobState.Failed:
						mErrorMessage = mGet.mErrorMessage;
						if (_OnTranslationReady != null)
						{
							_OnTranslationReady(_requests, mErrorMessage);
						}
						mGet.Dispose();
						mGet = null;
						break;
					}
				}
				return mJobState;
			}

			public override void Dispose()
			{
				if (mPost != null)
				{
					mPost.Dispose();
				}
				if (mGet != null)
				{
					mGet.Dispose();
				}
				mPost = null;
				mGet = null;
			}
		}
		public class TranslationJob_POST : TranslationJob_WWW
		{
			private Dictionary<string, TranslationQuery> _requests;

			private GoogleTranslation.fnOnTranslationReady _OnTranslationReady;

			public TranslationJob_POST(Dictionary<string, TranslationQuery> requests, GoogleTranslation.fnOnTranslationReady OnTranslationReady)
			{
				_requests = requests;
				_OnTranslationReady = OnTranslationReady;
				List<string> list = GoogleTranslation.ConvertTranslationRequest(requests, encodeGET: false);
				WWWForm wWWForm = new WWWForm();
				wWWForm.AddField("action", "Translate");
				wWWForm.AddField("list", list[0]);
				www = UnityWebRequest.Post(LocalizationManager.GetWebServiceURL(), wWWForm);
				I2Utils.SendWebRequest(www);
			}

			public override eJobState GetState()
			{
				if (www != null && www.isDone)
				{
					ProcessResult(www.downloadHandler.data, www.error);
					www.Dispose();
					www = null;
				}
				return mJobState;
			}

			public void ProcessResult(byte[] bytes, string errorMsg)
			{
				if (!string.IsNullOrEmpty(errorMsg))
				{
					mJobState = eJobState.Failed;
					return;
				}
				errorMsg = GoogleTranslation.ParseTranslationResult(Encoding.UTF8.GetString(bytes, 0, bytes.Length), _requests);
				if (_OnTranslationReady != null)
				{
					_OnTranslationReady(_requests, errorMsg);
				}
				mJobState = eJobState.Succeeded;
			}
		}
		public class TranslationJob_WEB : TranslationJob_WWW
		{
			private Dictionary<string, TranslationQuery> _requests;

			private GoogleTranslation.fnOnTranslationReady _OnTranslationReady;

			public string mErrorMessage;

			private string mCurrentBatch_ToLanguageCode;

			private string mCurrentBatch_FromLanguageCode;

			private List<string> mCurrentBatch_Text;

			private List<KeyValuePair<string, string>> mQueries;

			public TranslationJob_WEB(Dictionary<string, TranslationQuery> requests, GoogleTranslation.fnOnTranslationReady OnTranslationReady)
			{
				_requests = requests;
				_OnTranslationReady = OnTranslationReady;
				FindAllQueries();
				ExecuteNextBatch();
			}

			private void FindAllQueries()
			{
				mQueries = new List<KeyValuePair<string, string>>();
				foreach (KeyValuePair<string, TranslationQuery> request in _requests)
				{
					string[] targetLanguagesCode = request.Value.TargetLanguagesCode;
					foreach (string text in targetLanguagesCode)
					{
						mQueries.Add(new KeyValuePair<string, string>(request.Value.OrigText, request.Value.LanguageCode + ":" + text));
					}
				}
				mQueries.Sort((KeyValuePair<string, string> a, KeyValuePair<string, string> b) => a.Value.CompareTo(b.Value));
			}

			private void ExecuteNextBatch()
			{
				if (mQueries.Count == 0)
				{
					mJobState = eJobState.Succeeded;
					return;
				}
				mCurrentBatch_Text = new List<string>();
				string text = null;
				int num = 200;
				StringBuilder stringBuilder = new StringBuilder();
				int i;
				for (i = 0; i < mQueries.Count; i++)
				{
					string key = mQueries[i].Key;
					string value = mQueries[i].Value;
					if (text == null || value == text)
					{
						if (i != 0)
						{
							stringBuilder.Append("|||");
						}
						stringBuilder.Append(key);
						mCurrentBatch_Text.Add(key);
						text = value;
					}
					if (stringBuilder.Length > num)
					{
						break;
					}
				}
				mQueries.RemoveRange(0, i);
				string[] array = text.Split(':');
				mCurrentBatch_FromLanguageCode = array[0];
				mCurrentBatch_ToLanguageCode = array[1];
				string text2 = $"http://www.google.com/translate_t?hl=en&vi=c&ie=UTF8&oe=UTF8&submit=Translate&langpair={mCurrentBatch_FromLanguageCode}|{mCurrentBatch_ToLanguageCode}&text={Uri.EscapeUriString(stringBuilder.ToString())}";
				UnityEngine.Debug.Log(text2);
				www = UnityWebRequest.Get(text2);
				I2Utils.SendWebRequest(www);
			}

			public override eJobState GetState()
			{
				if (www != null && www.isDone)
				{
					ProcessResult(www.downloadHandler.data, www.error);
					www.Dispose();
					www = null;
				}
				if (www == null)
				{
					ExecuteNextBatch();
				}
				return mJobState;
			}

			public void ProcessResult(byte[] bytes, string errorMsg)
			{
				if (string.IsNullOrEmpty(errorMsg))
				{
					string @string = Encoding.UTF8.GetString(bytes, 0, bytes.Length);
					UnityEngine.Debug.Log(ParseTranslationResult(@string, "aab"));
					if (string.IsNullOrEmpty(errorMsg))
					{
						if (_OnTranslationReady != null)
						{
							_OnTranslationReady(_requests, null);
						}
						return;
					}
				}
				mJobState = eJobState.Failed;
				mErrorMessage = errorMsg;
			}

			private string ParseTranslationResult(string html, string OriginalText)
			{
				try
				{
					int num = html.IndexOf("TRANSLATED_TEXT='") + "TRANSLATED_TEXT='".Length;
					int num2 = html.IndexOf("';var", num);
					string input = html.Substring(num, num2 - num);
					input = Regex.Replace(input, "\\\\x([a-fA-F0-9]{2})", (Match match) => char.ConvertFromUtf32(int.Parse(match.Groups[1].Value, NumberStyles.HexNumber)));
					input = Regex.Replace(input, "&#(\\d+);", (Match match) => char.ConvertFromUtf32(int.Parse(match.Groups[1].Value)));
					input = input.Replace("<br>", "\n");
					if (OriginalText.ToUpper() == OriginalText)
					{
						input = input.ToUpper();
					}
					else if (GoogleTranslation.UppercaseFirst(OriginalText) == OriginalText)
					{
						input = GoogleTranslation.UppercaseFirst(input);
					}
					else if (GoogleTranslation.TitleCase(OriginalText) == OriginalText)
					{
						input = GoogleTranslation.TitleCase(input);
					}
					return input;
				}
				catch (Exception ex)
				{
					UnityEngine.Debug.LogError(ex.Message);
					return string.Empty;
				}
			}
		}
		public enum eLanguageDataFlags
		{
			DISABLED = 1,
			KEEP_LOADED = 2,
			NOT_LOADED = 4
		}
		[Serializable]
		public class LanguageData
		{
			public string Name;

			public string Code;

			public byte Flags;

			[NonSerialized]
			public bool Compressed;

			public bool IsEnabled()
			{
				return (Flags & 1) == 0;
			}

			public void SetEnabled(bool bEnabled)
			{
				if (bEnabled)
				{
					Flags = (byte)(Flags & 0xFFFFFFFEu);
				}
				else
				{
					Flags |= 1;
				}
			}

			public bool IsLoaded()
			{
				return (Flags & 4) == 0;
			}

			public bool CanBeUnloaded()
			{
				return (Flags & 2) == 0;
			}

			public void SetLoaded(bool loaded)
			{
				if (loaded)
				{
					Flags = (byte)(Flags & 0xFFFFFFFBu);
				}
				else
				{
					Flags |= 4;
				}
			}

			public void SetCanBeUnLoaded(bool allowUnloading)
			{
				if (allowUnloading)
				{
					Flags = (byte)(Flags & 0xFFFFFFFDu);
				}
				else
				{
					Flags |= 2;
				}
			}
		}
		[AddComponentMenu("I2/Localization/Source")]
		[ExecuteInEditMode]
		public class LanguageSource : MonoBehaviour, ISerializationCallbackReceiver, ILanguageSource
		{
			public delegate void fnOnSourceUpdated(LanguageSourceData source, bool ReceivedNewData, string errorMsg);

			public LanguageSourceData mSource = new LanguageSourceData();

			public int version;

			public bool NeverDestroy;

			public bool UserAgreesToHaveItOnTheScene;

			public bool UserAgreesToHaveItInsideThePluginsFolder;

			public bool GoogleLiveSyncIsUptoDate = true;

			public List<UnityEngine.Object> Assets = new List<UnityEngine.Object>();

			public string Google_WebServiceURL;

			public string Google_SpreadsheetKey;

			public string Google_SpreadsheetName;

			public string Google_LastUpdatedVersion;

			public LanguageSourceData.eGoogleUpdateFrequency GoogleUpdateFrequency = LanguageSourceData.eGoogleUpdateFrequency.Weekly;

			public float GoogleUpdateDelay = 5f;

			public List<LanguageData> mLanguages = new List<LanguageData>();

			public bool IgnoreDeviceLanguage;

			public LanguageSourceData.eAllowUnloadLanguages _AllowUnloadingLanguages;

			public List<TermData> mTerms = new List<TermData>();

			public bool CaseInsensitiveTerms;

			public LanguageSourceData.MissingTranslationAction OnMissingTranslation = LanguageSourceData.MissingTranslationAction.Fallback;

			public string mTerm_AppName;

			public LanguageSourceData SourceData
			{
				get
				{
					return mSource;
				}
				set
				{
					mSource = value;
				}
			}

			public event fnOnSourceUpdated Event_OnSourceUpdateFromGoogle;

			private void Awake()
			{
				mSource.owner = this;
				mSource.Awake();
			}

			private void OnDestroy()
			{
				NeverDestroy = false;
				if (!NeverDestroy)
				{
					mSource.OnDestroy();
				}
			}

			public string GetSourceName()
			{
				string text = base.gameObject.name;
				Transform parent = base.transform.parent;
				while ((bool)parent)
				{
					text = parent.name + "_" + text;
					parent = parent.parent;
				}
				return text;
			}

			public void OnBeforeSerialize()
			{
				version = 1;
			}

			public void OnAfterDeserialize()
			{
				if (version != 0 && mSource != null)
				{
					return;
				}
				mSource = new LanguageSourceData();
				mSource.owner = this;
				mSource.UserAgreesToHaveItOnTheScene = UserAgreesToHaveItOnTheScene;
				mSource.UserAgreesToHaveItInsideThePluginsFolder = UserAgreesToHaveItInsideThePluginsFolder;
				mSource.IgnoreDeviceLanguage = IgnoreDeviceLanguage;
				mSource._AllowUnloadingLanguages = _AllowUnloadingLanguages;
				mSource.CaseInsensitiveTerms = CaseInsensitiveTerms;
				mSource.OnMissingTranslation = OnMissingTranslation;
				mSource.mTerm_AppName = mTerm_AppName;
				mSource.GoogleLiveSyncIsUptoDate = GoogleLiveSyncIsUptoDate;
				mSource.Google_WebServiceURL = Google_WebServiceURL;
				mSource.Google_SpreadsheetKey = Google_SpreadsheetKey;
				mSource.Google_SpreadsheetName = Google_SpreadsheetName;
				mSource.Google_LastUpdatedVersion = Google_LastUpdatedVersion;
				mSource.GoogleUpdateFrequency = GoogleUpdateFrequency;
				mSource.GoogleUpdateDelay = GoogleUpdateDelay;
				mSource.Event_OnSourceUpdateFromGoogle += this.Event_OnSourceUpdateFromGoogle;
				if (mLanguages != null && mLanguages.Count > 0)
				{
					mSource.mLanguages.Clear();
					mSource.mLanguages.AddRange(mLanguages);
					mLanguages.Clear();
				}
				if (Assets != null && Assets.Count > 0)
				{
					mSource.Assets.Clear();
					mSource.Assets.AddRange(Assets);
					Assets.Clear();
				}
				if (mTerms != null && mTerms.Count > 0)
				{
					mSource.mTerms.Clear();
					for (int i = 0; i < mTerms.Count; i++)
					{
						mSource.mTerms.Add(mTerms[i]);
					}
					mTerms.Clear();
				}
				version = 1;
				this.Event_OnSourceUpdateFromGoogle = null;
			}
		}
		[CreateAssetMenu(fileName = "I2Languages", menuName = "I2 Localization/LanguageSource", order = 1)]
		public class LanguageSourceAsset : ScriptableObject, ILanguageSource
		{
			public LanguageSourceData mSource = new LanguageSourceData();

			public LanguageSourceData SourceData
			{
				get
				{
					return mSource;
				}
				set
				{
					mSource = value;
				}
			}
		}
		public interface ILanguageSource
		{
			LanguageSourceData SourceData { get; set; }
		}
		[Serializable]
		[ExecuteInEditMode]
		public class LanguageSourceData
		{
			public enum MissingTranslationAction
			{
				Empty,
				Fallback,
				ShowWarning,
				ShowTerm
			}

			public enum eAllowUnloadLanguages
			{
				Never,
				OnlyInDevice,
				EditorAndDevice
			}

			public enum eGoogleUpdateFrequency
			{
				Always,
				Never,
				Daily,
				Weekly,
				Monthly,
				OnlyOnce,
				EveryOtherDay
			}

			public enum eGoogleUpdateSynchronization
			{
				Manual,
				OnSceneLoaded,
				AsSoonAsDownloaded
			}

			[NonSerialized]
			public ILanguageSource owner;

			public bool UserAgreesToHaveItOnTheScene;

			public bool UserAgreesToHaveItInsideThePluginsFolder;

			public bool GoogleLiveSyncIsUptoDate = true;

			[NonSerialized]
			public bool mIsGlobalSource;

			public List<TermData> mTerms = new List<TermData>();

			public bool CaseInsensitiveTerms;

			[NonSerialized]
			public Dictionary<string, TermData> mDictionary = new Dictionary<string, TermData>(StringComparer.Ordinal);

			public MissingTranslationAction OnMissingTranslation = MissingTranslationAction.Fallback;

			public string mTerm_AppName;

			public List<LanguageData> mLanguages = new List<LanguageData>();

			public bool IgnoreDeviceLanguage;

			public eAllowUnloadLanguages _AllowUnloadingLanguages;

			public string Google_WebServiceURL;

			public string Google_SpreadsheetKey;

			public string Google_SpreadsheetName;

			public string Google_LastUpdatedVersion;

			public eGoogleUpdateFrequency GoogleUpdateFrequency = eGoogleUpdateFrequency.Weekly;

			public eGoogleUpdateFrequency GoogleInEditorCheckFrequency = eGoogleUpdateFrequency.Daily;

			public eGoogleUpdateSynchronization GoogleUpdateSynchronization = eGoogleUpdateSynchronization.OnSceneLoaded;

			public float GoogleUpdateDelay;

			public List<UnityEngine.Object> Assets = new List<UnityEngine.Object>();

			[NonSerialized]
			public Dictionary<string, UnityEngine.Object> mAssetDictionary = new Dictionary<string, UnityEngine.Object>(StringComparer.Ordinal);

			private string mDelayedGoogleData;

			public static string EmptyCategory = "Default";

			public static char[] CategorySeparators = "/\\".ToCharArray();

			public UnityEngine.Object ownerObject => owner as UnityEngine.Object;

			public event LanguageSource.fnOnSourceUpdated Event_OnSourceUpdateFromGoogle;

			public void Awake()
			{
				LocalizationManager.AddSource(this);
				UpdateDictionary();
				UpdateAssetDictionary();
				LocalizationManager.LocalizeAll(Force: true);
			}

			public void OnDestroy()
			{
				LocalizationManager.RemoveSource(this);
			}

			public bool IsEqualTo(LanguageSourceData Source)
			{
				if (Source.mLanguages.Count != mLanguages.Count)
				{
					return false;
				}
				int i = 0;
				for (int count = mLanguages.Count; i < count; i++)
				{
					if (Source.GetLanguageIndex(mLanguages[i].Name) < 0)
					{
						return false;
					}
				}
				if (Source.mTerms.Count != mTerms.Count)
				{
					return false;
				}
				for (int j = 0; j < mTerms.Count; j++)
				{
					if (Source.GetTermData(mTerms[j].Term) == null)
					{
						return false;
					}
				}
				return true;
			}

			internal bool ManagerHasASimilarSource()
			{
				int i = 0;
				for (int count = LocalizationManager.Sources.Count; i < count; i++)
				{
					LanguageSourceData languageSourceData = LocalizationManager.Sources[i];
					if (languageSourceData != null && languageSourceData.IsEqualTo(this) && languageSourceData != this)
					{
						return true;
					}
				}
				return false;
			}

			public void ClearAllData()
			{
				mTerms.Clear();
				mLanguages.Clear();
				mDictionary.Clear();
				mAssetDictionary.Clear();
			}

			public bool IsGlobalSource()
			{
				return mIsGlobalSource;
			}

			public void Editor_SetDirty()
			{
			}

			public void UpdateAssetDictionary()
			{
				Assets.RemoveAll((UnityEngine.Object x) => x == null);
				mAssetDictionary = (from o in Assets.Distinct()
					group o by o.name).ToDictionary((IGrouping<string, UnityEngine.Object> g) => g.Key, (IGrouping<string, UnityEngine.Object> g) => g.First());
			}

			public UnityEngine.Object FindAsset(string Name)
			{
				if (Assets != null)
				{
					if (mAssetDictionary == null || mAssetDictionary.Count != Assets.Count)
					{
						UpdateAssetDictionary();
					}
					if (mAssetDictionary.TryGetValue(Name, out var value))
					{
						return value;
					}
				}
				return null;
			}

			public bool HasAsset(UnityEngine.Object Obj)
			{
				return Assets.Contains(Obj);
			}

			public void AddAsset(UnityEngine.Object Obj)
			{
				if (!Assets.Contains(Obj))
				{
					Assets.Add(Obj);
					UpdateAssetDictionary();
				}
			}

			public string Export_I2CSV(string Category, char Separator = ',', bool specializationsAsRows = true)
			{
				StringBuilder stringBuilder = new StringBuilder();
				stringBuilder.Append("Key[*]Type[*]Desc");
				foreach (LanguageData mLanguage in mLanguages)
				{
					stringBuilder.Append("[*]");
					if (!mLanguage.IsEnabled())
					{
						stringBuilder.Append('$');
					}
					stringBuilder.Append(GoogleLanguages.GetCodedLanguage(mLanguage.Name, mLanguage.Code));
				}
				stringBuilder.Append("[ln]");
				mTerms.Sort((TermData a, TermData b) => string.CompareOrdinal(a.Term, b.Term));
				int count = mLanguages.Count;
				bool flag = true;
				foreach (TermData mTerm in mTerms)
				{
					string term;
					if (string.IsNullOrEmpty(Category) || (Category == EmptyCategory && mTerm.Term.IndexOfAny(CategorySeparators) < 0))
					{
						term = mTerm.Term;
					}
					else
					{
						if (!mTerm.Term.StartsWith(Category + "/") || !(Category != mTerm.Term))
						{
							continue;
						}
						term = mTerm.Term.Substring(Category.Length + 1);
					}
					if (!flag)
					{
						stringBuilder.Append("[ln]");
					}
					flag = false;
					if (!specializationsAsRows)
					{
						AppendI2Term(stringBuilder, count, term, mTerm, Separator, null);
						continue;
					}
					List<string> allSpecializations = mTerm.GetAllSpecializations();
					for (int i = 0; i < allSpecializations.Count; i++)
					{
						if (i != 0)
						{
							stringBuilder.Append("[ln]");
						}
						string forceSpecialization = allSpecializations[i];
						AppendI2Term(stringBuilder, count, term, mTerm, Separator, forceSpecialization);
					}
				}
				return stringBuilder.ToString();
			}

			private static void AppendI2Term(StringBuilder Builder, int nLanguages, string Term, TermData termData, char Separator, string forceSpecialization)
			{
				AppendI2Text(Builder, Term);
				if (!string.IsNullOrEmpty(forceSpecialization) && forceSpecialization != "Any")
				{
					Builder.Append("[");
					Builder.Append(forceSpecialization);
					Builder.Append("]");
				}
				Builder.Append("[*]");
				Builder.Append(termData.TermType.ToString());
				Builder.Append("[*]");
				Builder.Append(termData.Description);
				for (int i = 0; i < Mathf.Min(nLanguages, termData.Languages.Length); i++)
				{
					Builder.Append("[*]");
					string text = termData.Languages[i];
					if (!string.IsNullOrEmpty(forceSpecialization))
					{
						text = termData.GetTranslation(i, forceSpecialization);
					}
					AppendI2Text(Builder, text);
				}
			}

			private static void AppendI2Text(StringBuilder Builder, string text)
			{
				if (!string.IsNullOrEmpty(text))
				{
					if (text.StartsWith("'") || text.StartsWith("="))
					{
						Builder.Append('\'');
					}
					Builder.Append(text);
				}
			}

			private string Export_Language_to_Cache(int langIndex, bool fillTermWithFallback)
			{
				if (!mLanguages[langIndex].IsLoaded())
				{
					return null;
				}
				StringBuilder stringBuilder = new StringBuilder();
				for (int i = 0; i < mTerms.Count; i++)
				{
					if (i > 0)
					{
						stringBuilder.Append("[i2t]");
					}
					TermData termData = mTerms[i];
					stringBuilder.Append(termData.Term);
					stringBuilder.Append("=");
					string Translation = termData.Languages[langIndex];
					if (OnMissingTranslation == MissingTranslationAction.Fallback && string.IsNullOrEmpty(Translation) && TryGetFallbackTranslation(termData, out Translation, langIndex, null, skipDisabled: true))
					{
						stringBuilder.Append("[i2fb]");
						if (fillTermWithFallback)
						{
							termData.Languages[langIndex] = Translation;
						}
					}
					if (!string.IsNullOrEmpty(Translation))
					{
						stringBuilder.Append(Translation);
					}
				}
				return stringBuilder.ToString();
			}

			public string Export_CSV(string Category, char Separator = ',', bool specializationsAsRows = true)
			{
				StringBuilder stringBuilder = new StringBuilder();
				int count = mLanguages.Count;
				stringBuilder.AppendFormat("Key{0}Type{0}Desc", Separator);
				foreach (LanguageData mLanguage in mLanguages)
				{
					stringBuilder.Append(Separator);
					if (!mLanguage.IsEnabled())
					{
						stringBuilder.Append('$');
					}
					AppendString(stringBuilder, GoogleLanguages.GetCodedLanguage(mLanguage.Name, mLanguage.Code), Separator);
				}
				stringBuilder.Append("\n");
				mTerms.Sort((TermData a, TermData b) => string.CompareOrdinal(a.Term, b.Term));
				foreach (TermData mTerm in mTerms)
				{
					string term;
					if (string.IsNullOrEmpty(Category) || (Category == EmptyCategory && mTerm.Term.IndexOfAny(CategorySeparators) < 0))
					{
						term = mTerm.Term;
					}
					else
					{
						if (!mTerm.Term.StartsWith(Category + "/") || !(Category != mTerm.Term))
						{
							continue;
						}
						term = mTerm.Term.Substring(Category.Length + 1);
					}
					if (specializationsAsRows)
					{
						foreach (string allSpecialization in mTerm.GetAllSpecializations())
						{
							AppendTerm(stringBuilder, count, term, mTerm, allSpecialization, Separator);
						}
					}
					else
					{
						AppendTerm(stringBuilder, count, term, mTerm, null, Separator);
					}
				}
				return stringBuilder.ToString();
			}

			private static void AppendTerm(StringBuilder Builder, int nLanguages, string Term, TermData termData, string specialization, char Separator)
			{
				AppendString(Builder, Term, Separator);
				if (!string.IsNullOrEmpty(specialization) && specialization != "Any")
				{
					Builder.AppendFormat("[{0}]", specialization);
				}
				Builder.Append(Separator);
				Builder.Append(termData.TermType.ToString());
				Builder.Append(Separator);
				AppendString(Builder, termData.Description, Separator);
				for (int i = 0; i < Mathf.Min(nLanguages, termData.Languages.Length); i++)
				{
					Builder.Append(Separator);
					string text = termData.Languages[i];
					if (!string.IsNullOrEmpty(specialization))
					{
						text = termData.GetTranslation(i, specialization);
					}
					AppendTranslation(Builder, text, Separator, null);
				}
				Builder.Append("\n");
			}

			private static void AppendString(StringBuilder Builder, string Text, char Separator)
			{
				if (!string.IsNullOrEmpty(Text))
				{
					Text = Text.Replace("\\n", "\n");
					if (Text.IndexOfAny((Separator + "\n\"").ToCharArray()) >= 0)
					{
						Text = Text.Replace("\"", "\"\"");
						Builder.AppendFormat("\"{0}\"", Text);
					}
					else
					{
						Builder.Append(Text);
					}
				}
			}

			private static void AppendTranslation(StringBuilder Builder, string Text, char Separator, string tags)
			{
				if (!string.IsNullOrEmpty(Text))
				{
					Text = Text.Replace("\\n", "\n");
					if (Text.IndexOfAny((Separator + "\n\"").ToCharArray()) >= 0)
					{
						Text = Text.Replace("\"", "\"\"");
						Builder.AppendFormat("\"{0}{1}\"", tags, Text);
					}
					else
					{
						Builder.Append(tags);
						Builder.Append(Text);
					}
				}
			}

			public UnityWebRequest Export_Google_CreateWWWcall(eSpreadsheetUpdateMode UpdateMode = eSpreadsheetUpdateMode.Replace)
			{
				string value = Export_Google_CreateData();
				WWWForm wWWForm = new WWWForm();
				wWWForm.AddField("key", Google_SpreadsheetKey);
				wWWForm.AddField("action", "SetLanguageSource");
				wWWForm.AddField("data", value);
				wWWForm.AddField("updateMode", UpdateMode.ToString());
				UnityWebRequest unityWebRequest = UnityWebRequest.Post(LocalizationManager.GetWebServiceURL(this), wWWForm);
				I2Utils.SendWebRequest(unityWebRequest);
				return unityWebRequest;
			}

			private string Export_Google_CreateData()
			{
				List<string> categories = GetCategories(OnlyMainCategory: true);
				StringBuilder stringBuilder = new StringBuilder();
				bool flag = true;
				foreach (string item in categories)
				{
					if (flag)
					{
						flag = false;
					}
					else
					{
						stringBuilder.Append("<I2Loc>");
					}
					bool specializationsAsRows = true;
					string value = Export_I2CSV(item, ',', specializationsAsRows);
					stringBuilder.Append(item);
					stringBuilder.Append("<I2Loc>");
					stringBuilder.Append(value);
				}
				return stringBuilder.ToString();
			}

			public string Import_CSV(string Category, string CSVstring, eSpreadsheetUpdateMode UpdateMode = eSpreadsheetUpdateMode.Replace, char Separator = ',')
			{
				List<string[]> cSV = LocalizationReader.ReadCSV(CSVstring, Separator);
				return Import_CSV(Category, cSV, UpdateMode);
			}

			public string Import_I2CSV(string Category, string I2CSVstring, eSpreadsheetUpdateMode UpdateMode = eSpreadsheetUpdateMode.Replace)
			{
				List<string[]> cSV = LocalizationReader.ReadI2CSV(I2CSVstring);
				return Import_CSV(Category, cSV, UpdateMode);
			}

			public string Import_CSV(string Category, List<string[]> CSV, eSpreadsheetUpdateMode UpdateMode = eSpreadsheetUpdateMode.Replace)
			{
				string[] array = CSV[0];
				int num = 1;
				int num2 = -1;
				int num3 = -1;
				string[] texts = new string[1] { "Key" };
				string[] texts2 = new string[1] { "Type" };
				string[] texts3 = new string[2] { "Desc", "Description" };
				if (array.Length > 1 && ArrayContains(array[0], texts))
				{
					if (UpdateMode == eSpreadsheetUpdateMode.Replace)
					{
						ClearAllData();
					}
					if (array.Length > 2)
					{
						if (ArrayContains(array[1], texts2))
						{
							num2 = 1;
							num = 2;
						}
						if (ArrayContains(array[1], texts3))
						{
							num3 = 1;
							num = 2;
						}
					}
					if (array.Length > 3)
					{
						if (ArrayContains(array[2], texts2))
						{
							num2 = 2;
							num = 3;
						}
						if (ArrayContains(array[2], texts3))
						{
							num3 = 2;
							num = 3;
						}
					}
					int num4 = Mathf.Max(array.Length - num, 0);
					int[] array2 = new int[num4];
					for (int i = 0; i < num4; i++)
					{
						if (string.IsNullOrEmpty(array[i + num]))
						{
							array2[i] = -1;
							continue;
						}
						string text = array[i + num];
						bool flag = true;
						if (text.StartsWith("$"))
						{
							flag = false;
							text = text.Substring(1);
						}
						GoogleLanguages.UnPackCodeFromLanguageName(text, out var Language, out var code);
						int num5 = -1;
						num5 = (string.IsNullOrEmpty(code) ? GetLanguageIndex(Language, AllowDiscartingRegion: true, SkipDisabled: false) : GetLanguageIndexFromCode(code));
						if (num5 < 0)
						{
							LanguageData languageData = new LanguageData();
							languageData.Name = Language;
							languageData.Code = code;
							languageData.Flags = (byte)(0u | ((!flag) ? 1u : 0u));
							mLanguages.Add(languageData);
							num5 = mLanguages.Count - 1;
						}
						array2[i] = num5;
					}
					num4 = mLanguages.Count;
					int j = 0;
					for (int count = mTerms.Count; j < count; j++)
					{
						TermData termData = mTerms[j];
						if (termData.Languages.Length < num4)
						{
							Array.Resize(ref termData.Languages, num4);
							Array.Resize(ref termData.Flags, num4);
						}
					}
					int k = 1;
					for (int count2 = CSV.Count; k < count2; k++)
					{
						array = CSV[k];
						string Term = (string.IsNullOrEmpty(Category) ? array[0] : (Category + "/" + array[0]));
						string text2 = null;
						if (Term.EndsWith("]"))
						{
							int num6 = Term.LastIndexOf('[');
							if (num6 > 0)
							{
								text2 = Term.Substring(num6 + 1, Term.Length - num6 - 2);
								if (text2 == "touch")
								{
									text2 = "Touch";
								}
								Term = Term.Remove(num6);
							}
						}
						ValidateFullTerm(ref Term);
						if (string.IsNullOrEmpty(Term))
						{
							continue;
						}
						TermData termData2 = GetTermData(Term);
						if (termData2 == null)
						{
							termData2 = new TermData();
							termData2.Term = Term;
							termData2.Languages = new string[mLanguages.Count];
							termData2.Flags = new byte[mLanguages.Count];
							for (int l = 0; l < mLanguages.Count; l++)
							{
								termData2.Languages[l] = string.Empty;
							}
							mTerms.Add(termData2);
							mDictionary.Add(Term, termData2);
						}
						else if (UpdateMode == eSpreadsheetUpdateMode.AddNewTerms)
						{
							continue;
						}
						if (num2 > 0)
						{
							termData2.TermType = GetTermType(array[num2]);
						}
						if (num3 > 0)
						{
							termData2.Description = array[num3];
						}
						for (int m = 0; m < array2.Length && m < array.Length - num; m++)
						{
							if (string.IsNullOrEmpty(array[m + num]))
							{
								continue;
							}
							int num7 = array2[m];
							if (num7 >= 0)
							{
								string text3 = array[m + num];
								if (text3 == "-")
								{
									text3 = string.Empty;
								}
								else if (text3 == "")
								{
									text3 = null;
								}
								termData2.SetTranslation(num7, text3, text2);
							}
						}
					}
					if (Application.isPlaying)
					{
						SaveLanguages(HasUnloadedLanguages());
					}
					return string.Empty;
				}
				return "Bad Spreadsheet Format.\nFirst columns should be 'Key', 'Type' and 'Desc'";
			}

			private bool ArrayContains(string MainText, params string[] texts)
			{
				int i = 0;
				for (int num = texts.Length; i < num; i++)
				{
					if (MainText.IndexOf(texts[i], StringComparison.OrdinalIgnoreCase) >= 0)
					{
						return true;
					}
				}
				return false;
			}

			public static eTermType GetTermType(string type)
			{
				int i = 0;
				for (int num = 10; i <= num; i++)
				{
					eTermType eTermType2 = (eTermType)i;
					if (string.Equals(eTermType2.ToString(), type, StringComparison.OrdinalIgnoreCase))
					{
						return (eTermType)i;
					}
				}
				return eTermType.Text;
			}

			private void Import_Language_from_Cache(int langIndex, string langData, bool useFallback, bool onlyCurrentSpecialization)
			{
				int num = 0;
				while (num < langData.Length)
				{
					int num2 = langData.IndexOf("[i2t]", num);
					if (num2 < 0)
					{
						num2 = langData.Length;
					}
					int num3 = langData.IndexOf("=", num);
					if (num3 >= num2)
					{
						break;
					}
					string term = langData.Substring(num, num3 - num);
					num = num3 + 1;
					TermData termData = GetTermData(term);
					if (termData != null)
					{
						string text = null;
						if (num != num2)
						{
							text = langData.Substring(num, num2 - num);
							if (text.StartsWith("[i2fb]"))
							{
								text = (useFallback ? text.Substring(6) : null);
							}
							if (onlyCurrentSpecialization && text != null)
							{
								text = SpecializationManager.GetSpecializedText(text);
							}
						}
						termData.Languages[langIndex] = text;
					}
					num = num2 + 5;
				}
			}

			public static void FreeUnusedLanguages()
			{
				LanguageSourceData languageSourceData = LocalizationManager.Sources[0];
				int languageIndex = languageSourceData.GetLanguageIndex(LocalizationManager.CurrentLanguage);
				for (int i = 0; i < languageSourceData.mTerms.Count; i++)
				{
					TermData termData = languageSourceData.mTerms[i];
					for (int j = 0; j < termData.Languages.Length; j++)
					{
						if (j != languageIndex)
						{
							termData.Languages[j] = null;
						}
					}
				}
			}

			public void Import_Google_FromCache()
			{
				if (GoogleUpdateFrequency == eGoogleUpdateFrequency.Never || !I2Utils.IsPlaying())
				{
					return;
				}
				string sourcePlayerPrefName = GetSourcePlayerPrefName();
				string text = PersistentStorage.LoadFile(PersistentStorage.eFileType.Persistent, "I2Source_" + sourcePlayerPrefName + ".loc", logExceptions: false);
				if (string.IsNullOrEmpty(text))
				{
					return;
				}
				if (text.StartsWith("[i2e]", StringComparison.Ordinal))
				{
					text = StringObfucator.Decode(text.Substring(5, text.Length - 5));
				}
				bool flag = false;
				string text2 = Google_LastUpdatedVersion;
				if (PersistentStorage.HasSetting("I2SourceVersion_" + sourcePlayerPrefName))
				{
					text2 = PersistentStorage.GetSetting_String("I2SourceVersion_" + sourcePlayerPrefName, Google_LastUpdatedVersion);
					flag = IsNewerVersion(Google_LastUpdatedVersion, text2);
				}
				if (!flag)
				{
					PersistentStorage.DeleteFile(PersistentStorage.eFileType.Persistent, "I2Source_" + sourcePlayerPrefName + ".loc", logExceptions: false);
					PersistentStorage.DeleteSetting("I2SourceVersion_" + sourcePlayerPrefName);
					return;
				}
				if (text2.Length > 19)
				{
					text2 = string.Empty;
				}
				Google_LastUpdatedVersion = text2;
				Import_Google_Result(text, eSpreadsheetUpdateMode.Replace);
			}

			private bool IsNewerVersion(string currentVersion, string newVersion)
			{
				if (string.IsNullOrEmpty(newVersion))
				{
					return false;
				}
				if (string.IsNullOrEmpty(currentVersion))
				{
					return true;
				}
				if (!long.TryParse(newVersion, out var result) || !long.TryParse(currentVersion, out var result2))
				{
					return true;
				}
				return result > result2;
			}

			public void Import_Google(bool ForceUpdate, bool justCheck)
			{
				if ((!ForceUpdate && GoogleUpdateFrequency == eGoogleUpdateFrequency.Never) || !I2Utils.IsPlaying())
				{
					return;
				}
				eGoogleUpdateFrequency googleUpdateFrequency = GoogleUpdateFrequency;
				string sourcePlayerPrefName = GetSourcePlayerPrefName();
				if (!ForceUpdate && googleUpdateFrequency != 0)
				{
					string setting_String = PersistentStorage.GetSetting_String("LastGoogleUpdate_" + sourcePlayerPrefName, "");
					try
					{
						if (DateTime.TryParse(setting_String, out var result))
						{
							double totalDays = (DateTime.Now - result).TotalDays;
							switch (googleUpdateFrequency)
							{
							case eGoogleUpdateFrequency.Daily:
								if (totalDays < 1.0)
								{
									return;
								}
								break;
							case eGoogleUpdateFrequency.Weekly:
								if (totalDays < 8.0)
								{
									return;
								}
								break;
							case eGoogleUpdateFrequency.Monthly:
								if (totalDays < 31.0)
								{
									return;
								}
								break;
							case eGoogleUpdateFrequency.OnlyOnce:
								return;
							case eGoogleUpdateFrequency.EveryOtherDay:
								if (totalDays < 2.0)
								{
									return;
								}
								break;
							}
						}
					}
					catch (Exception)
					{
					}
				}
				PersistentStorage.SetSetting_String("LastGoogleUpdate_" + sourcePlayerPrefName, DateTime.Now.ToString());
				CoroutineManager.Start(Import_Google_Coroutine(justCheck));
			}

			private string GetSourcePlayerPrefName()
			{
				if (owner == null)
				{
					return null;
				}
				string text = (owner as UnityEngine.Object).name;
				if (!string.IsNullOrEmpty(Google_SpreadsheetKey))
				{
					text += Google_SpreadsheetKey;
				}
				if (Array.IndexOf(LocalizationManager.GlobalSources, (owner as UnityEngine.Object).name) >= 0)
				{
					return text;
				}
				return SceneManager.GetActiveScene().name + "_" + text;
			}

			private IEnumerator Import_Google_Coroutine(bool JustCheck)
			{
				UnityWebRequest www = Import_Google_CreateWWWcall(ForceUpdate: false, JustCheck);
				if (www == null)
				{
					yield break;
				}
				while (!www.isDone)
				{
					yield return null;
				}
				if (string.IsNullOrEmpty(www.error))
				{
					byte[] data = www.downloadHandler.data;
					string @string = Encoding.UTF8.GetString(data, 0, data.Length);
					bool flag = string.IsNullOrEmpty(@string) || @string == "\"\"";
					if (JustCheck)
					{
						if (!flag)
						{
							UnityEngine.Debug.LogWarning("Spreadsheet is not up-to-date and Google Live Synchronization is enabled\nWhen playing in the device the Spreadsheet will be downloaded and translations may not behave as what you see in the editor.\nTo fix this, Import or Export replace to Google");
							GoogleLiveSyncIsUptoDate = false;
						}
						yield break;
					}
					if (!flag)
					{
						mDelayedGoogleData = @string;
						switch (GoogleUpdateSynchronization)
						{
						case eGoogleUpdateSynchronization.AsSoonAsDownloaded:
							ApplyDownloadedDataFromGoogle();
							break;
						case eGoogleUpdateSynchronization.OnSceneLoaded:
							SceneManager.sceneLoaded += ApplyDownloadedDataOnSceneLoaded;
							break;
						}
						yield break;
					}
				}
				if (this.Event_OnSourceUpdateFromGoogle != null)
				{
					this.Event_OnSourceUpdateFromGoogle(this, ReceivedNewData: false, www.error);
				}
				UnityEngine.Debug.Log("Language Source was up-to-date with Google Spreadsheet");
			}

			private void ApplyDownloadedDataOnSceneLoaded(Scene scene, LoadSceneMode mode)
			{
				SceneManager.sceneLoaded -= ApplyDownloadedDataOnSceneLoaded;
				ApplyDownloadedDataFromGoogle();
			}

			public void ApplyDownloadedDataFromGoogle()
			{
				if (string.IsNullOrEmpty(mDelayedGoogleData))
				{
					return;
				}
				if (string.IsNullOrEmpty(Import_Google_Result(mDelayedGoogleData, eSpreadsheetUpdateMode.Replace, saveInPlayerPrefs: true)))
				{
					if (this.Event_OnSourceUpdateFromGoogle != null)
					{
						this.Event_OnSourceUpdateFromGoogle(this, ReceivedNewData: true, "");
					}
					LocalizationManager.LocalizeAll(Force: true);
					UnityEngine.Debug.Log("Done Google Sync");
				}
				else
				{
					if (this.Event_OnSourceUpdateFromGoogle != null)
					{
						this.Event_OnSourceUpdateFromGoogle(this, ReceivedNewData: false, "");
					}
					UnityEngine.Debug.Log("Done Google Sync: source was up-to-date");
				}
			}

			public UnityWebRequest Import_Google_CreateWWWcall(bool ForceUpdate, bool justCheck)
			{
				if (!HasGoogleSpreadsheet())
				{
					return null;
				}
				string text = PersistentStorage.GetSetting_String("I2SourceVersion_" + GetSourcePlayerPrefName(), Google_LastUpdatedVersion);
				if (text.Length > 19)
				{
					text = string.Empty;
				}
				if (IsNewerVersion(text, Google_LastUpdatedVersion))
				{
					Google_LastUpdatedVersion = text;
				}
				UnityWebRequest unityWebRequest = UnityWebRequest.Get(string.Format("{0}?key={1}&action=GetLanguageSource&version={2}", LocalizationManager.GetWebServiceURL(this), Google_SpreadsheetKey, ForceUpdate ? "0" : Google_LastUpdatedVersion));
				I2Utils.SendWebRequest(unityWebRequest);
				return unityWebRequest;
			}

			public bool HasGoogleSpreadsheet()
			{
				if (!string.IsNullOrEmpty(Google_WebServiceURL) && !string.IsNullOrEmpty(Google_SpreadsheetKey))
				{
					return !string.IsNullOrEmpty(LocalizationManager.GetWebServiceURL(this));
				}
				return false;
			}

			public string Import_Google_Result(string JsonString, eSpreadsheetUpdateMode UpdateMode, bool saveInPlayerPrefs = false)
			{
				try
				{
					string empty = string.Empty;
					if (string.IsNullOrEmpty(JsonString) || JsonString == "\"\"")
					{
						return empty;
					}
					int num = JsonString.IndexOf("version=", StringComparison.Ordinal);
					int num2 = JsonString.IndexOf("script_version=", StringComparison.Ordinal);
					if (num < 0 || num2 < 0)
					{
						return "Invalid Response from Google, Most likely the WebService needs to be updated";
					}
					num += "version=".Length;
					num2 += "script_version=".Length;
					string text = JsonString.Substring(num, JsonString.IndexOf(",", num, StringComparison.Ordinal) - num);
					int num3 = int.Parse(JsonString.Substring(num2, JsonString.IndexOf(",", num2, StringComparison.Ordinal) - num2));
					if (text.Length > 19)
					{
						text = string.Empty;
					}
					if (num3 != LocalizationManager.GetRequiredWebServiceVersion())
					{
						return "The current Google WebService is not supported.\nPlease, delete the WebService from the Google Drive and Install the latest version.";
					}
					if (saveInPlayerPrefs && !IsNewerVersion(Google_LastUpdatedVersion, text))
					{
						return "LanguageSource is up-to-date";
					}
					if (saveInPlayerPrefs)
					{
						string sourcePlayerPrefName = GetSourcePlayerPrefName();
						PersistentStorage.SaveFile(PersistentStorage.eFileType.Persistent, "I2Source_" + sourcePlayerPrefName + ".loc", "[i2e]" + StringObfucator.Encode(JsonString));
						PersistentStorage.SetSetting_String("I2SourceVersion_" + sourcePlayerPrefName, text);
						PersistentStorage.ForceSaveSettings();
					}
					Google_LastUpdatedVersion = text;
					if (UpdateMode == eSpreadsheetUpdateMode.Replace)
					{
						ClearAllData();
					}
					int num4 = JsonString.IndexOf("[i2category]", StringComparison.Ordinal);
					while (num4 > 0)
					{
						num4 += "[i2category]".Length;
						int num5 = JsonString.IndexOf("[/i2category]", num4, StringComparison.Ordinal);
						string category = JsonString.Substring(num4, num5 - num4);
						num5 += "[/i2category]".Length;
						int num6 = JsonString.IndexOf("[/i2csv]", num5, StringComparison.Ordinal);
						string i2CSVstring = JsonString.Substring(num5, num6 - num5);
						num4 = JsonString.IndexOf("[i2category]", num6, StringComparison.Ordinal);
						Import_I2CSV(category, i2CSVstring, UpdateMode);
						if (UpdateMode == eSpreadsheetUpdateMode.Replace)
						{
							UpdateMode = eSpreadsheetUpdateMode.Merge;
						}
					}
					GoogleLiveSyncIsUptoDate = true;
					if (I2Utils.IsPlaying())
					{
						SaveLanguages(unloadAll: true);
					}
					if (!string.IsNullOrEmpty(empty))
					{
						Editor_SetDirty();
					}
					return empty;
				}
				catch (Exception ex)
				{
					UnityEngine.Debug.LogWarning(ex);
					return ex.ToString();
				}
			}

			public int GetLanguageIndex(string language, bool AllowDiscartingRegion = true, bool SkipDisabled = true)
			{
				int i = 0;
				for (int count = mLanguages.Count; i < count; i++)
				{
					if ((!SkipDisabled || mLanguages[i].IsEnabled()) && string.Compare(mLanguages[i].Name, language, StringComparison.OrdinalIgnoreCase) == 0)
					{
						return i;
					}
				}
				if (AllowDiscartingRegion)
				{
					int num = -1;
					int num2 = 0;
					int j = 0;
					for (int count2 = mLanguages.Count; j < count2; j++)
					{
						if (!SkipDisabled || mLanguages[j].IsEnabled())
						{
							int commonWordInLanguageNames = GetCommonWordInLanguageNames(mLanguages[j].Name, language);
							if (commonWordInLanguageNames > num2)
							{
								num2 = commonWordInLanguageNames;
								num = j;
							}
						}
					}
					if (num >= 0)
					{
						return num;
					}
				}
				return -1;
			}

			public LanguageData GetLanguageData(string language, bool AllowDiscartingRegion = true)
			{
				int languageIndex = GetLanguageIndex(language, AllowDiscartingRegion, SkipDisabled: false);
				if (languageIndex >= 0)
				{
					return mLanguages[languageIndex];
				}
				return null;
			}

			public bool IsCurrentLanguage(int languageIndex)
			{
				return LocalizationManager.CurrentLanguage == mLanguages[languageIndex].Name;
			}

			public int GetLanguageIndexFromCode(string Code, bool exactMatch = true, bool ignoreDisabled = false)
			{
				int i = 0;
				for (int count = mLanguages.Count; i < count; i++)
				{
					if ((!ignoreDisabled || mLanguages[i].IsEnabled()) && string.Compare(mLanguages[i].Code, Code, StringComparison.OrdinalIgnoreCase) == 0)
					{
						return i;
					}
				}
				if (!exactMatch)
				{
					int j = 0;
					for (int count2 = mLanguages.Count; j < count2; j++)
					{
						if ((!ignoreDisabled || mLanguages[j].IsEnabled()) && string.Compare(mLanguages[j].Code, 0, Code, 0, 2, StringComparison.OrdinalIgnoreCase) == 0)
						{
							return j;
						}
					}
				}
				return -1;
			}

			public static int GetCommonWordInLanguageNames(string Language1, string Language2)
			{
				if (string.IsNullOrEmpty(Language1) || string.IsNullOrEmpty(Language2))
				{
					return 0;
				}
				char[] separator = "( )-/\\".ToCharArray();
				string[] array = Language1.ToLower().Split(separator);
				string[] array2 = Language2.ToLower().Split(separator);
				int num = 0;
				string[] array3 = array;
				foreach (string value in array3)
				{
					if (!string.IsNullOrEmpty(value) && array2.Contains(value))
					{
						num++;
					}
				}
				array3 = array2;
				foreach (string value2 in array3)
				{
					if (!string.IsNullOrEmpty(value2) && array.Contains(value2))
					{
						num++;
					}
				}
				return num;
			}

			public static bool AreTheSameLanguage(string Language1, string Language2)
			{
				Language1 = GetLanguageWithoutRegion(Language1);
				Language2 = GetLanguageWithoutRegion(Language2);
				return string.Compare(Language1, Language2, StringComparison.OrdinalIgnoreCase) == 0;
			}

			public static string GetLanguageWithoutRegion(string Language)
			{
				int num = Language.IndexOfAny("(/\\[,{".ToCharArray());
				if (num < 0)
				{
					return Language;
				}
				return Language.Substring(0, num).Trim();
			}

			public void AddLanguage(string LanguageName)
			{
				AddLanguage(LanguageName, GoogleLanguages.GetLanguageCode(LanguageName));
			}

			public void AddLanguage(string LanguageName, string LanguageCode)
			{
				if (GetLanguageIndex(LanguageName, AllowDiscartingRegion: false) < 0)
				{
					LanguageData languageData = new LanguageData();
					languageData.Name = LanguageName;
					languageData.Code = LanguageCode;
					mLanguages.Add(languageData);
					int count = mLanguages.Count;
					int i = 0;
					for (int count2 = mTerms.Count; i < count2; i++)
					{
						Array.Resize(ref mTerms[i].Languages, count);
						Array.Resize(ref mTerms[i].Flags, count);
					}
					Editor_SetDirty();
				}
			}

			public void RemoveLanguage(string LanguageName)
			{
				int languageIndex = GetLanguageIndex(LanguageName, AllowDiscartingRegion: false, SkipDisabled: false);
				if (languageIndex < 0)
				{
					return;
				}
				int count = mLanguages.Count;
				int i = 0;
				for (int count2 = mTerms.Count; i < count2; i++)
				{
					for (int j = languageIndex + 1; j < count; j++)
					{
						mTerms[i].Languages[j - 1] = mTerms[i].Languages[j];
						mTerms[i].Flags[j - 1] = mTerms[i].Flags[j];
					}
					Array.Resize(ref mTerms[i].Languages, count - 1);
					Array.Resize(ref mTerms[i].Flags, count - 1);
				}
				mLanguages.RemoveAt(languageIndex);
				Editor_SetDirty();
			}

			public List<string> GetLanguages(bool skipDisabled = true)
			{
				List<string> list = new List<string>();
				int i = 0;
				for (int count = mLanguages.Count; i < count; i++)
				{
					if (!skipDisabled || mLanguages[i].IsEnabled())
					{
						list.Add(mLanguages[i].Name);
					}
				}
				return list;
			}

			public List<string> GetLanguagesCode(bool allowRegions = true, bool skipDisabled = true)
			{
				List<string> list = new List<string>();
				int i = 0;
				for (int count = mLanguages.Count; i < count; i++)
				{
					if (!skipDisabled || mLanguages[i].IsEnabled())
					{
						string text = mLanguages[i].Code;
						if (!allowRegions && text != null && text.Length > 2)
						{
							text = text.Substring(0, 2);
						}
						if (!string.IsNullOrEmpty(text) && !list.Contains(text))
						{
							list.Add(text);
						}
					}
				}
				return list;
			}

			public bool IsLanguageEnabled(string Language)
			{
				int languageIndex = GetLanguageIndex(Language, AllowDiscartingRegion: false);
				if (languageIndex >= 0)
				{
					return mLanguages[languageIndex].IsEnabled();
				}
				return false;
			}

			public void EnableLanguage(string Language, bool bEnabled)
			{
				int languageIndex = GetLanguageIndex(Language, AllowDiscartingRegion: false, SkipDisabled: false);
				if (languageIndex >= 0)
				{
					mLanguages[languageIndex].SetEnabled(bEnabled);
				}
			}

			public bool AllowUnloadingLanguages()
			{
				return _AllowUnloadingLanguages != eAllowUnloadLanguages.Never;
			}

			private string GetSavedLanguageFileName(int languageIndex)
			{
				if (languageIndex < 0)
				{
					return null;
				}
				return "LangSource_" + GetSourcePlayerPrefName() + "_" + mLanguages[languageIndex].Name + ".loc";
			}

			public void LoadLanguage(int languageIndex, bool UnloadOtherLanguages, bool useFallback, bool onlyCurrentSpecialization, bool forceLoad)
			{
				if (!AllowUnloadingLanguages() || !PersistentStorage.CanAccessFiles())
				{
					return;
				}
				if (languageIndex >= 0 && (forceLoad || !mLanguages[languageIndex].IsLoaded()))
				{
					string savedLanguageFileName = GetSavedLanguageFileName(languageIndex);
					string text = PersistentStorage.LoadFile(PersistentStorage.eFileType.Temporal, savedLanguageFileName, logExceptions: false);
					if (!string.IsNullOrEmpty(text))
					{
						Import_Language_from_Cache(languageIndex, text, useFallback, onlyCurrentSpecialization);
						mLanguages[languageIndex].SetLoaded(loaded: true);
					}
				}
				if (!UnloadOtherLanguages || !I2Utils.IsPlaying())
				{
					return;
				}
				for (int i = 0; i < mLanguages.Count; i++)
				{
					if (i != languageIndex)
					{
						UnloadLanguage(i);
					}
				}
			}

			public void LoadAllLanguages(bool forceLoad = false)
			{
				for (int i = 0; i < mLanguages.Count; i++)
				{
					LoadLanguage(i, UnloadOtherLanguages: false, useFallback: false, onlyCurrentSpecialization: false, forceLoad);
				}
			}

			public void UnloadLanguage(int languageIndex)
			{
				if (!AllowUnloadingLanguages() || !PersistentStorage.CanAccessFiles() || !I2Utils.IsPlaying() || !mLanguages[languageIndex].IsLoaded() || !mLanguages[languageIndex].CanBeUnloaded() || IsCurrentLanguage(languageIndex) || !PersistentStorage.HasFile(PersistentStorage.eFileType.Temporal, GetSavedLanguageFileName(languageIndex)))
				{
					return;
				}
				foreach (TermData mTerm in mTerms)
				{
					mTerm.Languages[languageIndex] = null;
				}
				mLanguages[languageIndex].SetLoaded(loaded: false);
			}

			public void SaveLanguages(bool unloadAll, PersistentStorage.eFileType fileLocation = PersistentStorage.eFileType.Temporal)
			{
				if (!AllowUnloadingLanguages() || !PersistentStorage.CanAccessFiles())
				{
					return;
				}
				for (int i = 0; i < mLanguages.Count; i++)
				{
					string text = Export_Language_to_Cache(i, IsCurrentLanguage(i));
					if (!string.IsNullOrEmpty(text))
					{
						PersistentStorage.SaveFile(PersistentStorage.eFileType.Temporal, GetSavedLanguageFileName(i), text);
					}
				}
				if (!unloadAll)
				{
					return;
				}
				for (int j = 0; j < mLanguages.Count; j++)
				{
					if (unloadAll && !IsCurrentLanguage(j))
					{
						UnloadLanguage(j);
					}
				}
			}

			public bool HasUnloadedLanguages()
			{
				for (int i = 0; i < mLanguages.Count; i++)
				{
					if (!mLanguages[i].IsLoaded())
					{
						return true;
					}
				}
				return false;
			}

			public List<string> GetCategories(bool OnlyMainCategory = false, List<string> Categories = null)
			{
				if (Categories == null)
				{
					Categories = new List<string>();
				}
				foreach (TermData mTerm in mTerms)
				{
					string categoryFromFullTerm = GetCategoryFromFullTerm(mTerm.Term, OnlyMainCategory);
					if (!Categories.Contains(categoryFromFullTerm))
					{
						Categories.Add(categoryFromFullTerm);
					}
				}
				Categories.Sort();
				return Categories;
			}

			public static string GetKeyFromFullTerm(string FullTerm, bool OnlyMainCategory = false)
			{
				int num = (OnlyMainCategory ? FullTerm.IndexOfAny(CategorySeparators) : FullTerm.LastIndexOfAny(CategorySeparators));
				if (num >= 0)
				{
					return FullTerm.Substring(num + 1);
				}
				return FullTerm;
			}

			public static string GetCategoryFromFullTerm(string FullTerm, bool OnlyMainCategory = false)
			{
				int num = (OnlyMainCategory ? FullTerm.IndexOfAny(CategorySeparators) : FullTerm.LastIndexOfAny(CategorySeparators));
				if (num >= 0)
				{
					return FullTerm.Substring(0, num);
				}
				return EmptyCategory;
			}

			public static void DeserializeFullTerm(string FullTerm, out string Key, out string Category, bool OnlyMainCategory = false)
			{
				int num = (OnlyMainCategory ? FullTerm.IndexOfAny(CategorySeparators) : FullTerm.LastIndexOfAny(CategorySeparators));
				if (num < 0)
				{
					Category = EmptyCategory;
					Key = FullTerm;
				}
				else
				{
					Category = FullTerm.Substring(0, num);
					Key = FullTerm.Substring(num + 1);
				}
			}

			public void UpdateDictionary(bool force = false)
			{
				if (force || mDictionary == null || mDictionary.Count != mTerms.Count)
				{
					StringComparer stringComparer = (CaseInsensitiveTerms ? StringComparer.OrdinalIgnoreCase : StringComparer.Ordinal);
					if (mDictionary.Comparer != stringComparer)
					{
						mDictionary = new Dictionary<string, TermData>(stringComparer);
					}
					else
					{
						mDictionary.Clear();
					}
					int i = 0;
					for (int count = mTerms.Count; i < count; i++)
					{
						TermData termData = mTerms[i];
						ValidateFullTerm(ref termData.Term);
						mDictionary[termData.Term] = mTerms[i];
						mTerms[i].Validate();
					}
					if (I2Utils.IsPlaying())
					{
						SaveLanguages(unloadAll: true);
					}
				}
			}

			public string GetTranslation(string term, string overrideLanguage = null, string overrideSpecialization = null, bool skipDisabled = false, bool allowCategoryMistmatch = false)
			{
				if (TryGetTranslation(term, out var Translation, overrideLanguage, overrideSpecialization, skipDisabled, allowCategoryMistmatch))
				{
					return Translation;
				}
				return string.Empty;
			}

			public bool TryGetTranslation(string term, out string Translation, string overrideLanguage = null, string overrideSpecialization = null, bool skipDisabled = false, bool allowCategoryMistmatch = false)
			{
				int languageIndex = GetLanguageIndex((overrideLanguage == null) ? LocalizationManager.CurrentLanguage : overrideLanguage, AllowDiscartingRegion: true, SkipDisabled: false);
				if (languageIndex >= 0 && (!skipDisabled || mLanguages[languageIndex].IsEnabled()))
				{
					TermData termData = GetTermData(term, allowCategoryMistmatch);
					if (termData != null)
					{
						Translation = termData.GetTranslation(languageIndex, overrideSpecialization, editMode: true);
						if (Translation == "---")
						{
							Translation = string.Empty;
							return true;
						}
						if (!string.IsNullOrEmpty(Translation))
						{
							return true;
						}
						Translation = null;
					}
					if (OnMissingTranslation == MissingTranslationAction.ShowWarning)
					{
						Translation = $"<!-Missing Translation [{term}]-!>";
						return true;
					}
					if (OnMissingTranslation == MissingTranslationAction.Fallback && termData != null)
					{
						return TryGetFallbackTranslation(termData, out Translation, languageIndex, overrideSpecialization, skipDisabled);
					}
					if (OnMissingTranslation == MissingTranslationAction.Empty)
					{
						Translation = string.Empty;
						return true;
					}
					if (OnMissingTranslation == MissingTranslationAction.ShowTerm)
					{
						Translation = term;
						return true;
					}
				}
				Translation = null;
				return false;
			}

			private bool TryGetFallbackTranslation(TermData termData, out string Translation, int langIndex, string overrideSpecialization = null, bool skipDisabled = false)
			{
				string text = mLanguages[langIndex].Code;
				if (!string.IsNullOrEmpty(text))
				{
					if (text.Contains('-'))
					{
						text = text.Substring(0, text.IndexOf('-'));
					}
					for (int i = 0; i < mLanguages.Count; i++)
					{
						if (i != langIndex && mLanguages[i].Code.StartsWith(text) && (!skipDisabled || mLanguages[i].IsEnabled()))
						{
							Translation = termData.GetTranslation(i, overrideSpecialization, editMode: true);
							if (!string.IsNullOrEmpty(Translation))
							{
								return true;
							}
						}
					}
				}
				for (int j = 0; j < mLanguages.Count; j++)
				{
					if (j != langIndex && (!skipDisabled || mLanguages[j].IsEnabled()) && (text == null || !mLanguages[j].Code.StartsWith(text)))
					{
						Translation = termData.GetTranslation(j, overrideSpecialization, editMode: true);
						if (!string.IsNullOrEmpty(Translation))
						{
							return true;
						}
					}
				}
				Translation = null;
				return false;
			}

			public TermData AddTerm(string term)
			{
				return AddTerm(term, eTermType.Text);
			}

			public TermData GetTermData(string term, bool allowCategoryMistmatch = false)
			{
				if (string.IsNullOrEmpty(term))
				{
					return null;
				}
				if (mDictionary.Count == 0)
				{
					UpdateDictionary();
				}
				if (mDictionary.TryGetValue(term, out var value))
				{
					return value;
				}
				TermData termData = null;
				if (allowCategoryMistmatch)
				{
					string keyFromFullTerm = GetKeyFromFullTerm(term);
					foreach (KeyValuePair<string, TermData> item in mDictionary)
					{
						if (item.Value.IsTerm(keyFromFullTerm, allowCategoryMistmatch: true))
						{
							if (termData != null)
							{
								return null;
							}
							termData = item.Value;
						}
					}
				}
				return termData;
			}

			public bool ContainsTerm(string term)
			{
				return GetTermData(term) != null;
			}

			public List<string> GetTermsList(string Category = null)
			{
				if (mDictionary.Count != mTerms.Count)
				{
					UpdateDictionary();
				}
				if (string.IsNullOrEmpty(Category))
				{
					return new List<string>(mDictionary.Keys);
				}
				List<string> list = new List<string>();
				for (int i = 0; i < mTerms.Count; i++)
				{
					TermData termData = mTerms[i];
					if (GetCategoryFromFullTerm(termData.Term) == Category)
					{
						list.Add(termData.Term);
					}
				}
				return list;
			}

			public TermData AddTerm(string NewTerm, eTermType termType, bool SaveSource = true)
			{
				ValidateFullTerm(ref NewTerm);
				NewTerm = NewTerm.Trim();
				if (mLanguages.Count == 0)
				{
					AddLanguage("English", "en");
				}
				TermData termData = GetTermData(NewTerm);
				if (termData == null)
				{
					termData = new TermData();
					termData.Term = NewTerm;
					termData.TermType = termType;
					termData.Languages = new string[mLanguages.Count];
					termData.Flags = new byte[mLanguages.Count];
					mTerms.Add(termData);
					mDictionary.Add(NewTerm, termData);
				}
				return termData;
			}

			public void RemoveTerm(string term)
			{
				int i = 0;
				for (int count = mTerms.Count; i < count; i++)
				{
					if (mTerms[i].Term == term)
					{
						mTerms.RemoveAt(i);
						mDictionary.Remove(term);
						break;
					}
				}
			}

			public static void ValidateFullTerm(ref string Term)
			{
				Term = Term.Replace('\\', '/');
				Term = Term.Trim();
				if (Term.StartsWith(EmptyCategory, StringComparison.Ordinal) && Term.Length > EmptyCategory.Length && Term[EmptyCategory.Length] == '/')
				{
					Term = Term.Substring(EmptyCategory.Length + 1);
				}
				Term = I2Utils.GetValidTermName(Term, allowCategory: true);
			}
		}
		public enum eSpreadsheetUpdateMode
		{
			None,
			Replace,
			Merge,
			AddNewTerms
		}
		public class LocalizationReader
		{
			public static Dictionary<string, string> ReadTextAsset(TextAsset asset)
			{
				StringReader stringReader = new StringReader(Encoding.UTF8.GetString(asset.bytes, 0, asset.bytes.Length).Replace("\r\n", "\n").Replace("\r", "\n"));
				Dictionary<string, string> dictionary = new Dictionary<string, string>(StringComparer.Ordinal);
				string line;
				while ((line = stringReader.ReadLine()) != null)
				{
					if (TextAsset_ReadLine(line, out var key, out var value, out var _, out var _, out var _) && !string.IsNullOrEmpty(key) && !string.IsNullOrEmpty(value))
					{
						dictionary[key] = value;
					}
				}
				return dictionary;
			}

			public static bool TextAsset_ReadLine(string line, out string key, out string value, out string category, out string comment, out string termType)
			{
				key = string.Empty;
				category = string.Empty;
				comment = string.Empty;
				termType = string.Empty;
				value = string.Empty;
				int num = line.LastIndexOf("//");
				if (num >= 0)
				{
					comment = line.Substring(num + 2).Trim();
					comment = DecodeString(comment);
					line = line.Substring(0, num);
				}
				int num2 = line.IndexOf("=");
				if (num2 < 0)
				{
					return false;
				}
				key = line.Substring(0, num2).Trim();
				value = line.Substring(num2 + 1).Trim();
				value = value.Replace("\r\n", "\n").Replace("\n", "\\n");
				value = DecodeString(value);
				if (key.Length > 2 && key[0] == '[')
				{
					int num3 = key.IndexOf(']');
					if (num3 >= 0)
					{
						termType = key.Substring(1, num3 - 1);
						key = key.Substring(num3 + 1);
					}
				}
				ValidateFullTerm(ref key);
				return true;
			}

			public static string ReadCSVfile(string Path, Encoding encoding)
			{
				string text = string.Empty;
				using (StreamReader streamReader = new StreamReader(Path, encoding))
				{
					text = streamReader.ReadToEnd();
				}
				text = text.Replace("\r\n", "\n");
				return text.Replace("\r", "\n");
			}

			public static List<string[]> ReadCSV(string Text, char Separator = ',')
			{
				int iStart = 0;
				List<string[]> list = new List<string[]>();
				while (iStart < Text.Length)
				{
					string[] array = ParseCSVline(Text, ref iStart, Separator);
					if (array == null)
					{
						break;
					}
					list.Add(array);
				}
				return list;
			}

			private static string[] ParseCSVline(string Line, ref int iStart, char Separator)
			{
				List<string> list = new List<string>();
				int length = Line.Length;
				int iWordStart = iStart;
				bool flag = false;
				while (iStart < length)
				{
					char c = Line[iStart];
					if (flag)
					{
						if (c == '"')
						{
							if (iStart + 1 >= length || Line[iStart + 1] != '"')
							{
								flag = false;
							}
							else if (iStart + 2 < length && Line[iStart + 2] == '"')
							{
								flag = false;
								iStart += 2;
							}
							else
							{
								iStart++;
							}
						}
					}
					else if (c == '\n' || c == Separator)
					{
						AddCSVtoken(ref list, ref Line, iStart, ref iWordStart);
						if (c == '\n')
						{
							iStart++;
							break;
						}
					}
					else if (c == '"')
					{
						flag = true;
					}
					iStart++;
				}
				if (iStart > iWordStart)
				{
					AddCSVtoken(ref list, ref Line, iStart, ref iWordStart);
				}
				return list.ToArray();
			}

			private static void AddCSVtoken(ref List<string> list, ref string Line, int iEnd, ref int iWordStart)
			{
				string text = Line.Substring(iWordStart, iEnd - iWordStart);
				iWordStart = iEnd + 1;
				text = text.Replace("\"\"", "\"");
				if (text.Length > 1 && text[0] == '"' && text[text.Length - 1] == '"')
				{
					text = text.Substring(1, text.Length - 2);
				}
				list.Add(text);
			}

			public static List<string[]> ReadI2CSV(string Text)
			{
				string[] separator = new string[1] { "[*]" };
				string[] separator2 = new string[1] { "[ln]" };
				List<string[]> list = new List<string[]>();
				string[] array = Text.Split(separator2, StringSplitOptions.None);
				foreach (string text in array)
				{
					list.Add(text.Split(separator, StringSplitOptions.None));
				}
				return list;
			}

			public static void ValidateFullTerm(ref string Term)
			{
				Term = Term.Replace('\\', '/');
				int num = Term.IndexOf('/');
				if (num >= 0)
				{
					int startIndex;
					while ((startIndex = Term.LastIndexOf('/')) != num)
					{
						Term = Term.Remove(startIndex, 1);
					}
				}
			}

			public static string EncodeString(string str)
			{
				if (string.IsNullOrEmpty(str))
				{
					return string.Empty;
				}
				return str.Replace("\r\n", "<\\n>").Replace("\r", "<\\n>").Replace("\n", "<\\n>");
			}

			public static string DecodeString(string str)
			{
				if (string.IsNullOrEmpty(str))
				{
					return string.Empty;
				}
				return str.Replace("<\\n>", "\r\n");
			}
		}
		[AddComponentMenu("I2/Localization/I2 Localize")]
		public class Localize : MonoBehaviour
		{
			public enum TermModification
			{
				DontModify,
				ToUpper,
				ToLower,
				ToUpperFirst,
				ToTitle
			}

			public string mTerm = string.Empty;

			public string mTermSecondary = string.Empty;

			[NonSerialized]
			public string FinalTerm;

			[NonSerialized]
			public string FinalSecondaryTerm;

			public TermModification PrimaryTermModifier;

			public TermModification SecondaryTermModifier;

			public string TermPrefix;

			public string TermSuffix;

			public bool LocalizeOnAwake = true;

			private string LastLocalizedLanguage;

			public bool IgnoreRTL;

			public int MaxCharactersInRTL;

			public bool IgnoreNumbersInRTL = true;

			public bool CorrectAlignmentForRTL = true;

			public bool AddSpacesToJoinedLanguages;

			public bool AllowLocalizedParameters = true;

			public bool AllowParameters = true;

			public List<UnityEngine.Object> TranslatedObjects = new List<UnityEngine.Object>();

			[NonSerialized]
			public Dictionary<string, UnityEngine.Object> mAssetDictionary = new Dictionary<string, UnityEngine.Object>(StringComparer.Ordinal);

			public UnityEvent LocalizeEvent = new UnityEvent();

			public static string MainTranslation;

			public static string SecondaryTranslation;

			public static string CallBackTerm;

			public static string CallBackSecondaryTerm;

			public static Localize CurrentLocalizeComponent;

			public bool AlwaysForceLocalize;

			[SerializeField]
			public EventCallback LocalizeCallBack = new EventCallback();

			public bool mGUI_ShowReferences;

			public bool mGUI_ShowTems = true;

			public bool mGUI_ShowCallback;

			public ILocalizeTarget mLocalizeTarget;

			public string mLocalizeTargetName;

			public string Term
			{
				get
				{
					return mTerm;
				}
				set
				{
					SetTerm(value);
				}
			}

			public string SecondaryTerm
			{
				get
				{
					return mTermSecondary;
				}
				set
				{
					SetTerm(null, value);
				}
			}

			private void Awake()
			{
				UpdateAssetDictionary();
				FindTarget();
				if (LocalizeOnAwake)
				{
					OnLocalize();
				}
			}

			private void OnEnable()
			{
				OnLocalize();
			}

			public bool HasCallback()
			{
				if (LocalizeCallBack.HasCallback())
				{
					return true;
				}
				return LocalizeEvent.GetPersistentEventCount() > 0;
			}

			public void OnLocalize(bool Force = false)
			{
				if ((!Force && (!base.enabled || base.gameObject == null || !base.gameObject.activeInHierarchy)) || string.IsNullOrEmpty(LocalizationManager.CurrentLanguage) || (!AlwaysForceLocalize && !Force && !HasCallback() && LastLocalizedLanguage == LocalizationManager.CurrentLanguage))
				{
					return;
				}
				LastLocalizedLanguage = LocalizationManager.CurrentLanguage;
				if (string.IsNullOrEmpty(FinalTerm) || string.IsNullOrEmpty(FinalSecondaryTerm))
				{
					GetFinalTerms(out FinalTerm, out FinalSecondaryTerm);
				}
				bool flag = I2Utils.IsPlaying() && HasCallback();
				if (!flag && string.IsNullOrEmpty(FinalTerm) && string.IsNullOrEmpty(FinalSecondaryTerm))
				{
					return;
				}
				CallBackTerm = FinalTerm;
				CallBackSecondaryTerm = FinalSecondaryTerm;
				MainTranslation = ((string.IsNullOrEmpty(FinalTerm) || FinalTerm == "-") ? null : LocalizationManager.GetTranslation(FinalTerm, FixForRTL: false));
				SecondaryTranslation = ((string.IsNullOrEmpty(FinalSecondaryTerm) || FinalSecondaryTerm == "-") ? null : LocalizationManager.GetTranslation(FinalSecondaryTerm, FixForRTL: false));
				if (!flag && string.IsNullOrEmpty(FinalTerm) && string.IsNullOrEmpty(SecondaryTranslation))
				{
					return;
				}
				CurrentLocalizeComponent = this;
				LocalizeCallBack.Execute(this);
				LocalizeEvent.Invoke();
				if (AllowParameters)
				{
					LocalizationManager.ApplyLocalizationParams(ref MainTranslation, base.gameObject, AllowLocalizedParameters);
				}
				if (!FindTarget())
				{
					return;
				}
				bool flag2 = LocalizationManager.IsRight2Left && !IgnoreRTL;
				if (MainTranslation != null)
				{
					switch (PrimaryTermModifier)
					{
					case TermModification.ToUpper:
						MainTranslation = MainTranslation.ToUpper();
						break;
					case TermModification.ToLower:
						MainTranslation = MainTranslation.ToLower();
						break;
					case TermModification.ToUpperFirst:
						MainTranslation = GoogleTranslation.UppercaseFirst(MainTranslation);
						break;
					case TermModification.ToTitle:
						MainTranslation = GoogleTranslation.TitleCase(MainTranslation);
						break;
					}
					if (!string.IsNullOrEmpty(TermPrefix))
					{
						MainTranslation = (flag2 ? (MainTranslation + TermPrefix) : (TermPrefix + MainTranslation));
					}
					if (!string.IsNullOrEmpty(TermSuffix))
					{
						MainTranslation = (flag2 ? (TermSuffix + MainTranslation) : (MainTranslation + TermSuffix));
					}
					if (AddSpacesToJoinedLanguages && LocalizationManager.HasJoinedWords && !string.IsNullOrEmpty(MainTranslation))
					{
						StringBuilder stringBuilder = new StringBuilder();
						stringBuilder.Append(MainTranslation[0]);
						int i = 1;
						for (int length = MainTranslation.Length; i < length; i++)
						{
							stringBuilder.Append(' ');
							stringBuilder.Append(MainTranslation[i]);
						}
						MainTranslation = stringBuilder.ToString();
					}
					if (flag2 && mLocalizeTarget.AllowMainTermToBeRTL() && !string.IsNullOrEmpty(MainTranslation))
					{
						MainTranslation = LocalizationManager.ApplyRTLfix(MainTranslation, MaxCharactersInRTL, IgnoreNumbersInRTL);
					}
				}
				if (SecondaryTranslation != null)
				{
					switch (SecondaryTermModifier)
					{
					case TermModification.ToUpper:
						SecondaryTranslation = SecondaryTranslation.ToUpper();
						break;
					case TermModification.ToLower:
						SecondaryTranslation = SecondaryTranslation.ToLower();
						break;
					case TermModification.ToUpperFirst:
						SecondaryTranslation = GoogleTranslation.UppercaseFirst(SecondaryTranslation);
						break;
					case TermModification.ToTitle:
						SecondaryTranslation = GoogleTranslation.TitleCase(SecondaryTranslation);
						break;
					}
					if (flag2 && mLocalizeTarget.AllowSecondTermToBeRTL() && !string.IsNullOrEmpty(SecondaryTranslation))
					{
						SecondaryTranslation = LocalizationManager.ApplyRTLfix(SecondaryTranslation);
					}
				}
				if (LocalizationManager.HighlightLocalizedTargets)
				{
					MainTranslation = "LOC:" + FinalTerm;
				}
				mLocalizeTarget.DoLocalize(this, MainTranslation, SecondaryTranslation);
				CurrentLocalizeComponent = null;
			}

			public bool FindTarget()
			{
				if (mLocalizeTarget != null && mLocalizeTarget.IsValid(this))
				{
					return true;
				}
				if (mLocalizeTarget != null)
				{
					UnityEngine.Object.DestroyImmediate(mLocalizeTarget);
					mLocalizeTarget = null;
					mLocalizeTargetName = null;
				}
				if (!string.IsNullOrEmpty(mLocalizeTargetName))
				{
					foreach (ILocalizeTargetDescriptor mLocalizeTarget in LocalizationManager.mLocalizeTargets)
					{
						if (mLocalizeTargetName == mLocalizeTarget.GetTargetType().ToString())
						{
							if (mLocalizeTarget.CanLocalize(this))
							{
								this.mLocalizeTarget = mLocalizeTarget.CreateTarget(this);
							}
							if (this.mLocalizeTarget != null)
							{
								return true;
							}
						}
					}
				}
				foreach (ILocalizeTargetDescriptor mLocalizeTarget2 in LocalizationManager.mLocalizeTargets)
				{
					if (mLocalizeTarget2.CanLocalize(this))
					{
						this.mLocalizeTarget = mLocalizeTarget2.CreateTarget(this);
						mLocalizeTargetName = mLocalizeTarget2.GetTargetType().ToString();
						if (this.mLocalizeTarget != null)
						{
							return true;
						}
					}
				}
				return false;
			}

			public void GetFinalTerms(out string primaryTerm, out string secondaryTerm)
			{
				primaryTerm = string.Empty;
				secondaryTerm = string.Empty;
				if (FindTarget())
				{
					if (mLocalizeTarget != null)
					{
						mLocalizeTarget.GetFinalTerms(this, mTerm, mTermSecondary, out primaryTerm, out secondaryTerm);
						primaryTerm = I2Utils.GetValidTermName(primaryTerm);
					}
					if (!string.IsNullOrEmpty(mTerm))
					{
						primaryTerm = mTerm;
					}
					if (!string.IsNullOrEmpty(mTermSecondary))
					{
						secondaryTerm = mTermSecondary;
					}
					if (primaryTerm != null)
					{
						primaryTerm = primaryTerm.Trim();
					}
					if (secondaryTerm != null)
					{
						secondaryTerm = secondaryTerm.Trim();
					}
				}
			}

			public string GetMainTargetsText()
			{
				string primaryTerm = null;
				string secondaryTerm = null;
				if (mLocalizeTarget != null)
				{
					mLocalizeTarget.GetFinalTerms(this, null, null, out primaryTerm, out secondaryTerm);
				}
				if (!string.IsNullOrEmpty(primaryTerm))
				{
					return primaryTerm;
				}
				return mTerm;
			}

			public void SetFinalTerms(string Main, string Secondary, out string primaryTerm, out string secondaryTerm, bool RemoveNonASCII)
			{
				primaryTerm = (RemoveNonASCII ? I2Utils.GetValidTermName(Main) : Main);
				secondaryTerm = Secondary;
			}

			public void SetTerm(string primary)
			{
				if (!string.IsNullOrEmpty(primary))
				{
					FinalTerm = (mTerm = primary);
				}
				OnLocalize(Force: true);
			}

			public void SetTerm(string primary, string secondary)
			{
				if (!string.IsNullOrEmpty(primary))
				{
					FinalTerm = (mTerm = primary);
				}
				FinalSecondaryTerm = (mTermSecondary = secondary);
				OnLocalize(Force: true);
			}

			internal T GetSecondaryTranslatedObj<T>(ref string mainTranslation, ref string secondaryTranslation) where T : UnityEngine.Object
			{
				DeserializeTranslation(mainTranslation, out var value, out var secondary);
				T val = null;
				if (!string.IsNullOrEmpty(secondary))
				{
					val = GetObject<T>(secondary);
					if (val != null)
					{
						mainTranslation = value;
						secondaryTranslation = secondary;
					}
				}
				if (val == null)
				{
					val = GetObject<T>(secondaryTranslation);
				}
				return val;
			}

			public void UpdateAssetDictionary()
			{
				TranslatedObjects.RemoveAll((UnityEngine.Object x) => x == null);
				mAssetDictionary = (from o in TranslatedObjects.Distinct()
					group o by o.name).ToDictionary((IGrouping<string, UnityEngine.Object> g) => g.Key, (IGrouping<string, UnityEngine.Object> g) => g.First());
			}

			internal T GetObject<T>(string Translation) where T : UnityEngine.Object
			{
				if (string.IsNullOrEmpty(Translation))
				{
					return null;
				}
				return GetTranslatedObject<T>(Translation);
			}

			private T GetTranslatedObject<T>(string Translation) where T : UnityEngine.Object
			{
				return FindTranslatedObject<T>(Translation);
			}

			private void DeserializeTranslation(string translation, out string value, out string secondary)
			{
				if (!string.IsNullOrEmpty(translation) && translation.Length > 1 && translation[0] == '[')
				{
					int num = translation.IndexOf(']');
					if (num > 0)
					{
						secondary = translation.Substring(1, num - 1);
						value = translation.Substring(num + 1);
						return;
					}
				}
				value = translation;
				secondary = string.Empty;
			}

			public T FindTranslatedObject<T>(string value) where T : UnityEngine.Object
			{
				if (string.IsNullOrEmpty(value))
				{
					return null;
				}
				if (mAssetDictionary == null || mAssetDictionary.Count != TranslatedObjects.Count)
				{
					UpdateAssetDictionary();
				}
				foreach (KeyValuePair<string, UnityEngine.Object> item in mAssetDictionary)
				{
					if (item.Value is T && value.EndsWith(item.Key, StringComparison.OrdinalIgnoreCase) && string.Compare(value, item.Key, StringComparison.OrdinalIgnoreCase) == 0)
					{
						return (T)item.Value;
					}
				}
				T val = LocalizationManager.FindAsset(value) as T;
				if ((bool)val)
				{
					return val;
				}
				return ResourceManager.pInstance.GetAsset<T>(value);
			}

			public bool HasTranslatedObject(UnityEngine.Object Obj)
			{
				if (TranslatedObjects.Contains(Obj))
				{
					return true;
				}
				return ResourceManager.pInstance.HasAsset(Obj);
			}

			public void AddTranslatedObject(UnityEngine.Object Obj)
			{
				if (!TranslatedObjects.Contains(Obj))
				{
					TranslatedObjects.Add(Obj);
					UpdateAssetDictionary();
				}
			}

			public void SetGlobalLanguage(string Language)
			{
				LocalizationManager.CurrentLanguage = Language;
			}
		}
		[AddComponentMenu("I2/Localization/Localize Dropdown")]
		public class LocalizeDropdown : MonoBehaviour
		{
			public List<string> _Terms = new List<string>();

			public void Start()
			{
				LocalizationManager.OnLocalizeEvent += OnLocalize;
				OnLocalize();
			}

			public void OnDestroy()
			{
				LocalizationManager.OnLocalizeEvent -= OnLocalize;
			}

			private void OnEnable()
			{
				if (_Terms.Count == 0)
				{
					FillValues();
				}
				OnLocalize();
			}

			public void OnLocalize()
			{
				if (base.enabled && !(base.gameObject == null) && base.gameObject.activeInHierarchy && !string.IsNullOrEmpty(LocalizationManager.CurrentLanguage))
				{
					UpdateLocalization();
				}
			}

			private void FillValues()
			{
				Dropdown component = GetComponent<Dropdown>();
				if (component == null && I2Utils.IsPlaying())
				{
					FillValuesTMPro();
					return;
				}
				foreach (Dropdown.OptionData option in component.options)
				{
					_Terms.Add(option.text);
				}
			}

			public void UpdateLocalization()
			{
				Dropdown component = GetComponent<Dropdown>();
				if (component == null)
				{
					UpdateLocalizationTMPro();
					return;
				}
				component.options.Clear();
				foreach (string term in _Terms)
				{
					string translation = LocalizationManager.GetTranslation(term);
					component.options.Add(new Dropdown.OptionData(translation));
				}
				component.RefreshShownValue();
			}

			public void UpdateLocalizationTMPro()
			{
				TMP_Dropdown component = GetComponent<TMP_Dropdown>();
				if (component == null)
				{
					return;
				}
				component.options.Clear();
				foreach (string term in _Terms)
				{
					string translation = LocalizationManager.GetTranslation(term);
					component.options.Add(new TMP_Dropdown.OptionData(translation));
				}
				component.RefreshShownValue();
			}

			private void FillValuesTMPro()
			{
				TMP_Dropdown component = GetComponent<TMP_Dropdown>();
				if (component == null)
				{
					return;
				}
				foreach (TMP_Dropdown.OptionData option in component.options)
				{
					_Terms.Add(option.text);
				}
			}
		}
		public static class LocalizationManager
		{
			public delegate object _GetParam(string param);

			public delegate void OnLocalizeCallback();

			private static string mCurrentLanguage;

			private static string mLanguageCode;

			private static CultureInfo mCurrentCulture;

			private static bool mChangeCultureInfo = false;

			public static bool IsRight2Left = false;

			public static bool HasJoinedWords = false;

			public static List<ILocalizationParamsManager> ParamManagers = new List<ILocalizationParamsManager>();

			private static string[] LanguagesRTL = new string[21]
			{
				"ar-DZ", "ar", "ar-BH", "ar-EG", "ar-IQ", "ar-JO", "ar-KW", "ar-LB", "ar-LY", "ar-MA",
				"ar-OM", "ar-QA", "ar-SA", "ar-SY", "ar-TN", "ar-AE", "ar-YE", "fa", "he", "ur",
				"ji"
			};

			public static List<LanguageSourceData> Sources = new List<LanguageSourceData>();

			public static string[] GlobalSources = new string[1] { "I2Languages" };

			public static Func<LanguageSourceData, bool> Callback_AllowSyncFromGoogle = null;

			private static string mCurrentDeviceLanguage;

			public static List<ILocalizeTargetDescriptor> mLocalizeTargets = new List<ILocalizeTargetDescriptor>();

			private static bool mLocalizeIsScheduled = false;

			private static bool mLocalizeIsScheduledWithForcedValue = false;

			public static bool HighlightLocalizedTargets = false;

			public static string CurrentLanguage
			{
				get
				{
					InitializeIfNeeded();
					return mCurrentLanguage;
				}
				set
				{
					InitializeIfNeeded();
					string supportedLanguage = GetSupportedLanguage(value);
					if (!string.IsNullOrEmpty(supportedLanguage) && mCurrentLanguage != supportedLanguage)
					{
						SetLanguageAndCode(supportedLanguage, GetLanguageCode(supportedLanguage));
					}
				}
			}

			public static string CurrentLanguageCode
			{
				get
				{
					InitializeIfNeeded();
					return mLanguageCode;
				}
				set
				{
					InitializeIfNeeded();
					if (mLanguageCode != value)
					{
						string languageFromCode = GetLanguageFromCode(value);
						if (!string.IsNullOrEmpty(languageFromCode))
						{
							SetLanguageAndCode(languageFromCode, value);
						}
					}
				}
			}

			public static string CurrentRegion
			{
				get
				{
					string currentLanguage = CurrentLanguage;
					int num = currentLanguage.IndexOfAny("/\\".ToCharArray());
					if (num > 0)
					{
						return currentLanguage.Substring(num + 1);
					}
					num = currentLanguage.IndexOfAny("[(".ToCharArray());
					int num2 = currentLanguage.LastIndexOfAny("])".ToCharArray());
					if (num > 0 && num != num2)
					{
						return currentLanguage.Substring(num + 1, num2 - num - 1);
					}
					return string.Empty;
				}
				set
				{
					string text = CurrentLanguage;
					int num = text.IndexOfAny("/\\".ToCharArray());
					if (num > 0)
					{
						CurrentLanguage = text.Substring(num + 1) + value;
						return;
					}
					num = text.IndexOfAny("[(".ToCharArray());
					int num2 = text.LastIndexOfAny("])".ToCharArray());
					if (num > 0 && num != num2)
					{
						text = text.Substring(num);
					}
					CurrentLanguage = text + "(" + value + ")";
				}
			}

			public static string CurrentRegionCode
			{
				get
				{
					string currentLanguageCode = CurrentLanguageCode;
					int num = currentLanguageCode.IndexOfAny(" -_/\\".ToCharArray());
					if (num >= 0)
					{
						return currentLanguageCode.Substring(num + 1);
					}
					return string.Empty;
				}
				set
				{
					string text = CurrentLanguageCode;
					int num = text.IndexOfAny(" -_/\\".ToCharArray());
					if (num > 0)
					{
						text = text.Substring(0, num);
					}
					CurrentLanguageCode = text + "-" + value;
				}
			}

			public static CultureInfo CurrentCulture => mCurrentCulture;

			public static event OnLocalizeCallback OnLocalizeEvent;

			public static void InitializeIfNeeded()
			{
				if (string.IsNullOrEmpty(mCurrentLanguage) || Sources.Count == 0)
				{
					AutoLoadGlobalParamManagers();
					UpdateSources();
					SelectStartupLanguage();
				}
			}

			public static string GetVersion()
			{
				return "2.8.13 f1";
			}

			public static int GetRequiredWebServiceVersion()
			{
				return 5;
			}

			public static string GetWebServiceURL(LanguageSourceData source = null)
			{
				if (source != null && !string.IsNullOrEmpty(source.Google_WebServiceURL))
				{
					return source.Google_WebServiceURL;
				}
				InitializeIfNeeded();
				for (int i = 0; i < Sources.Count; i++)
				{
					if (Sources[i] != null && !string.IsNullOrEmpty(Sources[i].Google_WebServiceURL))
					{
						return Sources[i].Google_WebServiceURL;
					}
				}
				return string.Empty;
			}

			public static void SetLanguageAndCode(string LanguageName, string LanguageCode, bool RememberLanguage = true, bool Force = false)
			{
				if (mCurrentLanguage != LanguageName || mLanguageCode != LanguageCode || Force)
				{
					if (RememberLanguage)
					{
						PersistentStorage.SetSetting_String("I2 Language", LanguageName);
					}
					mCurrentLanguage = LanguageName;
					mLanguageCode = LanguageCode;
					mCurrentCulture = CreateCultureForCode(LanguageCode);
					if (mChangeCultureInfo)
					{
						SetCurrentCultureInfo();
					}
					IsRight2Left = IsRTL(mLanguageCode);
					HasJoinedWords = GoogleLanguages.LanguageCode_HasJoinedWord(mLanguageCode);
					LocalizeAll(Force);
				}
			}

			private static CultureInfo CreateCultureForCode(string code)
			{
				try
				{
					return CultureInfo.CreateSpecificCulture(code);
				}
				catch (Exception)
				{
					return CultureInfo.InvariantCulture;
				}
			}

			public static void EnableChangingCultureInfo(bool bEnable)
			{
				if (!mChangeCultureInfo && bEnable)
				{
					SetCurrentCultureInfo();
				}
				mChangeCultureInfo = bEnable;
			}

			private static void SetCurrentCultureInfo()
			{
				Thread.CurrentThread.CurrentCulture = mCurrentCulture;
			}

			private static void SelectStartupLanguage()
			{
				if (Sources.Count == 0)
				{
					return;
				}
				string setting_String = PersistentStorage.GetSetting_String("I2 Language", string.Empty);
				string currentDeviceLanguage = GetCurrentDeviceLanguage();
				if (!string.IsNullOrEmpty(setting_String) && HasLanguage(setting_String, AllowDiscartingRegion: true, Initialize: false))
				{
					SetLanguageAndCode(setting_String, GetLanguageCode(setting_String));
					return;
				}
				if (!Sources[0].IgnoreDeviceLanguage)
				{
					string supportedLanguage = GetSupportedLanguage(currentDeviceLanguage, ignoreDisabled: true);
					if (!string.IsNullOrEmpty(supportedLanguage))
					{
						SetLanguageAndCode(supportedLanguage, GetLanguageCode(supportedLanguage), RememberLanguage: false);
						return;
					}
				}
				int i = 0;
				for (int count = Sources.Count; i < count; i++)
				{
					if (Sources[i].mLanguages.Count <= 0)
					{
						continue;
					}
					for (int j = 0; j < Sources[i].mLanguages.Count; j++)
					{
						if (Sources[i].mLanguages[j].IsEnabled())
						{
							SetLanguageAndCode(Sources[i].mLanguages[j].Name, Sources[i].mLanguages[j].Code, RememberLanguage: false);
							return;
						}
					}
				}
			}

			public static bool HasLanguage(string Language, bool AllowDiscartingRegion = true, bool Initialize = true, bool SkipDisabled = true)
			{
				if (Initialize)
				{
					InitializeIfNeeded();
				}
				int i = 0;
				for (int count = Sources.Count; i < count; i++)
				{
					if (Sources[i].GetLanguageIndex(Language, AllowDiscartingRegion: false, SkipDisabled) >= 0)
					{
						return true;
					}
				}
				if (AllowDiscartingRegion)
				{
					int j = 0;
					for (int count2 = Sources.Count; j < count2; j++)
					{
						if (Sources[j].GetLanguageIndex(Language, AllowDiscartingRegion: true, SkipDisabled) >= 0)
						{
							return true;
						}
					}
				}
				return false;
			}

			public static string GetSupportedLanguage(string Language, bool ignoreDisabled = false)
			{
				string languageCode = GoogleLanguages.GetLanguageCode(Language);
				if (!string.IsNullOrEmpty(languageCode))
				{
					int i = 0;
					for (int count = Sources.Count; i < count; i++)
					{
						int languageIndexFromCode = Sources[i].GetLanguageIndexFromCode(languageCode, exactMatch: true, ignoreDisabled);
						if (languageIndexFromCode >= 0)
						{
							return Sources[i].mLanguages[languageIndexFromCode].Name;
						}
					}
					int j = 0;
					for (int count2 = Sources.Count; j < count2; j++)
					{
						int languageIndexFromCode2 = Sources[j].GetLanguageIndexFromCode(languageCode, exactMatch: false, ignoreDisabled);
						if (languageIndexFromCode2 >= 0)
						{
							return Sources[j].mLanguages[languageIndexFromCode2].Name;
						}
					}
				}
				int k = 0;
				for (int count3 = Sources.Count; k < count3; k++)
				{
					int languageIndex = Sources[k].GetLanguageIndex(Language, AllowDiscartingRegion: false, ignoreDisabled);
					if (languageIndex >= 0)
					{
						return Sources[k].mLanguages[languageIndex].Name;
					}
				}
				int l = 0;
				for (int count4 = Sources.Count; l < count4; l++)
				{
					int languageIndex2 = Sources[l].GetLanguageIndex(Language, AllowDiscartingRegion: true, ignoreDisabled);
					if (languageIndex2 >= 0)
					{
						return Sources[l].mLanguages[languageIndex2].Name;
					}
				}
				return string.Empty;
			}

			public static string GetLanguageCode(string Language)
			{
				if (Sources.Count == 0)
				{
					UpdateSources();
				}
				int i = 0;
				for (int count = Sources.Count; i < count; i++)
				{
					int languageIndex = Sources[i].GetLanguageIndex(Language);
					if (languageIndex >= 0)
					{
						return Sources[i].mLanguages[languageIndex].Code;
					}
				}
				return string.Empty;
			}

			public static string GetLanguageFromCode(string Code, bool exactMatch = true)
			{
				if (Sources.Count == 0)
				{
					UpdateSources();
				}
				int i = 0;
				for (int count = Sources.Count; i < count; i++)
				{
					int languageIndexFromCode = Sources[i].GetLanguageIndexFromCode(Code, exactMatch);
					if (languageIndexFromCode >= 0)
					{
						return Sources[i].mLanguages[languageIndexFromCode].Name;
					}
				}
				return string.Empty;
			}

			public static List<string> GetAllLanguages(bool SkipDisabled = true)
			{
				if (Sources.Count == 0)
				{
					UpdateSources();
				}
				List<string> Languages = new List<string>();
				int i = 0;
				for (int count = Sources.Count; i < count; i++)
				{
					Languages.AddRange(from x in Sources[i].GetLanguages(SkipDisabled)
						where !Languages.Contains(x)
						select x);
				}
				return Languages;
			}

			public static List<string> GetAllLanguagesCode(bool allowRegions = true, bool SkipDisabled = true)
			{
				List<string> Languages = new List<string>();
				int i = 0;
				for (int count = Sources.Count; i < count; i++)
				{
					Languages.AddRange(from x in Sources[i].GetLanguagesCode(allowRegions, SkipDisabled)
						where !Languages.Contains(x)
						select x);
				}
				return Languages;
			}

			public static bool IsLanguageEnabled(string Language)
			{
				int i = 0;
				for (int count = Sources.Count; i < count; i++)
				{
					if (!Sources[i].IsLanguageEnabled(Language))
					{
						return false;
					}
				}
				return true;
			}

			private static void LoadCurrentLanguage()
			{
				for (int i = 0; i < Sources.Count; i++)
				{
					int languageIndex = Sources[i].GetLanguageIndex(mCurrentLanguage, AllowDiscartingRegion: true, SkipDisabled: false);
					Sources[i].LoadLanguage(languageIndex, UnloadOtherLanguages: true, useFallback: true, onlyCurrentSpecialization: true, forceLoad: false);
				}
			}

			public static void PreviewLanguage(string NewLanguage)
			{
				mCurrentLanguage = NewLanguage;
				mLanguageCode = GetLanguageCode(mCurrentLanguage);
				IsRight2Left = IsRTL(mLanguageCode);
				HasJoinedWords = GoogleLanguages.LanguageCode_HasJoinedWord(mLanguageCode);
			}

			public static void AutoLoadGlobalParamManagers()
			{
				LocalizationParamsManager[] array = UnityEngine.Object.FindObjectsOfType<LocalizationParamsManager>();
				foreach (LocalizationParamsManager localizationParamsManager in array)
				{
					if (localizationParamsManager._IsGlobalManager && !ParamManagers.Contains(localizationParamsManager))
					{
						UnityEngine.Debug.Log(localizationParamsManager);
						ParamManagers.Add(localizationParamsManager);
					}
				}
			}

			public static void ApplyLocalizationParams(ref string translation, bool allowLocalizedParameters = true)
			{
				ApplyLocalizationParams(ref translation, (string p) => GetLocalizationParam(p, null), allowLocalizedParameters);
			}

			public static void ApplyLocalizationParams(ref string translation, GameObject root, bool allowLocalizedParameters = true)
			{
				ApplyLocalizationParams(ref translation, (string p) => GetLocalizationParam(p, root), allowLocalizedParameters);
			}

			public static void ApplyLocalizationParams(ref string translation, Dictionary<string, object> parameters, bool allowLocalizedParameters = true)
			{
				ApplyLocalizationParams(ref translation, delegate(string p)
				{
					object value = null;
					return parameters.TryGetValue(p, out value) ? value : null;
				}, allowLocalizedParameters);
			}

			public static void ApplyLocalizationParams(ref string translation, _GetParam getParam, bool allowLocalizedParameters = true)
			{
				if (translation == null)
				{
					return;
				}
				string text = null;
				int num = 0;
				int length = translation.Length;
				int num2 = 0;
				while (num2 >= 0 && num2 < translation.Length)
				{
					int num3 = translation.IndexOf("{[", num2);
					if (num3 < 0)
					{
						break;
					}
					int num4 = translation.IndexOf("]}", num3);
					if (num4 < 0)
					{
						break;
					}
					int num5 = translation.IndexOf("{[", num3 + 1);
					if (num5 > 0 && num5 < num4)
					{
						num2 = num5;
						continue;
					}
					int num6 = ((translation[num3 + 2] == '#') ? 3 : 2);
					string param = translation.Substring(num3 + num6, num4 - num3 - num6);
					string text2 = (string)getParam(param);
					if (text2 != null)
					{
						if (allowLocalizedParameters)
						{
							LanguageSourceData source;
							TermData termData = GetTermData(text2, out source);
							if (termData != null)
							{
								int languageIndex = source.GetLanguageIndex(CurrentLanguage);
								if (languageIndex >= 0)
								{
									text2 = termData.GetTranslation(languageIndex);
								}
							}
						}
						string oldValue = translation.Substring(num3, num4 - num3 + 2);
						translation = translation.Replace(oldValue, text2);
						int result = 0;
						if (int.TryParse(text2, out result))
						{
							text = GoogleLanguages.GetPluralType(CurrentLanguageCode, result).ToString();
						}
						num2 = num3 + text2.Length;
					}
					else
					{
						num2 = num4 + 2;
					}
				}
				if (text != null)
				{
					string text3 = "[i2p_" + text + "]";
					num = translation.IndexOf(text3, StringComparison.OrdinalIgnoreCase);
					num = ((num >= 0) ? (num + text3.Length) : 0);
					length = translation.IndexOf("[i2p_", num + 1, StringComparison.OrdinalIgnoreCase);
					if (length < 0)
					{
						length = translation.Length;
					}
					translation = translation.Substring(num, length - num);
				}
			}

			internal static string GetLocalizationParam(string ParamName, GameObject root)
			{
				string text = null;
				if ((bool)root)
				{
					MonoBehaviour[] components = root.GetComponents<MonoBehaviour>();
					int i = 0;
					for (int num = components.Length; i < num; i++)
					{
						if (components[i] is ILocalizationParamsManager localizationParamsManager && components[i].enabled)
						{
							text = localizationParamsManager.GetParameterValue(ParamName);
							if (text != null)
							{
								return text;
							}
						}
					}
				}
				int j = 0;
				for (int count = ParamManagers.Count; j < count; j++)
				{
					text = ParamManagers[j].GetParameterValue(ParamName);
					if (text != null)
					{
						return text;
					}
				}
				return null;
			}

			private static string GetPluralType(MatchCollection matches, string langCode, _GetParam getParam)
			{
				int i = 0;
				for (int count = matches.Count; i < count; i++)
				{
					Match match = matches[i];
					string value = match.Groups[match.Groups.Count - 1].Value;
					string text = (string)getParam(value);
					if (text != null)
					{
						int result = 0;
						if (int.TryParse(text, out result))
						{
							return GoogleLanguages.GetPluralType(langCode, result).ToString();
						}
					}
				}
				return null;
			}

			public static string ApplyRTLfix(string line)
			{
				return ApplyRTLfix(line, 0, ignoreNumbers: true);
			}

			public static string ApplyRTLfix(string line, int maxCharacters, bool ignoreNumbers)
			{
				if (string.IsNullOrEmpty(line))
				{
					return line;
				}
				char c = line[0];
				if (c == '!' || c == '.' || c == '?')
				{
					line = line.Substring(1) + c;
				}
				int tagStart = -1;
				int num = 0;
				int num2 = 40000;
				num = 0;
				List<string> list = new List<string>();
				while (I2Utils.FindNextTag(line, num, out tagStart, out num))
				{
					string text = "@@" + (char)(num2 + list.Count) + "@@";
					list.Add(line.Substring(tagStart, num - tagStart + 1));
					line = line.Substring(0, tagStart) + text + line.Substring(num + 1);
					num = tagStart + 5;
				}
				line = line.Replace("\r\n", "\n");
				line = I2Utils.SplitLine(line, maxCharacters);
				line = RTLFixer.Fix(line, showTashkeel: true, !ignoreNumbers);
				for (int i = 0; i < list.Count; i++)
				{
					int length = line.Length;
					for (int j = 0; j < length; j++)
					{
						if (line[j] == '@' && line[j + 1] == '@' && line[j + 2] >= num2 && line[j + 3] == '@' && line[j + 4] == '@')
						{
							int num3 = line[j + 2] - num2;
							num3 = ((num3 % 2 != 0) ? (num3 - 1) : (num3 + 1));
							if (num3 >= list.Count)
							{
								num3 = list.Count - 1;
							}
							line = line.Substring(0, j) + list[num3] + line.Substring(j + 5);
							break;
						}
					}
				}
				return line;
			}

			public static string FixRTL_IfNeeded(string text, int maxCharacters = 0, bool ignoreNumber = false)
			{
				if (IsRight2Left)
				{
					return ApplyRTLfix(text, maxCharacters, ignoreNumber);
				}
				return text;
			}

			public static bool IsRTL(string Code)
			{
				return Array.IndexOf(LanguagesRTL, Code) >= 0;
			}

			public static bool UpdateSources()
			{
				UnregisterDeletededSources();
				RegisterSourceInResources();
				RegisterSceneSources();
				return Sources.Count > 0;
			}

			private static void UnregisterDeletededSources()
			{
				for (int num = Sources.Count - 1; num >= 0; num--)
				{
					if (Sources[num] == null)
					{
						RemoveSource(Sources[num]);
					}
				}
			}

			private static void RegisterSceneSources()
			{
				LanguageSource[] array = (LanguageSource[])Resources.FindObjectsOfTypeAll(typeof(LanguageSource));
				foreach (LanguageSource languageSource in array)
				{
					if (!Sources.Contains(languageSource.mSource))
					{
						if (languageSource.mSource.owner == null)
						{
							languageSource.mSource.owner = languageSource;
						}
						AddSource(languageSource.mSource);
					}
				}
			}

			private static void RegisterSourceInResources()
			{
				string[] globalSources = GlobalSources;
				foreach (string name in globalSources)
				{
					LanguageSourceAsset asset = ResourceManager.pInstance.GetAsset<LanguageSourceAsset>(name);
					if ((bool)asset && !Sources.Contains(asset.mSource))
					{
						if (!asset.mSource.mIsGlobalSource)
						{
							asset.mSource.mIsGlobalSource = true;
						}
						asset.mSource.owner = asset;
						AddSource(asset.mSource);
					}
				}
			}

			private static bool AllowSyncFromGoogle(LanguageSourceData Source)
			{
				if (Callback_AllowSyncFromGoogle == null)
				{
					return true;
				}
				return Callback_AllowSyncFromGoogle(Source);
			}

			internal static void AddSource(LanguageSourceData Source)
			{
				if (Sources.Contains(Source))
				{
					return;
				}
				Sources.Add(Source);
				if (Source.HasGoogleSpreadsheet() && Source.GoogleUpdateFrequency != LanguageSourceData.eGoogleUpdateFrequency.Never && AllowSyncFromGoogle(Source))
				{
					Source.Import_Google_FromCache();
					bool justCheck = false;
					if (Source.GoogleUpdateDelay > 0f)
					{
						CoroutineManager.Start(Delayed_Import_Google(Source, Source.GoogleUpdateDelay, justCheck));
					}
					else
					{
						Source.Import_Google(ForceUpdate: false, justCheck);
					}
				}
				for (int i = 0; i < Source.mLanguages.Count(); i++)
				{
					Source.mLanguages[i].SetLoaded(loaded: true);
				}
				if (Source.mDictionary.Count == 0)
				{
					Source.UpdateDictionary(force: true);
				}
			}

			private static IEnumerator Delayed_Import_Google(LanguageSourceData source, float delay, bool justCheck)
			{
				yield return new WaitForSeconds(delay);
				source?.Import_Google(ForceUpdate: false, justCheck);
			}

			internal static void RemoveSource(LanguageSourceData Source)
			{
				Sources.Remove(Source);
			}

			public static bool IsGlobalSource(string SourceName)
			{
				return Array.IndexOf(GlobalSources, SourceName) >= 0;
			}

			public static LanguageSourceData GetSourceContaining(string term, bool fallbackToFirst = true)
			{
				if (!string.IsNullOrEmpty(term))
				{
					int i = 0;
					for (int count = Sources.Count; i < count; i++)
					{
						if (Sources[i].GetTermData(term) != null)
						{
							return Sources[i];
						}
					}
				}
				if (!fallbackToFirst || Sources.Count <= 0)
				{
					return null;
				}
				return Sources[0];
			}

			public static UnityEngine.Object FindAsset(string value)
			{
				int i = 0;
				for (int count = Sources.Count; i < count; i++)
				{
					UnityEngine.Object @object = Sources[i].FindAsset(value);
					if ((bool)@object)
					{
						return @object;
					}
				}
				return null;
			}

			public static void ApplyDownloadedDataFromGoogle()
			{
				int i = 0;
				for (int count = Sources.Count; i < count; i++)
				{
					Sources[i].ApplyDownloadedDataFromGoogle();
				}
			}

			public static string GetCurrentDeviceLanguage(bool force = false)
			{
				if (force || string.IsNullOrEmpty(mCurrentDeviceLanguage))
				{
					DetectDeviceLanguage();
				}
				return mCurrentDeviceLanguage;
			}

			private static void DetectDeviceLanguage()
			{
				try
				{
					mCurrentDeviceLanguage = new AndroidJavaClass("java/util/Locale").CallStatic<AndroidJavaObject>("getDefault", Array.Empty<object>()).Call<string>("toString", Array.Empty<object>());
					if (!string.IsNullOrEmpty(mCurrentDeviceLanguage))
					{
						mCurrentDeviceLanguage = mCurrentDeviceLanguage.Replace('_', '-');
						mCurrentDeviceLanguage = GoogleLanguages.GetLanguageName(mCurrentDeviceLanguage, useParenthesesForRegion: true);
						if (!string.IsNullOrEmpty(mCurrentDeviceLanguage))
						{
							return;
						}
					}
				}
				catch (Exception)
				{
				}
				mCurrentDeviceLanguage = Application.systemLanguage.ToString();
				if (mCurrentDeviceLanguage == "ChineseSimplified")
				{
					mCurrentDeviceLanguage = "Chinese (Simplified)";
				}
				if (mCurrentDeviceLanguage == "ChineseTraditional")
				{
					mCurrentDeviceLanguage = "Chinese (Traditional)";
				}
			}

			public static void RegisterTarget(ILocalizeTargetDescriptor desc)
			{
				if (mLocalizeTargets.FindIndex((ILocalizeTargetDescriptor x) => x.Name == desc.Name) != -1)
				{
					return;
				}
				for (int i = 0; i < mLocalizeTargets.Count; i++)
				{
					if (mLocalizeTargets[i].Priority > desc.Priority)
					{
						mLocalizeTargets.Insert(i, desc);
						return;
					}
				}
				mLocalizeTargets.Add(desc);
			}

			public static string GetTranslation(string Term, bool FixForRTL = true, int maxLineLengthForRTL = 0, bool ignoreRTLnumbers = true, bool applyParameters = false, GameObject localParametersRoot = null, string overrideLanguage = null, bool allowLocalizedParameters = true)
			{
				string Translation = null;
				TryGetTranslation(Term, out Translation, FixForRTL, maxLineLengthForRTL, ignoreRTLnumbers, applyParameters, localParametersRoot, overrideLanguage, allowLocalizedParameters);
				return Translation;
			}

			public static string GetTermTranslation(string Term, bool FixForRTL = true, int maxLineLengthForRTL = 0, bool ignoreRTLnumbers = true, bool applyParameters = false, GameObject localParametersRoot = null, string overrideLanguage = null, bool allowLocalizedParameters = true)
			{
				return GetTranslation(Term, FixForRTL, maxLineLengthForRTL, ignoreRTLnumbers, applyParameters, localParametersRoot, overrideLanguage, allowLocalizedParameters);
			}

			public static bool TryGetTranslation(string Term, out string Translation, bool FixForRTL = true, int maxLineLengthForRTL = 0, bool ignoreRTLnumbers = true, bool applyParameters = false, GameObject localParametersRoot = null, string overrideLanguage = null, bool allowLocalizedParameters = true)
			{
				Translation = null;
				if (string.IsNullOrEmpty(Term))
				{
					return false;
				}
				InitializeIfNeeded();
				int i = 0;
				for (int count = Sources.Count; i < count; i++)
				{
					if (Sources[i].TryGetTranslation(Term, out Translation, overrideLanguage))
					{
						if (applyParameters)
						{
							ApplyLocalizationParams(ref Translation, localParametersRoot, allowLocalizedParameters);
						}
						if (IsRight2Left && FixForRTL)
						{
							Translation = ApplyRTLfix(Translation, maxLineLengthForRTL, ignoreRTLnumbers);
						}
						return true;
					}
				}
				return false;
			}

			public static T GetTranslatedObject<T>(string AssetName, Localize optionalLocComp = null) where T : UnityEngine.Object
			{
				if (optionalLocComp != null)
				{
					return optionalLocComp.FindTranslatedObject<T>(AssetName);
				}
				T val = FindAsset(AssetName) as T;
				if ((bool)val)
				{
					return val;
				}
				return ResourceManager.pInstance.GetAsset<T>(AssetName);
			}

			public static T GetTranslatedObjectByTermName<T>(string Term, Localize optionalLocComp = null) where T : UnityEngine.Object
			{
				return GetTranslatedObject<T>(GetTranslation(Term, FixForRTL: false));
			}

			public static string GetAppName(string languageCode)
			{
				if (!string.IsNullOrEmpty(languageCode))
				{
					for (int i = 0; i < Sources.Count; i++)
					{
						if (string.IsNullOrEmpty(Sources[i].mTerm_AppName))
						{
							continue;
						}
						int languageIndexFromCode = Sources[i].GetLanguageIndexFromCode(languageCode, exactMatch: false);
						if (languageIndexFromCode < 0)
						{
							continue;
						}
						TermData termData = Sources[i].GetTermData(Sources[i].mTerm_AppName);
						if (termData != null)
						{
							string translation = termData.GetTranslation(languageIndexFromCode);
							if (!string.IsNullOrEmpty(translation))
							{
								return translation;
							}
						}
					}
				}
				return Application.productName;
			}

			public static void LocalizeAll(bool Force = false)
			{
				LoadCurrentLanguage();
				if (!Application.isPlaying)
				{
					DoLocalizeAll(Force);
					return;
				}
				mLocalizeIsScheduledWithForcedValue |= Force;
				if (!mLocalizeIsScheduled)
				{
					CoroutineManager.Start(Coroutine_LocalizeAll());
				}
			}

			private static IEnumerator Coroutine_LocalizeAll()
			{
				mLocalizeIsScheduled = true;
				yield return null;
				mLocalizeIsScheduled = false;
				bool force = mLocalizeIsScheduledWithForcedValue;
				mLocalizeIsScheduledWithForcedValue = false;
				DoLocalizeAll(force);
			}

			private static void DoLocalizeAll(bool Force = false)
			{
				Localize[] array = (Localize[])Resources.FindObjectsOfTypeAll(typeof(Localize));
				int i = 0;
				for (int num = array.Length; i < num; i++)
				{
					array[i].OnLocalize(Force);
				}
				if (LocalizationManager.OnLocalizeEvent != null)
				{
					LocalizationManager.OnLocalizeEvent();
				}
			}

			public static List<string> GetCategories()
			{
				List<string> list = new List<string>();
				int i = 0;
				for (int count = Sources.Count; i < count; i++)
				{
					Sources[i].GetCategories(OnlyMainCategory: false, list);
				}
				return list;
			}

			public static List<string> GetTermsList(string Category = null)
			{
				if (Sources.Count == 0)
				{
					UpdateSources();
				}
				if (Sources.Count == 1)
				{
					return Sources[0].GetTermsList(Category);
				}
				HashSet<string> hashSet = new HashSet<string>();
				int i = 0;
				for (int count = Sources.Count; i < count; i++)
				{
					hashSet.UnionWith(Sources[i].GetTermsList(Category));
				}
				return new List<string>(hashSet);
			}

			public static TermData GetTermData(string term)
			{
				InitializeIfNeeded();
				int i = 0;
				for (int count = Sources.Count; i < count; i++)
				{
					TermData termData = Sources[i].GetTermData(term);
					if (termData != null)
					{
						return termData;
					}
				}
				return null;
			}

			public static TermData GetTermData(string term, out LanguageSourceData source)
			{
				InitializeIfNeeded();
				int i = 0;
				for (int count = Sources.Count; i < count; i++)
				{
					TermData termData = Sources[i].GetTermData(term);
					if (termData != null)
					{
						source = Sources[i];
						return termData;
					}
				}
				source = null;
				return null;
			}
		}
		public abstract class ILocalizeTarget : ScriptableObject
		{
			public abstract bool IsValid(Localize cmp);

			public abstract void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm);

			public abstract void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation);

			public abstract bool CanUseSecondaryTerm();

			public abstract bool AllowMainTermToBeRTL();

			public abstract bool AllowSecondTermToBeRTL();

			public abstract eTermType GetPrimaryTermType(Localize cmp);

			public abstract eTermType GetSecondaryTermType(Localize cmp);
		}
		public abstract class LocalizeTarget<T> : ILocalizeTarget where T : UnityEngine.Object
		{
			public T mTarget;

			public override bool IsValid(Localize cmp)
			{
				if (mTarget != null)
				{
					UnityEngine.Component component = mTarget as UnityEngine.Component;
					if (component != null && component.gameObject != cmp.gameObject)
					{
						mTarget = null;
					}
				}
				if (mTarget == null)
				{
					mTarget = cmp.GetComponent<T>();
				}
				return mTarget != null;
			}
		}
		public abstract class ILocalizeTargetDescriptor
		{
			public string Name;

			public int Priority;

			public abstract bool CanLocalize(Localize cmp);

			public abstract ILocalizeTarget CreateTarget(Localize cmp);

			public abstract Type GetTargetType();
		}
		public abstract class LocalizeTargetDesc<T> : ILocalizeTargetDescriptor where T : ILocalizeTarget
		{
			public override ILocalizeTarget CreateTarget(Localize cmp)
			{
				return ScriptableObject.CreateInstance<T>();
			}

			public override Type GetTargetType()
			{
				return typeof(T);
			}
		}
		public class LocalizeTargetDesc_Type<T, G> : LocalizeTargetDesc<G> where T : UnityEngine.Object where G : LocalizeTarget<T>
		{
			public override bool CanLocalize(Localize cmp)
			{
				return cmp.GetComponent<T>() != null;
			}

			public override ILocalizeTarget CreateTarget(Localize cmp)
			{
				T component = cmp.GetComponent<T>();
				if (component == null)
				{
					return null;
				}
				G val = ScriptableObject.CreateInstance<G>();
				val.mTarget = component;
				return val;
			}
		}
		public class LocalizeTarget_TextMeshPro_Label : LocalizeTarget<TextMeshPro>
		{
			private TextAlignmentOptions mAlignment_RTL = TextAlignmentOptions.Right;

			private TextAlignmentOptions mAlignment_LTR = TextAlignmentOptions.Left;

			private bool mAlignmentWasRTL;

			private bool mInitializeAlignment = true;

			static LocalizeTarget_TextMeshPro_Label()
			{
				AutoRegister();
			}

			[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
			private static void AutoRegister()
			{
				LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Type<TextMeshPro, LocalizeTarget_TextMeshPro_Label>
				{
					Name = "TextMeshPro Label",
					Priority = 100
				});
			}

			public override eTermType GetPrimaryTermType(Localize cmp)
			{
				return eTermType.Text;
			}

			public override eTermType GetSecondaryTermType(Localize cmp)
			{
				return eTermType.Font;
			}

			public override bool CanUseSecondaryTerm()
			{
				return true;
			}

			public override bool AllowMainTermToBeRTL()
			{
				return true;
			}

			public override bool AllowSecondTermToBeRTL()
			{
				return false;
			}

			public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
			{
				primaryTerm = (mTarget ? mTarget.text : null);
				secondaryTerm = ((mTarget.font != null) ? mTarget.font.name : string.Empty);
			}

			public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
			{
				TMP_FontAsset secondaryTranslatedObj = cmp.GetSecondaryTranslatedObj<TMP_FontAsset>(ref mainTranslation, ref secondaryTranslation);
				if (secondaryTranslatedObj != null)
				{
					SetFont(mTarget, secondaryTranslatedObj);
				}
				else
				{
					Material secondaryTranslatedObj2 = cmp.GetSecondaryTranslatedObj<Material>(ref mainTranslation, ref secondaryTranslation);
					if (secondaryTranslatedObj2 != null && mTarget.fontMaterial != secondaryTranslatedObj2)
					{
						if (!secondaryTranslatedObj2.name.StartsWith(mTarget.font.name, StringComparison.Ordinal))
						{
							secondaryTranslatedObj = GetTMPFontFromMaterial(cmp, secondaryTranslation.EndsWith(secondaryTranslatedObj2.name, StringComparison.Ordinal) ? secondaryTranslation : secondaryTranslatedObj2.name);
							if (secondaryTranslatedObj != null)
							{
								SetFont(mTarget, secondaryTranslatedObj);
							}
						}
						SetMaterial(mTarget, secondaryTranslatedObj2);
					}
				}
				if (mInitializeAlignment)
				{
					mInitializeAlignment = false;
					mAlignmentWasRTL = LocalizationManager.IsRight2Left;
					InitAlignment_TMPro(mAlignmentWasRTL, mTarget.alignment, out mAlignment_LTR, out mAlignment_RTL);
				}
				else
				{
					InitAlignment_TMPro(mAlignmentWasRTL, mTarget.alignment, out var alignLTR, out var alignRTL);
					if ((mAlignmentWasRTL && mAlignment_RTL != alignRTL) || (!mAlignmentWasRTL && mAlignment_LTR != alignLTR))
					{
						mAlignment_LTR = alignLTR;
						mAlignment_RTL = alignRTL;
					}
					mAlignmentWasRTL = LocalizationManager.IsRight2Left;
				}
				if (mainTranslation == null || !(mTarget.text != mainTranslation))
				{
					return;
				}
				if (mainTranslation != null && cmp.CorrectAlignmentForRTL)
				{
					mTarget.alignment = (LocalizationManager.IsRight2Left ? mAlignment_RTL : mAlignment_LTR);
					mTarget.isRightToLeftText = LocalizationManager.IsRight2Left;
					if (LocalizationManager.IsRight2Left)
					{
						mainTranslation = I2Utils.ReverseText(mainTranslation);
					}
				}
				mTarget.text = mainTranslation;
			}

			internal static TMP_FontAsset GetTMPFontFromMaterial(Localize cmp, string matName)
			{
				string text = " .\\/-[]()";
				int num = matName.Length - 1;
				while (num > 0)
				{
					while (num > 0 && text.IndexOf(matName[num]) >= 0)
					{
						num--;
					}
					if (num <= 0)
					{
						break;
					}
					string translation = matName.Substring(0, num + 1);
					TMP_FontAsset @object = cmp.GetObject<TMP_FontAsset>(translation);
					if (@object != null)
					{
						return @object;
					}
					while (num > 0 && text.IndexOf(matName[num]) < 0)
					{
						num--;
					}
				}
				return null;
			}

			internal static void InitAlignment_TMPro(bool isRTL, TextAlignmentOptions alignment, out TextAlignmentOptions alignLTR, out TextAlignmentOptions alignRTL)
			{
				alignLTR = (alignRTL = alignment);
				if (isRTL)
				{
					switch (alignment)
					{
					case TextAlignmentOptions.TopRight:
						alignLTR = TextAlignmentOptions.TopLeft;
						break;
					case TextAlignmentOptions.Right:
						alignLTR = TextAlignmentOptions.Left;
						break;
					case TextAlignmentOptions.BottomRight:
						alignLTR = TextAlignmentOptions.BottomLeft;
						break;
					case TextAlignmentOptions.BaselineRight:
						alignLTR = TextAlignmentOptions.BaselineLeft;
						break;
					case TextAlignmentOptions.MidlineRight:
						alignLTR = TextAlignmentOptions.MidlineLeft;
						break;
					case TextAlignmentOptions.CaplineRight:
						alignLTR = TextAlignmentOptions.CaplineLeft;
						break;
					case TextAlignmentOptions.TopLeft:
						alignLTR = TextAlignmentOptions.TopRight;
						break;
					case TextAlignmentOptions.Left:
						alignLTR = TextAlignmentOptions.Right;
						break;
					case TextAlignmentOptions.BottomLeft:
						alignLTR = TextAlignmentOptions.BottomRight;
						break;
					case TextAlignmentOptions.BaselineLeft:
						alignLTR = TextAlignmentOptions.BaselineRight;
						break;
					case TextAlignmentOptions.MidlineLeft:
						alignLTR = TextAlignmentOptions.MidlineRight;
						break;
					case TextAlignmentOptions.CaplineLeft:
						alignLTR = TextAlignmentOptions.CaplineRight;
						break;
					}
				}
				else
				{
					switch (alignment)
					{
					case TextAlignmentOptions.TopRight:
						alignRTL = TextAlignmentOptions.TopLeft;
						break;
					case TextAlignmentOptions.Right:
						alignRTL = TextAlignmentOptions.Left;
						break;
					case TextAlignmentOptions.BottomRight:
						alignRTL = TextAlignmentOptions.BottomLeft;
						break;
					case TextAlignmentOptions.BaselineRight:
						alignRTL = TextAlignmentOptions.BaselineLeft;
						break;
					case TextAlignmentOptions.MidlineRight:
						alignRTL = TextAlignmentOptions.MidlineLeft;
						break;
					case TextAlignmentOptions.CaplineRight:
						alignRTL = TextAlignmentOptions.CaplineLeft;
						break;
					case TextAlignmentOptions.TopLeft:
						alignRTL = TextAlignmentOptions.TopRight;
						break;
					case TextAlignmentOptions.Left:
						alignRTL = TextAlignmentOptions.Right;
						break;
					case TextAlignmentOptions.BottomLeft:
						alignRTL = TextAlignmentOptions.BottomRight;
						break;
					case TextAlignmentOptions.BaselineLeft:
						alignRTL = TextAlignmentOptions.BaselineRight;
						break;
					case TextAlignmentOptions.MidlineLeft:
						alignRTL = TextAlignmentOptions.MidlineRight;
						break;
					case TextAlignmentOptions.CaplineLeft:
						alignRTL = TextAlignmentOptions.CaplineRight;
						break;
					}
				}
			}

			internal static void SetFont(TMP_Text label, TMP_FontAsset newFont)
			{
				if (label.font != newFont)
				{
					label.font = newFont;
				}
				if (label.linkedTextComponent != null)
				{
					SetFont(label.linkedTextComponent, newFont);
				}
			}

			internal static void SetMaterial(TMP_Text label, Material newMat)
			{
				if (label.fontSharedMaterial != newMat)
				{
					label.fontSharedMaterial = newMat;
				}
				if (label.linkedTextComponent != null)
				{
					SetMaterial(label.linkedTextComponent, newMat);
				}
			}
		}
		public class LocalizeTarget_TextMeshPro_UGUI : LocalizeTarget<TextMeshProUGUI>
		{
			public TextAlignmentOptions mAlignment_RTL = TextAlignmentOptions.Right;

			public TextAlignmentOptions mAlignment_LTR = TextAlignmentOptions.Left;

			public bool mAlignmentWasRTL;

			public bool mInitializeAlignment = true;

			static LocalizeTarget_TextMeshPro_UGUI()
			{
				AutoRegister();
			}

			[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
			private static void AutoRegister()
			{
				LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Type<TextMeshProUGUI, LocalizeTarget_TextMeshPro_UGUI>
				{
					Name = "TextMeshPro UGUI",
					Priority = 100
				});
			}

			public override eTermType GetPrimaryTermType(Localize cmp)
			{
				return eTermType.Text;
			}

			public override eTermType GetSecondaryTermType(Localize cmp)
			{
				return eTermType.TextMeshPFont;
			}

			public override bool CanUseSecondaryTerm()
			{
				return true;
			}

			public override bool AllowMainTermToBeRTL()
			{
				return true;
			}

			public override bool AllowSecondTermToBeRTL()
			{
				return false;
			}

			public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
			{
				primaryTerm = (mTarget ? mTarget.text : null);
				secondaryTerm = ((mTarget.font != null) ? mTarget.font.name : string.Empty);
			}

			public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
			{
				TMP_FontAsset secondaryTranslatedObj = cmp.GetSecondaryTranslatedObj<TMP_FontAsset>(ref mainTranslation, ref secondaryTranslation);
				if (secondaryTranslatedObj != null)
				{
					LocalizeTarget_TextMeshPro_Label.SetFont(mTarget, secondaryTranslatedObj);
				}
				else
				{
					Material secondaryTranslatedObj2 = cmp.GetSecondaryTranslatedObj<Material>(ref mainTranslation, ref secondaryTranslation);
					if (secondaryTranslatedObj2 != null && mTarget.fontMaterial != secondaryTranslatedObj2)
					{
						if (!secondaryTranslatedObj2.name.StartsWith(mTarget.font.name, StringComparison.Ordinal))
						{
							secondaryTranslatedObj = LocalizeTarget_TextMeshPro_Label.GetTMPFontFromMaterial(cmp, secondaryTranslation.EndsWith(secondaryTranslatedObj2.name, StringComparison.Ordinal) ? secondaryTranslation : secondaryTranslatedObj2.name);
							if (secondaryTranslatedObj != null)
							{
								LocalizeTarget_TextMeshPro_Label.SetFont(mTarget, secondaryTranslatedObj);
							}
						}
						LocalizeTarget_TextMeshPro_Label.SetMaterial(mTarget, secondaryTranslatedObj2);
					}
				}
				if (mInitializeAlignment)
				{
					mInitializeAlignment = false;
					mAlignmentWasRTL = LocalizationManager.IsRight2Left;
					LocalizeTarget_TextMeshPro_Label.InitAlignment_TMPro(mAlignmentWasRTL, mTarget.alignment, out mAlignment_LTR, out mAlignment_RTL);
				}
				else
				{
					LocalizeTarget_TextMeshPro_Label.InitAlignment_TMPro(mAlignmentWasRTL, mTarget.alignment, out var alignLTR, out var alignRTL);
					if ((mAlignmentWasRTL && mAlignment_RTL != alignRTL) || (!mAlignmentWasRTL && mAlignment_LTR != alignLTR))
					{
						mAlignment_LTR = alignLTR;
						mAlignment_RTL = alignRTL;
					}
					mAlignmentWasRTL = LocalizationManager.IsRight2Left;
				}
				if (mainTranslation == null || !(mTarget.text != mainTranslation))
				{
					return;
				}
				if (mainTranslation != null && cmp.CorrectAlignmentForRTL)
				{
					mTarget.alignment = (LocalizationManager.IsRight2Left ? mAlignment_RTL : mAlignment_LTR);
					mTarget.isRightToLeftText = LocalizationManager.IsRight2Left;
					if (LocalizationManager.IsRight2Left)
					{
						mainTranslation = I2Utils.ReverseText(mainTranslation);
					}
				}
				mTarget.text = mainTranslation;
			}
		}
		public class LocalizeTarget_UnityStandard_AudioSource : LocalizeTarget<AudioSource>
		{
			static LocalizeTarget_UnityStandard_AudioSource()
			{
				AutoRegister();
			}

			[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
			private static void AutoRegister()
			{
				LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Type<AudioSource, LocalizeTarget_UnityStandard_AudioSource>
				{
					Name = "AudioSource",
					Priority = 100
				});
			}

			public override eTermType GetPrimaryTermType(Localize cmp)
			{
				return eTermType.AudioClip;
			}

			public override eTermType GetSecondaryTermType(Localize cmp)
			{
				return eTermType.Text;
			}

			public override bool CanUseSecondaryTerm()
			{
				return false;
			}

			public override bool AllowMainTermToBeRTL()
			{
				return false;
			}

			public override bool AllowSecondTermToBeRTL()
			{
				return false;
			}

			public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
			{
				primaryTerm = (mTarget.clip ? mTarget.clip.name : string.Empty);
				secondaryTerm = null;
			}

			public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
			{
				bool num = (mTarget.isPlaying || mTarget.loop) && Application.isPlaying;
				AudioClip clip = mTarget.clip;
				AudioClip audioClip = cmp.FindTranslatedObject<AudioClip>(mainTranslation);
				if (clip != audioClip)
				{
					mTarget.clip = audioClip;
				}
				if (num && (bool)mTarget.clip)
				{
					mTarget.Play();
				}
			}
		}
		public class LocalizeTargetDesc_Child : LocalizeTargetDesc<LocalizeTarget_UnityStandard_Child>
		{
			public override bool CanLocalize(Localize cmp)
			{
				return cmp.transform.childCount > 1;
			}
		}
		public class LocalizeTarget_UnityStandard_Child : LocalizeTarget<GameObject>
		{
			static LocalizeTarget_UnityStandard_Child()
			{
				AutoRegister();
			}

			[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
			private static void AutoRegister()
			{
				LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Child
				{
					Name = "Child",
					Priority = 200
				});
			}

			public override bool IsValid(Localize cmp)
			{
				return cmp.transform.childCount > 1;
			}

			public override eTermType GetPrimaryTermType(Localize cmp)
			{
				return eTermType.GameObject;
			}

			public override eTermType GetSecondaryTermType(Localize cmp)
			{
				return eTermType.Text;
			}

			public override bool CanUseSecondaryTerm()
			{
				return false;
			}

			public override bool AllowMainTermToBeRTL()
			{
				return false;
			}

			public override bool AllowSecondTermToBeRTL()
			{
				return false;
			}

			public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
			{
				primaryTerm = cmp.name;
				secondaryTerm = null;
			}

			public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
			{
				if (!string.IsNullOrEmpty(mainTranslation))
				{
					Transform transform = cmp.transform;
					string text = mainTranslation;
					int num = mainTranslation.LastIndexOfAny(LanguageSourceData.CategorySeparators);
					if (num >= 0)
					{
						text = text.Substring(num + 1);
					}
					for (int i = 0; i < transform.childCount; i++)
					{
						Transform child = transform.GetChild(i);
						child.gameObject.SetActive(child.name == text);
					}
				}
			}
		}
		public class LocalizeTarget_UnityStandard_MeshRenderer : LocalizeTarget<MeshRenderer>
		{
			static LocalizeTarget_UnityStandard_MeshRenderer()
			{
				AutoRegister();
			}

			[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
			private static void AutoRegister()
			{
				LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Type<MeshRenderer, LocalizeTarget_UnityStandard_MeshRenderer>
				{
					Name = "MeshRenderer",
					Priority = 800
				});
			}

			public override eTermType GetPrimaryTermType(Localize cmp)
			{
				return eTermType.Mesh;
			}

			public override eTermType GetSecondaryTermType(Localize cmp)
			{
				return eTermType.Material;
			}

			public override bool CanUseSecondaryTerm()
			{
				return true;
			}

			public override bool AllowMainTermToBeRTL()
			{
				return false;
			}

			public override bool AllowSecondTermToBeRTL()
			{
				return false;
			}

			public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
			{
				if (mTarget == null)
				{
					primaryTerm = (secondaryTerm = null);
				}
				else
				{
					MeshFilter component = mTarget.GetComponent<MeshFilter>();
					if (component == null || component.sharedMesh == null)
					{
						primaryTerm = null;
					}
					else
					{
						primaryTerm = component.sharedMesh.name;
					}
				}
				if (mTarget == null || mTarget.sharedMaterial == null)
				{
					secondaryTerm = null;
				}
				else
				{
					secondaryTerm = mTarget.sharedMaterial.name;
				}
			}

			public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
			{
				Material secondaryTranslatedObj = cmp.GetSecondaryTranslatedObj<Material>(ref mainTranslation, ref secondaryTranslation);
				if (secondaryTranslatedObj != null && mTarget.sharedMaterial != secondaryTranslatedObj)
				{
					mTarget.material = secondaryTranslatedObj;
				}
				Mesh mesh = cmp.FindTranslatedObject<Mesh>(mainTranslation);
				MeshFilter component = mTarget.GetComponent<MeshFilter>();
				if (mesh != null && component.sharedMesh != mesh)
				{
					component.mesh = mesh;
				}
			}
		}
		public class LocalizeTargetDesc_Prefab : LocalizeTargetDesc<LocalizeTarget_UnityStandard_Prefab>
		{
			public override bool CanLocalize(Localize cmp)
			{
				return true;
			}
		}
		public class LocalizeTarget_UnityStandard_Prefab : LocalizeTarget<GameObject>
		{
			static LocalizeTarget_UnityStandard_Prefab()
			{
				AutoRegister();
			}

			[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
			private static void AutoRegister()
			{
				LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Prefab
				{
					Name = "Prefab",
					Priority = 250
				});
			}

			public override bool IsValid(Localize cmp)
			{
				return true;
			}

			public override eTermType GetPrimaryTermType(Localize cmp)
			{
				return eTermType.GameObject;
			}

			public override eTermType GetSecondaryTermType(Localize cmp)
			{
				return eTermType.Text;
			}

			public override bool CanUseSecondaryTerm()
			{
				return false;
			}

			public override bool AllowMainTermToBeRTL()
			{
				return false;
			}

			public override bool AllowSecondTermToBeRTL()
			{
				return false;
			}

			public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
			{
				primaryTerm = cmp.name;
				secondaryTerm = null;
			}

			public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
			{
				if (string.IsNullOrEmpty(mainTranslation) || ((bool)mTarget && mTarget.name == mainTranslation))
				{
					return;
				}
				Transform transform = cmp.transform;
				string text = mainTranslation;
				int num = mainTranslation.LastIndexOfAny(LanguageSourceData.CategorySeparators);
				if (num >= 0)
				{
					text = text.Substring(num + 1);
				}
				Transform transform2 = InstantiateNewPrefab(cmp, mainTranslation);
				if (transform2 == null)
				{
					return;
				}
				transform2.name = text;
				for (int num2 = transform.childCount - 1; num2 >= 0; num2--)
				{
					Transform child = transform.GetChild(num2);
					if (child != transform2)
					{
						UnityEngine.Object.Destroy(child.gameObject);
					}
				}
			}

			private Transform InstantiateNewPrefab(Localize cmp, string mainTranslation)
			{
				GameObject gameObject = cmp.FindTranslatedObject<GameObject>(mainTranslation);
				if (gameObject == null)
				{
					return null;
				}
				GameObject gameObject2 = mTarget;
				mTarget = UnityEngine.Object.Instantiate(gameObject);
				if (mTarget == null)
				{
					return null;
				}
				Transform transform = cmp.transform;
				Transform transform2 = mTarget.transform;
				transform2.SetParent(transform);
				Transform transform3 = (gameObject2 ? gameObject2.transform : transform);
				transform2.rotation = transform3.rotation;
				transform2.position = transform3.position;
				return transform2;
			}
		}
		public class LocalizeTarget_UnityStandard_SpriteRenderer : LocalizeTarget<SpriteRenderer>
		{
			static LocalizeTarget_UnityStandard_SpriteRenderer()
			{
				AutoRegister();
			}

			[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
			private static void AutoRegister()
			{
				LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Type<SpriteRenderer, LocalizeTarget_UnityStandard_SpriteRenderer>
				{
					Name = "SpriteRenderer",
					Priority = 100
				});
			}

			public override eTermType GetPrimaryTermType(Localize cmp)
			{
				return eTermType.Sprite;
			}

			public override eTermType GetSecondaryTermType(Localize cmp)
			{
				return eTermType.Text;
			}

			public override bool CanUseSecondaryTerm()
			{
				return false;
			}

			public override bool AllowMainTermToBeRTL()
			{
				return false;
			}

			public override bool AllowSecondTermToBeRTL()
			{
				return false;
			}

			public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
			{
				primaryTerm = ((mTarget.sprite != null) ? mTarget.sprite.name : string.Empty);
				secondaryTerm = null;
			}

			public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
			{
				Sprite sprite = mTarget.sprite;
				if (sprite == null || sprite.name != mainTranslation)
				{
					mTarget.sprite = cmp.FindTranslatedObject<Sprite>(mainTranslation);
				}
			}
		}
		public class LocalizeTarget_UnityStandard_TextMesh : LocalizeTarget<TextMesh>
		{
			private TextAlignment mAlignment_RTL = TextAlignment.Right;

			private TextAlignment mAlignment_LTR;

			private bool mAlignmentWasRTL;

			private bool mInitializeAlignment = true;

			static LocalizeTarget_UnityStandard_TextMesh()
			{
				AutoRegister();
			}

			[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
			private static void AutoRegister()
			{
				LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Type<TextMesh, LocalizeTarget_UnityStandard_TextMesh>
				{
					Name = "TextMesh",
					Priority = 100
				});
			}

			public override eTermType GetPrimaryTermType(Localize cmp)
			{
				return eTermType.Text;
			}

			public override eTermType GetSecondaryTermType(Localize cmp)
			{
				return eTermType.Font;
			}

			public override bool CanUseSecondaryTerm()
			{
				return true;
			}

			public override bool AllowMainTermToBeRTL()
			{
				return true;
			}

			public override bool AllowSecondTermToBeRTL()
			{
				return false;
			}

			public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
			{
				primaryTerm = (mTarget ? mTarget.text : null);
				secondaryTerm = ((string.IsNullOrEmpty(Secondary) && mTarget.font != null) ? mTarget.font.name : null);
			}

			public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
			{
				Font secondaryTranslatedObj = cmp.GetSecondaryTranslatedObj<Font>(ref mainTranslation, ref secondaryTranslation);
				if (secondaryTranslatedObj != null && mTarget.font != secondaryTranslatedObj)
				{
					mTarget.font = secondaryTranslatedObj;
					mTarget.GetComponentInChildren<MeshRenderer>().material = secondaryTranslatedObj.material;
				}
				if (mInitializeAlignment)
				{
					mInitializeAlignment = false;
					mAlignment_LTR = (mAlignment_RTL = mTarget.alignment);
					if (LocalizationManager.IsRight2Left && mAlignment_RTL == TextAlignment.Right)
					{
						mAlignment_LTR = TextAlignment.Left;
					}
					if (!LocalizationManager.IsRight2Left && mAlignment_LTR == TextAlignment.Left)
					{
						mAlignment_RTL = TextAlignment.Right;
					}
				}
				if (mainTranslation != null && mTarget.text != mainTranslation)
				{
					if (cmp.CorrectAlignmentForRTL && mTarget.alignment != TextAlignment.Center)
					{
						mTarget.alignment = (LocalizationManager.IsRight2Left ? mAlignment_RTL : mAlignment_LTR);
					}
					mTarget.font.RequestCharactersInTexture(mainTranslation);
					mTarget.text = mainTranslation;
				}
			}
		}
		public class LocalizeTarget_UnityStandard_VideoPlayer : LocalizeTarget<VideoPlayer>
		{
			static LocalizeTarget_UnityStandard_VideoPlayer()
			{
				AutoRegister();
			}

			[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
			private static void AutoRegister()
			{
				LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Type<VideoPlayer, LocalizeTarget_UnityStandard_VideoPlayer>
				{
					Name = "VideoPlayer",
					Priority = 100
				});
			}

			public override eTermType GetPrimaryTermType(Localize cmp)
			{
				return eTermType.Video;
			}

			public override eTermType GetSecondaryTermType(Localize cmp)
			{
				return eTermType.Text;
			}

			public override bool CanUseSecondaryTerm()
			{
				return false;
			}

			public override bool AllowMainTermToBeRTL()
			{
				return false;
			}

			public override bool AllowSecondTermToBeRTL()
			{
				return false;
			}

			public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
			{
				primaryTerm = ((mTarget.clip != null) ? mTarget.clip.name : string.Empty);
				secondaryTerm = null;
			}

			public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
			{
				VideoClip clip = mTarget.clip;
				if (clip == null || clip.name != mainTranslation)
				{
					mTarget.clip = cmp.FindTranslatedObject<VideoClip>(mainTranslation);
				}
			}
		}
		public class LocalizeTarget_UnityUI_Image : LocalizeTarget<Image>
		{
			static LocalizeTarget_UnityUI_Image()
			{
				AutoRegister();
			}

			[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
			private static void AutoRegister()
			{
				LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Type<Image, LocalizeTarget_UnityUI_Image>
				{
					Name = "Image",
					Priority = 100
				});
			}

			public override bool CanUseSecondaryTerm()
			{
				return false;
			}

			public override bool AllowMainTermToBeRTL()
			{
				return false;
			}

			public override bool AllowSecondTermToBeRTL()
			{
				return false;
			}

			public override eTermType GetPrimaryTermType(Localize cmp)
			{
				if (!(mTarget.sprite == null))
				{
					return eTermType.Sprite;
				}
				return eTermType.Texture;
			}

			public override eTermType GetSecondaryTermType(Localize cmp)
			{
				return eTermType.Text;
			}

			public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
			{
				primaryTerm = (mTarget.mainTexture ? mTarget.mainTexture.name : "");
				if (mTarget.sprite != null && mTarget.sprite.name != primaryTerm)
				{
					primaryTerm = primaryTerm + "." + mTarget.sprite.name;
				}
				secondaryTerm = null;
			}

			public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
			{
				Sprite sprite = mTarget.sprite;
				if (sprite == null || sprite.name != mainTranslation)
				{
					mTarget.sprite = cmp.FindTranslatedObject<Sprite>(mainTranslation);
				}
			}
		}
		public class LocalizeTarget_UnityUI_RawImage : LocalizeTarget<RawImage>
		{
			static LocalizeTarget_UnityUI_RawImage()
			{
				AutoRegister();
			}

			[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
			private static void AutoRegister()
			{
				LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Type<RawImage, LocalizeTarget_UnityUI_RawImage>
				{
					Name = "RawImage",
					Priority = 100
				});
			}

			public override eTermType GetPrimaryTermType(Localize cmp)
			{
				return eTermType.Texture;
			}

			public override eTermType GetSecondaryTermType(Localize cmp)
			{
				return eTermType.Text;
			}

			public override bool CanUseSecondaryTerm()
			{
				return false;
			}

			public override bool AllowMainTermToBeRTL()
			{
				return false;
			}

			public override bool AllowSecondTermToBeRTL()
			{
				return false;
			}

			public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
			{
				primaryTerm = (mTarget.mainTexture ? mTarget.mainTexture.name : "");
				secondaryTerm = null;
			}

			public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
			{
				Texture texture = mTarget.texture;
				if (texture == null || texture.name != mainTranslation)
				{
					mTarget.texture = cmp.FindTranslatedObject<Texture>(mainTranslation);
				}
			}
		}
		public class LocalizeTarget_UnityUI_Text : LocalizeTarget<Text>
		{
			private TextAnchor mAlignment_RTL = TextAnchor.UpperRight;

			private TextAnchor mAlignment_LTR;

			private bool mAlignmentWasRTL;

			private bool mInitializeAlignment = true;

			static LocalizeTarget_UnityUI_Text()
			{
				AutoRegister();
			}

			[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
			private static void AutoRegister()
			{
				LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Type<Text, LocalizeTarget_UnityUI_Text>
				{
					Name = "Text",
					Priority = 100
				});
			}

			public override eTermType GetPrimaryTermType(Localize cmp)
			{
				return eTermType.Text;
			}

			public override eTermType GetSecondaryTermType(Localize cmp)
			{
				return eTermType.Font;
			}

			public override bool CanUseSecondaryTerm()
			{
				return true;
			}

			public override bool AllowMainTermToBeRTL()
			{
				return true;
			}

			public override bool AllowSecondTermToBeRTL()
			{
				return false;
			}

			public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
			{
				primaryTerm = (mTarget ? mTarget.text : null);
				secondaryTerm = ((mTarget.font != null) ? mTarget.font.name : string.Empty);
			}

			public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
			{
				Font secondaryTranslatedObj = cmp.GetSecondaryTranslatedObj<Font>(ref mainTranslation, ref secondaryTranslation);
				if (secondaryTranslatedObj != null && secondaryTranslatedObj != mTarget.font)
				{
					mTarget.font = secondaryTranslatedObj;
				}
				if (mInitializeAlignment)
				{
					mInitializeAlignment = false;
					mAlignmentWasRTL = LocalizationManager.IsRight2Left;
					InitAlignment(mAlignmentWasRTL, mTarget.alignment, out mAlignment_LTR, out mAlignment_RTL);
				}
				else
				{
					InitAlignment(mAlignmentWasRTL, mTarget.alignment, out var alignLTR, out var alignRTL);
					if ((mAlignmentWasRTL && mAlignment_RTL != alignRTL) || (!mAlignmentWasRTL && mAlignment_LTR != alignLTR))
					{
						mAlignment_LTR = alignLTR;
						mAlignment_RTL = alignRTL;
					}
					mAlignmentWasRTL = LocalizationManager.IsRight2Left;
				}
				if (mainTranslation != null && mTarget.text != mainTranslation)
				{
					if (cmp.CorrectAlignmentForRTL)
					{
						mTarget.alignment = (LocalizationManager.IsRight2Left ? mAlignment_RTL : mAlignment_LTR);
					}
					mTarget.text = mainTranslation;
					mTarget.SetVerticesDirty();
				}
			}

			private void InitAlignment(bool isRTL, TextAnchor alignment, out TextAnchor alignLTR, out TextAnchor alignRTL)
			{
				alignLTR = (alignRTL = alignment);
				if (isRTL)
				{
					switch (alignment)
					{
					case TextAnchor.UpperRight:
						alignLTR = TextAnchor.UpperLeft;
						break;
					case TextAnchor.MiddleRight:
						alignLTR = TextAnchor.MiddleLeft;
						break;
					case TextAnchor.LowerRight:
						alignLTR = TextAnchor.LowerLeft;
						break;
					case TextAnchor.UpperLeft:
						alignLTR = TextAnchor.UpperRight;
						break;
					case TextAnchor.MiddleLeft:
						alignLTR = TextAnchor.MiddleRight;
						break;
					case TextAnchor.LowerLeft:
						alignLTR = TextAnchor.LowerRight;
						break;
					case TextAnchor.UpperCenter:
					case TextAnchor.MiddleCenter:
					case TextAnchor.LowerCenter:
						break;
					}
				}
				else
				{
					switch (alignment)
					{
					case TextAnchor.UpperRight:
						alignRTL = TextAnchor.UpperLeft;
						break;
					case TextAnchor.MiddleRight:
						alignRTL = TextAnchor.MiddleLeft;
						break;
					case TextAnchor.LowerRight:
						alignRTL = TextAnchor.LowerLeft;
						break;
					case TextAnchor.UpperLeft:
						alignRTL = TextAnchor.UpperRight;
						break;
					case TextAnchor.MiddleLeft:
						alignRTL = TextAnchor.MiddleRight;
						break;
					case TextAnchor.LowerLeft:
						alignRTL = TextAnchor.LowerRight;
						break;
					case TextAnchor.UpperCenter:
					case TextAnchor.MiddleCenter:
					case TextAnchor.LowerCenter:
						break;
					}
				}
			}
		}
		public enum eTermType
		{
			Text,
			Font,
			Texture,
			AudioClip,
			GameObject,
			Sprite,
			Material,
			Child,
			Mesh,
			TextMeshPFont,
			Object,
			Video
		}
		public enum TranslationFlag : byte
		{
			Normal = 1,
			AutoTranslated
		}
		[Serializable]
		public class TermData
		{
			public string Term = string.Empty;

			public eTermType TermType;

			[NonSerialized]
			public string Description;

			public string[] Languages = new string[0];

			public byte[] Flags = new byte[0];

			[SerializeField]
			private string[] Languages_Touch;

			public string GetTranslation(int idx, string specialization = null, bool editMode = false)
			{
				string text = Languages[idx];
				if (text != null)
				{
					text = SpecializationManager.GetSpecializedText(text, specialization);
					if (!editMode)
					{
						text = text.Replace("[i2nt]", "").Replace("[/i2nt]", "");
					}
				}
				return text;
			}

			public void SetTranslation(int idx, string translation, string specialization = null)
			{
				Languages[idx] = SpecializationManager.SetSpecializedText(Languages[idx], translation, specialization);
			}

			public void RemoveSpecialization(string specialization)
			{
				for (int i = 0; i < Languages.Length; i++)
				{
					RemoveSpecialization(i, specialization);
				}
			}

			public void RemoveSpecialization(int idx, string specialization)
			{
				string text = Languages[idx];
				if (!(specialization == "Any") && text.Contains("[i2s_" + specialization + "]"))
				{
					Dictionary<string, string> specializations = SpecializationManager.GetSpecializations(text);
					specializations.Remove(specialization);
					Languages[idx] = SpecializationManager.SetSpecializedText(specializations);
				}
			}

			public bool IsAutoTranslated(int idx, bool IsTouch)
			{
				return (Flags[idx] & 2) > 0;
			}

			public void Validate()
			{
				int num = Mathf.Max(Languages.Length, Flags.Length);
				if (Languages.Length != num)
				{
					Array.Resize(ref Languages, num);
				}
				if (Flags.Length != num)
				{
					Array.Resize(ref Flags, num);
				}
				if (Languages_Touch == null)
				{
					return;
				}
				for (int i = 0; i < Mathf.Min(Languages_Touch.Length, num); i++)
				{
					if (string.IsNullOrEmpty(Languages[i]) && !string.IsNullOrEmpty(Languages_Touch[i]))
					{
						Languages[i] = Languages_Touch[i];
						Languages_Touch[i] = null;
					}
				}
				Languages_Touch = null;
			}

			public bool IsTerm(string name, bool allowCategoryMistmatch)
			{
				if (!allowCategoryMistmatch)
				{
					return name == Term;
				}
				return name == LanguageSourceData.GetKeyFromFullTerm(Term);
			}

			public bool HasSpecializations()
			{
				for (int i = 0; i < Languages.Length; i++)
				{
					if (!string.IsNullOrEmpty(Languages[i]) && Languages[i].Contains("[i2s_"))
					{
						return true;
					}
				}
				return false;
			}

			public List<string> GetAllSpecializations()
			{
				List<string> list = new List<string>();
				for (int i = 0; i < Languages.Length; i++)
				{
					SpecializationManager.AppendSpecializations(Languages[i], list);
				}
				return list;
			}
		}
		public class TermsPopup : PropertyAttribute
		{
			public string Filter { get; private set; }

			public TermsPopup(string filter = "")
			{
				Filter = filter;
			}
		}
		public class AutoChangeCultureInfo : MonoBehaviour
		{
			public void Start()
			{
				LocalizationManager.EnableChangingCultureInfo(bEnable: true);
			}
		}
		public class CoroutineManager : MonoBehaviour
		{
			private static CoroutineManager mInstance;

			private static CoroutineManager pInstance
			{
				get
				{
					if (mInstance == null)
					{
						GameObject gameObject = new GameObject("_Coroutiner");
						gameObject.hideFlags = HideFlags.HideAndDontSave;
						mInstance = gameObject.AddComponent<CoroutineManager>();
						if (Application.isPlaying)
						{
							UnityEngine.Object.DontDestroyOnLoad(gameObject);
						}
					}
					return mInstance;
				}
			}

			private void Awake()
			{
				if (Application.isPlaying)
				{
					UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
				}
			}

			public static Coroutine Start(IEnumerator coroutine)
			{
				return pInstance.StartCoroutine(coroutine);
			}
		}
		[AddComponentMenu("I2/Localization/I2 Localize Callback")]
		public class CustomLocalizeCallback : MonoBehaviour
		{
			public UnityEvent _OnLocalize = new UnityEvent();

			public void OnEnable()
			{
				LocalizationManager.OnLocalizeEvent -= OnLocalize;
				LocalizationManager.OnLocalizeEvent += OnLocalize;
			}

			public void OnDisable()
			{
				LocalizationManager.OnLocalizeEvent -= OnLocalize;
			}

			public void OnLocalize()
			{
				_OnLocalize.Invoke();
			}
		}
		public class HindiFixer
		{
			internal static string Fix(string text)
			{
				char[] array = text.ToCharArray();
				bool flag = false;
				for (int i = 0; i < array.Length; i++)
				{
					if (array[i] == '\u093f' && !char.IsWhiteSpace(array[i - 1]) && array[i - 1] != 0)
					{
						array[i] = array[i - 1];
						array[i - 1] = '\u093f';
						flag = true;
					}
					if (i != array.Length - 1)
					{
						if (array[i] == 'इ' && array[i + 1] == '\u093c')
						{
							array[i] = 'ऌ';
							array[i + 1] = '\0';
							flag = true;
						}
						if (array[i] == '\u0943' && array[i + 1] == '\u093c')
						{
							array[i] = '\u0944';
							array[i + 1] = '\0';
							flag = true;
						}
						if (array[i] == '\u0901' && array[i + 1] == '\u093c')
						{
							array[i] = 'ॐ';
							array[i + 1] = '\0';
							flag = true;
						}
						if (array[i] == 'ऋ' && array[i + 1] == '\u093c')
						{
							array[i] = 'ॠ';
							array[i + 1] = '\0';
							flag = true;
						}
						if (array[i] == 'ई' && array[i + 1] == '\u093c')
						{
							array[i] = 'ॡ';
							array[i + 1] = '\0';
							flag = true;
						}
						if (array[i] == '\u093f' && array[i + 1] == '\u093c')
						{
							array[i] = '\u0962';
							array[i + 1] = '\0';
							flag = true;
						}
						if (array[i] == '\u0940' && array[i + 1] == '\u093c')
						{
							array[i] = '\u0963';
							array[i + 1] = '\0';
							flag = true;
						}
						if (array[i] == '।' && array[i + 1] == '\u093c')
						{
							array[i] = 'ऽ';
							array[i + 1] = '\0';
							flag = true;
						}
					}
				}
				if (!flag)
				{
					return text;
				}
				string text2 = new string(array.Where((char x) => x != '\0').ToArray());
				if (text2 == text)
				{
					return text2;
				}
				text = text2;
				return text;
			}
		}
		public static class I2Utils
		{
			public const string ValidChars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_";

			public const string NumberChars = "0123456789";

			public const string ValidNameSymbols = ".-_$#@*()[]{}+:?!&',^=<>~`";

			public static string ReverseText(string source)
			{
				int length = source.Length;
				char[] array = new char[length];
				for (int i = 0; i < length; i++)
				{
					array[length - 1 - i] = source[i];
				}
				return new string(array);
			}

			public static string RemoveNonASCII(string text, bool allowCategory = false)
			{
				if (string.IsNullOrEmpty(text))
				{
					return text;
				}
				int num = 0;
				char[] array = new char[text.Length];
				bool flag = false;
				char[] array2 = text.Trim().ToCharArray();
				foreach (char c in array2)
				{
					char c2 = ' ';
					if ((allowCategory && (c == '\\' || c == '"' || c == '/')) || char.IsLetterOrDigit(c) || ".-_$#@*()[]{}+:?!&',^=<>~`".IndexOf(c) >= 0)
					{
						c2 = c;
					}
					if (char.IsWhiteSpace(c2))
					{
						if (!flag)
						{
							if (num > 0)
							{
								array[num++] = ' ';
							}
							flag = true;
						}
					}
					else
					{
						flag = false;
						array[num++] = c2;
					}
				}
				return new string(array, 0, num);
			}

			public static string GetValidTermName(string text, bool allowCategory = false)
			{
				if (text == null)
				{
					return null;
				}
				text = RemoveTags(text);
				return RemoveNonASCII(text, allowCategory);
			}

			public static string SplitLine(string line, int maxCharacters)
			{
				if (maxCharacters <= 0 || line.Length < maxCharacters)
				{
					return line;
				}
				char[] array = line.ToCharArray();
				bool flag = true;
				bool flag2 = false;
				int i = 0;
				int num = 0;
				for (; i < array.Length; i++)
				{
					if (flag)
					{
						num++;
						if (array[i] == '\n')
						{
							num = 0;
						}
						if (num >= maxCharacters && char.IsWhiteSpace(array[i]))
						{
							array[i] = '\n';
							flag = false;
							flag2 = false;
						}
					}
					else if (!char.IsWhiteSpace(array[i]))
					{
						flag = true;
						num = 0;
					}
					else if (array[i] != '\n')
					{
						array[i] = '\0';
					}
					else
					{
						if (!flag2)
						{
							array[i] = '\0';
						}
						flag2 = true;
					}
				}
				return new string(array.Where((char c) => c != '\0').ToArray());
			}

			public static bool FindNextTag(string line, int iStart, out int tagStart, out int tagEnd)
			{
				tagStart = -1;
				tagEnd = -1;
				int length = line.Length;
				tagStart = iStart;
				while (tagStart < length && line[tagStart] != '[' && line[tagStart] != '(' && line[tagStart] != '{' && line[tagStart] != '<')
				{
					tagStart++;
				}
				if (tagStart == length)
				{
					return false;
				}
				bool flag = false;
				for (tagEnd = tagStart + 1; tagEnd < length; tagEnd++)
				{
					char c = line[tagEnd];
					if (c == ']' || c == ')' || c == '}' || c == '>')
					{
						if (flag)
						{
							return FindNextTag(line, tagEnd + 1, out tagStart, out tagEnd);
						}
						return true;
					}
					if (c > 'ÿ')
					{
						flag = true;
					}
				}
				return false;
			}

			public static string RemoveTags(string text)
			{
				return Regex.Replace(text, "\\{\\[(.*?)]}|\\[(.*?)]|\\<(.*?)>", "");
			}

			public static bool RemoveResourcesPath(ref string sPath)
			{
				int num = sPath.IndexOf("\\Resources\\");
				int num2 = sPath.IndexOf("\\Resources/");
				int num3 = sPath.IndexOf("/Resources\\");
				int num4 = sPath.IndexOf("/Resources/");
				int num5 = Mathf.Max(num, num2, num3, num4);
				bool result = false;
				if (num5 >= 0)
				{
					sPath = sPath.Substring(num5 + 11);
					result = true;
				}
				else
				{
					num5 = sPath.LastIndexOfAny(LanguageSourceData.CategorySeparators);
					if (num5 > 0)
					{
						sPath = sPath.Substring(num5 + 1);
					}
				}
				string extension = Path.GetExtension(sPath);
				if (!string.IsNullOrEmpty(extension))
				{
					sPath = sPath.Substring(0, sPath.Length - extension.Length);
				}
				return result;
			}

			public static bool IsPlaying()
			{
				if (Application.isPlaying)
				{
					return true;
				}
				return false;
			}

			public static string GetPath(this Transform tr)
			{
				Transform parent = tr.parent;
				if (tr == null)
				{
					return tr.name;
				}
				return parent.GetPath() + "/" + tr.name;
			}

			public static Transform FindObject(string objectPath)
			{
				return FindObject(SceneManager.GetActiveScene(), objectPath);
			}

			public static Transform FindObject(Scene scene, string objectPath)
			{
				GameObject[] rootGameObjects = scene.GetRootGameObjects();
				for (int i = 0; i < rootGameObjects.Length; i++)
				{
					Transform transform = rootGameObjects[i].transform;
					if (transform.name == objectPath)
					{
						return transform;
					}
					if (objectPath.StartsWith(transform.name + "/"))
					{
						return FindObject(transform, objectPath.Substring(transform.name.Length + 1));
					}
				}
				return null;
			}

			public static Transform FindObject(Transform root, string objectPath)
			{
				for (int i = 0; i < root.childCount; i++)
				{
					Transform child = root.GetChild(i);
					if (child.name == objectPath)
					{
						return child;
					}
					if (objectPath.StartsWith(child.name + "/"))
					{
						return FindObject(child, objectPath.Substring(child.name.Length + 1));
					}
				}
				return null;
			}

			public static H FindInParents<H>(Transform tr) where H : UnityEngine.Component
			{
				if (!tr)
				{
					return null;
				}
				H component = tr.GetComponent<H>();
				while (!component && (bool)tr)
				{
					component = tr.GetComponent<H>();
					tr = tr.parent;
				}
				return component;
			}

			public static string GetCaptureMatch(Match match)
			{
				for (int num = match.Groups.Count - 1; num >= 0; num--)
				{
					if (match.Groups[num].Success)
					{
						return match.Groups[num].ToString();
					}
				}
				return match.ToString();
			}

			public static void SendWebRequest(UnityWebRequest www)
			{
				www.SendWebRequest();
			}
		}
		public interface ILocalizationParamsManager
		{
			string GetParameterValue(string Param);
		}
		public class LocalizationParamsManager : MonoBehaviour, ILocalizationParamsManager
		{
			[Serializable]
			public struct ParamValue
			{
				public string Name;

				public string Value;
			}

			[SerializeField]
			public List<ParamValue> _Params = new List<ParamValue>();

			public bool _IsGlobalManager;

			public string GetParameterValue(string ParamName)
			{
				if (_Params != null)
				{
					int i = 0;
					for (int count = _Params.Count; i < count; i++)
					{
						if (_Params[i].Name == ParamName)
						{
							return _Params[i].Value;
						}
					}
				}
				return null;
			}

			public void SetParameterValue(string ParamName, string ParamValue, bool localize = true)
			{
				bool flag = false;
				int i = 0;
				for (int count = _Params.Count; i < count; i++)
				{
					if (_Params[i].Name == ParamName)
					{
						ParamValue value = _Params[i];
						value.Value = ParamValue;
						_Params[i] = value;
						flag = true;
						break;
					}
				}
				if (!flag)
				{
					_Params.Add(new ParamValue
					{
						Name = ParamName,
						Value = ParamValue
					});
				}
				if (localize)
				{
					OnLocalize();
				}
			}

			public void OnLocalize()
			{
				Localize component = GetComponent<Localize>();
				if (component != null)
				{
					component.OnLocalize(Force: true);
				}
			}

			public virtual void OnEnable()
			{
				if (_IsGlobalManager)
				{
					DoAutoRegister();
				}
			}

			public void DoAutoRegister()
			{
				if (!LocalizationManager.ParamManagers.Contains(this))
				{
					LocalizationManager.ParamManagers.Add(this);
					LocalizationManager.LocalizeAll(Force: true);
				}
			}

			public void OnDisable()
			{
				LocalizationManager.ParamManagers.Remove(this);
			}
		}
		[Serializable]
		public struct LocalizedString
		{
			public string mTerm;

			public bool mRTL_IgnoreArabicFix;

			public int mRTL_MaxLineLength;

			public bool mRTL_ConvertNumbers;

			public bool m_DontLocalizeParameters;

			public static implicit operator string(LocalizedString s)
			{
				return s.ToString();
			}

			public static implicit operator LocalizedString(string term)
			{
				LocalizedString result = default(LocalizedString);
				result.mTerm = term;
				return result;
			}

			public LocalizedString(LocalizedString str)
			{
				mTerm = str.mTerm;
				mRTL_IgnoreArabicFix = str.mRTL_IgnoreArabicFix;
				mRTL_MaxLineLength = str.mRTL_MaxLineLength;
				mRTL_ConvertNumbers = str.mRTL_ConvertNumbers;
				m_DontLocalizeParameters = str.m_DontLocalizeParameters;
			}

			public override string ToString()
			{
				string translation = LocalizationManager.GetTranslation(mTerm, !mRTL_IgnoreArabicFix, mRTL_MaxLineLength, !mRTL_ConvertNumbers, applyParameters: true);
				LocalizationManager.ApplyLocalizationParams(ref translation, !m_DontLocalizeParameters);
				return translation;
			}
		}
		public class RTLFixer
		{
			public static string Fix(string str)
			{
				return Fix(str, showTashkeel: false, useHinduNumbers: true);
			}

			public static string Fix(string str, bool rtl)
			{
				if (rtl)
				{
					return Fix(str);
				}
				string[] array = str.Split(' ');
				string text = "";
				string text2 = "";
				string[] array2 = array;
				foreach (string text3 in array2)
				{
					if (char.IsLower(text3.ToLower()[text3.Length / 2]))
					{
						text = text + Fix(text2) + text3 + " ";
						text2 = "";
					}
					else
					{
						text2 = text2 + text3 + " ";
					}
				}
				if (text2 != "")
				{
					text += Fix(text2);
				}
				return text;
			}

			public static string Fix(string str, bool showTashkeel, bool useHinduNumbers)
			{
				string text = HindiFixer.Fix(str);
				if (text != str)
				{
					return text;
				}
				RTLFixerTool.showTashkeel = showTashkeel;
				RTLFixerTool.useHinduNumbers = useHinduNumbers;
				if (str.Contains("\n"))
				{
					str = str.Replace("\n", Environment.NewLine);
				}
				if (str.Contains(Environment.NewLine))
				{
					string[] separator = new string[1] { Environment.NewLine };
					string[] array = str.Split(separator, StringSplitOptions.None);
					if (array.Length == 0)
					{
						return RTLFixerTool.FixLine(str);
					}
					if (array.Length == 1)
					{
						return RTLFixerTool.FixLine(str);
					}
					string text2 = RTLFixerTool.FixLine(array[0]);
					int i = 1;
					if (array.Length > 1)
					{
						for (; i < array.Length; i++)
						{
							text2 = text2 + Environment.NewLine + RTLFixerTool.FixLine(array[i]);
						}
					}
					return text2;
				}
				return RTLFixerTool.FixLine(str);
			}
		}
		internal enum IsolatedArabicLetters
		{
			Hamza = 65152,
			Alef = 65165,
			AlefHamza = 65155,
			WawHamza = 65157,
			AlefMaksoor = 65159,
			AlefMaksora = 64508,
			HamzaNabera = 65161,
			Ba = 65167,
			Ta = 65173,
			Tha2 = 65177,
			Jeem = 65181,
			H7aa = 65185,
			Khaa2 = 65189,
			Dal = 65193,
			Thal = 65195,
			Ra2 = 65197,
			Zeen = 65199,
			Seen = 65201,
			Sheen = 65205,
			S9a = 65209,
			Dha = 65213,
			T6a = 65217,
			T6ha = 65221,
			Ain = 65225,
			Gain = 65229,
			Fa = 65233,
			Gaf = 65237,
			Kaf = 65241,
			Lam = 65245,
			Meem = 65249,
			Noon = 65253,
			Ha = 65257,
			Waw = 65261,
			Ya = 65265,
			AlefMad = 65153,
			TaMarboota = 65171,
			PersianPe = 64342,
			PersianChe = 64378,
			PersianZe = 64394,
			PersianGaf = 64402,
			PersianGaf2 = 64398
		}
		internal enum GeneralArabicLetters
		{
			Hamza = 1569,
			Alef = 1575,
			AlefHamza = 1571,
			WawHamza = 1572,
			AlefMaksoor = 1573,
			AlefMagsora = 1609,
			HamzaNabera = 1574,
			Ba = 1576,
			Ta = 1578,
			Tha2 = 1579,
			Jeem = 1580,
			H7aa = 1581,
			Khaa2 = 1582,
			Dal = 1583,
			Thal = 1584,
			Ra2 = 1585,
			Zeen = 1586,
			Seen = 1587,
			Sheen = 1588,
			S9a = 1589,
			Dha = 1590,
			T6a = 1591,
			T6ha = 1592,
			Ain = 1593,
			Gain = 1594,
			Fa = 1601,
			Gaf = 1602,
			Kaf = 1603,
			Lam = 1604,
			Meem = 1605,
			Noon = 1606,
			Ha = 1607,
			Waw = 1608,
			Ya = 1610,
			AlefMad = 1570,
			TaMarboota = 1577,
			PersianPe = 1662,
			PersianChe = 1670,
			PersianZe = 1688,
			PersianGaf = 1711,
			PersianGaf2 = 1705
		}
		internal class ArabicMapping
		{
			public int from;

			public int to;

			public ArabicMapping(int from, int to)
			{
				this.from = from;
				this.to = to;
			}
		}
		internal class ArabicTable
		{
			private static List<ArabicMapping> mapList;

			private static ArabicTable arabicMapper;

			internal static ArabicTable ArabicMapper
			{
				get
				{
					if (arabicMapper == null)
					{
						arabicMapper = new ArabicTable();
					}
					return arabicMapper;
				}
			}

			private ArabicTable()
			{
				mapList = new List<ArabicMapping>();
				mapList.Add(new ArabicMapping(1569, 65152));
				mapList.Add(new ArabicMapping(1575, 65165));
				mapList.Add(new ArabicMapping(1571, 65155));
				mapList.Add(new ArabicMapping(1572, 65157));
				mapList.Add(new ArabicMapping(1573, 65159));
				mapList.Add(new ArabicMapping(1609, 64508));
				mapList.Add(new ArabicMapping(1574, 65161));
				mapList.Add(new ArabicMapping(1576, 65167));
				mapList.Add(new ArabicMapping(1578, 65173));
				mapList.Add(new ArabicMapping(1579, 65177));
				mapList.Add(new ArabicMapping(1580, 65181));
				mapList.Add(new ArabicMapping(1581, 65185));
				mapList.Add(new ArabicMapping(1582, 65189));
				mapList.Add(new ArabicMapping(1583, 65193));
				mapList.Add(new ArabicMapping(1584, 65195));
				mapList.Add(new ArabicMapping(1585, 65197));
				mapList.Add(new ArabicMapping(1586, 65199));
				mapList.Add(new ArabicMapping(1587, 65201));
				mapList.Add(new ArabicMapping(1588, 65205));
				mapList.Add(new ArabicMapping(1589, 65209));
				mapList.Add(new ArabicMapping(1590, 65213));
				mapList.Add(new ArabicMapping(1591, 65217));
				mapList.Add(new ArabicMapping(1592, 65221));
				mapList.Add(new ArabicMapping(1593, 65225));
				mapList.Add(new ArabicMapping(1594, 65229));
				mapList.Add(new ArabicMapping(1601, 65233));
				mapList.Add(new ArabicMapping(1602, 65237));
				mapList.Add(new ArabicMapping(1603, 65241));
				mapList.Add(new ArabicMapping(1604, 65245));
				mapList.Add(new ArabicMapping(1605, 65249));
				mapList.Add(new ArabicMapping(1606, 65253));
				mapList.Add(new ArabicMapping(1607, 65257));
				mapList.Add(new ArabicMapping(1608, 65261));
				mapList.Add(new ArabicMapping(1610, 65265));
				mapList.Add(new ArabicMapping(1570, 65153));
				mapList.Add(new ArabicMapping(1577, 65171));
				mapList.Add(new ArabicMapping(1662, 64342));
				mapList.Add(new ArabicMapping(1670, 64378));
				mapList.Add(new ArabicMapping(1688, 64394));
				mapList.Add(new ArabicMapping(1711, 64402));
				mapList.Add(new ArabicMapping(1705, 64398));
			}

			internal int Convert(int toBeConverted)
			{
				foreach (ArabicMapping map in mapList)
				{
					if (map.from == toBeConverted)
					{
						return map.to;
					}
				}
				return toBeConverted;
			}
		}
		internal class TashkeelLocation
		{
			public char tashkeel;

			public int position;

			public TashkeelLocation(char tashkeel, int position)
			{
				this.tashkeel = tashkeel;
				this.position = position;
			}
		}
		internal class RTLFixerTool
		{
			internal static bool showTashkeel = true;

			internal static bool useHinduNumbers = false;

			internal static string RemoveTashkeel(string str, out List<TashkeelLocation> tashkeelLocation)
			{
				tashkeelLocation = new List<TashkeelLocation>();
				char[] array = str.ToCharArray();
				int num = 0;
				for (int i = 0; i < array.Length; i++)
				{
					if (array[i] == '\u064b')
					{
						tashkeelLocation.Add(new TashkeelLocation('\u064b', i));
						num++;
					}
					else if (array[i] == '\u064c')
					{
						tashkeelLocation.Add(new TashkeelLocation('\u064c', i));
						num++;
					}
					else if (array[i] == '\u064d')
					{
						tashkeelLocation.Add(new TashkeelLocation('\u064d', i));
						num++;
					}
					else if (array[i] == '\u064e')
					{
						if (num > 0 && tashkeelLocation[num - 1].tashkeel == '\u0651')
						{
							tashkeelLocation[num - 1].tashkeel = 'ﱠ';
							continue;
						}
						tashkeelLocation.Add(new TashkeelLocation('\u064e', i));
						num++;
					}
					else if (array[i] == '\u064f')
					{
						if (num > 0 && tashkeelLocation[num - 1].tashkeel == '\u0651')
						{
							tashkeelLocation[num - 1].tashkeel = 'ﱡ';
							continue;
						}
						tashkeelLocation.Add(new TashkeelLocation('\u064f', i));
						num++;
					}
					else if (array[i] == '\u0650')
					{
						if (num > 0 && tashkeelLocation[num - 1].tashkeel == '\u0651')
						{
							tashkeelLocation[num - 1].tashkeel = 'ﱢ';
							continue;
						}
						tashkeelLocation.Add(new TashkeelLocation('\u0650', i));
						num++;
					}
					else if (array[i] == '\u0651')
					{
						if (num > 0)
						{
							if (tashkeelLocation[num - 1].tashkeel == '\u064e')
							{
								tashkeelLocation[num - 1].tashkeel = 'ﱠ';
								continue;
							}
							if (tashkeelLocation[num - 1].tashkeel == '\u064f')
							{
								tashkeelLocation[num - 1].tashkeel = 'ﱡ';
								continue;
							}
							if (tashkeelLocation[num - 1].tashkeel == '\u0650')
							{
								tashkeelLocation[num - 1].tashkeel = 'ﱢ';
								continue;
							}
						}
						tashkeelLocation.Add(new TashkeelLocation('\u0651', i));
						num++;
					}
					else if (array[i] == '\u0652')
					{
						tashkeelLocation.Add(new TashkeelLocation('\u0652', i));
						num++;
					}
					else if (array[i] == '\u0653')
					{
						tashkeelLocation.Add(new TashkeelLocation('\u0653', i));
						num++;
					}
				}
				string[] array2 = str.Split('\u064b', '\u064c', '\u064d', '\u064e', '\u064f', '\u0650', '\u0651', '\u0652', '\u0653', 'ﱠ', 'ﱡ', 'ﱢ');
				str = "";
				string[] array3 = array2;
				foreach (string text in array3)
				{
					str += text;
				}
				return str;
			}

			internal static char[] ReturnTashkeel(char[] letters, List<TashkeelLocation> tashkeelLocation)
			{
				char[] array = new char[letters.Length + tashkeelLocation.Count];
				int num = 0;
				for (int i = 0; i < letters.Length; i++)
				{
					array[num] = letters[i];
					num++;
					foreach (TashkeelLocation item in tashkeelLocation)
					{
						if (item.position == num)
						{
							array[num] = item.tashkeel;
							num++;
						}
					}
				}
				return array;
			}

			internal static string FixLine(string str)
			{
				string text = "";
				List<TashkeelLocation> tashkeelLocation;
				string text2 = RemoveTashkeel(str, out tashkeelLocation);
				char[] array = text2.ToCharArray();
				char[] array2 = text2.ToCharArray();
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = (char)ArabicTable.ArabicMapper.Convert(array[i]);
				}
				for (int j = 0; j < array.Length; j++)
				{
					bool flag = false;
					if (array[j] == 'ﻝ' && j < array.Length - 1)
					{
						if (array[j + 1] == 'ﺇ')
						{
							array[j] = 'ﻷ';
							array2[j + 1] = '\uffff';
							flag = true;
						}
						else if (array[j + 1] == 'ﺍ')
						{
							array[j] = 'ﻹ';
							array2[j + 1] = '\uffff';
							flag = true;
						}
						else if (array[j + 1] == 'ﺃ')
						{
							array[j] = 'ﻵ';
							array2[j + 1] = '\uffff';
							flag = true;
						}
						else if (array[j + 1] == 'ﺁ')
						{
							array[j] = 'ﻳ';
							array2[j + 1] = '\uffff';
							flag = true;
						}
					}
					if (!IsIgnoredCharacter(array[j]))
					{
						if (IsMiddleLetter(array, j))
						{
							array2[j] = (char)(array[j] + 3);
						}
						else if (IsFinishingLetter(array, j))
						{
							array2[j] = (char)(array[j] + 1);
						}
						else if (IsLeadingLetter(array, j))
						{
							array2[j] = (char)(array[j] + 2);
						}
					}
					text = text + Convert.ToString(array[j], 16) + " ";
					if (flag)
					{
						j++;
					}
					if (useHinduNumbers)
					{
						if (array[j] == '0')
						{
							array2[j] = '٠';
						}
						else if (array[j] == '1')
						{
							array2[j] = '١';
						}
						else if (array[j] == '2')
						{
							array2[j] = '٢';
						}
						else if (array[j] == '3')
						{
							array2[j] = '٣';
						}
						else if (array[j] == '4')
						{
							array2[j] = '٤';
						}
						else if (array[j] == '5')
						{
							array2[j] = '٥';
						}
						else if (array[j] == '6')
						{
							array2[j] = '٦';
						}
						else if (array[j] == '7')
						{
							array2[j] = '٧';
						}
						else if (array[j] == '8')
						{
							array2[j] = '٨';
						}
						else if (array[j] == '9')
						{
							array2[j] = '٩';
						}
					}
				}
				if (showTashkeel)
				{
					array2 = ReturnTashkeel(array2, tashkeelLocation);
				}
				List<char> list = new List<char>();
				List<char> list2 = new List<char>();
				for (int num = array2.Length - 1; num >= 0; num--)
				{
					if (char.IsPunctuation(array2[num]) && num > 0 && num < array2.Length - 1 && (char.IsPunctuation(array2[num - 1]) || char.IsPunctuation(array2[num + 1])))
					{
						if (array2[num] == '(')
						{
							list.Add(')');
						}
						else if (array2[num] == ')')
						{
							list.Add('(');
						}
						else if (array2[num] == '<')
						{
							list.Add('>');
						}
						else if (array2[num] == '>')
						{
							list.Add('<');
						}
						else if (array2[num] == '[')
						{
							list.Add(']');
						}
						else if (array2[num] == ']')
						{
							list.Add('[');
						}
						else if (array2[num] != '\uffff')
						{
							list.Add(array2[num]);
						}
					}
					else if (array2[num] == ' ' && num > 0 && num < array2.Length - 1 && (char.IsLower(array2[num - 1]) || char.IsUpper(array2[num - 1]) || char.IsNumber(array2[num - 1])) && (char.IsLower(array2[num + 1]) || char.IsUpper(array2[num + 1]) || char.IsNumber(array2[num + 1])))
					{
						list2.Add(array2[num]);
					}
					else if (char.IsNumber(array2[num]) || char.IsLower(array2[num]) || char.IsUpper(array2[num]) || char.IsSymbol(array2[num]) || char.IsPunctuation(array2[num]))
					{
						if (array2[num] == '(')
						{
							list2.Add(')');
						}
						else if (array2[num] == ')')
						{
							list2.Add('(');
						}
						else if (array2[num] == '<')
						{
							list2.Add('>');
						}
						else if (array2[num] == '>')
						{
							list2.Add('<');
						}
						else if (array2[num] == '[')
						{
							list.Add(']');
						}
						else if (array2[num] == ']')
						{
							list.Add('[');
						}
						else
						{
							list2.Add(array2[num]);
						}
					}
					else if ((array2[num] >= '\ud800' && array2[num] <= '\udbff') || (array2[num] >= '\udc00' && array2[num] <= '\udfff'))
					{
						list2.Add(array2[num]);
					}
					else
					{
						if (list2.Count > 0)
						{
							for (int k = 0; k < list2.Count; k++)
							{
								list.Add(list2[list2.Count - 1 - k]);
							}
							list2.Clear();
						}
						if (array2[num] != '\uffff')
						{
							list.Add(array2[num]);
						}
					}
				}
				if (list2.Count > 0)
				{
					for (int l = 0; l < list2.Count; l++)
					{
						list.Add(list2[list2.Count - 1 - l]);
					}
					list2.Clear();
				}
				array2 = new char[list.Count];
				for (int m = 0; m < array2.Length; m++)
				{
					array2[m] = list[m];
				}
				str = new string(array2);
				return str;
			}

			internal static bool IsIgnoredCharacter(char ch)
			{
				bool num = char.IsPunctuation(ch);
				bool flag = char.IsNumber(ch);
				bool flag2 = char.IsLower(ch);
				bool flag3 = char.IsUpper(ch);
				bool flag4 = char.IsSymbol(ch);
				bool flag5 = ch == 'ﭖ' || ch == 'ﭺ' || ch == 'ﮊ' || ch == 'ﮒ' || ch == 'ﮎ';
				bool flag6 = (ch <= '\ufeff' && ch >= 'ﹰ') || flag5 || ch == 'ﯼ';
				if (!(num || flag || flag2 || flag3 || flag4) && flag6 && ch != 'a' && ch != '>' && ch != '<')
				{
					return ch == '؛';
				}
				return true;
			}

			internal static bool IsLeadingLetter(char[] letters, int index)
			{
				bool num = index == 0 || letters[index - 1] == ' ' || letters[index - 1] == '*' || letters[index - 1] == 'A' || char.IsPunctuation(letters[index - 1]) || letters[index - 1] == '>' || letters[index - 1] == '<' || letters[index - 1] == 'ﺍ' || letters[index - 1] == 'ﺩ' || letters[index - 1] == 'ﺫ' || letters[index - 1] == 'ﺭ' || letters[index - 1] == 'ﺯ' || letters[index - 1] == 'ﮊ' || letters[index - 1] == 'ﻭ' || letters[index - 1] == 'ﺁ' || letters[index - 1] == 'ﺃ' || letters[index - 1] == 'ﺇ' || letters[index - 1] == 'ﺅ';
				bool flag = letters[index] != ' ' && letters[index] != 'ﺩ' && letters[index] != 'ﺫ' && letters[index] != 'ﺭ' && letters[index] != 'ﺯ' && letters[index] != 'ﮊ' && letters[index] != 'ﺍ' && letters[index] != 'ﺃ' && letters[index] != 'ﺇ' && letters[index] != 'ﺁ' && letters[index] != 'ﺅ' && letters[index] != 'ﻭ' && letters[index] != 'ﺀ';
				bool flag2 = index < letters.Length - 1 && letters[index + 1] != ' ' && !char.IsPunctuation(letters[index + 1]) && !char.IsNumber(letters[index + 1]) && !char.IsSymbol(letters[index + 1]) && !char.IsLower(letters[index + 1]) && !char.IsUpper(letters[index + 1]) && letters[index + 1] != 'ﺀ';
				if (num && flag && flag2)
				{
					return true;
				}
				return false;
			}

			internal static bool IsFinishingLetter(char[] letters, int index)
			{
				bool num = index != 0 && letters[index - 1] != ' ' && letters[index - 1] != 'ﺩ' && letters[index - 1] != 'ﺫ' && letters[index - 1] != 'ﺭ' && letters[index - 1] != 'ﺯ' && letters[index - 1] != 'ﮊ' && letters[index - 1] != 'ﻭ' && letters[index - 1] != 'ﺍ' && letters[index - 1] != 'ﺁ' && letters[index - 1] != 'ﺃ' && letters[index - 1] != 'ﺇ' && letters[index - 1] != 'ﺅ' && letters[index - 1] != 'ﺀ' && !char.IsPunctuation(letters[index - 1]) && letters[index - 1] != '>' && letters[index - 1] != '<';
				bool flag = letters[index] != ' ' && letters[index] != 'ﺀ';
				if (num && flag)
				{
					return true;
				}
				return false;
			}

			internal static bool IsMiddleLetter(char[] letters, int index)
			{
				bool flag = index != 0 && letters[index] != 'ﺍ' && letters[index] != 'ﺩ' && letters[index] != 'ﺫ' && letters[index] != 'ﺭ' && letters[index] != 'ﺯ' && letters[index] != 'ﮊ' && letters[index] != 'ﻭ' && letters[index] != 'ﺁ' && letters[index] != 'ﺃ' && letters[index] != 'ﺇ' && letters[index] != 'ﺅ' && letters[index] != 'ﺀ';
				bool flag2 = index != 0 && letters[index - 1] != 'ﺍ' && letters[index - 1] != 'ﺩ' && letters[index - 1] != 'ﺫ' && letters[index - 1] != 'ﺭ' && letters[index - 1] != 'ﺯ' && letters[index - 1] != 'ﮊ' && letters[index - 1] != 'ﻭ' && letters[index - 1] != 'ﺁ' && letters[index - 1] != 'ﺃ' && letters[index - 1] != 'ﺇ' && letters[index - 1] != 'ﺅ' && letters[index - 1] != 'ﺀ' && !char.IsPunctuation(letters[index - 1]) && letters[index - 1] != '>' && letters[index - 1] != '<' && letters[index - 1] != ' ' && letters[index - 1] != '*';
				if (index < letters.Length - 1 && letters[index + 1] != ' ' && letters[index + 1] != '\r' && letters[index + 1] != 'ﺀ' && !char.IsNumber(letters[index + 1]) && !char.IsSymbol(letters[index + 1]) && !char.IsPunctuation(letters[index + 1]) && flag2 && flag)
				{
					try
					{
						if (char.IsPunctuation(letters[index + 1]))
						{
							return false;
						}
						return true;
					}
					catch
					{
						return false;
					}
				}
				return false;
			}
		}
		public class RegisterCallback_AllowSyncFromGoogle : MonoBehaviour
		{
			public void Awake()
			{
				LocalizationManager.Callback_AllowSyncFromGoogle = AllowSyncFromGoogle;
			}

			public void OnEnable()
			{
				LocalizationManager.Callback_AllowSyncFromGoogle = AllowSyncFromGoogle;
			}

			public void OnDisable()
			{
				LocalizationManager.Callback_AllowSyncFromGoogle = null;
			}

			public virtual bool AllowSyncFromGoogle(LanguageSourceData Source)
			{
				return true;
			}
		}
		public class RegisterGlobalParameters : MonoBehaviour, ILocalizationParamsManager
		{
			public virtual void OnEnable()
			{
				if (!LocalizationManager.ParamManagers.Contains(this))
				{
					LocalizationManager.ParamManagers.Add(this);
					LocalizationManager.LocalizeAll(Force: true);
				}
			}

			public virtual void OnDisable()
			{
				LocalizationManager.ParamManagers.Remove(this);
			}

			public virtual string GetParameterValue(string ParamName)
			{
				return null;
			}
		}
		public interface IResourceManager_Bundles
		{
			UnityEngine.Object LoadFromBundle(string path, Type assetType);
		}
		public class ResourceManager : MonoBehaviour
		{
			private static ResourceManager mInstance;

			public List<IResourceManager_Bundles> mBundleManagers = new List<IResourceManager_Bundles>();

			public UnityEngine.Object[] Assets;

			private readonly Dictionary<string, UnityEngine.Object> mResourcesCache = new Dictionary<string, UnityEngine.Object>(StringComparer.Ordinal);

			public static ResourceManager pInstance
			{
				get
				{
					bool flag = mInstance == null;
					if (mInstance == null)
					{
						mInstance = (ResourceManager)UnityEngine.Object.FindObjectOfType(typeof(ResourceManager));
					}
					if (mInstance == null)
					{
						GameObject obj = new GameObject("I2ResourceManager", typeof(ResourceManager));
						obj.hideFlags |= HideFlags.HideAndDontSave;
						mInstance = obj.GetComponent<ResourceManager>();
						SceneManager.sceneLoaded += MyOnLevelWasLoaded;
					}
					if (flag && Application.isPlaying)
					{
						UnityEngine.Object.DontDestroyOnLoad(mInstance.gameObject);
					}
					return mInstance;
				}
			}

			public static void MyOnLevelWasLoaded(Scene scene, LoadSceneMode mode)
			{
				pInstance.CleanResourceCache();
				LocalizationManager.UpdateSources();
			}

			public T GetAsset<T>(string Name) where T : UnityEngine.Object
			{
				T val = FindAsset(Name) as T;
				if (val != null)
				{
					return val;
				}
				return LoadFromResources<T>(Name);
			}

			private UnityEngine.Object FindAsset(string Name)
			{
				if (Assets != null)
				{
					int i = 0;
					for (int num = Assets.Length; i < num; i++)
					{
						if (Assets[i] != null && Assets[i].name == Name)
						{
							return Assets[i];
						}
					}
				}
				return null;
			}

			public bool HasAsset(UnityEngine.Object Obj)
			{
				if (Assets == null)
				{
					return false;
				}
				return Array.IndexOf(Assets, Obj) >= 0;
			}

			public T LoadFromResources<T>(string Path) where T : UnityEngine.Object
			{
				try
				{
					if (string.IsNullOrEmpty(Path))
					{
						return null;
					}
					if (mResourcesCache.TryGetValue(Path, out var value) && value != null)
					{
						return value as T;
					}
					T val = null;
					if (Path.EndsWith("]", StringComparison.OrdinalIgnoreCase))
					{
						int num = Path.LastIndexOf("[", StringComparison.OrdinalIgnoreCase);
						int length = Path.Length - num - 2;
						string value2 = Path.Substring(num + 1, length);
						Path = Path.Substring(0, num);
						T[] array = Resources.LoadAll<T>(Path);
						int i = 0;
						for (int num2 = array.Length; i < num2; i++)
						{
							if (array[i].name.Equals(value2))
							{
								val = array[i];
								break;
							}
						}
					}
					else
					{
						val = Resources.Load(Path, typeof(T)) as T;
					}
					if (val == null)
					{
						val = LoadFromBundle<T>(Path);
					}
					if (val != null)
					{
						mResourcesCache[Path] = val;
					}
					return val;
				}
				catch (Exception ex)
				{
					UnityEngine.Debug.LogErrorFormat("Unable to load {0} '{1}'\nERROR: {2}", typeof(T), Path, ex.ToString());
					return null;
				}
			}

			public T LoadFromBundle<T>(string path) where T : UnityEngine.Object
			{
				int i = 0;
				for (int count = mBundleManagers.Count; i < count; i++)
				{
					if (mBundleManagers[i] != null)
					{
						T val = mBundleManagers[i].LoadFromBundle(path, typeof(T)) as T;
						if (val != null)
						{
							return val;
						}
					}
				}
				return null;
			}

			public void CleanResourceCache()
			{
				mResourcesCache.Clear();
				Resources.UnloadUnusedAssets();
				CancelInvoke();
			}
		}
		[AddComponentMenu("I2/Localization/SetLanguage Button")]
		public class SetLanguage : MonoBehaviour
		{
			public string _Language;

			private void OnClick()
			{
				ApplyLanguage();
			}

			public void ApplyLanguage()
			{
				if (LocalizationManager.HasLanguage(_Language))
				{
					LocalizationManager.CurrentLanguage = _Language;
				}
			}
		}
		[AddComponentMenu("I2/Localization/SetLanguage Dropdown")]
		public class SetLanguageDropdown : MonoBehaviour
		{
			private void OnEnable()
			{
				Dropdown component = GetComponent<Dropdown>();
				if (!(component == null))
				{
					string currentLanguage = LocalizationManager.CurrentLanguage;
					if (LocalizationManager.Sources.Count == 0)
					{
						LocalizationManager.UpdateSources();
					}
					List<string> allLanguages = LocalizationManager.GetAllLanguages();
					component.ClearOptions();
					component.AddOptions(allLanguages);
					component.value = allLanguages.IndexOf(currentLanguage);
					component.onValueChanged.RemoveListener(OnValueChanged);
					component.onValueChanged.AddListener(OnValueChanged);
				}
			}

			private void OnValueChanged(int index)
			{
				Dropdown component = GetComponent<Dropdown>();
				if (index < 0)
				{
					index = 0;
					component.value = index;
				}
				LocalizationManager.CurrentLanguage = component.options[index].text;
			}
		}
		public class StringObfucator
		{
			public static char[] StringObfuscatorPassword = "ÝúbUu\u00b8CÁÂ§*4PÚ©-á©¾@T6Dl±ÒWâuzÅm4GÐóØ$=Íg,¥Që®iKEßr¡×60Ít4öÃ~^«y:Èd1<QÛÝúbUu\u00b8CÁÂ§*4PÚ©-á©¾@T6Dl±ÒWâuzÅm4GÐóØ$=Íg,¥Që®iKEßr¡×60Ít4öÃ~^«y:Èd".ToCharArray();

			public static string Encode(string NormalString)
			{
				try
				{
					return ToBase64(XoREncode(NormalString));
				}
				catch (Exception)
				{
					return null;
				}
			}

			public static string Decode(string ObfucatedString)
			{
				try
				{
					return XoREncode(FromBase64(ObfucatedString));
				}
				catch (Exception)
				{
					return null;
				}
			}

			private static string ToBase64(string regularString)
			{
				return Convert.ToBase64String(Encoding.UTF8.GetBytes(regularString));
			}

			private static string FromBase64(string base64string)
			{
				byte[] array = Convert.FromBase64String(base64string);
				return Encoding.UTF8.GetString(array, 0, array.Length);
			}

			private static string XoREncode(string NormalString)
			{
				try
				{
					char[] stringObfuscatorPassword = StringObfuscatorPassword;
					char[] array = NormalString.ToCharArray();
					int num = stringObfuscatorPassword.Length;
					int i = 0;
					for (int num2 = array.Length; i < num2; i++)
					{
						array[i] = (char)(array[i] ^ stringObfuscatorPassword[i % num] ^ (byte)((i % 2 == 0) ? (i * 23) : (-i * 51)));
					}
					return new string(array);
				}
				catch (Exception)
				{
					return null;
				}
			}
		}
	}
	namespace I2.Loc.SimpleJSON
	{
		public enum JSONBinaryTag
		{
			Array = 1,
			Class,
			Value,
			IntValue,
			DoubleValue,
			BoolValue,
			FloatValue
		}
		public class JSONNode
		{
			public virtual JSONNode this[int aIndex]
			{
				get
				{
					return null;
				}
				set
				{
				}
			}

			public virtual JSONNode this[string aKey]
			{
				get
				{
					return null;
				}
				set
				{
				}
			}

			public virtual string Value
			{
				get
				{
					return "";
				}
				set
				{
				}
			}

			public virtual int Count => 0;

			public virtual IEnumerable<JSONNode> Childs
			{
				get
				{
					yield break;
				}
			}

			public IEnumerable<JSONNode> DeepChilds
			{
				get
				{
					foreach (JSONNode child in Childs)
					{
						foreach (JSONNode deepChild in child.DeepChilds)
						{
							yield return deepChild;
						}
					}
				}
			}

			public virtual int AsInt
			{
				get
				{
					int result = 0;
					if (int.TryParse(Value, out result))
					{
						return result;
					}
					return 0;
				}
				set
				{
					Value = value.ToString();
				}
			}

			public virtual float AsFloat
			{
				get
				{
					float result = 0f;
					if (float.TryParse(Value, out result))
					{
						return result;
					}
					return 0f;
				}
				set
				{
					Value = value.ToString();
				}
			}

			public virtual double AsDouble
			{
				get
				{
					double result = 0.0;
					if (double.TryParse(Value, out result))
					{
						return result;
					}
					return 0.0;
				}
				set
				{
					Value = value.ToString();
				}
			}

			public virtual bool AsBool
			{
				get
				{
					bool result = false;
					if (bool.TryParse(Value, out result))
					{
						return result;
					}
					return !string.IsNullOrEmpty(Value);
				}
				set
				{
					Value = (value ? "true" : "false");
				}
			}

			public virtual JSONArray AsArray => this as JSONArray;

			public virtual JSONClass AsObject => this as JSONClass;

			public virtual void Add(string aKey, JSONNode aItem)
			{
			}

			public virtual void Add(JSONNode aItem)
			{
				Add("", aItem);
			}

			public virtual JSONNode Remove(string aKey)
			{
				return null;
			}

			public virtual JSONNode Remove(int aIndex)
			{
				return null;
			}

			public virtual JSONNode Remove(JSONNode aNode)
			{
				return aNode;
			}

			public override string ToString()
			{
				return "JSONNode";
			}

			public virtual string ToString(string aPrefix)
			{
				return "JSONNode";
			}

			public static implicit operator JSONNode(string s)
			{
				return new JSONData(s);
			}

			public static implicit operator string(JSONNode d)
			{
				if (!(d == null))
				{
					return d.Value;
				}
				return null;
			}

			public static bool operator ==(JSONNode a, object b)
			{
				if (b == null && a is JSONLazyCreator)
				{
					return true;
				}
				return (object)a == b;
			}

			public static bool operator !=(JSONNode a, object b)
			{
				return !(a == b);
			}

			public override bool Equals(object obj)
			{
				return (object)this == obj;
			}

			public override int GetHashCode()
			{
				return base.GetHashCode();
			}

			internal static string Escape(string aText)
			{
				string text = "";
				for (int i = 0; i < aText.Length; i++)
				{
					char c = aText[i];
					text = c switch
					{
						'\\' => text + "\\\\", 
						'"' => text + "\\\"", 
						'\n' => text + "\\n", 
						'\r' => text + "\\r", 
						'\t' => text + "\\t", 
						'\b' => text + "\\b", 
						'\f' => text + "\\f", 
						_ => text + c, 
					};
				}
				return text;
			}

			public static JSONNode Parse(string aJSON)
			{
				Stack<JSONNode> stack = new Stack<JSONNode>();
				JSONNode jSONNode = null;
				int i = 0;
				string text = "";
				string text2 = "";
				bool flag = false;
				for (; i < aJSON.Length; i++)
				{
					switch (aJSON[i])
					{
					case '{':
						if (flag)
						{
							text += aJSON[i];
							break;
						}
						stack.Push(new JSONClass());
						if (jSONNode != null)
						{
							text2 = text2.Trim();
							if (jSONNode is JSONArray)
							{
								jSONNode.Add(stack.Peek());
							}
							else if (text2 != "")
							{
								jSONNode.Add(text2, stack.Peek());
							}
						}
						text2 = "";
						text = "";
						jSONNode = stack.Peek();
						break;
					case '[':
						if (flag)
						{
							text += aJSON[i];
							break;
						}
						stack.Push(new JSONArray());
						if (jSONNode != null)
						{
							text2 = text2.Trim();
							if (jSONNode is JSONArray)
							{
								jSONNode.Add(stack.Peek());
							}
							else if (text2 != "")
							{
								jSONNode.Add(text2, stack.Peek());
							}
						}
						text2 = "";
						text = "";
						jSONNode = stack.Peek();
						break;
					case ']':
					case '}':
						if (flag)
						{
							text += aJSON[i];
							break;
						}
						if (stack.Count == 0)
						{
							throw new Exception("JSON Parse: Too many closing brackets");
						}
						stack.Pop();
						if (text != "")
						{
							text2 = text2.Trim();
							if (jSONNode is JSONArray)
							{
								jSONNode.Add(text);
							}
							else if (text2 != "")
							{
								jSONNode.Add(text2, text);
							}
						}
						text2 = "";
						text = "";
						if (stack.Count > 0)
						{
							jSONNode = stack.Peek();
						}
						break;
					case ':':
						if (flag)
						{
							text += aJSON[i];
							break;
						}
						text2 = text;
						text = "";
						break;
					case '"':
						flag = !flag;
						break;
					case ',':
						if (flag)
						{
							text += aJSON[i];
							break;
						}
						if (text != "")
						{
							if (jSONNode is JSONArray)
							{
								jSONNode.Add(text);
							}
							else if (text2 != "")
							{
								jSONNode.Add(text2, text);
							}
						}
						text2 = "";
						text = "";
						break;
					case '\t':
					case ' ':
						if (flag)
						{
							text += aJSON[i];
						}
						break;
					case '\\':
						i++;
						if (flag)
						{
							char c = aJSON[i];
							switch (c)
							{
							case 't':
								text += "\t";
								break;
							case 'r':
								text += "\r";
								break;
							case 'n':
								text += "\n";
								break;
							case 'b':
								text += "\b";
								break;
							case 'f':
								text += "\f";
								break;
							case 'u':
							{
								string s = aJSON.Substring(i + 1, 4);
								text += (char)int.Parse(s, NumberStyles.AllowHexSpecifier);
								i += 4;
								break;
							}
							default:
								text += c;
								break;
							}
						}
						break;
					default:
						text += aJSON[i];
						break;
					case '\n':
					case '\r':
						break;
					}
				}
				if (flag)
				{
					throw new Exception("JSON Parse: Quotation marks seems to be messed up.");
				}
				return jSONNode;
			}

			public virtual void Serialize(BinaryWriter aWriter)
			{
			}

			public void SaveToStream(Stream aData)
			{
				BinaryWriter aWriter = new BinaryWriter(aData);
				Serialize(aWriter);
			}

			public void SaveToCompressedStream(Stream aData)
			{
				throw new Exception("Can't use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON");
			}

			public void SaveToCompressedFile(string aFileName)
			{
				throw new Exception("Can't use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON");
			}

			public string SaveToCompressedBase64()
			{
				throw new Exception("Can't use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON");
			}

			public void SaveToFile(string aFileName)
			{
				Directory.CreateDirectory(new FileInfo(aFileName).Directory.FullName);
				using FileStream aData = File.OpenWrite(aFileName);
				SaveToStream(aData);
			}

			public string SaveToBase64()
			{
				using MemoryStream memoryStream = new MemoryStream();
				SaveToStream(memoryStream);
				memoryStream.Position = 0L;
				return Convert.ToBase64String(memoryStream.ToArray());
			}

			public static JSONNode Deserialize(BinaryReader aReader)
			{
				JSONBinaryTag jSONBinaryTag = (JSONBinaryTag)aReader.ReadByte();
				switch (jSONBinaryTag)
				{
				case JSONBinaryTag.Array:
				{
					int num2 = aReader.ReadInt32();
					JSONArray jSONArray = new JSONArray();
					for (int j = 0; j < num2; j++)
					{
						jSONArray.Add(Deserialize(aReader));
					}
					return jSONArray;
				}
				case JSONBinaryTag.Class:
				{
					int num = aReader.ReadInt32();
					JSONClass jSONClass = new JSONClass();
					for (int i = 0; i < num; i++)
					{
						string aKey = aReader.ReadString();
						JSONNode aItem = Deserialize(aReader);
						jSONClass.Add(aKey, aItem);
					}
					return jSONClass;
				}
				case JSONBinaryTag.Value:
					return new JSONData(aReader.ReadString());
				case JSONBinaryTag.IntValue:
					return new JSONData(aReader.ReadInt32());
				case JSONBinaryTag.DoubleValue:
					return new JSONData(aReader.ReadDouble());
				case JSONBinaryTag.BoolValue:
					return new JSONData(aReader.ReadBoolean());
				case JSONBinaryTag.FloatValue:
					return new JSONData(aReader.ReadSingle());
				default:
					throw new Exception("Error deserializing JSON. Unknown tag: " + jSONBinaryTag);
				}
			}

			public static JSONNode LoadFromCompressedFile(string aFileName)
			{
				throw new Exception("Can't use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON");
			}

			public static JSONNode LoadFromCompressedStream(Stream aData)
			{
				throw new Exception("Can't use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON");
			}

			public static JSONNode LoadFromCompressedBase64(string aBase64)
			{
				throw new Exception("Can't use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON");
			}

			public static JSONNode LoadFromStream(Stream aData)
			{
				using BinaryReader aReader = new BinaryReader(aData);
				return Deserialize(aReader);
			}

			public static JSONNode LoadFromFile(string aFileName)
			{
				using FileStream aData = File.OpenRead(aFileName);
				return LoadFromStream(aData);
			}

			public static JSONNode LoadFromBase64(string aBase64)
			{
				return LoadFromStream(new MemoryStream(Convert.FromBase64String(aBase64))
				{
					Position = 0L
				});
			}
		}
		public class JSONArray : JSONNode, IEnumerable
		{
			private List<JSONNode> m_List = new List<JSONNode>();

			public override JSONNode this[int aIndex]
			{
				get
				{
					if (aIndex < 0 || aIndex >= m_List.Count)
					{
						return new JSONLazyCreator(this);
					}
					return m_List[aIndex];
				}
				set
				{
					if (aIndex < 0 || aIndex >= m_List.Count)
					{
						m_List.Add(value);
					}
					else
					{
						m_List[aIndex] = value;
					}
				}
			}

			public override JSONNode this[string aKey]
			{
				get
				{
					return new JSONLazyCreator(this);
				}
				set
				{
					m_List.Add(value);
				}
			}

			public override int Count => m_List.Count;

			public override IEnumerable<JSONNode> Childs
			{
				get
				{
					foreach (JSONNode item in m_List)
					{
						yield return item;
					}
				}
			}

			public override void Add(string aKey, JSONNode aItem)
			{
				m_List.Add(aItem);
			}

			public override JSONNode Remove(int aIndex)
			{
				if (aIndex < 0 || aIndex >= m_List.Count)
				{
					return null;
				}
				JSONNode result = m_List[aIndex];
				m_List.RemoveAt(aIndex);
				return result;
			}

			public override JSONNode Remove(JSONNode aNode)
			{
				m_List.Remove(aNode);
				return aNode;
			}

			public IEnumerator GetEnumerator()
			{
				foreach (JSONNode item in m_List)
				{
					yield return item;
				}
			}

			public override string ToString()
			{
				string text = "[ ";
				foreach (JSONNode item in m_List)
				{
					if (text.Length > 2)
					{
						text += ", ";
					}
					text += item.ToString();
				}
				return text + " ]";
			}

			public override string ToString(string aPrefix)
			{
				string text = "[ ";
				foreach (JSONNode item in m_List)
				{
					if (text.Length > 3)
					{
						text += ", ";
					}
					text = text + "\n" + aPrefix + "   ";
					text += item.ToString(aPrefix + "   ");
				}
				return text + "\n" + aPrefix + "]";
			}

			public override void Serialize(BinaryWriter aWriter)
			{
				aWriter.Write((byte)1);
				aWriter.Write(m_List.Count);
				for (int i = 0; i < m_List.Count; i++)
				{
					m_List[i].Serialize(aWriter);
				}
			}
		}
		public class JSONClass : JSONNode, IEnumerable
		{
			private Dictionary<string, JSONNode> m_Dict = new Dictionary<string, JSONNode>(StringComparer.Ordinal);

			public override JSONNode this[string aKey]
			{
				get
				{
					if (m_Dict.ContainsKey(aKey))
					{
						return m_Dict[aKey];
					}
					return new JSONLazyCreator(this, aKey);
				}
				set
				{
					if (m_Dict.ContainsKey(aKey))
					{
						m_Dict[aKey] = value;
					}
					else
					{
						m_Dict.Add(aKey, value);
					}
				}
			}

			public override JSONNode this[int aIndex]
			{
				get
				{
					if (aIndex < 0 || aIndex >= m_Dict.Count)
					{
						return null;
					}
					return m_Dict.ElementAt(aIndex).Value;
				}
				set
				{
					if (aIndex >= 0 && aIndex < m_Dict.Count)
					{
						string key = m_Dict.ElementAt(aIndex).Key;
						m_Dict[key] = value;
					}
				}
			}

			public override int Count => m_Dict.Count;

			public override IEnumerable<JSONNode> Childs
			{
				get
				{
					foreach (KeyValuePair<string, JSONNode> item in m_Dict)
					{
						yield return item.Value;
					}
				}
			}

			public override void Add(string aKey, JSONNode aItem)
			{
				if (!string.IsNullOrEmpty(aKey))
				{
					if (m_Dict.ContainsKey(aKey))
					{
						m_Dict[aKey] = aItem;
					}
					else
					{
						m_Dict.Add(aKey, aItem);
					}
				}
				else
				{
					m_Dict.Add(Guid.NewGuid().ToString(), aItem);
				}
			}

			public override JSONNode Remove(string aKey)
			{
				if (!m_Dict.ContainsKey(aKey))
				{
					return null;
				}
				JSONNode result = m_Dict[aKey];
				m_Dict.Remove(aKey);
				return result;
			}

			public override JSONNode Remove(int aIndex)
			{
				if (aIndex < 0 || aIndex >= m_Dict.Count)
				{
					return null;
				}
				KeyValuePair<string, JSONNode> keyValuePair = m_Dict.ElementAt(aIndex);
				m_Dict.Remove(keyValuePair.Key);
				return keyValuePair.Value;
			}

			public override JSONNode Remove(JSONNode aNode)
			{
				try
				{
					KeyValuePair<string, JSONNode> keyValuePair = m_Dict.Where((KeyValuePair<string, JSONNode> k) => k.Value == aNode).First();
					m_Dict.Remove(keyValuePair.Key);
					return aNode;
				}
				catch
				{
					return null;
				}
			}

			public IEnumerator GetEnumerator()
			{
				foreach (KeyValuePair<string, JSONNode> item in m_Dict)
				{
					yield return item;
				}
			}

			public override string ToString()
			{
				string text = "{";
				foreach (KeyValuePair<string, JSONNode> item in m_Dict)
				{
					if (text.Length > 2)
					{
						text += ", ";
					}
					text = text + "\"" + JSONNode.Escape(item.Key) + "\":" + item.Value.ToString();
				}
				return text + "}";
			}

			public override string ToString(string aPrefix)
			{
				string text = "{ ";
				foreach (KeyValuePair<string, JSONNode> item in m_Dict)
				{
					if (text.Length > 3)
					{
						text += ", ";
					}
					text = text + "\n" + aPrefix + "   ";
					text = text + "\"" + JSONNode.Escape(item.Key) + "\" : " + item.Value.ToString(aPrefix + "   ");
				}
				return text + "\n" + aPrefix + "}";
			}

			public override void Serialize(BinaryWriter aWriter)
			{
				aWriter.Write((byte)2);
				aWriter.Write(m_Dict.Count);
				foreach (string key in m_Dict.Keys)
				{
					aWriter.Write(key);
					m_Dict[key].Serialize(aWriter);
				}
			}
		}
		public class JSONData : JSONNode
		{
			private string m_Data;

			public override string Value
			{
				get
				{
					return m_Data;
				}
				set
				{
					m_Data = value;
				}
			}

			public JSONData(string aData)
			{
				m_Data = aData;
			}

			public JSONData(float aData)
			{
				AsFloat = aData;
			}

			public JSONData(double aData)
			{
				AsDouble = aData;
			}

			public JSONData(bool aData)
			{
				AsBool = aData;
			}

			public JSONData(int aData)
			{
				AsInt = aData;
			}

			public override string ToString()
			{
				return "\"" + JSONNode.Escape(m_Data) + "\"";
			}

			public override string ToString(string aPrefix)
			{
				return "\"" + JSONNode.Escape(m_Data) + "\"";
			}

			public override void Serialize(BinaryWriter aWriter)
			{
				JSONData jSONData = new JSONData("");
				jSONData.AsInt = AsInt;
				if (jSONData.m_Data == m_Data)
				{
					aWriter.Write((byte)4);
					aWriter.Write(AsInt);
					return;
				}
				jSONData.AsFloat = AsFloat;
				if (jSONData.m_Data == m_Data)
				{
					aWriter.Write((byte)7);
					aWriter.Write(AsFloat);
					return;
				}
				jSONData.AsDouble = AsDouble;
				if (jSONData.m_Data == m_Data)
				{
					aWriter.Write((byte)5);
					aWriter.Write(AsDouble);
					return;
				}
				jSONData.AsBool = AsBool;
				if (jSONData.m_Data == m_Data)
				{
					aWriter.Write((byte)6);
					aWriter.Write(AsBool);
				}
				else
				{
					aWriter.Write((byte)3);
					aWriter.Write(m_Data);
				}
			}
		}
		internal class JSONLazyCreator : JSONNode
		{
			private JSONNode m_Node;

			private string m_Key;

			public override JSONNode this[int aIndex]
			{
				get
				{
					return new JSONLazyCreator(this);
				}
				set
				{
					JSONArray jSONArray = new JSONArray();
					jSONArray.Add(value);
					Set(jSONArray);
				}
			}

			public override JSONNode this[string aKey]
			{
				get
				{
					return new JSONLazyCreator(this, aKey);
				}
				set
				{
					JSONClass jSONClass = new JSONClass();
					jSONClass.Add(aKey, value);
					Set(jSONClass);
				}
			}

			public override int AsInt
			{
				get
				{
					JSONData aVal = new JSONData(0);
					Set(aVal);
					return 0;
				}
				set
				{
					JSONData aVal = new JSONData(value);
					Set(aVal);
				}
			}

			public override float AsFloat
			{
				get
				{
					JSONData aVal = new JSONData(0f);
					Set(aVal);
					return 0f;
				}
				set
				{
					JSONData aVal = new JSONData(value);
					Set(aVal);
				}
			}

			public override double AsDouble
			{
				get
				{
					JSONData aVal = new JSONData(0.0);
					Set(aVal);
					return 0.0;
				}
				set
				{
					JSONData aVal = new JSONData(value);
					Set(aVal);
				}
			}

			public override bool AsBool
			{
				get
				{
					JSONData aVal = new JSONData(aData: false);
					Set(aVal);
					return false;
				}
				set
				{
					JSONData aVal = new JSONData(value);
					Set(aVal);
				}
			}

			public override JSONArray AsArray
			{
				get
				{
					JSONArray jSONArray = new JSONArray();
					Set(jSONArray);
					return jSONArray;
				}
			}

			public override JSONClass AsObject
			{
				get
				{
					JSONClass jSONClass = new JSONClass();
					Set(jSONClass);
					return jSONClass;
				}
			}

			public JSONLazyCreator(JSONNode aNode)
			{
				m_Node = aNode;
				m_Key = null;
			}

			public JSONLazyCreator(JSONNode aNode, string aKey)
			{
				m_Node = aNode;
				m_Key = aKey;
			}

			private void Set(JSONNode aVal)
			{
				if (m_Key == null)
				{
					m_Node.Add(aVal);
				}
				else
				{
					m_Node.Add(m_Key, aVal);
				}
				m_Node = null;
			}

			public override void Add(JSONNode aItem)
			{
				JSONArray jSONArray = new JSONArray();
				jSONArray.Add(aItem);
				Set(jSONArray);
			}

			public override void Add(string aKey, JSONNode aItem)
			{
				JSONClass jSONClass = new JSONClass();
				jSONClass.Add(aKey, aItem);
				Set(jSONClass);
			}

			public static bool operator ==(JSONLazyCreator a, object b)
			{
				if (b == null)
				{
					return true;
				}
				return (object)a == b;
			}

			public static bool operator !=(JSONLazyCreator a, object b)
			{
				return !(a == b);
			}

			public override bool Equals(object obj)
			{
				if (obj == null)
				{
					return true;
				}
				return (object)this == obj;
			}

			public override int GetHashCode()
			{
				return base.GetHashCode();
			}

			public override string ToString()
			{
				return "";
			}

			public override string ToString(string aPrefix)
			{
				return "";
			}
		}
		public static class JSON
		{
			public static JSONNode Parse(string aJSON)
			{
				return JSONNode.Parse(aJSON);
			}
		}
	}
	namespace UnityStandardAssets.ImageEffects
	{
		public enum AAMode
		{
			FXAA2,
			FXAA3Console,
			FXAA1PresetA,
			FXAA1PresetB,
			NFAA,
			SSAA,
			DLAA
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(Camera))]
		[AddComponentMenu("Image Effects/Other/Antialiasing")]
		public class Antialiasing : PostEffectsBase
		{
			public AAMode mode = AAMode.FXAA3Console;

			public bool showGeneratedNormals;

			public float offsetScale = 0.2f;

			public float blurRadius = 18f;

			public float edgeThresholdMin = 0.05f;

			public float edgeThreshold = 0.2f;

			public float edgeSharpness = 4f;

			public bool dlaaSharp;

			public Shader ssaaShader;

			private Material ssaa;

			public Shader dlaaShader;

			private Material dlaa;

			public Shader nfaaShader;

			private Material nfaa;

			public Shader shaderFXAAPreset2;

			private Material materialFXAAPreset2;

			public Shader shaderFXAAPreset3;

			private Material materialFXAAPreset3;

			public Shader shaderFXAAII;

			private Material materialFXAAII;

			public Shader shaderFXAAIII;

			private Material materialFXAAIII;

			public Material CurrentAAMaterial()
			{
				Material material = null;
				return mode switch
				{
					AAMode.FXAA3Console => materialFXAAIII, 
					AAMode.FXAA2 => materialFXAAII, 
					AAMode.FXAA1PresetA => materialFXAAPreset2, 
					AAMode.FXAA1PresetB => materialFXAAPreset3, 
					AAMode.NFAA => nfaa, 
					AAMode.SSAA => ssaa, 
					AAMode.DLAA => dlaa, 
					_ => null, 
				};
			}

			public override bool CheckResources()
			{
				CheckSupport(needDepth: false);
				materialFXAAPreset2 = CreateMaterial(shaderFXAAPreset2, materialFXAAPreset2);
				materialFXAAPreset3 = CreateMaterial(shaderFXAAPreset3, materialFXAAPreset3);
				materialFXAAII = CreateMaterial(shaderFXAAII, materialFXAAII);
				materialFXAAIII = CreateMaterial(shaderFXAAIII, materialFXAAIII);
				nfaa = CreateMaterial(nfaaShader, nfaa);
				ssaa = CreateMaterial(ssaaShader, ssaa);
				dlaa = CreateMaterial(dlaaShader, dlaa);
				if (!ssaaShader.isSupported)
				{
					NotSupported();
					ReportAutoDisable();
				}
				return isSupported;
			}

			public void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (!CheckResources())
				{
					Graphics.Blit(source, destination);
				}
				else if (mode == AAMode.FXAA3Console && materialFXAAIII != null)
				{
					materialFXAAIII.SetFloat("_EdgeThresholdMin", edgeThresholdMin);
					materialFXAAIII.SetFloat("_EdgeThreshold", edgeThreshold);
					materialFXAAIII.SetFloat("_EdgeSharpness", edgeSharpness);
					Graphics.Blit(source, destination, materialFXAAIII);
				}
				else if (mode == AAMode.FXAA1PresetB && materialFXAAPreset3 != null)
				{
					Graphics.Blit(source, destination, materialFXAAPreset3);
				}
				else if (mode == AAMode.FXAA1PresetA && materialFXAAPreset2 != null)
				{
					source.anisoLevel = 4;
					Graphics.Blit(source, destination, materialFXAAPreset2);
					source.anisoLevel = 0;
				}
				else if (mode == AAMode.FXAA2 && materialFXAAII != null)
				{
					Graphics.Blit(source, destination, materialFXAAII);
				}
				else if (mode == AAMode.SSAA && ssaa != null)
				{
					Graphics.Blit(source, destination, ssaa);
				}
				else if (mode == AAMode.DLAA && dlaa != null)
				{
					source.anisoLevel = 0;
					RenderTexture temporary = RenderTexture.GetTemporary(source.width, source.height);
					Graphics.Blit(source, temporary, dlaa, 0);
					Graphics.Blit(temporary, destination, dlaa, (!dlaaSharp) ? 1 : 2);
					RenderTexture.ReleaseTemporary(temporary);
				}
				else if (mode == AAMode.NFAA && nfaa != null)
				{
					source.anisoLevel = 0;
					nfaa.SetFloat("_OffsetScale", offsetScale);
					nfaa.SetFloat("_BlurRadius", blurRadius);
					Graphics.Blit(source, destination, nfaa, showGeneratedNormals ? 1 : 0);
				}
				else
				{
					Graphics.Blit(source, destination);
				}
			}
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(Camera))]
		[AddComponentMenu("Image Effects/Bloom and Glow/Bloom")]
		public class Bloom : PostEffectsBase
		{
			public enum LensFlareStyle
			{
				Ghosting,
				Anamorphic,
				Combined
			}

			public enum TweakMode
			{
				Basic,
				Complex
			}

			public enum HDRBloomMode
			{
				Auto,
				On,
				Off
			}

			public enum BloomScreenBlendMode
			{
				Screen,
				Add
			}

			public enum BloomQuality
			{
				Cheap,
				High
			}

			public TweakMode tweakMode;

			public BloomScreenBlendMode screenBlendMode = BloomScreenBlendMode.Add;

			public HDRBloomMode hdr;

			private bool doHdr;

			public float sepBlurSpread = 2.5f;

			public BloomQuality quality = BloomQuality.High;

			public float bloomIntensity = 0.5f;

			public float bloomThreshold = 0.5f;

			public Color bloomThresholdColor = Color.white;

			public int bloomBlurIterations = 2;

			public int hollywoodFlareBlurIterations = 2;

			public float flareRotation;

			public LensFlareStyle lensflareMode = LensFlareStyle.Anamorphic;

			public float hollyStretchWidth = 2.5f;

			public float lensflareIntensity;

			public float lensflareThreshold = 0.3f;

			public float lensFlareSaturation = 0.75f;

			public Color flareColorA = new Color(0.4f, 0.4f, 0.8f, 0.75f);

			public Color flareColorB = new Color(0.4f, 0.8f, 0.8f, 0.75f);

			public Color flareColorC = new Color(0.8f, 0.4f, 0.8f, 0.75f);

			public Color flareColorD = new Color(0.8f, 0.4f, 0f, 0.75f);

			public Texture2D lensFlareVignetteMask;

			public Shader lensFlareShader;

			private Material lensFlareMaterial;

			public Shader screenBlendShader;

			private Material screenBlend;

			public Shader blurAndFlaresShader;

			private Material blurAndFlaresMaterial;

			public Shader brightPassFilterShader;

			private Material brightPassFilterMaterial;

			public override bool CheckResources()
			{
				CheckSupport(needDepth: false);
				screenBlend = CheckShaderAndCreateMaterial(screenBlendShader, screenBlend);
				lensFlareMaterial = CheckShaderAndCreateMaterial(lensFlareShader, lensFlareMaterial);
				blurAndFlaresMaterial = CheckShaderAndCreateMaterial(blurAndFlaresShader, blurAndFlaresMaterial);
				brightPassFilterMaterial = CheckShaderAndCreateMaterial(brightPassFilterShader, brightPassFilterMaterial);
				if (!isSupported)
				{
					ReportAutoDisable();
				}
				return isSupported;
			}

			public void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (!CheckResources())
				{
					Graphics.Blit(source, destination);
					return;
				}
				doHdr = false;
				if (hdr == HDRBloomMode.Auto)
				{
					doHdr = source.format == RenderTextureFormat.ARGBHalf && GetComponent<Camera>().allowHDR;
				}
				else
				{
					doHdr = hdr == HDRBloomMode.On;
				}
				doHdr = doHdr && supportHDRTextures;
				BloomScreenBlendMode bloomScreenBlendMode = screenBlendMode;
				if (doHdr)
				{
					bloomScreenBlendMode = BloomScreenBlendMode.Add;
				}
				RenderTextureFormat format = (doHdr ? RenderTextureFormat.ARGBHalf : RenderTextureFormat.Default);
				int width = source.width / 2;
				int height = source.height / 2;
				int width2 = source.width / 4;
				int height2 = source.height / 4;
				float num = 1f * (float)source.width / (1f * (float)source.height);
				float num2 = 0.001953125f;
				RenderTexture temporary = RenderTexture.GetTemporary(width2, height2, 0, format);
				RenderTexture temporary2 = RenderTexture.GetTemporary(width, height, 0, format);
				if (quality > BloomQuality.Cheap)
				{
					Graphics.Blit(source, temporary2, screenBlend, 2);
					RenderTexture temporary3 = RenderTexture.GetTemporary(width2, height2, 0, format);
					Graphics.Blit(temporary2, temporary3, screenBlend, 2);
					Graphics.Blit(temporary3, temporary, screenBlend, 6);
					RenderTexture.ReleaseTemporary(temporary3);
				}
				else
				{
					Graphics.Blit(source, temporary2);
					Graphics.Blit(temporary2, temporary, screenBlend, 6);
				}
				RenderTexture.ReleaseTemporary(temporary2);
				RenderTexture renderTexture = RenderTexture.GetTemporary(width2, height2, 0, format);
				BrightFilter(bloomThreshold * bloomThresholdColor, temporary, renderTexture);
				if (bloomBlurIterations < 1)
				{
					bloomBlurIterations = 1;
				}
				else if (bloomBlurIterations > 10)
				{
					bloomBlurIterations = 10;
				}
				for (int i = 0; i < bloomBlurIterations; i++)
				{
					float num3 = (1f + (float)i * 0.25f) * sepBlurSpread;
					RenderTexture temporary4 = RenderTexture.GetTemporary(width2, height2, 0, format);
					blurAndFlaresMaterial.SetVector("_Offsets", new Vector4(0f, num3 * num2, 0f, 0f));
					Graphics.Blit(renderTexture, temporary4, blurAndFlaresMaterial, 4);
					RenderTexture.ReleaseTemporary(renderTexture);
					renderTexture = temporary4;
					temporary4 = RenderTexture.GetTemporary(width2, height2, 0, format);
					blurAndFlaresMaterial.SetVector("_Offsets", new Vector4(num3 / num * num2, 0f, 0f, 0f));
					Graphics.Blit(renderTexture, temporary4, blurAndFlaresMaterial, 4);
					RenderTexture.ReleaseTemporary(renderTexture);
					renderTexture = temporary4;
					if (quality > BloomQuality.Cheap)
					{
						if (i == 0)
						{
							Graphics.SetRenderTarget(temporary);
							GL.Clear(clearDepth: false, clearColor: true, Color.black);
							Graphics.Blit(renderTexture, temporary);
						}
						else
						{
							temporary.MarkRestoreExpected();
							Graphics.Blit(renderTexture, temporary, screenBlend, 10);
						}
					}
				}
				if (quality > BloomQuality.Cheap)
				{
					Graphics.SetRenderTarget(renderTexture);
					GL.Clear(clearDepth: false, clearColor: true, Color.black);
					Graphics.Blit(temporary, renderTexture, screenBlend, 6);
				}
				if (lensflareIntensity > Mathf.Epsilon)
				{
					RenderTexture temporary5 = RenderTexture.GetTemporary(width2, height2, 0, format);
					if (lensflareMode == LensFlareStyle.Ghosting)
					{
						BrightFilter(lensflareThreshold, renderTexture, temporary5);
						if (quality > BloomQuality.Cheap)
						{
							blurAndFlaresMaterial.SetVector("_Offsets", new Vector4(0f, 1.5f / (1f * (float)temporary.height), 0f, 0f));
							Graphics.SetRenderTarget(temporary);
							GL.Clear(clearDepth: false, clearColor: true, Color.black);
							Graphics.Blit(temporary5, temporary, blurAndFlaresMaterial, 4);
							blurAndFlaresMaterial.SetVector("_Offsets", new Vector4(1.5f / (1f * (float)temporary.width), 0f, 0f, 0f));
							Graphics.SetRenderTarget(temporary5);
							GL.Clear(clearDepth: false, clearColor: true, Color.black);
							Graphics.Blit(temporary, temporary5, blurAndFlaresMaterial, 4);
						}
						Vignette(0.975f, temporary5, temporary5);
						BlendFlares(temporary5, renderTexture);
					}
					else
					{
						float num4 = 1f * Mathf.Cos(flareRotation);
						float num5 = 1f * Mathf.Sin(flareRotation);
						float num6 = hollyStretchWidth * 1f / num * num2;
						blurAndFlaresMaterial.SetVector("_Offsets", new Vector4(num4, num5, 0f, 0f));
						blurAndFlaresMaterial.SetVector("_Threshhold", new Vector4(lensflareThreshold, 1f, 0f, 0f));
						blurAndFlaresMaterial.SetVector("_TintColor", new Vector4(flareColorA.r, flareColorA.g, flareColorA.b, flareColorA.a) * flareColorA.a * lensflareIntensity);
						blurAndFlaresMaterial.SetFloat("_Saturation", lensFlareSaturation);
						temporary.DiscardContents();
						Graphics.Blit(temporary5, temporary, blurAndFlaresMaterial, 2);
						temporary5.DiscardContents();
						Graphics.Blit(temporary, temporary5, blurAndFlaresMaterial, 3);
						blurAndFlaresMaterial.SetVector("_Offsets", new Vector4(num4 * num6, num5 * num6, 0f, 0f));
						blurAndFlaresMaterial.SetFloat("_StretchWidth", hollyStretchWidth);
						temporary.DiscardContents();
						Graphics.Blit(temporary5, temporary, blurAndFlaresMaterial, 1);
						blurAndFlaresMaterial.SetFloat("_StretchWidth", hollyStretchWidth * 2f);
						temporary5.DiscardContents();
						Graphics.Blit(temporary, temporary5, blurAndFlaresMaterial, 1);
						blurAndFlaresMaterial.SetFloat("_StretchWidth", hollyStretchWidth * 4f);
						temporary.DiscardContents();
						Graphics.Blit(temporary5, temporary, blurAndFlaresMaterial, 1);
						for (int j = 0; j < hollywoodFlareBlurIterations; j++)
						{
							num6 = hollyStretchWidth * 2f / num * num2;
							blurAndFlaresMaterial.SetVector("_Offsets", new Vector4(num6 * num4, num6 * num5, 0f, 0f));
							temporary5.DiscardContents();
							Graphics.Blit(temporary, temporary5, blurAndFlaresMaterial, 4);
							blurAndFlaresMaterial.SetVector("_Offsets", new Vector4(num6 * num4, num6 * num5, 0f, 0f));
							temporary.DiscardContents();
							Graphics.Blit(temporary5, temporary, blurAndFlaresMaterial, 4);
						}
						if (lensflareMode == LensFlareStyle.Anamorphic)
						{
							AddTo(1f, temporary, renderTexture);
						}
						else
						{
							Vignette(1f, temporary, temporary5);
							BlendFlares(temporary5, temporary);
							AddTo(1f, temporary, renderTexture);
						}
					}
					RenderTexture.ReleaseTemporary(temporary5);
				}
				int pass = (int)bloomScreenBlendMode;
				screenBlend.SetFloat("_Intensity", bloomIntensity);
				screenBlend.SetTexture("_ColorBuffer", source);
				if (quality > BloomQuality.Cheap)
				{
					RenderTexture temporary6 = RenderTexture.GetTemporary(width, height, 0, format);
					Graphics.Blit(renderTexture, temporary6);
					Graphics.Blit(temporary6, destination, screenBlend, pass);
					RenderTexture.ReleaseTemporary(temporary6);
				}
				else
				{
					Graphics.Blit(renderTexture, destination, screenBlend, pass);
				}
				RenderTexture.ReleaseTemporary(temporary);
				RenderTexture.ReleaseTemporary(renderTexture);
			}

			private void AddTo(float intensity_, RenderTexture from, RenderTexture to)
			{
				screenBlend.SetFloat("_Intensity", intensity_);
				to.MarkRestoreExpected();
				Graphics.Blit(from, to, screenBlend, 9);
			}

			private void BlendFlares(RenderTexture from, RenderTexture to)
			{
				lensFlareMaterial.SetVector("colorA", new Vector4(flareColorA.r, flareColorA.g, flareColorA.b, flareColorA.a) * lensflareIntensity);
				lensFlareMaterial.SetVector("colorB", new Vector4(flareColorB.r, flareColorB.g, flareColorB.b, flareColorB.a) * lensflareIntensity);
				lensFlareMaterial.SetVector("colorC", new Vector4(flareColorC.r, flareColorC.g, flareColorC.b, flareColorC.a) * lensflareIntensity);
				lensFlareMaterial.SetVector("colorD", new Vector4(flareColorD.r, flareColorD.g, flareColorD.b, flareColorD.a) * lensflareIntensity);
				to.MarkRestoreExpected();
				Graphics.Blit(from, to, lensFlareMaterial);
			}

			private void BrightFilter(float thresh, RenderTexture from, RenderTexture to)
			{
				brightPassFilterMaterial.SetVector("_Threshhold", new Vector4(thresh, thresh, thresh, thresh));
				Graphics.Blit(from, to, brightPassFilterMaterial, 0);
			}

			private void BrightFilter(Color threshColor, RenderTexture from, RenderTexture to)
			{
				brightPassFilterMaterial.SetVector("_Threshhold", threshColor);
				Graphics.Blit(from, to, brightPassFilterMaterial, 1);
			}

			private void Vignette(float amount, RenderTexture from, RenderTexture to)
			{
				if ((bool)lensFlareVignetteMask)
				{
					screenBlend.SetTexture("_ColorBuffer", lensFlareVignetteMask);
					to.MarkRestoreExpected();
					Graphics.Blit((from == to) ? null : from, to, screenBlend, (from == to) ? 7 : 3);
				}
				else if (from != to)
				{
					Graphics.SetRenderTarget(to);
					GL.Clear(clearDepth: false, clearColor: true, Color.black);
					Graphics.Blit(from, to);
				}
			}
		}
		public enum LensflareStyle34
		{
			Ghosting,
			Anamorphic,
			Combined
		}
		public enum TweakMode34
		{
			Basic,
			Complex
		}
		public enum HDRBloomMode
		{
			Auto,
			On,
			Off
		}
		public enum BloomScreenBlendMode
		{
			Screen,
			Add
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(Camera))]
		[AddComponentMenu("Image Effects/Bloom and Glow/BloomAndFlares (3.5, Deprecated)")]
		public class BloomAndFlares : PostEffectsBase
		{
			public TweakMode34 tweakMode;

			public BloomScreenBlendMode screenBlendMode = BloomScreenBlendMode.Add;

			public HDRBloomMode hdr;

			private bool doHdr;

			public float sepBlurSpread = 1.5f;

			public float useSrcAlphaAsMask = 0.5f;

			public float bloomIntensity = 1f;

			public float bloomThreshold = 0.5f;

			public int bloomBlurIterations = 2;

			public bool lensflares;

			public int hollywoodFlareBlurIterations = 2;

			public LensflareStyle34 lensflareMode = LensflareStyle34.Anamorphic;

			public float hollyStretchWidth = 3.5f;

			public float lensflareIntensity = 1f;

			public float lensflareThreshold = 0.3f;

			public Color flareColorA = new Color(0.4f, 0.4f, 0.8f, 0.75f);

			public Color flareColorB = new Color(0.4f, 0.8f, 0.8f, 0.75f);

			public Color flareColorC = new Color(0.8f, 0.4f, 0.8f, 0.75f);

			public Color flareColorD = new Color(0.8f, 0.4f, 0f, 0.75f);

			public Texture2D lensFlareVignetteMask;

			public Shader lensFlareShader;

			private Material lensFlareMaterial;

			public Shader vignetteShader;

			private Material vignetteMaterial;

			public Shader separableBlurShader;

			private Material separableBlurMaterial;

			public Shader addBrightStuffOneOneShader;

			private Material addBrightStuffBlendOneOneMaterial;

			public Shader screenBlendShader;

			private Material screenBlend;

			public Shader hollywoodFlaresShader;

			private Material hollywoodFlaresMaterial;

			public Shader brightPassFilterShader;

			private Material brightPassFilterMaterial;

			public override bool CheckResources()
			{
				CheckSupport(needDepth: false);
				screenBlend = CheckShaderAndCreateMaterial(screenBlendShader, screenBlend);
				lensFlareMaterial = CheckShaderAndCreateMaterial(lensFlareShader, lensFlareMaterial);
				vignetteMaterial = CheckShaderAndCreateMaterial(vignetteShader, vignetteMaterial);
				separableBlurMaterial = CheckShaderAndCreateMaterial(separableBlurShader, separableBlurMaterial);
				addBrightStuffBlendOneOneMaterial = CheckShaderAndCreateMaterial(addBrightStuffOneOneShader, addBrightStuffBlendOneOneMaterial);
				hollywoodFlaresMaterial = CheckShaderAndCreateMaterial(hollywoodFlaresShader, hollywoodFlaresMaterial);
				brightPassFilterMaterial = CheckShaderAndCreateMaterial(brightPassFilterShader, brightPassFilterMaterial);
				if (!isSupported)
				{
					ReportAutoDisable();
				}
				return isSupported;
			}

			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (!CheckResources())
				{
					Graphics.Blit(source, destination);
					return;
				}
				doHdr = false;
				if (hdr == HDRBloomMode.Auto)
				{
					doHdr = source.format == RenderTextureFormat.ARGBHalf && GetComponent<Camera>().allowHDR;
				}
				else
				{
					doHdr = hdr == HDRBloomMode.On;
				}
				doHdr = doHdr && supportHDRTextures;
				BloomScreenBlendMode pass = screenBlendMode;
				if (doHdr)
				{
					pass = BloomScreenBlendMode.Add;
				}
				RenderTextureFormat format = (doHdr ? RenderTextureFormat.ARGBHalf : RenderTextureFormat.Default);
				RenderTexture temporary = RenderTexture.GetTemporary(source.width / 2, source.height / 2, 0, format);
				RenderTexture temporary2 = RenderTexture.GetTemporary(source.width / 4, source.height / 4, 0, format);
				RenderTexture temporary3 = RenderTexture.GetTemporary(source.width / 4, source.height / 4, 0, format);
				RenderTexture temporary4 = RenderTexture.GetTemporary(source.width / 4, source.height / 4, 0, format);
				float num = 1f * (float)source.width / (1f * (float)source.height);
				float num2 = 0.001953125f;
				Graphics.Blit(source, temporary, screenBlend, 2);
				Graphics.Blit(temporary, temporary2, screenBlend, 2);
				RenderTexture.ReleaseTemporary(temporary);
				BrightFilter(bloomThreshold, useSrcAlphaAsMask, temporary2, temporary3);
				temporary2.DiscardContents();
				if (bloomBlurIterations < 1)
				{
					bloomBlurIterations = 1;
				}
				for (int i = 0; i < bloomBlurIterations; i++)
				{
					float num3 = (1f + (float)i * 0.5f) * sepBlurSpread;
					separableBlurMaterial.SetVector("offsets", new Vector4(0f, num3 * num2, 0f, 0f));
					RenderTexture obj = ((i == 0) ? temporary3 : temporary2);
					Graphics.Blit(obj, temporary4, separableBlurMaterial);
					obj.DiscardContents();
					separableBlurMaterial.SetVector("offsets", new Vector4(num3 / num * num2, 0f, 0f, 0f));
					Graphics.Blit(temporary4, temporary2, separableBlurMaterial);
					temporary4.DiscardContents();
				}
				if (lensflares)
				{
					if (lensflareMode == LensflareStyle34.Ghosting)
					{
						BrightFilter(lensflareThreshold, 0f, temporary2, temporary4);
						temporary2.DiscardContents();
						Vignette(0.975f, temporary4, temporary3);
						temporary4.DiscardContents();
						BlendFlares(temporary3, temporary2);
						temporary3.DiscardContents();
					}
					else
					{
						hollywoodFlaresMaterial.SetVector("_threshold", new Vector4(lensflareThreshold, 1f / (1f - lensflareThreshold), 0f, 0f));
						hollywoodFlaresMaterial.SetVector("tintColor", new Vector4(flareColorA.r, flareColorA.g, flareColorA.b, flareColorA.a) * flareColorA.a * lensflareIntensity);
						Graphics.Blit(temporary4, temporary3, hollywoodFlaresMaterial, 2);
						temporary4.DiscardContents();
						Graphics.Blit(temporary3, temporary4, hollywoodFlaresMaterial, 3);
						temporary3.DiscardContents();
						hollywoodFlaresMaterial.SetVector("offsets", new Vector4(sepBlurSpread * 1f / num * num2, 0f, 0f, 0f));
						hollywoodFlaresMaterial.SetFloat("stretchWidth", hollyStretchWidth);
						Graphics.Blit(temporary4, temporary3, hollywoodFlaresMaterial, 1);
						temporary4.DiscardContents();
						hollywoodFlaresMaterial.SetFloat("stretchWidth", hollyStretchWidth * 2f);
						Graphics.Blit(temporary3, temporary4, hollywoodFlaresMaterial, 1);
						temporary3.DiscardContents();
						hollywoodFlaresMaterial.SetFloat("stretchWidth", hollyStretchWidth * 4f);
						Graphics.Blit(temporary4, temporary3, hollywoodFlaresMaterial, 1);
						temporary4.DiscardContents();
						if (lensflareMode == LensflareStyle34.Anamorphic)
						{
							for (int j = 0; j < hollywoodFlareBlurIterations; j++)
							{
								separableBlurMaterial.SetVector("offsets", new Vector4(hollyStretchWidth * 2f / num * num2, 0f, 0f, 0f));
								Graphics.Blit(temporary3, temporary4, separableBlurMaterial);
								temporary3.DiscardContents();
								separableBlurMaterial.SetVector("offsets", new Vector4(hollyStretchWidth * 2f / num * num2, 0f, 0f, 0f));
								Graphics.Blit(temporary4, temporary3, separableBlurMaterial);
								temporary4.DiscardContents();
							}
							AddTo(1f, temporary3, temporary2);
							temporary3.DiscardContents();
						}
						else
						{
							for (int k = 0; k < hollywoodFlareBlurIterations; k++)
							{
								separableBlurMaterial.SetVector("offsets", new Vector4(hollyStretchWidth * 2f / num * num2, 0f, 0f, 0f));
								Graphics.Blit(temporary3, temporary4, separableBlurMaterial);
								temporary3.DiscardContents();
								separableBlurMaterial.SetVector("offsets", new Vector4(hollyStretchWidth * 2f / num * num2, 0f, 0f, 0f));
								Graphics.Blit(temporary4, temporary3, separableBlurMaterial);
								temporary4.DiscardContents();
							}
							Vignette(1f, temporary3, temporary4);
							temporary3.DiscardContents();
							BlendFlares(temporary4, temporary3);
							temporary4.DiscardContents();
							AddTo(1f, temporary3, temporary2);
							temporary3.DiscardContents();
						}
					}
				}
				screenBlend.SetFloat("_Intensity", bloomIntensity);
				screenBlend.SetTexture("_ColorBuffer", source);
				Graphics.Blit(temporary2, destination, screenBlend, (int)pass);
				RenderTexture.ReleaseTemporary(temporary2);
				RenderTexture.ReleaseTemporary(temporary3);
				RenderTexture.ReleaseTemporary(temporary4);
			}

			private void AddTo(float intensity_, RenderTexture from, RenderTexture to)
			{
				addBrightStuffBlendOneOneMaterial.SetFloat("_Intensity", intensity_);
				Graphics.Blit(from, to, addBrightStuffBlendOneOneMaterial);
			}

			private void BlendFlares(RenderTexture from, RenderTexture to)
			{
				lensFlareMaterial.SetVector("colorA", new Vector4(flareColorA.r, flareColorA.g, flareColorA.b, flareColorA.a) * lensflareIntensity);
				lensFlareMaterial.SetVector("colorB", new Vector4(flareColorB.r, flareColorB.g, flareColorB.b, flareColorB.a) * lensflareIntensity);
				lensFlareMaterial.SetVector("colorC", new Vector4(flareColorC.r, flareColorC.g, flareColorC.b, flareColorC.a) * lensflareIntensity);
				lensFlareMaterial.SetVector("colorD", new Vector4(flareColorD.r, flareColorD.g, flareColorD.b, flareColorD.a) * lensflareIntensity);
				Graphics.Blit(from, to, lensFlareMaterial);
			}

			private void BrightFilter(float thresh, float useAlphaAsMask, RenderTexture from, RenderTexture to)
			{
				if (doHdr)
				{
					brightPassFilterMaterial.SetVector("threshold", new Vector4(thresh, 1f, 0f, 0f));
				}
				else
				{
					brightPassFilterMaterial.SetVector("threshold", new Vector4(thresh, 1f / (1f - thresh), 0f, 0f));
				}
				brightPassFilterMaterial.SetFloat("useSrcAlphaAsMask", useAlphaAsMask);
				Graphics.Blit(from, to, brightPassFilterMaterial);
			}

			private void Vignette(float amount, RenderTexture from, RenderTexture to)
			{
				if ((bool)lensFlareVignetteMask)
				{
					screenBlend.SetTexture("_ColorBuffer", lensFlareVignetteMask);
					Graphics.Blit(from, to, screenBlend, 3);
				}
				else
				{
					vignetteMaterial.SetFloat("vignetteIntensity", amount);
					Graphics.Blit(from, to, vignetteMaterial);
				}
			}
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(Camera))]
		[AddComponentMenu("Image Effects/Bloom and Glow/Bloom (Optimized)")]
		public class BloomOptimized : PostEffectsBase
		{
			public enum Resolution
			{
				Low,
				High
			}

			public enum BlurType
			{
				Standard,
				Sgx
			}

			[Range(0f, 1.5f)]
			public float threshold = 0.25f;

			[Range(0f, 2.5f)]
			public float intensity = 0.75f;

			[Range(0.25f, 5.5f)]
			public float blurSize = 1f;

			private Resolution resolution;

			[Range(1f, 4f)]
			public int blurIterations = 1;

			public BlurType blurType;

			public Shader fastBloomShader;

			private Material fastBloomMaterial;

			public override bool CheckResources()
			{
				CheckSupport(needDepth: false);
				fastBloomMaterial = CheckShaderAndCreateMaterial(fastBloomShader, fastBloomMaterial);
				if (!isSupported)
				{
					ReportAutoDisable();
				}
				return isSupported;
			}

			private void OnDisable()
			{
				if ((bool)fastBloomMaterial)
				{
					UnityEngine.Object.DestroyImmediate(fastBloomMaterial);
				}
			}

			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (!CheckResources())
				{
					Graphics.Blit(source, destination);
					return;
				}
				int num = ((resolution == Resolution.Low) ? 4 : 2);
				float num2 = ((resolution == Resolution.Low) ? 0.5f : 1f);
				fastBloomMaterial.SetVector("_Parameter", new Vector4(blurSize * num2, 0f, threshold, intensity));
				source.filterMode = FilterMode.Bilinear;
				int width = source.width / num;
				int height = source.height / num;
				RenderTexture renderTexture = RenderTexture.GetTemporary(width, height, 0, source.format);
				renderTexture.filterMode = FilterMode.Bilinear;
				Graphics.Blit(source, renderTexture, fastBloomMaterial, 1);
				int num3 = ((blurType != 0) ? 2 : 0);
				for (int i = 0; i < blurIterations; i++)
				{
					fastBloomMaterial.SetVector("_Parameter", new Vector4(blurSize * num2 + (float)i * 1f, 0f, threshold, intensity));
					RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0, source.format);
					temporary.filterMode = FilterMode.Bilinear;
					Graphics.Blit(renderTexture, temporary, fastBloomMaterial, 2 + num3);
					RenderTexture.ReleaseTemporary(renderTexture);
					renderTexture = temporary;
					temporary = RenderTexture.GetTemporary(width, height, 0, source.format);
					temporary.filterMode = FilterMode.Bilinear;
					Graphics.Blit(renderTexture, temporary, fastBloomMaterial, 3 + num3);
					RenderTexture.ReleaseTemporary(renderTexture);
					renderTexture = temporary;
				}
				fastBloomMaterial.SetTexture("_Bloom", renderTexture);
				Graphics.Blit(source, destination, fastBloomMaterial, 0);
				RenderTexture.ReleaseTemporary(renderTexture);
			}
		}
		[ExecuteInEditMode]
		[AddComponentMenu("Image Effects/Blur/Blur")]
		public class Blur : MonoBehaviour
		{
			[Range(0f, 10f)]
			public int iterations = 3;

			[Range(0f, 1f)]
			public float blurSpread = 0.6f;

			public Shader blurShader;

			private static Material m_Material;

			protected Material material
			{
				get
				{
					if (m_Material == null)
					{
						m_Material = new Material(blurShader);
						m_Material.hideFlags = HideFlags.DontSave;
					}
					return m_Material;
				}
			}

			protected void OnDisable()
			{
				if ((bool)m_Material)
				{
					UnityEngine.Object.DestroyImmediate(m_Material);
				}
			}

			protected void Start()
			{
				if (!SystemInfo.supportsImageEffects)
				{
					base.enabled = false;
				}
				else if (!blurShader || !material.shader.isSupported)
				{
					base.enabled = false;
				}
			}

			public void FourTapCone(RenderTexture source, RenderTexture dest, int iteration)
			{
				float num = 0.5f + (float)iteration * blurSpread;
				Graphics.BlitMultiTap(source, dest, material, new Vector2(0f - num, 0f - num), new Vector2(0f - num, num), new Vector2(num, num), new Vector2(num, 0f - num));
			}

			private void DownSample4x(RenderTexture source, RenderTexture dest)
			{
				float num = 1f;
				Graphics.BlitMultiTap(source, dest, material, new Vector2(0f - num, 0f - num), new Vector2(0f - num, num), new Vector2(num, num), new Vector2(num, 0f - num));
			}

			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				int width = source.width / 4;
				int height = source.height / 4;
				RenderTexture renderTexture = RenderTexture.GetTemporary(width, height, 0);
				DownSample4x(source, renderTexture);
				for (int i = 0; i < iterations; i++)
				{
					RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0);
					FourTapCone(renderTexture, temporary, i);
					RenderTexture.ReleaseTemporary(renderTexture);
					renderTexture = temporary;
				}
				Graphics.Blit(renderTexture, destination);
				RenderTexture.ReleaseTemporary(renderTexture);
			}
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(Camera))]
		[AddComponentMenu("Image Effects/Blur/Blur (Optimized)")]
		public class BlurOptimized : PostEffectsBase
		{
			public enum BlurType
			{
				StandardGauss,
				SgxGauss
			}

			[Range(0f, 2f)]
			public int downsample = 1;

			[Range(0f, 10f)]
			public float blurSize = 3f;

			[Range(1f, 4f)]
			public int blurIterations = 2;

			public BlurType blurType;

			public Shader blurShader;

			private Material blurMaterial;

			public override bool CheckResources()
			{
				CheckSupport(needDepth: false);
				blurMaterial = CheckShaderAndCreateMaterial(blurShader, blurMaterial);
				if (!isSupported)
				{
					ReportAutoDisable();
				}
				return isSupported;
			}

			public void OnDisable()
			{
				if ((bool)blurMaterial)
				{
					UnityEngine.Object.DestroyImmediate(blurMaterial);
				}
			}

			public void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (!CheckResources())
				{
					Graphics.Blit(source, destination);
					return;
				}
				float num = 1f / (1f * (float)(1 << downsample));
				blurMaterial.SetVector("_Parameter", new Vector4(blurSize * num, (0f - blurSize) * num, 0f, 0f));
				source.filterMode = FilterMode.Bilinear;
				int width = source.width >> downsample;
				int height = source.height >> downsample;
				RenderTexture renderTexture = RenderTexture.GetTemporary(width, height, 0, source.format);
				renderTexture.filterMode = FilterMode.Bilinear;
				Graphics.Blit(source, renderTexture, blurMaterial, 0);
				int num2 = ((blurType != 0) ? 2 : 0);
				for (int i = 0; i < blurIterations; i++)
				{
					float num3 = (float)i * 1f;
					blurMaterial.SetVector("_Parameter", new Vector4(blurSize * num + num3, (0f - blurSize) * num - num3, 0f, 0f));
					RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0, source.format);
					temporary.filterMode = FilterMode.Bilinear;
					Graphics.Blit(renderTexture, temporary, blurMaterial, 1 + num2);
					RenderTexture.ReleaseTemporary(renderTexture);
					renderTexture = temporary;
					temporary = RenderTexture.GetTemporary(width, height, 0, source.format);
					temporary.filterMode = FilterMode.Bilinear;
					Graphics.Blit(renderTexture, temporary, blurMaterial, 2 + num2);
					RenderTexture.ReleaseTemporary(renderTexture);
					renderTexture = temporary;
				}
				Graphics.Blit(renderTexture, destination);
				RenderTexture.ReleaseTemporary(renderTexture);
			}
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(Camera))]
		[AddComponentMenu("Image Effects/Camera/Camera Motion Blur")]
		public class CameraMotionBlur : PostEffectsBase
		{
			public enum MotionBlurFilter
			{
				CameraMotion,
				LocalBlur,
				Reconstruction,
				ReconstructionDX11,
				ReconstructionDisc
			}

			private static float MAX_RADIUS = 10f;

			public MotionBlurFilter filterType = MotionBlurFilter.Reconstruction;

			public bool preview;

			public Vector3 previewScale = Vector3.one;

			public float movementScale;

			public float rotationScale = 1f;

			public float maxVelocity = 8f;

			public float minVelocity = 0.1f;

			public float velocityScale = 0.375f;

			public float softZDistance = 0.005f;

			public int velocityDownsample = 1;

			public LayerMask excludeLayers = 0;

			private GameObject tmpCam;

			public Shader shader;

			public Shader dx11MotionBlurShader;

			public Shader replacementClear;

			private Material motionBlurMaterial;

			private Material dx11MotionBlurMaterial;

			public Texture2D noiseTexture;

			public float jitter = 0.05f;

			public bool showVelocity;

			public float showVelocityScale = 1f;

			private Matrix4x4 currentViewProjMat;

			private Matrix4x4[] currentStereoViewProjMat;

			private Matrix4x4 prevViewProjMat;

			private Matrix4x4[] prevStereoViewProjMat;

			private int prevFrameCount;

			private bool wasActive;

			private Vector3 prevFrameForward = Vector3.forward;

			private Vector3 prevFrameUp = Vector3.up;

			private Vector3 prevFramePos = Vector3.zero;

			private Camera _camera;

			private void CalculateViewProjection()
			{
				Matrix4x4 worldToCameraMatrix = _camera.worldToCameraMatrix;
				Matrix4x4 gPUProjectionMatrix = GL.GetGPUProjectionMatrix(_camera.projectionMatrix, renderIntoTexture: true);
				currentViewProjMat = gPUProjectionMatrix * worldToCameraMatrix;
				if (_camera.stereoEnabled)
				{
					for (int i = 0; i < 2; i++)
					{
						Matrix4x4 stereoViewMatrix = _camera.GetStereoViewMatrix((i != 0) ? Camera.StereoscopicEye.Right : Camera.StereoscopicEye.Left);
						Matrix4x4 stereoProjectionMatrix = _camera.GetStereoProjectionMatrix((i != 0) ? Camera.StereoscopicEye.Right : Camera.StereoscopicEye.Left);
						stereoProjectionMatrix = GL.GetGPUProjectionMatrix(stereoProjectionMatrix, renderIntoTexture: true);
						currentStereoViewProjMat[i] = stereoProjectionMatrix * stereoViewMatrix;
					}
				}
			}

			private new void Start()
			{
				CheckResources();
				if (_camera == null)
				{
					_camera = GetComponent<Camera>();
				}
				wasActive = base.gameObject.activeInHierarchy;
				currentStereoViewProjMat = new Matrix4x4[2];
				prevStereoViewProjMat = new Matrix4x4[2];
				CalculateViewProjection();
				Remember();
				wasActive = false;
			}

			private void OnEnable()
			{
				if (_camera == null)
				{
					_camera = GetComponent<Camera>();
				}
				_camera.depthTextureMode |= DepthTextureMode.Depth;
			}

			private void OnDisable()
			{
				if (null != motionBlurMaterial)
				{
					UnityEngine.Object.DestroyImmediate(motionBlurMaterial);
					motionBlurMaterial = null;
				}
				if (null != dx11MotionBlurMaterial)
				{
					UnityEngine.Object.DestroyImmediate(dx11MotionBlurMaterial);
					dx11MotionBlurMaterial = null;
				}
				if (null != tmpCam)
				{
					UnityEngine.Object.DestroyImmediate(tmpCam);
					tmpCam = null;
				}
			}

			public override bool CheckResources()
			{
				CheckSupport(needDepth: true, needHdr: true);
				motionBlurMaterial = CheckShaderAndCreateMaterial(shader, motionBlurMaterial);
				if (supportDX11 && filterType == MotionBlurFilter.ReconstructionDX11)
				{
					dx11MotionBlurMaterial = CheckShaderAndCreateMaterial(dx11MotionBlurShader, dx11MotionBlurMaterial);
				}
				if (!isSupported)
				{
					ReportAutoDisable();
				}
				return isSupported;
			}

			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (!CheckResources())
				{
					Graphics.Blit(source, destination);
					return;
				}
				if (filterType == MotionBlurFilter.CameraMotion)
				{
					StartFrame();
				}
				RenderTextureFormat format = (SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.RGHalf) ? RenderTextureFormat.RGHalf : RenderTextureFormat.ARGBHalf);
				RenderTexture temporary = RenderTexture.GetTemporary(divRoundUp(source.width, velocityDownsample), divRoundUp(source.height, velocityDownsample), 0, format);
				int num = 1;
				int num2 = 1;
				maxVelocity = Mathf.Max(2f, maxVelocity);
				float num3 = maxVelocity;
				bool flag = filterType == MotionBlurFilter.ReconstructionDX11 && dx11MotionBlurMaterial == null;
				if (filterType == MotionBlurFilter.Reconstruction || flag || filterType == MotionBlurFilter.ReconstructionDisc)
				{
					maxVelocity = Mathf.Min(maxVelocity, MAX_RADIUS);
					num = divRoundUp(temporary.width, (int)maxVelocity);
					num2 = divRoundUp(temporary.height, (int)maxVelocity);
					num3 = temporary.width / num;
				}
				else
				{
					num = divRoundUp(temporary.width, (int)maxVelocity);
					num2 = divRoundUp(temporary.height, (int)maxVelocity);
					num3 = temporary.width / num;
				}
				RenderTexture temporary2 = RenderTexture.GetTemporary(num, num2, 0, format);
				RenderTexture temporary3 = RenderTexture.GetTemporary(num, num2, 0, format);
				temporary.filterMode = FilterMode.Point;
				temporary2.filterMode = FilterMode.Point;
				temporary3.filterMode = FilterMode.Point;
				if ((bool)noiseTexture)
				{
					noiseTexture.filterMode = FilterMode.Point;
				}
				source.wrapMode = TextureWrapMode.Clamp;
				temporary.wrapMode = TextureWrapMode.Clamp;
				temporary3.wrapMode = TextureWrapMode.Clamp;
				temporary2.wrapMode = TextureWrapMode.Clamp;
				CalculateViewProjection();
				if (base.gameObject.activeInHierarchy && !wasActive)
				{
					Remember();
				}
				wasActive = base.gameObject.activeInHierarchy;
				Matrix4x4 matrix4x = Matrix4x4.Inverse(currentViewProjMat);
				motionBlurMaterial.SetMatrix("_InvViewProj", matrix4x);
				motionBlurMaterial.SetMatrix("_PrevViewProj", prevViewProjMat);
				motionBlurMaterial.SetMatrix("_ToPrevViewProjCombined", prevViewProjMat * matrix4x);
				if (_camera.stereoEnabled)
				{
					Matrix4x4[] array = new Matrix4x4[2]
					{
						Matrix4x4.Inverse(currentStereoViewProjMat[0]),
						Matrix4x4.Inverse(currentStereoViewProjMat[1])
					};
					Matrix4x4 value = prevStereoViewProjMat[0] * array[0];
					motionBlurMaterial.SetMatrix("_StereoToPrevViewProjCombined0", value);
					motionBlurMaterial.SetMatrix("_StereoToPrevViewProjCombined1", prevStereoViewProjMat[1] * array[1]);
				}
				motionBlurMaterial.SetFloat("_MaxVelocity", num3);
				motionBlurMaterial.SetFloat("_MaxRadiusOrKInPaper", num3);
				motionBlurMaterial.SetFloat("_MinVelocity", minVelocity);
				motionBlurMaterial.SetFloat("_VelocityScale", velocityScale);
				motionBlurMaterial.SetFloat("_Jitter", jitter);
				motionBlurMaterial.SetTexture("_NoiseTex", noiseTexture);
				motionBlurMaterial.SetTexture("_VelTex", temporary);
				motionBlurMaterial.SetTexture("_NeighbourMaxTex", temporary3);
				motionBlurMaterial.SetTexture("_TileTexDebug", temporary2);
				if (preview)
				{
					Matrix4x4 worldToCameraMatrix = _camera.worldToCameraMatrix;
					Matrix4x4 identity = Matrix4x4.identity;
					identity.SetTRS(previewScale * 0.3333f, Quaternion.identity, Vector3.one);
					Matrix4x4 gPUProjectionMatrix = GL.GetGPUProjectionMatrix(_camera.projectionMatrix, renderIntoTexture: true);
					prevViewProjMat = gPUProjectionMatrix * identity * worldToCameraMatrix;
					motionBlurMaterial.SetMatrix("_PrevViewProj", prevViewProjMat);
					motionBlurMaterial.SetMatrix("_ToPrevViewProjCombined", prevViewProjMat * matrix4x);
				}
				if (filterType == MotionBlurFilter.CameraMotion)
				{
					Vector4 zero = Vector4.zero;
					float num4 = Vector3.Dot(base.transform.up, Vector3.up);
					Vector3 rhs = prevFramePos - base.transform.position;
					float magnitude = rhs.magnitude;
					float num5 = 1f;
					num5 = Vector3.Angle(base.transform.up, prevFrameUp) / _camera.fieldOfView * ((float)source.width * 0.75f);
					zero.x = rotationScale * num5;
					num5 = Vector3.Angle(base.transform.forward, prevFrameForward) / _camera.fieldOfView * ((float)source.width * 0.75f);
					zero.y = rotationScale * num4 * num5;
					num5 = Vector3.Angle(base.transform.forward, prevFrameForward) / _camera.fieldOfView * ((float)source.width * 0.75f);
					zero.z = rotationScale * (1f - num4) * num5;
					if (magnitude > Mathf.Epsilon && movementScale > Mathf.Epsilon)
					{
						zero.w = movementScale * Vector3.Dot(base.transform.forward, rhs) * ((float)source.width * 0.5f);
						zero.x += movementScale * Vector3.Dot(base.transform.up, rhs) * ((float)source.width * 0.5f);
						zero.y += movementScale * Vector3.Dot(base.transform.right, rhs) * ((float)source.width * 0.5f);
					}
					if (preview)
					{
						motionBlurMaterial.SetVector("_BlurDirectionPacked", new Vector4(previewScale.y, previewScale.x, 0f, previewScale.z) * 0.5f * _camera.fieldOfView);
					}
					else
					{
						motionBlurMaterial.SetVector("_BlurDirectionPacked", zero);
					}
				}
				else
				{
					Graphics.Blit(source, temporary, motionBlurMaterial, 0);
					Camera camera = null;
					if (excludeLayers.value != 0)
					{
						camera = GetTmpCam();
					}
					if ((bool)camera && excludeLayers.value != 0 && (bool)replacementClear && replacementClear.isSupported)
					{
						camera.targetTexture = temporary;
						camera.cullingMask = excludeLayers;
						camera.RenderWithShader(replacementClear, "");
					}
				}
				if (!preview && Time.frameCount != prevFrameCount)
				{
					prevFrameCount = Time.frameCount;
					Remember();
				}
				source.filterMode = FilterMode.Bilinear;
				if (showVelocity)
				{
					motionBlurMaterial.SetFloat("_DisplayVelocityScale", showVelocityScale);
					Graphics.Blit(temporary, destination, motionBlurMaterial, 1);
				}
				else if (filterType == MotionBlurFilter.ReconstructionDX11 && !flag)
				{
					dx11MotionBlurMaterial.SetFloat("_MinVelocity", minVelocity);
					dx11MotionBlurMaterial.SetFloat("_VelocityScale", velocityScale);
					dx11MotionBlurMaterial.SetFloat("_Jitter", jitter);
					dx11MotionBlurMaterial.SetTexture("_NoiseTex", noiseTexture);
					dx11MotionBlurMaterial.SetTexture("_VelTex", temporary);
					dx11MotionBlurMaterial.SetTexture("_NeighbourMaxTex", temporary3);
					dx11MotionBlurMaterial.SetFloat("_SoftZDistance", Mathf.Max(0.00025f, softZDistance));
					dx11MotionBlurMaterial.SetFloat("_MaxRadiusOrKInPaper", num3);
					Graphics.Blit(temporary, temporary2, dx11MotionBlurMaterial, 0);
					Graphics.Blit(temporary2, temporary3, dx11MotionBlurMaterial, 1);
					Graphics.Blit(source, destination, dx11MotionBlurMaterial, 2);
				}
				else if (filterType == MotionBlurFilter.Reconstruction || flag)
				{
					motionBlurMaterial.SetFloat("_SoftZDistance", Mathf.Max(0.00025f, softZDistance));
					Graphics.Blit(temporary, temporary2, motionBlurMaterial, 2);
					Graphics.Blit(temporary2, temporary3, motionBlurMaterial, 3);
					Graphics.Blit(source, destination, motionBlurMaterial, 4);
				}
				else if (filterType == MotionBlurFilter.CameraMotion)
				{
					Graphics.Blit(source, destination, motionBlurMaterial, 6);
				}
				else if (filterType == MotionBlurFilter.ReconstructionDisc)
				{
					motionBlurMaterial.SetFloat("_SoftZDistance", Mathf.Max(0.00025f, softZDistance));
					Graphics.Blit(temporary, temporary2, motionBlurMaterial, 2);
					Graphics.Blit(temporary2, temporary3, motionBlurMaterial, 3);
					Graphics.Blit(source, destination, motionBlurMaterial, 7);
				}
				else
				{
					Graphics.Blit(source, destination, motionBlurMaterial, 5);
				}
				RenderTexture.ReleaseTemporary(temporary);
				RenderTexture.ReleaseTemporary(temporary2);
				RenderTexture.ReleaseTemporary(temporary3);
			}

			private void Remember()
			{
				prevViewProjMat = currentViewProjMat;
				prevFrameForward = base.transform.forward;
				prevFrameUp = base.transform.up;
				prevFramePos = base.transform.position;
				prevStereoViewProjMat[0] = currentStereoViewProjMat[0];
				prevStereoViewProjMat[1] = currentStereoViewProjMat[1];
			}

			private Camera GetTmpCam()
			{
				if (tmpCam == null)
				{
					string text = "_" + _camera.name + "_MotionBlurTmpCam";
					GameObject gameObject = GameObject.Find(text);
					if (null == gameObject)
					{
						tmpCam = new GameObject(text, typeof(Camera));
					}
					else
					{
						tmpCam = gameObject;
					}
				}
				tmpCam.hideFlags = HideFlags.DontSave;
				tmpCam.transform.position = _camera.transform.position;
				tmpCam.transform.rotation = _camera.transform.rotation;
				tmpCam.transform.localScale = _camera.transform.localScale;
				tmpCam.GetComponent<Camera>().CopyFrom(_camera);
				tmpCam.GetComponent<Camera>().enabled = false;
				tmpCam.GetComponent<Camera>().depthTextureMode = DepthTextureMode.None;
				tmpCam.GetComponent<Camera>().clearFlags = CameraClearFlags.Nothing;
				return tmpCam.GetComponent<Camera>();
			}

			private void StartFrame()
			{
				prevFramePos = Vector3.Slerp(prevFramePos, base.transform.position, 0.75f);
			}

			private static int divRoundUp(int x, int d)
			{
				return (x + d - 1) / d;
			}
		}
		[ExecuteInEditMode]
		[AddComponentMenu("Image Effects/Color Adjustments/Color Correction (Curves, Saturation)")]
		public class ColorCorrectionCurves : PostEffectsBase
		{
			public enum ColorCorrectionMode
			{
				Simple,
				Advanced
			}

			public AnimationCurve redChannel = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1f, 1f));

			public AnimationCurve greenChannel = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1f, 1f));

			public AnimationCurve blueChannel = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1f, 1f));

			public bool useDepthCorrection;

			public AnimationCurve zCurve = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1f, 1f));

			public AnimationCurve depthRedChannel = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1f, 1f));

			public AnimationCurve depthGreenChannel = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1f, 1f));

			public AnimationCurve depthBlueChannel = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1f, 1f));

			private Material ccMaterial;

			private Material ccDepthMaterial;

			private Material selectiveCcMaterial;

			private Texture2D rgbChannelTex;

			private Texture2D rgbDepthChannelTex;

			private Texture2D zCurveTex;

			public float saturation = 1f;

			public bool selectiveCc;

			public Color selectiveFromColor = Color.white;

			public Color selectiveToColor = Color.white;

			public ColorCorrectionMode mode;

			public bool updateTextures = true;

			public Shader colorCorrectionCurvesShader;

			public Shader simpleColorCorrectionCurvesShader;

			public Shader colorCorrectionSelectiveShader;

			private bool updateTexturesOnStartup = true;

			private new void Start()
			{
				base.Start();
				updateTexturesOnStartup = true;
			}

			private void Awake()
			{
			}

			public override bool CheckResources()
			{
				CheckSupport(mode == ColorCorrectionMode.Advanced);
				ccMaterial = CheckShaderAndCreateMaterial(simpleColorCorrectionCurvesShader, ccMaterial);
				ccDepthMaterial = CheckShaderAndCreateMaterial(colorCorrectionCurvesShader, ccDepthMaterial);
				selectiveCcMaterial = CheckShaderAndCreateMaterial(colorCorrectionSelectiveShader, selectiveCcMaterial);
				if (!rgbChannelTex)
				{
					rgbChannelTex = new Texture2D(256, 4, TextureFormat.ARGB32, mipChain: false, linear: true);
				}
				if (!rgbDepthChannelTex)
				{
					rgbDepthChannelTex = new Texture2D(256, 4, TextureFormat.ARGB32, mipChain: false, linear: true);
				}
				if (!zCurveTex)
				{
					zCurveTex = new Texture2D(256, 1, TextureFormat.ARGB32, mipChain: false, linear: true);
				}
				rgbChannelTex.hideFlags = HideFlags.DontSave;
				rgbDepthChannelTex.hideFlags = HideFlags.DontSave;
				zCurveTex.hideFlags = HideFlags.DontSave;
				rgbChannelTex.wrapMode = TextureWrapMode.Clamp;
				rgbDepthChannelTex.wrapMode = TextureWrapMode.Clamp;
				zCurveTex.wrapMode = TextureWrapMode.Clamp;
				if (!isSupported)
				{
					ReportAutoDisable();
				}
				return isSupported;
			}

			public void UpdateParameters()
			{
				CheckResources();
				if (redChannel != null && greenChannel != null && blueChannel != null)
				{
					for (float num = 0f; num <= 1f; num += 0.003921569f)
					{
						float num2 = Mathf.Clamp(redChannel.Evaluate(num), 0f, 1f);
						float num3 = Mathf.Clamp(greenChannel.Evaluate(num), 0f, 1f);
						float num4 = Mathf.Clamp(blueChannel.Evaluate(num), 0f, 1f);
						rgbChannelTex.SetPixel((int)Mathf.Floor(num * 255f), 0, new Color(num2, num2, num2));
						rgbChannelTex.SetPixel((int)Mathf.Floor(num * 255f), 1, new Color(num3, num3, num3));
						rgbChannelTex.SetPixel((int)Mathf.Floor(num * 255f), 2, new Color(num4, num4, num4));
						float num5 = Mathf.Clamp(zCurve.Evaluate(num), 0f, 1f);
						zCurveTex.SetPixel((int)Mathf.Floor(num * 255f), 0, new Color(num5, num5, num5));
						num2 = Mathf.Clamp(depthRedChannel.Evaluate(num), 0f, 1f);
						num3 = Mathf.Clamp(depthGreenChannel.Evaluate(num), 0f, 1f);
						num4 = Mathf.Clamp(depthBlueChannel.Evaluate(num), 0f, 1f);
						rgbDepthChannelTex.SetPixel((int)Mathf.Floor(num * 255f), 0, new Color(num2, num2, num2));
						rgbDepthChannelTex.SetPixel((int)Mathf.Floor(num * 255f), 1, new Color(num3, num3, num3));
						rgbDepthChannelTex.SetPixel((int)Mathf.Floor(num * 255f), 2, new Color(num4, num4, num4));
					}
					rgbChannelTex.Apply();
					rgbDepthChannelTex.Apply();
					zCurveTex.Apply();
				}
			}

			private void UpdateTextures()
			{
				UpdateParameters();
			}

			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (!CheckResources())
				{
					Graphics.Blit(source, destination);
					return;
				}
				if (updateTexturesOnStartup)
				{
					UpdateParameters();
					updateTexturesOnStartup = false;
				}
				if (useDepthCorrection)
				{
					GetComponent<Camera>().depthTextureMode |= DepthTextureMode.Depth;
				}
				RenderTexture renderTexture = destination;
				if (selectiveCc)
				{
					renderTexture = RenderTexture.GetTemporary(source.width, source.height);
				}
				if (useDepthCorrection)
				{
					ccDepthMaterial.SetTexture("_RgbTex", rgbChannelTex);
					ccDepthMaterial.SetTexture("_ZCurve", zCurveTex);
					ccDepthMaterial.SetTexture("_RgbDepthTex", rgbDepthChannelTex);
					ccDepthMaterial.SetFloat("_Saturation", saturation);
					Graphics.Blit(source, renderTexture, ccDepthMaterial);
				}
				else
				{
					ccMaterial.SetTexture("_RgbTex", rgbChannelTex);
					ccMaterial.SetFloat("_Saturation", saturation);
					Graphics.Blit(source, renderTexture, ccMaterial);
				}
				if (selectiveCc)
				{
					selectiveCcMaterial.SetColor("selColor", selectiveFromColor);
					selectiveCcMaterial.SetColor("targetColor", selectiveToColor);
					Graphics.Blit(renderTexture, destination, selectiveCcMaterial);
					RenderTexture.ReleaseTemporary(renderTexture);
				}
			}
		}
		[ExecuteInEditMode]
		[AddComponentMenu("Image Effects/Color Adjustments/Color Correction (3D Lookup Texture)")]
		public class ColorCorrectionLookup : PostEffectsBase
		{
			public Shader shader;

			private Material material;

			public Texture3D converted3DLut;

			public string basedOnTempTex = "";

			public override bool CheckResources()
			{
				CheckSupport(needDepth: false);
				material = CheckShaderAndCreateMaterial(shader, material);
				if (!isSupported || !SystemInfo.supports3DTextures)
				{
					ReportAutoDisable();
				}
				return isSupported;
			}

			private void OnDisable()
			{
				if ((bool)material)
				{
					UnityEngine.Object.DestroyImmediate(material);
					material = null;
				}
			}

			private void OnDestroy()
			{
				if ((bool)converted3DLut)
				{
					UnityEngine.Object.DestroyImmediate(converted3DLut);
				}
				converted3DLut = null;
			}

			public void SetIdentityLut()
			{
				int num = 16;
				Color[] array = new Color[num * num * num];
				float num2 = 1f / (1f * (float)num - 1f);
				for (int i = 0; i < num; i++)
				{
					for (int j = 0; j < num; j++)
					{
						for (int k = 0; k < num; k++)
						{
							array[i + j * num + k * num * num] = new Color((float)i * 1f * num2, (float)j * 1f * num2, (float)k * 1f * num2, 1f);
						}
					}
				}
				if ((bool)converted3DLut)
				{
					UnityEngine.Object.DestroyImmediate(converted3DLut);
				}
				converted3DLut = new Texture3D(num, num, num, TextureFormat.ARGB32, mipChain: false);
				converted3DLut.SetPixels(array);
				converted3DLut.Apply();
				basedOnTempTex = "";
			}

			public bool ValidDimensions(Texture2D tex2d)
			{
				if (!tex2d)
				{
					return false;
				}
				if (tex2d.height != Mathf.FloorToInt(Mathf.Sqrt(tex2d.width)))
				{
					return false;
				}
				return true;
			}

			public void Convert(Texture2D temp2DTex, string path)
			{
				if ((bool)temp2DTex)
				{
					int num = temp2DTex.width * temp2DTex.height;
					num = temp2DTex.height;
					if (!ValidDimensions(temp2DTex))
					{
						UnityEngine.Debug.LogWarning("The given 2D texture " + temp2DTex.name + " cannot be used as a 3D LUT.");
						basedOnTempTex = "";
						return;
					}
					Color[] pixels = temp2DTex.GetPixels();
					Color[] array = new Color[pixels.Length];
					for (int i = 0; i < num; i++)
					{
						for (int j = 0; j < num; j++)
						{
							for (int k = 0; k < num; k++)
							{
								int num2 = num - j - 1;
								array[i + j * num + k * num * num] = pixels[k * num + i + num2 * num * num];
							}
						}
					}
					if ((bool)converted3DLut)
					{
						UnityEngine.Object.DestroyImmediate(converted3DLut);
					}
					converted3DLut = new Texture3D(num, num, num, TextureFormat.ARGB32, mipChain: false);
					converted3DLut.SetPixels(array);
					converted3DLut.Apply();
					basedOnTempTex = path;
				}
				else
				{
					UnityEngine.Debug.LogError("Couldn't color correct with 3D LUT texture. Image Effect will be disabled.");
				}
			}

			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (!CheckResources() || !SystemInfo.supports3DTextures)
				{
					Graphics.Blit(source, destination);
					return;
				}
				if (converted3DLut == null)
				{
					SetIdentityLut();
				}
				int width = converted3DLut.width;
				converted3DLut.wrapMode = TextureWrapMode.Clamp;
				material.SetFloat("_Scale", (float)(width - 1) / (1f * (float)width));
				material.SetFloat("_Offset", 1f / (2f * (float)width));
				material.SetTexture("_ClutTex", converted3DLut);
				Graphics.Blit(source, destination, material, (QualitySettings.activeColorSpace == ColorSpace.Linear) ? 1 : 0);
			}
		}
		[ExecuteInEditMode]
		[AddComponentMenu("Image Effects/Color Adjustments/Color Correction (Ramp)")]
		public class ColorCorrectionRamp : ImageEffectBase
		{
			public Texture textureRamp;

			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				base.material.SetTexture("_RampTex", textureRamp);
				Graphics.Blit(source, destination, base.material);
			}
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(Camera))]
		[AddComponentMenu("Image Effects/Color Adjustments/Contrast Enhance (Unsharp Mask)")]
		public class ContrastEnhance : PostEffectsBase
		{
			[Range(0f, 1f)]
			public float intensity = 0.5f;

			[Range(0f, 0.999f)]
			public float threshold;

			private Material separableBlurMaterial;

			private Material contrastCompositeMaterial;

			[Range(0f, 1f)]
			public float blurSpread = 1f;

			public Shader separableBlurShader;

			public Shader contrastCompositeShader;

			public override bool CheckResources()
			{
				CheckSupport(needDepth: false);
				contrastCompositeMaterial = CheckShaderAndCreateMaterial(contrastCompositeShader, contrastCompositeMaterial);
				separableBlurMaterial = CheckShaderAndCreateMaterial(separableBlurShader, separableBlurMaterial);
				if (!isSupported)
				{
					ReportAutoDisable();
				}
				return isSupported;
			}

			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (!CheckResources())
				{
					Graphics.Blit(source, destination);
					return;
				}
				int width = source.width;
				int height = source.height;
				RenderTexture temporary = RenderTexture.GetTemporary(width / 2, height / 2, 0);
				Graphics.Blit(source, temporary);
				RenderTexture temporary2 = RenderTexture.GetTemporary(width / 4, height / 4, 0);
				Graphics.Blit(temporary, temporary2);
				RenderTexture.ReleaseTemporary(temporary);
				separableBlurMaterial.SetVector("offsets", new Vector4(0f, blurSpread * 1f / (float)temporary2.height, 0f, 0f));
				RenderTexture temporary3 = RenderTexture.GetTemporary(width / 4, height / 4, 0);
				Graphics.Blit(temporary2, temporary3, separableBlurMaterial);
				RenderTexture.ReleaseTemporary(temporary2);
				separableBlurMaterial.SetVector("offsets", new Vector4(blurSpread * 1f / (float)temporary2.width, 0f, 0f, 0f));
				temporary2 = RenderTexture.GetTemporary(width / 4, height / 4, 0);
				Graphics.Blit(temporary3, temporary2, separableBlurMaterial);
				RenderTexture.ReleaseTemporary(temporary3);
				contrastCompositeMaterial.SetTexture("_MainTexBlurred", temporary2);
				contrastCompositeMaterial.SetFloat("intensity", intensity);
				contrastCompositeMaterial.SetFloat("threshold", threshold);
				Graphics.Blit(source, destination, contrastCompositeMaterial);
				RenderTexture.ReleaseTemporary(temporary2);
			}
		}
		[ExecuteInEditMode]
		[AddComponentMenu("Image Effects/Color Adjustments/Contrast Stretch")]
		public class ContrastStretch : MonoBehaviour
		{
			[Range(0.0001f, 1f)]
			public float adaptationSpeed = 0.02f;

			[Range(0f, 1f)]
			public float limitMinimum = 0.2f;

			[Range(0f, 1f)]
			public float limitMaximum = 0.6f;

			private RenderTexture[] adaptRenderTex = new RenderTexture[2];

			private int curAdaptIndex;

			public Shader shaderLum;

			private Material m_materialLum;

			public Shader shaderReduce;

			private Material m_materialReduce;

			public Shader shaderAdapt;

			private Material m_materialAdapt;

			public Shader shaderApply;

			private Material m_materialApply;

			protected Material materialLum
			{
				get
				{
					if (m_materialLum == null)
					{
						m_materialLum = new Material(shaderLum);
						m_materialLum.hideFlags = HideFlags.HideAndDontSave;
					}
					return m_materialLum;
				}
			}

			protected Material materialReduce
			{
				get
				{
					if (m_materialReduce == null)
					{
						m_materialReduce = new Material(shaderReduce);
						m_materialReduce.hideFlags = HideFlags.HideAndDontSave;
					}
					return m_materialReduce;
				}
			}

			protected Material materialAdapt
			{
				get
				{
					if (m_materialAdapt == null)
					{
						m_materialAdapt = new Material(shaderAdapt);
						m_materialAdapt.hideFlags = HideFlags.HideAndDontSave;
					}
					return m_materialAdapt;
				}
			}

			protected Material materialApply
			{
				get
				{
					if (m_materialApply == null)
					{
						m_materialApply = new Material(shaderApply);
						m_materialApply.hideFlags = HideFlags.HideAndDontSave;
					}
					return m_materialApply;
				}
			}

			private void Start()
			{
				if (!SystemInfo.supportsImageEffects)
				{
					base.enabled = false;
				}
				else if (!shaderAdapt.isSupported || !shaderApply.isSupported || !shaderLum.isSupported || !shaderReduce.isSupported)
				{
					base.enabled = false;
				}
			}

			private void OnEnable()
			{
				for (int i = 0; i < 2; i++)
				{
					if (!adaptRenderTex[i])
					{
						adaptRenderTex[i] = new RenderTexture(1, 1, 0);
						adaptRenderTex[i].hideFlags = HideFlags.HideAndDontSave;
					}
				}
			}

			private void OnDisable()
			{
				for (int i = 0; i < 2; i++)
				{
					UnityEngine.Object.DestroyImmediate(adaptRenderTex[i]);
					adaptRenderTex[i] = null;
				}
				if ((bool)m_materialLum)
				{
					UnityEngine.Object.DestroyImmediate(m_materialLum);
				}
				if ((bool)m_materialReduce)
				{
					UnityEngine.Object.DestroyImmediate(m_materialReduce);
				}
				if ((bool)m_materialAdapt)
				{
					UnityEngine.Object.DestroyImmediate(m_materialAdapt);
				}
				if ((bool)m_materialApply)
				{
					UnityEngine.Object.DestroyImmediate(m_materialApply);
				}
			}

			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				RenderTexture renderTexture = RenderTexture.GetTemporary(source.width / 1, source.height / 1);
				Graphics.Blit(source, renderTexture, materialLum);
				while (renderTexture.width > 1 || renderTexture.height > 1)
				{
					int num = renderTexture.width / 2;
					if (num < 1)
					{
						num = 1;
					}
					int num2 = renderTexture.height / 2;
					if (num2 < 1)
					{
						num2 = 1;
					}
					RenderTexture temporary = RenderTexture.GetTemporary(num, num2);
					Graphics.Blit(renderTexture, temporary, materialReduce);
					RenderTexture.ReleaseTemporary(renderTexture);
					renderTexture = temporary;
				}
				CalculateAdaptation(renderTexture);
				materialApply.SetTexture("_AdaptTex", adaptRenderTex[curAdaptIndex]);
				Graphics.Blit(source, destination, materialApply);
				RenderTexture.ReleaseTemporary(renderTexture);
			}

			private void CalculateAdaptation(Texture curTexture)
			{
				int num = curAdaptIndex;
				curAdaptIndex = (curAdaptIndex + 1) % 2;
				float value = 1f - Mathf.Pow(1f - adaptationSpeed, 30f * Time.deltaTime);
				value = Mathf.Clamp(value, 0.01f, 1f);
				materialAdapt.SetTexture("_CurTex", curTexture);
				materialAdapt.SetVector("_AdaptParams", new Vector4(value, limitMinimum, limitMaximum, 0f));
				Graphics.SetRenderTarget(adaptRenderTex[curAdaptIndex]);
				GL.Clear(clearDepth: false, clearColor: true, Color.black);
				Graphics.Blit(adaptRenderTex[num], adaptRenderTex[curAdaptIndex], materialAdapt);
			}
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(Camera))]
		[AddComponentMenu("Image Effects/Edge Detection/Crease Shading")]
		public class CreaseShading : PostEffectsBase
		{
			public float intensity = 0.5f;

			public int softness = 1;

			public float spread = 1f;

			public Shader blurShader;

			private Material blurMaterial;

			public Shader depthFetchShader;

			private Material depthFetchMaterial;

			public Shader creaseApplyShader;

			private Material creaseApplyMaterial;

			public override bool CheckResources()
			{
				CheckSupport(needDepth: true);
				blurMaterial = CheckShaderAndCreateMaterial(blurShader, blurMaterial);
				depthFetchMaterial = CheckShaderAndCreateMaterial(depthFetchShader, depthFetchMaterial);
				creaseApplyMaterial = CheckShaderAndCreateMaterial(creaseApplyShader, creaseApplyMaterial);
				if (!isSupported)
				{
					ReportAutoDisable();
				}
				return isSupported;
			}

			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (!CheckResources())
				{
					Graphics.Blit(source, destination);
					return;
				}
				int width = source.width;
				int height = source.height;
				float num = 1f * (float)width / (1f * (float)height);
				float num2 = 0.001953125f;
				RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0);
				RenderTexture renderTexture = RenderTexture.GetTemporary(width / 2, height / 2, 0);
				Graphics.Blit(source, temporary, depthFetchMaterial);
				Graphics.Blit(temporary, renderTexture);
				for (int i = 0; i < softness; i++)
				{
					RenderTexture temporary2 = RenderTexture.GetTemporary(width / 2, height / 2, 0);
					blurMaterial.SetVector("offsets", new Vector4(0f, spread * num2, 0f, 0f));
					Graphics.Blit(renderTexture, temporary2, blurMaterial);
					RenderTexture.ReleaseTemporary(renderTexture);
					renderTexture = temporary2;
					temporary2 = RenderTexture.GetTemporary(width / 2, height / 2, 0);
					blurMaterial.SetVector("offsets", new Vector4(spread * num2 / num, 0f, 0f, 0f));
					Graphics.Blit(renderTexture, temporary2, blurMaterial);
					RenderTexture.ReleaseTemporary(renderTexture);
					renderTexture = temporary2;
				}
				creaseApplyMaterial.SetTexture("_HrDepthTex", temporary);
				creaseApplyMaterial.SetTexture("_LrDepthTex", renderTexture);
				creaseApplyMaterial.SetFloat("intensity", intensity);
				Graphics.Blit(source, destination, creaseApplyMaterial);
				RenderTexture.ReleaseTemporary(temporary);
				RenderTexture.ReleaseTemporary(renderTexture);
			}
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(Camera))]
		[AddComponentMenu("Image Effects/Camera/Depth of Field (Lens Blur, Scatter, DX11)")]
		public class DepthOfField : PostEffectsBase
		{
			public enum BlurType
			{
				DiscBlur,
				DX11
			}

			public enum BlurSampleCount
			{
				Low,
				Medium,
				High
			}

			public bool visualizeFocus;

			public float focalLength = 10f;

			public float focalSize = 0.05f;

			public float aperture = 0.5f;

			public Transform focalTransform;

			public float maxBlurSize = 2f;

			public bool highResolution;

			public BlurType blurType;

			public BlurSampleCount blurSampleCount = BlurSampleCount.High;

			public bool nearBlur;

			public float foregroundOverlap = 1f;

			public Shader dofHdrShader;

			private Material dofHdrMaterial;

			public Shader dx11BokehShader;

			private Material dx11bokehMaterial;

			public float dx11BokehThreshold = 0.5f;

			public float dx11SpawnHeuristic = 0.0875f;

			public Texture2D dx11BokehTexture;

			public float dx11BokehScale = 1.2f;

			public float dx11BokehIntensity = 2.5f;

			private float focalDistance01 = 10f;

			private ComputeBuffer cbDrawArgs;

			private ComputeBuffer cbPoints;

			private float internalBlurWidth = 1f;

			private Camera cachedCamera;

			public override bool CheckResources()
			{
				CheckSupport(needDepth: true);
				dofHdrMaterial = CheckShaderAndCreateMaterial(dofHdrShader, dofHdrMaterial);
				if (supportDX11 && blurType == BlurType.DX11)
				{
					dx11bokehMaterial = CheckShaderAndCreateMaterial(dx11BokehShader, dx11bokehMaterial);
					CreateComputeResources();
				}
				if (!isSupported)
				{
					ReportAutoDisable();
				}
				return isSupported;
			}

			private void OnEnable()
			{
				cachedCamera = GetComponent<Camera>();
				cachedCamera.depthTextureMode |= DepthTextureMode.Depth;
			}

			private void OnDisable()
			{
				ReleaseComputeResources();
				if ((bool)dofHdrMaterial)
				{
					UnityEngine.Object.DestroyImmediate(dofHdrMaterial);
				}
				dofHdrMaterial = null;
				if ((bool)dx11bokehMaterial)
				{
					UnityEngine.Object.DestroyImmediate(dx11bokehMaterial);
				}
				dx11bokehMaterial = null;
			}

			private void ReleaseComputeResources()
			{
				if (cbDrawArgs != null)
				{
					cbDrawArgs.Release();
				}
				cbDrawArgs = null;
				if (cbPoints != null)
				{
					cbPoints.Release();
				}
				cbPoints = null;
			}

			private void CreateComputeResources()
			{
				if (cbDrawArgs == null)
				{
					cbDrawArgs = new ComputeBuffer(1, 16, ComputeBufferType.DrawIndirect);
					int[] data = new int[4] { 0, 1, 0, 0 };
					cbDrawArgs.SetData(data);
				}
				if (cbPoints == null)
				{
					cbPoints = new ComputeBuffer(90000, 28, ComputeBufferType.Append);
				}
			}

			private float FocalDistance01(float worldDist)
			{
				return cachedCamera.WorldToViewportPoint((worldDist - cachedCamera.nearClipPlane) * cachedCamera.transform.forward + cachedCamera.transform.position).z / (cachedCamera.farClipPlane - cachedCamera.nearClipPlane);
			}

			private void WriteCoc(RenderTexture fromTo, bool fgDilate)
			{
				dofHdrMaterial.SetTexture("_FgOverlap", null);
				if (nearBlur && fgDilate)
				{
					int width = fromTo.width / 2;
					int height = fromTo.height / 2;
					RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0, fromTo.format);
					Graphics.Blit(fromTo, temporary, dofHdrMaterial, 4);
					float num = internalBlurWidth * foregroundOverlap;
					dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, num, 0f, num));
					RenderTexture temporary2 = RenderTexture.GetTemporary(width, height, 0, fromTo.format);
					Graphics.Blit(temporary, temporary2, dofHdrMaterial, 2);
					RenderTexture.ReleaseTemporary(temporary);
					dofHdrMaterial.SetVector("_Offsets", new Vector4(num, 0f, 0f, num));
					temporary = RenderTexture.GetTemporary(width, height, 0, fromTo.format);
					Graphics.Blit(temporary2, temporary, dofHdrMaterial, 2);
					RenderTexture.ReleaseTemporary(temporary2);
					dofHdrMaterial.SetTexture("_FgOverlap", temporary);
					fromTo.MarkRestoreExpected();
					Graphics.Blit(fromTo, fromTo, dofHdrMaterial, 13);
					RenderTexture.ReleaseTemporary(temporary);
				}
				else
				{
					fromTo.MarkRestoreExpected();
					Graphics.Blit(fromTo, fromTo, dofHdrMaterial, 0);
				}
			}

			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (!CheckResources())
				{
					Graphics.Blit(source, destination);
					return;
				}
				if (aperture < 0f)
				{
					aperture = 0f;
				}
				if (maxBlurSize < 0.1f)
				{
					maxBlurSize = 0.1f;
				}
				focalSize = Mathf.Clamp(focalSize, 0f, 2f);
				internalBlurWidth = Mathf.Max(maxBlurSize, 0f);
				focalDistance01 = (focalTransform ? (cachedCamera.WorldToViewportPoint(focalTransform.position).z / cachedCamera.farClipPlane) : FocalDistance01(focalLength));
				dofHdrMaterial.SetVector("_CurveParams", new Vector4(1f, focalSize, 1f / (1f - aperture) - 1f, focalDistance01));
				RenderTexture renderTexture = null;
				RenderTexture renderTexture2 = null;
				RenderTexture renderTexture3 = null;
				RenderTexture renderTexture4 = null;
				float num = internalBlurWidth * foregroundOverlap;
				if (visualizeFocus)
				{
					WriteCoc(source, fgDilate: true);
					Graphics.Blit(source, destination, dofHdrMaterial, 16);
				}
				else if (blurType == BlurType.DX11 && (bool)dx11bokehMaterial)
				{
					if (highResolution)
					{
						internalBlurWidth = ((internalBlurWidth < 0.1f) ? 0.1f : internalBlurWidth);
						num = internalBlurWidth * foregroundOverlap;
						renderTexture = RenderTexture.GetTemporary(source.width, source.height, 0, source.format);
						RenderTexture temporary = RenderTexture.GetTemporary(source.width, source.height, 0, source.format);
						WriteCoc(source, fgDilate: false);
						renderTexture3 = RenderTexture.GetTemporary(source.width >> 1, source.height >> 1, 0, source.format);
						renderTexture4 = RenderTexture.GetTemporary(source.width >> 1, source.height >> 1, 0, source.format);
						Graphics.Blit(source, renderTexture3, dofHdrMaterial, 15);
						dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, 1.5f, 0f, 1.5f));
						Graphics.Blit(renderTexture3, renderTexture4, dofHdrMaterial, 19);
						dofHdrMaterial.SetVector("_Offsets", new Vector4(1.5f, 0f, 0f, 1.5f));
						Graphics.Blit(renderTexture4, renderTexture3, dofHdrMaterial, 19);
						if (nearBlur)
						{
							Graphics.Blit(source, renderTexture4, dofHdrMaterial, 4);
						}
						dx11bokehMaterial.SetTexture("_BlurredColor", renderTexture3);
						dx11bokehMaterial.SetFloat("_SpawnHeuristic", dx11SpawnHeuristic);
						dx11bokehMaterial.SetVector("_BokehParams", new Vector4(dx11BokehScale, dx11BokehIntensity, Mathf.Clamp(dx11BokehThreshold, 0.005f, 4f), internalBlurWidth));
						dx11bokehMaterial.SetTexture("_FgCocMask", nearBlur ? renderTexture4 : null);
						Graphics.SetRandomWriteTarget(1, cbPoints);
						Graphics.Blit(source, renderTexture, dx11bokehMaterial, 0);
						Graphics.ClearRandomWriteTargets();
						if (nearBlur)
						{
							dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, num, 0f, num));
							Graphics.Blit(renderTexture4, renderTexture3, dofHdrMaterial, 2);
							dofHdrMaterial.SetVector("_Offsets", new Vector4(num, 0f, 0f, num));
							Graphics.Blit(renderTexture3, renderTexture4, dofHdrMaterial, 2);
							Graphics.Blit(renderTexture4, renderTexture, dofHdrMaterial, 3);
						}
						Graphics.Blit(renderTexture, temporary, dofHdrMaterial, 20);
						dofHdrMaterial.SetVector("_Offsets", new Vector4(internalBlurWidth, 0f, 0f, internalBlurWidth));
						Graphics.Blit(renderTexture, source, dofHdrMaterial, 5);
						dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, internalBlurWidth, 0f, internalBlurWidth));
						Graphics.Blit(source, temporary, dofHdrMaterial, 21);
						Graphics.SetRenderTarget(temporary);
						ComputeBuffer.CopyCount(cbPoints, cbDrawArgs, 0);
						dx11bokehMaterial.SetBuffer("pointBuffer", cbPoints);
						dx11bokehMaterial.SetTexture("_MainTex", dx11BokehTexture);
						dx11bokehMaterial.SetVector("_Screen", new Vector3(1f / (1f * (float)source.width), 1f / (1f * (float)source.height), internalBlurWidth));
						dx11bokehMaterial.SetPass(2);
						Graphics.DrawProceduralIndirectNow(MeshTopology.Points, cbDrawArgs);
						Graphics.Blit(temporary, destination);
						RenderTexture.ReleaseTemporary(temporary);
						RenderTexture.ReleaseTemporary(renderTexture3);
						RenderTexture.ReleaseTemporary(renderTexture4);
					}
					else
					{
						renderTexture = RenderTexture.GetTemporary(source.width >> 1, source.height >> 1, 0, source.format);
						renderTexture2 = RenderTexture.GetTemporary(source.width >> 1, source.height >> 1, 0, source.format);
						num = internalBlurWidth * foregroundOverlap;
						WriteCoc(source, fgDilate: false);
						source.filterMode = FilterMode.Bilinear;
						Graphics.Blit(source, renderTexture, dofHdrMaterial, 6);
						renderTexture3 = RenderTexture.GetTemporary(renderTexture.width >> 1, renderTexture.height >> 1, 0, renderTexture.format);
						renderTexture4 = RenderTexture.GetTemporary(renderTexture.width >> 1, renderTexture.height >> 1, 0, renderTexture.format);
						Graphics.Blit(renderTexture, renderTexture3, dofHdrMaterial, 15);
						dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, 1.5f, 0f, 1.5f));
						Graphics.Blit(renderTexture3, renderTexture4, dofHdrMaterial, 19);
						dofHdrMaterial.SetVector("_Offsets", new Vector4(1.5f, 0f, 0f, 1.5f));
						Graphics.Blit(renderTexture4, renderTexture3, dofHdrMaterial, 19);
						RenderTexture renderTexture5 = null;
						if (nearBlur)
						{
							renderTexture5 = RenderTexture.GetTemporary(source.width >> 1, source.height >> 1, 0, source.format);
							Graphics.Blit(source, renderTexture5, dofHdrMaterial, 4);
						}
						dx11bokehMaterial.SetTexture("_BlurredColor", renderTexture3);
						dx11bokehMaterial.SetFloat("_SpawnHeuristic", dx11SpawnHeuristic);
						dx11bokehMaterial.SetVector("_BokehParams", new Vector4(dx11BokehScale, dx11BokehIntensity, Mathf.Clamp(dx11BokehThreshold, 0.005f, 4f), internalBlurWidth));
						dx11bokehMaterial.SetTexture("_FgCocMask", renderTexture5);
						Graphics.SetRandomWriteTarget(1, cbPoints);
						Graphics.Blit(renderTexture, renderTexture2, dx11bokehMaterial, 0);
						Graphics.ClearRandomWriteTargets();
						RenderTexture.ReleaseTemporary(renderTexture3);
						RenderTexture.ReleaseTemporary(renderTexture4);
						if (nearBlur)
						{
							dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, num, 0f, num));
							Graphics.Blit(renderTexture5, renderTexture, dofHdrMaterial, 2);
							dofHdrMaterial.SetVector("_Offsets", new Vector4(num, 0f, 0f, num));
							Graphics.Blit(renderTexture, renderTexture5, dofHdrMaterial, 2);
							Graphics.Blit(renderTexture5, renderTexture2, dofHdrMaterial, 3);
						}
						dofHdrMaterial.SetVector("_Offsets", new Vector4(internalBlurWidth, 0f, 0f, internalBlurWidth));
						Graphics.Blit(renderTexture2, renderTexture, dofHdrMaterial, 5);
						dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, internalBlurWidth, 0f, internalBlurWidth));
						Graphics.Blit(renderTexture, renderTexture2, dofHdrMaterial, 5);
						Graphics.SetRenderTarget(renderTexture2);
						ComputeBuffer.CopyCount(cbPoints, cbDrawArgs, 0);
						dx11bokehMaterial.SetBuffer("pointBuffer", cbPoints);
						dx11bokehMaterial.SetTexture("_MainTex", dx11BokehTexture);
						dx11bokehMaterial.SetVector("_Screen", new Vector3(1f / (1f * (float)renderTexture2.width), 1f / (1f * (float)renderTexture2.height), internalBlurWidth));
						dx11bokehMaterial.SetPass(1);
						Graphics.DrawProceduralIndirectNow(MeshTopology.Points, cbDrawArgs);
						dofHdrMaterial.SetTexture("_LowRez", renderTexture2);
						dofHdrMaterial.SetTexture("_FgOverlap", renderTexture5);
						dofHdrMaterial.SetVector("_Offsets", 1f * (float)source.width / (1f * (float)renderTexture2.width) * internalBlurWidth * Vector4.one);
						Graphics.Blit(source, destination, dofHdrMaterial, 9);
						if ((bool)renderTexture5)
						{
							RenderTexture.ReleaseTemporary(renderTexture5);
						}
					}
				}
				else
				{
					source.filterMode = FilterMode.Bilinear;
					if (highResolution)
					{
						internalBlurWidth *= 2f;
					}
					WriteCoc(source, fgDilate: true);
					renderTexture = RenderTexture.GetTemporary(source.width >> 1, source.height >> 1, 0, source.format);
					renderTexture2 = RenderTexture.GetTemporary(source.width >> 1, source.height >> 1, 0, source.format);
					int pass = ((blurSampleCount == BlurSampleCount.High || blurSampleCount == BlurSampleCount.Medium) ? 17 : 11);
					if (highResolution)
					{
						dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, internalBlurWidth, 0.025f, internalBlurWidth));
						Graphics.Blit(source, destination, dofHdrMaterial, pass);
					}
					else
					{
						dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, internalBlurWidth, 0.1f, internalBlurWidth));
						Graphics.Blit(source, renderTexture, dofHdrMaterial, 6);
						Graphics.Blit(renderTexture, renderTexture2, dofHdrMaterial, pass);
						dofHdrMaterial.SetTexture("_LowRez", renderTexture2);
						dofHdrMaterial.SetTexture("_FgOverlap", null);
						dofHdrMaterial.SetVector("_Offsets", Vector4.one * (1f * (float)source.width / (1f * (float)renderTexture2.width)) * internalBlurWidth);
						Graphics.Blit(source, destination, dofHdrMaterial, (blurSampleCount == BlurSampleCount.High) ? 18 : 12);
					}
				}
				if ((bool)renderTexture)
				{
					RenderTexture.ReleaseTemporary(renderTexture);
				}
				if ((bool)renderTexture2)
				{
					RenderTexture.ReleaseTemporary(renderTexture2);
				}
			}
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(Camera))]
		[AddComponentMenu("Image Effects/Camera/Depth of Field (deprecated)")]
		public class DepthOfFieldDeprecated : PostEffectsBase
		{
			public enum Dof34QualitySetting
			{
				OnlyBackground = 1,
				BackgroundAndForeground
			}

			public enum DofResolution
			{
				High = 2,
				Medium,
				Low
			}

			public enum DofBlurriness
			{
				Low = 1,
				High = 2,
				VeryHigh = 4
			}

			public enum BokehDestination
			{
				Background = 1,
				Foreground,
				BackgroundAndForeground
			}

			private static int SMOOTH_DOWNSAMPLE_PASS = 6;

			private static float BOKEH_EXTRA_BLUR = 2f;

			public Dof34QualitySetting quality = Dof34QualitySetting.OnlyBackground;

			public DofResolution resolution = DofResolution.Low;

			public bool simpleTweakMode = true;

			public float focalPoint = 1f;

			public float smoothness = 0.5f;

			public float focalZDistance;

			public float focalZStartCurve = 1f;

			public float focalZEndCurve = 1f;

			private float focalStartCurve = 2f;

			private float focalEndCurve = 2f;

			private float focalDistance01 = 0.1f;

			public Transform objectFocus;

			public float focalSize;

			public DofBlurriness bluriness = DofBlurriness.High;

			public float maxBlurSpread = 1.75f;

			public float foregroundBlurExtrude = 1.15f;

			public Shader dofBlurShader;

			private Material dofBlurMaterial;

			public Shader dofShader;

			private Material dofMaterial;

			public bool visualize;

			public BokehDestination bokehDestination = BokehDestination.Background;

			private float widthOverHeight = 1.25f;

			private float oneOverBaseSize = 0.001953125f;

			public bool bokeh;

			public bool bokehSupport = true;

			public Shader bokehShader;

			public Texture2D bokehTexture;

			public float bokehScale = 2.4f;

			public float bokehIntensity = 0.15f;

			public float bokehThresholdContrast = 0.1f;

			public float bokehThresholdLuminance = 0.55f;

			public int bokehDownsample = 1;

			private Material bokehMaterial;

			private Camera _camera;

			private RenderTexture foregroundTexture;

			private RenderTexture mediumRezWorkTexture;

			private RenderTexture finalDefocus;

			private RenderTexture lowRezWorkTexture;

			private RenderTexture bokehSource;

			private RenderTexture bokehSource2;

			private void CreateMaterials()
			{
				dofBlurMaterial = CheckShaderAndCreateMaterial(dofBlurShader, dofBlurMaterial);
				dofMaterial = CheckShaderAndCreateMaterial(dofShader, dofMaterial);
				bokehSupport = bokehShader.isSupported;
				if (bokeh && bokehSupport && (bool)bokehShader)
				{
					bokehMaterial = CheckShaderAndCreateMaterial(bokehShader, bokehMaterial);
				}
			}

			public override bool CheckResources()
			{
				CheckSupport(needDepth: true);
				dofBlurMaterial = CheckShaderAndCreateMaterial(dofBlurShader, dofBlurMaterial);
				dofMaterial = CheckShaderAndCreateMaterial(dofShader, dofMaterial);
				bokehSupport = bokehShader.isSupported;
				if (bokeh && bokehSupport && (bool)bokehShader)
				{
					bokehMaterial = CheckShaderAndCreateMaterial(bokehShader, bokehMaterial);
				}
				if (!isSupported)
				{
					ReportAutoDisable();
				}
				return isSupported;
			}

			private void OnDisable()
			{
				Quads.Cleanup();
			}

			private void OnEnable()
			{
				_camera = GetComponent<Camera>();
				_camera.depthTextureMode |= DepthTextureMode.Depth;
			}

			private float FocalDistance01(float worldDist)
			{
				return _camera.WorldToViewportPoint((worldDist - _camera.nearClipPlane) * _camera.transform.forward + _camera.transform.position).z / (_camera.farClipPlane - _camera.nearClipPlane);
			}

			private int GetDividerBasedOnQuality()
			{
				int result = 1;
				if (resolution == DofResolution.Medium)
				{
					result = 2;
				}
				else if (resolution == DofResolution.Low)
				{
					result = 2;
				}
				return result;
			}

			private int GetLowResolutionDividerBasedOnQuality(int baseDivider)
			{
				int num = baseDivider;
				if (resolution == DofResolution.High)
				{
					num *= 2;
				}
				if (resolution == DofResolution.Low)
				{
					num *= 2;
				}
				return num;
			}

			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (!CheckResources())
				{
					Graphics.Blit(source, destination);
					return;
				}
				if (smoothness < 0.1f)
				{
					smoothness = 0.1f;
				}
				bokeh = bokeh && bokehSupport;
				float num = (bokeh ? BOKEH_EXTRA_BLUR : 1f);
				bool flag = quality > Dof34QualitySetting.OnlyBackground;
				float num2 = focalSize / (_camera.farClipPlane - _camera.nearClipPlane);
				if (simpleTweakMode)
				{
					focalDistance01 = (objectFocus ? (_camera.WorldToViewportPoint(objectFocus.position).z / _camera.farClipPlane) : FocalDistance01(focalPoint));
					focalStartCurve = focalDistance01 * smoothness;
					focalEndCurve = focalStartCurve;
					flag = flag && focalPoint > _camera.nearClipPlane + Mathf.Epsilon;
				}
				else
				{
					if ((bool)objectFocus)
					{
						Vector3 vector = _camera.WorldToViewportPoint(objectFocus.position);
						vector.z /= _camera.farClipPlane;
						focalDistance01 = vector.z;
					}
					else
					{
						focalDistance01 = FocalDistance01(focalZDistance);
					}
					focalStartCurve = focalZStartCurve;
					focalEndCurve = focalZEndCurve;
					flag = flag && focalPoint > _camera.nearClipPlane + Mathf.Epsilon;
				}
				widthOverHeight = 1f * (float)source.width / (1f * (float)source.height);
				oneOverBaseSize = 0.001953125f;
				dofMaterial.SetFloat("_ForegroundBlurExtrude", foregroundBlurExtrude);
				dofMaterial.SetVector("_CurveParams", new Vector4(simpleTweakMode ? (1f / focalStartCurve) : focalStartCurve, simpleTweakMode ? (1f / focalEndCurve) : focalEndCurve, num2 * 0.5f, focalDistance01));
				dofMaterial.SetVector("_InvRenderTargetSize", new Vector4(1f / (1f * (float)source.width), 1f / (1f * (float)source.height), 0f, 0f));
				int dividerBasedOnQuality = GetDividerBasedOnQuality();
				int lowResolutionDividerBasedOnQuality = GetLowResolutionDividerBasedOnQuality(dividerBasedOnQuality);
				AllocateTextures(flag, source, dividerBasedOnQuality, lowResolutionDividerBasedOnQuality);
				Graphics.Blit(source, source, dofMaterial, 3);
				Downsample(source, mediumRezWorkTexture);
				Blur(mediumRezWorkTexture, mediumRezWorkTexture, DofBlurriness.Low, 4, maxBlurSpread);
				if (bokeh && (BokehDestination.Foreground & bokehDestination) != 0)
				{
					dofMaterial.SetVector("_Threshhold", new Vector4(bokehThresholdContrast, bokehThresholdLuminance, 0.95f, 0f));
					Graphics.Blit(mediumRezWorkTexture, bokehSource2, dofMaterial, 11);
					Graphics.Blit(mediumRezWorkTexture, lowRezWorkTexture);
					Blur(lowRezWorkTexture, lowRezWorkTexture, bluriness, 0, maxBlurSpread * num);
				}
				else
				{
					Downsample(mediumRezWorkTexture, lowRezWorkTexture);
					Blur(lowRezWorkTexture, lowRezWorkTexture, bluriness, 0, maxBlurSpread);
				}
				dofBlurMaterial.SetTexture("_TapLow", lowRezWorkTexture);
				dofBlurMaterial.SetTexture("_TapMedium", mediumRezWorkTexture);
				Graphics.Blit(null, finalDefocus, dofBlurMaterial, 3);
				if (bokeh && (BokehDestination.Foreground & bokehDestination) != 0)
				{
					AddBokeh(bokehSource2, bokehSource, finalDefocus);
				}
				dofMaterial.SetTexture("_TapLowBackground", finalDefocus);
				dofMaterial.SetTexture("_TapMedium", mediumRezWorkTexture);
				Graphics.Blit(source, flag ? foregroundTexture : destination, dofMaterial, visualize ? 2 : 0);
				if (flag)
				{
					Graphics.Blit(foregroundTexture, source, dofMaterial, 5);
					Downsample(source, mediumRezWorkTexture);
					BlurFg(mediumRezWorkTexture, mediumRezWorkTexture, DofBlurriness.Low, 2, maxBlurSpread);
					if (bokeh && (BokehDestination.Foreground & bokehDestination) != 0)
					{
						dofMaterial.SetVector("_Threshhold", new Vector4(bokehThresholdContrast * 0.5f, bokehThresholdLuminance, 0f, 0f));
						Graphics.Blit(mediumRezWorkTexture, bokehSource2, dofMaterial, 11);
						Graphics.Blit(mediumRezWorkTexture, lowRezWorkTexture);
						BlurFg(lowRezWorkTexture, lowRezWorkTexture, bluriness, 1, maxBlurSpread * num);
					}
					else
					{
						BlurFg(mediumRezWorkTexture, lowRezWorkTexture, bluriness, 1, maxBlurSpread);
					}
					Graphics.Blit(lowRezWorkTexture, finalDefocus);
					dofMaterial.SetTexture("_TapLowForeground", finalDefocus);
					Graphics.Blit(source, destination, dofMaterial, visualize ? 1 : 4);
					if (bokeh && (BokehDestination.Foreground & bokehDestination) != 0)
					{
						AddBokeh(bokehSource2, bokehSource, destination);
					}
				}
				ReleaseTextures();
			}

			private void Blur(RenderTexture from, RenderTexture to, DofBlurriness iterations, int blurPass, float spread)
			{
				RenderTexture temporary = RenderTexture.GetTemporary(to.width, to.height);
				if (iterations > DofBlurriness.Low)
				{
					BlurHex(from, to, blurPass, spread, temporary);
					if (iterations > DofBlurriness.High)
					{
						dofBlurMaterial.SetVector("offsets", new Vector4(0f, spread * oneOverBaseSize, 0f, 0f));
						Graphics.Blit(to, temporary, dofBlurMaterial, blurPass);
						dofBlurMaterial.SetVector("offsets", new Vector4(spread / widthOverHeight * oneOverBaseSize, 0f, 0f, 0f));
						Graphics.Blit(temporary, to, dofBlurMaterial, blurPass);
					}
				}
				else
				{
					dofBlurMaterial.SetVector("offsets", new Vector4(0f, spread * oneOverBaseSize, 0f, 0f));
					Graphics.Blit(from, temporary, dofBlurMaterial, blurPass);
					dofBlurMaterial.SetVector("offsets", new Vector4(spread / widthOverHeight * oneOverBaseSize, 0f, 0f, 0f));
					Graphics.Blit(temporary, to, dofBlurMaterial, blurPass);
				}
				RenderTexture.ReleaseTemporary(temporary);
			}

			private void BlurFg(RenderTexture from, RenderTexture to, DofBlurriness iterations, int blurPass, float spread)
			{
				dofBlurMaterial.SetTexture("_TapHigh", from);
				RenderTexture temporary = RenderTexture.GetTemporary(to.width, to.height);
				if (iterations > DofBlurriness.Low)
				{
					BlurHex(from, to, blurPass, spread, temporary);
					if (iterations > DofBlurriness.High)
					{
						dofBlurMaterial.SetVector("offsets", new Vector4(0f, spread * oneOverBaseSize, 0f, 0f));
						Graphics.Blit(to, temporary, dofBlurMaterial, blurPass);
						dofBlurMaterial.SetVector("offsets", new Vector4(spread / widthOverHeight * oneOverBaseSize, 0f, 0f, 0f));
						Graphics.Blit(temporary, to, dofBlurMaterial, blurPass);
					}
				}
				else
				{
					dofBlurMaterial.SetVector("offsets", new Vector4(0f, spread * oneOverBaseSize, 0f, 0f));
					Graphics.Blit(from, temporary, dofBlurMaterial, blurPass);
					dofBlurMaterial.SetVector("offsets", new Vector4(spread / widthOverHeight * oneOverBaseSize, 0f, 0f, 0f));
					Graphics.Blit(temporary, to, dofBlurMaterial, blurPass);
				}
				RenderTexture.ReleaseTemporary(temporary);
			}

			private void BlurHex(RenderTexture from, RenderTexture to, int blurPass, float spread, RenderTexture tmp)
			{
				dofBlurMaterial.SetVector("offsets", new Vector4(0f, spread * oneOverBaseSize, 0f, 0f));
				Graphics.Blit(from, tmp, dofBlurMaterial, blurPass);
				dofBlurMaterial.SetVector("offsets", new Vector4(spread / widthOverHeight * oneOverBaseSize, 0f, 0f, 0f));
				Graphics.Blit(tmp, to, dofBlurMaterial, blurPass);
				dofBlurMaterial.SetVector("offsets", new Vector4(spread / widthOverHeight * oneOverBaseSize, spread * oneOverBaseSize, 0f, 0f));
				Graphics.Blit(to, tmp, dofBlurMaterial, blurPass);
				dofBlurMaterial.SetVector("offsets", new Vector4(spread / widthOverHeight * oneOverBaseSize, (0f - spread) * oneOverBaseSize, 0f, 0f));
				Graphics.Blit(tmp, to, dofBlurMaterial, blurPass);
			}

			private void Downsample(RenderTexture from, RenderTexture to)
			{
				dofMaterial.SetVector("_InvRenderTargetSize", new Vector4(1f / (1f * (float)to.width), 1f / (1f * (float)to.height), 0f, 0f));
				Graphics.Blit(from, to, dofMaterial, SMOOTH_DOWNSAMPLE_PASS);
			}

			private void AddBokeh(RenderTexture bokehInfo, RenderTexture tempTex, RenderTexture finalTarget)
			{
				if (!bokehMaterial)
				{
					return;
				}
				Mesh[] meshes = Quads.GetMeshes(tempTex.width, tempTex.height);
				RenderTexture.active = tempTex;
				GL.Clear(clearDepth: false, clearColor: true, new Color(0f, 0f, 0f, 0f));
				GL.PushMatrix();
				GL.LoadIdentity();
				bokehInfo.filterMode = FilterMode.Point;
				float num = (float)bokehInfo.width * 1f / ((float)bokehInfo.height * 1f);
				float num2 = 2f / (1f * (float)bokehInfo.width);
				num2 += bokehScale * maxBlurSpread * BOKEH_EXTRA_BLUR * oneOverBaseSize;
				bokehMaterial.SetTexture("_Source", bokehInfo);
				bokehMaterial.SetTexture("_MainTex", bokehTexture);
				bokehMaterial.SetVector("_ArScale", new Vector4(num2, num2 * num, 0.5f, 0.5f * num));
				bokehMaterial.SetFloat("_Intensity", bokehIntensity);
				bokehMaterial.SetPass(0);
				Mesh[] array = meshes;
				foreach (Mesh mesh in array)
				{
					if ((bool)mesh)
					{
						Graphics.DrawMeshNow(mesh, Matrix4x4.identity);
					}
				}
				GL.PopMatrix();
				Graphics.Blit(tempTex, finalTarget, dofMaterial, 8);
				bokehInfo.filterMode = FilterMode.Bilinear;
			}

			private void ReleaseTextures()
			{
				if ((bool)foregroundTexture)
				{
					RenderTexture.ReleaseTemporary(foregroundTexture);
				}
				if ((bool)finalDefocus)
				{
					RenderTexture.ReleaseTemporary(finalDefocus);
				}
				if ((bool)mediumRezWorkTexture)
				{
					RenderTexture.ReleaseTemporary(mediumRezWorkTexture);
				}
				if ((bool)lowRezWorkTexture)
				{
					RenderTexture.ReleaseTemporary(lowRezWorkTexture);
				}
				if ((bool)bokehSource)
				{
					RenderTexture.ReleaseTemporary(bokehSource);
				}
				if ((bool)bokehSource2)
				{
					RenderTexture.ReleaseTemporary(bokehSource2);
				}
			}

			private void AllocateTextures(bool blurForeground, RenderTexture source, int divider, int lowTexDivider)
			{
				foregroundTexture = null;
				if (blurForeground)
				{
					foregroundTexture = RenderTexture.GetTemporary(source.width, source.height, 0);
				}
				mediumRezWorkTexture = RenderTexture.GetTemporary(source.width / divider, source.height / divider, 0);
				finalDefocus = RenderTexture.GetTemporary(source.width / divider, source.height / divider, 0);
				lowRezWorkTexture = RenderTexture.GetTemporary(source.width / lowTexDivider, source.height / lowTexDivider, 0);
				bokehSource = null;
				bokehSource2 = null;
				if (bokeh)
				{
					bokehSource = RenderTexture.GetTemporary(source.width / (lowTexDivider * bokehDownsample), source.height / (lowTexDivider * bokehDownsample), 0, RenderTextureFormat.ARGBHalf);
					bokehSource2 = RenderTexture.GetTemporary(source.width / (lowTexDivider * bokehDownsample), source.height / (lowTexDivider * bokehDownsample), 0, RenderTextureFormat.ARGBHalf);
					bokehSource.filterMode = FilterMode.Bilinear;
					bokehSource2.filterMode = FilterMode.Bilinear;
					RenderTexture.active = bokehSource2;
					GL.Clear(clearDepth: false, clearColor: true, new Color(0f, 0f, 0f, 0f));
				}
				source.filterMode = FilterMode.Bilinear;
				finalDefocus.filterMode = FilterMode.Bilinear;
				mediumRezWorkTexture.filterMode = FilterMode.Bilinear;
				lowRezWorkTexture.filterMode = FilterMode.Bilinear;
				if ((bool)foregroundTexture)
				{
					foregroundTexture.filterMode = FilterMode.Bilinear;
				}
			}
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(Camera))]
		[AddComponentMenu("Image Effects/Edge Detection/Edge Detection")]
		public class EdgeDetection : PostEffectsBase
		{
			public enum EdgeDetectMode
			{
				TriangleDepthNormals,
				RobertsCrossDepthNormals,
				SobelDepth,
				SobelDepthThin,
				TriangleLuminance
			}

			public EdgeDetectMode mode = EdgeDetectMode.SobelDepthThin;

			public float sensitivityDepth = 1f;

			public float sensitivityNormals = 1f;

			public float lumThreshold = 0.2f;

			public float edgeExp = 1f;

			public float sampleDist = 1f;

			public float edgesOnly;

			public Color edgesOnlyBgColor = Color.white;

			public Shader edgeDetectShader;

			private Material edgeDetectMaterial;

			private EdgeDetectMode oldMode = EdgeDetectMode.SobelDepthThin;

			public override bool CheckResources()
			{
				CheckSupport(needDepth: true);
				edgeDetectMaterial = CheckShaderAndCreateMaterial(edgeDetectShader, edgeDetectMaterial);
				if (mode != oldMode)
				{
					SetCameraFlag();
				}
				oldMode = mode;
				if (!isSupported)
				{
					ReportAutoDisable();
				}
				return isSupported;
			}

			private new void Start()
			{
				oldMode = mode;
			}

			private void SetCameraFlag()
			{
				if (mode == EdgeDetectMode.SobelDepth || mode == EdgeDetectMode.SobelDepthThin)
				{
					GetComponent<Camera>().depthTextureMode |= DepthTextureMode.Depth;
				}
				else if (mode == EdgeDetectMode.TriangleDepthNormals || mode == EdgeDetectMode.RobertsCrossDepthNormals)
				{
					GetComponent<Camera>().depthTextureMode |= DepthTextureMode.DepthNormals;
				}
			}

			private void OnEnable()
			{
				SetCameraFlag();
			}

			[ImageEffectOpaque]
			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (!CheckResources())
				{
					Graphics.Blit(source, destination);
					return;
				}
				Vector2 vector = new Vector2(sensitivityDepth, sensitivityNormals);
				edgeDetectMaterial.SetVector("_Sensitivity", new Vector4(vector.x, vector.y, 1f, vector.y));
				edgeDetectMaterial.SetFloat("_BgFade", edgesOnly);
				edgeDetectMaterial.SetFloat("_SampleDistance", sampleDist);
				edgeDetectMaterial.SetVector("_BgColor", edgesOnlyBgColor);
				edgeDetectMaterial.SetFloat("_Exponent", edgeExp);
				edgeDetectMaterial.SetFloat("_Threshold", lumThreshold);
				Graphics.Blit(source, destination, edgeDetectMaterial, (int)mode);
			}
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(Camera))]
		[AddComponentMenu("Image Effects/Displacement/Fisheye")]
		public class Fisheye : PostEffectsBase
		{
			[Range(0f, 1.5f)]
			public float strengthX = 0.05f;

			[Range(0f, 1.5f)]
			public float strengthY = 0.05f;

			public Shader fishEyeShader;

			private Material fisheyeMaterial;

			public override bool CheckResources()
			{
				CheckSupport(needDepth: false);
				fisheyeMaterial = CheckShaderAndCreateMaterial(fishEyeShader, fisheyeMaterial);
				if (!isSupported)
				{
					ReportAutoDisable();
				}
				return isSupported;
			}

			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (!CheckResources())
				{
					Graphics.Blit(source, destination);
					return;
				}
				float num = 5f / 32f;
				float num2 = (float)source.width * 1f / ((float)source.height * 1f);
				fisheyeMaterial.SetVector("intensity", new Vector4(strengthX * num2 * num, strengthY * num, strengthX * num2 * num, strengthY * num));
				Graphics.Blit(source, destination, fisheyeMaterial);
			}
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(Camera))]
		[AddComponentMenu("Image Effects/Rendering/Global Fog")]
		internal class GlobalFog : PostEffectsBase
		{
			[Tooltip("Apply distance-based fog?")]
			public bool distanceFog = true;

			[Tooltip("Exclude far plane pixels from distance-based fog? (Skybox or clear color)")]
			public bool excludeFarPixels = true;

			[Tooltip("Distance fog is based on radial distance from camera when checked")]
			public bool useRadialDistance;

			[Tooltip("Apply height-based fog?")]
			public bool heightFog = true;

			[Tooltip("Fog top Y coordinate")]
			public float height = 1f;

			[Range(0.001f, 10f)]
			public float heightDensity = 2f;

			[Tooltip("Push fog away from the camera by this amount")]
			public float startDistance;

			public Shader fogShader;

			private Material fogMaterial;

			public override bool CheckResources()
			{
				CheckSupport(needDepth: true);
				fogMaterial = CheckShaderAndCreateMaterial(fogShader, fogMaterial);
				if (!isSupported)
				{
					ReportAutoDisable();
				}
				return isSupported;
			}

			[ImageEffectOpaque]
			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (!CheckResources() || (!distanceFog && !heightFog))
				{
					Graphics.Blit(source, destination);
					return;
				}
				Camera component = GetComponent<Camera>();
				Transform transform = component.transform;
				float nearClipPlane = component.nearClipPlane;
				float farClipPlane = component.farClipPlane;
				float fieldOfView = component.fieldOfView;
				float aspect = component.aspect;
				Matrix4x4 identity = Matrix4x4.identity;
				float num = fieldOfView * 0.5f;
				Vector3 vector = transform.right * nearClipPlane * Mathf.Tan(num * ((float)Math.PI / 180f)) * aspect;
				Vector3 vector2 = transform.up * nearClipPlane * Mathf.Tan(num * ((float)Math.PI / 180f));
				Vector3 vector3 = transform.forward * nearClipPlane - vector + vector2;
				float num2 = vector3.magnitude * farClipPlane / nearClipPlane;
				vector3.Normalize();
				vector3 *= num2;
				Vector3 vector4 = transform.forward * nearClipPlane + vector + vector2;
				vector4.Normalize();
				vector4 *= num2;
				Vector3 vector5 = transform.forward * nearClipPlane + vector - vector2;
				vector5.Normalize();
				vector5 *= num2;
				Vector3 vector6 = transform.forward * nearClipPlane - vector - vector2;
				vector6.Normalize();
				vector6 *= num2;
				identity.SetRow(0, vector3);
				identity.SetRow(1, vector4);
				identity.SetRow(2, vector5);
				identity.SetRow(3, vector6);
				Vector3 position = transform.position;
				float num3 = position.y - height;
				float z = ((num3 <= 0f) ? 1f : 0f);
				float y = (excludeFarPixels ? 1f : 2f);
				fogMaterial.SetMatrix("_FrustumCornersWS", identity);
				fogMaterial.SetVector("_CameraWS", position);
				fogMaterial.SetVector("_HeightParams", new Vector4(height, num3, z, heightDensity * 0.5f));
				fogMaterial.SetVector("_DistanceParams", new Vector4(0f - Mathf.Max(startDistance, 0f), y, 0f, 0f));
				FogMode fogMode = RenderSettings.fogMode;
				float fogDensity = RenderSettings.fogDensity;
				float fogStartDistance = RenderSettings.fogStartDistance;
				float fogEndDistance = RenderSettings.fogEndDistance;
				bool flag = fogMode == FogMode.Linear;
				float num4 = (flag ? (fogEndDistance - fogStartDistance) : 0f);
				float num5 = ((Mathf.Abs(num4) > 0.0001f) ? (1f / num4) : 0f);
				Vector4 value = default(Vector4);
				value.x = fogDensity * 1.2011224f;
				value.y = fogDensity * 1.442695f;
				value.z = (flag ? (0f - num5) : 0f);
				value.w = (flag ? (fogEndDistance * num5) : 0f);
				fogMaterial.SetVector("_SceneFogParams", value);
				fogMaterial.SetVector("_SceneFogMode", new Vector4((float)fogMode, useRadialDistance ? 1 : 0, 0f, 0f));
				int num6 = 0;
				CustomGraphicsBlit(passNr: (!distanceFog || !heightFog) ? (distanceFog ? 1 : 2) : 0, source: source, dest: destination, fxMaterial: fogMaterial);
			}

			private static void CustomGraphicsBlit(RenderTexture source, RenderTexture dest, Material fxMaterial, int passNr)
			{
				RenderTexture.active = dest;
				fxMaterial.SetTexture("_MainTex", source);
				GL.PushMatrix();
				GL.LoadOrtho();
				fxMaterial.SetPass(passNr);
				GL.Begin(7);
				GL.MultiTexCoord2(0, 0f, 0f);
				GL.Vertex3(0f, 0f, 3f);
				GL.MultiTexCoord2(0, 1f, 0f);
				GL.Vertex3(1f, 0f, 2f);
				GL.MultiTexCoord2(0, 1f, 1f);
				GL.Vertex3(1f, 1f, 1f);
				GL.MultiTexCoord2(0, 0f, 1f);
				GL.Vertex3(0f, 1f, 0f);
				GL.End();
				GL.PopMatrix();
			}
		}
		[ExecuteInEditMode]
		[AddComponentMenu("Image Effects/Color Adjustments/Grayscale")]
		public class Grayscale : ImageEffectBase
		{
			public Texture textureRamp;

			[Range(-1f, 1f)]
			public float rampOffset;

			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				base.material.SetTexture("_RampTex", textureRamp);
				base.material.SetFloat("_RampOffset", rampOffset);
				Graphics.Blit(source, destination, base.material);
			}
		}
		[RequireComponent(typeof(Camera))]
		[AddComponentMenu("")]
		public class ImageEffectBase : MonoBehaviour
		{
			public Shader shader;

			private Material m_Material;

			protected Material material
			{
				get
				{
					if (m_Material == null)
					{
						m_Material = new Material(shader);
						m_Material.hideFlags = HideFlags.HideAndDontSave;
					}
					return m_Material;
				}
			}

			protected virtual void Start()
			{
				if (!SystemInfo.supportsImageEffects)
				{
					base.enabled = false;
				}
				else if (!shader || !shader.isSupported)
				{
					base.enabled = false;
				}
			}

			protected virtual void OnDisable()
			{
				if ((bool)m_Material)
				{
					UnityEngine.Object.DestroyImmediate(m_Material);
				}
			}
		}
		[AddComponentMenu("")]
		public class ImageEffects
		{
			public static void RenderDistortion(Material material, RenderTexture source, RenderTexture destination, float angle, Vector2 center, Vector2 radius)
			{
				if (source.texelSize.y < 0f)
				{
					center.y = 1f - center.y;
					angle = 0f - angle;
				}
				Matrix4x4 value = Matrix4x4.TRS(Vector3.zero, Quaternion.Euler(0f, 0f, angle), Vector3.one);
				material.SetMatrix("_RotationMatrix", value);
				material.SetVector("_CenterRadius", new Vector4(center.x, center.y, radius.x, radius.y));
				material.SetFloat("_Angle", angle * ((float)Math.PI / 180f));
				Graphics.Blit(source, destination, material);
			}

			[Obsolete("Use Graphics.Blit(source,dest) instead")]
			public static void Blit(RenderTexture source, RenderTexture dest)
			{
				Graphics.Blit(source, dest);
			}

			[Obsolete("Use Graphics.Blit(source, destination, material) instead")]
			public static void BlitWithMaterial(Material material, RenderTexture source, RenderTexture dest)
			{
				Graphics.Blit(source, dest, material);
			}
		}
		[ExecuteInEditMode]
		[AddComponentMenu("Image Effects/Blur/Motion Blur (Color Accumulation)")]
		[RequireComponent(typeof(Camera))]
		public class MotionBlur : ImageEffectBase
		{
			[Range(0f, 0.92f)]
			public float blurAmount = 0.8f;

			public bool extraBlur;

			private RenderTexture accumTexture;

			protected override void Start()
			{
				if (!SystemInfo.supportsRenderTextures)
				{
					base.enabled = false;
				}
				else
				{
					base.Start();
				}
			}

			protected override void OnDisable()
			{
				base.OnDisable();
				UnityEngine.Object.DestroyImmediate(accumTexture);
			}

			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (accumTexture == null || accumTexture.width != source.width || accumTexture.height != source.height)
				{
					UnityEngine.Object.DestroyImmediate(accumTexture);
					accumTexture = new RenderTexture(source.width, source.height, 0);
					accumTexture.hideFlags = HideFlags.HideAndDontSave;
					Graphics.Blit(source, accumTexture);
				}
				if (extraBlur)
				{
					RenderTexture temporary = RenderTexture.GetTemporary(source.width / 4, source.height / 4, 0);
					accumTexture.MarkRestoreExpected();
					Graphics.Blit(accumTexture, temporary);
					Graphics.Blit(temporary, accumTexture);
					RenderTexture.ReleaseTemporary(temporary);
				}
				blurAmount = Mathf.Clamp(blurAmount, 0f, 0.92f);
				base.material.SetTexture("_MainTex", accumTexture);
				base.material.SetFloat("_AccumOrig", 1f - blurAmount);
				accumTexture.MarkRestoreExpected();
				Graphics.Blit(source, accumTexture, base.material);
				Graphics.Blit(accumTexture, destination);
			}
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(Camera))]
		[AddComponentMenu("Image Effects/Noise/Noise And Grain (Filmic)")]
		public class NoiseAndGrain : PostEffectsBase
		{
			public float intensityMultiplier = 0.25f;

			public float generalIntensity = 0.5f;

			public float blackIntensity = 1f;

			public float whiteIntensity = 1f;

			public float midGrey = 0.2f;

			public bool dx11Grain;

			public float softness;

			public bool monochrome;

			public Vector3 intensities = new Vector3(1f, 1f, 1f);

			public Vector3 tiling = new Vector3(64f, 64f, 64f);

			public float monochromeTiling = 64f;

			public FilterMode filterMode = FilterMode.Bilinear;

			public Texture2D noiseTexture;

			public Shader noiseShader;

			private Material noiseMaterial;

			public Shader dx11NoiseShader;

			private Material dx11NoiseMaterial;

			private static float TILE_AMOUNT = 64f;

			private Mesh mesh;

			private void Awake()
			{
				mesh = new Mesh();
			}

			public override bool CheckResources()
			{
				CheckSupport(needDepth: false);
				noiseMaterial = CheckShaderAndCreateMaterial(noiseShader, noiseMaterial);
				if (dx11Grain && supportDX11)
				{
					dx11NoiseMaterial = CheckShaderAndCreateMaterial(dx11NoiseShader, dx11NoiseMaterial);
				}
				if (!isSupported)
				{
					ReportAutoDisable();
				}
				return isSupported;
			}

			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (!CheckResources() || null == noiseTexture)
				{
					Graphics.Blit(source, destination);
					if (null == noiseTexture)
					{
						UnityEngine.Debug.LogWarning("Noise & Grain effect failing as noise texture is not assigned. please assign.", base.transform);
					}
					return;
				}
				softness = Mathf.Clamp(softness, 0f, 0.99f);
				if (dx11Grain && supportDX11)
				{
					dx11NoiseMaterial.SetFloat("_DX11NoiseTime", Time.frameCount);
					dx11NoiseMaterial.SetTexture("_NoiseTex", noiseTexture);
					dx11NoiseMaterial.SetVector("_NoisePerChannel", monochrome ? Vector3.one : intensities);
					dx11NoiseMaterial.SetVector("_MidGrey", new Vector3(midGrey, 1f / (1f - midGrey), -1f / midGrey));
					dx11NoiseMaterial.SetVector("_NoiseAmount", new Vector3(generalIntensity, blackIntensity, whiteIntensity) * intensityMultiplier);
					if (softness > Mathf.Epsilon)
					{
						RenderTexture temporary = RenderTexture.GetTemporary((int)((float)source.width * (1f - softness)), (int)((float)source.height * (1f - softness)));
						DrawNoiseQuadGrid(source, temporary, dx11NoiseMaterial, noiseTexture, mesh, monochrome ? 3 : 2);
						dx11NoiseMaterial.SetTexture("_NoiseTex", temporary);
						Graphics.Blit(source, destination, dx11NoiseMaterial, 4);
						RenderTexture.ReleaseTemporary(temporary);
					}
					else
					{
						DrawNoiseQuadGrid(source, destination, dx11NoiseMaterial, noiseTexture, mesh, monochrome ? 1 : 0);
					}
					return;
				}
				if ((bool)noiseTexture)
				{
					noiseTexture.wrapMode = TextureWrapMode.Repeat;
					noiseTexture.filterMode = filterMode;
				}
				noiseMaterial.SetTexture("_NoiseTex", noiseTexture);
				noiseMaterial.SetVector("_NoisePerChannel", monochrome ? Vector3.one : intensities);
				noiseMaterial.SetVector("_NoiseTilingPerChannel", monochrome ? (Vector3.one * monochromeTiling) : tiling);
				noiseMaterial.SetVector("_MidGrey", new Vector3(midGrey, 1f / (1f - midGrey), -1f / midGrey));
				noiseMaterial.SetVector("_NoiseAmount", new Vector3(generalIntensity, blackIntensity, whiteIntensity) * intensityMultiplier);
				if (softness > Mathf.Epsilon)
				{
					RenderTexture temporary2 = RenderTexture.GetTemporary((int)((float)source.width * (1f - softness)), (int)((float)source.height * (1f - softness)));
					DrawNoiseQuadGrid(source, temporary2, noiseMaterial, noiseTexture, mesh, 2);
					noiseMaterial.SetTexture("_NoiseTex", temporary2);
					Graphics.Blit(source, destination, noiseMaterial, 1);
					RenderTexture.ReleaseTemporary(temporary2);
				}
				else
				{
					DrawNoiseQuadGrid(source, destination, noiseMaterial, noiseTexture, mesh, 0);
				}
			}

			private static void DrawNoiseQuadGrid(RenderTexture source, RenderTexture dest, Material fxMaterial, Texture2D noise, Mesh mesh, int passNr)
			{
				RenderTexture.active = dest;
				fxMaterial.SetTexture("_MainTex", source);
				GL.PushMatrix();
				GL.LoadOrtho();
				fxMaterial.SetPass(passNr);
				BuildMesh(mesh, source, noise);
				Transform obj = Camera.main.transform;
				Vector3 position = obj.position;
				Quaternion rotation = obj.rotation;
				obj.position = Vector3.zero;
				obj.rotation = Quaternion.identity;
				Graphics.DrawMeshNow(mesh, Matrix4x4.identity);
				obj.position = position;
				obj.rotation = rotation;
				GL.PopMatrix();
			}

			private static void BuildMesh(Mesh mesh, RenderTexture source, Texture2D noise)
			{
				float noiseSize = (float)noise.width * 1f;
				float num = 1f * (float)source.width / TILE_AMOUNT;
				float num2 = 1f * (float)source.width / (1f * (float)source.height);
				float num3 = 1f / num;
				float num4 = num3 * num2;
				int num5 = (int)Mathf.Ceil(num);
				int num6 = (int)Mathf.Ceil(1f / num4);
				if (mesh.vertices.Length != num5 * num6 * 4)
				{
					Vector3[] array = new Vector3[num5 * num6 * 4];
					Vector2[] array2 = new Vector2[num5 * num6 * 4];
					int[] array3 = new int[num5 * num6 * 6];
					int num7 = 0;
					int num8 = 0;
					for (float num9 = 0f; num9 < 1f; num9 += num3)
					{
						for (float num10 = 0f; num10 < 1f; num10 += num4)
						{
							array[num7] = new Vector3(num9, num10, 0.1f);
							array[num7 + 1] = new Vector3(num9 + num3, num10, 0.1f);
							array[num7 + 2] = new Vector3(num9 + num3, num10 + num4, 0.1f);
							array[num7 + 3] = new Vector3(num9, num10 + num4, 0.1f);
							array2[num7] = new Vector2(0f, 0f);
							array2[num7 + 1] = new Vector2(1f, 0f);
							array2[num7 + 2] = new Vector2(1f, 1f);
							array2[num7 + 3] = new Vector2(0f, 1f);
							array3[num8] = num7;
							array3[num8 + 1] = num7 + 1;
							array3[num8 + 2] = num7 + 2;
							array3[num8 + 3] = num7;
							array3[num8 + 4] = num7 + 2;
							array3[num8 + 5] = num7 + 3;
							num7 += 4;
							num8 += 6;
						}
					}
					mesh.vertices = array;
					mesh.uv2 = array2;
					mesh.triangles = array3;
				}
				BuildMeshUV0(mesh, num5, num6, noiseSize, noise.width);
			}

			private static void BuildMeshUV0(Mesh mesh, int width, int height, float noiseSize, int noiseWidth)
			{
				float num = noiseSize / ((float)noiseWidth * 1f);
				float num2 = 1f / noiseSize;
				Vector2[] array = new Vector2[width * height * 4];
				int num3 = 0;
				for (int i = 0; i < width * height; i++)
				{
					float f = UnityEngine.Random.Range(0f, noiseSize);
					float f2 = UnityEngine.Random.Range(0f, noiseSize);
					f = Mathf.Floor(f) * num2;
					f2 = Mathf.Floor(f2) * num2;
					array[num3] = new Vector2(f, f2);
					array[num3 + 1] = new Vector2(f + num * num2, f2);
					array[num3 + 2] = new Vector2(f + num * num2, f2 + num * num2);
					array[num3 + 3] = new Vector2(f, f2 + num * num2);
					num3 += 4;
				}
				mesh.uv = array;
			}
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(Camera))]
		[AddComponentMenu("Image Effects/Noise/Noise and Scratches")]
		public class NoiseAndScratches : MonoBehaviour
		{
			public bool monochrome = true;

			private bool rgbFallback;

			[Range(0f, 5f)]
			public float grainIntensityMin = 0.1f;

			[Range(0f, 5f)]
			public float grainIntensityMax = 0.2f;

			[Range(0.1f, 50f)]
			public float grainSize = 2f;

			[Range(0f, 5f)]
			public float scratchIntensityMin = 0.05f;

			[Range(0f, 5f)]
			public float scratchIntensityMax = 0.25f;

			[Range(1f, 30f)]
			public float scratchFPS = 10f;

			[Range(0f, 1f)]
			public float scratchJitter = 0.01f;

			public Texture grainTexture;

			public Texture scratchTexture;

			public Shader shaderRGB;

			public Shader shaderYUV;

			private Material m_MaterialRGB;

			private Material m_MaterialYUV;

			private float scratchTimeLeft;

			private float scratchX;

			private float scratchY;

			protected Material material
			{
				get
				{
					if (m_MaterialRGB == null)
					{
						m_MaterialRGB = new Material(shaderRGB);
						m_MaterialRGB.hideFlags = HideFlags.HideAndDontSave;
					}
					if (m_MaterialYUV == null && !rgbFallback)
					{
						m_MaterialYUV = new Material(shaderYUV);
						m_MaterialYUV.hideFlags = HideFlags.HideAndDontSave;
					}
					if (rgbFallback || monochrome)
					{
						return m_MaterialRGB;
					}
					return m_MaterialYUV;
				}
			}

			protected void Start()
			{
				if (!SystemInfo.supportsImageEffects)
				{
					base.enabled = false;
				}
				else if (shaderRGB == null || shaderYUV == null)
				{
					UnityEngine.Debug.Log("Noise shaders are not set up! Disabling noise effect.");
					base.enabled = false;
				}
				else if (!shaderRGB.isSupported)
				{
					base.enabled = false;
				}
				else if (!shaderYUV.isSupported)
				{
					rgbFallback = true;
				}
			}

			protected void OnDisable()
			{
				if ((bool)m_MaterialRGB)
				{
					UnityEngine.Object.DestroyImmediate(m_MaterialRGB);
				}
				if ((bool)m_MaterialYUV)
				{
					UnityEngine.Object.DestroyImmediate(m_MaterialYUV);
				}
			}

			private void SanitizeParameters()
			{
				grainIntensityMin = Mathf.Clamp(grainIntensityMin, 0f, 5f);
				grainIntensityMax = Mathf.Clamp(grainIntensityMax, 0f, 5f);
				scratchIntensityMin = Mathf.Clamp(scratchIntensityMin, 0f, 5f);
				scratchIntensityMax = Mathf.Clamp(scratchIntensityMax, 0f, 5f);
				scratchFPS = Mathf.Clamp(scratchFPS, 1f, 30f);
				scratchJitter = Mathf.Clamp(scratchJitter, 0f, 1f);
				grainSize = Mathf.Clamp(grainSize, 0.1f, 50f);
			}

			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				SanitizeParameters();
				if (scratchTimeLeft <= 0f)
				{
					scratchTimeLeft = UnityEngine.Random.value * 2f / scratchFPS;
					scratchX = UnityEngine.Random.value;
					scratchY = UnityEngine.Random.value;
				}
				scratchTimeLeft -= Time.deltaTime;
				Material material = this.material;
				material.SetTexture("_GrainTex", grainTexture);
				material.SetTexture("_ScratchTex", scratchTexture);
				float num = 1f / grainSize;
				material.SetVector("_GrainOffsetScale", new Vector4(UnityEngine.Random.value, UnityEngine.Random.value, (float)Screen.width / (float)grainTexture.width * num, (float)Screen.height / (float)grainTexture.height * num));
				material.SetVector("_ScratchOffsetScale", new Vector4(scratchX + UnityEngine.Random.value * scratchJitter, scratchY + UnityEngine.Random.value * scratchJitter, (float)Screen.width / (float)scratchTexture.width, (float)Screen.height / (float)scratchTexture.height));
				material.SetVector("_Intensity", new Vector4(UnityEngine.Random.Range(grainIntensityMin, grainIntensityMax), UnityEngine.Random.Range(scratchIntensityMin, scratchIntensityMax), 0f, 0f));
				Graphics.Blit(source, destination, material);
			}
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(Camera))]
		public class PostEffectsBase : MonoBehaviour
		{
			protected bool supportHDRTextures = true;

			protected bool supportDX11;

			protected bool isSupported = true;

			private List<Material> createdMaterials = new List<Material>();

			protected Material CheckShaderAndCreateMaterial(Shader s, Material m2Create)
			{
				if (!s)
				{
					UnityEngine.Debug.Log("Missing shader in " + ToString());
					base.enabled = false;
					return null;
				}
				if (s.isSupported && (bool)m2Create && m2Create.shader == s)
				{
					return m2Create;
				}
				if (!s.isSupported)
				{
					NotSupported();
					UnityEngine.Debug.Log("The shader " + s.ToString() + " on effect " + ToString() + " is not supported on this platform!");
					return null;
				}
				m2Create = new Material(s);
				createdMaterials.Add(m2Create);
				m2Create.hideFlags = HideFlags.DontSave;
				return m2Create;
			}

			protected Material CreateMaterial(Shader s, Material m2Create)
			{
				if (!s)
				{
					UnityEngine.Debug.Log("Missing shader in " + ToString());
					return null;
				}
				if ((bool)m2Create && m2Create.shader == s && s.isSupported)
				{
					return m2Create;
				}
				if (!s.isSupported)
				{
					return null;
				}
				m2Create = new Material(s);
				createdMaterials.Add(m2Create);
				m2Create.hideFlags = HideFlags.DontSave;
				return m2Create;
			}

			private void OnEnable()
			{
				isSupported = true;
			}

			private void OnDestroy()
			{
				RemoveCreatedMaterials();
			}

			private void RemoveCreatedMaterials()
			{
				while (createdMaterials.Count > 0)
				{
					Material obj = createdMaterials[0];
					createdMaterials.RemoveAt(0);
					UnityEngine.Object.Destroy(obj);
				}
			}

			protected bool CheckSupport()
			{
				return CheckSupport(needDepth: false);
			}

			public virtual bool CheckResources()
			{
				UnityEngine.Debug.LogWarning("CheckResources () for " + ToString() + " should be overwritten.");
				return isSupported;
			}

			protected void Start()
			{
				CheckResources();
			}

			protected bool CheckSupport(bool needDepth)
			{
				isSupported = true;
				supportHDRTextures = SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.ARGBHalf);
				supportDX11 = SystemInfo.graphicsShaderLevel >= 50 && SystemInfo.supportsComputeShaders;
				if (!SystemInfo.supportsImageEffects || !SystemInfo.supportsRenderTextures)
				{
					NotSupported();
					return false;
				}
				if (needDepth && !SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.Depth))
				{
					NotSupported();
					return false;
				}
				if (needDepth)
				{
					GetComponent<Camera>().depthTextureMode |= DepthTextureMode.Depth;
				}
				return true;
			}

			protected bool CheckSupport(bool needDepth, bool needHdr)
			{
				if (!CheckSupport(needDepth))
				{
					return false;
				}
				if (needHdr && !supportHDRTextures)
				{
					NotSupported();
					return false;
				}
				return true;
			}

			public bool Dx11Support()
			{
				return supportDX11;
			}

			protected void ReportAutoDisable()
			{
				UnityEngine.Debug.LogWarning("The image effect " + ToString() + " has been disabled as it's not supported on the current platform.");
			}

			private bool CheckShader(Shader s)
			{
				UnityEngine.Debug.Log("The shader " + s.ToString() + " on effect " + ToString() + " is not part of the Unity 3.2+ effects suite anymore. For best performance and quality, please ensure you are using the latest Standard Assets Image Effects (Pro only) package.");
				if (!s.isSupported)
				{
					NotSupported();
					return false;
				}
				return false;
			}

			protected void NotSupported()
			{
				base.enabled = false;
				isSupported = false;
			}

			protected void DrawBorder(RenderTexture dest, Material material)
			{
				RenderTexture.active = dest;
				bool flag = true;
				GL.PushMatrix();
				GL.LoadOrtho();
				for (int i = 0; i < material.passCount; i++)
				{
					material.SetPass(i);
					float y;
					float y2;
					if (flag)
					{
						y = 1f;
						y2 = 0f;
					}
					else
					{
						y = 0f;
						y2 = 1f;
					}
					float x = 0f + 1f / ((float)dest.width * 1f);
					float y3 = 0f;
					float y4 = 1f;
					GL.Begin(7);
					GL.TexCoord2(0f, y);
					GL.Vertex3(0f, y3, 0.1f);
					GL.TexCoord2(1f, y);
					GL.Vertex3(x, y3, 0.1f);
					GL.TexCoord2(1f, y2);
					GL.Vertex3(x, y4, 0.1f);
					GL.TexCoord2(0f, y2);
					GL.Vertex3(0f, y4, 0.1f);
					float x2 = 1f - 1f / ((float)dest.width * 1f);
					x = 1f;
					y3 = 0f;
					y4 = 1f;
					GL.TexCoord2(0f, y);
					GL.Vertex3(x2, y3, 0.1f);
					GL.TexCoord2(1f, y);
					GL.Vertex3(x, y3, 0.1f);
					GL.TexCoord2(1f, y2);
					GL.Vertex3(x, y4, 0.1f);
					GL.TexCoord2(0f, y2);
					GL.Vertex3(x2, y4, 0.1f);
					x = 1f;
					y3 = 0f;
					y4 = 0f + 1f / ((float)dest.height * 1f);
					GL.TexCoord2(0f, y);
					GL.Vertex3(0f, y3, 0.1f);
					GL.TexCoord2(1f, y);
					GL.Vertex3(x, y3, 0.1f);
					GL.TexCoord2(1f, y2);
					GL.Vertex3(x, y4, 0.1f);
					GL.TexCoord2(0f, y2);
					GL.Vertex3(0f, y4, 0.1f);
					x = 1f;
					y3 = 1f - 1f / ((float)dest.height * 1f);
					y4 = 1f;
					GL.TexCoord2(0f, y);
					GL.Vertex3(0f, y3, 0.1f);
					GL.TexCoord2(1f, y);
					GL.Vertex3(x, y3, 0.1f);
					GL.TexCoord2(1f, y2);
					GL.Vertex3(x, y4, 0.1f);
					GL.TexCoord2(0f, y2);
					GL.Vertex3(0f, y4, 0.1f);
					GL.End();
				}
				GL.PopMatrix();
			}
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(Camera))]
		internal class PostEffectsHelper : MonoBehaviour
		{
			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				UnityEngine.Debug.Log("OnRenderImage in Helper called ...");
			}

			private static void DrawLowLevelPlaneAlignedWithCamera(float dist, RenderTexture source, RenderTexture dest, Material material, Camera cameraForProjectionMatrix)
			{
				RenderTexture.active = dest;
				material.SetTexture("_MainTex", source);
				bool flag = true;
				GL.PushMatrix();
				GL.LoadIdentity();
				GL.LoadProjectionMatrix(cameraForProjectionMatrix.projectionMatrix);
				float f = cameraForProjectionMatrix.fieldOfView * 0.5f * ((float)Math.PI / 180f);
				float num = Mathf.Cos(f) / Mathf.Sin(f);
				float aspect = cameraForProjectionMatrix.aspect;
				float num2 = aspect / (0f - num);
				float num3 = aspect / num;
				float num4 = 1f / (0f - num);
				float num5 = 1f / num;
				float num6 = 1f;
				num2 *= dist * num6;
				num3 *= dist * num6;
				num4 *= dist * num6;
				num5 *= dist * num6;
				float z = 0f - dist;
				for (int i = 0; i < material.passCount; i++)
				{
					material.SetPass(i);
					GL.Begin(7);
					float y;
					float y2;
					if (flag)
					{
						y = 1f;
						y2 = 0f;
					}
					else
					{
						y = 0f;
						y2 = 1f;
					}
					GL.TexCoord2(0f, y);
					GL.Vertex3(num2, num4, z);
					GL.TexCoord2(1f, y);
					GL.Vertex3(num3, num4, z);
					GL.TexCoord2(1f, y2);
					GL.Vertex3(num3, num5, z);
					GL.TexCoord2(0f, y2);
					GL.Vertex3(num2, num5, z);
					GL.End();
				}
				GL.PopMatrix();
			}

			private static void DrawBorder(RenderTexture dest, Material material)
			{
				RenderTexture.active = dest;
				bool flag = true;
				GL.PushMatrix();
				GL.LoadOrtho();
				for (int i = 0; i < material.passCount; i++)
				{
					material.SetPass(i);
					float y;
					float y2;
					if (flag)
					{
						y = 1f;
						y2 = 0f;
					}
					else
					{
						y = 0f;
						y2 = 1f;
					}
					float x = 0f + 1f / ((float)dest.width * 1f);
					float y3 = 0f;
					float y4 = 1f;
					GL.Begin(7);
					GL.TexCoord2(0f, y);
					GL.Vertex3(0f, y3, 0.1f);
					GL.TexCoord2(1f, y);
					GL.Vertex3(x, y3, 0.1f);
					GL.TexCoord2(1f, y2);
					GL.Vertex3(x, y4, 0.1f);
					GL.TexCoord2(0f, y2);
					GL.Vertex3(0f, y4, 0.1f);
					float x2 = 1f - 1f / ((float)dest.width * 1f);
					x = 1f;
					y3 = 0f;
					y4 = 1f;
					GL.TexCoord2(0f, y);
					GL.Vertex3(x2, y3, 0.1f);
					GL.TexCoord2(1f, y);
					GL.Vertex3(x, y3, 0.1f);
					GL.TexCoord2(1f, y2);
					GL.Vertex3(x, y4, 0.1f);
					GL.TexCoord2(0f, y2);
					GL.Vertex3(x2, y4, 0.1f);
					x = 1f;
					y3 = 0f;
					y4 = 0f + 1f / ((float)dest.height * 1f);
					GL.TexCoord2(0f, y);
					GL.Vertex3(0f, y3, 0.1f);
					GL.TexCoord2(1f, y);
					GL.Vertex3(x, y3, 0.1f);
					GL.TexCoord2(1f, y2);
					GL.Vertex3(x, y4, 0.1f);
					GL.TexCoord2(0f, y2);
					GL.Vertex3(0f, y4, 0.1f);
					x = 1f;
					y3 = 1f - 1f / ((float)dest.height * 1f);
					y4 = 1f;
					GL.TexCoord2(0f, y);
					GL.Vertex3(0f, y3, 0.1f);
					GL.TexCoord2(1f, y);
					GL.Vertex3(x, y3, 0.1f);
					GL.TexCoord2(1f, y2);
					GL.Vertex3(x, y4, 0.1f);
					GL.TexCoord2(0f, y2);
					GL.Vertex3(0f, y4, 0.1f);
					GL.End();
				}
				GL.PopMatrix();
			}

			private static void DrawLowLevelQuad(float x1, float x2, float y1, float y2, RenderTexture source, RenderTexture dest, Material material)
			{
				RenderTexture.active = dest;
				material.SetTexture("_MainTex", source);
				bool flag = true;
				GL.PushMatrix();
				GL.LoadOrtho();
				for (int i = 0; i < material.passCount; i++)
				{
					material.SetPass(i);
					GL.Begin(7);
					float y3;
					float y4;
					if (flag)
					{
						y3 = 1f;
						y4 = 0f;
					}
					else
					{
						y3 = 0f;
						y4 = 1f;
					}
					GL.TexCoord2(0f, y3);
					GL.Vertex3(x1, y1, 0.1f);
					GL.TexCoord2(1f, y3);
					GL.Vertex3(x2, y1, 0.1f);
					GL.TexCoord2(1f, y4);
					GL.Vertex3(x2, y2, 0.1f);
					GL.TexCoord2(0f, y4);
					GL.Vertex3(x1, y2, 0.1f);
					GL.End();
				}
				GL.PopMatrix();
			}
		}
		internal class Quads
		{
			private static Mesh[] meshes;

			private static int currentQuads;

			private static bool HasMeshes()
			{
				if (meshes == null)
				{
					return false;
				}
				Mesh[] array = meshes;
				foreach (Mesh mesh in array)
				{
					if (null == mesh)
					{
						return false;
					}
				}
				return true;
			}

			public static void Cleanup()
			{
				if (meshes == null)
				{
					return;
				}
				for (int i = 0; i < meshes.Length; i++)
				{
					if (null != meshes[i])
					{
						UnityEngine.Object.DestroyImmediate(meshes[i]);
						meshes[i] = null;
					}
				}
				meshes = null;
			}

			public static Mesh[] GetMeshes(int totalWidth, int totalHeight)
			{
				if (HasMeshes() && currentQuads == totalWidth * totalHeight)
				{
					return meshes;
				}
				int num = 10833;
				int num2 = (currentQuads = totalWidth * totalHeight);
				meshes = new Mesh[Mathf.CeilToInt(1f * (float)num2 / (1f * (float)num))];
				int num3 = 0;
				int num4 = 0;
				for (num3 = 0; num3 < num2; num3 += num)
				{
					int triCount = Mathf.FloorToInt(Mathf.Clamp(num2 - num3, 0, num));
					meshes[num4] = GetMesh(triCount, num3, totalWidth, totalHeight);
					num4++;
				}
				return meshes;
			}

			private static Mesh GetMesh(int triCount, int triOffset, int totalWidth, int totalHeight)
			{
				Mesh mesh = new Mesh();
				mesh.hideFlags = HideFlags.DontSave;
				Vector3[] array = new Vector3[triCount * 4];
				Vector2[] array2 = new Vector2[triCount * 4];
				Vector2[] array3 = new Vector2[triCount * 4];
				int[] array4 = new int[triCount * 6];
				for (int i = 0; i < triCount; i++)
				{
					int num = i * 4;
					int num2 = i * 6;
					int num3 = triOffset + i;
					float num4 = Mathf.Floor(num3 % totalWidth) / (float)totalWidth;
					float num5 = Mathf.Floor(num3 / totalWidth) / (float)totalHeight;
					array[num + 3] = (array[num + 2] = (array[num + 1] = (array[num] = new Vector3(num4 * 2f - 1f, num5 * 2f - 1f, 1f))));
					array2[num] = new Vector2(0f, 0f);
					array2[num + 1] = new Vector2(1f, 0f);
					array2[num + 2] = new Vector2(0f, 1f);
					array2[num + 3] = new Vector2(1f, 1f);
					array3[num] = new Vector2(num4, num5);
					array3[num + 1] = new Vector2(num4, num5);
					array3[num + 2] = new Vector2(num4, num5);
					array3[num + 3] = new Vector2(num4, num5);
					array4[num2] = num;
					array4[num2 + 1] = num + 1;
					array4[num2 + 2] = num + 2;
					array4[num2 + 3] = num + 1;
					array4[num2 + 4] = num + 2;
					array4[num2 + 5] = num + 3;
				}
				mesh.vertices = array;
				mesh.triangles = array4;
				mesh.uv = array2;
				mesh.uv2 = array3;
				return mesh;
			}
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(Camera))]
		[AddComponentMenu("Image Effects/Other/Screen Overlay")]
		public class ScreenOverlay : PostEffectsBase
		{
			public enum OverlayBlendMode
			{
				Additive,
				ScreenBlend,
				Multiply,
				Overlay,
				AlphaBlend
			}

			public OverlayBlendMode blendMode = OverlayBlendMode.Overlay;

			public float intensity = 1f;

			public Texture2D texture;

			public Shader overlayShader;

			private Material overlayMaterial;

			public override bool CheckResources()
			{
				CheckSupport(needDepth: false);
				overlayMaterial = CheckShaderAndCreateMaterial(overlayShader, overlayMaterial);
				if (!isSupported)
				{
					ReportAutoDisable();
				}
				return isSupported;
			}

			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (!CheckResources())
				{
					Graphics.Blit(source, destination);
					return;
				}
				Vector4 value = new Vector4(1f, 0f, 0f, 1f);
				overlayMaterial.SetVector("_UV_Transform", value);
				overlayMaterial.SetFloat("_Intensity", intensity);
				overlayMaterial.SetTexture("_Overlay", texture);
				Graphics.Blit(source, destination, overlayMaterial, (int)blendMode);
			}
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(Camera))]
		[AddComponentMenu("Image Effects/Rendering/Screen Space Ambient Obscurance")]
		internal class ScreenSpaceAmbientObscurance : PostEffectsBase
		{
			[Range(0f, 3f)]
			public float intensity = 0.5f;

			[Range(0.1f, 3f)]
			public float radius = 0.2f;

			[Range(0f, 3f)]
			public int blurIterations = 1;

			[Range(0f, 5f)]
			public float blurFilterDistance = 1.25f;

			[Range(0f, 1f)]
			public int downsample;

			public Texture2D rand;

			public Shader aoShader;

			private Material aoMaterial;

			public override bool CheckResources()
			{
				CheckSupport(needDepth: true);
				aoMaterial = CheckShaderAndCreateMaterial(aoShader, aoMaterial);
				if (!isSupported)
				{
					ReportAutoDisable();
				}
				return isSupported;
			}

			private void OnDisable()
			{
				if ((bool)aoMaterial)
				{
					UnityEngine.Object.DestroyImmediate(aoMaterial);
				}
				aoMaterial = null;
			}

			[ImageEffectOpaque]
			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (!CheckResources())
				{
					Graphics.Blit(source, destination);
					return;
				}
				Camera component = GetComponent<Camera>();
				Matrix4x4 projectionMatrix = component.projectionMatrix;
				Matrix4x4 inverse = projectionMatrix.inverse;
				Vector4 value = new Vector4(-2f / projectionMatrix[0, 0], -2f / projectionMatrix[1, 1], (1f - projectionMatrix[0, 2]) / projectionMatrix[0, 0], (1f + projectionMatrix[1, 2]) / projectionMatrix[1, 1]);
				if (component.stereoEnabled)
				{
					Matrix4x4 stereoProjectionMatrix = component.GetStereoProjectionMatrix(Camera.StereoscopicEye.Left);
					Matrix4x4 stereoProjectionMatrix2 = component.GetStereoProjectionMatrix(Camera.StereoscopicEye.Right);
					Vector4 value2 = new Vector4(-2f / stereoProjectionMatrix[0, 0], -2f / stereoProjectionMatrix[1, 1], (1f - stereoProjectionMatrix[0, 2]) / stereoProjectionMatrix[0, 0], (1f + stereoProjectionMatrix[1, 2]) / stereoProjectionMatrix[1, 1]);
					Vector4 value3 = new Vector4(-2f / stereoProjectionMatrix2[0, 0], -2f / stereoProjectionMatrix2[1, 1], (1f - stereoProjectionMatrix2[0, 2]) / stereoProjectionMatrix2[0, 0], (1f + stereoProjectionMatrix2[1, 2]) / stereoProjectionMatrix2[1, 1]);
					aoMaterial.SetVector("_ProjInfoLeft", value2);
					aoMaterial.SetVector("_ProjInfoRight", value3);
				}
				aoMaterial.SetVector("_ProjInfo", value);
				aoMaterial.SetMatrix("_ProjectionInv", inverse);
				aoMaterial.SetTexture("_Rand", rand);
				aoMaterial.SetFloat("_Radius", radius);
				aoMaterial.SetFloat("_Radius2", radius * radius);
				aoMaterial.SetFloat("_Intensity", intensity);
				aoMaterial.SetFloat("_BlurFilterDistance", blurFilterDistance);
				int width = source.width;
				int height = source.height;
				RenderTexture renderTexture = RenderTexture.GetTemporary(width >> downsample, height >> downsample);
				Graphics.Blit(source, renderTexture, aoMaterial, 0);
				if (downsample > 0)
				{
					RenderTexture temporary = RenderTexture.GetTemporary(width, height);
					Graphics.Blit(renderTexture, temporary, aoMaterial, 4);
					RenderTexture.ReleaseTemporary(renderTexture);
					renderTexture = temporary;
				}
				for (int i = 0; i < blurIterations; i++)
				{
					aoMaterial.SetVector("_Axis", new Vector2(1f, 0f));
					RenderTexture temporary = RenderTexture.GetTemporary(width, height);
					Graphics.Blit(renderTexture, temporary, aoMaterial, 1);
					RenderTexture.ReleaseTemporary(renderTexture);
					aoMaterial.SetVector("_Axis", new Vector2(0f, 1f));
					renderTexture = RenderTexture.GetTemporary(width, height);
					Graphics.Blit(temporary, renderTexture, aoMaterial, 1);
					RenderTexture.ReleaseTemporary(temporary);
				}
				aoMaterial.SetTexture("_AOTex", renderTexture);
				Graphics.Blit(source, destination, aoMaterial, 2);
				RenderTexture.ReleaseTemporary(renderTexture);
			}
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(Camera))]
		[AddComponentMenu("Image Effects/Rendering/Screen Space Ambient Occlusion")]
		public class ScreenSpaceAmbientOcclusion : MonoBehaviour
		{
			public enum SSAOSamples
			{
				Low,
				Medium,
				High
			}

			[Range(0.05f, 1f)]
			public float m_Radius = 0.4f;

			public SSAOSamples m_SampleCount = SSAOSamples.Medium;

			[Range(0.5f, 4f)]
			public float m_OcclusionIntensity = 1.5f;

			[Range(0f, 4f)]
			public int m_Blur = 2;

			[Range(1f, 6f)]
			public int m_Downsampling = 2;

			[Range(0.2f, 2f)]
			public float m_OcclusionAttenuation = 1f;

			[Range(1E-05f, 0.5f)]
			public float m_MinZ = 0.01f;

			public Shader m_SSAOShader;

			private Material m_SSAOMaterial;

			public Texture2D m_RandomTexture;

			private bool m_Supported;

			private static Material CreateMaterial(Shader shader)
			{
				if (!shader)
				{
					return null;
				}
				return new Material(shader)
				{
					hideFlags = HideFlags.HideAndDontSave
				};
			}

			private static void DestroyMaterial(Material mat)
			{
				if ((bool)mat)
				{
					UnityEngine.Object.DestroyImmediate(mat);
					mat = null;
				}
			}

			private void OnDisable()
			{
				DestroyMaterial(m_SSAOMaterial);
			}

			private void Start()
			{
				if (!SystemInfo.supportsImageEffects || !SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.Depth))
				{
					m_Supported = false;
					base.enabled = false;
					return;
				}
				CreateMaterials();
				if (!m_SSAOMaterial || m_SSAOMaterial.passCount != 5)
				{
					m_Supported = false;
					base.enabled = false;
				}
				else
				{
					m_Supported = true;
				}
			}

			private void OnEnable()
			{
				GetComponent<Camera>().depthTextureMode |= DepthTextureMode.DepthNormals;
			}

			private void CreateMaterials()
			{
				if (!m_SSAOMaterial && m_SSAOShader.isSupported)
				{
					m_SSAOMaterial = CreateMaterial(m_SSAOShader);
					m_SSAOMaterial.SetTexture("_RandomTexture", m_RandomTexture);
				}
			}

			[ImageEffectOpaque]
			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (!m_Supported || !m_SSAOShader.isSupported)
				{
					base.enabled = false;
					return;
				}
				CreateMaterials();
				m_Downsampling = Mathf.Clamp(m_Downsampling, 1, 6);
				m_Radius = Mathf.Clamp(m_Radius, 0.05f, 1f);
				m_MinZ = Mathf.Clamp(m_MinZ, 1E-05f, 0.5f);
				m_OcclusionIntensity = Mathf.Clamp(m_OcclusionIntensity, 0.5f, 4f);
				m_OcclusionAttenuation = Mathf.Clamp(m_OcclusionAttenuation, 0.2f, 2f);
				m_Blur = Mathf.Clamp(m_Blur, 0, 4);
				RenderTexture renderTexture = RenderTexture.GetTemporary(source.width / m_Downsampling, source.height / m_Downsampling, 0);
				float fieldOfView = GetComponent<Camera>().fieldOfView;
				float farClipPlane = GetComponent<Camera>().farClipPlane;
				float num = Mathf.Tan(fieldOfView * ((float)Math.PI / 180f) * 0.5f) * farClipPlane;
				float x = num * GetComponent<Camera>().aspect;
				m_SSAOMaterial.SetVector("_FarCorner", new Vector3(x, num, farClipPlane));
				int num2;
				int num3;
				if ((bool)m_RandomTexture)
				{
					num2 = m_RandomTexture.width;
					num3 = m_RandomTexture.height;
				}
				else
				{
					num2 = 1;
					num3 = 1;
				}
				m_SSAOMaterial.SetVector("_NoiseScale", new Vector3((float)renderTexture.width / (float)num2, (float)renderTexture.height / (float)num3, 0f));
				m_SSAOMaterial.SetVector("_Params", new Vector4(m_Radius, m_MinZ, 1f / m_OcclusionAttenuation, m_OcclusionIntensity));
				bool num4 = m_Blur > 0;
				Graphics.Blit(num4 ? null : source, renderTexture, m_SSAOMaterial, (int)m_SampleCount);
				if (num4)
				{
					RenderTexture temporary = RenderTexture.GetTemporary(source.width, source.height, 0);
					m_SSAOMaterial.SetVector("_TexelOffsetScale", new Vector4((float)m_Blur / (float)source.width, 0f, 0f, 0f));
					m_SSAOMaterial.SetTexture("_SSAO", renderTexture);
					Graphics.Blit(null, temporary, m_SSAOMaterial, 3);
					RenderTexture.ReleaseTemporary(renderTexture);
					RenderTexture temporary2 = RenderTexture.GetTemporary(source.width, source.height, 0);
					m_SSAOMaterial.SetVector("_TexelOffsetScale", new Vector4(0f, (float)m_Blur / (float)source.height, 0f, 0f));
					m_SSAOMaterial.SetTexture("_SSAO", temporary);
					Graphics.Blit(source, temporary2, m_SSAOMaterial, 3);
					RenderTexture.ReleaseTemporary(temporary);
					renderTexture = temporary2;
				}
				m_SSAOMaterial.SetTexture("_SSAO", renderTexture);
				Graphics.Blit(source, destination, m_SSAOMaterial, 4);
				RenderTexture.ReleaseTemporary(renderTexture);
			}
		}
		[ExecuteInEditMode]
		[AddComponentMenu("Image Effects/Color Adjustments/Sepia Tone")]
		public class SepiaTone : ImageEffectBase
		{
			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				Graphics.Blit(source, destination, base.material);
			}
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(Camera))]
		[AddComponentMenu("Image Effects/Rendering/Sun Shafts")]
		public class SunShafts : PostEffectsBase
		{
			public enum SunShaftsResolution
			{
				Low,
				Normal,
				High
			}

			public enum ShaftsScreenBlendMode
			{
				Screen,
				Add
			}

			public SunShaftsResolution resolution = SunShaftsResolution.Normal;

			public ShaftsScreenBlendMode screenBlendMode;

			public Transform sunTransform;

			public int radialBlurIterations = 2;

			public Color sunColor = Color.white;

			public Color sunThreshold = new Color(0.87f, 0.74f, 0.65f);

			public float sunShaftBlurRadius = 2.5f;

			public float sunShaftIntensity = 1.15f;

			public float maxRadius = 0.75f;

			public bool useDepthTexture = true;

			public Shader sunShaftsShader;

			private Material sunShaftsMaterial;

			public Shader simpleClearShader;

			private Material simpleClearMaterial;

			public override bool CheckResources()
			{
				CheckSupport(useDepthTexture);
				sunShaftsMaterial = CheckShaderAndCreateMaterial(sunShaftsShader, sunShaftsMaterial);
				simpleClearMaterial = CheckShaderAndCreateMaterial(simpleClearShader, simpleClearMaterial);
				if (!isSupported)
				{
					ReportAutoDisable();
				}
				return isSupported;
			}

			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (!CheckResources())
				{
					Graphics.Blit(source, destination);
					return;
				}
				if (useDepthTexture)
				{
					GetComponent<Camera>().depthTextureMode |= DepthTextureMode.Depth;
				}
				int num = 4;
				if (resolution == SunShaftsResolution.Normal)
				{
					num = 2;
				}
				else if (resolution == SunShaftsResolution.High)
				{
					num = 1;
				}
				Vector3 vector = Vector3.one * 0.5f;
				vector = ((!sunTransform) ? new Vector3(0.5f, 0.5f, 0f) : GetComponent<Camera>().WorldToViewportPoint(sunTransform.position));
				int width = source.width / num;
				int height = source.height / num;
				RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0);
				sunShaftsMaterial.SetVector("_BlurRadius4", new Vector4(1f, 1f, 0f, 0f) * sunShaftBlurRadius);
				sunShaftsMaterial.SetVector("_SunPosition", new Vector4(vector.x, vector.y, vector.z, maxRadius));
				sunShaftsMaterial.SetVector("_SunThreshold", sunThreshold);
				if (!useDepthTexture)
				{
					RenderTextureFormat format = (GetComponent<Camera>().allowHDR ? RenderTextureFormat.DefaultHDR : RenderTextureFormat.Default);
					RenderTexture renderTexture = (RenderTexture.active = RenderTexture.GetTemporary(source.width, source.height, 0, format));
					GL.ClearWithSkybox(clearDepth: false, GetComponent<Camera>());
					sunShaftsMaterial.SetTexture("_Skybox", renderTexture);
					Graphics.Blit(source, temporary, sunShaftsMaterial, 3);
					RenderTexture.ReleaseTemporary(renderTexture);
				}
				else
				{
					Graphics.Blit(source, temporary, sunShaftsMaterial, 2);
				}
				DrawBorder(temporary, simpleClearMaterial);
				radialBlurIterations = Mathf.Clamp(radialBlurIterations, 1, 4);
				float num2 = sunShaftBlurRadius * 0.0013020834f;
				sunShaftsMaterial.SetVector("_BlurRadius4", new Vector4(num2, num2, 0f, 0f));
				sunShaftsMaterial.SetVector("_SunPosition", new Vector4(vector.x, vector.y, vector.z, maxRadius));
				for (int i = 0; i < radialBlurIterations; i++)
				{
					RenderTexture temporary3 = RenderTexture.GetTemporary(width, height, 0);
					Graphics.Blit(temporary, temporary3, sunShaftsMaterial, 1);
					RenderTexture.ReleaseTemporary(temporary);
					num2 = sunShaftBlurRadius * (((float)i * 2f + 1f) * 6f) / 768f;
					sunShaftsMaterial.SetVector("_BlurRadius4", new Vector4(num2, num2, 0f, 0f));
					temporary = RenderTexture.GetTemporary(width, height, 0);
					Graphics.Blit(temporary3, temporary, sunShaftsMaterial, 1);
					RenderTexture.ReleaseTemporary(temporary3);
					num2 = sunShaftBlurRadius * (((float)i * 2f + 2f) * 6f) / 768f;
					sunShaftsMaterial.SetVector("_BlurRadius4", new Vector4(num2, num2, 0f, 0f));
				}
				if (vector.z >= 0f)
				{
					sunShaftsMaterial.SetVector("_SunColor", new Vector4(sunColor.r, sunColor.g, sunColor.b, sunColor.a) * sunShaftIntensity);
				}
				else
				{
					sunShaftsMaterial.SetVector("_SunColor", Vector4.zero);
				}
				sunShaftsMaterial.SetTexture("_ColorBuffer", temporary);
				Graphics.Blit(source, destination, sunShaftsMaterial, (screenBlendMode != 0) ? 4 : 0);
				RenderTexture.ReleaseTemporary(temporary);
			}
		}
		[RequireComponent(typeof(Camera))]
		[AddComponentMenu("Image Effects/Camera/Tilt Shift (Lens Blur)")]
		internal class TiltShift : PostEffectsBase
		{
			public enum TiltShiftMode
			{
				TiltShiftMode,
				IrisMode
			}

			public enum TiltShiftQuality
			{
				Preview,
				Normal,
				High
			}

			public TiltShiftMode mode;

			public TiltShiftQuality quality = TiltShiftQuality.Normal;

			[Range(0f, 15f)]
			public float blurArea = 1f;

			[Range(0f, 25f)]
			public float maxBlurSize = 5f;

			[Range(0f, 1f)]
			public int downsample;

			public Shader tiltShiftShader;

			private Material tiltShiftMaterial;

			public override bool CheckResources()
			{
				CheckSupport(needDepth: true);
				tiltShiftMaterial = CheckShaderAndCreateMaterial(tiltShiftShader, tiltShiftMaterial);
				if (!isSupported)
				{
					ReportAutoDisable();
				}
				return isSupported;
			}

			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (!CheckResources())
				{
					Graphics.Blit(source, destination);
					return;
				}
				tiltShiftMaterial.SetFloat("_BlurSize", (maxBlurSize < 0f) ? 0f : maxBlurSize);
				tiltShiftMaterial.SetFloat("_BlurArea", blurArea);
				source.filterMode = FilterMode.Bilinear;
				RenderTexture renderTexture = destination;
				if ((float)downsample > 0f)
				{
					renderTexture = RenderTexture.GetTemporary(source.width >> downsample, source.height >> downsample, 0, source.format);
					renderTexture.filterMode = FilterMode.Bilinear;
				}
				int num = (int)quality;
				num *= 2;
				Graphics.Blit(source, renderTexture, tiltShiftMaterial, (mode == TiltShiftMode.TiltShiftMode) ? num : (num + 1));
				if (downsample > 0)
				{
					tiltShiftMaterial.SetTexture("_Blurred", renderTexture);
					Graphics.Blit(source, destination, tiltShiftMaterial, 6);
				}
				if (renderTexture != destination)
				{
					RenderTexture.ReleaseTemporary(renderTexture);
				}
			}
		}
		[ImageEffectAllowedInSceneView]
		[ExecuteInEditMode]
		[RequireComponent(typeof(Camera))]
		[AddComponentMenu("Image Effects/Color Adjustments/Tonemapping")]
		public class Tonemapping : PostEffectsBase
		{
			public enum TonemapperType
			{
				SimpleReinhard,
				UserCurve,
				Hable,
				Photographic,
				OptimizedHejiDawson,
				AdaptiveReinhard,
				AdaptiveReinhardAutoWhite
			}

			public enum AdaptiveTexSize
			{
				Square16 = 0x10,
				Square32 = 0x20,
				Square64 = 0x40,
				Square128 = 0x80,
				Square256 = 0x100,
				Square512 = 0x200,
				Square1024 = 0x400
			}

			public TonemapperType type = TonemapperType.Photographic;

			public AdaptiveTexSize adaptiveTextureSize = AdaptiveTexSize.Square256;

			public AnimationCurve remapCurve;

			private Texture2D curveTex;

			public float exposureAdjustment = 1.5f;

			public float middleGrey = 0.4f;

			public float white = 2f;

			public float adaptionSpeed = 1.5f;

			public Shader tonemapper;

			public bool validRenderTextureFormat = true;

			private Material tonemapMaterial;

			private RenderTexture rt;

			private RenderTextureFormat rtFormat = RenderTextureFormat.ARGBHalf;

			public override bool CheckResources()
			{
				CheckSupport(needDepth: false, needHdr: true);
				tonemapMaterial = CheckShaderAndCreateMaterial(tonemapper, tonemapMaterial);
				if (!curveTex && type == TonemapperType.UserCurve)
				{
					curveTex = new Texture2D(256, 1, TextureFormat.ARGB32, mipChain: false, linear: true);
					curveTex.filterMode = FilterMode.Bilinear;
					curveTex.wrapMode = TextureWrapMode.Clamp;
					curveTex.hideFlags = HideFlags.DontSave;
				}
				if (!isSupported)
				{
					ReportAutoDisable();
				}
				return isSupported;
			}

			public float UpdateCurve()
			{
				float num = 1f;
				if (remapCurve.keys.Length < 1)
				{
					remapCurve = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(2f, 1f));
				}
				if (remapCurve != null)
				{
					if (remapCurve.length > 0)
					{
						num = remapCurve[remapCurve.length - 1].time;
					}
					for (float num2 = 0f; num2 <= 1f; num2 += 0.003921569f)
					{
						float num3 = remapCurve.Evaluate(num2 * 1f * num);
						curveTex.SetPixel((int)Mathf.Floor(num2 * 255f), 0, new Color(num3, num3, num3));
					}
					curveTex.Apply();
				}
				return 1f / num;
			}

			private void OnDisable()
			{
				if ((bool)rt)
				{
					UnityEngine.Object.DestroyImmediate(rt);
					rt = null;
				}
				if ((bool)tonemapMaterial)
				{
					UnityEngine.Object.DestroyImmediate(tonemapMaterial);
					tonemapMaterial = null;
				}
				if ((bool)curveTex)
				{
					UnityEngine.Object.DestroyImmediate(curveTex);
					curveTex = null;
				}
			}

			private bool CreateInternalRenderTexture()
			{
				if ((bool)rt)
				{
					return false;
				}
				rtFormat = (SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.RGHalf) ? RenderTextureFormat.RGHalf : RenderTextureFormat.ARGBHalf);
				rt = new RenderTexture(1, 1, 0, rtFormat);
				rt.hideFlags = HideFlags.DontSave;
				return true;
			}

			[ImageEffectTransformsToLDR]
			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (!CheckResources())
				{
					Graphics.Blit(source, destination);
					return;
				}
				exposureAdjustment = ((exposureAdjustment < 0.001f) ? 0.001f : exposureAdjustment);
				if (type == TonemapperType.UserCurve)
				{
					float value = UpdateCurve();
					tonemapMaterial.SetFloat("_RangeScale", value);
					tonemapMaterial.SetTexture("_Curve", curveTex);
					Graphics.Blit(source, destination, tonemapMaterial, 4);
					return;
				}
				if (type == TonemapperType.SimpleReinhard)
				{
					tonemapMaterial.SetFloat("_ExposureAdjustment", exposureAdjustment);
					Graphics.Blit(source, destination, tonemapMaterial, 6);
					return;
				}
				if (type == TonemapperType.Hable)
				{
					tonemapMaterial.SetFloat("_ExposureAdjustment", exposureAdjustment);
					Graphics.Blit(source, destination, tonemapMaterial, 5);
					return;
				}
				if (type == TonemapperType.Photographic)
				{
					tonemapMaterial.SetFloat("_ExposureAdjustment", exposureAdjustment);
					Graphics.Blit(source, destination, tonemapMaterial, 8);
					return;
				}
				if (type == TonemapperType.OptimizedHejiDawson)
				{
					tonemapMaterial.SetFloat("_ExposureAdjustment", 0.5f * exposureAdjustment);
					Graphics.Blit(source, destination, tonemapMaterial, 7);
					return;
				}
				bool flag = CreateInternalRenderTexture();
				RenderTexture temporary = RenderTexture.GetTemporary((int)adaptiveTextureSize, (int)adaptiveTextureSize, 0, rtFormat);
				Graphics.Blit(source, temporary);
				int num = (int)Mathf.Log((float)temporary.width * 1f, 2f);
				int num2 = 2;
				RenderTexture[] array = new RenderTexture[num];
				for (int i = 0; i < num; i++)
				{
					array[i] = RenderTexture.GetTemporary(temporary.width / num2, temporary.width / num2, 0, rtFormat);
					num2 *= 2;
				}
				RenderTexture source2 = array[num - 1];
				Graphics.Blit(temporary, array[0], tonemapMaterial, 1);
				if (type == TonemapperType.AdaptiveReinhardAutoWhite)
				{
					for (int j = 0; j < num - 1; j++)
					{
						Graphics.Blit(array[j], array[j + 1], tonemapMaterial, 9);
						source2 = array[j + 1];
					}
				}
				else if (type == TonemapperType.AdaptiveReinhard)
				{
					for (int k = 0; k < num - 1; k++)
					{
						Graphics.Blit(array[k], array[k + 1]);
						source2 = array[k + 1];
					}
				}
				adaptionSpeed = ((adaptionSpeed < 0.001f) ? 0.001f : adaptionSpeed);
				tonemapMaterial.SetFloat("_AdaptionSpeed", adaptionSpeed);
				rt.MarkRestoreExpected();
				Graphics.Blit(source2, rt, tonemapMaterial, flag ? 3 : 2);
				middleGrey = ((middleGrey < 0.001f) ? 0.001f : middleGrey);
				tonemapMaterial.SetVector("_HdrParams", new Vector4(middleGrey, middleGrey, middleGrey, white * white));
				tonemapMaterial.SetTexture("_SmallTex", rt);
				if (type == TonemapperType.AdaptiveReinhard)
				{
					Graphics.Blit(source, destination, tonemapMaterial, 0);
				}
				else if (type == TonemapperType.AdaptiveReinhardAutoWhite)
				{
					Graphics.Blit(source, destination, tonemapMaterial, 10);
				}
				else
				{
					UnityEngine.Debug.LogError("No valid adaptive tonemapper type found!");
					Graphics.Blit(source, destination);
				}
				for (int l = 0; l < num; l++)
				{
					RenderTexture.ReleaseTemporary(array[l]);
				}
				RenderTexture.ReleaseTemporary(temporary);
			}
		}
		internal class Triangles
		{
			private static Mesh[] meshes;

			private static int currentTris;

			private static bool HasMeshes()
			{
				if (meshes == null)
				{
					return false;
				}
				for (int i = 0; i < meshes.Length; i++)
				{
					if (null == meshes[i])
					{
						return false;
					}
				}
				return true;
			}

			private static void Cleanup()
			{
				if (meshes == null)
				{
					return;
				}
				for (int i = 0; i < meshes.Length; i++)
				{
					if (null != meshes[i])
					{
						UnityEngine.Object.DestroyImmediate(meshes[i]);
						meshes[i] = null;
					}
				}
				meshes = null;
			}

			private static Mesh[] GetMeshes(int totalWidth, int totalHeight)
			{
				if (HasMeshes() && currentTris == totalWidth * totalHeight)
				{
					return meshes;
				}
				int num = 21666;
				int num2 = (currentTris = totalWidth * totalHeight);
				meshes = new Mesh[Mathf.CeilToInt(1f * (float)num2 / (1f * (float)num))];
				int num3 = 0;
				int num4 = 0;
				for (num3 = 0; num3 < num2; num3 += num)
				{
					int triCount = Mathf.FloorToInt(Mathf.Clamp(num2 - num3, 0, num));
					meshes[num4] = GetMesh(triCount, num3, totalWidth, totalHeight);
					num4++;
				}
				return meshes;
			}

			private static Mesh GetMesh(int triCount, int triOffset, int totalWidth, int totalHeight)
			{
				Mesh mesh = new Mesh();
				mesh.hideFlags = HideFlags.DontSave;
				Vector3[] array = new Vector3[triCount * 3];
				Vector2[] array2 = new Vector2[triCount * 3];
				Vector2[] array3 = new Vector2[triCount * 3];
				int[] array4 = new int[triCount * 3];
				for (int i = 0; i < triCount; i++)
				{
					int num = i * 3;
					int num2 = triOffset + i;
					float num3 = Mathf.Floor(num2 % totalWidth) / (float)totalWidth;
					float num4 = Mathf.Floor(num2 / totalWidth) / (float)totalHeight;
					array[num + 2] = (array[num + 1] = (array[num] = new Vector3(num3 * 2f - 1f, num4 * 2f - 1f, 1f)));
					array2[num] = new Vector2(0f, 0f);
					array2[num + 1] = new Vector2(1f, 0f);
					array2[num + 2] = new Vector2(0f, 1f);
					array3[num] = new Vector2(num3, num4);
					array3[num + 1] = new Vector2(num3, num4);
					array3[num + 2] = new Vector2(num3, num4);
					array4[num] = num;
					array4[num + 1] = num + 1;
					array4[num + 2] = num + 2;
				}
				mesh.vertices = array;
				mesh.triangles = array4;
				mesh.uv = array2;
				mesh.uv2 = array3;
				return mesh;
			}
		}
		[ExecuteInEditMode]
		[AddComponentMenu("Image Effects/Displacement/Twirl")]
		public class Twirl : ImageEffectBase
		{
			public Vector2 radius = new Vector2(0.3f, 0.3f);

			[Range(0f, 360f)]
			public float angle = 50f;

			public Vector2 center = new Vector2(0.5f, 0.5f);

			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				ImageEffects.RenderDistortion(base.material, source, destination, angle, center, radius);
			}
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(Camera))]
		[AddComponentMenu("Image Effects/Camera/Vignette and Chromatic Aberration")]
		public class VignetteAndChromaticAberration : PostEffectsBase
		{
			public enum AberrationMode
			{
				Simple,
				Advanced
			}

			public AberrationMode mode;

			public float intensity = 0.036f;

			public float chromaticAberration = 0.2f;

			public float axialAberration = 0.5f;

			public float blur;

			public float blurSpread = 0.75f;

			public float luminanceDependency = 0.25f;

			public float blurDistance = 2.5f;

			public Shader vignetteShader;

			public Shader separableBlurShader;

			public Shader chromAberrationShader;

			private Material m_VignetteMaterial;

			private Material m_SeparableBlurMaterial;

			private Material m_ChromAberrationMaterial;

			public override bool CheckResources()
			{
				CheckSupport(needDepth: false);
				m_VignetteMaterial = CheckShaderAndCreateMaterial(vignetteShader, m_VignetteMaterial);
				m_SeparableBlurMaterial = CheckShaderAndCreateMaterial(separableBlurShader, m_SeparableBlurMaterial);
				m_ChromAberrationMaterial = CheckShaderAndCreateMaterial(chromAberrationShader, m_ChromAberrationMaterial);
				if (!isSupported)
				{
					ReportAutoDisable();
				}
				return isSupported;
			}

			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (!CheckResources())
				{
					Graphics.Blit(source, destination);
					return;
				}
				int width = source.width;
				int height = source.height;
				bool flag = Mathf.Abs(blur) > 0f || Mathf.Abs(intensity) > 0f;
				float num = 1f * (float)width / (1f * (float)height);
				RenderTexture renderTexture = null;
				RenderTexture renderTexture2 = null;
				if (flag)
				{
					renderTexture = RenderTexture.GetTemporary(width, height, 0, source.format);
					if (Mathf.Abs(blur) > 0f)
					{
						renderTexture2 = RenderTexture.GetTemporary(width / 2, height / 2, 0, source.format);
						Graphics.Blit(source, renderTexture2, m_ChromAberrationMaterial, 0);
						for (int i = 0; i < 2; i++)
						{
							m_SeparableBlurMaterial.SetVector("offsets", new Vector4(0f, blurSpread * 0.001953125f, 0f, 0f));
							RenderTexture temporary = RenderTexture.GetTemporary(width / 2, height / 2, 0, source.format);
							Graphics.Blit(renderTexture2, temporary, m_SeparableBlurMaterial);
							RenderTexture.ReleaseTemporary(renderTexture2);
							m_SeparableBlurMaterial.SetVector("offsets", new Vector4(blurSpread * 0.001953125f / num, 0f, 0f, 0f));
							renderTexture2 = RenderTexture.GetTemporary(width / 2, height / 2, 0, source.format);
							Graphics.Blit(temporary, renderTexture2, m_SeparableBlurMaterial);
							RenderTexture.ReleaseTemporary(temporary);
						}
					}
					m_VignetteMaterial.SetFloat("_Intensity", 1f / (1f - intensity) - 1f);
					m_VignetteMaterial.SetFloat("_Blur", 1f / (1f - blur) - 1f);
					m_VignetteMaterial.SetTexture("_VignetteTex", renderTexture2);
					Graphics.Blit(source, renderTexture, m_VignetteMaterial, 0);
				}
				m_ChromAberrationMaterial.SetFloat("_ChromaticAberration", chromaticAberration);
				m_ChromAberrationMaterial.SetFloat("_AxialAberration", axialAberration);
				m_ChromAberrationMaterial.SetVector("_BlurDistance", new Vector2(0f - blurDistance, blurDistance));
				m_ChromAberrationMaterial.SetFloat("_Luminance", 1f / Mathf.Max(Mathf.Epsilon, luminanceDependency));
				if (flag)
				{
					renderTexture.wrapMode = TextureWrapMode.Clamp;
				}
				else
				{
					source.wrapMode = TextureWrapMode.Clamp;
				}
				Graphics.Blit(flag ? renderTexture : source, destination, m_ChromAberrationMaterial, (mode != AberrationMode.Advanced) ? 1 : 2);
				RenderTexture.ReleaseTemporary(renderTexture);
				RenderTexture.ReleaseTemporary(renderTexture2);
			}
		}
		[ExecuteInEditMode]
		[AddComponentMenu("Image Effects/Displacement/Vortex")]
		public class Vortex : ImageEffectBase
		{
			public Vector2 radius = new Vector2(0.4f, 0.4f);

			public float angle = 50f;

			public Vector2 center = new Vector2(0.5f, 0.5f);

			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				ImageEffects.RenderDistortion(base.material, source, destination, angle, center, radius);
			}
		}
	}
