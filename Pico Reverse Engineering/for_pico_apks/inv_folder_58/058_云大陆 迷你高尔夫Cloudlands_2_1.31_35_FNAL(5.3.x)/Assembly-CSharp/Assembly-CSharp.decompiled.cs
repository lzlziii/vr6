using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using AOT;
using BoundarySystem_Ext;
using ExitGames.Client.Photon;
using I2.Loc;
using LitJson;
using Oculus.Avatar;
using Oculus.Platform;
using Oculus.Platform.Models;
using Oculus.Spatializer.Propagation;
using Photon.Pun;
using Photon.Realtime;
using Photon.Voice.PUN;
using Photon.Voice.Unity;
using Pvr_UnitySDKAPI;
using Pvr_UnitySDKAPI.Achievement;
using TMPro;
using UnityEngine;
using UnityEngine.Android;
using UnityEngine.Audio;
using UnityEngine.EventSystems;
using UnityEngine.Events;
using UnityEngine.Experimental.Rendering;
using UnityEngine.Networking;
using UnityEngine.Rendering;
using UnityEngine.SceneManagement;
using UnityEngine.UI;
using UnityEngine.XR;
using Valve.VR;

[assembly: CompilationRelaxations(8)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: InternalsVisibleTo("Assembly-CSharp-Editor")]
[assembly: AssemblyVersion("0.0.0.0")]
public class Boat : MonoBehaviour
{
	private float orgY;

	public float waveSpeed = 1.7f;

	public float moveDis = 0.1f;

	public float LeftRight = 1f;

	private void Start()
	{
		orgY = base.transform.position.y;
	}

	private void Update()
	{
		base.transform.position = new Vector3(base.transform.position.x, orgY + moveDis * Mathf.Sin(Time.time * waveSpeed), base.transform.position.z);
		base.transform.localEulerAngles = new Vector3(base.transform.localEulerAngles.x, base.transform.localEulerAngles.y, LeftRight * Mathf.Sin(Time.time * waveSpeed + 1.5f));
	}
}
public class RFX4_AudioCurves : MonoBehaviour
{
	public AnimationCurve AudioCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public bool IsLoop;

	private bool canUpdate;

	private float startTime;

	private AudioSource audioSource;

	private float startVolume;

	private void Awake()
	{
		audioSource = GetComponent<AudioSource>();
		startVolume = audioSource.volume;
		audioSource.volume = AudioCurve.Evaluate(0f);
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float volume = AudioCurve.Evaluate(num / GraphTimeMultiplier) * startVolume;
			audioSource.volume = volume;
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}
}
public class RFX4_LightCurves : MonoBehaviour
{
	public AnimationCurve LightCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphIntensityMultiplier = 1f;

	public bool IsLoop;

	[HideInInspector]
	public bool canUpdate;

	private float startTime;

	private Light lightSource;

	private void Awake()
	{
		lightSource = GetComponent<Light>();
		lightSource.intensity = LightCurve.Evaluate(0f);
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float intensity = LightCurve.Evaluate(num / GraphTimeMultiplier) * GraphIntensityMultiplier;
			lightSource.intensity = intensity;
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}
}
public class RFX4_PhysicsForceCurves : MonoBehaviour
{
	public float ForceRadius = 5f;

	public float ForceMultiplier = 1f;

	public AnimationCurve ForceCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public ForceMode ForceMode;

	public float GraphTimeMultiplier = 1f;

	public float GraphIntensityMultiplier = 1f;

	public bool IsLoop;

	public float DestoryDistance = -1f;

	public bool UseDistanceScale;

	public AnimationCurve DistanceScaleCurve = AnimationCurve.EaseInOut(1f, 1f, 1f, 1f);

	public bool UseUPVector;

	public AnimationCurve DragCurve = AnimationCurve.EaseInOut(0f, 0f, 0f, 1f);

	public float DragGraphTimeMultiplier = -1f;

	public float DragGraphIntensityMultiplier = -1f;

	public string AffectedName;

	[HideInInspector]
	public float forceAdditionalMultiplier = 1f;

	private bool canUpdate;

	private float startTime;

	private Transform t;

	private void Awake()
	{
		t = base.transform;
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
		forceAdditionalMultiplier = 1f;
	}

	private void FixedUpdate()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float num2 = ForceCurve.Evaluate(num / GraphTimeMultiplier) * GraphIntensityMultiplier;
			Collider[] array = Physics.OverlapSphere(t.position, ForceRadius);
			foreach (Collider collider in array)
			{
				Rigidbody component = collider.GetComponent<Rigidbody>();
				if (!(component == null) && (AffectedName.Length <= 0 || collider.name.Contains(AffectedName)))
				{
					Vector3 vector;
					float num3;
					if (UseUPVector)
					{
						vector = Vector3.up;
						num3 = 1f - Mathf.Clamp01(collider.transform.position.y - t.position.y);
						num3 *= 1f - (collider.transform.position - t.position).magnitude / ForceRadius;
					}
					else
					{
						vector = collider.transform.position - t.position;
						num3 = 1f - vector.magnitude / ForceRadius;
					}
					if (UseDistanceScale)
					{
						collider.transform.localScale = DistanceScaleCurve.Evaluate(num3) * collider.transform.localScale;
					}
					if (DestoryDistance > 0f && vector.magnitude < DestoryDistance)
					{
						UnityEngine.Object.Destroy(collider.gameObject);
					}
					component.AddForce(vector.normalized * num3 * ForceMultiplier * num2 * forceAdditionalMultiplier, ForceMode);
					if (DragGraphTimeMultiplier > 0f)
					{
						component.drag = DragCurve.Evaluate(num / DragGraphTimeMultiplier) * DragGraphIntensityMultiplier;
						component.angularDrag = component.drag / 10f;
					}
				}
			}
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}

	private void OnDrawGizmosSelected()
	{
		Gizmos.color = Color.yellow;
		Gizmos.DrawWireSphere(base.transform.position, ForceRadius);
	}
}
public class RFX4_ScaleCurves : MonoBehaviour
{
	public AnimationCurve FloatCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphIntensityMultiplier = 1f;

	public bool IsLoop;

	private bool canUpdate;

	private float startTime;

	private Transform t;

	private int nameId;

	private Projector proj;

	private Vector3 startScale;

	private void Awake()
	{
		t = GetComponent<Transform>();
		startScale = t.localScale;
		t.localScale = Vector3.zero;
		proj = GetComponent<Projector>();
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
		t.localScale = Vector3.zero;
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float num2 = FloatCurve.Evaluate(num / GraphTimeMultiplier) * GraphIntensityMultiplier;
			t.localScale = num2 * startScale;
			if (proj != null)
			{
				proj.orthographicSize = num2;
			}
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}
}
public class RFX4_ShaderColorGradient : MonoBehaviour
{
	public RFX4_ShaderProperties ShaderColorProperty;

	public Gradient Color = new Gradient();

	public float TimeMultiplier = 1f;

	public bool IsLoop;

	public bool UseSharedMaterial;

	[HideInInspector]
	public float HUE = -1f;

	[HideInInspector]
	public bool canUpdate;

	private Material mat;

	private int propertyID;

	private float startTime;

	private Color startColor;

	private bool isInitialized;

	private string shaderProperty;

	private void Start()
	{
		Init();
	}

	private void Init()
	{
		shaderProperty = ShaderColorProperty.ToString();
		startTime = Time.time;
		canUpdate = true;
		Renderer component = GetComponent<Renderer>();
		if (component == null)
		{
			Projector component2 = GetComponent<Projector>();
			if (component2 != null)
			{
				if (!component2.material.name.EndsWith("(Instance)"))
				{
					component2.material = new Material(component2.material)
					{
						name = component2.material.name + " (Instance)"
					};
				}
				mat = component2.material;
			}
		}
		else if (!UseSharedMaterial)
		{
			mat = component.material;
		}
		else
		{
			mat = component.sharedMaterial;
		}
		if (mat == null)
		{
			canUpdate = false;
			return;
		}
		if (!mat.HasProperty(shaderProperty))
		{
			canUpdate = false;
			return;
		}
		if (mat.HasProperty(shaderProperty))
		{
			propertyID = Shader.PropertyToID(shaderProperty);
		}
		startColor = mat.GetColor(propertyID);
		Color color = Color.Evaluate(0f);
		mat.SetColor(propertyID, color * startColor);
		isInitialized = true;
	}

	private void OnEnable()
	{
		if (isInitialized)
		{
			startTime = Time.time;
			canUpdate = true;
		}
	}

	private void Update()
	{
		if (mat == null)
		{
			return;
		}
		float num = Time.time - startTime;
		if (canUpdate)
		{
			Color color = Color.Evaluate(num / TimeMultiplier);
			if (HUE > -0.9f)
			{
				color = RFX4_ColorHelper.ConvertRGBColorByHUE(color, HUE);
				startColor = RFX4_ColorHelper.ConvertRGBColorByHUE(startColor, HUE);
			}
			mat.SetColor(propertyID, color * startColor);
		}
		if (num >= TimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}

	private void OnDisable()
	{
		if (!(mat == null))
		{
			if (UseSharedMaterial)
			{
				mat.SetColor(propertyID, startColor);
			}
			mat.SetColor(propertyID, startColor);
		}
	}
}
public class RFX4_ShaderFloatCurve : MonoBehaviour
{
	public RFX4_ShaderProperties ShaderFloatProperty = RFX4_ShaderProperties._Cutoff;

	public AnimationCurve FloatCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphIntensityMultiplier = 1f;

	public bool IsLoop;

	public bool UseSharedMaterial;

	private bool canUpdate;

	private float startTime;

	private Material mat;

	private float startFloat;

	private int propertyID;

	private string shaderProperty;

	private bool isInitialized;

	private void Awake()
	{
		Renderer component = GetComponent<Renderer>();
		if (component == null)
		{
			Projector component2 = GetComponent<Projector>();
			if (component2 != null)
			{
				if (!UseSharedMaterial)
				{
					if (!component2.material.name.EndsWith("(Instance)"))
					{
						component2.material = new Material(component2.material)
						{
							name = component2.material.name + " (Instance)"
						};
					}
					mat = component2.material;
				}
				else
				{
					mat = component2.material;
				}
			}
		}
		else if (!UseSharedMaterial)
		{
			mat = component.material;
		}
		else
		{
			mat = component.sharedMaterial;
		}
		shaderProperty = ShaderFloatProperty.ToString();
		if (mat.HasProperty(shaderProperty))
		{
			propertyID = Shader.PropertyToID(shaderProperty);
		}
		startFloat = mat.GetFloat(propertyID);
		float value = FloatCurve.Evaluate(0f) * GraphIntensityMultiplier;
		mat.SetFloat(propertyID, value);
		isInitialized = true;
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
		if (isInitialized)
		{
			float value = FloatCurve.Evaluate(0f) * GraphIntensityMultiplier;
			mat.SetFloat(propertyID, value);
		}
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float value = FloatCurve.Evaluate(num / GraphTimeMultiplier) * GraphIntensityMultiplier;
			mat.SetFloat(propertyID, value);
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}

	private void OnDisable()
	{
		if (UseSharedMaterial)
		{
			mat.SetFloat(propertyID, startFloat);
		}
	}

	private void OnDestroy()
	{
		if (!UseSharedMaterial)
		{
			if (mat != null)
			{
				UnityEngine.Object.DestroyImmediate(mat);
			}
			mat = null;
		}
	}
}
public enum RFX4_ShaderProperties
{
	_TintColor,
	_Cutoff,
	_Color,
	_EmissionColor,
	_MaskPow,
	_Cutout,
	_Speed,
	_BumpAmt
}
public class RFX4_WindCurves : MonoBehaviour
{
	public AnimationCurve WindCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphIntensityMultiplier = 1f;

	public bool IsLoop;

	private bool canUpdate;

	private float startTime;

	private WindZone windZone;

	private void Awake()
	{
		windZone = GetComponent<WindZone>();
		windZone.windMain = WindCurve.Evaluate(0f);
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float windMain = WindCurve.Evaluate(num / GraphTimeMultiplier) * GraphIntensityMultiplier;
			windZone.windMain = windMain;
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}
}
public class RFX4_EffectSettingColor : MonoBehaviour
{
	public Color Color = Color.red;

	private Color previousColor;

	private void OnEnable()
	{
		UpdateColor();
	}

	private void Update()
	{
		if (previousColor != Color)
		{
			UpdateColor();
		}
	}

	private void UpdateColor()
	{
		RFX4_TransformMotion componentInChildren = GetComponentInChildren<RFX4_TransformMotion>(includeInactive: true);
		RFX4_RaycastCollision componentInChildren2 = GetComponentInChildren<RFX4_RaycastCollision>(includeInactive: true);
		float h = RFX4_ColorHelper.ColorToHSV(Color).H;
		RFX4_ColorHelper.ChangeObjectColorByHUE(base.gameObject, h);
		if (componentInChildren != null)
		{
			componentInChildren.HUE = h;
		}
		if (componentInChildren2 != null)
		{
			componentInChildren2.HUE = h;
		}
		previousColor = Color;
	}
}
public class RFX4_EffectSettingPhysxForce : MonoBehaviour
{
	public float ForceMultiplier = 1f;

	private void Start()
	{
	}

	private void Update()
	{
		RFX4_TransformMotion componentInChildren = GetComponentInChildren<RFX4_TransformMotion>(includeInactive: true);
		if (componentInChildren != null)
		{
			foreach (GameObject collidedInstance in componentInChildren.CollidedInstances)
			{
				RFX4_PhysicsForceCurves component = collidedInstance.GetComponent<RFX4_PhysicsForceCurves>();
				if (component != null)
				{
					component.forceAdditionalMultiplier = ForceMultiplier;
				}
			}
		}
		RFX4_PhysicsForceCurves[] componentsInChildren = GetComponentsInChildren<RFX4_PhysicsForceCurves>();
		foreach (RFX4_PhysicsForceCurves rFX4_PhysicsForceCurves in componentsInChildren)
		{
			if (rFX4_PhysicsForceCurves != null)
			{
				rFX4_PhysicsForceCurves.forceAdditionalMultiplier = ForceMultiplier;
			}
		}
	}
}
public class RFX4_EffectSettingProjectile : MonoBehaviour
{
	public float FlyDistanceForProjectiles = 30f;

	public float SpeedMultiplier = 1f;

	public LayerMask CollidesWith = -1;

	private float startSpeed;

	private const string particlesAdditionalName = "Distance";

	private void Awake()
	{
		RFX4_TransformMotion componentInChildren = GetComponentInChildren<RFX4_TransformMotion>(includeInactive: true);
		if (componentInChildren != null)
		{
			startSpeed = componentInChildren.Speed;
		}
	}

	private void OnEnable()
	{
		RFX4_TransformMotion componentInChildren = GetComponentInChildren<RFX4_TransformMotion>(includeInactive: true);
		if (componentInChildren != null)
		{
			componentInChildren.Distance = FlyDistanceForProjectiles;
			componentInChildren.CollidesWith = CollidesWith;
			componentInChildren.Speed = startSpeed * SpeedMultiplier;
		}
		RFX4_RaycastCollision componentInChildren2 = GetComponentInChildren<RFX4_RaycastCollision>(includeInactive: true);
		if (componentInChildren2 != null)
		{
			componentInChildren2.RaycastDistance = FlyDistanceForProjectiles;
		}
		ParticleSystem[] componentsInChildren = GetComponentsInChildren<ParticleSystem>();
		foreach (ParticleSystem particleSystem in componentsInChildren)
		{
			if (particleSystem.name.Contains("Distance"))
			{
				particleSystem.GetComponent<ParticleSystemRenderer>().lengthScale = FlyDistanceForProjectiles / particleSystem.main.startSize.constantMax;
			}
		}
	}
}
public class RFX4_EffectSettingVisible : MonoBehaviour
{
	public bool IsActive = true;

	public float FadeOutTime = 3f;

	private bool previousActiveStatus;

	private const string rendererAdditionalName = "Loop";

	private string[] colorProperties = new string[8] { "_TintColor", "_Color", "_EmissionColor", "_BorderColor", "_ReflectColor", "_RimColor", "_MainColor", "_CoreColor" };

	private float alpha;

	private void Start()
	{
	}

	private void Update()
	{
		if (IsActive)
		{
			alpha += Time.deltaTime;
		}
		else
		{
			alpha -= Time.deltaTime;
		}
		alpha = Mathf.Clamp01(alpha);
		if (!IsActive)
		{
			Renderer[] componentsInChildren = GetComponentsInChildren<Renderer>();
			foreach (Renderer renderer in componentsInChildren)
			{
				if (renderer.GetComponent<ParticleSystem>() != null || !renderer.name.Contains("Loop"))
				{
					continue;
				}
				Material material = renderer.material;
				RFX4_ShaderColorGradient component = renderer.GetComponent<RFX4_ShaderColorGradient>();
				if (component != null)
				{
					component.canUpdate = false;
				}
				string[] array = colorProperties;
				foreach (string text in array)
				{
					if (material.HasProperty(text))
					{
						Color color = material.GetColor(text);
						color.a = alpha;
						material.SetColor(text, color);
					}
				}
			}
			Projector[] componentsInChildren2 = GetComponentsInChildren<Projector>();
			foreach (Projector projector in componentsInChildren2)
			{
				if (!projector.name.Contains("Loop"))
				{
					continue;
				}
				if (!projector.material.name.EndsWith("(Instance)"))
				{
					projector.material = new Material(projector.material)
					{
						name = projector.material.name + " (Instance)"
					};
				}
				Material material2 = projector.material;
				RFX4_ShaderColorGradient component2 = projector.GetComponent<RFX4_ShaderColorGradient>();
				if (component2 != null)
				{
					component2.canUpdate = false;
				}
				string[] array = colorProperties;
				foreach (string text2 in array)
				{
					if (material2.HasProperty(text2))
					{
						Color color2 = material2.GetColor(text2);
						color2.a = alpha;
						material2.SetColor(text2, color2);
					}
				}
			}
			ParticleSystem[] componentsInChildren3 = GetComponentsInChildren<ParticleSystem>(includeInactive: true);
			foreach (ParticleSystem particleSystem in componentsInChildren3)
			{
				if (particleSystem != null)
				{
					particleSystem.Stop();
				}
			}
			Light[] componentsInChildren4 = GetComponentsInChildren<Light>(includeInactive: true);
			for (int k = 0; k < componentsInChildren4.Length; k++)
			{
				if (componentsInChildren4[k].isActiveAndEnabled)
				{
					RFX4_LightCurves component3 = componentsInChildren4[k].GetComponent<RFX4_LightCurves>();
					if (component3 != null)
					{
						componentsInChildren4[k].intensity = alpha * component3.GraphIntensityMultiplier;
						component3.canUpdate = false;
					}
					else
					{
						componentsInChildren4[k].intensity = alpha;
					}
				}
			}
		}
		if (IsActive && !previousActiveStatus)
		{
			Transform[] componentsInChildren5 = base.gameObject.GetComponentsInChildren<Transform>();
			foreach (Transform obj in componentsInChildren5)
			{
				obj.gameObject.SetActive(value: false);
				obj.gameObject.SetActive(value: true);
			}
		}
		previousActiveStatus = IsActive;
	}
}
public class RFX4_CollisionPropertyDeactiavtion : MonoBehaviour
{
	public float DeactivateTimeDelay = 1f;

	private float startTime;

	private WindZone windZone;

	private ParticleSystem ps;

	private ParticleSystem.CollisionModule collisionModule;

	private void Awake()
	{
		ps = GetComponent<ParticleSystem>();
		collisionModule = ps.collision;
	}

	private void OnEnable()
	{
		startTime = Time.time;
		collisionModule.enabled = true;
	}

	private void Update()
	{
		if (Time.time - startTime >= DeactivateTimeDelay)
		{
			collisionModule.enabled = false;
		}
	}
}
[RequireComponent(typeof(ParticleSystem))]
public class RFX4_ParticleCollisionHandler : MonoBehaviour
{
	public GameObject[] EffectsOnCollision;

	public float Offset;

	public float DestroyTimeDelay = 5f;

	public bool UseWorldSpacePosition;

	private ParticleSystem part;

	private List<ParticleCollisionEvent> collisionEvents = new List<ParticleCollisionEvent>();

	private ParticleSystem ps;

	private void Start()
	{
		part = GetComponent<ParticleSystem>();
	}

	private void OnParticleCollision(GameObject other)
	{
		int num = part.GetCollisionEvents(other, collisionEvents);
		for (int i = 0; i < num; i++)
		{
			GameObject[] effectsOnCollision = EffectsOnCollision;
			for (int j = 0; j < effectsOnCollision.Length; j++)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(effectsOnCollision[j], collisionEvents[i].intersection + collisionEvents[i].normal * Offset, default(Quaternion));
				gameObject.transform.LookAt(collisionEvents[i].intersection + collisionEvents[i].normal);
				if (!UseWorldSpacePosition)
				{
					gameObject.transform.parent = base.transform;
				}
				UnityEngine.Object.Destroy(gameObject, DestroyTimeDelay);
			}
		}
	}
}
[RequireComponent(typeof(ParticleSystem))]
public class RFX4_ParticleLight : MonoBehaviour
{
	public float LightIntencityMultiplayer = 1f;

	public LightShadows Shadows;

	private ParticleSystem ps;

	private ParticleSystem.Particle[] particles;

	private Light[] lights;

	private int lightLimit = 20;

	private void Start()
	{
		ps = GetComponent<ParticleSystem>();
		ParticleSystem.MainModule main = ps.main;
		if (main.maxParticles > lightLimit)
		{
			main.maxParticles = lightLimit;
		}
		particles = new ParticleSystem.Particle[main.maxParticles];
		lights = new Light[main.maxParticles];
		for (int i = 0; i < lights.Length; i++)
		{
			GameObject gameObject = new GameObject();
			lights[i] = gameObject.AddComponent<Light>();
			lights[i].transform.parent = base.transform;
			lights[i].intensity = 0f;
			lights[i].shadows = Shadows;
		}
	}

	private void Update()
	{
		int num = ps.GetParticles(particles);
		for (int i = 0; i < num; i++)
		{
			lights[i].gameObject.SetActive(value: true);
			lights[i].transform.position = particles[i].position;
			lights[i].color = particles[i].GetCurrentColor(ps);
			lights[i].range = particles[i].GetCurrentSize(ps);
			lights[i].intensity = (float)(int)particles[i].GetCurrentColor(ps).a / 255f * LightIntencityMultiplayer;
		}
		for (int j = num; j < particles.Length; j++)
		{
			lights[j].gameObject.SetActive(value: false);
		}
	}
}
[RequireComponent(typeof(ParticleSystem))]
public class RFX4_ParticleTrail : MonoBehaviour
{
	public GameObject Target;

	public Vector2 DefaultSizeMultiplayer = Vector2.one;

	public float VertexLifeTime = 2f;

	public float TrailLifeTime = 2f;

	public bool UseShaderMaterial;

	public Material TrailMaterial;

	public bool UseColorOverLifeTime;

	public Gradient ColorOverLifeTime = new Gradient();

	public float ColorLifeTime = 1f;

	public bool UseUvAnimation;

	public int TilesX = 4;

	public int TilesY = 4;

	public int FPS = 30;

	public bool IsLoop = true;

	[Range(0.001f, 1f)]
	public float MinVertexDistance = 0.01f;

	public bool GetVelocityFromParticleSystem;

	public float Gravity = 0.01f;

	public Vector3 Force = new Vector3(0f, 0.01f, 0f);

	public float InheritVelocity;

	public float Drag = 0.01f;

	[Range(0.001f, 10f)]
	public float Frequency = 1f;

	[Range(0.001f, 10f)]
	public float OffsetSpeed = 0.5f;

	public bool RandomTurbulenceOffset;

	[Range(0.001f, 10f)]
	public float Amplitude = 2f;

	public float TurbulenceStrength = 0.1f;

	public AnimationCurve VelocityByDistance = AnimationCurve.EaseInOut(0f, 1f, 1f, 1f);

	public float AproximatedFlyDistance = -1f;

	public bool SmoothCurves = true;

	private Dictionary<int, LineRenderer> dict = new Dictionary<int, LineRenderer>();

	private ParticleSystem ps;

	private ParticleSystem.Particle[] particles;

	private TrailRenderer[] trails;

	private Color psColor;

	private Transform targetT;

	private int layer;

	private bool isLocalSpace = true;

	private Transform t;

	private void OnEnable()
	{
		if (Target != null)
		{
			targetT = Target.transform;
		}
		ps = GetComponent<ParticleSystem>();
		t = base.transform;
		isLocalSpace = ps.main.simulationSpace == ParticleSystemSimulationSpace.Local;
		particles = new ParticleSystem.Particle[ps.main.maxParticles];
		if (TrailMaterial != null)
		{
			psColor = TrailMaterial.GetColor(TrailMaterial.HasProperty("_TintColor") ? "_TintColor" : "_Color");
		}
		layer = base.gameObject.layer;
		Update();
	}

	private void ClearTrails()
	{
		TrailRenderer[] array = trails;
		foreach (TrailRenderer trailRenderer in array)
		{
			if (trailRenderer != null)
			{
				UnityEngine.Object.Destroy(trailRenderer.gameObject);
			}
		}
		trails = null;
	}

	private void Update()
	{
		if (dict.Count > 10)
		{
			RemoveEmptyTrails();
		}
		int num = ps.GetParticles(particles);
		for (int i = 0; i < num; i++)
		{
			int hashCode = particles[i].rotation3D.GetHashCode();
			if (!dict.ContainsKey(hashCode))
			{
				GameObject gameObject = new GameObject(hashCode.ToString());
				gameObject.transform.parent = base.transform;
				gameObject.transform.position = ps.transform.position;
				if (TrailLifeTime > 1E-05f)
				{
					UnityEngine.Object.Destroy(gameObject, TrailLifeTime + VertexLifeTime);
				}
				gameObject.layer = layer;
				LineRenderer lineRenderer = gameObject.AddComponent<LineRenderer>();
				lineRenderer.startWidth = 0f;
				lineRenderer.endWidth = 0f;
				lineRenderer.sharedMaterial = TrailMaterial;
				lineRenderer.useWorldSpace = false;
				if (UseColorOverLifeTime)
				{
					RFX4_ShaderColorGradient rFX4_ShaderColorGradient = gameObject.AddComponent<RFX4_ShaderColorGradient>();
					rFX4_ShaderColorGradient.Color = ColorOverLifeTime;
					rFX4_ShaderColorGradient.TimeMultiplier = ColorLifeTime;
				}
				if (UseUvAnimation)
				{
					RFX4_UVAnimation rFX4_UVAnimation = gameObject.AddComponent<RFX4_UVAnimation>();
					rFX4_UVAnimation.TilesX = TilesX;
					rFX4_UVAnimation.TilesY = TilesY;
					rFX4_UVAnimation.FPS = FPS;
					rFX4_UVAnimation.IsLoop = IsLoop;
				}
				dict.Add(hashCode, lineRenderer);
				continue;
			}
			LineRenderer lineRenderer2 = dict[hashCode];
			if (!(lineRenderer2 == null))
			{
				if (!lineRenderer2.useWorldSpace)
				{
					lineRenderer2.useWorldSpace = true;
					InitTrailRenderer(lineRenderer2.gameObject);
				}
				Vector2 vector = DefaultSizeMultiplayer * particles[i].GetCurrentSize(ps);
				lineRenderer2.startWidth = vector.y;
				lineRenderer2.endWidth = vector.x;
				if (Target != null)
				{
					float num2 = 1f - particles[i].remainingLifetime / particles[i].startLifetime;
					Vector3 a = Vector3.Lerp(particles[i].position, targetT.position, num2);
					lineRenderer2.transform.position = Vector3.Lerp(a, targetT.position, Time.deltaTime * num2);
				}
				else
				{
					lineRenderer2.transform.position = (isLocalSpace ? ps.transform.TransformPoint(particles[i].position) : particles[i].position);
				}
				lineRenderer2.transform.rotation = t.rotation;
				Color32 currentColor = particles[i].GetCurrentColor(ps);
				Color endColor = (lineRenderer2.startColor = psColor * currentColor);
				lineRenderer2.endColor = endColor;
			}
		}
		ps.SetParticles(particles, num);
	}

	private void InitTrailRenderer(GameObject go)
	{
		RFX4_TrailRenderer rFX4_TrailRenderer = go.AddComponent<RFX4_TrailRenderer>();
		rFX4_TrailRenderer.Amplitude = Amplitude;
		rFX4_TrailRenderer.Drag = Drag;
		rFX4_TrailRenderer.Gravity = Gravity;
		rFX4_TrailRenderer.Force = Force;
		rFX4_TrailRenderer.Frequency = Frequency;
		rFX4_TrailRenderer.InheritVelocity = InheritVelocity;
		rFX4_TrailRenderer.VertexLifeTime = VertexLifeTime;
		rFX4_TrailRenderer.TrailLifeTime = TrailLifeTime;
		rFX4_TrailRenderer.MinVertexDistance = MinVertexDistance;
		rFX4_TrailRenderer.OffsetSpeed = OffsetSpeed;
		rFX4_TrailRenderer.SmoothCurves = SmoothCurves;
		rFX4_TrailRenderer.AproximatedFlyDistance = AproximatedFlyDistance;
		rFX4_TrailRenderer.VelocityByDistance = VelocityByDistance;
		rFX4_TrailRenderer.RandomTurbulenceOffset = RandomTurbulenceOffset;
		rFX4_TrailRenderer.TurbulenceStrength = TurbulenceStrength;
	}

	private void RemoveEmptyTrails()
	{
		for (int i = 0; i < dict.Count; i++)
		{
			KeyValuePair<int, LineRenderer> keyValuePair = dict.ElementAt(i);
			if (keyValuePair.Value == null)
			{
				dict.Remove(keyValuePair.Key);
			}
		}
	}

	private void OnDisable()
	{
		foreach (KeyValuePair<int, LineRenderer> item in dict)
		{
			if (item.Value != null)
			{
				UnityEngine.Object.Destroy(item.Value.gameObject);
			}
		}
		dict.Clear();
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(ParticleSystem))]
public class RFX4_Turbulence : MonoBehaviour
{
	public enum MoveMethodEnum
	{
		Position,
		Velocity,
		RelativePosition
	}

	public enum PerfomanceEnum
	{
		High,
		Low
	}

	public float TurbulenceStrenght = 1f;

	public bool TurbulenceByTime;

	public float TimeDelay;

	public AnimationCurve TurbulenceStrengthByTime = AnimationCurve.EaseInOut(1f, 1f, 1f, 1f);

	public Vector3 Frequency = new Vector3(1f, 1f, 1f);

	public Vector3 OffsetSpeed = new Vector3(0.5f, 0.5f, 0.5f);

	public Vector3 Amplitude = new Vector3(5f, 5f, 5f);

	public Vector3 GlobalForce;

	public bool UseGlobalOffset = true;

	public MoveMethodEnum MoveMethod;

	public PerfomanceEnum Perfomance;

	public float ThreshholdSpeed;

	public AnimationCurve VelocityByDistance = AnimationCurve.EaseInOut(0f, 1f, 1f, 1f);

	public float AproximatedFlyDistance = -1f;

	private float lastStopTime;

	private Vector3 currentOffset;

	private float deltaTime;

	private float deltaTimeLastUpdateOffset;

	private ParticleSystem.Particle[] particleArray;

	private ParticleSystem particleSys;

	private float time;

	private int currentSplit;

	private float fpsTime;

	private int FPS;

	private int splitUpdate = 2;

	private PerfomanceEnum perfomanceOldSettings;

	private bool skipFrame;

	private Transform t;

	private float currentDelay;

	private void Start()
	{
		t = base.transform;
		particleSys = GetComponent<ParticleSystem>();
		if (particleArray == null || particleArray.Length < particleSys.main.maxParticles)
		{
			particleArray = new ParticleSystem.Particle[particleSys.main.maxParticles];
		}
		perfomanceOldSettings = Perfomance;
		UpdatePerfomanceSettings();
	}

	private void OnEnable()
	{
		currentDelay = 0f;
	}

	private void Update()
	{
		if (!UnityEngine.Application.isPlaying)
		{
			deltaTime = Time.realtimeSinceStartup - lastStopTime;
			lastStopTime = Time.realtimeSinceStartup;
		}
		else
		{
			deltaTime = Time.deltaTime;
		}
		currentDelay += deltaTime;
		if (currentDelay < TimeDelay)
		{
			return;
		}
		if (!UseGlobalOffset)
		{
			currentOffset += OffsetSpeed * deltaTime;
		}
		else if (UnityEngine.Application.isPlaying)
		{
			currentOffset = OffsetSpeed * Time.time;
		}
		else
		{
			currentOffset = OffsetSpeed * Time.realtimeSinceStartup;
		}
		if (Perfomance != perfomanceOldSettings)
		{
			perfomanceOldSettings = Perfomance;
			UpdatePerfomanceSettings();
		}
		time += deltaTime;
		if (QualitySettings.vSyncCount == 2)
		{
			UpdateTurbulence();
		}
		else if (QualitySettings.vSyncCount == 1)
		{
			if (Perfomance == PerfomanceEnum.Low)
			{
				if (skipFrame)
				{
					UpdateTurbulence();
				}
				skipFrame = !skipFrame;
			}
			if (Perfomance == PerfomanceEnum.High)
			{
				UpdateTurbulence();
			}
		}
		else if (QualitySettings.vSyncCount == 0)
		{
			if (time >= fpsTime)
			{
				time = 0f;
				UpdateTurbulence();
				deltaTimeLastUpdateOffset = 0f;
			}
			else
			{
				deltaTimeLastUpdateOffset += deltaTime;
			}
		}
	}

	private void UpdatePerfomanceSettings()
	{
		if (Perfomance == PerfomanceEnum.High)
		{
			FPS = 80;
			splitUpdate = 2;
		}
		if (Perfomance == PerfomanceEnum.Low)
		{
			FPS = 40;
			splitUpdate = 2;
		}
		fpsTime = 1f / (float)FPS;
	}

	private void UpdateTurbulence()
	{
		int particles = particleSys.GetParticles(particleArray);
		int num = 1;
		int num2;
		int num3;
		if (splitUpdate > 1)
		{
			num2 = particles / splitUpdate * currentSplit;
			num3 = Mathf.CeilToInt((float)particles * 1f / (float)splitUpdate * ((float)currentSplit + 1f));
			num = splitUpdate;
		}
		else
		{
			num2 = 0;
			num3 = particles;
		}
		for (int i = num2; i < num3; i++)
		{
			ParticleSystem.Particle particle = particleArray[i];
			float num4 = 1f;
			if (TurbulenceByTime)
			{
				num4 = TurbulenceStrengthByTime.Evaluate(1f - particle.remainingLifetime / particle.startLifetime);
			}
			if (ThreshholdSpeed > 1E-07f && num4 < ThreshholdSpeed)
			{
				return;
			}
			Vector3 position = particle.position;
			position.x /= Frequency.x + 1E-07f;
			position.y /= Frequency.y + 1E-07f;
			position.z /= Frequency.z + 1E-07f;
			Vector3 vector = default(Vector3);
			float num5 = deltaTime + deltaTimeLastUpdateOffset;
			vector.x = (Mathf.PerlinNoise(position.z - currentOffset.z, position.y - currentOffset.y) * 2f - 1f) * Amplitude.x * num5;
			vector.y = (Mathf.PerlinNoise(position.x - currentOffset.x, position.z - currentOffset.z) * 2f - 1f) * Amplitude.y * num5;
			vector.z = (Mathf.PerlinNoise(position.y - currentOffset.y, position.x - currentOffset.x) * 2f - 1f) * Amplitude.z * num5;
			float num6 = TurbulenceStrenght * num4 * (float)num;
			float num7 = 1f;
			float num8 = Mathf.Abs((particle.position - t.position).magnitude);
			if (AproximatedFlyDistance > 0f)
			{
				num7 = VelocityByDistance.Evaluate(Mathf.Clamp01(num8 / AproximatedFlyDistance));
			}
			vector *= num6;
			if (MoveMethod == MoveMethodEnum.Position)
			{
				particleArray[i].position += vector * num7;
			}
			if (MoveMethod == MoveMethodEnum.Velocity)
			{
				particleArray[i].velocity += vector * num7;
			}
			if (MoveMethod == MoveMethodEnum.RelativePosition)
			{
				particleArray[i].position += vector * particleArray[i].velocity.magnitude;
				particleArray[i].velocity = particleArray[i].velocity * 0.85f + vector.normalized * 0.15f * num7 + GlobalForce * num7;
			}
		}
		particleSys.SetParticles(particleArray, particles);
		currentSplit++;
		if (currentSplit >= splitUpdate)
		{
			currentSplit = 0;
		}
	}
}
public class RFX4_CameraShake : MonoBehaviour
{
	public AnimationCurve ShakeCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 0f);

	public float Duration = 2f;

	public float Speed = 22f;

	public float Magnitude = 1f;

	public float DistanceForce = 100f;

	public float RotationDamper = 2f;

	public bool IsEnabled = true;

	private bool isPlaying;

	[HideInInspector]
	public bool canUpdate;

	private void PlayShake()
	{
		StopAllCoroutines();
		StartCoroutine(Shake());
	}

	private void Update()
	{
		if (isPlaying && IsEnabled)
		{
			isPlaying = false;
			PlayShake();
		}
	}

	private void OnEnable()
	{
		isPlaying = true;
		if (UnityEngine.Object.FindObjectsOfType(typeof(RFX4_CameraShake)) is RFX4_CameraShake[] array)
		{
			RFX4_CameraShake[] array2 = array;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i].canUpdate = false;
			}
		}
		canUpdate = true;
	}

	private IEnumerator Shake()
	{
		float elapsed = 0f;
		Transform camT = Camera.main.transform;
		Vector3 originalCamRotation = camT.rotation.eulerAngles;
		Vector3 direction = (base.transform.position - camT.position).normalized;
		float time = 0f;
		float randomStart = UnityEngine.Random.Range(-1000f, 1000f);
		float distanceDamper = 1f - Mathf.Clamp01((camT.position - base.transform.position).magnitude / DistanceForce);
		Vector3 oldRotation = Vector3.zero;
		while (elapsed < Duration && canUpdate)
		{
			elapsed += Time.deltaTime;
			float num = elapsed / Duration;
			float num2 = ShakeCurve.Evaluate(num) * distanceDamper;
			time += Time.deltaTime * num2;
			camT.position -= direction * Time.deltaTime * Mathf.Sin(time * Speed) * num2 * Magnitude / 2f;
			float num3 = randomStart + Speed * num / 10f;
			float num4 = Mathf.PerlinNoise(num3, 0f) * 2f - 1f;
			float num5 = Mathf.PerlinNoise(1000f + num3, num3 + 1000f) * 2f - 1f;
			float num6 = Mathf.PerlinNoise(0f, num3) * 2f - 1f;
			if (Quaternion.Euler(originalCamRotation + oldRotation) != camT.rotation)
			{
				originalCamRotation = camT.rotation.eulerAngles;
			}
			oldRotation = Mathf.Sin(time * Speed) * num2 * Magnitude * new Vector3(0.5f + num5, 0.3f + num4, 0.3f + num6) * RotationDamper;
			camT.rotation = Quaternion.Euler(originalCamRotation + oldRotation);
			yield return null;
		}
	}
}
public static class RFX4_ColorHelper
{
	public struct HSBColor
	{
		public float H;

		public float S;

		public float B;

		public float A;

		public HSBColor(float h, float s, float b, float a)
		{
			H = h;
			S = s;
			B = b;
			A = a;
		}
	}

	private const float TOLERANCE = 0.0001f;

	private static string[] colorProperties = new string[8] { "_TintColor", "_Color", "_EmissionColor", "_BorderColor", "_ReflectColor", "_RimColor", "_MainColor", "_CoreColor" };

	public static HSBColor ColorToHSV(Color color)
	{
		HSBColor result = new HSBColor(0f, 0f, 0f, color.a);
		float r = color.r;
		float g = color.g;
		float b = color.b;
		float num = Mathf.Max(r, Mathf.Max(g, b));
		if (num <= 0f)
		{
			return result;
		}
		float num2 = Mathf.Min(r, Mathf.Min(g, b));
		float num3 = num - num2;
		if (num > num2)
		{
			if (Math.Abs(g - num) < 0.0001f)
			{
				result.H = (b - r) / num3 * 60f + 120f;
			}
			else if (Math.Abs(b - num) < 0.0001f)
			{
				result.H = (r - g) / num3 * 60f + 240f;
			}
			else if (b > g)
			{
				result.H = (g - b) / num3 * 60f + 360f;
			}
			else
			{
				result.H = (g - b) / num3 * 60f;
			}
			if (result.H < 0f)
			{
				result.H += 360f;
			}
		}
		else
		{
			result.H = 0f;
		}
		result.H *= 0.0027777778f;
		result.S = num3 / num * 1f;
		result.B = num;
		return result;
	}

	public static Color HSVToColor(HSBColor hsbColor)
	{
		float value = hsbColor.B;
		float value2 = hsbColor.B;
		float value3 = hsbColor.B;
		if (Math.Abs(hsbColor.S) > 0.0001f)
		{
			float b = hsbColor.B;
			float num = hsbColor.B * hsbColor.S;
			float num2 = hsbColor.B - num;
			float num3 = hsbColor.H * 360f;
			if (num3 < 60f)
			{
				value = b;
				value2 = num3 * num / 60f + num2;
				value3 = num2;
			}
			else if (num3 < 120f)
			{
				value = (0f - (num3 - 120f)) * num / 60f + num2;
				value2 = b;
				value3 = num2;
			}
			else if (num3 < 180f)
			{
				value = num2;
				value2 = b;
				value3 = (num3 - 120f) * num / 60f + num2;
			}
			else if (num3 < 240f)
			{
				value = num2;
				value2 = (0f - (num3 - 240f)) * num / 60f + num2;
				value3 = b;
			}
			else if (num3 < 300f)
			{
				value = (num3 - 240f) * num / 60f + num2;
				value2 = num2;
				value3 = b;
			}
			else if (num3 <= 360f)
			{
				value = b;
				value2 = num2;
				value3 = (0f - (num3 - 360f)) * num / 60f + num2;
			}
			else
			{
				value = 0f;
				value2 = 0f;
				value3 = 0f;
			}
		}
		return new Color(Mathf.Clamp01(value), Mathf.Clamp01(value2), Mathf.Clamp01(value3), hsbColor.A);
	}

	public static Color ConvertRGBColorByHUE(Color rgbColor, float hue)
	{
		float num = ColorToHSV(rgbColor).B;
		if (num < 0.0001f)
		{
			num = 0.0001f;
		}
		HSBColor hsbColor = ColorToHSV(rgbColor / num);
		hsbColor.H = hue;
		Color result = HSVToColor(hsbColor) * num;
		result.a = rgbColor.a;
		return result;
	}

	public static void ChangeObjectColorByHUE(GameObject go, float hue)
	{
		Renderer[] componentsInChildren = go.GetComponentsInChildren<Renderer>(includeInactive: true);
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			Material material = componentsInChildren[i].material;
			if (material == null)
			{
				continue;
			}
			string[] array = colorProperties;
			foreach (string name in array)
			{
				if (material.HasProperty(name))
				{
					setMatHUEColor(material, name, hue);
				}
			}
		}
		SkinnedMeshRenderer[] componentsInChildren2 = go.GetComponentsInChildren<SkinnedMeshRenderer>(includeInactive: true);
		for (int i = 0; i < componentsInChildren2.Length; i++)
		{
			Material material2 = componentsInChildren2[i].material;
			if (material2 == null)
			{
				continue;
			}
			string[] array = colorProperties;
			foreach (string name2 in array)
			{
				if (material2.HasProperty(name2))
				{
					setMatHUEColor(material2, name2, hue);
				}
			}
		}
		Projector[] componentsInChildren3 = go.GetComponentsInChildren<Projector>(includeInactive: true);
		foreach (Projector projector in componentsInChildren3)
		{
			if (!projector.material.name.EndsWith("(Instance)"))
			{
				projector.material = new Material(projector.material)
				{
					name = projector.material.name + " (Instance)"
				};
			}
			Material material3 = projector.material;
			if (material3 == null)
			{
				continue;
			}
			string[] array = colorProperties;
			foreach (string name3 in array)
			{
				if (material3.HasProperty(name3))
				{
					projector.material = setMatHUEColor(material3, name3, hue);
				}
			}
		}
		Light[] componentsInChildren4 = go.GetComponentsInChildren<Light>(includeInactive: true);
		foreach (Light obj in componentsInChildren4)
		{
			HSBColor hsbColor = ColorToHSV(obj.color);
			hsbColor.H = hue;
			obj.color = HSVToColor(hsbColor);
		}
		ParticleSystem[] componentsInChildren5 = go.GetComponentsInChildren<ParticleSystem>(includeInactive: true);
		foreach (ParticleSystem obj2 in componentsInChildren5)
		{
			ParticleSystem.MainModule main = obj2.main;
			HSBColor hsbColor2 = ColorToHSV(obj2.main.startColor.color);
			hsbColor2.H = hue;
			main.startColor = HSVToColor(hsbColor2);
		}
		RFX4_ParticleTrail[] componentsInChildren6 = go.GetComponentsInChildren<RFX4_ParticleTrail>(includeInactive: true);
		foreach (RFX4_ParticleTrail rFX4_ParticleTrail in componentsInChildren6)
		{
			Material trailMaterial = rFX4_ParticleTrail.TrailMaterial;
			if (trailMaterial == null)
			{
				continue;
			}
			trailMaterial = (rFX4_ParticleTrail.TrailMaterial = new Material(rFX4_ParticleTrail.TrailMaterial));
			string[] array = colorProperties;
			foreach (string name4 in array)
			{
				if (trailMaterial.HasProperty(name4))
				{
					setMatHUEColor(trailMaterial, name4, hue);
				}
			}
		}
		RFX4_ShaderColorGradient[] componentsInChildren7 = go.GetComponentsInChildren<RFX4_ShaderColorGradient>(includeInactive: true);
		for (int i = 0; i < componentsInChildren7.Length; i++)
		{
			componentsInChildren7[i].HUE = hue;
		}
	}

	private static Material setMatHUEColor(Material mat, string name, float hueColor)
	{
		Color value = ConvertRGBColorByHUE(mat.GetColor(name), hueColor);
		mat.SetColor(name, value);
		return mat;
	}

	private static Material setMatAlphaColor(Material mat, string name, float alpha)
	{
		Color color = mat.GetColor(name);
		color.a = alpha;
		mat.SetColor(name, color);
		return mat;
	}
}
public class RFX4_CopyPosition : MonoBehaviour
{
	public Transform CopiedTransform;

	private Transform t;

	private void Start()
	{
		t = base.transform;
	}

	private void Update()
	{
		t.position = CopiedTransform.position;
	}
}
public class RFX4_DeactivateByTime : MonoBehaviour
{
	public float DeactivateTime = 3f;

	private bool canUpdateState;

	private void OnEnable()
	{
		canUpdateState = true;
	}

	private void Update()
	{
		if (canUpdateState)
		{
			canUpdateState = false;
			Invoke("DeactivateThis", DeactivateTime);
		}
	}

	private void DeactivateThis()
	{
		base.gameObject.SetActive(value: false);
	}
}
public class RFX4_DeactivateRigidbodyByTime : MonoBehaviour
{
	public float TimeDelayToDeactivate = 6f;

	private void OnEnable()
	{
		Rigidbody component = GetComponent<Rigidbody>();
		component.isKinematic = false;
		component.detectCollisions = true;
		Invoke("Deactivate", TimeDelayToDeactivate);
	}

	private void Deactivate()
	{
		Rigidbody component = GetComponent<Rigidbody>();
		component.isKinematic = true;
		component.detectCollisions = false;
	}
}
public class RFX4_DemoReactivation : MonoBehaviour
{
	public float ReactivationTime = 5f;

	public GameObject Effect;

	private void Start()
	{
		InvokeRepeating("Reactivate", 0f, ReactivationTime);
	}

	private void Reactivate()
	{
		Effect.SetActive(value: false);
		Effect.SetActive(value: true);
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(Camera))]
[AddComponentMenu("KriptoFX/RFX4_BloomAndDistortion")]
[ImageEffectAllowedInSceneView]
public class RFX4_DistortionAndBloom : MonoBehaviour
{
	[Range(0.05f, 1f)]
	[Tooltip("Camera render texture resolution")]
	public float RenderTextureResolutoinFactor = 0.25f;

	public bool UseBloom = true;

	[Range(0.1f, 3f)]
	[Tooltip("Filters out pixels under this level of brightness.")]
	public float Threshold = 2f;

	[SerializeField]
	[Range(0f, 1f)]
	[Tooltip("Makes transition between under/over-threshold gradual.")]
	public float SoftKnee;

	[Range(1f, 7f)]
	[Tooltip("Changes extent of veiling effects in A screen resolution-independent fashion.")]
	public float Radius = 7f;

	[Tooltip("Blend factor of the result image.")]
	public float Intensity = 1f;

	[Tooltip("Controls filter quality and buffer resolution.")]
	public bool HighQuality;

	[Tooltip("Reduces flashing noise with an additional filter.")]
	public bool AntiFlicker;

	private const string shaderName = "Hidden/KriptoFX/PostEffects/RFX4_Bloom";

	private const string shaderAdditiveName = "Hidden/KriptoFX/PostEffects/RFX4_BloomAdditive";

	private RenderTexture source;

	private RenderTexture destination;

	private int previuosFrameWidth;

	private int previuosFrameHeight;

	private float previousScale;

	private Camera _cameraInstance;

	private Material m_Material;

	private Material m_MaterialAdditive;

	private const int kMaxIterations = 16;

	private readonly RenderTexture[] m_blurBuffer1 = new RenderTexture[16];

	private readonly RenderTexture[] m_blurBuffer2 = new RenderTexture[16];

	public Material mat
	{
		get
		{
			if (m_Material == null)
			{
				m_Material = CheckShaderAndCreateMaterial(Shader.Find("Hidden/KriptoFX/PostEffects/RFX4_Bloom"));
			}
			return m_Material;
		}
	}

	public Material matAdditive
	{
		get
		{
			if (m_MaterialAdditive == null)
			{
				m_MaterialAdditive = CheckShaderAndCreateMaterial(Shader.Find("Hidden/KriptoFX/PostEffects/RFX4_BloomAdditive"));
				m_MaterialAdditive.renderQueue = 3900;
			}
			return m_MaterialAdditive;
		}
	}

	public static Material CheckShaderAndCreateMaterial(Shader s)
	{
		if (s == null || !s.isSupported)
		{
			return null;
		}
		return new Material(s)
		{
			hideFlags = HideFlags.DontSave
		};
	}

	private void OnDisable()
	{
		if (m_Material != null)
		{
			UnityEngine.Object.DestroyImmediate(m_Material);
		}
		m_Material = null;
		if (m_MaterialAdditive != null)
		{
			UnityEngine.Object.DestroyImmediate(m_MaterialAdditive);
		}
		m_MaterialAdditive = null;
		if (_cameraInstance != null)
		{
			_cameraInstance.gameObject.SetActive(value: false);
		}
	}

	private void OnDestroy()
	{
		if (_cameraInstance != null)
		{
			UnityEngine.Object.DestroyImmediate(_cameraInstance.gameObject);
		}
	}

	private void OnGUI()
	{
		if (Event.current.type.Equals(EventType.Repaint) && UseBloom)
		{
			Graphics.DrawTexture(new Rect(0f, 0f, Screen.width, Screen.height), destination, matAdditive);
		}
	}

	private void Start()
	{
		InitializeRenderTarget();
	}

	private void LateUpdate()
	{
		if (previuosFrameWidth != Screen.width || previuosFrameHeight != Screen.height || Mathf.Abs(previousScale - RenderTextureResolutoinFactor) > 0.01f)
		{
			InitializeRenderTarget();
			previuosFrameWidth = Screen.width;
			previuosFrameHeight = Screen.height;
			previousScale = RenderTextureResolutoinFactor;
		}
		Shader.EnableKeyword("DISTORT_OFF");
		UpdateCameraCopy();
		if (UseBloom)
		{
			UpdateBloom();
		}
		Shader.SetGlobalTexture("_GrabTextureMobile", source);
		Shader.SetGlobalFloat("_GrabTextureMobileScale", RenderTextureResolutoinFactor);
		Shader.DisableKeyword("DISTORT_OFF");
	}

	private void InitializeRenderTarget()
	{
		int num = (int)((float)Screen.width * RenderTextureResolutoinFactor);
		int num2 = (int)((float)Screen.height * RenderTextureResolutoinFactor);
		source = new RenderTexture(num, num2, 16, RenderTextureFormat.DefaultHDR);
		if (UseBloom)
		{
			destination = new RenderTexture(((double)RenderTextureResolutoinFactor > 0.99) ? num : (num / 2), ((double)RenderTextureResolutoinFactor > 0.99) ? num2 : (num2 / 2), 0, RenderTextureFormat.ARGB32);
		}
	}

	private void UpdateBloom()
	{
		bool isMobilePlatform = UnityEngine.Application.isMobilePlatform;
		int num = source.width;
		int num2 = source.height;
		if (!HighQuality)
		{
			num /= 2;
			num2 /= 2;
		}
		RenderTextureFormat format = (isMobilePlatform ? RenderTextureFormat.Default : RenderTextureFormat.DefaultHDR);
		float num3 = Mathf.Log(num2, 2f) + Radius - 8f;
		int num4 = (int)num3;
		int num5 = Mathf.Clamp(num4, 1, 16);
		float num6 = Mathf.GammaToLinearSpace(Threshold);
		mat.SetFloat("_Threshold", num6);
		float num7 = num6 * SoftKnee + 1E-05f;
		Vector3 vector = new Vector3(num6 - num7, num7 * 2f, 0.25f / num7);
		mat.SetVector("_Curve", vector);
		bool flag = !HighQuality && AntiFlicker;
		mat.SetFloat("_PrefilterOffs", flag ? (-0.5f) : 0f);
		mat.SetFloat("_SampleScale", 0.5f + num3 - (float)num4);
		mat.SetFloat("_Intensity", Mathf.Max(0f, Intensity));
		RenderTexture temporary = RenderTexture.GetTemporary(num, num2, 0, format);
		Graphics.Blit(source, temporary, mat, AntiFlicker ? 1 : 0);
		RenderTexture renderTexture = temporary;
		for (int i = 0; i < num5; i++)
		{
			m_blurBuffer1[i] = RenderTexture.GetTemporary(renderTexture.width / 2, renderTexture.height / 2, 0, format);
			Graphics.Blit(renderTexture, m_blurBuffer1[i], mat, (i == 0) ? (AntiFlicker ? 3 : 2) : 4);
			renderTexture = m_blurBuffer1[i];
		}
		for (int num8 = num5 - 2; num8 >= 0; num8--)
		{
			RenderTexture renderTexture2 = m_blurBuffer1[num8];
			mat.SetTexture("_BaseTex", renderTexture2);
			m_blurBuffer2[num8] = RenderTexture.GetTemporary(renderTexture2.width, renderTexture2.height, 0, format);
			Graphics.Blit(renderTexture, m_blurBuffer2[num8], mat, HighQuality ? 6 : 5);
			renderTexture = m_blurBuffer2[num8];
		}
		destination.DiscardContents();
		Graphics.Blit(renderTexture, destination, mat, HighQuality ? 8 : 7);
		for (int j = 0; j < 16; j++)
		{
			if (m_blurBuffer1[j] != null)
			{
				RenderTexture.ReleaseTemporary(m_blurBuffer1[j]);
			}
			if (m_blurBuffer2[j] != null)
			{
				RenderTexture.ReleaseTemporary(m_blurBuffer2[j]);
			}
			m_blurBuffer1[j] = null;
			m_blurBuffer2[j] = null;
		}
		RenderTexture.ReleaseTemporary(temporary);
	}

	private void InitializeCameraCopy()
	{
		if (_cameraInstance != null)
		{
			_cameraInstance.gameObject.SetActive(value: true);
		}
		GameObject gameObject = GameObject.Find("RenderTextureCamera");
		if (gameObject == null)
		{
			GameObject gameObject2 = new GameObject("RenderTextureCamera");
			gameObject2.transform.parent = Camera.main.transform;
			_cameraInstance = gameObject2.AddComponent<Camera>();
			_cameraInstance.CopyFrom(Camera.main);
			_cameraInstance.clearFlags = Camera.main.clearFlags;
			_cameraInstance.depth--;
			_cameraInstance.allowHDR = true;
			_cameraInstance.targetTexture = source;
			Shader.SetGlobalTexture("_GrabTextureMobile", source);
			Shader.SetGlobalFloat("_GrabTextureMobileScale", RenderTextureResolutoinFactor);
			_cameraInstance.Render();
		}
		else
		{
			_cameraInstance = gameObject.GetComponent<Camera>();
		}
	}

	private void UpdateCameraCopy()
	{
		Camera current = Camera.current;
		if (current != null && current.name == "SceneCamera")
		{
			source.DiscardContents();
			current.targetTexture = source;
			current.Render();
			current.targetTexture = null;
			return;
		}
		current = Camera.main;
		bool allowHDR = current.allowHDR;
		source.DiscardContents();
		current.allowHDR = true;
		current.targetTexture = source;
		current.Render();
		current.allowHDR = allowHDR;
		current.targetTexture = null;
	}
}
public class RFX4_EffectEvent : MonoBehaviour
{
	public GameObject CharacterEffect;

	public Transform CharacterAttachPoint;

	public GameObject CharacterEffect2;

	public Transform CharacterAttachPoint2;

	public GameObject Effect;

	public Transform AttachPoint;

	public GameObject AdditionalEffect;

	public Transform AdditionalEffectAttachPoint;

	private void OnEnable()
	{
		if (Effect != null)
		{
			Effect.SetActive(value: false);
		}
		if (AdditionalEffect != null)
		{
			AdditionalEffect.SetActive(value: false);
		}
		if (CharacterEffect != null)
		{
			CharacterEffect.SetActive(value: false);
		}
		if (CharacterEffect2 != null)
		{
			CharacterEffect2.SetActive(value: false);
		}
	}

	public void ActivateEffect()
	{
		if (!(Effect == null))
		{
			Effect.SetActive(value: true);
		}
	}

	public void ActivateAdditionalEffect()
	{
		if (!(AdditionalEffect == null))
		{
			AdditionalEffect.SetActive(value: true);
		}
	}

	public void ActivateCharacterEffect()
	{
		if (!(CharacterEffect == null))
		{
			CharacterEffect.SetActive(value: true);
		}
	}

	public void ActivateCharacterEffect2()
	{
		if (!(CharacterEffect2 == null))
		{
			CharacterEffect2.SetActive(value: true);
		}
	}

	private void LateUpdate()
	{
		if (Effect != null && AttachPoint != null)
		{
			Effect.transform.position = AttachPoint.position;
		}
		if (AdditionalEffect != null && AdditionalEffectAttachPoint != null)
		{
			AdditionalEffect.transform.position = AdditionalEffectAttachPoint.position;
		}
		if (CharacterEffect != null && CharacterAttachPoint != null)
		{
			CharacterEffect.transform.position = CharacterAttachPoint.position;
		}
		if (CharacterEffect2 != null && CharacterAttachPoint2 != null)
		{
			CharacterEffect2.transform.position = CharacterAttachPoint2.position;
		}
	}
}
[RequireComponent(typeof(Renderer))]
[ExecuteInEditMode]
public class RFX4_MaterialQueue : MonoBehaviour
{
	[Tooltip("Background=1000, Geometry=2000, AlphaTest=2450, Transparent=3000, Overlay=4000")]
	public int queue = 2000;

	public int[] queues;

	private void Start()
	{
		Renderer component = GetComponent<Renderer>();
		if ((bool)component && (bool)component.sharedMaterial && queues != null)
		{
			component.sharedMaterial.renderQueue = queue;
			for (int i = 0; i < queues.Length && i < component.sharedMaterials.Length; i++)
			{
				component.sharedMaterials[i].renderQueue = queues[i];
			}
		}
	}

	private void OnValidate()
	{
		Start();
	}

	private void Update()
	{
		if (!UnityEngine.Application.isPlaying)
		{
			Start();
		}
	}
}
public class RFX4_OnEnableResetTransform : MonoBehaviour
{
	private Transform t;

	private Vector3 startPosition;

	private Quaternion startRotation;

	private Vector3 startScale;

	private bool isInitialized;

	private void OnEnable()
	{
		if (!isInitialized)
		{
			isInitialized = true;
			t = base.transform;
			startPosition = t.position;
			startRotation = t.rotation;
			startScale = t.localScale;
		}
		else
		{
			t.position = startPosition;
			t.rotation = startRotation;
			t.localScale = startScale;
		}
	}

	private void OnDisable()
	{
		if (!isInitialized)
		{
			isInitialized = true;
			t = base.transform;
			startPosition = t.position;
			startRotation = t.rotation;
			startScale = t.localScale;
		}
		else
		{
			t.position = startPosition;
			t.rotation = startRotation;
			t.localScale = startScale;
		}
	}
}
public class RFX4_PhysXSetImpulse : MonoBehaviour
{
	public float Force = 1f;

	public ForceMode ForceMode;

	private Rigidbody rig;

	private Transform t;

	private void Start()
	{
		rig = GetComponent<Rigidbody>();
		t = base.transform;
	}

	private void FixedUpdate()
	{
		if (rig != null)
		{
			rig.AddForce(t.forward * Force, ForceMode);
		}
	}

	private void OnDisable()
	{
		if (rig != null)
		{
			rig.velocity = Vector3.zero;
		}
	}
}
public class RFX4_RaycastCollision : MonoBehaviour
{
	public float RaycastDistance = 100f;

	public GameObject[] Effects;

	public float Offset;

	public float TimeDelay;

	public float DestroyTime = 3f;

	public bool UsePivotPosition;

	public bool UseNormalRotation = true;

	public bool IsWorldSpace = true;

	public bool RealTimeUpdateRaycast;

	public bool DestroyAfterDisabling;

	[HideInInspector]
	public float HUE = -1f;

	[HideInInspector]
	public List<GameObject> CollidedInstances = new List<GameObject>();

	private bool isInitialized;

	private bool canUpdate;

	private void Start()
	{
		isInitialized = true;
		if (TimeDelay < 0.001f)
		{
			UpdateRaycast();
		}
		else
		{
			Invoke("LateEnable", TimeDelay);
		}
	}

	private void OnEnable()
	{
		CollidedInstances.Clear();
		if (isInitialized)
		{
			if (TimeDelay < 0.001f)
			{
				UpdateRaycast();
			}
			else
			{
				Invoke("LateEnable", TimeDelay);
			}
		}
	}

	private void OnDisable()
	{
		if (!DestroyAfterDisabling)
		{
			return;
		}
		foreach (GameObject collidedInstance in CollidedInstances)
		{
			UnityEngine.Object.Destroy(collidedInstance);
		}
	}

	private void Update()
	{
		if (canUpdate)
		{
			UpdateRaycast();
		}
	}

	private void LateEnable()
	{
		UpdateRaycast();
	}

	private void UpdateRaycast()
	{
		if (Physics.Raycast(base.transform.position, base.transform.forward, out var hitInfo, RaycastDistance))
		{
			Vector3 position = ((!UsePivotPosition) ? (hitInfo.point + hitInfo.normal * Offset) : hitInfo.transform.position);
			if (CollidedInstances.Count == 0)
			{
				GameObject[] effects = Effects;
				for (int i = 0; i < effects.Length; i++)
				{
					GameObject gameObject = UnityEngine.Object.Instantiate(effects[i], position, default(Quaternion));
					CollidedInstances.Add(gameObject);
					if (HUE > -0.9f)
					{
						RFX4_ColorHelper.ChangeObjectColorByHUE(gameObject, HUE);
					}
					if (!IsWorldSpace)
					{
						gameObject.transform.parent = base.transform;
					}
					if (UseNormalRotation)
					{
						gameObject.transform.LookAt(hitInfo.point + hitInfo.normal);
					}
					if (DestroyTime > 0.0001f)
					{
						UnityEngine.Object.Destroy(gameObject, DestroyTime);
					}
				}
			}
			else
			{
				foreach (GameObject collidedInstance in CollidedInstances)
				{
					if (!(collidedInstance == null))
					{
						collidedInstance.transform.position = position;
						if (UseNormalRotation)
						{
							collidedInstance.transform.LookAt(hitInfo.point + hitInfo.normal);
						}
					}
				}
			}
		}
		if (RealTimeUpdateRaycast)
		{
			canUpdate = true;
		}
	}

	private void OnDrawGizmosSelected()
	{
		Gizmos.color = Color.blue;
		Gizmos.DrawLine(base.transform.position, base.transform.position + base.transform.forward * RaycastDistance);
	}
}
public class RFX4_ReplaceMaterialByTime : MonoBehaviour
{
	public Material ReplacementMaterial;

	public float TimeDelay = 1f;

	public bool ChangeShadow = true;

	private bool isInitialized;

	private Material mat;

	private MeshRenderer mshRend;

	private void Start()
	{
		isInitialized = true;
		mshRend = GetComponent<MeshRenderer>();
		mat = mshRend.sharedMaterial;
		Invoke("ReplaceObject", TimeDelay);
	}

	private void OnEnable()
	{
		if (isInitialized)
		{
			mshRend.sharedMaterial = mat;
			Invoke("ReplaceObject", TimeDelay);
		}
	}

	private void ReplaceObject()
	{
		mshRend.sharedMaterial = ReplacementMaterial;
	}
}
public class RFX4_ReplaceModelOnCollision : MonoBehaviour
{
	public GameObject PhysicsObjects;

	private bool isCollided;

	private Transform t;

	private void OnCollisionEnter(Collision collision)
	{
		if (!isCollided)
		{
			isCollided = true;
			PhysicsObjects.SetActive(value: true);
			MeshRenderer component = GetComponent<MeshRenderer>();
			if (component != null)
			{
				component.enabled = false;
			}
			Rigidbody component2 = GetComponent<Rigidbody>();
			component2.isKinematic = true;
			component2.detectCollisions = false;
		}
	}

	private void OnEnable()
	{
		isCollided = false;
		PhysicsObjects.SetActive(value: false);
		MeshRenderer component = GetComponent<MeshRenderer>();
		if (component != null)
		{
			component.enabled = true;
		}
		Rigidbody component2 = GetComponent<Rigidbody>();
		component2.isKinematic = false;
		component2.detectCollisions = true;
	}
}
public class RFX4_RotateAround : MonoBehaviour
{
	public Vector3 Offset = Vector3.forward;

	public Vector3 RotateVector = Vector3.forward;

	public float LifeTime = 1f;

	private Transform t;

	private float currentTime;

	private Quaternion rotation;

	private void Start()
	{
		t = base.transform;
		rotation = t.rotation;
	}

	private void OnEnable()
	{
		currentTime = 0f;
		if (t != null)
		{
			t.rotation = rotation;
		}
	}

	private void Update()
	{
		if (!(currentTime >= LifeTime) || !(LifeTime > 0.0001f))
		{
			currentTime += Time.deltaTime;
			t.Rotate(RotateVector * Time.deltaTime);
		}
	}
}
public class RFX4_StartDelay : MonoBehaviour
{
	public GameObject ActivatedGameObject;

	public float Delay = 1f;

	private void OnEnable()
	{
		ActivatedGameObject.SetActive(value: false);
		Invoke("ActivateGO", Delay);
	}

	private void ActivateGO()
	{
		ActivatedGameObject.SetActive(value: true);
	}

	private void OnDisable()
	{
		CancelInvoke("ActivateGO");
	}
}
public enum RFX4_TextureShaderProperties
{
	_MainTex,
	_DistortTex,
	_Mask,
	_Cutout,
	_CutoutTex,
	_Bump,
	_BumpTex,
	_EmissionTex
}
public class RFX4_TornadoParticles : MonoBehaviour
{
	public Material TornadoMaterial;

	private ParticleSystem.Particle[] particleArray;

	private ParticleSystem particleSys;

	private Light myLight;

	private Vector4 _twistScale;

	private int materialID = -1;

	private void Start()
	{
		particleSys = GetComponent<ParticleSystem>();
		myLight = GetComponent<Light>();
		if (particleSys != null)
		{
			particleArray = new ParticleSystem.Particle[particleSys.main.maxParticles];
		}
		if (TornadoMaterial.HasProperty("_TwistScale"))
		{
			materialID = Shader.PropertyToID("_TwistScale");
		}
		else
		{
			UnityEngine.Debug.Log(TornadoMaterial.name + " not have property twist");
		}
		if (materialID != -1)
		{
			_twistScale = TornadoMaterial.GetVector(materialID);
		}
	}

	private void Update()
	{
		if (particleSys != null)
		{
			int particles = particleSys.GetParticles(particleArray);
			for (int i = 0; i < particles; i++)
			{
				Vector3 position = particleArray[i].position;
				float num = (position.y - base.transform.position.y) * _twistScale.y;
				position.x = Mathf.Sin(Time.time * _twistScale.z + position.y * _twistScale.x) * num;
				position.z = Mathf.Sin(Time.time * _twistScale.z + position.y * _twistScale.x + 1.57075f) * num;
				particleArray[i].position = position;
				particleSys.SetParticles(particleArray, particles);
			}
		}
		if (myLight != null)
		{
			Vector3 localPosition = base.transform.localPosition;
			float num2 = localPosition.y * _twistScale.y;
			localPosition.x = Mathf.Sin(Time.time * _twistScale.z + localPosition.y * _twistScale.x) * num2;
			localPosition.z = Mathf.Sin(Time.time * _twistScale.z + localPosition.y * _twistScale.x + 1.57075f) * num2;
			base.transform.localPosition = localPosition;
		}
	}
}
[RequireComponent(typeof(LineRenderer))]
public class RFX4_TrailRenderer : MonoBehaviour
{
	public float VertexLifeTime = 2f;

	public float TrailLifeTime = 2f;

	[Range(0.001f, 1f)]
	public float MinVertexDistance = 0.01f;

	public float Gravity = 0.01f;

	public Vector3 Force = new Vector3(0f, 0f, 0f);

	public float InheritVelocity;

	public float Drag = 0.01f;

	[Range(0.001f, 10f)]
	public float Frequency = 1f;

	[Range(0.001f, 10f)]
	public float OffsetSpeed = 0.5f;

	public bool RandomTurbulenceOffset;

	[Range(0.001f, 10f)]
	public float Amplitude = 2f;

	public float TurbulenceStrength = 0.1f;

	public AnimationCurve VelocityByDistance = AnimationCurve.EaseInOut(0f, 1f, 1f, 1f);

	public float AproximatedFlyDistance = -1f;

	public bool SmoothCurves;

	private LineRenderer lineRenderer;

	private List<Vector3> positions;

	private List<float> currentTimes;

	private List<Vector3> velocities;

	[HideInInspector]
	public float currentLifeTime;

	private Transform t;

	private Vector3 prevPosition;

	private Vector3 startPosition;

	private List<Vector3> controlPoints = new List<Vector3>();

	private int curveCount;

	private const float MinimumSqrDistance = 0.01f;

	private const float DivisionThreshold = -0.99f;

	private const float SmoothCurvesScale = 0.5f;

	private float currentVelocity;

	private float turbulenceRandomOffset;

	private bool isInitialized;

	private void Start()
	{
		Init();
		isInitialized = true;
	}

	private void OnEnable()
	{
		if (isInitialized)
		{
			Init();
		}
	}

	private void Init()
	{
		positions = new List<Vector3>();
		currentTimes = new List<float>();
		velocities = new List<Vector3>();
		currentLifeTime = 0f;
		curveCount = 0;
		currentVelocity = 0f;
		t = base.transform;
		prevPosition = t.position;
		startPosition = t.position;
		lineRenderer = GetComponent<LineRenderer>();
		lineRenderer.positionCount = 0;
		lineRenderer.startColor = Color.white;
		lineRenderer.endColor = Color.white;
		positions.Add(t.position);
		currentTimes.Add(currentLifeTime);
		velocities.Add(Vector3.zero);
		turbulenceRandomOffset = (RandomTurbulenceOffset ? (UnityEngine.Random.Range(0f, 10000f) / 1000f) : 0f);
	}

	private void Update()
	{
		UpdatePositionsCount();
		UpdateForce();
		UpdateImpulse();
		UpdateVelocity();
		int lastDeletedIndex = GetLastDeletedIndex();
		RemovePositionsBeforeIndex(lastDeletedIndex);
		if (SmoothCurves && positions.Count > 2)
		{
			InterpolateBezier(positions, 0.5f);
			List<Vector3> drawingPoints = GetDrawingPoints();
			lineRenderer.positionCount = drawingPoints.Count;
			lineRenderer.SetPositions(drawingPoints.ToArray());
		}
		else
		{
			lineRenderer.positionCount = positions.Count;
			lineRenderer.SetPositions(positions.ToArray());
		}
	}

	private int GetLastDeletedIndex()
	{
		int result = -1;
		int count = currentTimes.Count;
		for (int i = 1; i < count; i++)
		{
			currentTimes[i] -= Time.deltaTime;
			if (currentTimes[i] <= 0f)
			{
				result = i;
			}
		}
		return result;
	}

	private void UpdatePositionsCount()
	{
		if (!(TrailLifeTime > 0.0001f) || !(currentLifeTime > TrailLifeTime))
		{
			currentLifeTime += Time.deltaTime;
			Vector3 vector = ((positions.Count != 0) ? positions[positions.Count - 1] : Vector3.zero);
			if (Mathf.Abs((t.position - vector).magnitude) > MinVertexDistance && positions.Count > 0)
			{
				AddInterpolatedPositions(vector, t.position);
			}
		}
	}

	private void AddInterpolatedPositions(Vector3 start, Vector3 end)
	{
		int num = (int)((start - end).magnitude / MinVertexDistance);
		float num2 = currentTimes.LastOrDefault();
		Vector3 zero = Vector3.zero;
		for (int i = 1; i <= num - 1; i++)
		{
			Vector3 item = start + (end - start) * i * 1f / num;
			float item2 = num2 + (VertexLifeTime - num2) * (float)i * 1f / (float)num;
			positions.Add(item);
			currentTimes.Add(item2);
			velocities.Add(zero);
		}
	}

	private void RemovePositionsBeforeIndex(int lastDeletedIndex)
	{
		if (lastDeletedIndex != -1)
		{
			if (positions.Count - lastDeletedIndex == 1)
			{
				positions.Clear();
				currentTimes.Clear();
				velocities.Clear();
			}
			else
			{
				positions.RemoveRange(0, lastDeletedIndex);
				currentTimes.RemoveRange(0, lastDeletedIndex);
				velocities.RemoveRange(0, lastDeletedIndex);
			}
		}
	}

	private void UpdateForce()
	{
		if (positions.Count < 1)
		{
			return;
		}
		Vector3 vector = Gravity * Vector3.down * Time.deltaTime;
		Vector3 vector2 = t.rotation * Force * Time.deltaTime;
		for (int i = 0; i < positions.Count; i++)
		{
			Vector3 zero = Vector3.zero;
			if (TurbulenceStrength > 1E-06f)
			{
				Vector3 vector3 = positions[i] / Frequency;
				float num = (Time.time + turbulenceRandomOffset) * OffsetSpeed;
				vector3 -= num * Vector3.one;
				zero.x += (Mathf.PerlinNoise(vector3.z, vector3.y) * 2f - 1f) * Amplitude * Time.deltaTime * TurbulenceStrength / 10f;
				zero.y += (Mathf.PerlinNoise(vector3.x, vector3.z) * 2f - 1f) * Amplitude * Time.deltaTime * TurbulenceStrength / 10f;
				zero.z += (Mathf.PerlinNoise(vector3.y, vector3.x) * 2f - 1f) * Amplitude * Time.deltaTime * TurbulenceStrength / 10f;
			}
			Vector3 vector4 = vector + vector2 + zero;
			if (AproximatedFlyDistance > 0.01f)
			{
				float num2 = Mathf.Abs((positions[i] - startPosition).magnitude);
				vector4 *= VelocityByDistance.Evaluate(Mathf.Clamp01(num2 / AproximatedFlyDistance));
			}
			velocities[i] += vector4;
		}
	}

	private void UpdateImpulse()
	{
		if (velocities.Count != 0)
		{
			currentVelocity = (t.position - prevPosition).magnitude / Time.deltaTime;
			Vector3 normalized = (t.position - prevPosition).normalized;
			prevPosition = t.position;
			velocities[velocities.Count - 1] += currentVelocity * InheritVelocity * normalized * Time.deltaTime;
		}
	}

	private void UpdateVelocity()
	{
		if (velocities.Count == 0)
		{
			return;
		}
		int count = positions.Count;
		for (int i = 0; i < count; i++)
		{
			if (Drag > 1E-05f)
			{
				velocities[i] -= Drag * velocities[i] * Time.deltaTime;
			}
			if (velocities[i].magnitude < 1E-05f)
			{
				velocities[i] = Vector3.zero;
			}
			positions[i] += velocities[i] * Time.deltaTime;
		}
	}

	public void InterpolateBezier(List<Vector3> segmentPoints, float scale)
	{
		controlPoints.Clear();
		if (segmentPoints.Count < 2)
		{
			return;
		}
		for (int i = 0; i < segmentPoints.Count; i++)
		{
			if (i == 0)
			{
				Vector3 vector = segmentPoints[i];
				Vector3 vector2 = segmentPoints[i + 1] - vector;
				Vector3 item = vector + scale * vector2;
				controlPoints.Add(vector);
				controlPoints.Add(item);
			}
			else if (i == segmentPoints.Count - 1)
			{
				Vector3 vector3 = segmentPoints[i - 1];
				Vector3 vector4 = segmentPoints[i];
				Vector3 vector5 = vector4 - vector3;
				Vector3 item2 = vector4 - scale * vector5;
				controlPoints.Add(item2);
				controlPoints.Add(vector4);
			}
			else
			{
				Vector3 vector6 = segmentPoints[i - 1];
				Vector3 vector7 = segmentPoints[i];
				Vector3 vector8 = segmentPoints[i + 1];
				Vector3 normalized = (vector8 - vector6).normalized;
				Vector3 item3 = vector7 - scale * normalized * (vector7 - vector6).magnitude;
				Vector3 item4 = vector7 + scale * normalized * (vector8 - vector7).magnitude;
				controlPoints.Add(item3);
				controlPoints.Add(vector7);
				controlPoints.Add(item4);
			}
		}
		curveCount = (controlPoints.Count - 1) / 3;
	}

	public List<Vector3> GetDrawingPoints()
	{
		List<Vector3> list = new List<Vector3>();
		for (int i = 0; i < curveCount; i++)
		{
			List<Vector3> list2 = FindDrawingPoints(i);
			if (i != 0)
			{
				list2.RemoveAt(0);
			}
			list.AddRange(list2);
		}
		return list;
	}

	private List<Vector3> FindDrawingPoints(int curveIndex)
	{
		List<Vector3> list = new List<Vector3>();
		Vector3 item = CalculateBezierPoint(curveIndex, 0f);
		Vector3 item2 = CalculateBezierPoint(curveIndex, 1f);
		list.Add(item);
		list.Add(item2);
		FindDrawingPoints(curveIndex, 0f, 1f, list, 1);
		return list;
	}

	private int FindDrawingPoints(int curveIndex, float t0, float t1, List<Vector3> pointList, int insertionIndex)
	{
		Vector3 vector = CalculateBezierPoint(curveIndex, t0);
		Vector3 vector2 = CalculateBezierPoint(curveIndex, t1);
		if ((vector - vector2).sqrMagnitude < 0.01f)
		{
			return 0;
		}
		float num = (t0 + t1) / 2f;
		Vector3 vector3 = CalculateBezierPoint(curveIndex, num);
		Vector3 normalized = (vector - vector3).normalized;
		Vector3 normalized2 = (vector2 - vector3).normalized;
		if (Vector3.Dot(normalized, normalized2) > -0.99f || Mathf.Abs(num - 0.5f) < 0.0001f)
		{
			int num2 = 0;
			num2 += FindDrawingPoints(curveIndex, t0, num, pointList, insertionIndex);
			pointList.Insert(insertionIndex + num2, vector3);
			num2++;
			return num2 + FindDrawingPoints(curveIndex, num, t1, pointList, insertionIndex + num2);
		}
		return 0;
	}

	public Vector3 CalculateBezierPoint(int curveIndex, float t)
	{
		int num = curveIndex * 3;
		Vector3 p = controlPoints[num];
		Vector3 p2 = controlPoints[num + 1];
		Vector3 p3 = controlPoints[num + 2];
		Vector3 p4 = controlPoints[num + 3];
		return CalculateBezierPoint(t, p, p2, p3, p4);
	}

	private Vector3 CalculateBezierPoint(float t, Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3)
	{
		float num = 1f - t;
		float num2 = t * t;
		float num3 = num * num;
		float num4 = num3 * num;
		float num5 = num2 * t;
		return num4 * p0 + 3f * num3 * t * p1 + 3f * num * num2 * p2 + num5 * p3;
	}
}
public class RFX4_TransformMotion : MonoBehaviour
{
	public enum RFX4_SimulationSpace
	{
		Local,
		World
	}

	public class RFX4_CollisionInfo : EventArgs
	{
		public RaycastHit Hit;
	}

	public float Distance = 30f;

	public float Speed = 1f;

	public float Dampeen;

	public float MinSpeed = 1f;

	public float TimeDelay;

	public LayerMask CollidesWith = -1;

	public GameObject[] EffectsOnCollision;

	public float CollisionOffset;

	public float DestroyTimeDelay = 5f;

	public bool CollisionEffectInWorldSpace = true;

	public GameObject[] DeactivatedObjectsOnCollision;

	[HideInInspector]
	public float HUE = -1f;

	[HideInInspector]
	public List<GameObject> CollidedInstances;

	private Vector3 startPositionLocal;

	private Transform t;

	private Vector3 oldPos;

	private bool isCollided;

	private bool isOutDistance;

	private Quaternion startQuaternion;

	private float currentSpeed;

	private float currentDelay;

	private const float RayCastTolerance = 0.3f;

	private bool isInitialized;

	private bool dropFirstFrameForFixUnityBugWithParticles;

	public event EventHandler<RFX4_CollisionInfo> CollisionEnter;

	private void Start()
	{
		t = base.transform;
		startQuaternion = t.rotation;
		startPositionLocal = t.localPosition;
		oldPos = t.TransformPoint(startPositionLocal);
		Initialize();
		isInitialized = true;
	}

	private void OnEnable()
	{
		if (isInitialized)
		{
			Initialize();
		}
	}

	private void OnDisable()
	{
		if (isInitialized)
		{
			Initialize();
		}
	}

	private void Initialize()
	{
		isCollided = false;
		isOutDistance = false;
		currentSpeed = Speed;
		currentDelay = 0f;
		startQuaternion = t.rotation;
		t.localPosition = startPositionLocal;
		oldPos = t.TransformPoint(startPositionLocal);
		OnCollisionDeactivateBehaviour(active: true);
		dropFirstFrameForFixUnityBugWithParticles = true;
	}

	private void Update()
	{
		if (!dropFirstFrameForFixUnityBugWithParticles)
		{
			UpdateWorldPosition();
		}
		else
		{
			dropFirstFrameForFixUnityBugWithParticles = false;
		}
	}

	private void UpdateWorldPosition()
	{
		currentDelay += Time.deltaTime;
		if (!(currentDelay < TimeDelay))
		{
			Vector3 vector = Vector3.zero;
			Vector3 vector2 = Vector3.zero;
			if (!isCollided && !isOutDistance)
			{
				currentSpeed = Mathf.Clamp(currentSpeed - Speed * Dampeen * Time.deltaTime, MinSpeed, Speed);
				Vector3 vector3 = Vector3.forward * currentSpeed * Time.deltaTime;
				vector = t.localRotation * vector3;
				vector2 = startQuaternion * vector3;
			}
			float magnitude = (t.localPosition + vector - startPositionLocal).magnitude;
			if (!isCollided && Physics.Raycast(t.position, t.forward, out var hitInfo, 10f, CollidesWith) && vector.magnitude + 0.3f > hitInfo.distance)
			{
				isCollided = true;
				t.position = hitInfo.point;
				oldPos = t.position;
				OnCollisionBehaviour(hitInfo);
				OnCollisionDeactivateBehaviour(active: false);
			}
			else if (!isOutDistance && magnitude > Distance)
			{
				isOutDistance = true;
				t.localPosition = startPositionLocal + t.localRotation * Vector3.forward * Distance;
				oldPos = t.position;
			}
			else
			{
				t.position = oldPos + vector2;
				oldPos = t.position;
			}
		}
	}

	private void OnCollisionBehaviour(RaycastHit hit)
	{
		this.CollisionEnter?.Invoke(this, new RFX4_CollisionInfo
		{
			Hit = hit
		});
		CollidedInstances.Clear();
		GameObject[] effectsOnCollision = EffectsOnCollision;
		for (int i = 0; i < effectsOnCollision.Length; i++)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(effectsOnCollision[i], hit.point + hit.normal * CollisionOffset, default(Quaternion));
			CollidedInstances.Add(gameObject);
			if (HUE > -0.9f)
			{
				RFX4_ColorHelper.ChangeObjectColorByHUE(gameObject, HUE);
			}
			gameObject.transform.LookAt(hit.point + hit.normal + hit.normal * CollisionOffset);
			if (!CollisionEffectInWorldSpace)
			{
				gameObject.transform.parent = base.transform;
			}
			UnityEngine.Object.Destroy(gameObject, DestroyTimeDelay);
		}
	}

	private void OnCollisionDeactivateBehaviour(bool active)
	{
		GameObject[] deactivatedObjectsOnCollision = DeactivatedObjectsOnCollision;
		for (int i = 0; i < deactivatedObjectsOnCollision.Length; i++)
		{
			deactivatedObjectsOnCollision[i].SetActive(active);
		}
	}

	private void OnDrawGizmosSelected()
	{
		if (!UnityEngine.Application.isPlaying)
		{
			t = base.transform;
			Gizmos.color = Color.blue;
			Gizmos.DrawLine(t.position, t.position + t.forward * Distance);
		}
	}
}
public class RFX4_UVAnimation : MonoBehaviour
{
	public int TilesX = 4;

	public int TilesY = 4;

	public int FPS = 30;

	public int StartFrameOffset;

	public bool IsLoop = true;

	public float StartDelay;

	public bool IsReverse;

	public bool IsInterpolateFrames;

	public RFX4_TextureShaderProperties[] TextureNames = new RFX4_TextureShaderProperties[1];

	public AnimationCurve FrameOverTime = AnimationCurve.Linear(0f, 1f, 1f, 1f);

	private int count;

	private Renderer currentRenderer;

	private Projector projector;

	private Material instanceMaterial;

	private float animationStartTime;

	private bool canUpdate;

	private int previousIndex;

	private int totalFrames;

	private float currentInterpolatedTime;

	private int currentIndex;

	private Vector2 size;

	private bool isInitialized;

	private void OnEnable()
	{
		if (isInitialized)
		{
			InitDefaultVariables();
		}
	}

	private void Start()
	{
		InitDefaultVariables();
		isInitialized = true;
	}

	private void Update()
	{
		if (canUpdate)
		{
			UpdateMaterial();
			SetSpriteAnimation();
			if (IsInterpolateFrames)
			{
				SetSpriteAnimationIterpolated();
			}
		}
	}

	private void InitDefaultVariables()
	{
		InitializeMaterial();
		totalFrames = TilesX * TilesY;
		previousIndex = 0;
		canUpdate = true;
		count = TilesY * TilesX;
		Vector3 zero = Vector3.zero;
		StartFrameOffset -= StartFrameOffset / count * count;
		size = new Vector2(1f / (float)TilesX, 1f / (float)TilesY);
		animationStartTime = Time.time;
		if (instanceMaterial != null)
		{
			RFX4_TextureShaderProperties[] textureNames = TextureNames;
			for (int i = 0; i < textureNames.Length; i++)
			{
				RFX4_TextureShaderProperties rFX4_TextureShaderProperties = textureNames[i];
				instanceMaterial.SetTextureScale(rFX4_TextureShaderProperties.ToString(), size);
				instanceMaterial.SetTextureOffset(rFX4_TextureShaderProperties.ToString(), zero);
			}
		}
	}

	private void InitializeMaterial()
	{
		currentRenderer = GetComponent<Renderer>();
		if (currentRenderer == null)
		{
			projector = GetComponent<Projector>();
			if (projector != null)
			{
				if (!projector.material.name.EndsWith("(Instance)"))
				{
					projector.material = new Material(projector.material)
					{
						name = projector.material.name + " (Instance)"
					};
				}
				instanceMaterial = projector.material;
			}
		}
		else
		{
			instanceMaterial = currentRenderer.material;
		}
	}

	private void UpdateMaterial()
	{
		if (currentRenderer == null)
		{
			if (projector != null)
			{
				if (!projector.material.name.EndsWith("(Instance)"))
				{
					projector.material = new Material(projector.material)
					{
						name = projector.material.name + " (Instance)"
					};
				}
				instanceMaterial = projector.material;
			}
		}
		else
		{
			instanceMaterial = currentRenderer.material;
		}
	}

	private void SetSpriteAnimation()
	{
		int num = (int)((Time.time - animationStartTime) * (float)FPS);
		num %= totalFrames;
		if (!IsLoop && num < previousIndex)
		{
			canUpdate = false;
			return;
		}
		if (IsInterpolateFrames && num != previousIndex)
		{
			currentInterpolatedTime = 0f;
		}
		previousIndex = num;
		if (IsReverse)
		{
			num = totalFrames - num - 1;
		}
		int num2 = num % TilesX;
		int num3 = num / TilesX;
		float x = (float)num2 * size.x;
		float y = 1f - size.y - (float)num3 * size.y;
		Vector2 value = new Vector2(x, y);
		if (instanceMaterial != null)
		{
			RFX4_TextureShaderProperties[] textureNames = TextureNames;
			for (int i = 0; i < textureNames.Length; i++)
			{
				RFX4_TextureShaderProperties rFX4_TextureShaderProperties = textureNames[i];
				instanceMaterial.SetTextureScale(rFX4_TextureShaderProperties.ToString(), size);
				instanceMaterial.SetTextureOffset(rFX4_TextureShaderProperties.ToString(), value);
			}
		}
	}

	private void SetSpriteAnimationIterpolated()
	{
		currentInterpolatedTime += Time.deltaTime;
		int num = previousIndex + 1;
		if (num == totalFrames)
		{
			num = previousIndex;
		}
		if (IsReverse)
		{
			num = totalFrames - num - 1;
		}
		int num2 = num % TilesX;
		int num3 = num / TilesX;
		float x = (float)num2 * size.x;
		float y = 1f - size.y - (float)num3 * size.y;
		Vector2 vector = new Vector2(x, y);
		if (instanceMaterial != null)
		{
			instanceMaterial.SetVector("_Tex_NextFrame", new Vector4(size.x, size.y, vector.x, vector.y));
			instanceMaterial.SetFloat("InterpolationValue", Mathf.Clamp01(currentInterpolatedTime * (float)FPS));
		}
	}
}
public class RFX4_UVScroll : MonoBehaviour
{
	public Vector2 UvScrollMultiplier = new Vector2(1f, 0f);

	public RFX4_TextureShaderProperties TextureName;

	private Vector2 uvOffset = Vector2.zero;

	private Material mat;

	private void Start()
	{
		Renderer component = GetComponent<Renderer>();
		if (component == null)
		{
			Projector component2 = GetComponent<Projector>();
			if (component2 != null)
			{
				if (!component2.material.name.EndsWith("(Instance)"))
				{
					component2.material = new Material(component2.material)
					{
						name = component2.material.name + " (Instance)"
					};
				}
				mat = component2.material;
			}
		}
		else
		{
			mat = component.material;
		}
	}

	private void Update()
	{
		uvOffset += UvScrollMultiplier * Time.deltaTime;
		if (mat != null)
		{
			mat.SetTextureOffset(TextureName.ToString(), uvOffset);
		}
	}
}
public class Lighting : MonoBehaviour
{
	public float lighting = 1f;

	public Light lightPower;

	public bool flashFlg;

	public float flashTimer = 0.3f;

	private bool lightKeepFlg;

	public float revOnTime;

	public float keepOnTime;

	public float keepTime;

	public bool flashingFlg;

	public float minLight;

	public float maxLight = 1f;

	private bool lightOffFlg;

	public float flashingOff;

	public float flashingOffPower;

	public float flashingOffIntensity = 1f;

	private void Start()
	{
		lightPower = GetComponent<Light>();
		flash();
		setRev();
		keepOn();
		setFlashingOff();
	}

	private void Update()
	{
		if (flashingFlg)
		{
			if (lightOffFlg)
			{
				lightPower.intensity -= lighting * Time.deltaTime;
				if (lightPower.intensity <= minLight)
				{
					lightOffFlg = false;
				}
			}
			else
			{
				lightPower.intensity += lighting * Time.deltaTime;
				if (lightPower.intensity > maxLight)
				{
					lightOffFlg = true;
				}
			}
		}
		else if (lightPower.intensity > 0f && lightPower.enabled && !lightKeepFlg)
		{
			lightPower.intensity -= lighting * Time.deltaTime;
		}
		if (lightKeepFlg && keepTime > 0f)
		{
			keepTime -= Time.deltaTime;
			if (keepTime <= 0f)
			{
				lightKeepFlg = false;
			}
		}
	}

	private IEnumerator flash()
	{
		if (flashFlg)
		{
			lightPower.enabled = false;
			yield return new WaitForSeconds(flashTimer);
			lightPower.enabled = true;
		}
	}

	private IEnumerator setRev()
	{
		if (revOnTime > 0f)
		{
			yield return new WaitForSeconds(revOnTime);
			lighting *= -1f;
		}
	}

	private IEnumerator keepOn()
	{
		if (keepOnTime > 0f)
		{
			yield return new WaitForSeconds(keepOnTime);
			lightKeepFlg = true;
		}
	}

	private IEnumerator setFlashingOff()
	{
		if (flashingOff > 0f)
		{
			yield return new WaitForSeconds(flashingOff);
			flashingFlg = false;
			if (flashingOffPower > 0f)
			{
				lightPower.intensity = flashingOffIntensity;
				lighting = flashingOffPower;
			}
		}
	}
}
public class ThisDestroy : MonoBehaviour
{
	public float time = 1f;

	private void Start()
	{
		UnityEngine.Object.Destroy(base.gameObject, time);
		base.enabled = false;
	}

	private void Update()
	{
	}
}
public class RFX1_AudioPitchCurves : MonoBehaviour
{
	public AnimationCurve AudioCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphPitchMultiplier = 1f;

	public bool IsLoop;

	private bool canUpdate;

	private float startTime;

	private AudioSource audioSource;

	private float startPitch;

	private void Awake()
	{
		audioSource = GetComponent<AudioSource>();
		startPitch = audioSource.pitch;
		audioSource.pitch = AudioCurve.Evaluate(0f) * GraphPitchMultiplier;
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
		if (audioSource != null)
		{
			audioSource.pitch = AudioCurve.Evaluate(0f) * GraphPitchMultiplier;
		}
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float pitch = AudioCurve.Evaluate(num / GraphTimeMultiplier) * startPitch * GraphPitchMultiplier;
			audioSource.pitch = pitch;
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}
}
public class RFX1_AudioVolumeCurves : MonoBehaviour
{
	public AnimationCurve AudioCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public bool IsLoop;

	private bool canUpdate;

	private float startTime;

	private AudioSource audioSource;

	private float startVolume;

	private void Awake()
	{
		audioSource = GetComponent<AudioSource>();
		startVolume = audioSource.volume;
		audioSource.volume = AudioCurve.Evaluate(0f);
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
		if (audioSource != null)
		{
			audioSource.volume = AudioCurve.Evaluate(0f);
		}
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float volume = AudioCurve.Evaluate(num / GraphTimeMultiplier) * startVolume;
			audioSource.volume = volume;
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}
}
public class RFX1_LightCurves : MonoBehaviour
{
	public AnimationCurve LightCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphIntensityMultiplier = 1f;

	public bool IsLoop;

	[HideInInspector]
	public bool canUpdate;

	private float startTime;

	private Light lightSource;

	private void Awake()
	{
		lightSource = GetComponent<Light>();
		lightSource.intensity = LightCurve.Evaluate(0f) * GraphIntensityMultiplier;
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
		if (lightSource != null)
		{
			lightSource.intensity = LightCurve.Evaluate(0f) * GraphIntensityMultiplier;
		}
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float intensity = LightCurve.Evaluate(num / GraphTimeMultiplier) * GraphIntensityMultiplier;
			lightSource.intensity = intensity;
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}
}
public class RFX1_ProjectorSizeCurves : MonoBehaviour
{
	public AnimationCurve ProjectorSize = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphIntensityMultiplier = 1f;

	public bool IsLoop;

	private bool canUpdate;

	private float startTime;

	private Projector projector;

	private void Awake()
	{
		projector = GetComponent<Projector>();
		projector.orthographicSize = ProjectorSize.Evaluate(0f);
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float orthographicSize = ProjectorSize.Evaluate(num / GraphTimeMultiplier) * GraphIntensityMultiplier;
			projector.orthographicSize = orthographicSize;
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}
}
public class RFX1_ScaleCurves : MonoBehaviour
{
	public AnimationCurve FloatCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphIntensityMultiplier = 1f;

	public bool IsLoop;

	private bool canUpdate;

	private float startTime;

	private Transform t;

	private int nameId;

	private Projector proj;

	private Vector3 startScale;

	private void Awake()
	{
		t = GetComponent<Transform>();
		startScale = t.localScale;
		t.localScale = Vector3.zero;
		proj = GetComponent<Projector>();
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
		t.localScale = Vector3.zero;
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float num2 = FloatCurve.Evaluate(num / GraphTimeMultiplier) * GraphIntensityMultiplier;
			t.localScale = num2 * startScale;
			if (proj != null)
			{
				proj.orthographicSize = num2;
			}
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}
}
public class RFX1_ShaderColorGradient : MonoBehaviour
{
	public RFX1_ShaderProperties ShaderColorProperty;

	public Gradient Color = new Gradient();

	public float TimeMultiplier = 1f;

	public bool IsLoop;

	public bool UseSharedMaterial;

	[HideInInspector]
	public float HUE = -1f;

	[HideInInspector]
	public bool canUpdate;

	private Material mat;

	private int propertyID;

	private float startTime;

	private Color startColor;

	private bool isInitialized;

	private string shaderProperty;

	private void Start()
	{
		Init();
	}

	private void Init()
	{
		shaderProperty = ShaderColorProperty.ToString();
		startTime = Time.time;
		canUpdate = true;
		Renderer component = GetComponent<Renderer>();
		if (component == null)
		{
			Projector component2 = GetComponent<Projector>();
			if (component2 != null)
			{
				if (!component2.material.name.EndsWith("(Instance)"))
				{
					component2.material = new Material(component2.material)
					{
						name = component2.material.name + " (Instance)"
					};
				}
				mat = component2.material;
			}
		}
		else if (!UseSharedMaterial)
		{
			mat = component.material;
		}
		else
		{
			mat = component.sharedMaterial;
		}
		if (mat == null)
		{
			canUpdate = false;
			return;
		}
		if (!mat.HasProperty(shaderProperty))
		{
			canUpdate = false;
			return;
		}
		if (mat.HasProperty(shaderProperty))
		{
			propertyID = Shader.PropertyToID(shaderProperty);
		}
		startColor = mat.GetColor(propertyID);
		Color color = Color.Evaluate(0f);
		mat.SetColor(propertyID, color * startColor);
		isInitialized = true;
	}

	private void OnEnable()
	{
		if (isInitialized)
		{
			startTime = Time.time;
			canUpdate = true;
		}
	}

	private void Update()
	{
		if (mat == null)
		{
			return;
		}
		float num = Time.time - startTime;
		if (canUpdate)
		{
			Color color = Color.Evaluate(num / TimeMultiplier);
			mat.SetColor(propertyID, color * startColor);
		}
		if (num >= TimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}

	private void OnDisable()
	{
		if (!(mat == null))
		{
			if (UseSharedMaterial)
			{
				mat.SetColor(propertyID, startColor);
			}
			mat.SetColor(propertyID, startColor);
		}
	}
}
public class RFX1_ShaderFloatCurve : MonoBehaviour
{
	public RFX1_ShaderProperties ShaderFloatProperty = RFX1_ShaderProperties._Cutoff;

	public AnimationCurve FloatCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphIntensityMultiplier = 1f;

	public bool IsLoop;

	public bool UseSharedMaterial;

	private bool canUpdate;

	private float startTime;

	private Material mat;

	private float startFloat;

	private int propertyID;

	private string shaderProperty;

	private bool isInitialized;

	private void Awake()
	{
		Renderer component = GetComponent<Renderer>();
		if (component == null)
		{
			Projector component2 = GetComponent<Projector>();
			if (component2 != null)
			{
				if (!UseSharedMaterial)
				{
					if (!component2.material.name.EndsWith("(Instance)"))
					{
						component2.material = new Material(component2.material)
						{
							name = component2.material.name + " (Instance)"
						};
					}
					mat = component2.material;
				}
				else
				{
					mat = component2.material;
				}
			}
		}
		else if (!UseSharedMaterial)
		{
			mat = component.material;
		}
		else
		{
			mat = component.sharedMaterial;
		}
		shaderProperty = ShaderFloatProperty.ToString();
		if (mat.HasProperty(shaderProperty))
		{
			propertyID = Shader.PropertyToID(shaderProperty);
		}
		startFloat = mat.GetFloat(propertyID);
		float value = FloatCurve.Evaluate(0f) * GraphIntensityMultiplier;
		mat.SetFloat(propertyID, value);
		isInitialized = true;
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
		if (isInitialized)
		{
			float value = FloatCurve.Evaluate(0f) * GraphIntensityMultiplier;
			mat.SetFloat(propertyID, value);
		}
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float value = FloatCurve.Evaluate(num / GraphTimeMultiplier) * GraphIntensityMultiplier;
			mat.SetFloat(propertyID, value);
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}

	private void OnDisable()
	{
		if (UseSharedMaterial)
		{
			mat.SetFloat(propertyID, startFloat);
		}
	}
}
public enum RFX1_ShaderProperties
{
	_TintColor,
	_Cutoff,
	_Color,
	_EmissionColor,
	_MaskPow,
	_Cutout,
	_Speed,
	_BumpAmt,
	_AlphaPow,
	_Distortion,
	_MainColor
}
public class RFX1_WindCurves : MonoBehaviour
{
	public AnimationCurve WindCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphIntensityMultiplier = 1f;

	public bool IsLoop;

	private bool canUpdate;

	private float startTime;

	private WindZone windZone;

	private void Awake()
	{
		windZone = GetComponent<WindZone>();
		windZone.windMain = WindCurve.Evaluate(0f);
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float windMain = WindCurve.Evaluate(num / GraphTimeMultiplier) * GraphIntensityMultiplier;
			windZone.windMain = windMain;
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}
}
public class destroyMe : MonoBehaviour
{
	private float timer;

	public float deathtimer = 10f;

	private void Start()
	{
	}

	private void Update()
	{
		timer += Time.deltaTime;
		if (timer >= deathtimer)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}
}
public class RFX1_EffectSettingColor : MonoBehaviour
{
	public Color Color = Color.red;

	private Color previousColor;

	private void OnEnable()
	{
		UpdateColor();
	}

	private void Update()
	{
		if (previousColor != Color)
		{
			UpdateColor();
		}
	}

	private void UpdateColor()
	{
		float h = RFX1_ColorHelper.ColorToHSV(Color).H;
		RFX1_ColorHelper.ChangeObjectColorByHUE(base.gameObject, h);
		RFX1_TransformMotion componentInChildren = GetComponentInChildren<RFX1_TransformMotion>(includeInactive: true);
		if (componentInChildren != null)
		{
			componentInChildren.HUE = h;
		}
		previousColor = Color;
	}
}
public class RFX1_EffectSettingProjectile : MonoBehaviour
{
	public float FlyDistanceForProjectiles = 30f;

	public float SpeedMultiplier = 1f;

	public LayerMask CollidesWith = -1;

	private float startSpeed;

	private float oldSpeedMultiplier;

	private void Awake()
	{
		oldSpeedMultiplier = SpeedMultiplier;
		RFX1_TransformMotion componentInChildren = GetComponentInChildren<RFX1_TransformMotion>(includeInactive: true);
		if (componentInChildren != null)
		{
			startSpeed = componentInChildren.Speed;
		}
	}

	private void OnEnable()
	{
		RFX1_TransformMotion componentInChildren = GetComponentInChildren<RFX1_TransformMotion>(includeInactive: true);
		if (componentInChildren != null)
		{
			componentInChildren.Distance = FlyDistanceForProjectiles;
			componentInChildren.CollidesWith = CollidesWith;
			componentInChildren.Speed = startSpeed * SpeedMultiplier;
		}
	}

	private void Update()
	{
		if (Mathf.Abs(oldSpeedMultiplier - SpeedMultiplier) > 0.001f)
		{
			OnEnable();
		}
	}
}
public class RFX1_ShieldInteraction : MonoBehaviour
{
	private RFX1_TransformMotion transformMotion;

	private SphereCollider coll;

	private void Start()
	{
		transformMotion = GetComponentInChildren<RFX1_TransformMotion>();
		if (transformMotion != null)
		{
			transformMotion.CollisionEnter += TransformMotion_CollisionEnter;
			coll = transformMotion.gameObject.AddComponent<SphereCollider>();
			coll.radius = 0.1f;
			coll.isTrigger = true;
		}
	}

	private void TransformMotion_CollisionEnter(object sender, RFX1_TransformMotion.RFX1_CollisionInfo e)
	{
		RFX1_ShieldCollisionTrigger componentInChildren = e.Hit.transform.GetComponentInChildren<RFX1_ShieldCollisionTrigger>();
		if (!(componentInChildren == null))
		{
			componentInChildren.OnCollision(e.Hit, base.gameObject);
			coll.enabled = false;
		}
	}

	private void OnEnable()
	{
		if (coll != null)
		{
			coll.enabled = true;
		}
	}

	private void Update()
	{
	}
}
public class RFX1_Target : MonoBehaviour
{
	public GameObject Target;

	private GameObject currentTarget;

	private RFX1_TransformMotion transformMotion;

	private void Start()
	{
		transformMotion = GetComponentInChildren<RFX1_TransformMotion>();
		UpdateTarget();
	}

	private void Update()
	{
		UpdateTarget();
	}

	private void UpdateTarget()
	{
		if (!(Target == null))
		{
			if (transformMotion == null)
			{
				UnityEngine.Debug.Log("You must attach the target script on projectile effect!");
			}
			else if (Target != currentTarget)
			{
				currentTarget = Target;
				transformMotion.Target = currentTarget;
			}
		}
	}
}
public class RFX1_ActivateGravityAfterCollision : MonoBehaviour
{
	public RFX1_TransformMotion TransformMotion;

	public Vector2 Gravity = new Vector2(1f, 1f);

	private ParticleSystem ps;

	private ParticleSystem.MinMaxCurve startGravity;

	private bool isInitialized;

	private void OnEnable()
	{
		TransformMotion.CollisionEnter += TransformMotion_CollisionEnter;
		ps = GetComponent<ParticleSystem>();
		ParticleSystem.MainModule main = ps.main;
		if (!isInitialized)
		{
			isInitialized = true;
			startGravity = main.gravityModifier;
		}
		else
		{
			main.gravityModifier = startGravity;
		}
	}

	private void OnDisable()
	{
		TransformMotion.CollisionEnter -= TransformMotion_CollisionEnter;
	}

	private void TransformMotion_CollisionEnter(object sender, RFX1_TransformMotion.RFX1_CollisionInfo e)
	{
		ParticleSystem.MainModule main = ps.main;
		main.gravityModifier = new ParticleSystem.MinMaxCurve(Gravity.x, Gravity.y);
	}
}
public class RFX1_AnimatorEvents : MonoBehaviour
{
	[Serializable]
	public class RFX1_EffectAnimatorProperty
	{
		public GameObject Prefab;

		public Transform BonePosition;

		public Transform BoneRotation;

		public float DestroyTime = 10f;

		[HideInInspector]
		public GameObject CurrentInstance;
	}

	public RFX1_EffectAnimatorProperty Effect1;

	public RFX1_EffectAnimatorProperty Effect2;

	public RFX1_EffectAnimatorProperty Effect3;

	public RFX1_EffectAnimatorProperty Effect4;

	public RFX1_EffectAnimatorProperty Effect5;

	public RFX1_EffectAnimatorProperty Effect6;

	public RFX1_EffectAnimatorProperty Effect7;

	public RFX1_EffectAnimatorProperty Effect8;

	public GameObject Target;

	[HideInInspector]
	public float HUE = -1f;

	[HideInInspector]
	public float Speed = -1f;

	private float oldHUE;

	private float oldSpeed;

	private void InstantiateEffect(RFX1_EffectAnimatorProperty effect)
	{
		if (effect.Prefab == null)
		{
			return;
		}
		effect.CurrentInstance = UnityEngine.Object.Instantiate(effect.Prefab, effect.BonePosition.position, effect.BoneRotation.rotation);
		if (HUE > -0.9f)
		{
			UpdateColor(effect);
		}
		if (Speed > -0.9f)
		{
			UpdateSpeed(effect);
		}
		if (Target != null)
		{
			RFX1_Target component = effect.CurrentInstance.GetComponent<RFX1_Target>();
			if (component != null)
			{
				component.Target = Target;
			}
		}
		if (effect.DestroyTime > 0.001f)
		{
			UnityEngine.Object.Destroy(effect.CurrentInstance, effect.DestroyTime);
		}
	}

	public void ActivateEffect1()
	{
		InstantiateEffect(Effect1);
	}

	public void ActivateEffect2()
	{
		InstantiateEffect(Effect2);
	}

	public void ActivateEffect3()
	{
		InstantiateEffect(Effect3);
	}

	public void ActivateEffect4()
	{
		InstantiateEffect(Effect4);
	}

	public void ActivateEffect5()
	{
		InstantiateEffect(Effect5);
	}

	public void ActivateEffect6()
	{
		InstantiateEffect(Effect6);
	}

	public void ActivateEffect7()
	{
		InstantiateEffect(Effect7);
	}

	public void ActivateEffect8()
	{
		InstantiateEffect(Effect8);
	}

	private void LateUpdate()
	{
		UpdateInstance(Effect1);
		UpdateInstance(Effect2);
		UpdateInstance(Effect3);
		UpdateInstance(Effect4);
		UpdateInstance(Effect5);
		UpdateInstance(Effect6);
		UpdateInstance(Effect7);
		UpdateInstance(Effect8);
	}

	private void UpdateInstance(RFX1_EffectAnimatorProperty effect)
	{
		if (effect.CurrentInstance != null && effect.BonePosition != null)
		{
			effect.CurrentInstance.transform.position = effect.BonePosition.position;
			if (HUE > -0.9f && Mathf.Abs(oldHUE - HUE) > 0.001f)
			{
				UpdateColor(effect);
			}
			if (Speed > -0.9f && Mathf.Abs(oldSpeed - Speed) > 0.001f)
			{
				UpdateSpeed(effect);
			}
		}
	}

	private void UpdateSpeed(RFX1_EffectAnimatorProperty effect)
	{
		oldSpeed = Speed;
		RFX1_EffectSettingProjectile rFX1_EffectSettingProjectile = effect.CurrentInstance.GetComponent<RFX1_EffectSettingProjectile>();
		if (rFX1_EffectSettingProjectile == null)
		{
			rFX1_EffectSettingProjectile = effect.CurrentInstance.AddComponent<RFX1_EffectSettingProjectile>();
		}
		rFX1_EffectSettingProjectile.SpeedMultiplier *= Speed;
	}

	private void UpdateColor(RFX1_EffectAnimatorProperty effect)
	{
		oldHUE = HUE;
		RFX1_EffectSettingColor rFX1_EffectSettingColor = effect.CurrentInstance.GetComponent<RFX1_EffectSettingColor>();
		if (rFX1_EffectSettingColor == null)
		{
			rFX1_EffectSettingColor = effect.CurrentInstance.AddComponent<RFX1_EffectSettingColor>();
		}
		RFX1_ColorHelper.HSBColor hsbColor = RFX1_ColorHelper.ColorToHSV(rFX1_EffectSettingColor.Color);
		hsbColor.H = HUE;
		rFX1_EffectSettingColor.Color = RFX1_ColorHelper.HSVToColor(hsbColor);
	}
}
public static class RFX1_ColorHelper
{
	public struct HSBColor
	{
		public float H;

		public float S;

		public float B;

		public float A;

		public HSBColor(float h, float s, float b, float a)
		{
			H = h;
			S = s;
			B = b;
			A = a;
		}
	}

	private const float TOLERANCE = 0.0001f;

	private static string[] colorProperties = new string[10] { "_TintColor", "_Color", "_EmissionColor", "_BorderColor", "_ReflectColor", "_RimColor", "_MainColor", "_CoreColor", "_FresnelColor", "_CutoutColor" };

	public static HSBColor ColorToHSV(Color color)
	{
		HSBColor result = new HSBColor(0f, 0f, 0f, color.a);
		float r = color.r;
		float g = color.g;
		float b = color.b;
		float num = Mathf.Max(r, Mathf.Max(g, b));
		if (num <= 0f)
		{
			return result;
		}
		float num2 = Mathf.Min(r, Mathf.Min(g, b));
		float num3 = num - num2;
		if (num > num2)
		{
			if (Math.Abs(g - num) < 0.0001f)
			{
				result.H = (b - r) / num3 * 60f + 120f;
			}
			else if (Math.Abs(b - num) < 0.0001f)
			{
				result.H = (r - g) / num3 * 60f + 240f;
			}
			else if (b > g)
			{
				result.H = (g - b) / num3 * 60f + 360f;
			}
			else
			{
				result.H = (g - b) / num3 * 60f;
			}
			if (result.H < 0f)
			{
				result.H += 360f;
			}
		}
		else
		{
			result.H = 0f;
		}
		result.H *= 0.0027777778f;
		result.S = num3 / num * 1f;
		result.B = num;
		return result;
	}

	public static Color HSVToColor(HSBColor hsbColor)
	{
		float value = hsbColor.B;
		float value2 = hsbColor.B;
		float value3 = hsbColor.B;
		if (Math.Abs(hsbColor.S) > 0.0001f)
		{
			float b = hsbColor.B;
			float num = hsbColor.B * hsbColor.S;
			float num2 = hsbColor.B - num;
			float num3 = hsbColor.H * 360f;
			if (num3 < 60f)
			{
				value = b;
				value2 = num3 * num / 60f + num2;
				value3 = num2;
			}
			else if (num3 < 120f)
			{
				value = (0f - (num3 - 120f)) * num / 60f + num2;
				value2 = b;
				value3 = num2;
			}
			else if (num3 < 180f)
			{
				value = num2;
				value2 = b;
				value3 = (num3 - 120f) * num / 60f + num2;
			}
			else if (num3 < 240f)
			{
				value = num2;
				value2 = (0f - (num3 - 240f)) * num / 60f + num2;
				value3 = b;
			}
			else if (num3 < 300f)
			{
				value = (num3 - 240f) * num / 60f + num2;
				value2 = num2;
				value3 = b;
			}
			else if (num3 <= 360f)
			{
				value = b;
				value2 = num2;
				value3 = (0f - (num3 - 360f)) * num / 60f + num2;
			}
			else
			{
				value = 0f;
				value2 = 0f;
				value3 = 0f;
			}
		}
		return new Color(Mathf.Clamp01(value), Mathf.Clamp01(value2), Mathf.Clamp01(value3), hsbColor.A);
	}

	public static Color ConvertRGBColorByHUE(Color rgbColor, float hue)
	{
		float num = ColorToHSV(rgbColor).B;
		if (num < 0.0001f)
		{
			num = 0.0001f;
		}
		HSBColor hsbColor = ColorToHSV(rgbColor / num);
		hsbColor.H = hue;
		Color result = HSVToColor(hsbColor) * num;
		result.a = rgbColor.a;
		return result;
	}

	public static void ChangeObjectColorByHUE(GameObject go, float hue)
	{
		Renderer[] componentsInChildren = go.GetComponentsInChildren<Renderer>(includeInactive: true);
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			Material material = componentsInChildren[i].material;
			if (material == null)
			{
				continue;
			}
			string[] array = colorProperties;
			foreach (string name in array)
			{
				if (material.HasProperty(name))
				{
					setMatHUEColor(material, name, hue);
				}
			}
		}
		ParticleSystemRenderer[] componentsInChildren2 = go.GetComponentsInChildren<ParticleSystemRenderer>(includeInactive: true);
		foreach (ParticleSystemRenderer particleSystemRenderer in componentsInChildren2)
		{
			Material trailMaterial = particleSystemRenderer.trailMaterial;
			if (trailMaterial == null)
			{
				continue;
			}
			trailMaterial = (particleSystemRenderer.trailMaterial = new Material(trailMaterial)
			{
				name = trailMaterial.name + " (Instance)"
			});
			string[] array = colorProperties;
			foreach (string name2 in array)
			{
				if (trailMaterial.HasProperty(name2))
				{
					setMatHUEColor(trailMaterial, name2, hue);
				}
			}
		}
		SkinnedMeshRenderer[] componentsInChildren3 = go.GetComponentsInChildren<SkinnedMeshRenderer>(includeInactive: true);
		for (int i = 0; i < componentsInChildren3.Length; i++)
		{
			Material material3 = componentsInChildren3[i].material;
			if (material3 == null)
			{
				continue;
			}
			string[] array = colorProperties;
			foreach (string name3 in array)
			{
				if (material3.HasProperty(name3))
				{
					setMatHUEColor(material3, name3, hue);
				}
			}
		}
		Projector[] componentsInChildren4 = go.GetComponentsInChildren<Projector>(includeInactive: true);
		foreach (Projector projector in componentsInChildren4)
		{
			if (!projector.material.name.EndsWith("(Instance)"))
			{
				projector.material = new Material(projector.material)
				{
					name = projector.material.name + " (Instance)"
				};
			}
			Material material4 = projector.material;
			if (material4 == null)
			{
				continue;
			}
			string[] array = colorProperties;
			foreach (string name4 in array)
			{
				if (material4.HasProperty(name4))
				{
					projector.material = setMatHUEColor(material4, name4, hue);
				}
			}
		}
		Light[] componentsInChildren5 = go.GetComponentsInChildren<Light>(includeInactive: true);
		foreach (Light obj in componentsInChildren5)
		{
			HSBColor hsbColor = ColorToHSV(obj.color);
			hsbColor.H = hue;
			obj.color = HSVToColor(hsbColor);
		}
		ParticleSystem[] componentsInChildren6 = go.GetComponentsInChildren<ParticleSystem>(includeInactive: true);
		foreach (ParticleSystem obj2 in componentsInChildren6)
		{
			ParticleSystem.MainModule main = obj2.main;
			HSBColor hsbColor2 = ColorToHSV(obj2.main.startColor.color);
			hsbColor2.H = hue;
			main.startColor = HSVToColor(hsbColor2);
			ParticleSystem.ColorOverLifetimeModule colorOverLifetime = obj2.colorOverLifetime;
			ParticleSystem.MinMaxGradient color = colorOverLifetime.color;
			Gradient gradient = colorOverLifetime.color.gradient;
			GradientColorKey[] colorKeys = colorOverLifetime.color.gradient.colorKeys;
			float num = 0f;
			hsbColor2 = ColorToHSV(colorKeys[0].color);
			num = Math.Abs(ColorToHSV(colorKeys[1].color).H - hsbColor2.H);
			hsbColor2.H = hue;
			colorKeys[0].color = HSVToColor(hsbColor2);
			for (int k = 1; k < colorKeys.Length; k++)
			{
				hsbColor2 = ColorToHSV(colorKeys[k].color);
				hsbColor2.H = Mathf.Repeat(hsbColor2.H + num, 1f);
				colorKeys[k].color = HSVToColor(hsbColor2);
			}
			gradient.colorKeys = colorKeys;
			color.gradient = gradient;
			colorOverLifetime.color = color;
		}
		RFX1_ShaderColorGradient[] componentsInChildren7 = go.GetComponentsInChildren<RFX1_ShaderColorGradient>(includeInactive: true);
		for (int i = 0; i < componentsInChildren7.Length; i++)
		{
			componentsInChildren7[i].HUE = hue;
		}
	}

	private static Material setMatHUEColor(Material mat, string name, float hueColor)
	{
		Color value = ConvertRGBColorByHUE(mat.GetColor(name), hueColor);
		mat.SetColor(name, value);
		return mat;
	}

	private static Material setMatAlphaColor(Material mat, string name, float alpha)
	{
		Color color = mat.GetColor(name);
		color.a = alpha;
		mat.SetColor(name, color);
		return mat;
	}
}
public class RFX1_DeactivateByTime : MonoBehaviour
{
	public float DeactivateTime = 3f;

	private void OnEnable()
	{
		Invoke("DeactivateThis", DeactivateTime);
	}

	private void OnDisable()
	{
		CancelInvoke("DeactivateThis");
	}

	private void DeactivateThis()
	{
		base.gameObject.SetActive(value: false);
	}
}
[ExecuteInEditMode]
public class RFX1_ParticleCollisionDecal : MonoBehaviour
{
	public ParticleSystem DecalParticles;

	public bool IsBilboard;

	public bool InstantiateWhenZeroSpeed;

	public float MaxGroundAngleDeviation = 45f;

	public float MinDistanceBetweenDecals = 0.1f;

	public float MinDistanceBetweenSurface = 0.03f;

	private List<ParticleCollisionEvent> collisionEvents = new List<ParticleCollisionEvent>();

	private ParticleSystem.Particle[] particles;

	private ParticleSystem initiatorPS;

	private List<GameObject> collidedGameObjects = new List<GameObject>();

	private void OnEnable()
	{
		collisionEvents.Clear();
		collidedGameObjects.Clear();
		initiatorPS = GetComponent<ParticleSystem>();
		particles = new ParticleSystem.Particle[DecalParticles.main.maxParticles];
		if (InstantiateWhenZeroSpeed)
		{
			InvokeRepeating("CollisionDetect", 0f, 0.1f);
		}
	}

	private void OnDisable()
	{
		if (InstantiateWhenZeroSpeed)
		{
			CancelInvoke("CollisionDetect");
		}
	}

	private void CollisionDetect()
	{
		int aliveParticles = 0;
		if (InstantiateWhenZeroSpeed)
		{
			aliveParticles = DecalParticles.GetParticles(particles);
		}
		foreach (GameObject collidedGameObject in collidedGameObjects)
		{
			OnParticleCollisionManual(collidedGameObject, aliveParticles);
		}
	}

	private void OnParticleCollisionManual(GameObject other, int aliveParticles = -1)
	{
		collisionEvents.Clear();
		int num = initiatorPS.GetCollisionEvents(other, collisionEvents);
		for (int i = 0; i < num; i++)
		{
			if (Vector3.Angle(collisionEvents[i].normal, Vector3.up) > MaxGroundAngleDeviation)
			{
				continue;
			}
			if (InstantiateWhenZeroSpeed)
			{
				if (collisionEvents[i].velocity.sqrMagnitude > 0.1f)
				{
					continue;
				}
				bool flag = false;
				for (int j = 0; j < aliveParticles; j++)
				{
					if (Vector3.Distance(collisionEvents[i].intersection, particles[j].position) < MinDistanceBetweenDecals)
					{
						flag = true;
					}
				}
				if (flag)
				{
					continue;
				}
			}
			ParticleSystem.EmitParams emitParams = default(ParticleSystem.EmitParams);
			emitParams.position = collisionEvents[i].intersection;
			Vector3 eulerAngles = Quaternion.LookRotation(-collisionEvents[i].normal).eulerAngles;
			eulerAngles.z = UnityEngine.Random.Range(0, 360);
			emitParams.rotation3D = eulerAngles;
			DecalParticles.Emit(emitParams, 1);
		}
	}

	private void OnParticleCollision(GameObject other)
	{
		if (InstantiateWhenZeroSpeed)
		{
			if (!collidedGameObjects.Contains(other))
			{
				collidedGameObjects.Add(other);
			}
		}
		else
		{
			OnParticleCollisionManual(other);
		}
	}
}
public class RFX1_ParticleCollisionGameObject : MonoBehaviour
{
	public GameObject InstancedGO;

	public float DestroyDelay = 5f;

	private List<ParticleCollisionEvent> collisionEvents = new List<ParticleCollisionEvent>();

	private ParticleSystem initiatorPS;

	private void OnEnable()
	{
		collisionEvents.Clear();
		initiatorPS = GetComponent<ParticleSystem>();
	}

	private void OnParticleCollision(GameObject other)
	{
		int num = initiatorPS.GetCollisionEvents(other, collisionEvents);
		for (int i = 0; i < num; i++)
		{
			UnityEngine.Object.Destroy(UnityEngine.Object.Instantiate(InstancedGO, collisionEvents[i].intersection, default(Quaternion)), DestroyDelay);
		}
	}
}
[ExecuteInEditMode]
public class RFX1_ParticleGravityPoint : MonoBehaviour
{
	public Transform target;

	public float Force = 1f;

	public AnimationCurve ForceByTime = AnimationCurve.EaseInOut(0f, 1f, 1f, 1f);

	public float ForceLifeTime = 1f;

	private ParticleSystem ps;

	private ParticleSystem.Particle[] particles;

	private ParticleSystem.MainModule mainModule;

	private float startTime;

	private void Start()
	{
		ps = GetComponent<ParticleSystem>();
		mainModule = ps.main;
	}

	private void OnEnable()
	{
		startTime = Time.time;
	}

	private void LateUpdate()
	{
		int maxParticles = mainModule.maxParticles;
		if (particles == null || particles.Length < maxParticles)
		{
			particles = new ParticleSystem.Particle[maxParticles];
		}
		int num = ps.GetParticles(particles);
		float num2 = ForceByTime.Evaluate((Time.time - startTime) / ForceLifeTime) * Time.deltaTime * Force;
		Vector3 vector = Vector3.zero;
		if (mainModule.simulationSpace == ParticleSystemSimulationSpace.Local)
		{
			vector = base.transform.InverseTransformPoint(target.position);
		}
		if (mainModule.simulationSpace == ParticleSystemSimulationSpace.World)
		{
			vector = target.position;
		}
		for (int i = 0; i < num; i++)
		{
			Vector3 vector2 = Vector3.Normalize(vector - particles[i].position) * num2;
			particles[i].velocity += vector2;
		}
		ps.SetParticles(particles, num);
	}
}
public class RFX1_ParticleInfinite : MonoBehaviour
{
	public float Delay = 3f;

	private ParticleSystem ps;

	private ParticleSystem.MainModule main;

	private float oldSimulation;

	private void OnEnable()
	{
		if (ps == null)
		{
			ps = GetComponent<ParticleSystem>();
			main = ps.main;
			oldSimulation = main.simulationSpeed;
		}
		else
		{
			main.simulationSpeed = oldSimulation;
		}
		CancelInvoke("UpdateParticles");
		Invoke("UpdateParticles", Delay);
	}

	private void UpdateParticles()
	{
		main.simulationSpeed = 0f;
	}
}
public class RFX1_ParticlePositionPoint : MonoBehaviour
{
	[HideInInspector]
	public Vector3 Position;

	public RFX1_ShieldCollisionTrigger ShieldCollisionTrigger;

	public float Force = 1f;

	public AnimationCurve ForceByTime = AnimationCurve.EaseInOut(0f, 1f, 1f, 1f);

	public float ForceLifeTime = 1f;

	private bool canUpdate;

	private ParticleSystem ps;

	private ParticleSystem.Particle[] particles;

	private ParticleSystem.MainModule mainModule;

	private float startTime;

	private void Start()
	{
		ShieldCollisionTrigger.CollisionEnter += ShieldCollisionTrigger_CollisionEnter;
		ShieldCollisionTrigger.Detected += ShieldCollisionTrigger_Detected;
		ps = GetComponent<ParticleSystem>();
		mainModule = ps.main;
	}

	private void ShieldCollisionTrigger_Detected(object sender, RFX1_ShieldDetectInfo e)
	{
		if (Physics.Raycast(e.DetectedGameObject.transform.position, e.DetectedGameObject.transform.forward, out var hitInfo, 10f))
		{
			Position = hitInfo.point;
			ManualOnEnable();
		}
	}

	private void ShieldCollisionTrigger_CollisionEnter(object sender, RFX1_ShieldCollisionInfo e)
	{
		Position = e.Hit.point;
		ManualOnEnable();
	}

	public void ManualOnEnable()
	{
		CancelInvoke("ManualOnDisable");
		startTime = Time.time;
		canUpdate = true;
		Invoke("ManualOnDisable", ForceLifeTime);
	}

	private void ManualOnDisable()
	{
		canUpdate = false;
	}

	private void LateUpdate()
	{
		if (canUpdate)
		{
			int maxParticles = mainModule.maxParticles;
			if (particles == null || particles.Length < maxParticles)
			{
				particles = new ParticleSystem.Particle[maxParticles];
			}
			ps.GetParticles(particles);
			float num = ForceByTime.Evaluate((Time.time - startTime) / ForceLifeTime) * Time.deltaTime * Force;
			Vector3 vector = Vector3.zero;
			if (mainModule.simulationSpace == ParticleSystemSimulationSpace.Local)
			{
				vector = base.transform.InverseTransformPoint(Position);
			}
			if (mainModule.simulationSpace == ParticleSystemSimulationSpace.World)
			{
				vector = Position;
			}
			int particleCount = ps.particleCount;
			for (int i = 0; i < particleCount; i++)
			{
				Vector3 vector2 = Vector3.Normalize(vector - particles[i].position) * num;
				particles[i].position += vector2;
			}
			ps.SetParticles(particles, particleCount);
		}
	}
}
public class RFX1_RandomRotate : MonoBehaviour
{
	public int x = 300;

	public int y = 300;

	public int z = 300;

	private float rangeX;

	private float rangeY;

	private float rangeZ;

	private void Start()
	{
		rangeX = (float)UnityEngine.Random.Range(0, 10000) / 100f;
		rangeY = (float)UnityEngine.Random.Range(0, 10000) / 100f;
		rangeZ = (float)UnityEngine.Random.Range(0, 10000) / 100f;
	}

	private void Update()
	{
		base.transform.Rotate(Time.deltaTime * Mathf.Sin(Time.time + rangeX) * (float)x, Time.deltaTime * Mathf.Sin(Time.time + rangeY) * (float)y, Time.deltaTime * Mathf.Sin(Time.time + rangeZ) * (float)z);
	}
}
public class RFX1_RotationFreeze : MonoBehaviour
{
	public bool LockX = true;

	public bool LockY = true;

	public bool LockZ = true;

	private Vector3 startRotation;

	private void Start()
	{
		startRotation = base.transform.localRotation.eulerAngles;
	}

	private void Update()
	{
		float x = (LockX ? startRotation.x : base.transform.rotation.eulerAngles.x);
		float y = (LockY ? startRotation.y : base.transform.rotation.eulerAngles.y);
		float z = (LockZ ? startRotation.z : base.transform.rotation.eulerAngles.z);
		base.transform.rotation = Quaternion.Euler(x, y, z);
	}
}
public class RFX1_ShieldCollisionTrigger : MonoBehaviour
{
	public float DetectRange;

	public GameObject[] EffectOnCollision;

	public float DestroyTimeDelay = 5f;

	public bool CollisionEffectInWorldSpace = true;

	public float CollisionOffset;

	private const string layerName = "Collision";

	public event EventHandler<RFX1_ShieldCollisionInfo> CollisionEnter;

	public event EventHandler<RFX1_ShieldDetectInfo> Detected;

	private void Start()
	{
	}

	private void Update()
	{
		if (DetectRange < 0.001f)
		{
			return;
		}
		Collider[] array = Physics.OverlapSphere(base.transform.position, DetectRange);
		foreach (Collider collider in array)
		{
			if (collider.name.EndsWith("Collision"))
			{
				this.Detected?.Invoke(this, new RFX1_ShieldDetectInfo
				{
					DetectedGameObject = collider.gameObject
				});
			}
		}
	}

	private void OnDrawGizmosSelected()
	{
		if (!UnityEngine.Application.isPlaying)
		{
			Gizmos.color = Color.blue;
			Gizmos.DrawWireSphere(base.transform.position, DetectRange);
		}
	}

	public void OnCollision(RaycastHit hit, GameObject sender = null)
	{
		this.CollisionEnter?.Invoke(this, new RFX1_ShieldCollisionInfo
		{
			Hit = hit
		});
		GameObject[] effectOnCollision = EffectOnCollision;
		for (int i = 0; i < effectOnCollision.Length; i++)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(effectOnCollision[i], hit.point + hit.normal * CollisionOffset, default(Quaternion));
			gameObject.transform.LookAt(hit.point + hit.normal + hit.normal * CollisionOffset);
			if (!CollisionEffectInWorldSpace)
			{
				gameObject.transform.parent = base.transform;
			}
			UnityEngine.Object.Destroy(gameObject, DestroyTimeDelay);
		}
	}
}
public class RFX1_ShieldCollisionInfo : EventArgs
{
	public RaycastHit Hit;
}
public class RFX1_ShieldDetectInfo : EventArgs
{
	public GameObject DetectedGameObject;
}
public class RFX1_SimpleDecal : MonoBehaviour
{
	public float Offset = 0.05f;

	private Transform t;

	private RaycastHit hit;

	private void Awake()
	{
		t = base.transform;
	}

	private void LateUpdate()
	{
		if (Physics.Raycast(t.parent.position + Vector3.up / 2f, Vector3.down, out hit))
		{
			base.transform.position = hit.point + Vector3.up * Offset;
			base.transform.rotation = Quaternion.LookRotation(-hit.normal);
		}
	}
}
public class RFX1_StartDelay : MonoBehaviour
{
	public GameObject ActivatedGameObject;

	public float Delay = 1f;

	private void OnEnable()
	{
		ActivatedGameObject.SetActive(value: false);
		Invoke("ActivateGO", Delay);
	}

	private void ActivateGO()
	{
		ActivatedGameObject.SetActive(value: true);
	}

	private void OnDisable()
	{
		CancelInvoke("ActivateGO");
	}
}
public enum RFX1_TextureShaderProperties
{
	_MainTex,
	_DistortTex,
	_Mask,
	_Cutout,
	_CutoutTex,
	_Bump,
	_BumpTex,
	_EmissionTex
}
public class RFX1_TransformMotion : MonoBehaviour
{
	public enum RFX4_SimulationSpace
	{
		Local,
		World
	}

	public class RFX1_CollisionInfo : EventArgs
	{
		public RaycastHit Hit;
	}

	public float Distance = 30f;

	public float Speed = 1f;

	public float TimeDelay;

	public float RandomMoveRadius;

	public float RandomMoveSpeedScale;

	public GameObject Target;

	public LayerMask CollidesWith = -1;

	public GameObject[] EffectsOnCollision;

	public float CollisionOffset;

	public float DestroyTimeDelay = 5f;

	public bool CollisionEffectInWorldSpace = true;

	public GameObject[] DeactivatedObjectsOnCollision;

	[HideInInspector]
	public float HUE = -1f;

	[HideInInspector]
	public List<GameObject> CollidedInstances;

	private Vector3 startPosition;

	private Vector3 startPositionLocal;

	private Transform t;

	private Transform targetT;

	private Vector3 oldPos;

	private bool isCollided;

	private bool isOutDistance;

	private Quaternion startQuaternion;

	private float currentDelay;

	private const float RayCastTolerance = 0.15f;

	private bool isInitialized;

	private bool dropFirstFrameForFixUnityBugWithParticles;

	private Vector3 randomTimeOffset;

	public event EventHandler<RFX1_CollisionInfo> CollisionEnter;

	private void Start()
	{
		t = base.transform;
		if (Target != null)
		{
			targetT = Target.transform;
		}
		startQuaternion = t.rotation;
		startPositionLocal = t.localPosition;
		startPosition = t.position;
		oldPos = t.TransformPoint(startPositionLocal);
		Initialize();
		isInitialized = true;
	}

	private void OnEnable()
	{
		if (isInitialized)
		{
			Initialize();
		}
	}

	private void OnDisable()
	{
		if (isInitialized)
		{
			Initialize();
		}
	}

	private void Initialize()
	{
		isCollided = false;
		isOutDistance = false;
		currentDelay = 0f;
		startQuaternion = t.rotation;
		t.localPosition = startPositionLocal;
		oldPos = t.TransformPoint(startPositionLocal);
		OnCollisionDeactivateBehaviour(active: true);
		dropFirstFrameForFixUnityBugWithParticles = true;
		randomTimeOffset = UnityEngine.Random.insideUnitSphere * 10f;
	}

	private void Update()
	{
		if (!dropFirstFrameForFixUnityBugWithParticles)
		{
			UpdateWorldPosition();
		}
		else
		{
			dropFirstFrameForFixUnityBugWithParticles = false;
		}
	}

	private void UpdateWorldPosition()
	{
		currentDelay += Time.deltaTime;
		if (currentDelay < TimeDelay)
		{
			return;
		}
		Vector3 vector = Vector3.zero;
		if (RandomMoveRadius > 0f)
		{
			vector = GetRadiusRandomVector() * RandomMoveRadius;
			if (Target != null)
			{
				if (targetT == null)
				{
					targetT = Target.transform;
				}
				float num = Vector3.Distance(t.position, targetT.position) / Vector3.Distance(startPosition, targetT.position);
				vector *= num;
			}
		}
		Vector3 vector2 = Vector3.zero;
		Vector3 vector3 = Vector3.zero;
		if (!isCollided && !isOutDistance)
		{
			if (Target == null)
			{
				Vector3 vector4 = (Vector3.forward + vector) * Speed * Time.deltaTime;
				vector2 = t.localRotation * vector4;
				vector3 = startQuaternion * vector4;
			}
			else
			{
				vector3 = (vector2 = ((targetT.position - t.position).normalized + vector) * Speed * Time.deltaTime);
			}
		}
		float magnitude = (t.localPosition + vector2 - startPositionLocal).magnitude;
		UnityEngine.Debug.DrawRay(t.position, vector3.normalized * (Distance - magnitude));
		if (!isCollided && Physics.Raycast(t.position, vector3.normalized, out var hitInfo, Distance, CollidesWith) && vector2.magnitude + 0.15f > hitInfo.distance)
		{
			isCollided = true;
			t.position = hitInfo.point;
			oldPos = t.position;
			OnCollisionBehaviour(hitInfo);
			OnCollisionDeactivateBehaviour(active: false);
		}
		else if (!isOutDistance && magnitude + 0.15f > Distance)
		{
			isOutDistance = true;
			OnCollisionDeactivateBehaviour(active: false);
			if (Target == null)
			{
				t.localPosition = startPositionLocal + t.localRotation * (Vector3.forward + vector) * Distance;
			}
			else
			{
				Vector3 normalized = (targetT.position - t.position).normalized;
				t.position = startPosition + normalized * Distance;
			}
			oldPos = t.position;
		}
		else
		{
			t.position = oldPos + vector3;
			oldPos = t.position;
		}
	}

	private Vector3 GetRadiusRandomVector()
	{
		float num = Time.time * RandomMoveSpeedScale + randomTimeOffset.x;
		float x = Mathf.Sin(num / 7f + Mathf.Cos(num / 2f)) * Mathf.Cos(num / 5f + Mathf.Sin(num));
		num = Time.time * RandomMoveSpeedScale + randomTimeOffset.y;
		float y = Mathf.Cos(num / 8f + Mathf.Sin(num / 2f)) * Mathf.Sin(Mathf.Sin(num / 1.2f) + num * 1.2f);
		num = Time.time * RandomMoveSpeedScale + randomTimeOffset.z;
		float z = Mathf.Cos(num * 0.7f + Mathf.Cos(num * 0.5f)) * Mathf.Cos(Mathf.Sin(num * 0.8f) + num * 0.3f);
		return new Vector3(x, y, z);
	}

	private void OnCollisionBehaviour(RaycastHit hit)
	{
		this.CollisionEnter?.Invoke(this, new RFX1_CollisionInfo
		{
			Hit = hit
		});
		CollidedInstances.Clear();
		GameObject[] effectsOnCollision = EffectsOnCollision;
		for (int i = 0; i < effectsOnCollision.Length; i++)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(effectsOnCollision[i], hit.point + hit.normal * CollisionOffset, default(Quaternion));
			CollidedInstances.Add(gameObject);
			if (HUE > -0.9f)
			{
				RFX1_EffectSettingColor rFX1_EffectSettingColor = gameObject.AddComponent<RFX1_EffectSettingColor>();
				RFX1_ColorHelper.HSBColor hsbColor = RFX1_ColorHelper.ColorToHSV(rFX1_EffectSettingColor.Color);
				hsbColor.H = HUE;
				rFX1_EffectSettingColor.Color = RFX1_ColorHelper.HSVToColor(hsbColor);
			}
			gameObject.transform.LookAt(hit.point + hit.normal + hit.normal * CollisionOffset);
			if (!CollisionEffectInWorldSpace)
			{
				gameObject.transform.parent = base.transform;
			}
			UnityEngine.Object.Destroy(gameObject, DestroyTimeDelay);
		}
	}

	private void OnCollisionDeactivateBehaviour(bool active)
	{
		GameObject[] deactivatedObjectsOnCollision = DeactivatedObjectsOnCollision;
		foreach (GameObject gameObject in deactivatedObjectsOnCollision)
		{
			if (gameObject != null)
			{
				gameObject.SetActive(active);
			}
		}
	}

	private void OnDrawGizmosSelected()
	{
		if (!UnityEngine.Application.isPlaying)
		{
			t = base.transform;
			Gizmos.color = Color.blue;
			Gizmos.DrawLine(t.position, t.position + t.forward * Distance);
		}
	}
}
public class RFX1_UVAnimation : MonoBehaviour
{
	public int TilesX = 4;

	public int TilesY = 4;

	public int FPS = 30;

	public float StartDelay;

	public bool IsLoop = true;

	public bool IsReverse;

	public bool IsInterpolateFrames;

	public bool IsParticleSystemTrail;

	public RFX1_TextureShaderProperties[] TextureNames = new RFX1_TextureShaderProperties[1];

	public AnimationCurve FrameOverTime = AnimationCurve.Linear(0f, 1f, 1f, 1f);

	private Renderer currentRenderer;

	private Projector projector;

	private Material instanceMaterial;

	private float animationStartTime;

	private bool canUpdate;

	private int previousIndex;

	private int totalFrames;

	private float currentInterpolatedTime;

	private int currentIndex;

	private Vector2 size;

	private bool isInitialized;

	private bool startDelayIsBroken;

	private ParticleSystemRenderer pr;

	private void OnEnable()
	{
		if (isInitialized)
		{
			InitDefaultVariables();
		}
	}

	private void Start()
	{
		InitDefaultVariables();
		isInitialized = true;
	}

	private void Update()
	{
		if (startDelayIsBroken)
		{
			ManualUpdate();
		}
	}

	private void ManualUpdate()
	{
		if (canUpdate)
		{
			UpdateMaterial();
			SetSpriteAnimation();
			if (IsInterpolateFrames)
			{
				SetSpriteAnimationIterpolated();
			}
		}
	}

	private void StartDelayFunc()
	{
		startDelayIsBroken = true;
		animationStartTime = Time.time;
	}

	private void InitDefaultVariables()
	{
		InitializeMaterial();
		totalFrames = TilesX * TilesY;
		previousIndex = 0;
		canUpdate = true;
		Vector3 zero = Vector3.zero;
		size = new Vector2(1f / (float)TilesX, 1f / (float)TilesY);
		animationStartTime = Time.time;
		if (StartDelay > 1E-05f)
		{
			startDelayIsBroken = false;
			Invoke("StartDelayFunc", StartDelay);
		}
		else
		{
			startDelayIsBroken = true;
		}
		if (instanceMaterial != null)
		{
			RFX1_TextureShaderProperties[] textureNames = TextureNames;
			for (int i = 0; i < textureNames.Length; i++)
			{
				RFX1_TextureShaderProperties rFX1_TextureShaderProperties = textureNames[i];
				instanceMaterial.SetTextureScale(rFX1_TextureShaderProperties.ToString(), size);
				instanceMaterial.SetTextureOffset(rFX1_TextureShaderProperties.ToString(), zero);
			}
		}
	}

	private void InitializeMaterial()
	{
		if (IsParticleSystemTrail)
		{
			pr = GetComponent<ParticleSystem>().GetComponent<ParticleSystemRenderer>();
			currentRenderer = pr;
			instanceMaterial = pr.trailMaterial;
			if (!instanceMaterial.name.EndsWith("(Instance)"))
			{
				instanceMaterial = new Material(instanceMaterial)
				{
					name = instanceMaterial.name + " (Instance)"
				};
			}
			pr.trailMaterial = instanceMaterial;
			return;
		}
		currentRenderer = GetComponent<Renderer>();
		if (currentRenderer == null)
		{
			projector = GetComponent<Projector>();
			if (projector != null)
			{
				if (!projector.material.name.EndsWith("(Instance)"))
				{
					projector.material = new Material(projector.material)
					{
						name = projector.material.name + " (Instance)"
					};
				}
				instanceMaterial = projector.material;
			}
		}
		else
		{
			instanceMaterial = currentRenderer.material;
		}
	}

	private void UpdateMaterial()
	{
		if (currentRenderer == null)
		{
			if (projector != null)
			{
				if (!projector.material.name.EndsWith("(Instance)"))
				{
					projector.material = new Material(projector.material)
					{
						name = projector.material.name + " (Instance)"
					};
				}
				instanceMaterial = projector.material;
			}
		}
		else if (!IsParticleSystemTrail)
		{
			instanceMaterial = currentRenderer.material;
		}
	}

	private void SetSpriteAnimation()
	{
		int num = (int)((Time.time - animationStartTime) * (float)FPS);
		num %= totalFrames;
		if (!IsLoop && num < previousIndex)
		{
			canUpdate = false;
			return;
		}
		if (IsInterpolateFrames && num != previousIndex)
		{
			currentInterpolatedTime = 0f;
		}
		previousIndex = num;
		if (IsReverse)
		{
			num = totalFrames - num - 1;
		}
		int num2 = num % TilesX;
		int num3 = num / TilesX;
		float x = (float)num2 * size.x;
		float y = 1f - size.y - (float)num3 * size.y;
		Vector2 value = new Vector2(x, y);
		if (instanceMaterial != null)
		{
			RFX1_TextureShaderProperties[] textureNames = TextureNames;
			for (int i = 0; i < textureNames.Length; i++)
			{
				RFX1_TextureShaderProperties rFX1_TextureShaderProperties = textureNames[i];
				instanceMaterial.SetTextureScale(rFX1_TextureShaderProperties.ToString(), size);
				instanceMaterial.SetTextureOffset(rFX1_TextureShaderProperties.ToString(), value);
			}
		}
	}

	private void SetSpriteAnimationIterpolated()
	{
		currentInterpolatedTime += Time.deltaTime;
		int num = previousIndex + 1;
		if (num == totalFrames)
		{
			num = previousIndex;
		}
		if (IsReverse)
		{
			num = totalFrames - num - 1;
		}
		int num2 = num % TilesX;
		int num3 = num / TilesX;
		float x = (float)num2 * size.x;
		float y = 1f - size.y - (float)num3 * size.y;
		Vector2 vector = new Vector2(x, y);
		if (instanceMaterial != null)
		{
			instanceMaterial.SetVector("_Tex_NextFrame", new Vector4(size.x, size.y, vector.x, vector.y));
			instanceMaterial.SetFloat("InterpolationValue", Mathf.Clamp01(currentInterpolatedTime * (float)FPS));
		}
	}
}
[ExecuteInEditMode]
public class RFX4_LocalSpaceFix : MonoBehaviour
{
	private void Update()
	{
		Matrix4x4 worldToLocalMatrix = base.transform.worldToLocalMatrix;
		ParticleSystemRenderer component = GetComponent<ParticleSystemRenderer>();
		if (component != null)
		{
			if (UnityEngine.Application.isPlaying)
			{
				component.material.SetMatrix("_InverseTransformMatrix", worldToLocalMatrix);
			}
			else
			{
				component.sharedMaterial.SetMatrix("_InverseTransformMatrix", worldToLocalMatrix);
			}
		}
	}
}
public class SpringBone : MonoBehaviour
{
	public Vector3 springEnd = Vector3.left;

	public bool useSpecifiedRotation;

	public Vector3 customRotation;

	public float stiffness = 1f;

	public float bounciness = 40f;

	[Range(0f, 0.9f)]
	public float dampness = 0.1f;

	private bool updated;

	private Vector3 currentTipPos;

	private SpringBone parBone;

	private Vector3 velocity;

	private float springLength => springEnd.magnitude;

	private void Start()
	{
		currentTipPos = base.transform.TransformPoint(springEnd);
		if (base.transform.parent != null)
		{
			parBone = base.transform.parent.GetComponentInParent<SpringBone>();
		}
	}

	private void Update()
	{
		updated = false;
	}

	private void LateUpdate()
	{
		UpdateSpring();
	}

	private void UpdateSpring()
	{
		if (!updated)
		{
			if (parBone != null)
			{
				parBone.UpdateSpring();
			}
			updated = true;
			Vector3 vector = currentTipPos;
			if (useSpecifiedRotation)
			{
				base.transform.localRotation = Quaternion.Euler(customRotation);
			}
			currentTipPos = base.transform.TransformPoint(springEnd);
			Vector3 vector2 = bounciness * (currentTipPos - vector);
			vector2 += stiffness * (currentTipPos - base.transform.position).normalized;
			vector2 -= dampness * velocity;
			velocity += vector2 * Time.deltaTime;
			currentTipPos = vector + velocity * Time.deltaTime;
			currentTipPos = springLength * (currentTipPos - base.transform.position).normalized + base.transform.position;
			base.transform.rotation = Quaternion.FromToRotation(base.transform.TransformDirection(springEnd), (currentTipPos - base.transform.position).normalized) * base.transform.rotation;
		}
	}
}
public class OvrAvatarTestDriver : OvrAvatarDriver
{
	private Vector3 headPos = new Vector3(0f, 1.6f, 0f);

	private Quaternion headRot = Quaternion.identity;

	private float voiceAmplitude;

	private ControllerPose GetMalibuControllerPose(OVRInput.Controller controller)
	{
		ovrAvatarButton ovrAvatarButton2 = (ovrAvatarButton)0;
		if (OVRInput.Get(OVRInput.Button.PrimaryIndexTrigger, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.One;
		}
		ControllerPose result = default(ControllerPose);
		result.buttons = ovrAvatarButton2;
		result.touches = (OVRInput.Get(OVRInput.Touch.PrimaryTouchpad) ? ovrAvatarTouch.One : ((ovrAvatarTouch)0));
		result.joystickPosition = OVRInput.Get(OVRInput.Axis2D.PrimaryTouchpad, controller);
		result.indexTrigger = 0f;
		result.handTrigger = 0f;
		result.isActive = (OVRInput.GetActiveController() & controller) != 0;
		return result;
	}

	private ControllerPose GetControllerPose(OVRInput.Controller controller)
	{
		ovrAvatarButton ovrAvatarButton2 = (ovrAvatarButton)0;
		if (OVRInput.Get(OVRInput.Button.One, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.One;
		}
		if (OVRInput.Get(OVRInput.Button.Two, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.Two;
		}
		if (OVRInput.Get(OVRInput.Button.Start, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.Three;
		}
		if (OVRInput.Get(OVRInput.Button.PrimaryThumbstick, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.Joystick;
		}
		ovrAvatarTouch ovrAvatarTouch2 = (ovrAvatarTouch)0;
		if (OVRInput.Get(OVRInput.Touch.One, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.One;
		}
		if (OVRInput.Get(OVRInput.Touch.Two, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Two;
		}
		if (OVRInput.Get(OVRInput.Touch.PrimaryThumbstick, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Joystick;
		}
		if (OVRInput.Get(OVRInput.Touch.PrimaryThumbRest, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.ThumbRest;
		}
		if (OVRInput.Get(OVRInput.Touch.PrimaryIndexTrigger, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Index;
		}
		if (!OVRInput.Get(OVRInput.NearTouch.PrimaryIndexTrigger, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Pointing;
		}
		if (!OVRInput.Get(OVRInput.NearTouch.PrimaryThumbButtons, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.ThumbUp;
		}
		ControllerPose result = default(ControllerPose);
		result.buttons = ovrAvatarButton2;
		result.touches = ovrAvatarTouch2;
		result.joystickPosition = OVRInput.Get(OVRInput.Axis2D.PrimaryThumbstick, controller);
		result.indexTrigger = OVRInput.Get(OVRInput.Axis1D.PrimaryIndexTrigger, controller);
		result.handTrigger = OVRInput.Get(OVRInput.Axis1D.PrimaryHandTrigger, controller);
		result.isActive = (OVRInput.GetActiveController() & controller) != 0;
		return result;
	}

	private void CalculateCurrentPose()
	{
		if (OvrAvatarDriver.GetIsTrackedRemote())
		{
			CurrentPose = new PoseFrame
			{
				voiceAmplitude = voiceAmplitude,
				headPosition = headPos,
				headRotation = headRot,
				handLeftPosition = OVRInput.GetLocalControllerPosition(OVRInput.Controller.LTrackedRemote),
				handLeftRotation = OVRInput.GetLocalControllerRotation(OVRInput.Controller.LTrackedRemote),
				handRightPosition = OVRInput.GetLocalControllerPosition(OVRInput.Controller.RTrackedRemote),
				handRightRotation = OVRInput.GetLocalControllerRotation(OVRInput.Controller.RTrackedRemote),
				controllerLeftPose = GetMalibuControllerPose(OVRInput.Controller.LTrackedRemote),
				controllerRightPose = GetMalibuControllerPose(OVRInput.Controller.RTrackedRemote)
			};
		}
		else
		{
			CurrentPose = new PoseFrame
			{
				voiceAmplitude = voiceAmplitude,
				headPosition = headPos,
				headRotation = headRot,
				handLeftPosition = OVRInput.GetLocalControllerPosition(OVRInput.Controller.LTouch),
				handLeftRotation = OVRInput.GetLocalControllerRotation(OVRInput.Controller.LTouch),
				handRightPosition = OVRInput.GetLocalControllerPosition(OVRInput.Controller.RTouch),
				handRightRotation = OVRInput.GetLocalControllerRotation(OVRInput.Controller.RTouch),
				controllerLeftPose = GetControllerPose(OVRInput.Controller.LTouch),
				controllerRightPose = GetControllerPose(OVRInput.Controller.RTouch)
			};
		}
	}

	public override void UpdateTransforms(IntPtr sdkAvatar)
	{
		CalculateCurrentPose();
		UpdateTransformsFromPose(sdkAvatar);
	}
}
public class PoseEditHelper : MonoBehaviour
{
	public Transform poseRoot;

	private void OnDrawGizmos()
	{
		if (poseRoot != null)
		{
			DrawJoints(poseRoot);
		}
	}

	private void DrawJoints(Transform joint)
	{
		Gizmos.DrawWireSphere(joint.position, 0.005f);
		for (int i = 0; i < joint.childCount; i++)
		{
			Transform child = joint.GetChild(i);
			if (!child.name.EndsWith("_grip") && !child.name.EndsWith("hand_ignore"))
			{
				Gizmos.DrawLine(joint.position, child.position);
				DrawJoints(child);
			}
		}
	}
}
public class GazeTargetSpawner : MonoBehaviour
{
	public GameObject GazeTargetPrefab;

	public int NumberOfDummyTargets = 100;

	public int RadiusMultiplier = 3;

	[SerializeField]
	private bool isVisible;

	public bool IsVisible
	{
		get
		{
			return isVisible;
		}
		set
		{
			isVisible = value;
			GazeTarget[] componentsInChildren = base.gameObject.GetComponentsInChildren<GazeTarget>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				MeshRenderer component = componentsInChildren[i].GetComponent<MeshRenderer>();
				if (component != null)
				{
					component.enabled = isVisible;
				}
			}
		}
	}

	private void Start()
	{
		for (int i = 0; i < NumberOfDummyTargets; i++)
		{
			GameObject obj = UnityEngine.Object.Instantiate(GazeTargetPrefab, base.transform);
			obj.name = obj.name + "_" + i;
			obj.transform.localPosition = UnityEngine.Random.insideUnitSphere * RadiusMultiplier;
			obj.transform.rotation = Quaternion.identity;
			obj.GetComponent<MeshRenderer>().enabled = IsVisible;
		}
	}

	private void OnValidate()
	{
		IsVisible = isVisible;
	}
}
public class RemoteLoopbackManager : MonoBehaviour
{
	private class PacketLatencyPair
	{
		public byte[] PacketData;

		public float FakeLatency;
	}

	[Serializable]
	public class SimulatedLatencySettings
	{
		[Range(0f, 0.5f)]
		public float FakeLatencyMax = 0.25f;

		[Range(0f, 0.5f)]
		public float FakeLatencyMin = 0.002f;

		[Range(0f, 1f)]
		public float LatencyWeight = 0.25f;

		[Range(0f, 10f)]
		public int MaxSamples = 4;

		internal float AverageWindow;

		internal float LatencySum;

		internal LinkedList<float> LatencyValues = new LinkedList<float>();

		public float NextValue()
		{
			AverageWindow = LatencySum / (float)LatencyValues.Count;
			float num = UnityEngine.Random.Range(FakeLatencyMin, FakeLatencyMax);
			float num2 = AverageWindow * (1f - LatencyWeight) + LatencyWeight * num;
			if (LatencyValues.Count >= MaxSamples)
			{
				LatencySum -= LatencyValues.First.Value;
				LatencyValues.RemoveFirst();
			}
			LatencySum += num2;
			LatencyValues.AddLast(num2);
			return num2;
		}
	}

	public OvrAvatar LocalAvatar;

	public OvrAvatar LoopbackAvatar;

	public SimulatedLatencySettings LatencySettings = new SimulatedLatencySettings();

	private int PacketSequence;

	private LinkedList<PacketLatencyPair> packetQueue = new LinkedList<PacketLatencyPair>();

	private void Start()
	{
		LocalAvatar.RecordPackets = true;
		OvrAvatar localAvatar = LocalAvatar;
		localAvatar.PacketRecorded = (EventHandler<OvrAvatar.PacketEventArgs>)Delegate.Combine(localAvatar.PacketRecorded, new EventHandler<OvrAvatar.PacketEventArgs>(OnLocalAvatarPacketRecorded));
		float num = UnityEngine.Random.Range(LatencySettings.FakeLatencyMin, LatencySettings.FakeLatencyMax);
		LatencySettings.LatencyValues.AddFirst(num);
		LatencySettings.LatencySum += num;
	}

	private void OnLocalAvatarPacketRecorded(object sender, OvrAvatar.PacketEventArgs args)
	{
		using MemoryStream memoryStream = new MemoryStream();
		BinaryWriter binaryWriter = new BinaryWriter(memoryStream);
		if (LocalAvatar.UseSDKPackets)
		{
			uint num = Oculus.Avatar.CAPI.ovrAvatarPacket_GetSize(args.Packet.ovrNativePacket);
			byte[] buffer = new byte[num];
			Oculus.Avatar.CAPI.ovrAvatarPacket_Write(args.Packet.ovrNativePacket, num, buffer);
			binaryWriter.Write(PacketSequence++);
			binaryWriter.Write(num);
			binaryWriter.Write(buffer);
		}
		else
		{
			binaryWriter.Write(PacketSequence++);
			args.Packet.Write(memoryStream);
		}
		SendPacketData(memoryStream.ToArray());
	}

	private void Update()
	{
		if (packetQueue.Count <= 0)
		{
			return;
		}
		List<PacketLatencyPair> list = new List<PacketLatencyPair>();
		foreach (PacketLatencyPair item in packetQueue)
		{
			item.FakeLatency -= Time.deltaTime;
			if (item.FakeLatency < 0f)
			{
				ReceivePacketData(item.PacketData);
				list.Add(item);
			}
		}
		foreach (PacketLatencyPair item2 in list)
		{
			packetQueue.Remove(item2);
		}
	}

	private void SendPacketData(byte[] data)
	{
		PacketLatencyPair packetLatencyPair = new PacketLatencyPair();
		packetLatencyPair.PacketData = data;
		packetLatencyPair.FakeLatency = LatencySettings.NextValue();
		packetQueue.AddLast(packetLatencyPair);
	}

	private void ReceivePacketData(byte[] data)
	{
		using MemoryStream memoryStream = new MemoryStream(data);
		BinaryReader binaryReader = new BinaryReader(memoryStream);
		int sequence = binaryReader.ReadInt32();
		OvrAvatarPacket packet;
		if (LoopbackAvatar.UseSDKPackets)
		{
			int count = binaryReader.ReadInt32();
			byte[] buffer = binaryReader.ReadBytes(count);
			IntPtr ovrNativePacket = Oculus.Avatar.CAPI.ovrAvatarPacket_Read((uint)data.Length, buffer);
			packet = new OvrAvatarPacket
			{
				ovrNativePacket = ovrNativePacket
			};
		}
		else
		{
			packet = OvrAvatarPacket.Read(memoryStream);
		}
		LoopbackAvatar.GetComponent<OvrAvatarRemoteDriver>().QueuePacket(sequence, packet);
	}
}
public class P2PManager
{
	private enum MessageType : byte
	{
		Update = 1
	}

	public P2PManager()
	{
		Net.SetPeerConnectRequestCallback(PeerConnectRequestCallback);
		Net.SetConnectionStateChangedCallback(ConnectionStateChangedCallback);
	}

	public void ConnectTo(ulong userID)
	{
		if (SocialPlatformManager.MyID < userID)
		{
			Net.Connect(userID);
			SocialPlatformManager.LogOutput("P2P connect to " + userID);
		}
	}

	public void Disconnect(ulong userID)
	{
		if (userID != 0L)
		{
			Net.Close(userID);
			RemotePlayer remoteUser = SocialPlatformManager.GetRemoteUser(userID);
			if (remoteUser != null)
			{
				remoteUser.p2pConnectionState = PeerConnectionState.Unknown;
			}
		}
	}

	private void PeerConnectRequestCallback(Message<NetworkingPeer> msg)
	{
		SocialPlatformManager.LogOutput("P2P request from " + msg.Data.ID);
		if (SocialPlatformManager.GetRemoteUser(msg.Data.ID) != null)
		{
			SocialPlatformManager.LogOutput("P2P request accepted from " + msg.Data.ID);
			Net.Accept(msg.Data.ID);
		}
	}

	private void ConnectionStateChangedCallback(Message<NetworkingPeer> msg)
	{
		SocialPlatformManager.LogOutput("P2P state to " + msg.Data.ID + " changed to  " + msg.Data.State);
		RemotePlayer remoteUser = SocialPlatformManager.GetRemoteUser(msg.Data.ID);
		if (remoteUser != null)
		{
			remoteUser.p2pConnectionState = msg.Data.State;
			if (msg.Data.State == PeerConnectionState.Timeout && SocialPlatformManager.MyID < msg.Data.ID)
			{
				Net.Connect(msg.Data.ID);
				SocialPlatformManager.LogOutput("P2P re-connect to " + msg.Data.ID);
			}
		}
	}

	public void SendAvatarUpdate(ulong userID, Transform rootTransform, uint sequence, byte[] avatarPacket)
	{
		byte[] array = new byte[avatarPacket.Length + 41];
		int offset = 0;
		PackByte(1, array, ref offset);
		PackULong(SocialPlatformManager.MyID, array, ref offset);
		PackFloat(rootTransform.position.x, array, ref offset);
		PackFloat(0f, array, ref offset);
		PackFloat(rootTransform.position.z, array, ref offset);
		PackFloat(rootTransform.rotation.x, array, ref offset);
		PackFloat(rootTransform.rotation.y, array, ref offset);
		PackFloat(rootTransform.rotation.z, array, ref offset);
		PackFloat(rootTransform.rotation.w, array, ref offset);
		PackUInt32(sequence, array, ref offset);
		Buffer.BlockCopy(avatarPacket, 0, array, offset, avatarPacket.Length);
		Net.SendPacket(userID, array, SendPolicy.Unreliable);
	}

	public void GetRemotePackets()
	{
		Packet packet;
		while ((packet = Net.ReadPacket()) != null)
		{
			byte[] packet2 = new byte[packet.Size];
			packet.ReadBytes(packet2);
			int offset = 0;
			MessageType messageType = (MessageType)ReadByte(packet2, ref offset);
			ulong num = ReadULong(packet2, ref offset);
			RemotePlayer remoteUser = SocialPlatformManager.GetRemoteUser(num);
			if (remoteUser == null)
			{
				SocialPlatformManager.LogOutput("Unknown remote player: " + num);
			}
			else if (messageType == MessageType.Update)
			{
				processAvatarPacket(remoteUser, ref packet2, ref offset);
			}
			else
			{
				SocialPlatformManager.LogOutput("Invalid packet type: " + packet.Size);
			}
		}
	}

	public void processAvatarPacket(RemotePlayer remote, ref byte[] packet, ref int offset)
	{
		if (remote != null)
		{
			remote.receivedRootPositionPrior = remote.receivedRootPosition;
			remote.receivedRootPosition.x = ReadFloat(packet, ref offset);
			remote.receivedRootPosition.y = ReadFloat(packet, ref offset);
			remote.receivedRootPosition.z = ReadFloat(packet, ref offset);
			remote.receivedRootRotationPrior = remote.receivedRootRotation;
			remote.receivedRootRotation.x = ReadFloat(packet, ref offset);
			remote.receivedRootRotation.y = ReadFloat(packet, ref offset);
			remote.receivedRootRotation.z = ReadFloat(packet, ref offset);
			remote.receivedRootRotation.w = ReadFloat(packet, ref offset);
			remote.RemoteAvatar.transform.position = remote.receivedRootPosition;
			remote.RemoteAvatar.transform.rotation = remote.receivedRootRotation;
			int sequence = (int)ReadUInt32(packet, ref offset);
			byte[] array = new byte[packet.Length - offset];
			Buffer.BlockCopy(packet, offset, array, 0, array.Length);
			IntPtr ovrNativePacket = Oculus.Avatar.CAPI.ovrAvatarPacket_Read((uint)array.Length, array);
			OvrAvatarPacket packet2 = new OvrAvatarPacket
			{
				ovrNativePacket = ovrNativePacket
			};
			remote.RemoteAvatar.GetComponent<OvrAvatarRemoteDriver>().QueuePacket(sequence, packet2);
		}
	}

	private void PackByte(byte b, byte[] buf, ref int offset)
	{
		buf[offset] = b;
		offset++;
	}

	private byte ReadByte(byte[] buf, ref int offset)
	{
		byte result = buf[offset];
		offset++;
		return result;
	}

	private void PackFloat(float f, byte[] buf, ref int offset)
	{
		Buffer.BlockCopy(BitConverter.GetBytes(f), 0, buf, offset, 4);
		offset += 4;
	}

	private float ReadFloat(byte[] buf, ref int offset)
	{
		float result = BitConverter.ToSingle(buf, offset);
		offset += 4;
		return result;
	}

	private void PackULong(ulong u, byte[] buf, ref int offset)
	{
		Buffer.BlockCopy(BitConverter.GetBytes(u), 0, buf, offset, 8);
		offset += 8;
	}

	private ulong ReadULong(byte[] buf, ref int offset)
	{
		ulong result = BitConverter.ToUInt64(buf, offset);
		offset += 8;
		return result;
	}

	private void PackUInt32(uint u, byte[] buf, ref int offset)
	{
		Buffer.BlockCopy(BitConverter.GetBytes(u), 0, buf, offset, 4);
		offset += 4;
	}

	private uint ReadUInt32(byte[] buf, ref int offset)
	{
		uint result = BitConverter.ToUInt32(buf, offset);
		offset += 4;
		return result;
	}
}
public class PlayerController : SocialPlatformManager
{
	public Camera spyCamera;

	private GameObject cameraRig;

	private bool showUI = true;

	public override void Awake()
	{
		base.Awake();
		cameraRig = localPlayerHead.gameObject;
	}

	public override void Start()
	{
		base.Start();
		spyCamera.enabled = false;
	}

	public override void Update()
	{
		base.Update();
		checkInput();
	}

	private void checkInput()
	{
		if (UnityEngine.Application.platform == RuntimePlatform.Android)
		{
			if (OVRInput.GetDown(OVRInput.Button.Back))
			{
				Rooms.LaunchInvitableUserFlow(roomManager.roomID);
			}
			if (OVRInput.GetDown(OVRInput.Button.PrimaryTouchpad))
			{
				ToggleCamera();
			}
			if (OVRInput.GetDown(OVRInput.Button.PrimaryIndexTrigger))
			{
				ToggleUI();
			}
		}
		else
		{
			if (OVRInput.GetDown(OVRInput.Button.Three))
			{
				Rooms.LaunchInvitableUserFlow(roomManager.roomID);
			}
			if (OVRInput.GetDown(OVRInput.Button.Four))
			{
				ToggleCamera();
			}
			if (OVRInput.GetDown(OVRInput.Button.PrimaryThumbstick))
			{
				ToggleUI();
			}
		}
	}

	private void ToggleCamera()
	{
		spyCamera.enabled = !spyCamera.enabled;
		localAvatar.ShowThirdPerson = !localAvatar.ShowThirdPerson;
		cameraRig.SetActive(!cameraRig.activeSelf);
	}

	private void ToggleUI()
	{
		showUI = !showUI;
		helpPanel.SetActive(showUI);
		localAvatar.ShowLeftController(showUI);
	}
}
public class RemotePlayer
{
	public ulong remoteUserID;

	public bool stillInRoom;

	public PeerConnectionState p2pConnectionState;

	public PeerConnectionState voipConnectionState;

	public OvrAvatar RemoteAvatar;

	public Vector3 receivedRootPosition;

	public Vector3 receivedRootPositionPrior;

	public Quaternion receivedRootRotation;

	public Quaternion receivedRootRotationPrior;

	public VoipAudioSourceHiLevel voipSource;
}
public class RoomManager
{
	public ulong roomID;

	private ulong invitedRoomID;

	private bool amIServer;

	private bool startupDone;

	public RoomManager()
	{
		amIServer = false;
		startupDone = false;
		Rooms.SetRoomInviteAcceptedNotificationCallback(AcceptingInviteCallback);
		Rooms.SetUpdateNotificationCallback(RoomUpdateCallback);
	}

	private void AcceptingInviteCallback(Message<string> msg)
	{
		if (msg.IsError)
		{
			SocialPlatformManager.TerminateWithError(msg);
			return;
		}
		SocialPlatformManager.LogOutput("Launched Invite to join Room: " + msg.Data);
		invitedRoomID = Convert.ToUInt64(msg.GetString());
		if (startupDone)
		{
			CheckForInvite();
		}
	}

	public bool CheckForInvite()
	{
		startupDone = true;
		if (invitedRoomID != 0L)
		{
			JoinExistingRoom(invitedRoomID);
			return true;
		}
		return false;
	}

	public void CreateRoom()
	{
		Rooms.CreateAndJoinPrivate(RoomJoinPolicy.FriendsOfOwner, 4u, subscribeToUpdates: true).OnComplete(CreateAndJoinPrivateRoomCallback);
	}

	private void CreateAndJoinPrivateRoomCallback(Message<Oculus.Platform.Models.Room> msg)
	{
		if (msg.IsError)
		{
			SocialPlatformManager.TerminateWithError(msg);
			return;
		}
		roomID = msg.Data.ID;
		if (msg.Data.OwnerOptional != null && msg.Data.OwnerOptional.ID == SocialPlatformManager.MyID)
		{
			amIServer = true;
		}
		else
		{
			amIServer = false;
		}
		SocialPlatformManager.TransitionToState(SocialPlatformManager.State.WAITING_IN_A_ROOM);
		SocialPlatformManager.SetFloorColorForState(amIServer);
	}

	private void OnLaunchInviteWorkflowComplete(Message msg)
	{
		if (msg.IsError)
		{
			SocialPlatformManager.TerminateWithError(msg);
		}
	}

	public void JoinExistingRoom(ulong roomID)
	{
		SocialPlatformManager.TransitionToState(SocialPlatformManager.State.JOINING_A_ROOM);
		Rooms.Join(roomID, subscribeToUpdates: true).OnComplete(JoinRoomCallback);
	}

	private void JoinRoomCallback(Message<Oculus.Platform.Models.Room> msg)
	{
		if (!msg.IsError)
		{
			string text = ((msg.Data.OwnerOptional != null) ? msg.Data.OwnerOptional.OculusID : "null");
			int num = ((msg.Data.UsersOptional != null) ? msg.Data.UsersOptional.Count : 0);
			SocialPlatformManager.LogOutput("Joined Room " + msg.Data.ID + " owner: " + text + " count: " + num);
			roomID = msg.Data.ID;
			ProcessRoomData(msg);
		}
	}

	private void RoomUpdateCallback(Message<Oculus.Platform.Models.Room> msg)
	{
		if (msg.IsError)
		{
			SocialPlatformManager.TerminateWithError(msg);
			return;
		}
		string text = ((msg.Data.OwnerOptional != null) ? msg.Data.OwnerOptional.OculusID : "null");
		int num = ((msg.Data.UsersOptional != null) ? msg.Data.UsersOptional.Count : 0);
		SocialPlatformManager.LogOutput("Room Update " + msg.Data.ID + " owner: " + text + " count: " + num);
		ProcessRoomData(msg);
	}

	public void LeaveCurrentRoom()
	{
		if (roomID != 0L)
		{
			Rooms.Leave(roomID);
			roomID = 0uL;
		}
		SocialPlatformManager.TransitionToState(SocialPlatformManager.State.LEAVING_A_ROOM);
	}

	private void ProcessRoomData(Message<Oculus.Platform.Models.Room> msg)
	{
		if (msg.Data.OwnerOptional != null && msg.Data.OwnerOptional.ID == SocialPlatformManager.MyID)
		{
			amIServer = true;
		}
		else
		{
			amIServer = false;
		}
		if (msg.Data.UsersOptional != null && msg.Data.UsersOptional.Count == 1)
		{
			SocialPlatformManager.TransitionToState(SocialPlatformManager.State.WAITING_IN_A_ROOM);
		}
		else
		{
			SocialPlatformManager.TransitionToState(SocialPlatformManager.State.CONNECTED_IN_A_ROOM);
		}
		SocialPlatformManager.MarkAllRemoteUsersAsNotInRoom();
		if (msg.Data.UsersOptional != null)
		{
			foreach (User item in msg.Data.UsersOptional)
			{
				if (item.ID != SocialPlatformManager.MyID)
				{
					if (!SocialPlatformManager.IsUserInRoom(item.ID))
					{
						SocialPlatformManager.AddRemoteUser(item.ID);
					}
					else
					{
						SocialPlatformManager.MarkRemoteUserInRoom(item.ID);
					}
				}
			}
		}
		SocialPlatformManager.ForgetRemoteUsersNotInRoom();
		SocialPlatformManager.SetFloorColorForState(amIServer);
	}
}
public class SocialPlatformManager : MonoBehaviour
{
	public enum State
	{
		INITIALIZING,
		CHECKING_LAUNCH_STATE,
		CREATING_A_ROOM,
		WAITING_IN_A_ROOM,
		JOINING_A_ROOM,
		CONNECTED_IN_A_ROOM,
		LEAVING_A_ROOM,
		SHUTDOWN
	}

	private static readonly Vector3 START_ROTATION_ONE = new Vector3(0f, 180f, 0f);

	private static readonly Vector3 START_POSITION_ONE = new Vector3(0f, 4f, 5f);

	private static readonly Vector3 START_ROTATION_TWO = new Vector3(0f, 0f, 0f);

	private static readonly Vector3 START_POSITION_TWO = new Vector3(0f, 4f, -5f);

	private static readonly Vector3 START_ROTATION_THREE = new Vector3(0f, 270f, 0f);

	private static readonly Vector3 START_POSITION_THREE = new Vector3(5f, 4f, 0f);

	private static readonly Vector3 START_ROTATION_FOUR = new Vector3(0f, 90f, 0f);

	private static readonly Vector3 START_POSITION_FOUR = new Vector3(-5f, 4f, 0f);

	private static readonly Color BLACK = new Color(0f, 0f, 0f);

	private static readonly Color WHITE = new Color(1f, 1f, 1f);

	private static readonly Color CYAN = new Color(0f, 1f, 1f);

	private static readonly Color BLUE = new Color(0f, 0f, 1f);

	private static readonly Color GREEN = new Color(0f, 1f, 0f);

	private float voiceCurrent;

	private uint packetSequence;

	public OvrAvatar localAvatarPrefab;

	public OvrAvatar remoteAvatarPrefab;

	public GameObject helpPanel;

	protected MeshRenderer helpMesh;

	public Material riftMaterial;

	public Material gearMaterial;

	protected OvrAvatar localAvatar;

	protected GameObject localTrackingSpace;

	protected GameObject localPlayerHead;

	protected Dictionary<ulong, RemotePlayer> remoteUsers = new Dictionary<ulong, RemotePlayer>();

	public GameObject roomSphere;

	protected MeshRenderer sphereMesh;

	public GameObject roomFloor;

	protected MeshRenderer floorMesh;

	protected State currentState;

	protected static SocialPlatformManager s_instance = null;

	protected RoomManager roomManager;

	protected P2PManager p2pManager;

	protected VoipManager voipManager;

	protected ulong myID;

	protected string myOculusID;

	public static readonly float VOIP_SCALE = 2f;

	public static State CurrentState => s_instance.currentState;

	public static ulong MyID
	{
		get
		{
			if (s_instance != null)
			{
				return s_instance.myID;
			}
			return 0uL;
		}
	}

	public static string MyOculusID
	{
		get
		{
			if (s_instance != null && s_instance.myOculusID != null)
			{
				return s_instance.myOculusID;
			}
			return string.Empty;
		}
	}

	public virtual void Update()
	{
		p2pManager.GetRemotePackets();
		foreach (KeyValuePair<ulong, RemotePlayer> remoteUser in remoteUsers)
		{
			if (remoteUser.Value.voipSource == null && remoteUser.Value.RemoteAvatar.MouthAnchor != null)
			{
				remoteUser.Value.voipSource = remoteUser.Value.RemoteAvatar.MouthAnchor.AddComponent<VoipAudioSourceHiLevel>();
				remoteUser.Value.voipSource.senderID = remoteUser.Value.remoteUserID;
			}
			if (remoteUser.Value.voipSource != null)
			{
				float voiceAmplitude = Mathf.Clamp(remoteUser.Value.voipSource.peakAmplitude * VOIP_SCALE, 0f, 1f);
				remoteUser.Value.RemoteAvatar.VoiceAmplitude = voiceAmplitude;
			}
		}
		if (localAvatar != null)
		{
			localAvatar.VoiceAmplitude = Mathf.Clamp(voiceCurrent * VOIP_SCALE, 0f, 1f);
		}
		Oculus.Platform.Request.RunCallbacks();
	}

	public virtual void Awake()
	{
		LogOutputLine("Start Log.");
		helpMesh = helpPanel.GetComponent<MeshRenderer>();
		sphereMesh = roomSphere.GetComponent<MeshRenderer>();
		floorMesh = roomFloor.GetComponent<MeshRenderer>();
		localTrackingSpace = base.transform.Find("OVRCameraRig/TrackingSpace").gameObject;
		localPlayerHead = base.transform.Find("OVRCameraRig/TrackingSpace/CenterEyeAnchor").gameObject;
		if (s_instance != null)
		{
			UnityEngine.Object.Destroy(base.gameObject);
			return;
		}
		s_instance = this;
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		TransitionToState(State.INITIALIZING);
		Core.AsyncInitialize().OnComplete(InitCallback);
		roomManager = new RoomManager();
		p2pManager = new P2PManager();
		voipManager = new VoipManager();
	}

	private void InitCallback(Message<PlatformInitialize> msg)
	{
		if (msg.IsError)
		{
			TerminateWithError(msg);
			return;
		}
		LaunchDetails launchDetails = ApplicationLifecycle.GetLaunchDetails();
		LogOutput("App launched with LaunchType " + launchDetails.LaunchType);
		Entitlements.IsUserEntitledToApplication().OnComplete(IsEntitledCallback);
	}

	public virtual void Start()
	{
	}

	private void IsEntitledCallback(Message msg)
	{
		if (msg.IsError)
		{
			TerminateWithError(msg);
		}
		else
		{
			Users.GetLoggedInUser().OnComplete(GetLoggedInUserCallback);
		}
	}

	private void GetLoggedInUserCallback(Message<User> msg)
	{
		if (msg.IsError)
		{
			TerminateWithError(msg);
			return;
		}
		myID = msg.Data.ID;
		myOculusID = msg.Data.OculusID;
		localAvatar = UnityEngine.Object.Instantiate(localAvatarPrefab);
		localAvatar.CanOwnMicrophone = false;
		localTrackingSpace = base.transform.Find("OVRCameraRig/TrackingSpace").gameObject;
		localAvatar.transform.SetParent(localTrackingSpace.transform, worldPositionStays: false);
		localAvatar.transform.localPosition = new Vector3(0f, 0f, 0f);
		localAvatar.transform.localRotation = Quaternion.identity;
		if (UnityEngine.Application.platform == RuntimePlatform.Android)
		{
			helpPanel.transform.SetParent(localAvatar.transform.Find("body"), worldPositionStays: false);
			helpPanel.transform.localPosition = new Vector3(0f, 1f, 1f);
			helpMesh.material = gearMaterial;
		}
		else
		{
			helpPanel.transform.SetParent(localAvatar.transform.Find("hand_left"), worldPositionStays: false);
			helpPanel.transform.localPosition = new Vector3(0f, 0.2f, 0.2f);
			helpMesh.material = riftMaterial;
		}
		localAvatar.oculusUserID = myID.ToString();
		localAvatar.RecordPackets = true;
		OvrAvatar ovrAvatar = localAvatar;
		ovrAvatar.PacketRecorded = (EventHandler<OvrAvatar.PacketEventArgs>)Delegate.Combine(ovrAvatar.PacketRecorded, new EventHandler<OvrAvatar.PacketEventArgs>(OnLocalAvatarPacketRecorded));
		localAvatar.EnableMouthVertexAnimation = true;
		Quaternion identity = Quaternion.identity;
		switch (UnityEngine.Random.Range(0, 4))
		{
		case 0:
			identity.eulerAngles = START_ROTATION_ONE;
			base.transform.localPosition = START_POSITION_ONE;
			base.transform.localRotation = identity;
			break;
		case 1:
			identity.eulerAngles = START_ROTATION_TWO;
			base.transform.localPosition = START_POSITION_TWO;
			base.transform.localRotation = identity;
			break;
		case 2:
			identity.eulerAngles = START_ROTATION_THREE;
			base.transform.localPosition = START_POSITION_THREE;
			base.transform.localRotation = identity;
			break;
		default:
			identity.eulerAngles = START_ROTATION_FOUR;
			base.transform.localPosition = START_POSITION_FOUR;
			base.transform.localRotation = identity;
			break;
		}
		TransitionToState(State.CHECKING_LAUNCH_STATE);
		if (!roomManager.CheckForInvite())
		{
			LogOutput("No invite on launch, looking for a friend to join.");
			Users.GetLoggedInUserFriendsAndRooms().OnComplete(GetLoggedInUserFriendsAndRoomsCallback);
		}
		Voip.SetMicrophoneFilterCallback(MicFilter);
	}

	private void GetLoggedInUserFriendsAndRoomsCallback(Message<UserAndRoomList> msg)
	{
		if (msg.IsError)
		{
			return;
		}
		foreach (UserAndRoom datum in msg.Data)
		{
			if (datum.User != null && datum.RoomOptional != null && !datum.RoomOptional.IsMembershipLocked && datum.RoomOptional.Joinability == RoomJoinability.CanJoin && datum.RoomOptional.JoinPolicy != 0)
			{
				LogOutput("Trying to join room " + datum.RoomOptional.ID + ", friend " + datum.User.OculusID);
				roomManager.JoinExistingRoom(datum.RoomOptional.ID);
				return;
			}
		}
		LogOutput("No friend to join. Creating my own room.");
		roomManager.CreateRoom();
		TransitionToState(State.CREATING_A_ROOM);
	}

	public void OnLocalAvatarPacketRecorded(object sender, OvrAvatar.PacketEventArgs args)
	{
		uint num = Oculus.Avatar.CAPI.ovrAvatarPacket_GetSize(args.Packet.ovrNativePacket);
		byte[] array = new byte[num];
		Oculus.Avatar.CAPI.ovrAvatarPacket_Write(args.Packet.ovrNativePacket, num, array);
		foreach (KeyValuePair<ulong, RemotePlayer> remoteUser in remoteUsers)
		{
			p2pManager.SendAvatarUpdate(remoteUser.Key, localTrackingSpace.transform, packetSequence, array);
		}
		packetSequence++;
	}

	public void OnApplicationQuit()
	{
		roomManager.LeaveCurrentRoom();
		foreach (KeyValuePair<ulong, RemotePlayer> remoteUser in remoteUsers)
		{
			p2pManager.Disconnect(remoteUser.Key);
			voipManager.Disconnect(remoteUser.Key);
		}
		LogOutputLine("End Log.");
	}

	public void AddUser(ulong userID, ref RemotePlayer remoteUser)
	{
		remoteUsers.Add(userID, remoteUser);
	}

	public void LogOutputLine(string line)
	{
		UnityEngine.Debug.Log(Time.time + ": " + line);
	}

	public static void TerminateWithError(Message msg)
	{
		s_instance.LogOutputLine("Error: " + msg.GetError().Message);
		UnityEngine.Application.Quit();
	}

	public static void TransitionToState(State newState)
	{
		if ((bool)s_instance)
		{
			s_instance.LogOutputLine(string.Concat("State ", s_instance.currentState, " -> ", newState));
		}
		if ((bool)s_instance && s_instance.currentState != newState)
		{
			s_instance.currentState = newState;
			if (newState == State.SHUTDOWN)
			{
				s_instance.OnApplicationQuit();
			}
		}
		SetSphereColorForState();
	}

	private static void SetSphereColorForState()
	{
		switch (s_instance.currentState)
		{
		case State.INITIALIZING:
		case State.SHUTDOWN:
			s_instance.sphereMesh.material.color = BLACK;
			break;
		case State.WAITING_IN_A_ROOM:
			s_instance.sphereMesh.material.color = WHITE;
			break;
		case State.CONNECTED_IN_A_ROOM:
			s_instance.sphereMesh.material.color = CYAN;
			break;
		}
	}

	public static void SetFloorColorForState(bool host)
	{
		if (host)
		{
			s_instance.floorMesh.material.color = BLUE;
		}
		else
		{
			s_instance.floorMesh.material.color = GREEN;
		}
	}

	public static void MarkAllRemoteUsersAsNotInRoom()
	{
		foreach (KeyValuePair<ulong, RemotePlayer> remoteUser in s_instance.remoteUsers)
		{
			remoteUser.Value.stillInRoom = false;
		}
	}

	public static void MarkRemoteUserInRoom(ulong userID)
	{
		RemotePlayer value = new RemotePlayer();
		if (s_instance.remoteUsers.TryGetValue(userID, out value))
		{
			value.stillInRoom = true;
		}
	}

	public static void ForgetRemoteUsersNotInRoom()
	{
		List<ulong> list = new List<ulong>();
		foreach (KeyValuePair<ulong, RemotePlayer> remoteUser in s_instance.remoteUsers)
		{
			if (!remoteUser.Value.stillInRoom)
			{
				list.Add(remoteUser.Key);
			}
		}
		foreach (ulong item in list)
		{
			RemoveRemoteUser(item);
		}
	}

	public static void LogOutput(string line)
	{
		s_instance.LogOutputLine(Time.time + ": " + line);
	}

	public static bool IsUserInRoom(ulong userID)
	{
		return s_instance.remoteUsers.ContainsKey(userID);
	}

	public static void AddRemoteUser(ulong userID)
	{
		RemotePlayer remoteUser = new RemotePlayer();
		remoteUser.RemoteAvatar = UnityEngine.Object.Instantiate(s_instance.remoteAvatarPrefab);
		remoteUser.RemoteAvatar.oculusUserID = userID.ToString();
		remoteUser.RemoteAvatar.ShowThirdPerson = true;
		remoteUser.RemoteAvatar.EnableMouthVertexAnimation = true;
		remoteUser.p2pConnectionState = PeerConnectionState.Unknown;
		remoteUser.voipConnectionState = PeerConnectionState.Unknown;
		remoteUser.stillInRoom = true;
		remoteUser.remoteUserID = userID;
		s_instance.AddUser(userID, ref remoteUser);
		s_instance.p2pManager.ConnectTo(userID);
		s_instance.voipManager.ConnectTo(userID);
		s_instance.LogOutputLine("Adding User " + userID);
	}

	public static void RemoveRemoteUser(ulong userID)
	{
		RemotePlayer value = new RemotePlayer();
		if (s_instance.remoteUsers.TryGetValue(userID, out value))
		{
			UnityEngine.Object.Destroy(value.RemoteAvatar.MouthAnchor.GetComponent<VoipAudioSourceHiLevel>(), 0f);
			UnityEngine.Object.Destroy(value.RemoteAvatar.gameObject, 0f);
			s_instance.remoteUsers.Remove(userID);
			s_instance.LogOutputLine("Removing User " + userID);
		}
	}

	public void UpdateVoiceData(short[] pcmData, int numChannels)
	{
		if (localAvatar != null)
		{
			localAvatar.UpdateVoiceData(pcmData, numChannels);
		}
		float num = 0f;
		float[] array = new float[pcmData.Length];
		for (int i = 0; i < pcmData.Length; i++)
		{
			float num2 = (array[i] = (float)pcmData[i] / 32767f);
			if (num2 > num)
			{
				num = num2;
			}
		}
		voiceCurrent = num;
	}

	[MonoPInvokeCallback(typeof(Oculus.Platform.CAPI.FilterCallback))]
	public static void MicFilter(short[] pcmData, UIntPtr pcmDataLength, int frequency, int numChannels)
	{
		s_instance.UpdateVoiceData(pcmData, numChannels);
	}

	public static RemotePlayer GetRemoteUser(ulong userID)
	{
		RemotePlayer value = new RemotePlayer();
		if (s_instance.remoteUsers.TryGetValue(userID, out value))
		{
			return value;
		}
		return null;
	}
}
public class VoipManager
{
	public VoipManager()
	{
		Voip.SetVoipConnectRequestCallback(VoipConnectRequestCallback);
		Voip.SetVoipStateChangeCallback(VoipStateChangedCallback);
	}

	public void ConnectTo(ulong userID)
	{
		if (SocialPlatformManager.MyID < userID)
		{
			Voip.Start(userID);
			SocialPlatformManager.LogOutput("Voip connect to " + userID);
		}
	}

	public void Disconnect(ulong userID)
	{
		if (userID != 0L)
		{
			Voip.Stop(userID);
			RemotePlayer remoteUser = SocialPlatformManager.GetRemoteUser(userID);
			if (remoteUser != null)
			{
				remoteUser.voipConnectionState = PeerConnectionState.Unknown;
			}
		}
	}

	private void VoipConnectRequestCallback(Message<NetworkingPeer> msg)
	{
		SocialPlatformManager.LogOutput("Voip request from " + msg.Data.ID);
		if (SocialPlatformManager.GetRemoteUser(msg.Data.ID) != null)
		{
			SocialPlatformManager.LogOutput("Voip request accepted from " + msg.Data.ID);
			Voip.Accept(msg.Data.ID);
		}
	}

	private void VoipStateChangedCallback(Message<NetworkingPeer> msg)
	{
		SocialPlatformManager.LogOutput("Voip state to " + msg.Data.ID + " changed to  " + msg.Data.State);
		RemotePlayer remoteUser = SocialPlatformManager.GetRemoteUser(msg.Data.ID);
		if (remoteUser != null)
		{
			remoteUser.voipConnectionState = msg.Data.State;
			if (msg.Data.State == PeerConnectionState.Timeout && SocialPlatformManager.MyID < msg.Data.ID)
			{
				Voip.Start(msg.Data.ID);
				SocialPlatformManager.LogOutput("Voip re-connect to " + msg.Data.ID);
			}
		}
	}
}
public class GazeTarget : MonoBehaviour
{
	public ovrAvatarGazeTargetType Type;

	private static ovrAvatarGazeTargets RuntimeTargetList;

	static GazeTarget()
	{
		RuntimeTargetList.targets = new ovrAvatarGazeTarget[128];
		RuntimeTargetList.targetCount = 1u;
	}

	private void Start()
	{
		UpdateGazeTarget();
		base.transform.hasChanged = false;
	}

	private void Update()
	{
		if (base.transform.hasChanged)
		{
			base.transform.hasChanged = false;
			UpdateGazeTarget();
		}
	}

	private void OnDestroy()
	{
		Oculus.Avatar.CAPI.ovrAvatar_RemoveGazeTargets(1u, new uint[1] { (uint)base.transform.GetInstanceID() });
	}

	private void UpdateGazeTarget()
	{
		ovrAvatarGazeTarget ovrAvatarGazeTarget2 = CreateOvrGazeTarget((uint)base.transform.GetInstanceID(), base.transform.position, Type);
		RuntimeTargetList.targets[0] = ovrAvatarGazeTarget2;
		Oculus.Avatar.CAPI.ovrAvatar_UpdateGazeTargets(RuntimeTargetList);
	}

	private ovrAvatarGazeTarget CreateOvrGazeTarget(uint targetId, Vector3 targetPosition, ovrAvatarGazeTargetType targetType)
	{
		ovrAvatarGazeTarget result = default(ovrAvatarGazeTarget);
		result.id = targetId;
		result.worldPosition = new Vector3(targetPosition.x, targetPosition.y, 0f - targetPosition.z);
		result.type = targetType;
		return result;
	}
}
[Serializable]
public class AvatarLayer
{
	public int layerIndex;
}
[Serializable]
public class PacketRecordSettings
{
	internal bool RecordingFrames;

	public float UpdateRate = 1f / 30f;

	internal float AccumulatedTime;
}
public class OvrAvatar : MonoBehaviour
{
	public class PacketEventArgs : EventArgs
	{
		public readonly OvrAvatarPacket Packet;

		public PacketEventArgs(OvrAvatarPacket packet)
		{
			Packet = packet;
		}
	}

	public enum HandType
	{
		Right,
		Left,
		Max
	}

	public enum HandJoint
	{
		HandBase,
		IndexBase,
		IndexTip,
		ThumbBase,
		ThumbTip,
		Max
	}

	[Header("Avatar")]
	public IntPtr sdkAvatar = IntPtr.Zero;

	public string oculusUserID;

	public OvrAvatarDriver Driver;

	[Header("Capabilities")]
	public bool EnableBody = true;

	public bool EnableHands = true;

	public bool EnableBase = true;

	public bool EnableExpressive;

	[Header("Network")]
	public bool RecordPackets;

	public bool UseSDKPackets = true;

	public PacketRecordSettings PacketSettings = new PacketRecordSettings();

	[Header("Visibility")]
	public bool StartWithControllers;

	public AvatarLayer FirstPersonLayer;

	public AvatarLayer ThirdPersonLayer;

	public bool ShowFirstPerson = true;

	public bool ShowThirdPerson;

	internal ovrAvatarCapabilities Capabilities = ovrAvatarCapabilities.Body;

	[Header("Performance")]
	[Tooltip("LOD mesh complexity and texture resolution. Highest LOD recommended on PC and simple mobile apps. Medium LOD recommended on mobile devices or for background characters on PC. Lowest LOD recommended for background characters on mobile.")]
	[SerializeField]
	internal ovrAvatarAssetLevelOfDetail LevelOfDetail = ovrAvatarAssetLevelOfDetail.Medium;

	[Tooltip("Enable to use combined meshes to reduce draw calls. Currently only available on mobile devices. Will be forced to false on PC.")]
	private bool CombineMeshes = true;

	[Tooltip("Enable to use transparent queue, disable to use geometry queue. Requires restart to take effect.")]
	public bool UseTransparentRenderQueue = true;

	[Header("Shaders")]
	public Shader Monochrome_SurfaceShader;

	public Shader Monochrome_SurfaceShader_SelfOccluding;

	public Shader Monochrome_SurfaceShader_PBS;

	public Shader Skinshaded_SurfaceShader_SingleComponent;

	public Shader Skinshaded_VertFrag_SingleComponent;

	public Shader Skinshaded_VertFrag_CombinedMesh;

	public Shader Skinshaded_Expressive_SurfaceShader_SingleComponent;

	public Shader Skinshaded_Expressive_VertFrag_SingleComponent;

	public Shader Skinshaded_Expressive_VertFrag_CombinedMesh;

	public Shader Loader_VertFrag_CombinedMesh;

	public Shader EyeLens;

	public Shader ControllerShader;

	[Header("Other")]
	public bool CanOwnMicrophone = true;

	[Tooltip("Enable laughter detection and animation as part of OVRLipSync.")]
	public bool EnableLaughter = true;

	public GameObject MouthAnchor;

	public Transform LeftHandCustomPose;

	public Transform RightHandCustomPose;

	private HashSet<ulong> assetLoadingIds = new HashSet<ulong>();

	public bool assetsFinishedLoading;

	private int renderPartCount;

	private OvrAvatarMaterialManager materialManager;

	private bool waitingForCombinedMesh;

	private static bool doneExpressiveGlobalInit;

	private Vector4 clothingAlphaOffset = new Vector4(0f, 0f, 0f, 1f);

	private ulong clothingAlphaTexture;

	private OVRLipSyncMicInput micInput;

	private OVRLipSyncContext lipsyncContext;

	private OVRLipSync.Frame currentFrame = new OVRLipSync.Frame();

	private float[] visemes = new float[16];

	private AudioSource audioSource;

	private ONSPAudioSource spatializedSource;

	private List<float[]> voiceUpdates = new List<float[]>();

	private static ovrAvatarVisemes RuntimeVisemes;

	private Transform cachedLeftHandCustomPose;

	private Transform[] cachedCustomLeftHandJoints;

	private ovrAvatarTransform[] cachedLeftHandTransforms;

	private Transform cachedRightHandCustomPose;

	private Transform[] cachedCustomRightHandJoints;

	private ovrAvatarTransform[] cachedRightHandTransforms;

	private bool showLeftController;

	private bool showRightController;

	private const bool USE_MOBILE_TEXTURE_FORMAT = true;

	private static readonly Vector3 MOUTH_HEAD_OFFSET;

	private const string MOUTH_HELPER_NAME = "MouthAnchor";

	private const int VISEME_COUNT = 16;

	private const float ACTION_UNIT_ONSET_SPEED = 30f;

	private const float ACTION_UNIT_FALLOFF_SPEED = 20f;

	private const float VISEME_LEVEL_MULTIPLIER = 1.5f;

	internal ulong oculusUserIDInternal;

	internal OvrAvatarBase Base;

	internal OvrAvatarTouchController ControllerLeft;

	internal OvrAvatarTouchController ControllerRight;

	internal OvrAvatarBody Body;

	internal OvrAvatarHand HandLeft;

	internal OvrAvatarHand HandRight;

	internal ovrAvatarLookAndFeelVersion LookAndFeelVersion = ovrAvatarLookAndFeelVersion.Two;

	internal ovrAvatarLookAndFeelVersion FallbackLookAndFeelVersion = ovrAvatarLookAndFeelVersion.Two;

	private OvrAvatarPacket CurrentUnityPacket;

	public EventHandler<PacketEventArgs> PacketRecorded;

	private static string[,] HandJoints;

	private static Vector3 MOUTH_POSITION_OFFSET;

	private static string VOICE_PROPERTY;

	private static string MOUTH_POSITION_PROPERTY;

	private static string MOUTH_DIRECTION_PROPERTY;

	private static string MOUTH_SCALE_PROPERTY;

	private static float MOUTH_SCALE_GLOBAL;

	private static float MOUTH_MAX_GLOBAL;

	private static string NECK_JONT;

	public float VoiceAmplitude;

	public bool EnableMouthVertexAnimation;

	private static ovrAvatarLights ovrLights;

	static OvrAvatar()
	{
		doneExpressiveGlobalInit = false;
		MOUTH_HEAD_OFFSET = new Vector3(0f, -0.085f, 0.09f);
		HandJoints = new string[2, 5]
		{
			{ "hands:r_hand_world", "hands:r_hand_world/hands:b_r_hand/hands:b_r_index1", "hands:r_hand_world/hands:b_r_hand/hands:b_r_index1/hands:b_r_index2/hands:b_r_index3/hands:b_r_index_ignore", "hands:r_hand_world/hands:b_r_hand/hands:b_r_thumb1/hands:b_r_thumb2", "hands:r_hand_world/hands:b_r_hand/hands:b_r_thumb1/hands:b_r_thumb2/hands:b_r_thumb3/hands:b_r_thumb_ignore" },
			{ "hands:l_hand_world", "hands:l_hand_world/hands:b_l_hand/hands:b_l_index1", "hands:l_hand_world/hands:b_l_hand/hands:b_l_index1/hands:b_l_index2/hands:b_l_index3/hands:b_l_index_ignore", "hands:l_hand_world/hands:b_l_hand/hands:b_l_thumb1/hands:b_l_thumb2", "hands:l_hand_world/hands:b_l_hand/hands:b_l_thumb1/hands:b_l_thumb2/hands:b_l_thumb3/hands:b_l_thumb_ignore" }
		};
		MOUTH_POSITION_OFFSET = new Vector3(0f, -0.018f, 0.1051f);
		VOICE_PROPERTY = "_Voice";
		MOUTH_POSITION_PROPERTY = "_MouthPosition";
		MOUTH_DIRECTION_PROPERTY = "_MouthDirection";
		MOUTH_SCALE_PROPERTY = "_MouthEffectScale";
		MOUTH_SCALE_GLOBAL = 0.007f;
		MOUTH_MAX_GLOBAL = 0.007f;
		NECK_JONT = "root_JNT/body_JNT/chest_JNT/neckBase_JNT/neck_JNT";
		ovrLights = default(ovrAvatarLights);
		RuntimeVisemes.visemeParams = new float[32];
		RuntimeVisemes.visemeParamCount = 16u;
	}

	private void OnDestroy()
	{
		if (sdkAvatar != IntPtr.Zero)
		{
			Oculus.Avatar.CAPI.ovrAvatar_Destroy(sdkAvatar);
		}
	}

	public void AssetLoadedCallback(OvrAvatarAsset asset)
	{
		assetLoadingIds.Remove(asset.assetID);
	}

	public void CombinedMeshLoadedCallback(IntPtr assetPtr)
	{
		if (waitingForCombinedMesh)
		{
			ulong[] array = Oculus.Avatar.CAPI.ovrAvatarAsset_GetCombinedMeshIDs(assetPtr);
			foreach (ulong item in array)
			{
				assetLoadingIds.Remove(item);
			}
			Oculus.Avatar.CAPI.ovrAvatar_GetCombinedMeshAlphaData(sdkAvatar, ref clothingAlphaTexture, ref clothingAlphaOffset);
			waitingForCombinedMesh = false;
		}
	}

	private OvrAvatarSkinnedMeshRenderComponent AddSkinnedMeshRenderComponent(GameObject gameObject, ovrAvatarRenderPart_SkinnedMeshRender skinnedMeshRender)
	{
		OvrAvatarSkinnedMeshRenderComponent ovrAvatarSkinnedMeshRenderComponent = gameObject.AddComponent<OvrAvatarSkinnedMeshRenderComponent>();
		ovrAvatarSkinnedMeshRenderComponent.Initialize(skinnedMeshRender, Monochrome_SurfaceShader, Monochrome_SurfaceShader_SelfOccluding, ThirdPersonLayer.layerIndex, FirstPersonLayer.layerIndex);
		return ovrAvatarSkinnedMeshRenderComponent;
	}

	private OvrAvatarSkinnedMeshRenderPBSComponent AddSkinnedMeshRenderPBSComponent(GameObject gameObject, ovrAvatarRenderPart_SkinnedMeshRenderPBS skinnedMeshRenderPBS)
	{
		OvrAvatarSkinnedMeshRenderPBSComponent ovrAvatarSkinnedMeshRenderPBSComponent = gameObject.AddComponent<OvrAvatarSkinnedMeshRenderPBSComponent>();
		ovrAvatarSkinnedMeshRenderPBSComponent.Initialize(skinnedMeshRenderPBS, Monochrome_SurfaceShader_PBS, ThirdPersonLayer.layerIndex, FirstPersonLayer.layerIndex);
		return ovrAvatarSkinnedMeshRenderPBSComponent;
	}

	private OvrAvatarSkinnedMeshPBSV2RenderComponent AddSkinnedMeshRenderPBSV2Component(IntPtr renderPart, GameObject go, ovrAvatarRenderPart_SkinnedMeshRenderPBS_V2 skinnedMeshRenderPBSV2, bool isBodyPartZero, bool isControllerModel)
	{
		OvrAvatarSkinnedMeshPBSV2RenderComponent ovrAvatarSkinnedMeshPBSV2RenderComponent = go.AddComponent<OvrAvatarSkinnedMeshPBSV2RenderComponent>();
		ovrAvatarSkinnedMeshPBSV2RenderComponent.Initialize(renderPart, skinnedMeshRenderPBSV2, materialManager, ThirdPersonLayer.layerIndex, FirstPersonLayer.layerIndex, isBodyPartZero && CombineMeshes, LevelOfDetail, isBodyPartZero && EnableExpressive, this, isControllerModel);
		return ovrAvatarSkinnedMeshPBSV2RenderComponent;
	}

	public static IntPtr GetRenderPart(ovrAvatarComponent component, uint renderPartIndex)
	{
		return Marshal.ReadIntPtr(component.renderParts, Marshal.SizeOf(typeof(IntPtr)) * (int)renderPartIndex);
	}

	private static string GetRenderPartName(ovrAvatarComponent component, uint renderPartIndex)
	{
		return component.name + "_renderPart_" + (int)renderPartIndex;
	}

	internal static void ConvertTransform(float[] transform, ref ovrAvatarTransform target)
	{
		target.position.x = transform[0];
		target.position.y = transform[1];
		target.position.z = transform[2];
		target.orientation.x = transform[3];
		target.orientation.y = transform[4];
		target.orientation.z = transform[5];
		target.orientation.w = transform[6];
		target.scale.x = transform[7];
		target.scale.y = transform[8];
		target.scale.z = transform[9];
	}

	internal static void ConvertTransform(ovrAvatarTransform transform, Transform target)
	{
		Vector3 position = transform.position;
		position.z = 0f - position.z;
		Quaternion orientation = transform.orientation;
		orientation.x = 0f - orientation.x;
		orientation.y = 0f - orientation.y;
		target.localPosition = position;
		target.localRotation = orientation;
		target.localScale = transform.scale;
	}

	public static ovrAvatarTransform CreateOvrAvatarTransform(Vector3 position, Quaternion orientation)
	{
		ovrAvatarTransform result = default(ovrAvatarTransform);
		result.position = new Vector3(position.x, position.y, 0f - position.z);
		result.orientation = new Quaternion(0f - orientation.x, 0f - orientation.y, orientation.z, orientation.w);
		result.scale = Vector3.one;
		return result;
	}

	private static ovrAvatarGazeTarget CreateOvrGazeTarget(uint targetId, Vector3 targetPosition, ovrAvatarGazeTargetType targetType)
	{
		ovrAvatarGazeTarget result = default(ovrAvatarGazeTarget);
		result.id = targetId;
		result.worldPosition = new Vector3(targetPosition.x, targetPosition.y, 0f - targetPosition.z);
		result.type = targetType;
		return result;
	}

	private void BuildRenderComponents()
	{
		ovrAvatarBaseComponent component = default(ovrAvatarBaseComponent);
		ovrAvatarHandComponent component2 = default(ovrAvatarHandComponent);
		ovrAvatarHandComponent component3 = default(ovrAvatarHandComponent);
		ovrAvatarControllerComponent component4 = default(ovrAvatarControllerComponent);
		ovrAvatarControllerComponent component5 = default(ovrAvatarControllerComponent);
		ovrAvatarBodyComponent component6 = default(ovrAvatarBodyComponent);
		ovrAvatarComponent component7 = default(ovrAvatarComponent);
		if (Oculus.Avatar.CAPI.ovrAvatarPose_GetLeftHandComponent(sdkAvatar, ref component2))
		{
			Oculus.Avatar.CAPI.ovrAvatarComponent_Get(component2.renderComponent, includeName: true, ref component7);
			AddAvatarComponent(ref HandLeft, component7);
			HandLeft.isLeftHand = true;
		}
		if (Oculus.Avatar.CAPI.ovrAvatarPose_GetRightHandComponent(sdkAvatar, ref component3))
		{
			Oculus.Avatar.CAPI.ovrAvatarComponent_Get(component3.renderComponent, includeName: true, ref component7);
			AddAvatarComponent(ref HandRight, component7);
			HandRight.isLeftHand = false;
		}
		if (Oculus.Avatar.CAPI.ovrAvatarPose_GetBodyComponent(sdkAvatar, ref component6))
		{
			Oculus.Avatar.CAPI.ovrAvatarComponent_Get(component6.renderComponent, includeName: true, ref component7);
			AddAvatarComponent(ref Body, component7);
		}
		if (Oculus.Avatar.CAPI.ovrAvatarPose_GetLeftControllerComponent(sdkAvatar, ref component4))
		{
			Oculus.Avatar.CAPI.ovrAvatarComponent_Get(component4.renderComponent, includeName: true, ref component7);
			AddAvatarComponent(ref ControllerLeft, component7);
			ControllerLeft.isLeftHand = true;
		}
		if (Oculus.Avatar.CAPI.ovrAvatarPose_GetRightControllerComponent(sdkAvatar, ref component5))
		{
			Oculus.Avatar.CAPI.ovrAvatarComponent_Get(component5.renderComponent, includeName: true, ref component7);
			AddAvatarComponent(ref ControllerRight, component7);
			ControllerRight.isLeftHand = false;
		}
		if (Oculus.Avatar.CAPI.ovrAvatarPose_GetBaseComponent(sdkAvatar, ref component))
		{
			Oculus.Avatar.CAPI.ovrAvatarComponent_Get(component.renderComponent, includeName: true, ref component7);
			AddAvatarComponent(ref Base, component7);
		}
	}

	private void AddAvatarComponent<T>(ref T root, ovrAvatarComponent nativeComponent) where T : OvrAvatarComponent
	{
		GameObject gameObject = new GameObject();
		gameObject.name = nativeComponent.name;
		gameObject.transform.SetParent(base.transform);
		root = gameObject.AddComponent<T>();
		root.SetOvrAvatarOwner(this);
		AddRenderParts(root, nativeComponent, gameObject.transform);
	}

	private void UpdateCustomPoses()
	{
		if (UpdatePoseRoot(LeftHandCustomPose, ref cachedLeftHandCustomPose, ref cachedCustomLeftHandJoints, ref cachedLeftHandTransforms) && cachedLeftHandCustomPose == null && sdkAvatar != IntPtr.Zero)
		{
			Oculus.Avatar.CAPI.ovrAvatar_SetLeftHandGesture(sdkAvatar, ovrAvatarHandGesture.Default);
		}
		if (UpdatePoseRoot(RightHandCustomPose, ref cachedRightHandCustomPose, ref cachedCustomRightHandJoints, ref cachedRightHandTransforms) && cachedRightHandCustomPose == null && sdkAvatar != IntPtr.Zero)
		{
			Oculus.Avatar.CAPI.ovrAvatar_SetRightHandGesture(sdkAvatar, ovrAvatarHandGesture.Default);
		}
		if (sdkAvatar != IntPtr.Zero)
		{
			if (cachedLeftHandCustomPose != null && UpdateTransforms(cachedCustomLeftHandJoints, cachedLeftHandTransforms))
			{
				Oculus.Avatar.CAPI.ovrAvatar_SetLeftHandCustomGesture(sdkAvatar, (uint)cachedLeftHandTransforms.Length, cachedLeftHandTransforms);
			}
			if (cachedRightHandCustomPose != null && UpdateTransforms(cachedCustomRightHandJoints, cachedRightHandTransforms))
			{
				Oculus.Avatar.CAPI.ovrAvatar_SetRightHandCustomGesture(sdkAvatar, (uint)cachedRightHandTransforms.Length, cachedRightHandTransforms);
			}
		}
	}

	private static bool UpdatePoseRoot(Transform poseRoot, ref Transform cachedPoseRoot, ref Transform[] cachedPoseJoints, ref ovrAvatarTransform[] transforms)
	{
		if (poseRoot == cachedPoseRoot)
		{
			return false;
		}
		if (!poseRoot)
		{
			cachedPoseRoot = null;
			cachedPoseJoints = null;
			transforms = null;
		}
		else
		{
			List<Transform> list = new List<Transform>();
			OrderJoints(poseRoot, list);
			cachedPoseRoot = poseRoot;
			cachedPoseJoints = list.ToArray();
			transforms = new ovrAvatarTransform[list.Count];
		}
		return true;
	}

	private static bool UpdateTransforms(Transform[] joints, ovrAvatarTransform[] transforms)
	{
		bool result = false;
		for (int i = 0; i < joints.Length; i++)
		{
			Transform transform = joints[i];
			ovrAvatarTransform ovrAvatarTransform2 = CreateOvrAvatarTransform(transform.localPosition, transform.localRotation);
			if (ovrAvatarTransform2.position != transforms[i].position || ovrAvatarTransform2.orientation != transforms[i].orientation)
			{
				transforms[i] = ovrAvatarTransform2;
				result = true;
			}
		}
		return result;
	}

	private static void OrderJoints(Transform transform, List<Transform> joints)
	{
		joints.Add(transform);
		for (int i = 0; i < transform.childCount; i++)
		{
			OrderJoints(transform.GetChild(i), joints);
		}
	}

	private void AvatarSpecificationCallback(IntPtr avatarSpecification)
	{
		sdkAvatar = Oculus.Avatar.CAPI.ovrAvatar_Create(avatarSpecification, Capabilities);
		ShowLeftController(showLeftController);
		ShowRightController(showRightController);
		if (Driver != null)
		{
			Driver.UpdateTransformsFromPose(sdkAvatar);
		}
		uint num = Oculus.Avatar.CAPI.ovrAvatar_GetReferencedAssetCount(sdkAvatar);
		for (uint num2 = 0u; num2 < num; num2++)
		{
			ulong num3 = Oculus.Avatar.CAPI.ovrAvatar_GetReferencedAsset(sdkAvatar, num2);
			if (OvrAvatarSDKManager.Instance.GetAsset(num3) == null)
			{
				OvrAvatarSDKManager.Instance.BeginLoadingAsset(num3, LevelOfDetail, AssetLoadedCallback);
				assetLoadingIds.Add(num3);
			}
		}
		if (CombineMeshes)
		{
			OvrAvatarSDKManager.Instance.RegisterCombinedMeshCallback(sdkAvatar, CombinedMeshLoadedCallback);
		}
	}

	private void Start()
	{
		if (!(OvrAvatarSDKManager.Instance == null))
		{
			materialManager = base.gameObject.AddComponent<OvrAvatarMaterialManager>();
			try
			{
				oculusUserIDInternal = ulong.Parse(oculusUserID);
			}
			catch (Exception)
			{
				oculusUserIDInternal = 0uL;
			}
			if (oculusUserIDInternal == 0L)
			{
				CombineMeshes = false;
			}
			Capabilities = (ovrAvatarCapabilities)0;
			bool flag = false;
			switch (OVRPlugin.GetSystemHeadsetType())
			{
			case OVRPlugin.SystemHeadset.GearVR_R320:
			case OVRPlugin.SystemHeadset.GearVR_R321:
			case OVRPlugin.SystemHeadset.GearVR_R322:
			case OVRPlugin.SystemHeadset.GearVR_R323:
			case OVRPlugin.SystemHeadset.GearVR_R324:
			case OVRPlugin.SystemHeadset.GearVR_R325:
			case OVRPlugin.SystemHeadset.Oculus_Go:
				flag = true;
				break;
			}
			if (flag && !EnableBody)
			{
				EnableBody = true;
				ShowFirstPerson = true;
				ShowThirdPerson = false;
			}
			if (EnableBody)
			{
				Capabilities |= ovrAvatarCapabilities.Body;
			}
			if (EnableHands)
			{
				Capabilities |= ovrAvatarCapabilities.Hands;
			}
			if (EnableBase && EnableBody)
			{
				Capabilities |= ovrAvatarCapabilities.Base;
			}
			if (EnableExpressive)
			{
				Capabilities |= ovrAvatarCapabilities.Expressive;
			}
			if (OVRPlugin.positionSupported)
			{
				Capabilities |= ovrAvatarCapabilities.BodyTilt;
			}
			ShowLeftController(StartWithControllers);
			ShowRightController(StartWithControllers);
			OvrAvatarSDKManager.AvatarSpecRequestParams avatarSpecRequest = new OvrAvatarSDKManager.AvatarSpecRequestParams(oculusUserIDInternal, AvatarSpecificationCallback, CombineMeshes, LevelOfDetail, forceMobileTextureFormat: true, LookAndFeelVersion, FallbackLookAndFeelVersion, EnableExpressive);
			OvrAvatarSDKManager.Instance.RequestAvatarSpecification(avatarSpecRequest);
			OvrAvatarSDKManager.Instance.AddLoadingAvatar(GetInstanceID());
			waitingForCombinedMesh = CombineMeshes;
			if (Driver != null)
			{
				Driver.Mode = ((!UseSDKPackets) ? OvrAvatarDriver.PacketMode.Unity : OvrAvatarDriver.PacketMode.SDK);
			}
		}
	}

	private void Update()
	{
		if (!OvrAvatarSDKManager.Instance || sdkAvatar == IntPtr.Zero || materialManager == null)
		{
			return;
		}
		if (Driver != null)
		{
			Driver.UpdateTransforms(sdkAvatar);
			foreach (float[] voiceUpdate in voiceUpdates)
			{
				Oculus.Avatar.CAPI.ovrAvatarPose_UpdateVoiceVisualization(sdkAvatar, voiceUpdate);
			}
			voiceUpdates.Clear();
			Oculus.Avatar.CAPI.ovrAvatarPose_Finalize(sdkAvatar, Time.deltaTime);
		}
		if (RecordPackets)
		{
			RecordFrame();
		}
		if (assetLoadingIds.Count != 0)
		{
			return;
		}
		if (!assetsFinishedLoading)
		{
			try
			{
				BuildRenderComponents();
			}
			catch (Exception)
			{
				assetsFinishedLoading = true;
				throw;
			}
			InitPostLoad();
			assetsFinishedLoading = true;
			OvrAvatarSDKManager.Instance.RemoveLoadingAvatar(GetInstanceID());
		}
		UpdateVoiceBehavior();
		UpdateCustomPoses();
		if (EnableExpressive)
		{
			UpdateExpressive();
		}
	}

	public static ovrAvatarHandInputState CreateInputState(ovrAvatarTransform transform, OvrAvatarDriver.ControllerPose pose)
	{
		ovrAvatarHandInputState result = default(ovrAvatarHandInputState);
		result.transform = transform;
		result.buttonMask = pose.buttons;
		result.touchMask = pose.touches;
		result.joystickX = pose.joystickPosition.x;
		result.joystickY = pose.joystickPosition.y;
		result.indexTrigger = pose.indexTrigger;
		result.handTrigger = pose.handTrigger;
		result.isActive = pose.isActive;
		return result;
	}

	public void ShowControllers(bool show)
	{
		ShowLeftController(show);
		ShowRightController(show);
	}

	public void ShowLeftController(bool show)
	{
		if (sdkAvatar != IntPtr.Zero)
		{
			Oculus.Avatar.CAPI.ovrAvatar_SetLeftControllerVisibility(sdkAvatar, show);
		}
		showLeftController = show;
	}

	public void ShowRightController(bool show)
	{
		if (sdkAvatar != IntPtr.Zero)
		{
			Oculus.Avatar.CAPI.ovrAvatar_SetRightControllerVisibility(sdkAvatar, show);
		}
		showRightController = show;
	}

	public void UpdateVoiceVisualization(float[] voiceSamples)
	{
		voiceUpdates.Add(voiceSamples);
	}

	private void RecordFrame()
	{
		if (UseSDKPackets)
		{
			RecordSDKFrame();
		}
		else
		{
			RecordUnityFrame();
		}
	}

	private void RecordUnityFrame()
	{
		float num = Time.deltaTime;
		OvrAvatarDriver.PoseFrame currentPose = Driver.GetCurrentPose();
		if (CurrentUnityPacket == null)
		{
			CurrentUnityPacket = new OvrAvatarPacket(currentPose);
			num = 0f;
		}
		float num2 = 0f;
		while (num2 < num)
		{
			float num3 = num - num2;
			float num4 = PacketSettings.UpdateRate - CurrentUnityPacket.Duration;
			if (num3 < num4)
			{
				CurrentUnityPacket.AddFrame(currentPose, num3);
				num2 += num3;
				continue;
			}
			OvrAvatarDriver.PoseFrame finalFrame = CurrentUnityPacket.FinalFrame;
			OvrAvatarDriver.PoseFrame b = currentPose;
			float t = num4 / num3;
			OvrAvatarDriver.PoseFrame poseFrame = OvrAvatarDriver.PoseFrame.Interpolate(finalFrame, b, t);
			CurrentUnityPacket.AddFrame(poseFrame, num4);
			num2 += num4;
			if (PacketRecorded != null)
			{
				PacketRecorded(this, new PacketEventArgs(CurrentUnityPacket));
			}
			CurrentUnityPacket = new OvrAvatarPacket(poseFrame);
		}
	}

	private void RecordSDKFrame()
	{
		if (sdkAvatar == IntPtr.Zero)
		{
			return;
		}
		if (!PacketSettings.RecordingFrames)
		{
			Oculus.Avatar.CAPI.ovrAvatarPacket_BeginRecording(sdkAvatar);
			PacketSettings.AccumulatedTime = 0f;
			PacketSettings.RecordingFrames = true;
		}
		PacketSettings.AccumulatedTime += Time.deltaTime;
		if (PacketSettings.AccumulatedTime >= PacketSettings.UpdateRate)
		{
			PacketSettings.AccumulatedTime = 0f;
			IntPtr intPtr = Oculus.Avatar.CAPI.ovrAvatarPacket_EndRecording(sdkAvatar);
			Oculus.Avatar.CAPI.ovrAvatarPacket_BeginRecording(sdkAvatar);
			if (PacketRecorded != null)
			{
				PacketRecorded(this, new PacketEventArgs(new OvrAvatarPacket
				{
					ovrNativePacket = intPtr
				}));
			}
			Oculus.Avatar.CAPI.ovrAvatarPacket_Free(intPtr);
		}
	}

	private void AddRenderParts(OvrAvatarComponent ovrComponent, ovrAvatarComponent component, Transform parent)
	{
		bool flag = ovrComponent.name == "body";
		bool flag2 = ovrComponent.name == "controller_left";
		bool flag3 = ovrComponent.name == "controller_right";
		for (uint num = 0u; num < component.renderPartCount; num++)
		{
			GameObject gameObject = new GameObject();
			gameObject.name = GetRenderPartName(component, num);
			gameObject.transform.SetParent(parent);
			IntPtr renderPart = GetRenderPart(component, num);
			ovrAvatarRenderPartType ovrAvatarRenderPartType2 = Oculus.Avatar.CAPI.ovrAvatarRenderPart_GetType(renderPart);
			OvrAvatarRenderComponent ovrAvatarRenderComponent = null;
			switch (ovrAvatarRenderPartType2)
			{
			case ovrAvatarRenderPartType.SkinnedMeshRender:
				ovrAvatarRenderComponent = AddSkinnedMeshRenderComponent(gameObject, Oculus.Avatar.CAPI.ovrAvatarRenderPart_GetSkinnedMeshRender(renderPart));
				break;
			case ovrAvatarRenderPartType.SkinnedMeshRenderPBS:
				ovrAvatarRenderComponent = AddSkinnedMeshRenderPBSComponent(gameObject, Oculus.Avatar.CAPI.ovrAvatarRenderPart_GetSkinnedMeshRenderPBS(renderPart));
				break;
			case ovrAvatarRenderPartType.SkinnedMeshRenderPBS_V2:
				ovrAvatarRenderComponent = AddSkinnedMeshRenderPBSV2Component(renderPart, gameObject, Oculus.Avatar.CAPI.ovrAvatarRenderPart_GetSkinnedMeshRenderPBSV2(renderPart), flag && num == 0, flag2 || flag3);
				break;
			}
			if (ovrAvatarRenderComponent != null)
			{
				ovrComponent.RenderParts.Add(ovrAvatarRenderComponent);
			}
		}
	}

	public void RefreshBodyParts()
	{
		if (!(Body != null))
		{
			return;
		}
		foreach (OvrAvatarRenderComponent renderPart in Body.RenderParts)
		{
			UnityEngine.Object.Destroy(renderPart.gameObject);
		}
		Body.RenderParts.Clear();
		ovrAvatarComponent? nativeAvatarComponent = Body.GetNativeAvatarComponent();
		if (nativeAvatarComponent.HasValue)
		{
			AddRenderParts(Body, nativeAvatarComponent.Value, Body.gameObject.transform);
		}
	}

	public ovrAvatarBodyComponent? GetBodyComponent()
	{
		if (Body != null)
		{
			Oculus.Avatar.CAPI.ovrAvatarPose_GetBodyComponent(sdkAvatar, ref Body.component);
			return Body.component;
		}
		return null;
	}

	public Transform GetHandTransform(HandType hand, HandJoint joint)
	{
		if (hand >= HandType.Max || joint >= HandJoint.Max)
		{
			return null;
		}
		OvrAvatarHand ovrAvatarHand = ((hand == HandType.Left) ? HandLeft : HandRight);
		if (ovrAvatarHand != null)
		{
			OvrAvatarComponent component = ovrAvatarHand.GetComponent<OvrAvatarComponent>();
			if (component != null && component.RenderParts.Count > 0)
			{
				return component.RenderParts[0].transform.Find(HandJoints[(int)hand, (int)joint]);
			}
		}
		return null;
	}

	public void GetPointingDirection(HandType hand, ref Vector3 forward, ref Vector3 up)
	{
		Transform handTransform = GetHandTransform(hand, HandJoint.HandBase);
		if (handTransform != null)
		{
			forward = handTransform.forward;
			up = handTransform.up;
		}
	}

	private void UpdateVoiceBehavior()
	{
		if (EnableMouthVertexAnimation && Body != null)
		{
			OvrAvatarComponent component = Body.GetComponent<OvrAvatarComponent>();
			VoiceAmplitude = Mathf.Clamp(VoiceAmplitude, 0f, 1f);
			if (component.RenderParts.Count > 0)
			{
				Material sharedMaterial = component.RenderParts[0].mesh.sharedMaterial;
				Transform transform = component.RenderParts[0].mesh.transform.Find(NECK_JONT);
				Vector3 vector = transform.TransformPoint(Vector3.up) - transform.position;
				sharedMaterial.SetFloat(MOUTH_SCALE_PROPERTY, vector.magnitude);
				sharedMaterial.SetFloat(VOICE_PROPERTY, Mathf.Min(vector.magnitude * MOUTH_MAX_GLOBAL, vector.magnitude * VoiceAmplitude * MOUTH_SCALE_GLOBAL));
				sharedMaterial.SetVector(MOUTH_POSITION_PROPERTY, transform.TransformPoint(MOUTH_POSITION_OFFSET));
				sharedMaterial.SetVector(MOUTH_DIRECTION_PROPERTY, transform.up);
			}
		}
	}

	private bool IsValidMic()
	{
		string[] devices = Microphone.devices;
		if (devices.Length < 1)
		{
			return false;
		}
		int num = 0;
		string deviceName = devices[num];
		Microphone.GetDeviceCaps(deviceName, out var _, out var maxFreq);
		if (maxFreq == 0)
		{
			maxFreq = 44100;
		}
		if (Microphone.Start(deviceName, loop: true, 1, maxFreq) == null)
		{
			return false;
		}
		Microphone.End(deviceName);
		return true;
	}

	private void InitPostLoad()
	{
		ExpressiveGlobalInit();
		ConfigureHelpers();
		if (GetComponent<OvrAvatarLocalDriver>() != null)
		{
			lipsyncContext.audioLoopback = false;
			if (CanOwnMicrophone && IsValidMic())
			{
				micInput = MouthAnchor.gameObject.AddComponent<OVRLipSyncMicInput>();
				micInput.enableMicSelectionGUI = false;
				micInput.MicFrequency = 44100f;
				micInput.micControl = OVRLipSyncMicInput.micActivation.ConstantSpeak;
			}
			Oculus.Avatar.CAPI.ovrAvatar_SetActionUnitOnsetSpeed(sdkAvatar, 30f);
			Oculus.Avatar.CAPI.ovrAvatar_SetActionUnitFalloffSpeed(sdkAvatar, 20f);
			Oculus.Avatar.CAPI.ovrAvatar_SetVisemeMultiplier(sdkAvatar, 1.5f);
		}
	}

	private static void ExpressiveGlobalInit()
	{
		if (!doneExpressiveGlobalInit)
		{
			doneExpressiveGlobalInit = true;
			ovrLights.lights = new ovrAvatarLight[16];
			InitializeLights();
		}
	}

	private static void InitializeLights()
	{
		ovrLights.ambientIntensity = RenderSettings.ambientLight.grayscale * 0.5f;
		Light[] array = UnityEngine.Object.FindObjectsOfType(typeof(Light)) as Light[];
		int num = 0;
		for (num = 0; num < array.Length && num < ovrLights.lights.Length; num++)
		{
			Light light = array[num];
			if ((bool)light && light.enabled)
			{
				uint instanceID = (uint)light.transform.GetInstanceID();
				switch (light.type)
				{
				case LightType.Directional:
					CreateLightDirectional(instanceID, light.transform.forward, light.intensity, ref ovrLights.lights[num]);
					break;
				case LightType.Point:
					CreateLightPoint(instanceID, light.transform.position, light.range, light.intensity, ref ovrLights.lights[num]);
					break;
				case LightType.Spot:
					CreateLightSpot(instanceID, light.transform.position, light.transform.forward, light.spotAngle, light.range, light.intensity, ref ovrLights.lights[num]);
					break;
				}
			}
		}
		ovrLights.lightCount = (uint)num;
		Oculus.Avatar.CAPI.ovrAvatar_UpdateLights(ovrLights);
	}

	private static ovrAvatarLight CreateLightDirectional(uint id, Vector3 direction, float intensity, ref ovrAvatarLight light)
	{
		light.id = id;
		light.type = ovrAvatarLightType.Direction;
		light.worldDirection = new Vector3(direction.x, direction.y, 0f - direction.z);
		light.intensity = intensity;
		return light;
	}

	private static ovrAvatarLight CreateLightPoint(uint id, Vector3 position, float range, float intensity, ref ovrAvatarLight light)
	{
		light.id = id;
		light.type = ovrAvatarLightType.Point;
		light.worldPosition = new Vector3(position.x, position.y, 0f - position.z);
		light.range = range;
		light.intensity = intensity;
		return light;
	}

	private static ovrAvatarLight CreateLightSpot(uint id, Vector3 position, Vector3 direction, float spotAngleDeg, float range, float intensity, ref ovrAvatarLight light)
	{
		light.id = id;
		light.type = ovrAvatarLightType.Spot;
		light.worldPosition = new Vector3(position.x, position.y, 0f - position.z);
		light.worldDirection = new Vector3(direction.x, direction.y, 0f - direction.z);
		light.spotAngleDeg = spotAngleDeg;
		light.range = range;
		light.intensity = intensity;
		return light;
	}

	private void UpdateExpressive()
	{
		ovrAvatarTransform ovrAvatarTransform2 = CreateOvrAvatarTransform(base.transform.position, base.transform.rotation);
		Oculus.Avatar.CAPI.ovrAvatar_UpdateWorldTransform(sdkAvatar, ovrAvatarTransform2);
		UpdateFacewave();
	}

	private void ConfigureHelpers()
	{
		Transform transform = base.transform.Find("body/body_renderPart_0/root_JNT/body_JNT/chest_JNT/neckBase_JNT/neck_JNT/head_JNT");
		if (transform == null)
		{
			transform = base.transform;
		}
		if (MouthAnchor == null)
		{
			MouthAnchor = CreateHelperObject(transform, MOUTH_HEAD_OFFSET, "MouthAnchor");
		}
		if (GetComponent<OvrAvatarLocalDriver>() != null)
		{
			if (audioSource == null)
			{
				audioSource = MouthAnchor.gameObject.AddComponent<AudioSource>();
			}
			spatializedSource = MouthAnchor.GetComponent<ONSPAudioSource>();
			if (spatializedSource == null)
			{
				spatializedSource = MouthAnchor.gameObject.AddComponent<ONSPAudioSource>();
			}
			spatializedSource.UseInvSqr = true;
			spatializedSource.EnableRfl = false;
			spatializedSource.EnableSpatialization = true;
			spatializedSource.Far = 100f;
			spatializedSource.Near = 0.1f;
			lipsyncContext = MouthAnchor.GetComponent<OVRLipSyncContext>();
			if (lipsyncContext == null)
			{
				lipsyncContext = MouthAnchor.gameObject.AddComponent<OVRLipSyncContext>();
			}
			lipsyncContext.provider = ((!EnableLaughter) ? OVRLipSync.ContextProviders.Enhanced : OVRLipSync.ContextProviders.Enhanced_with_Laughter);
			lipsyncContext.skipAudioSource = !CanOwnMicrophone;
			StartCoroutine(WaitForMouthAudioSource());
		}
		if (GetComponent<OvrAvatarRemoteDriver>() != null)
		{
			transform.gameObject.AddComponent<GazeTarget>().Type = ovrAvatarGazeTargetType.AvatarHead;
			Transform transform2 = base.transform.Find("hand_left");
			if (!(transform2 == null))
			{
				transform2.gameObject.AddComponent<GazeTarget>().Type = ovrAvatarGazeTargetType.AvatarHand;
			}
			transform2 = base.transform.Find("hand_right");
			if (!(transform2 == null))
			{
				transform2.gameObject.AddComponent<GazeTarget>().Type = ovrAvatarGazeTargetType.AvatarHand;
			}
		}
	}

	private IEnumerator WaitForMouthAudioSource()
	{
		while (MouthAnchor.GetComponent<AudioSource>() == null)
		{
			yield return new WaitForSeconds(0.1f);
		}
		AudioSource component = MouthAnchor.GetComponent<AudioSource>();
		component.minDistance = 0.3f;
		component.maxDistance = 4f;
		component.rolloffMode = AudioRolloffMode.Logarithmic;
		component.loop = true;
		component.playOnAwake = true;
		component.spatialBlend = 1f;
		component.spatialize = true;
		component.spatializePostEffects = true;
	}

	public void DestroyHelperObjects()
	{
		if ((bool)MouthAnchor)
		{
			UnityEngine.Object.DestroyImmediate(MouthAnchor.gameObject);
		}
	}

	public GameObject CreateHelperObject(Transform parent, Vector3 localPositionOffset, string helperName, string helperTag = "")
	{
		GameObject gameObject = new GameObject();
		gameObject.name = helperName;
		if (helperTag != "")
		{
			gameObject.tag = helperTag;
		}
		gameObject.transform.SetParent(parent);
		gameObject.transform.localRotation = Quaternion.identity;
		gameObject.transform.localPosition = localPositionOffset;
		return gameObject;
	}

	public void UpdateVoiceData(short[] pcmData, int numChannels)
	{
		if (lipsyncContext != null && micInput == null)
		{
			lipsyncContext.ProcessAudioSamplesRaw(pcmData, numChannels);
		}
	}

	public void UpdateVoiceData(float[] pcmData, int numChannels)
	{
		if (lipsyncContext != null && micInput == null)
		{
			lipsyncContext.ProcessAudioSamplesRaw(pcmData, numChannels);
		}
	}

	private void UpdateFacewave()
	{
		if (!(lipsyncContext != null) || (!(micInput != null) && CanOwnMicrophone))
		{
			return;
		}
		currentFrame = lipsyncContext.GetCurrentPhonemeFrame();
		if (currentFrame.Visemes.Length != 15)
		{
			UnityEngine.Debug.LogError("Unexpected number of visemes " + currentFrame.Visemes);
			return;
		}
		currentFrame.Visemes.CopyTo(visemes, 0);
		visemes[15] = (EnableLaughter ? currentFrame.laughterScore : 0f);
		for (int i = 0; i < 16; i++)
		{
			RuntimeVisemes.visemeParams[i] = visemes[i];
		}
		Oculus.Avatar.CAPI.ovrAvatar_SetVisemes(sdkAvatar, RuntimeVisemes);
	}
}
public class OvrAvatarAsset
{
	public ulong assetID;
}
public class OvrAvatarAssetMesh : OvrAvatarAsset
{
	public Mesh mesh;

	private ovrAvatarSkinnedMeshPose skinnedBindPose;

	public string[] jointNames;

	public OvrAvatarAssetMesh(ulong _assetId, IntPtr asset, ovrAvatarAssetType meshType)
	{
		assetID = _assetId;
		mesh = new Mesh();
		mesh.name = "Procedural Geometry for asset " + _assetId;
		SetSkinnedBindPose(asset, meshType);
		long vertexCount = 0L;
		IntPtr vertexBuffer = IntPtr.Zero;
		uint indexCount = 0u;
		IntPtr indexBuffer = IntPtr.Zero;
		GetVertexAndIndexData(asset, meshType, out vertexCount, out vertexBuffer, out indexCount, out indexBuffer);
		Vector3[] array = new Vector3[vertexCount];
		Vector3[] array2 = new Vector3[vertexCount];
		Vector4[] array3 = new Vector4[vertexCount];
		Vector2[] array4 = new Vector2[vertexCount];
		Color[] array5 = new Color[vertexCount];
		BoneWeight[] array6 = new BoneWeight[vertexCount];
		long num = vertexBuffer.ToInt64();
		switch (meshType)
		{
		case ovrAvatarAssetType.Mesh:
		{
			long num5 = Marshal.SizeOf(typeof(ovrAvatarMeshVertex));
			for (long num6 = 0L; num6 < vertexCount; num6++)
			{
				long num7 = num5 * num6;
				ovrAvatarMeshVertex ovrAvatarMeshVertex2 = (ovrAvatarMeshVertex)Marshal.PtrToStructure(new IntPtr(num + num7), typeof(ovrAvatarMeshVertex));
				array[num6] = new Vector3(ovrAvatarMeshVertex2.x, ovrAvatarMeshVertex2.y, 0f - ovrAvatarMeshVertex2.z);
				array2[num6] = new Vector3(ovrAvatarMeshVertex2.nx, ovrAvatarMeshVertex2.ny, 0f - ovrAvatarMeshVertex2.nz);
				array3[num6] = new Vector4(ovrAvatarMeshVertex2.tx, ovrAvatarMeshVertex2.ty, 0f - ovrAvatarMeshVertex2.tz, ovrAvatarMeshVertex2.tw);
				array4[num6] = new Vector2(ovrAvatarMeshVertex2.u, ovrAvatarMeshVertex2.v);
				array5[num6] = new Color(0f, 0f, 0f, 1f);
				array6[num6].boneIndex0 = ovrAvatarMeshVertex2.blendIndices[0];
				array6[num6].boneIndex1 = ovrAvatarMeshVertex2.blendIndices[1];
				array6[num6].boneIndex2 = ovrAvatarMeshVertex2.blendIndices[2];
				array6[num6].boneIndex3 = ovrAvatarMeshVertex2.blendIndices[3];
				array6[num6].weight0 = ovrAvatarMeshVertex2.blendWeights[0];
				array6[num6].weight1 = ovrAvatarMeshVertex2.blendWeights[1];
				array6[num6].weight2 = ovrAvatarMeshVertex2.blendWeights[2];
				array6[num6].weight3 = ovrAvatarMeshVertex2.blendWeights[3];
			}
			break;
		}
		case ovrAvatarAssetType.CombinedMesh:
		{
			long num2 = Marshal.SizeOf(typeof(ovrAvatarMeshVertexV2));
			for (long num3 = 0L; num3 < vertexCount; num3++)
			{
				long num4 = num2 * num3;
				ovrAvatarMeshVertexV2 ovrAvatarMeshVertexV3 = (ovrAvatarMeshVertexV2)Marshal.PtrToStructure(new IntPtr(num + num4), typeof(ovrAvatarMeshVertexV2));
				array[num3] = new Vector3(ovrAvatarMeshVertexV3.x, ovrAvatarMeshVertexV3.y, 0f - ovrAvatarMeshVertexV3.z);
				array2[num3] = new Vector3(ovrAvatarMeshVertexV3.nx, ovrAvatarMeshVertexV3.ny, 0f - ovrAvatarMeshVertexV3.nz);
				array3[num3] = new Vector4(ovrAvatarMeshVertexV3.tx, ovrAvatarMeshVertexV3.ty, 0f - ovrAvatarMeshVertexV3.tz, ovrAvatarMeshVertexV3.tw);
				array4[num3] = new Vector2(ovrAvatarMeshVertexV3.u, ovrAvatarMeshVertexV3.v);
				array5[num3] = new Color(ovrAvatarMeshVertexV3.r, ovrAvatarMeshVertexV3.g, ovrAvatarMeshVertexV3.b, ovrAvatarMeshVertexV3.a);
				array6[num3].boneIndex0 = ovrAvatarMeshVertexV3.blendIndices[0];
				array6[num3].boneIndex1 = ovrAvatarMeshVertexV3.blendIndices[1];
				array6[num3].boneIndex2 = ovrAvatarMeshVertexV3.blendIndices[2];
				array6[num3].boneIndex3 = ovrAvatarMeshVertexV3.blendIndices[3];
				array6[num3].weight0 = ovrAvatarMeshVertexV3.blendWeights[0];
				array6[num3].weight1 = ovrAvatarMeshVertexV3.blendWeights[1];
				array6[num3].weight2 = ovrAvatarMeshVertexV3.blendWeights[2];
				array6[num3].weight3 = ovrAvatarMeshVertexV3.blendWeights[3];
			}
			break;
		}
		default:
			throw new Exception("Bad Mesh Asset Type");
		}
		mesh.vertices = array;
		mesh.normals = array2;
		mesh.uv = array4;
		mesh.tangents = array3;
		mesh.boneWeights = array6;
		mesh.colors = array5;
		LoadBlendShapes(asset, vertexCount);
		LoadSubmeshes(asset, indexBuffer, indexCount);
		uint jointCount = skinnedBindPose.jointCount;
		jointNames = new string[jointCount];
		for (uint num8 = 0u; num8 < jointCount; num8++)
		{
			jointNames[num8] = Marshal.PtrToStringAnsi(skinnedBindPose.jointNames[num8]);
		}
	}

	private void LoadSubmeshes(IntPtr asset, IntPtr indexBufferPtr, ulong indexCount)
	{
		uint num = Oculus.Avatar.CAPI.ovrAvatarAsset_GetSubmeshCount(asset);
		short[] array = new short[indexCount];
		Marshal.Copy(indexBufferPtr, array, 0, (int)indexCount);
		mesh.subMeshCount = (int)num;
		uint num2 = 0u;
		for (uint num3 = 0u; num3 < num; num3++)
		{
			uint num4 = Oculus.Avatar.CAPI.ovrAvatarAsset_GetSubmeshLastIndex(asset, num3);
			uint num5 = num4 - num2;
			int[] array2 = new int[num5];
			int num6 = 0;
			for (ulong num7 = num2; num7 < num4; num7 += 3)
			{
				array2[num6 + 2] = array[num7];
				array2[num6 + 1] = array[num7 + 1];
				array2[num6] = array[num7 + 2];
				num6 += 3;
			}
			num2 += num5;
			mesh.SetIndices(array2, MeshTopology.Triangles, (int)num3);
		}
	}

	private void LoadBlendShapes(IntPtr asset, long vertexCount)
	{
		uint num = Oculus.Avatar.CAPI.ovrAvatarAsset_GetMeshBlendShapeCount(asset);
		IntPtr intPtr = Oculus.Avatar.CAPI.ovrAvatarAsset_GetMeshBlendShapeVertices(asset);
		if (!(intPtr != IntPtr.Zero))
		{
			return;
		}
		long num2 = 0L;
		long num3 = Marshal.SizeOf(typeof(ovrAvatarBlendVertex));
		long num4 = intPtr.ToInt64();
		for (uint num5 = 0u; num5 < num; num5++)
		{
			Vector3[] array = new Vector3[vertexCount];
			Vector3[] array2 = new Vector3[vertexCount];
			Vector3[] array3 = new Vector3[vertexCount];
			for (long num6 = 0L; num6 < vertexCount; num6++)
			{
				ovrAvatarBlendVertex ovrAvatarBlendVertex2 = (ovrAvatarBlendVertex)Marshal.PtrToStructure(new IntPtr(num4 + num2), typeof(ovrAvatarBlendVertex));
				array[num6] = new Vector3(ovrAvatarBlendVertex2.x, ovrAvatarBlendVertex2.y, 0f - ovrAvatarBlendVertex2.z);
				array2[num6] = new Vector3(ovrAvatarBlendVertex2.nx, ovrAvatarBlendVertex2.ny, 0f - ovrAvatarBlendVertex2.nz);
				array3[num6] = new Vector4(ovrAvatarBlendVertex2.tx, ovrAvatarBlendVertex2.ty, 0f - ovrAvatarBlendVertex2.tz);
				num2 += num3;
			}
			string shapeName = Marshal.PtrToStringAnsi(Oculus.Avatar.CAPI.ovrAvatarAsset_GetMeshBlendShapeName(asset, num5));
			mesh.AddBlendShapeFrame(shapeName, 100f, array, array2, array3);
		}
	}

	private void SetSkinnedBindPose(IntPtr asset, ovrAvatarAssetType meshType)
	{
		switch (meshType)
		{
		case ovrAvatarAssetType.Mesh:
			skinnedBindPose = Oculus.Avatar.CAPI.ovrAvatarAsset_GetMeshData(asset).skinnedBindPose;
			break;
		case ovrAvatarAssetType.CombinedMesh:
			skinnedBindPose = Oculus.Avatar.CAPI.ovrAvatarAsset_GetCombinedMeshData(asset).skinnedBindPose;
			break;
		}
	}

	private void GetVertexAndIndexData(IntPtr asset, ovrAvatarAssetType meshType, out long vertexCount, out IntPtr vertexBuffer, out uint indexCount, out IntPtr indexBuffer)
	{
		vertexCount = 0L;
		vertexBuffer = IntPtr.Zero;
		indexCount = 0u;
		indexBuffer = IntPtr.Zero;
		switch (meshType)
		{
		case ovrAvatarAssetType.Mesh:
			vertexCount = Oculus.Avatar.CAPI.ovrAvatarAsset_GetMeshData(asset).vertexCount;
			vertexBuffer = Oculus.Avatar.CAPI.ovrAvatarAsset_GetMeshData(asset).vertexBuffer;
			indexCount = Oculus.Avatar.CAPI.ovrAvatarAsset_GetMeshData(asset).indexCount;
			indexBuffer = Oculus.Avatar.CAPI.ovrAvatarAsset_GetMeshData(asset).indexBuffer;
			break;
		case ovrAvatarAssetType.CombinedMesh:
			vertexCount = Oculus.Avatar.CAPI.ovrAvatarAsset_GetCombinedMeshData(asset).vertexCount;
			vertexBuffer = Oculus.Avatar.CAPI.ovrAvatarAsset_GetCombinedMeshData(asset).vertexBuffer;
			indexCount = Oculus.Avatar.CAPI.ovrAvatarAsset_GetCombinedMeshData(asset).indexCount;
			indexBuffer = Oculus.Avatar.CAPI.ovrAvatarAsset_GetCombinedMeshData(asset).indexBuffer;
			break;
		}
	}

	public SkinnedMeshRenderer CreateSkinnedMeshRendererOnObject(GameObject target)
	{
		SkinnedMeshRenderer skinnedMeshRenderer = target.AddComponent<SkinnedMeshRenderer>();
		skinnedMeshRenderer.sharedMesh = mesh;
		mesh.name = "AvatarMesh_" + assetID;
		uint jointCount = skinnedBindPose.jointCount;
		GameObject[] array = new GameObject[jointCount];
		Transform[] array2 = new Transform[jointCount];
		Matrix4x4[] array3 = new Matrix4x4[jointCount];
		for (uint num = 0u; num < jointCount; num++)
		{
			array[num] = new GameObject();
			array2[num] = array[num].transform;
			array[num].name = jointNames[num];
			int num2 = skinnedBindPose.jointParents[num];
			if (num2 == -1)
			{
				array[num].transform.parent = skinnedMeshRenderer.transform;
				skinnedMeshRenderer.rootBone = array[num].transform;
			}
			else
			{
				array[num].transform.parent = array[num2].transform;
			}
			Vector3 position = skinnedBindPose.jointTransform[num].position;
			position.z = 0f - position.z;
			array[num].transform.localPosition = position;
			Quaternion orientation = skinnedBindPose.jointTransform[num].orientation;
			orientation.x = 0f - orientation.x;
			orientation.y = 0f - orientation.y;
			array[num].transform.localRotation = orientation;
			array[num].transform.localScale = skinnedBindPose.jointTransform[num].scale;
			array3[num] = array[num].transform.worldToLocalMatrix * skinnedMeshRenderer.transform.localToWorldMatrix;
		}
		skinnedMeshRenderer.bones = array2;
		mesh.bindposes = array3;
		return skinnedMeshRenderer;
	}
}
public class OvrAvatarAssetTexture : OvrAvatarAsset
{
	public Texture2D texture;

	private const int ASTCHeaderSize = 16;

	public OvrAvatarAssetTexture(ulong _assetId, IntPtr asset)
	{
		assetID = _assetId;
		ovrAvatarTextureAssetData ovrAvatarTextureAssetData2 = Oculus.Avatar.CAPI.ovrAvatarAsset_GetTextureData(asset);
		IntPtr data = ovrAvatarTextureAssetData2.textureData;
		int num = (int)ovrAvatarTextureAssetData2.textureDataSize;
		TextureFormat textureFormat;
		switch (ovrAvatarTextureAssetData2.format)
		{
		case ovrAvatarTextureFormat.RGB24:
			textureFormat = TextureFormat.RGB24;
			break;
		case ovrAvatarTextureFormat.DXT1:
			textureFormat = TextureFormat.DXT1;
			break;
		case ovrAvatarTextureFormat.DXT5:
			textureFormat = TextureFormat.DXT5;
			break;
		case ovrAvatarTextureFormat.ASTC_RGB_6x6:
			textureFormat = TextureFormat.ASTC_RGB_6x6;
			data = new IntPtr(data.ToInt64() + 16);
			num -= 16;
			break;
		case ovrAvatarTextureFormat.ASTC_RGB_6x6_MIPMAPS:
			textureFormat = TextureFormat.ASTC_RGB_6x6;
			break;
		default:
			throw new NotImplementedException($"Unsupported texture format {ovrAvatarTextureAssetData2.format.ToString()}");
		}
		texture = new Texture2D((int)ovrAvatarTextureAssetData2.sizeX, (int)ovrAvatarTextureAssetData2.sizeY, textureFormat, ovrAvatarTextureAssetData2.mipCount > 1, (QualitySettings.activeColorSpace != 0) ? true : false)
		{
			filterMode = FilterMode.Trilinear,
			anisoLevel = 4
		};
		texture.LoadRawTextureData(data, num);
		texture.Apply(updateMipmaps: true, makeNoLongerReadable: false);
	}
}
public class OvrAvatarBase : OvrAvatarComponent
{
	private ovrAvatarBaseComponent component;

	private void Update()
	{
		if (!(owner == null))
		{
			if (Oculus.Avatar.CAPI.ovrAvatarPose_GetBaseComponent(owner.sdkAvatar, ref component))
			{
				UpdateAvatar(component.renderComponent);
				return;
			}
			owner.Base = null;
			UnityEngine.Object.Destroy(this);
		}
	}
}
public class OvrAvatarBody : OvrAvatarComponent
{
	public ovrAvatarBodyComponent component;

	public ovrAvatarComponent? GetNativeAvatarComponent()
	{
		if (owner == null)
		{
			return null;
		}
		if (Oculus.Avatar.CAPI.ovrAvatarPose_GetBodyComponent(owner.sdkAvatar, ref component))
		{
			Oculus.Avatar.CAPI.ovrAvatarComponent_Get(component.renderComponent, includeName: true, ref nativeAvatarComponent);
			return nativeAvatarComponent;
		}
		return null;
	}

	private void Update()
	{
		if (!(owner == null))
		{
			if (Oculus.Avatar.CAPI.ovrAvatarPose_GetBodyComponent(owner.sdkAvatar, ref component))
			{
				UpdateAvatar(component.renderComponent);
				return;
			}
			owner.Body = null;
			UnityEngine.Object.Destroy(this);
		}
	}
}
public class OvrAvatarComponent : MonoBehaviour
{
	public static readonly string[] LayerKeywords = new string[9] { "LAYERS_0", "LAYERS_1", "LAYERS_2", "LAYERS_3", "LAYERS_4", "LAYERS_5", "LAYERS_6", "LAYERS_7", "LAYERS_8" };

	public static readonly string[] LayerSampleModeParameters = new string[8] { "_LayerSampleMode0", "_LayerSampleMode1", "_LayerSampleMode2", "_LayerSampleMode3", "_LayerSampleMode4", "_LayerSampleMode5", "_LayerSampleMode6", "_LayerSampleMode7" };

	public static readonly string[] LayerBlendModeParameters = new string[8] { "_LayerBlendMode0", "_LayerBlendMode1", "_LayerBlendMode2", "_LayerBlendMode3", "_LayerBlendMode4", "_LayerBlendMode5", "_LayerBlendMode6", "_LayerBlendMode7" };

	public static readonly string[] LayerMaskTypeParameters = new string[8] { "_LayerMaskType0", "_LayerMaskType1", "_LayerMaskType2", "_LayerMaskType3", "_LayerMaskType4", "_LayerMaskType5", "_LayerMaskType6", "_LayerMaskType7" };

	public static readonly string[] LayerColorParameters = new string[8] { "_LayerColor0", "_LayerColor1", "_LayerColor2", "_LayerColor3", "_LayerColor4", "_LayerColor5", "_LayerColor6", "_LayerColor7" };

	public static readonly string[] LayerSurfaceParameters = new string[8] { "_LayerSurface0", "_LayerSurface1", "_LayerSurface2", "_LayerSurface3", "_LayerSurface4", "_LayerSurface5", "_LayerSurface6", "_LayerSurface7" };

	public static readonly string[] LayerSampleParametersParameters = new string[8] { "_LayerSampleParameters0", "_LayerSampleParameters1", "_LayerSampleParameters2", "_LayerSampleParameters3", "_LayerSampleParameters4", "_LayerSampleParameters5", "_LayerSampleParameters6", "_LayerSampleParameters7" };

	public static readonly string[] LayerMaskParametersParameters = new string[8] { "_LayerMaskParameters0", "_LayerMaskParameters1", "_LayerMaskParameters2", "_LayerMaskParameters3", "_LayerMaskParameters4", "_LayerMaskParameters5", "_LayerMaskParameters6", "_LayerMaskParameters7" };

	public static readonly string[] LayerMaskAxisParameters = new string[8] { "_LayerMaskAxis0", "_LayerMaskAxis1", "_LayerMaskAxis2", "_LayerMaskAxis3", "_LayerMaskAxis4", "_LayerMaskAxis5", "_LayerMaskAxis6", "_LayerMaskAxis7" };

	private Dictionary<Material, ovrAvatarMaterialState> materialStates = new Dictionary<Material, ovrAvatarMaterialState>();

	public List<OvrAvatarRenderComponent> RenderParts = new List<OvrAvatarRenderComponent>();

	protected OvrAvatar owner;

	protected ovrAvatarComponent nativeAvatarComponent;

	public void SetOvrAvatarOwner(OvrAvatar ovrAvatarOwner)
	{
		owner = ovrAvatarOwner;
	}

	public void UpdateAvatar(IntPtr nativeComponent)
	{
		Oculus.Avatar.CAPI.ovrAvatarComponent_Get(nativeComponent, includeName: false, ref nativeAvatarComponent);
		OvrAvatar.ConvertTransform(nativeAvatarComponent.transform, base.transform);
		for (uint num = 0u; num < nativeAvatarComponent.renderPartCount && RenderParts.Count > num; num++)
		{
			OvrAvatarRenderComponent ovrAvatarRenderComponent = RenderParts[(int)num];
			IntPtr renderPart = OvrAvatar.GetRenderPart(nativeAvatarComponent, num);
			switch (Oculus.Avatar.CAPI.ovrAvatarRenderPart_GetType(renderPart))
			{
			case ovrAvatarRenderPartType.SkinnedMeshRender:
				((OvrAvatarSkinnedMeshRenderComponent)ovrAvatarRenderComponent).UpdateSkinnedMeshRender(this, owner, renderPart);
				break;
			case ovrAvatarRenderPartType.SkinnedMeshRenderPBS:
				((OvrAvatarSkinnedMeshRenderPBSComponent)ovrAvatarRenderComponent).UpdateSkinnedMeshRenderPBS(owner, renderPart, ovrAvatarRenderComponent.mesh.sharedMaterial);
				break;
			case ovrAvatarRenderPartType.SkinnedMeshRenderPBS_V2:
				((OvrAvatarSkinnedMeshPBSV2RenderComponent)ovrAvatarRenderComponent).UpdateSkinnedMeshRender(this, owner, renderPart);
				break;
			}
		}
	}

	protected void UpdateActive(OvrAvatar avatar, ovrAvatarVisibilityFlags mask)
	{
		bool flag = avatar.ShowFirstPerson && (mask & ovrAvatarVisibilityFlags.FirstPerson) != 0;
		flag |= avatar.ShowThirdPerson && (mask & ovrAvatarVisibilityFlags.ThirdPerson) != 0;
		base.gameObject.SetActive(flag);
	}

	public void UpdateAvatarMaterial(Material mat, ovrAvatarMaterialState matState)
	{
		mat.SetColor("_BaseColor", matState.baseColor);
		mat.SetInt("_BaseMaskType", (int)matState.baseMaskType);
		mat.SetVector("_BaseMaskParameters", matState.baseMaskParameters);
		mat.SetVector("_BaseMaskAxis", matState.baseMaskAxis);
		if (matState.alphaMaskTextureID != 0L)
		{
			mat.SetTexture("_AlphaMask", GetLoadedTexture(matState.alphaMaskTextureID));
			mat.SetTextureScale("_AlphaMask", new Vector2(matState.alphaMaskScaleOffset.x, matState.alphaMaskScaleOffset.y));
			mat.SetTextureOffset("_AlphaMask", new Vector2(matState.alphaMaskScaleOffset.z, matState.alphaMaskScaleOffset.w));
		}
		if (matState.normalMapTextureID != 0L)
		{
			mat.EnableKeyword("NORMAL_MAP_ON");
			mat.SetTexture("_NormalMap", GetLoadedTexture(matState.normalMapTextureID));
			mat.SetTextureScale("_NormalMap", new Vector2(matState.normalMapScaleOffset.x, matState.normalMapScaleOffset.y));
			mat.SetTextureOffset("_NormalMap", new Vector2(matState.normalMapScaleOffset.z, matState.normalMapScaleOffset.w));
		}
		if (matState.parallaxMapTextureID != 0L)
		{
			mat.SetTexture("_ParallaxMap", GetLoadedTexture(matState.parallaxMapTextureID));
			mat.SetTextureScale("_ParallaxMap", new Vector2(matState.parallaxMapScaleOffset.x, matState.parallaxMapScaleOffset.y));
			mat.SetTextureOffset("_ParallaxMap", new Vector2(matState.parallaxMapScaleOffset.z, matState.parallaxMapScaleOffset.w));
		}
		if (matState.roughnessMapTextureID != 0L)
		{
			mat.EnableKeyword("ROUGHNESS_ON");
			mat.SetTexture("_RoughnessMap", GetLoadedTexture(matState.roughnessMapTextureID));
			mat.SetTextureScale("_RoughnessMap", new Vector2(matState.roughnessMapScaleOffset.x, matState.roughnessMapScaleOffset.y));
			mat.SetTextureOffset("_RoughnessMap", new Vector2(matState.roughnessMapScaleOffset.z, matState.roughnessMapScaleOffset.w));
		}
		mat.EnableKeyword(LayerKeywords[matState.layerCount]);
		for (ulong num = 0uL; num < matState.layerCount; num++)
		{
			ovrAvatarMaterialLayerState ovrAvatarMaterialLayerState2 = matState.layers[num];
			mat.SetInt(LayerSampleModeParameters[num], (int)ovrAvatarMaterialLayerState2.sampleMode);
			mat.SetInt(LayerBlendModeParameters[num], (int)ovrAvatarMaterialLayerState2.blendMode);
			mat.SetInt(LayerMaskTypeParameters[num], (int)ovrAvatarMaterialLayerState2.maskType);
			mat.SetColor(LayerColorParameters[num], ovrAvatarMaterialLayerState2.layerColor);
			if (ovrAvatarMaterialLayerState2.sampleMode != 0)
			{
				string text = LayerSurfaceParameters[num];
				mat.SetTexture(text, GetLoadedTexture(ovrAvatarMaterialLayerState2.sampleTexture));
				mat.SetTextureScale(text, new Vector2(ovrAvatarMaterialLayerState2.sampleScaleOffset.x, ovrAvatarMaterialLayerState2.sampleScaleOffset.y));
				mat.SetTextureOffset(text, new Vector2(ovrAvatarMaterialLayerState2.sampleScaleOffset.z, ovrAvatarMaterialLayerState2.sampleScaleOffset.w));
			}
			if (ovrAvatarMaterialLayerState2.sampleMode == ovrAvatarMaterialLayerSampleMode.Parallax)
			{
				mat.EnableKeyword("PARALLAX_ON");
			}
			mat.SetColor(LayerSampleParametersParameters[num], ovrAvatarMaterialLayerState2.sampleParameters);
			mat.SetColor(LayerMaskParametersParameters[num], ovrAvatarMaterialLayerState2.maskParameters);
			mat.SetColor(LayerMaskAxisParameters[num], ovrAvatarMaterialLayerState2.maskAxis);
		}
		materialStates[mat] = matState;
	}

	public static Texture2D GetLoadedTexture(ulong assetId)
	{
		return ((OvrAvatarAssetTexture)OvrAvatarSDKManager.Instance.GetAsset(assetId))?.texture;
	}
}
public abstract class OvrAvatarDriver : MonoBehaviour
{
	public enum PacketMode
	{
		SDK,
		Unity
	}

	public struct ControllerPose
	{
		public ovrAvatarButton buttons;

		public ovrAvatarTouch touches;

		public Vector2 joystickPosition;

		public float indexTrigger;

		public float handTrigger;

		public bool isActive;

		public static ControllerPose Interpolate(ControllerPose a, ControllerPose b, float t)
		{
			ControllerPose result = default(ControllerPose);
			result.buttons = ((t < 0.5f) ? a.buttons : b.buttons);
			result.touches = ((t < 0.5f) ? a.touches : b.touches);
			result.joystickPosition = Vector2.Lerp(a.joystickPosition, b.joystickPosition, t);
			result.indexTrigger = Mathf.Lerp(a.indexTrigger, b.indexTrigger, t);
			result.handTrigger = Mathf.Lerp(a.handTrigger, b.handTrigger, t);
			result.isActive = ((t < 0.5f) ? a.isActive : b.isActive);
			return result;
		}
	}

	public struct PoseFrame
	{
		public Vector3 headPosition;

		public Quaternion headRotation;

		public Vector3 handLeftPosition;

		public Quaternion handLeftRotation;

		public Vector3 handRightPosition;

		public Quaternion handRightRotation;

		public float voiceAmplitude;

		public ControllerPose controllerLeftPose;

		public ControllerPose controllerRightPose;

		public static PoseFrame Interpolate(PoseFrame a, PoseFrame b, float t)
		{
			PoseFrame result = default(PoseFrame);
			result.headPosition = Vector3.Lerp(a.headPosition, b.headPosition, t);
			result.headRotation = Quaternion.Slerp(a.headRotation, b.headRotation, t);
			result.handLeftPosition = Vector3.Lerp(a.handLeftPosition, b.handLeftPosition, t);
			result.handLeftRotation = Quaternion.Slerp(a.handLeftRotation, b.handLeftRotation, t);
			result.handRightPosition = Vector3.Lerp(a.handRightPosition, b.handRightPosition, t);
			result.handRightRotation = Quaternion.Slerp(a.handRightRotation, b.handRightRotation, t);
			result.voiceAmplitude = Mathf.Lerp(a.voiceAmplitude, b.voiceAmplitude, t);
			result.controllerLeftPose = ControllerPose.Interpolate(a.controllerLeftPose, b.controllerLeftPose, t);
			result.controllerRightPose = ControllerPose.Interpolate(a.controllerRightPose, b.controllerRightPose, t);
			return result;
		}
	}

	public PacketMode Mode;

	protected PoseFrame CurrentPose;

	private ovrAvatarControllerType ControllerType = ovrAvatarControllerType.Quest;

	public PoseFrame GetCurrentPose()
	{
		return CurrentPose;
	}

	public abstract void UpdateTransforms(IntPtr sdkAvatar);

	private void Start()
	{
		switch (OVRPlugin.GetSystemHeadsetType())
		{
		case OVRPlugin.SystemHeadset.GearVR_R320:
		case OVRPlugin.SystemHeadset.GearVR_R321:
		case OVRPlugin.SystemHeadset.GearVR_R322:
		case OVRPlugin.SystemHeadset.GearVR_R323:
		case OVRPlugin.SystemHeadset.GearVR_R324:
		case OVRPlugin.SystemHeadset.GearVR_R325:
			ControllerType = ovrAvatarControllerType.Malibu;
			break;
		case OVRPlugin.SystemHeadset.Oculus_Go:
			ControllerType = ovrAvatarControllerType.Go;
			break;
		case OVRPlugin.SystemHeadset.Oculus_Quest:
		case OVRPlugin.SystemHeadset.Rift_S:
			ControllerType = ovrAvatarControllerType.Quest;
			break;
		default:
			ControllerType = ovrAvatarControllerType.Touch;
			break;
		}
	}

	public void UpdateTransformsFromPose(IntPtr sdkAvatar)
	{
		if (sdkAvatar != IntPtr.Zero)
		{
			ovrAvatarTransform headPose = OvrAvatar.CreateOvrAvatarTransform(CurrentPose.headPosition, CurrentPose.headRotation);
			ovrAvatarHandInputState inputStateLeft = OvrAvatar.CreateInputState(OvrAvatar.CreateOvrAvatarTransform(CurrentPose.handLeftPosition, CurrentPose.handLeftRotation), CurrentPose.controllerLeftPose);
			ovrAvatarHandInputState inputStateRight = OvrAvatar.CreateInputState(OvrAvatar.CreateOvrAvatarTransform(CurrentPose.handRightPosition, CurrentPose.handRightRotation), CurrentPose.controllerRightPose);
			Oculus.Avatar.CAPI.ovrAvatarPose_UpdateBody(sdkAvatar, headPose);
			Oculus.Avatar.CAPI.ovrAvatarPose_UpdateHandsWithType(sdkAvatar, inputStateLeft, inputStateRight, ControllerType);
		}
	}

	public static bool GetIsTrackedRemote()
	{
		if (!OVRInput.IsControllerConnected(OVRInput.Controller.RTrackedRemote))
		{
			return OVRInput.IsControllerConnected(OVRInput.Controller.LTrackedRemote);
		}
		return true;
	}
}
public class OvrAvatarHand : OvrAvatarComponent
{
	public bool isLeftHand = true;

	private ovrAvatarHandComponent component;

	private void Update()
	{
		if (owner == null)
		{
			return;
		}
		bool flag = false;
		if ((!isLeftHand) ? Oculus.Avatar.CAPI.ovrAvatarPose_GetRightHandComponent(owner.sdkAvatar, ref component) : Oculus.Avatar.CAPI.ovrAvatarPose_GetLeftHandComponent(owner.sdkAvatar, ref component))
		{
			UpdateAvatar(component.renderComponent);
			return;
		}
		if (isLeftHand)
		{
			owner.HandLeft = null;
		}
		else
		{
			owner.HandRight = null;
		}
		UnityEngine.Object.Destroy(this);
	}
}
public class OvrAvatarLocalDriver : OvrAvatarDriver
{
	private Vector3 centerEyePosition = Vector3.zero;

	private Quaternion centerEyeRotation = Quaternion.identity;

	private float voiceAmplitude;

	private ControllerPose GetMalibuControllerPose(OVRInput.Controller controller)
	{
		ovrAvatarButton ovrAvatarButton2 = (ovrAvatarButton)0;
		if (OVRInput.Get(OVRInput.Button.PrimaryIndexTrigger, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.One;
		}
		ControllerPose result = default(ControllerPose);
		result.buttons = ovrAvatarButton2;
		result.touches = (OVRInput.Get(OVRInput.Touch.PrimaryTouchpad) ? ovrAvatarTouch.One : ((ovrAvatarTouch)0));
		result.joystickPosition = OVRInput.Get(OVRInput.Axis2D.PrimaryTouchpad, controller);
		result.indexTrigger = 0f;
		result.handTrigger = 0f;
		result.isActive = (OVRInput.GetActiveController() & controller) != 0;
		return result;
	}

	private ControllerPose GetControllerPose(OVRInput.Controller controller)
	{
		ovrAvatarButton ovrAvatarButton2 = (ovrAvatarButton)0;
		if (OVRInput.Get(OVRInput.Button.One, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.One;
		}
		if (OVRInput.Get(OVRInput.Button.Two, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.Two;
		}
		if (OVRInput.Get(OVRInput.Button.Start, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.Three;
		}
		if (OVRInput.Get(OVRInput.Button.PrimaryThumbstick, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.Joystick;
		}
		ovrAvatarTouch ovrAvatarTouch2 = (ovrAvatarTouch)0;
		if (OVRInput.Get(OVRInput.Touch.One, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.One;
		}
		if (OVRInput.Get(OVRInput.Touch.Two, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Two;
		}
		if (OVRInput.Get(OVRInput.Touch.PrimaryThumbstick, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Joystick;
		}
		if (OVRInput.Get(OVRInput.Touch.PrimaryThumbRest, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.ThumbRest;
		}
		if (OVRInput.Get(OVRInput.Touch.PrimaryIndexTrigger, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Index;
		}
		if (!OVRInput.Get(OVRInput.NearTouch.PrimaryIndexTrigger, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Pointing;
		}
		if (!OVRInput.Get(OVRInput.NearTouch.PrimaryThumbButtons, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.ThumbUp;
		}
		ControllerPose result = default(ControllerPose);
		result.buttons = ovrAvatarButton2;
		result.touches = ovrAvatarTouch2;
		result.joystickPosition = OVRInput.Get(OVRInput.Axis2D.PrimaryThumbstick, controller);
		result.indexTrigger = OVRInput.Get(OVRInput.Axis1D.PrimaryIndexTrigger, controller);
		result.handTrigger = OVRInput.Get(OVRInput.Axis1D.PrimaryHandTrigger, controller);
		result.isActive = (OVRInput.GetActiveController() & controller) != 0;
		return result;
	}

	private void CalculateCurrentPose()
	{
		OVRNodeStateProperties.GetNodeStatePropertyVector3(XRNode.CenterEye, NodeStatePropertyType.Position, OVRPlugin.Node.EyeCenter, OVRPlugin.Step.Render, out centerEyePosition);
		OVRNodeStateProperties.GetNodeStatePropertyQuaternion(XRNode.CenterEye, NodeStatePropertyType.Orientation, OVRPlugin.Node.EyeCenter, OVRPlugin.Step.Render, out centerEyeRotation);
		if (OvrAvatarDriver.GetIsTrackedRemote())
		{
			CurrentPose = new PoseFrame
			{
				voiceAmplitude = voiceAmplitude,
				headPosition = centerEyePosition,
				headRotation = centerEyeRotation,
				handLeftPosition = OVRInput.GetLocalControllerPosition(OVRInput.Controller.LTrackedRemote),
				handLeftRotation = OVRInput.GetLocalControllerRotation(OVRInput.Controller.LTrackedRemote),
				handRightPosition = OVRInput.GetLocalControllerPosition(OVRInput.Controller.RTrackedRemote),
				handRightRotation = OVRInput.GetLocalControllerRotation(OVRInput.Controller.RTrackedRemote),
				controllerLeftPose = GetMalibuControllerPose(OVRInput.Controller.LTrackedRemote),
				controllerRightPose = GetMalibuControllerPose(OVRInput.Controller.RTrackedRemote)
			};
		}
		else
		{
			CurrentPose = new PoseFrame
			{
				voiceAmplitude = voiceAmplitude,
				headPosition = centerEyePosition,
				headRotation = centerEyeRotation,
				handLeftPosition = OVRInput.GetLocalControllerPosition(OVRInput.Controller.LTouch),
				handLeftRotation = OVRInput.GetLocalControllerRotation(OVRInput.Controller.LTouch),
				handRightPosition = OVRInput.GetLocalControllerPosition(OVRInput.Controller.RTouch),
				handRightRotation = OVRInput.GetLocalControllerRotation(OVRInput.Controller.RTouch),
				controllerLeftPose = GetControllerPose(OVRInput.Controller.LTouch),
				controllerRightPose = GetControllerPose(OVRInput.Controller.RTouch)
			};
		}
	}

	public override void UpdateTransforms(IntPtr sdkAvatar)
	{
		CalculateCurrentPose();
		UpdateTransformsFromPose(sdkAvatar);
	}
}
public class OvrAvatarMaterialManager : MonoBehaviour
{
	public enum TextureType
	{
		DiffuseTextures,
		NormalMaps,
		RoughnessMaps,
		Count
	}

	public struct AvatarComponentMaterialProperties
	{
		public ovrAvatarBodyPartType TypeIndex;

		public Color Color;

		public Texture2D[] Textures;

		public float DiffuseIntensity;

		public float RimIntensity;

		public float ReflectionIntensity;
	}

	public struct AvatarTextureArrayProperties
	{
		public Texture2D[] Textures;

		public Texture2DArray TextureArray;
	}

	public struct AvatarMaterialPropertyBlock
	{
		public Vector4[] Colors;

		public float[] DiffuseIntensities;

		public float[] RimIntensities;

		public float[] ReflectionIntensities;
	}

	[Serializable]
	public class AvatarMaterialConfig
	{
		public AvatarComponentMaterialProperties[] ComponentMaterialProperties;

		public AvatarMaterialPropertyBlock MaterialPropertyBlock;
	}

	private Renderer TargetRenderer;

	private AvatarTextureArrayProperties[] TextureArrays;

	private readonly string[] TextureTypeToShaderProperties = new string[3] { "_MainTex", "_NormalMap", "_RoughnessMap" };

	public AvatarMaterialConfig LocalAvatarConfig = new AvatarMaterialConfig();

	public List<ReflectionProbeBlendInfo> ReflectionProbes = new List<ReflectionProbeBlendInfo>();

	private Shader CombinedShader;

	public static string AVATAR_SHADER_LOADER = "OvrAvatar/Avatar_Mobile_Loader";

	public static string AVATAR_SHADER_MAINTEX = "_MainTex";

	public static string AVATAR_SHADER_NORMALMAP = "_NormalMap";

	public static string AVATAR_SHADER_ROUGHNESSMAP = "_RoughnessMap";

	public static string AVATAR_SHADER_COLOR = "_BaseColor";

	public static string AVATAR_SHADER_DIFFUSEINTENSITY = "_DiffuseIntensity";

	public static string AVATAR_SHADER_RIMINTENSITY = "_RimIntensity";

	public static string AVATAR_SHADER_REFLECTIONINTENSITY = "_ReflectionIntensity";

	public static string AVATAR_SHADER_CUBEMAP = "_Cubemap";

	public static string AVATAR_SHADER_ALPHA = "_Alpha";

	public static string AVATAR_SHADER_LOADING_DIMMER = "_LoadingDimmer";

	public static string AVATAR_SHADER_IRIS_COLOR = "_MaskColorIris";

	public static string AVATAR_SHADER_LIP_COLOR = "_MaskColorLips";

	public static string AVATAR_SHADER_BROW_COLOR = "_MaskColorBrows";

	public static string AVATAR_SHADER_LASH_COLOR = "_MaskColorLashes";

	public static string AVATAR_SHADER_SCLERA_COLOR = "_MaskColorSclera";

	public static string AVATAR_SHADER_GUM_COLOR = "_MaskColorGums";

	public static string AVATAR_SHADER_TEETH_COLOR = "_MaskColorTeeth";

	public static string AVATAR_SHADER_LIP_SMOOTHNESS = "_LipSmoothness";

	public static float[] DiffuseIntensities = new float[5] { 0.3f, 0.1f, 0f, 0.15f, 0.15f };

	public static float[] RimIntensities = new float[5] { 5f, 2f, 2.84f, 4f, 4f };

	public static float[] ReflectionIntensities = new float[5] { 0f, 0.3f, 0.4f, 0f, 0f };

	private const float LOADING_ANIMATION_AMPLITUDE = 0.5f;

	private const float LOADING_ANIMATION_PERIOD = 0.35f;

	private const float LOADING_ANIMATION_CURVE_SCALE = 0.25f;

	private const float LOADING_ANIMATION_DIMMER_MIN = 0.3f;

	public void CreateTextureArrays()
	{
		LocalAvatarConfig.ComponentMaterialProperties = new AvatarComponentMaterialProperties[5];
		LocalAvatarConfig.MaterialPropertyBlock.Colors = new Vector4[5];
		LocalAvatarConfig.MaterialPropertyBlock.DiffuseIntensities = new float[5];
		LocalAvatarConfig.MaterialPropertyBlock.RimIntensities = new float[5];
		LocalAvatarConfig.MaterialPropertyBlock.ReflectionIntensities = new float[5];
		for (int i = 0; i < LocalAvatarConfig.ComponentMaterialProperties.Length; i++)
		{
			LocalAvatarConfig.ComponentMaterialProperties[i].Textures = new Texture2D[3];
		}
		TextureArrays = new AvatarTextureArrayProperties[3];
	}

	public void SetRenderer(Renderer renderer)
	{
		TargetRenderer = renderer;
		TargetRenderer.GetClosestReflectionProbes(ReflectionProbes);
	}

	public void OnCombinedMeshReady()
	{
		InitTextureArrays();
		SetMaterialPropertyBlock();
		StartCoroutine(RunLoadingAnimation(DeleteTextureSet));
	}

	public void AddTextureIDToTextureManager(ulong assetID, bool isSingleComponent)
	{
		OvrAvatarSDKManager.Instance.GetTextureCopyManager().AddTextureIDToTextureSet(GetInstanceID(), assetID, isSingleComponent);
	}

	private void DeleteTextureSet()
	{
		OvrAvatarSDKManager.Instance.GetTextureCopyManager().DeleteTextureSet(GetInstanceID());
	}

	public void InitTextureArrays()
	{
		AvatarComponentMaterialProperties avatarComponentMaterialProperties = LocalAvatarConfig.ComponentMaterialProperties[0];
		for (int i = 0; i < TextureArrays.Length && i < avatarComponentMaterialProperties.Textures.Length; i++)
		{
			TextureArrays[i].TextureArray = new Texture2DArray(avatarComponentMaterialProperties.Textures[0].height, avatarComponentMaterialProperties.Textures[0].width, LocalAvatarConfig.ComponentMaterialProperties.Length, avatarComponentMaterialProperties.Textures[0].format, mipChain: true, (QualitySettings.activeColorSpace != 0) ? true : false)
			{
				filterMode = FilterMode.Trilinear,
				anisoLevel = ((i == 2) ? 16 : 4)
			};
			TextureArrays[i].TextureArray.name = $"Texture Array Type: {(TextureType)i}";
			TextureArrays[i].Textures = new Texture2D[LocalAvatarConfig.ComponentMaterialProperties.Length];
			for (int j = 0; j < LocalAvatarConfig.ComponentMaterialProperties.Length; j++)
			{
				TextureArrays[i].Textures[j] = LocalAvatarConfig.ComponentMaterialProperties[j].Textures[i];
				TextureArrays[i].Textures[j].name = $"Texture Type: {(TextureType)i} Component: {j}";
			}
			ProcessTexturesWithMips(TextureArrays[i].Textures, avatarComponentMaterialProperties.Textures[i].height, TextureArrays[i].TextureArray);
		}
	}

	private void ProcessTexturesWithMips(Texture2D[] textures, int texArrayResolution, Texture2DArray texArray)
	{
		for (int i = 0; i < textures.Length; i++)
		{
			int num = texArrayResolution;
			for (int num2 = textures[i].mipmapCount - 1; num2 >= 0; num2--)
			{
				int mipSize = texArrayResolution / num;
				OvrAvatarSDKManager.Instance.GetTextureCopyManager().CopyTexture(textures[i], texArray, num2, mipSize, i, useQueue: false);
				num /= 2;
			}
		}
	}

	private void SetMaterialPropertyBlock()
	{
		if (TargetRenderer != null)
		{
			for (int i = 0; i < LocalAvatarConfig.ComponentMaterialProperties.Length; i++)
			{
				LocalAvatarConfig.MaterialPropertyBlock.Colors[i] = LocalAvatarConfig.ComponentMaterialProperties[i].Color;
				LocalAvatarConfig.MaterialPropertyBlock.DiffuseIntensities[i] = DiffuseIntensities[i];
				LocalAvatarConfig.MaterialPropertyBlock.RimIntensities[i] = RimIntensities[i];
				LocalAvatarConfig.MaterialPropertyBlock.ReflectionIntensities[i] = ReflectionIntensities[i];
			}
		}
	}

	private void ApplyMaterialPropertyBlock()
	{
		MaterialPropertyBlock materialPropertyBlock = new MaterialPropertyBlock();
		materialPropertyBlock.SetVectorArray(AVATAR_SHADER_COLOR, LocalAvatarConfig.MaterialPropertyBlock.Colors);
		materialPropertyBlock.SetFloatArray(AVATAR_SHADER_DIFFUSEINTENSITY, LocalAvatarConfig.MaterialPropertyBlock.DiffuseIntensities);
		materialPropertyBlock.SetFloatArray(AVATAR_SHADER_RIMINTENSITY, LocalAvatarConfig.MaterialPropertyBlock.RimIntensities);
		materialPropertyBlock.SetFloatArray(AVATAR_SHADER_REFLECTIONINTENSITY, LocalAvatarConfig.MaterialPropertyBlock.ReflectionIntensities);
		TargetRenderer.GetClosestReflectionProbes(ReflectionProbes);
		if (ReflectionProbes != null && ReflectionProbes.Count > 0 && ReflectionProbes[0].probe.texture != null)
		{
			materialPropertyBlock.SetTexture(AVATAR_SHADER_CUBEMAP, ReflectionProbes[0].probe.texture);
		}
		for (int i = 0; i < TextureArrays.Length; i++)
		{
			materialPropertyBlock.SetTexture(TextureTypeToShaderProperties[i], TextureArrays[i].TextureArray);
		}
		TargetRenderer.SetPropertyBlock(materialPropertyBlock);
	}

	public static ovrAvatarBodyPartType GetComponentType(string objectName)
	{
		if (objectName.Contains("0"))
		{
			return ovrAvatarBodyPartType.Body;
		}
		if (objectName.Contains("1"))
		{
			return ovrAvatarBodyPartType.Clothing;
		}
		if (objectName.Contains("2"))
		{
			return ovrAvatarBodyPartType.Eyewear;
		}
		if (objectName.Contains("3"))
		{
			return ovrAvatarBodyPartType.Hair;
		}
		if (objectName.Contains("4"))
		{
			return ovrAvatarBodyPartType.Beard;
		}
		return ovrAvatarBodyPartType.Count;
	}

	private ulong GetTextureIDForType(ovrAvatarPBSMaterialState materialState, TextureType type)
	{
		return type switch
		{
			TextureType.DiffuseTextures => materialState.albedoTextureID, 
			TextureType.NormalMaps => materialState.normalTextureID, 
			TextureType.RoughnessMaps => materialState.metallicnessTextureID, 
			_ => 0uL, 
		};
	}

	public void ValidateTextures(ovrAvatarPBSMaterialState[] materialStates)
	{
		AvatarComponentMaterialProperties[] componentMaterialProperties = LocalAvatarConfig.ComponentMaterialProperties;
		int[] array = new int[3];
		TextureFormat[] array2 = new TextureFormat[3];
		for (int i = 0; i < componentMaterialProperties.Length; i++)
		{
			for (int j = 0; j < componentMaterialProperties[i].Textures.Length; j++)
			{
				if (componentMaterialProperties[i].Textures[j] == null)
				{
					string text = componentMaterialProperties[i].TypeIndex.ToString();
					TextureType textureType = (TextureType)j;
					throw new Exception(text + "Invalid: " + textureType);
				}
				array[j] = componentMaterialProperties[i].Textures[j].height;
				array2[j] = componentMaterialProperties[i].Textures[j].format;
			}
		}
		for (int k = 0; k < 3; k++)
		{
			for (int l = 1; l < componentMaterialProperties.Length; l++)
			{
				if (componentMaterialProperties[l - 1].Textures[k].height != componentMaterialProperties[l].Textures[k].height)
				{
					object[] obj = new object[12]
					{
						componentMaterialProperties[l].TypeIndex.ToString(),
						" Mismatching Resolutions: ",
						null,
						null,
						null,
						null,
						null,
						null,
						null,
						null,
						null,
						null
					};
					TextureType textureType = (TextureType)k;
					obj[2] = textureType.ToString();
					obj[3] = " ";
					obj[4] = componentMaterialProperties[l - 1].Textures[k].height;
					obj[5] = " (ID: ";
					obj[6] = GetTextureIDForType(materialStates[l - 1], (TextureType)k);
					obj[7] = ") vs ";
					obj[8] = componentMaterialProperties[l].Textures[k].height;
					obj[9] = " (ID: ";
					obj[10] = GetTextureIDForType(materialStates[l], (TextureType)k);
					obj[11] = ") Ensure you are using ASTC texture compression on Android or turn off CombineMeshes";
					throw new Exception(string.Concat(obj));
				}
				if (componentMaterialProperties[l - 1].Textures[k].format != componentMaterialProperties[l].Textures[k].format)
				{
					object[] obj2 = new object[12]
					{
						componentMaterialProperties[l].TypeIndex.ToString(),
						" Mismatching Formats: ",
						null,
						null,
						null,
						null,
						null,
						null,
						null,
						null,
						null,
						null
					};
					TextureType textureType = (TextureType)k;
					obj2[2] = textureType.ToString();
					obj2[3] = " ";
					obj2[4] = componentMaterialProperties[l - 1].Textures[k].format;
					obj2[5] = " (ID: ";
					obj2[6] = GetTextureIDForType(materialStates[l - 1], (TextureType)k);
					obj2[7] = ") vs ";
					obj2[8] = componentMaterialProperties[l].Textures[k].format;
					obj2[9] = " (ID: ";
					obj2[10] = GetTextureIDForType(materialStates[l], (TextureType)k);
					obj2[11] = ") Ensure you are using ASTC texture compression on Android or turn off CombineMeshes";
					throw new Exception(string.Concat(obj2));
				}
			}
		}
	}

	private IEnumerator RunLoadingAnimation(Action callBack)
	{
		CombinedShader = TargetRenderer.sharedMaterial.shader;
		int srcBlend = TargetRenderer.sharedMaterial.GetInt("_SrcBlend");
		int dstBlend = TargetRenderer.sharedMaterial.GetInt("_DstBlend");
		string lightModeTag = TargetRenderer.sharedMaterial.GetTag("LightMode", searchFallbacks: false);
		string renderTypeTag = TargetRenderer.sharedMaterial.GetTag("RenderType", searchFallbacks: false);
		string renderQueueTag = TargetRenderer.sharedMaterial.GetTag("Queue", searchFallbacks: false);
		string ignoreProjectorTag = TargetRenderer.sharedMaterial.GetTag("IgnoreProjector", searchFallbacks: false);
		int renderQueue = TargetRenderer.sharedMaterial.renderQueue;
		bool transparentQueue = TargetRenderer.sharedMaterial.IsKeywordEnabled("_ALPHATEST_ON");
		TargetRenderer.sharedMaterial.shader = Shader.Find(AVATAR_SHADER_LOADER);
		TargetRenderer.sharedMaterial.SetColor(AVATAR_SHADER_COLOR, Color.white);
		while (OvrAvatarSDKManager.Instance.GetTextureCopyManager().GetTextureCount() > 0)
		{
			float value = (0.5f * Mathf.Sin(Time.timeSinceLevelLoad / 0.35f) + 0.5f) * 0.25f + 0.3f;
			TargetRenderer.sharedMaterial.SetFloat(AVATAR_SHADER_LOADING_DIMMER, value);
			yield return null;
		}
		TargetRenderer.sharedMaterial.SetFloat(AVATAR_SHADER_LOADING_DIMMER, 1f);
		TargetRenderer.sharedMaterial.shader = CombinedShader;
		TargetRenderer.sharedMaterial.SetInt("_SrcBlend", srcBlend);
		TargetRenderer.sharedMaterial.SetInt("_DstBlend", dstBlend);
		TargetRenderer.sharedMaterial.SetOverrideTag("LightMode", lightModeTag);
		TargetRenderer.sharedMaterial.SetOverrideTag("RenderType", renderTypeTag);
		TargetRenderer.sharedMaterial.SetOverrideTag("Queue", renderQueueTag);
		TargetRenderer.sharedMaterial.SetOverrideTag("IgnoreProjector", ignoreProjectorTag);
		if (transparentQueue)
		{
			TargetRenderer.sharedMaterial.EnableKeyword("_ALPHATEST_ON");
			TargetRenderer.sharedMaterial.EnableKeyword("_ALPHABLEND_ON");
			TargetRenderer.sharedMaterial.EnableKeyword("_ALPHAPREMULTIPLY_ON");
		}
		else
		{
			TargetRenderer.sharedMaterial.DisableKeyword("_ALPHATEST_ON");
			TargetRenderer.sharedMaterial.DisableKeyword("_ALPHABLEND_ON");
			TargetRenderer.sharedMaterial.DisableKeyword("_ALPHAPREMULTIPLY_ON");
		}
		TargetRenderer.sharedMaterial.renderQueue = renderQueue;
		ApplyMaterialPropertyBlock();
		callBack?.Invoke();
	}
}
public class OvrAvatarMeshInstance : MonoBehaviour
{
	private HashSet<ulong> AssetsToLoad;

	public ulong MeshID;

	private ulong MaterialID;

	private ulong FadeTextureID;

	public ovrAvatarBodyPartType MeshType;

	public ovrAvatarMaterialState MaterialState;

	private MeshFilter Mesh;

	private MeshRenderer MeshInstance;

	public void AssetLoadedCallback(OvrAvatarAsset asset)
	{
		AssetsToLoad.Remove(asset.assetID);
		HandleAssetAvailable(asset);
		if (AssetsToLoad.Count <= 0)
		{
			UpdateMaterial();
		}
	}

	public void SetMeshAssets(ulong fadeTexture, ulong meshID, ulong materialID, ovrAvatarBodyPartType type)
	{
		MaterialID = materialID;
		MeshID = meshID;
		FadeTextureID = fadeTexture;
		MeshType = type;
		AssetsToLoad = new HashSet<ulong>();
		RequestAsset(meshID);
		RequestAsset(materialID);
		RequestAsset(fadeTexture);
	}

	private void HandleAssetAvailable(OvrAvatarAsset asset)
	{
		if (asset.assetID == MeshID)
		{
			Mesh = base.gameObject.AddComponent<MeshFilter>();
			MeshInstance = base.gameObject.AddComponent<MeshRenderer>();
			MeshInstance.shadowCastingMode = ShadowCastingMode.Off;
			Mesh.sharedMesh = ((OvrAvatarAssetMesh)asset).mesh;
			Material material = new Material(Shader.Find("OvrAvatar/AvatarSurfaceShaderSelfOccluding"));
			MeshInstance.material = material;
		}
		if (asset.assetID == MaterialID)
		{
			MaterialState = ((OvrAvatarAssetMaterial)asset).material;
			MaterialState.alphaMaskTextureID = FadeTextureID;
			RequestMaterialTextures();
		}
	}

	public void ChangeMaterial(ulong assetID)
	{
		MaterialID = assetID;
		RequestAsset(MaterialID);
	}

	private void RequestAsset(ulong assetID)
	{
		if (assetID != 0L)
		{
			OvrAvatarAsset asset = OvrAvatarSDKManager.Instance.GetAsset(assetID);
			if (asset == null)
			{
				OvrAvatarSDKManager.Instance.BeginLoadingAsset(assetID, ovrAvatarAssetLevelOfDetail.Medium, AssetLoadedCallback);
				AssetsToLoad.Add(assetID);
			}
			else
			{
				HandleAssetAvailable(asset);
			}
		}
	}

	private void RequestMaterialTextures()
	{
		RequestAsset(MaterialState.normalMapTextureID);
		RequestAsset(MaterialState.parallaxMapTextureID);
		RequestAsset(MaterialState.roughnessMapTextureID);
		for (int i = 0; i < MaterialState.layerCount; i++)
		{
			RequestAsset(MaterialState.layers[i].sampleTexture);
		}
	}

	public void SetActive(bool active)
	{
		base.gameObject.SetActive(active);
		if (active)
		{
			UpdateMaterial();
		}
	}

	private void UpdateMaterial()
	{
		if (MeshInstance == null || MaterialID == 0L)
		{
			return;
		}
		Material material = MeshInstance.material;
		ovrAvatarMaterialState materialState = MaterialState;
		material.SetColor("_BaseColor", materialState.baseColor);
		material.SetInt("_BaseMaskType", (int)materialState.baseMaskType);
		material.SetVector("_BaseMaskParameters", materialState.baseMaskParameters);
		material.SetVector("_BaseMaskAxis", materialState.baseMaskAxis);
		if (materialState.alphaMaskTextureID != 0L)
		{
			material.SetTexture("_AlphaMask", OvrAvatarComponent.GetLoadedTexture(materialState.alphaMaskTextureID));
			material.SetTextureScale("_AlphaMask", new Vector2(materialState.alphaMaskScaleOffset.x, materialState.alphaMaskScaleOffset.y));
			material.SetTextureOffset("_AlphaMask", new Vector2(materialState.alphaMaskScaleOffset.z, materialState.alphaMaskScaleOffset.w));
		}
		if (materialState.normalMapTextureID != 0L)
		{
			material.EnableKeyword("NORMAL_MAP_ON");
			material.SetTexture("_NormalMap", OvrAvatarComponent.GetLoadedTexture(materialState.normalMapTextureID));
			material.SetTextureScale("_NormalMap", new Vector2(materialState.normalMapScaleOffset.x, materialState.normalMapScaleOffset.y));
			material.SetTextureOffset("_NormalMap", new Vector2(materialState.normalMapScaleOffset.z, materialState.normalMapScaleOffset.w));
		}
		if (materialState.parallaxMapTextureID != 0L)
		{
			material.SetTexture("_ParallaxMap", OvrAvatarComponent.GetLoadedTexture(materialState.parallaxMapTextureID));
			material.SetTextureScale("_ParallaxMap", new Vector2(materialState.parallaxMapScaleOffset.x, materialState.parallaxMapScaleOffset.y));
			material.SetTextureOffset("_ParallaxMap", new Vector2(materialState.parallaxMapScaleOffset.z, materialState.parallaxMapScaleOffset.w));
		}
		if (materialState.roughnessMapTextureID != 0L)
		{
			material.EnableKeyword("ROUGHNESS_ON");
			material.SetTexture("_RoughnessMap", OvrAvatarComponent.GetLoadedTexture(materialState.roughnessMapTextureID));
			material.SetTextureScale("_RoughnessMap", new Vector2(materialState.roughnessMapScaleOffset.x, materialState.roughnessMapScaleOffset.y));
			material.SetTextureOffset("_RoughnessMap", new Vector2(materialState.roughnessMapScaleOffset.z, materialState.roughnessMapScaleOffset.w));
		}
		material.EnableKeyword(OvrAvatarComponent.LayerKeywords[materialState.layerCount]);
		for (ulong num = 0uL; num < materialState.layerCount; num++)
		{
			ovrAvatarMaterialLayerState ovrAvatarMaterialLayerState2 = materialState.layers[num];
			material.SetInt(OvrAvatarComponent.LayerSampleModeParameters[num], (int)ovrAvatarMaterialLayerState2.sampleMode);
			material.SetInt(OvrAvatarComponent.LayerBlendModeParameters[num], (int)ovrAvatarMaterialLayerState2.blendMode);
			material.SetInt(OvrAvatarComponent.LayerMaskTypeParameters[num], (int)ovrAvatarMaterialLayerState2.maskType);
			material.SetColor(OvrAvatarComponent.LayerColorParameters[num], ovrAvatarMaterialLayerState2.layerColor);
			if (ovrAvatarMaterialLayerState2.sampleMode != 0)
			{
				string text = OvrAvatarComponent.LayerSurfaceParameters[num];
				material.SetTexture(text, OvrAvatarComponent.GetLoadedTexture(ovrAvatarMaterialLayerState2.sampleTexture));
				material.SetTextureScale(text, new Vector2(ovrAvatarMaterialLayerState2.sampleScaleOffset.x, ovrAvatarMaterialLayerState2.sampleScaleOffset.y));
				material.SetTextureOffset(text, new Vector2(ovrAvatarMaterialLayerState2.sampleScaleOffset.z, ovrAvatarMaterialLayerState2.sampleScaleOffset.w));
			}
			if (ovrAvatarMaterialLayerState2.sampleMode == ovrAvatarMaterialLayerSampleMode.Parallax)
			{
				material.EnableKeyword("PARALLAX_ON");
			}
			material.SetColor(OvrAvatarComponent.LayerSampleParametersParameters[num], ovrAvatarMaterialLayerState2.sampleParameters);
			material.SetColor(OvrAvatarComponent.LayerMaskParametersParameters[num], ovrAvatarMaterialLayerState2.maskParameters);
			material.SetColor(OvrAvatarComponent.LayerMaskAxisParameters[num], ovrAvatarMaterialLayerState2.maskAxis);
		}
	}
}
public class OvrAvatarPacket
{
	public IntPtr ovrNativePacket = IntPtr.Zero;

	private List<float> frameTimes = new List<float>();

	private List<OvrAvatarDriver.PoseFrame> frames = new List<OvrAvatarDriver.PoseFrame>();

	private List<byte[]> encodedAudioPackets = new List<byte[]>();

	public float Duration => frameTimes[frameTimes.Count - 1];

	public OvrAvatarDriver.PoseFrame FinalFrame => frames[frames.Count - 1];

	public OvrAvatarPacket()
	{
	}

	public OvrAvatarPacket(OvrAvatarDriver.PoseFrame initialPose)
	{
		frameTimes.Add(0f);
		frames.Add(initialPose);
	}

	private OvrAvatarPacket(List<float> frameTimes, List<OvrAvatarDriver.PoseFrame> frames, List<byte[]> audioPackets)
	{
		this.frameTimes = frameTimes;
		this.frames = frames;
	}

	public void AddFrame(OvrAvatarDriver.PoseFrame frame, float deltaSeconds)
	{
		frameTimes.Add(Duration + deltaSeconds);
		frames.Add(frame);
	}

	public OvrAvatarDriver.PoseFrame GetPoseFrame(float seconds)
	{
		if (frames.Count == 1)
		{
			return frames[0];
		}
		int i;
		for (i = 1; i < frameTimes.Count && frameTimes[i] < seconds; i++)
		{
		}
		OvrAvatarDriver.PoseFrame a = frames[i - 1];
		OvrAvatarDriver.PoseFrame b = frames[i];
		float num = frameTimes[i - 1];
		float num2 = frameTimes[i];
		float t = (seconds - num) / (num2 - num);
		return OvrAvatarDriver.PoseFrame.Interpolate(a, b, t);
	}

	public static OvrAvatarPacket Read(Stream stream)
	{
		BinaryReader binaryReader = new BinaryReader(stream);
		int num = binaryReader.ReadInt32();
		List<float> list = new List<float>(num);
		for (int i = 0; i < num; i++)
		{
			list.Add(binaryReader.ReadSingle());
		}
		List<OvrAvatarDriver.PoseFrame> list2 = new List<OvrAvatarDriver.PoseFrame>(num);
		for (int j = 0; j < num; j++)
		{
			list2.Add(binaryReader.ReadPoseFrame());
		}
		int num2 = binaryReader.ReadInt32();
		List<byte[]> list3 = new List<byte[]>(num2);
		for (int k = 0; k < num2; k++)
		{
			int count = binaryReader.ReadInt32();
			byte[] item = binaryReader.ReadBytes(count);
			list3.Add(item);
		}
		return new OvrAvatarPacket(list, list2, list3);
	}

	public void Write(Stream stream)
	{
		BinaryWriter binaryWriter = new BinaryWriter(stream);
		int count = frameTimes.Count;
		binaryWriter.Write(count);
		for (int i = 0; i < count; i++)
		{
			binaryWriter.Write(frameTimes[i]);
		}
		for (int j = 0; j < count; j++)
		{
			OvrAvatarDriver.PoseFrame frame = frames[j];
			binaryWriter.Write(frame);
		}
		int count2 = encodedAudioPackets.Count;
		binaryWriter.Write(count2);
		for (int k = 0; k < count2; k++)
		{
			byte[] array = encodedAudioPackets[k];
			binaryWriter.Write(array.Length);
			binaryWriter.Write(array);
		}
	}
}
internal static class BinaryWriterExtensions
{
	public static void Write(this BinaryWriter writer, OvrAvatarDriver.PoseFrame frame)
	{
		writer.Write(frame.headPosition);
		writer.Write(frame.headRotation);
		writer.Write(frame.handLeftPosition);
		writer.Write(frame.handLeftRotation);
		writer.Write(frame.handRightPosition);
		writer.Write(frame.handRightRotation);
		writer.Write(frame.voiceAmplitude);
		writer.Write(frame.controllerLeftPose);
		writer.Write(frame.controllerRightPose);
	}

	public static void Write(this BinaryWriter writer, Vector3 vec3)
	{
		writer.Write(vec3.x);
		writer.Write(vec3.y);
		writer.Write(vec3.z);
	}

	public static void Write(this BinaryWriter writer, Vector2 vec2)
	{
		writer.Write(vec2.x);
		writer.Write(vec2.y);
	}

	public static void Write(this BinaryWriter writer, Quaternion quat)
	{
		writer.Write(quat.x);
		writer.Write(quat.y);
		writer.Write(quat.z);
		writer.Write(quat.w);
	}

	public static void Write(this BinaryWriter writer, OvrAvatarDriver.ControllerPose pose)
	{
		writer.Write((uint)pose.buttons);
		writer.Write((uint)pose.touches);
		writer.Write(pose.joystickPosition);
		writer.Write(pose.indexTrigger);
		writer.Write(pose.handTrigger);
		writer.Write(pose.isActive);
	}
}
internal static class BinaryReaderExtensions
{
	public static OvrAvatarDriver.PoseFrame ReadPoseFrame(this BinaryReader reader)
	{
		OvrAvatarDriver.PoseFrame result = default(OvrAvatarDriver.PoseFrame);
		result.headPosition = reader.ReadVector3();
		result.headRotation = reader.ReadQuaternion();
		result.handLeftPosition = reader.ReadVector3();
		result.handLeftRotation = reader.ReadQuaternion();
		result.handRightPosition = reader.ReadVector3();
		result.handRightRotation = reader.ReadQuaternion();
		result.voiceAmplitude = reader.ReadSingle();
		result.controllerLeftPose = reader.ReadControllerPose();
		result.controllerRightPose = reader.ReadControllerPose();
		return result;
	}

	public static Vector2 ReadVector2(this BinaryReader reader)
	{
		Vector2 result = default(Vector2);
		result.x = reader.ReadSingle();
		result.y = reader.ReadSingle();
		return result;
	}

	public static Vector3 ReadVector3(this BinaryReader reader)
	{
		Vector3 result = default(Vector3);
		result.x = reader.ReadSingle();
		result.y = reader.ReadSingle();
		result.z = reader.ReadSingle();
		return result;
	}

	public static Quaternion ReadQuaternion(this BinaryReader reader)
	{
		Quaternion result = default(Quaternion);
		result.x = reader.ReadSingle();
		result.y = reader.ReadSingle();
		result.z = reader.ReadSingle();
		result.w = reader.ReadSingle();
		return result;
	}

	public static OvrAvatarDriver.ControllerPose ReadControllerPose(this BinaryReader reader)
	{
		OvrAvatarDriver.ControllerPose result = default(OvrAvatarDriver.ControllerPose);
		result.buttons = (ovrAvatarButton)reader.ReadUInt32();
		result.touches = (ovrAvatarTouch)reader.ReadUInt32();
		result.joystickPosition = reader.ReadVector2();
		result.indexTrigger = reader.ReadSingle();
		result.handTrigger = reader.ReadSingle();
		result.isActive = reader.ReadBoolean();
		return result;
	}
}
public class OvrAvatarProjectorRenderComponent : OvrAvatarRenderComponent
{
	private Material material;

	internal void InitializeProjectorRender(ovrAvatarRenderPart_ProjectorRender render, Shader shader, OvrAvatarRenderComponent target)
	{
		if (shader == null)
		{
			shader = Shader.Find("OvrAvatar/AvatarSurfaceShader");
		}
		material = CreateAvatarMaterial(base.gameObject.name + "_projector", shader);
		material.EnableKeyword("PROJECTOR_ON");
		Renderer component = target.GetComponent<Renderer>();
		if (component != null)
		{
			List<Material> list = new List<Material>(component.sharedMaterials);
			list.Add(material);
			component.sharedMaterials = list.ToArray();
		}
	}

	internal void UpdateProjectorRender(OvrAvatarComponent component, ovrAvatarRenderPart_ProjectorRender render)
	{
		OvrAvatar.ConvertTransform(render.localTransform, base.transform);
		material.SetMatrix("_ProjectorWorldToLocal", base.transform.worldToLocalMatrix);
		component.UpdateAvatarMaterial(material, render.materialState);
	}

	private void OnDrawGizmos()
	{
		Vector3 from = base.transform.localToWorldMatrix.MultiplyPoint(new Vector3(-1f, -1f, -1f));
		Vector3 vector = base.transform.localToWorldMatrix.MultiplyPoint(new Vector3(1f, -1f, -1f));
		Vector3 vector2 = base.transform.localToWorldMatrix.MultiplyPoint(new Vector3(-1f, 1f, -1f));
		Vector3 vector3 = base.transform.localToWorldMatrix.MultiplyPoint(new Vector3(1f, 1f, -1f));
		Vector3 vector4 = base.transform.localToWorldMatrix.MultiplyPoint(new Vector3(-1f, -1f, 1f));
		Vector3 vector5 = base.transform.localToWorldMatrix.MultiplyPoint(new Vector3(1f, -1f, 1f));
		Vector3 vector6 = base.transform.localToWorldMatrix.MultiplyPoint(new Vector3(-1f, 1f, 1f));
		Vector3 to = base.transform.localToWorldMatrix.MultiplyPoint(new Vector3(1f, 1f, 1f));
		Gizmos.color = Color.gray;
		Gizmos.DrawLine(from, vector);
		Gizmos.DrawLine(from, vector2);
		Gizmos.DrawLine(vector2, vector3);
		Gizmos.DrawLine(vector, vector3);
		Gizmos.DrawLine(from, vector4);
		Gizmos.DrawLine(vector, vector5);
		Gizmos.DrawLine(vector2, vector6);
		Gizmos.DrawLine(vector3, to);
		Gizmos.DrawLine(vector4, vector5);
		Gizmos.DrawLine(vector4, vector6);
		Gizmos.DrawLine(vector6, to);
		Gizmos.DrawLine(vector5, to);
	}
}
public class OvrAvatarRemoteDriver : OvrAvatarDriver
{
	private Queue<OvrAvatarPacket> packetQueue = new Queue<OvrAvatarPacket>();

	private IntPtr CurrentSDKPacket = IntPtr.Zero;

	private float CurrentPacketTime;

	private const int MinPacketQueue = 1;

	private const int MaxPacketQueue = 4;

	private int CurrentSequence = -1;

	private bool isStreaming;

	private OvrAvatarPacket currentPacket;

	public void QueuePacket(int sequence, OvrAvatarPacket packet)
	{
		if (sequence > CurrentSequence)
		{
			CurrentSequence = sequence;
			packetQueue.Enqueue(packet);
		}
	}

	public override void UpdateTransforms(IntPtr sdkAvatar)
	{
		switch (Mode)
		{
		case PacketMode.SDK:
			UpdateFromSDKPacket(sdkAvatar);
			break;
		case PacketMode.Unity:
			UpdateFromUnityPacket(sdkAvatar);
			break;
		}
	}

	private void UpdateFromSDKPacket(IntPtr sdkAvatar)
	{
		if (CurrentSDKPacket == IntPtr.Zero && packetQueue.Count >= 1)
		{
			CurrentSDKPacket = packetQueue.Dequeue().ovrNativePacket;
		}
		if (!(CurrentSDKPacket != IntPtr.Zero))
		{
			return;
		}
		float num = Oculus.Avatar.CAPI.ovrAvatarPacket_GetDurationSeconds(CurrentSDKPacket);
		Oculus.Avatar.CAPI.ovrAvatar_UpdatePoseFromPacket(sdkAvatar, CurrentSDKPacket, Mathf.Min(num, CurrentPacketTime));
		CurrentPacketTime += Time.deltaTime;
		if (CurrentPacketTime > num)
		{
			Oculus.Avatar.CAPI.ovrAvatarPacket_Free(CurrentSDKPacket);
			CurrentSDKPacket = IntPtr.Zero;
			CurrentPacketTime -= num;
			while (packetQueue.Count > 4)
			{
				packetQueue.Dequeue();
			}
		}
	}

	private void UpdateFromUnityPacket(IntPtr sdkAvatar)
	{
		if (!isStreaming && packetQueue.Count > 1)
		{
			currentPacket = packetQueue.Dequeue();
			isStreaming = true;
		}
		if (!isStreaming)
		{
			return;
		}
		CurrentPacketTime += Time.deltaTime;
		while (CurrentPacketTime > currentPacket.Duration)
		{
			if (packetQueue.Count == 0)
			{
				CurrentPose = currentPacket.FinalFrame;
				CurrentPacketTime = 0f;
				currentPacket = null;
				isStreaming = false;
				return;
			}
			while (packetQueue.Count > 4)
			{
				packetQueue.Dequeue();
			}
			CurrentPacketTime -= currentPacket.Duration;
			currentPacket = packetQueue.Dequeue();
		}
		CurrentPose = currentPacket.GetPoseFrame(CurrentPacketTime);
		UpdateTransformsFromPose(sdkAvatar);
	}
}
public class OvrAvatarRenderComponent : MonoBehaviour
{
	private bool firstSkinnedUpdate = true;

	public SkinnedMeshRenderer mesh;

	public Transform[] bones;

	private bool isBodyComponent;

	protected void UpdateActive(OvrAvatar avatar, ovrAvatarVisibilityFlags mask)
	{
		if (isBodyComponent && avatar.EnableExpressive && avatar.ShowFirstPerson && !avatar.ShowThirdPerson)
		{
			bool num = (mask & ovrAvatarVisibilityFlags.FirstPerson) != 0;
			bool flag = (mask & ovrAvatarVisibilityFlags.ThirdPerson) != 0;
			base.gameObject.SetActive(flag || flag);
			if (!num)
			{
				mesh.enabled = false;
			}
		}
		else
		{
			bool flag2 = avatar.ShowFirstPerson && (mask & ovrAvatarVisibilityFlags.FirstPerson) != 0;
			flag2 |= avatar.ShowThirdPerson && (mask & ovrAvatarVisibilityFlags.ThirdPerson) != 0;
			base.gameObject.SetActive(flag2);
			mesh.enabled = flag2;
		}
	}

	protected SkinnedMeshRenderer CreateSkinnedMesh(ulong assetID, ovrAvatarVisibilityFlags visibilityMask, int thirdPersonLayer, int firstPersonLayer)
	{
		isBodyComponent = base.name.Contains("body");
		OvrAvatarAssetMesh obj = ((OvrAvatarAssetMesh)OvrAvatarSDKManager.Instance.GetAsset(assetID)) ?? throw new Exception("Couldn't find mesh for asset " + assetID);
		if ((visibilityMask & ovrAvatarVisibilityFlags.ThirdPerson) != 0)
		{
			base.gameObject.layer = thirdPersonLayer;
		}
		else
		{
			base.gameObject.layer = firstPersonLayer;
		}
		SkinnedMeshRenderer skinnedMeshRenderer = obj.CreateSkinnedMeshRendererOnObject(base.gameObject);
		skinnedMeshRenderer.quality = SkinQuality.Bone2;
		skinnedMeshRenderer.updateWhenOffscreen = true;
		if ((visibilityMask & ovrAvatarVisibilityFlags.SelfOccluding) == 0)
		{
			skinnedMeshRenderer.shadowCastingMode = ShadowCastingMode.Off;
		}
		base.gameObject.SetActive(value: false);
		return skinnedMeshRenderer;
	}

	protected void UpdateSkinnedMesh(OvrAvatar avatar, Transform[] bones, ovrAvatarTransform localTransform, ovrAvatarVisibilityFlags visibilityMask, IntPtr renderPart)
	{
		UpdateActive(avatar, visibilityMask);
		OvrAvatar.ConvertTransform(localTransform, base.transform);
		ovrAvatarRenderPartType ovrAvatarRenderPartType2 = Oculus.Avatar.CAPI.ovrAvatarRenderPart_GetType(renderPart);
		ulong num = ovrAvatarRenderPartType2 switch
		{
			ovrAvatarRenderPartType.SkinnedMeshRender => Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRender_GetDirtyJoints(renderPart), 
			ovrAvatarRenderPartType.SkinnedMeshRenderPBS => Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBS_GetDirtyJoints(renderPart), 
			ovrAvatarRenderPartType.SkinnedMeshRenderPBS_V2 => Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBSV2_GetDirtyJoints(renderPart), 
			_ => throw new Exception("Unhandled render part type: " + ovrAvatarRenderPartType2), 
		};
		for (uint num2 = 0u; num2 < 64; num2++)
		{
			ulong num3 = (ulong)(1L << (int)num2);
			if ((firstSkinnedUpdate && num2 < bones.Length) || (num3 & num) != 0L)
			{
				Transform target = bones[num2];
				OvrAvatar.ConvertTransform(ovrAvatarRenderPartType2 switch
				{
					ovrAvatarRenderPartType.SkinnedMeshRender => Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRender_GetJointTransform(renderPart, num2), 
					ovrAvatarRenderPartType.SkinnedMeshRenderPBS => Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBS_GetJointTransform(renderPart, num2), 
					ovrAvatarRenderPartType.SkinnedMeshRenderPBS_V2 => Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBSV2_GetJointTransform(renderPart, num2), 
					_ => throw new Exception("Unhandled render part type: " + ovrAvatarRenderPartType2), 
				}, target);
			}
		}
		firstSkinnedUpdate = false;
	}

	protected Material CreateAvatarMaterial(string name, Shader shader)
	{
		if (shader == null)
		{
			throw new Exception("No shader provided for avatar material.");
		}
		return new Material(shader)
		{
			name = name
		};
	}
}
[Flags]
public enum ovrAvatarCapabilities
{
	Body = 1,
	Hands = 2,
	Base = 4,
	BodyTilt = 0x10,
	Expressive = 0x20,
	All = -1
}
public enum ovrAvatarMessageType
{
	AvatarSpecification,
	AssetLoaded,
	Count
}
public struct ovrAvatarMessage_AvatarSpecification
{
	public IntPtr avatarSpec;

	public ulong oculusUserID;
}
public struct ovrAvatarMessage_AssetLoaded
{
	public ulong assetID;

	public IntPtr asset;
}
public enum ovrAvatarAssetType
{
	Mesh,
	Texture,
	Pose,
	Material,
	CombinedMesh,
	PBSMaterial,
	FailedLoad,
	Count
}
public struct ovrAvatarMeshVertex
{
	public float x;

	public float y;

	public float z;

	public float nx;

	public float ny;

	public float nz;

	public float tx;

	public float ty;

	public float tz;

	public float tw;

	public float u;

	public float v;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
	public byte[] blendIndices;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
	public float[] blendWeights;
}
public struct ovrAvatarMeshVertexV2
{
	public float x;

	public float y;

	public float z;

	public float nx;

	public float ny;

	public float nz;

	public float tx;

	public float ty;

	public float tz;

	public float tw;

	public float u;

	public float v;

	public float r;

	public float g;

	public float b;

	public float a;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
	public byte[] blendIndices;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
	public float[] blendWeights;
}
public struct ovrAvatarBlendVertex
{
	public float x;

	public float y;

	public float z;

	public float nx;

	public float ny;

	public float nz;

	public float tx;

	public float ty;

	public float tz;
}
public struct ovrAvatarMeshAssetData
{
	public uint vertexCount;

	public IntPtr vertexBuffer;

	public uint indexCount;

	public IntPtr indexBuffer;

	public ovrAvatarSkinnedMeshPose skinnedBindPose;
}
public struct ovrAvatarMeshAssetDataV2
{
	public uint vertexCount;

	public IntPtr vertexBuffer;

	public uint indexCount;

	public IntPtr indexBuffer;

	public ovrAvatarSkinnedMeshPose skinnedBindPose;
}
public enum ovrAvatarTextureFormat
{
	RGB24,
	DXT1,
	DXT5,
	ASTC_RGB_6x6,
	ASTC_RGB_6x6_MIPMAPS,
	Count
}
public struct ovrAvatarTextureAssetData
{
	public ovrAvatarTextureFormat format;

	public uint sizeX;

	public uint sizeY;

	public uint mipCount;

	public ulong textureDataSize;

	public IntPtr textureData;
}
public enum ovrAvatarRenderPartType
{
	SkinnedMeshRender,
	SkinnedMeshRenderPBS,
	ProjectorRender,
	SkinnedMeshRenderPBS_V2,
	Count
}
public enum ovrAvatarLogLevel
{
	Unknown,
	Default,
	Verbose,
	Debug,
	Info,
	Warn,
	Error,
	Fatal,
	Silent
}
public struct ovrAvatarTransform
{
	public Vector3 position;

	public Quaternion orientation;

	public Vector3 scale;
}
[Flags]
public enum ovrAvatarButton
{
	One = 1,
	Two = 2,
	Three = 4,
	Joystick = 8
}
[Flags]
public enum ovrAvatarTouch
{
	One = 1,
	Two = 2,
	Joystick = 4,
	ThumbRest = 8,
	Index = 0x10,
	Pointing = 0x40,
	ThumbUp = 0x80
}
public struct ovrAvatarHandInputState
{
	public ovrAvatarTransform transform;

	public ovrAvatarButton buttonMask;

	public ovrAvatarTouch touchMask;

	public float joystickX;

	public float joystickY;

	public float indexTrigger;

	public float handTrigger;

	[MarshalAs(UnmanagedType.I1)]
	public bool isActive;
}
public struct ovrAvatarComponent
{
	public ovrAvatarTransform transform;

	public uint renderPartCount;

	public IntPtr renderParts;

	[MarshalAs(UnmanagedType.LPStr)]
	public string name;
}
[StructLayout(LayoutKind.Sequential, Size = 1)]
internal struct ovrAvatarComponent_Offsets
{
	public static long transform = Marshal.OffsetOf(typeof(ovrAvatarComponent), "transform").ToInt64();

	public static int renderPartCount = Marshal.OffsetOf(typeof(ovrAvatarComponent), "renderPartCount").ToInt32();

	public static int renderParts = Marshal.OffsetOf(typeof(ovrAvatarComponent), "renderParts").ToInt32();

	public static int name = Marshal.OffsetOf(typeof(ovrAvatarComponent), "name").ToInt32();
}
public struct ovrAvatarBaseComponent
{
	public Vector3 basePosition;

	public IntPtr renderComponent;
}
public struct ovrAvatarBodyComponent
{
	public ovrAvatarTransform leftEyeTransform;

	public ovrAvatarTransform rightEyeTransform;

	public ovrAvatarTransform centerEyeTransform;

	public IntPtr renderComponent;
}
[StructLayout(LayoutKind.Sequential, Size = 1)]
public struct ovrAvatarBodyComponent_Offsets
{
	public static long leftEyeTransform = Marshal.OffsetOf(typeof(ovrAvatarBodyComponent), "leftEyeTransform").ToInt64();

	public static long rightEyeTransform = Marshal.OffsetOf(typeof(ovrAvatarBodyComponent), "rightEyeTransform").ToInt64();

	public static long centerEyeTransform = Marshal.OffsetOf(typeof(ovrAvatarBodyComponent), "centerEyeTransform").ToInt64();

	public static long renderComponent = Marshal.OffsetOf(typeof(ovrAvatarBodyComponent), "renderComponent").ToInt64();
}
public struct ovrAvatarControllerComponent
{
	public ovrAvatarHandInputState inputState;

	public IntPtr renderComponent;
}
public struct ovrAvatarHandComponent
{
	public ovrAvatarHandInputState inputState;

	public IntPtr renderComponent;
}
public enum ovrAvatarMaterialLayerBlendMode
{
	Add,
	Multiply,
	Count
}
public enum ovrAvatarMaterialLayerSampleMode
{
	Color,
	Texture,
	TextureSingleChannel,
	Parallax,
	Count
}
public enum ovrAvatarMaterialMaskType
{
	None,
	Positional,
	ViewReflection,
	Fresnel,
	Pulse,
	Count
}
public enum ovrAvatarControllerType
{
	Touch,
	Malibu,
	Go,
	Quest,
	Count
}
public enum ovrAvatarAssetLevelOfDetail
{
	Lowest = 1,
	Medium = 3,
	Highest = 5
}
public enum ovrAvatarLookAndFeelVersion
{
	Unknown = -1,
	One,
	Two
}
public struct ovrAvatarMaterialLayerState
{
	public ovrAvatarMaterialLayerBlendMode blendMode;

	public ovrAvatarMaterialLayerSampleMode sampleMode;

	public ovrAvatarMaterialMaskType maskType;

	public Vector4 layerColor;

	public Vector4 sampleParameters;

	public ulong sampleTexture;

	public Vector4 sampleScaleOffset;

	public Vector4 maskParameters;

	public Vector4 maskAxis;

	private static bool VectorEquals(Vector4 a, Vector4 b)
	{
		if (a.x == b.x && a.y == b.y && a.z == b.z)
		{
			return a.w == b.w;
		}
		return false;
	}

	public override bool Equals(object obj)
	{
		if (!(obj is ovrAvatarMaterialLayerState ovrAvatarMaterialLayerState2))
		{
			return false;
		}
		if (blendMode != ovrAvatarMaterialLayerState2.blendMode)
		{
			return false;
		}
		if (sampleMode != ovrAvatarMaterialLayerState2.sampleMode)
		{
			return false;
		}
		if (maskType != ovrAvatarMaterialLayerState2.maskType)
		{
			return false;
		}
		if (!VectorEquals(layerColor, ovrAvatarMaterialLayerState2.layerColor))
		{
			return false;
		}
		if (!VectorEquals(sampleParameters, ovrAvatarMaterialLayerState2.sampleParameters))
		{
			return false;
		}
		if (sampleTexture != ovrAvatarMaterialLayerState2.sampleTexture)
		{
			return false;
		}
		if (!VectorEquals(sampleScaleOffset, ovrAvatarMaterialLayerState2.sampleScaleOffset))
		{
			return false;
		}
		if (!VectorEquals(maskParameters, ovrAvatarMaterialLayerState2.maskParameters))
		{
			return false;
		}
		if (!VectorEquals(maskAxis, ovrAvatarMaterialLayerState2.maskAxis))
		{
			return false;
		}
		return true;
	}

	public override int GetHashCode()
	{
		return blendMode.GetHashCode() ^ sampleMode.GetHashCode() ^ maskType.GetHashCode() ^ layerColor.GetHashCode() ^ sampleParameters.GetHashCode() ^ sampleTexture.GetHashCode() ^ sampleScaleOffset.GetHashCode() ^ maskParameters.GetHashCode() ^ maskAxis.GetHashCode();
	}
}
public struct ovrAvatarMaterialState
{
	public Vector4 baseColor;

	public ovrAvatarMaterialMaskType baseMaskType;

	public Vector4 baseMaskParameters;

	public Vector4 baseMaskAxis;

	public ovrAvatarMaterialLayerSampleMode sampleMode;

	public ulong alphaMaskTextureID;

	public Vector4 alphaMaskScaleOffset;

	public ulong normalMapTextureID;

	public Vector4 normalMapScaleOffset;

	public ulong parallaxMapTextureID;

	public Vector4 parallaxMapScaleOffset;

	public ulong roughnessMapTextureID;

	public Vector4 roughnessMapScaleOffset;

	public uint layerCount;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
	public ovrAvatarMaterialLayerState[] layers;

	private static bool VectorEquals(Vector4 a, Vector4 b)
	{
		if (a.x == b.x && a.y == b.y && a.z == b.z)
		{
			return a.w == b.w;
		}
		return false;
	}

	public override bool Equals(object obj)
	{
		if (!(obj is ovrAvatarMaterialState ovrAvatarMaterialState2))
		{
			return false;
		}
		if (!VectorEquals(baseColor, ovrAvatarMaterialState2.baseColor))
		{
			return false;
		}
		if (baseMaskType != ovrAvatarMaterialState2.baseMaskType)
		{
			return false;
		}
		if (!VectorEquals(baseMaskParameters, ovrAvatarMaterialState2.baseMaskParameters))
		{
			return false;
		}
		if (!VectorEquals(baseMaskAxis, ovrAvatarMaterialState2.baseMaskAxis))
		{
			return false;
		}
		if (sampleMode != ovrAvatarMaterialState2.sampleMode)
		{
			return false;
		}
		if (alphaMaskTextureID != ovrAvatarMaterialState2.alphaMaskTextureID)
		{
			return false;
		}
		if (!VectorEquals(alphaMaskScaleOffset, ovrAvatarMaterialState2.alphaMaskScaleOffset))
		{
			return false;
		}
		if (normalMapTextureID != ovrAvatarMaterialState2.normalMapTextureID)
		{
			return false;
		}
		if (!VectorEquals(normalMapScaleOffset, ovrAvatarMaterialState2.normalMapScaleOffset))
		{
			return false;
		}
		if (parallaxMapTextureID != ovrAvatarMaterialState2.parallaxMapTextureID)
		{
			return false;
		}
		if (!VectorEquals(parallaxMapScaleOffset, ovrAvatarMaterialState2.parallaxMapScaleOffset))
		{
			return false;
		}
		if (roughnessMapTextureID != ovrAvatarMaterialState2.roughnessMapTextureID)
		{
			return false;
		}
		if (!VectorEquals(roughnessMapScaleOffset, ovrAvatarMaterialState2.roughnessMapScaleOffset))
		{
			return false;
		}
		if (layerCount != ovrAvatarMaterialState2.layerCount)
		{
			return false;
		}
		for (int i = 0; i < layerCount; i++)
		{
			if (!layers[i].Equals(ovrAvatarMaterialState2.layers[i]))
			{
				return false;
			}
		}
		return true;
	}

	public override int GetHashCode()
	{
		int num = 0;
		num ^= baseColor.GetHashCode();
		num ^= baseMaskType.GetHashCode();
		num ^= baseMaskParameters.GetHashCode();
		num ^= baseMaskAxis.GetHashCode();
		num ^= sampleMode.GetHashCode();
		num ^= alphaMaskTextureID.GetHashCode();
		num ^= alphaMaskScaleOffset.GetHashCode();
		num ^= normalMapTextureID.GetHashCode();
		num ^= normalMapScaleOffset.GetHashCode();
		num ^= parallaxMapTextureID.GetHashCode();
		num ^= parallaxMapScaleOffset.GetHashCode();
		num ^= roughnessMapTextureID.GetHashCode();
		num ^= roughnessMapScaleOffset.GetHashCode();
		num ^= layerCount.GetHashCode();
		for (int i = 0; i < layerCount; i++)
		{
			num ^= layers[i].GetHashCode();
		}
		return num;
	}
}
public struct ovrAvatarExpressiveParameters
{
	public Vector4 irisColor;

	public Vector4 scleraColor;

	public Vector4 lashColor;

	public Vector4 browColor;

	public Vector4 lipColor;

	public Vector4 teethColor;

	public Vector4 gumColor;

	public float browLashIntensity;

	public float lipSmoothness;

	private static bool VectorEquals(Vector4 a, Vector4 b)
	{
		if (a.x == b.x && a.y == b.y && a.z == b.z)
		{
			return a.w == b.w;
		}
		return false;
	}

	public override bool Equals(object obj)
	{
		if (!(obj is ovrAvatarExpressiveParameters ovrAvatarExpressiveParameters2))
		{
			return false;
		}
		if (!VectorEquals(irisColor, ovrAvatarExpressiveParameters2.irisColor))
		{
			return false;
		}
		if (!VectorEquals(scleraColor, ovrAvatarExpressiveParameters2.scleraColor))
		{
			return false;
		}
		if (!VectorEquals(lashColor, ovrAvatarExpressiveParameters2.lashColor))
		{
			return false;
		}
		if (!VectorEquals(browColor, ovrAvatarExpressiveParameters2.browColor))
		{
			return false;
		}
		if (!VectorEquals(lipColor, ovrAvatarExpressiveParameters2.lipColor))
		{
			return false;
		}
		if (!VectorEquals(teethColor, ovrAvatarExpressiveParameters2.teethColor))
		{
			return false;
		}
		if (!VectorEquals(gumColor, ovrAvatarExpressiveParameters2.gumColor))
		{
			return false;
		}
		if (browLashIntensity != ovrAvatarExpressiveParameters2.browLashIntensity)
		{
			return false;
		}
		if (lipSmoothness != ovrAvatarExpressiveParameters2.lipSmoothness)
		{
			return false;
		}
		return true;
	}

	public override int GetHashCode()
	{
		return irisColor.GetHashCode() ^ scleraColor.GetHashCode() ^ lashColor.GetHashCode() ^ browColor.GetHashCode() ^ lipColor.GetHashCode() ^ teethColor.GetHashCode() ^ gumColor.GetHashCode() ^ browLashIntensity.GetHashCode() ^ lipSmoothness.GetHashCode();
	}
}
public struct ovrAvatarPBSMaterialState
{
	public Vector4 baseColor;

	public ulong albedoTextureID;

	public Vector4 albedoMultiplier;

	public ulong metallicnessTextureID;

	public float glossinessScale;

	public ulong normalTextureID;

	public ulong heightTextureID;

	public ulong occlusionTextureID;

	public ulong emissionTextureID;

	public Vector4 emissionMultiplier;

	public ulong detailMaskTextureID;

	public ulong detailAlbedoTextureID;

	public ulong detailNormalTextureID;

	private static bool VectorEquals(Vector4 a, Vector4 b)
	{
		if (a.x == b.x && a.y == b.y && a.z == b.z)
		{
			return a.w == b.w;
		}
		return false;
	}

	public override bool Equals(object obj)
	{
		if (!(obj is ovrAvatarPBSMaterialState ovrAvatarPBSMaterialState2))
		{
			return false;
		}
		if (!VectorEquals(baseColor, ovrAvatarPBSMaterialState2.baseColor))
		{
			return false;
		}
		if (albedoTextureID != ovrAvatarPBSMaterialState2.albedoTextureID)
		{
			return false;
		}
		if (!VectorEquals(albedoMultiplier, ovrAvatarPBSMaterialState2.albedoMultiplier))
		{
			return false;
		}
		if (metallicnessTextureID != ovrAvatarPBSMaterialState2.metallicnessTextureID)
		{
			return false;
		}
		if (glossinessScale != ovrAvatarPBSMaterialState2.glossinessScale)
		{
			return false;
		}
		if (normalTextureID != ovrAvatarPBSMaterialState2.normalTextureID)
		{
			return false;
		}
		if (heightTextureID != ovrAvatarPBSMaterialState2.heightTextureID)
		{
			return false;
		}
		if (occlusionTextureID != ovrAvatarPBSMaterialState2.occlusionTextureID)
		{
			return false;
		}
		if (emissionTextureID != ovrAvatarPBSMaterialState2.emissionTextureID)
		{
			return false;
		}
		if (!VectorEquals(emissionMultiplier, ovrAvatarPBSMaterialState2.emissionMultiplier))
		{
			return false;
		}
		if (detailMaskTextureID != ovrAvatarPBSMaterialState2.detailMaskTextureID)
		{
			return false;
		}
		if (detailAlbedoTextureID != ovrAvatarPBSMaterialState2.detailAlbedoTextureID)
		{
			return false;
		}
		if (detailNormalTextureID != ovrAvatarPBSMaterialState2.detailNormalTextureID)
		{
			return false;
		}
		return true;
	}

	public override int GetHashCode()
	{
		return baseColor.GetHashCode() ^ albedoTextureID.GetHashCode() ^ albedoMultiplier.GetHashCode() ^ metallicnessTextureID.GetHashCode() ^ glossinessScale.GetHashCode() ^ normalTextureID.GetHashCode() ^ heightTextureID.GetHashCode() ^ occlusionTextureID.GetHashCode() ^ emissionTextureID.GetHashCode() ^ emissionMultiplier.GetHashCode() ^ detailMaskTextureID.GetHashCode() ^ detailAlbedoTextureID.GetHashCode() ^ detailNormalTextureID.GetHashCode();
	}
}
public class OvrAvatarAssetMaterial : OvrAvatarAsset
{
	public ovrAvatarMaterialState material;

	public OvrAvatarAssetMaterial(ulong id, IntPtr mat)
	{
		assetID = id;
		material = Oculus.Avatar.CAPI.ovrAvatarAsset_GetMaterialState(mat);
	}
}
public struct ovrAvatarSkinnedMeshPose
{
	public uint jointCount;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 64)]
	public ovrAvatarTransform[] jointTransform;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 64)]
	public int[] jointParents;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 64)]
	public IntPtr[] jointNames;
}
[Flags]
public enum ovrAvatarVisibilityFlags
{
	FirstPerson = 1,
	ThirdPerson = 2,
	SelfOccluding = 4
}
public struct ovrAvatarRenderPart_SkinnedMeshRender
{
	public ovrAvatarTransform localTransform;

	public ovrAvatarVisibilityFlags visibilityMask;

	public ulong meshAssetID;

	public ovrAvatarMaterialState materialState;

	public ovrAvatarSkinnedMeshPose skinnedPose;
}
public struct ovrAvatarRenderPart_SkinnedMeshRenderPBS
{
	public ovrAvatarTransform localTransform;

	public ovrAvatarVisibilityFlags visibilityMask;

	public ulong meshAssetID;

	public ulong albedoTextureAssetID;

	public ulong surfaceTextureAssetID;

	public ovrAvatarSkinnedMeshPose skinnedPose;
}
public struct ovrAvatarRenderPart_ProjectorRender
{
	public ovrAvatarTransform localTransform;

	public uint componentIndex;

	public uint renderPartIndex;

	public ovrAvatarMaterialState materialState;
}
public struct ovrAvatarRenderPart_SkinnedMeshRenderPBS_V2
{
	public ovrAvatarTransform localTransform;

	public ovrAvatarVisibilityFlags visibilityMask;

	public ulong meshAssetID;

	public ovrAvatarPBSMaterialState materialState;

	public ovrAvatarSkinnedMeshPose skinnedPose;
}
public enum ovrAvatarHandGesture
{
	Default,
	GripSphere,
	GripCube,
	Count
}
public enum ovrAvatarBodyPartType
{
	Body,
	Clothing,
	Eyewear,
	Hair,
	Beard,
	Count
}
public struct ovrAvatarBlendShapeParams
{
	public uint blendShapeParamCount;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 64)]
	public float[] blendShapeParams;
}
[StructLayout(LayoutKind.Sequential, Size = 1)]
internal struct ovrAvatarBlendShapeParams_Offsets
{
	public static int blendShapeParamCount = Marshal.OffsetOf(typeof(ovrAvatarBlendShapeParams), "blendShapeParamCount").ToInt32();

	public static long blendShapeParams = Marshal.SizeOf(typeof(uint));
}
public struct ovrAvatarVisemes
{
	public uint visemeParamCount;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 32)]
	public float[] visemeParams;
}
[StructLayout(LayoutKind.Sequential, Size = 1)]
internal struct ovrAvatarVisemes_Offsets
{
	public static int visemeParamCount = Marshal.OffsetOf(typeof(ovrAvatarVisemes), "visemeParamCount").ToInt32();

	public static long visemeParams = Marshal.SizeOf(typeof(uint));
}
public enum ovrAvatarGazeTargetType
{
	AvatarHead,
	AvatarHand,
	Object,
	ObjectStatic,
	Count
}
public struct ovrAvatarGazeTarget
{
	public uint id;

	public Vector3 worldPosition;

	public ovrAvatarGazeTargetType type;
}
[StructLayout(LayoutKind.Sequential, Size = 1)]
internal struct ovrAvatarGazeTarget_Offsets
{
	public static int id = 0;

	public static int worldPosition = Marshal.SizeOf(typeof(uint));

	public static int type = worldPosition + Marshal.SizeOf(typeof(Vector3));
}
public struct ovrAvatarGazeTargets
{
	public uint targetCount;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 128)]
	public ovrAvatarGazeTarget[] targets;
}
[StructLayout(LayoutKind.Sequential, Size = 1)]
internal struct ovrAvatarGazeTargets_Offsets
{
	public static int targetCount = Marshal.OffsetOf(typeof(ovrAvatarGazeTargets), "targetCount").ToInt32();

	public static long targets = Marshal.SizeOf(typeof(uint));
}
public enum ovrAvatarLightType
{
	Point,
	Direction,
	Spot,
	Count
}
public struct ovrAvatarLight
{
	public uint id;

	public ovrAvatarLightType type;

	public float intensity;

	public Vector3 worldDirection;

	public Vector3 worldPosition;

	public float range;

	public float spotAngleDeg;
}
[StructLayout(LayoutKind.Sequential, Size = 1)]
internal struct ovrAvatarLight_Offsets
{
	public static long id = Marshal.OffsetOf(typeof(ovrAvatarLight), "id").ToInt64();

	public static long type = Marshal.OffsetOf(typeof(ovrAvatarLight), "type").ToInt64();

	public static long intensity = Marshal.OffsetOf(typeof(ovrAvatarLight), "intensity").ToInt64();

	public static long worldDirection = Marshal.OffsetOf(typeof(ovrAvatarLight), "worldDirection").ToInt64();

	public static long worldPosition = Marshal.OffsetOf(typeof(ovrAvatarLight), "worldPosition").ToInt64();

	public static long range = Marshal.OffsetOf(typeof(ovrAvatarLight), "range").ToInt64();

	public static long spotAngleDeg = Marshal.OffsetOf(typeof(ovrAvatarLight), "spotAngleDeg").ToInt64();
}
public struct ovrAvatarLights
{
	public float ambientIntensity;

	public uint lightCount;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
	public ovrAvatarLight[] lights;
}
[StructLayout(LayoutKind.Sequential, Size = 1)]
internal struct ovrAvatarLights_Offsets
{
	public static long ambientIntensity = Marshal.OffsetOf(typeof(ovrAvatarLights), "ambientIntensity").ToInt64();

	public static long lightCount = Marshal.OffsetOf(typeof(ovrAvatarLights), "lightCount").ToInt64();

	public static long lights = Marshal.OffsetOf(typeof(ovrAvatarLights), "lights").ToInt64();
}
[Flags]
public enum ovrAvatarDebugContext : uint
{
	None = 0u,
	GazeTarget = 1u,
	Any = uint.MaxValue
}
public struct ovrAvatarDebugLine
{
	public Vector3 startPoint;

	public Vector3 endPoint;

	public Vector3 color;

	public ovrAvatarDebugContext context;

	public IntPtr text;
}
public struct ovrAvatarDebugTransform
{
	public ovrAvatarTransform transform;

	public ovrAvatarDebugContext context;

	public IntPtr text;
}
public delegate void specificationCallback(IntPtr specification);
public delegate void assetLoadedCallback(OvrAvatarAsset asset);
public delegate void combinedMeshLoadedCallback(IntPtr asset);
public class OvrAvatarSDKManager : MonoBehaviour
{
	public struct AvatarSpecRequestParams
	{
		public ulong _userId;

		public specificationCallback _callback;

		public bool _useCombinedMesh;

		public ovrAvatarAssetLevelOfDetail _lod;

		public bool _forceMobileTextureFormat;

		public ovrAvatarLookAndFeelVersion _lookVersion;

		public ovrAvatarLookAndFeelVersion _fallbackVersion;

		public bool _enableExpressive;

		public AvatarSpecRequestParams(ulong userId, specificationCallback callback, bool useCombinedMesh, ovrAvatarAssetLevelOfDetail lod, bool forceMobileTextureFormat, ovrAvatarLookAndFeelVersion lookVersion, ovrAvatarLookAndFeelVersion fallbackVersion, bool enableExpressive)
		{
			_userId = userId;
			_callback = callback;
			_useCombinedMesh = useCombinedMesh;
			_lod = lod;
			_forceMobileTextureFormat = forceMobileTextureFormat;
			_lookVersion = lookVersion;
			_fallbackVersion = fallbackVersion;
			_enableExpressive = enableExpressive;
		}
	}

	private static OvrAvatarSDKManager _instance;

	private bool initialized;

	private Dictionary<ulong, HashSet<specificationCallback>> specificationCallbacks;

	private Dictionary<ulong, HashSet<assetLoadedCallback>> assetLoadedCallbacks;

	private Dictionary<IntPtr, combinedMeshLoadedCallback> combinedMeshLoadedCallbacks;

	private Dictionary<ulong, OvrAvatarAsset> assetCache;

	private OvrAvatarTextureCopyManager textureCopyManager;

	public ovrAvatarLogLevel LoggingLevel = ovrAvatarLogLevel.Info;

	private Queue<AvatarSpecRequestParams> avatarSpecificationQueue;

	private List<int> loadingAvatars;

	private bool avatarSpecRequestAvailable = true;

	private float lastDispatchedAvatarSpecRequestTime;

	private const float AVATAR_SPEC_REQUEST_TIMEOUT = 5f;

	private ovrAvatarDebugContext debugContext;

	public static OvrAvatarSDKManager Instance
	{
		get
		{
			if (_instance == null)
			{
				_instance = UnityEngine.Object.FindObjectOfType<OvrAvatarSDKManager>();
				if (_instance == null)
				{
					GameObject gameObject = new GameObject("OvrAvatarSDKManager");
					_instance = gameObject.AddComponent<OvrAvatarSDKManager>();
					_instance.textureCopyManager = gameObject.AddComponent<OvrAvatarTextureCopyManager>();
					_instance.initialized = _instance.Initialize();
				}
			}
			if (!_instance.initialized)
			{
				return null;
			}
			return _instance;
		}
	}

	private bool Initialize()
	{
		Oculus.Avatar.CAPI.Initialize();
		string appId = GetAppId();
		if (appId == "")
		{
			appId = "0";
			return false;
		}
		Oculus.Avatar.CAPI.ovrAvatar_InitializeAndroidUnity(appId);
		specificationCallbacks = new Dictionary<ulong, HashSet<specificationCallback>>();
		assetLoadedCallbacks = new Dictionary<ulong, HashSet<assetLoadedCallback>>();
		combinedMeshLoadedCallbacks = new Dictionary<IntPtr, combinedMeshLoadedCallback>();
		assetCache = new Dictionary<ulong, OvrAvatarAsset>();
		avatarSpecificationQueue = new Queue<AvatarSpecRequestParams>();
		loadingAvatars = new List<int>();
		Oculus.Avatar.CAPI.ovrAvatar_SetLoggingLevel(LoggingLevel);
		Oculus.Avatar.CAPI.ovrAvatar_RegisterLoggingCallback(Oculus.Avatar.CAPI.LoggingCallback);
		return true;
	}

	private void OnDestroy()
	{
		Oculus.Avatar.CAPI.Shutdown();
		Oculus.Avatar.CAPI.ovrAvatar_RegisterLoggingCallback(null);
		Oculus.Avatar.CAPI.ovrAvatar_Shutdown();
	}

	private void Update()
	{
		if (Instance == null)
		{
			return;
		}
		if (avatarSpecificationQueue.Count > 0 && (avatarSpecRequestAvailable || Time.time - lastDispatchedAvatarSpecRequestTime >= 5f))
		{
			avatarSpecRequestAvailable = false;
			AvatarSpecRequestParams avatarSpecRequest = avatarSpecificationQueue.Dequeue();
			DispatchAvatarSpecificationRequest(avatarSpecRequest);
			lastDispatchedAvatarSpecRequestTime = Time.time;
		}
		IntPtr intPtr = Oculus.Avatar.CAPI.ovrAvatarMessage_Pop();
		if (intPtr == IntPtr.Zero)
		{
			return;
		}
		ovrAvatarMessageType ovrAvatarMessageType2 = Oculus.Avatar.CAPI.ovrAvatarMessage_GetType(intPtr);
		switch (ovrAvatarMessageType2)
		{
		case ovrAvatarMessageType.AssetLoaded:
		{
			ovrAvatarMessage_AssetLoaded ovrAvatarMessage_AssetLoaded2 = Oculus.Avatar.CAPI.ovrAvatarMessage_GetAssetLoaded(intPtr);
			IntPtr asset = ovrAvatarMessage_AssetLoaded2.asset;
			ulong assetID = ovrAvatarMessage_AssetLoaded2.assetID;
			ovrAvatarAssetType ovrAvatarAssetType2 = Oculus.Avatar.CAPI.ovrAvatarAsset_GetType(asset);
			OvrAvatarAsset ovrAvatarAsset = null;
			IntPtr key = IntPtr.Zero;
			switch (ovrAvatarAssetType2)
			{
			case ovrAvatarAssetType.Mesh:
				ovrAvatarAsset = new OvrAvatarAssetMesh(assetID, asset, ovrAvatarAssetType.Mesh);
				break;
			case ovrAvatarAssetType.Texture:
				ovrAvatarAsset = new OvrAvatarAssetTexture(assetID, asset);
				break;
			case ovrAvatarAssetType.Material:
				ovrAvatarAsset = new OvrAvatarAssetMaterial(assetID, asset);
				break;
			case ovrAvatarAssetType.CombinedMesh:
				key = Oculus.Avatar.CAPI.ovrAvatarAsset_GetAvatar(asset);
				ovrAvatarAsset = new OvrAvatarAssetMesh(assetID, asset, ovrAvatarAssetType.CombinedMesh);
				break;
			default:
				throw new NotImplementedException($"Unsupported asset type format {ovrAvatarAssetType2.ToString()}");
			case ovrAvatarAssetType.FailedLoad:
				break;
			}
			if (ovrAvatarAssetType2 == ovrAvatarAssetType.CombinedMesh)
			{
				if (!assetCache.ContainsKey(assetID))
				{
					assetCache.Add(assetID, ovrAvatarAsset);
				}
				if (combinedMeshLoadedCallbacks.TryGetValue(key, out var value2))
				{
					value2(asset);
					combinedMeshLoadedCallbacks.Remove(key);
				}
			}
			else
			{
				if (ovrAvatarAsset == null || !assetLoadedCallbacks.TryGetValue(ovrAvatarMessage_AssetLoaded2.assetID, out var value3))
				{
					break;
				}
				assetCache.Add(assetID, ovrAvatarAsset);
				foreach (assetLoadedCallback item in value3)
				{
					item(ovrAvatarAsset);
				}
				assetLoadedCallbacks.Remove(ovrAvatarMessage_AssetLoaded2.assetID);
			}
			break;
		}
		case ovrAvatarMessageType.AvatarSpecification:
		{
			avatarSpecRequestAvailable = true;
			ovrAvatarMessage_AvatarSpecification ovrAvatarMessage_AvatarSpecification2 = Oculus.Avatar.CAPI.ovrAvatarMessage_GetAvatarSpecification(intPtr);
			if (!specificationCallbacks.TryGetValue(ovrAvatarMessage_AvatarSpecification2.oculusUserID, out var value))
			{
				break;
			}
			foreach (specificationCallback item2 in value)
			{
				item2(ovrAvatarMessage_AvatarSpecification2.avatarSpec);
			}
			specificationCallbacks.Remove(ovrAvatarMessage_AvatarSpecification2.oculusUserID);
			break;
		}
		default:
			throw new NotImplementedException("Unhandled ovrAvatarMessageType: " + ovrAvatarMessageType2);
		}
		Oculus.Avatar.CAPI.ovrAvatarMessage_Free(intPtr);
	}

	public bool IsAvatarSpecWaiting()
	{
		return avatarSpecificationQueue.Count > 0;
	}

	public bool IsAvatarLoading()
	{
		return loadingAvatars.Count > 0;
	}

	public void AddLoadingAvatar(int gameobjectID)
	{
		loadingAvatars.Add(gameobjectID);
	}

	public void RemoveLoadingAvatar(int gameobjectID)
	{
		loadingAvatars.Remove(gameobjectID);
	}

	public void RequestAvatarSpecification(AvatarSpecRequestParams avatarSpecRequest)
	{
		avatarSpecificationQueue.Enqueue(avatarSpecRequest);
	}

	private void DispatchAvatarSpecificationRequest(AvatarSpecRequestParams avatarSpecRequest)
	{
		textureCopyManager.CheckFallbackTextureSet(avatarSpecRequest._lod);
		Oculus.Avatar.CAPI.ovrAvatar_SetForceASTCTextures(avatarSpecRequest._forceMobileTextureFormat);
		if (!specificationCallbacks.TryGetValue(avatarSpecRequest._userId, out var value))
		{
			value = new HashSet<specificationCallback>();
			specificationCallbacks.Add(avatarSpecRequest._userId, value);
			IntPtr specificationRequest = Oculus.Avatar.CAPI.ovrAvatarSpecificationRequest_Create(avatarSpecRequest._userId);
			Oculus.Avatar.CAPI.ovrAvatarSpecificationRequest_SetLookAndFeelVersion(specificationRequest, avatarSpecRequest._lookVersion);
			Oculus.Avatar.CAPI.ovrAvatarSpecificationRequest_SetFallbackLookAndFeelVersion(specificationRequest, avatarSpecRequest._fallbackVersion);
			Oculus.Avatar.CAPI.ovrAvatarSpecificationRequest_SetLevelOfDetail(specificationRequest, avatarSpecRequest._lod);
			Oculus.Avatar.CAPI.ovrAvatarSpecificationRequest_SetCombineMeshes(specificationRequest, avatarSpecRequest._useCombinedMesh);
			Oculus.Avatar.CAPI.ovrAvatarSpecificationRequest_SetExpressiveFlag(specificationRequest, avatarSpecRequest._enableExpressive);
			Oculus.Avatar.CAPI.ovrAvatar_RequestAvatarSpecificationFromSpecRequest(specificationRequest);
			Oculus.Avatar.CAPI.ovrAvatarSpecificationRequest_Destroy(specificationRequest);
		}
		value.Add(avatarSpecRequest._callback);
	}

	public void BeginLoadingAsset(ulong assetId, ovrAvatarAssetLevelOfDetail lod, assetLoadedCallback callback)
	{
		if (!assetLoadedCallbacks.TryGetValue(assetId, out var value))
		{
			value = new HashSet<assetLoadedCallback>();
			assetLoadedCallbacks.Add(assetId, value);
		}
		Oculus.Avatar.CAPI.ovrAvatarAsset_BeginLoadingLOD(assetId, lod);
		value.Add(callback);
	}

	public void RegisterCombinedMeshCallback(IntPtr sdkAvatar, combinedMeshLoadedCallback callback)
	{
		if (!combinedMeshLoadedCallbacks.TryGetValue(sdkAvatar, out var _))
		{
			combinedMeshLoadedCallbacks.Add(sdkAvatar, callback);
			return;
		}
		throw new Exception("Adding second combind mesh callback for same avatar");
	}

	public OvrAvatarAsset GetAsset(ulong assetId)
	{
		if (assetCache.TryGetValue(assetId, out var value))
		{
			return value;
		}
		return null;
	}

	public void DeleteAssetFromCache(ulong assetId)
	{
		if (assetCache.ContainsKey(assetId))
		{
			assetCache.Remove(assetId);
		}
	}

	public string GetAppId()
	{
		if (UnityEngine.Application.platform != RuntimePlatform.Android)
		{
			return OvrAvatarSettings.AppID;
		}
		return OvrAvatarSettings.MobileAppID;
	}

	public OvrAvatarTextureCopyManager GetTextureCopyManager()
	{
		if (textureCopyManager != null)
		{
			return textureCopyManager;
		}
		return null;
	}
}
public sealed class OvrAvatarSettings : ScriptableObject
{
	private static OvrAvatarSettings instance;

	[SerializeField]
	private string ovrAppID = "";

	[SerializeField]
	private string ovrGearAppID = "";

	public static string AppID
	{
		get
		{
			return Instance.ovrAppID;
		}
		set
		{
			Instance.ovrAppID = value;
		}
	}

	public static string MobileAppID
	{
		get
		{
			return Instance.ovrGearAppID;
		}
		set
		{
			Instance.ovrGearAppID = value;
		}
	}

	public static OvrAvatarSettings Instance
	{
		get
		{
			if (instance == null)
			{
				instance = Resources.Load<OvrAvatarSettings>("OvrAvatarSettings");
				if (instance == null)
				{
					instance = ScriptableObject.CreateInstance<OvrAvatarSettings>();
				}
			}
			return instance;
		}
		set
		{
			instance = value;
		}
	}
}
public class OvrAvatarSkinnedMeshRenderComponent : OvrAvatarRenderComponent
{
	private Shader surface;

	private Shader surfaceSelfOccluding;

	private bool previouslyActive;

	internal void Initialize(ovrAvatarRenderPart_SkinnedMeshRender skinnedMeshRender, Shader surface, Shader surfaceSelfOccluding, int thirdPersonLayer, int firstPersonLayer)
	{
		this.surfaceSelfOccluding = ((surfaceSelfOccluding != null) ? surfaceSelfOccluding : Shader.Find("OvrAvatar/AvatarSurfaceShaderSelfOccluding"));
		this.surface = ((surface != null) ? surface : Shader.Find("OvrAvatar/AvatarSurfaceShader"));
		mesh = CreateSkinnedMesh(skinnedMeshRender.meshAssetID, skinnedMeshRender.visibilityMask, thirdPersonLayer, firstPersonLayer);
		bones = mesh.bones;
		UpdateMeshMaterial(skinnedMeshRender.visibilityMask, mesh);
	}

	public void UpdateSkinnedMeshRender(OvrAvatarComponent component, OvrAvatar avatar, IntPtr renderPart)
	{
		ovrAvatarVisibilityFlags visibilityMask = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRender_GetVisibilityMask(renderPart);
		ovrAvatarTransform localTransform = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRender_GetTransform(renderPart);
		UpdateSkinnedMesh(avatar, bones, localTransform, visibilityMask, renderPart);
		UpdateMeshMaterial(visibilityMask, mesh);
		bool activeSelf = base.gameObject.activeSelf;
		if (mesh != null && (Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRender_MaterialStateChanged(renderPart) || (!previouslyActive && activeSelf)))
		{
			ovrAvatarMaterialState matState = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRender_GetMaterialState(renderPart);
			component.UpdateAvatarMaterial(mesh.sharedMaterial, matState);
		}
		previouslyActive = activeSelf;
	}

	private void UpdateMeshMaterial(ovrAvatarVisibilityFlags visibilityMask, SkinnedMeshRenderer rootMesh)
	{
		Shader shader = (((visibilityMask & ovrAvatarVisibilityFlags.SelfOccluding) != 0) ? surfaceSelfOccluding : surface);
		if (rootMesh.sharedMaterial == null || rootMesh.sharedMaterial.shader != shader)
		{
			rootMesh.sharedMaterial = CreateAvatarMaterial(base.gameObject.name + "_material", shader);
		}
	}
}
public class OvrAvatarSkinnedMeshRenderPBSComponent : OvrAvatarRenderComponent
{
	private bool isMaterialInitilized;

	internal void Initialize(ovrAvatarRenderPart_SkinnedMeshRenderPBS skinnedMeshRenderPBS, Shader shader, int thirdPersonLayer, int firstPersonLayer)
	{
		if (shader == null)
		{
			shader = Shader.Find("OvrAvatar/AvatarSurfaceShaderPBS");
		}
		mesh = CreateSkinnedMesh(skinnedMeshRenderPBS.meshAssetID, skinnedMeshRenderPBS.visibilityMask, thirdPersonLayer, firstPersonLayer);
		mesh.sharedMaterial = CreateAvatarMaterial(base.gameObject.name + "_material", shader);
		bones = mesh.bones;
	}

	internal void UpdateSkinnedMeshRenderPBS(OvrAvatar avatar, IntPtr renderPart, Material mat)
	{
		if (!isMaterialInitilized)
		{
			isMaterialInitilized = true;
			ulong assetId = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBS_GetAlbedoTextureAssetID(renderPart);
			ulong assetId2 = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBS_GetSurfaceTextureAssetID(renderPart);
			mat.SetTexture("_Albedo", OvrAvatarComponent.GetLoadedTexture(assetId));
			mat.SetTexture("_Surface", OvrAvatarComponent.GetLoadedTexture(assetId2));
		}
		ovrAvatarVisibilityFlags visibilityMask = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBS_GetVisibilityMask(renderPart);
		ovrAvatarTransform localTransform = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBS_GetTransform(renderPart);
		UpdateSkinnedMesh(avatar, bones, localTransform, visibilityMask, renderPart);
	}
}
public class OvrAvatarSkinnedMeshPBSV2RenderComponent : OvrAvatarRenderComponent
{
	private OvrAvatarMaterialManager avatarMaterialManager;

	private bool previouslyActive;

	private bool isCombinedMaterial;

	private ovrAvatarExpressiveParameters ExpressiveParameters;

	private bool EnableExpressive;

	private int blendShapeCount;

	private ovrAvatarBlendShapeParams blendShapeParams;

	private const string MAIN_MATERIAL_NAME = "main_material";

	private const string EYE_MATERIAL_NAME = "eye_material";

	private const string DEFAULT_MATERIAL_NAME = "_material";

	internal void Initialize(IntPtr renderPart, ovrAvatarRenderPart_SkinnedMeshRenderPBS_V2 skinnedMeshRender, OvrAvatarMaterialManager materialManager, int thirdPersonLayer, int firstPersonLayer, bool combinedMesh, ovrAvatarAssetLevelOfDetail lod, bool assignExpressiveParams, OvrAvatar avatar, bool isControllerModel)
	{
		avatarMaterialManager = materialManager;
		isCombinedMaterial = combinedMesh;
		mesh = CreateSkinnedMesh(skinnedMeshRender.meshAssetID, skinnedMeshRender.visibilityMask, thirdPersonLayer, firstPersonLayer);
		EnableExpressive = assignExpressiveParams;
		Shader shader = (EnableExpressive ? avatar.Skinshaded_Expressive_VertFrag_SingleComponent : avatar.Skinshaded_VertFrag_SingleComponent);
		Shader shader2 = (EnableExpressive ? avatar.Skinshaded_Expressive_VertFrag_CombinedMesh : avatar.Skinshaded_VertFrag_CombinedMesh);
		Shader shader3 = (isCombinedMaterial ? shader2 : shader);
		if (isControllerModel)
		{
			shader3 = avatar.ControllerShader;
		}
		if (EnableExpressive)
		{
			ExpressiveParameters = Oculus.Avatar.CAPI.ovrAvatar_GetExpressiveParameters(avatar.sdkAvatar);
			Shader eyeLens = avatar.EyeLens;
			Material[] array = new Material[2]
			{
				CreateAvatarMaterial(base.gameObject.name + "main_material", shader3),
				CreateAvatarMaterial(base.gameObject.name + "eye_material", eyeLens)
			};
			if (avatar.UseTransparentRenderQueue)
			{
				SetMaterialTransparent(array[0]);
			}
			else
			{
				SetMaterialOpaque(array[0]);
			}
			array[1].renderQueue = -1;
			mesh.materials = array;
		}
		else
		{
			mesh.sharedMaterial = CreateAvatarMaterial(base.gameObject.name + "_material", shader3);
			if (avatar.UseTransparentRenderQueue && !isControllerModel)
			{
				SetMaterialTransparent(mesh.sharedMaterial);
			}
			else
			{
				SetMaterialOpaque(mesh.sharedMaterial);
			}
		}
		bones = mesh.bones;
		if (isCombinedMaterial)
		{
			avatarMaterialManager.SetRenderer(mesh);
			InitializeCombinedMaterial(renderPart, (int)lod);
			avatarMaterialManager.OnCombinedMeshReady();
		}
		blendShapeParams = default(ovrAvatarBlendShapeParams);
		blendShapeParams.blendShapeParamCount = 0u;
		blendShapeParams.blendShapeParams = new float[64];
		blendShapeCount = mesh.sharedMesh.blendShapeCount;
	}

	public void UpdateSkinnedMeshRender(OvrAvatarComponent component, OvrAvatar avatar, IntPtr renderPart)
	{
		ovrAvatarVisibilityFlags visibilityMask = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBSV2_GetVisibilityMask(renderPart);
		ovrAvatarTransform localTransform = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBSV2_GetTransform(renderPart);
		UpdateSkinnedMesh(avatar, bones, localTransform, visibilityMask, renderPart);
		bool activeSelf = base.gameObject.activeSelf;
		if (mesh != null && !previouslyActive && activeSelf && !isCombinedMaterial)
		{
			InitializeSingleComponentMaterial(renderPart, (int)(avatar.LevelOfDetail - 1));
		}
		if (blendShapeCount > 0)
		{
			Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRender_GetBlendShapeParams(renderPart, ref blendShapeParams);
			for (uint num = 0u; num < blendShapeParams.blendShapeParamCount && num < blendShapeCount; num++)
			{
				float num2 = blendShapeParams.blendShapeParams[num];
				mesh.SetBlendShapeWeight((int)num, num2 * 100f);
			}
		}
		previouslyActive = activeSelf;
	}

	private void InitializeSingleComponentMaterial(IntPtr renderPart, int lodIndex)
	{
		ovrAvatarPBSMaterialState ovrAvatarPBSMaterialState2 = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBSV2_GetPBSMaterialState(renderPart);
		int componentType = (int)OvrAvatarMaterialManager.GetComponentType(base.gameObject.name);
		Texture2D texture2D = OvrAvatarComponent.GetLoadedTexture(ovrAvatarPBSMaterialState2.albedoTextureID);
		Texture2D texture2D2 = OvrAvatarComponent.GetLoadedTexture(ovrAvatarPBSMaterialState2.normalTextureID);
		Texture2D texture2D3 = OvrAvatarComponent.GetLoadedTexture(ovrAvatarPBSMaterialState2.metallicnessTextureID);
		if (texture2D != null)
		{
			avatarMaterialManager.AddTextureIDToTextureManager(ovrAvatarPBSMaterialState2.albedoTextureID, isSingleComponent: true);
		}
		else
		{
			texture2D = OvrAvatarSDKManager.Instance.GetTextureCopyManager().FallbackTextureSets[lodIndex].DiffuseRoughness;
		}
		texture2D.anisoLevel = 4;
		if (texture2D2 != null)
		{
			avatarMaterialManager.AddTextureIDToTextureManager(ovrAvatarPBSMaterialState2.normalTextureID, isSingleComponent: true);
		}
		else
		{
			texture2D2 = OvrAvatarSDKManager.Instance.GetTextureCopyManager().FallbackTextureSets[lodIndex].Normal;
		}
		texture2D2.anisoLevel = 4;
		if (texture2D3 != null)
		{
			avatarMaterialManager.AddTextureIDToTextureManager(ovrAvatarPBSMaterialState2.metallicnessTextureID, isSingleComponent: true);
		}
		else
		{
			texture2D3 = OvrAvatarSDKManager.Instance.GetTextureCopyManager().FallbackTextureSets[lodIndex].DiffuseRoughness;
		}
		texture2D3.anisoLevel = 16;
		mesh.materials[0].SetTexture(OvrAvatarMaterialManager.AVATAR_SHADER_MAINTEX, texture2D);
		mesh.materials[0].SetTexture(OvrAvatarMaterialManager.AVATAR_SHADER_NORMALMAP, texture2D2);
		mesh.materials[0].SetTexture(OvrAvatarMaterialManager.AVATAR_SHADER_ROUGHNESSMAP, texture2D3);
		mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_COLOR, ovrAvatarPBSMaterialState2.albedoMultiplier);
		mesh.materials[0].SetFloat(OvrAvatarMaterialManager.AVATAR_SHADER_DIFFUSEINTENSITY, OvrAvatarMaterialManager.DiffuseIntensities[componentType]);
		mesh.materials[0].SetFloat(OvrAvatarMaterialManager.AVATAR_SHADER_RIMINTENSITY, OvrAvatarMaterialManager.RimIntensities[componentType]);
		mesh.materials[0].SetFloat(OvrAvatarMaterialManager.AVATAR_SHADER_REFLECTIONINTENSITY, OvrAvatarMaterialManager.ReflectionIntensities[componentType]);
		mesh.GetClosestReflectionProbes(avatarMaterialManager.ReflectionProbes);
		if (avatarMaterialManager.ReflectionProbes != null && avatarMaterialManager.ReflectionProbes.Count > 0)
		{
			mesh.materials[0].SetTexture(OvrAvatarMaterialManager.AVATAR_SHADER_CUBEMAP, avatarMaterialManager.ReflectionProbes[0].probe.texture);
		}
		if (EnableExpressive)
		{
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_IRIS_COLOR, ExpressiveParameters.irisColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_LIP_COLOR, ExpressiveParameters.lipColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_BROW_COLOR, ExpressiveParameters.browColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_LASH_COLOR, ExpressiveParameters.lashColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_SCLERA_COLOR, ExpressiveParameters.scleraColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_GUM_COLOR, ExpressiveParameters.gumColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_TEETH_COLOR, ExpressiveParameters.teethColor);
			mesh.materials[0].SetFloat(OvrAvatarMaterialManager.AVATAR_SHADER_LIP_SMOOTHNESS, ExpressiveParameters.lipSmoothness);
		}
	}

	private void InitializeCombinedMaterial(IntPtr renderPart, int lodIndex)
	{
		ovrAvatarPBSMaterialState[] array = Oculus.Avatar.CAPI.ovrAvatar_GetBodyPBSMaterialStates(renderPart);
		if (array.Length != 5)
		{
			return;
		}
		avatarMaterialManager.CreateTextureArrays();
		OvrAvatarMaterialManager.AvatarComponentMaterialProperties[] componentMaterialProperties = avatarMaterialManager.LocalAvatarConfig.ComponentMaterialProperties;
		for (int i = 0; i < array.Length; i++)
		{
			componentMaterialProperties[i].TypeIndex = (ovrAvatarBodyPartType)i;
			componentMaterialProperties[i].Color = array[i].albedoMultiplier;
			componentMaterialProperties[i].DiffuseIntensity = OvrAvatarMaterialManager.DiffuseIntensities[i];
			componentMaterialProperties[i].RimIntensity = OvrAvatarMaterialManager.RimIntensities[i];
			componentMaterialProperties[i].ReflectionIntensity = OvrAvatarMaterialManager.ReflectionIntensities[i];
			Texture2D loadedTexture = OvrAvatarComponent.GetLoadedTexture(array[i].albedoTextureID);
			Texture2D loadedTexture2 = OvrAvatarComponent.GetLoadedTexture(array[i].normalTextureID);
			Texture2D loadedTexture3 = OvrAvatarComponent.GetLoadedTexture(array[i].metallicnessTextureID);
			if (loadedTexture != null)
			{
				componentMaterialProperties[i].Textures[0] = loadedTexture;
				avatarMaterialManager.AddTextureIDToTextureManager(array[i].albedoTextureID, isSingleComponent: false);
			}
			else
			{
				componentMaterialProperties[i].Textures[0] = OvrAvatarSDKManager.Instance.GetTextureCopyManager().FallbackTextureSets[lodIndex].DiffuseRoughness;
			}
			componentMaterialProperties[i].Textures[0].anisoLevel = 4;
			if (loadedTexture2 != null)
			{
				componentMaterialProperties[i].Textures[1] = loadedTexture2;
				avatarMaterialManager.AddTextureIDToTextureManager(array[i].normalTextureID, isSingleComponent: false);
			}
			else
			{
				componentMaterialProperties[i].Textures[1] = OvrAvatarSDKManager.Instance.GetTextureCopyManager().FallbackTextureSets[lodIndex].Normal;
			}
			componentMaterialProperties[i].Textures[1].anisoLevel = 4;
			if (loadedTexture3 != null)
			{
				componentMaterialProperties[i].Textures[2] = loadedTexture3;
				avatarMaterialManager.AddTextureIDToTextureManager(array[i].metallicnessTextureID, isSingleComponent: false);
			}
			else
			{
				componentMaterialProperties[i].Textures[2] = OvrAvatarSDKManager.Instance.GetTextureCopyManager().FallbackTextureSets[lodIndex].DiffuseRoughness;
			}
			componentMaterialProperties[i].Textures[2].anisoLevel = 16;
		}
		if (EnableExpressive)
		{
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_IRIS_COLOR, ExpressiveParameters.irisColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_LIP_COLOR, ExpressiveParameters.lipColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_BROW_COLOR, ExpressiveParameters.browColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_LASH_COLOR, ExpressiveParameters.lashColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_SCLERA_COLOR, ExpressiveParameters.scleraColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_GUM_COLOR, ExpressiveParameters.gumColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_TEETH_COLOR, ExpressiveParameters.teethColor);
			mesh.materials[0].SetFloat(OvrAvatarMaterialManager.AVATAR_SHADER_LIP_SMOOTHNESS, ExpressiveParameters.lipSmoothness);
		}
		avatarMaterialManager.ValidateTextures(array);
	}

	private void SetMaterialTransparent(Material mat)
	{
		mat.SetOverrideTag("Queue", "Transparent");
		mat.SetOverrideTag("RenderType", "Transparent");
		mat.SetInt("_SrcBlend", 5);
		mat.SetInt("_DstBlend", 10);
		mat.EnableKeyword("_ALPHATEST_ON");
		mat.EnableKeyword("_ALPHABLEND_ON");
		mat.EnableKeyword("_ALPHAPREMULTIPLY_ON");
		mat.renderQueue = 3000;
	}

	private void SetMaterialOpaque(Material mat)
	{
		mat.SetOverrideTag("Queue", "Geometry");
		mat.SetOverrideTag("RenderType", "Opaque");
		mat.SetInt("_SrcBlend", 1);
		mat.SetInt("_DstBlend", 0);
		mat.DisableKeyword("_ALPHATEST_ON");
		mat.DisableKeyword("_ALPHABLEND_ON");
		mat.DisableKeyword("_ALPHAPREMULTIPLY_ON");
		mat.renderQueue = 2000;
	}
}
public class OvrAvatarTextureCopyManager : MonoBehaviour
{
	[Serializable]
	public struct FallbackTextureSet
	{
		public bool Initialized;

		public Texture2D DiffuseRoughness;

		public Texture2D Normal;
	}

	private struct CopyTextureParams
	{
		public Texture Src;

		public Texture Dst;

		public int Mip;

		public int SrcSize;

		public int DstElement;

		public CopyTextureParams(Texture src, Texture dst, int mip, int srcSize, int dstElement)
		{
			Src = src;
			Dst = dst;
			Mip = mip;
			SrcSize = srcSize;
			DstElement = dstElement;
		}
	}

	public struct TextureSet
	{
		public Dictionary<ulong, bool> TextureIDSingleMeshPair;

		public bool IsProcessed;

		public TextureSet(Dictionary<ulong, bool> textureIDSingleMeshPair, bool isProcessed)
		{
			TextureIDSingleMeshPair = textureIDSingleMeshPair;
			IsProcessed = isProcessed;
		}
	}

	public FallbackTextureSet[] FallbackTextureSets = new FallbackTextureSet[6];

	private Queue<CopyTextureParams> texturesToCopy;

	private Dictionary<int, TextureSet> textureSets;

	private const int TEXTURES_TO_COPY_QUEUE_CAPACITY = 256;

	private const int COPIES_PER_FRAME = 8;

	private readonly string[] FALLBACK_TEXTURE_PATHS_DIFFUSE_ROUGHNESS = new string[6] { "null", "FallbackTextures/fallback_diffuse_roughness_256", "null", "FallbackTextures/fallback_diffuse_roughness_1024", "null", "FallbackTextures/fallback_diffuse_roughness_2048" };

	private readonly string[] FALLBACK_TEXTURE_PATHS_NORMAL = new string[6] { "null", "FallbackTextures/fallback_normal_256", "null", "FallbackTextures/fallback_normal_1024", "null", "FallbackTextures/fallback_normal_2048" };

	private const string PATH_HIGHEST_DIFFUSE_ROUGHNESS = "FallbackTextures/fallback_diffuse_roughness_2048";

	private const string PATH_MEDIUM_DIFFUSE_ROUGHNESS = "FallbackTextures/fallback_diffuse_roughness_1024";

	private const string PATH_LOWEST_DIFFUSE_ROUGHNESS = "FallbackTextures/fallback_diffuse_roughness_256";

	private const string PATH_HIGHEST_NORMAL = "FallbackTextures/fallback_normal_2048";

	private const string PATH_MEDIUM_NORMAL = "FallbackTextures/fallback_normal_1024";

	private const string PATH_LOWEST_NORMAL = "FallbackTextures/fallback_normal_256";

	private const int GPU_TEXTURE_COPY_WAIT_TIME = 10;

	public OvrAvatarTextureCopyManager()
	{
		texturesToCopy = new Queue<CopyTextureParams>(256);
		textureSets = new Dictionary<int, TextureSet>();
	}

	public void Update()
	{
		if (texturesToCopy.Count == 0)
		{
			return;
		}
		lock (texturesToCopy)
		{
			for (int i = 0; i < Mathf.Min(8, texturesToCopy.Count); i++)
			{
				CopyTexture(texturesToCopy.Dequeue());
			}
		}
	}

	public int GetTextureCount()
	{
		return texturesToCopy.Count;
	}

	public void CopyTexture(Texture src, Texture dst, int mipLevel, int mipSize, int dstElement, bool useQueue = true)
	{
		CopyTextureParams copyTextureParams = new CopyTextureParams(src, dst, mipLevel, mipSize, dstElement);
		if (useQueue)
		{
			lock (texturesToCopy)
			{
				if (texturesToCopy.Count < 256)
				{
					texturesToCopy.Enqueue(copyTextureParams);
				}
				else
				{
					CopyTexture(copyTextureParams);
				}
				return;
			}
		}
		CopyTexture(copyTextureParams);
	}

	private void CopyTexture(CopyTextureParams copyTextureParams)
	{
		Graphics.CopyTexture(copyTextureParams.Src, 0, copyTextureParams.Mip, copyTextureParams.Dst, copyTextureParams.DstElement, copyTextureParams.Mip);
	}

	public void AddTextureIDToTextureSet(int gameobjectID, ulong textureID, bool isSingleMesh)
	{
		bool value2;
		if (!textureSets.ContainsKey(gameobjectID))
		{
			TextureSet value = new TextureSet(new Dictionary<ulong, bool>(), isProcessed: false);
			value.TextureIDSingleMeshPair.Add(textureID, isSingleMesh);
			textureSets.Add(gameobjectID, value);
		}
		else if (textureSets[gameobjectID].TextureIDSingleMeshPair.TryGetValue(textureID, out value2))
		{
			if (!value2 && isSingleMesh)
			{
				textureSets[gameobjectID].TextureIDSingleMeshPair[textureID] = true;
			}
		}
		else
		{
			textureSets[gameobjectID].TextureIDSingleMeshPair.Add(textureID, isSingleMesh);
		}
	}

	public void DeleteTextureSet(int gameobjectID)
	{
		if (textureSets.TryGetValue(gameobjectID, out var value) && !value.IsProcessed)
		{
			StartCoroutine(DeleteTextureSetCoroutine(value, gameobjectID));
		}
	}

	private IEnumerator DeleteTextureSetCoroutine(TextureSet textureSetToDelete, int gameobjectID)
	{
		yield return new WaitForSeconds(10f);
		while (OvrAvatarSDKManager.Instance.IsAvatarLoading())
		{
			yield return null;
		}
		foreach (KeyValuePair<ulong, bool> item in textureSetToDelete.TextureIDSingleMeshPair)
		{
			bool flag = !item.Value;
			if (flag)
			{
				foreach (KeyValuePair<int, TextureSet> textureSet in textureSets)
				{
					if (textureSet.Key == gameobjectID)
					{
						continue;
					}
					foreach (KeyValuePair<ulong, bool> item2 in textureSet.Value.TextureIDSingleMeshPair)
					{
						if (item2.Key == item.Key && (!textureSet.Value.IsProcessed || item2.Value))
						{
							flag = false;
							break;
						}
					}
					if (!flag)
					{
						break;
					}
				}
			}
			if (flag)
			{
				Texture2D loadedTexture = OvrAvatarComponent.GetLoadedTexture(item.Key);
				if (loadedTexture != null)
				{
					OvrAvatarSDKManager.Instance.DeleteAssetFromCache(item.Key);
					UnityEngine.Object.Destroy(loadedTexture);
				}
			}
		}
		textureSetToDelete.IsProcessed = true;
		textureSets.Remove(gameobjectID);
	}

	public void CheckFallbackTextureSet(ovrAvatarAssetLevelOfDetail lod)
	{
		if (!FallbackTextureSets[(int)lod].Initialized)
		{
			InitFallbackTextureSet(lod);
		}
	}

	private void InitFallbackTextureSet(ovrAvatarAssetLevelOfDetail lod)
	{
		FallbackTextureSets[(int)lod].DiffuseRoughness = (FallbackTextureSets[(int)lod].DiffuseRoughness = Resources.Load<Texture2D>(FALLBACK_TEXTURE_PATHS_DIFFUSE_ROUGHNESS[(int)lod]));
		FallbackTextureSets[(int)lod].Normal = (FallbackTextureSets[(int)lod].Normal = Resources.Load<Texture2D>(FALLBACK_TEXTURE_PATHS_NORMAL[(int)lod]));
		FallbackTextureSets[(int)lod].Initialized = true;
	}
}
public class OvrAvatarTouchController : OvrAvatarComponent
{
	public bool isLeftHand = true;

	private ovrAvatarControllerComponent component;

	private void Update()
	{
		if (owner == null)
		{
			return;
		}
		bool flag = false;
		if ((!isLeftHand) ? Oculus.Avatar.CAPI.ovrAvatarPose_GetRightControllerComponent(owner.sdkAvatar, ref component) : Oculus.Avatar.CAPI.ovrAvatarPose_GetLeftControllerComponent(owner.sdkAvatar, ref component))
		{
			UpdateAvatar(component.renderComponent);
			return;
		}
		if (isLeftHand)
		{
			owner.ControllerLeft = null;
		}
		else
		{
			owner.ControllerRight = null;
		}
		UnityEngine.Object.Destroy(this);
	}
}
public class EnableSwitch : MonoBehaviour
{
	public GameObject[] SwitchTargets;

	public bool SetActive<T>(int target) where T : MonoBehaviour
	{
		if (target < 0 || target >= SwitchTargets.Length)
		{
			return false;
		}
		for (int i = 0; i < SwitchTargets.Length; i++)
		{
			SwitchTargets[i].SetActive(value: false);
			OVRLipSyncContextMorphTarget component = SwitchTargets[i].GetComponent<OVRLipSyncContextMorphTarget>();
			if ((bool)component)
			{
				component.enabled = false;
			}
			OVRLipSyncContextTextureFlip component2 = SwitchTargets[i].GetComponent<OVRLipSyncContextTextureFlip>();
			if ((bool)component2)
			{
				component2.enabled = false;
			}
		}
		SwitchTargets[target].SetActive(value: true);
		MonoBehaviour component3 = SwitchTargets[target].GetComponent<T>();
		if (component3 != null)
		{
			component3.enabled = true;
		}
		return true;
	}
}
public class LipSyncDemo_Control : MonoBehaviour
{
	[Tooltip("Key used to rotate the demo object up to 45 degrees to the left.")]
	public KeyCode rotateLeftKey = KeyCode.LeftArrow;

	[Tooltip("Key used to rotate the demo object up to 45 degrees to the right.")]
	public KeyCode rotateRightKey = KeyCode.RightArrow;

	[Tooltip("Key used to reset demo object rotation.")]
	public KeyCode resetRotationKey = KeyCode.DownArrow;

	private float resetRotation = 180f;

	private float rotationAmount = 20f;

	private float rotationMax = 45f;

	private void Start()
	{
	}

	private void Update()
	{
		if (Input.GetKey(rotateLeftKey))
		{
			RotateObject(rotationAmount);
		}
		else if (Input.GetKey(rotateRightKey))
		{
			RotateObject(0f - rotationAmount);
		}
		else if (Input.GetKey(resetRotationKey))
		{
			RotateObject(resetRotation, absolute: true);
		}
	}

	private void RotateObject(float amountDegrees, bool absolute = false)
	{
		GameObject gameObject = GameObject.Find("LipSyncMorphTarget_Female");
		if (gameObject == null)
		{
			gameObject = GameObject.Find("RobotHead_TextureFlip");
		}
		if (!gameObject)
		{
			return;
		}
		if (absolute)
		{
			float num = amountDegrees - gameObject.transform.eulerAngles.y;
			gameObject.transform.Rotate(Vector3.up * num);
			return;
		}
		float num2 = Time.deltaTime * amountDegrees;
		if (num2 + gameObject.transform.eulerAngles.y >= resetRotation - rotationMax && num2 + gameObject.transform.eulerAngles.y <= resetRotation + rotationMax)
		{
			gameObject.transform.Rotate(Vector3.up * num2);
		}
	}
}
public class LipSyncDemo_SetCurrentTarget : MonoBehaviour
{
	public EnableSwitch[] SwitchTargets;

	private int targetSet;

	private int maxTarget = 6;

	private void Start()
	{
		OVRTouchpad.AddListener(LocalTouchEventCallback);
		targetSet = 0;
		SwitchTargets[0].SetActive<OVRLipSyncContextMorphTarget>(0);
		SwitchTargets[1].SetActive<OVRLipSyncContextMorphTarget>(0);
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Alpha1))
		{
			targetSet = 0;
			SetCurrentTarget();
		}
		else if (Input.GetKeyDown(KeyCode.Alpha2))
		{
			targetSet = 1;
			SetCurrentTarget();
		}
		else if (Input.GetKeyDown(KeyCode.Alpha3))
		{
			targetSet = 2;
			SetCurrentTarget();
		}
		else if (Input.GetKeyDown(KeyCode.Alpha4))
		{
			targetSet = 3;
			SetCurrentTarget();
		}
		else if (Input.GetKeyDown(KeyCode.Alpha5))
		{
			targetSet = 4;
			SetCurrentTarget();
		}
		else if (Input.GetKeyDown(KeyCode.Alpha6))
		{
			targetSet = 5;
			SetCurrentTarget();
		}
		if (Input.GetKeyDown(KeyCode.Escape))
		{
			UnityEngine.Application.Quit();
		}
	}

	private void SetCurrentTarget()
	{
		switch (targetSet)
		{
		case 0:
			SwitchTargets[0].SetActive<OVRLipSyncContextMorphTarget>(0);
			SwitchTargets[1].SetActive<OVRLipSyncContextMorphTarget>(0);
			break;
		case 1:
			SwitchTargets[0].SetActive<OVRLipSyncContextTextureFlip>(0);
			SwitchTargets[1].SetActive<OVRLipSyncContextTextureFlip>(1);
			break;
		case 2:
			SwitchTargets[0].SetActive<OVRLipSyncContextMorphTarget>(1);
			SwitchTargets[1].SetActive<OVRLipSyncContextMorphTarget>(2);
			break;
		case 3:
			SwitchTargets[0].SetActive<OVRLipSyncContextTextureFlip>(1);
			SwitchTargets[1].SetActive<OVRLipSyncContextTextureFlip>(3);
			break;
		case 4:
			SwitchTargets[0].SetActive<OVRLipSyncContextMorphTarget>(2);
			SwitchTargets[1].SetActive<OVRLipSyncContextMorphTarget>(4);
			break;
		case 5:
			SwitchTargets[0].SetActive<OVRLipSyncContextTextureFlip>(2);
			SwitchTargets[1].SetActive<OVRLipSyncContextTextureFlip>(5);
			break;
		}
		OVRLipSyncDebugConsole.Clear();
	}

	private void LocalTouchEventCallback(OVRTouchpad.TouchEvent touchEvent)
	{
		switch (touchEvent)
		{
		case OVRTouchpad.TouchEvent.Left:
			targetSet--;
			if (targetSet < 0)
			{
				targetSet = maxTarget - 1;
			}
			SetCurrentTarget();
			break;
		case OVRTouchpad.TouchEvent.Right:
			targetSet++;
			if (targetSet >= maxTarget)
			{
				targetSet = 0;
			}
			SetCurrentTarget();
			break;
		}
	}
}
public class OVRLipSyncDebugConsole : MonoBehaviour
{
	public ArrayList messages = new ArrayList();

	public int maxMessages = 15;

	public Text textMsg;

	private static OVRLipSyncDebugConsole s_Instance;

	private bool clearTimeoutOn;

	private float clearTimeout;

	public static OVRLipSyncDebugConsole instance
	{
		get
		{
			if (s_Instance == null)
			{
				s_Instance = UnityEngine.Object.FindObjectOfType(typeof(OVRLipSyncDebugConsole)) as OVRLipSyncDebugConsole;
				if (s_Instance == null)
				{
					GameObject obj = new GameObject();
					obj.AddComponent<OVRLipSyncDebugConsole>();
					obj.name = "OVRLipSyncDebugConsole";
					s_Instance = UnityEngine.Object.FindObjectOfType(typeof(OVRLipSyncDebugConsole)) as OVRLipSyncDebugConsole;
				}
			}
			return s_Instance;
		}
	}

	private void Awake()
	{
		s_Instance = this;
		Init();
	}

	private void Update()
	{
		if (clearTimeoutOn)
		{
			clearTimeout -= Time.deltaTime;
			if (clearTimeout < 0f)
			{
				Clear();
				clearTimeout = 0f;
				clearTimeoutOn = false;
			}
		}
	}

	public void Init()
	{
		if (textMsg == null)
		{
			UnityEngine.Debug.LogWarning("DebugConsole Init WARNING::UI text not set. Will not be able to display anything.");
		}
		Clear();
	}

	public static void Log(string message)
	{
		instance.AddMessage(message, Color.white);
	}

	public static void Log(string message, Color color)
	{
		instance.AddMessage(message, color);
	}

	public static void Clear()
	{
		instance.ClearMessages();
	}

	public static void ClearTimeout(float timeToClear)
	{
		instance.SetClearTimeout(timeToClear);
	}

	public void AddMessage(string message, Color color)
	{
		messages.Add(message);
		if (textMsg != null)
		{
			textMsg.color = color;
		}
		Display();
	}

	public void ClearMessages()
	{
		messages.Clear();
		Display();
	}

	public void SetClearTimeout(float timeout)
	{
		clearTimeout = timeout;
		clearTimeoutOn = true;
	}

	private void Prune()
	{
		if (messages.Count > maxMessages)
		{
			int count = ((messages.Count > 0) ? (messages.Count - maxMessages) : 0);
			messages.RemoveRange(0, count);
		}
	}

	private void Display()
	{
		if (messages.Count > maxMessages)
		{
			Prune();
		}
		if (textMsg != null)
		{
			textMsg.text = "";
			for (int i = 0; i < messages.Count; i++)
			{
				textMsg.text += (string)messages[i];
				textMsg.text += "\n";
			}
		}
	}
}
public class OVRNamedArrayAttribute : PropertyAttribute
{
	public readonly string[] names;

	public OVRNamedArrayAttribute(string[] names)
	{
		this.names = names;
	}
}
public static class OVRTouchpad
{
	public enum TouchEvent
	{
		SingleTap,
		DoubleTap,
		Left,
		Right,
		Up,
		Down
	}

	public delegate void OVRTouchpadCallback<TouchEvent>(TouchEvent arg);

	private static Vector3 moveAmountMouse;

	private static float minMovMagnitudeMouse = 25f;

	public static Delegate touchPadCallbacks = null;

	private static OVRTouchpadHelper touchpadHelper = new GameObject("OVRTouchpadHelper").AddComponent<OVRTouchpadHelper>();

	public static void Create()
	{
	}

	public static void Update()
	{
		if (Input.GetMouseButtonDown(0))
		{
			moveAmountMouse = Input.mousePosition;
		}
		else if (Input.GetMouseButtonUp(0))
		{
			moveAmountMouse -= Input.mousePosition;
			HandleInputMouse(ref moveAmountMouse);
		}
	}

	public static void OnDisable()
	{
	}

	private static void HandleInputMouse(ref Vector3 move)
	{
		if ((object)touchPadCallbacks == null)
		{
			return;
		}
		OVRTouchpadCallback<TouchEvent> oVRTouchpadCallback = touchPadCallbacks as OVRTouchpadCallback<TouchEvent>;
		if (move.magnitude < minMovMagnitudeMouse)
		{
			oVRTouchpadCallback(TouchEvent.SingleTap);
			return;
		}
		move.Normalize();
		if (Mathf.Abs(move.x) > Mathf.Abs(move.y))
		{
			if (move.x > 0f)
			{
				oVRTouchpadCallback(TouchEvent.Left);
			}
			else
			{
				oVRTouchpadCallback(TouchEvent.Right);
			}
		}
		else if (move.y > 0f)
		{
			oVRTouchpadCallback(TouchEvent.Down);
		}
		else
		{
			oVRTouchpadCallback(TouchEvent.Up);
		}
	}

	public static void AddListener(OVRTouchpadCallback<TouchEvent> handler)
	{
		touchPadCallbacks = (OVRTouchpadCallback<TouchEvent>)Delegate.Combine((OVRTouchpadCallback<TouchEvent>)touchPadCallbacks, handler);
	}
}
public sealed class OVRTouchpadHelper : MonoBehaviour
{
	private void Awake()
	{
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
	}

	private void Start()
	{
		OVRTouchpad.AddListener(LocalTouchEventCallback);
	}

	private void Update()
	{
		OVRTouchpad.Update();
	}

	public void OnDisable()
	{
		OVRTouchpad.OnDisable();
	}

	private void LocalTouchEventCallback(OVRTouchpad.TouchEvent touchEvent)
	{
		switch (touchEvent)
		{
		}
	}
}
public class OVRLipSync : MonoBehaviour
{
	public enum Result
	{
		Success = 0,
		Unknown = -2200,
		CannotCreateContext = -2201,
		InvalidParam = -2202,
		BadSampleRate = -2203,
		MissingDLL = -2204,
		BadVersion = -2205,
		UndefinedFunction = -2206
	}

	public enum AudioDataType
	{
		S16_Mono,
		S16_Stereo,
		F32_Mono,
		F32_Stereo
	}

	public enum Viseme
	{
		sil,
		PP,
		FF,
		TH,
		DD,
		kk,
		CH,
		SS,
		nn,
		RR,
		aa,
		E,
		ih,
		oh,
		ou
	}

	public enum Signals
	{
		VisemeOn,
		VisemeOff,
		VisemeAmount,
		VisemeSmoothing,
		LaughterAmount
	}

	public enum ContextProviders
	{
		Original,
		Enhanced,
		Enhanced_with_Laughter
	}

	[Serializable]
	public class Frame
	{
		public int frameNumber;

		public int frameDelay;

		public float[] Visemes = new float[VisemeCount];

		public float laughterScore;

		public void CopyInput(Frame input)
		{
			frameNumber = input.frameNumber;
			frameDelay = input.frameDelay;
			input.Visemes.CopyTo(Visemes, 0);
			laughterScore = input.laughterScore;
		}

		public void Reset()
		{
			frameNumber = 0;
			frameDelay = 0;
			Array.Clear(Visemes, 0, VisemeCount);
			laughterScore = 0f;
		}
	}

	public static readonly int VisemeCount = Enum.GetNames(typeof(Viseme)).Length;

	public static readonly int SignalCount = Enum.GetNames(typeof(Signals)).Length;

	public const string strOVRLS = "OVRLipSync";

	private static Result sInitialized = Result.Unknown;

	public static OVRLipSync sInstance = null;

	[DllImport("OVRLipSync")]
	private static extern int ovrLipSyncDll_Initialize(int samplerate, int buffersize);

	[DllImport("OVRLipSync")]
	private static extern void ovrLipSyncDll_Shutdown();

	[DllImport("OVRLipSync")]
	private static extern IntPtr ovrLipSyncDll_GetVersion(ref int Major, ref int Minor, ref int Patch);

	[DllImport("OVRLipSync")]
	private static extern int ovrLipSyncDll_CreateContextEx(ref uint context, ContextProviders provider, int sampleRate, bool enableAcceleration);

	[DllImport("OVRLipSync")]
	private static extern int ovrLipSyncDll_CreateContextWithModelFile(ref uint context, ContextProviders provider, string modelPath, int sampleRate, bool enableAcceleration);

	[DllImport("OVRLipSync")]
	private static extern int ovrLipSyncDll_DestroyContext(uint context);

	[DllImport("OVRLipSync")]
	private static extern int ovrLipSyncDll_ResetContext(uint context);

	[DllImport("OVRLipSync")]
	private static extern int ovrLipSyncDll_SendSignal(uint context, Signals signal, int arg1, int arg2);

	[DllImport("OVRLipSync")]
	private static extern int ovrLipSyncDll_ProcessFrameEx(uint context, IntPtr audioBuffer, uint bufferSize, AudioDataType dataType, ref int frameNumber, ref int frameDelay, float[] visemes, int visemeCount, ref float laughterScore, float[] laughterCategories, int laughterCategoriesLength);

	private void Awake()
	{
		if (sInstance == null)
		{
			sInstance = this;
			if (IsInitialized() != 0)
			{
				sInitialized = Initialize();
				if (sInitialized != 0)
				{
					UnityEngine.Debug.LogWarning($"OvrLipSync Awake: Failed to init Speech Rec library");
				}
			}
			OVRTouchpad.Create();
		}
		else
		{
			UnityEngine.Debug.LogWarning($"OVRLipSync Awake: Only one instance of OVRPLipSync can exist in the scene.");
		}
	}

	private void OnDestroy()
	{
		if (sInstance != this)
		{
			UnityEngine.Debug.LogWarning("OVRLipSync OnDestroy: This is not the correct OVRLipSync instance.");
		}
	}

	public static Result Initialize()
	{
		int outputSampleRate = AudioSettings.outputSampleRate;
		AudioSettings.GetDSPBufferSize(out var bufferLength, out var _);
		UnityEngine.Debug.LogWarning($"OvrLipSync Awake: Queried SampleRate: {outputSampleRate:F0} BufferSize: {bufferLength:F0}");
		sInitialized = (Result)ovrLipSyncDll_Initialize(outputSampleRate, bufferLength);
		return sInitialized;
	}

	public static Result Initialize(int sampleRate, int bufferSize)
	{
		UnityEngine.Debug.LogWarning($"OvrLipSync Awake: Queried SampleRate: {sampleRate:F0} BufferSize: {bufferSize:F0}");
		sInitialized = (Result)ovrLipSyncDll_Initialize(sampleRate, bufferSize);
		return sInitialized;
	}

	public static void Shutdown()
	{
		ovrLipSyncDll_Shutdown();
		sInitialized = Result.Unknown;
	}

	public static Result IsInitialized()
	{
		return sInitialized;
	}

	public static Result CreateContext(ref uint context, ContextProviders provider, int sampleRate = 0, bool enableAcceleration = false)
	{
		if (IsInitialized() != 0 && Initialize() != 0)
		{
			return Result.CannotCreateContext;
		}
		return (Result)ovrLipSyncDll_CreateContextEx(ref context, provider, sampleRate, enableAcceleration);
	}

	public static Result CreateContextWithModelFile(ref uint context, ContextProviders provider, string modelPath, int sampleRate = 0, bool enableAcceleration = false)
	{
		if (IsInitialized() != 0 && Initialize() != 0)
		{
			return Result.CannotCreateContext;
		}
		return (Result)ovrLipSyncDll_CreateContextWithModelFile(ref context, provider, modelPath, sampleRate, enableAcceleration);
	}

	public static Result DestroyContext(uint context)
	{
		if (IsInitialized() != 0)
		{
			return Result.Unknown;
		}
		return (Result)ovrLipSyncDll_DestroyContext(context);
	}

	public static Result ResetContext(uint context)
	{
		if (IsInitialized() != 0)
		{
			return Result.Unknown;
		}
		return (Result)ovrLipSyncDll_ResetContext(context);
	}

	public static Result SendSignal(uint context, Signals signal, int arg1, int arg2)
	{
		if (IsInitialized() != 0)
		{
			return Result.Unknown;
		}
		return (Result)ovrLipSyncDll_SendSignal(context, signal, arg1, arg2);
	}

	public static Result ProcessFrame(uint context, float[] audioBuffer, Frame frame, bool stereo = true)
	{
		if (IsInitialized() != 0)
		{
			return Result.Unknown;
		}
		AudioDataType dataType = (stereo ? AudioDataType.F32_Stereo : AudioDataType.F32_Mono);
		uint bufferSize = (uint)(stereo ? (audioBuffer.Length / 2) : audioBuffer.Length);
		GCHandle gCHandle = GCHandle.Alloc(audioBuffer, GCHandleType.Pinned);
		int result = ovrLipSyncDll_ProcessFrameEx(context, gCHandle.AddrOfPinnedObject(), bufferSize, dataType, ref frame.frameNumber, ref frame.frameDelay, frame.Visemes, frame.Visemes.Length, ref frame.laughterScore, null, 0);
		gCHandle.Free();
		return (Result)result;
	}

	public static Result ProcessFrame(uint context, short[] audioBuffer, Frame frame, bool stereo = true)
	{
		if (IsInitialized() != 0)
		{
			return Result.Unknown;
		}
		AudioDataType dataType = (stereo ? AudioDataType.S16_Stereo : AudioDataType.S16_Mono);
		uint bufferSize = (uint)(stereo ? (audioBuffer.Length / 2) : audioBuffer.Length);
		GCHandle gCHandle = GCHandle.Alloc(audioBuffer, GCHandleType.Pinned);
		int result = ovrLipSyncDll_ProcessFrameEx(context, gCHandle.AddrOfPinnedObject(), bufferSize, dataType, ref frame.frameNumber, ref frame.frameDelay, frame.Visemes, frame.Visemes.Length, ref frame.laughterScore, null, 0);
		gCHandle.Free();
		return (Result)result;
	}
}
[RequireComponent(typeof(AudioSource))]
public class OVRLipSyncContext : OVRLipSyncContextBase
{
	[Tooltip("Allow capturing of keyboard input to control operation.")]
	public bool enableKeyboardInput;

	[Tooltip("Register a mouse/touch callback to control loopback and gain (requires script restart).")]
	public bool enableTouchInput;

	[Tooltip("Play input audio back through audio output.")]
	public bool audioLoopback;

	[Tooltip("Key to toggle audio loopback.")]
	public KeyCode loopbackKey = KeyCode.L;

	[Tooltip("Show viseme scores in an OVRLipSyncDebugConsole display.")]
	public bool showVisemes;

	[Tooltip("Key to toggle viseme score display.")]
	public KeyCode debugVisemesKey = KeyCode.D;

	[Tooltip("Skip data from the Audio Source. Use if you intend to pass audio data in manually.")]
	public bool skipAudioSource;

	[Tooltip("Adjust the linear audio gain multiplier before processing lipsync")]
	public float gain = 1f;

	private bool hasDebugConsole;

	public KeyCode debugLaughterKey = KeyCode.H;

	public bool showLaughter;

	public float laughterScore;

	private void Start()
	{
		if (enableTouchInput)
		{
			OVRTouchpad.AddListener(LocalTouchEventCallback);
		}
		OVRLipSyncDebugConsole[] array = UnityEngine.Object.FindObjectsOfType<OVRLipSyncDebugConsole>();
		if (array.Length != 0)
		{
			hasDebugConsole = array[0];
		}
	}

	private void HandleKeyboard()
	{
		if (Input.GetKeyDown(loopbackKey))
		{
			ToggleAudioLoopback();
		}
		else if (Input.GetKeyDown(debugVisemesKey))
		{
			showVisemes = !showVisemes;
			if (showVisemes)
			{
				if (hasDebugConsole)
				{
					UnityEngine.Debug.Log("DEBUG SHOW VISEMES: ENABLED");
					return;
				}
				UnityEngine.Debug.LogWarning("Warning: No OVRLipSyncDebugConsole in the scene!");
				showVisemes = false;
			}
			else
			{
				if (hasDebugConsole)
				{
					OVRLipSyncDebugConsole.Clear();
				}
				UnityEngine.Debug.Log("DEBUG SHOW VISEMES: DISABLED");
			}
		}
		else if (Input.GetKeyDown(debugLaughterKey))
		{
			showLaughter = !showLaughter;
			if (showLaughter)
			{
				if (hasDebugConsole)
				{
					UnityEngine.Debug.Log("DEBUG SHOW LAUGHTER: ENABLED");
					return;
				}
				UnityEngine.Debug.LogWarning("Warning: No OVRLipSyncDebugConsole in the scene!");
				showLaughter = false;
			}
			else
			{
				if (hasDebugConsole)
				{
					OVRLipSyncDebugConsole.Clear();
				}
				UnityEngine.Debug.Log("DEBUG SHOW LAUGHTER: DISABLED");
			}
		}
		else if (Input.GetKeyDown(KeyCode.LeftArrow))
		{
			gain -= 1f;
			if (gain < 1f)
			{
				gain = 1f;
			}
			string text = "LINEAR GAIN: ";
			text += gain;
			if (hasDebugConsole)
			{
				OVRLipSyncDebugConsole.Clear();
				OVRLipSyncDebugConsole.Log(text);
				OVRLipSyncDebugConsole.ClearTimeout(1.5f);
			}
		}
		else if (Input.GetKeyDown(KeyCode.RightArrow))
		{
			gain += 1f;
			if (gain > 15f)
			{
				gain = 15f;
			}
			string text2 = "LINEAR GAIN: ";
			text2 += gain;
			if (hasDebugConsole)
			{
				OVRLipSyncDebugConsole.Clear();
				OVRLipSyncDebugConsole.Log(text2);
				OVRLipSyncDebugConsole.ClearTimeout(1.5f);
			}
		}
	}

	private void Update()
	{
		if (enableKeyboardInput)
		{
			HandleKeyboard();
		}
		laughterScore = base.Frame.laughterScore;
		DebugShowVisemesAndLaughter();
	}

	public void PreprocessAudioSamples(float[] data, int channels)
	{
		for (int i = 0; i < data.Length; i++)
		{
			data[i] *= gain;
		}
	}

	public void PostprocessAudioSamples(float[] data, int channels)
	{
		if (!audioLoopback)
		{
			for (int i = 0; i < data.Length; i++)
			{
				data[i] *= 0f;
			}
		}
	}

	public void ProcessAudioSamplesRaw(float[] data, int channels)
	{
		lock (this)
		{
			if (base.Context != 0 && OVRLipSync.IsInitialized() == OVRLipSync.Result.Success)
			{
				OVRLipSync.Frame frame = base.Frame;
				OVRLipSync.ProcessFrame(base.Context, data, frame, channels == 2);
			}
		}
	}

	public void ProcessAudioSamplesRaw(short[] data, int channels)
	{
		lock (this)
		{
			if (base.Context != 0 && OVRLipSync.IsInitialized() == OVRLipSync.Result.Success)
			{
				OVRLipSync.Frame frame = base.Frame;
				OVRLipSync.ProcessFrame(base.Context, data, frame, channels == 2);
			}
		}
	}

	public void ProcessAudioSamples(float[] data, int channels)
	{
		if (OVRLipSync.IsInitialized() == OVRLipSync.Result.Success && !(audioSource == null))
		{
			PreprocessAudioSamples(data, channels);
			ProcessAudioSamplesRaw(data, channels);
			PostprocessAudioSamples(data, channels);
		}
	}

	private void OnAudioFilterRead(float[] data, int channels)
	{
		if (!skipAudioSource)
		{
			ProcessAudioSamples(data, channels);
		}
	}

	private void DebugShowVisemesAndLaughter()
	{
		if (!hasDebugConsole)
		{
			return;
		}
		string text = "";
		if (showLaughter)
		{
			text += "Laughter:";
			int num = (int)(50f * base.Frame.laughterScore);
			for (int i = 0; i < num; i++)
			{
				text += "*";
			}
			text += "\n";
		}
		if (showVisemes)
		{
			for (int j = 0; j < base.Frame.Visemes.Length; j++)
			{
				string text2 = text;
				OVRLipSync.Viseme viseme = (OVRLipSync.Viseme)j;
				text = text2 + viseme;
				text += ":";
				int num2 = (int)(50f * base.Frame.Visemes[j]);
				for (int k = 0; k < num2; k++)
				{
					text += "*";
				}
				text += "\n";
			}
		}
		OVRLipSyncDebugConsole.Clear();
		if (text != "")
		{
			OVRLipSyncDebugConsole.Log(text);
		}
	}

	private void ToggleAudioLoopback()
	{
		audioLoopback = !audioLoopback;
		if (hasDebugConsole)
		{
			OVRLipSyncDebugConsole.Clear();
			OVRLipSyncDebugConsole.ClearTimeout(1.5f);
			if (audioLoopback)
			{
				OVRLipSyncDebugConsole.Log("LOOPBACK MODE: ENABLED");
			}
			else
			{
				OVRLipSyncDebugConsole.Log("LOOPBACK MODE: DISABLED");
			}
		}
	}

	private void LocalTouchEventCallback(OVRTouchpad.TouchEvent touchEvent)
	{
		string text = "LINEAR GAIN: ";
		switch (touchEvent)
		{
		case OVRTouchpad.TouchEvent.SingleTap:
			ToggleAudioLoopback();
			break;
		case OVRTouchpad.TouchEvent.Up:
			gain += 1f;
			if (gain > 15f)
			{
				gain = 15f;
			}
			text += gain;
			if (hasDebugConsole)
			{
				OVRLipSyncDebugConsole.Clear();
				OVRLipSyncDebugConsole.Log(text);
				OVRLipSyncDebugConsole.ClearTimeout(1.5f);
			}
			break;
		case OVRTouchpad.TouchEvent.Down:
			gain -= 1f;
			if (gain < 1f)
			{
				gain = 1f;
			}
			text += gain;
			if (hasDebugConsole)
			{
				OVRLipSyncDebugConsole.Clear();
				OVRLipSyncDebugConsole.Log(text);
				OVRLipSyncDebugConsole.ClearTimeout(1.5f);
			}
			break;
		}
	}
}
[RequireComponent(typeof(AudioSource))]
public class OVRLipSyncContextBase : MonoBehaviour
{
	public AudioSource audioSource;

	[Tooltip("Which lip sync provider to use for viseme computation.")]
	public OVRLipSync.ContextProviders provider = OVRLipSync.ContextProviders.Enhanced;

	[Tooltip("Enable DSP offload on supported Android devices.")]
	public bool enableAcceleration = true;

	private OVRLipSync.Frame frame = new OVRLipSync.Frame();

	private uint context;

	private int _smoothing;

	public int Smoothing
	{
		get
		{
			return _smoothing;
		}
		set
		{
			switch (OVRLipSync.SendSignal(context, OVRLipSync.Signals.VisemeSmoothing, value, 0))
			{
			case OVRLipSync.Result.InvalidParam:
				UnityEngine.Debug.LogError("OVRLipSyncContextBase.SetSmoothing: A viseme smoothing parameter is invalid, it should be between 1 and 100!");
				break;
			default:
				UnityEngine.Debug.LogError("OVRLipSyncContextBase.SetSmoothing: An unexpected error occured.");
				break;
			case OVRLipSync.Result.Success:
				break;
			}
			_smoothing = value;
		}
	}

	public uint Context => context;

	protected OVRLipSync.Frame Frame => frame;

	private void Awake()
	{
		if (!audioSource)
		{
			audioSource = GetComponent<AudioSource>();
		}
		lock (this)
		{
			if (context == 0 && OVRLipSync.CreateContext(ref context, provider, 0, enableAcceleration) != 0)
			{
				UnityEngine.Debug.LogError("OVRLipSyncContextBase.Start ERROR: Could not create Phoneme context.");
			}
		}
	}

	private void OnDestroy()
	{
		lock (this)
		{
			if (context != 0 && OVRLipSync.DestroyContext(context) != 0)
			{
				UnityEngine.Debug.LogError("OVRLipSyncContextBase.OnDestroy ERROR: Could not delete Phoneme context.");
			}
		}
	}

	public OVRLipSync.Frame GetCurrentPhonemeFrame()
	{
		return frame;
	}

	public void SetVisemeBlend(int viseme, int amount)
	{
		switch (OVRLipSync.SendSignal(context, OVRLipSync.Signals.VisemeAmount, viseme, amount))
		{
		case OVRLipSync.Result.InvalidParam:
			UnityEngine.Debug.LogError("OVRLipSyncContextBase.SetVisemeBlend: Viseme ID is invalid.");
			break;
		default:
			UnityEngine.Debug.LogError("OVRLipSyncContextBase.SetVisemeBlend: An unexpected error occured.");
			break;
		case OVRLipSync.Result.Success:
			break;
		}
	}

	public void SetLaughterBlend(int amount)
	{
		if (OVRLipSync.SendSignal(context, OVRLipSync.Signals.LaughterAmount, amount, 0) != 0)
		{
			UnityEngine.Debug.LogError("OVRLipSyncContextBase.SetLaughterBlend: An unexpected error occured.");
		}
	}

	public OVRLipSync.Result ResetContext()
	{
		frame.Reset();
		return OVRLipSync.ResetContext(context);
	}
}
[RequireComponent(typeof(AudioSource))]
public class OVRLipSyncContextCanned : OVRLipSyncContextBase
{
	[Tooltip("Pre-computed viseme sequence asset. Compute from audio in Unity with Tools -> Oculus -> Generate Lip Sync Assets.")]
	public OVRLipSyncSequence currentSequence;

	private void Update()
	{
		if (audioSource.isPlaying && currentSequence != null)
		{
			OVRLipSync.Frame frameAtTime = currentSequence.GetFrameAtTime(audioSource.time);
			base.Frame.CopyInput(frameAtTime);
		}
	}
}
public class OVRLipSyncContextMorphTarget : MonoBehaviour
{
	[Tooltip("Skinned Mesh Rendered target to be driven by Oculus Lipsync")]
	public SkinnedMeshRenderer skinnedMeshRenderer;

	[Tooltip("Blendshape index to trigger for each viseme.")]
	public int[] visemeToBlendTargets = Enumerable.Range(0, OVRLipSync.VisemeCount).ToArray();

	[Tooltip("Enable using the test keys defined below to manually trigger each viseme.")]
	public bool enableVisemeTestKeys;

	[Tooltip("Test keys used to manually trigger an individual viseme - by default the QWERTY row of a US keyboard.")]
	public KeyCode[] visemeTestKeys = new KeyCode[15]
	{
		KeyCode.BackQuote,
		KeyCode.Tab,
		KeyCode.Q,
		KeyCode.W,
		KeyCode.E,
		KeyCode.R,
		KeyCode.T,
		KeyCode.Y,
		KeyCode.U,
		KeyCode.I,
		KeyCode.O,
		KeyCode.P,
		KeyCode.LeftBracket,
		KeyCode.RightBracket,
		KeyCode.Backslash
	};

	[Tooltip("Test key used to manually trigger laughter and visualise the results")]
	public KeyCode laughterKey = KeyCode.CapsLock;

	[Tooltip("Blendshape index to trigger for laughter")]
	public int laughterBlendTarget = OVRLipSync.VisemeCount;

	[Range(0f, 1f)]
	[Tooltip("Laughter probability threshold above which the laughter blendshape will be activated")]
	public float laughterThreshold = 0.5f;

	[Range(0f, 3f)]
	[Tooltip("Laughter animation linear multiplier, the final output will be clamped to 1.0")]
	public float laughterMultiplier = 1.5f;

	[Range(1f, 100f)]
	[Tooltip("Smoothing of 1 will yield only the current predicted viseme, 100 will yield an extremely smooth viseme response.")]
	public int smoothAmount = 70;

	private OVRLipSyncContextBase lipsyncContext;

	private void Start()
	{
		if (skinnedMeshRenderer == null)
		{
			UnityEngine.Debug.LogError("LipSyncContextMorphTarget.Start Error: Please set the target Skinned Mesh Renderer to be controlled!");
			return;
		}
		lipsyncContext = GetComponent<OVRLipSyncContextBase>();
		if (lipsyncContext == null)
		{
			UnityEngine.Debug.LogError("LipSyncContextMorphTarget.Start Error: No OVRLipSyncContext component on this object!");
		}
		else
		{
			lipsyncContext.Smoothing = smoothAmount;
		}
	}

	private void Update()
	{
		if (lipsyncContext != null && skinnedMeshRenderer != null)
		{
			OVRLipSync.Frame currentPhonemeFrame = lipsyncContext.GetCurrentPhonemeFrame();
			if (currentPhonemeFrame != null)
			{
				SetVisemeToMorphTarget(currentPhonemeFrame);
				SetLaughterToMorphTarget(currentPhonemeFrame);
			}
			CheckForKeys();
			if (smoothAmount != lipsyncContext.Smoothing)
			{
				lipsyncContext.Smoothing = smoothAmount;
			}
		}
	}

	private void CheckForKeys()
	{
		if (enableVisemeTestKeys)
		{
			for (int i = 0; i < OVRLipSync.VisemeCount; i++)
			{
				CheckVisemeKey(visemeTestKeys[i], i, 100);
			}
		}
		CheckLaughterKey();
	}

	private void SetVisemeToMorphTarget(OVRLipSync.Frame frame)
	{
		for (int i = 0; i < visemeToBlendTargets.Length; i++)
		{
			if (visemeToBlendTargets[i] != -1)
			{
				skinnedMeshRenderer.SetBlendShapeWeight(visemeToBlendTargets[i], frame.Visemes[i] * 100f);
			}
		}
	}

	private void SetLaughterToMorphTarget(OVRLipSync.Frame frame)
	{
		if (laughterBlendTarget != -1)
		{
			float laughterScore = frame.laughterScore;
			laughterScore = ((laughterScore < laughterThreshold) ? 0f : (laughterScore - laughterThreshold));
			laughterScore = Mathf.Min(laughterScore * laughterMultiplier, 1f);
			laughterScore *= 1f / laughterThreshold;
			skinnedMeshRenderer.SetBlendShapeWeight(laughterBlendTarget, laughterScore * 100f);
		}
	}

	private void CheckVisemeKey(KeyCode key, int viseme, int amount)
	{
		if (Input.GetKeyDown(key))
		{
			lipsyncContext.SetVisemeBlend(visemeToBlendTargets[viseme], amount);
		}
		if (Input.GetKeyUp(key))
		{
			lipsyncContext.SetVisemeBlend(visemeToBlendTargets[viseme], 0);
		}
	}

	private void CheckLaughterKey()
	{
		if (Input.GetKeyDown(laughterKey))
		{
			lipsyncContext.SetLaughterBlend(100);
		}
		if (Input.GetKeyUp(laughterKey))
		{
			lipsyncContext.SetLaughterBlend(0);
		}
	}
}
public class OVRLipSyncContextTextureFlip : MonoBehaviour
{
	public Material material;

	[Tooltip("The texture used for each viseme.")]
	[OVRNamedArray(new string[]
	{
		"sil", "PP", "FF", "TH", "DD", "kk", "CH", "SS", "nn", "RR",
		"aa", "E", "ih", "oh", "ou"
	})]
	public Texture[] Textures = new Texture[OVRLipSync.VisemeCount];

	[Range(1f, 100f)]
	[Tooltip("Smoothing of 1 will yield only the current predicted viseme,100 will yield an extremely smooth viseme response.")]
	public int smoothAmount = 70;

	private OVRLipSyncContextBase lipsyncContext;

	private OVRLipSync.Frame oldFrame = new OVRLipSync.Frame();

	private void Start()
	{
		lipsyncContext = GetComponent<OVRLipSyncContextBase>();
		if (lipsyncContext == null)
		{
			UnityEngine.Debug.LogWarning("LipSyncContextTextureFlip.Start WARNING: No lip sync context component set to object");
		}
		else
		{
			lipsyncContext.Smoothing = smoothAmount;
		}
		if (material == null)
		{
			UnityEngine.Debug.LogWarning("LipSyncContextTextureFlip.Start WARNING: Lip sync context texture flip has no material target to control!");
		}
	}

	private void Update()
	{
		if (lipsyncContext != null && material != null)
		{
			OVRLipSync.Frame currentPhonemeFrame = lipsyncContext.GetCurrentPhonemeFrame();
			if (currentPhonemeFrame != null)
			{
				if (lipsyncContext.provider == OVRLipSync.ContextProviders.Original)
				{
					for (int i = 0; i < currentPhonemeFrame.Visemes.Length; i++)
					{
						float num = (float)(smoothAmount - 1) / 100f;
						oldFrame.Visemes[i] = oldFrame.Visemes[i] * num + currentPhonemeFrame.Visemes[i] * (1f - num);
					}
				}
				else
				{
					oldFrame.Visemes = currentPhonemeFrame.Visemes;
				}
				SetVisemeToTexture();
			}
		}
		if (smoothAmount != lipsyncContext.Smoothing)
		{
			lipsyncContext.Smoothing = smoothAmount;
		}
	}

	private void SetVisemeToTexture()
	{
		int num = -1;
		float num2 = 0f;
		for (int i = 0; i < oldFrame.Visemes.Length; i++)
		{
			if (oldFrame.Visemes[i] > num2)
			{
				num = i;
				num2 = oldFrame.Visemes[i];
			}
		}
		if (num != -1 && num < Textures.Length)
		{
			Texture texture = Textures[num];
			if (texture != null)
			{
				material.SetTexture("_MainTex", texture);
			}
		}
	}
}
[RequireComponent(typeof(AudioSource))]
public class OVRLipSyncMicInput : MonoBehaviour
{
	public enum micActivation
	{
		HoldToSpeak,
		PushToSpeak,
		ConstantSpeak
	}

	[Tooltip("Manual specification of Audio Source - by default will use any attached to the same object.")]
	public AudioSource audioSource;

	[Tooltip("Enable a keypress to toggle the microphone device selection GUI.")]
	public bool enableMicSelectionGUI;

	[Tooltip("Key to toggle the microphone selection GUI if enabled.")]
	public KeyCode micSelectionGUIKey = KeyCode.M;

	[SerializeField]
	[Range(0f, 100f)]
	[Tooltip("Microphone input volume control.")]
	private float micInputVolume = 100f;

	[SerializeField]
	[Tooltip("Requested microphone input frequency")]
	private int micFrequency = 48000;

	[Tooltip("Microphone input control method. Hold To Speak and Push To Speak are driven with the Mic Activation Key.")]
	public micActivation micControl = micActivation.ConstantSpeak;

	[Tooltip("Key used to drive Hold To Speak and Push To Speak methods of microphone input control.")]
	public KeyCode micActivationKey = KeyCode.Space;

	[Tooltip("Will contain the string name of the selected microphone device - read only.")]
	public string selectedDevice;

	private bool micSelected;

	private int minFreq;

	private int maxFreq;

	private bool focused = true;

	private bool initialized;

	public float MicFrequency
	{
		get
		{
			return micFrequency;
		}
		set
		{
			micFrequency = (int)Mathf.Clamp(value, 0f, 96000f);
		}
	}

	private void Awake()
	{
		if (!audioSource)
		{
			audioSource = GetComponent<AudioSource>();
		}
		_ = (bool)audioSource;
	}

	private void Start()
	{
		audioSource.loop = true;
		audioSource.mute = false;
		InitializeMicrophone();
	}

	private void InitializeMicrophone()
	{
		if (!initialized && Microphone.devices.Length != 0)
		{
			selectedDevice = Microphone.devices[0].ToString();
			micSelected = true;
			GetMicCaps();
			initialized = true;
		}
	}

	private void Update()
	{
		if (!focused)
		{
			if (Microphone.IsRecording(selectedDevice))
			{
				StopMicrophone();
			}
			return;
		}
		if (!UnityEngine.Application.isPlaying)
		{
			StopMicrophone();
			return;
		}
		if (!initialized)
		{
			InitializeMicrophone();
		}
		audioSource.volume = micInputVolume / 100f;
		if (micControl == micActivation.HoldToSpeak)
		{
			if (Input.GetKey(micActivationKey))
			{
				if (!Microphone.IsRecording(selectedDevice))
				{
					StartMicrophone();
				}
			}
			else if (Microphone.IsRecording(selectedDevice))
			{
				StopMicrophone();
			}
		}
		if (micControl == micActivation.PushToSpeak && Input.GetKeyDown(micActivationKey))
		{
			if (Microphone.IsRecording(selectedDevice))
			{
				StopMicrophone();
			}
			else if (!Microphone.IsRecording(selectedDevice))
			{
				StartMicrophone();
			}
		}
		if (micControl == micActivation.ConstantSpeak && !Microphone.IsRecording(selectedDevice))
		{
			StartMicrophone();
		}
		if (enableMicSelectionGUI && Input.GetKeyDown(micSelectionGUIKey))
		{
			micSelected = false;
		}
	}

	private void OnApplicationFocus(bool focus)
	{
		focused = focus;
		if (!focused)
		{
			StopMicrophone();
		}
	}

	private void OnApplicationPause(bool pauseStatus)
	{
		focused = !pauseStatus;
		if (!focused)
		{
			StopMicrophone();
		}
	}

	private void OnDisable()
	{
		StopMicrophone();
	}

	private void OnGUI()
	{
		MicDeviceGUI(Screen.width / 2 - 150, Screen.height / 2 - 75, 300f, 50f, 10f, -300f);
	}

	public void MicDeviceGUI(float left, float top, float width, float height, float buttonSpaceTop, float buttonSpaceLeft)
	{
		if (Microphone.devices.Length < 1 || !enableMicSelectionGUI || micSelected)
		{
			return;
		}
		for (int i = 0; i < Microphone.devices.Length; i++)
		{
			if (GUI.Button(new Rect(left + (width + buttonSpaceLeft) * (float)i, top + (height + buttonSpaceTop) * (float)i, width, height), Microphone.devices[i].ToString()))
			{
				StopMicrophone();
				selectedDevice = Microphone.devices[i].ToString();
				micSelected = true;
				GetMicCaps();
				StartMicrophone();
			}
		}
	}

	public void GetMicCaps()
	{
		if (micSelected)
		{
			Microphone.GetDeviceCaps(selectedDevice, out minFreq, out maxFreq);
			if (minFreq == 0 && maxFreq == 0)
			{
				UnityEngine.Debug.LogWarning("GetMicCaps warning:: min and max frequencies are 0");
				minFreq = 44100;
				maxFreq = 44100;
			}
			if (micFrequency > maxFreq)
			{
				micFrequency = maxFreq;
			}
		}
	}

	public void StartMicrophone()
	{
		if (micSelected)
		{
			audioSource.clip = Microphone.Start(selectedDevice, loop: true, 1, micFrequency);
			Stopwatch stopwatch = Stopwatch.StartNew();
			while (Microphone.GetPosition(selectedDevice) <= 0 && stopwatch.Elapsed.TotalMilliseconds < 1000.0)
			{
				Thread.Sleep(50);
			}
			if (Microphone.GetPosition(selectedDevice) <= 0)
			{
				throw new Exception("Timeout initializing microphone " + selectedDevice);
			}
			audioSource.Play();
		}
	}

	public void StopMicrophone()
	{
		if (micSelected)
		{
			if (audioSource != null && audioSource.clip != null && audioSource.clip.name == "Microphone")
			{
				audioSource.Stop();
			}
			GetComponent<OVRLipSyncContext>().ResetContext();
			Microphone.End(selectedDevice);
		}
	}

	private float GetAveragedVolume()
	{
		return 0f;
	}
}
[Serializable]
public class OVRLipSyncSequence : ScriptableObject
{
	public List<OVRLipSync.Frame> entries = new List<OVRLipSync.Frame>();

	public float length;

	public OVRLipSync.Frame GetFrameAtTime(float time)
	{
		OVRLipSync.Frame result = null;
		if (time < length && entries.Count > 0)
		{
			float num = time / length;
			result = entries[(int)((float)entries.Count * num)];
		}
		return result;
	}
}
public class BufferedAudioStream
{
	private const bool VerboseLogging = false;

	private AudioSource audio;

	private float[] audioBuffer;

	private int writePos;

	private const float bufferLengthSeconds = 0.25f;

	private const int sampleRate = 48000;

	private const int bufferSize = 12000;

	private const float playbackDelayTimeSeconds = 0.05f;

	private float playbackDelayRemaining;

	private float remainingBufferTime;

	public BufferedAudioStream(AudioSource audio)
	{
		audioBuffer = new float[12000];
		this.audio = audio;
		audio.loop = true;
		audio.clip = AudioClip.Create("", 12000, 1, 48000, stream: false);
		Stop();
	}

	public void Update()
	{
		if (remainingBufferTime > 0f)
		{
			if (!audio.isPlaying && remainingBufferTime > 0.05f)
			{
				playbackDelayRemaining -= Time.deltaTime;
				if (playbackDelayRemaining <= 0f)
				{
					audio.Play();
				}
			}
			if (audio.isPlaying)
			{
				remainingBufferTime -= Time.deltaTime;
				if (remainingBufferTime < 0f)
				{
					remainingBufferTime = 0f;
				}
			}
		}
		if (remainingBufferTime <= 0f)
		{
			if (audio.isPlaying)
			{
				UnityEngine.Debug.Log("Buffer empty, stopping " + DateTime.Now);
				Stop();
			}
			else if (writePos != 0)
			{
				UnityEngine.Debug.LogError("writePos non zero while not playing, how did this happen?");
			}
		}
	}

	private void Stop()
	{
		audio.Stop();
		audio.time = 0f;
		writePos = 0;
		playbackDelayRemaining = 0.05f;
	}

	public void AddData(float[] samples)
	{
		int num = samples.Length;
		if (writePos > audioBuffer.Length)
		{
			throw new Exception();
		}
		do
		{
			int num2 = num;
			int num3 = audioBuffer.Length - writePos;
			if (num2 > num3)
			{
				num2 = num3;
			}
			Array.Copy(samples, 0, audioBuffer, writePos, num2);
			num -= num2;
			writePos += num2;
			if (writePos > audioBuffer.Length)
			{
				throw new Exception();
			}
			if (writePos == audioBuffer.Length)
			{
				writePos = 0;
			}
		}
		while (num > 0);
		remainingBufferTime += (float)samples.Length / 48000f;
		audio.clip.SetData(audioBuffer, 0);
	}
}
[AddComponentMenu("Camera-Control/Mouse Look")]
public class MouseLook : MonoBehaviour
{
	public enum RotationAxes
	{
		MouseXAndY,
		MouseX,
		MouseY
	}

	public RotationAxes axes;

	public float sensitivityX = 15f;

	public float sensitivityY = 15f;

	public float minimumX = -360f;

	public float maximumX = 360f;

	public float minimumY = -60f;

	public float maximumY = 60f;

	private float rotationY;

	private void Update()
	{
		if (axes == RotationAxes.MouseXAndY)
		{
			float y = base.transform.localEulerAngles.y + Input.GetAxis("Mouse X") * sensitivityX;
			rotationY += Input.GetAxis("Mouse Y") * sensitivityY;
			rotationY = Mathf.Clamp(rotationY, minimumY, maximumY);
			base.transform.localEulerAngles = new Vector3(0f - rotationY, y, 0f);
		}
		else if (axes == RotationAxes.MouseX)
		{
			base.transform.Rotate(0f, Input.GetAxis("Mouse X") * sensitivityX, 0f);
		}
		else
		{
			rotationY += Input.GetAxis("Mouse Y") * sensitivityY;
			rotationY = Mathf.Clamp(rotationY, minimumY, maximumY);
			base.transform.localEulerAngles = new Vector3(0f - rotationY, base.transform.localEulerAngles.y, 0f);
		}
	}

	private void Start()
	{
		if ((bool)GetComponent<Rigidbody>())
		{
			GetComponent<Rigidbody>().freezeRotation = true;
		}
	}
}
public struct ReflectionSnapshot
{
	public AudioMixerSnapshot mixerSnapshot;

	public float fadeTime;
}
public class ONSPReflectionZone : MonoBehaviour
{
	public AudioMixerSnapshot mixerSnapshot;

	public float fadeTime;

	private static Stack<ReflectionSnapshot> snapshotList = new Stack<ReflectionSnapshot>();

	private static ReflectionSnapshot currentSnapshot = default(ReflectionSnapshot);

	private void Start()
	{
	}

	private void Update()
	{
	}

	private void OnTriggerEnter(Collider other)
	{
		if (CheckForAudioListener(other.gameObject))
		{
			PushCurrentMixerShapshot();
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (CheckForAudioListener(other.gameObject))
		{
			PopCurrentMixerSnapshot();
		}
	}

	private bool CheckForAudioListener(GameObject gameObject)
	{
		if (gameObject.GetComponentInChildren<AudioListener>() != null)
		{
			return true;
		}
		return false;
	}

	private void PushCurrentMixerShapshot()
	{
		ReflectionSnapshot item = currentSnapshot;
		snapshotList.Push(item);
		SetReflectionValues();
	}

	private void PopCurrentMixerSnapshot()
	{
		ReflectionSnapshot mss = snapshotList.Pop();
		SetReflectionValues(ref mss);
	}

	private void SetReflectionValues()
	{
		if (mixerSnapshot != null)
		{
			UnityEngine.Debug.Log("Setting off snapshot " + mixerSnapshot.name);
			mixerSnapshot.TransitionTo(fadeTime);
			currentSnapshot.mixerSnapshot = mixerSnapshot;
			currentSnapshot.fadeTime = fadeTime;
		}
		else
		{
			UnityEngine.Debug.Log("Mixer snapshot not set - Please ensure play area has at least one encompassing snapshot.");
		}
	}

	private void SetReflectionValues(ref ReflectionSnapshot mss)
	{
		if (mss.mixerSnapshot != null)
		{
			UnityEngine.Debug.Log("Setting off snapshot " + mss.mixerSnapshot.name);
			mss.mixerSnapshot.TransitionTo(mss.fadeTime);
			currentSnapshot.mixerSnapshot = mss.mixerSnapshot;
			currentSnapshot.fadeTime = mss.fadeTime;
		}
		else
		{
			UnityEngine.Debug.Log("Mixer snapshot not set - Please ensure play area has at least one encompassing snapshot.");
		}
	}
}
public class OculusSpatializerUnity : MonoBehaviour
{
	public delegate void AudioRaycastCallback(Vector3 origin, Vector3 direction, out Vector3 point, out Vector3 normal, IntPtr data);

	public LayerMask layerMask = -1;

	public bool visualizeRoom = true;

	private bool roomVisualizationInitialized;

	public int raysPerSecond = 256;

	public float roomInterpSpeed = 0.9f;

	public float maxWallDistance = 50f;

	public int rayCacheSize = 512;

	public bool dynamicReflectionsEnabled = true;

	private AudioRaycastCallback _raycastCallback;

	private float particleSize = 0.2f;

	private float particleOffset = 0.1f;

	private GameObject room;

	private Renderer[] wallRenderer = new Renderer[6];

	private float[] dims = new float[3] { 1f, 1f, 1f };

	private float[] coefs = new float[6];

	private const int HIT_COUNT = 2048;

	private Vector3[] points = new Vector3[2048];

	private Vector3[] normals = new Vector3[2048];

	private ParticleSystem sys;

	private ParticleSystem.Particle[] particles = new ParticleSystem.Particle[2048];

	private static LayerMask gLayerMask = -1;

	private const string strOSP = "AudioPluginOculusSpatializer";

	private static Vector3 swapHandedness(Vector3 vec)
	{
		return new Vector3(vec.x, vec.y, 0f - vec.z);
	}

	private static void AudioRaycast(Vector3 origin, Vector3 direction, out Vector3 point, out Vector3 normal, IntPtr data)
	{
		point = Vector3.zero;
		normal = Vector3.zero;
		if (Physics.Raycast(swapHandedness(origin), swapHandedness(direction), out var hitInfo, 1000f, gLayerMask.value))
		{
			point = swapHandedness(hitInfo.point);
			normal = swapHandedness(hitInfo.normal);
		}
	}

	private void Start()
	{
		_raycastCallback = AudioRaycast;
		OSP_Unity_AssignRaycastCallback(_raycastCallback, IntPtr.Zero);
	}

	private void OnDestroy()
	{
		OSP_Unity_AssignRaycastCallback(IntPtr.Zero, IntPtr.Zero);
	}

	private void Update()
	{
		if (dynamicReflectionsEnabled)
		{
			OSP_Unity_AssignRaycastCallback(_raycastCallback, IntPtr.Zero);
		}
		else
		{
			OSP_Unity_AssignRaycastCallback(IntPtr.Zero, IntPtr.Zero);
		}
		OSP_Unity_SetDynamicRoomRaysPerSecond(raysPerSecond);
		OSP_Unity_SetDynamicRoomInterpSpeed(roomInterpSpeed);
		OSP_Unity_SetDynamicRoomMaxWallDistance(maxWallDistance);
		OSP_Unity_SetDynamicRoomRaysRayCacheSize(rayCacheSize);
		gLayerMask = layerMask;
		OSP_Unity_UpdateRoomModel(1f);
		if (!visualizeRoom)
		{
			return;
		}
		if (!roomVisualizationInitialized)
		{
			inititalizeRoomVisualization();
			roomVisualizationInitialized = true;
		}
		OSP_Unity_GetRoomDimensions(dims, coefs, out var position);
		position.z *= -1f;
		Vector3 vector = new Vector3(dims[0], dims[1], dims[2]);
		float sqrMagnitude = vector.sqrMagnitude;
		if (!float.IsNaN(sqrMagnitude) && 0f < sqrMagnitude && sqrMagnitude < 1000000f)
		{
			base.transform.localScale = vector * 0.999f;
		}
		base.transform.position = position;
		OSP_Unity_GetRaycastHits(points, normals, 2048);
		for (int i = 0; i < 2048; i++)
		{
			if (points[i] == Vector3.zero)
			{
				points[i].y = -10000f;
			}
			points[i].z *= -1f;
			normals[i].z *= -1f;
			particles[i].position = points[i] + normals[i] * particleOffset;
			if (normals[i] != Vector3.zero)
			{
				particles[i].rotation3D = Quaternion.LookRotation(normals[i]).eulerAngles;
			}
			particles[i].startSize = particleSize;
			particles[i].startColor = new Color(0.8156863f, 0.14901961f, 58f / 85f, 1f);
		}
		for (int j = 0; j < 6; j++)
		{
			Color value = Color.Lerp(Color.red, Color.green, coefs[j]);
			wallRenderer[j].material.SetColor("_TintColor", value);
		}
		sys.SetParticles(particles, particles.Length);
	}

	private void inititalizeRoomVisualization()
	{
		UnityEngine.Debug.Log("Oculus Audio dynamic room estimation visualization enabled");
		base.transform.position = Vector3.zero;
		GameObject gameObject = new GameObject("DecalManager");
		gameObject.transform.parent = base.transform;
		sys = gameObject.AddComponent<ParticleSystem>();
		ParticleSystem.MainModule main = sys.main;
		main.simulationSpace = ParticleSystemSimulationSpace.World;
		main.loop = false;
		main.playOnAwake = false;
		ParticleSystem.EmissionModule emission = sys.emission;
		emission.enabled = false;
		ParticleSystem.ShapeModule shape = sys.shape;
		shape.enabled = false;
		ParticleSystemRenderer component = sys.GetComponent<ParticleSystemRenderer>();
		component.renderMode = ParticleSystemRenderMode.Mesh;
		component.material.shader = Shader.Find("Particles/Additive");
		Texture2D texture2D = new Texture2D(64, 64);
		for (int i = 0; i < 32; i++)
		{
			for (int j = 0; j < 32; j++)
			{
				float num = 32 - i;
				float num2 = 32 - j;
				float num3 = Mathf.Sqrt(num * num + num2 * num2);
				float num4 = 2f * num3 / 32f;
				float a = ((num3 < 32f) ? Mathf.Clamp01(Mathf.Sin((float)Math.PI * 2f * num4)) : 0f);
				Color color = new Color(1f, 1f, 1f, a);
				texture2D.SetPixel(i, j, color);
				texture2D.SetPixel(64 - i, j, color);
				texture2D.SetPixel(i, 64 - j, color);
				texture2D.SetPixel(64 - i, 64 - j, color);
			}
		}
		texture2D.Apply();
		component.material.mainTexture = texture2D;
		Mesh mesh = new Mesh();
		mesh.name = "ParticleQuad";
		mesh.vertices = new Vector3[4]
		{
			new Vector3(-0.5f, -0.5f, 0f),
			new Vector3(0.5f, -0.5f, 0f),
			new Vector3(0.5f, 0.5f, 0f),
			new Vector3(-0.5f, 0.5f, 0f)
		};
		mesh.uv = new Vector2[4]
		{
			new Vector2(0f, 0f),
			new Vector2(0f, 1f),
			new Vector2(1f, 1f),
			new Vector2(1f, 0f)
		};
		mesh.triangles = new int[6] { 0, 1, 2, 0, 2, 3 };
		mesh.RecalculateNormals();
		component.mesh = mesh;
		sys.Emit(2048);
		room = new GameObject("RoomVisualizer");
		room.transform.parent = base.transform;
		room.transform.localPosition = Vector3.zero;
		Texture2D texture2D2 = new Texture2D(32, 32);
		Color color2 = new Color(0f, 0f, 0f, 0f);
		for (int k = 0; k < 32; k++)
		{
			for (int l = 0; l < 32; l++)
			{
				texture2D2.SetPixel(k, l, color2);
			}
		}
		for (int m = 0; m < 32; m++)
		{
			Color color3 = Color.white * 0.125f;
			texture2D2.SetPixel(8, m, color3);
			texture2D2.SetPixel(m, 8, color3);
			texture2D2.SetPixel(24, m, color3);
			texture2D2.SetPixel(m, 24, color3);
			color3 *= 2f;
			texture2D2.SetPixel(16, m, color3);
			texture2D2.SetPixel(m, 16, color3);
			color3 *= 2f;
			texture2D2.SetPixel(0, m, color3);
			texture2D2.SetPixel(m, 0, color3);
		}
		texture2D2.Apply();
		for (int n = 0; n < 6; n++)
		{
			Mesh mesh2 = new Mesh();
			mesh2.name = "Plane" + n;
			Vector3[] array = new Vector3[4];
			int num5 = n / 2;
			int num6 = ((n % 2 == 0) ? 1 : (-1));
			for (int num7 = 0; num7 < 4; num7++)
			{
				array[num7][num5] = (float)num6 * 0.5f;
				array[num7][(num5 + 1) % 3] = 0.5f * (float)((num7 == 1 || num7 == 2) ? 1 : (-1));
				array[num7][(num5 + 2) % 3] = 0.5f * (float)((num7 == 2 || num7 == 3) ? 1 : (-1));
			}
			mesh2.vertices = array;
			mesh2.uv = new Vector2[4]
			{
				new Vector2(0f, 0f),
				new Vector2(0f, 1f),
				new Vector2(1f, 1f),
				new Vector2(1f, 0f)
			};
			mesh2.triangles = new int[6] { 0, 1, 2, 0, 2, 3 };
			mesh2.RecalculateNormals();
			GameObject obj = new GameObject("Wall_" + n);
			obj.AddComponent<MeshFilter>().mesh = mesh2;
			MeshRenderer meshRenderer = obj.AddComponent<MeshRenderer>();
			wallRenderer[n] = meshRenderer;
			meshRenderer.material.shader = Shader.Find("Particles/Additive");
			meshRenderer.material.mainTexture = texture2D2;
			meshRenderer.material.mainTextureScale = new Vector2(8f, 8f);
			obj.transform.parent = room.transform;
			room.transform.localPosition = Vector3.zero;
		}
	}

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_AssignRaycastCallback(MulticastDelegate callback, IntPtr data);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_AssignRaycastCallback(IntPtr callback, IntPtr data);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_SetDynamicRoomRaysPerSecond(int RaysPerSecond);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_SetDynamicRoomInterpSpeed(float InterpSpeed);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_SetDynamicRoomMaxWallDistance(float MaxWallDistance);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_SetDynamicRoomRaysRayCacheSize(int RayCacheSize);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_UpdateRoomModel(float wetLevel);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_GetRoomDimensions(float[] roomDimensions, float[] reflectionsCoefs, out Vector3 position);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_GetRaycastHits(Vector3[] points, Vector3[] normals, int length);
}
public class ONSPAmbisonicsNative : MonoBehaviour
{
	public enum ovrAmbisonicsNativeStatus
	{
		Uninitialized = -1,
		NotEnabled,
		Success,
		StreamError,
		ProcessError,
		MaxStatValue
	}

	private static int numFOAChannels = 4;

	private static int paramVSpeakerMode = 6;

	private static int paramAmbiStat = 7;

	private ovrAmbisonicsNativeStatus currentStatus = ovrAmbisonicsNativeStatus.Uninitialized;

	[SerializeField]
	private bool useVirtualSpeakers;

	public bool UseVirtualSpeakers
	{
		get
		{
			return useVirtualSpeakers;
		}
		set
		{
			useVirtualSpeakers = value;
		}
	}

	private void OnEnable()
	{
		AudioSource component = GetComponent<AudioSource>();
		currentStatus = ovrAmbisonicsNativeStatus.Uninitialized;
		if (component == null)
		{
			UnityEngine.Debug.Log("Ambisonic ERROR: AudioSource does not exist.");
			return;
		}
		if (component.spatialize)
		{
			UnityEngine.Debug.Log("Ambisonic WARNING: Turning spatialize field off for Ambisonic sources.");
			component.spatialize = false;
		}
		if (component.clip == null)
		{
			UnityEngine.Debug.Log("Ambisonic ERROR: AudioSource does not contain an audio clip.");
		}
		else if (component.clip.channels != numFOAChannels)
		{
			UnityEngine.Debug.Log("Ambisonic ERROR: AudioSource clip does not have correct number of channels.");
		}
	}

	private void Update()
	{
		AudioSource component = GetComponent<AudioSource>();
		if (component == null)
		{
			return;
		}
		if (useVirtualSpeakers)
		{
			component.SetAmbisonicDecoderFloat(paramVSpeakerMode, 1f);
		}
		else
		{
			component.SetAmbisonicDecoderFloat(paramVSpeakerMode, 0f);
		}
		float value = 0f;
		component.GetAmbisonicDecoderFloat(paramAmbiStat, out value);
		ovrAmbisonicsNativeStatus ovrAmbisonicsNativeStatus = (ovrAmbisonicsNativeStatus)value;
		if (ovrAmbisonicsNativeStatus != currentStatus)
		{
			switch (ovrAmbisonicsNativeStatus)
			{
			case ovrAmbisonicsNativeStatus.NotEnabled:
				UnityEngine.Debug.Log("Ambisonic Native: Ambisonic not enabled on clip. Check clip field and turn it on");
				break;
			case ovrAmbisonicsNativeStatus.Uninitialized:
				UnityEngine.Debug.Log("Ambisonic Native: Stream uninitialized");
				break;
			case ovrAmbisonicsNativeStatus.Success:
				UnityEngine.Debug.Log("Ambisonic Native: Stream successfully initialized and playing/playable");
				break;
			case ovrAmbisonicsNativeStatus.StreamError:
				UnityEngine.Debug.Log("Ambisonic Native WARNING: Stream error (bad input format?)");
				break;
			case ovrAmbisonicsNativeStatus.ProcessError:
				UnityEngine.Debug.Log("Ambisonic Native WARNING: Stream process error (check default speaker setup)");
				break;
			}
		}
		currentStatus = ovrAmbisonicsNativeStatus;
	}
}
public class ONSPAudioSource : MonoBehaviour
{
	private enum Parameters
	{
		P_GAIN,
		P_USEINVSQR,
		P_NEAR,
		P_FAR,
		P_RADIUS,
		P_DISABLE_RFL,
		P_VSPEAKERMODE,
		P_AMBISTAT,
		P_READONLY_GLOBAL_RFL_ENABLED,
		P_READONLY_NUM_VOICES,
		P_SENDLEVEL,
		P_NUM
	}

	public const string strONSPS = "AudioPluginOculusSpatializer";

	[SerializeField]
	private bool enableSpatialization = true;

	[SerializeField]
	private float gain;

	[SerializeField]
	private bool useInvSqr;

	[SerializeField]
	private float near = 0.25f;

	[SerializeField]
	private float far = 250f;

	[SerializeField]
	private float volumetricRadius;

	[SerializeField]
	private float reverbSend;

	[SerializeField]
	private bool enableRfl;

	private static ONSPAudioSource RoomReflectionGizmoAS;

	public bool EnableSpatialization
	{
		get
		{
			return enableSpatialization;
		}
		set
		{
			enableSpatialization = value;
		}
	}

	public float Gain
	{
		get
		{
			return gain;
		}
		set
		{
			gain = Mathf.Clamp(value, 0f, 24f);
		}
	}

	public bool UseInvSqr
	{
		get
		{
			return useInvSqr;
		}
		set
		{
			useInvSqr = value;
		}
	}

	public float Near
	{
		get
		{
			return near;
		}
		set
		{
			near = Mathf.Clamp(value, 0f, 1000000f);
		}
	}

	public float Far
	{
		get
		{
			return far;
		}
		set
		{
			far = Mathf.Clamp(value, 0f, 1000000f);
		}
	}

	public float VolumetricRadius
	{
		get
		{
			return volumetricRadius;
		}
		set
		{
			volumetricRadius = Mathf.Clamp(value, 0f, 1000f);
		}
	}

	public float ReverbSend
	{
		get
		{
			return reverbSend;
		}
		set
		{
			reverbSend = Mathf.Clamp(value, -60f, 20f);
		}
	}

	public bool EnableRfl
	{
		get
		{
			return enableRfl;
		}
		set
		{
			enableRfl = value;
		}
	}

	private static void OnBeforeSceneLoadRuntimeMethod()
	{
		OSP_SetGlobalVoiceLimit(ONSPSettings.Instance.voiceLimit);
	}

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern void ONSP_GetGlobalRoomReflectionValues(ref bool reflOn, ref bool reverbOn, ref float width, ref float height, ref float length);

	private void Awake()
	{
		AudioSource source = GetComponent<AudioSource>();
		SetParameters(ref source);
	}

	private void Start()
	{
	}

	private void Update()
	{
		AudioSource source = GetComponent<AudioSource>();
		if (!UnityEngine.Application.isPlaying || AudioListener.pause || !source.isPlaying || !source.isActiveAndEnabled)
		{
			source.spatialize = false;
		}
		else
		{
			SetParameters(ref source);
		}
	}

	public void SetParameters(ref AudioSource source)
	{
		source.spatialize = enableSpatialization;
		source.SetSpatializerFloat(0, gain);
		if (useInvSqr)
		{
			source.SetSpatializerFloat(1, 1f);
		}
		else
		{
			source.SetSpatializerFloat(1, 0f);
		}
		source.SetSpatializerFloat(2, near);
		source.SetSpatializerFloat(3, far);
		source.SetSpatializerFloat(4, volumetricRadius);
		if (enableRfl)
		{
			source.SetSpatializerFloat(5, 0f);
		}
		else
		{
			source.SetSpatializerFloat(5, 1f);
		}
		source.SetSpatializerFloat(10, reverbSend);
	}

	private void OnDrawGizmos()
	{
		if (RoomReflectionGizmoAS == null)
		{
			RoomReflectionGizmoAS = this;
		}
		Color color = default(Color);
		color.r = 1f;
		color.g = 0.5f;
		color.b = 0f;
		color.a = 1f;
		Gizmos.color = color;
		Gizmos.DrawWireSphere(base.transform.position, Near);
		color.a = 0.1f;
		Gizmos.color = color;
		Gizmos.DrawSphere(base.transform.position, Near);
		color.r = 1f;
		color.g = 0f;
		color.b = 0f;
		color.a = 1f;
		Gizmos.color = Color.red;
		Gizmos.DrawWireSphere(base.transform.position, Far);
		color.a = 0.1f;
		Gizmos.color = color;
		Gizmos.DrawSphere(base.transform.position, Far);
		color.r = 1f;
		color.g = 0f;
		color.b = 1f;
		color.a = 1f;
		Gizmos.color = color;
		Gizmos.DrawWireSphere(base.transform.position, VolumetricRadius);
		color.a = 0.1f;
		Gizmos.color = color;
		Gizmos.DrawSphere(base.transform.position, VolumetricRadius);
		if (RoomReflectionGizmoAS == this)
		{
			bool reflOn = false;
			bool reverbOn = false;
			float width = 1f;
			float height = 1f;
			float length = 1f;
			ONSP_GetGlobalRoomReflectionValues(ref reflOn, ref reverbOn, ref width, ref height, ref length);
			if (Camera.main != null && reflOn)
			{
				color = (Gizmos.color = ((!reverbOn) ? Color.cyan : Color.white));
				Gizmos.DrawWireCube(Camera.main.transform.position, new Vector3(width, height, length));
				color.a = 0.1f;
				Gizmos.color = color;
				Gizmos.DrawCube(Camera.main.transform.position, new Vector3(width, height, length));
			}
		}
	}

	private void OnDestroy()
	{
		if (RoomReflectionGizmoAS == this)
		{
			RoomReflectionGizmoAS = null;
		}
	}

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_SetGlobalVoiceLimit(int VoiceLimit);
}
public class ONSPProfiler : MonoBehaviour
{
	public bool profilerEnabled;

	private const int DEFAULT_PORT = 2121;

	public int port = 2121;

	public const string strONSPS = "AudioPluginOculusSpatializer";

	private void Start()
	{
		UnityEngine.Application.runInBackground = true;
	}

	private void Update()
	{
		if (port < 0 || port > 65535)
		{
			port = 2121;
		}
		ONSP_SetProfilerPort(port);
		ONSP_SetProfilerEnabled(profilerEnabled);
	}

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int ONSP_SetProfilerEnabled(bool enabled);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int ONSP_SetProfilerPort(int port);
}
public class ONSPPropagationGeometry : MonoBehaviour
{
	private struct MeshMaterial
	{
		public MeshFilter meshFilter;

		public ONSPPropagationMaterial[] materials;
	}

	private struct TerrainMaterial
	{
		public Terrain terrain;

		public ONSPPropagationMaterial[] materials;

		public Mesh[] treePrototypeMeshes;
	}

	public static string GeometryAssetDirectory = "AudioGeometry";

	public string filePathRelative = "";

	public bool fileEnabled;

	public bool includeChildMeshes = true;

	private IntPtr geometryHandle = IntPtr.Zero;

	public static int OSPSuccess = 0;

	public const string GEOMETRY_FILE_EXTENSION = "ovramesh";

	private static int terrainDecimation = 4;

	public static string GeometryAssetPath => UnityEngine.Application.streamingAssetsPath + "/" + GeometryAssetDirectory;

	public string filePath => GeometryAssetPath + "/" + filePathRelative;

	private static string GetPath(Transform current)
	{
		if (current.parent == null)
		{
			return current.gameObject.scene.name + "/" + current.name;
		}
		return GetPath(current.parent) + "-" + current.name;
	}

	private void Awake()
	{
		CreatePropagationGeometry();
	}

	private void CreatePropagationGeometry()
	{
		if (ONSPPropagation.Interface.CreateAudioGeometry(out geometryHandle) != OSPSuccess)
		{
			throw new Exception("Unable to create geometry handle");
		}
		if (filePath != null && filePath.Length != 0 && fileEnabled && UnityEngine.Application.isPlaying)
		{
			if (!ReadFile())
			{
				UnityEngine.Debug.LogError("Failed to read file, attempting to regenerate audio geometry");
				UploadGeometry();
			}
		}
		else
		{
			UploadGeometry();
		}
	}

	private void Update()
	{
		if (!(geometryHandle == IntPtr.Zero))
		{
			Matrix4x4 localToWorldMatrix = base.transform.localToWorldMatrix;
			float[] matrix4x = new float[16]
			{
				localToWorldMatrix[0, 0],
				localToWorldMatrix[1, 0],
				0f - localToWorldMatrix[2, 0],
				localToWorldMatrix[3, 0],
				localToWorldMatrix[0, 1],
				localToWorldMatrix[1, 1],
				0f - localToWorldMatrix[2, 1],
				localToWorldMatrix[3, 1],
				localToWorldMatrix[0, 2],
				localToWorldMatrix[1, 2],
				0f - localToWorldMatrix[2, 2],
				localToWorldMatrix[3, 2],
				localToWorldMatrix[0, 3],
				localToWorldMatrix[1, 3],
				0f - localToWorldMatrix[2, 3],
				localToWorldMatrix[3, 3]
			};
			ONSPPropagation.Interface.AudioGeometrySetTransform(geometryHandle, matrix4x);
		}
	}

	private void OnDestroy()
	{
		if (geometryHandle != IntPtr.Zero && ONSPPropagation.Interface.DestroyAudioGeometry(geometryHandle) != OSPSuccess)
		{
			throw new Exception("Unable to destroy geometry");
		}
		geometryHandle = IntPtr.Zero;
	}

	private static void traverseMeshHierarchy(GameObject obj, ONSPPropagationMaterial[] currentMaterials, bool includeChildren, List<MeshMaterial> meshMaterials, List<TerrainMaterial> terrainMaterials, bool ignoreStatic, ref int ignoredMeshCount)
	{
		if (!obj.activeInHierarchy)
		{
			return;
		}
		MeshFilter[] components = obj.GetComponents<MeshFilter>();
		Terrain[] components2 = obj.GetComponents<Terrain>();
		ONSPPropagationMaterial[] components3 = obj.GetComponents<ONSPPropagationMaterial>();
		if (components3 != null && components3.Length != 0)
		{
			int num = components3.Length;
			if (currentMaterials != null)
			{
				num = Math.Max(num, currentMaterials.Length);
			}
			ONSPPropagationMaterial[] array = new ONSPPropagationMaterial[num];
			if (currentMaterials != null)
			{
				for (int i = components3.Length; i < num; i++)
				{
					array[i] = currentMaterials[i];
				}
			}
			currentMaterials = array;
			for (int j = 0; j < components3.Length; j++)
			{
				currentMaterials[j] = components3[j];
			}
		}
		MeshFilter[] array2 = components;
		foreach (MeshFilter meshFilter in array2)
		{
			Mesh sharedMesh = meshFilter.sharedMesh;
			if (!(sharedMesh == null))
			{
				if (ignoreStatic && !sharedMesh.isReadable)
				{
					UnityEngine.Debug.LogWarning("Mesh: " + meshFilter.gameObject.name + " not readable, cannot be static.", meshFilter.gameObject);
					ignoredMeshCount++;
					continue;
				}
				MeshMaterial item = default(MeshMaterial);
				item.meshFilter = meshFilter;
				item.materials = currentMaterials;
				meshMaterials.Add(item);
			}
		}
		Terrain[] array3 = components2;
		foreach (Terrain terrain in array3)
		{
			TerrainMaterial item2 = default(TerrainMaterial);
			item2.terrain = terrain;
			item2.materials = currentMaterials;
			terrainMaterials.Add(item2);
		}
		if (!includeChildren)
		{
			return;
		}
		foreach (Transform item3 in obj.transform)
		{
			if (item3.GetComponent<ONSPPropagationGeometry>() == null)
			{
				traverseMeshHierarchy(item3.gameObject, currentMaterials, includeChildren, meshMaterials, terrainMaterials, ignoreStatic, ref ignoredMeshCount);
			}
		}
	}

	private int uploadMesh(IntPtr geometryHandle, GameObject meshObject, Matrix4x4 worldToLocal)
	{
		int ignoredMeshCount = 0;
		return uploadMesh(geometryHandle, meshObject, worldToLocal, ignoreStatic: false, ref ignoredMeshCount);
	}

	private int uploadMesh(IntPtr geometryHandle, GameObject meshObject, Matrix4x4 worldToLocal, bool ignoreStatic, ref int ignoredMeshCount)
	{
		List<MeshMaterial> list = new List<MeshMaterial>();
		List<TerrainMaterial> list2 = new List<TerrainMaterial>();
		traverseMeshHierarchy(meshObject, null, includeChildMeshes, list, list2, ignoreStatic, ref ignoredMeshCount);
		ONSPPropagationMaterial[] array = new ONSPPropagationMaterial[1] { base.gameObject.AddComponent<ONSPPropagationMaterial>() };
		array[0].SetPreset(ONSPPropagationMaterial.Preset.Foliage);
		int totalVertexCount = 0;
		uint totalIndexCount = 0u;
		int totalFaceCount = 0;
		int totalMaterialCount = 0;
		foreach (MeshMaterial item in list)
		{
			updateCountsForMesh(ref totalVertexCount, ref totalIndexCount, ref totalFaceCount, ref totalMaterialCount, item.meshFilter.sharedMesh);
		}
		for (int i = 0; i < list2.Count; i++)
		{
			TerrainMaterial value = list2[i];
			TerrainData terrainData = value.terrain.terrainData;
			int heightmapWidth = terrainData.heightmapWidth;
			int heightmapHeight = terrainData.heightmapHeight;
			int num = (heightmapWidth - 1) / terrainDecimation + 1;
			int num2 = (heightmapHeight - 1) / terrainDecimation + 1;
			int num3 = num * num2;
			int num4 = (num - 1) * (num2 - 1) * 6;
			totalMaterialCount++;
			totalVertexCount += num3;
			totalIndexCount += (uint)num4;
			totalFaceCount += num4 / 3;
			TreePrototype[] treePrototypes = terrainData.treePrototypes;
			value.treePrototypeMeshes = new Mesh[treePrototypes.Length];
			for (int j = 0; j < treePrototypes.Length; j++)
			{
				MeshFilter[] componentsInChildren = treePrototypes[j].prefab.GetComponentsInChildren<MeshFilter>();
				int num5 = int.MaxValue;
				int num6 = -1;
				for (int k = 0; k < componentsInChildren.Length; k++)
				{
					int vertexCount = componentsInChildren[k].sharedMesh.vertexCount;
					if (vertexCount < num5)
					{
						num5 = vertexCount;
						num6 = k;
					}
				}
				value.treePrototypeMeshes[j] = componentsInChildren[num6].sharedMesh;
			}
			TreeInstance[] treeInstances = terrainData.treeInstances;
			for (int l = 0; l < treeInstances.Length; l++)
			{
				TreeInstance treeInstance = treeInstances[l];
				updateCountsForMesh(ref totalVertexCount, ref totalIndexCount, ref totalFaceCount, ref totalMaterialCount, value.treePrototypeMeshes[treeInstance.prototypeIndex]);
			}
			list2[i] = value;
		}
		List<Vector3> tempVertices = new List<Vector3>();
		List<int> tempIndices = new List<int>();
		MeshGroup[] array2 = new MeshGroup[totalMaterialCount];
		float[] array3 = new float[totalVertexCount * 3];
		int[] array4 = new int[totalIndexCount];
		int vertexOffset = 0;
		int indexOffset = 0;
		int groupOffset = 0;
		foreach (MeshMaterial item2 in list)
		{
			MeshFilter meshFilter = item2.meshFilter;
			Matrix4x4 matrix = worldToLocal * meshFilter.gameObject.transform.localToWorldMatrix;
			uploadMeshFilter(tempVertices, tempIndices, array2, array3, array4, ref vertexOffset, ref indexOffset, ref groupOffset, meshFilter.sharedMesh, item2.materials, matrix);
		}
		foreach (TerrainMaterial item3 in list2)
		{
			TerrainData terrainData2 = item3.terrain.terrainData;
			Matrix4x4 matrix4x = worldToLocal * item3.terrain.gameObject.transform.localToWorldMatrix;
			int heightmapWidth2 = terrainData2.heightmapWidth;
			int heightmapHeight2 = terrainData2.heightmapHeight;
			float[,] heights = terrainData2.GetHeights(0, 0, heightmapWidth2, heightmapHeight2);
			Vector3 size = terrainData2.size;
			size = new Vector3(size.x / (float)(heightmapWidth2 - 1) * (float)terrainDecimation, size.y, size.z / (float)(heightmapHeight2 - 1) * (float)terrainDecimation);
			int num7 = (heightmapWidth2 - 1) / terrainDecimation + 1;
			int num8 = (heightmapHeight2 - 1) / terrainDecimation + 1;
			int num9 = num7 * num8;
			int num10 = (num7 - 1) * (num8 - 1) * 2;
			array2[groupOffset].faceType = FaceType.TRIANGLES;
			array2[groupOffset].faceCount = (UIntPtr)(ulong)num10;
			array2[groupOffset].indexOffset = (UIntPtr)(ulong)indexOffset;
			if (item3.materials != null && item3.materials.Length != 0)
			{
				item3.materials[0].StartInternal();
				array2[groupOffset].material = item3.materials[0].materialHandle;
			}
			else
			{
				array2[groupOffset].material = IntPtr.Zero;
			}
			for (int m = 0; m < num8; m++)
			{
				for (int n = 0; n < num7; n++)
				{
					int num11 = (vertexOffset + m * num7 + n) * 3;
					Vector3 vector = matrix4x.MultiplyPoint3x4(Vector3.Scale(size, new Vector3(m, heights[n * terrainDecimation, m * terrainDecimation], n)));
					array3[num11] = vector.x;
					array3[num11 + 1] = vector.y;
					array3[num11 + 2] = vector.z;
				}
			}
			for (int num12 = 0; num12 < num8 - 1; num12++)
			{
				for (int num13 = 0; num13 < num7 - 1; num13++)
				{
					array4[indexOffset] = vertexOffset + num12 * num7 + num13;
					array4[indexOffset + 1] = vertexOffset + (num12 + 1) * num7 + num13;
					array4[indexOffset + 2] = vertexOffset + num12 * num7 + num13 + 1;
					array4[indexOffset + 3] = vertexOffset + (num12 + 1) * num7 + num13;
					array4[indexOffset + 4] = vertexOffset + (num12 + 1) * num7 + num13 + 1;
					array4[indexOffset + 5] = vertexOffset + num12 * num7 + num13 + 1;
					indexOffset += 6;
				}
			}
			vertexOffset += num9;
			groupOffset++;
			TreeInstance[] treeInstances = terrainData2.treeInstances;
			for (int l = 0; l < treeInstances.Length; l++)
			{
				TreeInstance treeInstance2 = treeInstances[l];
				Vector3 vector2 = Vector3.Scale(treeInstance2.position, terrainData2.size);
				Matrix4x4 localToWorldMatrix = item3.terrain.gameObject.transform.localToWorldMatrix;
				localToWorldMatrix.SetColumn(3, localToWorldMatrix.GetColumn(3) + new Vector4(vector2.x, vector2.y, vector2.z, 0f));
				Matrix4x4 matrix2 = worldToLocal * localToWorldMatrix;
				uploadMeshFilter(tempVertices, tempIndices, array2, array3, array4, ref vertexOffset, ref indexOffset, ref groupOffset, item3.treePrototypeMeshes[treeInstance2.prototypeIndex], array, matrix2);
			}
		}
		return ONSPPropagation.Interface.AudioGeometryUploadMeshArrays(geometryHandle, array3, totalVertexCount, array4, array4.Length, array2, array2.Length);
	}

	private static void uploadMeshFilter(List<Vector3> tempVertices, List<int> tempIndices, MeshGroup[] groups, float[] vertices, int[] indices, ref int vertexOffset, ref int indexOffset, ref int groupOffset, Mesh mesh, ONSPPropagationMaterial[] materials, Matrix4x4 matrix)
	{
		tempVertices.Clear();
		mesh.GetVertices(tempVertices);
		int count = tempVertices.Count;
		for (int i = 0; i < count; i++)
		{
			Vector3 vector = matrix.MultiplyPoint3x4(tempVertices[i]);
			int num = (vertexOffset + i) * 3;
			vertices[num] = vector.x;
			vertices[num + 1] = vector.y;
			vertices[num + 2] = vector.z;
		}
		for (int j = 0; j < mesh.subMeshCount; j++)
		{
			MeshTopology topology = mesh.GetTopology(j);
			if (topology != 0 && topology != MeshTopology.Quads)
			{
				continue;
			}
			tempIndices.Clear();
			mesh.GetIndices(tempIndices, j);
			int count2 = tempIndices.Count;
			for (int k = 0; k < count2; k++)
			{
				indices[indexOffset + k] = tempIndices[k] + vertexOffset;
			}
			switch (topology)
			{
			case MeshTopology.Triangles:
				groups[groupOffset + j].faceType = FaceType.TRIANGLES;
				groups[groupOffset + j].faceCount = (UIntPtr)(ulong)(count2 / 3);
				break;
			case MeshTopology.Quads:
				groups[groupOffset + j].faceType = FaceType.QUADS;
				groups[groupOffset + j].faceCount = (UIntPtr)(ulong)(count2 / 4);
				break;
			}
			groups[groupOffset + j].indexOffset = (UIntPtr)(ulong)indexOffset;
			if (materials != null && materials.Length != 0)
			{
				int num2 = j;
				if (num2 >= materials.Length)
				{
					num2 = materials.Length - 1;
				}
				materials[num2].StartInternal();
				groups[groupOffset + j].material = materials[num2].materialHandle;
			}
			else
			{
				groups[groupOffset + j].material = IntPtr.Zero;
			}
			indexOffset += count2;
		}
		vertexOffset += count;
		groupOffset += mesh.subMeshCount;
	}

	private static void updateCountsForMesh(ref int totalVertexCount, ref uint totalIndexCount, ref int totalFaceCount, ref int totalMaterialCount, Mesh mesh)
	{
		totalMaterialCount += mesh.subMeshCount;
		totalVertexCount += mesh.vertexCount;
		for (int i = 0; i < mesh.subMeshCount; i++)
		{
			MeshTopology topology = mesh.GetTopology(i);
			if (topology == MeshTopology.Triangles || topology == MeshTopology.Quads)
			{
				uint indexCount = mesh.GetIndexCount(i);
				totalIndexCount += indexCount;
				switch (topology)
				{
				case MeshTopology.Triangles:
					totalFaceCount += (int)indexCount / 3;
					break;
				case MeshTopology.Quads:
					totalFaceCount += (int)indexCount / 4;
					break;
				}
			}
		}
	}

	public void UploadGeometry()
	{
		int ignoredMeshCount = 0;
		if (uploadMesh(geometryHandle, base.gameObject, base.gameObject.transform.worldToLocalMatrix, ignoreStatic: true, ref ignoredMeshCount) != OSPSuccess)
		{
			throw new Exception("Unable to upload audio mesh geometry");
		}
		if (ignoredMeshCount != 0)
		{
			UnityEngine.Debug.LogError("Failed to upload meshes, " + ignoredMeshCount + " static meshes ignored. Turn on \"File Enabled\" to process static meshes offline", base.gameObject);
		}
	}

	public bool ReadFile()
	{
		if (filePath == null || filePath.Length == 0)
		{
			UnityEngine.Debug.LogError("Invalid mesh file path");
			return false;
		}
		if (ONSPPropagation.Interface.AudioGeometryReadMeshFile(geometryHandle, filePath) != OSPSuccess)
		{
			UnityEngine.Debug.LogError("Error reading mesh file " + filePath);
			return false;
		}
		return true;
	}

	public bool WriteToObj()
	{
		IntPtr geometry = IntPtr.Zero;
		if (ONSPPropagation.Interface.CreateAudioGeometry(out geometry) != OSPSuccess)
		{
			throw new Exception("Failed to create temp geometry handle");
		}
		if (uploadMesh(geometry, base.gameObject, base.gameObject.transform.worldToLocalMatrix) != OSPSuccess)
		{
			UnityEngine.Debug.LogError("Error uploading mesh " + base.gameObject.name);
			return false;
		}
		if (ONSPPropagation.Interface.AudioGeometryWriteMeshFileObj(geometry, filePath + ".obj") != OSPSuccess)
		{
			UnityEngine.Debug.LogError("Error writing .obj file " + filePath + ".obj");
			return false;
		}
		if (ONSPPropagation.Interface.DestroyAudioGeometry(geometry) != OSPSuccess)
		{
			throw new Exception("Failed to destroy temp geometry handle");
		}
		return true;
	}
}
internal class ONSPPropagation
{
	public enum ovrAudioScalarType : uint
	{
		Int8,
		UInt8,
		Int16,
		UInt16,
		Int32,
		UInt32,
		Int64,
		UInt64,
		Float16,
		Float32,
		Float64
	}

	public class ClientType
	{
		public const uint OVRA_CLIENT_TYPE_NATIVE = 0u;

		public const uint OVRA_CLIENT_TYPE_WWISE_2016 = 1u;

		public const uint OVRA_CLIENT_TYPE_WWISE_2017_1 = 2u;

		public const uint OVRA_CLIENT_TYPE_WWISE_2017_2 = 3u;

		public const uint OVRA_CLIENT_TYPE_WWISE_2018_1 = 4u;

		public const uint OVRA_CLIENT_TYPE_FMOD = 5u;

		public const uint OVRA_CLIENT_TYPE_UNITY = 6u;

		public const uint OVRA_CLIENT_TYPE_UE4 = 7u;

		public const uint OVRA_CLIENT_TYPE_VST = 8u;

		public const uint OVRA_CLIENT_TYPE_AAX = 9u;

		public const uint OVRA_CLIENT_TYPE_TEST = 10u;

		public const uint OVRA_CLIENT_TYPE_OTHER = 11u;

		public const uint OVRA_CLIENT_TYPE_WWISE_UNKNOWN = 12u;
	}

	public interface PropagationInterface
	{
		int SetPropagationQuality(float quality);

		int SetPropagationThreadAffinity(ulong cpuMask);

		int CreateAudioGeometry(out IntPtr geometry);

		int DestroyAudioGeometry(IntPtr geometry);

		int AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, int vertexCount, int[] indices, int indexCount, MeshGroup[] groups, int groupCount);

		int AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4);

		int AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4);

		int AudioGeometryWriteMeshFile(IntPtr geometry, string filePath);

		int AudioGeometryReadMeshFile(IntPtr geometry, string filePath);

		int AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath);

		int AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value);

		int CreateAudioMaterial(out IntPtr material);

		int DestroyAudioMaterial(IntPtr material);

		int AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value);

		int AudioMaterialReset(IntPtr material, MaterialProperty property);
	}

	public class UnityNativeInterface : PropagationInterface
	{
		public const string strOSPS = "AudioPluginOculusSpatializer";

		private IntPtr context_ = IntPtr.Zero;

		private IntPtr context
		{
			get
			{
				if (context_ == IntPtr.Zero)
				{
					ovrAudio_GetPluginContext(out context_, 6u);
				}
				return context_;
			}
		}

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_GetPluginContext(out IntPtr context, uint clientType);

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_SetPropagationQuality(IntPtr context, float quality);

		public int SetPropagationQuality(float quality)
		{
			return ovrAudio_SetPropagationQuality(context, quality);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_SetPropagationThreadAffinity(IntPtr context, ulong cpuMask);

		public int SetPropagationThreadAffinity(ulong cpuMask)
		{
			return ovrAudio_SetPropagationThreadAffinity(context, cpuMask);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_CreateAudioGeometry(IntPtr context, out IntPtr geometry);

		public int CreateAudioGeometry(out IntPtr geometry)
		{
			return ovrAudio_CreateAudioGeometry(context, out geometry);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_DestroyAudioGeometry(IntPtr geometry);

		public int DestroyAudioGeometry(IntPtr geometry)
		{
			return ovrAudio_DestroyAudioGeometry(geometry);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, UIntPtr verticesBytesOffset, UIntPtr vertexCount, UIntPtr vertexStride, ovrAudioScalarType vertexType, int[] indices, UIntPtr indicesByteOffset, UIntPtr indexCount, ovrAudioScalarType indexType, MeshGroup[] groups, UIntPtr groupCount);

		public int AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, int vertexCount, int[] indices, int indexCount, MeshGroup[] groups, int groupCount)
		{
			return ovrAudio_AudioGeometryUploadMeshArrays(geometry, vertices, UIntPtr.Zero, (UIntPtr)(ulong)vertexCount, UIntPtr.Zero, ovrAudioScalarType.Float32, indices, UIntPtr.Zero, (UIntPtr)(ulong)indexCount, ovrAudioScalarType.UInt32, groups, (UIntPtr)(ulong)groupCount);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4);

		public int AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4)
		{
			return ovrAudio_AudioGeometrySetTransform(geometry, matrix4x4);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4);

		public int AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4)
		{
			return ovrAudio_AudioGeometryGetTransform(geometry, out matrix4x4);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioGeometryWriteMeshFile(IntPtr geometry, string filePath);

		public int AudioGeometryWriteMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFile(geometry, filePath);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioGeometryReadMeshFile(IntPtr geometry, string filePath);

		public int AudioGeometryReadMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryReadMeshFile(geometry, filePath);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath);

		public int AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFileObj(geometry, filePath);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_CreateAudioMaterial(IntPtr context, out IntPtr material);

		public int CreateAudioMaterial(out IntPtr material)
		{
			return ovrAudio_CreateAudioMaterial(context, out material);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_DestroyAudioMaterial(IntPtr material);

		public int DestroyAudioMaterial(IntPtr material)
		{
			return ovrAudio_DestroyAudioMaterial(material);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value);

		public int AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value)
		{
			return ovrAudio_AudioMaterialSetFrequency(material, property, frequency, value);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value);

		public int AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value)
		{
			return ovrAudio_AudioMaterialGetFrequency(material, property, frequency, out value);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioMaterialReset(IntPtr material, MaterialProperty property);

		public int AudioMaterialReset(IntPtr material, MaterialProperty property)
		{
			return ovrAudio_AudioMaterialReset(material, property);
		}
	}

	public class WwisePluginInterface : PropagationInterface
	{
		public const string strOSPS = "OculusSpatializerWwise";

		private IntPtr context_ = IntPtr.Zero;

		private IntPtr context
		{
			get
			{
				if (context_ == IntPtr.Zero)
				{
					ovrAudio_GetPluginContext(out context_, 12u);
				}
				return context_;
			}
		}

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_GetPluginContext(out IntPtr context, uint clientType);

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_SetPropagationQuality(IntPtr context, float quality);

		public int SetPropagationQuality(float quality)
		{
			return ovrAudio_SetPropagationQuality(context, quality);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_SetPropagationThreadAffinity(IntPtr context, ulong cpuMask);

		public int SetPropagationThreadAffinity(ulong cpuMask)
		{
			return ovrAudio_SetPropagationThreadAffinity(context, cpuMask);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_CreateAudioGeometry(IntPtr context, out IntPtr geometry);

		public int CreateAudioGeometry(out IntPtr geometry)
		{
			return ovrAudio_CreateAudioGeometry(context, out geometry);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_DestroyAudioGeometry(IntPtr geometry);

		public int DestroyAudioGeometry(IntPtr geometry)
		{
			return ovrAudio_DestroyAudioGeometry(geometry);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, UIntPtr verticesBytesOffset, UIntPtr vertexCount, UIntPtr vertexStride, ovrAudioScalarType vertexType, int[] indices, UIntPtr indicesByteOffset, UIntPtr indexCount, ovrAudioScalarType indexType, MeshGroup[] groups, UIntPtr groupCount);

		public int AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, int vertexCount, int[] indices, int indexCount, MeshGroup[] groups, int groupCount)
		{
			return ovrAudio_AudioGeometryUploadMeshArrays(geometry, vertices, UIntPtr.Zero, (UIntPtr)(ulong)vertexCount, UIntPtr.Zero, ovrAudioScalarType.Float32, indices, UIntPtr.Zero, (UIntPtr)(ulong)indexCount, ovrAudioScalarType.UInt32, groups, (UIntPtr)(ulong)groupCount);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4);

		public int AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4)
		{
			return ovrAudio_AudioGeometrySetTransform(geometry, matrix4x4);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4);

		public int AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4)
		{
			return ovrAudio_AudioGeometryGetTransform(geometry, out matrix4x4);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioGeometryWriteMeshFile(IntPtr geometry, string filePath);

		public int AudioGeometryWriteMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFile(geometry, filePath);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioGeometryReadMeshFile(IntPtr geometry, string filePath);

		public int AudioGeometryReadMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryReadMeshFile(geometry, filePath);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath);

		public int AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFileObj(geometry, filePath);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_CreateAudioMaterial(IntPtr context, out IntPtr material);

		public int CreateAudioMaterial(out IntPtr material)
		{
			return ovrAudio_CreateAudioMaterial(context, out material);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_DestroyAudioMaterial(IntPtr material);

		public int DestroyAudioMaterial(IntPtr material)
		{
			return ovrAudio_DestroyAudioMaterial(material);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value);

		public int AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value)
		{
			return ovrAudio_AudioMaterialSetFrequency(material, property, frequency, value);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value);

		public int AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value)
		{
			return ovrAudio_AudioMaterialGetFrequency(material, property, frequency, out value);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioMaterialReset(IntPtr material, MaterialProperty property);

		public int AudioMaterialReset(IntPtr material, MaterialProperty property)
		{
			return ovrAudio_AudioMaterialReset(material, property);
		}
	}

	public class FMODPluginInterface : PropagationInterface
	{
		public const string strOSPS = "OculusSpatializerFMOD";

		private IntPtr context_ = IntPtr.Zero;

		private IntPtr context
		{
			get
			{
				if (context_ == IntPtr.Zero)
				{
					ovrAudio_GetPluginContext(out context_, 5u);
				}
				return context_;
			}
		}

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_GetPluginContext(out IntPtr context, uint clientType);

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_SetPropagationQuality(IntPtr context, float quality);

		public int SetPropagationQuality(float quality)
		{
			return ovrAudio_SetPropagationQuality(context, quality);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_SetPropagationThreadAffinity(IntPtr context, ulong cpuMask);

		public int SetPropagationThreadAffinity(ulong cpuMask)
		{
			return ovrAudio_SetPropagationThreadAffinity(context, cpuMask);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_CreateAudioGeometry(IntPtr context, out IntPtr geometry);

		public int CreateAudioGeometry(out IntPtr geometry)
		{
			return ovrAudio_CreateAudioGeometry(context, out geometry);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_DestroyAudioGeometry(IntPtr geometry);

		public int DestroyAudioGeometry(IntPtr geometry)
		{
			return ovrAudio_DestroyAudioGeometry(geometry);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, UIntPtr verticesBytesOffset, UIntPtr vertexCount, UIntPtr vertexStride, ovrAudioScalarType vertexType, int[] indices, UIntPtr indicesByteOffset, UIntPtr indexCount, ovrAudioScalarType indexType, MeshGroup[] groups, UIntPtr groupCount);

		public int AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, int vertexCount, int[] indices, int indexCount, MeshGroup[] groups, int groupCount)
		{
			return ovrAudio_AudioGeometryUploadMeshArrays(geometry, vertices, UIntPtr.Zero, (UIntPtr)(ulong)vertexCount, UIntPtr.Zero, ovrAudioScalarType.Float32, indices, UIntPtr.Zero, (UIntPtr)(ulong)indexCount, ovrAudioScalarType.UInt32, groups, (UIntPtr)(ulong)groupCount);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4);

		public int AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4)
		{
			return ovrAudio_AudioGeometrySetTransform(geometry, matrix4x4);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4);

		public int AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4)
		{
			return ovrAudio_AudioGeometryGetTransform(geometry, out matrix4x4);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioGeometryWriteMeshFile(IntPtr geometry, string filePath);

		public int AudioGeometryWriteMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFile(geometry, filePath);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioGeometryReadMeshFile(IntPtr geometry, string filePath);

		public int AudioGeometryReadMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryReadMeshFile(geometry, filePath);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath);

		public int AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFileObj(geometry, filePath);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_CreateAudioMaterial(IntPtr context, out IntPtr material);

		public int CreateAudioMaterial(out IntPtr material)
		{
			return ovrAudio_CreateAudioMaterial(context, out material);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_DestroyAudioMaterial(IntPtr material);

		public int DestroyAudioMaterial(IntPtr material)
		{
			return ovrAudio_DestroyAudioMaterial(material);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value);

		public int AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value)
		{
			return ovrAudio_AudioMaterialSetFrequency(material, property, frequency, value);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value);

		public int AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value)
		{
			return ovrAudio_AudioMaterialGetFrequency(material, property, frequency, out value);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioMaterialReset(IntPtr material, MaterialProperty property);

		public int AudioMaterialReset(IntPtr material, MaterialProperty property)
		{
			return ovrAudio_AudioMaterialReset(material, property);
		}
	}

	private static PropagationInterface CachedInterface;

	public static PropagationInterface Interface
	{
		get
		{
			if (CachedInterface == null)
			{
				CachedInterface = FindInterface();
			}
			return CachedInterface;
		}
	}

	private static PropagationInterface FindInterface()
	{
		IntPtr context;
		try
		{
			WwisePluginInterface.ovrAudio_GetPluginContext(out context, 12u);
			UnityEngine.Debug.Log("Propagation initialized with Wwise Oculus Spatializer plugin");
			return new WwisePluginInterface();
		}
		catch (DllNotFoundException)
		{
		}
		try
		{
			FMODPluginInterface.ovrAudio_GetPluginContext(out context, 5u);
			UnityEngine.Debug.Log("Propagation initialized with FMOD Oculus Spatializer plugin");
			return new FMODPluginInterface();
		}
		catch (DllNotFoundException)
		{
		}
		UnityEngine.Debug.Log("Propagation initialized with Unity Oculus Spatializer plugin");
		return new UnityNativeInterface();
	}
}
public sealed class ONSPPropagationMaterial : MonoBehaviour
{
	public enum Preset
	{
		Custom,
		AcousticTile,
		Brick,
		BrickPainted,
		Carpet,
		CarpetHeavy,
		CarpetHeavyPadded,
		CeramicTile,
		Concrete,
		ConcreteRough,
		ConcreteBlock,
		ConcreteBlockPainted,
		Curtain,
		Foliage,
		Glass,
		GlassHeavy,
		Grass,
		Gravel,
		GypsumBoard,
		PlasterOnBrick,
		PlasterOnConcreteBlock,
		Soil,
		SoundProof,
		Snow,
		Steel,
		Water,
		WoodThin,
		WoodThick,
		WoodFloor,
		WoodOnConcrete
	}

	[Serializable]
	public sealed class Point
	{
		public float frequency;

		public float data;

		public Point(float frequency = 0f, float data = 0f)
		{
			this.frequency = frequency;
			this.data = data;
		}

		public static implicit operator Point(Vector2 v)
		{
			return new Point(v.x, v.y);
		}

		public static implicit operator Vector2(Point point)
		{
			return new Vector2(point.frequency, point.data);
		}
	}

	[Serializable]
	public sealed class Spectrum
	{
		public int selection = int.MaxValue;

		public List<Point> points = new List<Point>();

		public float this[float f]
		{
			get
			{
				if (points.Count > 0)
				{
					Point point = new Point(float.MinValue);
					Point point2 = new Point(float.MaxValue);
					foreach (Point point3 in points)
					{
						if (point3.frequency < f)
						{
							if (point3.frequency > point.frequency)
							{
								point = point3;
							}
						}
						else if (point3.frequency < point2.frequency)
						{
							point2 = point3;
						}
					}
					if (point.frequency == float.MinValue)
					{
						point.data = points.OrderBy((Point p) => p.frequency).First().data;
					}
					if (point2.frequency == float.MaxValue)
					{
						point2.data = points.OrderBy((Point p) => p.frequency).Last().data;
					}
					return point.data + (f - point.frequency) * (point2.data - point.data) / (point2.frequency - point.frequency);
				}
				return 0f;
			}
		}
	}

	public IntPtr materialHandle = IntPtr.Zero;

	[Tooltip("Absorption")]
	public Spectrum absorption = new Spectrum();

	[Tooltip("Transmission")]
	public Spectrum transmission = new Spectrum();

	[Tooltip("Scattering")]
	public Spectrum scattering = new Spectrum();

	[SerializeField]
	private Preset preset_;

	public Preset preset
	{
		get
		{
			return preset_;
		}
		set
		{
			SetPreset(value);
			preset_ = value;
		}
	}

	private void Start()
	{
		StartInternal();
	}

	public void StartInternal()
	{
		if (!(materialHandle != IntPtr.Zero))
		{
			if (ONSPPropagation.Interface.CreateAudioMaterial(out materialHandle) != ONSPPropagationGeometry.OSPSuccess)
			{
				throw new Exception("Unable to create internal audio material");
			}
			UploadMaterial();
		}
	}

	private void OnDestroy()
	{
		DestroyInternal();
	}

	public void DestroyInternal()
	{
		if (materialHandle != IntPtr.Zero)
		{
			ONSPPropagation.Interface.DestroyAudioMaterial(materialHandle);
			materialHandle = IntPtr.Zero;
		}
	}

	public void UploadMaterial()
	{
		if (materialHandle == IntPtr.Zero)
		{
			return;
		}
		ONSPPropagation.Interface.AudioMaterialReset(materialHandle, MaterialProperty.ABSORPTION);
		foreach (Point point in absorption.points)
		{
			ONSPPropagation.Interface.AudioMaterialSetFrequency(materialHandle, MaterialProperty.ABSORPTION, point.frequency, point.data);
		}
		ONSPPropagation.Interface.AudioMaterialReset(materialHandle, MaterialProperty.TRANSMISSION);
		foreach (Point point2 in transmission.points)
		{
			ONSPPropagation.Interface.AudioMaterialSetFrequency(materialHandle, MaterialProperty.TRANSMISSION, point2.frequency, point2.data);
		}
		ONSPPropagation.Interface.AudioMaterialReset(materialHandle, MaterialProperty.SCATTERING);
		foreach (Point point3 in scattering.points)
		{
			ONSPPropagation.Interface.AudioMaterialSetFrequency(materialHandle, MaterialProperty.SCATTERING, point3.frequency, point3.data);
		}
	}

	public void SetPreset(Preset preset)
	{
		ONSPPropagationMaterial material = this;
		switch (preset)
		{
		case Preset.AcousticTile:
			AcousticTile(ref material);
			break;
		case Preset.Brick:
			Brick(ref material);
			break;
		case Preset.BrickPainted:
			BrickPainted(ref material);
			break;
		case Preset.Carpet:
			Carpet(ref material);
			break;
		case Preset.CarpetHeavy:
			CarpetHeavy(ref material);
			break;
		case Preset.CarpetHeavyPadded:
			CarpetHeavyPadded(ref material);
			break;
		case Preset.CeramicTile:
			CeramicTile(ref material);
			break;
		case Preset.Concrete:
			Concrete(ref material);
			break;
		case Preset.ConcreteRough:
			ConcreteRough(ref material);
			break;
		case Preset.ConcreteBlock:
			ConcreteBlock(ref material);
			break;
		case Preset.ConcreteBlockPainted:
			ConcreteBlockPainted(ref material);
			break;
		case Preset.Curtain:
			Curtain(ref material);
			break;
		case Preset.Foliage:
			Foliage(ref material);
			break;
		case Preset.Glass:
			Glass(ref material);
			break;
		case Preset.GlassHeavy:
			GlassHeavy(ref material);
			break;
		case Preset.Grass:
			Grass(ref material);
			break;
		case Preset.Gravel:
			Gravel(ref material);
			break;
		case Preset.GypsumBoard:
			GypsumBoard(ref material);
			break;
		case Preset.PlasterOnBrick:
			PlasterOnBrick(ref material);
			break;
		case Preset.PlasterOnConcreteBlock:
			PlasterOnConcreteBlock(ref material);
			break;
		case Preset.Soil:
			Soil(ref material);
			break;
		case Preset.SoundProof:
			SoundProof(ref material);
			break;
		case Preset.Snow:
			Snow(ref material);
			break;
		case Preset.Steel:
			Steel(ref material);
			break;
		case Preset.Water:
			Water(ref material);
			break;
		case Preset.WoodThin:
			WoodThin(ref material);
			break;
		case Preset.WoodThick:
			WoodThick(ref material);
			break;
		case Preset.WoodFloor:
			WoodFloor(ref material);
			break;
		case Preset.WoodOnConcrete:
			WoodOnConcrete(ref material);
			break;
		case Preset.Custom:
			break;
		}
	}

	private static void AcousticTile(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.5f),
			new Point(250f, 0.7f),
			new Point(500f, 0.6f),
			new Point(1000f, 0.7f),
			new Point(2000f, 0.7f),
			new Point(4000f, 0.5f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.25f),
			new Point(4000f, 0.3f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.05f),
			new Point(250f, 0.04f),
			new Point(500f, 0.03f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.005f),
			new Point(4000f, 0.002f)
		};
	}

	private static void Brick(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.02f),
			new Point(500f, 0.03f),
			new Point(1000f, 0.04f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.07f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.25f),
			new Point(500f, 0.3f),
			new Point(1000f, 0.35f),
			new Point(2000f, 0.4f),
			new Point(4000f, 0.45f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.025f),
			new Point(250f, 0.019f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.0045f),
			new Point(2000f, 0.0018f),
			new Point(4000f, 0.00089f)
		};
	}

	private static void BrickPainted(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.01f),
			new Point(500f, 0.02f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.03f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.15f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.2f),
			new Point(4000f, 0.25f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.025f),
			new Point(250f, 0.019f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.0045f),
			new Point(2000f, 0.0018f),
			new Point(4000f, 0.00089f)
		};
	}

	private static void Carpet(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.05f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.45f),
			new Point(4000f, 0.65f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.15f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.3f),
			new Point(4000f, 0.45f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void CarpetHeavy(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.06f),
			new Point(500f, 0.14f),
			new Point(1000f, 0.37f),
			new Point(2000f, 0.48f),
			new Point(4000f, 0.63f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.25f),
			new Point(2000f, 0.35f),
			new Point(4000f, 0.5f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void CarpetHeavyPadded(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.08f),
			new Point(250f, 0.24f),
			new Point(500f, 0.57f),
			new Point(1000f, 0.69f),
			new Point(2000f, 0.71f),
			new Point(4000f, 0.73f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.25f),
			new Point(2000f, 0.35f),
			new Point(4000f, 0.5f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void CeramicTile(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.01f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.01f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.02f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.12f),
			new Point(500f, 0.14f),
			new Point(1000f, 0.16f),
			new Point(2000f, 0.18f),
			new Point(4000f, 0.2f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void Concrete(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.01f),
			new Point(500f, 0.02f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.02f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.11f),
			new Point(500f, 0.12f),
			new Point(1000f, 0.13f),
			new Point(2000f, 0.14f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void ConcreteRough(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.02f),
			new Point(500f, 0.04f),
			new Point(1000f, 0.06f),
			new Point(2000f, 0.08f),
			new Point(4000f, 0.1f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.12f),
			new Point(500f, 0.15f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.25f),
			new Point(4000f, 0.3f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void ConcreteBlock(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.36f),
			new Point(250f, 0.44f),
			new Point(500f, 0.31f),
			new Point(1000f, 0.29f),
			new Point(2000f, 0.39f),
			new Point(4000f, 0.21f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.12f),
			new Point(500f, 0.15f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.3f),
			new Point(4000f, 0.4f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.01f),
			new Point(500f, 0.0063f),
			new Point(1000f, 0.0035f),
			new Point(2000f, 0.00011f),
			new Point(4000f, 0.00063f)
		};
	}

	private static void ConcreteBlockPainted(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.05f),
			new Point(500f, 0.06f),
			new Point(1000f, 0.07f),
			new Point(2000f, 0.09f),
			new Point(4000f, 0.08f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.11f),
			new Point(500f, 0.13f),
			new Point(1000f, 0.15f),
			new Point(2000f, 0.16f),
			new Point(4000f, 0.2f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.01f),
			new Point(500f, 0.0063f),
			new Point(1000f, 0.0035f),
			new Point(2000f, 0.00011f),
			new Point(4000f, 0.00063f)
		};
	}

	private static void Curtain(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.07f),
			new Point(250f, 0.31f),
			new Point(500f, 0.49f),
			new Point(1000f, 0.75f),
			new Point(2000f, 0.7f),
			new Point(4000f, 0.6f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.3f),
			new Point(2000f, 0.4f),
			new Point(4000f, 0.5f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.42f),
			new Point(250f, 0.39f),
			new Point(500f, 0.21f),
			new Point(1000f, 0.14f),
			new Point(2000f, 0.079f),
			new Point(4000f, 0.045f)
		};
	}

	private static void Foliage(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.03f),
			new Point(250f, 0.06f),
			new Point(500f, 0.11f),
			new Point(1000f, 0.17f),
			new Point(2000f, 0.27f),
			new Point(4000f, 0.31f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.3f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.5f),
			new Point(2000f, 0.7f),
			new Point(4000f, 0.8f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.9f),
			new Point(250f, 0.9f),
			new Point(500f, 0.9f),
			new Point(1000f, 0.8f),
			new Point(2000f, 0.5f),
			new Point(4000f, 0.3f)
		};
	}

	private static void Glass(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.35f),
			new Point(250f, 0.25f),
			new Point(500f, 0.18f),
			new Point(1000f, 0.12f),
			new Point(2000f, 0.07f),
			new Point(4000f, 0.05f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.05f),
			new Point(250f, 0.05f),
			new Point(500f, 0.05f),
			new Point(1000f, 0.05f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.05f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.125f),
			new Point(250f, 0.089f),
			new Point(500f, 0.05f),
			new Point(1000f, 0.028f),
			new Point(2000f, 0.022f),
			new Point(4000f, 0.079f)
		};
	}

	private static void GlassHeavy(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.18f),
			new Point(250f, 0.06f),
			new Point(500f, 0.04f),
			new Point(1000f, 0.03f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.02f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.05f),
			new Point(250f, 0.05f),
			new Point(500f, 0.05f),
			new Point(1000f, 0.05f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.05f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.056f),
			new Point(250f, 0.039f),
			new Point(500f, 0.028f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.032f),
			new Point(4000f, 0.014f)
		};
	}

	private static void Grass(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.11f),
			new Point(250f, 0.26f),
			new Point(500f, 0.6f),
			new Point(1000f, 0.69f),
			new Point(2000f, 0.92f),
			new Point(4000f, 0.99f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.3f),
			new Point(250f, 0.3f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.5f),
			new Point(2000f, 0.6f),
			new Point(4000f, 0.7f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void Gravel(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.25f),
			new Point(250f, 0.6f),
			new Point(500f, 0.65f),
			new Point(1000f, 0.7f),
			new Point(2000f, 0.75f),
			new Point(4000f, 0.8f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.3f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.5f),
			new Point(2000f, 0.6f),
			new Point(4000f, 0.7f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void GypsumBoard(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.29f),
			new Point(250f, 0.1f),
			new Point(500f, 0.05f),
			new Point(1000f, 0.04f),
			new Point(2000f, 0.07f),
			new Point(4000f, 0.09f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.11f),
			new Point(500f, 0.12f),
			new Point(1000f, 0.13f),
			new Point(2000f, 0.14f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.035f),
			new Point(250f, 0.0125f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0025f),
			new Point(2000f, 0.0013f),
			new Point(4000f, 0.0032f)
		};
	}

	private static void PlasterOnBrick(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.02f),
			new Point(500f, 0.02f),
			new Point(1000f, 0.03f),
			new Point(2000f, 0.04f),
			new Point(4000f, 0.05f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.25f),
			new Point(500f, 0.3f),
			new Point(1000f, 0.35f),
			new Point(2000f, 0.4f),
			new Point(4000f, 0.45f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.025f),
			new Point(250f, 0.019f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.0045f),
			new Point(2000f, 0.0018f),
			new Point(4000f, 0.00089f)
		};
	}

	private static void PlasterOnConcreteBlock(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.12f),
			new Point(250f, 0.09f),
			new Point(500f, 0.07f),
			new Point(1000f, 0.05f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.04f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.25f),
			new Point(500f, 0.3f),
			new Point(1000f, 0.35f),
			new Point(2000f, 0.4f),
			new Point(4000f, 0.45f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.01f),
			new Point(500f, 0.0063f),
			new Point(1000f, 0.0035f),
			new Point(2000f, 0.00011f),
			new Point(4000f, 0.00063f)
		};
	}

	private static void Soil(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.15f),
			new Point(250f, 0.25f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.55f),
			new Point(2000f, 0.6f),
			new Point(4000f, 0.6f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.2f),
			new Point(500f, 0.25f),
			new Point(1000f, 0.4f),
			new Point(2000f, 0.55f),
			new Point(4000f, 0.7f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void SoundProof(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(1000f, 1f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(1000f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void Snow(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.45f),
			new Point(250f, 0.75f),
			new Point(500f, 0.9f),
			new Point(1000f, 0.95f),
			new Point(2000f, 0.95f),
			new Point(4000f, 0.95f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.3f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.5f),
			new Point(2000f, 0.6f),
			new Point(4000f, 0.75f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void Steel(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.05f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.07f),
			new Point(4000f, 0.02f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.1f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.25f),
			new Point(250f, 0.2f),
			new Point(500f, 0.17f),
			new Point(1000f, 0.089f),
			new Point(2000f, 0.089f),
			new Point(4000f, 0.0056f)
		};
	}

	private static void Water(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.01f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.03f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.07f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.05f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.03f),
			new Point(250f, 0.03f),
			new Point(500f, 0.03f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.015f),
			new Point(4000f, 0.01f)
		};
	}

	private static void WoodThin(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.42f),
			new Point(250f, 0.21f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.08f),
			new Point(2000f, 0.06f),
			new Point(4000f, 0.06f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.125f),
			new Point(500f, 0.079f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.089f),
			new Point(4000f, 0.05f)
		};
	}

	private static void WoodThick(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.19f),
			new Point(250f, 0.14f),
			new Point(500f, 0.09f),
			new Point(1000f, 0.06f),
			new Point(2000f, 0.06f),
			new Point(4000f, 0.05f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.035f),
			new Point(250f, 0.028f),
			new Point(500f, 0.028f),
			new Point(1000f, 0.028f),
			new Point(2000f, 0.011f),
			new Point(4000f, 0.0071f)
		};
	}

	private static void WoodFloor(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.15f),
			new Point(250f, 0.11f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.07f),
			new Point(2000f, 0.06f),
			new Point(4000f, 0.07f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.071f),
			new Point(250f, 0.025f),
			new Point(500f, 0.0158f),
			new Point(1000f, 0.0056f),
			new Point(2000f, 0.0035f),
			new Point(4000f, 0.0016f)
		};
	}

	private static void WoodOnConcrete(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.04f),
			new Point(250f, 0.04f),
			new Point(500f, 0.07f),
			new Point(1000f, 0.06f),
			new Point(2000f, 0.06f),
			new Point(4000f, 0.07f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}
}
public class ONSPPropagationSettings : MonoBehaviour
{
	public float quality = 100f;

	private void Update()
	{
		ONSPPropagation.Interface.SetPropagationQuality(quality / 100f);
	}
}
public sealed class ONSPSettings : ScriptableObject
{
	[SerializeField]
	public int voiceLimit = 64;

	private static ONSPSettings instance;

	public static ONSPSettings Instance
	{
		get
		{
			if (instance == null)
			{
				instance = Resources.Load<ONSPSettings>("ONSPSettings");
				if (instance == null)
				{
					instance = ScriptableObject.CreateInstance<ONSPSettings>();
				}
			}
			return instance;
		}
	}
}
public class ONSPVersion : MonoBehaviour
{
	public const string strONSPS = "AudioPluginOculusSpatializer";

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern void ONSP_GetVersion(ref int Major, ref int Minor, ref int Patch);

	private void Awake()
	{
		int Major = 0;
		int Minor = 0;
		int Patch = 0;
		ONSP_GetVersion(ref Major, ref Minor, ref Patch);
		UnityEngine.Debug.Log($"ONSP Version: {Major:F0}.{Minor:F0}.{Patch:F0}");
	}

	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class AchievementSample : MonoBehaviour
{
	public Text dataOutput;

	public InputField getDefinitionsByNameInputField;

	public InputField getProgressByNameInputField;

	public InputField unLockInputField;

	public InputField addCountInputField;

	public InputField addFieldsInputField;

	private void Start()
	{
		AchievementCore.RegisterNetwork();
	}

	private void OnDestroy()
	{
		AchievementCore.UnRegisterNetwork();
	}

	private void OnApplicationPause(bool pause)
	{
		if (!pause)
		{
			printOutputLine("Achievement Init");
			achievementInit();
		}
	}

	private void Update()
	{
		Pvr_UnitySDKAPI.Achievement.Request.RunCallbacks();
	}

	public void AsyncInitialize()
	{
		dataOutput.text = "> ";
		printOutputLine("AsyncInitialize");
		achievementInit();
	}

	public void GetDefinitionsByName()
	{
		dataOutput.text = "> ";
		printOutputLine("GetDefinitionsByName");
		string text = getDefinitionsByNameInputField.text;
		if (text != "")
		{
			string[] achievementNames = text.Split(',');
			getAchievementDefinition(achievementNames);
			getDefinitionsByNameInputField.text = "";
		}
		else
		{
			printOutputLine("Invalid Command");
		}
	}

	public void GetProgressByName()
	{
		dataOutput.text = "> ";
		printOutputLine("GetProgressByName");
		string text = getProgressByNameInputField.text;
		if (text != "")
		{
			string[] achievementNames = text.Split(',');
			getAchievementProgress(achievementNames);
			getProgressByNameInputField.text = "";
		}
		else
		{
			printOutputLine("Invalid Command");
		}
	}

	public void GetAllDefinitions()
	{
		dataOutput.text = "> ";
		printOutputLine("GetAllDefinitions");
		getAchievementAllDefinition();
	}

	public void GetAllProgress()
	{
		dataOutput.text = "> ";
		printOutputLine("GetAllProgress");
		getAchievementAllProgress();
	}

	public void UnLock()
	{
		dataOutput.text = "> ";
		printOutputLine("UnLock");
		string text = unLockInputField.text;
		if (text != "")
		{
			unlockAchievement(text);
			unLockInputField.text = "";
		}
		else
		{
			printOutputLine("Invalid Command");
		}
	}

	public void AddCount()
	{
		dataOutput.text = "> ";
		printOutputLine("AddCount");
		string text = addCountInputField.text;
		if (text != "")
		{
			string[] array = text.Split(',');
			if (array.Length > 1)
			{
				try
				{
					Convert.ToInt64(array[1]);
				}
				catch (Exception)
				{
					printOutputLine("Invalid Command");
					throw;
				}
				addCountAchievement(array[0], array[1]);
				addCountInputField.text = "";
			}
			else
			{
				printOutputLine("Invalid Command");
			}
		}
		else
		{
			printOutputLine("Invalid Command");
		}
	}

	public void AddFields()
	{
		dataOutput.text = "> ";
		printOutputLine("AddFields");
		string text = addFieldsInputField.text;
		if (text != "")
		{
			string[] array = text.Split(',');
			if (array.Length > 1)
			{
				addFieldsAchievement(array[0], array[1]);
				addFieldsInputField.text = "";
			}
			else
			{
				printOutputLine("Invalid Command");
			}
		}
		else
		{
			printOutputLine("Invalid Command");
		}
	}

	private void achievementInit()
	{
		Pvr_UnitySDKAPI.Achievement.Achievements.Init().OnComplete(initAchievementCallback);
	}

	private void getAchievementAllDefinition()
	{
		Pvr_UnitySDKAPI.Achievement.Achievements.GetAllDefinitions().OnComplete(achievementAllDefinitionCallback);
	}

	private void getAchievementAllProgress()
	{
		Pvr_UnitySDKAPI.Achievement.Achievements.GetAllProgress().OnComplete(achievementAllProgressCallback);
	}

	private void addFieldsAchievement(string achievementName, string fields)
	{
		Pvr_UnitySDKAPI.Achievement.Achievements.AddFields(achievementName, fields).OnComplete(achievementFieldsCallback);
	}

	private void addCountAchievement(string achievementName, string count)
	{
		Pvr_UnitySDKAPI.Achievement.Achievements.AddCount(achievementName, Convert.ToInt64(count)).OnComplete(achievementCountCallback);
	}

	private void unlockAchievement(string achievementName)
	{
		Pvr_UnitySDKAPI.Achievement.Achievements.Unlock(achievementName).OnComplete(achievementUnlockCallback);
	}

	private void getAchievementProgress(string[] achievementNames)
	{
		Pvr_UnitySDKAPI.Achievement.Achievements.GetProgressByName(achievementNames).OnComplete(achievementProgressCallback);
	}

	private void getAchievementDefinition(string[] achievementNames)
	{
		Pvr_UnitySDKAPI.Achievement.Achievements.GetDefinitionsByName(achievementNames).OnComplete(achievementDefinitionCallback);
	}

	private void printOutputLine(string newLine)
	{
		dataOutput.text = "> " + newLine + Environment.NewLine + dataOutput.text;
	}

	private void achievementAllDefinitionCallback(Pvr_Message<Pvr_AchievementDefinitionList> msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Received achievement definitions success");
			Pvr_AchievementDefinitionList achievementDefinitions = msg.GetAchievementDefinitions();
			if (achievementDefinitions.HasNextPage)
			{
				Pvr_UnitySDKAPI.Achievement.Achievements.GetNextAchievementDefinitionListPage(achievementDefinitions).OnComplete(achievementAllDefinitionCallback);
			}
			{
				foreach (Pvr_AchievementDefinition item in achievementDefinitions)
				{
					printOutputLine("Bitfield Name: " + item.Name.ToString());
					switch (item.Type)
					{
					case Pvr_UnitySDKAPI.Achievement.AchievementType.Simple:
						printOutputLine("Achievement Type: Simple");
						break;
					case Pvr_UnitySDKAPI.Achievement.AchievementType.Bitfield:
						printOutputLine("Achievement Type: Bitfield");
						printOutputLine("Bitfield Length: " + item.BitfieldLength);
						printOutputLine("Target: " + item.Target);
						break;
					case Pvr_UnitySDKAPI.Achievement.AchievementType.Count:
						printOutputLine("Achievement Type: Count");
						printOutputLine("Target: " + item.Target);
						break;
					default:
						printOutputLine("Achievement Type: Unknown");
						break;
					}
					printOutputLine("Bitfield Title: " + item.Title.ToString());
					printOutputLine("Bitfield Description: " + item.Description.ToString());
					printOutputLine("Bitfield UnlockedDescription: " + item.UnlockedDescription.ToString());
					printOutputLine("Bitfield UnlockedIcon: " + item.UnlockedIcon.ToString());
					printOutputLine("Bitfield LockedIcon: " + item.LockedIcon.ToString());
					printOutputLine("Bitfield IsSecrect: " + item.IsSecrect);
				}
				return;
			}
		}
		printOutputLine("Received achievement definitions error");
		Pvr_UnitySDKAPI.Achievement.Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementAllProgressCallback(Pvr_Message<Pvr_AchievementProgressList> msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Received achievement progress success");
			Pvr_AchievementProgressList achievementProgressList = msg.GetAchievementProgressList();
			if (achievementProgressList.HasNextPage)
			{
				Pvr_UnitySDKAPI.Achievement.Achievements.GetNextAchievementProgressListPage(achievementProgressList).OnComplete(achievementAllProgressCallback);
			}
			{
				foreach (Pvr_AchievementProgress item in achievementProgressList)
				{
					printOutputLine("Current Name: " + item.Name.ToString());
					if (item.IsUnlocked)
					{
						printOutputLine("Achievement Unlocked");
					}
					else
					{
						printOutputLine("Achievement Locked");
					}
					printOutputLine("Current Bitfield: " + item.Bitfield.ToString());
					printOutputLine("Current Count: " + item.Count);
					printOutputLine("Current UnlockTime: " + item.UnlockTime.ToString());
				}
				return;
			}
		}
		printOutputLine("Received achievement progress error");
		Pvr_UnitySDKAPI.Achievement.Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementFieldsCallback(Pvr_Message msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Achievement fields added.");
			return;
		}
		printOutputLine("Received achievement fields add error");
		Pvr_UnitySDKAPI.Achievement.Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementCountCallback(Pvr_Message msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Achievement count added.");
			return;
		}
		printOutputLine("Received achievement count add error");
		Pvr_UnitySDKAPI.Achievement.Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementUnlockCallback(Pvr_Message msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Achievement unlocked");
			return;
		}
		printOutputLine("Received achievement unlock error");
		Pvr_UnitySDKAPI.Achievement.Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementProgressCallback(Pvr_Message<Pvr_AchievementProgressList> msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Received achievement progress success");
			{
				foreach (Pvr_AchievementProgress achievementProgress in msg.GetAchievementProgressList())
				{
					if (achievementProgress.IsUnlocked)
					{
						printOutputLine("Achievement Unlocked");
					}
					else
					{
						printOutputLine("Achievement Locked");
					}
					printOutputLine("Current Bitfield: " + achievementProgress.Bitfield.ToString());
					printOutputLine("Current Count: " + achievementProgress.Count);
				}
				return;
			}
		}
		printOutputLine("Received achievement progress error");
		Pvr_UnitySDKAPI.Achievement.Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementDefinitionCallback(Pvr_Message<Pvr_AchievementDefinitionList> msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Received achievement definitions success");
			{
				foreach (Pvr_AchievementDefinition achievementDefinition in msg.GetAchievementDefinitions())
				{
					switch (achievementDefinition.Type)
					{
					case Pvr_UnitySDKAPI.Achievement.AchievementType.Simple:
						printOutputLine("Achievement Type: Simple");
						break;
					case Pvr_UnitySDKAPI.Achievement.AchievementType.Bitfield:
						printOutputLine("Achievement Type: Bitfield");
						printOutputLine("Bitfield Length: " + achievementDefinition.BitfieldLength);
						printOutputLine("Target: " + achievementDefinition.Target);
						break;
					case Pvr_UnitySDKAPI.Achievement.AchievementType.Count:
						printOutputLine("Achievement Type: Count");
						printOutputLine("Target: " + achievementDefinition.Target);
						break;
					default:
						printOutputLine("Achievement Type: Unknown");
						break;
					}
				}
				return;
			}
		}
		printOutputLine("Received achievement definitions error");
		Pvr_UnitySDKAPI.Achievement.Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void initAchievementCallback(Pvr_Message msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Received init success");
			return;
		}
		printOutputLine("Received init error");
		Pvr_UnitySDKAPI.Achievement.Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void LoginCallback(string LoginInfo)
	{
		UnityEngine.Debug.Log("Received loginCallback:" + LoginInfo);
		printOutputLine("Received loginCallback: " + LoginInfo);
	}
}
public class Pvr_Controller : MonoBehaviour
{
	public enum UserHandNess
	{
		Right,
		Left
	}

	public enum GazeType
	{
		Never,
		DuringMotion,
		Always
	}

	public enum ControllerAxis
	{
		Controller,
		Wrist,
		Elbow,
		Shoulder
	}

	public GameObject controller0;

	public GameObject controller1;

	private static UserHandNess handness;

	public ControllerAxis Axis;

	public GazeType Gazetype;

	[Range(0f, 0.2f)]
	public float ElbowHeight;

	[Range(0f, 0.2f)]
	public float ElbowDepth;

	[Range(0f, 30f)]
	public float PointerTiltAngle = 15f;

	private float mouseX;

	private float mouseY;

	private float mouseZ;

	private Vector3[] inputDirection = new Vector3[2];

	public static Vector3 pointerPosition { get; set; }

	public static Quaternion pointerRotation { get; set; }

	public static Vector3 elbowPosition { get; set; }

	public static Quaternion elbowRotation { get; set; }

	public static Vector3 wristPosition { get; set; }

	public static Quaternion wristRotation { get; set; }

	public static Vector3 shoulderPosition { get; set; }

	public static Quaternion shoulderRotation { get; set; }

	public static Vector3 originOffsetL { get; set; }

	public static Vector3 originOffsetR { get; set; }

	private void Awake()
	{
		Pvr_ControllerManager.PvrServiceStartSuccessEvent += ServiceStartSuccess;
		Pvr_ControllerManager.SetControllerAbilityEvent += CheckControllerState;
		Pvr_ControllerManager.ChangeMainControllerCallBackEvent += MainControllerChanged;
		Pvr_ControllerManager.ChangeHandNessCallBackEvent += HandnessChanged;
	}

	private void Start()
	{
		handness = Pvr_UnitySDKAPI.Controller.UPvr_GetHandNess();
		if (handness == (UserHandNess)(-1))
		{
			handness = UserHandNess.Right;
		}
	}

	private void OnDestroy()
	{
		Pvr_ControllerManager.PvrServiceStartSuccessEvent -= ServiceStartSuccess;
		Pvr_ControllerManager.SetControllerAbilityEvent -= CheckControllerState;
		Pvr_ControllerManager.ChangeMainControllerCallBackEvent -= MainControllerChanged;
		Pvr_ControllerManager.ChangeHandNessCallBackEvent -= HandnessChanged;
	}

	private void MainControllerChanged(string index)
	{
		RefreshHandness();
	}

	private void HandnessChanged(string index)
	{
		RefreshHandness();
	}

	private void ServiceStartSuccess()
	{
		RefreshHandness();
	}

	private void RefreshHandness()
	{
		handness = Pvr_UnitySDKAPI.Controller.UPvr_GetHandNess();
		if (Pvr_UnitySDKAPI.Controller.UPvr_GetMainHandNess() == 1)
		{
			ChangeHandNess();
		}
	}

	private void OnApplicationPause(bool pause)
	{
		if (!pause)
		{
			if (controller0 != null)
			{
				controller0.transform.localScale = Vector3.zero;
			}
			if (controller1 != null)
			{
				controller1.transform.localScale = Vector3.zero;
			}
		}
		Invoke("ShowController", 0.1f * Time.timeScale);
	}

	private void ShowController()
	{
		if (controller0 != null)
		{
			controller0.transform.localScale = Vector3.one;
		}
		if (controller1 != null)
		{
			controller1.transform.localScale = Vector3.one;
		}
	}

	private void CheckControllerState(string data)
	{
		bool num = Convert.ToBoolean(Convert.ToInt16(data.Substring(4, 1)));
		short num2 = Convert.ToInt16(data.Substring(0, 1));
		if (num && num2 == 1)
		{
			RefreshHandness();
		}
	}

	private void Update()
	{
		if (Pvr_UnitySDKManager.SDK.ControllerOnlyrot)
		{
			DoUpdateControler0();
			DoUpdateControler1();
			UpdateControlloerRay();
			return;
		}
		if (Pvr_UnitySDKAPI.Controller.UPvr_GetPreferenceDevice() == 1)
		{
			DoUpdateControler0();
			DoUpdateControler1();
			UpdateControlloerRay();
			return;
		}
		if (controller0 != null)
		{
			controller0.transform.localRotation = Pvr_UnitySDKAPI.Controller.UPvr_GetControllerQUA(0);
			controller0.transform.localPosition = Pvr_UnitySDKAPI.Controller.UPvr_GetControllerPOS(0) + Pvr_UnitySDKAPI.Controller.UPvr_GetControllerQUA(0) * originOffsetL;
			UpdateControlloerRay(update0: true, update1: false);
		}
		if (controller1 != null)
		{
			controller1.transform.localRotation = Pvr_UnitySDKAPI.Controller.UPvr_GetControllerQUA(1);
			controller1.transform.localPosition = Pvr_UnitySDKAPI.Controller.UPvr_GetControllerPOS(1) + Pvr_UnitySDKAPI.Controller.UPvr_GetControllerQUA(1) * originOffsetR;
			UpdateControlloerRay(update0: false);
		}
	}

	public static void ChangeHandNess()
	{
		handness = ((handness == UserHandNess.Right) ? UserHandNess.Left : UserHandNess.Right);
	}

	private void DoUpdateControler0()
	{
		SetArmParaToSo((int)handness, (int)Gazetype, ElbowHeight, ElbowDepth, PointerTiltAngle);
		CalcArmModelfromSo(0);
		UpdateControllerDataSO(0);
	}

	private void DoUpdateControler1()
	{
		int hand = ((handness != UserHandNess.Left) ? 1 : 0);
		SetArmParaToSo(hand, (int)Gazetype, ElbowHeight, ElbowDepth, PointerTiltAngle);
		CalcArmModelfromSo(1);
		UpdateControllerDataSO(1);
	}

	private void UpdateControlloerRay(bool update0 = true, bool update1 = true)
	{
		if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
		{
			if (update0 && controller0 != null)
			{
				controller0.GetComponent<Pvr_ControllerModuleInit>().UpdateRay();
			}
			if (update1 && controller1 != null)
			{
				controller1.GetComponent<Pvr_ControllerModuleInit>().UpdateRay();
			}
		}
	}

	private Quaternion UpdateSimulatedFrameParams()
	{
		if (Input.GetKey(KeyCode.LeftShift))
		{
			mouseX += Input.GetAxis("Mouse X") * 5f;
			if (mouseX <= -180f)
			{
				mouseX += 360f;
			}
			else if (mouseX > 180f)
			{
				mouseX -= 360f;
			}
			mouseY -= Input.GetAxis("Mouse Y") * 2.4f;
			mouseY = Mathf.Clamp(mouseY, -80f, 80f);
		}
		else if (Input.GetKey(KeyCode.RightShift))
		{
			mouseZ += Input.GetAxis("Mouse X") * 5f;
			mouseZ = Mathf.Clamp(mouseZ, -80f, 80f);
		}
		return Quaternion.Euler(mouseY, mouseX, mouseZ);
	}

	private void SetArmParaToSo(int hand, int gazeType, float elbowHeight, float elbowDepth, float pointerTiltAngle)
	{
		Pvr_UnitySDKAPI.Controller.UPvr_SetArmModelParameters(hand, gazeType, elbowHeight, elbowDepth, pointerTiltAngle);
	}

	private void CalcArmModelfromSo(int hand)
	{
		float[] array = new float[4];
		float[] array2 = new float[4];
		float[] array3 = new float[3];
		Quaternion quaternion = default(Quaternion);
		quaternion = Pvr_UnitySDKAPI.Controller.UPvr_GetControllerQUA(hand);
		Vector3 vector = Pvr_UnitySDKAPI.Controller.UPvr_GetAngularVelocity(hand);
		array2[0] = quaternion.x;
		array2[1] = quaternion.y;
		array2[2] = quaternion.z;
		array2[3] = quaternion.w;
		array3[0] = vector.x;
		array3[1] = vector.y;
		array3[2] = vector.z;
		if (Gazetype == GazeType.DuringMotion)
		{
			Vector3 b = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation * Vector3.forward;
			b.y = 0f;
			b.Normalize();
			float t = Mathf.Clamp((vector.magnitude - 0.2f) / 45f, 0f, 0.1f);
			inputDirection[hand] = Vector3.Slerp(inputDirection[hand], b, t);
			if (Pvr_UnitySDKAPI.Controller.UPvr_GetKeyLongPressed(hand, Pvr_KeyCode.HOME))
			{
				inputDirection[hand] = default(Vector3);
			}
			Quaternion quaternion2 = Quaternion.FromToRotation(Vector3.forward, inputDirection[hand]);
			array[0] = quaternion2.x;
			array[1] = quaternion2.y;
			array[2] = quaternion2.z;
			array[3] = quaternion2.w;
		}
		else
		{
			array[0] = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.x;
			array[1] = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.y;
			array[2] = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.z;
			array[3] = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.w;
		}
		Pvr_UnitySDKAPI.Controller.UPvr_CalcArmModelParameters(array, array2, array3);
	}

	public void UpdateControllerDataSO(int hand)
	{
		float[] array = new float[4];
		float[] array2 = new float[3];
		Vector3 vector;
		Quaternion localRotation;
		switch (Axis)
		{
		case ControllerAxis.Controller:
			Pvr_UnitySDKAPI.Controller.UPvr_GetPointerPose(array, array2);
			pointerPosition = new Vector3(array2[0], array2[1], array2[2]);
			pointerRotation = new Quaternion(array[0], array[1], array[2], array[3]);
			vector = pointerPosition;
			localRotation = pointerRotation;
			break;
		case ControllerAxis.Wrist:
			Pvr_UnitySDKAPI.Controller.UPvr_GetWristPose(array, array2);
			wristPosition = new Vector3(array2[0], array2[1], array2[2]);
			wristRotation = new Quaternion(array[0], array[1], array[2], array[3]);
			vector = wristPosition;
			localRotation = wristRotation;
			break;
		case ControllerAxis.Elbow:
			Pvr_UnitySDKAPI.Controller.UPvr_GetElbowPose(array, array2);
			elbowPosition = new Vector3(array2[0], array2[1], array2[2]);
			elbowRotation = new Quaternion(array[0], array[1], array[2], array[3]);
			vector = elbowPosition;
			localRotation = elbowRotation;
			break;
		case ControllerAxis.Shoulder:
			Pvr_UnitySDKAPI.Controller.UPvr_GetShoulderPose(array, array2);
			shoulderPosition = new Vector3(array2[0], array2[1], array2[2]);
			shoulderRotation = new Quaternion(array[0], array[1], array[2], array[3]);
			vector = shoulderPosition;
			localRotation = shoulderRotation;
			break;
		default:
			throw new Exception("Invalid FromJoint.");
		}
		if (hand == 0)
		{
			if (controller0 != null)
			{
				if (!Pvr_UnitySDKManager.SDK.HmdOnlyrot)
				{
					controller0.transform.localPosition = vector + Pvr_UnitySDKSensor.Instance.HeadPose.Position;
				}
				else if (Pvr_UnitySDKManager.SDK.TrackingOrigin == TrackingOrigin.FloorLevel)
				{
					controller0.transform.localPosition = vector + Pvr_UnitySDKSensor.Instance.HeadPose.Position;
				}
				else
				{
					controller0.transform.localPosition = vector;
				}
				controller0.transform.localRotation = localRotation;
			}
		}
		else if (controller1 != null)
		{
			if (!Pvr_UnitySDKManager.SDK.HmdOnlyrot)
			{
				controller1.transform.localPosition = vector + Pvr_UnitySDKSensor.Instance.HeadPose.Position;
			}
			else if (Pvr_UnitySDKManager.SDK.TrackingOrigin == TrackingOrigin.FloorLevel)
			{
				controller1.transform.localPosition = vector + Pvr_UnitySDKSensor.Instance.HeadPose.Position;
			}
			else
			{
				controller1.transform.localPosition = vector;
			}
			controller1.transform.localRotation = localRotation;
		}
	}
}
public class Pvr_ControllerDemo : MonoBehaviour
{
	public GameObject HeadSetController;

	public GameObject controller0;

	public GameObject controller1;

	public GameObject cube;

	private Ray ray;

	private GameObject currentController;

	private Transform lastHit;

	private Transform currentHit;

	[SerializeField]
	private Material normat;

	[SerializeField]
	private Material gazemat;

	[SerializeField]
	private Material clickmat;

	private bool noClick;

	private GameObject referenceObj;

	public float rayDefaultLength = 4f;

	private bool isHasController;

	private bool headcontrolmode;

	private RaycastHit hit;

	private GameObject rayLine;

	private GameObject dot;

	private Transform dragObj;

	private float disX;

	private float disY;

	private float disZ;

	private void Start()
	{
		ray = default(Ray);
		hit = default(RaycastHit);
		if (Pvr_UnitySDKManager.SDK.isHasController)
		{
			Pvr_ControllerManager.PvrServiceStartSuccessEvent += ServiceStartSuccess;
			Pvr_ControllerManager.SetControllerStateChangedEvent += ControllerStateListener;
			Pvr_ControllerManager.ControllerStatusChangeEvent += CheckControllerStateForGoblin;
			isHasController = true;
		}
		referenceObj = new GameObject("ReferenceObj");
	}

	private void OnDestroy()
	{
		if (isHasController)
		{
			Pvr_ControllerManager.PvrServiceStartSuccessEvent -= ServiceStartSuccess;
			Pvr_ControllerManager.SetControllerStateChangedEvent -= ControllerStateListener;
			Pvr_ControllerManager.ControllerStatusChangeEvent -= CheckControllerStateForGoblin;
		}
	}

	private void Update()
	{
		if (HeadSetController.activeSelf)
		{
			HeadSetController.transform.parent.localRotation = Quaternion.Euler(Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.eulerAngles.x, Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.eulerAngles.y, 0f);
			HeadSetController.transform.parent.localPosition = Pvr_UnitySDKSensor.Instance.HeadPose.Position;
			ray.direction = HeadSetController.transform.position - HeadSetController.transform.parent.parent.Find("Head").position;
			ray.origin = HeadSetController.transform.parent.parent.Find("Head").position;
			if (Physics.Raycast(ray, out hit))
			{
				if (HeadSetController.name == "SightPointer")
				{
					HeadSetController.transform.localScale = new Vector3(0.09f, 0.09f, 0.09f);
				}
				currentHit = hit.transform;
				if (currentHit != null && lastHit != null && currentHit != lastHit && (bool)lastHit.GetComponent<Pvr_UIGraphicRaycaster>() && lastHit.transform.gameObject.activeInHierarchy && lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = false;
				}
				if (currentHit != null && lastHit != null && currentHit == lastHit && (bool)currentHit.GetComponent<Pvr_UIGraphicRaycaster>() && !currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = true;
				}
				if (1 << hit.transform.gameObject.layer == LayerMask.GetMask("Water") && !noClick)
				{
					hit.transform.GetComponent<Renderer>().material = gazemat;
				}
				lastHit = hit.transform;
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					HeadSetController.transform.position = hit.point;
					HeadSetController.transform.position -= (hit.point - HeadSetController.transform.parent.parent.Find("Head").position).normalized * 0.02f;
					float num = 0.008f * hit.distance / 4f;
					Mathf.Clamp(num, 0.002f, 0.008f);
					HeadSetController.transform.localScale = new Vector3(num, num, 1f);
				}
			}
			else
			{
				if (HeadSetController.name == "SightPointer")
				{
					HeadSetController.transform.localScale = Vector3.zero;
				}
				if (lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water"))
				{
					lastHit.transform.GetComponent<Renderer>().material = normat;
				}
				currentHit = null;
				noClick = false;
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					HeadSetController.transform.position = HeadSetController.transform.parent.parent.Find("Head").position + ray.direction.normalized * (0.5f + rayDefaultLength);
					HeadSetController.transform.localScale = new Vector3(0.008f, 0.008f, 1f);
				}
			}
			if ((Input.GetKeyDown(KeyCode.JoystickButton0) || Input.GetMouseButtonDown(0)) && lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water") && currentHit != null)
			{
				lastHit.transform.GetComponent<Renderer>().material = clickmat;
				noClick = true;
			}
			return;
		}
		if (currentController != null)
		{
			ray.direction = currentController.transform.forward - currentController.transform.up * 0.25f;
			ray.origin = currentController.transform.Find("start").position;
			if (Physics.Raycast(ray, out hit))
			{
				currentHit = hit.transform;
				if (currentHit != null && lastHit != null && currentHit != lastHit && (bool)lastHit.GetComponent<Pvr_UIGraphicRaycaster>() && lastHit.transform.gameObject.activeInHierarchy && lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = false;
				}
				if (currentHit != null && lastHit != null && currentHit == lastHit && (bool)currentHit.GetComponent<Pvr_UIGraphicRaycaster>() && !currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = true;
				}
				if (1 << hit.transform.gameObject.layer == LayerMask.GetMask("Water"))
				{
					if (!noClick)
					{
						hit.transform.GetComponent<Renderer>().material = gazemat;
					}
					if (Pvr_UnitySDKAPI.Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.TOUCHPAD) || Pvr_UnitySDKAPI.Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TOUCHPAD) || Input.GetMouseButtonDown(0))
					{
						referenceObj.transform.position = hit.point;
						disX = hit.transform.position.x - referenceObj.transform.position.x;
						disY = hit.transform.position.y - referenceObj.transform.position.y;
						dragObj = hit.transform;
					}
					if ((Pvr_UnitySDKAPI.Controller.UPvr_GetKey(0, Pvr_KeyCode.TOUCHPAD) || Pvr_UnitySDKAPI.Controller.UPvr_GetKey(1, Pvr_KeyCode.TOUCHPAD) || Input.GetMouseButton(0)) && hit.transform == dragObj.transform)
					{
						referenceObj.transform.position = new Vector3(hit.point.x, hit.point.y, hit.transform.position.z);
						dragObj.position = new Vector3(referenceObj.transform.position.x + disX, referenceObj.transform.position.y + disY, hit.transform.position.z);
					}
				}
				lastHit = hit.transform;
				currentController.transform.Find("dot").position = hit.point;
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					float num2 = 0.178f * currentController.transform.Find("dot").localPosition.z / 3.3f;
					Mathf.Clamp(num2, 0.05f, 0.178f);
					currentController.transform.Find("dot").localScale = new Vector3(num2, num2, 1f);
				}
			}
			else
			{
				if (lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water"))
				{
					lastHit.transform.GetComponent<Renderer>().material = normat;
				}
				currentHit = null;
				noClick = false;
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					currentController.transform.Find("dot").localScale = new Vector3(0.178f, 0.178f, 1f);
				}
			}
		}
		if ((Pvr_UnitySDKAPI.Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.TOUCHPAD) || Pvr_UnitySDKAPI.Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TOUCHPAD) || Input.GetMouseButtonDown(0)) && lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water") && currentHit != null)
		{
			lastHit.transform.GetComponent<Renderer>().material = clickmat;
			noClick = true;
		}
	}

	private void ServiceStartSuccess()
	{
		if (Pvr_UnitySDKAPI.Controller.UPvr_GetControllerState(0) == ControllerState.Connected || Pvr_UnitySDKAPI.Controller.UPvr_GetControllerState(1) == ControllerState.Connected)
		{
			HeadSetController.SetActive(value: false);
		}
		else
		{
			HeadSetController.SetActive(value: true);
		}
		if (Pvr_UnitySDKAPI.Controller.UPvr_GetMainHandNess() == 0)
		{
			currentController = controller0;
		}
		if (Pvr_UnitySDKAPI.Controller.UPvr_GetMainHandNess() == 1)
		{
			currentController = controller1;
		}
	}

	private void ControllerStateListener(string data)
	{
		if (Pvr_UnitySDKAPI.Controller.UPvr_GetControllerState(0) == ControllerState.Connected || Pvr_UnitySDKAPI.Controller.UPvr_GetControllerState(1) == ControllerState.Connected)
		{
			HeadSetController.SetActive(value: false);
		}
		else
		{
			HeadSetController.SetActive(value: true);
		}
		if (Pvr_UnitySDKAPI.Controller.UPvr_GetMainHandNess() == 0)
		{
			currentController = controller0;
		}
		if (Pvr_UnitySDKAPI.Controller.UPvr_GetMainHandNess() == 1)
		{
			currentController = controller1;
		}
	}

	private void CheckControllerStateForGoblin(string state)
	{
		HeadSetController.SetActive(Convert.ToInt16(state) != 1);
	}

	public void SwitchControlMode()
	{
	}
}
public class Pvr_ControllerEventsExamples : MonoBehaviour
{
	private void Start()
	{
		if (!(GetComponent<Pvr_UIPointer>() == null))
		{
			GetComponent<Pvr_UIPointer>().UIPointerElementEnter += UIPointerElementEnter;
			GetComponent<Pvr_UIPointer>().UIPointerElementExit += UIPointerElementExit;
			GetComponent<Pvr_UIPointer>().UIPointerElementClick += UIPointerElementClick;
			GetComponent<Pvr_UIPointer>().UIPointerElementDragStart += UIPointerElementDragStart;
			GetComponent<Pvr_UIPointer>().UIPointerElementDragEnd += UIPointerElementDragEnd;
		}
	}

	private void UIPointerElementEnter(object sender, UIPointerEventArgs e)
	{
		PLOG.I("UI Pointer entered" + e.currentTarget.name);
	}

	private void UIPointerElementExit(object sender, UIPointerEventArgs e)
	{
		PLOG.I("UI Pointer exited" + e.currentTarget.name);
	}

	private void UIPointerElementClick(object sender, UIPointerEventArgs e)
	{
		PLOG.I("UI Pointer clicked" + e.currentTarget.name);
	}

	private void UIPointerElementDragStart(object sender, UIPointerEventArgs e)
	{
		PLOG.I("UI Pointer started dragging" + e.currentTarget.name);
	}

	private void UIPointerElementDragEnd(object sender, UIPointerEventArgs e)
	{
		PLOG.I("UI Pointer stopped dragging" + e.currentTarget.name);
	}
}
public class Pvr_ControllerInit : MonoBehaviour
{
	private ControllerVariety Variety;

	private bool isCustomModel;

	[SerializeField]
	private GameObject goblin;

	[SerializeField]
	private GameObject g2;

	[SerializeField]
	private GameObject neo2L;

	[SerializeField]
	private GameObject neo2R;

	[SerializeField]
	private GameObject neo3L;

	[SerializeField]
	private GameObject neo3R;

	[SerializeField]
	private Material standardMat;

	[SerializeField]
	private Material unlitMat;

	private int controllerType = -1;

	[HideInInspector]
	public bool loadModelSuccess;

	private int systemOrUnity;

	private JsonData curControllerData;

	private string modelName = "";

	private string texFormat = "";

	private string prePath = "";

	private string modelFilePath = "/system/media/PvrRes/controller/";

	private const string goblinTexbasePath = "Controller/controller1/controller1";

	private const string g2TexbasePath = "Controller/controller3/controller3";

	private const string neo2TexbasePath = "Controller/controller4/controller4";

	private const string neo3TexbasePath = "Controller/controller5/controller5";

	private void Awake()
	{
		Render.UPvr_GetIntConfig(15, ref systemOrUnity);
		Variety = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().Variety;
		isCustomModel = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().IsCustomModel;
		if (!isCustomModel)
		{
			Pvr_ControllerManager.PvrServiceStartSuccessEvent += ServiceStartSuccess;
			Pvr_ControllerManager.SetControllerAbilityEvent += CheckControllerStateOfAbility;
			Pvr_ControllerManager.ControllerStatusChangeEvent += CheckControllerStateForGoblin;
		}
	}

	private void OnDestroy()
	{
		Pvr_ControllerManager.PvrServiceStartSuccessEvent -= ServiceStartSuccess;
		Pvr_ControllerManager.SetControllerAbilityEvent -= CheckControllerStateOfAbility;
		Pvr_ControllerManager.ControllerStatusChangeEvent -= CheckControllerStateForGoblin;
	}

	private void OnApplicationPause(bool pause)
	{
		if (pause)
		{
			DestroyLocalController();
		}
	}

	private void ServiceStartSuccess()
	{
		int num = Pvr_UnitySDKAPI.Controller.UPvr_GetDeviceType();
		if (controllerType != num && num != 0)
		{
			controllerType = num;
		}
		LoadResFromJson();
		if (Pvr_ControllerManager.controllerlink.neoserviceStarted)
		{
			if (Variety == ControllerVariety.Controller0)
			{
				if (Pvr_ControllerManager.controllerlink.controller0Connected)
				{
					StartCoroutine(RefreshController(0));
				}
				else
				{
					DestroyLocalController();
				}
			}
			if (Variety == ControllerVariety.Controller1)
			{
				if (Pvr_ControllerManager.controllerlink.controller1Connected)
				{
					StartCoroutine(RefreshController(1));
				}
				else
				{
					DestroyLocalController();
				}
			}
		}
		if (Pvr_ControllerManager.controllerlink.goblinserviceStarted && Variety == ControllerVariety.Controller0)
		{
			if (Pvr_ControllerManager.controllerlink.controller0Connected)
			{
				StartCoroutine(RefreshController(0));
			}
			else
			{
				DestroyLocalController();
			}
		}
	}

	private void LoadResFromJson()
	{
		string text = Pvr_UnitySDKAPI.System.UPvr_GetObjectOrArray("config.controller", 7);
		if (text != null)
		{
			JsonData jsonData = JsonMapper.ToObject(text);
			if (controllerType >= 0 && jsonData.Count >= controllerType)
			{
				curControllerData = jsonData[controllerType - 1];
				modelFilePath = (string)curControllerData["base_path"];
				modelName = (string)curControllerData["model_name"] + "_sys";
			}
		}
		else
		{
			PLOG.E("PvrLog LoadJsonFromSystem Error");
		}
	}

	private void CheckControllerStateForGoblin(string state)
	{
		int num = Pvr_UnitySDKAPI.Controller.UPvr_GetDeviceType();
		if (Variety != 0)
		{
			return;
		}
		if (Convert.ToInt16(state) == 1)
		{
			if (controllerType != num)
			{
				DestroySysController();
				controllerType = num;
			}
			StartCoroutine(RefreshController(0));
		}
		else
		{
			DestroyLocalController();
		}
	}

	private void CheckControllerStateOfAbility(string data)
	{
		bool num = Convert.ToBoolean(Convert.ToInt16(data.Substring(4, 1)));
		short num2 = Convert.ToInt16(data.Substring(0, 1));
		int num3 = Pvr_UnitySDKAPI.Controller.UPvr_GetDeviceType();
		if (num)
		{
			controllerType = num3;
			switch (num2)
			{
			case 0:
				if (Variety == ControllerVariety.Controller0)
				{
					StartCoroutine(RefreshController(0));
				}
				break;
			case 1:
				if (Variety == ControllerVariety.Controller1)
				{
					StartCoroutine(RefreshController(1));
				}
				break;
			}
			return;
		}
		switch (num2)
		{
		case 0:
			if (Variety == ControllerVariety.Controller0)
			{
				DestroyLocalController();
			}
			break;
		case 1:
			if (Variety == ControllerVariety.Controller1)
			{
				DestroyLocalController();
			}
			break;
		}
	}

	private void DestroyLocalController()
	{
		foreach (Transform item in base.transform)
		{
			UnityEngine.Object.Destroy(item.gameObject);
			loadModelSuccess = false;
		}
	}

	private void DestroySysController()
	{
		foreach (Transform item in base.transform)
		{
			if (item.name == modelName)
			{
				UnityEngine.Object.Destroy(item.gameObject);
				loadModelSuccess = false;
			}
		}
	}

	private IEnumerator RefreshController(int id)
	{
		yield return null;
		yield return null;
		if (Pvr_UnitySDKAPI.Controller.UPvr_GetControllerState(id) != ControllerState.Connected)
		{
			yield break;
		}
		if (systemOrUnity == 0)
		{
			LoadControllerFromPrefab();
			if (!loadModelSuccess)
			{
				LoadControllerFromSystem(id);
			}
		}
		else
		{
			bool flag = false;
			foreach (Transform item in base.transform)
			{
				if (item.name == modelName)
				{
					flag = true;
				}
			}
			if (!flag)
			{
				LoadControllerFromSystem(id);
				if (!loadModelSuccess)
				{
					LoadControllerFromPrefab();
				}
			}
			else
			{
				base.transform.Find(modelName).gameObject.SetActive(value: true);
			}
		}
		Pvr_ToolTips.RefreshTips();
		PLOG.I("PvrLog Controller Refresh Success");
	}

	private void LoadControllerFromPrefab()
	{
		switch (controllerType)
		{
		case 1:
		{
			Pvr_ControllerVisual pvr_ControllerVisual3 = UnityEngine.Object.Instantiate(goblin, base.transform, worldPositionStays: false).AddComponent<Pvr_ControllerVisual>();
			pvr_ControllerVisual3.currentDevice = ControllerDevice.Goblin;
			LoadTexture(pvr_ControllerVisual3, "Controller/controller1/controller1", fromRes: true);
			loadModelSuccess = true;
			break;
		}
		case 3:
		{
			Pvr_ControllerVisual pvr_ControllerVisual2 = UnityEngine.Object.Instantiate(g2, base.transform, worldPositionStays: false).AddComponent<Pvr_ControllerVisual>();
			pvr_ControllerVisual2.currentDevice = ControllerDevice.G2;
			LoadTexture(pvr_ControllerVisual2, "Controller/controller3/controller3", fromRes: true);
			loadModelSuccess = true;
			break;
		}
		case 4:
		{
			Pvr_ControllerVisual pvr_ControllerVisual4 = UnityEngine.Object.Instantiate((Variety == ControllerVariety.Controller0) ? neo2L : neo2R, base.transform, worldPositionStays: false).AddComponent<Pvr_ControllerVisual>();
			pvr_ControllerVisual4.currentDevice = ControllerDevice.Neo2;
			LoadTexture(pvr_ControllerVisual4, "Controller/controller4/controller4", fromRes: true);
			loadModelSuccess = true;
			break;
		}
		case 5:
		{
			Pvr_ControllerVisual pvr_ControllerVisual = UnityEngine.Object.Instantiate((Variety == ControllerVariety.Controller0) ? neo3L : neo3R, base.transform, worldPositionStays: false).AddComponent<Pvr_ControllerVisual>();
			pvr_ControllerVisual.currentDevice = ControllerDevice.Neo3;
			LoadTexture(pvr_ControllerVisual, "Controller/controller5/controller5", fromRes: true);
			loadModelSuccess = true;
			break;
		}
		default:
			loadModelSuccess = false;
			break;
		}
	}

	private void LoadControllerFromSystem(int id)
	{
		string text = controllerType.ToString() + id + ".obj";
		string text2 = modelFilePath + text;
		if (!File.Exists(text2))
		{
			PLOG.I("PvrLog Obj File does not exist==" + text2);
			return;
		}
		GameObject gameObject = new GameObject();
		gameObject.name = modelName;
		gameObject.AddComponent<MeshFilter>().mesh = Pvr_ObjImporter.Instance.ImportFile(text2);
		gameObject.transform.SetParent(base.transform);
		gameObject.transform.localPosition = Vector3.zero;
		gameObject.AddComponent<MeshRenderer>().material = (((int)curControllerData["material_type"] == 0) ? standardMat : unlitMat);
		loadModelSuccess = true;
		Pvr_ControllerVisual pvr_ControllerVisual = gameObject.AddComponent<Pvr_ControllerVisual>();
		switch (controllerType)
		{
		case 1:
			pvr_ControllerVisual.currentDevice = ControllerDevice.Goblin;
			break;
		case 3:
			pvr_ControllerVisual.currentDevice = ControllerDevice.G2;
			break;
		case 4:
			pvr_ControllerVisual.currentDevice = ControllerDevice.Neo2;
			break;
		case 5:
			pvr_ControllerVisual.currentDevice = ControllerDevice.Neo3;
			break;
		default:
			pvr_ControllerVisual.currentDevice = ControllerDevice.NewController;
			break;
		}
		pvr_ControllerVisual.variety = Variety;
		LoadTexture(pvr_ControllerVisual, controllerType.ToString() + id, fromRes: false);
		gameObject.transform.localRotation = Quaternion.Euler(new Vector3(0f, 180f, 0f));
		gameObject.transform.localScale = new Vector3(-0.01f, 0.01f, 0.01f);
	}

	private void LoadTexture(Pvr_ControllerVisual visual, string controllerName, bool fromRes)
	{
		if (fromRes)
		{
			texFormat = "";
			prePath = controllerName;
		}
		else
		{
			texFormat = "." + (string)curControllerData["tex_format"];
			prePath = modelFilePath + controllerName;
		}
		string filepath = prePath + "_idle" + texFormat;
		visual.m_idle = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_app" + texFormat;
		visual.m_app = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_home" + texFormat;
		visual.m_home = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_touch" + texFormat;
		visual.m_touchpad = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_volume_down" + texFormat;
		visual.m_volDn = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_volume_up" + texFormat;
		visual.m_volUp = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_trigger" + texFormat;
		visual.m_trigger = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_a" + texFormat;
		visual.m_a = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_b" + texFormat;
		visual.m_b = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_x" + texFormat;
		visual.m_x = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_y" + texFormat;
		visual.m_y = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_grip" + texFormat;
		visual.m_grip = LoadOneTexture(filepath, fromRes);
	}

	private Texture2D LoadOneTexture(string filepath, bool fromRes)
	{
		if (fromRes)
		{
			return Resources.Load<Texture2D>(filepath);
		}
		int width = (int)curControllerData["tex_width"];
		int height = (int)curControllerData["tex_height"];
		Texture2D texture2D = new Texture2D(width, height);
		texture2D.LoadImage(ReadPNG(filepath));
		return texture2D;
	}

	private byte[] ReadPNG(string path)
	{
		FileStream fileStream = new FileStream(path, FileMode.Open, FileAccess.Read);
		fileStream.Seek(0L, SeekOrigin.Begin);
		byte[] array = new byte[fileStream.Length];
		fileStream.Read(array, 0, (int)fileStream.Length);
		fileStream.Close();
		fileStream.Dispose();
		fileStream = null;
		return array;
	}
}
public class Pvr_ControllerLink
{
	public AndroidJavaClass javaHummingbirdClass;

	public AndroidJavaClass javaPico2ReceiverClass;

	public AndroidJavaClass javaserviceClass;

	public AndroidJavaClass javavractivityclass;

	public AndroidJavaClass javaCVClass;

	public AndroidJavaObject activity;

	public string gameobjname = "";

	public bool picoDevice;

	public string hummingBirdMac;

	public int hummingBirdRSSI;

	public bool goblinserviceStarted;

	public bool neoserviceStarted;

	public bool controller0Connected;

	public bool controller1Connected;

	public int mainHandID;

	public Pvr_Controller.UserHandNess handness;

	public int controllerType;

	public ControllerHand Controller0;

	public ControllerHand Controller1;

	public int platFormType = -1;

	public int trackingmode = -1;

	public int systemProp = -1;

	public int enablehand6dofbyhead = -1;

	public bool switchHomeKey = true;

	private const float SWITCH_METER = 1000f;

	private int iPhoneHMDModeEnabled;

	private float[] hbPoseData = new float[4];

	private float[] sensorData = new float[28];

	private int[] keyData = new int[134];

	private int[] neo3TouchValue = new int[15];

	private float[] fixedState = new float[7] { 0f, 0f, 0f, 1f, 0f, 0f, 0f };

	private float[] neoposeData = new float[7] { 0f, 0f, 0f, 1f, 0f, 0f, 0f };

	private int[] goblinKeyArray = new int[47];

	private int[] neoKeyArray = new int[67];

	private int[] neotriggerV = new int[9];

	private float[] velocity = new float[3];

	private float[] angularVelocity = new float[3];

	private float[] acceData = new float[3];

	private float[] predictData = new float[7];

	public Pvr_ControllerLink(string name)
	{
		gameobjname = name;
		hummingBirdMac = "";
		hummingBirdRSSI = 0;
		UnityEngine.Debug.Log("PvrLog Controller GameObject:" + gameobjname);
		StartHummingBirdService();
		Controller0 = new ControllerHand();
		Controller0.Position = new Vector3(0f, Pvr_UnitySDKSensor.Instance.HeadPose.Position.y, 0f) + new Vector3(-0.1f, -0.3f, 0.3f);
		Controller1 = new ControllerHand();
		Controller1.Position = new Vector3(0f, Pvr_UnitySDKSensor.Instance.HeadPose.Position.y, 0f) + new Vector3(0.1f, -0.3f, 0.3f);
	}

	private void StartHummingBirdService()
	{
		try
		{
			AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
			activity = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
			javaHummingbirdClass = new AndroidJavaClass("com.picovr.picovrlib.hummingbirdclient.HbClientActivity");
			javaCVClass = new AndroidJavaClass("com.picovr.picovrlib.cvcontrollerclient.ControllerClient");
			javavractivityclass = new AndroidJavaClass("com.psmart.vrlib.VrActivity");
			javaserviceClass = new AndroidJavaClass("com.picovr.picovrlib.hummingbirdclient.UnityClient");
			Pvr_UnitySDKAPI.System.Pvr_SetInitActivity(activity.GetRawObject(), javaHummingbirdClass.GetRawClass());
			Render.UPvr_GetIntConfig(4, ref platFormType);
			UnityEngine.Debug.Log("PvrLog platform" + platFormType);
			Render.UPvr_GetIntConfig(5, ref trackingmode);
			UnityEngine.Debug.Log("PvrLog trackingmode" + trackingmode);
			systemProp = GetSysproc();
			UnityEngine.Debug.Log("PvrLog systemProp" + systemProp);
			Render.UPvr_GetIntConfig(7, ref enablehand6dofbyhead);
			UnityEngine.Debug.Log("PvrLog enablehand6dofbyhead" + enablehand6dofbyhead);
			if (trackingmode == 0 || trackingmode == 1 || ((trackingmode == 3 || trackingmode == 5 || trackingmode == 6) && (systemProp == 1 || systemProp == 3)))
			{
				picoDevice = platFormType != 0;
				javaPico2ReceiverClass = new AndroidJavaClass("com.picovr.picovrlib.hummingbirdclient.HbClientReceiver");
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "startReceiver", activity, gameobjname);
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "setPlatformType", platFormType);
			}
			else
			{
				picoDevice = true;
				SetGameObjectToJar(gameobjname);
			}
			Render.UPvr_GetIntConfig(16, ref iPhoneHMDModeEnabled);
			if (iPhoneHMDModeEnabled == 1)
			{
				BindService();
			}
			else if (IsServiceExisted())
			{
				BindService();
			}
		}
		catch (AndroidJavaException ex)
		{
			PLOG.E("ConnectToAndriod--catch" + ex.Message);
		}
	}

	public bool IsServiceExisted()
	{
		bool result = false;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaserviceClass, "isServiceExisted", activity, trackingmode);
		UnityEngine.Debug.Log("PvrLog ServiceExisted ?" + result);
		return result;
	}

	public void SetGameObjectToJar(string name)
	{
		UnityEngine.Debug.Log("PvrLog SetGameObjectToJar " + name);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setGameObjectCallback", name);
	}

	public void BindService()
	{
		UnityEngine.Debug.Log("PvrLog Bind Service");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaserviceClass, "bindService", activity, trackingmode);
	}

	public void UnBindService()
	{
		UnityEngine.Debug.Log("PvrLog UnBind Service");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaserviceClass, "unbindService", activity, trackingmode);
	}

	public void StopReceiver()
	{
		UnityEngine.Debug.Log("PvrLog StopReceiver");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "stopReceiver", activity);
	}

	public void StartReceiver()
	{
		UnityEngine.Debug.Log("PvrLog StartReceiver");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "startReceiver", activity, gameobjname);
	}

	public int getHandness()
	{
		int result = -1;
		if (iPhoneHMDModeEnabled == 0)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javavractivityclass, "getPvrHandness", activity);
		}
		else
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getHbHandednessInSP");
		}
		PLOG.I("PvrLog GetHandness =" + result);
		return result;
	}

	public void setHandness(int hand)
	{
		PLOG.I("PvrLog SetHandness =" + hand);
		if (iPhoneHMDModeEnabled == 1)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "setHbHandednessInSP", hand);
		}
	}

	public void StartScan()
	{
		PLOG.I("PvrLog ScanHBController");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "scanHbDevice", true);
	}

	public void StopScan()
	{
		PLOG.I("PvrLog StopScanHBController");
		if (iPhoneHMDModeEnabled == 0)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "scanHbDevice", false);
		}
	}

	public int GetSysproc()
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaserviceClass, "getSysproc");
		PLOG.I("PvrLog GetSysproc" + result);
		return result;
	}

	public void ResetController(int num)
	{
		UnityEngine.Debug.Log("PvrLog ResetController" + num);
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "resetControllerSensorState", num);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "resetHbSensorState");
		}
	}

	public void ConnectBLE()
	{
		UnityEngine.Debug.Log("PvrLog ConnectHBController" + hummingBirdMac);
		if (hummingBirdMac != "")
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "connectHbController", hummingBirdMac);
		}
	}

	public void DisConnectBLE()
	{
		UnityEngine.Debug.Log("PvrLog DisConnectHBController");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "disconnectHbController");
	}

	public bool StartUpgrade()
	{
		UnityEngine.Debug.Log("PvrLog StartUpgradeHBController");
		bool result = false;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "startUpgrade");
		return result;
	}

	public void setBinPath(string path, bool isasset)
	{
		UnityEngine.Debug.Log("PvrLog setBinPath" + path + isasset);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "setBinPath", path, isasset);
	}

	public string GetBLEImageType()
	{
		string result = "";
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getBLEImageType");
		}
		UnityEngine.Debug.Log("PvrLog GetBLEImageType" + result);
		return result;
	}

	public long GetBLEVersion()
	{
		long result = 0L;
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getBLEVersion");
		}
		UnityEngine.Debug.Log("PvrLog GetBLEVersion" + result);
		return result;
	}

	public string GetFileImageType()
	{
		string result = "";
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getFileImageType");
		}
		UnityEngine.Debug.Log("PvrLog GetFileImageType" + result);
		return result;
	}

	public long GetFileVersion()
	{
		long result = 0L;
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getFileVersion");
		}
		UnityEngine.Debug.Log("PvrLog GetFileVersion" + result);
		return result;
	}

	public int GetControllerConnectionState(int num)
	{
		int result = -1;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerConnectionState", num);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getHbConnectionState");
		}
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog GetControllerState:" + num + "state:" + result);
		}
		return result;
	}

	public void RebackToLauncher()
	{
		UnityEngine.Debug.Log("PvrLog RebackToLauncher");
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startLauncher");
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "startLauncher");
		}
	}

	public void TurnUpVolume()
	{
		UnityEngine.Debug.Log("PvrLog TurnUpVolume");
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "turnUpVolume", activity);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "turnUpVolume", activity);
		}
	}

	public void TurnDownVolume()
	{
		UnityEngine.Debug.Log("PvrLog TurnDownVolume");
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "turnDownVolume", activity);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "turnDownVolume", activity);
		}
	}

	public float[] GetHBControllerPoseData()
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref hbPoseData, javaHummingbirdClass, "getHBSensorPose");
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog HBControllerData" + hbPoseData[0] + "," + hbPoseData[1] + "," + hbPoseData[2] + "," + hbPoseData[3]);
		}
		return hbPoseData;
	}

	public float[] GetControllerSensorData()
	{
		if (enablehand6dofbyhead == 1)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref sensorData, javaCVClass, "getControllerDataInfoBySharmem", Pvr_UnitySDKManager.SDK.headData);
		}
		else
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref sensorData, javaCVClass, "getControllerDataInfoBySharmem");
		}
		return sensorData;
	}

	public int[] GetControllerKeyData()
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref keyData, javaCVClass, "getDoubleControllerKeyEventUnityExtBySharmem");
		return keyData;
	}

	public int[] GetNeo3TouchData(int hand)
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neo3TouchValue, javaCVClass, "getControllerTouchEvent", hand);
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog Neo3Touch hand:" + hand + "-" + neo3TouchValue[0] + neo3TouchValue[1] + neo3TouchValue[2] + neo3TouchValue[3] + neo3TouchValue[4] + "," + neo3TouchValue[5] + neo3TouchValue[6] + neo3TouchValue[7] + neo3TouchValue[8] + neo3TouchValue[9] + "," + neo3TouchValue[10] + neo3TouchValue[11] + neo3TouchValue[12] + neo3TouchValue[13] + neo3TouchValue[14]);
		}
		return neo3TouchValue;
	}

	public int GetNeo3GripValue(int hand)
	{
		int result = 0;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerGripValue", hand);
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog Neo3GripValue:" + result);
		}
		return result;
	}

	public float[] GetControllerFixedSensorState(int hand)
	{
		if (trackingmode == 2 || trackingmode == 3)
		{
			return fixedState;
		}
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref fixedState, javaCVClass, "getControllerFixedSensorState", hand);
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog GetControllerFixedSensorState " + hand + "Rotation:" + fixedState[0] + "," + fixedState[1] + "," + fixedState[2] + "," + fixedState[3] + "Position:" + fixedState[4] + "," + fixedState[5] + "," + fixedState[6]);
		}
		return fixedState;
	}

	public float[] GetCvControllerPoseData(int hand)
	{
		if (enablehand6dofbyhead == 1)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neoposeData, javaCVClass, "getControllerSensorState", hand, Pvr_UnitySDKManager.SDK.headData);
		}
		else
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neoposeData, javaCVClass, "getControllerSensorState", hand);
		}
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog CVControllerData :" + neoposeData[0] + "," + neoposeData[1] + "," + neoposeData[2] + "," + neoposeData[3] + "," + neoposeData[4] + "," + neoposeData[5] + "," + neoposeData[6]);
		}
		return neoposeData;
	}

	public int[] GetHBControllerKeyData()
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref goblinKeyArray, javaHummingbirdClass, "getHBKeyEventUnityExt");
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog HBControllerKey" + goblinKeyArray[0] + goblinKeyArray[1] + goblinKeyArray[2] + goblinKeyArray[3] + goblinKeyArray[4] + "," + goblinKeyArray[5] + goblinKeyArray[6] + goblinKeyArray[7] + goblinKeyArray[8] + goblinKeyArray[9] + "," + goblinKeyArray[10] + goblinKeyArray[11] + goblinKeyArray[12] + goblinKeyArray[13] + goblinKeyArray[14] + "," + goblinKeyArray[15] + goblinKeyArray[16] + goblinKeyArray[17] + goblinKeyArray[18] + goblinKeyArray[19] + "," + goblinKeyArray[20] + goblinKeyArray[21] + goblinKeyArray[22] + goblinKeyArray[23] + goblinKeyArray[24] + "," + goblinKeyArray[25] + goblinKeyArray[26] + goblinKeyArray[27] + goblinKeyArray[28] + goblinKeyArray[29] + "," + goblinKeyArray[30] + goblinKeyArray[31] + goblinKeyArray[32] + goblinKeyArray[33] + goblinKeyArray[34] + "," + goblinKeyArray[35] + goblinKeyArray[36] + goblinKeyArray[37] + goblinKeyArray[38] + goblinKeyArray[39] + "," + goblinKeyArray[40] + goblinKeyArray[41] + goblinKeyArray[42] + goblinKeyArray[43] + goblinKeyArray[44] + "," + goblinKeyArray[45] + goblinKeyArray[46]);
		}
		return goblinKeyArray;
	}

	public int GetHBKeyValue()
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getTriggerKeyEvent");
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog GoblinControllerTriggerKey:" + result);
		}
		return result;
	}

	public int[] GetCvControllerKeyData(int hand)
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neoKeyArray, javaCVClass, "getControllerKeyEventUnityExt", hand);
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog CVControllerKey hand:" + hand + "-" + neoKeyArray[0] + neoKeyArray[1] + neoKeyArray[2] + neoKeyArray[3] + neoKeyArray[4] + "," + neoKeyArray[5] + neoKeyArray[6] + neoKeyArray[7] + neoKeyArray[8] + neoKeyArray[9] + "," + neoKeyArray[10] + neoKeyArray[11] + neoKeyArray[12] + neoKeyArray[13] + neoKeyArray[14] + "," + neoKeyArray[15] + neoKeyArray[16] + neoKeyArray[17] + neoKeyArray[18] + neoKeyArray[19] + "," + neoKeyArray[20] + neoKeyArray[21] + neoKeyArray[22] + neoKeyArray[23] + neoKeyArray[24] + "," + neoKeyArray[25] + neoKeyArray[26] + neoKeyArray[27] + neoKeyArray[28] + neoKeyArray[29] + "," + neoKeyArray[30] + neoKeyArray[31] + neoKeyArray[32] + neoKeyArray[33] + neoKeyArray[34] + "," + neoKeyArray[35] + neoKeyArray[36] + neoKeyArray[37] + neoKeyArray[38] + neoKeyArray[39] + "," + neoKeyArray[40] + neoKeyArray[41] + neoKeyArray[42] + neoKeyArray[43] + neoKeyArray[44] + "," + neoKeyArray[45] + neoKeyArray[46] + neoKeyArray[47] + neoKeyArray[48] + neoKeyArray[49] + "," + neoKeyArray[50] + neoKeyArray[51] + neoKeyArray[52] + neoKeyArray[53] + neoKeyArray[54] + "," + neoKeyArray[55] + neoKeyArray[56] + neoKeyArray[57] + neoKeyArray[58] + neoKeyArray[59] + "," + neoKeyArray[60] + neoKeyArray[61] + neoKeyArray[62] + neoKeyArray[63] + neoKeyArray[64] + "," + neoKeyArray[65] + neoKeyArray[66]);
		}
		return neoKeyArray;
	}

	public int GetCVTriggerValue(int hand)
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neotriggerV, javaCVClass, "getControllerKeyEvent", hand);
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog CVTriggerValue " + neotriggerV[7]);
		}
		return neotriggerV[7];
	}

	public void AutoConnectHbController(int scanTimeMs)
	{
		PLOG.I("PvrLog AutoConnectHbController" + scanTimeMs);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "autoConnectHbController", scanTimeMs, gameobjname);
	}

	public void StartControllerThread(int headSensorState, int handSensorState)
	{
		if (BoundarySystem.UPvr_IsBoundaryEnable())
		{
			headSensorState = 1;
			handSensorState = 1;
		}
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startControllerThread", headSensorState, handSensorState);
		UnityEngine.Debug.Log("PvrLog StartControllerThread" + headSensorState + handSensorState);
	}

	public void StopControllerThread(int headSensorState, int handSensorState)
	{
		if (BoundarySystem.UPvr_IsBoundaryEnable())
		{
			headSensorState = 1;
			handSensorState = 1;
		}
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "stopControllerThread", headSensorState, handSensorState);
		UnityEngine.Debug.Log("PvrLog StopControllerThread" + headSensorState + handSensorState);
	}

	public void SetUnityVersionToJar(string version)
	{
		if (trackingmode == 4 || trackingmode == 5 || trackingmode == 6)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setUnityVersion", version);
		}
		UnityEngine.Debug.Log("PvrLog SetUnityVersionToJar" + version);
	}

	public Vector3 GetVelocity(int num)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref velocity, javaCVClass, "getControllerLinearVelocity", num);
		}
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog Velocity" + velocity[0] / 1000f + "," + velocity[1] / 1000f + "," + velocity[2] / 1000f);
		}
		return new Vector3(velocity[0] / 1000f, velocity[1] / 1000f, (0f - velocity[2]) / 1000f);
	}

	public Vector3 GetAngularVelocity(int num)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref angularVelocity, javaCVClass, "getControllerAngularVelocity", num);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref angularVelocity, javaHummingbirdClass, "getHbAngularVelocity");
		}
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog Gyro:" + angularVelocity[0] + "," + angularVelocity[1] + "," + angularVelocity[2]);
		}
		if (!float.IsNaN(angularVelocity[0]) && !float.IsNaN(angularVelocity[1]) && !float.IsNaN(angularVelocity[2]))
		{
			return new Vector3(angularVelocity[0], angularVelocity[1], angularVelocity[2]);
		}
		return new Vector3(0f, 0f, 0f);
	}

	public Vector3 GetAcceleration(int num)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref acceData, javaCVClass, "getControllerAcceleration", num);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref acceData, javaHummingbirdClass, "getHbAcceleration");
		}
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog Acce:" + acceData[0] / 1000f + acceData[1] / 1000f + acceData[2] / 1000f);
		}
		if (!float.IsNaN(acceData[0]) && !float.IsNaN(acceData[1]) && !float.IsNaN(acceData[2]))
		{
			return new Vector3(acceData[0] / 1000f, acceData[1] / 1000f, (0f - acceData[2]) / 1000f);
		}
		return new Vector3(0f, 0f, 0f);
	}

	public string GetConnectedDeviceMac()
	{
		string result = "";
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getConnectedDeviceMac");
		}
		PLOG.I("PvrLog ConnectedDeviceMac:" + result);
		return result;
	}

	public void VibrateNeo2Controller(float strength, int time, int hand)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "vibrateCV2ControllerStrength", strength, time, hand);
		}
		PLOG.I("PvrLog VibrateNeo2Controller:" + strength + time + hand);
	}

	public void VibrateController(float strength, int time, int hand)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "vibrateCV2ControllerStrength", strength, time, hand);
		}
		PLOG.I("PvrLog VibrateController:" + strength + time + hand);
	}

	public int GetMainControllerIndex()
	{
		int result = 0;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getMainControllerIndex");
		}
		PLOG.I("PvrLog GetMainControllerIndex:" + result);
		return result;
	}

	public void SetMainController(int index)
	{
		PLOG.I("PvrLog SetMainController:" + index);
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setMainController", index);
		}
	}

	public void ResetHeadSensorForController()
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "resetHeadSensorForController");
		}
		PLOG.I("PvrLog ResetHeadSensorForController:");
	}

	public void GetDeviceVersion(int deviceType)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "getDeviceVersion", deviceType);
		}
		PLOG.I("PvrLog GetDeviceVersion:" + deviceType);
	}

	public void GetControllerSnCode(int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "getControllerSnCode", controllerSerialNum);
		}
		PLOG.I("PvrLog GetControllerSnCode:" + controllerSerialNum);
	}

	public void SetControllerUnbind(int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setControllerUnbind", controllerSerialNum);
		}
		PLOG.I("PvrLog SetControllerUnbind:" + controllerSerialNum);
	}

	public void SetStationRestart()
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setStationRestart");
		}
		PLOG.I("PvrLog SetStationRestart");
	}

	public void StartStationOtaUpdate()
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startStationOtaUpdate");
		}
		PLOG.I("PvrLog StartStationOtaUpdate");
	}

	public void StartControllerOtaUpdate(int mode, int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startControllerOtaUpdate", mode, controllerSerialNum);
		}
		PLOG.I("PvrLog StartControllerOtaUpdate" + mode + controllerSerialNum);
	}

	public void EnterPairMode(int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "enterPairMode", controllerSerialNum);
		}
		PLOG.I("PvrLog EnterPairMode" + controllerSerialNum);
	}

	public void SetControllerShutdown(int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setControllerShutdown", controllerSerialNum);
		}
		PLOG.I("PvrLog SetControllerShutdown" + controllerSerialNum);
	}

	public int GetStationPairState()
	{
		int result = -1;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getStationPairState");
		}
		PLOG.I("PvrLog StationPairState" + result);
		return result;
	}

	public int GetStationOtaUpdateProgress()
	{
		int result = -1;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getStationOtaUpdateProgress");
		}
		PLOG.I("PvrLog StationOtaUpdateProgress" + result);
		return result;
	}

	public int GetControllerOtaUpdateProgress()
	{
		int result = -1;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerOtaUpdateProgress");
		}
		PLOG.I("PvrLog ControllerOtaUpdateProgress" + result);
		return result;
	}

	public void GetControllerVersionAndSN(int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "getControllerVersionAndSN", controllerSerialNum);
		}
		PLOG.I("PvrLog GetControllerVersionAndSN" + controllerSerialNum);
	}

	public void GetControllerUniqueID()
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "getControllerUniqueID");
		}
		PLOG.I("PvrLog GetControllerUniqueID");
	}

	public void InterruptStationPairMode()
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "interruptStationPairMode");
		}
		PLOG.I("PvrLog InterruptStationPairMode");
	}

	public int GetControllerAbility(int controllerSerialNum)
	{
		int result = -1;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerAbility", controllerSerialNum);
		}
		PLOG.I("PvrLog ControllerAbility:" + result);
		return result;
	}

	public void SwitchHomeKey(bool state)
	{
		PLOG.I("PvrLog SwitchHomeKey:" + state);
		switchHomeKey = state;
	}

	public void SetBootReconnect()
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "setBootReconnect");
		PLOG.I("PvrLog SetBootReconnect");
	}

	public int GetTemperature()
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getTemperature");
		PLOG.I("PvrLog Temperature:" + result);
		return result;
	}

	public int GetDeviceType()
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getDeviceType");
		PLOG.I("PvrLog DeviceType:" + result);
		return result;
	}

	public int GetControllerType()
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getControllerType");
		return result;
	}

	public string GetHummingBird2SN()
	{
		string result = "";
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getHummingBird2SN");
		PLOG.I("PvrLog HummingBird2SN:" + result);
		return result;
	}

	public string GetControllerVersion()
	{
		string result = "";
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getControllerVersion");
		PLOG.I("PvrLog ControllerVersion:" + result);
		return result;
	}

	public bool IsEnbleTrigger()
	{
		bool result = false;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "isEnbleTrigger");
		PLOG.I("PvrLog IsEnbleTrigger:" + result);
		return result;
	}

	public void StartCV2PairingMode(int devicetype)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startCV2PairingMode", devicetype);
		}
		PLOG.I("PvrLog StartCV2PairingMode:" + devicetype);
	}

	public void StopCV2PairingMode(int devicetype)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "stopCV2PairingMode", devicetype);
		}
		PLOG.I("PvrLog StopCV2PairingMode:" + devicetype);
	}

	public int GetControllerBindingState(int id)
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerBindingState", id);
		PLOG.I("PvrLog getControllerBindingState:" + result);
		return result;
	}

	public void setIsEnbleHomeKey(bool state)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setIsEnbleHomeKey", state);
		}
		PLOG.I("PvrLog setIsEnbleHomeKey:" + state);
	}

	public int getControllerSensorStatus(int id)
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerSensorStatus", id);
		PLOG.I("PvrLog getControllerSensorStatus:" + result);
		return result;
	}

	public float[] GetControllerPredictSensorData(int controllerID, float predictTime)
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "SetHeadDataAndPreTime", Pvr_UnitySDKManager.SDK.headData, predictTime);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref predictData, javaCVClass, "getControllerSensorStateWithHeadDataAndPreTime", controllerID);
		return predictData;
	}
}
public class Pvr_ControllerManager : MonoBehaviour
{
	public delegate void PvrServiceStartSuccess();

	public delegate void PvrControllerStateChanged(string data);

	public delegate void ChangeMainControllerCallBack(string index);

	public delegate void ChangeHandNessCallBack(string index);

	public delegate void SetHbServiceBindState();

	public delegate void ControllerThreadStartedCallback();

	public delegate void SetControllerServiceBindState();

	public delegate void ControllerStatusChange(string isconnect);

	public delegate void SetControllerAbility(string data);

	public delegate void SetControllerStateChanged(string data);

	public delegate void SetHbControllerMac(string mac);

	public delegate void ControllerDeviceVersionCallback(string data);

	public delegate void ControllerSnCodeCallback(string data);

	public delegate void ControllerUnbindCallback(string status);

	public delegate void ControllerStationStatusCallback(string status);

	public delegate void ControllerStationBusyCallback(string status);

	public delegate void ControllerOtaStartCodeCallback(string data);

	public delegate void ControllerDeviceVersionAndSNCallback(string data);

	public delegate void ControllerUniqueIDCallback(string data);

	public delegate void ControllerCombinedKeyUnbindCallback(string data);

	private static Pvr_ControllerManager instance;

	public static Pvr_ControllerLink controllerlink;

	private float cTime = 1f;

	private bool stopConnect;

	public Text toast;

	private bool controllerServicestate;

	private float disConnectTime;

	public bool LengthAdaptiveRay;

	private float[] sensorData = new float[28];

	private int[] keyData = new int[134];

	private float[] g2SensorData = new float[4];

	private int[] g2KeyData = new int[47];

	private int keyOffset;

	private int rotControllerMode = 1;

	public static Pvr_ControllerManager Instance
	{
		get
		{
			if (instance == null)
			{
				instance = UnityEngine.Object.FindObjectOfType<Pvr_ControllerManager>();
			}
			if (instance == null)
			{
				GameObject obj = new GameObject("GameObject");
				instance = obj.AddComponent<Pvr_ControllerManager>();
				obj.transform.localPosition = Vector3.zero;
			}
			return instance;
		}
	}

	public static event PvrServiceStartSuccess PvrServiceStartSuccessEvent;

	public static event PvrControllerStateChanged PvrControllerStateChangedEvent;

	public static event ChangeMainControllerCallBack ChangeMainControllerCallBackEvent;

	public static event ChangeHandNessCallBack ChangeHandNessCallBackEvent;

	public static event SetHbServiceBindState SetHbServiceBindStateEvent;

	public static event ControllerThreadStartedCallback ControllerThreadStartedCallbackEvent;

	public static event SetControllerServiceBindState SetControllerServiceBindStateEvent;

	public static event ControllerStatusChange ControllerStatusChangeEvent;

	public static event SetControllerAbility SetControllerAbilityEvent;

	public static event SetControllerStateChanged SetControllerStateChangedEvent;

	public static event SetHbControllerMac SetHbControllerMacEvent;

	public static event ControllerDeviceVersionCallback ControllerDeviceVersionCallbackEvent;

	public static event ControllerSnCodeCallback ControllerSnCodeCallbackEvent;

	public static event ControllerUnbindCallback ControllerUnbindCallbackEvent;

	public static event ControllerStationStatusCallback ControllerStationStatusCallbackEvent;

	public static event ControllerStationBusyCallback ControllerStationBusyCallbackEvent;

	public static event ControllerOtaStartCodeCallback ControllerOtaStartCodeCallbackEvent;

	public static event ControllerDeviceVersionAndSNCallback ControllerDeviceVersionAndSNCallbackEvent;

	public static event ControllerUniqueIDCallback ControllerUniqueIDCallbackEvent;

	public static event ControllerCombinedKeyUnbindCallback ControllerCombinedKeyUnbindCallbackEvent;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
		if (instance != this)
		{
			PLOG.E("instance object should be a singleton.");
			return;
		}
		if (controllerlink == null)
		{
			controllerlink = new Pvr_ControllerLink(base.gameObject.name);
			return;
		}
		controllerlink.SetGameObjectToJar(base.gameObject.name);
		BindService();
	}

	private void Start()
	{
		if (controllerlink.trackingmode < 2)
		{
			Invoke("CheckControllerService", 10f);
		}
		Render.UPvr_GetIntConfig(23, ref rotControllerMode);
	}

	private void Update()
	{
		if (controllerlink.neoserviceStarted)
		{
			sensorData = controllerlink.GetControllerSensorData();
			keyData = controllerlink.GetControllerKeyData();
			if (controllerlink.controller0Connected)
			{
				if (Pvr_UnitySDKManager.SDK.ShowVideoSeethrough)
				{
					sensorData[2] = 0f - sensorData[2];
					sensorData[3] = 0f - sensorData[3];
					controllerlink.Controller0.Rotation.Set(sensorData[0], sensorData[1], sensorData[2], sensorData[3]);
					if (rotControllerMode == 0)
					{
						controllerlink.Controller0.Rotation *= Quaternion.Euler(34f, 0f, 0f);
					}
					controllerlink.Controller0.Position.Set(sensorData[4] / 1000f, sensorData[5] / 1000f, (0f - sensorData[6]) / 1000f);
				}
				else
				{
					controllerlink.Controller0.Rotation.Set(sensorData[7], sensorData[8], sensorData[9], sensorData[10]);
					if (rotControllerMode == 0)
					{
						controllerlink.Controller0.Rotation *= Quaternion.Euler(34f, 0f, 0f);
					}
					controllerlink.Controller0.Position.Set(sensorData[11] / 1000f, sensorData[12] / 1000f, (0f - sensorData[13]) / 1000f);
				}
				if (!controllerlink.Controller0.isShowBoundary)
				{
					if (controllerlink.getControllerSensorStatus(0) == 0)
					{
						Sensor.UPvr_SetReinPosition(sensorData[0], sensorData[1], sensorData[2], sensorData[3], sensorData[4], sensorData[5], sensorData[6], 0, valid: false, 0);
					}
					else
					{
						controllerlink.Controller0.isShowBoundary = true;
						Sensor.UPvr_SetReinPosition(sensorData[0], sensorData[1], sensorData[2], sensorData[3], sensorData[4], sensorData[5], sensorData[6], 0, valid: true, Convert.ToInt32(Convert.ToString(keyData[35]) + Convert.ToString(keyData[15]) + "00", 2));
					}
				}
				else
				{
					Sensor.UPvr_SetReinPosition(sensorData[0], sensorData[1], sensorData[2], sensorData[3], sensorData[4], sensorData[5], sensorData[6], 0, valid: true, Convert.ToInt32(Convert.ToString(keyData[35]) + Convert.ToString(keyData[15]) + "00", 2));
				}
				TransformData(controllerlink.Controller0, 0, keyData);
			}
			else
			{
				Sensor.UPvr_SetReinPosition(sensorData[0], sensorData[1], sensorData[2], sensorData[3], sensorData[4], sensorData[5], sensorData[6], 0, valid: false, 0);
			}
			if (controllerlink.controller1Connected)
			{
				if (Pvr_UnitySDKManager.SDK.ShowVideoSeethrough)
				{
					sensorData[16] = 0f - sensorData[16];
					sensorData[17] = 0f - sensorData[17];
					controllerlink.Controller1.Rotation.Set(sensorData[14], sensorData[15], sensorData[16], sensorData[17]);
					if (rotControllerMode == 0)
					{
						controllerlink.Controller1.Rotation *= Quaternion.Euler(34f, 0f, 0f);
					}
					controllerlink.Controller1.Position.Set(sensorData[18] / 1000f, sensorData[19] / 1000f, (0f - sensorData[20]) / 1000f);
				}
				else
				{
					controllerlink.Controller1.Rotation.Set(sensorData[21], sensorData[22], sensorData[23], sensorData[24]);
					if (rotControllerMode == 0)
					{
						controllerlink.Controller1.Rotation *= Quaternion.Euler(34f, 0f, 0f);
					}
					controllerlink.Controller1.Position.Set(sensorData[25] / 1000f, sensorData[26] / 1000f, (0f - sensorData[27]) / 1000f);
				}
				if (!controllerlink.Controller1.isShowBoundary)
				{
					if (controllerlink.getControllerSensorStatus(1) == 0)
					{
						Sensor.UPvr_SetReinPosition(sensorData[14], sensorData[15], sensorData[16], sensorData[17], sensorData[18], sensorData[19], sensorData[20], 1, valid: false, 0);
					}
					else
					{
						controllerlink.Controller1.isShowBoundary = true;
						Sensor.UPvr_SetReinPosition(sensorData[14], sensorData[15], sensorData[16], sensorData[17], sensorData[18], sensorData[19], sensorData[20], 1, valid: true, Convert.ToInt32(Convert.ToString(keyData[102]) + Convert.ToString(keyData[82]) + "00", 2));
					}
				}
				else
				{
					Sensor.UPvr_SetReinPosition(sensorData[14], sensorData[15], sensorData[16], sensorData[17], sensorData[18], sensorData[19], sensorData[20], 1, valid: true, Convert.ToInt32(Convert.ToString(keyData[102]) + Convert.ToString(keyData[82]) + "00", 2));
				}
				TransformData(controllerlink.Controller1, 1, keyData);
			}
			else
			{
				Sensor.UPvr_SetReinPosition(sensorData[14], sensorData[15], sensorData[16], sensorData[17], sensorData[18], sensorData[19], sensorData[20], 1, valid: false, 0);
			}
		}
		if (controllerlink.goblinserviceStarted && controllerlink.controller0Connected)
		{
			g2SensorData = controllerlink.GetHBControllerPoseData();
			controllerlink.Controller0.Rotation.Set(g2SensorData[0], g2SensorData[1], g2SensorData[2], g2SensorData[3]);
			g2KeyData = controllerlink.GetHBControllerKeyData();
			TransformData(controllerlink.Controller0, 0, g2KeyData);
		}
		SetSystemKey();
	}

	private void OnApplicationPause(bool pause)
	{
		int headSensorState = ((!Pvr_UnitySDKManager.SDK.HmdOnlyrot) ? 1 : 0);
		int handSensorState = ((!Pvr_UnitySDKManager.SDK.ControllerOnlyrot) ? 1 : 0);
		if (pause)
		{
			if (controllerlink.neoserviceStarted)
			{
				controllerlink.SetGameObjectToJar("");
				controllerlink.StopControllerThread(headSensorState, handSensorState);
			}
			if (controllerlink.goblinserviceStarted)
			{
				controllerlink.StopReceiver();
			}
			return;
		}
		controllerlink.Controller0 = new ControllerHand();
		controllerlink.Controller1 = new ControllerHand();
		if (controllerlink.neoserviceStarted)
		{
			controllerlink.SetGameObjectToJar(base.gameObject.name);
			controllerlink.SetUnityVersionToJar("2.8.10.4");
			controllerlink.StartControllerThread(headSensorState, handSensorState);
		}
		if (controllerlink.goblinserviceStarted)
		{
			controllerlink.StartReceiver();
			controllerlink.controller0Connected = GetControllerConnectionState(0) == 1;
			controllerlink.controllerType = controllerlink.GetControllerType();
			controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
			if (Pvr_ControllerManager.PvrServiceStartSuccessEvent != null)
			{
				Pvr_ControllerManager.PvrServiceStartSuccessEvent();
			}
		}
	}

	private void OnDestroy()
	{
		controllerlink.UnBindService();
		Sensor.UPvr_SetReinPosition(0f, 0f, 0f, 1f, 0f, 0f, 0f, 0, valid: false, 0);
		Sensor.UPvr_SetReinPosition(0f, 0f, 0f, 1f, 0f, 0f, 0f, 1, valid: false, 0);
	}

	private void OnApplicationQuit()
	{
		int headSensorState = ((!Pvr_UnitySDKManager.SDK.HmdOnlyrot) ? 1 : 0);
		int handSensorState = ((!Pvr_UnitySDKManager.SDK.ControllerOnlyrot) ? 1 : 0);
		if (controllerlink.neoserviceStarted)
		{
			controllerlink.SetGameObjectToJar("");
			controllerlink.StopControllerThread(headSensorState, handSensorState);
		}
	}

	public Vector3 GetAngularVelocity(int num)
	{
		if (controllerlink != null)
		{
			return controllerlink.GetAngularVelocity(num);
		}
		return new Vector3(0f, 0f, 0f);
	}

	public Vector3 GetAcceleration(int num)
	{
		if (controllerlink != null)
		{
			return controllerlink.GetAcceleration(num);
		}
		return new Vector3(0f, 0f, 0f);
	}

	public void BindService()
	{
		if (controllerlink != null)
		{
			controllerlink.BindService();
		}
	}

	public void StartScan()
	{
		if (controllerlink != null)
		{
			controllerlink.StartScan();
		}
	}

	public void StopScan()
	{
		if (controllerlink != null)
		{
			controllerlink.StopScan();
		}
	}

	public void ResetController(int num)
	{
		if (controllerlink != null)
		{
			controllerlink.ResetController(num);
		}
	}

	public static int GetControllerConnectionState(int num)
	{
		return controllerlink.GetControllerConnectionState(num);
	}

	public void ConnectBLE()
	{
		if (controllerlink != null)
		{
			controllerlink.ConnectBLE();
		}
	}

	public void DisConnectBLE()
	{
		if (controllerlink != null)
		{
			controllerlink.DisConnectBLE();
		}
	}

	public void SetBinPath(string path, bool isAsset)
	{
		if (controllerlink != null)
		{
			controllerlink.setBinPath(path, isAsset);
		}
	}

	public void StartUpgrade()
	{
		if (controllerlink != null)
		{
			controllerlink.StartUpgrade();
		}
	}

	public static string GetBLEImageType()
	{
		return controllerlink.GetBLEImageType();
	}

	public static long GetBLEVersion()
	{
		return controllerlink.GetBLEVersion();
	}

	public static string GetFileImageType()
	{
		return controllerlink.GetFileImageType();
	}

	public static long GetFileVersion()
	{
		return controllerlink.GetFileVersion();
	}

	public static void AutoConnectHbController(int scans)
	{
		if (controllerlink != null)
		{
			controllerlink.AutoConnectHbController(scans);
		}
	}

	public static string GetConnectedDeviceMac()
	{
		string result = "";
		if (controllerlink != null)
		{
			result = controllerlink.GetConnectedDeviceMac();
		}
		return result;
	}

	public void setHbControllerMac(string mac)
	{
		PLOG.I("PvrLog HBMacRSSI" + mac);
		controllerlink.hummingBirdMac = mac.Substring(0, 17);
		controllerlink.hummingBirdRSSI = Convert.ToInt16(mac.Remove(0, 18));
		if (Pvr_ControllerManager.SetHbControllerMacEvent != null)
		{
			Pvr_ControllerManager.SetHbControllerMacEvent(mac.Substring(0, 17));
		}
	}

	public int GetControllerRSSI()
	{
		return controllerlink.hummingBirdRSSI;
	}

	public void setHbServiceBindState(string state)
	{
		PLOG.I("PvrLog HBBindCallBack" + state);
		controllerServicestate = true;
		if (Convert.ToInt16(state) == 0)
		{
			Invoke("BindService", 0.5f);
			controllerlink.goblinserviceStarted = false;
		}
		else if (Convert.ToInt16(state) == 1)
		{
			controllerlink.goblinserviceStarted = true;
			controllerlink.controller0Connected = GetControllerConnectionState(0) == 1;
			controllerlink.controllerType = controllerlink.GetControllerType();
			controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
			if (Pvr_ControllerManager.SetHbServiceBindStateEvent != null)
			{
				Pvr_ControllerManager.SetHbServiceBindStateEvent();
			}
			if (Pvr_ControllerManager.PvrServiceStartSuccessEvent != null)
			{
				Pvr_ControllerManager.PvrServiceStartSuccessEvent();
			}
		}
	}

	public void setControllerServiceBindState(string state)
	{
		PLOG.I("PvrLog CVBindCallBack" + state);
		if (Convert.ToInt16(state) == 0)
		{
			Invoke("BindService", 0.5f);
			controllerlink.neoserviceStarted = false;
		}
		else if (Convert.ToInt16(state) == 1)
		{
			controllerlink.SetUnityVersionToJar("2.8.10.4");
			controllerlink.neoserviceStarted = true;
			int headSensorState = ((!Pvr_UnitySDKManager.SDK.HmdOnlyrot) ? 1 : 0);
			int handSensorState = ((!Pvr_UnitySDKManager.SDK.ControllerOnlyrot) ? 1 : 0);
			controllerlink.StartControllerThread(headSensorState, handSensorState);
			if (Pvr_ControllerManager.SetControllerServiceBindStateEvent != null)
			{
				Pvr_ControllerManager.SetControllerServiceBindStateEvent();
			}
		}
	}

	public void setHbControllerConnectState(string isconnect)
	{
		PLOG.I("PvrLog HBControllerConnect" + isconnect);
		controllerlink.controller0Connected = Convert.ToInt16(isconnect) == 1;
		if (!controllerlink.controller0Connected)
		{
			controllerlink.Controller0 = new ControllerHand();
		}
		else
		{
			ResetController(0);
			controllerlink.controllerType = controllerlink.GetControllerType();
			controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
		}
		stopConnect = false;
		if (Pvr_ControllerManager.ControllerStatusChangeEvent != null)
		{
			Pvr_ControllerManager.ControllerStatusChangeEvent(isconnect);
		}
		if (Pvr_ControllerManager.PvrControllerStateChangedEvent != null)
		{
			Pvr_ControllerManager.PvrControllerStateChangedEvent(isconnect);
		}
	}

	public void setControllerStateChanged(string state)
	{
		PLOG.I("PvrLog CVControllerStateChanged" + state);
		int num = Convert.ToInt16(state.Substring(0, 1));
		if (num == 0)
		{
			controllerlink.controller0Connected = Convert.ToBoolean(Convert.ToInt16(state.Substring(2, 1)));
			if (!controllerlink.controller0Connected)
			{
				controllerlink.Controller0 = new ControllerHand();
				controllerlink.Controller0.Position = new Vector3(0f, Pvr_UnitySDKSensor.Instance.HeadPose.Position.y, 0f) + new Vector3(-0.1f, -0.3f, 0.3f);
			}
		}
		else
		{
			controllerlink.controller1Connected = Convert.ToBoolean(Convert.ToInt16(state.Substring(2, 1)));
			if (!controllerlink.controller1Connected)
			{
				controllerlink.Controller1 = new ControllerHand();
				controllerlink.Controller1.Position = new Vector3(0f, Pvr_UnitySDKSensor.Instance.HeadPose.Position.y, 0f) + new Vector3(0.1f, -0.3f, 0.3f);
			}
		}
		if (Convert.ToBoolean(Convert.ToInt16(state.Substring(2, 1))))
		{
			controllerlink.controllerType = controllerlink.GetControllerType();
			controllerlink.ResetController(num);
		}
		controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
		controllerlink.mainHandID = controllerlink.GetMainControllerIndex();
		if (Pvr_ControllerManager.SetControllerStateChangedEvent != null)
		{
			Pvr_ControllerManager.SetControllerStateChangedEvent(state);
		}
		if (Pvr_ControllerManager.PvrControllerStateChangedEvent != null)
		{
			Pvr_ControllerManager.PvrControllerStateChangedEvent(state);
		}
	}

	public void setControllerAbility(string data)
	{
		PLOG.I("PvrLog setControllerAbility" + data);
		if (Pvr_ControllerManager.SetControllerAbilityEvent != null)
		{
			Pvr_ControllerManager.SetControllerAbilityEvent(data);
		}
	}

	public void controllerThreadStartedCallback()
	{
		PLOG.I("PvrLog ThreadStartSuccess");
		GetCVControllerState();
		if (Pvr_ControllerManager.ControllerThreadStartedCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerThreadStartedCallbackEvent();
		}
		if (Pvr_ControllerManager.PvrServiceStartSuccessEvent != null)
		{
			Pvr_ControllerManager.PvrServiceStartSuccessEvent();
		}
	}

	public void controllerDeviceVersionCallback(string data)
	{
		PLOG.I("PvrLog VersionCallBack" + data);
		if (Pvr_ControllerManager.ControllerDeviceVersionCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerDeviceVersionCallbackEvent(data);
		}
	}

	public void controllerSnCodeCallback(string data)
	{
		PLOG.I("PvrLog SNCodeCallBack" + data);
		if (Pvr_ControllerManager.ControllerSnCodeCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerSnCodeCallbackEvent(data);
		}
	}

	public void controllerUnbindCallback(string status)
	{
		PLOG.I("PvrLog ControllerUnBindCallBack" + status);
		if (Pvr_ControllerManager.ControllerUnbindCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerUnbindCallbackEvent(status);
		}
	}

	public void controllerStationStatusCallback(string status)
	{
		PLOG.I("PvrLog StationStatusCallBack" + status);
		if (Pvr_ControllerManager.ControllerStationStatusCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerStationStatusCallbackEvent(status);
		}
	}

	public void controllerStationBusyCallback(string status)
	{
		PLOG.I("PvrLog StationBusyCallBack" + status);
		if (Pvr_ControllerManager.ControllerStationBusyCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerStationBusyCallbackEvent(status);
		}
	}

	public void controllerOTAStartCodeCallback(string data)
	{
		PLOG.I("PvrLog OTAUpdateCallBack" + data);
		if (Pvr_ControllerManager.ControllerOtaStartCodeCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerOtaStartCodeCallbackEvent(data);
		}
	}

	public void controllerDeviceVersionAndSNCallback(string data)
	{
		PLOG.I("PvrLog DeviceVersionAndSNCallback" + data);
		if (Pvr_ControllerManager.ControllerDeviceVersionAndSNCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerDeviceVersionAndSNCallbackEvent(data);
		}
	}

	public void controllerUniqueIDCallback(string data)
	{
		PLOG.I("PvrLog controllerUniqueIDCallback" + data);
		if (Pvr_ControllerManager.ControllerUniqueIDCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerUniqueIDCallbackEvent(data);
		}
	}

	public void controllerCombinedKeyUnbindCallback(string controllerSerialNum)
	{
		if (Pvr_ControllerManager.ControllerCombinedKeyUnbindCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerCombinedKeyUnbindCallbackEvent(controllerSerialNum);
		}
	}

	public void setupdateFailed()
	{
	}

	public void setupdateSuccess()
	{
	}

	public void setupdateProgress(string progress)
	{
	}

	public void setHbAutoConnectState(string state)
	{
		PLOG.I("PvrLog HBAutoConnectState" + state);
		controllerServicestate = true;
		if (Convert.ToInt16(state) == 0 && GetControllerConnectionState(0) == 0)
		{
			ShowToast(2);
		}
		if (Convert.ToInt16(state) == 2)
		{
			ShowToast(3);
		}
	}

	public void callbackControllerServiceState(string state)
	{
		PLOG.I("PvrLog HBServiceState" + state);
		controllerServicestate = true;
		if (Convert.ToInt16(state) == 0)
		{
			ShowToast(0);
		}
		if (Convert.ToInt16(state) == 1)
		{
			BindService();
		}
		if (Convert.ToInt16(state) == 2)
		{
			ShowToast(1);
		}
	}

	public void changeMainControllerCallback(string index)
	{
		PLOG.I("PvrLog MainControllerCallBack" + index);
		controllerlink.mainHandID = Convert.ToInt16(index);
		if (Pvr_ControllerManager.ChangeMainControllerCallBackEvent != null)
		{
			Pvr_ControllerManager.ChangeMainControllerCallBackEvent(index);
		}
	}

	public void changeHandnessCallback(string index)
	{
		PLOG.I("PvrLog changeHandnessCallback" + index);
		controllerlink.handness = (Pvr_Controller.UserHandNess)Convert.ToInt16(index);
		if (Pvr_ControllerManager.ChangeHandNessCallBackEvent != null)
		{
			Pvr_ControllerManager.ChangeHandNessCallBackEvent(index);
		}
	}

	private void ShowToast(int type)
	{
		if (toast != null)
		{
			switch (type)
			{
			case 0:
				toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip0");
				Invoke("HideToast", 5f);
				break;
			case 1:
				toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip1");
				Invoke("HideToast", 5f);
				break;
			case 2:
				toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip2");
				AutoConnectHbController(6000);
				Invoke("HideToast", 5f);
				break;
			case 3:
				toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip3");
				AutoConnectHbController(6000);
				Invoke("HideToast", 5f);
				break;
			case 4:
				toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip4");
				Invoke("HideToast", 10f);
				break;
			}
		}
	}

	private void HideToast()
	{
		if (toast != null)
		{
			toast.text = "";
		}
	}

	private void CheckControllerService()
	{
		if (!controllerServicestate)
		{
			ShowToast(4);
		}
	}

	private void GetCVControllerState()
	{
		int controllerConnectionState = GetControllerConnectionState(0);
		int controllerConnectionState2 = GetControllerConnectionState(1);
		PLOG.I("PvrLog CVconnect" + controllerConnectionState + controllerConnectionState2);
		if (controllerConnectionState == -1 && controllerConnectionState2 == -1)
		{
			Invoke("GetCVControllerState", 0.02f);
		}
		if (controllerConnectionState != -1 && controllerConnectionState2 != -1)
		{
			controllerlink.controller0Connected = controllerConnectionState == 1;
			controllerlink.controller1Connected = controllerConnectionState2 == 1;
			if (!controllerlink.controller0Connected && controllerlink.controller1Connected && controllerlink.GetMainControllerIndex() == 0)
			{
				Pvr_UnitySDKAPI.Controller.UPvr_SetMainHandNess(1);
			}
			if (controllerlink.controller0Connected || controllerlink.controller1Connected)
			{
				controllerlink.controllerType = controllerlink.GetControllerType();
			}
			controllerlink.mainHandID = controllerlink.GetMainControllerIndex();
			controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
		}
	}

	private void SetSystemKey()
	{
		if (controllerlink.switchHomeKey && (Pvr_UnitySDKAPI.Controller.UPvr_GetKeyLongPressed(0, Pvr_KeyCode.HOME) || Pvr_UnitySDKAPI.Controller.UPvr_GetKeyLongPressed(1, Pvr_KeyCode.HOME)))
		{
			if (Pvr_UnitySDKManager.SDK.HmdOnlyrot)
			{
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 0);
			}
			else if (controllerlink.trackingmode == 0 || controllerlink.trackingmode == 1)
			{
				Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
			}
			else
			{
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
			}
			if (Pvr_UnitySDKManager.SDK.ControllerOnlyrot || (controllerlink.controller0Connected && Pvr_UnitySDKAPI.Controller.UPvr_GetControllerPOS(0).Equals(Vector3.zero)) || (controllerlink.controller1Connected && Pvr_UnitySDKAPI.Controller.UPvr_GetControllerPOS(1).Equals(Vector3.zero)))
			{
				if (Pvr_UnitySDKAPI.Controller.UPvr_GetKeyLongPressed(0, Pvr_KeyCode.HOME))
				{
					ResetController(0);
				}
				if (Pvr_UnitySDKAPI.Controller.UPvr_GetKeyLongPressed(1, Pvr_KeyCode.HOME))
				{
					ResetController(1);
				}
			}
		}
		if (controllerlink.picoDevice)
		{
			if (controllerlink.switchHomeKey && (Pvr_UnitySDKAPI.Controller.UPvr_GetKeyClick(0, Pvr_KeyCode.HOME) || (Pvr_UnitySDKAPI.Controller.UPvr_GetKeyClick(1, Pvr_KeyCode.HOME) && !stopConnect)))
			{
				controllerlink.RebackToLauncher();
			}
			if (Pvr_UnitySDKAPI.Controller.UPvr_GetKeyClick(0, Pvr_KeyCode.VOLUMEUP) || Pvr_UnitySDKAPI.Controller.UPvr_GetKeyClick(1, Pvr_KeyCode.VOLUMEUP))
			{
				controllerlink.TurnUpVolume();
			}
			if (Pvr_UnitySDKAPI.Controller.UPvr_GetKeyClick(0, Pvr_KeyCode.VOLUMEDOWN) || Pvr_UnitySDKAPI.Controller.UPvr_GetKeyClick(1, Pvr_KeyCode.VOLUMEDOWN))
			{
				controllerlink.TurnDownVolume();
			}
			if (!Pvr_UnitySDKAPI.Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEUP) && !Pvr_UnitySDKAPI.Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEDOWN) && !Pvr_UnitySDKAPI.Controller.UPvr_GetKey(1, Pvr_KeyCode.VOLUMEUP) && !Pvr_UnitySDKAPI.Controller.UPvr_GetKey(1, Pvr_KeyCode.VOLUMEDOWN))
			{
				cTime = 1f;
			}
			if (Pvr_UnitySDKAPI.Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEUP) || Pvr_UnitySDKAPI.Controller.UPvr_GetKey(1, Pvr_KeyCode.VOLUMEUP))
			{
				cTime -= Time.deltaTime;
				if (cTime <= 0f)
				{
					cTime = 0.2f;
					controllerlink.TurnUpVolume();
				}
			}
			if (!Pvr_UnitySDKAPI.Controller.UPvr_GetKey(0, Pvr_KeyCode.HOME) && !Pvr_UnitySDKAPI.Controller.UPvr_GetKey(1, Pvr_KeyCode.HOME) && (Pvr_UnitySDKAPI.Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEDOWN) || Pvr_UnitySDKAPI.Controller.UPvr_GetKey(1, Pvr_KeyCode.VOLUMEDOWN)))
			{
				cTime -= Time.deltaTime;
				if (cTime <= 0f)
				{
					cTime = 0.2f;
					controllerlink.TurnDownVolume();
				}
			}
		}
		if (controllerlink.goblinserviceStarted && Pvr_UnitySDKAPI.Controller.UPvr_GetKey(0, Pvr_KeyCode.HOME) && Pvr_UnitySDKAPI.Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEDOWN) && !stopConnect)
		{
			disConnectTime += Time.deltaTime;
			if ((double)disConnectTime > 1.0)
			{
				DisConnectBLE();
				controllerlink.hummingBirdMac = "";
				stopConnect = true;
				disConnectTime = 0f;
			}
		}
	}

	private void TransformData(ControllerHand hand, int handId, int[] data)
	{
		keyOffset = ((handId == 1) ? 67 : 0);
		hand.TouchPadPosition.x = data[keyOffset];
		hand.TouchPadPosition.y = data[5 + keyOffset];
		TransSingleKey(hand.Home, 10 + keyOffset, data);
		TransSingleKey(hand.App, 15 + keyOffset, data);
		TransSingleKey(hand.Touch, 20 + keyOffset, data);
		TransSingleKey(hand.VolumeUp, 25 + keyOffset, data);
		TransSingleKey(hand.VolumeDown, 30 + keyOffset, data);
		TransSingleKey(hand.Trigger, 35 + keyOffset, data);
		if (controllerlink.goblinserviceStarted && !controllerlink.neoserviceStarted)
		{
			hand.TriggerNum = controllerlink.GetHBKeyValue();
		}
		if (!controllerlink.goblinserviceStarted && controllerlink.neoserviceStarted)
		{
			hand.TriggerNum = controllerlink.GetCVTriggerValue(handId);
		}
		hand.Battery = data[40 + keyOffset];
		if (data.Length == 47)
		{
			hand.SwipeDirection = (SwipeDirection)data[45];
			hand.TouchPadClick = (TouchPadClick)data[46];
		}
		else
		{
			switch (handId)
			{
			case 0:
				TransSingleKey(hand.X, 45 + keyOffset, data);
				TransSingleKey(hand.Y, 50 + keyOffset, data);
				TransSingleKey(hand.Left, 60 + keyOffset, data);
				break;
			case 1:
				TransSingleKey(hand.A, 45 + keyOffset, data);
				TransSingleKey(hand.B, 50 + keyOffset, data);
				TransSingleKey(hand.Right, 55 + keyOffset, data);
				break;
			}
			hand.SwipeDirection = (SwipeDirection)data[65 + keyOffset];
			hand.TouchPadClick = (TouchPadClick)data[66 + keyOffset];
		}
		hand.GripValue = controllerlink.GetNeo3GripValue(handId);
		TransformTouchData(hand, handId, controllerlink.GetNeo3TouchData(handId));
	}

	private void TransSingleKey(PvrControllerKey key, int beginIndex, int[] data)
	{
		key.State = Convert.ToBoolean(data[beginIndex]);
		key.PressedDown = Convert.ToBoolean(data[beginIndex + 1]);
		key.PressedUp = Convert.ToBoolean(data[beginIndex + 2]);
		key.LongPressed = Convert.ToBoolean(data[beginIndex + 3]);
		key.Click = Convert.ToBoolean(data[beginIndex + 4]);
	}

	private void TransformTouchData(ControllerHand hand, int handId, int[] data)
	{
		switch (handId)
		{
		case 0:
			TransSingleTouchValue(hand.X, 0, data);
			TransSingleTouchValue(hand.Y, 3, data);
			break;
		case 1:
			TransSingleTouchValue(hand.A, 0, data);
			TransSingleTouchValue(hand.B, 3, data);
			break;
		}
		TransSingleTouchValue(hand.Touch, 6, data);
		TransSingleTouchValue(hand.Trigger, 9, data);
		TransSingleTouchValue(hand.Thumbrest, 12, data);
	}

	private void TransSingleTouchValue(PvrControllerKey key, int beginIndex, int[] data)
	{
		key.Touch = Convert.ToBoolean(data[beginIndex]);
		key.TouchDown = Convert.ToBoolean(data[beginIndex + 1]);
		key.TouchUp = Convert.ToBoolean(data[beginIndex + 2]);
	}
}
public class Pvr_ControllerModuleInit : MonoBehaviour
{
	public ControllerVariety Variety;

	public bool IsCustomModel;

	[SerializeField]
	private GameObject dot;

	[SerializeField]
	private GameObject rayLine;

	[SerializeField]
	private GameObject controller;

	private bool moduleState = true;

	private void Awake()
	{
		Pvr_ControllerManager.PvrServiceStartSuccessEvent += ServiceStartSuccess;
		Pvr_ControllerManager.PvrControllerStateChangedEvent += ControllerStateChanged;
		Pvr_ControllerManager.ChangeMainControllerCallBackEvent += MainControllerIDChanged;
		if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
		{
			rayLine = base.transform.GetComponentInChildren<LineRenderer>(includeInactive: true).gameObject;
			rayLine.GetComponent<LineRenderer>().startWidth = 0.003f;
			rayLine.GetComponent<LineRenderer>().endWidth = 0.0015f;
		}
	}

	private void OnDestroy()
	{
		Pvr_ControllerManager.PvrServiceStartSuccessEvent -= ServiceStartSuccess;
		Pvr_ControllerManager.PvrControllerStateChangedEvent -= ControllerStateChanged;
		Pvr_ControllerManager.ChangeMainControllerCallBackEvent -= MainControllerIDChanged;
	}

	private void ServiceStartSuccess()
	{
	}

	private void ControllerStateChanged(string data)
	{
		if (Pvr_ControllerManager.controllerlink.controller0Connected || Pvr_ControllerManager.controllerlink.controller1Connected)
		{
			moduleState = true;
			controller.transform.localScale = Vector3.one;
		}
	}

	private void MainControllerIDChanged(string data)
	{
	}

	private void RefreshRay()
	{
	}

	private IEnumerator ShowOrHideRay(int id)
	{
		yield return null;
		yield return null;
		if (moduleState)
		{
			bool active = Pvr_UnitySDKAPI.Controller.UPvr_GetMainHandNess() == id && Pvr_UnitySDKAPI.Controller.UPvr_GetControllerState(id) == ControllerState.Connected;
			dot.SetActive(active);
			rayLine.SetActive(active);
		}
	}

	public void ForceHideOrShow(bool state)
	{
		dot.SetActive(state);
		rayLine.SetActive(state);
		controller.transform.localScale = (state ? Vector3.one : Vector3.zero);
		moduleState = state;
	}

	public void UpdateRay()
	{
		if (!Pvr_ControllerManager.Instance.LengthAdaptiveRay)
		{
			return;
		}
		bool flag = false;
		flag = ((Pvr_ControllerManager.controllerlink.controller0Connected || Pvr_ControllerManager.controllerlink.controller1Connected) ? true : false);
		if (flag && rayLine != null && rayLine.gameObject.activeSelf)
		{
			if (Pvr_UnitySDKAPI.Controller.UPvr_GetDeviceType() == 1)
			{
				rayLine.GetComponent<LineRenderer>().SetPosition(0, base.transform.TransformPoint(0f, 0f, 0.058f));
			}
			else
			{
				rayLine.GetComponent<LineRenderer>().SetPosition(0, base.transform.TransformPoint(0f, 0.009f, 0.055f));
			}
			rayLine.GetComponent<LineRenderer>().SetPosition(1, dot.transform.position);
		}
	}
}
public class Pvr_ControllerPower : MonoBehaviour
{
	[SerializeField]
	private Sprite power1;

	[SerializeField]
	private Sprite power2;

	[SerializeField]
	private Sprite power3;

	[SerializeField]
	private Sprite power4;

	[SerializeField]
	private Sprite power5;

	[HideInInspector]
	public ControllerVariety variety;

	[HideInInspector]
	public ControllerDevice currentDevice;

	private Image powerImage;

	private int powerValue;

	private float power;

	private void Start()
	{
		powerImage = base.transform.GetComponent<Image>();
		powerValue = -1;
		variety = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().Variety;
		currentDevice = base.transform.GetComponentInParent<Pvr_ControllerVisual>().currentDevice;
	}

	private void Update()
	{
		RefreshPower((variety != 0) ? 1 : 0);
	}

	private void RefreshPower(int hand)
	{
		if (powerValue != Pvr_UnitySDKAPI.Controller.UPvr_GetControllerPower(hand))
		{
			switch (Pvr_UnitySDKAPI.Controller.UPvr_GetControllerPower(hand))
			{
			case 1:
				powerImage.sprite = power1;
				powerImage.color = Color.red;
				break;
			case 2:
				powerImage.sprite = power2;
				powerImage.color = Color.white;
				break;
			case 3:
				powerImage.sprite = power3;
				powerImage.color = Color.white;
				break;
			case 4:
				powerImage.sprite = power4;
				powerImage.color = Color.white;
				break;
			case 5:
				powerImage.sprite = power5;
				powerImage.color = Color.white;
				break;
			default:
				powerImage.sprite = power1;
				powerImage.color = Color.white;
				break;
			}
			powerValue = Pvr_UnitySDKAPI.Controller.UPvr_GetControllerPower(hand);
		}
	}
}
public class Pvr_ControllerVisual : MonoBehaviour
{
	public ControllerDevice currentDevice;

	public Texture2D m_idle;

	public Texture2D m_app;

	public Texture2D m_home;

	public Texture2D m_touchpad;

	public Texture2D m_volUp;

	public Texture2D m_volDn;

	public Texture2D m_trigger;

	public Texture2D m_a;

	public Texture2D m_b;

	public Texture2D m_x;

	public Texture2D m_y;

	public Texture2D m_grip;

	private Renderer controllerRenderMat;

	[HideInInspector]
	public ControllerVariety variety;

	private void Awake()
	{
		controllerRenderMat = GetComponent<Renderer>();
	}

	private void Start()
	{
		variety = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().Variety;
	}

	private void Update()
	{
		ChangeKeyEffects((variety != 0) ? 1 : 0);
	}

	private void ChangeKeyEffects(int hand)
	{
		if (Pvr_UnitySDKAPI.Controller.UPvr_GetKey(hand, Pvr_KeyCode.TOUCHPAD))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_touchpad);
		}
		else if (Pvr_UnitySDKAPI.Controller.UPvr_GetKey(hand, Pvr_KeyCode.APP))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_app);
		}
		else if (Pvr_UnitySDKAPI.Controller.UPvr_GetKey(hand, Pvr_KeyCode.HOME))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_home);
		}
		else if (Pvr_UnitySDKAPI.Controller.UPvr_GetKey(hand, Pvr_KeyCode.VOLUMEUP))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_volUp);
		}
		else if (Pvr_UnitySDKAPI.Controller.UPvr_GetKey(hand, Pvr_KeyCode.VOLUMEDOWN))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_volDn);
		}
		else if (Pvr_UnitySDKAPI.Controller.UPvr_GetControllerTriggerValue(hand) > 0 || Pvr_UnitySDKAPI.Controller.UPvr_GetKey(hand, Pvr_KeyCode.TRIGGER))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_trigger);
		}
		else if (Pvr_UnitySDKAPI.Controller.UPvr_GetKey(hand, Pvr_KeyCode.X))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_x);
		}
		else if (Pvr_UnitySDKAPI.Controller.UPvr_GetKey(hand, Pvr_KeyCode.Y))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_y);
		}
		else if (Pvr_UnitySDKAPI.Controller.UPvr_GetKey(hand, Pvr_KeyCode.A))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_a);
		}
		else if (Pvr_UnitySDKAPI.Controller.UPvr_GetKey(hand, Pvr_KeyCode.B))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_b);
		}
		else if (Pvr_UnitySDKAPI.Controller.UPvr_GetKey(hand, Pvr_KeyCode.Left) || Pvr_UnitySDKAPI.Controller.UPvr_GetKey(hand, Pvr_KeyCode.Right))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_grip);
		}
		else if (controllerRenderMat.material.GetTexture("_MainTex") != m_idle)
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_idle);
		}
	}
}
public class Pvr_ToolTips : MonoBehaviour
{
	public enum TipBtn
	{
		app,
		touchpad,
		home,
		volup,
		voldown,
		trigger,
		grip
	}

	private ControllerDevice currentDevice;

	private float tipsAlpha;

	public static Pvr_ToolTips tooltips;

	public void ChangeTipsText(TipBtn tip, string key)
	{
		switch (tip)
		{
		case TipBtn.app:
			base.transform.Find("apptip/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.touchpad:
			base.transform.Find("touchtip/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.home:
			base.transform.Find("hometip/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.volup:
			base.transform.Find("volup/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.voldown:
			base.transform.Find("voldown/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.trigger:
			base.transform.Find("triggertip/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.grip:
			base.transform.Find("grip/btn/Text").GetComponent<Text>().text = key;
			break;
		}
	}

	private void Awake()
	{
		tooltips = base.transform.GetComponent<Pvr_ToolTips>();
	}

	private void Update()
	{
		switch (currentDevice)
		{
		case ControllerDevice.Goblin:
		case ControllerDevice.G2:
			tipsAlpha = (330f - base.transform.parent.parent.parent.localRotation.eulerAngles.x) / 45f;
			if (base.transform.parent.parent.parent.localRotation.eulerAngles.x >= 270f && base.transform.parent.parent.parent.localRotation.eulerAngles.x <= 330f)
			{
				tipsAlpha = Mathf.Max(0f, tipsAlpha);
				tipsAlpha = ((tipsAlpha > 1f) ? 1f : tipsAlpha);
			}
			else
			{
				tipsAlpha = 0f;
			}
			GetComponent<CanvasGroup>().alpha = tipsAlpha;
			break;
		case ControllerDevice.Neo2:
		case ControllerDevice.Neo3:
			tipsAlpha = (330f - base.transform.parent.parent.parent.localRotation.eulerAngles.x) / 45f;
			if (base.transform.parent.parent.parent.localRotation.eulerAngles.x >= 270f && base.transform.parent.parent.parent.localRotation.eulerAngles.x <= 330f)
			{
				tipsAlpha = Mathf.Max(0f, tipsAlpha);
				tipsAlpha = ((tipsAlpha > 1f) ? 1f : tipsAlpha);
			}
			else
			{
				tipsAlpha = 0f;
			}
			GetComponent<CanvasGroup>().alpha = tipsAlpha;
			break;
		case ControllerDevice.Neo:
			break;
		}
	}

	private void LoadTextFromJson()
	{
		currentDevice = base.transform.GetComponentInParent<Pvr_ControllerVisual>().currentDevice;
		base.transform.Find("apptip/btn/Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("apptip");
		base.transform.Find("touchtip/btn/Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("touchtip");
		base.transform.Find("hometip/btn/Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("hometip");
		Transform transform = base.transform.Find("volup/btn/Text");
		if (transform != null)
		{
			transform.GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("voluptip");
		}
		Transform transform2 = base.transform.Find("voldown/btn/Text");
		if (transform2 != null)
		{
			transform2.GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("voldowntip");
		}
		Transform transform3 = base.transform.Find("triggertip/btn/Text");
		if (transform3 != null)
		{
			transform3.GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("triggertip");
		}
		Transform transform4 = base.transform.Find("grip/btn/Text");
		if (transform4 != null)
		{
			transform4.GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("griptip");
		}
	}

	public static void RefreshTips()
	{
		if (tooltips != null)
		{
			tooltips.LoadTextFromJson();
		}
	}
}
public class Pvr_TouchPadScroll : MonoBehaviour
{
	private ScrollRect scrollRect;

	private bool isHoving;

	private int mainHand;

	private SwipeDirection direction;

	private Vector2 currPos;

	private Vector2 tarPos;

	private float lerpSpeed = 10f;

	private Transform tranViewport;

	private float ignoreDis = 3f;

	private Vector2 lastTouchDownPos;

	private Vector2 lastTouchUpPos;

	private bool isTouching;

	private bool isClosed = true;

	private Vector2 vecOrigin = Vector2.zero;

	private Vector2 vecOriginNeo2 = new Vector2(128f, 128f);

	private void Awake()
	{
		scrollRect = base.gameObject.GetComponent<ScrollRect>();
		tranViewport = base.transform.Find("Viewport");
	}

	private void Update()
	{
		Process();
		UpdateTargetPos();
		UpdatePos();
	}

	private bool IsControllerConnect()
	{
		mainHand = Pvr_UnitySDKAPI.Controller.UPvr_GetMainHandNess();
		if (mainHand == 0 && Pvr_ControllerManager.controllerlink.controller0Connected)
		{
			return true;
		}
		if (mainHand == 1 && Pvr_ControllerManager.controllerlink.controller1Connected)
		{
			return true;
		}
		return false;
	}

	private void UpdateTargetPos()
	{
		if (Pvr_UnitySDKAPI.Controller.UPvr_GetKey(0, Pvr_KeyCode.TOUCHPAD) || Pvr_UnitySDKAPI.Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TOUCHPAD))
		{
			ResetParameter();
		}
		else if (isHoving)
		{
			if (Pvr_ControllerManager.controllerlink.GetControllerType() == 3)
			{
				ComputeTouchPos();
			}
			else
			{
				ComputeRockerPos();
			}
			if ((currPos - tarPos).sqrMagnitude <= 10f)
			{
				isClosed = true;
			}
		}
	}

	private void ComputeTouchPos()
	{
		mainHand = Pvr_UnitySDKAPI.Controller.UPvr_GetMainHandNess();
		currPos = scrollRect.content.localPosition;
		Vector2 vector = vecOrigin;
		if (mainHand == 0 && Pvr_ControllerManager.controllerlink.controller0Connected)
		{
			vector = Pvr_UnitySDKAPI.Controller.UPvr_GetTouchPadPosition(mainHand);
		}
		if (mainHand == 1 && Pvr_ControllerManager.controllerlink.controller1Connected)
		{
			vector = Pvr_UnitySDKAPI.Controller.UPvr_GetTouchPadPosition(mainHand);
		}
		if ((vector - vecOrigin).sqrMagnitude >= 1f)
		{
			if (!isTouching)
			{
				lastTouchDownPos = vector;
				isTouching = true;
			}
			lastTouchUpPos.x = vector.x;
			if (Mathf.Abs(lastTouchUpPos.x - lastTouchDownPos.x) > ignoreDis)
			{
				Vector2 vector2 = new Vector2((lastTouchUpPos.x - lastTouchDownPos.x) * 10f, 0f);
				lastTouchDownPos.x = lastTouchUpPos.x;
				if (isClosed)
				{
					tarPos = currPos + vector2;
					isClosed = false;
				}
				else
				{
					tarPos += vector2;
				}
			}
		}
		else
		{
			lastTouchDownPos = vecOrigin;
			lastTouchUpPos = vecOrigin;
			isTouching = false;
			if ((double)scrollRect.horizontalScrollbar.value >= 0.999 || (double)scrollRect.horizontalScrollbar.value <= 0.0001)
			{
				isClosed = true;
			}
		}
	}

	private void ComputeRockerPos()
	{
		mainHand = Pvr_UnitySDKAPI.Controller.UPvr_GetMainHandNess();
		currPos = scrollRect.content.localPosition;
		Vector2 vector = vecOriginNeo2;
		if (mainHand == 0 && Pvr_ControllerManager.controllerlink.controller0Connected)
		{
			vector = Pvr_UnitySDKAPI.Controller.UPvr_GetTouchPadPosition(mainHand);
		}
		if (mainHand == 1 && Pvr_ControllerManager.controllerlink.controller1Connected)
		{
			vector = Pvr_UnitySDKAPI.Controller.UPvr_GetTouchPadPosition(mainHand);
		}
		if (VerifyNeo2TouchValid(vector) && (vector - vecOriginNeo2).sqrMagnitude >= 1f)
		{
			if (!isTouching)
			{
				lastTouchDownPos = vector;
				isTouching = true;
			}
			lastTouchUpPos.x = vector.x;
			if (Mathf.Abs(lastTouchUpPos.x - lastTouchDownPos.x) > ignoreDis)
			{
				Vector2 vector2 = new Vector2((lastTouchUpPos.x - lastTouchDownPos.x) * 10f, 0f);
				lastTouchDownPos.x = lastTouchUpPos.x;
				if (isClosed)
				{
					tarPos = currPos + vector2;
					isClosed = false;
				}
				else
				{
					tarPos += vector2;
				}
			}
		}
		else
		{
			lastTouchDownPos = vecOriginNeo2;
			lastTouchUpPos = vecOriginNeo2;
			isTouching = false;
			if ((double)scrollRect.horizontalScrollbar.value >= 0.999 || (double)scrollRect.horizontalScrollbar.value <= 0.0001)
			{
				isClosed = true;
			}
		}
	}

	private bool VerifyNeo2TouchValid(Vector2 nowTouchPos)
	{
		if (nowTouchPos.x > vecOriginNeo2.x && nowTouchPos.x > lastTouchDownPos.x)
		{
			return true;
		}
		if (nowTouchPos.x < vecOriginNeo2.x && nowTouchPos.x < lastTouchDownPos.x)
		{
			return true;
		}
		return false;
	}

	private void UpdatePos()
	{
		if (Pvr_UnitySDKAPI.Controller.UPvr_GetKey(0, Pvr_KeyCode.TOUCHPAD) || Pvr_UnitySDKAPI.Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TOUCHPAD))
		{
			ResetParameter();
		}
		else if (!isClosed && IsControllerConnect())
		{
			if ((double)scrollRect.horizontalScrollbar.value >= 0.9999 && tarPos.x <= currPos.x)
			{
				isClosed = true;
				return;
			}
			if ((double)scrollRect.horizontalScrollbar.value <= 0.0001 && tarPos.x >= currPos.x)
			{
				isClosed = true;
				return;
			}
			currPos.x = Mathf.Lerp(currPos.x, tarPos.x, lerpSpeed * Time.deltaTime);
			currPos.y = Mathf.Lerp(currPos.y, tarPos.y, lerpSpeed * Time.deltaTime);
			scrollRect.content.localPosition = currPos;
		}
	}

	private void ResetParameter()
	{
		currPos = scrollRect.content.localPosition;
		tarPos = scrollRect.content.localPosition;
		isClosed = true;
	}

	private void Process()
	{
		for (int i = 0; i < Pvr_InputModule.pointers.Count; i++)
		{
			Pvr_UIPointer pvr_UIPointer = Pvr_InputModule.pointers[i];
			if (pvr_UIPointer.gameObject.activeInHierarchy && pvr_UIPointer.enabled)
			{
				isHoving = IsHovering(pvr_UIPointer);
			}
		}
	}

	private bool IsHovering(Pvr_UIPointer pointer)
	{
		if (!IsControllerConnect())
		{
			return false;
		}
		foreach (GameObject item in pointer.pointerEventData.hovered)
		{
			if (FindTree(item.transform))
			{
				mainHand = Pvr_UnitySDKAPI.Controller.UPvr_GetMainHandNess();
				if (mainHand == 0 && Pvr_ControllerManager.controllerlink.controller0Connected)
				{
					return true;
				}
				if (mainHand == 1 && Pvr_ControllerManager.controllerlink.controller1Connected)
				{
					return true;
				}
			}
		}
		return false;
	}

	private bool FindTree(Transform tran)
	{
		if (tran == base.transform || tran == tranViewport)
		{
			return true;
		}
		if (tran.IsChildOf(tranViewport))
		{
			return true;
		}
		return false;
	}
}
public class Pvr_TouchVisual : MonoBehaviour
{
	[HideInInspector]
	public ControllerDevice currentDevice;

	[HideInInspector]
	public ControllerVariety variety;

	private MeshRenderer touchRenderer;

	private void Start()
	{
		variety = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().Variety;
		currentDevice = GetComponentInParent<Pvr_ControllerVisual>().currentDevice;
		touchRenderer = GetComponent<MeshRenderer>();
	}

	private void Update()
	{
		ChangeEffects((variety != 0) ? 1 : 0);
	}

	private void ChangeEffects(int hand)
	{
		ControllerDevice controllerDevice = currentDevice;
		if (controllerDevice == ControllerDevice.G2)
		{
			if (Pvr_UnitySDKAPI.Controller.UPvr_IsTouching(0))
			{
				touchRenderer.enabled = true;
				base.transform.localPosition = new Vector3(1.3f - Pvr_UnitySDKAPI.Controller.UPvr_GetTouchPadPosition(hand).x * 0.01f, 1.6f, -1.7f - Pvr_UnitySDKAPI.Controller.UPvr_GetTouchPadPosition(hand).y * 0.01f);
			}
			else
			{
				touchRenderer.enabled = false;
			}
		}
	}
}
public class DemoController : MonoBehaviour
{
	public delegate void showLoadingEventHandler();

	private Callback callback;

	private GameObject msg;

	private Pvr_UnitySDKManager picoVrManager;

	private string currentOrderID;

	public GameObject loading;

	public GameObject BG;

	public GameObject InputPanel;

	public static showLoadingEventHandler showLoading;

	private void Awake()
	{
		UnityEngine.Debug.Log(loading.name);
		UnityEngine.Debug.Log(BG.name);
		showLoading = (showLoadingEventHandler)Delegate.Combine(showLoading, new showLoadingEventHandler(StopLoading));
		InputManager.doEnter = (InputManager.doEnterEventHandler)Delegate.Combine(InputManager.doEnter, new InputManager.doEnterEventHandler(DoPayByCode));
		currentOrderID = "";
	}

	private void Start()
	{
		msg = GameObject.Find("MassageInfo");
		InitDelegate();
		callback = new Callback();
		picoVrManager = GameObject.Find("Pvr_UnitySDK").GetComponent<Pvr_UnitySDKManager>();
		InputPanel.SetActive(value: false);
	}

	private void Update()
	{
		if (picoVrManager != null && (Input.GetKeyDown(KeyCode.Y) || Input.GetKeyDown(KeyCode.Joystick1Button2)))
		{
			UnityEngine.Debug.Log("update");
			Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
		}
		if (Input.GetKeyDown(KeyCode.Joystick1Button1) || Input.GetKeyDown(KeyCode.Escape))
		{
			if (InputPanel.activeInHierarchy)
			{
				InputPanel.SetActive(value: false);
			}
			else
			{
				UnityEngine.Application.Quit();
			}
		}
	}

	private void InitDelegate()
	{
		foreach (string item in new ArrayList { "Login", "GetUserAPI", "PayOne", "PayCode", "QueryOrder" })
		{
			GameObject btnObj = GameObject.Find(item);
			btnObj.GetComponent<Button>().onClick.AddListener(delegate
			{
				OnClick(btnObj);
			});
		}
	}

	private void OnClick(GameObject btnObj)
	{
		switch (btnObj.name)
		{
		case "Login":
			StartLoading();
			LoginSDK.Login();
			break;
		case "PayOne":
			CommonDic.getInstance().setParameters("subject", "game");
			CommonDic.getInstance().setParameters("body", "gamePay");
			CommonDic.getInstance().setParameters("order_id", getRamdomTestOrderID());
			CommonDic.getInstance().setParameters("total", "1");
			CommonDic.getInstance().setParameters("goods_tag", "game");
			CommonDic.getInstance().setParameters("notify_url", "www.picovr.com");
			CommonDic.getInstance().setParameters("pay_code", "");
			StartLoading();
			PicoPaymentSDK.Pay(CommonDic.getInstance().PayOrderString());
			break;
		case "PayCode":
			InputPanel.SetActive(value: true);
			break;
		case "QueryOrder":
			StartLoading();
			PicoPaymentSDK.QueryOrder(currentOrderID);
			break;
		case "GetUserAPI":
			StartLoading();
			LoginSDK.GetUserAPI();
			break;
		}
	}

	public string getRamdomTestOrderID()
	{
		currentOrderID = (UnityEngine.Random.value * 65535f).ToString();
		return currentOrderID;
	}

	private void StartLoading()
	{
		loading.SetActive(value: true);
		BG.SetActive(value: true);
	}

	public void StopLoading()
	{
		if ((bool)loading && (bool)BG)
		{
			loading.SetActive(value: false);
			BG.SetActive(value: false);
		}
		else
		{
			UnityEngine.Debug.LogError("demo");
		}
	}

	public void DoPayByCode()
	{
		CommonDic.getInstance().setParameters("subject", "game");
		CommonDic.getInstance().setParameters("body", "gamePay");
		CommonDic.getInstance().setParameters("order_id", getRamdomTestOrderID());
		CommonDic.getInstance().setParameters("total", "0");
		CommonDic.getInstance().setParameters("goods_tag", "game");
		CommonDic.getInstance().setParameters("notify_url", "www.picovr.com");
		CommonDic.getInstance().setParameters("pay_code", GameObject.Find("CodeText").GetComponent<Text>().text);
		UnityEngine.Debug.Log("" + GameObject.Find("CodeText").GetComponent<Text>().text);
		StartLoading();
		GameObject.Find("CodeText").GetComponent<Text>().text = "";
		InputPanel.SetActive(value: false);
		PicoPaymentSDK.Pay(CommonDic.getInstance().PayOrderString());
	}

	private bool VerifyLocalToken()
	{
		if (CommonDic.getInstance().access_token.Equals(""))
		{
			GameObject.Find("MassageInfo").GetComponent<Text>().text = "{code:exception,msg:}";
			currentOrderID = "";
			StopLoading();
			return false;
		}
		return true;
	}
}
public class LoadingRatation : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
		base.gameObject.transform.Rotate(new Vector3(0f, 0f, -4f));
	}
}
public class InputManager : MonoBehaviour
{
	public delegate void doEnterEventHandler();

	public static doEnterEventHandler doEnter;

	private StringBuilder sb = new StringBuilder();

	private ArrayList btnsName = new ArrayList();

	private GameObject enter;

	private void Awake()
	{
		InitKeyBoard();
	}

	private void Start()
	{
	}

	private void Update()
	{
	}

	private void InitKeyBoard()
	{
		btnsName.Add("1");
		btnsName.Add("2");
		btnsName.Add("3");
		btnsName.Add("4");
		btnsName.Add("5");
		btnsName.Add("6");
		btnsName.Add("7");
		btnsName.Add("8");
		btnsName.Add("9");
		btnsName.Add("0");
		btnsName.Add("Q");
		btnsName.Add("W");
		btnsName.Add("E");
		btnsName.Add("R");
		btnsName.Add("T");
		btnsName.Add("Y");
		btnsName.Add("U");
		btnsName.Add("I");
		btnsName.Add("O");
		btnsName.Add("P");
		btnsName.Add("A");
		btnsName.Add("S");
		btnsName.Add("D");
		btnsName.Add("F");
		btnsName.Add("G");
		btnsName.Add("H");
		btnsName.Add("J");
		btnsName.Add("K");
		btnsName.Add("L");
		btnsName.Add("Z");
		btnsName.Add("X");
		btnsName.Add("C");
		btnsName.Add("V");
		btnsName.Add("B");
		btnsName.Add("N");
		btnsName.Add("M");
		btnsName.Add("Clear");
		btnsName.Add("Capslock");
		btnsName.Add("Enter");
		foreach (string item in btnsName)
		{
			GameObject btnObj = GameObject.Find(item);
			btnObj.GetComponent<Button>().onClick.AddListener(delegate
			{
				OnClick(btnObj);
			});
		}
		enter = GameObject.Find("Enter");
		enter.SetActive(sb.Length > 0);
	}

	private void OnClick(GameObject btnObj)
	{
		if (btnObj.name.Equals("Capslock"))
		{
			if (GameObject.Find("Q").transform.GetChild(0).GetComponent<Text>().text.Equals("Q"))
			{
				DoCapslock(IsUpper: true);
			}
			else
			{
				DoCapslock(IsUpper: false);
			}
		}
		else if (btnObj.name.Equals("Clear"))
		{
			GameObject.Find("CodeText").GetComponent<Text>().text = "";
			ClearBuffer();
		}
		else if (btnObj.name.Equals("Enter"))
		{
			ClearBuffer();
			doEnter();
		}
		else
		{
			EnterChar(btnObj.transform.GetChild(0).GetComponent<Text>().text);
		}
	}

	private void EnterChar(string s)
	{
		sb.Append(s);
		GameObject.Find("CodeText").GetComponent<Text>().text = sb.ToString();
		enter.SetActive(sb.Length > 0);
	}

	private void DoCapslock(bool IsUpper)
	{
		if (IsUpper)
		{
			foreach (string item in btnsName)
			{
				Text component = GameObject.Find(item).transform.GetChild(0).GetComponent<Text>();
				component.text = component.text.ToLower();
			}
			return;
		}
		foreach (string item2 in btnsName)
		{
			Text component2 = GameObject.Find(item2).transform.GetChild(0).GetComponent<Text>();
			component2.text = component2.text.ToUpper();
		}
	}

	private void ClearBuffer()
	{
		sb.Remove(0, sb.Length);
		enter.SetActive(sb.Length > 0);
	}
}
public class Callback : MonoBehaviour
{
	private static string IS_SUCCESS = "isSuccess";

	private static string MSG = "msg";

	private static string CODE = "code";

	public void LoginCallback(string LoginInfo)
	{
		MonoBehaviour.print("LoginCallback");
		JsonData jsonData = JsonMapper.ToObject(LoginInfo);
		if (jsonData[IS_SUCCESS] != null)
		{
			CommonDic.getInstance().isSuccess = jsonData[IS_SUCCESS].ToString();
			if (jsonData[IS_SUCCESS].ToString() == "true")
			{
				PicoPaymentSDK.GetUserAPI();
			}
			else if (jsonData[MSG] != null)
			{
				Notification.instance.AddNotification("Login failed:", " " + jsonData[MSG].ToString(), 0f, closeButton: true);
			}
		}
		UnityEngine.Debug.Log("login:" + LoginInfo);
	}

	public void QueryOrPayCallback(string queryOrPayInfo)
	{
		JsonData jsonData = JsonMapper.ToObject(queryOrPayInfo);
		if (jsonData[CODE] != null)
		{
			CommonDic.getInstance().code = jsonData["code"].ToString();
		}
		if (jsonData[MSG] != null)
		{
			CommonDic.getInstance().msg = jsonData["msg"].ToString();
		}
		if (jsonData != null)
		{
			CommonDic.getInstance().order_info = jsonData[1].ToString();
		}
		SetMassage(queryOrPayInfo);
		DemoController.showLoading();
		UnityEngine.Debug.Log("pay:" + queryOrPayInfo);
	}

	public void UserInfoCallback(string userInfo)
	{
		JsonData jsonData = JsonMapper.ToObject(userInfo);
		if (jsonData != null && jsonData.Keys.Contains("ret_code") && jsonData["ret_code"].ToString() == "0000")
		{
			RemoteServerManager.instance.playerID = jsonData["data"]["openid"].ToString();
			RemoteServerManager.instance.playerUserName = jsonData["data"]["username"].ToString();
			SaveFileManager.instance.CreateSaveFile();
			SaveFileManager.instance.LoadSaveFile();
		}
		else
		{
			Notification.instance.AddNotification("Failed Getting Pico Player Data:", " " + jsonData["ret_code"].ToString(), 0f, closeButton: true);
		}
		CommonDic.getInstance().user_info = userInfo;
	}

	public void SetMassage(string massage)
	{
		if (!GetCurrentGameObject().Equals(null))
		{
			Notification.instance.AddNotification("SM1", 0f, closeButton: true);
			GetCurrentGameObject().GetComponent<Text>().text = massage;
		}
		else
		{
			Notification.instance.AddNotification("SM2", 0f, closeButton: true);
			UnityEngine.Debug.LogError("Message");
		}
	}

	public GameObject GetCurrentGameObject()
	{
		return GameObject.Find("MassageInfo");
	}

	public void ActivityForResultCallback(string activity)
	{
		PicoPaymentSDK.jo.Call("authCallback", activity);
	}
}
public class CommonDic
{
	private static CommonDic dic;

	private static Dictionary<string, string> mydic;

	private string _app_ID;

	private string _app_Key;

	private string _user_token;

	private string _access_token = "";

	private string _open_id;

	private string _refresh_token;

	private string _expires_in;

	private string _user_info;

	private string _subject;

	private string _body;

	private string _order_id;

	private string _total;

	private string _goods_tag;

	private string _notify_url;

	private string _trade_type;

	private string _pay_code = "";

	private string _order_info;

	private string _code;

	private string _msg = "null";

	private string _merchant_ID;

	private string _payKey;

	private string _isSuucess;

	private string _loginMsg;

	public string subject
	{
		get
		{
			return _subject;
		}
		set
		{
			_subject = value;
		}
	}

	public string body
	{
		get
		{
			return _body;
		}
		set
		{
			_body = value;
		}
	}

	public string order_id
	{
		get
		{
			return _order_id;
		}
		set
		{
			_order_id = value;
		}
	}

	public string total
	{
		get
		{
			return _total;
		}
		set
		{
			_total = value;
		}
	}

	public string goods_tag
	{
		get
		{
			return _goods_tag;
		}
		set
		{
			_goods_tag = value;
		}
	}

	public string notify_url
	{
		get
		{
			return _notify_url;
		}
		set
		{
			_notify_url = value;
		}
	}

	public string pay_code
	{
		get
		{
			return _pay_code;
		}
		set
		{
			_pay_code = value;
		}
	}

	public string trade_type
	{
		get
		{
			return _trade_type;
		}
		set
		{
			_trade_type = value;
		}
	}

	public string user_token
	{
		get
		{
			return _user_token;
		}
		set
		{
			_user_token = value;
		}
	}

	public string access_token
	{
		get
		{
			return _access_token;
		}
		set
		{
			_access_token = value;
		}
	}

	public string open_id
	{
		get
		{
			return _open_id;
		}
		set
		{
			_open_id = value;
		}
	}

	public string refresh_token
	{
		get
		{
			return _refresh_token;
		}
		set
		{
			_refresh_token = value;
		}
	}

	public string expires_in
	{
		get
		{
			return _expires_in;
		}
		set
		{
			_expires_in = value;
		}
	}

	public string isSuccess
	{
		get
		{
			return _isSuucess;
		}
		set
		{
			_isSuucess = value;
		}
	}

	public string loginMsg
	{
		get
		{
			return _loginMsg;
		}
		set
		{
			_loginMsg = value;
		}
	}

	public string user_info
	{
		get
		{
			return _user_info;
		}
		set
		{
			_user_info = value;
		}
	}

	public string order_info
	{
		get
		{
			return _order_info;
		}
		set
		{
			_order_info = value;
		}
	}

	public string code
	{
		get
		{
			return _code;
		}
		set
		{
			_code = value;
		}
	}

	public string msg
	{
		get
		{
			return _msg;
		}
		set
		{
			_msg = value;
		}
	}

	public string app_ID
	{
		get
		{
			return _app_ID;
		}
		set
		{
			_app_ID = value;
		}
	}

	public string app_Key
	{
		get
		{
			return _app_Key;
		}
		set
		{
			_app_Key = value;
		}
	}

	public string merchant_ID
	{
		get
		{
			return _merchant_ID;
		}
		set
		{
			_merchant_ID = value;
		}
	}

	public string paykey
	{
		get
		{
			return _payKey;
		}
		set
		{
			_payKey = value;
		}
	}

	public static CommonDic getInstance()
	{
		if (dic == null)
		{
			dic = new CommonDic();
		}
		if (mydic == null)
		{
			mydic = new Dictionary<string, string>();
			InitDicData(mydic);
		}
		return dic;
	}

	public Dictionary<string, string> getDic()
	{
		return mydic;
	}

	public void setParameters(string name, string value)
	{
		if (name.Equals("subject"))
		{
			subject = value;
		}
		if (name.Equals("body"))
		{
			body = value;
		}
		if (name.Equals("order_id"))
		{
			order_id = value;
		}
		if (name.Equals("total"))
		{
			total = value;
		}
		if (name.Equals("goods_tag"))
		{
			goods_tag = value;
		}
		if (name.Equals("notify_url"))
		{
			notify_url = value;
		}
		if (name.Equals("trade_type"))
		{
			trade_type = value;
		}
		if (name.Equals("pay_code"))
		{
			pay_code = value;
		}
	}

	public string PayOrderString()
	{
		return JsonMapper.ToJson(getInstance());
	}

	public static void InitDicData(Dictionary<string, string> mydic)
	{
		mydic.Add("00000", "");
		mydic.Add("10000", "");
		mydic.Add("10001", "");
		mydic.Add("10002", "");
		mydic.Add("10003", "");
		mydic.Add("11000", "");
		mydic.Add("11001", "");
		mydic.Add("11002", "");
		mydic.Add("11003", "");
		mydic.Add("12000", "");
		mydic.Add("12001", "");
		mydic.Add("12003", "P");
		mydic.Add("12004", "");
		mydic.Add("13000", "");
		mydic.Add("13001", "");
		mydic.Add("13002", "");
		mydic.Add("14000", "");
		mydic.Add("14001", "/");
		mydic.Add("14002", "");
		mydic.Add("15000", "");
		mydic.Add("15001", "ID");
		mydic.Add("15002", "Pico");
		mydic.Add("NOAUTH", "");
		mydic.Add("SYSTEMERROR", "");
		mydic.Add("APP_ID_NOT_EXIST", "APP_ID");
		mydic.Add("MCHID_NOT_EXIST", "MCHID");
		mydic.Add("APP_ID_MCHID_NOT_MATCH", "app_idmch_idID");
		mydic.Add("LACK_PARAMS", "");
		mydic.Add("SIGNERROR", "");
		mydic.Add("NO_DATA", "");
	}
}
public class LoginSDK
{
	public static void Login()
	{
		PicoPaymentSDK.Login();
	}

	public static void GetUserAPI()
	{
		PicoPaymentSDK.GetUserAPI();
	}
}
public class PicoPaymentSDK
{
	private static AndroidJavaObject _jo = new AndroidJavaObject("com.pico.loginpaysdk.UnityInterface");

	public static AndroidJavaObject jo
	{
		get
		{
			return _jo;
		}
		set
		{
			_jo = value;
		}
	}

	public static void Login()
	{
		AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		jo.Call("init", @static);
		jo.Call("authSSO");
	}

	public static void Pay(string payOrderJson)
	{
		AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		jo.Call("init", @static);
		jo.Call("pay", payOrderJson);
	}

	public static void QueryOrder(string orderId)
	{
		AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		jo.Call("init", @static);
		jo.Call("queryOrder", orderId);
	}

	public static void GetUserAPI()
	{
		AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		jo.Call("init", @static);
		jo.Call("getUserAPI");
	}
}
public class Pvr_ToBService : MonoBehaviour
{
	public Text deviceInfoText;

	private void Awake()
	{
		InitToBService();
	}

	private void Start()
	{
		BindToBService();
	}

	private void OnDestory()
	{
		UnBindToBService();
	}

	private void InitToBService()
	{
		ToBService.UPvr_InitToBService();
		ToBService.UPvr_SetUnityObjectName(base.name);
	}

	private void BindToBService()
	{
		ToBService.UPvr_BindToBService();
	}

	private void UnBindToBService()
	{
		ToBService.UPvr_UnBindToBService();
	}

	private void BoolCallback(string value)
	{
		if (ToBService.BoolCallback != null)
		{
			ToBService.BoolCallback(bool.Parse(value));
		}
		ToBService.BoolCallback = null;
	}

	private void IntCallback(string value)
	{
		if (ToBService.IntCallback != null)
		{
			ToBService.IntCallback(int.Parse(value));
		}
		ToBService.IntCallback = null;
	}

	private void LongCallback(string value)
	{
		if (ToBService.LongCallback != null)
		{
			ToBService.LongCallback(int.Parse(value));
		}
		ToBService.LongCallback = null;
	}

	public void StateGetDeviceInfo()
	{
		string text = ToBService.UPvr_StateGetDeviceInfo(PBS_SystemInfoEnum.PUI_VERSION);
		deviceInfoText.text = "PUI_VERSION:" + text;
	}

	public void ControlSetDeviceAction()
	{
		ToBService.UPvr_ControlSetDeviceAction(PBS_DeviceControlEnum.DEVICE_CONTROL_SHUTDOWN, ControlSetDeviceActionCallBack);
	}

	private void ControlSetDeviceActionCallBack(int value)
	{
		UnityEngine.Debug.Log("ControlSetDeviceActionCallBack : " + value);
	}

	public void AppManager()
	{
		ToBService.UPvr_ControlAPPManger(PBS_PackageControlEnum.PACKAGE_SILENCE_UNINSTALL, "com.pico.ipd.test", AppManagerCallBack);
	}

	private void AppManagerCallBack(int value)
	{
		UnityEngine.Debug.Log("AppManagerCallBack : " + value);
	}
}
public class PLOG : MonoBehaviour
{
	public static int logLevel;

	public static void getConfigTraceLevel()
	{
		Render.UPvr_GetIntConfig(6, ref logLevel);
	}

	public static void D(string msg)
	{
		if (logLevel > 2)
		{
			UnityEngine.Debug.Log(msg);
		}
	}

	public static void I(string msg)
	{
		if (logLevel > 1)
		{
			UnityEngine.Debug.Log(msg);
		}
	}

	public static void W(string msg)
	{
		if (logLevel > 0)
		{
			UnityEngine.Debug.LogWarning(msg);
		}
	}

	public static void E(string msg)
	{
		UnityEngine.Debug.LogError(msg);
	}
}
public class PicoDevice : MonoBehaviour
{
	public enum DeviceType
	{
		HMD,
		LeftController,
		RightController
	}

	public DeviceType deviceType;

	private Vector3 devicePos;

	private Quaternion deviceRot;

	private void Awake()
	{
		if (deviceType == DeviceType.HMD)
		{
			base.gameObject.AddComponent<Camera>();
			GameObject obj = new GameObject();
			obj.name = "LeftEye";
			obj.transform.parent = base.transform;
			obj.AddComponent<Pvr_UnitySDKEye>().eyeSide = Eye.LeftEye;
			GameObject obj2 = new GameObject();
			obj2.name = "RightEye";
			obj2.transform.parent = base.transform;
			obj2.AddComponent<Pvr_UnitySDKEye>().eyeSide = Eye.RightEye;
			GameObject obj3 = new GameObject();
			obj3.name = "BothEye";
			obj3.transform.parent = base.transform;
			obj3.AddComponent<Pvr_UnitySDKEye>().eyeSide = Eye.BothEye;
			base.gameObject.AddComponent<Pvr_UnitySDKEyeManager>();
		}
	}

	private void Update()
	{
		switch (deviceType)
		{
		case DeviceType.HMD:
			devicePos = Pvr_UnitySDKSensor.Instance.HeadPose.Position;
			deviceRot = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation;
			break;
		case DeviceType.LeftController:
			devicePos = Pvr_ControllerManager.controllerlink.Controller0.Position;
			deviceRot = Pvr_ControllerManager.controllerlink.Controller0.Rotation;
			break;
		case DeviceType.RightController:
			devicePos = Pvr_ControllerManager.controllerlink.Controller1.Position;
			deviceRot = Pvr_ControllerManager.controllerlink.Controller1.Rotation;
			break;
		}
		base.transform.localPosition = devicePos;
		base.transform.localRotation = deviceRot;
	}
}
public class CPicoSDKSettingAsset : ScriptableObject
{
	public bool IgnoreSDKSetting;

	public bool DontshowBuildWaring;

	public bool AppIDChecked;
}
[Serializable]
public class Pvr_UnitySDKProjectSetting : ScriptableObject
{
	public RenderTextureAntiAliasing rtAntiAlising;

	public RenderTextureDepth rtBitDepth;

	public RenderTextureFormat rtFormat;

	public bool usedefaultRenderTexture;

	public Vector2 customRTSize;

	public bool usedefaultfps;

	public int customfps;

	public bool usesinglepass;

	public bool usecontentprotect;

	public static Pvr_UnitySDKProjectSetting GetProjectConfig()
	{
		return Resources.Load<Pvr_UnitySDKProjectSetting>("ProjectSetting");
	}
}
public sealed class Pvr_UnitySDKPlatformSetting : ScriptableObject
{
	public enum simulationType
	{
		Null,
		Invalid,
		Valid
	}

	[SerializeField]
	private bool entitlementchecksimulation;

	[SerializeField]
	private bool startTimeEntitlementCheck;

	[SerializeField]
	public string appID;

	public List<string> deviceSN = new List<string>();

	private static Pvr_UnitySDKPlatformSetting instance;

	public static bool Entitlementchecksimulation
	{
		get
		{
			return Instance.entitlementchecksimulation;
		}
		set
		{
			if (Instance.entitlementchecksimulation != value)
			{
				Instance.entitlementchecksimulation = value;
			}
		}
	}

	public static bool StartTimeEntitlementCheck
	{
		get
		{
			return Instance.startTimeEntitlementCheck;
		}
		set
		{
			if (Instance.startTimeEntitlementCheck != value)
			{
				Instance.startTimeEntitlementCheck = value;
			}
		}
	}

	public static Pvr_UnitySDKPlatformSetting Instance
	{
		get
		{
			if (instance == null)
			{
				instance = Resources.Load<Pvr_UnitySDKPlatformSetting>("PlatformSettings");
			}
			return instance;
		}
		set
		{
			instance = value;
		}
	}
}
public class Pvr_UnitySDKManager : MonoBehaviour
{
	public delegate void EntitlementCheckResult(int ReturnValue);

	public static PlatForm platform;

	private static Pvr_UnitySDKManager sdk;

	[HideInInspector]
	public float EyesAspect = 1f;

	[HideInInspector]
	public int posStatus;

	[HideInInspector]
	public bool ismirroring;

	[HideInInspector]
	public Vector3 resetBasePos;

	[HideInInspector]
	public int trackingmode = -1;

	[HideInInspector]
	public int systemprop = -1;

	[HideInInspector]
	public bool systemFPS;

	[HideInInspector]
	public float[] headData = new float[7];

	[SerializeField]
	private bool rotfoldout;

	[SerializeField]
	private bool hmdOnlyrot;

	[SerializeField]
	private bool controllerOnlyrot;

	[SerializeField]
	private TrackingOrigin trackingOrigin;

	public bool ResetTrackerOnLoad;

	[HideInInspector]
	public Vector3 leftEyeOffset;

	[HideInInspector]
	public Vector3 rightEyeOffset;

	[HideInInspector]
	public Rect leftEyeRect;

	[HideInInspector]
	public Rect rightEyeRect;

	[HideInInspector]
	public Matrix4x4 leftEyeView;

	[HideInInspector]
	public Matrix4x4 rightEyeView;

	[HideInInspector]
	public Pvr_UnitySDKEditor pvr_UnitySDKEditor;

	[SerializeField]
	private bool vrModeEnabled = true;

	[HideInInspector]
	public Material Eyematerial;

	[HideInInspector]
	public Material Middlematerial;

	[HideInInspector]
	public bool newPicovrTriggered;

	[SerializeField]
	private bool showFPS;

	[HideInInspector]
	public Vector3 neckOffset = new Vector3(0f, 0.075f, 0.0805f);

	[SerializeField]
	private bool pVRNeck = true;

	[HideInInspector]
	public bool UseCustomNeckPara;

	[HideInInspector]
	public bool onResume;

	[HideInInspector]
	public bool isEnterVRMode;

	public bool isHasController;

	public Pvr_UnitySDKConfigProfile pvr_UnitySDKConfig;

	private GameObject calltoast;

	private GameObject msgtoast;

	private GameObject lowhmdBatterytoast;

	private GameObject lowphoneBatterytoast;

	private GameObject LowPhoneHealthtoast;

	private GameObject LowcontrollerBatterytoast;

	private bool lowControllerpowerstate;

	private float controllerpowershowtime;

	private bool UseToast = true;

	private int iPhoneHMDModeEnabled;

	private GameObject G3LiteTips;

	[SerializeField]
	private bool monoscopic;

	private bool mIsAndroid7;

	public static Func<bool> eventEnterVRMode;

	[HideInInspector]
	public bool ShowVideoSeethrough;

	public int SystemDebugFFRLevel = -1;

	public int SystemFFRLevel = -1;

	public int AppCheckResult = 100;

	public Action longPressHomeKeyAction;

	public static Pvr_UnitySDKManager SDK
	{
		get
		{
			if (sdk == null)
			{
				sdk = UnityEngine.Object.FindObjectOfType<Pvr_UnitySDKManager>();
			}
			return sdk;
		}
	}

	public bool Rotfoldout
	{
		get
		{
			return rotfoldout;
		}
		set
		{
			if (value != rotfoldout)
			{
				rotfoldout = value;
			}
		}
	}

	public bool HmdOnlyrot
	{
		get
		{
			return hmdOnlyrot;
		}
		set
		{
			if (value != hmdOnlyrot)
			{
				hmdOnlyrot = value;
			}
		}
	}

	public bool ControllerOnlyrot
	{
		get
		{
			return controllerOnlyrot;
		}
		set
		{
			if (value != controllerOnlyrot)
			{
				controllerOnlyrot = value;
			}
		}
	}

	public TrackingOrigin TrackingOrigin
	{
		get
		{
			return trackingOrigin;
		}
		set
		{
			if (value != trackingOrigin)
			{
				trackingOrigin = value;
				Sensor.UPvr_SetTrackingOriginType(value);
			}
		}
	}

	[HideInInspector]
	public bool VRModeEnabled
	{
		get
		{
			return vrModeEnabled;
		}
		set
		{
			if (value != vrModeEnabled)
			{
				vrModeEnabled = value;
			}
		}
	}

	[HideInInspector]
	public bool picovrTriggered { get; set; }

	public bool ShowFPS
	{
		get
		{
			return showFPS;
		}
		set
		{
			if (value != showFPS)
			{
				showFPS = value;
			}
		}
	}

	public bool PVRNeck
	{
		get
		{
			return pVRNeck;
		}
		set
		{
			if (value != pVRNeck)
			{
				pVRNeck = value;
			}
		}
	}

	[HideInInspector]
	public bool Monoscopic
	{
		get
		{
			return monoscopic;
		}
		set
		{
			if (value != monoscopic)
			{
				monoscopic = value;
				Render.UPvr_SetMonoMode(monoscopic);
			}
		}
	}

	public static event EntitlementCheckResult EntitlementCheckResultEvent;

	public void ChangeDefaultCustomRtSize(int w, int h)
	{
		Pvr_UnitySDKProjectSetting.GetProjectConfig().customRTSize = new Vector2(w, h);
	}

	public Vector3 EyeOffset(Eye eye)
	{
		if (eye != 0)
		{
			return rightEyeOffset;
		}
		return leftEyeOffset;
	}

	public Rect EyeRect(Eye eye)
	{
		if (eye != 0)
		{
			return rightEyeRect;
		}
		return leftEyeRect;
	}

	private bool SDKManagerInit()
	{
		if (SDKManagerInitConfigProfile())
		{
			mIsAndroid7 = SystemInfo.operatingSystem.Contains("Android OS 7.");
			PLOG.I("Android 7 = " + mIsAndroid7);
			if (SDKManagerInitCoreAbility())
			{
				return true;
			}
			return false;
		}
		return false;
	}

	private bool SDKManagerInitCoreAbility()
	{
		Sensor.UPvr_SetTrackingOriginType(trackingOrigin);
		Render.UPvr_SetMonoMode(monoscopic);
		if (Pvr_UnitySDKRender.Instance == null)
		{
			PLOG.I("pvr_UnitySDKRender init failed");
		}
		if (Pvr_UnitySDKSensor.Instance == null)
		{
			PLOG.I("pvr_UnitySDKSensor init failed");
		}
		Pvr_UnitySDKAPI.System.UPvr_StartHomeKeyReceiver(base.gameObject.name);
		return true;
	}

	public void smsReceivedCallback(string msg)
	{
		PLOG.I("PvrLog MSG" + msg);
		JsonData jsonData = JsonMapper.ToObject(msg);
		string text = "";
		if (msg.Contains("messageSender"))
		{
			text = (string)jsonData["messageSender"];
		}
		string text2 = "";
		if (msg.Contains("messageAdr"))
		{
			text2 = (string)jsonData["messageAdr"];
			if (text2.Substring(0, 3) == "+82")
			{
				text2 = "0" + text2.Remove(0, 3);
				text2 = TransformNumber(text2);
			}
			else if (text2.Substring(0, 1) != "+")
			{
				text2 = TransformNumber(text2);
			}
		}
		if (UseToast)
		{
			msgtoast.transform.Find("number").GetComponent<Text>().text = text2;
			msgtoast.transform.Find("name").GetComponent<Text>().text = text;
			if (text.Length == 0)
			{
				msgtoast.transform.Find("number").transform.localPosition = new Vector3(0f, 0f, 0f);
			}
			else
			{
				msgtoast.transform.Find("number").transform.localPosition = new Vector3(60f, 0f, 0f);
			}
			StartCoroutine(ToastManager(2, state: true, 0f));
			StartCoroutine(ToastManager(2, state: false, 5f));
		}
	}

	public void phoneStateCallback(string state)
	{
		PLOG.I("PvrLog phone" + state);
		JsonData jsonData = JsonMapper.ToObject(state);
		string text = "";
		if (state.Contains("phoneNumber"))
		{
			text = (string)jsonData["phoneNumber"];
			if (text.Substring(0, 3) == "+82")
			{
				text = "0" + text.Remove(0, 3);
				text = TransformNumber(text);
			}
			else if (text.Substring(0, 1) != "+")
			{
				text = TransformNumber(text);
			}
		}
		string text2 = "";
		if (state.Contains("contactName"))
		{
			text2 = (string)jsonData["contactName"];
		}
		if (UseToast)
		{
			calltoast.transform.Find("number").GetComponent<Text>().text = text;
			calltoast.transform.Find("name").GetComponent<Text>().text = text2;
			if (text2.Length == 0)
			{
				calltoast.transform.Find("number").transform.localPosition = new Vector3(0f, 0f, 0f);
			}
			else
			{
				calltoast.transform.Find("number").transform.localPosition = new Vector3(60f, 0f, 0f);
			}
			StartCoroutine(ToastManager(1, state: true, 0f));
			StartCoroutine(ToastManager(1, state: false, 5f));
		}
	}

	public void phoneBatteryStateCallback(string state)
	{
		PLOG.I("PvrLog phoneBatteryState" + state);
		JsonData jsonData = JsonMapper.ToObject(state);
		string value = "";
		if (state.Contains("phoneBatteryLevel"))
		{
			value = (string)jsonData["phoneBatteryLevel"];
		}
		string value2 = "";
		if (state.Contains("phoneBatteryHealth"))
		{
			value2 = (string)jsonData["phoneBatteryHealth"];
		}
		if (!UseToast)
		{
			return;
		}
		if (Convert.ToInt16(value) <= 5)
		{
			if (!lowhmdBatterytoast.activeSelf)
			{
				StartCoroutine(ToastManager(4, state: true, 0f));
				StartCoroutine(ToastManager(4, state: false, 3f));
			}
			else
			{
				StartCoroutine(ToastManager(4, state: true, 5f));
				StartCoroutine(ToastManager(4, state: false, 8f));
			}
		}
		if (Convert.ToInt16(value2) == 3)
		{
			StartCoroutine(ToastManager(5, state: true, 0f));
			StartCoroutine(ToastManager(5, state: false, 5f));
		}
	}

	public void hmdLowBatteryCallback(string level)
	{
		PLOG.I("PvrLog hmdLowBatteryCallback" + level);
		if (UseToast)
		{
			if (!lowphoneBatterytoast.activeSelf)
			{
				StartCoroutine(ToastManager(3, state: true, 0f));
				StartCoroutine(ToastManager(3, state: false, 3f));
			}
			else
			{
				StartCoroutine(ToastManager(3, state: true, 5f));
				StartCoroutine(ToastManager(3, state: false, 8f));
			}
		}
	}

	private string TransformNumber(string number)
	{
		if (number.Length == 11)
		{
			string text = number.Substring(0, 3);
			string text2 = number.Substring(3, 4);
			string text3 = number.Substring(7, 4);
			number = text + "-" + text2 + "-" + text3;
		}
		else if (number.Length == 10)
		{
			if (number.Substring(1, 1) == "1")
			{
				string text4 = number.Substring(0, 3);
				string text5 = number.Substring(3, 3);
				string text6 = number.Substring(6, 4);
				number = text4 + "-" + text5 + "-" + text6;
			}
			else
			{
				string text7 = number.Substring(0, 2);
				string text8 = number.Substring(2, 4);
				string text9 = number.Substring(6, 4);
				number = text7 + "-" + text8 + "-" + text9;
			}
		}
		else if (number.Length == 9)
		{
			if (number.Substring(1, 1) == "2")
			{
				string text10 = number.Substring(0, 2);
				string text11 = number.Substring(2, 3);
				string text12 = number.Substring(5, 4);
				number = text10 + "-" + text11 + "-" + text12;
			}
			else
			{
				number = "+82" + number.Remove(0, 1);
			}
		}
		return number;
	}

	public void onHmdOrientationReseted()
	{
	}

	private IEnumerator ToastManager(int type, bool state, float time)
	{
		yield return new WaitForSeconds(time);
		switch (type)
		{
		case 1:
			calltoast.SetActive(state);
			break;
		case 2:
			msgtoast.SetActive(state);
			break;
		case 3:
			lowhmdBatterytoast.SetActive(state);
			break;
		case 4:
			lowphoneBatterytoast.SetActive(state);
			break;
		case 5:
			LowPhoneHealthtoast.SetActive(state);
			break;
		case 6:
			LowcontrollerBatterytoast.SetActive(state);
			break;
		}
	}

	private void CheckControllerStateForG2(string state)
	{
		if (iPhoneHMDModeEnabled == 1 && Convert.ToBoolean(Convert.ToInt16(state)) && Pvr_UnitySDKAPI.Controller.UPvr_GetControllerPower(0) == 0 && Pvr_ControllerManager.controllerlink.Controller0.Rotation.eulerAngles != Vector3.zero)
		{
			StartCoroutine(ToastManager(6, state: true, 0f));
			StartCoroutine(ToastManager(6, state: false, 3f));
		}
	}

	public void notificationCallback(string data)
	{
		JsonData jsonData = JsonMapper.ToObject(data);
		if (G3LiteTips == null)
		{
			G3LiteTips = UnityEngine.Object.Instantiate(Resources.Load("Prefabs/G3LiteTips") as GameObject, base.transform.Find("Head"), worldPositionStays: false);
		}
		JsonData jsonData2 = JsonMapper.ToObject(jsonData["str"].ToString());
		switch ((int)jsonData["type"])
		{
		case 0:
			SetProperty(0, jsonData2, "Sms");
			break;
		case 1:
			SetProperty(1, jsonData2, "Call");
			break;
		case 2:
			SetProperty(2, jsonData2, "Warnning");
			break;
		case 3:
			SetProperty(3, jsonData2, "Warnning");
			break;
		case 4:
			SetProperty(4, jsonData2, "Warnning");
			break;
		case 5:
		{
			Transform transform = G3LiteTips.transform.Find("Onlyimage");
			SetBaseProperty(transform, jsonData2["General"], "");
			SetImageProperty(transform, jsonData2["General"], "");
			transform.gameObject.SetActive(value: true);
			StartCoroutine(G3TipsManager(transform.gameObject, (int)jsonData2["General"]["time"]));
			break;
		}
		case -1:
			break;
		}
	}

	private Sprite LoadSprite(Vector2 size, string filepath)
	{
		int width = (int)size.x;
		int height = (int)size.y;
		Texture2D texture2D = new Texture2D(width, height);
		texture2D.LoadImage(ReadTex(filepath));
		return Sprite.Create(texture2D, new Rect(0f, 0f, texture2D.width, texture2D.height), new Vector2(0.5f, 0.5f));
	}

	private byte[] ReadTex(string path)
	{
		if (path == "")
		{
			return new byte[0];
		}
		FileStream fileStream = new FileStream(path, FileMode.Open, FileAccess.Read);
		fileStream.Seek(0L, SeekOrigin.Begin);
		byte[] array = new byte[fileStream.Length];
		fileStream.Read(array, 0, (int)fileStream.Length);
		fileStream.Close();
		fileStream.Dispose();
		fileStream = null;
		return array;
	}

	private void SetProperty(int type, JsonData data, string value)
	{
		Transform trans = G3LiteTips.transform.Find(value);
		SetBaseProperty(trans, data, "");
		SetImageProperty(trans, data, "");
		trans.gameObject.SetActive(value: true);
		StartCoroutine(G3TipsManager(trans.gameObject, (int)data["time"]));
		Transform transform = trans.transform.Find("icon");
		SetBaseProperty(transform, data, "icon_");
		SetImageProperty(transform, data, "icon_");
		Transform transform2 = trans.transform.Find("title");
		SetBaseProperty(transform2, data, "title_");
		SetTextProperty(transform2, data, "title_");
		if (type != 1)
		{
			Transform transform3 = trans.transform.Find("details");
			SetBaseProperty(transform3, data, "details_");
			SetTextProperty(transform3, data, "details_");
			Transform transform4 = trans.transform.Find("image1");
			SetBaseProperty(transform4, data, "image1_");
			SetImageProperty(transform4, data, "image1_");
		}
		if (type == 0 || type == 1)
		{
			Transform transform5 = trans.transform.Find("explain");
			SetBaseProperty(transform5, data, "explain_");
			SetTextProperty(transform5, data, "explain_");
			Transform transform6 = trans.transform.Find("source");
			SetBaseProperty(transform6, data, "source_");
			SetTextProperty(transform6, data, "source_");
		}
		if (type == 0)
		{
			Transform transform7 = trans.transform.Find("time");
			SetBaseProperty(transform7, data, "system_time_");
			SetTextProperty(transform7, data, "system_time_");
		}
		Transform transform8 = trans.transform.Find("Button");
		SetBaseProperty(transform8, data, "button_");
		SetImageProperty(transform8, data, "button_");
		transform8.GetComponent<Button>().onClick.AddListener(delegate
		{
			StartCoroutine(G3TipsManager(trans.gameObject, 0f));
		});
		Transform transform9 = transform8.transform.Find("Text");
		SetBaseProperty(transform9, data, "button_text_");
		SetTextProperty(transform9, data, "button_text_");
	}

	private void SetBaseProperty(Transform trans, JsonData data, string value)
	{
		string prop_name = value + "pos";
		string prop_name2 = value + "angles";
		string prop_name3 = value + "size";
		string prop_name4 = value + "scale";
		trans.GetComponent<RectTransform>().anchoredPosition3D = new Vector3(JsonToFloat(data[prop_name][0]), JsonToFloat(data[prop_name][1]), JsonToFloat(data[prop_name][2]));
		trans.GetComponent<RectTransform>().eulerAngles = new Vector3(JsonToFloat(data[prop_name2][0]), JsonToFloat(data[prop_name2][1]), JsonToFloat(data[prop_name2][2]));
		trans.GetComponent<RectTransform>().sizeDelta = new Vector2(JsonToFloat(data[prop_name3][0]), JsonToFloat(data[prop_name3][1]));
		trans.GetComponent<RectTransform>().localScale = new Vector3(JsonToFloat(data[prop_name4][0]), JsonToFloat(data[prop_name4][1]), JsonToFloat(data[prop_name4][2]));
	}

	private void SetImageProperty(Transform image, JsonData data, string value)
	{
		string prop_name = value + "sprite";
		string prop_name2 = value + "color";
		string prop_name3 = value + "size";
		image.GetComponent<Image>().sprite = LoadSprite(new Vector2(JsonToFloat(data[prop_name3][0]), JsonToFloat(data[prop_name3][1])), (string)data[prop_name]);
		image.GetComponent<Image>().color = new Color(JsonToFloat(data[prop_name2][0]), JsonToFloat(data[prop_name2][1]), JsonToFloat(data[prop_name2][2]), JsonToFloat(data[prop_name2][3]));
	}

	private void SetTextProperty(Transform text, JsonData data, string value)
	{
		string prop_name = value + "color";
		string prop_name2 = value + "font_size";
		string prop_name3 = value + "font_style";
		string prop_name4 = value + "text";
		text.GetComponent<Text>().text = (string)data[prop_name4];
		text.GetComponent<Text>().color = new Color(JsonToFloat(data[prop_name][0]), JsonToFloat(data[prop_name][1]), JsonToFloat(data[prop_name][2]), JsonToFloat(data[prop_name][3]));
		text.GetComponent<Text>().fontSize = (int)data[prop_name2];
		text.GetComponent<Text>().fontStyle = (FontStyle)(int)data[prop_name3];
	}

	private IEnumerator G3TipsManager(GameObject tip, float time)
	{
		yield return new WaitForSeconds(time);
		tip.SetActive(value: false);
	}

	private float JsonToFloat(JsonData data)
	{
		return Convert.ToSingle((string)data);
	}

	private bool SDKManagerInitFPS()
	{
		Transform[] componentsInChildren = GetComponentsInChildren<Transform>(includeInactive: true);
		GameObject gameObject = null;
		Transform[] array = componentsInChildren;
		foreach (Transform transform in array)
		{
			if (transform.gameObject.name == "FPS")
			{
				gameObject = transform.gameObject;
			}
		}
		if (gameObject != null)
		{
			if (systemFPS)
			{
				gameObject.SetActive(value: true);
				return true;
			}
			int res = 0;
			Render.UPvr_GetIntConfig(10, ref res);
			if (Convert.ToBoolean(res))
			{
				gameObject.SetActive(value: true);
				return true;
			}
			if (ShowFPS)
			{
				gameObject.SetActive(value: true);
				return true;
			}
			return false;
		}
		return false;
	}

	private bool SDKManagerInitConfigProfile()
	{
		pvr_UnitySDKConfig = Pvr_UnitySDKConfigProfile.Default;
		return true;
	}

	private bool SDKManagerInitEditor()
	{
		if (pvr_UnitySDKEditor == null)
		{
			pvr_UnitySDKEditor = base.gameObject.AddComponent<Pvr_UnitySDKEditor>();
		}
		else
		{
			pvr_UnitySDKEditor = null;
			pvr_UnitySDKEditor = base.gameObject.AddComponent<Pvr_UnitySDKEditor>();
		}
		return true;
	}

	private bool SDKManagerInitPara()
	{
		return true;
	}

	public void SDKManagerLongHomeKey()
	{
		if (Pvr_UnitySDKSensor.Instance == null)
		{
			return;
		}
		if (isHasController)
		{
			if (Pvr_UnitySDKAPI.Controller.UPvr_GetControllerState(0) == ControllerState.Connected || Pvr_UnitySDKAPI.Controller.UPvr_GetControllerState(1) == ControllerState.Connected)
			{
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(0, 1);
			}
			else
			{
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
			}
		}
		else
		{
			Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
		}
	}

	private void setLongHomeKey()
	{
		if (sdk.HmdOnlyrot)
		{
			if (Pvr_UnitySDKSensor.Instance != null)
			{
				PLOG.I(Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor() ? "Long Home Key to Reset Sensor Success!" : "Long Home Key to Reset Sensor Failed!");
			}
			return;
		}
		if (trackingmode == 4 || trackingmode == 5 || trackingmode == 6)
		{
			Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
		}
		else
		{
			if (trackingmode == 2 || trackingmode == 3)
			{
				if (isHasController && (Pvr_UnitySDKAPI.Controller.UPvr_GetControllerState(0) == ControllerState.Connected || Pvr_UnitySDKAPI.Controller.UPvr_GetControllerState(1) == ControllerState.Connected))
				{
					Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(0, 1);
				}
				else
				{
					Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
				}
			}
			if (trackingmode == 0 || trackingmode == 1)
			{
				Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
			}
		}
		if (longPressHomeKeyAction != null)
		{
			longPressHomeKeyAction();
		}
	}

	public void verifyAPPCallback(string code)
	{
		UnityEngine.Debug.Log("PvrLog verifyAPPCallback" + code);
		AppCheckResult = Convert.ToInt32(code);
		if (Pvr_UnitySDKManager.EntitlementCheckResultEvent != null)
		{
			Pvr_UnitySDKManager.EntitlementCheckResultEvent(AppCheckResult);
		}
	}

	public void IpdRefreshCallBack(string ipd)
	{
		UnityEngine.Debug.Log("PvrLog IpdRefreshCallBack");
		Pvr_UnitySDKEye[] eyes = Pvr_UnitySDKEyeManager.Instance.Eyes;
		for (int i = 0; i < eyes.Length; i++)
		{
			eyes[i].RefreshCameraPosition(Convert.ToSingle(ipd));
		}
	}

	private void Awake()
	{
		UnityEngine.Debug.Log("DISFT Unity Version:" + UnityEngine.Application.unityVersion);
		UnityEngine.Debug.Log("DISFT Customize NeckOffset:" + neckOffset);
		UnityEngine.Debug.Log("DISFT MSAA :" + Pvr_UnitySDKProjectSetting.GetProjectConfig().rtAntiAlising);
		if (GraphicsSettings.renderPipelineAsset != null)
		{
			UnityEngine.Debug.Log("DISFT LWRP = Enable");
		}
		UnityEngine.Debug.Log("DISFT Content Proctect :" + Pvr_UnitySDKProjectSetting.GetProjectConfig().usecontentprotect);
		int res = 0;
		LoadIsMirroringValue();
		if (!ismirroring)
		{
			Render.UPvr_GetIntConfig(18, ref res);
			if (res == 1)
			{
				UnityEngine.Debug.Log("DISFT ScreenOrientation.Portrait = Enable");
				Screen.orientation = ScreenOrientation.Portrait;
			}
		}
		else
		{
			Render.UPvr_GetIntConfig(19, ref res);
			Screen.orientation = ((res == 0) ? ScreenOrientation.Portrait : ScreenOrientation.LandscapeLeft);
		}
		new AndroidJavaClass("com.psmart.vrlib.VrActivity");
		new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		Pvr_ControllerManager pvr_ControllerManager = UnityEngine.Object.FindObjectOfType<Pvr_ControllerManager>();
		isHasController = pvr_ControllerManager != null;
		PLOG.getConfigTraceLevel();
		Render.UPvr_GetIntConfig(5, ref trackingmode);
		UnityEngine.Application.targetFrameRate = 61;
		int res2 = 0;
		Render.UPvr_GetIntConfig(3, ref res2);
		if (res2 == 0)
		{
			SDK.HmdOnlyrot = true;
		}
		int res3 = -1;
		Render.UPvr_GetIntConfig(9, ref res3);
		float res4 = 0f;
		Render.UPvr_GetFloatConfig(6, ref res4);
		UnityEngine.Application.targetFrameRate = ((res3 > 0) ? res3 : ((int)res4));
		if (!Pvr_UnitySDKProjectSetting.GetProjectConfig().usedefaultfps)
		{
			if ((float)Pvr_UnitySDKProjectSetting.GetProjectConfig().customfps <= res4)
			{
				UnityEngine.Application.targetFrameRate = Pvr_UnitySDKProjectSetting.GetProjectConfig().customfps;
			}
			else
			{
				UnityEngine.Application.targetFrameRate = (int)res4;
			}
		}
		UnityEngine.Debug.Log("DISFT Customize FPS :" + UnityEngine.Application.targetFrameRate);
		if (!UseCustomNeckPara)
		{
			float res5 = 0f;
			float res6 = 0f;
			float res7 = 0f;
			int configsenum = 4;
			int configsenum2 = 5;
			Render.UPvr_GetFloatConfig(3, ref res5);
			Render.UPvr_GetFloatConfig(configsenum, ref res6);
			Render.UPvr_GetFloatConfig(configsenum2, ref res7);
			if (res5 != 0f || res6 != 0f || res7 != 0f)
			{
				neckOffset = new Vector3(res5, res6, res7);
			}
		}
		Render.UPvr_GetIntConfig(16, ref iPhoneHMDModeEnabled);
		Pvr_ControllerManager.ControllerStatusChangeEvent += CheckControllerStateForG2;
		InitUI();
		RefreshTextByLanguage();
	}

	private IEnumerator Start()
	{
		if (SDKManagerInit())
		{
			PLOG.I("SDK Init success.");
		}
		else
		{
			PLOG.E("SDK Init Failed.");
			UnityEngine.Application.Quit();
		}
		if (Pvr_UnitySDKRender.Instance != null)
		{
			Pvr_UnitySDKRender.Instance.ReInit();
		}
		SDKManagerInitFPS();
		if (Pvr_UnitySDKPlatformSetting.StartTimeEntitlementCheck)
		{
			if (Pvr_UnitySDKAPI.PlatformSettings.UPvr_IsCurrentDeviceValid() != Pvr_UnitySDKPlatformSetting.simulationType.Valid)
			{
				UnityEngine.Debug.Log("DISFT Entitlement Check Simulation DO NOT PASS");
				string appID = Pvr_UnitySDKPlatformSetting.Instance.appID;
				UnityEngine.Debug.Log("DISFT Start-time Entitlement Check Enable");
				PLOG.I("DISFT Start-time Entitlement Check APPID :" + appID);
				Pvr_UnitySDKAPI.PlatformSettings.UPvr_AppEntitlementCheckExtra(appID);
			}
			else
			{
				UnityEngine.Debug.Log("DISFT Entitlement Check Simulation PASS");
			}
		}
		yield return StartCoroutine(InitRenderThreadRoutine());
	}

	private IEnumerator InitRenderThreadRoutine()
	{
		PLOG.I("InitRenderThreadRoutine begin");
		int i = 0;
		while (i < 2)
		{
			yield return null;
			int num = i + 1;
			i = num;
		}
		UnityEngine.Debug.Log("InitRenderThreadRoutine after a wait");
		if (Pvr_UnitySDKRender.Instance != null)
		{
			Pvr_UnitySDKRender.Instance.IssueRenderThread();
		}
		else
		{
			UnityEngine.Debug.Log("InitRenderThreadRoutine pvr_UnitySDKRender == null");
		}
		UnityEngine.Debug.Log("InitRenderThreadRoutine end");
	}

	private void Update()
	{
		if (isHasController && iPhoneHMDModeEnabled == 1 && Pvr_UnitySDKAPI.Controller.UPvr_GetControllerPower(0) == 0 && Pvr_ControllerManager.controllerlink.controller0Connected && Pvr_ControllerManager.controllerlink.Controller0.Rotation.eulerAngles != Vector3.zero)
		{
			if (!lowControllerpowerstate)
			{
				StartCoroutine(ToastManager(6, state: true, 0f));
				StartCoroutine(ToastManager(6, state: false, 3f));
				lowControllerpowerstate = true;
			}
			controllerpowershowtime += Time.deltaTime;
			if (controllerpowershowtime >= 3600f)
			{
				lowControllerpowerstate = false;
				controllerpowershowtime = 0f;
			}
		}
		if (Input.touchCount == 1 && Input.touches[0].phase == TouchPhase.Began)
		{
			newPicovrTriggered = true;
		}
		if (Input.GetKeyDown(KeyCode.JoystickButton0))
		{
			newPicovrTriggered = true;
		}
		if (Pvr_UnitySDKSensor.Instance != null)
		{
			Pvr_UnitySDKSensor.Instance.SensorUpdate();
		}
		picovrTriggered = newPicovrTriggered;
		newPicovrTriggered = false;
	}

	private void OnDestroy()
	{
		if (sdk == this)
		{
			sdk = null;
		}
		RenderTexture.active = null;
		Resources.UnloadUnusedAssets();
		GC.Collect();
		Pvr_ControllerManager.ControllerStatusChangeEvent -= CheckControllerStateForG2;
	}

	private void OnEnable()
	{
		if (sdk == null)
		{
			sdk = this;
		}
		else if (sdk != this)
		{
			sdk = this;
		}
	}

	private void OnDisable()
	{
		StopAllCoroutines();
	}

	private void OnPause()
	{
		Pvr_UnitySDKAPI.System.UPvr_StopHomeKeyReceiver();
		LeaveVRMode();
		if (Pvr_UnitySDKSensor.Instance != null)
		{
			Pvr_UnitySDKSensor.Instance.StopUnitySDKSensor();
		}
	}

	private void OnApplicationPause(bool pause)
	{
		bool flag = pause;
		UnityEngine.Debug.Log("OnApplicationPause-------------------------" + (flag ? "true" : "false"));
		if (Pvr_UnitySDKAPI.System.UPvr_IsPicoActivity() && !Pvr_UnitySDKRender.Instance.isShellMode)
		{
			bool flag2 = Pvr_UnitySDKAPI.System.UPvr_GetMainActivityPauseStatus();
			UnityEngine.Debug.Log("OnApplicationPause-------------------------Activity Pause State:" + flag2);
			pause = flag2;
		}
		if (flag == pause)
		{
			if (pause)
			{
				onResume = false;
				OnPause();
			}
			else
			{
				onResume = true;
				GL.InvalidateState();
				StartCoroutine(OnResume());
			}
		}
		else if (pause)
		{
			UnityEngine.Debug.Log("OnApplicationPause-------------------------Activity pause Unity resume");
			GL.InvalidateState();
			StartCoroutine(OnResume());
			onResume = false;
			OnPause();
		}
		else
		{
			UnityEngine.Debug.Log("OnApplicationPause-------------------------Activity resume Unity pause");
			OnPause();
			onResume = true;
			GL.InvalidateState();
			StartCoroutine(OnResume());
		}
	}

	public void EnterVRMode()
	{
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.Resume);
		isEnterVRMode = true;
		if (eventEnterVRMode != null)
		{
			eventEnterVRMode();
		}
	}

	public void LeaveVRMode()
	{
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.Pause);
		isEnterVRMode = false;
	}

	public void SixDofForceQuit()
	{
		UnityEngine.Application.Quit();
	}

	private void InitUI()
	{
		if (iPhoneHMDModeEnabled == 1)
		{
			Transform transform = UnityEngine.Object.Instantiate(Resources.Load("Prefabs/flamingo2Tips") as GameObject, base.transform.Find("Head"), worldPositionStays: false).transform;
			calltoast = transform.Find("Call").gameObject;
			msgtoast = transform.Find("Msg").gameObject;
			lowhmdBatterytoast = transform.Find("LowHmdBattery").gameObject;
			lowphoneBatterytoast = transform.Find("LowPhoneBattery").gameObject;
			LowPhoneHealthtoast = transform.Find("LowPhoneHealth").gameObject;
			LowcontrollerBatterytoast = transform.Find("LowControllerBattery").gameObject;
		}
	}

	private void RefreshTextByLanguage()
	{
		if (msgtoast != null)
		{
			msgtoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("msgtoast0");
			msgtoast.transform.Find("string").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("msgtoast1");
			calltoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("calltoast0");
			calltoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("calltoast1");
			lowhmdBatterytoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("lowhmdBatterytoast");
			lowphoneBatterytoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("lowphoneBatterytoast");
			LowPhoneHealthtoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("LowPhoneHealthtoast");
			LowcontrollerBatterytoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("LowcontrollerBatterytoast");
		}
	}

	private void LoadIsMirroringValue()
	{
		AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		AndroidJavaObject androidJavaObject = @static.Call<AndroidJavaObject>("getPackageManager", Array.Empty<object>());
		string text = @static.Call<string>("getPackageName", Array.Empty<object>());
		AndroidJavaObject androidJavaObject2 = androidJavaObject.Call<AndroidJavaObject>("getApplicationInfo", new object[2] { text, 128 }).Get<AndroidJavaObject>("metaData");
		ismirroring = Convert.ToBoolean(androidJavaObject2.Call<int>("getInt", new object[2] { "bypass_presentation", 0 }));
	}

	private IEnumerator OnResume()
	{
		int ability6dof = 0;
		Render.UPvr_GetIntConfig(3, ref ability6dof);
		RefreshTextByLanguage();
		if (Pvr_UnitySDKSensor.Instance != null)
		{
			Pvr_UnitySDKSensor.Instance.StartUnitySDKSensor();
			int res = -1;
			Render.UPvr_GetIntConfig(8, ref res);
			if (res != 1)
			{
				int res2 = -1;
				Render.UPvr_GetIntConfig(11, ref res2);
				if (res2 != 8)
				{
					Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
				}
			}
		}
		if (Pvr_UnitySDKAPI.System.UPvr_IsPicoActivity())
		{
			PLOG.I("onresume set monoPresentation success ?-------------" + Pvr_UnitySDKAPI.System.UPvr_SetMonoPresentation());
			PLOG.I("onresume presentation existed ?-------------" + Pvr_UnitySDKAPI.System.UPvr_IsPresentationExisted());
		}
		for (int j = 0; j < Pvr_UnitySDKEyeManager.Instance.Eyes.Length; j++)
		{
			Pvr_UnitySDKEyeManager.Instance.Eyes[j].RefreshCameraPosition(Pvr_UnitySDKAPI.System.UPvr_GetIPD());
		}
		int waitNum = 15;
		Render.UPvr_GetIntConfig(20, ref waitNum);
		int resetNum = 10;
		Render.UPvr_GetIntConfig(21, ref resetNum);
		for (int i = 0; i < waitNum; i++)
		{
			if (i == resetNum && ResetTrackerOnLoad && ability6dof == 1)
			{
				UnityEngine.Debug.Log("Reset Tracker OnLoad");
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
			}
			yield return null;
		}
		EnterVRMode();
		Pvr_UnitySDKAPI.System.UPvr_StartHomeKeyReceiver(base.gameObject.name);
		Pvr_UnitySDKEye.setLevel = false;
		if (longPressHomeKeyAction != null)
		{
			longPressHomeKeyAction();
		}
		if (Render.UPvr_GetIntSysProc("pvrsist.foveation.level", ref SystemDebugFFRLevel))
		{
			Render.SetFoveatedRenderingLevel((EFoveationLevel)SystemDebugFFRLevel);
			UnityEngine.Debug.Log("DISFT OnResume Get System Debug ffr level is : " + SystemDebugFFRLevel);
		}
		else
		{
			UnityEngine.Debug.Log("DISFT OnResume Get System Debug ffr level Error,ffr level is : " + SystemDebugFFRLevel);
		}
		if (SystemDebugFFRLevel == -1)
		{
			Render.UPvr_GetIntConfig(22, ref SystemFFRLevel);
			if (SystemFFRLevel != -1 && SystemFFRLevel >= (int)Pvr_UnitySDKEyeManager.Instance.FoveationLevel)
			{
				Render.SetFoveatedRenderingLevel((EFoveationLevel)SystemFFRLevel);
				UnityEngine.Debug.Log("DISFT OnResume Get System ffr level is : " + SystemFFRLevel);
			}
		}
	}
}
public class QuitGame : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Escape))
		{
			UnityEngine.Application.Quit();
		}
	}
}
public class Pvr_UnityEyeMask : MonoBehaviour
{
	private class EyeMaskData
	{
		public Eye eyeSide;

		public Camera camera;

		public CommandBuffer cmdBuf;
	}

	private Shader eyeMaskShader;

	private Material eyeMaskMaterial;

	private Mesh eyeMaskMeshLeft;

	private Mesh eyeMaskMeshRight;

	private Mesh eyeMaskMeshBoth;

	private float zDir = -1f;

	private Color eyeMaskColor = Color.black;

	private List<EyeMaskData> cameraDataList = new List<EyeMaskData>();

	private void Awake()
	{
		UnityEngine.Debug.Log("DISFT EyeMask = Enable");
		if (SystemInfo.graphicsDeviceType == GraphicsDeviceType.OpenGLES3 || SystemInfo.graphicsDeviceType == GraphicsDeviceType.OpenGLES2)
		{
			zDir = -1f;
		}
		else if (SystemInfo.usesReversedZBuffer)
		{
			zDir = 1f;
		}
		else
		{
			zDir = 0f;
		}
	}

	private void OnEnable()
	{
		if (eyeMaskShader == null)
		{
			eyeMaskShader = Shader.Find("Pvr_UnitySDK/Pvr_EyeMask");
		}
		if (eyeMaskMaterial == null && eyeMaskShader != null)
		{
			eyeMaskMaterial = new Material(eyeMaskShader);
			eyeMaskMaterial.SetColor("_Color", eyeMaskColor);
		}
		if (eyeMaskMaterial == null)
		{
			base.enabled = false;
			UnityEngine.Debug.LogWarning("EyeMask materil is null or EyeMask shader not found!");
		}
		else
		{
			PrepareCameras();
			Camera.onPreRender = (Camera.CameraCallback)Delegate.Combine(Camera.onPreRender, new Camera.CameraCallback(OnCustomPreRender));
			CreateCommandBuffer();
		}
	}

	private void OnDisable()
	{
		Camera.onPreRender = (Camera.CameraCallback)Delegate.Remove(Camera.onPreRender, new Camera.CameraCallback(OnCustomPreRender));
		foreach (EyeMaskData cameraData in cameraDataList)
		{
			if (cameraData.camera != null && cameraData.cmdBuf != null)
			{
				RemoveCameraCommandBuffer(cameraData);
			}
		}
		CleanEyeMask();
	}

	private void CreateCommandBuffer()
	{
		if (VerifyCommadBuffer())
		{
			return;
		}
		if (eyeMaskMeshLeft == null || eyeMaskMeshRight == null)
		{
			eyeMaskMeshLeft = GetStencilMesh(Eye.LeftEye);
			eyeMaskMeshRight = GetStencilMesh(Eye.RightEye);
			if (eyeMaskMeshLeft == null || eyeMaskMeshRight == null)
			{
				UnityEngine.Debug.LogWarning("Stencil Mesh is not exist, disable EyeMask.");
				base.enabled = false;
				return;
			}
		}
		foreach (EyeMaskData cameraData in cameraDataList)
		{
			if (cameraData.eyeSide == Eye.LeftEye)
			{
				CommandBuffer commandBuffer = new CommandBuffer();
				commandBuffer.name = "EyeMaskLeft";
				commandBuffer.DrawMesh(eyeMaskMeshLeft, Matrix4x4.identity, eyeMaskMaterial, 0, 0);
				cameraData.cmdBuf = commandBuffer;
			}
			else if (cameraData.eyeSide == Eye.RightEye)
			{
				CommandBuffer commandBuffer2 = new CommandBuffer();
				commandBuffer2.name = "EyeMaskRight";
				commandBuffer2.DrawMesh(eyeMaskMeshRight, Matrix4x4.identity, eyeMaskMaterial, 0, 0);
				cameraData.cmdBuf = commandBuffer2;
			}
			else if (cameraData.eyeSide == Eye.BothEye)
			{
				if (eyeMaskMeshBoth == null)
				{
					eyeMaskMeshBoth = GetStencilMeshBoth(eyeMaskMeshLeft, eyeMaskMeshRight);
					float value = Mathf.Max(Mathf.Abs(eyeMaskMeshLeft.bounds.max.x), Mathf.Abs(eyeMaskMeshRight.bounds.min.x));
					eyeMaskMaterial.SetFloat("_MeshOffsetX", value);
				}
				CommandBuffer commandBuffer3 = new CommandBuffer();
				commandBuffer3.name = "EyeMaskBoth";
				commandBuffer3.DrawMesh(eyeMaskMeshBoth, Matrix4x4.identity, eyeMaskMaterial, 0, 1);
				cameraData.cmdBuf = commandBuffer3;
			}
		}
	}

	private void OnCustomPreRender(Camera cam)
	{
		if (!VerifyCommadBuffer())
		{
			UnityEngine.Debug.LogWarning("Verify CommandBuffer failed!");
			return;
		}
		foreach (EyeMaskData cameraData in cameraDataList)
		{
			if (!(cameraData.camera != cam))
			{
				RemoveCameraCommandBuffer(cameraData);
				AddCameraCommandBuffer(cameraData);
			}
		}
	}

	private Mesh GetStencilMesh(Eye eyeSide)
	{
		int vertexCount = 0;
		int triangleCount = 0;
		IntPtr vertexDataPtr = IntPtr.Zero;
		IntPtr indexDataPtr = IntPtr.Zero;
		Render.UPvr_GetStencilMesh((int)eyeSide, ref vertexCount, ref triangleCount, ref vertexDataPtr, ref indexDataPtr);
		if (vertexCount <= 0 || triangleCount <= 0 || vertexDataPtr == IntPtr.Zero || indexDataPtr == IntPtr.Zero)
		{
			return null;
		}
		Vector3[] array = new Vector3[vertexCount];
		int[] array2 = new int[triangleCount * 3];
		float[] array3 = new float[vertexCount * 3];
		int[] array4 = new int[triangleCount * 3];
		Marshal.Copy(vertexDataPtr, array3, 0, vertexCount * 3);
		Marshal.Copy(indexDataPtr, array4, 0, triangleCount * 3);
		for (int i = 0; i < vertexCount; i++)
		{
			array[i] = new Vector3(array3[3 * i], array3[3 * i + 1], zDir);
		}
		for (int j = 0; j < triangleCount; j++)
		{
			array2[3 * j] = array4[3 * j + 2];
			array2[3 * j + 1] = array4[3 * j + 1];
			array2[3 * j + 2] = array4[3 * j];
		}
		Mesh mesh = new Mesh();
		mesh.name = "EyeMaskMesh";
		mesh.vertices = array;
		mesh.SetIndices(array2, MeshTopology.Triangles, 0);
		return mesh;
	}

	private Mesh GetStencilMeshBoth(Mesh leftMesh, Mesh rightMesh)
	{
		float num = Mathf.Max(Mathf.Abs(leftMesh.bounds.max.x), Mathf.Abs(rightMesh.bounds.min.x));
		Mesh mesh = new Mesh();
		mesh.name = "EyeMaskBoth";
		CombineInstance combineInstance = default(CombineInstance);
		combineInstance.mesh = leftMesh;
		Matrix4x4 identity = Matrix4x4.identity;
		identity.SetTRS(Vector3.left * num, Quaternion.identity, Vector3.one);
		combineInstance.transform = identity;
		CombineInstance combineInstance2 = default(CombineInstance);
		combineInstance2.mesh = rightMesh;
		Matrix4x4 identity2 = Matrix4x4.identity;
		identity2.SetTRS(Vector3.right * num, Quaternion.identity, Vector3.one);
		combineInstance2.transform = identity2;
		CombineInstance[] combine = new CombineInstance[2] { combineInstance, combineInstance2 };
		mesh.CombineMeshes(combine);
		return mesh;
	}

	private bool VerifyCommadBuffer()
	{
		if (cameraDataList == null || cameraDataList.Count <= 0)
		{
			return false;
		}
		foreach (EyeMaskData cameraData in cameraDataList)
		{
			if (cameraData == null || cameraData.cmdBuf == null)
			{
				return false;
			}
		}
		return true;
	}

	private void PrepareCameras()
	{
		cameraDataList.Clear();
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			if (Pvr_UnitySDKEyeManager.Instance.BothEyeCamera == null)
			{
				UnityEngine.Debug.LogWarning("BothEye Camera is null!");
				return;
			}
			EyeMaskData eyeMaskData = new EyeMaskData();
			eyeMaskData.eyeSide = Eye.BothEye;
			eyeMaskData.camera = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
			cameraDataList.Add(eyeMaskData);
		}
		else if (Pvr_UnitySDKEyeManager.Instance.LeftEyeCamera == null || Pvr_UnitySDKEyeManager.Instance.RightEyeCamera == null)
		{
			UnityEngine.Debug.LogWarning("LeftEye or RightEye Camera is null!");
		}
		else
		{
			EyeMaskData eyeMaskData2 = new EyeMaskData();
			eyeMaskData2.eyeSide = Eye.LeftEye;
			eyeMaskData2.camera = Pvr_UnitySDKEyeManager.Instance.LeftEyeCamera;
			eyeMaskData2.cmdBuf = null;
			cameraDataList.Add(eyeMaskData2);
			EyeMaskData eyeMaskData3 = new EyeMaskData();
			eyeMaskData3.eyeSide = Eye.RightEye;
			eyeMaskData3.camera = Pvr_UnitySDKEyeManager.Instance.RightEyeCamera;
			eyeMaskData3.cmdBuf = null;
			cameraDataList.Add(eyeMaskData3);
		}
	}

	private void AddCameraCommandBuffer(EyeMaskData data)
	{
		data.camera.AddCommandBuffer(CameraEvent.BeforeForwardOpaque, data.cmdBuf);
	}

	private void RemoveCameraCommandBuffer(EyeMaskData data)
	{
		data.camera.RemoveCommandBuffer(CameraEvent.BeforeForwardOpaque, data.cmdBuf);
	}

	private void CleanEyeMask()
	{
		cameraDataList.Clear();
		eyeMaskMeshLeft = null;
		eyeMaskMeshRight = null;
		eyeMaskMeshBoth = null;
		eyeMaskShader = null;
		eyeMaskMaterial = null;
	}
}
[RequireComponent(typeof(Camera))]
public class Pvr_UnitySDKEye : MonoBehaviour
{
	public static List<Pvr_UnitySDKEye> Instances = new List<Pvr_UnitySDKEye>();

	public Eye eyeSide;

	private int eyeCameraOriginCullingMask;

	private CameraClearFlags eyeCameraOriginClearFlag;

	private Color eyeCameraOriginBackgroundColor;

	private int lastBoundaryState;

	private Matrix4x4 realProj = Matrix4x4.identity;

	private const int bufferSize = 3;

	private int IDIndex;

	private RenderEventType eventType;

	private int previousId;

	public static bool setLevel = false;

	private Material mat_Vignette;

	public Camera eyecamera { get; private set; }

	private void Awake()
	{
		Instances.Add(this);
		eyecamera = GetComponent<Camera>();
	}

	private void Start()
	{
		Setup(eyeSide);
		SetupUpdate();
		if (eyecamera != null)
		{
			eyeCameraOriginCullingMask = eyecamera.cullingMask;
			eyeCameraOriginClearFlag = eyecamera.clearFlags;
			eyeCameraOriginBackgroundColor = eyecamera.backgroundColor;
		}
	}

	private void Update()
	{
		if (!(eyecamera != null) || !eyecamera.enabled)
		{
			return;
		}
		int num = BoundarySystem.UPvr_GetSeeThroughState();
		if (num == lastBoundaryState)
		{
			return;
		}
		switch (num)
		{
		case 2:
			eyeCameraOriginCullingMask = eyecamera.cullingMask;
			eyeCameraOriginClearFlag = eyecamera.clearFlags;
			eyeCameraOriginBackgroundColor = eyecamera.backgroundColor;
			eyecamera.cullingMask = 0;
			eyecamera.clearFlags = CameraClearFlags.Color;
			eyecamera.backgroundColor = Color.black;
			break;
		case 1:
			if (lastBoundaryState == 2)
			{
				if (eyecamera.cullingMask == 0)
				{
					eyecamera.cullingMask = eyeCameraOriginCullingMask;
				}
				if (eyecamera.clearFlags == CameraClearFlags.Color)
				{
					eyecamera.clearFlags = eyeCameraOriginClearFlag;
				}
				if (eyecamera.backgroundColor == Color.black)
				{
					eyecamera.backgroundColor = eyeCameraOriginBackgroundColor;
				}
			}
			break;
		default:
			if (lastBoundaryState == 2 || lastBoundaryState == 1)
			{
				if (eyecamera.cullingMask == 0)
				{
					eyecamera.cullingMask = eyeCameraOriginCullingMask;
				}
				if (eyecamera.clearFlags == CameraClearFlags.Color)
				{
					eyecamera.clearFlags = eyeCameraOriginClearFlag;
				}
				if (eyecamera.backgroundColor == Color.black)
				{
					eyecamera.backgroundColor = eyeCameraOriginBackgroundColor;
				}
			}
			break;
		}
		lastBoundaryState = num;
	}

	private void OnEnable()
	{
		if (GraphicsSettings.renderPipelineAsset != null)
		{
			RenderPipeline.beginCameraRendering += MyPreRender;
		}
	}

	private void OnDisable()
	{
		if (GraphicsSettings.renderPipelineAsset != null)
		{
			RenderPipeline.beginCameraRendering -= MyPreRender;
		}
	}

	private void OnDestroy()
	{
		Instances.Remove(this);
	}

	public void MyPreRender(Camera camera)
	{
		if (!(camera.gameObject != base.gameObject))
		{
			OnPreRender();
		}
	}

	public void MyPreRender(ScriptableRenderContext context, Camera camera)
	{
		if (!(camera.gameObject != base.gameObject))
		{
			OnPreRender();
		}
	}

	public void MyPostRender(ScriptableRenderContext context, Camera camera)
	{
		if (!(camera.gameObject != base.gameObject))
		{
			OnPostRender();
		}
	}

	private void OnPreRender()
	{
		if (!eyecamera.enabled)
		{
			return;
		}
		if (Pvr_UnitySDKRender.Instance.StereoRendering != null)
		{
			if (Pvr_UnitySDKRender.Instance.isSwitchSDK)
			{
				return;
			}
			Pvr_UnitySDKRender.Instance.StereoRendering.OnSDKPreRender();
		}
		SetFFRParameter();
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.BeginEye);
	}

	private void OnPostRender()
	{
		if (!eyecamera.enabled)
		{
			return;
		}
		Pvr_UnitySDKAPI.System.UPvr_UnityEventData(Pvr_UnitySDKAPI.System.UPvr_GetEyeBufferData(Pvr_UnitySDKRender.Instance.eyeTextureIds[IDIndex]));
		Pvr_UnitySDKPluginEvent.Issue(eventType);
		if (Pvr_UnitySDKRender.Instance.StereoRendering != null)
		{
			if (Pvr_UnitySDKRender.Instance.isSwitchSDK)
			{
				return;
			}
			Pvr_UnitySDKRender.Instance.StereoRendering.OnSDKPostRender();
		}
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.EndEye);
	}

	public void EyeRender()
	{
		SetupUpdate();
		if (Pvr_UnitySDKRender.Instance.eyeTextures[IDIndex] != null)
		{
			Pvr_UnitySDKRender.Instance.eyeTextures[IDIndex].DiscardContents();
			eyecamera.targetTexture = Pvr_UnitySDKRender.Instance.eyeTextures[IDIndex];
		}
	}

	private void Setup(Eye eyeSide)
	{
		eyecamera = GetComponent<Camera>();
		switch (eyeSide)
		{
		case Eye.LeftEye:
		case Eye.RightEye:
			base.transform.localPosition = Pvr_UnitySDKManager.SDK.EyeOffset(eyeSide);
			break;
		case Eye.BothEye:
			base.transform.localPosition = Vector3.zero;
			break;
		}
		eyecamera.aspect = Pvr_UnitySDKManager.SDK.EyesAspect;
		eyecamera.rect = new Rect(0f, 0f, 1f, 1f);
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.MultiPass)
		{
			eventType = ((eyeSide == Eye.LeftEye) ? RenderEventType.LeftEyeEndFrame : RenderEventType.RightEyeEndFrame);
		}
		else
		{
			eventType = RenderEventType.BothEyeEndFrame;
		}
	}

	private void SetupUpdate()
	{
		if (eyeSide == Eye.LeftEye || eyeSide == Eye.RightEye)
		{
			eyecamera.enabled = !Pvr_UnitySDKManager.SDK.Monoscopic && Pvr_UnitySDKRender.Instance.StereoRenderPath != StereoRenderingPathPico.SinglePass;
		}
		else if (eyeSide == Eye.BothEye)
		{
			eyecamera.enabled = Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass;
		}
		eyecamera.fieldOfView = Pvr_UnitySDKRender.Instance.EyeVFoV;
		eyecamera.aspect = Pvr_UnitySDKManager.SDK.EyesAspect;
		if (eyeSide == Eye.LeftEye || eyeSide == Eye.RightEye)
		{
			IDIndex = Pvr_UnitySDKRender.Instance.currEyeTextureIdx + (int)eyeSide * 3;
		}
		else if (eyeSide == Eye.BothEye)
		{
			IDIndex = Pvr_UnitySDKRender.Instance.currEyeTextureIdx;
			Pvr_UnitySDKRender.Instance.isSwitchSDK = Pvr_UnitySDKRender.Instance.lastEyeTextureIdx == Pvr_UnitySDKRender.Instance.currEyeTextureIdx;
			Pvr_UnitySDKRender.Instance.lastEyeTextureIdx = Pvr_UnitySDKRender.Instance.currEyeTextureIdx;
		}
	}

	public void RefreshCameraPosition(float ipd)
	{
		Pvr_UnitySDKManager.SDK.leftEyeOffset = new Vector3((0f - ipd) / 2f, 0f, 0f);
		Pvr_UnitySDKManager.SDK.rightEyeOffset = new Vector3(ipd / 2f, 0f, 0f);
		if (eyeSide == Eye.LeftEye || eyeSide == Eye.RightEye)
		{
			base.transform.localPosition = Pvr_UnitySDKManager.SDK.EyeOffset(eyeSide);
		}
		else if (eyeSide == Eye.BothEye)
		{
			eyecamera.stereoSeparation = ipd;
		}
	}

	private void DrawVignetteLine()
	{
		if (null == mat_Vignette)
		{
			mat_Vignette = new Material(Shader.Find("Diffuse"));
			if (null == mat_Vignette)
			{
				return;
			}
		}
		GL.PushMatrix();
		mat_Vignette.SetPass(0);
		GL.LoadOrtho();
		vignette();
		GL.PopMatrix();
	}

	private void vignette()
	{
		GL.Begin(7);
		GL.Color(Color.black);
		GL.Vertex3(0f, 1f, 0f);
		GL.Vertex3(1f, 1f, 0f);
		GL.Vertex3(1f, 0.995f, 0f);
		GL.Vertex3(0f, 0.995f, 0f);
		GL.Vertex3(0f, 0f, 0f);
		GL.Vertex3(0f, 0.005f, 0f);
		GL.Vertex3(1f, 0.005f, 0f);
		GL.Vertex3(1f, 0f, 0f);
		GL.Vertex(new Vector3(0f, 1f, 0f));
		GL.Vertex(new Vector3(0.005f, 1f, 0f));
		GL.Vertex(new Vector3(0.005f, 0f, 0f));
		GL.Vertex(new Vector3(0f, 0f, 0f));
		GL.Vertex(new Vector3(0.995f, 1f, 0f));
		GL.Vertex(new Vector3(1f, 1f, 0f));
		GL.Vertex(new Vector3(1f, 0f, 0f));
		GL.Vertex(new Vector3(0.995f, 0f, 0f));
		GL.End();
	}

	private void SetFFRParameter()
	{
		Vector3 vector = Vector3.zero;
		if (Pvr_UnitySDKManager.SDK.isEnterVRMode && Pvr_UnitySDKEyeManager.supportEyeTracking && Pvr_UnitySDKEyeManager.Instance.EyeTracking)
		{
			vector = Pvr_UnitySDKAPI.System.UPvr_getEyeTrackingPos();
		}
		int textureId = Pvr_UnitySDKRender.Instance.eyeTextureIds[IDIndex];
		Render.UPvr_SetFoveationResource(textureId, previousId, vector.x, vector.y);
		previousId = textureId;
	}
}
public class Pvr_UnitySDKEyeManager : MonoBehaviour
{
	private static Pvr_UnitySDKEyeManager instance;

	private Pvr_UnitySDKEye[] eyes;

	[HideInInspector]
	public Camera LeftEyeCamera;

	[HideInInspector]
	public Camera RightEyeCamera;

	[HideInInspector]
	public Camera MonoEyeCamera;

	[HideInInspector]
	public Camera BothEyeCamera;

	private int MonoEyeTextureID;

	private readonly int WaitSplashScreenFrames = 3;

	private int frameNum;

	[SerializeField]
	[HideInInspector]
	private bool foveatedRendering;

	[SerializeField]
	[HideInInspector]
	private EFoveationLevel foveationLevel;

	private int eyeTextureId;

	private RenderEventType eventType = RenderEventType.LeftEyeEndFrame;

	private Pvr_UnitySDKEyeOverlay compositeLayer;

	private int overlayLayerDepth = 1;

	private int underlayLayerDepth;

	private bool isHeadLocked;

	private int layerFlags;

	[HideInInspector]
	public bool EyeTracking;

	[HideInInspector]
	public Vector3 eyePoint;

	private EyeTrackingData eyePoseData;

	[HideInInspector]
	public static bool supportEyeTracking;

	[Tooltip("If true, specific color gradient when switching scenes.")]
	public bool screenFade;

	[Tooltip("Define the duration of screen fade.")]
	public float fadeTime = 5f;

	[Tooltip("Define the color of screen fade.")]
	public Color fadeColor = new Color(0f, 0f, 0f, 1f);

	public int renderQueue = 5000;

	private MeshRenderer fadeMeshRenderer;

	private MeshFilter fadeMeshFilter;

	private Material fadeMaterial;

	private float elapsedTime;

	private bool isFading;

	private float currentAlpha;

	private float nowFadeAlpha;

	public static Pvr_UnitySDKEyeManager Instance
	{
		get
		{
			if (instance == null)
			{
				PLOG.E("Pvr_UnitySDKEyeManager instance is not init yet...");
			}
			return instance;
		}
	}

	public Pvr_UnitySDKEye[] Eyes
	{
		get
		{
			if (eyes == null)
			{
				eyes = Pvr_UnitySDKEye.Instances.ToArray();
			}
			return eyes;
		}
	}

	[HideInInspector]
	public bool FoveatedRendering
	{
		get
		{
			return foveatedRendering;
		}
		set
		{
			if (value == foveatedRendering)
			{
				return;
			}
			foveatedRendering = value;
			if (UnityEngine.Application.isPlaying)
			{
				Render.UPvr_EnableFoveation(enable: true);
				if (!foveatedRendering)
				{
					Render.SetFoveatedRenderingLevel((EFoveationLevel)(-1));
				}
			}
		}
	}

	[HideInInspector]
	public EFoveationLevel FoveationLevel
	{
		get
		{
			return foveationLevel;
		}
		set
		{
			if (value != foveationLevel)
			{
				foveationLevel = value;
			}
		}
	}

	private void SetCameraEnableEditor()
	{
		MonoEyeCamera.enabled = !Pvr_UnitySDKManager.SDK.VRModeEnabled || Pvr_UnitySDKManager.SDK.Monoscopic;
		for (int i = 0; i < Eyes.Length; i++)
		{
			if (Eyes[i].eyeSide == Eye.LeftEye || Eyes[i].eyeSide == Eye.RightEye)
			{
				Eyes[i].eyecamera.enabled = Pvr_UnitySDKManager.SDK.VRModeEnabled;
			}
			else if (Eyes[i].eyeSide == Eye.BothEye)
			{
				Eyes[i].eyecamera.enabled = false;
			}
		}
	}

	private void SetCamerasEnableByStereoRendering()
	{
		MonoEyeCamera.enabled = Pvr_UnitySDKManager.SDK.Monoscopic && Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.MultiPass;
	}

	private void SetupMonoCamera()
	{
		base.transform.localPosition = Vector3.zero;
		MonoEyeCamera.aspect = Pvr_UnitySDKManager.SDK.EyesAspect;
		MonoEyeCamera.rect = new Rect(0f, 0f, 1f, 1f);
	}

	private void SetupUpdate()
	{
		MonoEyeCamera.fieldOfView = Pvr_UnitySDKRender.Instance.EyeVFoV;
		MonoEyeCamera.aspect = Pvr_UnitySDKManager.SDK.EyesAspect;
		MonoEyeTextureID = Pvr_UnitySDKRender.Instance.currEyeTextureIdx;
	}

	private void MonoEyeRender()
	{
		SetupUpdate();
		if (Pvr_UnitySDKRender.Instance.eyeTextures[MonoEyeTextureID] != null)
		{
			Pvr_UnitySDKRender.Instance.eyeTextures[MonoEyeTextureID].DiscardContents();
			MonoEyeCamera.targetTexture = Pvr_UnitySDKRender.Instance.eyeTextures[MonoEyeTextureID];
		}
	}

	private void Awake()
	{
		if (MonoEyeCamera == null)
		{
			MonoEyeCamera = GetComponent<Camera>();
		}
		if (LeftEyeCamera == null)
		{
			LeftEyeCamera = base.gameObject.transform.Find("LeftEye").GetComponent<Camera>();
		}
		if (RightEyeCamera == null)
		{
			RightEyeCamera = base.gameObject.transform.Find("RightEye").GetComponent<Camera>();
		}
		if (BothEyeCamera == null)
		{
			BothEyeCamera = base.gameObject.transform.Find("BothEye").GetComponent<Camera>();
		}
		if (BothEyeCamera != null)
		{
			BothEyeCamera.transform.GetComponent<Pvr_UnitySDKEye>().eyeSide = Eye.BothEye;
		}
		CreateFadeMesh();
		SetCurrentAlpha(0f);
		Render.UPvr_EnableFoveation(enable: true);
		if (foveatedRendering)
		{
			Render.SetFoveatedRenderingLevel(foveationLevel);
		}
		else
		{
			Render.SetFoveatedRenderingLevel((EFoveationLevel)(-1));
		}
		Pvr_UnitySDKManager.eventEnterVRMode = (Func<bool>)Delegate.Combine(Pvr_UnitySDKManager.eventEnterVRMode, new Func<bool>(SetEyeTrackingMode));
	}

	private void OnEnable()
	{
		if (instance == null)
		{
			instance = this;
		}
		else if (instance != this)
		{
			instance = this;
		}
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			Pvr_UnitySDKRender.Instance.StereoRendering.InitEye(BothEyeCamera);
		}
		foreach (Pvr_UnitySDKEyeOverlay instance in Pvr_UnitySDKEyeOverlay.Instances)
		{
			instance.RefreshCamera();
			if (instance.overlayType == Pvr_UnitySDKEyeOverlay.OverlayType.Overlay)
			{
				if (instance.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Cylinder)
				{
					UnityEngine.Debug.Log("DISFT Cylinder OverLay = Enable");
				}
				if (instance.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Equirect)
				{
					UnityEngine.Debug.Log("DISFT 360 OverLay= Enable");
				}
				if (instance.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Quad)
				{
					UnityEngine.Debug.Log("DISFT 2D OverLay= Enable");
				}
			}
			if (instance.overlayType == Pvr_UnitySDKEyeOverlay.OverlayType.Underlay)
			{
				UnityEngine.Debug.Log("DISFT UnderLay= Enable");
			}
		}
		GfxDeviceAdvanceFrameGLES();
		StartCoroutine("EndOfFrame");
		if (screenFade)
		{
			StartCoroutine(ScreenFade(1f, 0f));
		}
	}

	private void Start()
	{
		SetCamerasEnableByStereoRendering();
		SetupMonoCamera();
	}

	private void Update()
	{
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			for (int i = 0; i < Eyes.Length; i++)
			{
				if (Eyes[i].isActiveAndEnabled && Eyes[i].eyeSide == Eye.BothEye)
				{
					Eyes[i].EyeRender();
				}
			}
		}
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath != 0)
		{
			return;
		}
		if (!Pvr_UnitySDKManager.SDK.Monoscopic)
		{
			for (int j = 0; j < Eyes.Length; j++)
			{
				if (Eyes[j].isActiveAndEnabled && Eyes[j].eyeSide != Eye.BothEye)
				{
					Eyes[j].EyeRender();
				}
			}
		}
		else
		{
			MonoEyeRender();
		}
	}

	private void OnPause()
	{
		Pvr_UnitySDKManager.eventEnterVRMode = (Func<bool>)Delegate.Remove(Pvr_UnitySDKManager.eventEnterVRMode, new Func<bool>(SetEyeTrackingMode));
	}

	public void MyPostRender(ScriptableRenderContext context, Camera camera)
	{
		if (!(camera.gameObject != base.gameObject))
		{
			OnPostRender();
		}
	}

	private void OnDisable()
	{
		StopAllCoroutines();
	}

	private void OnDestroy()
	{
		DestoryFadeMesh();
	}

	private void OnPostRender()
	{
		long data = Pvr_UnitySDKAPI.System.UPvr_GetEyeBufferData(Pvr_UnitySDKRender.Instance.eyeTextureIds[Pvr_UnitySDKRender.Instance.currEyeTextureIdx]);
		Pvr_UnitySDKAPI.System.UPvr_UnityEventData(data);
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.LeftEyeEndFrame);
		Pvr_UnitySDKAPI.System.UPvr_UnityEventData(data);
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.RightEyeEndFrame);
	}

	private IEnumerator EndOfFrame()
	{
		while (true)
		{
			yield return new WaitForEndOfFrame();
			if (!Pvr_UnitySDKManager.SDK.isEnterVRMode)
			{
				GL.Clear(clearDepth: false, clearColor: true, Color.black);
			}
			if (Pvr_UnitySDKRender.Instance.isFirstStartup && frameNum == WaitSplashScreenFrames)
			{
				Pvr_UnitySDKAPI.System.UPvr_RemovePlatformLogo();
				if (Pvr_UnitySDKManager.SDK.ResetTrackerOnLoad)
				{
					UnityEngine.Debug.Log("Reset Tracker OnLoad");
					Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
				}
				Pvr_UnitySDKAPI.System.UPvr_StartVRModel();
				Pvr_UnitySDKRender.Instance.isFirstStartup = false;
			}
			else if (Pvr_UnitySDKRender.Instance.isFirstStartup && frameNum < WaitSplashScreenFrames)
			{
				PLOG.I("frameNum:" + frameNum);
				frameNum++;
			}
			if (GraphicsSettings.renderPipelineAsset != null)
			{
				for (int i = 0; i < Eyes.Length; i++)
				{
					if (!Eyes[i].isActiveAndEnabled || !Eyes[i].eyecamera.enabled)
					{
						continue;
					}
					switch (Eyes[i].eyeSide)
					{
					case Eye.LeftEye:
						eyeTextureId = Pvr_UnitySDKRender.Instance.eyeTextureIds[Pvr_UnitySDKRender.Instance.currEyeTextureIdx];
						eventType = RenderEventType.LeftEyeEndFrame;
						break;
					case Eye.RightEye:
						if (!Pvr_UnitySDKManager.SDK.Monoscopic)
						{
							eyeTextureId = Pvr_UnitySDKRender.Instance.eyeTextureIds[Pvr_UnitySDKRender.Instance.currEyeTextureIdx + 3];
						}
						else
						{
							eyeTextureId = Pvr_UnitySDKRender.Instance.eyeTextureIds[Pvr_UnitySDKRender.Instance.currEyeTextureIdx];
						}
						eventType = RenderEventType.RightEyeEndFrame;
						break;
					case Eye.BothEye:
						eyeTextureId = Pvr_UnitySDKRender.Instance.eyeTextureIds[Pvr_UnitySDKRender.Instance.currEyeTextureIdx];
						eventType = RenderEventType.BothEyeEndFrame;
						break;
					}
					Pvr_UnitySDKAPI.System.UPvr_UnityEventData(Pvr_UnitySDKAPI.System.UPvr_GetEyeBufferData(eyeTextureId));
					Pvr_UnitySDKPluginEvent.Issue(eventType);
					Pvr_UnitySDKPluginEvent.Issue(RenderEventType.EndEye);
				}
			}
			int num = BoundarySystem.UPvr_GetSeeThroughState();
			if (Pvr_UnitySDKEyeOverlay.Instances.Count > 0 && num != 2)
			{
				overlayLayerDepth = 1;
				underlayLayerDepth = 0;
				Pvr_UnitySDKEyeOverlay.Instances.Sort();
				for (int j = 0; j < Pvr_UnitySDKEyeOverlay.Instances.Count; j++)
				{
					compositeLayer = Pvr_UnitySDKEyeOverlay.Instances[j];
					if (!compositeLayer.isActiveAndEnabled || (compositeLayer.layerTextures[0] == null && compositeLayer.layerTextures[1] == null && !compositeLayer.isExternalAndroidSurface) || (compositeLayer.layerTransform != null && !compositeLayer.layerTransform.gameObject.activeSelf))
					{
						continue;
					}
					layerFlags = 0;
					if (compositeLayer.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Quad || compositeLayer.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Cylinder)
					{
						if (compositeLayer.overlayType == Pvr_UnitySDKEyeOverlay.OverlayType.Overlay)
						{
							isHeadLocked = false;
							if (compositeLayer.layerTransform != null && compositeLayer.layerTransform.parent == base.transform)
							{
								isHeadLocked = true;
							}
							if (compositeLayer.isExternalAndroidSurface)
							{
								layerFlags |= 1;
								CreateExternalSurface(compositeLayer, overlayLayerDepth);
							}
							Render.UPvr_SetOverlayModelViewMatrix((int)compositeLayer.overlayType, (int)compositeLayer.overlayShape, compositeLayer.layerTextureIds[0], 0, overlayLayerDepth, isHeadLocked, layerFlags, compositeLayer.MVMatrixs[0], compositeLayer.ModelScales[0], compositeLayer.ModelRotations[0], compositeLayer.ModelTranslations[0], compositeLayer.CameraRotations[0], compositeLayer.CameraTranslations[0], compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
							Render.UPvr_SetOverlayModelViewMatrix((int)compositeLayer.overlayType, (int)compositeLayer.overlayShape, compositeLayer.layerTextureIds[1], 1, overlayLayerDepth, isHeadLocked, layerFlags, compositeLayer.MVMatrixs[1], compositeLayer.ModelScales[1], compositeLayer.ModelRotations[1], compositeLayer.ModelTranslations[1], compositeLayer.CameraRotations[1], compositeLayer.CameraTranslations[1], compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
							overlayLayerDepth++;
						}
						else if (compositeLayer.overlayType == Pvr_UnitySDKEyeOverlay.OverlayType.Underlay)
						{
							if (compositeLayer.isExternalAndroidSurface)
							{
								layerFlags |= 1;
								CreateExternalSurface(compositeLayer, underlayLayerDepth);
							}
							Render.UPvr_SetOverlayModelViewMatrix((int)compositeLayer.overlayType, (int)compositeLayer.overlayShape, compositeLayer.layerTextureIds[0], 0, underlayLayerDepth, isHeadLocked: false, layerFlags, compositeLayer.MVMatrixs[0], compositeLayer.ModelScales[0], compositeLayer.ModelRotations[0], compositeLayer.ModelTranslations[0], compositeLayer.CameraRotations[0], compositeLayer.CameraTranslations[0], compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
							Render.UPvr_SetOverlayModelViewMatrix((int)compositeLayer.overlayType, (int)compositeLayer.overlayShape, compositeLayer.layerTextureIds[1], 1, underlayLayerDepth, isHeadLocked: false, layerFlags, compositeLayer.MVMatrixs[1], compositeLayer.ModelScales[1], compositeLayer.ModelRotations[1], compositeLayer.ModelTranslations[1], compositeLayer.CameraRotations[1], compositeLayer.CameraTranslations[1], compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
							underlayLayerDepth++;
						}
					}
					else if (compositeLayer.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Equirect)
					{
						if (compositeLayer.isExternalAndroidSurface)
						{
							layerFlags |= 1;
							CreateExternalSurface(compositeLayer, 0);
						}
						Render.UPvr_SetupLayerData(0, 0, compositeLayer.layerTextureIds[0], (int)compositeLayer.overlayShape, layerFlags, compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
						Render.UPvr_SetupLayerData(0, 1, compositeLayer.layerTextureIds[1], (int)compositeLayer.overlayShape, layerFlags, compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
					}
				}
			}
			Pvr_UnitySDKAPI.System.UPvr_UnityEventData(Pvr_UnitySDKAPI.System.UPvr_GetEyeBufferData(0));
			Pvr_UnitySDKPluginEvent.Issue(RenderEventType.TimeWarp);
			Pvr_UnitySDKRender.Instance.currEyeTextureIdx = Pvr_UnitySDKRender.Instance.nextEyeTextureIdx;
			Pvr_UnitySDKRender.Instance.nextEyeTextureIdx = (Pvr_UnitySDKRender.Instance.nextEyeTextureIdx + 1) % 3;
		}
	}

	private void CreateExternalSurface(Pvr_UnitySDKEyeOverlay overlayInstance, int layerDepth)
	{
		if (overlayInstance.externalAndroidSurfaceObject == IntPtr.Zero)
		{
			overlayInstance.externalAndroidSurfaceObject = Render.UPvr_CreateLayerAndroidSurface((int)overlayInstance.overlayType, layerDepth);
			UnityEngine.Debug.LogFormat("CreateExternalSurface: Overlay Type:{0}, LayerDepth:{1}, SurfaceObject:{2}", overlayInstance.overlayType, layerDepth, overlayInstance.externalAndroidSurfaceObject);
			if (overlayInstance.externalAndroidSurfaceObject != IntPtr.Zero && overlayInstance.externalAndroidSurfaceObjectCreated != null)
			{
				overlayInstance.externalAndroidSurfaceObjectCreated();
			}
		}
	}

	public bool SetEyeTrackingMode()
	{
		supportEyeTracking = (Pvr_UnitySDKAPI.System.UPvr_GetTrackingMode() & 4) != 0;
		bool result = false;
		if (EyeTracking && supportEyeTracking)
		{
			result = Pvr_UnitySDKAPI.System.UPvr_setTrackingMode(6);
		}
		UnityEngine.Debug.Log("SetEyeTrackingMode EyeTracking " + EyeTracking + " supportEyeTracking " + supportEyeTracking + " result " + result);
		return result;
	}

	public Vector3 GetEyeTrackingPos()
	{
		if (!Instance.EyeTracking)
		{
			return Vector3.zero;
		}
		bool flag = Pvr_UnitySDKAPI.System.UPvr_getEyeTrackingData(ref eyePoseData);
		if (!flag)
		{
			PLOG.E("UPvr_getEyeTrackingData failed " + flag);
			return Vector3.zero;
		}
		EyeDeviceInfo deviceInfo = GetDeviceInfo();
		Vector3 zero = Vector3.zero;
		zero.x = 0.5f * (deviceInfo.targetFrustumLeft.right - deviceInfo.targetFrustumLeft.left);
		zero.y = 0.5f * (deviceInfo.targetFrustumLeft.top - deviceInfo.targetFrustumLeft.bottom);
		zero.z = deviceInfo.targetFrustumLeft.near;
		Vector3 foveatedGazeDirection = eyePoseData.foveatedGazeDirection;
		float num = Vector3.Dot(foveatedGazeDirection, Vector3.forward);
		if (num > float.Epsilon)
		{
			eyePoint = foveatedGazeDirection * (zero.z / num);
			eyePoint.x /= zero.x;
			eyePoint.y /= zero.y;
		}
		return eyePoint;
	}

	private EyeDeviceInfo GetDeviceInfo()
	{
		float num = Mathf.Tan(Pvr_UnitySDKRender.Instance.EyeVFoV / 2f * ((float)Math.PI / 180f));
		float num2 = Mathf.Tan(Pvr_UnitySDKRender.Instance.EyeHFoV / 2f * ((float)Math.PI / 180f));
		EyeDeviceInfo result = default(EyeDeviceInfo);
		result.targetFrustumLeft.left = 0f - LeftEyeCamera.nearClipPlane * num2;
		result.targetFrustumLeft.right = LeftEyeCamera.nearClipPlane * num2;
		result.targetFrustumLeft.top = LeftEyeCamera.nearClipPlane * num;
		result.targetFrustumLeft.bottom = 0f - LeftEyeCamera.nearClipPlane * num;
		result.targetFrustumLeft.near = LeftEyeCamera.nearClipPlane;
		result.targetFrustumLeft.far = LeftEyeCamera.farClipPlane;
		result.targetFrustumRight.left = 0f - RightEyeCamera.nearClipPlane * num2;
		result.targetFrustumRight.right = RightEyeCamera.nearClipPlane * num2;
		result.targetFrustumRight.top = RightEyeCamera.nearClipPlane * num;
		result.targetFrustumRight.bottom = 0f - RightEyeCamera.nearClipPlane * num;
		result.targetFrustumRight.near = RightEyeCamera.nearClipPlane;
		result.targetFrustumRight.far = RightEyeCamera.farClipPlane;
		return result;
	}

	private void CreateFadeMesh()
	{
		fadeMaterial = new Material(Shader.Find("Pvr_UnitySDK/Fade"));
		fadeMeshFilter = base.gameObject.AddComponent<MeshFilter>();
		fadeMeshRenderer = base.gameObject.AddComponent<MeshRenderer>();
		Mesh mesh = new Mesh();
		fadeMeshFilter.mesh = mesh;
		Vector3[] array = new Vector3[4];
		float num = 2f;
		float num2 = 2f;
		float z = 1f;
		array[0] = new Vector3(0f - num, 0f - num2, z);
		array[1] = new Vector3(num, 0f - num2, z);
		array[2] = new Vector3(0f - num, num2, z);
		array[3] = new Vector3(num, num2, z);
		mesh.vertices = array;
		mesh.triangles = new int[6] { 0, 2, 1, 2, 3, 1 };
		mesh.normals = new Vector3[4]
		{
			-Vector3.forward,
			-Vector3.forward,
			-Vector3.forward,
			-Vector3.forward
		};
		mesh.uv = new Vector2[4]
		{
			new Vector2(0f, 0f),
			new Vector2(1f, 0f),
			new Vector2(0f, 1f),
			new Vector2(1f, 1f)
		};
	}

	private void DestoryFadeMesh()
	{
		if (fadeMeshRenderer != null)
		{
			UnityEngine.Object.Destroy(fadeMeshRenderer);
		}
		if (fadeMaterial != null)
		{
			UnityEngine.Object.Destroy(fadeMaterial);
		}
		if (fadeMeshFilter != null)
		{
			UnityEngine.Object.Destroy(fadeMeshFilter);
		}
	}

	public void SetCurrentAlpha(float alpha)
	{
		currentAlpha = alpha;
		SetMaterialAlpha();
	}

	private IEnumerator ScreenFade(float startAlpha, float endAlpha)
	{
		float elapsedTime = 0f;
		while (elapsedTime < fadeTime)
		{
			elapsedTime += Time.deltaTime;
			nowFadeAlpha = Mathf.Lerp(startAlpha, endAlpha, Mathf.Clamp01(elapsedTime / fadeTime));
			SetMaterialAlpha();
			yield return new WaitForEndOfFrame();
		}
	}

	private void SetMaterialAlpha()
	{
		Color color = fadeColor;
		color.a = Mathf.Max(currentAlpha, nowFadeAlpha);
		isFading = color.a > 0f;
		if (fadeMaterial != null)
		{
			fadeMaterial.color = color;
			fadeMaterial.renderQueue = renderQueue;
			fadeMeshRenderer.material = fadeMaterial;
			fadeMeshRenderer.enabled = isFading;
		}
	}

	public bool GfxDeviceAdvanceFrameGLES()
	{
		return false;
	}
}
public class Pvr_UnitySDKEyeOverlay : MonoBehaviour, IComparable<Pvr_UnitySDKEyeOverlay>
{
	public delegate void ExternalAndroidSurfaceObjectCreated();

	public enum OverlayShape
	{
		Quad,
		Cylinder,
		Equirect
	}

	public enum OverlayType
	{
		Overlay,
		Underlay
	}

	public enum OverlayTexFilterMode
	{
		NotCare,
		Nearest,
		Linear,
		Nearest_Mipmap_Nearest,
		Linear_Mipmap_Nearest,
		Nearest_Mipmap_Linear,
		Linear_Mipmap_Linear
	}

	public static List<Pvr_UnitySDKEyeOverlay> Instances = new List<Pvr_UnitySDKEyeOverlay>();

	public int layerIndex;

	public OverlayType overlayType;

	public OverlayShape overlayShape;

	public Transform layerTransform;

	public Texture[] layerTextures = new Texture[2];

	public int[] layerTextureIds = new int[2];

	public Matrix4x4[] MVMatrixs = new Matrix4x4[2];

	public Vector3[] ModelScales = new Vector3[2];

	public Quaternion[] ModelRotations = new Quaternion[2];

	public Vector3[] ModelTranslations = new Vector3[2];

	public Quaternion[] CameraRotations = new Quaternion[2];

	public Vector3[] CameraTranslations = new Vector3[2];

	public Camera[] layerEyeCamera = new Camera[2];

	public bool overrideColorScaleAndOffset;

	public Vector4 colorScale = Vector4.one;

	public Vector4 colorOffset = Vector4.zero;

	private Vector4 overlayLayerColorScaleDefault = Vector4.one;

	private Vector4 overlayLayerColorOffsetDefault = Vector4.zero;

	public bool isExternalAndroidSurface;

	public IntPtr externalAndroidSurfaceObject = IntPtr.Zero;

	public ExternalAndroidSurfaceObjectCreated externalAndroidSurfaceObjectCreated;

	public int CompareTo(Pvr_UnitySDKEyeOverlay other)
	{
		return layerIndex.CompareTo(other.layerIndex);
	}

	private void Awake()
	{
		Instances.Add(this);
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
		}
		else if (Pvr_UnitySDKManager.SDK.Monoscopic)
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.MonoEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.MonoEyeCamera;
		}
		else
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.LeftEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.RightEyeCamera;
		}
		layerTransform = GetComponent<Transform>();
		if (layerTransform != null)
		{
			MeshRenderer component = layerTransform.GetComponent<MeshRenderer>();
			if (component != null)
			{
				component.enabled = false;
			}
		}
		InitializeBuffer();
	}

	private void LateUpdate()
	{
		UpdateCoords();
	}

	private void OnDestroy()
	{
		Instances.Remove(this);
	}

	public void RefreshCamera()
	{
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
		}
		else if (Pvr_UnitySDKManager.SDK.Monoscopic)
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.MonoEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.MonoEyeCamera;
		}
		else
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.LeftEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.RightEyeCamera;
		}
	}

	private void InitializeBuffer()
	{
		OverlayShape overlayShape = this.overlayShape;
		if ((uint)overlayShape > 2u)
		{
			return;
		}
		for (int i = 0; i < layerTextureIds.Length; i++)
		{
			if (layerTextures[i] != null)
			{
				layerTextureIds[i] = layerTextures[i].GetNativeTexturePtr().ToInt32();
			}
			else
			{
				UnityEngine.Debug.LogWarning($"{(Eye)i} Texture is null!");
			}
		}
	}

	private void UpdateCoords()
	{
		if (layerTransform == null || !layerTransform.gameObject.activeSelf || layerEyeCamera[0] == null || layerEyeCamera[1] == null)
		{
			return;
		}
		for (int i = 0; i < MVMatrixs.Length; i++)
		{
			if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
			{
				Matrix4x4[] stereoWorldToCameraMat = Pvr_UnitySDKSinglePass.GetStereoWorldToCameraMat();
				MVMatrixs[i] = stereoWorldToCameraMat[i] * layerTransform.localToWorldMatrix;
			}
			else
			{
				MVMatrixs[i] = layerEyeCamera[i].worldToCameraMatrix * layerTransform.localToWorldMatrix;
			}
			ModelScales[i] = layerTransform.localScale;
			ModelRotations[i] = layerTransform.rotation;
			ModelTranslations[i] = layerTransform.position;
			CameraRotations[i] = layerEyeCamera[i].transform.rotation;
			CameraTranslations[i] = layerEyeCamera[i].transform.position;
		}
	}

	public void SetTexture(Texture texture)
	{
		for (int i = 0; i < layerTextures.Length; i++)
		{
			layerTextures[i] = texture;
		}
		InitializeBuffer();
	}

	public void SetLayerColorScaleAndOffset(Vector4 scale, Vector4 offset)
	{
		colorScale = scale;
		colorOffset = offset;
	}

	public Vector4 GetLayerColorScale()
	{
		if (!overrideColorScaleAndOffset)
		{
			return overlayLayerColorScaleDefault;
		}
		return colorScale;
	}

	public Vector4 GetLayerColorOffset()
	{
		if (!overrideColorScaleAndOffset)
		{
			return overlayLayerColorOffsetDefault;
		}
		return colorOffset;
	}
}
public class Pvr_UnitySDKRender
{
	private static Pvr_UnitySDKRender instance;

	public AndroidJavaObject activity;

	public static AndroidJavaClass javaVrActivityClass;

	public static AndroidJavaClass javaSysActivityClass;

	public static AndroidJavaClass javaserviceClass;

	public static AndroidJavaClass javaVrActivityLongReceiver;

	public static AndroidJavaClass javaVrActivityClientClass;

	private bool canConnecttoActivity;

	private bool isInitrenderThread = true;

	private string model;

	private Vector2 prefinger1 = new Vector2(0f, 0f);

	private Vector2 prefinger2 = new Vector2(0f, 0f);

	public int eyeTextureCount = 6;

	public RenderTexture[] eyeTextures;

	public int[] eyeTextureIds;

	public int currEyeTextureIdx;

	public int nextEyeTextureIdx = 1;

	public int lastEyeTextureIdx;

	public bool isSwitchSDK;

	public int RenderviewNumber;

	public bool isFirstStartup = true;

	public bool isShellMode;

	private StereoRenderingPathPico stereoRenderPath;

	private float rtScaleFactor = 1f;

	private float eyeVFov = 90f;

	private float eyeHFov = 90f;

	public static Pvr_UnitySDKRender Instance
	{
		get
		{
			if (instance == null)
			{
				instance = new Pvr_UnitySDKRender();
			}
			return instance;
		}
		set
		{
			instance = value;
		}
	}

	public StereoRenderingPathPico StereoRenderPath => stereoRenderPath;

	public SDKStereoRendering StereoRendering { get; private set; }

	public float RtScaleFactor
	{
		get
		{
			return rtScaleFactor;
		}
		set
		{
			if (value != rtScaleFactor)
			{
				rtScaleFactor = value;
				ReCreateEyeBuffer();
			}
		}
	}

	public float EyeVFoV
	{
		get
		{
			return eyeVFov;
		}
		set
		{
			if (value != eyeVFov)
			{
				eyeVFov = value;
			}
		}
	}

	public float EyeHFoV
	{
		get
		{
			return eyeHFov;
		}
		set
		{
			if (value != eyeHFov)
			{
				eyeHFov = value;
			}
		}
	}

	public Pvr_UnitySDKRender()
	{
		if (!canConnecttoActivity)
		{
			ConnectToAndriod();
			PLOG.I("PvrLog Init Render Ability Success!");
			isInitrenderThread = false;
		}
		Init();
	}

	public void ConnectToAndriod()
	{
		try
		{
			UnityEngine.Debug.Log("PvrLog SDK Version :  " + Pvr_UnitySDKAPI.System.UPvr_GetSDKVersion().ToString() + "  Unity Script Version :" + Pvr_UnitySDKAPI.System.UPvr_GetUnitySDKVersion().ToString());
			AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
			activity = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
			javaVrActivityClass = new AndroidJavaClass("com.psmart.vrlib.VrActivity");
			javaserviceClass = new AndroidJavaClass("com.picovr.picovrlib.hummingbirdclient.UnityClient");
			javaVrActivityLongReceiver = new AndroidJavaClass("com.psmart.vrlib.HomeKeyReceiver");
			javaSysActivityClass = new AndroidJavaClass("com.psmart.aosoperation.SysActivity");
			javaVrActivityClientClass = new AndroidJavaClass("com.psmart.vrlib.PvrClient");
			Pvr_UnitySDKAPI.System.Pvr_SetInitActivity(activity.GetRawObject(), javaVrActivityClass.GetRawClass());
			model = javaVrActivityClass.CallStatic<string>("Pvr_GetBuildModel", Array.Empty<object>());
			double[] result = new double[5];
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaVrActivityClass, "getDPIParameters", activity);
			int res = -1;
			Render.UPvr_GetIntConfig(4, ref res);
			string result2 = "";
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result2, javaserviceClass, "getSysproc", "persist.pvr.debug.appfps");
			if (result2 != "")
			{
				Pvr_UnitySDKManager.SDK.systemFPS = Convert.ToBoolean(Convert.ToInt16(result2));
			}
			if (res == 0)
			{
				Render.UPvr_ChangeScreenParameters(model, (int)result[0], (int)result[1], result[2], result[3], result[4]);
				Screen.sleepTimeout = -1;
			}
			if (Pvr_UnitySDKAPI.System.UPvr_IsPicoActivity())
			{
				UnityEngine.Debug.Log("ConnectToAndriod set monoPresentation success ?-------------" + Pvr_UnitySDKAPI.System.UPvr_SetMonoPresentation());
				UnityEngine.Debug.Log("ConnectToAndriod presentation existed ?-------------" + Pvr_UnitySDKAPI.System.UPvr_IsPresentationExisted());
			}
			isShellMode = GetIsShellMode();
			UnityEngine.Debug.Log("ConnectToAndriod isShellMode ?-------------" + isShellMode);
		}
		catch (AndroidJavaException ex)
		{
			PLOG.E("ConnectToAndriod--catch" + ex.Message);
		}
		canConnecttoActivity = true;
	}

	public void Init()
	{
		if (InitRenderAbility())
		{
			UnityEngine.Debug.Log("PvrLog Init Render Ability Success!");
			isInitrenderThread = false;
		}
		else
		{
			UnityEngine.Debug.Log("PvrLog Init Render Ability Failed!");
		}
	}

	private bool InitRenderAbility()
	{
		if (UpdateRenderParaFrame() && CreateEyeBuffer())
		{
			float num = Pvr_UnitySDKAPI.System.UPvr_GetIPD();
			Pvr_UnitySDKManager.SDK.leftEyeOffset = new Vector3((0f - num) / 2f, 0f, 0f);
			Pvr_UnitySDKManager.SDK.rightEyeOffset = new Vector3(num / 2f, 0f, 0f);
			return true;
		}
		return false;
	}

	private bool UpdateRenderParaFrame()
	{
		EyeVFoV = GetEyeVFOV();
		EyeHFoV = GetEyeHFOV();
		Pvr_UnitySDKManager.SDK.EyesAspect = EyeHFoV / EyeVFoV;
		return true;
	}

	private bool CreateEyeBuffer()
	{
		Vector2 eyeBufferResolution = GetEyeBufferResolution();
		if (isFirstStartup)
		{
			InitSinglePass();
			Pvr_UnitySDKAPI.System.UPvr_SetSinglePassDepthBufferWidthHeight((int)eyeBufferResolution.x, (int)eyeBufferResolution.y);
		}
		eyeTextures = new RenderTexture[eyeTextureCount];
		eyeTextureIds = new int[eyeTextureCount];
		for (int i = 0; i < eyeTextureCount; i++)
		{
			if (null == eyeTextures[i])
			{
				try
				{
					ConfigureEyeBuffer(i, eyeBufferResolution);
				}
				catch (Exception ex)
				{
					PLOG.E("ConfigureEyeBuffer ERROR " + ex.Message);
					throw;
				}
			}
			if (!eyeTextures[i].IsCreated())
			{
				eyeTextures[i].Create();
				eyeTextureIds[i] = eyeTextures[i].GetNativeTexturePtr().ToInt32();
			}
			eyeTextureIds[i] = eyeTextures[i].GetNativeTexturePtr().ToInt32();
		}
		return true;
	}

	private void InitSinglePass()
	{
		bool flag = true;
		if (GraphicsSettings.renderPipelineAsset != null)
		{
			flag = false;
			if (!BoundarySystem.UPvr_EnableLWRP(enable: true))
			{
				UnityEngine.Debug.Log("UPvr_EnableLWRP return false");
			}
			Vector2 eyeBufferResolution = GetEyeBufferResolution();
			if (!BoundarySystem.UPvr_SetViewportSize((int)eyeBufferResolution.x, (int)eyeBufferResolution.y))
			{
				UnityEngine.Debug.Log("UPvr_SetViewportSize return false");
			}
		}
		if (Pvr_UnitySDKProjectSetting.GetProjectConfig().usesinglepass)
		{
			bool flag2 = false;
			if (flag)
			{
				flag2 = Pvr_UnitySDKAPI.System.UPvr_EnableSinglePass(enable: true);
			}
			if (flag2)
			{
				StereoRendering = new Pvr_UnitySDKSinglePass();
				stereoRenderPath = StereoRenderingPathPico.SinglePass;
				eyeTextureCount = 3;
			}
			UnityEngine.Debug.Log("EnableSinglePass supportSinglePass " + flag + " result " + flag2);
		}
	}

	public float GetEyeVFOV()
	{
		float res = 102f;
		try
		{
			Render.UPvr_GetFloatConfig(1, ref res);
			if (res <= 0f)
			{
				res = 102f;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("GetEyeVFOV ERROR! " + ex.Message);
			throw;
		}
		return res;
	}

	public float GetEyeHFOV()
	{
		float res = 102f;
		try
		{
			Render.UPvr_GetFloatConfig(2, ref res);
			if (res <= 0f)
			{
				res = 102f;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("GetEyeHFOV ERROR! " + ex.Message);
			throw;
		}
		return res;
	}

	private void ConfigureEyeBuffer(int eyeTextureIndex, Vector2 resolution)
	{
		int width = (int)resolution.x;
		int height = (int)resolution.y;
		eyeTextures[eyeTextureIndex] = new RenderTexture(width, height, (int)Pvr_UnitySDKProjectSetting.GetProjectConfig().rtBitDepth, Pvr_UnitySDKProjectSetting.GetProjectConfig().rtFormat);
		if (StereoRenderPath == StereoRenderingPathPico.MultiPass)
		{
			eyeTextures[eyeTextureIndex].anisoLevel = 0;
			eyeTextures[eyeTextureIndex].antiAliasing = Mathf.Max(QualitySettings.antiAliasing, (int)Pvr_UnitySDKProjectSetting.GetProjectConfig().rtAntiAlising);
			UnityEngine.Debug.Log("MultiPass ConfigureEyeBuffer eyeTextureIndex " + eyeTextureIndex);
		}
		else if (StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			eyeTextures[eyeTextureIndex].useMipMap = false;
			eyeTextures[eyeTextureIndex].wrapMode = TextureWrapMode.Clamp;
			eyeTextures[eyeTextureIndex].filterMode = FilterMode.Bilinear;
			eyeTextures[eyeTextureIndex].anisoLevel = 1;
			eyeTextures[eyeTextureIndex].dimension = TextureDimension.Tex2DArray;
			eyeTextures[eyeTextureIndex].volumeDepth = 2;
			UnityEngine.Debug.Log("SinglePass ConfigureEyeBuffer eyeTextureIndex " + eyeTextureIndex);
		}
		eyeTextures[eyeTextureIndex].Create();
		if (eyeTextures[eyeTextureIndex].IsCreated())
		{
			eyeTextureIds[eyeTextureIndex] = eyeTextures[eyeTextureIndex].GetNativeTexturePtr().ToInt32();
			UnityEngine.Debug.Log("eyeTextureIndex : " + eyeTextureIndex);
		}
	}

	public bool ReCreateEyeBuffer()
	{
		if (!Pvr_UnitySDKProjectSetting.GetProjectConfig().usedefaultRenderTexture)
		{
			for (int i = 0; i < eyeTextureCount; i++)
			{
				if (eyeTextures[i] != null)
				{
					eyeTextures[i].Release();
				}
			}
			Array.Clear(eyeTextures, 0, eyeTextures.Length);
			return CreateEyeBuffer();
		}
		return false;
	}

	public void ReInit()
	{
		if (canConnecttoActivity && isInitrenderThread)
		{
			Init();
		}
	}

	public void IssueRenderThread()
	{
		if (canConnecttoActivity && !isInitrenderThread)
		{
			switch (QualitySettings.activeColorSpace)
			{
			case ColorSpace.Gamma:
				Render.UPvr_SetColorspaceType(0);
				break;
			case ColorSpace.Linear:
				Render.UPvr_SetColorspaceType(1);
				break;
			}
			Pvr_UnitySDKPluginEvent.Issue(RenderEventType.InitRenderThread);
			isInitrenderThread = true;
			if (StereoRendering != null)
			{
				StereoRendering.OnSDKRenderInited();
			}
			UnityEngine.Debug.Log("PvrLog IssueRenderThread end");
		}
		else
		{
			PLOG.I("PvrLog IssueRenderThread  canConnecttoActivity = " + canConnecttoActivity);
		}
	}

	private void AutoAdpatForPico1s()
	{
		Vector2 position = Input.touches[0].position;
		Vector2 position2 = Input.touches[1].position;
		if (Vector2.Distance(prefinger1, position) > 2f && Vector2.Distance(prefinger2, position2) > 2f)
		{
			float midH = (Input.touches[0].position.x + Input.touches[1].position.x) / (float)Screen.width - 1f;
			float midV = (Input.touches[0].position.y + Input.touches[1].position.y) / (float)Screen.height - 1f;
			Render.UPvr_SetRatio(midH, midV);
		}
		prefinger1 = position;
		prefinger2 = position2;
	}

	public Vector2 GetEyeBufferResolution()
	{
		int res = 1024;
		int res2 = 1024;
		if (Pvr_UnitySDKProjectSetting.GetProjectConfig().usedefaultRenderTexture)
		{
			try
			{
				Render.UPvr_GetIntConfig(0, ref res);
				Render.UPvr_GetIntConfig(1, ref res2);
			}
			catch (Exception ex)
			{
				PLOG.E("GetEyeBufferResolution ERROR! " + ex.Message);
				throw;
			}
		}
		else
		{
			res = (int)(Pvr_UnitySDKProjectSetting.GetProjectConfig().customRTSize.x * RtScaleFactor);
			res2 = (int)(Pvr_UnitySDKProjectSetting.GetProjectConfig().customRTSize.y * RtScaleFactor);
		}
		Vector2 vector = new Vector2(res, res2);
		UnityEngine.Debug.Log(string.Concat("DISFT Customize RenderTexture:", vector, ", scaleFactor: ", RtScaleFactor));
		return vector;
	}

	public bool GetUsePredictedMatrix()
	{
		return true;
	}

	public bool GetIsShellMode()
	{
		if (activity == null)
		{
			return false;
		}
		using (AndroidJavaObject androidJavaObject = activity.Call<AndroidJavaObject>("getPackageManager", Array.Empty<object>()).Call<AndroidJavaObject>("getApplicationInfo", new object[2]
		{
			activity.Call<string>("getPackageName", Array.Empty<object>()),
			128
		}))
		{
			AndroidJavaObject androidJavaObject2 = androidJavaObject.Get<AndroidJavaObject>("metaData");
			if (androidJavaObject2 != null)
			{
				if (androidJavaObject2.Call<int>("getInt", new object[1] { "shell_mode" }) == 1)
				{
					return true;
				}
				return false;
			}
		}
		return false;
	}
}
public class Pvr_UnitySDKSinglePass : SDKStereoRendering
{
	private static Camera bothCamera;

	private Matrix4x4[] unity_StereoMatrixP = new Matrix4x4[2];

	private Matrix4x4[] unity_StereoMatrixInvP = new Matrix4x4[2];

	private static Matrix4x4[] unity_StereoWorldToCamera = new Matrix4x4[2];

	private Matrix4x4[] unity_StereoCameraToWorld = new Matrix4x4[2];

	private Matrix4x4[] unity_StereoMatrixVP = new Matrix4x4[2];

	private Vector3[] eyesOffset = new Vector3[2];

	private static Matrix4x4[] eyesOffsetMatrix = new Matrix4x4[2];

	private CommandBuffer commandBufferBeforeForwardOpaque;

	private CommandBuffer commandBufferBeforeSkybox;

	private CommandBuffer commandBufferAfterSkybox;

	public override void InitEye(Camera eye)
	{
		bothCamera = eye;
		bothCamera.stereoSeparation = 0.0625f;
		bothCamera.stereoConvergence = 0f;
		bothCamera.allowHDR = false;
		bothCamera.allowDynamicResolution = false;
		SetEyesPosition();
		SetEyeProjection();
		Pvr_UnitySDKSensor.EyeFovChanged = (Action)Delegate.Combine(Pvr_UnitySDKSensor.EyeFovChanged, new Action(SetEyeProjection));
		UnityEngine.Debug.Log("SinglePass Init success! CameraName = " + eye.transform.name + " eye.eyeSide " + eye.GetComponent<Pvr_UnitySDKEye>().eyeSide);
	}

	public override void OnSDKRenderInited()
	{
		OnSDKRenderInited_SinglePass();
	}

	public override void OnSDKPreRender()
	{
		SinglePassPreRender();
	}

	public override void OnSDKPostRender()
	{
		SwitchKeywordAndDeviceView(enable: false);
	}

	public void OnSDKRenderInited_SinglePass()
	{
		Shader.SetGlobalVectorArray("unity_StereoScaleOffset", new Vector4[2]
		{
			new Vector4(1f, 1f, 0f, 0f),
			new Vector4(1f, 1f, 0.5f, 0f)
		});
		SetAntiAliasing();
		UnityEngine.Debug.Log("OnSDKRenderInited_SinglePass");
	}

	private void SetAntiAliasing()
	{
		int num = Mathf.Max(QualitySettings.antiAliasing, (int)Pvr_UnitySDKProjectSetting.GetProjectConfig().rtAntiAlising);
		Pvr_UnitySDKAPI.System.UPvr_SetAntiAliasing(num);
		UnityEngine.Debug.Log("SetAntiAliasing  antiAliasing = " + num);
	}

	public void SetEyesPosition()
	{
		float res = 0.0625f;
		int configsenum = 0;
		if (Render.UPvr_GetFloatConfig(configsenum, ref res) != 0)
		{
			PLOG.E("Cannot get ipd");
			res = 0.0625f;
		}
		bothCamera.stereoSeparation = res;
		Vector3 vector = new Vector3((0f - res) / 2f, 0f, 0f);
		Vector3 vector2 = new Vector3(res / 2f, 0f, 0f);
		Vector3 vector3 = (vector + vector2) / 2f;
		bothCamera.transform.localPosition = vector3;
		bothCamera.transform.localRotation = Quaternion.identity;
		Vector3 vector4 = vector - vector3;
		Vector3 vector5 = vector2 - vector3;
		eyesOffset[0] = vector4;
		eyesOffset[1] = vector5;
		eyesOffsetMatrix[0] = Matrix4x4.TRS(vector4, Quaternion.identity, Vector3.one);
		eyesOffsetMatrix[1] = Matrix4x4.TRS(vector5, Quaternion.identity, Vector3.one);
	}

	public void SetEyeProjection()
	{
		Matrix4x4 projection = GetProjection(bothCamera.nearClipPlane, bothCamera.farClipPlane);
		Matrix4x4 projection2 = GetProjection(bothCamera.nearClipPlane, bothCamera.farClipPlane);
		SetStereoProjectionMatrix(projection, projection2);
	}

	private static Matrix4x4 GetProjection(float near, float far)
	{
		if (near < 0.01f)
		{
			near = 0.01f;
		}
		if (far < 0.02f)
		{
			far = 0.02f;
		}
		_ = Matrix4x4.identity;
		return MakeProjection(near, far);
	}

	public static Matrix4x4 MakeProjection(float n, float f)
	{
		Vector2 eyeBufferResolution = Pvr_UnitySDKRender.Instance.GetEyeBufferResolution();
		float num = Mathf.Tan(Pvr_UnitySDKRender.Instance.EyeVFoV / 2f * ((float)Math.PI / 180f));
		float num2 = 1f / num;
		Matrix4x4 zero = Matrix4x4.zero;
		zero[0, 0] = num2 / (eyeBufferResolution.x / eyeBufferResolution.y);
		zero[1, 1] = num2;
		zero[2, 2] = (0f - (f + n)) / (f - n);
		zero[2, 3] = -2f * f * n / (f - n);
		zero[3, 2] = -1f;
		return zero;
	}

	public void SetStereoProjectionMatrix(Matrix4x4 left, Matrix4x4 right)
	{
		unity_StereoMatrixP[0] = left;
		unity_StereoMatrixInvP[0] = left.inverse;
		unity_StereoMatrixP[1] = right;
		unity_StereoMatrixInvP[1] = right.inverse;
	}

	private void SwitchKeywordAndDeviceView(bool enable)
	{
		if (enable)
		{
			Shader.EnableKeyword("STEREO_MULTIVIEW_ON");
			Shader.EnableKeyword("UNITY_SINGLE_PASS_STEREO");
			XRSettings.showDeviceView = false;
		}
		else
		{
			XRSettings.showDeviceView = true;
			Shader.DisableKeyword("UNITY_SINGLE_PASS_STEREO");
			Shader.DisableKeyword("STEREO_MULTIVIEW_ON");
		}
	}

	public static Matrix4x4[] GetStereoWorldToCameraMat()
	{
		Matrix4x4 worldToCameraMatrix = bothCamera.worldToCameraMatrix;
		unity_StereoWorldToCamera[0] = eyesOffsetMatrix[0].inverse * worldToCameraMatrix;
		unity_StereoWorldToCamera[1] = eyesOffsetMatrix[1].inverse * worldToCameraMatrix;
		return unity_StereoWorldToCamera;
	}

	public void SinglePassPreRender()
	{
		SwitchKeywordAndDeviceView(enable: true);
		Shader.SetGlobalMatrixArray("unity_StereoCameraProjection", unity_StereoMatrixP);
		Shader.SetGlobalMatrixArray("unity_StereoCameraInvProjection", unity_StereoMatrixInvP);
		Shader.SetGlobalMatrixArray("unity_StereoMatrixP", unity_StereoMatrixP);
		Matrix4x4 worldToCameraMatrix = bothCamera.worldToCameraMatrix;
		Matrix4x4 cameraToWorldMatrix = bothCamera.cameraToWorldMatrix;
		unity_StereoCameraToWorld[0] = cameraToWorldMatrix * eyesOffsetMatrix[0];
		unity_StereoCameraToWorld[1] = cameraToWorldMatrix * eyesOffsetMatrix[1];
		Shader.SetGlobalMatrixArray("unity_StereoCameraToWorld", unity_StereoCameraToWorld);
		unity_StereoWorldToCamera[0] = eyesOffsetMatrix[0].inverse * worldToCameraMatrix;
		unity_StereoWorldToCamera[1] = eyesOffsetMatrix[1].inverse * worldToCameraMatrix;
		Shader.SetGlobalMatrixArray("unity_StereoWorldToCamera", unity_StereoWorldToCamera);
		Vector4[] values = new Vector4[2]
		{
			bothCamera.transform.position + eyesOffset[0],
			bothCamera.transform.position + eyesOffset[1]
		};
		Shader.SetGlobalVectorArray("unity_StereoWorldSpaceCameraPos", values);
		Shader.SetGlobalMatrixArray("unity_StereoMatrixV", unity_StereoWorldToCamera);
		Shader.SetGlobalMatrixArray("unity_StereoMatrixInvV", unity_StereoCameraToWorld);
		unity_StereoMatrixVP[0] = unity_StereoMatrixP[0] * unity_StereoWorldToCamera[0];
		unity_StereoMatrixVP[1] = unity_StereoMatrixP[1] * unity_StereoWorldToCamera[1];
		Shader.SetGlobalMatrixArray("unity_StereoMatrixVP", unity_StereoMatrixVP);
		SetRenderTextureWithDepth();
		SetCommandBuffers();
	}

	private void SetCommandBuffers()
	{
		if (commandBufferBeforeForwardOpaque == null)
		{
			commandBufferBeforeForwardOpaque = new CommandBuffer();
			Pvr_UnitySDKPluginEvent.SetSinglePassBeforeForwardOpaque(commandBufferBeforeForwardOpaque);
			commandBufferBeforeForwardOpaque.ClearRenderTarget(clearDepth: true, clearColor: true, bothCamera.backgroundColor);
			commandBufferBeforeForwardOpaque.name = "SinglePassPrepare";
		}
		bothCamera.RemoveCommandBuffer(CameraEvent.BeforeForwardOpaque, commandBufferBeforeForwardOpaque);
		bothCamera.AddCommandBuffer(CameraEvent.BeforeForwardOpaque, commandBufferBeforeForwardOpaque);
		if (commandBufferAfterSkybox == null)
		{
			commandBufferAfterSkybox = new CommandBuffer();
		}
		bothCamera.RemoveCommandBuffer(CameraEvent.AfterSkybox, commandBufferAfterSkybox);
		commandBufferAfterSkybox.Clear();
		commandBufferAfterSkybox.SetGlobalMatrixArray("unity_StereoMatrixVP", unity_StereoMatrixVP);
		commandBufferAfterSkybox.name = "SinglePassAfterSkyBox";
		bothCamera.AddCommandBuffer(CameraEvent.AfterSkybox, commandBufferAfterSkybox);
		if (commandBufferBeforeSkybox == null)
		{
			commandBufferBeforeSkybox = new CommandBuffer();
		}
		Matrix4x4 transpose = (Matrix4x4.LookAt(Vector3.zero, bothCamera.transform.forward, bothCamera.transform.up) * Matrix4x4.Scale(new Vector3(1f, 1f, -1f))).transpose;
		Matrix4x4 matrix4x = unity_StereoMatrixP[0];
		Matrix4x4 matrix4x2 = unity_StereoMatrixP[1];
		matrix4x.m22 = -1f;
		matrix4x2.m22 = -1f;
		Matrix4x4[] values = new Matrix4x4[2]
		{
			matrix4x * transpose,
			matrix4x2 * transpose
		};
		bothCamera.RemoveCommandBuffer(CameraEvent.BeforeSkybox, commandBufferBeforeSkybox);
		commandBufferBeforeSkybox.Clear();
		commandBufferBeforeSkybox.SetGlobalMatrixArray("unity_StereoMatrixVP", values);
		commandBufferBeforeSkybox.name = "SinglePassAfterSkybox";
		bothCamera.AddCommandBuffer(CameraEvent.BeforeSkybox, commandBufferBeforeSkybox);
	}

	private void SetRenderTextureWithDepth()
	{
		Pvr_UnitySDKAPI.System.UPvr_SetCurrentRenderTexture((uint)Pvr_UnitySDKRender.Instance.eyeTextureIds[Pvr_UnitySDKRender.Instance.currEyeTextureIdx]);
	}
}
public abstract class SDKStereoRendering
{
	public abstract void InitEye(Camera eye);

	public abstract void OnSDKRenderInited();

	public abstract void OnSDKPreRender();

	public abstract void OnSDKPostRender();
}
public class HighlightAtGaze : MonoBehaviour
{
	public Color HighlightColor = Color.red;

	public float AnimationTime = 0.1f;

	private Renderer myRenderer;

	private Color originalColor;

	private Color targetColor;

	private EyeTrackingGazeRay gazeRay;

	private void Start()
	{
		myRenderer = GetComponent<Renderer>();
		originalColor = myRenderer.material.color;
		targetColor = originalColor;
	}

	private void Update()
	{
		Pvr_UnitySDKAPI.System.UPvr_getEyeTrackingGazeRay(ref gazeRay);
		if (Physics.Raycast(new Ray(gazeRay.Origin, gazeRay.Direction), out var hitInfo))
		{
			if (hitInfo.transform.name == base.transform.name)
			{
				if (targetColor != HighlightColor)
				{
					targetColor = HighlightColor;
				}
			}
			else if (targetColor != originalColor)
			{
				targetColor = originalColor;
			}
		}
		else if (targetColor != originalColor)
		{
			targetColor = originalColor;
		}
		myRenderer.material.color = Color.Lerp(myRenderer.material.color, targetColor, Time.deltaTime * (1f / AnimationTime));
	}
}
public class RayVisualizer : MonoBehaviour
{
	private LineRenderer _line;

	private EyeTrackingGazeRay gazeRay;

	private void Start()
	{
		_line = base.gameObject.GetComponent<LineRenderer>();
		_line.startWidth = 0.002f;
		_line.endWidth = 0.002f;
	}

	private void Update()
	{
		Matrix4x4 matrix = Pvr_UnitySDKSensor.Instance.HeadPose.Matrix;
		Pvr_UnitySDKAPI.System.UPvr_getEyeTrackingGazeRay(ref gazeRay);
		_line.SetPosition(0, matrix.MultiplyPoint(new Vector3(0f, -0.05f, 0.2f)));
		_line.SetPosition(1, gazeRay.Origin + gazeRay.Direction * 20f);
	}
}
public class GetSeeThroughImage : MonoBehaviour
{
	public RawImage viewImage_left;

	public RawImage viewImage_right;

	private int width;

	private int height;

	private RenderTexture cameraTex_left;

	private RenderTexture cameraTex_right;

	private bool cameraPreview;

	private void Start()
	{
		CreateTexture();
	}

	private void Update()
	{
		if (Input.GetKey(KeyCode.JoystickButton0))
		{
			DrawTexture();
		}
	}

	private void OnDestory()
	{
		if (cameraPreview)
		{
			cameraPreview = false;
			BoundarySystem.UPvr_StopCameraFrame();
		}
	}

	private void CreateTexture()
	{
		width = 600;
		height = 600;
		BoundarySystem.UPvr_BoundarySetCameraImageRect(width, height);
		cameraTex_left = new RenderTexture(width, height, 24, RenderTextureFormat.Default);
		cameraTex_right = new RenderTexture(width, height, 24, RenderTextureFormat.Default);
		cameraTex_left.Create();
		cameraTex_right.Create();
		viewImage_left.texture = cameraTex_left;
		viewImage_right.texture = cameraTex_right;
	}

	private void DrawTexture()
	{
		if (!cameraPreview)
		{
			cameraPreview = true;
			BoundarySystem.UPvr_StartCameraFrame();
		}
		BoundarySystem.UPvr_BoundaryGetSeeThroughData(0, cameraTex_left);
		BoundarySystem.UPvr_BoundaryGetSeeThroughData(1, cameraTex_right);
	}
}
public class OverlayExternalSurfaceDemo : MonoBehaviour
{
	public string movieName;

	public Pvr_UnitySDKEyeOverlay.OverlayType overlayType;

	public Pvr_UnitySDKEyeOverlay.OverlayShape overlayShape;

	private Pvr_UnitySDKEyeOverlay overlay;

	private const string TAG = "[ExternalSurface]>>>>>>";

	private void Awake()
	{
		overlay = GetComponent<Pvr_UnitySDKEyeOverlay>();
		if (overlay == null)
		{
			UnityEngine.Debug.LogError("[ExternalSurface]>>>>>>Overlay is null!");
			overlay = base.gameObject.AddComponent<Pvr_UnitySDKEyeOverlay>();
		}
		overlay.overlayType = overlayType;
		overlay.overlayShape = overlayShape;
		overlay.isExternalAndroidSurface = true;
	}

	private void Start()
	{
		if (!string.IsNullOrEmpty(movieName))
		{
			StartPlay(UnityEngine.Application.streamingAssetsPath + "/" + movieName, null);
		}
	}

	private void StartPlay(string moviePath, string licenceUrl)
	{
		if (moviePath != string.Empty)
		{
			if (overlay.isExternalAndroidSurface)
			{
				Pvr_UnitySDKEyeOverlay.ExternalAndroidSurfaceObjectCreated externalAndroidSurfaceObjectCreated = delegate
				{
					UnityEngine.Debug.Log("[ExternalSurface]>>>>>>SurfaceObject created callback is Invoke().");
				};
				if (overlay.externalAndroidSurfaceObject == IntPtr.Zero)
				{
					UnityEngine.Debug.Log("[ExternalSurface]>>>>>>Register surfaceObject crreated callback");
					overlay.externalAndroidSurfaceObjectCreated = externalAndroidSurfaceObjectCreated;
				}
				else
				{
					UnityEngine.Debug.Log("[ExternalSurface]>>>>>>SurfaceObject is already created! Invoke callback");
					externalAndroidSurfaceObjectCreated();
				}
			}
		}
		else
		{
			UnityEngine.Debug.LogError("[ExternalSurface]>>>>>>Movie path is null!");
		}
	}
}
public class MoveCylinder : MonoBehaviour
{
	private Vector3 startingPosition;

	private Quaternion startingRotation;

	private void Start()
	{
		startingPosition = base.transform.localPosition;
		startingRotation = base.transform.rotation;
	}

	public void Reset()
	{
		base.transform.localPosition = startingPosition;
		base.transform.rotation = startingRotation;
	}
}
[RequireComponent(typeof(Collider))]
public class MoveSphere : MonoBehaviour
{
	private Vector3 startingPosition;

	private void Start()
	{
		startingPosition = base.transform.localPosition;
		SetGazedAt(gazedAt: false);
		base.gameObject.GetComponent<Rigidbody>().AddForce(Vector3.right * 120f);
	}

	private void OnTriggerEnter(Collider other)
	{
	}

	public void SetGazedAt(bool gazedAt)
	{
		GetComponent<Renderer>().material.color = (gazedAt ? Color.yellow : Color.blue);
	}

	public void Reset()
	{
		base.transform.localPosition = startingPosition;
		SetGazedAt(gazedAt: false);
		base.gameObject.GetComponent<Rigidbody>().Sleep();
		base.gameObject.GetComponent<Rigidbody>().AddForce(Vector3.right * 120f);
	}

	public void TeleportRandomly()
	{
		Vector3 onUnitSphere = UnityEngine.Random.onUnitSphere;
		onUnitSphere.y = Mathf.Clamp(onUnitSphere.y, 0.5f, 1f);
		float num = 2f * UnityEngine.Random.value + 1.5f;
		base.transform.localPosition = onUnitSphere * num;
	}
}
public class Resetbutton : MonoBehaviour
{
	public void DemoResetTracking()
	{
		if (Pvr_UnitySDKSensor.Instance != null)
		{
			Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
		}
	}
}
public class UserEntitlementCheck : MonoBehaviour
{
	private void OnEnable()
	{
		Pvr_UnitySDKManager.EntitlementCheckResultEvent += HandelEntitlementCheckResult;
	}

	private void OnDisable()
	{
		Pvr_UnitySDKManager.EntitlementCheckResultEvent -= HandelEntitlementCheckResult;
	}

	private void HandelEntitlementCheckResult(int resultCode)
	{
		UnityEngine.Debug.Log("The User Entitlement Check Result is :" + resultCode);
		switch (resultCode)
		{
		case 0:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: success");
			break;
		case -1:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: invalid params");
			StartCoroutine(QuitGame("Entitlement check failed", ": -1"));
			break;
		case -2:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: service not exist");
			StartCoroutine(QuitGame("Entitlement check failed", ": -2"));
			break;
		case -3:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: bind failed");
			StartCoroutine(QuitGame("Entitlement check failed", ": -3"));
			break;
		case -4:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: exception");
			StartCoroutine(QuitGame("Entitlement check failed", ": -4"));
			break;
		case -5:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: timeout");
			StartCoroutine(QuitGame("Entitlement check failed", ": -5"));
			break;
		case 10:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: missing package name");
			StartCoroutine(QuitGame("Entitlement check failed", ": 10"));
			break;
		case 11:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: missing appid");
			StartCoroutine(QuitGame("Entitlement check failed", ": 11"));
			break;
		case 13:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: appid and package name not match");
			break;
		case 20:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: not login");
			StartCoroutine(QuitGame("Entitlement check failed", ": 20"));
			break;
		case 21:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: not pay");
			StartCoroutine(QuitGame("Entitlement check failed", ": 21"));
			break;
		case 31:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: invalid sn");
			StartCoroutine(QuitGame("Entitlement check failed", ": 31"));
			break;
		default:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: unknown");
			StartCoroutine(QuitGame("Entitlement check failed", ""));
			break;
		}
	}

	private IEnumerator QuitGame(string s1, string s2)
	{
		UnityEngine.Debug.Log("Quitting game due to failed Entitlement Check");
		yield return new WaitForSeconds(2f);
		Notification.instance.AddNotification(s1, s2, 0f, closeButton: true);
		yield return new WaitForSeconds(8f);
		UnityEngine.Application.Quit();
	}
}
public class Pvr_SQPLoader : MonoBehaviour
{
	private struct SceneInfo
	{
		public List<string> scenes;

		public long version;

		public SceneInfo(List<string> sceneList, long currentSceneEpochVersion)
		{
			scenes = sceneList;
			version = currentSceneEpochVersion;
		}
	}

	public const string RESOURCE_BUNDLE_NAME = "asset_resources";

	public const string EXTERNAL_STORAGE_PATH = "/sdcard/Android/data";

	public const string SCENE_LOAD_DATA_NAME = "SceneLoadData.txt";

	private const string SQP_INDEX_NAME = "PvrSQPIndex";

	private const string CACHE_SCENES_PATH = "cache/scenes";

	private UnityEngine.AsyncOperation loadSceneOperation;

	private string scenePath = "";

	private string sceneLoadDataPath = "";

	private List<AssetBundle> loadedAssetBundles = new List<AssetBundle>();

	private SceneInfo currentSceneInfo;

	private void Awake()
	{
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
	}

	private void Start()
	{
		string path = Path.Combine("/sdcard/Android/data", UnityEngine.Application.identifier);
		scenePath = Path.Combine(path, "cache/scenes");
		sceneLoadDataPath = Path.Combine(scenePath, "SceneLoadData.txt");
		currentSceneInfo = GetSceneInfo();
		if (currentSceneInfo.version != 0L && !string.IsNullOrEmpty(currentSceneInfo.scenes[0]))
		{
			LoadScene(currentSceneInfo);
		}
	}

	public void Update()
	{
	}

	private SceneInfo GetSceneInfo()
	{
		SceneInfo result = default(SceneInfo);
		try
		{
			StreamReader streamReader = new StreamReader(sceneLoadDataPath);
			result.version = Convert.ToInt64(streamReader.ReadLine());
			List<string> list = new List<string>();
			while (!streamReader.EndOfStream)
			{
				list.Add(streamReader.ReadLine());
			}
			result.scenes = list;
		}
		catch
		{
		}
		return result;
	}

	private void LoadScene(SceneInfo sceneInfo)
	{
		AssetBundle assetBundle = null;
		string[] files = Directory.GetFiles(scenePath, "*_*");
		string text = "scene_" + sceneInfo.scenes[0].ToLower();
		try
		{
			string[] array = files;
			for (int i = 0; i < array.Length; i++)
			{
				AssetBundle assetBundle2 = AssetBundle.LoadFromFile(array[i]);
				if (assetBundle2 != null)
				{
					UnityEngine.Debug.Log(("[PVRSceneLoader] Loading file bundle: " + assetBundle2.name == null) ? "null" : assetBundle2.name);
					loadedAssetBundles.Add(assetBundle2);
				}
				else
				{
					UnityEngine.Debug.LogError("[PVRSceneLoader] Loading file bundle failed");
				}
				if (assetBundle2.name == text)
				{
					assetBundle = assetBundle2;
				}
				_ = assetBundle2.name == "asset_resources";
			}
		}
		catch (Exception)
		{
			return;
		}
		if (assetBundle != null)
		{
			string fileNameWithoutExtension = Path.GetFileNameWithoutExtension(assetBundle.GetAllScenePaths()[0]);
			loadSceneOperation = SceneManager.LoadSceneAsync(fileNameWithoutExtension);
			loadSceneOperation.completed += LoadSceneOperation_completed;
		}
	}

	private void LoadSceneOperation_completed(UnityEngine.AsyncOperation obj)
	{
		StartCoroutine(onCheckNewSceneCoroutine());
	}

	private IEnumerator onCheckNewSceneCoroutine()
	{
		while (GetSceneInfo().version == currentSceneInfo.version)
		{
			yield return new WaitForSeconds(0f);
		}
		UnityEngine.Debug.Log("Scene change detected.");
		foreach (AssetBundle loadedAssetBundle in loadedAssetBundles)
		{
			if (loadedAssetBundle != null)
			{
				loadedAssetBundle.Unload(unloadAllLoadedObjects: true);
			}
		}
		loadedAssetBundles.Clear();
		int sceneCount = SceneManager.sceneCount;
		for (int i = 0; i < sceneCount; i++)
		{
			SceneManager.UnloadSceneAsync(SceneManager.GetSceneAt(i));
		}
		GameObject[] array = Resources.FindObjectsOfTypeAll(typeof(GameObject)) as GameObject[];
		for (int j = 0; j < array.Length; j++)
		{
			UnityEngine.Object.Destroy(array[j]);
		}
		SceneManager.LoadSceneAsync("PvrSQPIndex");
	}
}
public class Pvr_UnitySDKHeadTrack : MonoBehaviour
{
	[Tooltip("If true, head tracking will affect the rotation of each Pvr_UnitySDK's cameras.")]
	public bool trackRotation = true;

	[Tooltip("If true, head tracking will affect the position of each Pvr_UnitySDK's cameras.")]
	public bool trackPosition = true;

	public Transform target;

	private bool updated;

	private bool dataClock;

	public Ray Gaze
	{
		get
		{
			UpdateHead();
			return new Ray(base.transform.position, base.transform.forward);
		}
	}

	private void Update()
	{
		updated = false;
		UpdateHead();
	}

	private void UpdateHead()
	{
		if (updated)
		{
			return;
		}
		updated = true;
		if (Pvr_UnitySDKManager.SDK == null)
		{
			return;
		}
		if (trackRotation)
		{
			Quaternion orientation = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation;
			if (target == null)
			{
				base.transform.localRotation = orientation;
			}
			else
			{
				base.transform.rotation = orientation * target.rotation;
			}
		}
		else
		{
			Quaternion orientation2 = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation;
			if (target == null)
			{
				base.transform.localRotation = Quaternion.identity;
			}
			else
			{
				base.transform.rotation = orientation2 * target.rotation;
			}
		}
		if (trackPosition)
		{
			Vector3 position = Pvr_UnitySDKSensor.Instance.HeadPose.Position;
			if (target == null)
			{
				base.transform.localPosition = position;
			}
			else
			{
				base.transform.position = target.position + target.rotation * position;
			}
		}
	}
}
public class Pvr_UnitySDKPose
{
	protected static readonly Matrix4x4 flipZ = Matrix4x4.Scale(new Vector3(1f, 1f, -1f));

	public Matrix4x4 RightHandedMatrix => flipZ * Matrix * flipZ;

	public Vector3 Position { get; protected set; }

	public Quaternion Orientation { get; protected set; }

	public Matrix4x4 Matrix { get; protected set; }

	public Pvr_UnitySDKPose(Matrix4x4 matrix)
	{
		Set(matrix);
	}

	public Pvr_UnitySDKPose(Vector3 position, Quaternion orientation)
	{
		Set(position, orientation);
	}

	public void Set(Vector3 position, Quaternion orientation)
	{
		Position = position;
		Orientation = orientation;
		Matrix = Matrix4x4.TRS(position, orientation, Vector3.one);
	}

	protected void Set(Matrix4x4 matrix)
	{
		Matrix = matrix;
		Position = matrix.GetColumn(3);
		Orientation = Quaternion.LookRotation(matrix.GetColumn(2), matrix.GetColumn(1));
	}

	private Quaternion NormalizeQuaternion(ref Quaternion q)
	{
		float num = 0f;
		for (int i = 0; i < 4; i++)
		{
			num += q[i] * q[i];
		}
		float num2 = 1f / Mathf.Sqrt(num);
		for (int j = 0; j < 4; j++)
		{
			q[j] *= num2;
		}
		return q;
	}
}
public class Pvr_UnitySDKSensor
{
	public delegate void Enter3DofModel();

	public delegate void Exit3DofModel();

	private static Pvr_UnitySDKSensor instance;

	private bool SensorStart;

	private bool SensorInit;

	private Quaternion UnityQuaternion = Quaternion.identity;

	private Vector3 UnityPosition = Vector3.zero;

	private Sensorindex sensorIndex;

	private bool dofClock;

	public static Action EyeFovChanged;

	public Pvr_UnitySDKPose HeadPose;

	private float vfov = 102f;

	private float hfov = 102f;

	private float w;

	private float x;

	private float y;

	private float z;

	private float px;

	private float py;

	private float pz;

	public static Pvr_UnitySDKSensor Instance
	{
		get
		{
			if (instance == null)
			{
				instance = new Pvr_UnitySDKSensor();
			}
			return instance;
		}
		set
		{
			instance = value;
		}
	}

	public static event Enter3DofModel Enter3DofModelEvent;

	public static event Exit3DofModel Exit3DofModelEvent;

	public Pvr_UnitySDKSensor()
	{
		Init();
	}

	public void Init()
	{
		InitUnitySDK6DofSensor();
		SensorInit = InitUnitySDKSensor();
		SensorStart = StartUnitySDKSensor();
		HeadPose = new Pvr_UnitySDKPose(Vector3.zero, Quaternion.identity);
	}

	public void SensorUpdate()
	{
		if (GetUnitySDKSensorState())
		{
			HeadPose.Set(UnityPosition, UnityQuaternion);
		}
	}

	public bool InitUnitySDKSensor()
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_Init((int)sensorIndex) == 0)
			{
				result = true;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("InitUnitySDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool InitUnitySDK6DofSensor()
	{
		bool result = false;
		try
		{
			int res = 0;
			Render.UPvr_GetIntConfig(3, ref res);
			if (res == 1)
			{
				if (Sensor.UPvr_Enable6DofModule(!Pvr_UnitySDKManager.SDK.HmdOnlyrot) == 0 && !Pvr_UnitySDKManager.SDK.HmdOnlyrot)
				{
					result = true;
					Pvr_UnitySDKManager.SDK.PVRNeck = false;
				}
			}
			else
			{
				UnityEngine.Debug.LogWarning("This platform does not support 6 Dof !");
			}
		}
		catch (Exception ex)
		{
			PLOG.E("InitUnity6DofSDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool StartUnitySDKSensor()
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_StartSensor((int)sensorIndex) == 0)
			{
				result = true;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("StartUnitySDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool StopUnitySDKSensor()
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_StopSensor((int)sensorIndex) == 0)
			{
				result = true;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("StopUnitySDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool ResetUnitySDKSensor()
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_ResetSensor((int)sensorIndex) == 0)
			{
				result = true;
				PLOG.E("ResetUnitySDKSensor OK! ");
			}
		}
		catch (Exception ex)
		{
			PLOG.E("ResetUnitySDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool OptionalResetUnitySDKSensor(int resetRot, int resetPos)
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_OptionalResetSensor((int)sensorIndex, resetRot, resetPos) == 0)
			{
				result = true;
				UnityEngine.Debug.Log("PvrLog OptionalResetUnitySDKSensor OK!" + resetRot + resetPos);
			}
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError("OptionalResetUnitySDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool GetUnitySDKSensorState()
	{
		bool result = false;
		if (SensorInit && SensorStart)
		{
			try
			{
				int num = -1;
				if (Pvr_UnitySDKManager.SDK.ShowVideoSeethrough)
				{
					Pvr_BoundarySystem.Instance.CameraFramePtr = Pvr_BoundaryAPI.UPvr_GetCameraData_Ext();
					num = Pvr_BoundaryAPI.UPvr_GetMainSensorStateExt(ref x, ref y, ref z, ref w, ref px, ref py, ref pz, ref vfov, ref hfov, ref Pvr_UnitySDKRender.Instance.RenderviewNumber);
				}
				else
				{
					num = Sensor.UPvr_GetMainSensorState(ref x, ref y, ref z, ref w, ref px, ref py, ref pz, ref vfov, ref hfov, ref Pvr_UnitySDKRender.Instance.RenderviewNumber);
				}
				Pvr_UnitySDKManager.SDK.posStatus = Sensor.UPvr_Get6DofSensorQualityStatus();
				if (num == 0)
				{
					if (!Convert.ToBoolean(Pvr_UnitySDKManager.SDK.posStatus & 2))
					{
						if (!dofClock)
						{
							if (Pvr_UnitySDKSensor.Enter3DofModelEvent != null)
							{
								Pvr_UnitySDKSensor.Enter3DofModelEvent();
							}
							dofClock = true;
						}
					}
					else if (dofClock)
					{
						if (Pvr_UnitySDKSensor.Exit3DofModelEvent != null)
						{
							Pvr_UnitySDKSensor.Exit3DofModelEvent();
						}
						dofClock = false;
					}
					RefreshHeadData(x, y, z, w, px, py, pz);
					UnityQuaternion.Set(x, y, 0f - z, 0f - w);
					if (Pvr_UnitySDKRender.Instance.EyeVFoV != vfov)
					{
						Pvr_UnitySDKRender.Instance.EyeVFoV = vfov;
						if (EyeFovChanged != null)
						{
							EyeFovChanged();
						}
					}
					Pvr_UnitySDKRender.Instance.EyeHFoV = hfov;
					Pvr_UnitySDKManager.SDK.EyesAspect = hfov / vfov;
					result = true;
					if (Pvr_UnitySDKManager.SDK.HmdOnlyrot)
					{
						if (Pvr_UnitySDKManager.SDK.PVRNeck)
						{
							if (Pvr_UnitySDKManager.SDK.TrackingOrigin == TrackingOrigin.FloorLevel)
							{
								UnityPosition.Set(0f, py, 0f);
								UnityPosition += UnityQuaternion * Pvr_UnitySDKManager.SDK.neckOffset - Pvr_UnitySDKManager.SDK.neckOffset.y * Vector3.up;
							}
							else
							{
								UnityPosition = UnityQuaternion * Pvr_UnitySDKManager.SDK.neckOffset - Pvr_UnitySDKManager.SDK.neckOffset.y * Vector3.up;
							}
						}
					}
					else
					{
						UnityPosition.Set(px, py, 0f - pz);
					}
					if (PLOG.logLevel > 2)
					{
						PLOG.D("posStatus=" + Pvr_UnitySDKManager.SDK.posStatus);
						PLOG.D("PvrLog 6DoFHeadRotation:" + x + "," + y + "," + (0f - z) + "," + (0f - w) + ",Position:" + px + "," + py + "," + (0f - pz) + ",eulerAngles:" + UnityQuaternion.eulerAngles);
					}
				}
				if (num == -1)
				{
					PLOG.I("PvrLog Sensor update --- GetUnitySDKSensorState  -1 ");
				}
			}
			catch (Exception ex)
			{
				PLOG.E("GetUnitySDKSensorState ERROR! " + ex.Message);
				throw;
			}
		}
		return result;
	}

	public bool GetUnitySDKPSensorState()
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_ResetSensor((int)sensorIndex) == 0)
			{
				result = true;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("GetUnitySDKPSensorState ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	private void RefreshHeadData(float x, float y, float z, float w, float px, float py, float pz)
	{
		Pvr_UnitySDKManager.SDK.headData[0] = x;
		Pvr_UnitySDKManager.SDK.headData[1] = y;
		Pvr_UnitySDKManager.SDK.headData[2] = z;
		Pvr_UnitySDKManager.SDK.headData[3] = w;
		Pvr_UnitySDKManager.SDK.headData[4] = px;
		Pvr_UnitySDKManager.SDK.headData[5] = py;
		Pvr_UnitySDKManager.SDK.headData[6] = pz;
	}
}
public class CLoadingAsset : ScriptableObject
{
	public int SplashScreenType;

	public List<Texture2D> splashImage = new List<Texture2D>();

	public Texture2D Inside_background;

	public bool UseSplashText;

	public string DefaultText;

	public string ChineseText;

	public string EnglishText;

	public string JapaneseText;

	public string KoreanText;

	public string FontSize;

	public Color FontColor;

	public string TextHeight;

	public bool UseCarousel;

	public int SplashTextAlignment;
}
[Serializable]
public class Pvr_UnitySDKConfigProfile
{
	public struct Lenses
	{
		public float separation;

		public float offset;

		public float distance;

		public int alignment;

		public const int AlignTop = -1;

		public const int AlignCenter = 0;

		public const int AlignBottom = 1;
	}

	public struct MaxFOV
	{
		public float upper;

		public float lower;

		public float inner;

		public float outer;
	}

	public struct Distortion
	{
		public float k1;

		public float k2;

		public float k3;

		public float k4;

		public float k5;

		public float k6;

		public float distort(float r)
		{
			return 0f;
		}

		public float distort(float r, float dist)
		{
			float num = r * dist * 1000f;
			return (k1 * Mathf.Pow(num, 5f) + k2 * Mathf.Pow(num, 4f) + k3 * Mathf.Pow(num, 3f) + k4 * Mathf.Pow(num, 2f) + k5 * num + k6) / 1000f / dist;
		}

		public float diatortInv(float radious)
		{
			return 0f;
		}
	}

	public struct Device
	{
		public Lenses devLenses;

		public MaxFOV devMaxFov;

		public Distortion devDistortion;

		public Distortion devDistortionInv;
	}

	public static readonly Device SimulateDevice = new Device
	{
		devLenses = 
		{
			separation = 0.062f,
			offset = 0f,
			distance = 0.0403196f,
			alignment = 0
		},
		devMaxFov = 
		{
			upper = 40f,
			lower = 40f,
			inner = 40f,
			outer = 40f
		},
		devDistortion = 
		{
			k1 = 2.333E-06f,
			k2 = -0.000126f,
			k3 = 0.002978f,
			k4 = -0.02615f,
			k5 = 1.089f,
			k6 = -0.0337f
		},
		devDistortionInv = 
		{
			k1 = 1.342E-08f,
			k2 = 1.665E-06f,
			k3 = -0.0002797f,
			k4 = 0.001166f,
			k5 = 0.9945f,
			k6 = 0.004805f
		}
	};

	public Device device;

	public static readonly Pvr_UnitySDKConfigProfile Default = new Pvr_UnitySDKConfigProfile
	{
		device = SimulateDevice
	};

	public Pvr_UnitySDKConfigProfile Clone()
	{
		return new Pvr_UnitySDKConfigProfile
		{
			device = device
		};
	}

	public static Pvr_UnitySDKConfigProfile GetPicoProfile()
	{
		return new Pvr_UnitySDKConfigProfile
		{
			device = SimulateDevice
		};
	}

	public float[] GetLeftEyeVisibleTanAngles(float width, float height)
	{
		float val = (float)Math.Tan((double)(0f - device.devMaxFov.outer) * Math.PI / 180.0);
		float val2 = (float)Math.Tan((double)device.devMaxFov.upper * Math.PI / 180.0);
		float val3 = (float)Math.Tan((double)device.devMaxFov.inner * Math.PI / 180.0);
		float val4 = (float)Math.Tan((double)(0f - device.devMaxFov.lower) * Math.PI / 180.0);
		float num = width / 4f;
		float num2 = height / 2f;
		float num3 = device.devLenses.separation / 2f - num;
		float num4 = 0f;
		float distance = device.devLenses.distance;
		float val5 = device.devDistortion.distort((num3 - num) / distance, device.devLenses.distance);
		float val6 = device.devDistortion.distort((num4 + num2) / distance, device.devLenses.distance);
		float val7 = device.devDistortion.distort((num3 + num) / distance, device.devLenses.distance);
		float val8 = device.devDistortion.distort((num4 - num) / distance, device.devLenses.distance);
		float num5 = Math.Max(val, val5);
		float num6 = Math.Min(val2, val6);
		float num7 = Math.Min(val3, val7);
		float num8 = Math.Max(val4, val8);
		return new float[4] { num5, num6, num7, num8 };
	}

	public float[] GetLeftEyeNoLensTanAngles(float width, float height)
	{
		float val = device.devDistortionInv.distort((float)Math.Tan((double)(0f - device.devMaxFov.outer) * Math.PI / 180.0), device.devLenses.distance);
		float val2 = device.devDistortionInv.distort((float)Math.Tan((double)device.devMaxFov.upper * Math.PI / 180.0), device.devLenses.distance);
		float val3 = device.devDistortionInv.distort((float)Math.Tan((double)device.devMaxFov.inner * Math.PI / 180.0), device.devLenses.distance);
		float val4 = device.devDistortionInv.distort((float)Math.Tan((double)(0f - device.devMaxFov.lower) * Math.PI / 180.0), device.devLenses.distance);
		float num = width / 4f;
		float num2 = height / 2f;
		float num3 = device.devLenses.separation / 2f - num;
		float num4 = 0f;
		float distance = device.devLenses.distance;
		float val5 = (num3 - num) / distance;
		float val6 = (num4 + num2) / distance;
		float val7 = (num3 + num) / distance;
		float val8 = (num4 - num) / distance;
		float num5 = Math.Min(val, val5);
		float num6 = Math.Min(val2, val6);
		float num7 = Math.Min(val3, val7);
		float num8 = Math.Max(val4, val8);
		return new float[4] { num5, num6, num7, num8 };
	}

	public Rect GetLeftEyeVisibleScreenRect(float[] undistortedFrustum, float width, float height)
	{
		float distance = device.devLenses.distance;
		float num = (width - device.devLenses.separation) / 2f;
		float num2 = height / 2f;
		float num3 = (undistortedFrustum[0] * distance + num) / width;
		float num4 = (undistortedFrustum[1] * distance + num2) / height;
		float num5 = (undistortedFrustum[2] * distance + num) / width;
		float num6 = (undistortedFrustum[3] * distance + num2) / height;
		return new Rect(num3, num6, num5 - num3, num4 - num6);
	}
}
[RequireComponent(typeof(Text))]
public class Pvr_UnitySDKFPS : MonoBehaviour
{
	public Text fpsText;

	private float updateInterval = 0.5f;

	private float accum;

	private int frames;

	private float timeLeft;

	private string strFps;

	private void Update()
	{
		if (fpsText != null)
		{
			ShowFps();
		}
	}

	private void ShowFps()
	{
		timeLeft -= Time.unscaledDeltaTime;
		accum += Time.unscaledDeltaTime;
		frames++;
		if ((double)timeLeft <= 0.0)
		{
			float num = (float)frames / accum;
			strFps = $"FPS: {num:f0}";
			fpsText.text = strFps;
			timeLeft += updateInterval;
			accum = 0f;
			frames = 0;
		}
	}
}
public class Pvr_GazeFuse : MonoBehaviour
{
	public GameObject gazeGameObject;

	private Image image;

	private void Start()
	{
		image = GetComponent<Image>();
	}

	private void Update()
	{
		if (gazeGameObject == null || Pvr_GazeInputModule.gazeGameObject == gazeGameObject)
		{
			FuseAmountChanged(Pvr_GazeInputModule.gazeFraction);
		}
	}

	private void FuseAmountChanged(float fuseAmount)
	{
		if (image != null)
		{
			image.fillAmount = fuseAmount;
		}
	}
}
public class Pvr_GazeInputModule : PointerInputModule
{
	public enum Mode
	{
		Click,
		Gaze
	}

	public Mode mode;

	[Header("Click Settings")]
	public string ClickInputName = "Submit";

	[Header("Gaze Settings")]
	public float GazeTimeInSeconds = 2f;

	public RaycastResult CurrentRaycast;

	private PointerEventData pointerEventData;

	private GameObject currentLookAtHandler;

	private float currentLookAtHandlerClickTime;

	public static float gazeFraction { get; private set; }

	public static GameObject gazeGameObject { get; private set; }

	public override void Process()
	{
		HandleLook();
		HandleSelection();
	}

	private void HandleLook()
	{
		if (pointerEventData == null)
		{
			pointerEventData = new PointerEventData(base.eventSystem);
		}
		pointerEventData.position = new Vector2(Screen.width / 2, Screen.height / 2);
		pointerEventData.delta = Vector2.zero;
		List<RaycastResult> list = new List<RaycastResult>();
		base.eventSystem.RaycastAll(pointerEventData, list);
		RaycastResult currentRaycast = (pointerEventData.pointerCurrentRaycast = BaseInputModule.FindFirstRaycast(list));
		CurrentRaycast = currentRaycast;
		ProcessMove(pointerEventData);
	}

	private void HandleSelection()
	{
		gazeFraction = 0f;
		if (pointerEventData.pointerEnter != null)
		{
			GameObject eventHandler = ExecuteEvents.GetEventHandler<IPointerClickHandler>(pointerEventData.pointerEnter);
			if (currentLookAtHandler != eventHandler)
			{
				gazeGameObject = (currentLookAtHandler = eventHandler);
				currentLookAtHandlerClickTime = Time.realtimeSinceStartup + GazeTimeInSeconds;
			}
			if (mode == Mode.Gaze && currentLookAtHandler != null)
			{
				gazeFraction = Mathf.Clamp01(1f - (currentLookAtHandlerClickTime - Time.realtimeSinceStartup) / GazeTimeInSeconds);
			}
			if ((currentLookAtHandler != null && mode == Mode.Gaze && Time.realtimeSinceStartup > currentLookAtHandlerClickTime) || (mode == Mode.Click && Input.GetButtonDown(ClickInputName)))
			{
				_ = EventSystem.current.currentSelectedGameObject != null;
				EventSystem.current.SetSelectedGameObject(currentLookAtHandler);
				gazeFraction = 0f;
				ExecuteEvents.ExecuteHierarchy(currentLookAtHandler, pointerEventData, ExecuteEvents.pointerClickHandler);
				currentLookAtHandlerClickTime = float.MaxValue;
				ExecuteEvents.ExecuteHierarchy(EventSystem.current.currentSelectedGameObject, pointerEventData, ExecuteEvents.deselectHandler);
			}
		}
		else
		{
			gazeGameObject = (currentLookAtHandler = null);
		}
	}
}
[RequireComponent(typeof(Pvr_GazeInputModule))]
public class Pvr_GazeInputModuleCrosshair : MonoBehaviour
{
	public static bool DisplayCrosshair = true;

	[Tooltip("Crosshair GameObject attached to your VR Camera")]
	public Transform Crosshair;

	private Pvr_GazeInputModule gazeInputModule;

	private Vector3 CrosshairOriginalScale;

	private float CrosshairOriginalDistance;

	private void Awake()
	{
		gazeInputModule = GetComponent<Pvr_GazeInputModule>();
	}

	private void Start()
	{
		CrosshairOriginalScale = Crosshair.localScale;
		CrosshairOriginalDistance = Crosshair.localPosition.z;
		Crosshair.gameObject.SetActive(value: false);
	}

	private void Update()
	{
		Crosshair.gameObject.SetActive(DisplayCrosshair);
		if (DisplayCrosshair)
		{
			float crossHairAtDistance = CrosshairOriginalDistance;
			if (gazeInputModule.CurrentRaycast.isValid)
			{
				crossHairAtDistance = gazeInputModule.CurrentRaycast.distance * 0.8f - 0.5f;
			}
			SetCrossHairAtDistance(crossHairAtDistance);
		}
	}

	private void SetCrossHairAtDistance(float dist)
	{
		Vector3 localPosition = Crosshair.localPosition;
		Crosshair.localPosition = new Vector3(localPosition.x, localPosition.y, dist);
		Crosshair.localScale = CrosshairOriginalScale * dist;
	}
}
public enum RenderEventType
{
	InitRenderThread = 1024,
	Pause,
	Resume,
	LeftEyeEndFrame,
	RightEyeEndFrame,
	TimeWarp,
	ResetVrModeParms,
	ShutdownRenderThread,
	BeginEye,
	EndEye,
	BoundaryRenderLeft,
	BoundaryRenderRight,
	BothEyeEndFrame,
	CameraFrameLeft,
	CameraFrameRight,
	StartCameraFrame,
	StopCameraFrame
}
public static class Pvr_UnitySDKPluginEvent
{
	private delegate void RenderEventDelegate(int eventId);

	private const uint IS_DATA_FLAG = 2147483648u;

	private const uint DATA_POS_MASK = 1073741824u;

	private const int DATA_POS_SHIFT = 30;

	private const uint EVENT_TYPE_MASK = 1056899072u;

	private const int EVENT_TYPE_SHIFT = 17;

	private const uint PAYLOAD_MASK = 65535u;

	private const int PAYLOAD_SHIFT = 16;

	private static RenderEventDelegate SetSinglePassBeforeForwardOpaqueHandle = SetSinglePassBeforeForwardOpaque;

	private static IntPtr SetSinglePassBeforeForwardOpaquePtr = Marshal.GetFunctionPointerForDelegate(SetSinglePassBeforeForwardOpaqueHandle);

	public static void Issue(RenderEventType eventType)
	{
		GL.IssuePluginEvent(Pvr_UnitySDKAPI.System.GetRenderEventFunc(), (int)eventType);
	}

	private static int EncodeType(int eventType)
	{
		return eventType & 0x7FFFFFFF;
	}

	private static int EncodeData(int eventId, int eventData, int pos)
	{
		return int.MinValue | ((pos << 30) & 0x40000000) | ((eventId << 17) & 0x3EFF0000) | ((eventData >>> pos * 16) & 0xFFFF);
	}

	private static int DecodeData(int eventData)
	{
		uint num = (uint)(eventData & 0x40000000) >> 30;
		return (eventData & 0xFFFF) << (int)(16 * num);
	}

	[MonoPInvokeCallback(typeof(RenderEventDelegate))]
	private static void SetSinglePassBeforeForwardOpaque(int eventId)
	{
		Pvr_UnitySDKAPI.System.UPvr_SinglePassBeforeForwardOpaque();
	}

	public static void SetSinglePassBeforeForwardOpaque(CommandBuffer cmd)
	{
		cmd.IssuePluginEvent(SetSinglePassBeforeForwardOpaquePtr, 0);
	}
}
public class Pvr_UnitySDKSightInputModule : BaseInputModule
{
	[Tooltip("Optional object to place at raycast intersections as a 3D cursor. Be sure it is on a layer that raycasts will ignore.")]
	public GameObject cursor;

	public int trigger;

	[HideInInspector]
	public float clickTime = 0.1f;

	[HideInInspector]
	public Vector2 hotspot = new Vector2(0.5f, 0.5f);

	private PointerEventData pointerData;

	public override bool ShouldActivateModule()
	{
		if (!base.ShouldActivateModule())
		{
			return false;
		}
		return Pvr_UnitySDKManager.SDK.VRModeEnabled;
	}

	public override void DeactivateModule()
	{
		base.DeactivateModule();
		if (pointerData != null)
		{
			HandlePendingClick();
			HandlePointerExitAndEnter(pointerData, null);
			pointerData = null;
		}
		base.eventSystem.SetSelectedGameObject(null, GetBaseEventData());
		if (cursor != null)
		{
			cursor.SetActive(value: false);
		}
	}

	public override bool IsPointerOverGameObject(int pointerId)
	{
		if (pointerData != null)
		{
			return pointerData.pointerEnter != null;
		}
		return false;
	}

	public override void Process()
	{
		CastRayFromGaze();
		UpdateCurrentObject();
		PlaceCursor();
		HandlePendingClick();
		HandleTrigger();
	}

	private void CastRayFromGaze()
	{
		if (pointerData == null)
		{
			pointerData = new PointerEventData(base.eventSystem);
		}
		pointerData.Reset();
		pointerData.position = new Vector2(hotspot.x * (float)Screen.width, hotspot.y * (float)Screen.height);
		base.eventSystem.RaycastAll(pointerData, m_RaycastResultCache);
		pointerData.pointerCurrentRaycast = BaseInputModule.FindFirstRaycast(m_RaycastResultCache);
		m_RaycastResultCache.Clear();
	}

	private void UpdateCurrentObject()
	{
		GameObject gameObject = pointerData.pointerCurrentRaycast.gameObject;
		HandlePointerExitAndEnter(pointerData, gameObject);
		if (ExecuteEvents.GetEventHandler<ISelectHandler>(gameObject) == base.eventSystem.currentSelectedGameObject)
		{
			ExecuteEvents.Execute(base.eventSystem.currentSelectedGameObject, GetBaseEventData(), ExecuteEvents.updateSelectedHandler);
		}
		else
		{
			base.eventSystem.SetSelectedGameObject(null, pointerData);
		}
	}

	private void PlaceCursor()
	{
		if (!(cursor == null))
		{
			GameObject gameObject = pointerData.pointerCurrentRaycast.gameObject;
			cursor.SetActive(gameObject != null);
			if (cursor.activeInHierarchy)
			{
				Camera enterEventCamera = pointerData.enterEventCamera;
				float num = pointerData.pointerCurrentRaycast.distance + enterEventCamera.nearClipPlane - 0.1f;
				cursor.transform.position = enterEventCamera.transform.position + enterEventCamera.transform.forward * num;
			}
		}
	}

	private void HandlePendingClick()
	{
		if (pointerData.eligibleForClick && (Pvr_UnitySDKManager.SDK.picovrTriggered || !(Time.unscaledTime - pointerData.clickTime < clickTime)))
		{
			ExecuteEvents.Execute(pointerData.pointerPress, pointerData, ExecuteEvents.pointerUpHandler);
			ExecuteEvents.Execute(pointerData.pointerPress, pointerData, ExecuteEvents.pointerClickHandler);
			pointerData.pointerPress = null;
			pointerData.rawPointerPress = null;
			pointerData.eligibleForClick = false;
			pointerData.clickCount = 0;
		}
	}

	private void HandleTrigger()
	{
		if (Pvr_UnitySDKManager.SDK.picovrTriggered)
		{
			GameObject gameObject = pointerData.pointerCurrentRaycast.gameObject;
			if (!(gameObject == null) && !(ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject) == null))
			{
				pointerData.pointerPress = ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject);
				pointerData.pressPosition = pointerData.position;
				pointerData.pointerPressRaycast = pointerData.pointerCurrentRaycast;
				pointerData.pointerPress = ExecuteEvents.ExecuteHierarchy(gameObject, pointerData, ExecuteEvents.pointerDownHandler) ?? ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject);
				pointerData.rawPointerPress = gameObject;
				pointerData.eligibleForClick = true;
				pointerData.clickCount = 1;
				pointerData.clickTime = Time.unscaledTime;
			}
		}
	}
}
public class Pvr_ObjImporter
{
	private static Pvr_ObjImporter _instance;

	private List<int> triangles;

	private List<Vector3> vertices;

	private List<Vector2> uv;

	private List<Vector3> normals;

	private List<PvrVector3Int> faceData;

	private List<int> intArray;

	private const int MIN_POW_10 = -16;

	private const int MAX_POW_10 = 16;

	private const int NUM_POWS_10 = 33;

	private static readonly float[] pow10 = GenerateLookupTable();

	public static Pvr_ObjImporter Instance => _instance ?? (_instance = new Pvr_ObjImporter());

	public Mesh ImportFile(string filePath)
	{
		triangles = new List<int>();
		vertices = new List<Vector3>();
		uv = new List<Vector2>();
		normals = new List<Vector3>();
		faceData = new List<PvrVector3Int>();
		intArray = new List<int>();
		LoadMeshData(filePath);
		Vector3[] array = new Vector3[faceData.Count];
		Vector2[] array2 = new Vector2[faceData.Count];
		Vector3[] array3 = new Vector3[faceData.Count];
		for (int i = 0; i < faceData.Count; i++)
		{
			array[i] = vertices[faceData[i].x - 1];
			if (faceData[i].y >= 1)
			{
				array2[i] = uv[faceData[i].y - 1];
			}
			if (faceData[i].z >= 1)
			{
				array3[i] = normals[faceData[i].z - 1];
			}
		}
		Mesh mesh = new Mesh();
		mesh.vertices = array;
		mesh.uv = array2;
		mesh.normals = array3;
		mesh.triangles = triangles.ToArray();
		mesh.RecalculateBounds();
		return mesh;
	}

	private void LoadMeshData(string fileName)
	{
		StringBuilder stringBuilder = new StringBuilder();
		string text = File.ReadAllText(fileName);
		int num = 0;
		string text2 = null;
		int num2 = 0;
		StringBuilder sbInt = new StringBuilder();
		for (int i = 0; i < text.Length; i++)
		{
			if (text[i] != '\n')
			{
				continue;
			}
			stringBuilder.Remove(0, stringBuilder.Length);
			stringBuilder.Append(text, num + 1, i - num);
			num = i;
			if (stringBuilder[0] == 'o' && stringBuilder[1] == ' ')
			{
				sbInt.Remove(0, sbInt.Length);
				for (int j = 2; j < stringBuilder.Length; j++)
				{
					text2 += stringBuilder[j];
				}
			}
			else if (stringBuilder[0] == 'v' && stringBuilder[1] == ' ')
			{
				int start = 2;
				vertices.Add(new Vector3(GetFloat(stringBuilder, ref start, ref sbInt), GetFloat(stringBuilder, ref start, ref sbInt), GetFloat(stringBuilder, ref start, ref sbInt)));
			}
			else if (stringBuilder[0] == 'v' && stringBuilder[1] == 't' && stringBuilder[2] == ' ')
			{
				int start2 = 3;
				uv.Add(new Vector2(GetFloat(stringBuilder, ref start2, ref sbInt), GetFloat(stringBuilder, ref start2, ref sbInt)));
			}
			else if (stringBuilder[0] == 'v' && stringBuilder[1] == 'n' && stringBuilder[2] == ' ')
			{
				int start3 = 3;
				normals.Add(new Vector3(GetFloat(stringBuilder, ref start3, ref sbInt), GetFloat(stringBuilder, ref start3, ref sbInt), GetFloat(stringBuilder, ref start3, ref sbInt)));
			}
			else if (stringBuilder[0] == 'f' && stringBuilder[1] == ' ')
			{
				int start4 = 2;
				int num3 = 1;
				intArray.Clear();
				int num4 = 0;
				while (start4 < stringBuilder.Length && char.IsDigit(stringBuilder[start4]))
				{
					faceData.Add(new PvrVector3Int(GetInt(stringBuilder, ref start4, ref sbInt), GetInt(stringBuilder, ref start4, ref sbInt), GetInt(stringBuilder, ref start4, ref sbInt)));
					num3++;
					intArray.Add(num2);
					num2++;
				}
				num4 += num3;
				for (num3 = 1; num3 + 2 < num4; num3++)
				{
					triangles.Add(intArray[0]);
					triangles.Add(intArray[num3]);
					triangles.Add(intArray[num3 + 1]);
				}
			}
		}
	}

	private float GetFloat(StringBuilder sb, ref int start, ref StringBuilder sbFloat)
	{
		sbFloat.Remove(0, sbFloat.Length);
		while (start < sb.Length && (char.IsDigit(sb[start]) || sb[start] == '-' || sb[start] == '.'))
		{
			sbFloat.Append(sb[start]);
			start++;
		}
		start++;
		return ParseFloat(sbFloat);
	}

	private int GetInt(StringBuilder sb, ref int start, ref StringBuilder sbInt)
	{
		sbInt.Remove(0, sbInt.Length);
		while (start < sb.Length && char.IsDigit(sb[start]))
		{
			sbInt.Append(sb[start]);
			start++;
		}
		start++;
		return IntParseFast(sbInt);
	}

	private static float[] GenerateLookupTable()
	{
		float[] array = new float[320];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = (float)(i / 33) * Mathf.Pow(10f, i % 33 + -16);
		}
		return array;
	}

	private float ParseFloat(StringBuilder value)
	{
		float num = 0f;
		bool flag = false;
		int length = value.Length;
		int num2 = value.Length;
		for (int num3 = length - 1; num3 >= 0; num3--)
		{
			if (value[num3] == '.')
			{
				num2 = num3;
				break;
			}
		}
		int num4 = 16 + num2;
		for (int i = 0; i < num2; i++)
		{
			if (i != num2 && value[i] != '-')
			{
				num += pow10[(value[i] - 48) * 33 + num4 - i - 1];
			}
			else if (value[i] == '-')
			{
				flag = true;
			}
		}
		for (int j = num2 + 1; j < length; j++)
		{
			if (j != num2)
			{
				num += pow10[(value[j] - 48) * 33 + num4 - j];
			}
		}
		if (flag)
		{
			num = 0f - num;
		}
		return num;
	}

	private int IntParseFast(StringBuilder value)
	{
		int num = 0;
		for (int i = 0; i < value.Length; i++)
		{
			num = 10 * num + (value[i] - 48);
		}
		return num;
	}
}
public sealed class PvrVector3Int
{
	public int x { get; set; }

	public int y { get; set; }

	public int z { get; set; }

	public PvrVector3Int()
	{
	}

	public PvrVector3Int(int x, int y, int z)
	{
		this.x = x;
		this.y = y;
		this.z = z;
	}
}
public class Pvr_EnumFlags : PropertyAttribute
{
}
public enum ConfirmBtn
{
	App = 1,
	TouchPad = 2,
	Trigger = 4
}
public class Pvr_InputModule : PointerInputModule
{
	public static List<Pvr_UIPointer> pointers = new List<Pvr_UIPointer>();

	[Pvr_EnumFlags]
	public ConfirmBtn confirmBtn = ConfirmBtn.TouchPad;

	private List<RaycastResult> rayCasts = new List<RaycastResult>();

	private RaycastResult rayCastResult;

	public virtual void Initialise()
	{
		pointers.Clear();
	}

	public static void AddPoint(Pvr_UIPointer point)
	{
		if (!pointers.Contains(point))
		{
			pointers.Add(point);
		}
	}

	public static void RemovePoint(Pvr_UIPointer point)
	{
		if (pointers.Contains(point))
		{
			pointers.Remove(point);
		}
	}

	public override void Process()
	{
		if (Pvr_UnitySDKManager.SDK.isHasController)
		{
			if ((confirmBtn & ConfirmBtn.App) == ConfirmBtn.App)
			{
				Pvr_UIPointer.AppBtnValue = Pvr_UnitySDKAPI.Controller.UPvr_GetKey(Pvr_ControllerManager.controllerlink.mainHandID, Pvr_KeyCode.APP);
			}
			if ((confirmBtn & ConfirmBtn.TouchPad) == ConfirmBtn.TouchPad)
			{
				Pvr_UIPointer.TouchBtnValue = Pvr_UnitySDKAPI.Controller.UPvr_GetKey(Pvr_ControllerManager.controllerlink.mainHandID, Pvr_KeyCode.TOUCHPAD);
			}
			if ((confirmBtn & ConfirmBtn.Trigger) == ConfirmBtn.Trigger)
			{
				Pvr_UIPointer.TriggerBtnValue = Pvr_UnitySDKAPI.Controller.UPvr_GetKey(Pvr_ControllerManager.controllerlink.mainHandID, Pvr_KeyCode.TRIGGER);
			}
		}
		for (int i = 0; i < pointers.Count; i++)
		{
			Pvr_UIPointer pvr_UIPointer = pointers[i];
			if (pvr_UIPointer.gameObject.activeInHierarchy && pvr_UIPointer.enabled)
			{
				List<RaycastResult> results = new List<RaycastResult>();
				if (pvr_UIPointer.PointerActive())
				{
					results = CheckRaycasts(pvr_UIPointer);
				}
				Hover(pvr_UIPointer, results);
				Click(pvr_UIPointer, results);
				Drag(pvr_UIPointer, results);
			}
		}
	}

	protected virtual List<RaycastResult> CheckRaycasts(Pvr_UIPointer pointer)
	{
		rayCastResult.worldPosition = pointer.GetOriginPosition();
		rayCastResult.worldNormal = pointer.GetOriginForward();
		pointer.pointerEventData.pointerCurrentRaycast = rayCastResult;
		base.eventSystem.RaycastAll(pointer.pointerEventData, rayCasts);
		return rayCasts;
	}

	protected virtual bool CheckTransformTree(Transform target, Transform source)
	{
		if (target == null)
		{
			return false;
		}
		if (target.Equals(source))
		{
			return true;
		}
		return CheckTransformTree(target.transform.parent, source);
	}

	protected virtual bool NoValidCollision(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		if (results.Count != 0)
		{
			return !CheckTransformTree(results[0].gameObject.transform, pointer.pointerEventData.pointerEnter.transform);
		}
		return true;
	}

	protected virtual bool IsHovering(Pvr_UIPointer pointer)
	{
		foreach (GameObject item in pointer.pointerEventData.hovered)
		{
			if ((bool)pointer.pointerEventData.pointerEnter && (bool)item && CheckTransformTree(item.transform, pointer.pointerEventData.pointerEnter.transform))
			{
				return true;
			}
		}
		return false;
	}

	protected virtual bool ValidElement(GameObject obj)
	{
		Pvr_UICanvas componentInParent = obj.GetComponentInParent<Pvr_UICanvas>();
		if (!componentInParent || !componentInParent.enabled)
		{
			return false;
		}
		return true;
	}

	protected virtual void CheckPointerHoverClick(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		if (pointer.hoverDurationTimer > 0f)
		{
			pointer.hoverDurationTimer -= Time.deltaTime;
		}
		if (pointer.canClickOnHover && pointer.hoverDurationTimer <= 0f)
		{
			pointer.canClickOnHover = false;
			ClickOnDown(pointer, results, forceClick: true);
		}
	}

	protected virtual void Hover(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		if ((bool)pointer.pointerEventData.pointerEnter)
		{
			CheckPointerHoverClick(pointer, results);
			if (!ValidElement(pointer.pointerEventData.pointerEnter))
			{
				pointer.pointerEventData.pointerEnter = null;
				return;
			}
			if (NoValidCollision(pointer, results))
			{
				ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerEnter, pointer.pointerEventData, ExecuteEvents.pointerExitHandler);
				pointer.pointerEventData.hovered.Remove(pointer.pointerEventData.pointerEnter);
				pointer.pointerEventData.pointerEnter = null;
			}
			if (results.Count <= 0 || !(pointer.pointerEventData.pointerEnter != results[0].gameObject))
			{
				return;
			}
			{
				foreach (RaycastResult result in results)
				{
					if (!ValidElement(result.gameObject))
					{
						continue;
					}
					GameObject gameObject = ExecuteEvents.ExecuteHierarchy(result.gameObject, pointer.pointerEventData, ExecuteEvents.pointerEnterHandler);
					if (gameObject != null)
					{
						Selectable component = gameObject.GetComponent<Selectable>();
						if ((bool)component)
						{
							Navigation navigation = default(Navigation);
							navigation.mode = Navigation.Mode.None;
							component.navigation = navigation;
						}
						pointer.pointerEventData.hovered.Remove(pointer.pointerEventData.pointerEnter);
						pointer.OnUIPointerElementEnter(pointer.SetUIPointerEvent(result, gameObject, pointer.hoveringElement));
						pointer.hoveringElement = gameObject;
						pointer.pointerEventData.pointerCurrentRaycast = result;
						pointer.pointerEventData.pointerEnter = gameObject;
						pointer.pointerEventData.hovered.Add(pointer.pointerEventData.pointerEnter);
						break;
					}
					if (result.gameObject != pointer.hoveringElement)
					{
						pointer.OnUIPointerElementEnter(pointer.SetUIPointerEvent(result, result.gameObject, pointer.hoveringElement));
					}
					pointer.hoveringElement = result.gameObject;
				}
				return;
			}
		}
		foreach (RaycastResult result2 in results)
		{
			if (!ValidElement(result2.gameObject))
			{
				continue;
			}
			GameObject gameObject2 = ExecuteEvents.ExecuteHierarchy(result2.gameObject, pointer.pointerEventData, ExecuteEvents.pointerEnterHandler);
			if (gameObject2 != null)
			{
				Selectable component2 = gameObject2.GetComponent<Selectable>();
				if ((bool)component2)
				{
					Navigation navigation2 = default(Navigation);
					navigation2.mode = Navigation.Mode.None;
					component2.navigation = navigation2;
				}
				pointer.OnUIPointerElementEnter(pointer.SetUIPointerEvent(result2, gameObject2, pointer.hoveringElement));
				pointer.hoveringElement = gameObject2;
				pointer.pointerEventData.pointerCurrentRaycast = result2;
				pointer.pointerEventData.pointerEnter = gameObject2;
				pointer.pointerEventData.hovered.Add(pointer.pointerEventData.pointerEnter);
				break;
			}
			if (result2.gameObject != pointer.hoveringElement)
			{
				pointer.OnUIPointerElementEnter(pointer.SetUIPointerEvent(result2, result2.gameObject, pointer.hoveringElement));
			}
			pointer.hoveringElement = result2.gameObject;
		}
		if ((bool)pointer.hoveringElement && results.Count == 0)
		{
			pointer.OnUIPointerElementExit(pointer.SetUIPointerEvent(default(RaycastResult), null, pointer.hoveringElement));
			pointer.hoveringElement = null;
		}
	}

	protected virtual void Click(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		switch (pointer.clickMethod)
		{
		case Pvr_UIPointer.ClickMethods.ClickOnButtonUp:
			ClickOnUp(pointer, results);
			break;
		case Pvr_UIPointer.ClickMethods.ClickOnButtonDown:
			ClickOnDown(pointer, results);
			break;
		}
	}

	protected virtual void ClickOnUp(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		pointer.pointerEventData.eligibleForClick = pointer.ValidClick(checkLastClick: false);
		if (!AttemptClick(pointer))
		{
			IsEligibleClick(pointer, results);
		}
	}

	protected virtual void ClickOnDown(Pvr_UIPointer pointer, List<RaycastResult> results, bool forceClick = false)
	{
		pointer.pointerEventData.eligibleForClick = forceClick || pointer.ValidClick(checkLastClick: true);
		if (IsEligibleClick(pointer, results))
		{
			pointer.pointerEventData.eligibleForClick = false;
			AttemptClick(pointer);
		}
	}

	protected virtual bool IsEligibleClick(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		if (pointer.pointerEventData.eligibleForClick)
		{
			foreach (RaycastResult result in results)
			{
				if (ValidElement(result.gameObject))
				{
					GameObject gameObject = ExecuteEvents.ExecuteHierarchy(result.gameObject, pointer.pointerEventData, ExecuteEvents.pointerDownHandler);
					if (gameObject != null)
					{
						pointer.pointerEventData.pressPosition = pointer.pointerEventData.position;
						pointer.pointerEventData.pointerPressRaycast = result;
						pointer.pointerEventData.pointerPress = gameObject;
						return true;
					}
				}
			}
		}
		return false;
	}

	protected virtual bool AttemptClick(Pvr_UIPointer pointer)
	{
		if ((bool)pointer.pointerEventData.pointerPress)
		{
			if (!ValidElement(pointer.pointerEventData.pointerPress))
			{
				pointer.pointerEventData.pointerPress = null;
				return true;
			}
			if (pointer.pointerEventData.eligibleForClick)
			{
				if (!IsHovering(pointer))
				{
					ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerPress, pointer.pointerEventData, ExecuteEvents.pointerUpHandler);
					pointer.pointerEventData.pointerPress = null;
				}
			}
			else
			{
				pointer.OnUIPointerElementClick(pointer.SetUIPointerEvent(pointer.pointerEventData.pointerPressRaycast, pointer.pointerEventData.pointerPress));
				ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerPress, pointer.pointerEventData, ExecuteEvents.pointerClickHandler);
				ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerPress, pointer.pointerEventData, ExecuteEvents.pointerUpHandler);
				pointer.pointerEventData.pointerPress = null;
			}
			return true;
		}
		return false;
	}

	protected virtual void Drag(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		pointer.pointerEventData.dragging = pointer.IsSelectionButtonPressed() && pointer.pointerEventData.delta != Vector2.zero;
		if ((bool)pointer.pointerEventData.pointerDrag)
		{
			if (!ValidElement(pointer.pointerEventData.pointerDrag))
			{
				pointer.pointerEventData.pointerDrag = null;
				return;
			}
			if (pointer.pointerEventData.dragging)
			{
				if (IsHovering(pointer))
				{
					ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerDrag, pointer.pointerEventData, ExecuteEvents.dragHandler);
				}
				return;
			}
			ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerDrag, pointer.pointerEventData, ExecuteEvents.dragHandler);
			ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerDrag, pointer.pointerEventData, ExecuteEvents.endDragHandler);
			foreach (RaycastResult result in results)
			{
				ExecuteEvents.ExecuteHierarchy(result.gameObject, pointer.pointerEventData, ExecuteEvents.dropHandler);
			}
			pointer.pointerEventData.pointerDrag = null;
		}
		else
		{
			if (!pointer.pointerEventData.dragging)
			{
				return;
			}
			foreach (RaycastResult result2 in results)
			{
				if (ValidElement(result2.gameObject))
				{
					ExecuteEvents.ExecuteHierarchy(result2.gameObject, pointer.pointerEventData, ExecuteEvents.initializePotentialDrag);
					ExecuteEvents.ExecuteHierarchy(result2.gameObject, pointer.pointerEventData, ExecuteEvents.beginDragHandler);
					GameObject gameObject = ExecuteEvents.ExecuteHierarchy(result2.gameObject, pointer.pointerEventData, ExecuteEvents.dragHandler);
					if (gameObject != null)
					{
						pointer.pointerEventData.pointerDrag = gameObject;
						break;
					}
				}
			}
		}
	}
}
public class Pvr_UICanvas : MonoBehaviour
{
	public bool clickOnPointerCollision;

	public float autoActivateWithinDistance;

	protected BoxCollider canvasBoxCollider;

	protected Rigidbody canvasRigidBody;

	protected Coroutine draggablePanelCreation;

	protected const string CANVAS_DRAGGABLE_PANEL = "UICANVAS_DRAGGABLE_PANEL";

	protected virtual void OnEnable()
	{
		SetupCanvas();
	}

	protected virtual void OnDisable()
	{
		RemoveCanvas();
	}

	protected virtual void OnDestroy()
	{
		RemoveCanvas();
	}

	protected virtual void SetupCanvas()
	{
		Canvas component = GetComponent<Canvas>();
		if ((bool)component && component.renderMode == RenderMode.WorldSpace)
		{
			RectTransform component2 = component.GetComponent<RectTransform>();
			Vector2 sizeDelta = component2.sizeDelta;
			GraphicRaycaster component3 = component.gameObject.GetComponent<GraphicRaycaster>();
			Pvr_UIGraphicRaycaster pvr_UIGraphicRaycaster = component.gameObject.GetComponent<Pvr_UIGraphicRaycaster>();
			if (!pvr_UIGraphicRaycaster)
			{
				pvr_UIGraphicRaycaster = component.gameObject.AddComponent<Pvr_UIGraphicRaycaster>();
			}
			if ((bool)component3 && component3.enabled)
			{
				pvr_UIGraphicRaycaster.ignoreReversedGraphics = component3.ignoreReversedGraphics;
				pvr_UIGraphicRaycaster.blockingObjects = component3.blockingObjects;
				component3.enabled = false;
			}
			if (!component.gameObject.GetComponent<BoxCollider>())
			{
				float z = 0.1f / component2.localScale.z;
				canvasBoxCollider = component.gameObject.AddComponent<BoxCollider>();
				canvasBoxCollider.size = new Vector3(sizeDelta.x, sizeDelta.y, z);
				canvasBoxCollider.isTrigger = true;
			}
			if (!component.gameObject.GetComponent<Rigidbody>())
			{
				canvasRigidBody = component.gameObject.AddComponent<Rigidbody>();
				canvasRigidBody.isKinematic = true;
			}
			draggablePanelCreation = StartCoroutine(CreateDraggablePanel(component, sizeDelta));
		}
	}

	protected virtual IEnumerator CreateDraggablePanel(Canvas canvas, Vector2 canvasSize)
	{
		if ((bool)canvas && !canvas.transform.Find("UICANVAS_DRAGGABLE_PANEL"))
		{
			yield return null;
			GameObject obj = new GameObject("UICANVAS_DRAGGABLE_PANEL", typeof(RectTransform));
			obj.AddComponent<LayoutElement>().ignoreLayout = true;
			obj.AddComponent<Image>().color = Color.clear;
			obj.AddComponent<EventTrigger>();
			obj.transform.SetParent(canvas.transform);
			obj.GetComponent<RectTransform>().sizeDelta = canvasSize;
			obj.transform.localPosition = Vector3.zero;
			obj.transform.localRotation = Quaternion.identity;
			obj.transform.localScale = Vector3.one;
			obj.transform.SetAsFirstSibling();
		}
	}

	protected virtual void RemoveCanvas()
	{
		Canvas component = GetComponent<Canvas>();
		if ((bool)component)
		{
			GraphicRaycaster component2 = component.gameObject.GetComponent<GraphicRaycaster>();
			Pvr_UIGraphicRaycaster component3 = component.gameObject.GetComponent<Pvr_UIGraphicRaycaster>();
			if ((bool)component3)
			{
				UnityEngine.Object.Destroy(component3);
			}
			if ((bool)component2 && !component2.enabled)
			{
				component2.enabled = true;
			}
			if ((bool)canvasBoxCollider)
			{
				UnityEngine.Object.Destroy(canvasBoxCollider);
			}
			if ((bool)canvasRigidBody)
			{
				UnityEngine.Object.Destroy(canvasRigidBody);
			}
			StopCoroutine(draggablePanelCreation);
			Transform transform = component.transform.Find("UICANVAS_DRAGGABLE_PANEL");
			if ((bool)transform)
			{
				UnityEngine.Object.Destroy(transform.gameObject);
			}
		}
	}
}
public struct UIDraggableItemEventArgs
{
	public GameObject target;
}
public delegate void UIDraggableItemEventHandler(object sender, UIDraggableItemEventArgs e);
public class Pvr_UIDraggableItem : MonoBehaviour, IBeginDragHandler, IEventSystemHandler, IDragHandler, IEndDragHandler
{
	public bool restrictToDropZone;

	public bool restrictToOriginalCanvas;

	public float moveOffset = 0.1f;

	[HideInInspector]
	public GameObject validDropZone;

	protected RectTransform dragTransform;

	protected Vector3 startPosition;

	protected Quaternion startRotation;

	protected GameObject startDropZone;

	protected Transform startParent;

	protected Canvas startCanvas;

	protected CanvasGroup canvasGroup;

	protected Pvr_InputModule currentInputmodule;

	public event UIDraggableItemEventHandler DraggableItemDropped;

	public event UIDraggableItemEventHandler DraggableItemReset;

	public virtual void OnDraggableItemDropped(UIDraggableItemEventArgs e)
	{
		if (this.DraggableItemDropped != null)
		{
			this.DraggableItemDropped(this, e);
		}
	}

	public virtual void OnDraggableItemReset(UIDraggableItemEventArgs e)
	{
		if (this.DraggableItemReset != null)
		{
			this.DraggableItemReset(this, e);
		}
	}

	public void OnBeginDrag(PointerEventData eventData)
	{
		startPosition = base.transform.position;
		startRotation = base.transform.rotation;
		startParent = base.transform.parent;
		startCanvas = GetComponentInParent<Canvas>();
		canvasGroup.blocksRaycasts = false;
		if (restrictToDropZone)
		{
			startDropZone = GetComponentInParent<Pvr_UIDropZone>().gameObject;
			validDropZone = startDropZone;
		}
		SetDragPosition(eventData);
		Pvr_UIPointer pointer = GetPointer();
		if (pointer != null)
		{
			pointer.OnUIPointerElementDragStart(pointer.SetUIPointerEvent(pointer.pointerEventData.pointerPressRaycast, base.gameObject));
		}
	}

	public void OnDrag(PointerEventData eventData)
	{
		SetDragPosition(eventData);
	}

	public void OnEndDrag(PointerEventData eventData)
	{
		canvasGroup.blocksRaycasts = true;
		dragTransform = null;
		base.transform.position += base.transform.forward * moveOffset;
		bool flag = true;
		if (restrictToDropZone)
		{
			if (validDropZone != null && validDropZone != startDropZone)
			{
				base.transform.SetParent(validDropZone.transform);
			}
			else
			{
				ResetElement();
				flag = false;
			}
		}
		Canvas canvas = ((eventData.pointerEnter != null) ? eventData.pointerEnter.GetComponentInParent<Canvas>() : null);
		if (restrictToOriginalCanvas && canvas != null && canvas != startCanvas)
		{
			ResetElement();
			flag = false;
		}
		if (canvas == null)
		{
			ResetElement();
			flag = false;
		}
		if (flag)
		{
			Pvr_UIPointer pointer = GetPointer();
			if (pointer != null)
			{
				pointer.OnUIPointerElementDragEnd(pointer.SetUIPointerEvent(pointer.pointerEventData.pointerPressRaycast, base.gameObject));
			}
			OnDraggableItemDropped(SetEventPayload(validDropZone));
		}
		validDropZone = null;
		startParent = null;
		startCanvas = null;
	}

	protected virtual void OnEnable()
	{
		canvasGroup = GetComponent<CanvasGroup>();
		if (restrictToDropZone && GetComponentInParent<Pvr_UIDropZone>() == null)
		{
			base.enabled = false;
		}
		currentInputmodule = UnityEngine.Object.FindObjectOfType<Pvr_InputModule>();
	}

	protected virtual Pvr_UIPointer GetPointer()
	{
		foreach (Pvr_UIPointer pointer in Pvr_InputModule.pointers)
		{
			if (pointer.gameObject.activeInHierarchy && (bool)pointer)
			{
				return pointer;
			}
		}
		return null;
	}

	protected virtual void SetDragPosition(PointerEventData eventData)
	{
		if (eventData.pointerEnter != null && eventData.pointerEnter.transform as RectTransform != null)
		{
			dragTransform = eventData.pointerEnter.transform as RectTransform;
		}
		if (dragTransform != null && RectTransformUtility.ScreenPointToWorldPointInRectangle(dragTransform, eventData.position, eventData.pressEventCamera, out var worldPoint))
		{
			base.transform.position = worldPoint - base.transform.forward * moveOffset;
			base.transform.rotation = dragTransform.rotation;
		}
	}

	protected virtual void ResetElement()
	{
		base.transform.position = startPosition;
		base.transform.rotation = startRotation;
		base.transform.SetParent(startParent);
		OnDraggableItemReset(SetEventPayload(startParent.gameObject));
	}

	protected virtual UIDraggableItemEventArgs SetEventPayload(GameObject target)
	{
		UIDraggableItemEventArgs result = default(UIDraggableItemEventArgs);
		result.target = target;
		return result;
	}
}
public class Pvr_UIDropZone : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler
{
	protected Pvr_UIDraggableItem droppableItem;

	public void OnPointerEnter(PointerEventData eventData)
	{
		if ((bool)eventData.pointerDrag)
		{
			Pvr_UIDraggableItem component = eventData.pointerDrag.GetComponent<Pvr_UIDraggableItem>();
			if ((bool)component && component.restrictToDropZone)
			{
				component.validDropZone = base.gameObject;
				droppableItem = component;
			}
		}
	}

	public void OnPointerExit(PointerEventData eventData)
	{
		if ((bool)droppableItem)
		{
			droppableItem.validDropZone = null;
		}
		droppableItem = null;
	}
}
public class Pvr_UIGraphicRaycaster : GraphicRaycaster
{
	protected Canvas currentCanvas;

	protected Vector2 lastKnownPosition;

	protected const float UI_CONTROL_OFFSET = 1E-05f;

	[NonSerialized]
	private static List<RaycastResult> s_RaycastResults = new List<RaycastResult>();

	protected virtual Canvas canvas
	{
		get
		{
			if (currentCanvas != null)
			{
				return currentCanvas;
			}
			currentCanvas = base.gameObject.GetComponent<Canvas>();
			return currentCanvas;
		}
	}

	public override void Raycast(PointerEventData eventData, List<RaycastResult> resultAppendList)
	{
		if (!(canvas == null))
		{
			Raycast(ray: new Ray(eventData.pointerCurrentRaycast.worldPosition, eventData.pointerCurrentRaycast.worldNormal), canvas: canvas, eventCamera: eventCamera, results: ref s_RaycastResults);
			SetNearestRaycast(ref eventData, ref resultAppendList, ref s_RaycastResults);
			s_RaycastResults.Clear();
		}
	}

	protected virtual void SetNearestRaycast(ref PointerEventData eventData, ref List<RaycastResult> resultAppendList, ref List<RaycastResult> raycastResults)
	{
		RaycastResult? raycastResult = null;
		for (int i = 0; i < raycastResults.Count; i++)
		{
			RaycastResult raycastResult2 = raycastResults[i];
			raycastResult2.index = resultAppendList.Count;
			if (!raycastResult.HasValue || raycastResult2.distance < raycastResult.Value.distance)
			{
				raycastResult = raycastResult2;
			}
			resultAppendList.Add(raycastResult2);
		}
		if (raycastResult.HasValue)
		{
			eventData.position = raycastResult.Value.screenPosition;
			eventData.delta = eventData.position - lastKnownPosition;
			lastKnownPosition = eventData.position;
			eventData.pointerCurrentRaycast = raycastResult.Value;
		}
	}

	protected virtual float GetHitDistance(Ray ray)
	{
		float result = float.MaxValue;
		if (canvas.renderMode != 0 && base.blockingObjects != 0)
		{
			float num = Vector3.Distance(ray.origin, canvas.transform.position);
			if (base.blockingObjects == BlockingObjects.ThreeD || base.blockingObjects == BlockingObjects.All)
			{
				Physics.Raycast(ray, out var hitInfo, num);
				if ((bool)hitInfo.collider)
				{
					result = hitInfo.distance;
				}
			}
			if (base.blockingObjects == BlockingObjects.TwoD || base.blockingObjects == BlockingObjects.All)
			{
				RaycastHit2D raycastHit2D = Physics2D.Raycast(ray.origin, ray.direction, num);
				if (raycastHit2D.collider != null)
				{
					result = raycastHit2D.fraction * num;
				}
			}
		}
		return result;
	}

	protected virtual void Raycast(Canvas canvas, Camera eventCamera, Ray ray, ref List<RaycastResult> results)
	{
		float hitDistance = GetHitDistance(ray);
		IList<Graphic> graphicsForCanvas = GraphicRegistry.GetGraphicsForCanvas(canvas);
		for (int i = 0; i < graphicsForCanvas.Count; i++)
		{
			Graphic graphic = graphicsForCanvas[i];
			if (graphic.depth == -1 || !graphic.raycastTarget)
			{
				continue;
			}
			Transform transform = graphic.transform;
			Vector3 forward = transform.forward;
			float num = Vector3.Dot(forward, transform.position - ray.origin) / Vector3.Dot(forward, ray.direction);
			if (!(num < 0f) && !(num - 1E-05f > hitDistance))
			{
				Vector3 point = ray.GetPoint(num);
				Vector2 vector = eventCamera.WorldToScreenPoint(point);
				if (RectTransformUtility.RectangleContainsScreenPoint(graphic.rectTransform, vector, eventCamera) && graphic.Raycast(vector, eventCamera))
				{
					RaycastResult raycastResult = default(RaycastResult);
					raycastResult.gameObject = graphic.gameObject;
					raycastResult.module = this;
					raycastResult.distance = num;
					raycastResult.screenPosition = vector;
					raycastResult.worldPosition = point;
					raycastResult.depth = graphic.depth;
					raycastResult.sortingLayer = canvas.sortingLayerID;
					raycastResult.sortingOrder = canvas.sortingOrder;
					RaycastResult item = raycastResult;
					results.Add(item);
				}
			}
		}
		results.Sort((RaycastResult g1, RaycastResult g2) => g2.depth.CompareTo(g1.depth));
	}
}
public struct UIPointerEventArgs
{
	public bool isActive;

	public GameObject currentTarget;

	public GameObject previousTarget;

	public RaycastResult raycastResult;
}
public delegate void UIPointerEventHandler(object sender, UIPointerEventArgs e);
public class Pvr_UIPointer : MonoBehaviour
{
	public enum ClickMethods
	{
		ClickOnButtonUp,
		ClickOnButtonDown
	}

	public ClickMethods clickMethod;

	[HideInInspector]
	public bool collisionClick;

	[HideInInspector]
	public bool pressToDrag;

	[HideInInspector]
	public GameObject autoActivatingCanvas;

	[HideInInspector]
	public PointerEventData pointerEventData;

	[HideInInspector]
	public GameObject hoveringElement;

	[HideInInspector]
	public float hoverDurationTimer;

	[HideInInspector]
	public bool canClickOnHover;

	public Transform pointerOriginTransform;

	protected bool pointerClicked;

	protected bool beamEnabledState;

	protected bool lastPointerPressState;

	protected bool lastPointerClickState;

	protected GameObject currentTarget;

	protected EventSystem cachedEventSystem;

	protected Pvr_InputModule cachedVRInputModule;

	protected Transform originalPointerOriginTransform;

	public static bool TouchBtnValue;

	public static bool AppBtnValue;

	public static bool TriggerBtnValue;

	public event UIPointerEventHandler UIPointerElementEnter;

	public event UIPointerEventHandler UIPointerElementExit;

	public event UIPointerEventHandler UIPointerElementClick;

	public event UIPointerEventHandler UIPointerElementDragStart;

	public event UIPointerEventHandler UIPointerElementDragEnd;

	public virtual bool PointerActive()
	{
		return true;
	}

	public virtual bool IsSelectionButtonPressed()
	{
		if (!Input.GetMouseButton(0) && !Input.GetKey(KeyCode.JoystickButton0) && !TouchBtnValue && !AppBtnValue)
		{
			return TriggerBtnValue;
		}
		return true;
	}

	public virtual Vector3 GetOriginPosition()
	{
		if (!pointerOriginTransform)
		{
			return base.transform.position;
		}
		return pointerOriginTransform.position;
	}

	public virtual Vector3 GetOriginForward()
	{
		if (!pointerOriginTransform)
		{
			return base.transform.forward;
		}
		return pointerOriginTransform.forward;
	}

	public virtual bool ValidClick(bool checkLastClick, bool lastClickState = false)
	{
		bool result = (collisionClick ? collisionClick : IsSelectionButtonPressed());
		if (!checkLastClick)
		{
			return result;
		}
		return result;
	}

	protected virtual void ResetHoverTimer()
	{
		hoverDurationTimer = 0f;
		canClickOnHover = false;
	}

	public virtual void OnUIPointerElementEnter(UIPointerEventArgs e)
	{
		if (e.currentTarget != currentTarget)
		{
			ResetHoverTimer();
		}
		currentTarget = e.currentTarget;
		if (this.UIPointerElementEnter != null)
		{
			this.UIPointerElementEnter(this, e);
		}
	}

	public virtual void OnUIPointerElementExit(UIPointerEventArgs e)
	{
		if (e.previousTarget == currentTarget)
		{
			ResetHoverTimer();
		}
		if (this.UIPointerElementExit != null)
		{
			this.UIPointerElementExit(this, e);
		}
	}

	public virtual void OnUIPointerElementClick(UIPointerEventArgs e)
	{
		if (e.currentTarget == currentTarget)
		{
			ResetHoverTimer();
		}
		if (this.UIPointerElementClick != null)
		{
			this.UIPointerElementClick(this, e);
		}
	}

	public virtual void OnUIPointerElementDragStart(UIPointerEventArgs e)
	{
		if (this.UIPointerElementDragStart != null)
		{
			this.UIPointerElementDragStart(this, e);
		}
	}

	public virtual void OnUIPointerElementDragEnd(UIPointerEventArgs e)
	{
		if (this.UIPointerElementDragEnd != null)
		{
			this.UIPointerElementDragEnd(this, e);
		}
	}

	public virtual UIPointerEventArgs SetUIPointerEvent(RaycastResult currentRaycastResult, GameObject currentTarget, GameObject lastTarget = null)
	{
		UIPointerEventArgs result = default(UIPointerEventArgs);
		result.isActive = PointerActive();
		result.currentTarget = currentTarget;
		result.previousTarget = lastTarget;
		result.raycastResult = currentRaycastResult;
		return result;
	}

	protected virtual void Awake()
	{
		originalPointerOriginTransform = pointerOriginTransform;
	}

	protected virtual void OnEnable()
	{
		pointerOriginTransform = originalPointerOriginTransform;
		ConfigureEventSystem();
		pointerClicked = false;
		lastPointerPressState = false;
		lastPointerClickState = false;
		beamEnabledState = false;
	}

	protected virtual void OnDisable()
	{
		Pvr_InputModule.RemovePoint(this);
	}

	protected virtual void ConfigureEventSystem()
	{
		if (!cachedEventSystem)
		{
			cachedEventSystem = UnityEngine.Object.FindObjectOfType<EventSystem>();
		}
		if (!cachedVRInputModule)
		{
			cachedVRInputModule = cachedEventSystem.GetComponent<Pvr_InputModule>();
		}
		if ((bool)cachedEventSystem && (bool)cachedVRInputModule && pointerEventData == null)
		{
			pointerEventData = new PointerEventData(cachedEventSystem);
		}
		Pvr_InputModule.AddPoint(this);
	}
}
[ExecuteInEditMode]
public class Pvr_UnitySDKEditor : MonoBehaviour
{
	private bool vrModeEnabled = true;

	private float mouseX;

	private float mouseY;

	private float mouseZ;

	private float neckModelScale;

	private bool autoUntiltHead;

	private static readonly Vector3 neckOffset = new Vector3(0f, 0.075f, 0.0805f);

	[HideInInspector]
	public Matrix4x4 headView;

	[HideInInspector]
	public Matrix4x4 leftEyeUndistortedProj;

	[HideInInspector]
	public Matrix4x4 rightEyeUndistortedProj;

	[HideInInspector]
	public Matrix4x4 leftEyeProj;

	[HideInInspector]
	public Matrix4x4 rightEyeProj;

	private const float TOUCH_TIME_LIMIT = 0.2f;

	private float touchStartTime;

	public Matrix4x4 UndistortedProjection(Eye eye)
	{
		if (eye != 0)
		{
			return rightEyeUndistortedProj;
		}
		return leftEyeUndistortedProj;
	}

	public Matrix4x4 Projection(Eye eye)
	{
		if (eye != 0)
		{
			return rightEyeProj;
		}
		return leftEyeProj;
	}

	private void Awake()
	{
		InitEyePara();
		InitEditorSensorPara();
	}

	private void Update()
	{
		SimulateInput();
		Pvr_UnitySDKManager.SDK.picovrTriggered = Pvr_UnitySDKManager.SDK.newPicovrTriggered;
		Pvr_UnitySDKManager.SDK.newPicovrTriggered = false;
	}

	public void InitEyePara()
	{
		ComputeEyesFromProfile();
		InitForEye(ref Pvr_UnitySDKManager.SDK.Eyematerial, ref Pvr_UnitySDKManager.SDK.Middlematerial);
		if (Pvr_UnitySDKRender.Instance == null)
		{
			PLOG.I("pvr_UnitySDKRender init failed");
		}
		if (Pvr_UnitySDKSensor.Instance == null)
		{
			PLOG.I("pvr_UnitySDKSensor init failed");
		}
		FovAdjust();
	}

	private void InitEditorSensorPara()
	{
		Pvr_UnitySDKManager.SDK.picovrTriggered = Pvr_UnitySDKManager.SDK.newPicovrTriggered;
		Pvr_UnitySDKManager.SDK.newPicovrTriggered = false;
	}

	public static Matrix4x4 MakeProjection(float l, float t, float r, float b, float n, float f)
	{
		Matrix4x4 zero = Matrix4x4.zero;
		zero[0, 0] = 2f * n / (r - l);
		zero[1, 1] = 2f * n / (t - b);
		zero[0, 2] = (r + l) / (r - l);
		zero[1, 2] = (t + b) / (t - b);
		zero[2, 2] = (n + f) / (n - f);
		zero[2, 3] = 2f * n * f / (n - f);
		zero[3, 2] = -1f;
		return zero;
	}

	public bool UpdateStatesensor()
	{
		UpdateSimulatedSensor();
		return true;
	}

	public void ComputeEyesFromProfile()
	{
		Vector2 vector = new Vector2(0.11f, 0.062f);
		Pvr_UnitySDKManager.SDK.leftEyeView = Matrix4x4.identity;
		Pvr_UnitySDKManager.SDK.leftEyeView[0, 3] = (0f - Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.device.devLenses.separation) / 2f;
		float[] leftEyeVisibleTanAngles = Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.GetLeftEyeVisibleTanAngles(vector.x, vector.y);
		leftEyeProj = MakeProjection(leftEyeVisibleTanAngles[0], leftEyeVisibleTanAngles[1], leftEyeVisibleTanAngles[2], leftEyeVisibleTanAngles[3], 1f, 1000f);
		leftEyeVisibleTanAngles = Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.GetLeftEyeNoLensTanAngles(vector.x, vector.y);
		leftEyeUndistortedProj = MakeProjection(leftEyeVisibleTanAngles[0], leftEyeVisibleTanAngles[1], leftEyeVisibleTanAngles[2], leftEyeVisibleTanAngles[3], 1f, 1000f);
		Pvr_UnitySDKManager.SDK.leftEyeRect = Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.GetLeftEyeVisibleScreenRect(leftEyeVisibleTanAngles, vector.x, vector.y);
		Pvr_UnitySDKManager.SDK.rightEyeView = Pvr_UnitySDKManager.SDK.leftEyeView;
		Pvr_UnitySDKManager.SDK.rightEyeView[0, 3] *= -1f;
		rightEyeProj = leftEyeProj;
		rightEyeProj[0, 2] *= -1f;
		rightEyeUndistortedProj = leftEyeUndistortedProj;
		rightEyeUndistortedProj[0, 2] *= -1f;
		Rect leftEyeRect = new Rect(0f, 0f, 0.5f, 1f);
		Rect rightEyeRect = new Rect(0.5f, 0f, 0.5f, 1f);
		Pvr_UnitySDKManager.SDK.leftEyeRect = leftEyeRect;
		Pvr_UnitySDKManager.SDK.rightEyeRect = rightEyeRect;
		Pvr_UnitySDKManager.SDK.leftEyeOffset = new Vector3((0f - Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.device.devLenses.separation) / 2f, 0f, 0f);
		Pvr_UnitySDKManager.SDK.rightEyeOffset = new Vector3(Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.device.devLenses.separation / 2f, 0f, 0f);
	}

	public bool ResetUnitySDKSensor()
	{
		mouseX = (mouseY = (mouseZ = 0f));
		return true;
	}

	private void SimulateInput()
	{
		if (Input.GetMouseButtonDown(0) && (Input.GetKey(KeyCode.LeftAlt) || Input.GetKey(KeyCode.RightAlt)))
		{
			EnableVEmodel();
		}
		if (Input.GetMouseButtonDown(0))
		{
			touchStartTime = Time.time;
		}
		else if (Input.GetMouseButtonUp(0))
		{
			if (Time.time - touchStartTime <= 0.2f)
			{
				Pvr_UnitySDKManager.SDK.newPicovrTriggered = true;
			}
			touchStartTime = 0f;
		}
		UpdateSimulatedSensor();
	}

	private void FovAdjust()
	{
		Pvr_UnitySDKRender.Instance.EyeVFoV = 2f * Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.device.devMaxFov.upper;
	}

	private Rect RectAdjust(Rect eyeRect)
	{
		Rect result = new Rect(0f, 0f, 0.5f, 1f);
		result.width *= 2f * eyeRect.width;
		result.x = eyeRect.x + 2f * result.x * eyeRect.width;
		result.height *= eyeRect.height;
		result.y = eyeRect.y + result.y * eyeRect.height;
		return result;
	}

	private void UpdateSimulatedSensor()
	{
		bool flag = false;
		if (Input.GetKey(KeyCode.LeftAlt) || Input.GetKey(KeyCode.RightAlt))
		{
			mouseX += Input.GetAxis("Mouse X") * 5f;
			if (mouseX <= -180f)
			{
				mouseX += 360f;
			}
			else if (mouseX > 180f)
			{
				mouseX -= 360f;
			}
			mouseY -= Input.GetAxis("Mouse Y") * 2.4f;
			mouseY = Mathf.Clamp(mouseY, -91f, 91f);
		}
		else if (Input.GetKey(KeyCode.LeftControl) || Input.GetKey(KeyCode.RightControl))
		{
			flag = true;
			mouseZ += Input.GetAxis("Mouse X") * 5f;
			mouseZ = Mathf.Clamp(mouseZ, -91f, 91f);
		}
		if (!flag && autoUntiltHead)
		{
			mouseZ = Mathf.Lerp(mouseZ, 0f, Time.deltaTime / (Time.deltaTime + 0.1f));
		}
		Quaternion quaternion = Quaternion.Euler(mouseY, mouseX, mouseZ);
		Matrix4x4 matrix = Matrix4x4.TRS((quaternion * neckOffset - neckOffset.y * Vector3.up) * neckModelScale, quaternion, Vector3.one);
		Pvr_UnitySDKSensor.Instance.HeadPose = new Pvr_UnitySDKPose(matrix);
	}

	private void InitForEye(ref Material mat, ref Material mat1)
	{
		Shader shader = Shader.Find("Pvr_UnitySDK/Undistortion");
		Shader shader2 = Shader.Find("Pvr_UnitySDK/FillColor");
		if (shader == null || shader2 == null)
		{
			PLOG.E("Ths Shader Missing ");
			return;
		}
		mat = new Material(shader);
		mat1 = new Material(shader2);
	}

	private void EnableVEmodel()
	{
		vrModeEnabled = !vrModeEnabled;
		Pvr_UnitySDKManager.SDK.VRModeEnabled = vrModeEnabled;
	}
}
public class Pvr_VolumePowerBrightness : MonoBehaviour
{
	private bool VolEnable;

	private bool BattEnable;

	public Text showResult;

	public Text setVolumnum;

	public Text setBrightnum;

	public string MusicPath;

	private void Awake()
	{
		InitBatteryVolClass();
		string startreceivre = base.gameObject.name;
		StartBatteryReceiver(startreceivre);
		StartAudioReceiver(startreceivre);
	}

	private void OnDisable()
	{
		if (VolEnable)
		{
			StopAudioReceiver();
		}
		if (BattEnable)
		{
			StopBatteryReceiver();
		}
	}

	public void GetMaxVolumeNumber()
	{
		int num = 0;
		num = VolumePowerBrightness.UPvr_GetMaxVolumeNumber();
		showResult.text = "Maximum volume: " + num;
	}

	public void GetCurrentVolumeNumber()
	{
		int num = 0;
		num = VolumePowerBrightness.UPvr_GetCurrentVolumeNumber();
		showResult.text = "Current volume" + num;
	}

	public void VolumeUp()
	{
		if (!VolumePowerBrightness.UPvr_VolumeUp())
		{
			PLOG.E("VolumeUp Error");
		}
	}

	public void VolumeDown()
	{
		if (!VolumePowerBrightness.UPvr_VolumeDown())
		{
			PLOG.E("VolumeDown Error");
		}
	}

	public void SetVolumeNum()
	{
		int volume = new System.Random().Next(0, 15);
		setVolumnum.text = "Random number" + volume;
		if (!VolumePowerBrightness.UPvr_SetVolumeNum(volume))
		{
			PLOG.E("SetVolumeNum Error");
		}
	}

	public void SetBrightness()
	{
		int brightness = new System.Random().Next(0, 255);
		setBrightnum.text = "Random number" + brightness;
		if (!VolumePowerBrightness.UPvr_SetCommonBrightness(brightness))
		{
			PLOG.E("SetBrightness Error");
		}
	}

	public void GetCurrentBrightness()
	{
		int num = 0;
		num = VolumePowerBrightness.UPvr_GetCommonBrightness();
		showResult.text = "Current brightness" + num;
	}

	public bool setAudio(string s)
	{
		PLOG.I(s.ToString());
		return true;
	}

	public bool setBattery(string s)
	{
		PLOG.I(s.ToString());
		return true;
	}

	private bool InitBatteryVolClass()
	{
		return VolumePowerBrightness.UPvr_InitBatteryVolClass();
	}

	private bool StartBatteryReceiver(string startreceivre)
	{
		BattEnable = VolumePowerBrightness.UPvr_StartBatteryReceiver(startreceivre);
		return BattEnable;
	}

	private bool StopBatteryReceiver()
	{
		return VolumePowerBrightness.UPvr_StopBatteryReceiver();
	}

	private bool StartAudioReceiver(string startreceivre)
	{
		VolEnable = VolumePowerBrightness.UPvr_StartAudioReceiver(startreceivre);
		return VolEnable;
	}

	private bool StopAudioReceiver()
	{
		return VolumePowerBrightness.UPvr_StopAudioReceiver();
	}
}
public class BallColorPicker : MonoBehaviour
{
	public Color color;

	public Renderer ballRenderer;

	private List<PauseButton> pauseButtons = new List<PauseButton>();

	private void Start()
	{
		foreach (Transform item in base.transform.parent)
		{
			if (item.GetComponent<PauseButton>() != null)
			{
				pauseButtons.Add(item.GetComponent<PauseButton>());
			}
		}
		ballRenderer.material.color = color;
	}

	private void OnEnable()
	{
		if (color == GameManager.instance.GetBallColor())
		{
			GetComponent<PauseButton>().Highlight();
			GetComponent<PauseButton>().stayHighlighted = true;
		}
		else
		{
			GetComponent<PauseButton>().UnHighlight();
			GetComponent<PauseButton>().stayHighlighted = false;
		}
	}

	public void OnBallColorSelected()
	{
		ScoreManager.instance.playerTurn[GameManager.instance.playerIndex].ballColor = color;
		if (ScoreManager.instance.currentScoreCard.playerNames.Length != 0)
		{
			ScoreManager.instance.currentScoreCard.playerGolfballs[GameManager.instance.playerIndex].color = color;
		}
		if (GameManager.instance.playerIndex == 0)
		{
			GameManager.instance.SetBallColor(color);
		}
		else
		{
			GameManager.instance.SetBallColor(color, saveBallColor: false);
		}
		for (int i = 0; i < pauseButtons.Count; i++)
		{
			pauseButtons[i].stayHighlighted = false;
			pauseButtons[i].UnHighlight();
		}
		GetComponent<PauseButton>().stayHighlighted = true;
		GetComponent<PauseButton>().Highlight();
		SetMinimapIcons();
	}

	private void SetMinimapIcons()
	{
		Player.instance.minimapPlayerMarker.color = color;
		if (GameManager.instance.golfball != null)
		{
			GameManager.instance.golfball.minimapIcon.color = color;
		}
	}
}
public class CampaignHoleButton : PointerButton
{
	public CampaignDetailPanel campaignDetailPanel;

	public Difficulty difficulty;

	public int holeIndex;

	public bool boss;

	public WorkshopData workshopData;

	public Text holeNumberText;

	public Image bossIcon;

	private bool highlightNumber;

	public void GetWorkshopData()
	{
		if (!boss)
		{
			workshopData = GameManager.instance.campaignWorkshopData[holeIndex];
		}
	}

	private void UnlockHole()
	{
		bool flag = false;
		if (GameManager.instance.unlockAllHoles)
		{
			flag = true;
		}
		else
		{
			int num = SaveFileManager.instance.saveFile.campaignHoleScore[holeIndex];
			int num2 = 0;
			if (holeIndex > 0)
			{
				num2 = SaveFileManager.instance.saveFile.campaignHoleScore[holeIndex - 1];
			}
			if (boss)
			{
				SaveFile saveFile = SaveFileManager.instance.saveFile;
				if (holeIndex == 0)
				{
					if (saveFile.campaignHoleScore[17] > 0)
					{
						flag = true;
					}
				}
				else if (holeIndex == 1)
				{
					if (saveFile.campaignHoleScore[35] > 0 && saveFile.bossScore[0] > 0)
					{
						flag = true;
					}
				}
				else if (holeIndex == 2 && saveFile.campaignHoleScore[53] > 0 && saveFile.bossScore[1] > 0)
				{
					flag = true;
				}
			}
			else if (difficulty == Difficulty.Easy)
			{
				if ((holeIndex > 0 && num > 0) || holeIndex == 0)
				{
					flag = true;
				}
				else if (holeIndex > 0 && num2 > 0 && num2 != 0)
				{
					flag = true;
					highlightNumber = true;
				}
			}
			else if (holeIndex > 0)
			{
				if (difficulty == Difficulty.Medium)
				{
					if (GameManager.instance.hideBosses)
					{
						if ((num != 0 && num <= workshopData.par + 3) || holeIndex == 0)
						{
							flag = true;
						}
						else if (holeIndex > 0 && num2 <= campaignDetailPanel.campaignHoles[holeIndex - 1].workshopData.par + 3 && num2 != 0)
						{
							flag = true;
							highlightNumber = true;
						}
					}
					else if (SaveFileManager.instance.saveFile.bossScore[0] != 0)
					{
						if (holeIndex == 18)
						{
							flag = true;
							if (num > workshopData.par + 3 || num == 0)
							{
								highlightNumber = true;
							}
						}
						else if ((num != 0 && num <= workshopData.par + 3) || holeIndex == 0)
						{
							flag = true;
						}
						else if (holeIndex > 0 && num2 <= campaignDetailPanel.campaignHoles[holeIndex - 1].workshopData.par + 3 && num2 != 0)
						{
							flag = true;
							highlightNumber = true;
						}
					}
				}
				else if (difficulty == Difficulty.Hard)
				{
					if (GameManager.instance.hideBosses)
					{
						if ((num != 0 && num <= workshopData.par + 2) || holeIndex == 0)
						{
							flag = true;
						}
						else if (holeIndex > 0 && num2 <= campaignDetailPanel.campaignHoles[holeIndex - 1].workshopData.par + 2 && num2 != 0)
						{
							flag = true;
							highlightNumber = true;
						}
					}
					else if (SaveFileManager.instance.saveFile.bossScore[1] != 0)
					{
						if (holeIndex == 36)
						{
							flag = true;
							if (num > workshopData.par + 2 || num == 0)
							{
								highlightNumber = true;
							}
						}
						else if ((num != 0 && num <= workshopData.par + 2) || holeIndex == 0)
						{
							flag = true;
						}
						else if (holeIndex > 0 && num2 <= campaignDetailPanel.campaignHoles[holeIndex - 1].workshopData.par + 2 && num2 != 0)
						{
							flag = true;
							highlightNumber = true;
						}
					}
				}
			}
			else
			{
				flag = true;
			}
		}
		if (flag)
		{
			base.gameObject.SetActive(value: true);
		}
	}

	private void LockHoles()
	{
		base.gameObject.SetActive(value: false);
	}

	public void SetCampaignPanelData()
	{
		campaignDetailPanel.infoCanvas.SetActive(value: true);
		if (boss)
		{
			campaignDetailPanel.SetBossCampaignPanel(this, GetHoleButtonIndex());
		}
		else
		{
			campaignDetailPanel.SetCampaignPanel(this, GetHoleButtonIndex());
		}
	}

	public int GetHoleButtonIndex()
	{
		int result = 0;
		if (boss)
		{
			if (holeIndex == 0)
			{
				result = 18;
			}
			else if (holeIndex == 1)
			{
				result = 37;
			}
			else if (holeIndex == 2)
			{
				result = 56;
			}
		}
		else if (holeIndex < 18)
		{
			result = holeIndex;
		}
		else if (holeIndex < 36)
		{
			result = holeIndex + 1;
		}
		else if (holeIndex < 54)
		{
			result = holeIndex + 2;
		}
		return result;
	}

	public override void Highlight()
	{
		base.Highlight();
		campaignDetailPanel.HighlightButton(GetHoleButtonIndex());
	}

	public override void UnHighlight()
	{
		campaignDetailPanel.UnHighlight();
	}

	public void CheckUnlockHole()
	{
		GetWorkshopData();
		LockHoles();
		UnlockHole();
		HighlightHoleNumber();
	}

	private void HighlightHoleNumber()
	{
		if (highlightNumber)
		{
			if (boss)
			{
				bossIcon.color = Color.red;
			}
			else
			{
				holeNumberText.color = Color.cyan;
			}
		}
	}
}
public class ClubPowerButton : PointerButton
{
	public Image image;

	public Text power;

	public ClubType type;

	public Color highlightColor;

	private Color unhighlightColor;

	private float maxPower = 2f;

	private float currentPower = 1f;

	private void Start()
	{
		if (type == ClubType.Driver)
		{
			currentPower = GameManager.instance.GetClubPower(ClubType.Driver);
		}
		else if (type == ClubType.Iron)
		{
			currentPower = GameManager.instance.GetClubPower(ClubType.Iron);
		}
		else if (type == ClubType.Putter)
		{
			currentPower = GameManager.instance.GetClubPower(ClubType.Putter);
		}
		power.text = "x" + currentPower.ToString("F1");
		unhighlightColor = image.color;
	}

	public override void Highlight()
	{
		base.Highlight();
		image.color = highlightColor;
	}

	public override void UnHighlight()
	{
		image.color = unhighlightColor;
	}

	public void OnClubPowerButton(float x)
	{
		if (type == ClubType.Driver)
		{
			currentPower = GameManager.instance.GetClubPower(ClubType.Driver);
		}
		else if (type == ClubType.Iron)
		{
			currentPower = GameManager.instance.GetClubPower(ClubType.Iron);
		}
		else if (type == ClubType.Putter)
		{
			currentPower = GameManager.instance.GetClubPower(ClubType.Putter);
		}
		currentPower += x;
		if (currentPower > maxPower)
		{
			currentPower = maxPower;
		}
		else if (currentPower < 0.2f)
		{
			currentPower = 0.2f;
		}
		power.text = "x" + currentPower.ToString("F1");
		if (type == ClubType.Driver)
		{
			GameManager.instance.SetClubPower(ClubType.Driver, currentPower);
		}
		else if (type == ClubType.Iron)
		{
			GameManager.instance.SetClubPower(ClubType.Iron, currentPower);
		}
		else if (type == ClubType.Putter)
		{
			GameManager.instance.SetClubPower(ClubType.Putter, currentPower);
		}
	}
}
public class FAQButton : ImageButton
{
	public MessageBoard mb;

	public int FAQIndex;

	public TextMeshProUGUI title;

	private void OnEnable()
	{
		LocalizationManager.OnLocalizeEvent += OnLocalizationCall;
		title.text = LocalizationManager.GetTranslation(mb.faqs[FAQIndex].title);
	}

	private void OnDisable()
	{
		LocalizationManager.OnLocalizeEvent -= OnLocalizationCall;
	}

	public void OpenFAQ()
	{
		mb.OpenFAQsEntry(FAQIndex);
	}

	private void OnLocalizationCall()
	{
		title.text = LocalizationManager.GetTranslation(mb.faqs[FAQIndex].title);
	}
}
public class ImageButton : PointerButton
{
	public Image background;

	public RawImage rawBackground;

	public Color highlightColor;

	private Color unhighlightColor;

	private void Awake()
	{
		if (background != null)
		{
			unhighlightColor = background.color;
		}
		else if ((bool)rawBackground)
		{
			unhighlightColor = rawBackground.color;
		}
	}

	private void Update()
	{
		if (unhighlightColor.a == 0f)
		{
			unhighlightColor = Color.white;
		}
	}

	public override void Highlight()
	{
		if (clickable)
		{
			base.Highlight();
			if (background != null)
			{
				background.color = highlightColor;
			}
			else if ((bool)rawBackground)
			{
				rawBackground.color = highlightColor;
			}
		}
	}

	public override void UnHighlight()
	{
		if (clickable)
		{
			if (background != null)
			{
				background.color = unhighlightColor;
			}
			else if ((bool)rawBackground)
			{
				rawBackground.color = unhighlightColor;
			}
		}
	}

	public override void Greyed()
	{
		if (background != null)
		{
			background.color = Color.grey;
		}
		else if ((bool)rawBackground)
		{
			rawBackground.color = Color.grey;
		}
	}
}
public class PauseButton : PointerButton
{
	public Renderer frameRenderer;

	public Material frameMaterial;

	public Material frameHighlightMaterial;

	public Material frameActiveMaterial;

	public bool stayHighlighted;

	private Color greyTextColor = new Color32(135, 125, 106, byte.MaxValue);

	public bool pointerOnHighlight;

	public override void OnClick()
	{
		if (clickable)
		{
			onClickEvent.Invoke();
		}
	}

	public override void Highlight()
	{
		if (clickable)
		{
			base.Highlight();
			if (stayHighlighted)
			{
				frameRenderer.material = frameActiveMaterial;
			}
			else
			{
				frameRenderer.material = frameHighlightMaterial;
			}
		}
		if (pointerOnHighlight)
		{
			Player.instance.currentController.SwitchToPointer();
		}
	}

	public override void UnHighlight()
	{
		if (clickable && !stayHighlighted)
		{
			frameRenderer.material = frameMaterial;
		}
		if (pointerOnHighlight)
		{
			Player.instance.currentController.SwitchToClubs();
		}
	}

	public override void Greyed()
	{
		TextMeshPro[] componentsInChildren = GetComponentsInChildren<TextMeshPro>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].color = greyTextColor;
		}
	}

	public void White()
	{
		TextMeshPro[] componentsInChildren = GetComponentsInChildren<TextMeshPro>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].color = Color.white;
		}
	}
}
public class PointerButton : MonoBehaviour
{
	public UnityEvent onClickEvent;

	public string tip;

	public bool playDefaultClickSFX = true;

	public bool clickable = true;

	public virtual void OnClick()
	{
		if (clickable)
		{
			onClickEvent.Invoke();
		}
	}

	public virtual void Highlight()
	{
		Player.instance.currentControllerInput.Vibrate();
	}

	public virtual void UnHighlight()
	{
	}

	public virtual void Greyed()
	{
	}
}
public class ScrollButton : PointerButton
{
	public ScrollRect scrollRect;

	private float sensitivity = 20f;

	private float inertia = 0.15f;

	private float movement;

	private RectTransform pos;

	private Vector2 pos2;

	private float containerHeight;

	public Color highlightColor;

	public Image arrow;

	private Color unhighlightColor;

	private void Start()
	{
		pos = scrollRect.content;
		unhighlightColor = arrow.color;
	}

	public override void Highlight()
	{
		base.Highlight();
		arrow.color = highlightColor;
	}

	public override void UnHighlight()
	{
		arrow.color = unhighlightColor;
	}
}
public class TabButton : PointerButton
{
	public bool isActive;

	public GameObject activeSprite;

	public GameObject inactiveSprite;

	public Text text;

	public TextMeshProUGUI textMeshProUGUI;

	public Color highlightCol;

	public Color unHighlightCol;

	public Color clickedCol;

	private void Start()
	{
		if (isActive)
		{
			Active(x: true);
		}
		else
		{
			Active(x: false);
		}
	}

	public override void Highlight()
	{
		if (!isActive)
		{
			base.Highlight();
			if (text != null)
			{
				text.color = highlightCol;
			}
			else if (textMeshProUGUI != null)
			{
				textMeshProUGUI.color = highlightCol;
			}
		}
	}

	public override void UnHighlight()
	{
		if (!isActive)
		{
			if (text != null)
			{
				text.color = unHighlightCol;
			}
			else if (textMeshProUGUI != null)
			{
				textMeshProUGUI.color = unHighlightCol;
			}
		}
	}

	public void Active(bool x)
	{
		isActive = x;
		if (x)
		{
			if (activeSprite != null)
			{
				activeSprite.SetActive(value: true);
				inactiveSprite.SetActive(value: false);
			}
			if (text != null)
			{
				if (clickedCol.a == 0f)
				{
					text.color = highlightCol;
				}
				else
				{
					text.color = clickedCol;
				}
			}
			else if (textMeshProUGUI != null)
			{
				if (clickedCol.a == 0f)
				{
					textMeshProUGUI.color = highlightCol;
				}
				else
				{
					textMeshProUGUI.color = clickedCol;
				}
			}
		}
		else
		{
			if (activeSprite != null)
			{
				activeSprite.SetActive(value: false);
				inactiveSprite.SetActive(value: true);
			}
			if (text != null)
			{
				text.color = unHighlightCol;
			}
			else if (textMeshProUGUI != null)
			{
				textMeshProUGUI.color = unHighlightCol;
			}
		}
	}
}
public class TextButton : PointerButton
{
	public Text textUI;

	public TextMeshProUGUI textMeshProUGUI;

	public TextMeshPro textMeshPro;

	public Color highlightColor;

	public Color unhighlightColor;

	public bool stayHighlighted;

	private void Awake()
	{
		if (textUI != null)
		{
			unhighlightColor = textUI.color;
		}
		else if (textMeshProUGUI != null)
		{
			unhighlightColor = textMeshProUGUI.color;
		}
		else if (textMeshPro != null)
		{
			unhighlightColor = textMeshPro.color;
		}
		if (unhighlightColor.a == 0f)
		{
			unhighlightColor = Color.white;
		}
	}

	public override void Highlight()
	{
		if (clickable)
		{
			base.Highlight();
			if (textUI != null)
			{
				textUI.color = highlightColor;
			}
			else if (textMeshProUGUI != null)
			{
				textMeshProUGUI.color = highlightColor;
			}
			else if (textMeshPro != null)
			{
				textMeshPro.color = highlightColor;
			}
		}
	}

	public override void UnHighlight()
	{
		if (clickable && !stayHighlighted)
		{
			if (textUI != null)
			{
				textUI.color = unhighlightColor;
			}
			else if (textMeshProUGUI != null)
			{
				textMeshProUGUI.color = unhighlightColor;
			}
			else if (textMeshPro != null)
			{
				textMeshPro.color = unhighlightColor;
			}
		}
	}

	public override void Greyed()
	{
		if (textUI != null)
		{
			textUI.color = Color.grey;
		}
		else if (textMeshProUGUI != null)
		{
			textMeshProUGUI.color = Color.grey;
		}
		else if (textMeshPro != null)
		{
			textMeshPro.color = Color.grey;
		}
	}
}
public class CampaignMap : CampaignDetailPanel
{
	public AudioClip unlockSFX;

	public AudioClip failedSFX;

	public Color currentHoleHighlight = Color.green;

	public TextMeshPro scoreText;

	private AudioSource audioSource;

	private bool unlockedNewHole;

	public GameObject backToMainMenuButton;

	public GameObject finishButton;

	public GameObject nextHoleButton;

	public GameObject bossButton;

	public GameObject tryAgainButton;

	public GameObject loadHoleButton;

	public override void Start()
	{
		ToggleBossView();
		mapLevelsRenderer.material = new Material(mapLevelsRenderer.material);
		StartCoroutine(DelayStart());
		audioSource = GetComponent<AudioSource>();
		CalculatePar();
		SaveCampaign();
		if (GameManager.instance.pauseMenu.paused)
		{
			GameManager.instance.pauseMenu.Resume();
		}
		GameManager.instance.pauseMenu.allowPausing = false;
		if (!GameManager.instance.currentSceneName.Contains("Boss"))
		{
			CheckUnlockedNewHole();
		}
		else if (GameManager.instance.currentSceneName == "Boss3")
		{
			if (!GameManager.instance.GetShowedFinishedCampaignMessage())
			{
				GameManager.instance.finishedCampaign = true;
			}
			finishButton.SetActive(value: true);
			backToMainMenuButton.SetActive(value: false);
		}
		else
		{
			nextHoleButton.SetActive(value: true);
		}
	}

	private void Update()
	{
		if (Player.instance.currentControllerInput.startButton.wasPressed || (GameManager.instance.controllerType == ControllerType.FPS && Input.GetKeyDown(KeyCode.P)))
		{
			GameManager.instance.CenterNotification(base.gameObject);
		}
	}

	private IEnumerator DelayStart()
	{
		yield return null;
		SetCampaignHoleButtons();
		ShowMap();
	}

	public void LoadPickedHole()
	{
		if (boss)
		{
			if (bossIndex == 0)
			{
				GameManager.instance.holeIndex = 18;
				GameManager.instance.SwitchToScene("Boss1");
			}
			else if (bossIndex == 1)
			{
				GameManager.instance.SwitchToScene("Boss2 New Mechanic Test");
				GameManager.instance.holeIndex = 36;
			}
			else
			{
				GameManager.instance.SwitchToScene("Boss3");
				GameManager.instance.holeIndex = 54;
			}
		}
		else
		{
			if (holeIndex < 18)
			{
				GameManager.instance.holeIndex = holeIndex;
			}
			else if (holeIndex >= 36)
			{
				GameManager.instance.holeIndex = holeIndex - 36;
			}
			else if (holeIndex >= 18)
			{
				GameManager.instance.holeIndex = holeIndex - 18;
			}
			if (!GameManager.instance.currentSceneName.Contains("Boss"))
			{
				GameManager.instance.holeIndex--;
				Golfhole component = GameManager.instance.GetNearestHoleFromPos(GameManager.instance.player.transform.position).GetComponent<Golfhole>();
				component.StartCoroutine(component.NextHoleCountdown(0f));
			}
			else
			{
				GameManager.instance.SwitchToScene("CustomHoleScene");
			}
		}
		if (pickedCampaignHole.difficulty != GameManager.instance.campaignDifficulty)
		{
			SetCampaignHoleData();
			ScoreManager.instance.ResetStrokeTable();
			ScoreManager.instance.SetCampaignHighScore();
			ScoreManager.instance.SetHolePars();
		}
		GameManager.instance.SetMulligans();
		UnityEngine.Object.Destroy(base.gameObject);
	}

	public void LoadNextHole()
	{
		if (GameManager.instance.currentSceneName.Contains("Boss"))
		{
			if (GameManager.instance.campaignDifficulty == Difficulty.Easy)
			{
				holeIndex = 18;
			}
			else if (GameManager.instance.campaignDifficulty == Difficulty.Medium)
			{
				holeIndex = 36;
			}
			StartCampaign();
		}
		else
		{
			GameManager.instance.SetMulligans();
			if (GameManager.instance.holeIndex == 17)
			{
				if (GameManager.instance.holeData[17].publishID == 18)
				{
					holeIndex = 18;
				}
				else if (GameManager.instance.holeData[17].publishID == 36)
				{
					holeIndex = 36;
				}
				GameManager.instance.campaignDifficulty = campaignHoles[holeIndex].difficulty;
				StartCampaign();
			}
			else
			{
				Golfhole component = GameManager.instance.GetNearestHoleFromPos(GameManager.instance.player.transform.position).GetComponent<Golfhole>();
				component.StartCoroutine(component.NextHoleCountdown(0f));
			}
		}
		GameManager.instance.SetMulligans();
		UnityEngine.Object.Destroy(base.gameObject);
	}

	public void LoadBossHole()
	{
		_ = GameManager.instance.holeData[GameManager.instance.holeIndex];
		if (GameManager.instance.campaignDifficulty == Difficulty.Easy)
		{
			GameManager.instance.SwitchToScene("Boss1");
		}
		else if (GameManager.instance.campaignDifficulty == Difficulty.Medium)
		{
			GameManager.instance.SwitchToScene("Boss2 New Mechanic Test");
		}
		else if (GameManager.instance.campaignDifficulty == Difficulty.Hard)
		{
			GameManager.instance.SwitchToScene("Boss3");
		}
		Golfhole component = GameManager.instance.GetNearestHoleFromPos(GameManager.instance.player.transform.position).GetComponent<Golfhole>();
		component.StartCoroutine(component.NextHoleCountdown(0f));
		GameManager.instance.SetMulligans();
		UnityEngine.Object.Destroy(base.gameObject);
	}

	public void TryAgain()
	{
		base.gameObject.SetActive(value: false);
		if (GameManager.instance.currentSceneName.Contains("Boss"))
		{
			GameManager.instance.SwitchToScene(GameManager.instance.currentSceneName);
			return;
		}
		GameManager.instance.LoadNextHole(incrementHole: false);
		ScoreManager.instance.currentStrokeCount = 0;
	}

	public void BackToMainMenu()
	{
		GameManager.instance.BackToMainMenu();
	}

	public void GoToFinishScene()
	{
		GameManager.instance.BackToMainMenu();
	}

	private void CheckUnlockedNewHole()
	{
		WorkshopData workshopData = GameManager.instance.holeData[GameManager.instance.holeIndex];
		SaveFile saveFile = SaveFileManager.instance.saveFile;
		int currentStrokeCount = ScoreManager.instance.currentStrokeCount;
		if (workshopData.difficulty == 0)
		{
			if (currentStrokeCount > 0)
			{
				if (saveFile.campaignHoleScore[workshopData.publishID + 1] == 0)
				{
					audioSource.PlayOneShot(unlockSFX);
					campaignHoles[workshopData.publishID].gameObject.SetActive(value: true);
				}
				unlockedNewHole = true;
			}
		}
		else if (workshopData.difficulty == 1)
		{
			if (currentStrokeCount <= workshopData.par + 3)
			{
				if (saveFile.campaignHoleScore[workshopData.publishID + 1] == 0)
				{
					audioSource.PlayOneShot(unlockSFX);
					campaignHoles[workshopData.publishID].gameObject.SetActive(value: true);
				}
				unlockedNewHole = true;
			}
		}
		else if (workshopData.difficulty == 2 && currentStrokeCount <= workshopData.par + 2)
		{
			if (GameManager.instance.hideBosses)
			{
				if (workshopData.publishID == 54)
				{
					audioSource.PlayOneShot(unlockSFX);
					unlockedNewHole = true;
					if (!GameManager.instance.GetShowedFinishedCampaignMessage())
					{
						GameManager.instance.finishedCampaign = true;
					}
				}
				else
				{
					audioSource.PlayOneShot(unlockSFX);
					campaignHoles[workshopData.publishID].gameObject.SetActive(value: true);
					unlockedNewHole = true;
				}
			}
			else if (workshopData.publishID == 54)
			{
				if (saveFile.bossScore[2] == 0)
				{
					audioSource.PlayOneShot(unlockSFX);
					bossHoles[2].gameObject.SetActive(value: true);
				}
				unlockedNewHole = true;
			}
			else
			{
				if (saveFile.campaignHoleScore[workshopData.publishID] == 0)
				{
					audioSource.PlayOneShot(unlockSFX);
					campaignHoles[workshopData.publishID].gameObject.SetActive(value: true);
				}
				unlockedNewHole = true;
			}
		}
		if (unlockedNewHole)
		{
			if (GameManager.instance.hideBosses)
			{
				if (workshopData.publishID <= 53)
				{
					nextHoleButton.SetActive(value: true);
					return;
				}
				finishButton.SetActive(value: true);
				backToMainMenuButton.SetActive(value: false);
			}
			else if (workshopData.publishID == 18 || workshopData.publishID == 36 || workshopData.publishID == 54)
			{
				bossButton.SetActive(value: true);
			}
			else if (workshopData.publishID <= 53)
			{
				nextHoleButton.SetActive(value: true);
			}
		}
		else
		{
			audioSource.PlayOneShot(failedSFX);
			tryAgainButton.SetActive(value: true);
		}
	}

	private void SaveCampaign()
	{
		if (GameManager.instance.gameMode != GameMode.Campaign || SaveFileManager.instance.saveFile == null)
		{
			return;
		}
		int num = 0;
		if (GameManager.instance.currentSceneName.Contains("Boss"))
		{
			WorkshopData workshopData = GameManager.instance.holeData[GameManager.instance.holeData.Count - 1];
			if (ScoreManager.instance.currentStrokeCount > 0)
			{
				num = SaveFileManager.instance.saveFile.bossScore[workshopData.publishID];
				if (num > ScoreManager.instance.currentStrokeCount || num == 0)
				{
					SaveFileManager.instance.saveFile.bossScore[workshopData.publishID] = ScoreManager.instance.currentStrokeCount;
				}
			}
		}
		else
		{
			WorkshopData workshopData2 = GameManager.instance.holeData[GameManager.instance.holeIndex];
			num = SaveFileManager.instance.saveFile.campaignHoleScore[workshopData2.publishID - 1];
			if (num > ScoreManager.instance.currentStrokeCount || num == 0)
			{
				SaveFileManager.instance.saveFile.campaignHoleScore[workshopData2.publishID - 1] = ScoreManager.instance.currentStrokeCount;
			}
		}
		SaveFileManager.instance.SaveFile();
		MonoBehaviour.print("Saved file");
	}

	private void CalculatePar()
	{
		if (GameManager.instance.currentSceneName.Contains("Boss"))
		{
			scoreText.text = ScoreManager.instance.currentStrokeCount + " " + LocalizationManager.GetTranslation("Strokes");
			return;
		}
		int currentStrokeCount = ScoreManager.instance.currentStrokeCount;
		_ = GameManager.instance.holeData[GameManager.instance.holeIndex];
		int num = ScoreManager.instance.pars[GameManager.instance.holeIndex];
		int num2 = num;
		string text = "";
		if (currentStrokeCount > num2)
		{
			text = "+";
			num2 = currentStrokeCount - num2;
		}
		else if (currentStrokeCount < num2)
		{
			text = "-";
			num2 -= currentStrokeCount;
		}
		else
		{
			num2 = 0;
		}
		if (currentStrokeCount == 7)
		{
			scoreText.text = Mathf.Abs(currentStrokeCount - num) + " " + LocalizationManager.GetTranslation("Under Par") + " \n " + currentStrokeCount + "(" + text + num2 + ")";
		}
		else if (currentStrokeCount <= num - 2)
		{
			scoreText.text = LocalizationManager.GetTranslation("Eagle") + "! \n " + currentStrokeCount + "(" + text + num2 + ")";
		}
		else if (currentStrokeCount == num - 1)
		{
			scoreText.text = LocalizationManager.GetTranslation("Birdie") + "! \n " + currentStrokeCount + "(" + text + num2 + ")";
		}
		else if (currentStrokeCount == num)
		{
			scoreText.text = LocalizationManager.GetTranslation("Par") + "! \n " + currentStrokeCount + "(" + text + num2 + ")";
		}
		else if (currentStrokeCount == num + 1)
		{
			scoreText.text = LocalizationManager.GetTranslation("Bogey") + "! \n " + currentStrokeCount + "(" + text + num2 + ")";
		}
		else if (currentStrokeCount == num + 2)
		{
			scoreText.text = LocalizationManager.GetTranslation("Double Bogey") + "! \n " + currentStrokeCount + "(" + text + num2 + ")";
		}
		else
		{
			scoreText.text = Mathf.Abs(num - currentStrokeCount) + " " + LocalizationManager.GetTranslation("Over Par") + " \n " + currentStrokeCount + "(" + text + num2 + ")";
		}
	}

	public override void SetCampaignPanel(CampaignHoleButton chb, int buttonIndex)
	{
		base.SetCampaignPanel(chb, chb.GetHoleButtonIndex());
	}

	private void OnDestroy()
	{
		if (GameManager.instance != null)
		{
			GameManager.instance.pauseMenu.allowPausing = true;
		}
	}
}
public class ClubLengthBasedOnHeight : MonoBehaviour
{
	public int chosenHeightFeet = 5;

	public int chosenHeightInches = 10;

	public LayerMask heightMeasureGroundLayer;

	public GameObject rootClubProfileMenu;

	public GameObject editClubProfileMenu;

	public GameObject createClubProfileMenu;

	public GameObject deleteClubProfileButton;

	public TextMeshProUGUI feetText;

	public TextMeshProUGUI inchesText;

	public TextMeshProUGUI driverLengthText;

	public TextMeshProUGUI ironLengthText;

	public TextMeshProUGUI putterLengthText;

	public TextMeshProUGUI playerNameText;

	public TextMeshProUGUI noProfilesToEditText;

	private float averageDriverLength = 44f;

	private float averageIronLength = 39.5f;

	private float averagePutterLength = 33.5f;

	private float chosenDriverLength = 44f;

	private float chosenIronLength = 39.5f;

	private float chosenPutterLength = 33.5f;

	private string clubPath = "";

	private string currentlySelectedClubProfilePath = "";

	private FileInfo[] profiles;

	public GameObject clubProfileButtonPrefab;

	public Transform clubProfilebuttonContainer;

	[Header("Keyboard")]
	public GameObject keyboard;

	private string tempInputText = "";

	private string previousKeyboardText;

	private float caretTimer;

	[Header("Golfball")]
	public GameObject golfballPrefab;

	public Transform golfballSpawnPos;

	private float respawnTimer = 3f;

	private float respawnInterval = 3f;

	public AudioClip changeClubSFX;

	private AudioSource audioSource;

	private void Start()
	{
		clubPath = UnityEngine.Application.persistentDataPath + "/club profiles/";
		if (!Directory.Exists(clubPath))
		{
			Directory.CreateDirectory(clubPath);
		}
		audioSource = GetComponent<AudioSource>();
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.O))
		{
			MeasureHeight();
		}
		if (keyboard.activeSelf)
		{
			playerNameText.text = CaretText(tempInputText);
		}
		if (createClubProfileMenu.activeSelf && !GameManager.instance.pauseMenu.paused)
		{
			Player.instance.currentController.SwitchToClubs();
			Player.instance.currentController.pointer.TurnOnPointerLine();
			Player.instance.currentController.pointerActive = true;
		}
		RespawnBall();
	}

	public void AdjustHeightFeet(int amount)
	{
		chosenHeightFeet += amount;
		if (chosenHeightFeet < 4)
		{
			chosenHeightFeet = 4;
		}
		else if (chosenHeightFeet > 7)
		{
			chosenHeightFeet = 7;
		}
		feetText.text = chosenHeightFeet + "'";
		AdjustClubLength();
		audioSource.PlayOneShot(changeClubSFX);
	}

	public void AdjustHeightInches(int amount)
	{
		chosenHeightInches += amount;
		if (chosenHeightInches < 0)
		{
			chosenHeightInches = 0;
		}
		else if (chosenHeightInches > 11)
		{
			chosenHeightInches = 11;
		}
		inchesText.text = chosenHeightInches + "''";
		AdjustClubLength();
		audioSource.PlayOneShot(changeClubSFX);
	}

	public void PreviewDriver()
	{
		Player.instance.clubSwitcher.SwitchToClubType(ClubType.Driver);
		ClubSwitcher clubSwitcher = GameManager.instance.player.clubSwitcher;
		GameManager.instance.player.clubSwitcher.currentClub.clubScaler.SetClubLength(clubSwitcher.currentType, chosenDriverLength);
		audioSource.PlayOneShot(changeClubSFX);
	}

	public void PreviewIron()
	{
		Player.instance.clubSwitcher.SwitchToClubType(ClubType.Iron);
		ClubSwitcher clubSwitcher = GameManager.instance.player.clubSwitcher;
		GameManager.instance.player.clubSwitcher.currentClub.clubScaler.SetClubLength(clubSwitcher.currentType, chosenIronLength);
		audioSource.PlayOneShot(changeClubSFX);
	}

	public void PreviewPutter()
	{
		Player.instance.clubSwitcher.SwitchToClubType(ClubType.Putter);
		ClubSwitcher clubSwitcher = GameManager.instance.player.clubSwitcher;
		GameManager.instance.player.clubSwitcher.currentClub.clubScaler.SetClubLength(clubSwitcher.currentType, chosenPutterLength);
		audioSource.PlayOneShot(changeClubSFX);
	}

	public void AdjustDriverInches(float amount)
	{
		float num = averageDriverLength - 6f;
		float num2 = averageDriverLength + 6f;
		chosenDriverLength += amount;
		if (chosenDriverLength < num)
		{
			chosenDriverLength = num;
		}
		else if (chosenDriverLength > num2)
		{
			chosenDriverLength = num2;
		}
		driverLengthText.text = chosenDriverLength + "''";
		PreviewDriver();
	}

	public void AdjustIronInches(float amount)
	{
		float num = averageIronLength - 6f;
		float num2 = averageIronLength + 6f;
		chosenIronLength += amount;
		if (chosenIronLength < num)
		{
			chosenIronLength = num;
		}
		else if (chosenIronLength > num2)
		{
			chosenIronLength = num2;
		}
		ironLengthText.text = chosenIronLength + "''";
		PreviewIron();
	}

	public void AdjustPutterInches(float amount)
	{
		float num = averagePutterLength - 6f;
		float num2 = averagePutterLength + 6f;
		chosenPutterLength += amount;
		if (chosenPutterLength < num)
		{
			chosenPutterLength = num;
		}
		else if (chosenPutterLength > num2)
		{
			chosenPutterLength = num2;
		}
		putterLengthText.text = chosenPutterLength + "''";
		PreviewPutter();
	}

	public void MeasureHeight()
	{
		if (Physics.Raycast(Player.instance.head.position, -Vector3.up, out var hitInfo, (int)heightMeasureGroundLayer))
		{
			float num = Vector3.Distance(Player.instance.head.position, hitInfo.point);
			if (GameManager.instance.controllerType == ControllerType.Quest)
			{
				num += 0.0762f;
			}
			MonoBehaviour.print("Height: " + num);
			int num2 = (int)(num * 100f / 30.48f);
			int num3 = Mathf.CeilToInt((num * 100f / 30.48f - (float)num2) * 12f);
			if (num3 == 12)
			{
				num2++;
				num3 = 0;
			}
			feetText.text = num2 + "'";
			inchesText.text = num3 + "''";
			chosenHeightFeet = num2;
			chosenHeightInches = num3;
		}
	}

	public void AdjustClubLength()
	{
		int num = 5;
		float num2 = 0f;
		if (num < chosenHeightFeet)
		{
			num2 = (chosenHeightFeet - num) * -2;
		}
		else if (num > chosenHeightFeet)
		{
			num2 = (num - chosenHeightFeet) * 2;
		}
		if (chosenHeightInches >= 0 && chosenHeightInches < 3)
		{
			chosenDriverLength = averageDriverLength - num2 - 1.5f;
			chosenIronLength = averageIronLength - num2 - 1.5f;
			chosenPutterLength = averagePutterLength - num2 - 1.5f;
		}
		else if (chosenHeightInches >= 3 && chosenHeightInches < 6)
		{
			chosenDriverLength = averageDriverLength - num2 - 1f;
			chosenIronLength = averageIronLength - num2 - 1f;
			chosenPutterLength = averagePutterLength - num2 - 1f;
		}
		else if (chosenHeightInches >= 6 && chosenHeightInches < 9)
		{
			chosenDriverLength = averageDriverLength - num2 - 0.5f;
			chosenIronLength = averageIronLength - num2 - 0.5f;
			chosenPutterLength = averagePutterLength - num2 - 0.5f;
		}
		else if (chosenHeightInches == 9 || chosenHeightInches == 10)
		{
			chosenDriverLength = averageDriverLength - num2;
			chosenIronLength = averageIronLength - num2;
			chosenPutterLength = averagePutterLength - num2;
		}
		else if (chosenHeightInches == 11)
		{
			chosenDriverLength = averageDriverLength - num2 + 0.5f;
			chosenIronLength = averageIronLength - num2 + 0.5f;
			chosenPutterLength = averagePutterLength - num2 + 0.5f;
		}
		driverLengthText.text = chosenDriverLength + "''";
		ironLengthText.text = chosenIronLength + "''";
		putterLengthText.text = chosenPutterLength + "''";
		ClubSwitcher clubSwitcher = GameManager.instance.player.clubSwitcher;
		if (GameManager.instance.player.clubSwitcher.currentType == ClubType.Driver)
		{
			Player.instance.clubSwitcher.currentClub.clubScaler.SetClubLength(clubSwitcher.currentType, chosenDriverLength);
		}
		else if (GameManager.instance.player.clubSwitcher.currentType == ClubType.Iron)
		{
			Player.instance.clubSwitcher.currentClub.clubScaler.SetClubLength(clubSwitcher.currentType, chosenIronLength);
		}
		else
		{
			Player.instance.clubSwitcher.currentClub.clubScaler.SetClubLength(clubSwitcher.currentType, chosenPutterLength);
		}
	}

	public void OpenCreateClubProfileMenu()
	{
		rootClubProfileMenu.SetActive(value: false);
		editClubProfileMenu.SetActive(value: false);
		createClubProfileMenu.SetActive(value: true);
		if (currentlySelectedClubProfilePath == "")
		{
			deleteClubProfileButton.SetActive(value: false);
		}
		else
		{
			deleteClubProfileButton.SetActive(value: true);
		}
		Player.instance.clubs.SetActive(value: true);
		MeasureHeight();
		AdjustClubLength();
		playerNameText.text = LocalizationManager.GetTranslation("Name");
		tempInputText = "";
		if (!Player.instance.currentController.constrainedSwing)
		{
			GameManager.instance.golfball = UnityEngine.Object.Instantiate(golfballPrefab, golfballSpawnPos.position, golfballSpawnPos.rotation).GetComponent<Golfball>();
		}
	}

	public void OpenEditClubProfileMenu()
	{
		rootClubProfileMenu.SetActive(value: false);
		editClubProfileMenu.SetActive(value: true);
		GetAllProfiles();
	}

	public void OpenRootClubProfileMenu()
	{
		rootClubProfileMenu.SetActive(value: true);
		editClubProfileMenu.SetActive(value: false);
		createClubProfileMenu.SetActive(value: false);
		currentlySelectedClubProfilePath = "";
		Player.instance.clubs.SetActive(value: false);
		if (GameManager.instance.golfball != null)
		{
			UnityEngine.Object.Destroy(GameManager.instance.golfball.gameObject);
		}
	}

	public void SaveClubProfile()
	{
		if (playerNameText.text != "")
		{
			if (currentlySelectedClubProfilePath != "" && File.Exists(currentlySelectedClubProfilePath))
			{
				File.Delete(currentlySelectedClubProfilePath);
			}
			_ = clubPath + playerNameText.text + ".profile";
			string text = clubPath + playerNameText.text + ".profile";
			int num = 1;
			while (File.Exists(text))
			{
				num++;
				text = clubPath + playerNameText.text + num + ".profile";
			}
			string path = text;
			byte[] array = ((num != 1) ? Encoding.Unicode.GetBytes(playerNameText.text + num) : Encoding.Unicode.GetBytes(playerNameText.text));
			int num2 = array.Length;
			int num3 = 25 + num2;
			FileStream fileStream = new FileStream(path, FileMode.Create);
			MemoryStream memoryStream = new MemoryStream();
			memoryStream.SetLength(num3);
			memoryStream.Write(BitConverter.GetBytes(chosenHeightFeet), 0, 4);
			memoryStream.Write(BitConverter.GetBytes(chosenHeightInches), 0, 4);
			memoryStream.Write(BitConverter.GetBytes(chosenDriverLength), 0, 4);
			memoryStream.Write(BitConverter.GetBytes(chosenIronLength), 0, 4);
			memoryStream.Write(BitConverter.GetBytes(chosenPutterLength), 0, 4);
			memoryStream.Write(BitConverter.GetBytes(num2), 0, 4);
			memoryStream.Write(array, 0, num2);
			memoryStream.WriteTo(fileStream);
			fileStream.Flush();
			fileStream.Close();
			memoryStream.Dispose();
		}
		OpenRootClubProfileMenu();
	}

	public void DeleteClubProfile()
	{
		if (currentlySelectedClubProfilePath != "" && File.Exists(currentlySelectedClubProfilePath))
		{
			File.Delete(currentlySelectedClubProfilePath);
			if (currentlySelectedClubProfilePath == PlayerPrefs.GetString("ClubLength"))
			{
				GameManager.instance.SetClubLength("Medium");
			}
			currentlySelectedClubProfilePath = "";
			createClubProfileMenu.SetActive(value: false);
			OpenEditClubProfileMenu();
		}
	}

	public void LoadClubProfile(ClubProfile clubProfile)
	{
		currentlySelectedClubProfilePath = clubProfile.filePath;
		OpenCreateClubProfileMenu();
		chosenHeightFeet = clubProfile.feet;
		chosenHeightInches = clubProfile.inches;
		chosenDriverLength = clubProfile.driverLength;
		chosenIronLength = clubProfile.ironLength;
		chosenPutterLength = clubProfile.putterLength;
		playerNameText.text = clubProfile.profileName;
		ScoreManager.instance.playerTurn[0].clubProfile = clubProfile;
		feetText.text = chosenHeightFeet + "'";
		inchesText.text = chosenHeightInches + "''";
		driverLengthText.text = chosenDriverLength + "''";
		ironLengthText.text = chosenIronLength + "''";
		putterLengthText.text = chosenPutterLength + "''";
	}

	private void GetAllProfiles()
	{
		DirectoryInfo directoryInfo = new DirectoryInfo(clubPath);
		profiles = null;
		profiles = directoryInfo.GetFiles("*.profile");
		foreach (Transform item in clubProfilebuttonContainer)
		{
			UnityEngine.Object.Destroy(item.gameObject);
		}
		FileInfo[] array = profiles;
		foreach (FileInfo profile in array)
		{
			GameObject obj = UnityEngine.Object.Instantiate(clubProfileButtonPrefab);
			obj.transform.parent = clubProfilebuttonContainer;
			obj.transform.localPosition = Vector3.zero;
			obj.GetComponent<ClubProfileButton>().SetProfile(profile);
		}
		if (profiles.Length == 0)
		{
			noProfilesToEditText.gameObject.SetActive(value: true);
		}
		else
		{
			noProfilesToEditText.gameObject.SetActive(value: false);
		}
	}

	public void InputKey(string s)
	{
		switch (s)
		{
		case "enter":
			keyboard.SetActive(value: false);
			if (tempInputText.Length == 0 || (tempInputText.Contains("|") && tempInputText.Length == 1))
			{
				tempInputText = LocalizationManager.GetTranslation("Name");
			}
			else if (tempInputText.Contains("|"))
			{
				tempInputText.Remove(tempInputText.Length - 1);
			}
			playerNameText.text = tempInputText;
			break;
		case "delete":
			if (tempInputText.Length > 0)
			{
				tempInputText = tempInputText.Substring(0, tempInputText.Length - 1);
			}
			break;
		case "close":
			if (tempInputText.Contains("|"))
			{
				tempInputText.Remove(tempInputText.Length - 1);
			}
			playerNameText.text = previousKeyboardText;
			keyboard.SetActive(value: false);
			break;
		default:
			if (tempInputText.Length < 12)
			{
				tempInputText += s;
			}
			break;
		}
	}

	public void OpenKeyboard()
	{
		if (!keyboard.activeSelf)
		{
			tempInputText = playerNameText.text;
			previousKeyboardText = playerNameText.text;
			if (tempInputText == "Name")
			{
				tempInputText = "";
			}
			keyboard.SetActive(value: true);
		}
	}

	private string CaretText(string text)
	{
		string text2 = text;
		caretTimer += Time.deltaTime;
		if (caretTimer > 1f)
		{
			caretTimer = 0f;
		}
		else if (caretTimer > 0.5f)
		{
			text2 += "|";
		}
		return text2;
	}

	private void RespawnBall()
	{
		if (GameManager.instance.golfball != null && Vector3.Distance(GameManager.instance.golfball.transform.position, golfballSpawnPos.position) > 0.1f)
		{
			respawnTimer -= Time.deltaTime;
			if (respawnTimer <= 0f)
			{
				OBManager.instance.MoveTrailToObject();
				GameManager.instance.golfball.transform.position = golfballSpawnPos.position;
				GameManager.instance.golfball.FreezeVelocity();
				respawnTimer = respawnInterval;
			}
		}
	}
}
[Serializable]
public class ClubProfile
{
	public int feet;

	public int inches;

	public float driverLength = 44f;

	public float ironLength = 39.5f;

	public float putterLength = 33.5f;

	public string profileName;

	public string filePath = "Medium";
}
public class Controller : MonoBehaviour
{
	public ControllerMode controllerMode;

	public Pointer pointer;

	public GameObject clubObject;

	public ToolTip toolTip;

	public bool pointerActive;

	public ControllerInput controllerInput;

	public Transform touchpad;

	public GameObject touchLocationIndicator;

	private Vector3 touchLocationIndicatorStartPos;

	public float touchPointRadius = 0.035f;

	public float touchPointUpDiff = 0.0025f;

	public GameObject upButton;

	public GameObject rightButton;

	public GameObject downButton;

	public GameObject leftButton;

	public Vector3 hoverScale;

	[Header("3DOF Controls")]
	public bool constrainedSwing;

	[HideInInspector]
	public Vector3 lockedPuttForward;

	private Quaternion puttingModeOffset;

	private Vector3 currentBallOffset;

	public Vector3 lockedPuttSwingAxis;

	private Vector3 freeSwingOffset = new Vector3(0f, 0.5f, 0f);

	public float swivelDistance = 0.15f;

	private float putterBackDistance = 0.2f;

	private float putterUpDistance = 0.55f;

	public float freeSwingBackDistance = 0.1f;

	private float practiceHeight = 1.12f;

	private float puttingHeight = 1f;

	[HideInInspector]
	public Quaternion currentControllerRotation;

	public Vector3 putterSwingOffset;

	public bool freshWarp;

	public Vector4[] iconTilingOffset;

	private Mesh[] buttonIconMesh = new Mesh[4];

	private Vector2[][] originalUVs;

	public Vector3 hitRaisedPosition;

	public bool snapping;

	public Vector3 controllerPos;

	public float puttingModeClubLocation;

	public bool pointerLineActivationInScene;

	public MeshRenderer[] mesh;

	private bool meshInitialized;

	public GameObject xrControllerModel;

	private void Awake()
	{
		constrainedSwing = GameManager.instance.GetSwingConstraint();
	}

	public void Start()
	{
		touchLocationIndicatorStartPos = touchLocationIndicator.transform.localPosition;
		controllerInput = GetComponentInParent<ControllerInput>();
		if (!meshInitialized)
		{
			InitButtonIconMesh();
		}
		SetupTouchpadButtons(secondaryButtons: false);
		mesh = touchpad.GetComponentsInChildren<MeshRenderer>();
	}

	public void InitButtonIconMesh()
	{
		buttonIconMesh[0] = upButton.transform.GetChild(0).GetComponent<MeshFilter>().mesh;
		buttonIconMesh[1] = rightButton.transform.GetChild(0).GetComponent<MeshFilter>().mesh;
		buttonIconMesh[2] = downButton.transform.GetChild(0).GetComponent<MeshFilter>().mesh;
		buttonIconMesh[3] = leftButton.transform.GetChild(0).GetComponent<MeshFilter>().mesh;
		originalUVs = new Vector2[buttonIconMesh.Length][];
		for (int i = 0; i < buttonIconMesh.Length; i++)
		{
			originalUVs[i] = buttonIconMesh[i].uv;
		}
		meshInitialized = true;
	}

	public void Update()
	{
		if (!(GameManager.instance.currentSceneName == "LevelEditor") || LevelEditor.instance.previewing)
		{
			if (controllerInput.bButton.wasReleased)
			{
				SetupTouchpadButtons(secondaryButtons: false);
			}
			else if (controllerInput.bButton.wasPressed)
			{
				SetupTouchpadButtons(secondaryButtons: true);
			}
		}
		if (constrainedSwing)
		{
			ThreeDOFControls();
		}
		else if (GameManager.instance.controllerType == ControllerType.Vive)
		{
			Player.instance.currentControllerInput.GetComponent<SteamVR_TrackedObject>().enabled = true;
			base.transform.localPosition = Vector3.zero;
			base.transform.localRotation = Quaternion.identity;
		}
		UpdateTouchpad();
		TouchpadShadow();
	}

	public void SetupTouchpadButtons(bool secondaryButtons)
	{
		if (!meshInitialized)
		{
			InitButtonIconMesh();
		}
		if (!secondaryButtons)
		{
			SetIcon(Dir.Up, TouchpadIcon.ManualWarp);
			SetIcon(Dir.Right, TouchpadIcon.RightArrow);
			SetIcon(Dir.Down, TouchpadIcon.Menu);
			SetIcon(Dir.Left, TouchpadIcon.LeftArrow);
			return;
		}
		if (GameManager.instance.currentSceneName == "LevelEditor" && !LevelEditor.instance.finalizing)
		{
			SetIcon(Dir.Up, TouchpadIcon.DropBall);
		}
		else
		{
			SetIcon(Dir.Up, TouchpadIcon.Nothing);
		}
		SetIcon(Dir.Right, TouchpadIcon.SwitchClubRight);
		if (GameManager.instance.publishedPlatform == PublishedPlatform.XR)
		{
			SetIcon(Dir.Down, TouchpadIcon.Nothing);
		}
		else
		{
			SetIcon(Dir.Down, TouchpadIcon.BallSpin);
		}
		SetIcon(Dir.Left, TouchpadIcon.SwitchClubLeft);
	}

	public void SwitchToEditorButtons()
	{
		SetIcon(Dir.Up, TouchpadIcon.Select);
		SetIcon(Dir.Right, TouchpadIcon.Duplicate);
		if (snapping)
		{
			SetIcon(Dir.Down, TouchpadIcon.SnapMode);
		}
		else
		{
			SetIcon(Dir.Down, TouchpadIcon.SnapModeOff);
		}
		SetIcon(Dir.Left, TouchpadIcon.Delete);
	}

	public void SwitchToSnapMode(bool isSnap)
	{
		snapping = isSnap;
		if (snapping)
		{
			SetIcon(Dir.Down, TouchpadIcon.SnapMode);
		}
		else
		{
			SetIcon(Dir.Down, TouchpadIcon.SnapModeOff);
		}
	}

	public void SetIcon(Dir d, TouchpadIcon t)
	{
		Mesh mesh = buttonIconMesh[(int)d];
		Vector2[] uv = mesh.uv;
		for (int i = 0; i < uv.Length; i++)
		{
			uv[i].x = (originalUVs[(int)d][i].x + iconTilingOffset[(int)t].x) * iconTilingOffset[(int)t].z;
			uv[i].y = (originalUVs[(int)d][i].y + iconTilingOffset[(int)t].y) * iconTilingOffset[(int)t].w;
		}
		mesh.uv = uv;
	}

	private void UpdateTouchpad()
	{
		upButton.transform.localScale = Vector3.one;
		rightButton.transform.localScale = Vector3.one;
		downButton.transform.localScale = Vector3.one;
		leftButton.transform.localScale = Vector3.one;
		Vector2 stickAxis = controllerInput.stickAxis;
		if (controllerInput.stickAxis.magnitude > 0.01f)
		{
			touchLocationIndicator.transform.localPosition = touchLocationIndicatorStartPos + new Vector3(controllerInput.stickAxis.x * touchPointRadius, touchPointUpDiff, controllerInput.stickAxis.y * touchPointRadius);
			if (Mathf.Abs(stickAxis.x) > Mathf.Abs(stickAxis.y))
			{
				if (stickAxis.x > 0f)
				{
					rightButton.transform.localScale = hoverScale;
				}
				else
				{
					leftButton.transform.localScale = hoverScale;
				}
			}
			else if (stickAxis.y > 0f)
			{
				upButton.transform.localScale = hoverScale;
			}
			else
			{
				downButton.transform.localScale = hoverScale;
			}
		}
		else
		{
			touchLocationIndicator.transform.localPosition = touchLocationIndicatorStartPos;
		}
	}

	public void SwitchToPointer()
	{
		if (clubObject != null)
		{
			clubObject.SetActive(value: false);
		}
		pointerActive = true;
		pointer.TurnOnPointerLine();
		Player.instance.currentController.ToggleXRControllerModel(x: true);
	}

	public void SwitchToClubs()
	{
		if (clubObject != null)
		{
			clubObject.SetActive(value: true);
		}
		pointerActive = false;
		pointer.TurnOffPointerLine();
		Player.instance.currentController.ToggleXRControllerModel(x: false);
	}

	private void ThreeDOFControls()
	{
		Quaternion inputRotation = Player.instance.currentControllerInput.GetCurrentControllerRotation();
		UpdatePutterPositionAndRotation(inputRotation);
		if (pointerActive)
		{
			SwitchControllerMode(ControllerMode.FollowMode);
		}
		else if (!GameManager.instance.pauseMenu.paused)
		{
			if (ScoreManager.instance.ballScored)
			{
				return;
			}
			if (GameManager.instance.golfball != null)
			{
				if (!GameManager.instance.golfball.IsGrounded() || !Player.instance.InPuttRadius())
				{
					SwitchControllerMode(ControllerMode.FollowMode);
				}
				else if (pointerActive)
				{
					SwitchControllerMode(ControllerMode.FollowMode);
				}
				else if (Player.instance.InPuttRadius() && controllerMode == ControllerMode.FollowMode && GameManager.instance.golfball.rb.velocity.magnitude < 1f)
				{
					Player.instance.clubSwitcher.SwitchClubsOnWarp();
					SwitchControllerMode(ControllerMode.PracticeMode);
				}
				else if (Player.instance.currentControllerInput.bButton.wasReleased && controllerMode == ControllerMode.PuttingMode)
				{
					SwitchControllerMode(ControllerMode.PracticeMode);
				}
				else if (Player.instance.currentControllerInput.bButton.wasPressed && controllerMode == ControllerMode.PracticeMode)
				{
					SwitchControllerMode(ControllerMode.PuttingMode);
				}
			}
			else
			{
				SwitchControllerMode(ControllerMode.FollowMode);
			}
		}
		else
		{
			SwitchControllerMode(ControllerMode.FollowMode);
		}
	}

	private void UpdatePutterPositionAndRotation(Quaternion inputRotation)
	{
		Quaternion quaternion = inputRotation;
		switch (controllerMode)
		{
		case ControllerMode.PuttingMode:
			quaternion = Quaternion.FromToRotation(quaternion * Vector3.up, lockedPuttSwingAxis) * quaternion * puttingModeOffset;
			if (GameManager.instance.golfball != null)
			{
				Vector3 b = GameManager.instance.golfball.transform.position + currentBallOffset;
				float t = ((GameManager.instance.golfball.GetComponent<Rigidbody>().velocity.magnitude > 1f) ? 1f : 0.5f);
				base.transform.position = Vector3.LerpUnclamped(base.transform.position, b, t);
				base.transform.rotation = quaternion;
			}
			break;
		case ControllerMode.PracticeMode:
			if (GameManager.instance.golfball != null)
			{
				Vector3 up = Vector3.up;
				up = -GameManager.instance.golfball.GetFloorNormal();
				if (up == Vector3.zero)
				{
					up = Vector3.down;
				}
				_ = GameManager.instance.golfball.transform.position;
				quaternion = Quaternion.FromToRotation(quaternion * Vector3.forward, up) * quaternion;
				controllerPos = base.transform.position;
				if (Player.instance.rightHanded)
				{
					controllerPos = GameManager.instance.golfball.transform.position + -up + quaternion * Vector3.right * swivelDistance - quaternion * Vector3.up * putterBackDistance;
				}
				else
				{
					controllerPos = GameManager.instance.golfball.transform.position + -up - quaternion * Vector3.right * swivelDistance - quaternion * Vector3.up * putterBackDistance;
				}
				Quaternion quaternion2 = default(Quaternion);
				quaternion2.eulerAngles = new Vector3(-15f, 0f, 0f);
				quaternion *= quaternion2;
				controllerPos -= quaternion * Vector3.forward * putterUpDistance;
				base.transform.position = controllerPos;
				base.transform.rotation = quaternion;
			}
			break;
		case ControllerMode.FollowMode:
			base.transform.localPosition = Vector3.zero;
			base.transform.localRotation = Quaternion.identity;
			Player.instance.clubSwitcher.currentClub.ResetVelocity();
			base.transform.rotation = quaternion;
			break;
		}
		currentControllerRotation = base.transform.rotation;
	}

	public void SwitchControllerMode(ControllerMode mode)
	{
		if (!constrainedSwing)
		{
			return;
		}
		controllerMode = mode;
		switch (controllerMode)
		{
		case ControllerMode.PuttingMode:
		{
			clubObject.transform.localPosition = putterSwingOffset;
			if (Player.instance.clubSwitcher.currentClub != null)
			{
				Player.instance.clubSwitcher.currentClub.ResetVelocity();
				Player.instance.clubSwitcher.currentClub.detectCollisions = true;
			}
			if (GameManager.instance.golfball != null)
			{
				currentBallOffset = base.transform.position - GameManager.instance.golfball.transform.position;
				Vector3 vector = GameManager.instance.golfball.GetComponent<Golfball>().GetFloorNormal();
				if (vector == Vector3.zero)
				{
					vector = Vector3.up;
				}
				currentBallOffset += vector * (puttingHeight - practiceHeight);
			}
			lockedPuttSwingAxis = currentControllerRotation * Vector3.up;
			lockedPuttForward = currentControllerRotation * Vector3.right;
			Quaternion quaternion = Player.instance.currentControllerInput.GetCurrentControllerRotation();
			Quaternion quaternion2 = Quaternion.FromToRotation(quaternion * Vector3.up, lockedPuttSwingAxis);
			puttingModeOffset = Quaternion.Inverse(quaternion2 * quaternion) * currentControllerRotation;
			ToggleXRControllerModel(x: true);
			break;
		}
		case ControllerMode.PracticeMode:
			base.transform.SetParent(null);
			clubObject.transform.localPosition = putterSwingOffset;
			if (Player.instance.clubSwitcher.currentClub != null)
			{
				Player.instance.clubSwitcher.currentClub.ResetVelocity();
				Player.instance.clubSwitcher.currentClub.detectCollisions = false;
			}
			if (GameManager.instance.publishedPlatform != PublishedPlatform.XR)
			{
				if (Player.instance.clubSwitcher.currentClub.GetComponent<Putter>() != null)
				{
					Player.instance.clubSwitcher.currentClub.useAimLine = true;
				}
			}
			else
			{
				Player.instance.clubSwitcher.currentClub.useAimLine = true;
			}
			ToggleXRControllerModel(x: true);
			break;
		case ControllerMode.FollowMode:
			base.transform.SetParent(controllerInput.transform);
			base.transform.localPosition = Vector3.zero;
			base.transform.localRotation = Quaternion.identity;
			if (Player.instance.clubSwitcher.currentClub != null)
			{
				clubObject.transform.localPosition = Vector3.zero;
				Player.instance.clubSwitcher.currentClub.ResetVelocity();
				if (GameManager.instance.publishedPlatform != PublishedPlatform.XR)
				{
					if (Player.instance.clubSwitcher.currentClub.GetComponent<Putter>() != null)
					{
						Player.instance.clubSwitcher.currentClub.useAimLine = false;
					}
				}
				else
				{
					Player.instance.clubSwitcher.currentClub.useAimLine = false;
				}
			}
			if (!pointerActive)
			{
				ToggleXRControllerModel(x: false);
			}
			break;
		}
	}

	public bool ToggleSwingConstraint()
	{
		if (Player.instance.clubSwitcher.currentClub != null)
		{
			Player.instance.clubSwitcher.currentClub.ResetVelocity();
		}
		constrainedSwing = !constrainedSwing;
		GameManager.instance.SetSwingConstraint(constrainedSwing);
		return constrainedSwing;
	}

	private void TouchpadShadow()
	{
		MeshRenderer[] array = mesh;
		foreach (MeshRenderer meshRenderer in array)
		{
			if (GameManager.instance.GetClubShadows())
			{
				meshRenderer.shadowCastingMode = ShadowCastingMode.On;
			}
			else
			{
				meshRenderer.shadowCastingMode = ShadowCastingMode.Off;
			}
		}
	}

	public void RecenterXRController()
	{
	}

	public void ToggleXRControllerModel(bool x)
	{
		if (GameManager.instance.controllerType == ControllerType.XR)
		{
			xrControllerModel.SetActive(x);
		}
	}
}
public enum ControllerMode
{
	FollowMode,
	PuttingMode,
	PracticeMode
}
public enum TouchpadIcon
{
	Menu,
	ManualWarp,
	RightArrow,
	LeftArrow,
	BallSpin,
	Nothing,
	SwitchClubRight,
	SwitchClubLeft,
	Select,
	Duplicate,
	SnapMode,
	Delete,
	DropBall,
	SnapModeOff
}
public enum Dir
{
	Up,
	Right,
	Down,
	Left
}
public class EditorFairway : MonoBehaviour
{
	public Mesh terrainHull;

	public Mesh terrainCap;

	public List<EditPoint> points = new List<EditPoint>();

	public int subdivisions;

	public float newPointOffsetDistance;

	public MeshFilter meshFilter;

	public MeshCollider meshCollider;

	public Mesh terrainMesh;

	public Color32 color;

	public Color32 lightColor;

	public Color32[] colors;

	private int capVertCount;

	private int hullVertCount;

	private Vector3[] capVerts;

	private Vector3[] hullVerts;

	public float scaleFactor;

	private void Start()
	{
		capVerts = terrainCap.vertices;
		hullVerts = terrainHull.vertices;
		capVertCount = capVerts.Length;
		hullVertCount = hullVerts.Length;
		terrainMesh = new Mesh();
		meshFilter.mesh = terrainMesh;
		meshCollider.sharedMesh = terrainMesh;
		GenerateInitialMesh();
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.I))
		{
			GenerateCollision();
		}
	}

	public void GenerateCollision()
	{
		meshCollider.sharedMesh = terrainMesh;
	}

	public void AddPointAfter(EditPoint ep)
	{
		int num = points.IndexOf(ep);
		if (num == -1)
		{
			MonoBehaviour.print("point wasn't in list");
			return;
		}
		EditPoint editPoint = points[num];
		GameObject gameObject = UnityEngine.Object.Instantiate(editPoint.gameObject, base.transform);
		gameObject.name = editPoint.gameObject.name;
		EditPoint component = gameObject.GetComponent<EditPoint>();
		if (num == points.Count - 1)
		{
			gameObject.transform.localPosition += gameObject.transform.forward * newPointOffsetDistance;
			component.scale = editPoint.scale;
		}
		else
		{
			EditPoint editPoint2 = points[num + 1];
			gameObject.transform.localPosition = (editPoint.transform.localPosition + editPoint2.transform.localPosition) / 2f;
			gameObject.transform.localRotation = Quaternion.Slerp(editPoint.transform.localRotation, editPoint2.transform.localRotation, 0.5f);
			component.scale = (editPoint.scale + editPoint2.scale) / 2f;
		}
		points.Insert(num + 1, component);
		AddVerts(component);
	}

	public void RemovePoint(EditPoint ep)
	{
		if (points.Count > 2)
		{
			points.Remove(ep);
			UnityEngine.Object.Destroy(ep.gameObject);
		}
		else
		{
			MonoBehaviour.print("can't have less than 2 control points for the fairway");
		}
	}

	public void GenerateInitialMesh()
	{
		List<Vector3> list = new List<Vector3>();
		List<int> list2 = new List<int>();
		list.AddRange(terrainCap.vertices);
		for (int i = 0; i < list.Count; i++)
		{
			Vector3 vector = new Vector3(list[i].x * points[0].scale.x, list[i].y * points[0].scale.y, list[i].z * points[0].scale.z);
			list[i] = points[0].transform.localPosition + points[0].transform.localRotation * vector;
		}
		list2.AddRange(terrainCap.triangles);
		Vector3[] vertices = terrainHull.vertices;
		int num = vertices.Length;
		for (int j = 0; j < points.Count; j++)
		{
			for (int k = 0; k < vertices.Length; k++)
			{
				Vector3 vector2 = new Vector3(vertices[k].x * points[j].scale.x, vertices[k].y * points[j].scale.y, vertices[k].z * points[j].scale.z);
				list.Add(points[j].transform.localPosition + points[j].transform.localRotation * vector2);
			}
			if (j >= points.Count - 1)
			{
				continue;
			}
			for (int l = 0; l < subdivisions; l++)
			{
				float t = (float)(l + 1) / ((float)subdivisions + 1f);
				Vector3 vector3 = Vector3.Lerp(points[j].transform.localPosition, points[j + 1].transform.localPosition, t);
				Quaternion quaternion = Quaternion.Slerp(points[j].transform.localRotation, points[j + 1].transform.localRotation, t);
				Vector3 vector4 = Vector3.Lerp(points[j].scale, points[j + 1].scale, t);
				for (int m = 0; m < vertices.Length; m++)
				{
					Vector3 vector5 = new Vector3(vertices[m].x * vector4.x, vertices[m].y * vector4.y, vertices[m].z * vector4.z);
					list.Add(vector3 + quaternion * vector5);
				}
			}
		}
		int num2 = terrainCap.vertexCount;
		for (int n = 0; n < points.Count - 1; n++)
		{
			for (int num3 = 0; num3 < num; num3++)
			{
				list2.Add(num2 + num3);
				list2.Add(num2 + num3 + 1);
				list2.Add(num2 + num3 + num);
				list2.Add(num2 + num3 + num);
				list2.Add(num2 + num3 + 1);
				list2.Add(num2 + num3 + num + 1);
			}
			list2[list2.Count - 5] = num2;
			list2[list2.Count - 2] = num2;
			list2[list2.Count - 1] = num2 + num;
			num2 += num;
			if (n >= points.Count - 1)
			{
				continue;
			}
			for (int num4 = 0; num4 < subdivisions; num4++)
			{
				for (int num5 = 0; num5 < num; num5++)
				{
					list2.Add(num2 + num5);
					list2.Add(num2 + num5 + 1);
					list2.Add(num2 + num5 + num);
					list2.Add(num2 + num5 + num);
					list2.Add(num2 + num5 + 1);
					list2.Add(num2 + num5 + num + 1);
				}
				list2[list2.Count - 5] = num2;
				list2[list2.Count - 2] = num2;
				list2[list2.Count - 1] = num2 + num;
				num2 += num;
			}
		}
		int count = list.Count;
		int index = points.Count - 1;
		list.AddRange(terrainCap.vertices);
		for (int num6 = count; num6 < list.Count; num6++)
		{
			Vector3 vector6 = new Vector3(list[num6].x * points[index].scale.x, list[num6].y * points[index].scale.y, list[num6].z * points[index].scale.z);
			vector6 = points[index].transform.localRotation * Quaternion.Euler(0f, 180f, 0f) * vector6;
			list[num6] = points[index].transform.localPosition + vector6;
		}
		int[] triangles = terrainCap.triangles;
		for (int num7 = 0; num7 < triangles.Length; num7++)
		{
			list2.Add(triangles[num7] + count);
		}
		terrainMesh.triangles = new int[0];
		terrainMesh.vertices = list.ToArray();
		terrainMesh.triangles = list2.ToArray();
		terrainMesh.RecalculateNormals();
		int[] triangles2 = terrainMesh.triangles;
		Vector2[] array = new Vector2[terrainMesh.vertexCount];
		for (int num8 = 0; num8 < triangles2.Length; num8 += 3)
		{
			Vector3 vector7 = list[triangles2[num8]];
			Vector3 vector8 = list[triangles2[num8 + 1]];
			Vector3 vector9 = list[triangles2[num8 + 2]];
			Vector3 vector10 = Vector3.Cross(vector9 - vector7, vector8 - vector7);
			if (vector10 != Vector3.zero)
			{
				Quaternion quaternion2 = Quaternion.Inverse(Quaternion.LookRotation(vector10));
				array[triangles2[num8]] = (Vector2)(quaternion2 * vector7) * scaleFactor;
				array[triangles2[num8 + 1]] = (Vector2)(quaternion2 * vector8) * scaleFactor;
				array[triangles2[num8 + 2]] = (Vector2)(quaternion2 * vector9) * scaleFactor;
			}
		}
		terrainMesh.uv = array;
		if (terrainMesh.colors32.Length != list.Count)
		{
			terrainMesh.colors32 = new Color32[list.Count];
		}
	}

	public void AddVerts(EditPoint ep)
	{
		int num = points.IndexOf(ep);
		if (num == -1)
		{
			return;
		}
		List<Vector3> list = new List<Vector3>(terrainMesh.vertices);
		List<int> list2 = new List<int>();
		List<Vector3> list3 = new List<Vector3>();
		if (num == points.Count - 1)
		{
			int index = list.Count - capVertCount;
			int num2 = subdivisions + 1;
			for (int i = 0; i < num2; i++)
			{
				float t = ((float)i + 1f) / (float)num2;
				Vector3 vector = Vector3.Lerp(points[num - 1].transform.localPosition, ep.transform.localPosition, t);
				Quaternion quaternion = Quaternion.Slerp(points[num - 1].transform.localRotation, ep.transform.localRotation, t);
				Vector3 vector2 = Vector3.Lerp(points[num - 1].scale, ep.scale, t);
				for (int j = 0; j < hullVertCount; j++)
				{
					Vector3 vector3 = new Vector3(hullVerts[j].x * vector2.x, hullVerts[j].y * vector2.y, hullVerts[j].z * vector2.z);
					list3.Add(vector + quaternion * vector3);
				}
			}
			list.InsertRange(index, list3);
			index = list.Count - capVertCount;
			for (int k = 0; k < capVertCount; k++)
			{
				Vector3 vector4 = new Vector3(capVerts[k].x * ep.scale.x, capVerts[k].y * ep.scale.y, capVerts[k].z * ep.scale.z);
				vector4 = ep.transform.localRotation * Quaternion.Euler(0f, 180f, 0f) * vector4;
				list[index + k] = ep.transform.localPosition + vector4;
			}
		}
		else
		{
			int index2 = capVertCount + (num * (subdivisions + 1) - subdivisions) * hullVertCount;
			if (subdivisions > 0)
			{
				list.RemoveRange(index2, hullVertCount * subdivisions);
			}
			int num3 = subdivisions * 2 + 1;
			for (int l = 0; l < num3; l++)
			{
				float t2 = (float)(l + 1) / ((float)num3 + 1f);
				Vector3 vector5 = Vector3.Lerp(points[num - 1].transform.localPosition, points[num + 1].transform.localPosition, t2);
				Quaternion quaternion2 = Quaternion.Slerp(points[num - 1].transform.localRotation, points[num + 1].transform.localRotation, t2);
				Vector3 vector6 = Vector3.Lerp(points[num - 1].scale, points[num + 1].scale, t2);
				for (int m = 0; m < hullVertCount; m++)
				{
					Vector3 vector7 = new Vector3(hullVerts[m].x * vector6.x, hullVerts[m].y * vector6.y, hullVerts[m].z * vector6.z);
					list3.Add(vector5 + quaternion2 * vector7);
				}
			}
			list.InsertRange(index2, list3);
		}
		list2.AddRange(terrainCap.triangles);
		int num4 = terrainCap.vertexCount;
		int num5 = hullVertCount;
		for (int n = 0; n < points.Count; n++)
		{
			for (int num6 = 0; num6 < num5; num6++)
			{
				list2.Add(num4 + num6);
				list2.Add(num4 + num6 + 1);
				list2.Add(num4 + num6 + num5);
				list2.Add(num4 + num6 + num5);
				list2.Add(num4 + num6 + 1);
				list2.Add(num4 + num6 + num5 + 1);
			}
			list2[list2.Count - 5] = num4;
			list2[list2.Count - 2] = num4;
			list2[list2.Count - 1] = num4 + num5;
			num4 += num5;
			if (n >= points.Count - 1)
			{
				continue;
			}
			for (int num7 = 0; num7 < subdivisions; num7++)
			{
				for (int num8 = 0; num8 < num5; num8++)
				{
					list2.Add(num4 + num8);
					list2.Add(num4 + num8 + 1);
					list2.Add(num4 + num8 + num5);
					list2.Add(num4 + num8 + num5);
					list2.Add(num4 + num8 + 1);
					list2.Add(num4 + num8 + num5 + 1);
				}
				list2[list2.Count - 5] = num4;
				list2[list2.Count - 2] = num4;
				list2[list2.Count - 1] = num4 + num5;
				num4 += num5;
			}
		}
		int num9 = list.Count - capVertCount;
		int[] triangles = terrainCap.triangles;
		for (int num10 = 0; num10 < triangles.Length; num10++)
		{
			list2.Add(triangles[num10] + num9);
		}
		terrainMesh.triangles = new int[0];
		terrainMesh.vertices = list.ToArray();
		terrainMesh.triangles = list2.ToArray();
		terrainMesh.RecalculateNormals();
		if (terrainMesh.colors32.Length != list.Count)
		{
			terrainMesh.colors32 = new Color32[list.Count];
		}
	}

	public void SetTris()
	{
	}

	public void MoveVerts(EditPoint ep)
	{
	}

	public void OpenDetailMenu()
	{
	}
}
public class EndOfGameScoreboard : MonoBehaviour
{
	public GameObject proceedButton;

	public GameObject backToMainMenuButton;

	public GameObject replayButton;

	public GameObject newHolesButton;

	public int[] scores = new int[4];

	public string[] names = new string[4];

	public TextMeshProUGUI[] ranks = new TextMeshProUGUI[4];

	public Text[] nameText;

	public TextMeshProUGUI[] scoreText;

	public TextMeshProUGUI scorePar;

	private List<Photon.Realtime.Player> players = new List<Photon.Realtime.Player>();

	private int playerCount;

	private float timer = 30f;

	private bool proceeding;

	public TextMeshPro proceedText;

	private void Start()
	{
		backToMainMenuButton.SetActive(value: false);
		replayButton.SetActive(value: false);
		newHolesButton.SetActive(value: false);
		proceedButton.SetActive(value: false);
		if (PhotonNetwork.IsConnected)
		{
			players = PhotonManager.instance.GetUsablePlayers();
			playerCount = players.Count;
			proceedButton.SetActive(value: true);
		}
		else
		{
			playerCount = GameManager.instance.playerCount;
			backToMainMenuButton.SetActive(value: true);
			replayButton.SetActive(value: true);
			newHolesButton.SetActive(value: true);
		}
		if ((PhotonNetwork.IsConnected && players.Count > 1) || GameManager.instance.playerCount > 1)
		{
			SortOrder();
			TextMeshProUGUI[] array = ranks;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].text = "";
			}
			for (int j = 0; j < playerCount; j++)
			{
				ranks[j].text = "#" + (j + 1);
				nameText[j].text = names[j];
				int totalPars = ScoreManager.instance.GetTotalPars();
				if (scores[j] - totalPars > 0)
				{
					scoreText[j].text = scores[j] + "(+" + (scores[j] - totalPars) + ")";
				}
				else if (scores[j] - totalPars < 0)
				{
					scoreText[j].text = scores[j] + "(" + (scores[j] - totalPars) + ")";
				}
				else
				{
					scoreText[j].text = scores[j] + "(+0)";
				}
			}
		}
		else
		{
			scoreText[0].text = ScoreManager.instance.GetTotalStrokes().ToString();
			int totalPars2 = ScoreManager.instance.GetTotalPars();
			if (ScoreManager.instance.GetTotalStrokes() - totalPars2 > 0)
			{
				scorePar.text = "+" + (ScoreManager.instance.GetTotalStrokes() - totalPars2);
			}
			else if (ScoreManager.instance.GetTotalStrokes() - totalPars2 < 0)
			{
				scorePar.text = (ScoreManager.instance.GetTotalStrokes() - totalPars2).ToString();
			}
			else
			{
				scorePar.text = "+0";
			}
		}
	}

	private void Update()
	{
		Countdown();
	}

	private void SortOrder()
	{
		for (int i = 0; i < 4; i++)
		{
			int num = 0;
			if (PhotonNetwork.IsConnected)
			{
				if (i < playerCount)
				{
					int[] array = players[i].GetScores();
					foreach (int num2 in array)
					{
						if (num2 != -1)
						{
							num += num2;
						}
					}
					scores[i] = num;
					names[i] = players[i].NickName;
				}
				else
				{
					nameText[i].text = "";
					scoreText[i].text = "";
				}
			}
			else if (i < playerCount)
			{
				int[] array = ScoreManager.instance.strokeTable[i];
				foreach (int num3 in array)
				{
					if (num3 != -1)
					{
						num += num3;
					}
				}
				scores[i] = num;
				names[i] = ScoreManager.instance.playerTurn[i].playerName;
			}
			else
			{
				nameText[i].text = "";
				scoreText[i].text = "";
			}
		}
		for (int k = 0; k < playerCount; k++)
		{
			for (int l = 0; l < playerCount - 1; l++)
			{
				if (scores[l] > scores[l + 1] && scores[l + 1] != 0)
				{
					int num4 = scores[l + 1];
					scores[l + 1] = scores[l];
					scores[l] = num4;
					string text = names[l + 1];
					names[l + 1] = names[l];
					names[l] = text;
				}
			}
		}
	}

	private void Countdown()
	{
		if (PhotonNetwork.IsConnected && timer > 0f && !proceeding)
		{
			timer -= Time.deltaTime;
			proceedText.text = LocalizationManager.GetTranslation("Proceed") + "\n" + (int)timer;
			if (timer <= 0f)
			{
				OnProceedButton();
			}
		}
	}

	public void OnProceedButton()
	{
		if (!proceeding && !GameManager.instance.loadingLevel)
		{
			proceeding = true;
			if (GameManager.instance.gameMode == GameMode.Custom)
			{
				GameManager.instance.BackToRoomPrepScene(clearHoleData: false);
			}
			else
			{
				GameManager.instance.BackToMainMenu();
			}
		}
	}

	public void ChooseNewHoles()
	{
		if (!proceeding && !GameManager.instance.loadingLevel)
		{
			proceeding = true;
			PlayerTurn[] playerTurn = ScoreManager.instance.playerTurn;
			foreach (PlayerTurn obj in playerTurn)
			{
				obj.inputName = true;
				obj.mulliganUsed = false;
			}
			GameManager.instance.playerIndex = 0;
			GameManager.instance.holeData.Clear();
			GameManager.instance.playlistLeaderboardData = null;
			ScoreManager.instance.ResetStrokes();
			GameManager.instance.BackToRoomPrepScene(clearHoleData: false);
		}
	}

	public void ReplayHoles()
	{
		if (!proceeding && !GameManager.instance.loadingLevel)
		{
			proceeding = true;
			PlayerTurn[] playerTurn = ScoreManager.instance.playerTurn;
			foreach (PlayerTurn obj in playerTurn)
			{
				obj.inputName = true;
				obj.mulliganUsed = false;
			}
			GameManager.instance.SetMulligans();
			GameManager.instance.playerIndex = 0;
			GameManager.instance.holeIndex = 0;
			ScoreManager.instance.ResetStrokes();
			GameManager.instance.LoadNextHole(incrementHole: false);
		}
	}

	public void BackToMainMenu()
	{
		if (!proceeding && !GameManager.instance.loadingLevel)
		{
			proceeding = true;
			GameManager.instance.BackToMainMenu();
		}
	}
}
public class FaceToPlayer : MonoBehaviour
{
	public bool facePlayer = true;

	private void Update()
	{
		if (facePlayer)
		{
			Vector3 vector = Player.instance.head.position - base.transform.position;
			if (vector != Vector3.zero)
			{
				Quaternion rotation = base.transform.rotation;
				rotation.SetLookRotation(vector, Vector3.up);
				base.transform.rotation = rotation;
			}
		}
	}
}
public class FollowSign : MonoBehaviour
{
	protected Vector3 targetSlerp;

	protected Vector3 forwardlook;

	protected Vector3 lookPos;

	protected Quaternion lookRotation;

	protected Vector3 myForwardLook;

	protected Vector3 targetPosition;

	protected Vector3 offset = new Vector3(0f, 0.1f, 0f);

	protected float rotationOffset;

	protected float forwardLookOffset = 2f;

	protected float signSlerpSpeed = 1.75f;

	protected bool hasSetInitialPosition;

	protected int frameCounter;

	protected Player player;

	private float distanceToTeleport = 3f;

	private IEnumerator Start()
	{
		while (GameManager.instance == null || GameManager.instance.player == null)
		{
			yield return null;
		}
		player = GameManager.instance.player.GetComponent<Player>();
	}

	protected virtual void Update()
	{
		if (!(player != null))
		{
			return;
		}
		if (Vector3.Distance(Player.instance.head.position, base.transform.position) > distanceToTeleport)
		{
			base.transform.position = Player.instance.head.position;
		}
		if (!hasSetInitialPosition)
		{
			forwardlook = player.head.forward;
			forwardlook.y = 0f;
			forwardlook.Normalize();
			targetSlerp = player.head.position + Quaternion.Euler(GameManager.instance.player.transform.eulerAngles) * offset + forwardlook * forwardLookOffset;
			base.transform.position = targetSlerp;
			lookPos = player.head.position - base.transform.position;
			lookRotation = Quaternion.LookRotation(lookPos);
			base.transform.rotation = lookRotation;
			frameCounter++;
			if (frameCounter > 5)
			{
				hasSetInitialPosition = true;
			}
			return;
		}
		forwardlook = player.head.forward;
		forwardlook.y = 0f;
		forwardlook.Normalize();
		myForwardLook = -base.transform.forward;
		myForwardLook.y = 0f;
		myForwardLook.Normalize();
		targetSlerp = player.head.position + Quaternion.Euler(GameManager.instance.player.transform.eulerAngles) * offset + forwardlook * forwardLookOffset;
		base.transform.position = Vector3.Slerp(base.transform.position, targetSlerp, Time.deltaTime * signSlerpSpeed);
		lookPos = player.head.position - base.transform.position;
		lookRotation = Quaternion.LookRotation(lookPos);
		base.transform.rotation = lookRotation;
		if (rotationOffset != 0f)
		{
			base.transform.RotateAround(player.head.position, Vector3.up, rotationOffset);
		}
	}

	public void SetDistance(float x)
	{
		forwardLookOffset = x;
	}
}
public class GameAchievements : MonoBehaviour
{
	public void UnlockAchievement(Achievement a)
	{
		UnityEngine.Debug.Log("Unlocked achievement: " + a);
	}
}
public enum Achievement
{
	HOLE_IN_ONE = 0,
	BIRDIE = 1,
	EAGLE = 2,
	CREATE_EDITOR_HOLE = 3,
	PUBLISH_EDITOR_HOLE = 4,
	PLAY_ONLINE = 6,
	NO_MULLIGANS = 7,
	PAR = 9,
	BOSS1_PAR = 10,
	BOSS2_PAR = 11,
	BOSS3_PAR = 12
}
public class Autowarp : MonoBehaviour
{
	public ClubSwitcher clubSwitcher;

	public bool switchClubsOnWarp;

	public bool warpToCenter;

	public bool warpInAir;

	[Header("Manual Warp")]
	public GameObject manualWarpIndicatorPrefab;

	public Color manualWarpGoodColor;

	public Color manualWarpBadColor;

	public LineRenderer lineRenderer;

	public LayerMask manualWarpLayerMask;

	private ManualWarpIndicator manualWarpIndicator;

	private Vector3 manualWarpGravity = new Vector3(0f, -8f, 0f);

	private RaycastHit trajectoryHit;

	private int myNumSteps = 30;

	private float warpLineLength = 4f;

	private float warpTrajectoryForce = 32f;

	private bool hitValidSurface;

	private ControllerMode savedMode;

	public float distanceToBall = 0.5f;

	[Space(20f)]
	public bool holdingDownManualWarp;

	[Header("PC Warping")]
	public Vector3 warpOffset = Vector3.zero;

	public float resetWarpOffsetSpeedThreshold = 0.5f;

	private Vector3 lastOffset = Vector3.zero;

	[Header("Mobile Warping")]
	public bool warpOrientationLookAtHole;

	public TextMeshPro rangeFinderText;

	public bool canWarp = true;

	public float autoWarpPerpendicularAngle = 80f;

	public GameObject nearestHole;

	public static event Action onAutowarp;

	private void Start()
	{
		manualWarpIndicator = UnityEngine.Object.Instantiate(manualWarpIndicatorPrefab).GetComponent<ManualWarpIndicator>();
		switchClubsOnWarp = false;
		if (GameManager.instance.publishedPlatform == PublishedPlatform.XR)
		{
			warpToCenter = PlayerPrefsX.GetBool("WarpToCenter", defaultValue: false);
		}
		else
		{
			warpToCenter = PlayerPrefsX.GetBool("WarpToCenter", defaultValue: true);
		}
		warpInAir = PlayerPrefsX.GetBool("WarpInAir", defaultValue: true);
		if (GameManager.instance.publishedPlatform == PublishedPlatform.XR)
		{
			warpOrientationLookAtHole = true;
		}
	}

	private void Update()
	{
		if (!Player.instance.currentControllerInput.bButton.down)
		{
			if (PhotonNetwork.IsConnected && (GameManager.instance.currentSceneName == "RoomPrepScene" || GameManager.instance.currentSceneName == "ScoreScene"))
			{
				Warp();
				ShowManualWarpLine();
			}
			else if (GameManager.instance.currentSceneName.Contains("Boss2"))
			{
				if (!Player.instance.currentController.pointerActive)
				{
					Warp();
					ShowManualWarpLine();
				}
			}
			else if (Player.instance.currentController.pointerActive)
			{
				if (manualWarpIndicator.isShown)
				{
					HideManualWarpLine();
				}
			}
			else
			{
				Warp();
				ShowManualWarpLine();
			}
		}
		else if (Player.instance.currentControllerInput.bButton.wasPressed)
		{
			HideManualWarpLine();
		}
	}

	public void SetSwitchClubs()
	{
		if (GameManager.instance.IsCloudlands1Hole())
		{
			switchClubsOnWarp = false;
		}
		else
		{
			switchClubsOnWarp = GameManager.instance.GetClubChangeOnWarp();
		}
	}

	public void Warp(bool warpToClosestBallMat = false, bool forceWarp = false)
	{
		if (GameManager.instance.currentSceneName == "Boss2 New Mechanic Test" && !canWarp)
		{
			return;
		}
		bool wasPressed = Player.instance.currentControllerInput.xButton.wasPressed;
		bool flag = Player.instance.currentController.constrainedSwing && Player.instance.currentController.controllerMode == ControllerMode.PuttingMode;
		if (!((wasPressed && !flag) || forceWarp))
		{
			return;
		}
		Player.instance.clubSwitcher.currentClub.detectCollisions = false;
		if (!(GameManager.instance.golfball != null || warpToClosestBallMat))
		{
			return;
		}
		Golfball golfball = null;
		if (warpToClosestBallMat)
		{
			Transform[] warpPoints = Boss2Scene.instance.warpPoints;
			Transform transform = null;
			float num = float.PositiveInfinity;
			Transform[] array = warpPoints;
			foreach (Transform transform2 in array)
			{
				if (transform2.gameObject.activeSelf && Vector3.Distance(Player.instance.head.position, transform2.position) < num)
				{
					num = Vector3.Distance(Player.instance.head.position, transform2.transform.position);
					transform = transform2;
				}
			}
			StartCoroutine(BlinkWarp(WarpPlayer(Vector3.zero, transform.position)));
		}
		else
		{
			golfball = GameManager.instance.golfball;
		}
		if (golfball == null)
		{
			return;
		}
		if (Player.instance.currentController.constrainedSwing)
		{
			Vector3 position = golfball.transform.position;
			Vector3 vector = position;
			nearestHole = GameManager.instance.GetNearestHoleFromPos(position);
			if (GameManager.instance.publishedPlatform == PublishedPlatform.XR && nearestHole != null && golfball.IsGrounded() && ClearViewFromPlayerToHole(nearestHole))
			{
				bool flag2 = GameManager.instance.currentSceneName == "CustomHoleScene" && GameManager.instance.holeData[GameManager.instance.holeIndex].golfClubType == GolfClubType.Putter;
				if (!GameManager.instance.IsCloudlands1Hole() && !flag2)
				{
					RotateHeadPerpendicularToHole(position, nearestHole.transform);
				}
			}
			vector = StandardWarpPosition();
			StartCoroutine(BlinkWarp(WarpPlayer(Vector3.zero, vector)));
			clubSwitcher.ResetClubVelocities();
			savedMode = Player.instance.currentController.controllerMode;
			Player.instance.currentController.SwitchControllerMode(ControllerMode.FollowMode);
			clubSwitcher.SwitchClubsOnWarp();
			Player.instance.currentController.freshWarp = true;
		}
		else if (warpInAir || golfball.IsGrounded())
		{
			clubSwitcher.ResetClubVelocities();
			savedMode = Player.instance.currentController.controllerMode;
			StartCoroutine(BlinkWarp(WarpPlayer(Vector3.zero, golfball.transform.position)));
			if (golfball.rb.velocity.magnitude < resetWarpOffsetSpeedThreshold)
			{
				lastOffset = warpOffset;
			}
			clubSwitcher.SwitchClubsOnWarp();
		}
		if (TutorialManager.instance != null)
		{
			TutorialManager.instance.AutoWarped();
		}
	}

	private Vector3 WarpPlayer(Vector3 warpInFrontVector, Vector3 groundCollider)
	{
		groundCollider.y += 0.05f;
		Vector3 zero = Vector3.zero;
		if (!ScoreManager.instance.ballScored)
		{
			zero = ((!warpToCenter && !Player.instance.currentController.constrainedSwing && !(lastOffset == warpOffset)) ? (groundCollider + warpInFrontVector - warpOffset) : (groundCollider + warpInFrontVector));
		}
		else
		{
			Vector3 position = GameManager.instance.golfball.transform.position;
			zero = new Vector3(position.x, position.y + 0.2f, position.z) + warpInFrontVector;
		}
		OnAutoWarp();
		return zero;
	}

	public void SetWarpOffset(Vector3 offset)
	{
		lastOffset = warpOffset;
		if (GameManager.instance.golfball != null)
		{
			warpOffset = new Vector3(offset.x, GameManager.instance.golfball.transform.lossyScale.x * 0.5f, offset.z);
		}
	}

	protected virtual IEnumerator BlinkWarp(Vector3 newPlayerPos, bool isManualWarp = false)
	{
		float num = 0.01f;
		if ((newPlayerPos - Player.instance.transform.position).magnitude > num)
		{
			_ = Player.instance.head.position - Player.instance.transform.position;
			_ = newPlayerPos - Player.instance.transform.position;
			Player.instance.transform.position = newPlayerPos;
			Player.instance.clubSwitcher.currentClub.ResetVelocity();
			yield return null;
		}
	}

	public bool ToggleWarpToCenter()
	{
		warpToCenter = !warpToCenter;
		PlayerPrefsX.SetBool("WarpToCenter", warpToCenter);
		return warpToCenter;
	}

	public bool ToggleWarpInAir()
	{
		warpInAir = !warpInAir;
		PlayerPrefsX.SetBool("WarpInAir", warpInAir);
		return warpInAir;
	}

	public void ShowManualWarpLine()
	{
		if (Player.instance.currentControllerInput.touchpadStatus.upTouchpadButtonStatus.down)
		{
			lineRenderer.enabled = true;
			UpdateManualWarpLine();
			manualWarpIndicator.UpdatePosition();
			manualWarpIndicator.Show();
			savedMode = Player.instance.currentController.controllerMode;
			Player.instance.currentController.SwitchControllerMode(ControllerMode.FollowMode);
			holdingDownManualWarp = true;
		}
		else if (Player.instance.currentControllerInput.touchpadStatus.upTouchpadButtonStatus.wasReleased)
		{
			HideManualWarpLine();
			ManualWarp();
			holdingDownManualWarp = false;
		}
	}

	public void UpdateManualWarpLine()
	{
		lineRenderer.positionCount = myNumSteps;
		float num = warpLineLength / (float)myNumSteps;
		Vector3 position = Player.instance.clubSwitcher.manualWarpPoint.position;
		Vector3 vector = Player.instance.clubSwitcher.manualWarpPoint.forward * warpTrajectoryForce;
		Vector3 vector2 = Vector3.zero;
		Vector3 forward = Vector3.zero;
		hitValidSurface = false;
		int positionCount = myNumSteps;
		lineRenderer.SetPosition(0, position);
		for (int i = 1; i < myNumSteps; i++)
		{
			vector += manualWarpGravity * num;
			Vector3 vector3 = vector * num;
			if (Physics.Raycast(position, vector, out trajectoryHit, vector3.magnitude, manualWarpLayerMask))
			{
				if (trajectoryHit.collider.transform.gameObject.layer == LayerMask.NameToLayer("WarpBlockers") || trajectoryHit.collider.transform.gameObject.layer == LayerMask.NameToLayer("ClubScalable"))
				{
					hitValidSurface = false;
					vector2 = trajectoryHit.point;
					forward = trajectoryHit.normal;
					lineRenderer.SetPosition(i, vector2);
					positionCount = i + 1;
					break;
				}
				if (Vector3.Project(trajectoryHit.normal, Vector3.up).y > 0f)
				{
					if (trajectoryHit.collider.transform.gameObject.layer == LayerMask.NameToLayer("GolfingSurface"))
					{
						hitValidSurface = true;
					}
					else
					{
						hitValidSurface = false;
					}
					vector2 = trajectoryHit.point;
					forward = trajectoryHit.normal;
					lineRenderer.SetPosition(i, vector2);
					positionCount = i + 1;
					break;
				}
			}
			else if (Physics.Raycast(position + vector3, -vector, out trajectoryHit, vector3.magnitude, manualWarpLayerMask))
			{
				if (trajectoryHit.collider.transform.gameObject.layer == LayerMask.NameToLayer("GolfingSurface"))
				{
					if (Vector3.Project(trajectoryHit.normal, Vector3.up).y > 0f)
					{
						hitValidSurface = true;
						vector2 = trajectoryHit.point;
						forward = trajectoryHit.normal;
						lineRenderer.SetPosition(i, vector2);
						positionCount = i + 1;
						break;
					}
				}
				else
				{
					hitValidSurface = false;
				}
			}
			if (i == myNumSteps - 1)
			{
				vector2 = position;
				forward = Vector3.up;
			}
			else
			{
				position += vector * num;
			}
			lineRenderer.SetPosition(i, position);
		}
		lineRenderer.positionCount = positionCount;
		if (Player.instance.rightHanded)
		{
			rangeFinderText.transform.localScale = new Vector3(1f, 1f, 1f);
		}
		else
		{
			rangeFinderText.transform.localScale = new Vector3(-1f, 1f, 1f);
		}
		if (hitValidSurface)
		{
			manualWarpIndicator.ShowGood();
			lineRenderer.material.color = manualWarpGoodColor;
			float num2 = Vector3.Distance(vector2, Player.instance.currentController.transform.position) / 1.09361f;
			if (num2 < 0.1f)
			{
				rangeFinderText.text = "0 " + LocalizationManager.GetTranslation("Yards");
			}
			else
			{
				rangeFinderText.text = num2.ToString("#.0") + " " + LocalizationManager.GetTranslation("Yards");
				rangeFinderText.transform.SetParent(Player.instance.clubSwitcher.currentClub.clubScaler.clubHead.transform);
				rangeFinderText.transform.localPosition = new Vector3(0f, 0f, 0.15f);
			}
		}
		else
		{
			manualWarpIndicator.ShowBad();
			lineRenderer.material.color = manualWarpBadColor;
			rangeFinderText.text = "";
		}
		manualWarpIndicator.SetTarget(vector2, Quaternion.LookRotation(forward));
	}

	public void HideManualWarpLine()
	{
		rangeFinderText.text = "";
		manualWarpIndicator.Hide();
		lineRenderer.enabled = false;
	}

	public void ManualWarp()
	{
		if (manualWarpIndicator.IsOnValidWarpSurface())
		{
			nearestHole = GameManager.instance.GetNearestHoleFromPos(base.transform.position);
			if (warpToCenter)
			{
				base.transform.position = manualWarpIndicator.targetPosition;
			}
			else
			{
				base.transform.position = ReturnHeadToTargetWarp(manualWarpIndicator.targetPosition);
			}
			clubSwitcher.SwitchClubsOnWarp();
			if (Player.instance.currentController.constrainedSwing)
			{
				Player.instance.clubSwitcher.currentClub.ResetVelocity();
				Player.instance.currentController.SwitchControllerMode(ControllerMode.FollowMode);
			}
			if (TutorialManager.instance != null)
			{
				TutorialManager.instance.ManualWarped();
			}
			OnAutoWarp();
		}
	}

	private Vector3 StandardWarpPosition()
	{
		Vector3 vector = GameManager.instance.golfball.transform.position;
		if (!warpToCenter)
		{
			vector = ReturnHeadToTargetWarp(vector);
		}
		if (ScoreManager.instance.ballScored)
		{
			vector.y += 0.2f;
		}
		return vector;
	}

	public Vector3 ReturnHeadToTargetWarp(Vector3 target)
	{
		Transform head = GetComponent<Player>().head;
		Vector3 position = Player.instance.transform.position;
		Vector3 vector = target - (head.position - position);
		vector.y = target.y;
		target = ((!warpToCenter) ? (vector - ReturnOffsetHead()) : vector);
		return target;
	}

	private Vector3 ReturnOffsetHead()
	{
		Transform head = GetComponent<Player>().head;
		Vector3 vector = head.forward;
		if ((Vector3.Project(head.up, Vector3.up) - head.position).y < 0f)
		{
			vector = head.up;
		}
		vector.y = 0f;
		return vector.normalized * distanceToBall * 2f;
	}

	public void SetDistanceToBallClose()
	{
		distanceToBall = 0.25f;
	}

	public void SetDistanceToBallNormal()
	{
		distanceToBall = 0.5f;
	}

	public void SetDistanceToBallFar()
	{
		distanceToBall = 0.75f;
	}

	public bool ToggleWarpOrientation()
	{
		warpOrientationLookAtHole = !warpOrientationLookAtHole;
		return warpOrientationLookAtHole;
	}

	public void OnAutoWarp()
	{
		if (Autowarp.onAutowarp != null)
		{
			Autowarp.onAutowarp();
		}
	}

	private void RotateHeadPerpendicularToHole(Vector3 ballPos, Transform hole)
	{
		Transform head = Player.instance.head;
		Vector3 forward = hole.position - ballPos;
		forward.y = 0f;
		Quaternion rotation = Quaternion.LookRotation(forward, Vector3.up);
		base.transform.rotation = rotation;
		float y = head.localEulerAngles.y;
		Vector3 eulerAngles = base.transform.eulerAngles;
		eulerAngles.y -= y;
		if (Player.instance.rightHanded)
		{
			eulerAngles.y += autoWarpPerpendicularAngle;
		}
		else
		{
			eulerAngles.y -= autoWarpPerpendicularAngle;
		}
		base.transform.eulerAngles = eulerAngles;
	}

	private bool ClearViewFromPlayerToHole(GameObject hole)
	{
		Transform head = Player.instance.head;
		Golfhole component = hole.GetComponent<Golfhole>();
		_ = hole.transform.parent;
		Vector3 position = component.holePoint.position;
		position.y += 1.8f;
		if (Physics.Raycast(head.position, position - head.position, out var hitInfo, float.PositiveInfinity))
		{
			_ = hitInfo.transform.GetComponentInParent<Golfhole>() == component;
			return true;
		}
		return false;
	}
}
public class Boss1Scene : MonoBehaviour
{
	public static Boss1Scene instance;

	public CaveBoss boss;

	public CaveBossBallLauncher ballLauncher;

	public GolfballSpawner ballSpawn;

	private void Awake()
	{
		instance = this;
	}

	private void Start()
	{
		ScoreManager.instance.currentStrokeCount = 0;
		StartCoroutine(DelayStart());
	}

	private IEnumerator DelayStart()
	{
		yield return new WaitForEndOfFrame();
		Player.instance.clubSwitcher.SwitchToClubType(ClubType.Putter);
		GameManager.instance.audioManager.PlayBossSong(Song.boss1);
	}
}
public class CaveBoss : Boss
{
	public bool launchBall;

	[Header("Ball Launching")]
	public GameObject golfballPrefab;

	public Transform projectileLaunchPos;

	private float ballisticTime = 1f;

	private float initialBallLaunchTimer = 3f;

	[Header("Rocks")]
	public List<FallingRocks> rocks = new List<FallingRocks>();

	private int phase1RockFallAmount = 1;

	private int phase1RockFallsAttempts = 3;

	private int phase2RockFallAmount = 3;

	private int phase2RockFallsAttempts = 3;

	private int phase3RockFallAmount = 5;

	private int phase3RockFallsAttempts = 6;

	public int numRocksFalling;

	public int jumpAttempts;

	public bool makeRocksFall;

	[HideInInspector]
	private float rotateTowards;

	public float rotateSpeed = 1f;

	[Header("SFX")]
	public AudioSource[] otherSFX;

	public AudioSource idleSFX;

	public float idleSFXInterval = 8f;

	public float idleSFXTimer;

	public AudioSource fallingRockSFX;

	public AudioSource dislodingRockSFX;

	public bool hasBeenHit;

	public override void Start()
	{
		base.Start();
		rotateTowards = base.transform.eulerAngles.y;
		PlayAnimation("Idle");
		numRocksFalling = 0;
		jumpAttempts = 0;
	}

	private void Update()
	{
		if (Pause())
		{
			return;
		}
		if (Input.GetKeyDown(KeyCode.H))
		{
			TakeDamage();
		}
		if (!GameManager.instance.loadingLevel)
		{
			if (initialBallLaunchTimer > 0f)
			{
				initialBallLaunchTimer -= Time.deltaTime;
			}
			else if (GameManager.instance.golfball == null && !hasBeenHit && hp > 0 && hp != 4)
			{
				Boss1Scene.instance.ballLauncher._LaunchBall();
			}
		}
		if (hp > 0 && hp != 4)
		{
			RotateBody();
			FallingRockTimer();
			PlayIdleSFX();
		}
	}

	private void LaunchBallBasedOnBallisticTime()
	{
		Vector3 position = base.transform.position;
		position.y = Player.instance.head.position.y;
		Vector3 position2 = Player.instance.head.position;
		float magnitude = Boss.CalculateBestThrowSpeed(target: (Vector3.Distance(position, position2) > 16f) ? (Player.instance.head.position + (position - Player.instance.head.position) / 3f) : ((Vector3.Distance(position, position2) < 6.8f) ? ((position - Player.instance.head.position) / 100f) : ((Vector3.Distance(position, position2) < 9f) ? (Player.instance.head.position + (position - Player.instance.head.position) * 3f) : ((!(Vector3.Distance(position, position2) < 13f)) ? (Player.instance.head.position + (position - Player.instance.head.position) / 3.375f) : (Player.instance.head.position + (position - Player.instance.head.position) / 6f)))), origin: projectileLaunchPos.position, timeToTarget: ballisticTime).magnitude;
		GameObject gameObject = UnityEngine.Object.Instantiate(golfballPrefab, projectileLaunchPos.position, projectileLaunchPos.rotation);
		if (GameManager.instance.golfball != null)
		{
			UnityEngine.Object.Destroy(GameManager.instance.golfball.gameObject);
		}
		GameManager.instance.golfball = gameObject.GetComponent<Golfball>();
		GameManager.instance.golfball.AddTrailRenderer();
		float num = UnityEngine.Random.Range(0f - Boss1Scene.instance.ballLauncher.spread, Boss1Scene.instance.ballLauncher.spread);
		gameObject.GetComponent<Rigidbody>().AddForce(magnitude * projectileLaunchPos.forward + projectileLaunchPos.right * num, ForceMode.VelocityChange);
	}

	public void FinishedJump()
	{
		VibrateController();
		if (makeRocksFall)
		{
			FallingRocks();
		}
		if (launchBall)
		{
			launchBall = false;
			LaunchBallBasedOnBallisticTime();
		}
		hasBeenHit = false;
	}

	private void FallingRocks()
	{
		jumpAttempts--;
		for (int i = 0; i < numRocksFalling; i++)
		{
			if (rocks.Count > 0)
			{
				int index = UnityEngine.Random.Range(0, rocks.Count);
				rocks[index].MakeFall();
				rocks.RemoveAt(index);
			}
		}
		makeRocksFall = false;
		Player.instance.currentControllerInput.Vibrate(1f);
	}

	private void FallingRockTimer()
	{
		if (jumpAttempts > 0 && rocks.Count > 0 && !makeRocksFall)
		{
			attackTimer += Time.deltaTime;
			if (attackTimer >= attackInterval)
			{
				PlayAnimation("Jump");
				attackTimer = 0f;
				makeRocksFall = true;
			}
		}
	}

	private void RotateBody()
	{
		Vector3 forward = Player.instance.head.position - base.transform.position;
		forward.y = 0f;
		Quaternion b = Quaternion.LookRotation(forward);
		base.transform.rotation = Quaternion.Slerp(base.transform.rotation, b, rotateSpeed * Time.deltaTime);
	}

	private void SetRotateTowards()
	{
		int num = UnityEngine.Random.Range(0, 3) * 90;
		while (rotateTowards == (float)num)
		{
			num = UnityEngine.Random.Range(0, 3) * 90;
		}
		rotateTowards = num;
	}

	public override void TakeDamage()
	{
		attackTimer = 0f;
		SetRotateTowards();
		if (rocks.Count > 0)
		{
			makeRocksFall = true;
		}
		base.TakeDamage();
		if (hp == 0)
		{
			PlayDeathAnimation();
		}
		else
		{
			if (hp == 3)
			{
				numRocksFalling = phase1RockFallAmount;
				jumpAttempts = phase1RockFallsAttempts;
			}
			if (hp == 2)
			{
				numRocksFalling = phase2RockFallAmount;
				jumpAttempts = phase2RockFallsAttempts;
			}
			else if (hp == 1)
			{
				numRocksFalling = phase3RockFallAmount;
				jumpAttempts = phase3RockFallsAttempts;
			}
			launchBall = true;
			hasBeenHit = true;
			PlayAnimation("Hit");
		}
		if (GameManager.instance.golfball != null)
		{
			UnityEngine.Object.Destroy(GameManager.instance.golfball.gameObject);
		}
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (collision.gameObject.GetComponent<Golfball>() != null)
		{
			collision.gameObject.GetComponent<Golfball>().ballRenderer.enabled = false;
			collision.gameObject.GetComponent<Golfball>().rb.isKinematic = true;
			TakeDamage();
		}
	}

	public override void PlayDeathAnimation()
	{
		PlayAnimation("Death");
		if (ScoreManager.instance.currentStrokeCount <= GameManager.instance.holeData[GameManager.instance.holeData.Count - 1].par)
		{
			GameManager.instance.gameAchievements.UnlockAchievement(Achievement.BOSS1_PAR);
		}
	}

	public void VibrateController()
	{
		Player.instance.currentControllerInput.Vibrate(0.5f, 1f);
	}

	private void PlayIdleSFX()
	{
		if (idleSFXTimer >= idleSFXInterval)
		{
			idleSFXTimer = 0f;
			AudioSource[] array = otherSFX;
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i].enabled)
				{
					idleSFX.Stop();
					return;
				}
			}
			idleSFX.Play();
		}
		else
		{
			idleSFXTimer += Time.deltaTime;
		}
	}

	public void PlayRockLandingSFX()
	{
		if (!fallingRockSFX.isPlaying)
		{
			fallingRockSFX.Play();
		}
	}

	public void PlayDislodgingRockSFX()
	{
		if (makeRocksFall && !dislodingRockSFX.isPlaying)
		{
			dislodingRockSFX.Play();
		}
	}
}
public class CaveBossBallLauncher : Cannon
{
	public CaveBoss boss;

	public void _DoInteract()
	{
		DoInteract(GameManager.instance.golfball.GetComponent<Collider>());
	}

	public override void DoInteract(Collider other)
	{
		base.DoInteract(other);
	}

	private void OnTriggerStay(Collider other)
	{
		if (other.GetComponent<Golfball>() != null)
		{
			UnityEngine.Object.Destroy(other.gameObject);
			_LaunchBall();
		}
	}

	public void _LaunchBall()
	{
		if (boss.hp == 4)
		{
			boss.TakeDamage();
		}
		OBManager.instance.respawnTimer = 0f;
		boss.launchBall = true;
		if (boss.attackTimer >= boss.attackInterval - 10f)
		{
			boss.attackTimer = boss.attackInterval - 10f;
		}
		boss.animator.StopPlayback();
		boss.PlayAnimation("Jump");
	}
}
public class CaveBossEye : MonoBehaviour
{
	public CaveBoss caveBoss;

	private void OnCollisionEnter(Collision collision)
	{
		if (collision.gameObject.GetComponent<Golfball>() != null)
		{
			collision.gameObject.GetComponent<Golfball>().ballRenderer.enabled = false;
			collision.gameObject.GetComponent<Golfball>().rb.isKinematic = true;
			caveBoss.TakeDamage();
		}
	}
}
public class FallingRocks : MonoBehaviour
{
	public bool isFalling;

	private bool hasLanded;

	private Rigidbody rb;

	private MeshCollider col;

	private Vector3 velocity;

	private float dragMax = 2f;

	private void Start()
	{
		rb = GetComponent<Rigidbody>();
		col = GetComponent<MeshCollider>();
	}

	private void Update()
	{
		Fall();
	}

	private void Fall()
	{
		if (!isFalling)
		{
			return;
		}
		if (GameManager.instance.pauseMenu.paused)
		{
			if (rb.velocity != Vector3.zero)
			{
				velocity = rb.velocity;
			}
			rb.isKinematic = true;
			return;
		}
		rb.isKinematic = false;
		rb.drag = UnityEngine.Random.Range(0f, dragMax);
		if (velocity != Vector3.zero)
		{
			rb.velocity = velocity;
			velocity = Vector3.zero;
		}
	}

	public void MakeFall()
	{
		rb.drag = UnityEngine.Random.Range(0f, dragMax);
		isFalling = true;
	}

	private void OnCollisionEnter(Collision collision)
	{
		if ((bool)collision.gameObject.GetComponent<FallingRocks>())
		{
			return;
		}
		if (collision.gameObject.layer == LayerMask.NameToLayer("GolfingSurface"))
		{
			isFalling = false;
			rb.isKinematic = true;
			col.convex = false;
			hasLanded = true;
			Boss1Scene.instance.boss.PlayRockLandingSFX();
		}
		else if (collision.gameObject.GetComponentInParent<Golfball>() != null && !hasLanded && isFalling)
		{
			if (GameManager.instance.golfball != null)
			{
				UnityEngine.Object.Destroy(GameManager.instance.golfball.gameObject);
			}
			Boss1Scene.instance.ballLauncher._LaunchBall();
			OBManager.instance.PlayOBSFX();
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (!hasLanded && other.GetComponentInParent<Player>() != null)
		{
			MonoBehaviour.print("Hit player");
			ScoreManager.instance.AddStroke();
			StartCoroutine(Boss1Scene.instance.boss.Fade());
			if (GameManager.instance.golfball != null)
			{
				UnityEngine.Object.Destroy(GameManager.instance.golfball.gameObject);
			}
			Boss1Scene.instance.ballLauncher._LaunchBall();
			OBManager.instance.PlayOBSFX();
			ScoreManager.instance.AddStroke();
			Player.instance.currentControllerInput.Vibrate(0.1f, 1f);
		}
	}
}
public class AutoWarpBlocker : MonoBehaviour
{
	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.layer == LayerMask.NameToLayer("Golfball"))
		{
			Player.instance.autoWarp.canWarp = false;
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (other.gameObject.layer == LayerMask.NameToLayer("Golfball"))
		{
			Player.instance.autoWarp.canWarp = true;
		}
	}
}
public class Boss2Scene : MonoBehaviour
{
	public static Boss2Scene instance;

	public MagicianBoss boss;

	public GameObject[] magicWalls;

	public Transform[] bossPhasePositions;

	public MagicianCopy[] phase2MagicianCopies;

	public MagicianCopy[] phase3MagicianCopies;

	public bool playerEnteredPhaseTrigger = true;

	public bool allowSwitchingPhase;

	public Transform[] warpPoints;

	private void Awake()
	{
		instance = this;
	}

	private void Start()
	{
		GameObject[] array = magicWalls;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: true);
		}
		SetPhase1();
		StartCoroutine(DelayStart());
	}

	private IEnumerator DelayStart()
	{
		yield return new WaitForEndOfFrame();
		Player.instance.clubSwitcher.SwitchToClubType(ClubType.Iron);
		GameManager.instance.audioManager.PlayBossSong(Song.boss2);
	}

	private void Update()
	{
		Player.instance.clubSwitcher.preventClubSwitchOnWarp = true;
	}

	public void SetPhase1()
	{
		boss.transform.position = bossPhasePositions[0].position;
		boss.transform.rotation = bossPhasePositions[0].rotation;
		boss.projectileArc = 0.3f;
		boss.allowAttacking = true;
		boss.ToggleMesh(toggle: true);
		boss.aimIndex = 0;
		warpPoints[0].gameObject.SetActive(value: true);
	}

	public void SetPhase2()
	{
		allowSwitchingPhase = true;
		boss.transform.position = bossPhasePositions[1].position;
		boss.transform.rotation = bossPhasePositions[1].rotation;
		boss.projectileArc = 0.5f;
		boss.allowAttacking = false;
		boss.ToggleMesh(toggle: false);
		playerEnteredPhaseTrigger = false;
		ExplodeWall(magicWalls[0]);
		warpPoints[0].gameObject.SetActive(value: false);
		warpPoints[1].gameObject.SetActive(value: true);
		warpPoints[2].gameObject.SetActive(value: true);
		warpPoints[3].gameObject.SetActive(value: true);
	}

	public void SetPhase3()
	{
		allowSwitchingPhase = true;
		for (int i = 0; i < phase2MagicianCopies.Length; i++)
		{
			phase2MagicianCopies[i].gameObject.SetActive(value: false);
		}
		boss.projectileArc = 0.1f;
		boss.projectileSpeed = 10f;
		boss.ToggleMesh(toggle: true);
		boss.aimIndex = 1;
		ExplodeWall(magicWalls[1]);
		playerEnteredPhaseTrigger = false;
		boss.allowAttacking = true;
		warpPoints[4].gameObject.SetActive(value: true);
	}

	public void SetPhase4()
	{
		allowSwitchingPhase = true;
		for (int i = 0; i < phase3MagicianCopies.Length; i++)
		{
			phase3MagicianCopies[i].gameObject.SetActive(value: false);
		}
		boss.transform.position = bossPhasePositions[2].position;
		boss.transform.rotation = bossPhasePositions[2].rotation;
		boss.projectileArc = 0f;
		boss.projectileSpeed = 30f;
		boss.hasBeenHit = false;
		playerEnteredPhaseTrigger = false;
		ExplodeWall(magicWalls[2]);
		boss.ToggleMesh(toggle: true);
		boss.aimIndex = 2;
		warpPoints[4].gameObject.SetActive(value: false);
		warpPoints[5].gameObject.SetActive(value: true);
		Player.instance.clubSwitcher.SwitchToClubType(ClubType.Putter);
	}

	public void ExplodeWall(GameObject wall)
	{
		wall.GetComponent<Animator>().Play("EXG");
	}
}
public class MagicianBoss : Boss
{
	public MagicianPhase phase;

	public GameObject projectilePrefab;

	public Transform projectileLaunchPos;

	public float projectileSpeed = 10f;

	public float projectileArc;

	public Transform[] aimPoints;

	public int aimIndex;

	public GameObject[] mesh;

	public bool allowAttacking = true;

	public bool hasBeenHit;

	private float firstLerpSpeed = 3f;

	private float secondLerpSpeed = 10f;

	public Golfball ball;

	public Transform lerpToPosition;

	private float lerpCountdownInterval = 1.75f;

	private float lerpCountdownTimer;

	public bool lerpBall;

	public MagicianCrystal crystal;

	public override void Start()
	{
		base.Start();
	}

	private void Update()
	{
		if (Pause())
		{
			return;
		}
		if (Boss2Scene.instance.playerEnteredPhaseTrigger)
		{
			if (phase == MagicianPhase.Phase1)
			{
				Phase1();
			}
			else if (phase == MagicianPhase.Phase2)
			{
				Phase2();
			}
			else if (phase == MagicianPhase.Phase3)
			{
				Phase3();
			}
			else
			{
				Phase4();
			}
		}
		if (Input.GetKeyDown(KeyCode.H))
		{
			TakeDamage();
		}
	}

	private bool CanAttack()
	{
		if (phase == MagicianPhase.Phase2)
		{
			if (attackTimer >= attackInterval)
			{
				attackTimer = 0f;
				return true;
			}
			attackTimer += Time.deltaTime;
			return false;
		}
		if (ball == null)
		{
			return true;
		}
		return false;
	}

	private void Phase1()
	{
		if (attackTimer >= attackInterval)
		{
			if (CanAttack() && !animator.GetCurrentAnimatorStateInfo(0).IsName("Appear"))
			{
				PlayAnimation("Attack");
			}
		}
		else
		{
			attackTimer += Time.deltaTime;
		}
	}

	private void Phase2()
	{
		if (CanAttack())
		{
			CopyAttack();
		}
	}

	private void Phase3()
	{
		if (CanAttack() && !hasBeenHit)
		{
			PlayAnimation("Attack");
			CopyAttack();
		}
		LerpBallToPosition();
	}

	private void Phase4()
	{
		if (hp > 0 && CanAttack())
		{
			PlayAnimation("Attack");
		}
	}

	public override void PlayDeathAnimation()
	{
		PlayAnimation("Death");
	}

	public override void TakeDamage()
	{
		if (phase != MagicianPhase.Phase4)
		{
			if (phase == MagicianPhase.Phase3)
			{
				hasBeenHit = true;
			}
			base.TakeDamage();
			PlayAnimation("Hit");
			attackTimer = attackInterval - 2f;
		}
	}

	private void DoHitEvent()
	{
		if (hp == 5)
		{
			Boss2Scene.instance.SetPhase2();
		}
		else if (hp == 2)
		{
			Boss2Scene.instance.SetPhase3();
		}
		else if (hp == 1)
		{
			Boss2Scene.instance.SetPhase4();
		}
	}

	private bool CheckCrystalDestroyed()
	{
		if (crystal.crystalHP <= 0)
		{
			return true;
		}
		return false;
	}

	public void ThrowProjectile()
	{
		if (allowAttacking)
		{
			Vector3 position = aimPoints[aimIndex].position;
			if (Boss.CalculateTrajectory(base.transform.position, position, projectileSpeed, out var velocity, projectileArc))
			{
				ball = UnityEngine.Object.Instantiate(projectilePrefab, projectileLaunchPos.position, projectileLaunchPos.rotation).GetComponent<Golfball>();
				GameManager.instance.golfball = ball;
				ball.GetComponent<Rigidbody>().AddForce(velocity, ForceMode.VelocityChange);
			}
			else
			{
				UnityEngine.Debug.Log("Target cannot be reached. Increase speed or reduce distance.");
			}
		}
	}

	private void CopyAttack()
	{
		if (phase == MagicianPhase.Phase2)
		{
			for (int i = 0; i < Boss2Scene.instance.phase2MagicianCopies.Length; i++)
			{
				if (Boss2Scene.instance.phase2MagicianCopies[i].gameObject.activeSelf)
				{
					Boss2Scene.instance.phase2MagicianCopies[i].startShootTimer = true;
				}
			}
		}
		else
		{
			if (phase != MagicianPhase.Phase3)
			{
				return;
			}
			for (int j = 0; j < Boss2Scene.instance.phase3MagicianCopies.Length; j++)
			{
				if (Boss2Scene.instance.phase3MagicianCopies[j].gameObject.activeSelf && !Boss2Scene.instance.phase3MagicianCopies[j].hasBeenHit)
				{
					Boss2Scene.instance.phase3MagicianCopies[j].PlayAnimation("Attack");
				}
			}
		}
	}

	public void ToggleMesh(bool toggle)
	{
		GameObject[] array = mesh;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(toggle);
		}
	}

	private void LerpBallToPosition()
	{
		if (ball != null)
		{
			float num = 0f;
			lerpCountdownTimer += Time.deltaTime;
			Vector3 position;
			if (lerpCountdownTimer >= lerpCountdownInterval)
			{
				position = aimPoints[aimIndex].position;
				num = secondLerpSpeed;
				if (lerpBall)
				{
					ball.GetComponent<MagicianOrb>().PlayLaunchSFX();
				}
			}
			else
			{
				position = lerpToPosition.position;
				lerpBall = true;
				num = firstLerpSpeed;
			}
			if (Vector3.Distance(ball.transform.position, aimPoints[aimIndex].position) < 0.1f)
			{
				lerpBall = false;
			}
			if (lerpBall)
			{
				ball.FreezeVelocity();
				ball.transform.position = Vector3.Lerp(ball.transform.position, position, num * Time.deltaTime);
			}
		}
		else
		{
			lerpCountdownTimer = 0f;
		}
	}
}
public enum MagicianPhase
{
	Phase1,
	Phase2,
	Phase3,
	Phase4
}
public class MagicianCopy : MonoBehaviour
{
	public GameObject projectilePrefab;

	public Transform projectileLaunchPos;

	public float projectileSpeed = 10f;

	public float projectileArc;

	public float shootInterval = 5f;

	public float shootTimer;

	public Transform aimPosition;

	public bool startShootTimer;

	private Animator animator;

	public bool hasBeenHit;

	public GameObject playerWarpPosition;

	private float lerpSpeed = 3f;

	public GameObject ball;

	public Transform lerpToPosition;

	public float lerpCountdownTimer;

	private float lerpCountdownInterval = 1.75f;

	public float ballScale = 0.035f;

	private void Start()
	{
		animator = GetComponent<Animator>();
	}

	private void Update()
	{
		if (GameManager.instance.pauseMenu.paused || hasBeenHit)
		{
			return;
		}
		if (Boss2Scene.instance.boss.phase == MagicianPhase.Phase2)
		{
			if (startShootTimer)
			{
				if (shootTimer >= shootInterval)
				{
					shootTimer = 0f;
					startShootTimer = false;
					PlayAnimation("Attack");
				}
				else
				{
					shootTimer += Time.deltaTime;
				}
			}
			else
			{
				shootTimer = 0f;
			}
		}
		else if (Boss2Scene.instance.boss.phase == MagicianPhase.Phase3)
		{
			LerpBallToPosition();
		}
	}

	private void DoHitEvent()
	{
		hasBeenHit = true;
		PlayAnimation("Hit");
		if (playerWarpPosition != null)
		{
			playerWarpPosition.SetActive(value: false);
		}
		StartCoroutine(HideGameobject());
	}

	private IEnumerator HideGameobject()
	{
		yield return new WaitForSeconds(1f);
		base.gameObject.SetActive(value: false);
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (collision.gameObject.tag == "Golfball")
		{
			if (Boss2Scene.instance.boss.phase == MagicianPhase.Phase2)
			{
				Boss2Scene.instance.boss.TakeDamage();
			}
			DoHitEvent();
		}
	}

	public void ThrowProjectile()
	{
		Vector3 position = aimPosition.position;
		if (Boss.CalculateTrajectory(base.transform.position, position, projectileSpeed, out var velocity, projectileArc))
		{
			ball = UnityEngine.Object.Instantiate(projectilePrefab, projectileLaunchPos.position, projectileLaunchPos.rotation);
			GameManager.instance.golfball = ball.GetComponent<Golfball>();
			ball.GetComponent<Rigidbody>().AddForce(velocity, ForceMode.VelocityChange);
			startShootTimer = false;
		}
		else
		{
			UnityEngine.Debug.Log("Target cannot be reached. Increase speed or reduce distance.");
		}
	}

	public void PlayAnimation(string animationName)
	{
		animator.Play(animationName);
	}

	private void LerpBallToPosition()
	{
		if (ball != null)
		{
			ball.transform.localScale = new Vector3(ballScale, ballScale, ballScale);
			ball.GetComponent<Golfball>().FreezeVelocity();
			lerpCountdownTimer += Time.deltaTime;
			if (lerpCountdownTimer >= lerpCountdownInterval)
			{
				UnityEngine.Object.Destroy(ball);
				lerpCountdownTimer = 0f;
			}
			else
			{
				ball.transform.position = Vector3.Lerp(ball.transform.position, lerpToPosition.position, lerpSpeed * Time.deltaTime);
			}
		}
	}
}
public class MagicianCrystal : MonoBehaviour
{
	public int crystalHP = 3;

	public Light pointLight;

	public Transform[] crystalProps;

	public float baseRotateSpeed;

	public float[] propRotateSpeedMultiplier = new float[6];

	private AudioSource aSource;

	public GameObject explosionPFX;

	private void Start()
	{
		for (int i = 0; i < propRotateSpeedMultiplier.Length; i++)
		{
			propRotateSpeedMultiplier[i] = UnityEngine.Random.Range(1f, 2f);
		}
		aSource = GetComponent<AudioSource>();
	}

	private void Update()
	{
		if (crystalHP > 0 && !GameManager.instance.pauseMenu.paused)
		{
			for (int i = 0; i < propRotateSpeedMultiplier.Length; i++)
			{
				crystalProps[i].RotateAround(base.transform.position, Vector3.up, baseRotateSpeed * propRotateSpeedMultiplier[i] * Time.deltaTime);
			}
		}
	}

	private void DamageCrystal()
	{
		crystalHP--;
		if (crystalHP == 2)
		{
			baseRotateSpeed = 50f;
			pointLight.color = new Color(1f, 0.5f, 0f);
			if (GameManager.instance.currentSceneName == "Boss2")
			{
				Boss2Scene.instance.warpPoints[5].gameObject.SetActive(value: false);
				Boss2Scene.instance.warpPoints[6].gameObject.SetActive(value: true);
				Boss2Scene.instance.boss.aimIndex++;
			}
		}
		else if (crystalHP == 1)
		{
			baseRotateSpeed = 200f;
			pointLight.color = Color.red;
			if (GameManager.instance.currentSceneName == "Boss2")
			{
				Boss2Scene.instance.warpPoints[6].gameObject.SetActive(value: false);
				Boss2Scene.instance.warpPoints[7].gameObject.SetActive(value: true);
				Boss2Scene.instance.boss.aimIndex++;
			}
		}
		else
		{
			if (crystalHP != 0)
			{
				return;
			}
			Transform[] array = crystalProps;
			foreach (Transform obj in array)
			{
				obj.GetComponent<Rigidbody>().isKinematic = false;
				obj.GetComponent<RotateObject>().enabled = false;
			}
			GetComponent<MeshRenderer>().enabled = false;
			pointLight.enabled = false;
			GameManager.instance.audioManager.PlayBossSong(Song.victory);
			explosionPFX.SetActive(value: true);
			aSource.Play();
			if (GameManager.instance.currentSceneName == "Boss2")
			{
				Boss2Scene.instance.boss.PlayDeathAnimation();
				Boss2Scene.instance.boss.enabled = false;
				return;
			}
			MagicianNewMechanic.instance.PlayAnimation("Death");
			if (ScoreManager.instance.currentStrokeCount <= GameManager.instance.holeData[GameManager.instance.holeData.Count - 1].par)
			{
				GameManager.instance.gameAchievements.UnlockAchievement(Achievement.BOSS2_PAR);
			}
		}
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (collision.gameObject.tag == "Golfball")
		{
			DamageCrystal();
		}
	}
}
public class MagicianOrb : MonoBehaviour
{
	private Golfball golfball;

	public bool playTimer;

	public float explodeInterval = 5f;

	private float explodeTimer;

	public bool hasFrozeVelocity;

	public GameObject explosionPFX;

	public ParticleSystem[] idlePFX;

	public Light idlePFXLight;

	public AudioClip launchSFX;

	private AudioSource aSource;

	private Vector3 unpausedVelocity = Vector3.zero;

	public Gradient P_trail_lightning_seq_ExplodeColor;

	public Gradient P_ball_seq_ExplodeColor;

	public Gradient P_core_glow_detail_ExplodeColor;

	public Color pointLightExplodeColor;

	public bool hitWithPutter;

	public GameObject newExplodePFX;

	public GameObject newIdlePFX;

	private void OnEnable()
	{
		PauseMenu.onPaused += OnPaused;
		PauseMenu.onUnpaused += OnUnpaused;
	}

	private void OnDisable()
	{
		PauseMenu.onPaused -= OnPaused;
		PauseMenu.onUnpaused -= OnUnpaused;
	}

	private void Start()
	{
		golfball = GetComponent<Golfball>();
		golfball.golfballVisualTransform.gameObject.SetActive(value: false);
		aSource = GetComponent<AudioSource>();
		PlayLaunchSFX();
	}

	public void PlayLaunchSFX()
	{
		if (!aSource.isPlaying)
		{
			aSource.PlayOneShot(launchSFX);
		}
	}

	private void Update()
	{
		golfball.DestroyTrailRenderer();
		if (!GameManager.instance.pauseMenu.paused)
		{
			Explode();
		}
	}

	private void Explode()
	{
		if (playTimer)
		{
			if (explodeTimer >= explodeInterval)
			{
				explodeTimer = 0f;
				CheckDamagePlayer();
				PlayExplodePFX();
			}
			else
			{
				explodeTimer += Time.deltaTime;
			}
		}
	}

	private void PlayExplodePFX()
	{
		playTimer = false;
		newIdlePFX.SetActive(value: false);
		newExplodePFX.SetActive(value: true);
		newExplodePFX.transform.parent = null;
		GameManager.instance.golfball = null;
		HideOrb();
		Player.instance.currentControllerInput.Vibrate(1f);
		if (GameManager.instance.currentSceneName == "Boss2 New Mechanic Test" && MagicianNewMechanic.instance.phase == MagicianPhase.Phase3)
		{
			StartCoroutine(MagicianNewMechanic.instance.ThrowInitialBall(attackImmediately: true));
		}
	}

	private void HideOrb()
	{
		UnityEngine.Object.Destroy(golfball.golfballVisualTransform.gameObject);
		UnityEngine.Object.Destroy(base.gameObject);
		UnityEngine.Object.Destroy(newExplodePFX, 1f);
	}

	private void CheckDamagePlayer()
	{
		Vector3 position = Player.instance.head.position;
		position.y = base.transform.position.y;
		if (Vector3.Distance(base.transform.position, position) < 1.5f)
		{
			ScoreManager.instance.AddStroke();
		}
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (hasFrozeVelocity)
		{
			if (GameManager.instance.currentSceneName == "Boss2")
			{
				if (!(collision.relativeVelocity.magnitude > 1.5f))
				{
					return;
				}
				if (collision.collider.transform.gameObject.layer == LayerMask.NameToLayer("Boss"))
				{
					PlayExplodePFX();
					if ((bool)collision.gameObject.GetComponent<Boss>())
					{
						if (Boss2Scene.instance.boss.phase == MagicianPhase.Phase2)
						{
							Boss2Scene.instance.boss.ToggleMesh(toggle: false);
						}
						Boss2Scene.instance.boss.TakeDamage();
					}
				}
				else if (!hitWithPutter)
				{
					PlayExplodePFX();
				}
			}
			else if (MagicianNewMechanic.instance.phase == MagicianPhase.Phase3)
			{
				if (collision.gameObject.layer == LayerMask.NameToLayer("WarpBlockers"))
				{
					PlayExplodePFX();
				}
				else if (collision.relativeVelocity.magnitude > 1.5f && !hitWithPutter)
				{
					PlayExplodePFX();
				}
			}
			else if ((bool)collision.gameObject.GetComponent<MagicWall>())
			{
				collision.gameObject.GetComponent<MagicWall>().ExplodeWall();
				MagicianNewMechanic.instance.StartCoroutine(MagicianNewMechanic.instance.ShowArrow());
				PlayExplodePFX();
			}
		}
		else if (collision.collider.transform.gameObject.layer == LayerMask.NameToLayer("GolfingSurface"))
		{
			hasFrozeVelocity = true;
			golfball.FreezeVelocity();
			if (GameManager.instance.currentSceneName == "Boss2")
			{
				playTimer = true;
			}
			else if (GameManager.instance.currentSceneName == "Boss2 New Mechanic Test" && MagicianNewMechanic.instance.phase == MagicianPhase.Phase3)
			{
				playTimer = true;
			}
		}
	}

	private void AnimateOrb()
	{
		if (explodeTimer > 2.5f)
		{
			ParticleSystem.ColorOverLifetimeModule colorOverLifetime = idlePFX[0].colorOverLifetime;
			colorOverLifetime.color = P_trail_lightning_seq_ExplodeColor;
			ParticleSystem.ColorOverLifetimeModule colorOverLifetime2 = idlePFX[1].colorOverLifetime;
			colorOverLifetime2.color = P_ball_seq_ExplodeColor;
			ParticleSystem.ColorOverLifetimeModule colorOverLifetime3 = idlePFX[2].colorOverLifetime;
			colorOverLifetime3.color = P_core_glow_detail_ExplodeColor;
			idlePFXLight.color = pointLightExplodeColor;
		}
	}

	private void OnPaused()
	{
		unpausedVelocity = golfball.rb.velocity;
		golfball.rb.isKinematic = true;
		golfball.enabled = false;
	}

	private void OnUnpaused()
	{
		golfball.rb.isKinematic = false;
		golfball.rb.velocity = unpausedVelocity;
		golfball.enabled = true;
	}
}
public class MagicWall : MonoBehaviour
{
	public Animator anim;

	public void ExplodeWall()
	{
		anim.Play("EXG");
	}
}
public class OrbPedestal : MonoBehaviour
{
	public bool raisePedistal;

	private Vector3 originalPos;

	private Vector3 raisedPos;

	private float raiseSpeed = 0.05f;

	private void Start()
	{
		originalPos = base.transform.position;
		raisedPos = originalPos;
		raisedPos.y += 1.5f;
	}

	private void Update()
	{
		RaisePedistal();
	}

	private void RaisePedistal()
	{
		if (raisePedistal)
		{
			base.transform.position = Vector3.Lerp(base.transform.position, raisedPos, raiseSpeed);
		}
		else
		{
			base.transform.position = Vector3.Lerp(base.transform.position, originalPos, raiseSpeed);
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.tag == "Golfball")
		{
			raisePedistal = true;
			UnityEngine.Object.Destroy(other.gameObject);
		}
	}
}
public class Boss3Scene : MonoBehaviour
{
	public static Boss3Scene instance;

	public ReaperBoss boss;

	public DetectShadow shadowDetectionObj;

	public GolfballSpawner golfballSpawner;

	public Transform[] golfballSpawnerPositions;

	private int currentRoom;

	public MeshRenderer[] demoBalls;

	private float initialDemoAttackTimer = 3f;

	public bool hasFadedDemoBalls;

	public bool hasShownDemo;

	private bool hasSpawnedSkeletonHands;

	private void Awake()
	{
		instance = this;
		golfballSpawner.enabled = false;
	}

	private IEnumerator Start()
	{
		while (Player.instance == null)
		{
			yield return null;
		}
		Player.instance.clubSwitcher.SwitchToClubType(ClubType.Iron);
		GameManager.instance.audioManager.PlayBossSong(Song.noMusic);
		ScoreManager.instance.currentStrokeCount = 0;
	}

	private void Update()
	{
		if (GameManager.instance.pauseMenu.paused)
		{
			return;
		}
		ToggleDetectShadow();
		if (initialDemoAttackTimer > 0f)
		{
			initialDemoAttackTimer -= Time.deltaTime;
			if (initialDemoAttackTimer <= 0f)
			{
				StartCoroutine(boss.TelegraphShadows());
			}
		}
		else if (!hasFadedDemoBalls && boss.attackLightOn)
		{
			FadeDemoBalls();
		}
	}

	private void FadeDemoBalls()
	{
		MeshRenderer[] array = demoBalls;
		foreach (MeshRenderer meshRenderer in array)
		{
			if (!meshRenderer.GetComponent<DetectShadow>().IsInShadow())
			{
				Color color = meshRenderer.material.color;
				float a = color.a;
				if (a > 0f)
				{
					a -= Time.deltaTime;
					color.a = a;
				}
				else
				{
					color.a = 0f;
				}
				meshRenderer.material.color = color;
				if (!hasSpawnedSkeletonHands)
				{
					boss.SpawnSkeletonHand(meshRenderer.transform);
					boss.PlayAnimation("Reaper_AttackShot 0");
				}
			}
		}
		if (!hasSpawnedSkeletonHands)
		{
			boss.PlaySkeletonHandSFX();
		}
		hasSpawnedSkeletonHands = true;
	}

	public IEnumerator HideShadowDemoBalls()
	{
		while (GameManager.instance.pauseMenu.paused)
		{
			yield return null;
		}
		yield return new WaitForSeconds(3f);
		while (GameManager.instance.pauseMenu.paused)
		{
			yield return null;
		}
		MeshRenderer[] array = demoBalls;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].gameObject.SetActive(value: false);
		}
		hasFadedDemoBalls = true;
		golfballSpawner.enabled = true;
		hasShownDemo = true;
		GameManager.instance.audioManager.PlayBossSong(Song.boss3);
	}

	private void ToggleDetectShadow()
	{
		if (GameManager.instance.golfball != null)
		{
			shadowDetectionObj.enabled = true;
			Vector3 position = GameManager.instance.golfball.transform.position;
			position.y -= 0.03f;
			shadowDetectionObj.transform.position = position;
		}
		else
		{
			shadowDetectionObj.enabled = false;
		}
	}
}
public class Boss3Window : MonoBehaviour
{
	public GameObject brokenWindow;

	public bool damageBoss;

	private Material mat;

	private float currentEmission = 255f;

	private float maxEmission = 255f;

	private float minEmission = 100f;

	private float emissionStep = 100f;

	private void Start()
	{
		mat = GetComponent<MeshRenderer>().material;
		StartCoroutine(FadeOut());
	}

	private IEnumerator FadeOut()
	{
		new Color(maxEmission, maxEmission, maxEmission);
		while (currentEmission > minEmission)
		{
			currentEmission -= Time.deltaTime * emissionStep;
			Color value = new Color(currentEmission / 255f, currentEmission / 255f, currentEmission / 255f);
			mat.SetColor("_EmissionColor", value);
			yield return null;
		}
		StartCoroutine(FadeIn());
	}

	private IEnumerator FadeIn()
	{
		new Color(minEmission, minEmission, minEmission);
		while (currentEmission < maxEmission)
		{
			currentEmission += Time.deltaTime * emissionStep;
			Color value = new Color(currentEmission / 255f, currentEmission / 255f, currentEmission / 255f);
			mat.SetColor("_EmissionColor", value);
			yield return null;
		}
		StartCoroutine(FadeOut());
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.tag == "Golfball")
		{
			StopAllCoroutines();
			brokenWindow.SetActive(value: true);
			base.gameObject.SetActive(value: false);
			if (damageBoss)
			{
				Boss3Scene.instance.boss.TakeDamage();
				Boss3Scene.instance.boss.ResetBall();
			}
			Boss3Scene.instance.boss.PlayHurtAnimation();
			Boss3Scene.instance.boss.attackTimer = 0f;
		}
	}
}
public class DetectShadow : MonoBehaviour
{
	public Transform lightPos;

	public bool IsInShadow()
	{
		RaycastHit[] array = Physics.RaycastAll(base.transform.position, -lightPos.forward);
		foreach (RaycastHit raycastHit in array)
		{
			if (raycastHit.transform.gameObject.GetComponent<SafeShadow>() != null)
			{
				return true;
			}
		}
		return false;
	}
}
public class ForceClubOnLanding : MonoBehaviour
{
	private void OnCollisionEnter(Collision collision)
	{
		if (collision.gameObject.GetComponent<Golfball>() != null)
		{
			Player.instance.clubSwitcher.SwitchToClubType(ClubType.Iron);
		}
	}
}
public class ReaperBoss : Boss
{
	public GameObject redLightContainer;

	public Light ambientLight;

	public Light reaperLight;

	public Color defaultLightColor;

	public Color redLightStepColor;

	public Color redLightFinalColor;

	private float ambientDefaultLightIntensity = 0.7f;

	private float ambientDefaultLightFinalIntensity = 1.5f;

	private float redLightDefaultIntensity = 1f;

	private float redLightTransitionIntensity = 3f;

	private float redLightFinalIntensity = 5f;

	private Color originalLightingColor;

	public DetectShadow detectShadowScript;

	private bool telegraphingShadowAttack;

	public bool attackLightOn;

	public Transform[] movePositions;

	public float moveSpeed = 1f;

	public int currentMovePosition;

	public AudioClip flashSFX;

	public AudioClip attackVoiceSFX;

	public AudioClip brokenWindowSFX;

	public AudioClip skeletonHandSFX;

	public float pulseSpeed = 0.75f;

	private AudioSource aSource;

	public GameObject skeletonGrabHandPrefab;

	public ParticleSystem batPFX;

	private Coroutine telegraphShadowCoroutine;

	private Coroutine redLightCoroutine;

	private float randomIdleSFXInterval = 1f;

	private float randomIdleSFXTimer;

	public AudioSource idleSFX;

	public override void Start()
	{
		base.Start();
		aSource = GetComponent<AudioSource>();
	}

	private void Update()
	{
		PauseBats();
		if (!Pause())
		{
			if (Boss3Scene.instance.hasShownDemo && hp > 0)
			{
				Attack();
				CheckBallIsSafe();
				PlayIdleSFX();
			}
			PulseLight();
			aSource.UnPause();
		}
		else
		{
			aSource.Pause();
		}
		if (Input.GetKeyDown(KeyCode.H))
		{
			TakeDamage();
		}
	}

	public void StopTelegraphingAttack()
	{
		if (telegraphShadowCoroutine != null)
		{
			StopCoroutine(telegraphShadowCoroutine);
			telegraphShadowCoroutine = null;
		}
		if (redLightCoroutine != null)
		{
			StopCoroutine(redLightCoroutine);
			redLightCoroutine = null;
		}
		telegraphingShadowAttack = false;
		attackLightOn = false;
		reaperLight.color = defaultLightColor;
		reaperLight.intensity = redLightDefaultIntensity;
		ambientLight.color = defaultLightColor;
		ambientLight.intensity = ambientDefaultLightIntensity;
		aSource.Stop();
	}

	private void Attack()
	{
		if (!telegraphingShadowAttack)
		{
			attackTimer += Time.deltaTime;
			if (attackTimer >= attackInterval)
			{
				attackTimer = 0f;
				telegraphShadowCoroutine = StartCoroutine(TelegraphShadows());
			}
		}
	}

	private void PulseLight()
	{
		if (telegraphingShadowAttack)
		{
			reaperLight.shadowStrength = Mathf.PingPong(Time.time * pulseSpeed, 1f);
		}
		else
		{
			reaperLight.shadowStrength = Mathf.Lerp(reaperLight.shadowStrength, 1f, Time.time * pulseSpeed);
		}
	}

	private IEnumerator RedLightIntensity()
	{
		float steps = 20f;
		float delay = 0.4f;
		reaperLight.color = redLightStepColor;
		float increase = (redLightTransitionIntensity - redLightDefaultIntensity) / steps;
		while (steps > 0f)
		{
			steps -= 1f;
			while (GameManager.instance.pauseMenu.paused)
			{
				yield return null;
			}
			yield return new WaitForSeconds(delay);
			while (GameManager.instance.pauseMenu.paused)
			{
				yield return null;
			}
			reaperLight.intensity += increase;
		}
	}

	public IEnumerator TelegraphShadows()
	{
		if (telegraphingShadowAttack)
		{
			yield break;
		}
		PlayAnimation("Reaper_AttackRedy 0");
		telegraphingShadowAttack = true;
		float duration2 = 0.7f;
		float timeToMinusEachFlash = 0.05f;
		bool alternate = true;
		aSource.PlayOneShot(flashSFX);
		redLightCoroutine = StartCoroutine(RedLightIntensity());
		while (duration2 > 0f)
		{
			while (GameManager.instance.pauseMenu.paused)
			{
				yield return null;
			}
			yield return new WaitForSeconds(duration2);
			while (GameManager.instance.pauseMenu.paused)
			{
				yield return null;
			}
			alternate = !alternate;
			duration2 -= timeToMinusEachFlash;
		}
		float quickFlashes = 0.1f;
		duration2 = 3f;
		while (duration2 > 0f)
		{
			while (GameManager.instance.pauseMenu.paused)
			{
				yield return null;
			}
			yield return new WaitForSeconds(quickFlashes);
			while (GameManager.instance.pauseMenu.paused)
			{
				yield return null;
			}
			duration2 -= quickFlashes;
			alternate = !alternate;
		}
		telegraphingShadowAttack = false;
		StartCoroutine(AttackLight());
	}

	private IEnumerator AttackLight()
	{
		attackLightOn = true;
		reaperLight.color = redLightFinalColor;
		reaperLight.intensity = redLightFinalIntensity;
		ambientLight.color = redLightFinalColor;
		ambientLight.intensity = ambientDefaultLightFinalIntensity;
		while (GameManager.instance.pauseMenu.paused)
		{
			yield return null;
		}
		yield return new WaitForSeconds(3f);
		while (GameManager.instance.pauseMenu.paused)
		{
			yield return null;
		}
		attackLightOn = false;
		if (!Boss3Scene.instance.hasFadedDemoBalls)
		{
			Boss3Scene.instance.StartCoroutine(Boss3Scene.instance.HideShadowDemoBalls());
		}
		else
		{
			StartCoroutine(MoveReaper());
		}
		reaperLight.color = defaultLightColor;
		reaperLight.intensity = redLightDefaultIntensity;
		ambientLight.color = defaultLightColor;
		ambientLight.intensity = ambientDefaultLightIntensity;
	}

	private void PlayAttackVoiceSFX()
	{
		aSource.PlayOneShot(attackVoiceSFX);
	}

	private void CheckBallIsSafe()
	{
		if (attackLightOn)
		{
			if (!detectShadowScript.IsInShadow())
			{
				SpawnSkeletonHand(GameManager.instance.golfball.transform);
				OBManager.instance.PlayOBSFX();
				ResetBall();
				attackLightOn = false;
				ScoreManager.instance.AddStroke();
				PlayAnimation("Reaper_AttackShot 0");
				PlaySkeletonHandSFX();
			}
			else
			{
				PlayAnimation("Reaper_AttackRedy Reversed");
			}
		}
	}

	public void PlaySkeletonHandSFX()
	{
		aSource.PlayOneShot(skeletonHandSFX);
	}

	public void SpawnSkeletonHand(Transform pos)
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(skeletonGrabHandPrefab, pos.position, pos.rotation);
		Vector3 position = gameObject.transform.position;
		gameObject.transform.position = position;
		gameObject.transform.LookAt(Player.instance.head.position);
		gameObject.transform.eulerAngles = new Vector3(-90f, gameObject.transform.eulerAngles.y, 0f);
		UnityEngine.Object.Destroy(gameObject, 2f);
	}

	public void ResetBall()
	{
		if (GameManager.instance.golfball != null)
		{
			GameManager.instance.golfball.DestroyTrailRenderer();
			Boss3Scene.instance.golfballSpawner.ResetBall();
		}
	}

	private void FadeBall()
	{
		Color color = GameManager.instance.golfball.ballRenderer.material.color;
		float a = color.a;
		a -= Time.deltaTime;
		color.a = a;
		GameManager.instance.golfball.ballRenderer.material.color = color;
	}

	public void PlayHurtAnimation()
	{
		aSource.PlayOneShot(brokenWindowSFX);
	}

	public override void TakeDamage()
	{
		base.TakeDamage();
		PlayHurtAnimation();
		StopTelegraphingAttack();
		ResetBall();
		if (hp == 0)
		{
			PlayAnimation("Reaper_Death");
			if (GameManager.instance.golfball != null)
			{
				UnityEngine.Object.Destroy(GameManager.instance.golfball.gameObject);
			}
		}
		else
		{
			StartCoroutine(Fade());
			PlayAnimation("Reaper_AttackRedy Reversed");
		}
	}

	private IEnumerator MoveReaper()
	{
		currentMovePosition++;
		if (currentMovePosition > movePositions.Length - 1)
		{
			currentMovePosition = 0;
		}
		PlayAnimation("Reappear");
		float duration = 5f;
		while (duration > 0f)
		{
			while (GameManager.instance.pauseMenu.paused)
			{
				yield return null;
			}
			duration -= Time.deltaTime;
			base.transform.position = Vector3.Lerp(base.transform.position, movePositions[currentMovePosition].position, Time.deltaTime * moveSpeed);
			base.transform.rotation = Quaternion.Lerp(base.transform.rotation, movePositions[currentMovePosition].rotation, Time.deltaTime * moveSpeed);
			redLightContainer.transform.position = base.transform.position;
			Vector3 eulerAngles = base.transform.eulerAngles;
			eulerAngles.x = redLightContainer.transform.eulerAngles.x;
			redLightContainer.transform.eulerAngles = eulerAngles;
			yield return null;
		}
	}

	private void PlayIdleSFX()
	{
		if (animator.GetCurrentAnimatorStateInfo(0).IsName("Stand_Idle"))
		{
			if (randomIdleSFXTimer >= randomIdleSFXInterval)
			{
				randomIdleSFXTimer = 0f;
				randomIdleSFXInterval = UnityEngine.Random.Range(5f, 8f);
				idleSFX.Play();
			}
			else
			{
				randomIdleSFXTimer += Time.deltaTime;
			}
		}
		else
		{
			randomIdleSFXTimer = 0f;
		}
	}

	private void PauseBats()
	{
		if (GameManager.instance.pauseMenu.paused)
		{
			batPFX.Pause(withChildren: true);
		}
		else
		{
			batPFX.Play(withChildren: true);
		}
	}

	public override void PlayAnimation(string animationName)
	{
		if (hp == 0)
		{
			animator.Play("Reaper_Death");
			if (ScoreManager.instance.currentStrokeCount <= GameManager.instance.holeData[GameManager.instance.holeData.Count - 1].par)
			{
				GameManager.instance.gameAchievements.UnlockAchievement(Achievement.BOSS3_PAR);
			}
		}
		else
		{
			animator.Play(animationName);
		}
	}
}
public class SafeShadow : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class Boss : MonoBehaviour
{
	public int hp = 20;

	internal int maxHP = 20;

	public float attackTimer;

	public float attackInterval = 10f;

	internal Animator animator;

	public virtual void Start()
	{
		maxHP = hp;
		animator = GetComponent<Animator>();
	}

	public bool Pause()
	{
		if (GameManager.instance.pauseMenu.paused)
		{
			animator.speed = 0f;
			return true;
		}
		animator.speed = 1f;
		return false;
	}

	public virtual void TakeDamage()
	{
		if (hp > 0)
		{
			attackTimer = 3f;
			hp--;
			if (hp == 0)
			{
				GameManager.instance.audioManager.PlayBossSong(Song.victory);
			}
		}
	}

	public static Vector3 CalculateBestThrowSpeed(Vector3 origin, Vector3 target, float timeToTarget)
	{
		Vector3 vector;
		Vector3 vector2 = (vector = target - origin);
		vector.y = 0f;
		float y = vector2.y;
		float magnitude = vector.magnitude;
		float y2 = y / timeToTarget + 0.5f * Physics.gravity.magnitude * timeToTarget;
		float num = magnitude / timeToTarget;
		Vector3 normalized = vector.normalized;
		normalized *= num;
		normalized.y = y2;
		return normalized;
	}

	public static bool CalculateTrajectory(Vector3 origin, Vector3 target, float speed, out Vector3 velocity, float arc = 0f)
	{
		Vector3 vector;
		Vector3 vector2 = (vector = target - origin);
		vector.y = 0f;
		float y = vector2.y;
		float magnitude = vector.magnitude;
		float magnitude2 = Physics.gravity.magnitude;
		float num = speed * speed - y * magnitude2;
		float num2 = num * num - magnitude2 * magnitude2 * (magnitude * magnitude + y * y);
		if (num2 < 0f)
		{
			velocity = Vector3.zero;
			return false;
		}
		float num3 = Mathf.Sqrt(num2);
		float num4 = Mathf.Sqrt((num - num3) * 2f) / Mathf.Abs(magnitude2);
		float num5 = (Mathf.Sqrt((num + num3) * 2f) / Mathf.Abs(magnitude2) - num4) * arc + num4;
		float num6 = magnitude / num5;
		float y2 = y / num5 + num5 * magnitude2 / 2f;
		velocity = vector.normalized;
		velocity *= num6;
		velocity.y = y2;
		return true;
	}

	public virtual void PlayDeathAnimation()
	{
	}

	private void SpawnCampaignMap()
	{
		StartCoroutine(_SpawnCampaignMap());
	}

	private IEnumerator _SpawnCampaignMap()
	{
		yield return new WaitForSeconds(3f);
		GameManager.instance.SpawnCampaignMapNotification();
	}

	public virtual void PlayAnimation(string animationName)
	{
		animator.Play(animationName);
	}

	public IEnumerator Fade()
	{
		StartCoroutine(Player.instance.FadeOut());
		yield return new WaitForSeconds(1f);
		Transform transform = null;
		if (GameManager.instance.currentSceneName == "Boss1")
		{
			transform = Boss1Scene.instance.ballSpawn.GetComponent<HoleStart>().spawnPoint;
		}
		else if (GameManager.instance.currentSceneName == "Boss3")
		{
			transform = Boss3Scene.instance.golfballSpawner.GetComponent<HoleStart>().spawnPoint;
			if (GameManager.instance.golfball != null)
			{
				GameManager.instance.golfball.DestroyTrailRenderer();
			}
		}
		Player.instance.transform.position = transform.position;
		Player.instance.RotateHeadToFacePosition(transform);
		StartCoroutine(Player.instance.FadeIn());
	}
}
public class MagicianBaseBallHitDetection : MonoBehaviour
{
	public Transform positionToFollow;

	private Rigidbody rb;

	public float sensitivity = 100f;

	public Queue<Vector3> collisionPositions = new Queue<Vector3>();

	public Queue<Quaternion> collisionRotations = new Queue<Quaternion>();

	private Vector3 triggerOrigScale;

	private Vector3 triggerTmpScale;

	public float triggerThreshold = 0.2f;

	public float maxTriggerXScale = 0.4f;

	public float maxTriggerZScale = 0.3f;

	private void Start()
	{
		base.transform.parent = null;
		rb = GetComponent<Rigidbody>();
		triggerOrigScale = base.transform.localScale;
	}

	private void Update()
	{
		if (collisionPositions.Count < 5)
		{
			collisionPositions.Enqueue(positionToFollow.position);
			collisionRotations.Enqueue(positionToFollow.rotation);
		}
	}

	private void FixedUpdate()
	{
		DetectHit();
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.GetComponent<MagicianPingPongBall>() != null)
		{
			other.GetComponent<MagicianPingPongBall>().HasBeenHit();
		}
	}

	private void DetectHit()
	{
		if (collisionPositions.Count > 0)
		{
			rb.MovePosition(Vector3.Lerp(base.transform.position, collisionPositions.Dequeue(), sensitivity * Time.deltaTime));
			rb.MoveRotation(Quaternion.Lerp(base.transform.rotation, collisionRotations.Dequeue(), sensitivity * Time.deltaTime));
			ScaleTrigger(reset: false);
		}
	}

	private void ScaleTrigger(bool reset)
	{
		if (reset)
		{
			base.transform.localScale = triggerOrigScale;
			return;
		}
		float magnitude = Player.instance.clubSwitcher.currentClub.GetAverageVelocity().magnitude;
		triggerTmpScale = triggerOrigScale;
		if (magnitude > triggerThreshold)
		{
			triggerTmpScale.x = maxTriggerXScale;
			triggerTmpScale.z = maxTriggerZScale;
		}
		base.transform.localScale = triggerTmpScale;
	}
}
public class MagicianNewMechanic : Boss
{
	public MagicianPhase phase;

	public static MagicianNewMechanic instance;

	public Golfball ball;

	public GameObject projectilePrefab;

	public GameObject golfballPrefab;

	public MagicianPingPongBall projectile;

	public Transform projectileLaunchPos;

	private SphereCollider sphereCollider;

	public float projectileSpeed = 10f;

	public float projectileArc = 0.3f;

	public float distanceCheck = 3f;

	private bool isReflecting;

	public bool hasBeenHit;

	public bool throwNewBall;

	[Header("===Phase 1===")]
	public Transform phase1AimPos;

	[Header("===Phase 2===")]
	public Transform phase2AimPos;

	public Transform phase2Position;

	public GameObject[] phase2Magicians;

	public bool isCopyMagician;

	public Vector3 offset;

	[Header("===Phase 3===")]
	public Transform phase3Position;

	public Transform phase3AimPos1;

	public Transform phase3AimPos2;

	public Transform phase3AimPos3;

	public MagicianCrystal crystal;

	private AudioSource aSource;

	public AudioClip hitSFX;

	public AudioClip appearLaughSFX;

	public AudioClip disappearLaughSFX;

	public AudioClip finalLaughSFX;

	private float rethrowBallTimer = 10f;

	public GameObject[] arrows;

	private int arrowIndex;

	private void Awake()
	{
		if (!isCopyMagician)
		{
			instance = this;
		}
	}

	public override void Start()
	{
		base.Start();
		sphereCollider = GetComponent<SphereCollider>();
		StartCoroutine(ThrowInitialBall());
		aSource = GetComponent<AudioSource>();
		aSource.PlayOneShot(appearLaughSFX);
		if (!isCopyMagician)
		{
			StartCoroutine(DelayStart());
			ScoreManager.instance.currentStrokeCount = 0;
			Player.instance.clubSwitcher.SwitchToClubType(ClubType.Driver);
		}
	}

	private IEnumerator DelayStart()
	{
		yield return new WaitForEndOfFrame();
		GameManager.instance.audioManager.PlayBossSong(Song.boss2);
	}

	private void Update()
	{
		if (!Pause())
		{
			ReflectBall();
			if (throwNewBall)
			{
				StartCoroutine(ThrowInitialBall(attackImmediately: true));
			}
			if (phase != MagicianPhase.Phase3)
			{
				if (projectile == null)
				{
					if (!hasBeenHit)
					{
						rethrowBallTimer -= Time.deltaTime;
						if (rethrowBallTimer <= 0f)
						{
							MonoBehaviour.print("Force Rethrow");
							rethrowBallTimer = 10f;
							StartCoroutine(ThrowInitialBall(attackImmediately: true));
						}
					}
				}
				else
				{
					rethrowBallTimer = 10f;
				}
			}
		}
		if (Input.GetKeyDown(KeyCode.H) && phase != MagicianPhase.Phase3)
		{
			HitByBall();
		}
	}

	public IEnumerator ThrowInitialBall(bool attackImmediately = false)
	{
		if (!attackImmediately)
		{
			yield return new WaitForSeconds(attackInterval);
		}
		isReflecting = false;
		PlayAnimation("Attack");
		distanceCheck = 9f;
	}

	private void ThrowProjectile()
	{
		if (phase == MagicianPhase.Phase3)
		{
			Vector3 position = phase3AimPos1.position;
			if (Boss.CalculateTrajectory(projectileLaunchPos.position, position, projectileSpeed, out var velocity, projectileArc))
			{
				ball = UnityEngine.Object.Instantiate(golfballPrefab, projectileLaunchPos.position, projectileLaunchPos.rotation).GetComponent<Golfball>();
				GameManager.instance.golfball = ball;
				ball.enabled = true;
				ball.GetComponent<Rigidbody>().AddForce(velocity, ForceMode.VelocityChange);
			}
			else
			{
				UnityEngine.Debug.Log("Target cannot be reached. Increase speed or reduce distance.");
			}
			return;
		}
		if (isReflecting)
		{
			if (projectile != null)
			{
				projectile.HasBeenHit();
			}
		}
		else
		{
			projectile = UnityEngine.Object.Instantiate(projectilePrefab, projectileLaunchPos.position, projectileLaunchPos.rotation).GetComponent<MagicianPingPongBall>();
			projectile.magicianPos = base.transform;
			projectile.magician = this;
			throwNewBall = false;
			if (isCopyMagician)
			{
				projectile.offset = offset;
			}
		}
		isReflecting = true;
	}

	private void ReflectBall()
	{
		if (!(projectile != null) || projectile.moveToPlayer)
		{
			return;
		}
		if (projectile.numberOfHitsTillExplode > 0)
		{
			if (projectile.numberOfHitsTillExplode == 1)
			{
				sphereCollider.enabled = true;
			}
			else
			{
				sphereCollider.enabled = false;
			}
			if (Vector3.Distance(base.transform.position, projectile.transform.position) < distanceCheck)
			{
				PlayAnimation("Attack");
			}
		}
		else
		{
			sphereCollider.enabled = true;
		}
	}

	public void HitByBall()
	{
		PlayAnimation("Hit");
		projectile.PlayExplodePFX(throwBallBack: false);
		aSource.PlayOneShot(hitSFX);
		hasBeenHit = true;
		bool flag = true;
		if (phase == MagicianPhase.Phase2)
		{
			if (!hasBeenHit)
			{
				flag = false;
			}
			GameObject[] array = phase2Magicians;
			foreach (GameObject gameObject in array)
			{
				if (gameObject != null && !gameObject.GetComponent<MagicianNewMechanic>().hasBeenHit)
				{
					flag = false;
					break;
				}
			}
		}
		if (flag)
		{
			sphereCollider.enabled = false;
			Vector3 position = phase1AimPos.position;
			if (phase == MagicianPhase.Phase2)
			{
				position = phase2AimPos.position;
			}
			if (Boss.CalculateTrajectory(projectileLaunchPos.position, position, projectileSpeed, out var velocity, projectileArc))
			{
				ball = UnityEngine.Object.Instantiate(golfballPrefab, projectileLaunchPos.position, projectileLaunchPos.rotation).GetComponent<Golfball>();
				GameManager.instance.golfball = ball;
				ball.enabled = true;
				ball.GetComponent<Rigidbody>().AddForce(velocity, ForceMode.VelocityChange);
			}
			else
			{
				UnityEngine.Debug.Log("Target cannot be reached. Increase speed or reduce distance.");
			}
		}
		if (isCopyMagician)
		{
			UnityEngine.Object.Destroy(base.gameObject, 5f);
		}
	}

	public void SetPhase2()
	{
		base.transform.position = phase2Position.position;
		base.transform.rotation = phase2Position.rotation;
		GameObject[] array = phase2Magicians;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: true);
		}
		sphereCollider.enabled = true;
		PlayAnimation("Reapper");
		StartCoroutine(ThrowInitialBall());
		phase = MagicianPhase.Phase2;
		hasBeenHit = false;
		arrowIndex = 1;
	}

	public void SetPhase3()
	{
		sphereCollider.enabled = false;
		PlayAnimation("Reapper");
		aSource.PlayOneShot(finalLaughSFX);
		base.transform.position = phase3Position.position;
		base.transform.rotation = phase3Position.rotation;
		projectileArc = 0f;
		projectileSpeed = 30f;
		Player.instance.clubSwitcher.SwitchToClubType(ClubType.Putter);
		StartCoroutine(ThrowInitialBall());
		phase = MagicianPhase.Phase3;
		hasBeenHit = false;
	}

	public IEnumerator ShowArrow()
	{
		int flashes = 3;
		int index = arrowIndex;
		while (flashes > 0)
		{
			arrows[index].SetActive(value: true);
			yield return new WaitForSeconds(1f);
			arrows[index].SetActive(value: false);
			yield return new WaitForSeconds(1f);
			flashes--;
		}
		arrows[index].SetActive(value: true);
	}
}
public class MagicianPingPongBall : MonoBehaviour
{
	private Golfball golfball;

	public MagicianNewMechanic magician;

	public Transform magicianPos;

	public Vector3 target;

	public float projectileSpeed = 5f;

	public bool moveToPlayer = true;

	private Rigidbody rb;

	public int numberOfHitsTillExplode = 5;

	private float timeTillChangeTarget = 0.3f;

	private bool allowChangeTarget = true;

	public LayerMask explodeLayer;

	public GameObject explosionPFX;

	public Vector3 offset;

	private void Start()
	{
		rb = GetComponent<Rigidbody>();
		golfball = GetComponent<Golfball>();
		golfball.enabled = false;
		golfball.ballRenderer.enabled = false;
		target = Player.instance.head.transform.position;
		target += offset;
		Vector3 forward = target - base.transform.position;
		base.transform.rotation = Quaternion.LookRotation(forward, Vector3.up);
	}

	private void Update()
	{
		if (!GameManager.instance.pauseMenu.paused)
		{
			TimeTillChangeTarget();
		}
	}

	private void FixedUpdate()
	{
		if (!GameManager.instance.pauseMenu.paused)
		{
			MoveTowardsTarget();
		}
	}

	public void MoveTowardsTarget()
	{
		Vector3 position = base.transform.position;
		position += base.transform.forward * projectileSpeed * Time.fixedDeltaTime;
		if (!moveToPlayer)
		{
			if (Vector3.Distance(target, base.transform.position) > 0.1f)
			{
				rb.MovePosition(position);
			}
			else if (numberOfHitsTillExplode <= 0)
			{
				magician.HitByBall();
			}
		}
		else
		{
			rb.MovePosition(position);
		}
	}

	private void TimeTillChangeTarget()
	{
		if (!allowChangeTarget)
		{
			if (timeTillChangeTarget > 0f)
			{
				timeTillChangeTarget -= Time.deltaTime;
				return;
			}
			timeTillChangeTarget = 0.3f;
			allowChangeTarget = true;
		}
	}

	public void HasBeenHit()
	{
		if (!allowChangeTarget)
		{
			return;
		}
		if (moveToPlayer)
		{
			moveToPlayer = false;
			if (numberOfHitsTillExplode > 0)
			{
				target = magicianPos.position;
			}
			else
			{
				target = magicianPos.position + magicianPos.forward * 2f;
			}
			target.y += 1f;
			numberOfHitsTillExplode--;
			ScoreManager.instance.AddStroke();
			Player.instance.currentControllerInput.Vibrate(0.1f);
		}
		else
		{
			moveToPlayer = true;
			target = Player.instance.head.transform.position;
			target += offset;
			magician.distanceCheck += 1f;
		}
		projectileSpeed += 1f;
		Vector3 forward = target - base.transform.position;
		base.transform.rotation = Quaternion.LookRotation(forward, Vector3.up);
		allowChangeTarget = false;
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (((int)explodeLayer & (1 << collision.gameObject.layer)) == 1 << collision.gameObject.layer)
		{
			PlayExplodePFX(throwBallBack: true);
		}
	}

	public void PlayExplodePFX(bool throwBallBack)
	{
		explosionPFX.SetActive(value: true);
		explosionPFX.transform.parent = null;
		GameManager.instance.golfball = null;
		HideOrb();
		Player.instance.currentControllerInput.Vibrate(1f);
		if (throwBallBack)
		{
			magician.throwNewBall = true;
		}
	}

	private void HideOrb()
	{
		magician.projectile = null;
		UnityEngine.Object.Destroy(base.gameObject);
		UnityEngine.Object.Destroy(explosionPFX, 1f);
	}
}
public class PhaseChangeTrigger : MonoBehaviour
{
	public MagicianPhase phase;

	private bool triggered;

	private void OnTriggerEnter(Collider other)
	{
		if (GameManager.instance.pauseMenu.paused)
		{
			return;
		}
		if (GameManager.instance.currentSceneName == "Boss2")
		{
			if (Boss2Scene.instance.boss.phase != phase && other.transform.root.tag == "Player" && !triggered)
			{
				StartCoroutine(SetPhase());
				triggered = true;
			}
		}
		else if (other.transform.root.tag == "Player" && !triggered)
		{
			if (phase == MagicianPhase.Phase2)
			{
				MagicianNewMechanic.instance.SetPhase2();
			}
			else if (phase == MagicianPhase.Phase3)
			{
				MagicianNewMechanic.instance.SetPhase3();
			}
			triggered = true;
		}
	}

	private IEnumerator SetPhase()
	{
		if (!Boss2Scene.instance.allowSwitchingPhase)
		{
			yield break;
		}
		Boss2Scene.instance.playerEnteredPhaseTrigger = true;
		Boss2Scene.instance.boss.attackTimer = Boss2Scene.instance.boss.attackInterval;
		if (phase == MagicianPhase.Phase2)
		{
			for (int i = 0; i < Boss2Scene.instance.phase2MagicianCopies.Length; i++)
			{
				Boss2Scene.instance.phase2MagicianCopies[i].gameObject.SetActive(value: true);
			}
			Boss2Scene.instance.boss.phase = phase;
			Boss2Scene.instance.boss.attackTimer = Boss2Scene.instance.boss.attackInterval;
		}
		else if (phase == MagicianPhase.Phase3 || phase == MagicianPhase.Phase4)
		{
			if (phase == MagicianPhase.Phase3)
			{
				Boss2Scene.instance.boss.attackTimer = Boss2Scene.instance.boss.attackInterval - 3f;
				int num = UnityEngine.Random.Range(0, Boss2Scene.instance.phase3MagicianCopies.Length - 1);
				Boss2Scene.instance.boss.transform.position = Boss2Scene.instance.phase3MagicianCopies[num].transform.position;
				Boss2Scene.instance.boss.transform.rotation = Boss2Scene.instance.phase3MagicianCopies[num].transform.rotation;
				for (int j = 0; j < Boss2Scene.instance.phase3MagicianCopies.Length; j++)
				{
					if (j != num)
					{
						Boss2Scene.instance.phase3MagicianCopies[j].gameObject.SetActive(value: true);
					}
				}
			}
			else if (phase == MagicianPhase.Phase4)
			{
				Boss2Scene.instance.boss.attackTimer = Boss2Scene.instance.boss.attackInterval;
			}
			Boss2Scene.instance.boss.PlayAnimation("Hit_Reappear");
			yield return new WaitForEndOfFrame();
			while (Boss2Scene.instance.boss.animator.GetCurrentAnimatorStateInfo(0).IsName("Hit_Reappear"))
			{
				yield return null;
			}
			Boss2Scene.instance.boss.phase = phase;
			Boss2Scene.instance.allowSwitchingPhase = false;
		}
		base.gameObject.SetActive(value: false);
		MonoBehaviour.print("Entering " + phase);
	}
}
public class ClubSwitcher : MonoBehaviour
{
	public bool showDebugInGame;

	public GameObject[] driverClubs;

	public GameObject[] ironClubs;

	public GameObject[] putterClubs;

	public Transform clubContainer;

	private Vector3 constraintDriverPos = new Vector3(0.01f, -0.03f, -0.03f);

	private Vector3 constraintIronPos = new Vector3(0.012f, -0.08f, -0.02f);

	private Vector3 constraintPutterPos = Vector3.zero;

	public GolfClub currentClub;

	[HideInInspector]
	public ClubType currentType;

	[HideInInspector]
	public DriverType driverType;

	[HideInInspector]
	public IronType ironType;

	[HideInInspector]
	public PutterType putterType;

	[HideInInspector]
	public GolfClubType usableClubs;

	[Header("==Manual Warp==")]
	public Transform manualWarpPoint;

	public Transform manualWarpPointLineRenderOrigin;

	[Space(10f)]
	public TextMeshPro ballDistanceText;

	public TextMeshPro currentStrokeCountText;

	public bool preventClubSwitchOnWarp;

	private void Awake()
	{
		usableClubs = GolfClubType.Putter | GolfClubType.Iron | GolfClubType.Driver;
		DisableClubs();
		driverType = DriverType.RegularDriver;
		SwitchToClubType(ClubType.Driver);
	}

	private void Start()
	{
	}

	private void Update()
	{
		if (!Player.instance.currentController.pointerActive)
		{
			bool flag = false;
			if (GameManager.instance.publishedPlatform == PublishedPlatform.XR)
			{
				if (Player.instance.InPuttRadius())
				{
					flag = true;
				}
			}
			else
			{
				flag = true;
			}
			if (flag && Player.instance.currentControllerInput.bButton.down)
			{
				if (Player.instance.currentControllerInput.touchpadStatus.leftTouchpadButtonStatus.wasPressed)
				{
					SwitchClubOnGripPress(reverse: false);
				}
				else if (Player.instance.currentControllerInput.touchpadStatus.rightTouchpadButtonStatus.wasPressed)
				{
					SwitchClubOnGripPress(reverse: true);
				}
			}
		}
		if (GameManager.instance.currentSceneName == "CustomHoleScene" || GameManager.instance.currentSceneName == "LevelEditor")
		{
			if (Player.instance.currentController.constrainedSwing && Player.instance.currentController.controllerMode != 0)
			{
				HideInfo();
			}
			else if (Player.instance.autoWarp.holdingDownManualWarp || GameManager.instance.loadingLevel)
			{
				HideInfo();
			}
			else
			{
				if (!GameManager.instance.IsCloudlands1Hole())
				{
					BallDistance();
				}
				StrokeCount();
			}
		}
		else
		{
			HideInfo();
		}
		if (Player.instance.currentController.constrainedSwing)
		{
			if (Player.instance.currentController.controllerMode == ControllerMode.FollowMode)
			{
				clubContainer.transform.localPosition = Vector3.zero;
			}
			else if (currentType == ClubType.Driver)
			{
				clubContainer.transform.localPosition = constraintDriverPos;
			}
			else if (currentType == ClubType.Iron)
			{
				clubContainer.transform.localPosition = constraintIronPos;
			}
			else if (currentType == ClubType.Putter)
			{
				clubContainer.transform.localPosition = constraintPutterPos;
			}
		}
	}

	private void ToggleDebugInGame(bool x)
	{
		GameObject[] array = driverClubs;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].GetComponent<GolfClub>().showDebugInGame = x;
		}
		array = ironClubs;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].GetComponent<GolfClub>().showDebugInGame = x;
		}
		array = putterClubs;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].GetComponent<GolfClub>().showDebugInGame = x;
		}
	}

	public void ResetClubVelocities()
	{
		if (currentClub != null)
		{
			currentClub.ResetVelocity();
		}
	}

	private void DisableClubs()
	{
		GameObject[] array = driverClubs;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: false);
		}
		array = ironClubs;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: false);
		}
		array = putterClubs;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: false);
		}
	}

	public void SwitchToClubType(ClubType type)
	{
		ClubProfile clubProfile = ScoreManager.instance.playerTurn[GameManager.instance.playerIndex].clubProfile;
		if (type == ClubType.Driver && (usableClubs & GolfClubType.Driver) == GolfClubType.Driver)
		{
			if (currentType != 0)
			{
				currentClub.gameObject.SetActive(value: false);
			}
			driverClubs[(int)driverType].SetActive(value: true);
			currentClub = driverClubs[(int)driverType].GetComponent<GolfClub>();
			currentClub.clubScaler.SetClubLength(currentType, clubProfile.driverLength);
			currentType = ClubType.Driver;
		}
		else if (type == ClubType.Iron && (usableClubs & GolfClubType.Iron) == GolfClubType.Iron)
		{
			if (currentType != ClubType.Iron)
			{
				currentClub.gameObject.SetActive(value: false);
			}
			ironClubs[(int)ironType].SetActive(value: true);
			currentClub = ironClubs[(int)ironType].GetComponent<GolfClub>();
			currentClub.clubScaler.SetClubLength(currentType, clubProfile.ironLength);
			currentType = ClubType.Iron;
		}
		else if (type == ClubType.Putter && (usableClubs & GolfClubType.Putter) == GolfClubType.Putter)
		{
			if (currentType != ClubType.Putter)
			{
				currentClub.gameObject.SetActive(value: false);
			}
			putterClubs[(int)putterType].SetActive(value: true);
			currentClub = putterClubs[(int)putterType].GetComponent<GolfClub>();
			currentClub.clubScaler.SetClubLength(currentType, clubProfile.putterLength);
			currentType = ClubType.Putter;
		}
		currentClub.detectCollisions = false;
		if (GameManager.instance.publishedPlatform == PublishedPlatform.XR)
		{
			currentClub.useAimLine = true;
		}
	}

	public void SwitchClubsOnWarp()
	{
		if (!GameManager.instance.currentSceneName.Contains("Boss") && GameManager.instance.golfball != null && !preventClubSwitchOnWarp && Player.instance.autoWarp.switchClubsOnWarp)
		{
			if (GameManager.instance.golfball.currentSurface == SurfaceType.Tee)
			{
				SwitchToClubType(ClubType.Driver);
			}
			else if (GameManager.instance.golfball.currentSurface == SurfaceType.Green || GameManager.instance.golfball.currentSurface == SurfaceType.Cloudlands1)
			{
				SwitchToClubType(ClubType.Putter);
			}
			else if (GameManager.instance.golfball.currentSurface == SurfaceType.Fairway)
			{
				SwitchToClubType(ClubType.Iron);
			}
			else if (GameManager.instance.golfball.currentSurface == SurfaceType.Rough)
			{
				SwitchToClubType(ClubType.Iron);
			}
			else if (GameManager.instance.golfball.currentSurface == SurfaceType.Apron)
			{
				SwitchToClubType(ClubType.Iron);
			}
			else if (GameManager.instance.golfball.currentSurface == SurfaceType.Bunker)
			{
				SwitchToClubType(ClubType.Iron);
			}
		}
	}

	private void BallDistance()
	{
		if (GameManager.instance.golfball != null)
		{
			if (GameManager.instance.golfball.BallDistance() < 0.1f)
			{
				ballDistanceText.text = "0 " + LocalizationManager.GetTranslation("Yards");
			}
			else
			{
				ballDistanceText.text = GameManager.instance.golfball.BallDistance().ToString("#.0") + " " + LocalizationManager.GetTranslation("Yards");
			}
		}
		else
		{
			ballDistanceText.text = "";
		}
	}

	private void StrokeCount()
	{
		if (GameManager.instance.golfball != null)
		{
			if (ScoreManager.instance.currentStrokeCount == 1)
			{
				currentStrokeCountText.text = ScoreManager.instance.currentStrokeCount + " " + LocalizationManager.GetTranslation("Stroke");
			}
			else
			{
				currentStrokeCountText.text = ScoreManager.instance.currentStrokeCount + " " + LocalizationManager.GetTranslation("Strokes");
			}
		}
		else
		{
			currentStrokeCountText.text = "";
		}
	}

	private void HideInfo()
	{
		ballDistanceText.text = "";
		currentStrokeCountText.text = "";
	}

	private void SwitchClubOnGripPress(bool reverse)
	{
		if (GameManager.instance.IsCloudlands1Hole())
		{
			return;
		}
		int num = (int)currentType;
		int num2 = num;
		int num3 = 1;
		if (reverse)
		{
			num3 = -1;
		}
		do
		{
			num += num3;
			if (num < 0)
			{
				num = 2;
			}
			if (num > 2)
			{
				num = 0;
			}
		}
		while (num != num2 && !CanUseClub((ClubType)num));
		SwitchToClubType((ClubType)num);
		Player.instance.clubSwitcher.preventClubSwitchOnWarp = true;
		OBManager.instance.revertLastClubOnOB = true;
		OBManager.instance.clubTypeBeforeHit = (ClubType)num;
		if (TutorialManager.instance != null && TutorialManager.instance.adjustAim)
		{
			TutorialManager.instance.ChangedClubs();
		}
		Player.instance.currentControllerInput.Vibrate();
	}

	public bool CanUseClub(ClubType type)
	{
		if (type == ClubType.Putter && (usableClubs & GolfClubType.Putter) == GolfClubType.Putter)
		{
			return true;
		}
		if (type == ClubType.Iron && (usableClubs & GolfClubType.Iron) == GolfClubType.Iron)
		{
			return true;
		}
		if (type == ClubType.Driver && (usableClubs & GolfClubType.Driver) == GolfClubType.Driver)
		{
			return true;
		}
		return false;
	}
}
public enum ClubType
{
	Driver,
	Iron,
	Putter
}
public class ControllerInput : MonoBehaviour
{
	private SteamVR_TrackedObject controllerTrackedObject;

	public OVRInput.Controller oculusController;

	[Header("==Input==")]
	public Vector2 stickAxis;

	public float triggerValue;

	public ButtonStatus aButton;

	public ButtonStatus bButton;

	public ButtonStatus xButton;

	public ButtonStatus startButton;

	public TouchpadStatus touchpadStatus;

	private Coroutine oculusVibrateCoroutine;

	public int picoController;

	[Header("==XR SPACE==")]
	public bool usingController;

	private void Start()
	{
		if (GameManager.instance.controllerType == ControllerType.Vive)
		{
			controllerTrackedObject = GetComponent<SteamVR_TrackedObject>();
		}
	}

	private void Update()
	{
		if (bButton.down && TutorialManager.instance != null)
		{
			TutorialManager.instance.GripHeld();
		}
	}

	private void LateUpdate()
	{
		ResetButtons();
	}

	private void FixedUpdate()
	{
		if (GameManager.instance.currentSceneName != "Splash")
		{
			if (GameManager.instance.controllerType == ControllerType.Vive)
			{
				ViveControllerInput();
			}
			else if (GameManager.instance.controllerType == ControllerType.FPS)
			{
				FPSControllerInput();
			}
			else if (GameManager.instance.controllerType == ControllerType.Quest)
			{
				QuestControllerInput();
			}
			else if (GameManager.instance.controllerType == ControllerType.XR)
			{
				XRControllerInput();
			}
			else if (GameManager.instance.controllerType == ControllerType.Pico)
			{
				PicoControllerInput();
			}
		}
	}

	private void ViveControllerInput()
	{
		if (controllerTrackedObject.index == SteamVR_TrackedObject.EIndex.None)
		{
			return;
		}
		SteamVR_Controller.Device device = SteamVR_Controller.Input((int)controllerTrackedObject.index);
		stickAxis = device.GetAxis();
		triggerValue = device.GetAxis(EVRButtonId.k_EButton_Axis1).x;
		if (device.GetPress(4294967296uL))
		{
			if (!aButton.down)
			{
				aButton.wasPressed = true;
			}
			aButton.down = true;
		}
		else
		{
			if (aButton.down)
			{
				aButton.wasReleased = true;
			}
			aButton.down = false;
		}
		_ = aButton.wasPressed;
		if (device.GetPress(4uL))
		{
			if (!bButton.down)
			{
				bButton.wasPressed = true;
			}
			bButton.down = true;
		}
		else
		{
			if (bButton.down)
			{
				bButton.wasReleased = true;
			}
			bButton.down = false;
		}
		if (device.GetHairTrigger())
		{
			if (!xButton.down)
			{
				xButton.wasPressed = true;
			}
			xButton.down = true;
		}
		else
		{
			if (xButton.down)
			{
				xButton.wasReleased = true;
			}
			xButton.down = false;
		}
		if (device.GetPress(2uL))
		{
			if (!startButton.down)
			{
				startButton.wasPressed = true;
			}
			startButton.down = true;
		}
		else
		{
			if (startButton.down)
			{
				startButton.wasReleased = true;
			}
			startButton.down = false;
		}
		UpdateTouchpad(stickAxis);
	}

	private void QuestControllerInput()
	{
		aButton.wasPressed = OVRInput.GetDown(OVRInput.Button.PrimaryThumbstick, oculusController);
		aButton.wasReleased = OVRInput.GetUp(OVRInput.Button.PrimaryThumbstick, oculusController);
		aButton.down = OVRInput.Get(OVRInput.Button.PrimaryThumbstick, oculusController);
		xButton.wasPressed = OVRInput.GetDown(OVRInput.Button.PrimaryIndexTrigger, oculusController);
		xButton.wasReleased = OVRInput.GetUp(OVRInput.Button.PrimaryIndexTrigger, oculusController);
		xButton.down = OVRInput.Get(OVRInput.Button.PrimaryIndexTrigger, oculusController);
		startButton.wasPressed = OVRInput.GetDown(OVRInput.RawButton.Back, OVRInput.Controller.All) || OVRInput.GetDown(OVRInput.Button.One, oculusController) || OVRInput.GetDown(OVRInput.Button.Two, oculusController) || (Input.GetButtonDown("Oculus_CrossPlatform_Button1") && Player.instance.rightHanded) || (Input.GetButtonDown("Oculus_CrossPlatform_Button3") && !Player.instance.rightHanded);
		startButton.wasReleased = OVRInput.GetUp(OVRInput.RawButton.Back, OVRInput.Controller.All) || OVRInput.GetUp(OVRInput.Button.One, oculusController) || OVRInput.GetUp(OVRInput.Button.Two, oculusController) || (Input.GetButtonUp("Oculus_CrossPlatform_Button1") && Player.instance.rightHanded) || (Input.GetButtonUp("Oculus_CrossPlatform_Button3") && !Player.instance.rightHanded);
		startButton.down = OVRInput.Get(OVRInput.RawButton.Back, OVRInput.Controller.All) || OVRInput.Get(OVRInput.Button.One, oculusController) || OVRInput.Get(OVRInput.Button.Two, oculusController) || (Input.GetButton("Oculus_CrossPlatform_Button1") && Player.instance.rightHanded) || (Input.GetButton("Oculus_CrossPlatform_Button3") && !Player.instance.rightHanded);
		bButton.wasPressed = OVRInput.GetDown(OVRInput.Button.PrimaryHandTrigger, oculusController);
		bButton.wasReleased = OVRInput.GetUp(OVRInput.Button.PrimaryHandTrigger, oculusController);
		bButton.down = OVRInput.Get(OVRInput.Button.PrimaryHandTrigger, oculusController);
		stickAxis = OVRInput.Get(OVRInput.Axis2D.PrimaryThumbstick, oculusController);
		UpdateTouchpad(stickAxis);
	}

	private void FPSControllerInput()
	{
		stickAxis = Vector2.zero;
		if (Input.GetKey(KeyCode.Keypad4))
		{
			stickAxis.x = -1f;
		}
		else if (Input.GetKey(KeyCode.Keypad6))
		{
			stickAxis.x = 1f;
		}
		if (Input.GetKey(KeyCode.Keypad8))
		{
			stickAxis.y = 1f;
		}
		else if (Input.GetKey(KeyCode.Keypad2))
		{
			stickAxis.y = -1f;
		}
		if (stickAxis.x != 0f || stickAxis.y != 0f)
		{
			if (!aButton.down)
			{
				aButton.wasPressed = true;
			}
			aButton.down = true;
		}
		else
		{
			if (aButton.down)
			{
				aButton.wasReleased = true;
			}
			aButton.down = false;
		}
		_ = aButton.wasPressed;
		if (Input.GetMouseButton(0))
		{
			if (!xButton.down)
			{
				xButton.wasPressed = true;
			}
			xButton.down = true;
		}
		else
		{
			if (xButton.down)
			{
				xButton.wasReleased = true;
			}
			xButton.down = false;
		}
		if (Input.GetMouseButton(3))
		{
			if (!bButton.down)
			{
				bButton.wasPressed = true;
			}
			bButton.down = true;
		}
		else
		{
			if (bButton.down)
			{
				bButton.wasReleased = true;
			}
			bButton.down = false;
		}
		if (Input.GetMouseButton(2))
		{
			if (!startButton.down)
			{
				startButton.wasPressed = true;
			}
			startButton.down = true;
		}
		else
		{
			if (startButton.down)
			{
				startButton.wasReleased = true;
			}
			startButton.down = false;
		}
		UpdateTouchpad(stickAxis);
	}

	private void XRControllerInput()
	{
	}

	private void PicoControllerInput()
	{
		aButton.wasPressed = Pvr_UnitySDKAPI.Controller.UPvr_GetKeyDown(picoController, Pvr_KeyCode.TOUCHPAD);
		aButton.wasReleased = Pvr_UnitySDKAPI.Controller.UPvr_GetKeyUp(picoController, Pvr_KeyCode.TOUCHPAD);
		aButton.down = Pvr_UnitySDKAPI.Controller.UPvr_GetKey(picoController, Pvr_KeyCode.TOUCHPAD);
		xButton.wasPressed = Pvr_UnitySDKAPI.Controller.UPvr_GetKeyDown(picoController, Pvr_KeyCode.TRIGGER);
		xButton.wasReleased = Pvr_UnitySDKAPI.Controller.UPvr_GetKeyUp(picoController, Pvr_KeyCode.TRIGGER);
		xButton.down = Pvr_UnitySDKAPI.Controller.UPvr_GetKey(picoController, Pvr_KeyCode.TRIGGER);
		startButton.wasPressed = Pvr_UnitySDKAPI.Controller.UPvr_GetKeyDown(picoController, Pvr_KeyCode.APP);
		startButton.wasReleased = Pvr_UnitySDKAPI.Controller.UPvr_GetKeyUp(picoController, Pvr_KeyCode.APP);
		startButton.down = Pvr_UnitySDKAPI.Controller.UPvr_GetKey(picoController, Pvr_KeyCode.APP);
		bButton.wasPressed = Pvr_UnitySDKAPI.Controller.UPvr_GetKeyDown(picoController, Pvr_KeyCode.Left) || Pvr_UnitySDKAPI.Controller.UPvr_GetKeyDown(picoController, Pvr_KeyCode.Right);
		bButton.wasReleased = Pvr_UnitySDKAPI.Controller.UPvr_GetKeyUp(picoController, Pvr_KeyCode.Left) || Pvr_UnitySDKAPI.Controller.UPvr_GetKeyUp(picoController, Pvr_KeyCode.Right);
		bButton.down = Pvr_UnitySDKAPI.Controller.UPvr_GetKey(picoController, Pvr_KeyCode.Left) || Pvr_UnitySDKAPI.Controller.UPvr_GetKey(picoController, Pvr_KeyCode.Right);
		stickAxis = Pvr_UnitySDKAPI.Controller.UPvr_GetTouchPadPosition(picoController);
		stickAxis.x = stickAxis.x / 128f - 1f;
		stickAxis.y = stickAxis.y / 128f - 1f;
		UpdateTouchpad(stickAxis);
	}

	private void ResetButtons()
	{
		if (GameManager.instance.controllerType != ControllerType.XR)
		{
			if (aButton.wasPressed)
			{
				aButton.wasPressed = false;
			}
			if (aButton.wasReleased)
			{
				aButton.wasReleased = false;
			}
		}
		if (bButton.wasPressed)
		{
			bButton.wasPressed = false;
		}
		if (bButton.wasReleased)
		{
			bButton.wasReleased = false;
		}
		if (xButton.wasPressed)
		{
			xButton.wasPressed = false;
		}
		if (xButton.wasReleased)
		{
			xButton.wasReleased = false;
		}
		if (startButton.wasPressed)
		{
			startButton.wasPressed = false;
		}
		if (startButton.wasReleased)
		{
			startButton.wasReleased = false;
		}
		if (touchpadStatus.rightTouchpadButtonStatus.wasPressed)
		{
			touchpadStatus.rightTouchpadButtonStatus.wasPressed = false;
		}
		if (touchpadStatus.rightTouchpadButtonStatus.wasReleased)
		{
			touchpadStatus.rightTouchpadButtonStatus.wasReleased = false;
		}
		if (touchpadStatus.rightTouchpadButtonStatus.down)
		{
			touchpadStatus.rightTouchpadButtonStatus.wasReleased = false;
		}
		if (touchpadStatus.leftTouchpadButtonStatus.wasPressed)
		{
			touchpadStatus.leftTouchpadButtonStatus.wasPressed = false;
		}
		if (touchpadStatus.leftTouchpadButtonStatus.wasReleased)
		{
			touchpadStatus.leftTouchpadButtonStatus.wasReleased = false;
		}
		if (touchpadStatus.leftTouchpadButtonStatus.down)
		{
			touchpadStatus.leftTouchpadButtonStatus.wasReleased = false;
		}
		if (touchpadStatus.upTouchpadButtonStatus.wasPressed)
		{
			touchpadStatus.upTouchpadButtonStatus.wasPressed = false;
		}
		if (touchpadStatus.upTouchpadButtonStatus.wasReleased)
		{
			touchpadStatus.upTouchpadButtonStatus.wasReleased = false;
		}
		if (touchpadStatus.upTouchpadButtonStatus.down)
		{
			touchpadStatus.upTouchpadButtonStatus.wasReleased = false;
		}
		if (touchpadStatus.downTouchpadButtonStatus.wasPressed)
		{
			touchpadStatus.downTouchpadButtonStatus.wasPressed = false;
		}
		if (touchpadStatus.downTouchpadButtonStatus.wasReleased)
		{
			touchpadStatus.downTouchpadButtonStatus.wasReleased = false;
		}
		if (touchpadStatus.downTouchpadButtonStatus.down)
		{
			touchpadStatus.downTouchpadButtonStatus.wasReleased = false;
		}
	}

	private void UpdateTouchpad(Vector2 pos)
	{
		bool flag = false;
		if (GameManager.instance.controllerType == ControllerType.Quest)
		{
			if (Mathf.Abs(stickAxis.x) > 0.5f || Mathf.Abs(stickAxis.y) > 0.5f)
			{
				flag = true;
			}
		}
		else if (GameManager.instance.controllerType == ControllerType.Vive)
		{
			flag = aButton.down;
		}
		else if (GameManager.instance.controllerType == ControllerType.FPS)
		{
			flag = aButton.down;
		}
		else if (GameManager.instance.controllerType == ControllerType.XR)
		{
			flag = aButton.wasPressed;
		}
		else if (GameManager.instance.controllerType == ControllerType.Pico && (Mathf.Abs(stickAxis.x) > 0.5f || Mathf.Abs(stickAxis.y) > 0.5f))
		{
			flag = true;
		}
		if (flag)
		{
			if (!(pos != Vector2.zero))
			{
				return;
			}
			if (Mathf.Abs(pos.x) > Mathf.Abs(pos.y))
			{
				if (pos.x > 0f)
				{
					if (!touchpadStatus.rightTouchpadButtonStatus.down)
					{
						touchpadStatus.rightTouchpadButtonStatus.wasPressed = true;
					}
					touchpadStatus.rightTouchpadButtonStatus.down = true;
				}
				else
				{
					if (!touchpadStatus.leftTouchpadButtonStatus.down)
					{
						touchpadStatus.leftTouchpadButtonStatus.wasPressed = true;
					}
					touchpadStatus.leftTouchpadButtonStatus.down = true;
				}
			}
			else if (pos.y > 0f)
			{
				if (!touchpadStatus.upTouchpadButtonStatus.down)
				{
					touchpadStatus.upTouchpadButtonStatus.wasPressed = true;
				}
				touchpadStatus.upTouchpadButtonStatus.down = true;
			}
			else
			{
				if (!touchpadStatus.downTouchpadButtonStatus.down)
				{
					touchpadStatus.downTouchpadButtonStatus.wasPressed = true;
				}
				touchpadStatus.downTouchpadButtonStatus.down = true;
			}
		}
		else
		{
			if (touchpadStatus.rightTouchpadButtonStatus.down)
			{
				touchpadStatus.rightTouchpadButtonStatus.down = false;
				touchpadStatus.rightTouchpadButtonStatus.wasReleased = true;
			}
			if (touchpadStatus.leftTouchpadButtonStatus.down)
			{
				touchpadStatus.leftTouchpadButtonStatus.down = false;
				touchpadStatus.leftTouchpadButtonStatus.wasReleased = true;
			}
			if (touchpadStatus.upTouchpadButtonStatus.down)
			{
				touchpadStatus.upTouchpadButtonStatus.down = false;
				touchpadStatus.upTouchpadButtonStatus.wasReleased = true;
			}
			if (touchpadStatus.downTouchpadButtonStatus.down)
			{
				touchpadStatus.downTouchpadButtonStatus.down = false;
				touchpadStatus.downTouchpadButtonStatus.wasReleased = true;
			}
		}
	}

	public void Vibrate(float time = 0.01f, float strength = 0.4f)
	{
		if (GameManager.instance.controllerType == ControllerType.Vive)
		{
			if ((bool)controllerTrackedObject && controllerTrackedObject.isValid)
			{
				strength *= 1000f;
				SteamVR_Controller.Input((int)controllerTrackedObject.index).TriggerHapticPulse((ushort)strength);
			}
		}
		else if (GameManager.instance.controllerType == ControllerType.Quest)
		{
			if (oculusVibrateCoroutine != null)
			{
				StopCoroutine(oculusVibrateCoroutine);
			}
			oculusVibrateCoroutine = StartCoroutine(OculusVibrate(time, strength));
		}
		else
		{
			_ = GameManager.instance.controllerType;
			_ = 5;
		}
	}

	private IEnumerator OculusVibrate(float time, float strength)
	{
		OVRInput.SetControllerVibration(0f, 0f, oculusController);
		yield return new WaitForEndOfFrame();
		if (!GameManager.instance.loadingLevel)
		{
			if (strength > 1f)
			{
				strength = 1f;
			}
			float startTime = Time.realtimeSinceStartup;
			OVRInput.SetControllerVibration(1f, strength, oculusController);
			while (Time.realtimeSinceStartup - startTime <= time)
			{
				yield return null;
			}
			OVRInput.SetControllerVibration(0f, 0f, oculusController);
		}
		oculusVibrateCoroutine = null;
	}

	public Quaternion GetCurrentControllerRotation()
	{
		Quaternion result = default(Quaternion);
		ControllerType controllerType = GameManager.instance.controllerType;
		if (controllerType == ControllerType.Vive)
		{
			if (GameManager.instance.GetHandedness())
			{
				return GameManager.instance.player.transform.rotation * InputTracking.GetLocalRotation(XRNode.RightHand);
			}
			return GameManager.instance.player.transform.rotation * InputTracking.GetLocalRotation(XRNode.LeftHand);
		}
		return result;
	}

	public bool AnyButtonPressed()
	{
		if (xButton.wasPressed || aButton.wasPressed || bButton.wasPressed || startButton.wasPressed)
		{
			return true;
		}
		return false;
	}
}
[Serializable]
public struct ButtonStatus
{
	public bool down;

	public bool wasPressed;

	public bool wasReleased;
}
[Serializable]
public struct TouchpadStatus
{
	public ButtonStatus rightTouchpadButtonStatus;

	public ButtonStatus leftTouchpadButtonStatus;

	public ButtonStatus upTouchpadButtonStatus;

	public ButtonStatus downTouchpadButtonStatus;
}
public class DistanceBlips : MonoBehaviour
{
	public int vertexCount = 40;

	public float innerLineWidth = 0.2f;

	public float outerLineWidth = 1f;

	private float startingInnerRadius = 10f;

	private float startingOuterRadius = 50f;

	private float toYards = 1.09361f;

	public LineRenderer[] innerCircles;

	public LineRenderer[] outerCircles;

	public TextMeshPro distanceText;

	public List<GameObject> texts = new List<GameObject>();

	private bool[] showedInnerCircles;

	private bool[] showedOuterCircles;

	private void Start()
	{
		SetupCircle(innerCircles, startingInnerRadius, innerLineWidth);
		SetupCircle(outerCircles, startingOuterRadius, outerLineWidth);
		showedInnerCircles = new bool[innerCircles.Length];
		showedOuterCircles = new bool[outerCircles.Length];
	}

	private void Update()
	{
		if (!(GameManager.instance.golfball != null))
		{
			return;
		}
		float num = GameManager.instance.golfball.BallDistance();
		if (num <= 50f)
		{
			for (int i = 0; i < innerCircles.Length; i++)
			{
				if (num >= (float)(10 * (i + 1)))
				{
					StartCoroutine(Blip(i, inner: true));
				}
			}
			return;
		}
		for (int j = 0; j < outerCircles.Length; j++)
		{
			if (num >= (float)(50 * (j + 1)))
			{
				StartCoroutine(Blip(j, inner: false));
			}
		}
	}

	private void SetupCircle(LineRenderer[] lineRenderers, float startingRadius, float lineWidth)
	{
		for (int i = 0; i < lineRenderers.Length; i++)
		{
			lineRenderers[i].widthMultiplier = lineWidth;
			float num = (float)Math.PI * 2f / (float)vertexCount;
			float num2 = 0f;
			lineRenderers[i].positionCount = vertexCount;
			for (int j = 0; j < lineRenderers[i].positionCount; j++)
			{
				Vector3 position = new Vector3(startingRadius * (float)(i + 1) * toYards * Mathf.Cos(num2), 0f, startingRadius * (float)(i + 1) * toYards * Mathf.Sin(num2));
				lineRenderers[i].SetPosition(j, position);
				num2 += num;
			}
			lineRenderers[i].enabled = false;
		}
	}

	private IEnumerator Blip(int index, bool inner, float time = 2f)
	{
		if (!OBManager.instance.ballIsOB)
		{
			if (inner && !showedInnerCircles[index])
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(distanceText.gameObject);
				texts.Add(gameObject);
				gameObject.GetComponent<TextMeshPro>().text = (index + 1) * 10 + " " + LocalizationManager.GetTranslation("Yards");
				Vector3 position = GameManager.instance.golfball.transform.position;
				GameManager.instance.CenterNotification(gameObject);
				gameObject.transform.eulerAngles = gameObject.transform.eulerAngles + 180f * Vector3.up;
				position.y = base.transform.position.y + 1.5f + (float)index * 1.5f;
				gameObject.transform.position = position;
				UnityEngine.Object.Destroy(gameObject, time);
				showedInnerCircles[index] = true;
				innerCircles[index].enabled = true;
				yield return new WaitForSeconds(time);
				innerCircles[index].enabled = false;
			}
			else if (!inner && !showedOuterCircles[index])
			{
				GameObject gameObject2 = UnityEngine.Object.Instantiate(distanceText.gameObject);
				texts.Add(gameObject2);
				float num = 2 * (index + 1);
				gameObject2.transform.localScale = new Vector3(num, num, num);
				gameObject2.GetComponent<TextMeshPro>().text = (index + 1) * 50 + " " + LocalizationManager.GetTranslation("Yards");
				Vector3 position2 = GameManager.instance.golfball.transform.position;
				GameManager.instance.CenterNotification(gameObject2);
				gameObject2.transform.eulerAngles = gameObject2.transform.eulerAngles + 180f * Vector3.up;
				position2.y = base.transform.position.y + 10f + (float)index;
				gameObject2.transform.position = position2;
				UnityEngine.Object.Destroy(gameObject2, time);
				showedOuterCircles[index] = true;
				outerCircles[index].enabled = true;
				yield return new WaitForSeconds(time);
				outerCircles[index].enabled = false;
			}
		}
	}

	public void ResetBlips()
	{
		for (int i = 0; i < innerCircles.Length; i++)
		{
			innerCircles[i].enabled = false;
			showedInnerCircles[i] = false;
		}
		for (int j = 0; j < outerCircles.Length; j++)
		{
			outerCircles[j].enabled = false;
			showedOuterCircles[j] = false;
		}
		RemoveTexts();
	}

	public void HideBlips()
	{
		for (int i = 0; i < innerCircles.Length; i++)
		{
			innerCircles[i].enabled = false;
			showedInnerCircles[i] = true;
		}
		for (int j = 0; j < outerCircles.Length; j++)
		{
			outerCircles[j].enabled = false;
			showedOuterCircles[j] = true;
		}
		RemoveTexts();
	}

	private void RemoveTexts()
	{
		for (int i = 0; i < texts.Count; i++)
		{
			if (texts[i] != null)
			{
				UnityEngine.Object.Destroy(texts[i]);
			}
		}
		texts.Clear();
	}

	public void SetLocation(Vector3 pos)
	{
		base.transform.position = pos;
	}
}
public class DontGoThroughThings : MonoBehaviour
{
	public bool sendTriggerMessage;

	public LayerMask layerMask = -1;

	public float skinWidth = 0.1f;

	private float minimumExtent;

	private float partialExtent;

	private float sqrMinimumExtent;

	private Vector3 previousPosition;

	private Rigidbody myRigidbody;

	private Collider myCollider;

	public BallHitDetection ballHitDetection;

	private void Start()
	{
		myRigidbody = GetComponent<Rigidbody>();
		myCollider = GetComponent<Collider>();
		previousPosition = myRigidbody.position;
		minimumExtent = Mathf.Min(Mathf.Min(myCollider.bounds.extents.x, myCollider.bounds.extents.y), myCollider.bounds.extents.z);
		partialExtent = minimumExtent * (1f - skinWidth);
		sqrMinimumExtent = minimumExtent * minimumExtent;
	}

	private void FixedUpdate()
	{
		Vector3 vector = myRigidbody.position - previousPosition;
		float sqrMagnitude = vector.sqrMagnitude;
		if (myCollider.enabled && sqrMagnitude > sqrMinimumExtent)
		{
			float num = Mathf.Sqrt(sqrMagnitude);
			if (Physics.Raycast(previousPosition, vector, out var hitInfo, num, layerMask.value))
			{
				if (!hitInfo.collider)
				{
					return;
				}
				if (!hitInfo.collider.isTrigger)
				{
					myRigidbody.position = hitInfo.point - vector / num * partialExtent;
				}
				if (hitInfo.transform.GetComponent<Golfball>() != null)
				{
					Player.instance.clubSwitcher.currentClub.HitBall(hitInfo.transform.GetComponent<Golfball>());
				}
			}
		}
		previousPosition = myRigidbody.position;
	}
}
public class Golfball : MonoBehaviour
{
	public BallType ballType;

	public bool canWarp;

	[HideInInspector]
	public Rigidbody rb;

	public GameObject trailRenderer;

	public GameObject golfballVisualPrefab;

	public Transform golfballVisualTransform;

	[HideInInspector]
	public GameObject trail;

	private AudioSource audioSource;

	private LayerMask ballLayer;

	private float groundDistanceCheck = 0.05f;

	[HideInInspector]
	public Vector3 lastDeltaPosition;

	public Vector3 previousVelocity;

	[HideInInspector]
	public Vector3 previousPosition;

	public MeshRenderer ballRenderer;

	public LayerMask warpNodeLayer;

	private float angularDragStop = 50f;

	private float dragStop = 2f;

	[NonSerialized]
	[HideInInspector]
	public float dragSlopeStop = 100f;

	[NonSerialized]
	[HideInInspector]
	public float dragAngularSlopeStop = 50f;

	private float angularDragStopSpeed = 2.75f;

	private float dragStopSpeed = 0.5f;

	private float dragSlopeStopSpeed = 0.05f;

	private float angularDragNormal = 0.5f;

	private float dragNormal = 0.05f;

	private float angle;

	private bool calculatedGrounded;

	private bool currentGrounded;

	[Header("===Ball Curve===")]
	public Transform aimAdjustArrowParent;

	public Image aimAdjustArrowLeft;

	public Image aimAdjustArrowRight;

	public float distanceToShowArrow = 2f;

	public float controllerRotationPower;

	public float startingControllerRot;

	public float endingControllerRot;

	private bool startAimTimer;

	[HideInInspector]
	public float aimForce = 50f;

	public float aimTimer = 2f;

	private float baseAimForce = 50f;

	private float baseAimTimer = 5f;

	private float debugMoveSpeed = 5f;

	public Vector3 startHitPos;

	public Vector3 endHitPos;

	public bool recordEndHitPos;

	private float rotSpeed = 360f;

	[Header("===Terrain Effects===")]
	public GameObject[] fairwayHitPFX;

	public GameObject[] roughHitPFX;

	public GameObject[] sandHitPFX;

	public GameObject[] waterLandingPFX;

	public float ballVisualVerticalOffset = 0.1f;

	private Vector3 ballPosTmp;

	[Header("===SFX===")]
	public AudioClip sfxGolfBallBounce;

	public AudioClip ballLandGreenSFX;

	public AudioClip ballLandRoughSFX;

	public AudioClip ballLandFairwaySFX;

	public AudioClip ballLandBunkerSFX;

	public AudioClip ballLandWaterSFX;

	public AudioClip sfxHitBunker;

	public AudioClip sfxHitFairway;

	public AudioClip sfxHitRough;

	public AudioClip sfxHitGreen;

	private float playSFXTimer = 0.15f;

	private float currentPlaySFXTimer;

	[Header("===Physics Material===")]
	public PhysicMaterial CL1greenFloorPhysics;

	public PhysicMaterial CL2greenFloorPhysics;

	public PhysicMaterial fairwayFloorPhysics;

	public PhysicMaterial roughFloorPhysics;

	public PhysicMaterial bunkerFloorPhysics;

	public PhysicMaterial teeFloorPhysics;

	public PhysicMaterial apronFloorPhysics;

	public PhysicMaterial quicksandFloorPhysics;

	private RaycastHit hit;

	private LayerMask groundLayer;

	private float negativeBounceForce = 10f;

	public SphereCollider hiPolyCollider;

	[Header("===New Info Cluster===")]
	public GameObject infoParent;

	public Image holeDirectionImage;

	public Image windDirectionImage;

	public TextMeshPro holeDistanceText;

	public TextMeshPro windDirectionText;

	public TextMeshPro terrainText;

	public Transform rightHandedRaycast;

	public Transform leftHandedRaycast;

	public Image terrainPowerImage;

	public float maxClusterHeightOffset = 3f;

	[Header("===Terrain PFX Adjustments===")]
	public float PFXEmissionRateOverTime = 1000f;

	public float PFXStartSpeedMin = 2f;

	public float PFXStartSpeedMax = 5f;

	public float PFXStartSpeedClubPower = 30f;

	[Header("===Surface Bounce Dampening===")]
	public float greenForceMultiplier = 0.15f;

	public float greenGravityMultiplier = 0.01f;

	public float fairwayForceMultiplier = 0.2f;

	public float fairwayGravityMultiplier = 0.01f;

	public float roughForceMultiplier = 0.3f;

	public float roughGravityMultiplier = 0.02f;

	public SurfaceType currentSurface = SurfaceType.Null;

	public Image minimapIcon;

	private float timeSinceLastCollision;

	private const float MIN_TIME_BETWEEN_PHYSICS_DAMPENING = 0.25f;

	private const float MIN_VERTICAL_VELOCITY_TO_PHYSICS_DAMPENING = 0.1f;

	private Vector3 pausedVelocity;

	private bool wasHit;

	public static event Action onHit;

	private void Start()
	{
		groundLayer = 1 << LayerMask.NameToLayer("GolfingSurface");
		if ((bool)golfballVisualPrefab)
		{
			golfballVisualTransform = UnityEngine.Object.Instantiate(golfballVisualPrefab, base.transform.position, base.transform.rotation).transform;
			ballRenderer = golfballVisualTransform.GetComponent<MeshRenderer>();
		}
		else
		{
			ballRenderer.enabled = true;
		}
		audioSource = GetComponent<AudioSource>();
		rb = GetComponent<Rigidbody>();
		ballLayer = 1 << LayerMask.NameToLayer("Golfball");
		Color ballColor = GameManager.instance.GetBallColor();
		ballRenderer.material.color = ballColor;
		ChangeTrailColour(trail);
		aimAdjustArrowParent.gameObject.SetActive(value: false);
		aimForce = baseAimForce;
		aimTimer = baseAimTimer;
		minimapIcon.color = GameManager.instance.GetBallColor();
	}

	private void Update()
	{
		if (GameManager.instance.currentSceneName.Contains("Boss") && GameManager.instance.pauseMenu.paused)
		{
			return;
		}
		CurrentSurface();
		timeSinceLastCollision += Time.deltaTime;
		Vector3 direction = base.transform.position - previousPosition;
		if (Physics.Raycast(previousPosition, direction, out var hitInfo, direction.magnitude, warpNodeLayer, QueryTriggerInteraction.Collide))
		{
			base.transform.position = hitInfo.point;
			if (hitInfo.transform.GetComponent<WarpNode>() != null)
			{
				hitInfo.transform.GetComponent<WarpNode>().WarpBall(base.gameObject);
			}
			if (hitInfo.transform.GetComponent<Golfhole>() != null)
			{
				hitInfo.transform.GetComponent<Golfhole>().BallScored();
			}
		}
		lastDeltaPosition = direction;
		previousPosition = base.transform.position;
		SinkBallVisualIntoGround();
		ShowArrow();
		BallAimDirection();
		if (IsGrounded())
		{
			base.transform.Rotate(rb.velocity, rb.velocity.magnitude * Time.deltaTime * rotSpeed * 0.5f);
		}
		if (recordEndHitPos)
		{
			endHitPos = base.transform.position;
		}
		if (currentPlaySFXTimer < playSFXTimer)
		{
			currentPlaySFXTimer += Time.deltaTime;
		}
		InfoCluster();
		if (GameManager.instance.quickMenu.menu.activeSelf)
		{
			minimapIcon.transform.position = new Vector3(base.transform.position.x, base.transform.position.y + 300f, base.transform.position.z);
			minimapIcon.transform.eulerAngles = new Vector3(90f, 0f, 0f);
		}
	}

	private void SinkBallVisualIntoGround()
	{
		if (currentSurface == SurfaceType.Fairway)
		{
			ballVisualVerticalOffset = 0.01f;
		}
		else if (currentSurface == SurfaceType.Rough)
		{
			ballVisualVerticalOffset = 0.02f;
		}
		else if (currentSurface == SurfaceType.Bunker)
		{
			ballVisualVerticalOffset = 0.03f;
		}
		else
		{
			ballVisualVerticalOffset = 0.002f;
		}
		ballPosTmp = base.transform.position;
		ballPosTmp.y -= ballVisualVerticalOffset;
		golfballVisualTransform.position = ballPosTmp;
		golfballVisualTransform.rotation = base.transform.rotation;
	}

	private void FixedUpdate()
	{
		calculatedGrounded = false;
		if (GameManager.instance.currentSceneName.Contains("Boss"))
		{
			if (GameManager.instance.pauseMenu.paused)
			{
				if (rb.velocity != Vector3.zero)
				{
					pausedVelocity = rb.velocity;
				}
				rb.isKinematic = true;
				return;
			}
			rb.isKinematic = false;
			if (pausedVelocity != Vector3.zero)
			{
				rb.velocity = pausedVelocity;
				pausedVelocity = Vector3.zero;
			}
		}
		previousVelocity = rb.velocity;
		if (!IsGrounded())
		{
			ResetDrag();
			return;
		}
		OBManager.instance.respawnTimer = 0f;
		if (!wasHit)
		{
			if (!Slope(slowDrag: true))
			{
				if (rb.velocity.magnitude > 1f)
				{
					rb.AddForce(-rb.velocity * 0.1f);
				}
				else if (rb.velocity.magnitude > 0.5f)
				{
					rb.AddForce(-rb.velocity * 0.05f);
				}
				else if (rb.velocity.magnitude > 0.25f)
				{
					rb.AddForce(-rb.velocity * 0.15f);
				}
				else if (rb.velocity.magnitude > 0f)
				{
					rb.angularDrag = Mathf.Lerp(rb.angularDrag, angularDragStop, Time.fixedDeltaTime * angularDragStopSpeed);
					rb.drag = Mathf.Lerp(rb.drag, dragStop, Time.fixedDeltaTime * dragStopSpeed);
				}
				else
				{
					ResetDrag();
				}
			}
		}
		else
		{
			wasHit = false;
		}
		if (ballType == BallType.Airball && !IsGrounded())
		{
			rb.AddForce(-Physics.gravity * 0.1f);
		}
	}

	public void ResetDrag()
	{
		rb.angularDrag = angularDragNormal;
		rb.drag = dragNormal;
	}

	public void MaxDrag()
	{
		rb.angularDrag = dragAngularSlopeStop;
		rb.drag = dragSlopeStop;
	}

	private void OnCollisionEnter(Collision collision)
	{
		currentSurface = CurrentSurface();
		calculatedGrounded = false;
		IsGrounded();
		if (audioSource.enabled && currentPlaySFXTimer > playSFXTimer && previousVelocity.magnitude > 0f)
		{
			float num = Mathf.Clamp(previousVelocity.magnitude / 18f, 0.05f, 1f);
			currentPlaySFXTimer = 0f;
			AudioClip audioClip = null;
			if (collision.gameObject.layer != LayerMask.NameToLayer("Water"))
			{
				if (rb.velocity.y > 0.1f && timeSinceLastCollision > 0.25f && !GameManager.instance.IsCloudlands1Hole())
				{
					Vector3 velocity = rb.velocity;
					Vector3 vector = Vector3.zero;
					velocity.y = 0f;
					if (currentSurface == SurfaceType.Green)
					{
						vector = -velocity * greenForceMultiplier + Physics.gravity * greenGravityMultiplier;
					}
					else if (currentSurface == SurfaceType.Fairway)
					{
						vector = -velocity * fairwayForceMultiplier + Physics.gravity * fairwayGravityMultiplier;
					}
					else if (currentSurface == SurfaceType.Rough)
					{
						vector = -velocity * roughForceMultiplier + Physics.gravity * roughGravityMultiplier;
					}
					if (vector != Vector3.zero)
					{
						rb.AddForce(vector, ForceMode.Impulse);
					}
				}
				if (currentSurface == SurfaceType.Green || currentSurface == SurfaceType.Apron || currentSurface == SurfaceType.Tee)
				{
					audioClip = ballLandGreenSFX;
				}
				else if (currentSurface == SurfaceType.Fairway)
				{
					audioClip = ballLandFairwaySFX;
				}
				else if (currentSurface == SurfaceType.Rough)
				{
					audioClip = ballLandRoughSFX;
				}
				else if (currentSurface == SurfaceType.Bunker || currentSurface == SurfaceType.Quicksand)
				{
					SandPFX();
					rb.velocity = Vector3.zero;
					audioClip = ballLandBunkerSFX;
				}
				else if (collision.gameObject.layer != LayerMask.NameToLayer("Water") && collision.collider.gameObject.layer != 9)
				{
					audioClip = sfxGolfBallBounce;
				}
				if (audioClip != null)
				{
					audioSource.PlayOneShot(audioClip, num);
					RoomRPC.PlayOnlineSound(base.transform.position, audioClip.name, num);
				}
			}
		}
		timeSinceLastCollision = 0f;
	}

	public void PlayWaterSplashPFX(int waterType)
	{
		float num = Mathf.Clamp(previousVelocity.magnitude / 10f, 0.15f, 1f);
		audioSource.PlayOneShot(ballLandWaterSFX, num);
		RoomRPC.PlayOnlineSound(base.transform.position, ballLandWaterSFX.name, num);
		GameObject obj = UnityEngine.Object.Instantiate(waterLandingPFX[waterType], base.transform.position, Quaternion.identity);
		obj.GetComponentInChildren<ParticleSystem>().Play();
		UnityEngine.Object.Destroy(obj, 5f);
		FreezeVelocity();
		ballRenderer.enabled = false;
	}

	public bool IsGrounded()
	{
		if (!calculatedGrounded)
		{
			calculatedGrounded = true;
			if (Physics.Raycast(base.transform.position, Vector3.down, out var hitInfo, groundDistanceCheck, ~(int)ballLayer))
			{
				if (GameManager.instance.IsCloudlands1Hole())
				{
					if (hitInfo.collider.transform.CompareTag("Rock"))
					{
						currentGrounded = false;
					}
					else
					{
						currentGrounded = true;
					}
				}
				else
				{
					currentGrounded = true;
				}
			}
			else
			{
				currentGrounded = false;
			}
		}
		return currentGrounded;
	}

	public SurfaceType CurrentSurface()
	{
		SurfaceType surfaceType = SurfaceType.None;
		if (Physics.Raycast(base.transform.position, Vector3.down, out hit, groundDistanceCheck, groundLayer))
		{
			if (hit.collider != null)
			{
				PhysicMaterial sharedMaterial = hit.collider.sharedMaterial;
				if (sharedMaterial == CL2greenFloorPhysics)
				{
					surfaceType = SurfaceType.Green;
					if (hit.transform.GetComponent<EditorPiece>() != null && hit.transform.GetComponent<EditorPiece>().snapPoints.Length != 0)
					{
						terrainText.text = LocalizationManager.GetTranslation("Minigolf");
					}
					else
					{
						terrainText.text = LocalizationManager.GetTranslation("Green");
					}
				}
				else if (sharedMaterial == CL1greenFloorPhysics)
				{
					surfaceType = SurfaceType.Cloudlands1;
					terrainText.text = LocalizationManager.GetTranslation("Minigolf");
				}
				else if (sharedMaterial == fairwayFloorPhysics)
				{
					surfaceType = SurfaceType.Fairway;
					terrainText.text = LocalizationManager.GetTranslation("Fairway");
				}
				else if (sharedMaterial == roughFloorPhysics)
				{
					surfaceType = SurfaceType.Rough;
					terrainText.text = LocalizationManager.GetTranslation("Rough");
				}
				else if (sharedMaterial == bunkerFloorPhysics)
				{
					surfaceType = SurfaceType.Bunker;
					terrainText.text = LocalizationManager.GetTranslation("Bunker");
				}
				else if (sharedMaterial == teeFloorPhysics)
				{
					surfaceType = SurfaceType.Tee;
					terrainText.text = LocalizationManager.GetTranslation("Tee");
				}
				else if (sharedMaterial == apronFloorPhysics)
				{
					surfaceType = SurfaceType.Apron;
					terrainText.text = LocalizationManager.GetTranslation("Apron");
				}
				else if (sharedMaterial == quicksandFloorPhysics)
				{
					surfaceType = SurfaceType.Quicksand;
					terrainText.text = LocalizationManager.GetTranslation("Quicksand");
				}
				else
				{
					surfaceType = SurfaceType.None;
					terrainText.text = "";
				}
			}
			else
			{
				surfaceType = SurfaceType.None;
			}
		}
		currentSurface = surfaceType;
		return currentSurface;
	}

	public Difficulty SurfaceDifficulty()
	{
		if (Physics.Raycast(base.transform.position, Vector3.down, out hit, groundDistanceCheck, groundLayer) && hit.collider != null)
		{
			if (hit.collider.transform.parent.name.Contains("Hard"))
			{
				return Difficulty.Hard;
			}
			if (hit.collider.transform.parent.name.Contains("Medium"))
			{
				return Difficulty.Medium;
			}
			return Difficulty.Easy;
		}
		return Difficulty.Easy;
	}

	public void Hit()
	{
		if (Slope(slowDrag: false))
		{
			if (!GameManager.instance.IsCloudlands1Hole())
			{
				if (IsGrounded())
				{
					OBManager.instance.hitOnslope = true;
				}
				else
				{
					OBManager.instance.hitOnslope = false;
				}
			}
		}
		else
		{
			OBManager.instance.hitOnslope = false;
		}
		ResetDrag();
		if (Golfball.onHit != null)
		{
			Golfball.onHit();
		}
		DestroyTrailRenderer();
		AddTrailRenderer();
		ScoreManager.instance.AddStroke();
		startHitPos = base.transform.position;
		recordEndHitPos = true;
		if (GameManager.instance.currentSceneName != "ScoreScene")
		{
			GameManager.instance.SetCanMulligan();
		}
		float volumeScale = Mathf.Clamp(previousVelocity.magnitude / 10f, 0.15f, 1f);
		AudioClip audioClip = null;
		if (currentSurface == SurfaceType.Fairway)
		{
			audioClip = sfxHitFairway;
		}
		else if (currentSurface == SurfaceType.Rough)
		{
			audioClip = sfxHitRough;
		}
		else if (currentSurface == SurfaceType.Bunker)
		{
			rb.velocity = Vector3.zero;
			audioClip = sfxHitBunker;
		}
		else
		{
			audioClip = sfxHitGreen;
		}
		if (currentSurface != SurfaceType.Quicksand && Physics.Raycast(base.transform.position, -Vector3.up, out hit, groundDistanceCheck, groundLayer) && hit.collider.transform.tag != "DontSaveLastPosition")
		{
			OBManager.instance.StoreLastPosition(base.transform.position);
		}
		audioSource.PlayOneShot(audioClip, volumeScale);
		if (Player.instance.clubSwitcher.currentType != ClubType.Putter)
		{
			TerrainPFX();
		}
		Player.instance.autoWarp.SetWarpOffset(base.transform.position - Player.instance.transform.position);
		if (aimAdjustArrowParent.gameObject.activeSelf)
		{
			if (Player.instance.clubSwitcher.currentType != ClubType.Putter || (Player.instance.clubSwitcher.currentType != 0 && Player.instance.clubSwitcher.driverType != DriverType.PowerDriver))
			{
				aimForce = baseAimForce;
				aimTimer = baseAimTimer;
				startAimTimer = true;
			}
		}
		else
		{
			startAimTimer = false;
		}
		aimAdjustArrowParent.gameObject.SetActive(value: false);
		startingControllerRot = 0f;
		endingControllerRot = 0f;
		wasHit = true;
	}

	private bool Slope(bool slowDrag)
	{
		if (GameManager.instance.IsCloudlands1Hole() || currentSurface == SurfaceType.Cloudlands1 || currentSurface == SurfaceType.None || currentSurface == SurfaceType.Quicksand)
		{
			return false;
		}
		if (Physics.Raycast(base.transform.position, Vector3.down, out hit, groundDistanceCheck))
		{
			angle = Vector3.Angle(Vector3.up, hit.normal);
			if (angle > 0f)
			{
				if (slowDrag && hit.transform.gameObject.layer == LayerMask.NameToLayer("GolfingSurface") && rb.velocity.magnitude != 0f && rb.velocity.magnitude < 5f)
				{
					float num = 0f;
					if (angle < 0.5f)
					{
						num = 0.1f;
					}
					else if (angle < 2f)
					{
						num = 0.5f;
					}
					else if (currentSurface != SurfaceType.Green)
					{
						num = 1f;
					}
					rb.angularDrag = Mathf.Lerp(rb.angularDrag, dragAngularSlopeStop, Time.fixedDeltaTime * dragSlopeStopSpeed / rb.angularVelocity.magnitude * num);
					rb.drag = Mathf.Lerp(rb.drag, dragSlopeStop, Time.fixedDeltaTime * dragSlopeStopSpeed / rb.velocity.magnitude * num);
				}
				return true;
			}
		}
		return false;
	}

	private void ShowArrow()
	{
		if (Player.instance.clubSwitcher.currentType == ClubType.Putter || (Player.instance.clubSwitcher.currentType == ClubType.Driver && Player.instance.clubSwitcher.driverType == DriverType.PowerDriver))
		{
			aimAdjustArrowParent.gameObject.SetActive(value: false);
			controllerRotationPower = 0f;
			return;
		}
		SpinArrow();
		Vector3 position = Player.instance.head.position;
		position.y = base.transform.position.y;
		if (Vector3.Distance(base.transform.position, position) < distanceToShowArrow)
		{
			AdjustAim();
		}
	}

	private void SpinArrow()
	{
		if (controllerRotationPower != 0f)
		{
			aimAdjustArrowParent.transform.parent.rotation = Quaternion.identity;
			Image image = null;
			if (controllerRotationPower > 0f)
			{
				image = aimAdjustArrowRight;
				aimAdjustArrowLeft.enabled = false;
				aimAdjustArrowRight.enabled = true;
			}
			else if (controllerRotationPower < 0f)
			{
				image = aimAdjustArrowLeft;
				aimAdjustArrowLeft.enabled = true;
				aimAdjustArrowRight.enabled = false;
			}
			image.transform.RotateAround(base.transform.position, Vector3.up, controllerRotationPower * Time.deltaTime * 5f);
		}
	}

	private void AdjustAim()
	{
		if (Player.instance.currentControllerInput.bButton.down)
		{
			if (Player.instance.currentControllerInput.touchpadStatus.downTouchpadButtonStatus.wasPressed)
			{
				startingControllerRot = Player.instance.currentController.transform.eulerAngles.y;
				endingControllerRot = 0f;
			}
			if (Player.instance.currentControllerInput.touchpadStatus.downTouchpadButtonStatus.down)
			{
				if (Player.instance.InPuttRadius())
				{
					aimAdjustArrowParent.gameObject.SetActive(value: true);
					endingControllerRot = Player.instance.currentController.transform.eulerAngles.y;
					endingControllerRot = ((endingControllerRot > 180f) ? (endingControllerRot - 360f) : endingControllerRot);
					controllerRotationPower = Mathf.DeltaAngle(startingControllerRot, endingControllerRot);
					if (controllerRotationPower < -90f)
					{
						controllerRotationPower = -90f;
					}
					else if (controllerRotationPower > 90f)
					{
						controllerRotationPower = 90f;
					}
				}
			}
			else if (Player.instance.currentControllerInput.touchpadStatus.downTouchpadButtonStatus.wasReleased && TutorialManager.instance != null)
			{
				TutorialManager.instance.AdjustAim();
			}
		}
		else if (Player.instance.currentControllerInput.bButton.wasReleased && Player.instance.currentControllerInput.touchpadStatus.downTouchpadButtonStatus.down && TutorialManager.instance != null)
		{
			TutorialManager.instance.AdjustAim();
		}
	}

	private void BallAimDirection()
	{
		if (IsGrounded() || !startAimTimer || !(aimTimer > 0f))
		{
			return;
		}
		aimTimer -= Time.deltaTime;
		Vector3 vector = Vector3.zero;
		if (Mathf.Abs(rb.velocity.normalized.x) > Mathf.Abs(rb.velocity.normalized.z))
		{
			if (rb.velocity.normalized.x > 0f)
			{
				vector = new Vector3(0f, 0f, controllerRotationPower / -45f - rb.velocity.normalized.z);
			}
			else if (rb.velocity.normalized.x < 0f)
			{
				vector = new Vector3(0f, 0f, controllerRotationPower / 45f - rb.velocity.normalized.z);
			}
		}
		else if (Mathf.Abs(rb.velocity.normalized.x) < Mathf.Abs(rb.velocity.normalized.z))
		{
			if (rb.velocity.normalized.z > 0f)
			{
				vector = new Vector3(controllerRotationPower / 45f - rb.velocity.normalized.x, 0f, 0f);
			}
			else if (rb.velocity.normalized.z < 0f)
			{
				vector = new Vector3(controllerRotationPower / -45f - rb.velocity.normalized.x, 0f, 0f);
			}
		}
		vector *= aimForce;
		rb.AddForce(vector * Time.deltaTime);
		Vector3 velocity = rb.velocity;
		velocity.y = 0f;
		velocity = Quaternion.Euler(0f, 90f, 0f) * velocity;
		rb.AddTorque(velocity * Time.deltaTime);
	}

	public void AddTrailRenderer()
	{
		if (GameManager.instance.GetBallTrail())
		{
			trail = UnityEngine.Object.Instantiate(trailRenderer, base.gameObject.transform);
			trail.transform.localPosition = Vector3.zero;
			ChangeTrailColour(trail);
		}
	}

	public void DestroyTrailRenderer()
	{
		UnityEngine.Object.Destroy(trail);
		UnityEngine.Object.Destroy(GameManager.instance.unparentedTrails);
	}

	public void OnDestroy()
	{
		if (golfballVisualTransform != null)
		{
			UnityEngine.Object.Destroy(golfballVisualTransform.gameObject);
		}
	}

	public void ChangeTrailColour(GameObject trail)
	{
		if (trail != null)
		{
			Color ballColor = GameManager.instance.GetBallColor();
			trail.GetComponent<Renderer>().material.SetColor("_EmissionColor", ballColor);
			trail.GetComponent<Renderer>().material.color = ballColor;
		}
	}

	private void TerrainPFX()
	{
		ParticleSystem particleSystem = null;
		if (currentSurface == SurfaceType.Fairway || currentSurface == SurfaceType.Tee)
		{
			particleSystem = ((SurfaceDifficulty() == Difficulty.Medium) ? UnityEngine.Object.Instantiate(fairwayHitPFX[1], base.transform.position, Quaternion.identity).GetComponentInChildren<ParticleSystem>() : ((SurfaceDifficulty() != Difficulty.Hard) ? UnityEngine.Object.Instantiate(fairwayHitPFX[0], base.transform.position, Quaternion.identity).GetComponentInChildren<ParticleSystem>() : UnityEngine.Object.Instantiate(fairwayHitPFX[2], base.transform.position, Quaternion.identity).GetComponentInChildren<ParticleSystem>()));
		}
		else if (currentSurface == SurfaceType.Rough)
		{
			particleSystem = ((SurfaceDifficulty() == Difficulty.Medium) ? UnityEngine.Object.Instantiate(roughHitPFX[1], base.transform.position, Quaternion.identity).GetComponentInChildren<ParticleSystem>() : ((SurfaceDifficulty() != Difficulty.Hard) ? UnityEngine.Object.Instantiate(roughHitPFX[0], base.transform.position, Quaternion.identity).GetComponentInChildren<ParticleSystem>() : UnityEngine.Object.Instantiate(roughHitPFX[2], base.transform.position, Quaternion.identity).GetComponentInChildren<ParticleSystem>()));
		}
		else if (currentSurface == SurfaceType.Bunker)
		{
			particleSystem = ((SurfaceDifficulty() == Difficulty.Medium) ? UnityEngine.Object.Instantiate(sandHitPFX[1], base.transform.position, Quaternion.identity).GetComponentInChildren<ParticleSystem>() : ((SurfaceDifficulty() != Difficulty.Hard) ? UnityEngine.Object.Instantiate(sandHitPFX[0], base.transform.position, Quaternion.identity).GetComponentInChildren<ParticleSystem>() : UnityEngine.Object.Instantiate(sandHitPFX[2], base.transform.position, Quaternion.identity).GetComponentInChildren<ParticleSystem>()));
		}
		if (particleSystem != null)
		{
			particleSystem.transform.position = base.transform.position;
			UnityEngine.Object.Destroy(particleSystem.transform.parent.gameObject, 3f);
			ParticleSystem.MinMaxCurve startSpeed = default(ParticleSystem.MinMaxCurve);
			startSpeed.mode = ParticleSystemCurveMode.TwoConstants;
			ParticleSystem.MainModule main = particleSystem.main;
			ParticleSystem.EmissionModule emission = particleSystem.emission;
			startSpeed.constantMin = PFXStartSpeedMin;
			startSpeed.constantMax = Mathf.Clamp(Player.instance.clubSwitcher.currentClub.GetAverageVelocity().magnitude * PFXStartSpeedClubPower, 3f, PFXStartSpeedMax);
			main.startSpeed = startSpeed;
			emission.rateOverTime = PFXEmissionRateOverTime * Player.instance.clubSwitcher.currentClub.GetAverageVelocity().magnitude;
			particleSystem.Play();
		}
	}

	public void SandPFX()
	{
		ParticleSystem particleSystem = null;
		if (Physics.Raycast(base.transform.position, -Vector3.up, out hit, groundDistanceCheck, groundLayer) && hit.collider != null)
		{
			if (SurfaceDifficulty() == Difficulty.Medium)
			{
				particleSystem = UnityEngine.Object.Instantiate(sandHitPFX[1], base.transform.position, Quaternion.identity).GetComponentInChildren<ParticleSystem>();
			}
			else if (SurfaceDifficulty() == Difficulty.Hard)
			{
				particleSystem = UnityEngine.Object.Instantiate(sandHitPFX[2], base.transform.position, Quaternion.identity).GetComponentInChildren<ParticleSystem>();
			}
			else if (SurfaceDifficulty() == Difficulty.Easy)
			{
				particleSystem = UnityEngine.Object.Instantiate(sandHitPFX[0], base.transform.position, Quaternion.identity).GetComponentInChildren<ParticleSystem>();
			}
			if (particleSystem != null)
			{
				ParticleSystem.EmissionModule emission = particleSystem.emission;
				emission.rateOverTime = 10f + 1000f * Player.instance.clubSwitcher.currentClub.GetAverageVelocity().magnitude;
				particleSystem.Play();
				UnityEngine.Object.Destroy(particleSystem.transform.parent.gameObject, 3f);
			}
		}
	}

	public void FreezeVelocity()
	{
		rb.velocity = Vector3.zero;
		rb.angularVelocity = Vector3.zero;
		ResetDrag();
	}

	public Vector3 GetFloorNormal()
	{
		Vector3 result = Vector3.zero;
		if (Physics.Raycast(base.transform.position, -Vector3.up, out hit, groundDistanceCheck, ~(int)ballLayer))
		{
			result = hit.normal;
		}
		return result;
	}

	public float BallDistance()
	{
		if (GameManager.instance.golfball != null)
		{
			if (startHitPos == Vector3.zero || Vector3.Distance(endHitPos, startHitPos) < 0.01f)
			{
				return 0f;
			}
			Vector3 a = startHitPos;
			Vector3 b = endHitPos;
			a.y = 0f;
			b.y = 0f;
			return Vector3.Distance(a, b) / 1.09361f;
		}
		return 0f;
	}

	private void InfoCluster()
	{
		if (!ScoreManager.instance.ballScored && !GameManager.instance.IsCloudlands1Hole() && (GameManager.instance.currentSceneName == "CustomHoleScene" || GameManager.instance.currentSceneName == "LevelEditor" || GameManager.instance.currentSceneName == "Tutorial") && Vector3.Distance(new Vector3(Player.instance.head.position.x, base.transform.position.y, Player.instance.head.position.z), base.transform.position) < 3f && rb.velocity.magnitude < 1f)
		{
			Vector3 position = Player.instance.head.position;
			position.y = infoParent.transform.position.y;
			infoParent.transform.LookAt(position);
			infoParent.transform.eulerAngles = new Vector3(90f, infoParent.transform.eulerAngles.y + 180f, 0f);
			GameObject nearestHoleFromPos = GameManager.instance.GetNearestHoleFromPos(Player.instance.transform.position);
			if (nearestHoleFromPos != null)
			{
				Vector3 position2 = nearestHoleFromPos.transform.position;
				float num = Vector3.Distance(base.transform.position, position2);
				if (num < 0.1f)
				{
					holeDistanceText.text = "0 " + LocalizationManager.GetTranslation("Yards");
				}
				else
				{
					holeDistanceText.text = (num / 1.09361f).ToString("F2") + " " + LocalizationManager.GetTranslation("Yards");
				}
				Plane plane = new Plane(holeDistanceText.transform.forward, holeDirectionImage.transform.position);
				Ray ray = new Ray(position2, Vector3.up);
				Ray ray2 = new Ray(position2, Vector3.down);
				if (plane.Raycast(ray, out var enter))
				{
					Vector3 point = ray.GetPoint(enter);
					holeDirectionImage.transform.rotation = Quaternion.LookRotation(point - holeDirectionImage.transform.position, holeDistanceText.transform.forward) * Quaternion.Euler(90f, 0f, 0f);
				}
				else if (plane.Raycast(ray2, out enter))
				{
					Vector3 point2 = ray2.GetPoint(enter);
					holeDirectionImage.transform.rotation = Quaternion.LookRotation(point2 - holeDirectionImage.transform.position, holeDistanceText.transform.forward) * Quaternion.Euler(90f, 0f, 0f);
				}
				else
				{
					holeDirectionImage.transform.rotation = Quaternion.LookRotation(position2 - holeDirectionImage.transform.position, holeDistanceText.transform.forward) * Quaternion.Euler(90f, 0f, 0f);
				}
			}
			else
			{
				holeDistanceText.text = "0 Yards";
				holeDirectionImage.enabled = false;
			}
			Wind wind = null;
			if (GameManager.instance.currentSceneName == "LevelEditor")
			{
				wind = LevelEditor.instance.editorWind.wind;
			}
			else if (CustomHoleScene.instance != null)
			{
				wind = CustomHoleScene.instance.wind;
			}
			if (wind != null)
			{
				if (wind.windSpeed != 0f)
				{
					windDirectionText.text = wind.GetWindSpeedText();
					windDirectionImage.enabled = true;
					Vector3 direction = wind.direction;
					Plane plane2 = new Plane(windDirectionText.transform.forward, windDirectionImage.transform.position);
					Vector3 vector = windDirectionImage.transform.position + direction;
					Ray ray3 = new Ray(vector, Vector3.up);
					Ray ray4 = new Ray(vector, Vector3.down);
					if (plane2.Raycast(ray3, out var enter2))
					{
						Vector3 point3 = ray3.GetPoint(enter2);
						windDirectionImage.transform.rotation = Quaternion.LookRotation(point3 - windDirectionImage.transform.position, windDirectionText.transform.forward) * Quaternion.Euler(90f, 0f, 0f);
					}
					else if (plane2.Raycast(ray4, out enter2))
					{
						Vector3 point4 = ray4.GetPoint(enter2);
						windDirectionImage.transform.rotation = Quaternion.LookRotation(point4 - windDirectionImage.transform.position, windDirectionText.transform.forward) * Quaternion.Euler(90f, 0f, 0f);
					}
					else
					{
						windDirectionImage.transform.rotation = Quaternion.LookRotation(vector - windDirectionImage.transform.position, windDirectionText.transform.forward) * Quaternion.Euler(90f, 0f, 0f);
					}
				}
				else
				{
					windDirectionImage.enabled = false;
					windDirectionText.text = LocalizationManager.GetTranslation("Wind") + ": N/A";
				}
			}
			else
			{
				windDirectionImage.enabled = false;
				windDirectionText.text = LocalizationManager.GetTranslation("Wind") + ": N/A";
			}
			if (currentSurface == SurfaceType.Rough || currentSurface == SurfaceType.Bunker)
			{
				terrainPowerImage.gameObject.SetActive(value: true);
			}
			else
			{
				terrainPowerImage.gameObject.SetActive(value: false);
			}
			infoParent.SetActive(value: true);
		}
		else
		{
			infoParent.SetActive(value: false);
		}
	}

	public IEnumerator DisableBall()
	{
		yield return new WaitForSeconds(0.5f);
		rb.isKinematic = true;
		GetComponent<SphereCollider>().enabled = false;
	}
}
public enum BallType
{
	Normal,
	Gumball,
	Iceball,
	Airball,
	Heavyball,
	Featherball
}
public enum SurfaceType
{
	None = 0,
	Tee = 1,
	Green = 2,
	Fairway = 3,
	Rough = 4,
	Apron = 5,
	Bunker = 6,
	Quicksand = 7,
	Cloudlands1 = 8,
	Null = -1
}
public class GolfballSpawner : MonoBehaviour
{
	public GameObject golfballPrefab;

	[HideInInspector]
	public Vector3 spawnPos;

	public bool spawnBallAtStart = true;

	private void Start()
	{
		ResetSpawnPos();
		if (spawnBallAtStart)
		{
			StartCoroutine(SpawnBall());
		}
	}

	private void Update()
	{
	}

	public IEnumerator SpawnBall()
	{
		yield return null;
		while (GameManager.instance.loadingLevel)
		{
			yield return null;
		}
		GameManager.instance.golfball = UnityEngine.Object.Instantiate(golfballPrefab, spawnPos, base.transform.rotation).GetComponent<Golfball>();
		GameManager.instance.golfball.previousPosition = spawnPos;
		OBManager.instance.StoreLastPosition(base.transform.position + Vector3.up * 0.05f);
	}

	public void ResetBall()
	{
		if (GameManager.instance.golfball != null)
		{
			GameObject obj = GameManager.instance.golfball.gameObject;
			obj.transform.position = spawnPos;
			obj.GetComponent<Golfball>().rb.velocity = Vector3.zero;
			obj.GetComponent<Golfball>().rb.angularVelocity = Vector3.zero;
			obj.GetComponent<Golfball>().ResetDrag();
			OBManager.instance.StoreLastPosition(base.transform.position);
		}
	}

	public void ResetSpawnPos()
	{
		spawnPos = base.transform.position;
		spawnPos.y += 0.05f;
	}
}
public class BallHitDetection : MonoBehaviour
{
	public Transform positionToFollow;

	private GolfClub club;

	public Queue<Vector3> collisionPositions = new Queue<Vector3>();

	public Queue<Quaternion> collisionRotations = new Queue<Quaternion>();

	public float sensitivity = 100f;

	private Rigidbody rb;

	private BoxCollider bc;

	private Vector3 triggerOrigScale;

	private Vector3 triggerTmpScale;

	private float triggerThreshold = 0.2f;

	private float maxTriggerXScale = 0.4f;

	private float maxTriggerZScale = 0.3f;

	private float distanceForTeleport = 1f;

	public bool canHitBall;

	private void Start()
	{
		rb = GetComponent<Rigidbody>();
		bc = GetComponent<BoxCollider>();
	}

	private void Update()
	{
		if (Player.instance.clubSwitcher.currentClub != null)
		{
			club = Player.instance.clubSwitcher.currentClub;
			positionToFollow = club.collisionBox;
		}
		if (positionToFollow != null)
		{
			TeleportCollider();
			if (collisionPositions.Count < 5)
			{
				collisionPositions.Enqueue(positionToFollow.position);
				collisionRotations.Enqueue(positionToFollow.rotation);
			}
		}
	}

	private void FixedUpdate()
	{
		if (Player.instance.currentController.pointerActive || !Player.instance.clubSwitcher.currentClub.detectCollisions)
		{
			collisionPositions.Clear();
			collisionRotations.Clear();
			if (positionToFollow != null)
			{
				base.transform.position = positionToFollow.position;
				base.transform.rotation = positionToFollow.rotation;
			}
			ScaleTrigger(reset: true);
			bc.enabled = false;
		}
		else if (collisionPositions.Count > 0)
		{
			base.transform.localScale = positionToFollow.GetComponent<BoxCollider>().size;
			triggerOrigScale = base.transform.localScale;
			rb.MovePosition(Vector3.Lerp(base.transform.position, collisionPositions.Dequeue(), sensitivity * Time.deltaTime));
			rb.MoveRotation(Quaternion.Lerp(base.transform.rotation, collisionRotations.Dequeue(), sensitivity * Time.deltaTime));
			ScaleTrigger(reset: false);
			bc.enabled = true;
		}
		else if (collisionPositions.Count == 0)
		{
			bc.enabled = true;
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.tag == "Golfball")
		{
			Player.instance.clubSwitcher.currentClub.HitBall(other.gameObject.GetComponent<Golfball>());
		}
	}

	private void ScaleTrigger(bool reset)
	{
		if (reset)
		{
			base.transform.localScale = triggerOrigScale;
			return;
		}
		float magnitude = club.GetAverageVelocity().magnitude;
		triggerTmpScale = triggerOrigScale;
		if (magnitude > triggerThreshold)
		{
			triggerTmpScale.x = maxTriggerXScale;
			triggerTmpScale.z = maxTriggerZScale;
		}
		base.transform.localScale = triggerTmpScale;
	}

	private void TeleportCollider()
	{
		if (Vector3.Distance(positionToFollow.position, base.transform.position) > distanceForTeleport)
		{
			base.transform.position = positionToFollow.position;
		}
	}
}
public class ClubScaler : MonoBehaviour
{
	public Transform scaleRayCastPoint;

	public Transform clubHead;

	public Transform clubShaft;

	public Transform clubGrip;

	public Transform startPointScaler;

	public Transform endPointScaler;

	private float offsetAmount;

	private float shaftOffsetAmount;

	private Vector3 clubHeadLocalPosition;

	private Vector3 clubShaftLocalPosition;

	private Vector3 clubShaftLocalScale;

	public float scaleDiff;

	public float CLUB_HEAD_CALC_LENGTH = 0.71f;

	public float CLUB_HEAD_MAX_TRANSLATE = 0.58f;

	public float CLUB_SCALE_RAYCAST_MAX_DIST = 2.5f;

	public Vector3 clubHeadDefaultLocalPosition;

	private float currentClubShaftScale = 0.76f;

	private float clubDefaultLength;

	public float currentLengthInMeters;

	public float defaultLengthInMeters;

	public LayerMask golfingSurfaceLayer;

	private void Start()
	{
		clubDefaultLength = currentClubShaftScale;
	}

	private void FixedUpdate()
	{
		currentLengthInMeters = Mathf.Abs((endPointScaler.localPosition - startPointScaler.localPosition).y / 0.0254f);
		if (!Player.instance.currentController.constrainedSwing)
		{
			AdjustClubHead();
		}
	}

	private void AdjustClubHead()
	{
		if (Physics.Raycast(scaleRayCastPoint.position, scaleRayCastPoint.forward, out var hitInfo, CLUB_SCALE_RAYCAST_MAX_DIST, golfingSurfaceLayer))
		{
			offsetAmount = CLUB_HEAD_CALC_LENGTH - Vector3.Distance(hitInfo.point, scaleRayCastPoint.position);
			if (offsetAmount >= 0f && offsetAmount <= CLUB_HEAD_MAX_TRANSLATE)
			{
				clubHeadLocalPosition.x = clubHeadDefaultLocalPosition.x;
				clubHeadLocalPosition.y = clubHeadDefaultLocalPosition.y + offsetAmount;
				clubHeadLocalPosition.z = clubHeadDefaultLocalPosition.z;
				clubHead.localPosition = clubHeadLocalPosition;
				clubShaftLocalScale.x = 1f;
				clubShaftLocalScale.y = clubDefaultLength - offsetAmount * scaleDiff;
				clubShaftLocalScale.z = 1f;
				clubShaft.localScale = clubShaftLocalScale;
			}
		}
		else
		{
			clubHead.localPosition = clubHeadDefaultLocalPosition;
			clubShaft.localScale = new Vector3(1f, clubDefaultLength, 1f);
			currentLengthInMeters = defaultLengthInMeters;
		}
	}

	public void SetClubLength(ClubType type, float length)
	{
		if (!Player.instance.currentController.constrainedSwing)
		{
			Vector3 vector = endPointScaler.localPosition - startPointScaler.localPosition;
			endPointScaler.position = startPointScaler.position;
			endPointScaler.Translate(vector.normalized * length * 0.0254f);
			defaultLengthInMeters = Mathf.Abs((vector.normalized * length).y);
			Vector3 vector2 = clubHeadDefaultLocalPosition;
			vector2.y = endPointScaler.localPosition.y;
			clubHeadDefaultLocalPosition = vector2;
			switch (type)
			{
			case ClubType.Driver:
				currentClubShaftScale = 0.9f + (length - 38f) * 0.045f;
				break;
			case ClubType.Iron:
				currentClubShaftScale = 0.69f + (length - 33.5f) * 0.045f;
				break;
			case ClubType.Putter:
				currentClubShaftScale = 0.42f + (length - 27.5f) * 0.045f;
				break;
			}
			CLUB_HEAD_CALC_LENGTH = 1f - vector2.y;
			CLUB_HEAD_MAX_TRANSLATE = 1f - vector2.y - 0.17f - 0.2f;
			clubDefaultLength = currentClubShaftScale;
		}
	}
}
public class Driver : GolfClub
{
	public DriverType type;

	private float loftLimit = 10f;

	public float constraintMultiplier = 2.4f;

	private float maxLoftAngle = 80f;

	private float minAngleToUp = 10f;

	public override void Start()
	{
		base.Start();
		if (Player.instance.currentController.constrainedSwing)
		{
			clubScaler.SetClubLength(ClubType.Driver, ScoreManager.instance.playerTurn[GameManager.instance.playerIndex].clubProfile.driverLength);
			if (aimLine != null)
			{
				aimLine.positionCount = 2;
			}
		}
	}

	public override void HitBall(Golfball gb)
	{
		if (!detectCollisions)
		{
			return;
		}
		base.HitBall(gb);
		float clubfaceLoft = GetClubfaceLoft();
		Vector3 vector = new Vector3(0f, loftValue * clubfaceLoft, 0f);
		Vector3 vector2 = Vector3.zero;
		Vector3 vector3 = GetAverageVelocity();
		if (Player.instance.currentController.constrainedSwing)
		{
			vector = Vector3.zero;
			Vector3 lockedPuttForward = Player.instance.currentController.lockedPuttForward;
			float magnitude = vector3.magnitude;
			vector3 = Vector3.Project(vector3, lockedPuttForward).normalized * magnitude;
			float num = neutralAngle;
			float num2 = Vector3.Angle(lockedPuttForward, Vector3.up);
			num2 -= num;
			if (num2 < minAngleToUp)
			{
				num -= minAngleToUp - num2;
				if (num < 0f)
				{
					num = 0f;
				}
			}
			if (Vector3.Dot(vector3, lockedPuttForward) < 0f)
			{
				num = 0f - num;
			}
			Vector3 axis = Vector3.Cross(Player.instance.currentController.lockedPuttForward, gb.GetFloorNormal());
			vector3 = Quaternion.AngleAxis(num, axis) * vector3;
		}
		else
		{
			vector2 = clubHead.forward * GetClubfacePunch(clubfaceLoft);
		}
		Vector3 vector4 = (vector3.normalized + vector2 + vector) * (vector3.magnitude * velocityValue);
		if (vector4.y > loftLimit)
		{
			vector4.y = loftLimit;
		}
		if (Player.instance.currentController.constrainedSwing)
		{
			vector4 *= constraintMultiplier;
		}
		vector4 *= GameManager.instance.GetClubPower(ClubType.Driver);
		vector4 = Vector3.ClampMagnitude(vector4, baseVelocityClamp);
		vector4 *= ClubLengthPowerCompensation();
		gb.rb.AddForce(vector4, ForceMode.Impulse);
		ResetVelocity();
		ResetPositions();
		detectCollisions = false;
		if (Player.instance.currentController.constrainedSwing)
		{
			Player.instance.currentController.SwitchControllerMode(ControllerMode.FollowMode);
		}
	}
}
public enum DriverType
{
	RegularDriver,
	AssistDriver,
	PowerDriver
}
public class GolfClub : MonoBehaviour
{
	public Transform swingPoint;

	public Transform clubHead;

	public Transform clubMesh;

	public Transform collisionBox;

	public AudioClip sfxHitBall;

	private AudioSource audioSource;

	protected LayerMask ballLayer;

	protected LayerMask groundLayer;

	public bool detectCollisions;

	private float detectCollisionInterval = 0.5f;

	private float detectCollisionTimer;

	protected float loftValue;

	public float minConstraintLoftValue = 2f;

	public float minConstraintPunchValue = 0.5f;

	public float velocityValue;

	[Header("Basic Multipliers")]
	public float loftMultiplier = 1f;

	public float velocityMultiplier = 1f;

	public float aimForceMultiplier = 1f;

	public float aimTimerMultiplier = 1f;

	public float baseVelocityClamp = 15f;

	[Header("Tee")]
	public float teeLoftMultiplier = 1.7f;

	public float teeVelocityMultiplier = 25f;

	[Header("Green")]
	public float greenLoftMultiplier = 1.7f;

	public float greenVelocityMultiplier = 25f;

	[Header("Apron")]
	public float apronLoftMultiplier = 0.7f;

	public float apronVelocityMultiplier = 7f;

	[Header("Fairway")]
	public float fairwayLoftMultiplier = 1.5f;

	public float fairwayVelocityMultiplier = 20f;

	[Header("Rough")]
	public float roughLoftMultiplier = 1f;

	public float roughVelocityMultiplier = 10f;

	[Header("Bunker")]
	public float bunkerLoftMultiplier = 0.7f;

	public float bunkerVelocityMultiplier = 7f;

	[Space(10f)]
	private float pitchShiftAmount = 0.025f;

	protected float torqueMultiplier = 5000f;

	protected Vector3 lastPos;

	[HideInInspector]
	public Vector3[] prevVelocities;

	protected Vector3 lastControllerBallDiff;

	protected Vector3 lastClubPos;

	protected Quaternion lastClubRot;

	protected int prevVelocityCount = 5;

	protected int curPrevVelIndex;

	protected PrevPutterTransform[] prevPutterTransform;

	[Header("Settings")]
	public int prevPutterTransformCount = 30;

	protected int curPutterTransformIndex;

	protected float groundCheckDistance = 1.1f;

	public float neutralAngle = 30f;

	protected float minLoftMultiplier = 0.3f;

	protected float maxLoftMultiplier = 1.3f;

	protected Color[] colors = new Color[10]
	{
		new Color(1f, 0f, 0f),
		new Color(1f, 0.5f, 0f),
		new Color(1f, 1f, 0f),
		new Color(0.5f, 1f, 0f),
		new Color(0f, 1f, 0f),
		new Color(0f, 1f, 1f),
		new Color(0f, 0.5f, 1f),
		new Color(0f, 0f, 1f),
		new Color(0.5f, 0f, 1f),
		new Color(1f, 0f, 1f)
	};

	protected int colorIndex;

	public bool showDebugInGame;

	private List<LineRenderer> lrs = new List<LineRenderer>();

	private int nextLineRenderer;

	public ClubScaler clubScaler;

	public MeshRenderer[] mesh;

	[Header("Aim Line")]
	public LineRenderer aimLine;

	public bool useAimLine;

	public float aimLineLength = 1.5f;

	[Header("For Iron And Driver")]
	public float aimLineHeight = 0.5f;

	public BoxCollider clubCollider;

	private Vector3 newForward;

	private Vector3 golfballPos;

	private Vector3 calculatedEndPosition;

	private float flip;

	private void Awake()
	{
		mesh = clubMesh.GetComponentsInChildren<MeshRenderer>();
	}

	public virtual void Start()
	{
		audioSource = GetComponent<AudioSource>();
		lastPos = collisionBox.position;
		prevVelocities = new Vector3[prevVelocityCount];
		prevPutterTransform = new PrevPutterTransform[prevPutterTransformCount];
		ResetPositions();
		ballLayer = 1 << LayerMask.NameToLayer("Golfball");
		groundLayer = 1 << LayerMask.NameToLayer("GolfingSurface");
		baseVelocityClamp *= velocityMultiplier;
	}

	public virtual void Update()
	{
		ClubLengthPowerCompensation();
		if (showDebugInGame)
		{
			for (int i = 0; i < lrs.Count; i++)
			{
				lrs[i].gameObject.SetActive(value: false);
			}
			nextLineRenderer = 0;
			colorIndex = 0;
		}
		ToggleCollision();
		ChangeHitPower();
		if (Player.instance.currentController.constrainedSwing)
		{
			clubScaler.enabled = false;
		}
		else
		{
			clubScaler.enabled = true;
		}
		DetectHit();
		ClubShadow();
		AimLine();
	}

	public virtual void HitBall(Golfball gb)
	{
		gb.Hit();
		gb.aimForce *= aimForceMultiplier;
		PlaySFX();
		if (TutorialManager.instance != null)
		{
			TutorialManager.instance.BallHit();
		}
		float magnitude = GetAverageVelocity().magnitude;
		magnitude = Mathf.Clamp(magnitude, 0.03f, 1f);
		Player.instance.currentControllerInput.Vibrate(0.04f, magnitude * 5f);
		if (OBManager.instance.revertLastClubOnOB && !Player.instance.clubSwitcher.preventClubSwitchOnWarp)
		{
			OBManager.instance.revertLastClubOnOB = false;
		}
		Player.instance.clubSwitcher.preventClubSwitchOnWarp = false;
	}

	protected virtual float GetClubfaceLoft()
	{
		Vector3 vector = clubHead.transform.position + clubHead.transform.forward * 10f;
		vector.y = clubHead.transform.position.y;
		float num = Vector3.Angle(clubHead.transform.forward, vector - clubHead.transform.position) / neutralAngle;
		if (Player.instance.currentController.constrainedSwing && num < minConstraintLoftValue)
		{
			num = minConstraintLoftValue;
		}
		if (num < minLoftMultiplier)
		{
			return minLoftMultiplier;
		}
		if (num > maxLoftMultiplier)
		{
			return maxLoftMultiplier;
		}
		return num;
	}

	protected virtual float GetClubfacePunch(float loft)
	{
		float num = maxLoftMultiplier - loft;
		if (num < 0f)
		{
			num = 0f;
		}
		if (Player.instance.currentController.constrainedSwing && num < minConstraintPunchValue)
		{
			num = minConstraintPunchValue;
		}
		return num;
	}

	private void FixedUpdate()
	{
		Input.GetKeyDown(KeyCode.U);
	}

	public void ScaleClub(float length)
	{
		Vector3 localScale = base.transform.localScale;
		localScale.z = length;
		base.transform.localScale = localScale;
	}

	private void PreventUnderground()
	{
		groundCheckDistance = Vector3.Distance(base.transform.position, clubHead.position) + Vector3.Distance(base.transform.position, clubHead.position) / 10f;
		UnityEngine.Debug.DrawRay(Player.instance.currentControllerInput.transform.position, base.transform.forward * groundCheckDistance, Color.red);
		if (Physics.Raycast(Player.instance.currentControllerInput.transform.position, base.transform.forward, out var hitInfo, groundCheckDistance, groundLayer))
		{
			if (clubHead.position.y < hitInfo.point.y + 0.1f)
			{
				float num = hitInfo.point.y - clubHead.position.y;
				Vector3 position = Player.instance.currentControllerInput.transform.position;
				position.y = base.transform.position.y + num;
				base.transform.position = position;
			}
			else
			{
				base.transform.localPosition = Vector3.zero;
			}
		}
		else
		{
			base.transform.localPosition = Vector3.zero;
		}
	}

	public void DebugDrawBox(Vector3 center, Vector3 extents, Quaternion orientation, int iter, float duration = 0f)
	{
		Color color = colors[colorIndex++];
		if (colorIndex >= colors.Length)
		{
			colorIndex = 0;
		}
		float num = extents.x / 2f;
		float y = extents.y;
		float z = extents.z;
		Vector3 vector = center + orientation * new Vector3(num, y, z);
		Vector3 vector2 = center + orientation * new Vector3(num, y, 0f - z);
		Vector3 vector3 = center + orientation * new Vector3(0f - num, y, z);
		Vector3 vector4 = center + orientation * new Vector3(0f - num, y, 0f - z);
		Vector3 vector5 = center + orientation * new Vector3(0f - num, 0f - y, z);
		Vector3 vector6 = center + orientation * new Vector3(0f - num, 0f - y, 0f - z);
		Vector3 vector7 = center + orientation * new Vector3(num, 0f - y, z);
		Vector3 vector8 = center + orientation * new Vector3(num, 0f - y, 0f - z);
		if (showDebugInGame)
		{
			if (lrs.Count < nextLineRenderer + 1)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(GameManager.instance.debugLineRendererPrefab, GameManager.instance.transform);
				lrs.Add(gameObject.GetComponent<LineRenderer>());
			}
			else
			{
				while (lrs[nextLineRenderer].gameObject.activeSelf)
				{
					nextLineRenderer++;
					if (lrs.Count < nextLineRenderer + 1)
					{
						GameObject gameObject2 = UnityEngine.Object.Instantiate(GameManager.instance.debugLineRendererPrefab, GameManager.instance.transform);
						lrs.Add(gameObject2.GetComponent<LineRenderer>());
						break;
					}
				}
			}
			LineRenderer lineRenderer = lrs[nextLineRenderer];
			lineRenderer.gameObject.name = "lr" + iter;
			lineRenderer.startColor = color;
			lineRenderer.endColor = color;
			lineRenderer.gameObject.SetActive(value: true);
			lineRenderer.positionCount = 12;
			lineRenderer.SetPositions(new Vector3[12]
			{
				vector, vector2, vector4, vector3, vector, vector7, vector8, vector6, vector5, vector7,
				vector6, vector4
			});
		}
		UnityEngine.Debug.DrawLine(vector, vector2, color, duration);
		UnityEngine.Debug.DrawLine(vector2, vector4, color, duration);
		UnityEngine.Debug.DrawLine(vector4, vector3, color, duration);
		UnityEngine.Debug.DrawLine(vector3, vector, color, duration);
		UnityEngine.Debug.DrawLine(vector7, vector8, color, duration);
		UnityEngine.Debug.DrawLine(vector8, vector6, color, duration);
		UnityEngine.Debug.DrawLine(vector6, vector5, color, duration);
		UnityEngine.Debug.DrawLine(vector5, vector7, color, duration);
		UnityEngine.Debug.DrawLine(vector, vector7, color, duration);
		UnityEngine.Debug.DrawLine(vector2, vector8, color, duration);
		UnityEngine.Debug.DrawLine(vector4, vector6, color, duration);
		UnityEngine.Debug.DrawLine(vector3, vector5, color, duration);
	}

	private void OnDisable()
	{
		if (!showDebugInGame)
		{
			return;
		}
		for (int i = 0; i < lrs.Count; i++)
		{
			if (lrs[i] != null)
			{
				lrs[i].gameObject.SetActive(value: false);
			}
		}
		nextLineRenderer = 0;
		colorIndex = 0;
		detectCollisions = false;
	}

	protected void PlaySFX()
	{
		audioSource.pitch += UnityEngine.Random.Range(0f - pitchShiftAmount, pitchShiftAmount);
		float num = Mathf.Clamp(GetAverageVelocity().magnitude * 2f, 0.2f, 1f);
		audioSource.PlayOneShot(sfxHitBall, num);
		RoomRPC.PlayOnlineSound(base.transform.position, sfxHitBall.name, num);
	}

	public Vector3 GetAverageVelocity()
	{
		Vector3 zero = Vector3.zero;
		for (int i = 0; i < prevVelocities.Length; i++)
		{
			zero += prevVelocities[i];
		}
		return zero / prevVelocityCount;
	}

	public void ResetVelocity()
	{
		for (int i = 0; i < prevVelocities.Length; i++)
		{
			prevVelocities[i] = Vector3.zero;
		}
		lastPos = collisionBox.position;
		lastClubPos = base.transform.position;
		lastClubRot = base.transform.rotation;
		lastControllerBallDiff = Vector3.zero;
	}

	public void ResetPositions()
	{
		for (int i = 0; i < prevPutterTransform.Length; i++)
		{
			prevPutterTransform[i].pos = collisionBox.position;
			prevPutterTransform[i].rot = collisionBox.rotation;
		}
	}

	private void ToggleCollision()
	{
		if (Player.instance.currentController.constrainedSwing && (!Player.instance.currentController.constrainedSwing || Player.instance.currentController.controllerMode != ControllerMode.PuttingMode))
		{
			return;
		}
		if (!detectCollisions)
		{
			if (detectCollisionTimer <= detectCollisionInterval)
			{
				detectCollisionTimer += Time.deltaTime;
				return;
			}
			ResetVelocity();
			detectCollisionTimer = 0f;
			detectCollisions = true;
		}
		else
		{
			detectCollisionTimer = 0f;
		}
	}

	private void ChangeHitPower()
	{
		if (GameManager.instance.golfball != null)
		{
			if (GameManager.instance.golfball.currentSurface == SurfaceType.Tee)
			{
				loftValue = teeLoftMultiplier;
				velocityValue = teeVelocityMultiplier;
			}
			else if (GameManager.instance.golfball.currentSurface == SurfaceType.Green)
			{
				loftValue = greenLoftMultiplier;
				velocityValue = greenVelocityMultiplier;
			}
			else if (GameManager.instance.golfball.currentSurface == SurfaceType.Fairway)
			{
				loftValue = fairwayLoftMultiplier;
				velocityValue = fairwayVelocityMultiplier;
			}
			else if (GameManager.instance.golfball.currentSurface == SurfaceType.Rough)
			{
				loftValue = roughLoftMultiplier;
				velocityValue = roughVelocityMultiplier;
			}
			else if (GameManager.instance.golfball.currentSurface == SurfaceType.Apron)
			{
				loftValue = apronLoftMultiplier;
				velocityValue = apronVelocityMultiplier;
			}
			else if (GameManager.instance.golfball.currentSurface == SurfaceType.Bunker || GameManager.instance.golfball.currentSurface == SurfaceType.Quicksand)
			{
				loftValue = bunkerLoftMultiplier;
				velocityValue = bunkerVelocityMultiplier;
			}
			else
			{
				loftValue = greenLoftMultiplier;
				velocityValue = greenVelocityMultiplier;
			}
		}
	}

	public void DetectHit()
	{
		if (!detectCollisions)
		{
			return;
		}
		Vector3 position = base.transform.position;
		if (Player.instance.currentController.constrainedSwing)
		{
			Controller componentInParent = GetComponentInParent<Controller>();
			if ((bool)componentInParent)
			{
				position = componentInParent.transform.position;
			}
		}
		Vector3 vector = collisionBox.position - lastPos;
		prevVelocities[curPrevVelIndex++] = vector;
		if (curPrevVelIndex >= prevVelocityCount)
		{
			curPrevVelIndex = 0;
		}
		Vector3 vector2 = lastPos;
		Vector3 vector3 = collisionBox.position - vector2;
		Vector3 vector4 = lastClubPos;
		Vector3 vector5 = position - vector4;
		int num = Mathf.CeilToInt(vector3.magnitude / 0.1f);
		float magnitude = (position - collisionBox.position).magnitude;
		Vector3 size = collisionBox.GetComponent<BoxCollider>().size;
		size.x /= 2f;
		for (int i = 1; i <= num; i++)
		{
			float num2 = (float)(i - 1) / (float)num;
			float num3 = (float)i / (float)num;
			Vector3 vector6 = vector4 + vector5 * num2;
			Vector3 vector7 = vector4 + vector5 * num3;
			Vector3 vector8 = vector6 + (vector7 - vector6) / 2f;
			Vector3 vector9 = vector2 + vector3 * num2;
			vector9 = vector6 + (vector9 - vector6).normalized * magnitude;
			Vector3 vector10 = vector2 + vector3 * num3;
			vector10 = vector7 + (vector10 - vector7).normalized * magnitude;
			Vector3 vector11 = size;
			vector11.x += (vector9 - vector10).magnitude;
			vector11.y *= 0.5f;
			vector11.z *= 0.5f;
			Vector3 vector12 = vector9 + (vector10 - vector9) / 2f;
			vector12 = (vector12 - vector8).normalized;
			vector12 = vector8 + vector12 * magnitude;
			Quaternion quaternion = Quaternion.identity;
			if (num == 1)
			{
				quaternion = collisionBox.rotation;
			}
			else
			{
				Vector3 lhs = vector10 - vector9;
				Vector3 vector13 = vector8 - vector12;
				Vector3 view = Vector3.Cross(lhs, vector13);
				quaternion.SetLookRotation(view, vector13);
			}
			UnityEngine.Debug.DrawLine(vector9, vector9 + quaternion * Vector3.up * 0.1f, colors[colorIndex]);
			UnityEngine.Debug.DrawLine(vector10, vector10 + quaternion * Vector3.up * 0.1f, colors[colorIndex]);
			DebugDrawBox(vector12, vector11, quaternion, i);
			Collider[] array = new Collider[1];
			if (Physics.OverlapBoxNonAlloc(vector12, vector11, array, quaternion, ballLayer, QueryTriggerInteraction.Ignore) > 0)
			{
				Golfball component = array[0].GetComponent<Golfball>();
				if (component != null)
				{
					HitBall(component);
					break;
				}
			}
		}
		lastPos = collisionBox.position;
		lastClubPos = position;
		lastClubRot = base.transform.rotation;
	}

	public void DetectBackwardsHit()
	{
		float num = Vector3.Dot(GameManager.instance.golfball.transform.position - GetAverageVelocity(), clubHead.forward);
		MonoBehaviour.print(num);
		if (num > 0f)
		{
			MonoBehaviour.print("A Back");
		}
		else
		{
			MonoBehaviour.print("A Front");
		}
	}

	public float ClubLengthPowerCompensation()
	{
		float num = 50f;
		if (Player.instance.clubSwitcher.currentType == ClubType.Driver)
		{
			num = 50f;
		}
		else if (Player.instance.clubSwitcher.currentType == ClubType.Iron)
		{
			num = 45.5f;
		}
		else if (Player.instance.clubSwitcher.currentType == ClubType.Putter)
		{
			num = 39.5f;
		}
		float currentLengthInMeters = clubScaler.currentLengthInMeters;
		return num / currentLengthInMeters;
	}

	public void DebugDrawBox(Vector3 center, Vector3 extents, Quaternion orientation, Color c, float duration = 0f)
	{
		float num = extents.x / 2f;
		float y = extents.y;
		float z = extents.z;
		Vector3 vector = center + orientation * new Vector3(num, y, z);
		Vector3 vector2 = center + orientation * new Vector3(num, y, 0f - z);
		Vector3 vector3 = center + orientation * new Vector3(0f - num, y, z);
		Vector3 vector4 = center + orientation * new Vector3(0f - num, y, 0f - z);
		Vector3 vector5 = center + orientation * new Vector3(0f - num, 0f - y, z);
		Vector3 vector6 = center + orientation * new Vector3(0f - num, 0f - y, 0f - z);
		Vector3 vector7 = center + orientation * new Vector3(num, 0f - y, z);
		Vector3 vector8 = center + orientation * new Vector3(num, 0f - y, 0f - z);
		UnityEngine.Debug.DrawLine(vector, vector2, c, duration);
		UnityEngine.Debug.DrawLine(vector2, vector4, c, duration);
		UnityEngine.Debug.DrawLine(vector4, vector3, c, duration);
		UnityEngine.Debug.DrawLine(vector3, vector, c, duration);
		UnityEngine.Debug.DrawLine(vector7, vector8, c, duration);
		UnityEngine.Debug.DrawLine(vector8, vector6, c, duration);
		UnityEngine.Debug.DrawLine(vector6, vector5, c, duration);
		UnityEngine.Debug.DrawLine(vector5, vector7, c, duration);
		UnityEngine.Debug.DrawLine(vector, vector7, c, duration);
		UnityEngine.Debug.DrawLine(vector2, vector8, c, duration);
		UnityEngine.Debug.DrawLine(vector4, vector6, c, duration);
		UnityEngine.Debug.DrawLine(vector3, vector5, c, duration);
	}

	private void ClubShadow()
	{
		MeshRenderer[] array = mesh;
		foreach (MeshRenderer meshRenderer in array)
		{
			if (GameManager.instance.GetClubShadows())
			{
				meshRenderer.shadowCastingMode = ShadowCastingMode.On;
			}
			else
			{
				meshRenderer.shadowCastingMode = ShadowCastingMode.Off;
			}
		}
	}

	protected virtual void AimLine()
	{
		if (!(aimLine != null))
		{
			return;
		}
		bool @bool = PlayerPrefsX.GetBool("ShowAimLine", defaultValue: true);
		if (useAimLine && @bool)
		{
			if (!(GameManager.instance.golfball == null))
			{
				aimLine.enabled = true;
				newForward = Player.instance.currentController.lockedPuttForward;
				if (Player.instance.currentController.controllerMode == ControllerMode.PracticeMode)
				{
					newForward = Player.instance.currentController.transform.rotation * Vector3.right;
				}
				golfballPos = GameManager.instance.golfball.transform.position;
				flip = 1f;
				if (GameManager.instance.GetHandedness())
				{
					flip = -1f;
				}
				calculatedEndPosition = golfballPos + newForward * flip;
				calculatedEndPosition.y += aimLineHeight;
				aimLine.SetPosition(0, golfballPos);
				aimLine.SetPosition(1, calculatedEndPosition);
			}
		}
		else
		{
			aimLine.enabled = false;
		}
	}

	private Vector3 CalculateVelocty(Vector3 target, Vector3 origin, float time)
	{
		Vector3 vector;
		Vector3 vector2 = (vector = target - origin);
		vector.y = 0f;
		float y = vector2.y;
		float num = vector.magnitude * time;
		float y2 = y / time + 0.5f * Mathf.Abs(Physics.gravity.y) * time;
		Vector3 normalized = vector.normalized;
		normalized *= num;
		normalized.y = y2;
		return normalized;
	}

	private Vector3 CalculatePosInTime(Vector3 origin, Vector3 vo, float time)
	{
		Vector3 vector = vo;
		vector.y = 0f;
		Vector3 result = origin + vo * time;
		float y = -0.5f * Mathf.Abs(Physics.gravity.y) * (time * time) + vo.y * time + origin.y;
		result.y = y;
		return result;
	}

	public void SetAimLineColor(Color c)
	{
		if (aimLine != null)
		{
			aimLine.startColor = c;
			c.a = 0f;
			aimLine.endColor = c;
		}
	}

	private void OnEnable()
	{
		SetAimLineColor(GameManager.instance.GetBallColor());
	}
}
public struct PrevPutterTransform
{
	public Vector3 pos;

	public Quaternion rot;
}
[Flags]
public enum GolfClubType
{
	None = 0,
	Putter = 1,
	Iron = 2,
	Driver = 4
}
public class Iron : GolfClub
{
	public IronType type;

	private float loftLimit = 15f;

	public float constraintMultiplier = 2.4f;

	public float constraintLoftMultiplier = 2f;

	public float constraintVelocityClamp = 25f;

	private float maxLoftAngle = 80f;

	private float minAngleToUp = 10f;

	public override void Start()
	{
		base.Start();
		if (Player.instance.currentController.constrainedSwing)
		{
			clubScaler.SetClubLength(ClubType.Iron, ScoreManager.instance.playerTurn[GameManager.instance.playerIndex].clubProfile.ironLength);
			useAimLine = true;
			if (aimLine != null)
			{
				aimLine.positionCount = 2;
			}
		}
	}

	public override void HitBall(Golfball gb)
	{
		if (!detectCollisions)
		{
			return;
		}
		base.HitBall(gb);
		float clubfaceLoft = GetClubfaceLoft();
		Vector3 vector = new Vector3(0f, loftValue * clubfaceLoft, 0f);
		Vector3 vector2 = Vector3.zero;
		Vector3 vector3 = GetAverageVelocity();
		if (Player.instance.currentController.constrainedSwing)
		{
			vector = Vector3.zero;
			Vector3 lockedPuttForward = Player.instance.currentController.lockedPuttForward;
			float magnitude = vector3.magnitude;
			vector3 = Vector3.Project(vector3, lockedPuttForward).normalized * magnitude;
			float num = neutralAngle * constraintLoftMultiplier;
			float num2 = Vector3.Angle(lockedPuttForward, Vector3.up);
			num2 -= num;
			if (num2 < minAngleToUp)
			{
				num -= minAngleToUp - num2;
				if (num < 0f)
				{
					num = 0f;
				}
				MonoBehaviour.print(num);
			}
			if (Vector3.Dot(vector3, lockedPuttForward) < 0f)
			{
				num = 0f - num;
			}
			Vector3 axis = Vector3.Cross(Player.instance.currentController.lockedPuttForward, gb.GetFloorNormal());
			vector3 = Quaternion.Inverse(Quaternion.AngleAxis(num, axis)) * vector3;
		}
		else
		{
			vector2 = clubHead.forward * GetClubfacePunch(clubfaceLoft);
		}
		Vector3 vector4 = (vector3.normalized + vector2 + vector) * (vector3.magnitude * velocityValue);
		Vector3 vector5 = vector4;
		vector5.y = 0f;
		if (vector4.y > loftLimit)
		{
			vector4.y = loftLimit;
		}
		if (Player.instance.currentController.constrainedSwing)
		{
			vector4 *= constraintMultiplier;
			baseVelocityClamp = constraintVelocityClamp;
		}
		vector4 *= GameManager.instance.GetClubPower(ClubType.Iron);
		vector4 = Vector3.ClampMagnitude(vector4, baseVelocityClamp);
		vector4 *= ClubLengthPowerCompensation();
		gb.rb.AddForce(vector4, ForceMode.Impulse);
		gb.rb.AddTorque(clubHead.right * vector3.magnitude * torqueMultiplier, ForceMode.Impulse);
		ResetVelocity();
		ResetPositions();
		detectCollisions = false;
		if (Player.instance.currentController.constrainedSwing)
		{
			Player.instance.currentController.SwitchControllerMode(ControllerMode.FollowMode);
		}
	}
}
public enum IronType
{
	RegularIron,
	ShortIron,
	FarIron
}
public class Putter : GolfClub
{
	public PutterType type;

	public float constraintMultiplier = 0.8f;

	public override void Start()
	{
		base.Start();
		if (Player.instance.currentController.constrainedSwing)
		{
			clubScaler.SetClubLength(ClubType.Putter, ScoreManager.instance.playerTurn[GameManager.instance.playerIndex].clubProfile.putterLength);
		}
		if (GameManager.instance.publishedPlatform == PublishedPlatform.XR)
		{
			aimLineLength *= 3f;
		}
	}

	public override void Update()
	{
		base.Update();
		AimLine();
	}

	public override void HitBall(Golfball gb)
	{
		if (detectCollisions)
		{
			base.HitBall(gb);
			Vector3 lockedPuttForward = Player.instance.currentController.lockedPuttForward;
			Vector3 averageVelocity = GetAverageVelocity();
			Vector3 vector = Vector3.Project(averageVelocity, lockedPuttForward);
			Vector3 vector2 = Vector3.Reflect(gb.GetComponent<Rigidbody>().velocity, vector);
			Vector3 vector3 = (averageVelocity.normalized + vector) * (averageVelocity.magnitude * velocityValue) + vector2;
			vector3.y = 0f;
			float num = 0.1f;
			float num2 = (Mathf.Abs(Vector3.Angle(lockedPuttForward, vector3) - 90f) / 90f + num) * (1f / (1f + num));
			vector3 *= num2;
			if (Player.instance.currentController.constrainedSwing)
			{
				vector3 *= constraintMultiplier;
			}
			vector3 *= GameManager.instance.GetClubPower(ClubType.Putter);
			vector3 = Vector3.ClampMagnitude(vector3, baseVelocityClamp);
			vector3 *= ClubLengthPowerCompensation();
			if (Player.instance.currentController.constrainedSwing)
			{
				float magnitude = vector3.magnitude;
				vector3 = Vector3.Project(vector3, lockedPuttForward).normalized * magnitude;
			}
			gb.GetComponent<Rigidbody>().AddForce(vector3, ForceMode.Impulse);
			detectCollisions = false;
			if (gb.GetComponent<MagicianOrb>() != null)
			{
				gb.GetComponent<MagicianOrb>().hitWithPutter = true;
			}
			if (Player.instance.currentController.constrainedSwing)
			{
				Player.instance.currentController.SwitchControllerMode(ControllerMode.FollowMode);
			}
		}
	}

	protected override void AimLine()
	{
		bool @bool = PlayerPrefsX.GetBool("ShowAimLine", defaultValue: true);
		if (useAimLine && @bool)
		{
			aimLine.enabled = true;
			Vector3 vector = Player.instance.currentController.lockedPuttForward;
			if (Player.instance.currentController.controllerMode == ControllerMode.PracticeMode)
			{
				vector = Player.instance.currentController.transform.rotation * Vector3.right;
			}
			Vector3 position = GameManager.instance.golfball.transform.position;
			if (GameManager.instance.GetHandedness())
			{
				aimLine.SetPosition(0, position + vector * 0.15f);
				aimLine.SetPosition(1, position + -vector * aimLineLength);
			}
			else
			{
				aimLine.SetPosition(0, position + -(vector * 0.15f));
				aimLine.SetPosition(1, position + vector * aimLineLength);
			}
		}
		else
		{
			aimLine.enabled = false;
		}
	}
}
public enum PutterType
{
	RegularPutter,
	SuperPutter
}
public class SwingAnalysis : MonoBehaviour
{
	public bool showAnimatedClub = true;

	public LineRenderer lineRenderer;

	private int numSteps = 50;

	private int recordingIndex;

	private List<Vector3> positions = new List<Vector3>();

	private List<ClubTransform> recordedClubTransform = new List<ClubTransform>();

	public List<ClubTransform> animatedClubTransform = new List<ClubTransform>();

	public GameObject driverClubMesh;

	public GameObject ironClubMesh;

	public GameObject putterClubMesh;

	public GameObject ghostBallPrefab;

	private GameObject ghostBall;

	private Transform clubMeshObj;

	private int animateIndex;

	private int clubTransformIndex;

	private float pauseAnimationTimer;

	private float pauseAnimationInverval = 1f;

	private float lerpVal = 1f;

	private bool updatingSwing;

	private void Start()
	{
		if (showAnimatedClub)
		{
			lineRenderer.enabled = false;
			numSteps = 50;
		}
		else
		{
			numSteps = 10;
		}
	}

	private void Update()
	{
		RecordClubPositions();
		AnimateClubMesh();
	}

	private void RecordClubPositions()
	{
		GolfClub currentClub = Player.instance.clubSwitcher.currentClub;
		if (!(currentClub != null))
		{
			return;
		}
		if (showAnimatedClub)
		{
			Vector3 position = currentClub.transform.position;
			Quaternion rotation = currentClub.transform.rotation;
			if (recordedClubTransform.Count < numSteps)
			{
				recordedClubTransform.Add(new ClubTransform
				{
					position = position,
					rotation = rotation
				});
			}
			else
			{
				recordedClubTransform[recordingIndex].position = position;
				recordedClubTransform[recordingIndex].rotation = rotation;
			}
			recordingIndex++;
			if (recordingIndex >= numSteps)
			{
				recordingIndex = 0;
			}
		}
		else if (currentClub.GetAverageVelocity().magnitude > 0.1f)
		{
			Vector3 position2 = currentClub.clubHead.position;
			if (positions.Count < numSteps)
			{
				positions.Add(position2);
			}
			else
			{
				positions[recordingIndex] = position2;
			}
			recordingIndex++;
			if (recordingIndex >= numSteps)
			{
				recordingIndex = 0;
			}
		}
	}

	public void HideSwingAnalysis()
	{
		if (clubMeshObj != null)
		{
			UnityEngine.Object.Destroy(clubMeshObj.gameObject);
		}
		if (ghostBall != null)
		{
			UnityEngine.Object.Destroy(ghostBall);
		}
		lineRenderer.enabled = false;
		positions.Clear();
		recordingIndex = 0;
	}

	public IEnumerator UpdateSwingLine()
	{
		if (updatingSwing)
		{
			yield break;
		}
		foreach (ClubTransform item in recordedClubTransform)
		{
			item.hitBall = false;
		}
		updatingSwing = true;
		base.gameObject.SetActive(value: true);
		if (showAnimatedClub)
		{
			if (clubMeshObj != null)
			{
				UnityEngine.Object.Destroy(clubMeshObj.gameObject);
			}
			Vector3 ballPos = GameManager.instance.golfball.transform.position;
			recordedClubTransform[recordingIndex].hitBall = true;
			yield return new WaitForSeconds(0.1f);
			SpawnGhostBall(ballPos);
			GameObject gameObject = ((Player.instance.clubSwitcher.currentType == ClubType.Driver) ? UnityEngine.Object.Instantiate(driverClubMesh, base.transform) : ((Player.instance.clubSwitcher.currentType != ClubType.Iron) ? UnityEngine.Object.Instantiate(putterClubMesh, base.transform) : UnityEngine.Object.Instantiate(ironClubMesh, base.transform)));
			clubMeshObj = gameObject.transform;
			animatedClubTransform.Clear();
			foreach (ClubTransform item2 in recordedClubTransform)
			{
				animatedClubTransform.Add(new ClubTransform
				{
					position = item2.position,
					rotation = item2.rotation,
					hitBall = item2.hitBall
				});
			}
			animateIndex = 0;
			clubTransformIndex = recordingIndex;
		}
		else
		{
			SpawnGhostBall(GameManager.instance.golfball.transform.position);
			lineRenderer.enabled = true;
			lineRenderer.positionCount = positions.Count;
			int i = 0;
			int num = recordingIndex;
			for (; i < positions.Count; i++)
			{
				if (num >= positions.Count)
				{
					num = 0;
				}
				Vector3 position = positions[num];
				lineRenderer.SetPosition(i, position);
				num++;
			}
			positions.Clear();
			recordingIndex = 0;
		}
		updatingSwing = false;
	}

	private void AnimateClubMesh()
	{
		if (!showAnimatedClub || !(clubMeshObj != null))
		{
			return;
		}
		if (animateIndex < animatedClubTransform.Count)
		{
			if (clubTransformIndex >= animatedClubTransform.Count)
			{
				clubTransformIndex = 0;
			}
			if (animatedClubTransform[clubTransformIndex].hitBall && pauseAnimationTimer <= pauseAnimationInverval)
			{
				pauseAnimationTimer += Time.deltaTime;
				return;
			}
			Vector3 position = Vector3.Lerp(clubMeshObj.position, animatedClubTransform[clubTransformIndex].position, lerpVal);
			Quaternion rotation = Quaternion.Slerp(clubMeshObj.rotation, animatedClubTransform[clubTransformIndex].rotation, lerpVal);
			clubMeshObj.position = position;
			clubMeshObj.rotation = rotation;
			clubTransformIndex++;
			animateIndex++;
			pauseAnimationTimer = 0f;
		}
		else if (pauseAnimationTimer <= pauseAnimationInverval)
		{
			pauseAnimationTimer += Time.deltaTime;
		}
		else
		{
			pauseAnimationTimer = 0f;
			animateIndex = 0;
		}
	}

	private void SpawnGhostBall(Vector3 spawnPos)
	{
		UnityEngine.Object.Destroy(ghostBall);
		ghostBall = UnityEngine.Object.Instantiate(ghostBallPrefab, spawnPos, Quaternion.identity, base.transform);
	}

	private void OnDisable()
	{
		lineRenderer.enabled = false;
		positions.Clear();
		recordingIndex = 0;
	}
}
[Serializable]
public class ClubTransform
{
	public Vector3 position;

	public Quaternion rotation;

	public bool hitBall;
}
public class SlopeLines : MonoBehaviour
{
	public LayerMask golfingSurface;

	public LineRenderer[] lineRenderersX;

	public LineRenderer[] lineRenderersZ;

	public int posCount = 100;

	public float gridSizeX = 4f;

	public float gridSizeZ = 3f;

	private float height = 2f;

	private BoxCollider bc;

	private bool allowLines = true;

	private bool showingLines;

	private void Start()
	{
		if (GameManager.instance.currentSceneName != "LevelEditor")
		{
			SetLines();
		}
		DisableLines();
	}

	private void Update()
	{
		allowLines = GameManager.instance.GetGreenSlopeLines();
		if (!allowLines && showingLines)
		{
			showingLines = false;
			DisableLines();
		}
	}

	public void SetLines()
	{
		bc = GetComponent<BoxCollider>();
		bc.size = new Vector3(gridSizeX, bc.size.y, gridSizeZ);
		SetLines(lineRenderersX, xRot: true);
		AdjustHeight(lineRenderersX);
		SetLines(lineRenderersZ, xRot: false);
		AdjustHeight(lineRenderersZ);
	}

	private void SetLines(LineRenderer[] lineRenderers, bool xRot)
	{
		float num = gridSizeZ / 2f * -1f;
		float num2 = gridSizeX / (float)(lineRenderers.Length - 1);
		float num3 = gridSizeX / 2f * -1f;
		float num4 = gridSizeZ / (float)(lineRenderers.Length - 1);
		for (int i = 0; i < lineRenderers.Length; i++)
		{
			lineRenderers[i].positionCount = posCount;
			for (int j = 0; j < lineRenderers[i].positionCount; j++)
			{
				Vector3 position = ((!xRot) ? new Vector3(num3 + gridSizeX / (float)(posCount - 1) * (float)j, 0f, num + num4 * (float)i) : new Vector3(num3 + num2 * (float)i, 0f, num + gridSizeZ / (float)(posCount - 1) * (float)j));
				lineRenderers[i].SetPosition(j, position);
			}
		}
	}

	private void AdjustHeight(LineRenderer[] lineRenderers)
	{
		Vector3 position = Vector3.zero;
		for (int i = 0; i < lineRenderers.Length; i++)
		{
			for (int j = 0; j < posCount; j++)
			{
				Vector3 vector = base.transform.TransformPoint(lineRenderers[i].GetPosition(j));
				if (Physics.Raycast(new Vector3(vector.x, vector.y + height, vector.z), Vector3.down, out var hitInfo, height + 1f, golfingSurface))
				{
					position = base.transform.InverseTransformPoint(hitInfo.point);
				}
				lineRenderers[i].SetPosition(j, position);
			}
			lineRenderers[i].Simplify(0f);
		}
	}

	public void DisableLines()
	{
		showingLines = false;
		LineRenderer[] array = lineRenderersX;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].enabled = false;
		}
		array = lineRenderersZ;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].enabled = false;
		}
	}

	private void EnableLines()
	{
		if (allowLines)
		{
			showingLines = true;
			LineRenderer[] array = lineRenderersX;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enabled = true;
			}
			array = lineRenderersZ;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enabled = true;
			}
		}
	}

	private void OnTriggerStay(Collider other)
	{
		if (!(other.tag == "Golfball"))
		{
			return;
		}
		if (GameManager.instance.golfball.currentSurface == SurfaceType.Green)
		{
			if (GameManager.instance.golfball.rb.velocity.magnitude < 0.5f)
			{
				EnableLines();
			}
			else
			{
				DisableLines();
			}
		}
		else
		{
			DisableLines();
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (other.tag == "Golfball")
		{
			DisableLines();
		}
	}
}
public class Golfhole : MonoBehaviour
{
	public Transform holePoint;

	public AudioSource audioSource2D;

	public AudioSource audioSource3D;

	[Header("=====Audio=====")]
	public AudioClip sfxGolfBallDrop;

	public AudioClip sfxAbovePar;

	public AudioClip sfxBelowPar;

	public AudioClip sfxHoleInOne;

	public AudioClip sfxTickAudio;

	public AudioClip sfxBallHitPole;

	public ParticleSystem confetti;

	[Header("=====Stroke Count=====")]
	public TextMeshPro strokeNum1;

	public TextMeshPro strokeNum2;

	public TextMeshPro strokeTotal;

	private Transform strokeParent;

	private bool showStrokeTotal;

	private bool showStrokeCount;

	private GameObject beacon;

	public float beaconDistance = 30f;

	public Transform flagPole;

	private bool proceedToNextLevel;

	private bool startCountdown;

	private bool ballScoredInHole;

	public float timeTillForceProceed = 30f;

	private bool startForceProceedTimer;

	private float resendHoleFinishedScoredTimer = 5f;

	[HideInInspector]
	public SpriteRenderer minimapIcon;

	public GameObject grid;

	private void OnEnable()
	{
		Autowarp.onAutowarp += OnAutoWarp;
	}

	private void OnDisable()
	{
		Autowarp.onAutowarp -= OnAutoWarp;
	}

	private void Start()
	{
		strokeParent = strokeNum1.transform.parent;
		strokeNum1.text = " ";
		strokeNum2.text = " ";
		strokeTotal.text = " ";
		ResetVariables();
		StartCoroutine(DelayStart());
		minimapIcon = GetComponentInChildren<SpriteRenderer>();
		if (minimapIcon != null)
		{
			minimapIcon.transform.position = new Vector3(base.transform.position.x, base.transform.position.y + 300f, base.transform.position.z);
			minimapIcon.transform.eulerAngles = new Vector3(90f, 0f, 0f);
		}
		SpawnBeacon();
	}

	private IEnumerator DelayStart()
	{
		yield return new WaitForEndOfFrame();
		yield return new WaitForEndOfFrame();
		if (GameManager.instance.currentSceneName == "CustomHoleScene" || GameManager.instance.currentSceneName == "Tutorial")
		{
			ToggleBeacon();
			ToggleGrid();
		}
	}

	private void ResetVariables()
	{
		showStrokeCount = false;
		showStrokeTotal = false;
		proceedToNextLevel = false;
		ballScoredInHole = false;
		startCountdown = false;
		strokeNum1.text = "";
		strokeNum2.text = "";
		ScoreManager.instance.currentStrokeCount = 0;
		if (GameManager.instance.gameMode == GameMode.Campaign)
		{
			GameManager.instance.SetMulligans();
		}
	}

	private void Update()
	{
		if (ballScoredInHole)
		{
			if (PhotonNetwork.IsConnected)
			{
				resendHoleFinishedScoredTimer -= Time.deltaTime;
				if (resendHoleFinishedScoredTimer <= 0f)
				{
					resendHoleFinishedScoredTimer = 5f;
					PhotonNetwork.LocalPlayer.SetHoleFinished(value: true);
				}
			}
			if (showStrokeCount)
			{
				ShowStrokeCount();
			}
		}
		if (showStrokeCount)
		{
			ShowStrokeCount();
		}
		if (Input.GetKeyDown(KeyCode.U))
		{
			PlayGolfPoleCollisionSFX(1f);
		}
		if (!PhotonNetwork.IsConnected)
		{
			return;
		}
		if (!startCountdown && ballScoredInHole && AllPlayersReadyToProceed())
		{
			startCountdown = true;
			startForceProceedTimer = true;
			if (startForceProceedTimer)
			{
				timeTillForceProceed -= Time.deltaTime;
				if (timeTillForceProceed <= 0f)
				{
					timeTillForceProceed = 30f;
					proceedToNextLevel = true;
				}
			}
			StartCoroutine(NextHoleCountdown());
		}
		if (proceedToNextLevel && PhotonNetwork.IsMasterClient)
		{
			proceedToNextLevel = false;
			PhotonNetwork.CurrentRoom.LoadNextLevel();
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.tag == "Golfball")
		{
			BallScored();
		}
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (collision.gameObject.tag == "Golfball")
		{
			PlayGolfPoleCollisionSFX(collision.relativeVelocity.magnitude);
		}
	}

	public void ChangeFlagDirection(Vector3 dir)
	{
		if (dir != Vector3.zero && Vector3.Angle(base.transform.up, dir) != 0f)
		{
			Quaternion quaternion = Quaternion.LookRotation(Vector3.Cross(Vector3.Cross(base.transform.up, dir), base.transform.up), base.transform.up);
			if (flagPole != null && quaternion != Quaternion.identity)
			{
				flagPole.rotation = quaternion;
			}
		}
	}

	public void BallScored()
	{
		if (ballScoredInHole)
		{
			return;
		}
		ballScoredInHole = true;
		audioSource3D.PlayOneShot(sfxGolfBallDrop);
		PlayOnlineSounds();
		if (GameManager.instance.IsCloudlands1Hole())
		{
			if (ScoreManager.instance.currentStrokeCount <= 1)
			{
				audioSource2D.PlayOneShot(sfxBelowPar);
				HoleInOnePFX();
			}
			else if (ScoreManager.instance.currentStrokeCount <= ScoreManager.instance.pars[GameManager.instance.holeIndex])
			{
				audioSource2D.PlayOneShot(sfxBelowPar);
			}
			else if (ScoreManager.instance.currentStrokeCount > ScoreManager.instance.pars[GameManager.instance.holeIndex])
			{
				audioSource2D.PlayOneShot(sfxAbovePar);
			}
		}
		else if (ScoreManager.instance.currentStrokeCount <= ScoreManager.instance.pars[GameManager.instance.holeIndex] - 2)
		{
			audioSource2D.PlayOneShot(sfxBelowPar);
			HoleInOnePFX();
		}
		else if (ScoreManager.instance.currentStrokeCount <= ScoreManager.instance.pars[GameManager.instance.holeIndex])
		{
			audioSource2D.PlayOneShot(sfxBelowPar);
		}
		else if (ScoreManager.instance.currentStrokeCount > ScoreManager.instance.pars[GameManager.instance.holeIndex])
		{
			audioSource2D.PlayOneShot(sfxAbovePar);
		}
		if (GameManager.instance.currentSceneName == "Tutorial")
		{
			GameManager.instance.SetCanMulligan(value: false);
			StartCoroutine(NextHoleCountdown());
			return;
		}
		showStrokeCount = true;
		if (GameManager.instance.currentSceneName == "LevelEditor" || GameManager.instance.currentSceneName == "LevelEditorArt")
		{
			if (LevelEditor.instance.finalizing)
			{
				LevelEditor.instance.levelEditorMenu.SetPar();
			}
			else if (GameManager.instance.golfball != null)
			{
				Golfball golfball = GameManager.instance.golfball;
				golfball.DestroyTrailRenderer();
				if (LevelEditor.instance.ballSpawner != null)
				{
					golfball.rb.velocity = Vector3.zero;
					golfball.rb.angularVelocity = Vector3.zero;
					golfball.transform.position = LevelEditor.instance.ballSpawner.transform.position;
				}
				ScoreManager.instance.ResetStrokes();
				ScoreManager.instance.ballScored = false;
				ResetHole();
			}
			return;
		}
		GameManager.instance.SetCanMulligan(value: false);
		if (GameManager.instance.playerCount == 1)
		{
			SpawnHoleInfo();
		}
		if (GameManager.instance.holeIndex == GameManager.instance.holeData.Count - 1)
		{
			showStrokeTotal = true;
		}
		ScoreManager.instance.ballScored = true;
		ScoreManager.instance.SetScore(GameManager.instance.playerIndex);
		if (PhotonNetwork.IsConnected)
		{
			PhotonNetwork.LocalPlayer.SetHoleFinished(value: true);
			RoomRPC.instance.pView.RPC("SetOtherPlayersPhotonScore", RpcTarget.Others, false);
		}
		else if (GameManager.instance.playerCount == 1 && GameManager.instance.gameMode != GameMode.Campaign)
		{
			StartCoroutine(NextHoleCountdown());
		}
		else if (GameManager.instance.playerCount > 1)
		{
			UnityEngine.Object.Instantiate(GameManager.instance.playerTurnPromptPrefab);
			if (!ScoreManager.instance.playerTurn[GameManager.instance.playerIndex].infiniteMulligan)
			{
				StartCoroutine(RemoteServerManager.instance.UploadScore(GameManager.instance.holeData[GameManager.instance.holeIndex], ScoreManager.instance.currentStrokeCount, playlist: false, delegate
				{
				}));
			}
		}
		if (GameManager.instance.currentSceneName == "CustomHoleScene")
		{
			MoneyManager.instance.HoleScoredMoney(ScoreManager.instance.currentStrokeCount, ScoreManager.instance.pars[GameManager.instance.holeIndex]);
		}
		StartCoroutine(GameManager.instance.golfball.DisableBall());
		CheckAchievements();
		OBManager.instance.ballScoredPosition = holePoint.position;
	}

	public void HoleInOnePFX()
	{
		audioSource3D.PlayOneShot(sfxHoleInOne);
		confetti.Play();
	}

	public void ResetHole()
	{
		strokeParent.gameObject.SetActive(value: false);
		ballScoredInHole = false;
	}

	public IEnumerator NextHoleCountdown(float delay = 3f)
	{
		while (GameManager.instance.holeIndex < GameManager.instance.holeData.Count && GameManager.instance.holeInfoNotification != null)
		{
			yield return null;
		}
		yield return new WaitForSeconds(delay);
		if (PhotonNetwork.IsMasterClient)
		{
			PhotonNetwork.CurrentRoom.SetNextHoleCountDown(value: true);
		}
		int ticks = 3;
		while (ticks > 0)
		{
			ticks--;
			audioSource2D.PlayOneShot(sfxTickAudio);
			yield return new WaitForSeconds(1f);
		}
		if (PhotonNetwork.IsConnected)
		{
			if (AllPlayersReadyToProceed())
			{
				proceedToNextLevel = true;
				yield break;
			}
			proceedToNextLevel = false;
			startCountdown = false;
		}
		else if (GameManager.instance.currentSceneName == "Tutorial")
		{
			GameManager.instance.SwitchToScene("MainMenu");
		}
		else
		{
			GameManager.instance.LoadNextHole();
		}
	}

	private void ShowStrokeCount()
	{
		if (strokeNum1.text == "")
		{
			int num = ScoreManager.instance.pars[GameManager.instance.holeIndex];
			int currentStrokeCount = ScoreManager.instance.currentStrokeCount;
			string text = "";
			if (currentStrokeCount > num)
			{
				text = "+";
				num = currentStrokeCount - num;
			}
			else if (currentStrokeCount < num)
			{
				text = "-";
				num -= currentStrokeCount;
			}
			else
			{
				num = 0;
			}
			strokeNum1.text = ScoreManager.instance.currentStrokeCount + "(" + text + num + ")";
			strokeNum1.fontSizeMax = 1.5f;
			strokeNum2.text = strokeNum1.text;
			strokeNum2.fontSizeMax = 1.5f;
		}
		strokeNum1.transform.RotateAround(strokeParent.position, base.transform.up, 80f * Time.deltaTime);
		strokeNum2.transform.RotateAround(strokeParent.position, base.transform.up, 80f * Time.deltaTime);
		if (!showStrokeTotal)
		{
			return;
		}
		if (strokeTotal.text == "")
		{
			int num2 = ScoreManager.instance.GetTotalStrokes(GameManager.instance.playerIndex) - ScoreManager.instance.GetTotalPars();
			if (num2 > 0)
			{
				strokeTotal.text = ScoreManager.instance.GetTotalStrokes(GameManager.instance.playerIndex) + "(+" + num2 + ")";
			}
			else
			{
				strokeTotal.text = ScoreManager.instance.GetTotalStrokes(GameManager.instance.playerIndex) + "(" + num2 + ")";
			}
		}
		Vector3 vector = Camera.main.transform.position - strokeTotal.transform.position;
		vector = Vector3.ProjectOnPlane(vector, strokeTotal.transform.up);
		strokeTotal.transform.rotation = Quaternion.LookRotation(-vector.normalized, strokeTotal.transform.up);
	}

	public static bool AllPlayersReadyToProceed()
	{
		foreach (Photon.Realtime.Player usablePlayer in PhotonManager.instance.GetUsablePlayers())
		{
			if (!usablePlayer.GetHoleFinished() || !usablePlayer.GetRatingHole())
			{
				return false;
			}
		}
		return true;
	}

	private void SpawnHoleInfo()
	{
		if (!GameManager.instance.holeData[GameManager.instance.holeIndex].defaultHole && !GameManager.instance.holeData[GameManager.instance.holeIndex].localItem && RemoteServerManager.instance.playerID != "")
		{
			GameManager.instance.SpawnHoleInfoNotification(rating: true);
		}
		else if (GameManager.instance.holeData[GameManager.instance.holeIndex].defaultHole)
		{
			GameManager.instance.SpawnHoleInfoNotification(rating: false);
			if (PhotonNetwork.IsConnected)
			{
				GameManager.instance.holeInfoNotification.GetComponent<HoleInfo>().autoClose = true;
			}
		}
		else
		{
			GameManager.instance.SpawnHoleInfoNotification(rating: false);
		}
		if (RemoteServerManager.instance.playerID != "")
		{
			GameManager.instance.holeInfoNotification.GetComponentInChildren<HoleLeaderboard>().updatingLeaderboard = true;
		}
	}

	private void PlayOnlineSounds()
	{
		if (!PhotonNetwork.IsConnected)
		{
			return;
		}
		RoomRPC.PlayOnlineSound(base.transform.position, sfxGolfBallDrop.name);
		if (GameManager.instance.IsCloudlands1Hole())
		{
			if (ScoreManager.instance.currentStrokeCount <= 1)
			{
				RoomRPC.PlayOnlineSound(base.transform.position, sfxHoleInOne.name);
				RoomRPC.instance.pView.RPC("HoleInOnePFX", RpcTarget.Others, base.transform.position);
			}
			if (ScoreManager.instance.currentStrokeCount < ScoreManager.instance.pars[GameManager.instance.holeIndex])
			{
				RoomRPC.PlayOnlineSound(base.transform.position, sfxBelowPar.name);
			}
			else if (ScoreManager.instance.currentStrokeCount > ScoreManager.instance.pars[GameManager.instance.holeIndex])
			{
				RoomRPC.PlayOnlineSound(base.transform.position, sfxAbovePar.name);
			}
		}
		else
		{
			if (ScoreManager.instance.currentStrokeCount <= ScoreManager.instance.pars[GameManager.instance.holeIndex] - 2)
			{
				RoomRPC.PlayOnlineSound(base.transform.position, sfxHoleInOne.name);
				RoomRPC.instance.pView.RPC("HoleInOnePFX", RpcTarget.Others, base.transform.position);
			}
			if (ScoreManager.instance.currentStrokeCount < ScoreManager.instance.pars[GameManager.instance.holeIndex])
			{
				RoomRPC.PlayOnlineSound(base.transform.position, sfxBelowPar.name);
			}
			else if (ScoreManager.instance.currentStrokeCount > ScoreManager.instance.pars[GameManager.instance.holeIndex])
			{
				RoomRPC.PlayOnlineSound(base.transform.position, sfxAbovePar.name);
			}
		}
	}

	private void CheckAchievements()
	{
		if (ScoreManager.instance.currentStrokeCount == 1)
		{
			GameManager.instance.gameAchievements.UnlockAchievement(Achievement.HOLE_IN_ONE);
		}
		else if (ScoreManager.instance.strokeTable[GameManager.instance.playerIndex][GameManager.instance.holeIndex] > 1 && ScoreManager.instance.strokeTable[GameManager.instance.playerIndex][GameManager.instance.holeIndex] < GameManager.instance.holeData[GameManager.instance.holeIndex].par - 1)
		{
			GameManager.instance.gameAchievements.UnlockAchievement(Achievement.EAGLE);
		}
		else if (ScoreManager.instance.strokeTable[GameManager.instance.playerIndex][GameManager.instance.holeIndex] > 1 && ScoreManager.instance.strokeTable[GameManager.instance.playerIndex][GameManager.instance.holeIndex] == GameManager.instance.holeData[GameManager.instance.holeIndex].par - 1)
		{
			GameManager.instance.gameAchievements.UnlockAchievement(Achievement.BIRDIE);
		}
		else if (ScoreManager.instance.strokeTable[GameManager.instance.playerIndex][GameManager.instance.holeIndex] > 1 && ScoreManager.instance.strokeTable[GameManager.instance.playerIndex][GameManager.instance.holeIndex] == GameManager.instance.holeData[GameManager.instance.holeIndex].par)
		{
			GameManager.instance.gameAchievements.UnlockAchievement(Achievement.PAR);
		}
	}

	private void SpawnBeacon()
	{
		if (beacon == null && GameManager.instance.beaconPrefab != null)
		{
			beacon = UnityEngine.Object.Instantiate(GameManager.instance.beaconPrefab, base.transform);
			beacon.transform.position = holePoint.position;
			beacon.transform.rotation = Quaternion.identity;
			beacon.SetActive(value: false);
		}
	}

	private void PlayGolfPoleCollisionSFX(float volume)
	{
		volume = Mathf.Clamp01(volume);
		audioSource3D.PlayOneShot(sfxBallHitPole, volume);
		if (PhotonNetwork.IsConnected)
		{
			RoomRPC.PlayOnlineSound(base.transform.position, sfxBallHitPole.name, volume);
		}
	}

	private void ToggleBeacon()
	{
		if (beacon != null && (!(GameManager.instance.currentSceneName == "LevelEditor") || LevelEditor.instance.previewing))
		{
			Vector2 a = new Vector2(Player.instance.head.position.x, Player.instance.head.position.z);
			Vector2 b = new Vector2(base.transform.position.x, base.transform.position.z);
			if (Vector2.Distance(a, b) > beaconDistance / 1.09361f)
			{
				beacon.SetActive(value: true);
			}
			else
			{
				beacon.SetActive(value: false);
			}
		}
	}

	public void DelayToggleBeacon()
	{
		StartCoroutine(DelayToggleBeacon_());
	}

	private IEnumerator DelayToggleBeacon_()
	{
		yield return null;
		ToggleBeacon();
	}

	public void TurnOffBeacon()
	{
		if (beacon != null)
		{
			beacon.SetActive(value: false);
		}
	}

	private void ToggleGrid()
	{
		if (grid != null)
		{
			if (Vector3.Distance(Player.instance.head.position, base.transform.position) < beaconDistance / 1.09361f)
			{
				grid.SetActive(GameManager.instance.GetGreenSlopeLines());
			}
			else
			{
				grid.SetActive(value: false);
			}
		}
	}

	private void OnAutoWarp()
	{
		StartCoroutine(_OnAutoWarp());
	}

	private IEnumerator _OnAutoWarp()
	{
		yield return null;
		ToggleBeacon();
		ToggleGrid();
	}
}
public class GolfHoleFunnel : MonoBehaviour
{
	private float forceFactor = 3f;

	private float previousDrag;

	private float previousAngularDrag;

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.CompareTag("Golfball"))
		{
			previousDrag = other.GetComponent<Golfball>().rb.drag;
			previousAngularDrag = other.GetComponent<Golfball>().rb.angularDrag;
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (other.gameObject.CompareTag("Golfball"))
		{
			other.GetComponent<Golfball>().rb.drag = previousDrag;
			other.GetComponent<Golfball>().rb.angularDrag = previousAngularDrag;
			previousDrag = 0f;
			previousAngularDrag = 0f;
		}
	}

	private void OnTriggerStay(Collider other)
	{
		if (other.gameObject.CompareTag("Golfball"))
		{
			other.attachedRigidbody.AddForce((base.transform.position - other.transform.position) * forceFactor);
			other.GetComponent<Golfball>().ResetDrag();
		}
	}
}
public class BombBall : MonoBehaviour
{
	public float blowUpTime = 3f;

	public bool firstHit;

	public GameObject bunkerPrefab;

	private Explosion blowUpPFX;

	public AudioClip blowUpSFX;

	private AudioSource audioSource;

	private bool startTimer;

	private float groundDistanceCheck = 0.05f;

	private float pfxDuration;

	private Vector3 blowUpPos;

	private bool exploded;

	private float blowUpForce = 30f;

	private void Start()
	{
		audioSource = GetComponent<AudioSource>();
		blowUpPFX = GetComponentInChildren<Explosion>();
	}

	private void Update()
	{
		if (!startTimer)
		{
			return;
		}
		blowUpTime -= Time.deltaTime;
		if (!(blowUpTime <= 0f) || exploded)
		{
			return;
		}
		exploded = true;
		if (Physics.Raycast(base.transform.position, Vector3.down, out var hitInfo, groundDistanceCheck))
		{
			startTimer = true;
			if (hitInfo.transform.gameObject.layer == LayerMask.NameToLayer("GolfingSurface"))
			{
				GameObject obj = UnityEngine.Object.Instantiate(bunkerPrefab, blowUpPos, Quaternion.identity);
				obj.transform.position = blowUpPos;
				obj.transform.localScale = new Vector3(0.2f, 1f, 0.2f);
			}
		}
		audioSource.PlayOneShot(blowUpSFX);
		blowUpPFX.Play();
		ItemManager.instance.DelayFinishedItem();
		UnityEngine.Object.Destroy(base.gameObject, 2f);
	}

	public void HasGoneOB()
	{
		ItemManager.instance.FinishedItem();
		UnityEngine.Object.Destroy(base.gameObject);
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (firstHit && collision.gameObject.layer == LayerMask.NameToLayer("GolfingSurface") && Physics.Raycast(base.transform.position, Vector3.down, out var hitInfo, groundDistanceCheck))
		{
			startTimer = true;
			blowUpPos = hitInfo.point;
		}
	}
}
public class SmokeBall : MonoBehaviour
{
	public float blowUpTime = 3f;

	public bool firstHit;

	private bool startTimer;

	private ParticleSystem smokePFX;

	private float pfxDuration;

	private void Start()
	{
		smokePFX = GetComponentInChildren<ParticleSystem>();
	}

	private void Update()
	{
		if (!startTimer)
		{
			return;
		}
		blowUpTime -= Time.deltaTime;
		if (!(blowUpTime <= 0f))
		{
			return;
		}
		if (!smokePFX.isPlaying)
		{
			smokePFX.Play();
			ItemManager.instance.DelayFinishedItem();
			GetComponent<MeshRenderer>().enabled = false;
			return;
		}
		pfxDuration += Time.deltaTime;
		if (pfxDuration >= smokePFX.main.duration)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	public void HasGoneOB()
	{
		ItemManager.instance.FinishedItem();
		UnityEngine.Object.Destroy(base.gameObject);
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (firstHit && collision.gameObject.layer == LayerMask.NameToLayer("GolfingSurface"))
		{
			startTimer = true;
		}
	}
}
public class ManualWarpIndicator : MonoBehaviour
{
	public GameObject meshGood;

	public GameObject meshBad;

	private bool isOnValidWarpSurface;

	public Vector3 targetPosition;

	private Quaternion targetRotation;

	private float speed = 500f;

	public bool isShown { get; set; }

	private void Start()
	{
		meshGood.SetActive(value: false);
		meshBad.SetActive(value: false);
		SceneManager.MoveGameObjectToScene(base.gameObject, SceneManager.GetSceneByName("Main"));
	}

	public void SetTarget(Vector3 myTargetPosition, Quaternion myTargetRotation)
	{
		targetPosition = myTargetPosition;
		targetRotation = myTargetRotation;
	}

	public void Show()
	{
		isShown = true;
	}

	public void Hide()
	{
		isShown = false;
		if (meshGood.activeSelf)
		{
			meshGood.SetActive(value: false);
		}
		if (meshBad.activeSelf)
		{
			meshBad.SetActive(value: false);
		}
	}

	public bool IsOnValidWarpSurface()
	{
		return isOnValidWarpSurface;
	}

	public void ShowGood()
	{
		meshGood.SetActive(value: true);
		meshBad.SetActive(value: false);
		isOnValidWarpSurface = true;
	}

	public void ShowBad()
	{
		meshGood.SetActive(value: false);
		meshBad.SetActive(value: true);
		isOnValidWarpSurface = false;
	}

	private void Update()
	{
		if (isShown)
		{
			UpdatePosition();
		}
	}

	public void UpdatePosition()
	{
		base.transform.position = Vector3.Lerp(base.transform.position, targetPosition, Time.unscaledDeltaTime * speed);
		base.transform.rotation = Quaternion.Lerp(base.transform.rotation, targetRotation, Time.unscaledDeltaTime * speed);
	}
}
public class BallTypePicker : PauseButton
{
	public BallType type;

	public BallTypePicker[] buttons;

	private void Start()
	{
		buttons = base.transform.parent.GetComponentsInChildren<BallTypePicker>();
	}

	public void SetBallType()
	{
		BallTypePicker[] array = buttons;
		foreach (BallTypePicker obj in array)
		{
			obj.stayHighlighted = false;
			obj.UnHighlight();
		}
		stayHighlighted = true;
		Highlight();
		GameManager.instance.SetBallType(type);
	}
}
public class BallTypePickerCanvas : TextButton
{
	public BallType type;

	public BallTypePickerCanvas[] buttons;

	private void Start()
	{
		buttons = base.transform.parent.GetComponentsInChildren<BallTypePickerCanvas>();
	}

	public void SetBallType()
	{
		BallTypePickerCanvas[] array = buttons;
		foreach (BallTypePickerCanvas obj in array)
		{
			obj.stayHighlighted = false;
			obj.UnHighlight();
		}
		stayHighlighted = true;
		Highlight();
		GameManager.instance.SetBallType(type);
	}
}
public class CalibrateHeightButton : TextButton
{
	public ClubLengthBasedOnHeight clubLengthScript;

	public TextMeshProUGUI calibrateText;

	private bool calibrating;

	private float timeTillCalibrated = 1f;

	private float calibrateTimer;

	private string startingText;

	private void Start()
	{
		startingText = calibrateText.text;
	}

	private void Update()
	{
		if (calibrating)
		{
			clickable = false;
			calibrateText.text = LocalizationManager.GetTranslation("Calibrating");
			Highlight();
			calibrateTimer += Time.deltaTime;
			if (calibrateTimer >= timeTillCalibrated)
			{
				clubLengthScript.MeasureHeight();
				clubLengthScript.AdjustClubLength();
				UnHighlight();
				StartCoroutine(ChangeText());
				calibrating = false;
				clickable = true;
			}
		}
	}

	public override void OnClick()
	{
		calibrating = true;
	}

	public override void Highlight()
	{
		base.Highlight();
	}

	public override void UnHighlight()
	{
		base.UnHighlight();
	}

	private IEnumerator ChangeText()
	{
		calibrateText.text = LocalizationManager.GetTranslation("Calibrated");
		yield return new WaitForSeconds(1f);
		calibrateText.text = startingText;
	}
}
public class CampaignDetailPanel : MonoBehaviour
{
	public TextMeshPro holeNameText;

	public TextMeshPro parText;

	public TextMeshPro difficultyText;

	public TextMeshPro highScoreText;

	public RawImage screenshot;

	public CampaignHoleButton[] campaignHoles;

	public CampaignHoleButton[] bossHoles;

	public GameObject infoCanvas;

	internal int holeIndex;

	private Difficulty difficulty;

	public Image mapLevelsRenderer;

	public CampaignHoleButton hole18WithoutBoss;

	public CampaignHoleButton hole18WithBoss;

	public CampaignHoleButton hole36WithoutBoss;

	public CampaignHoleButton hole36WithBoss;

	public CampaignHoleButton hole54WithoutBoss;

	public CampaignHoleButton hole54WithBoss;

	internal CampaignHoleButton pickedCampaignHole;

	public Image campaignMapImage;

	public Material campaignMapWithoutBossMaterial;

	public Material campaignMapWithBossMaterial;

	protected bool boss;

	protected int bossIndex;

	private WorkshopData data;

	private void OnEnable()
	{
		LocalizationManager.OnLocalizeEvent += OnLocalizationCall;
	}

	private void OnDisable()
	{
		infoCanvas.SetActive(value: false);
		mapLevelsRenderer.material.SetFloat("_selectVal", 0f);
		LocalizationManager.OnLocalizeEvent -= OnLocalizationCall;
	}

	public virtual void Start()
	{
		ToggleBossView();
		mapLevelsRenderer.material = new Material(mapLevelsRenderer.material);
		UnHighlight();
		SetCampaignHoleButtons();
		ShowMap();
	}

	protected void ToggleBossView()
	{
		if (GameManager.instance.hideBosses)
		{
			campaignHoles[17] = hole18WithoutBoss;
			campaignHoles[35] = hole36WithoutBoss;
			campaignHoles[53] = hole54WithoutBoss;
			campaignMapImage.material = campaignMapWithoutBossMaterial;
		}
		else
		{
			campaignHoles[17] = hole18WithBoss;
			campaignHoles[35] = hole36WithBoss;
			campaignHoles[53] = hole54WithBoss;
			campaignMapImage.material = campaignMapWithBossMaterial;
		}
	}

	public virtual void SetCampaignPanel(CampaignHoleButton chb, int buttonIndex)
	{
		pickedCampaignHole = chb;
		data = chb.workshopData;
		holeNameText.text = data.levelName;
		TextMeshPro textMeshPro = difficultyText;
		string translation = LocalizationManager.GetTranslation("Difficulty");
		Difficulty difficulty = (Difficulty)data.difficulty;
		textMeshPro.text = translation + ": " + LocalizationManager.GetTranslation(difficulty.ToString());
		highScoreText.text = LocalizationManager.GetTranslation("Best Score") + ": N/A";
		holeIndex = data.publishID - 1;
		screenshot.texture = data.screenshot;
		this.difficulty = (Difficulty)data.difficulty;
		boss = false;
		int num = SaveFileManager.instance.saveFile.campaignHoleScore[holeIndex];
		if (this.difficulty == Difficulty.Easy)
		{
			parText.text = LocalizationManager.GetTranslation("Par") + ": " + data.par + " (" + LocalizationManager.GetTranslation("Complete Hole To Pass") + ")";
		}
		else if (this.difficulty == Difficulty.Medium)
		{
			parText.text = LocalizationManager.GetTranslation("Par") + ": " + data.par + " (" + string.Format(LocalizationManager.GetTranslation("Require {0} To Pass"), data.par + 3) + ")";
		}
		else if (this.difficulty == Difficulty.Hard)
		{
			parText.text = LocalizationManager.GetTranslation("Par") + ": " + data.par + " (" + string.Format(LocalizationManager.GetTranslation("Require {0} To Pass"), data.par + 2) + ")";
		}
		if (num == 0)
		{
			highScoreText.text = LocalizationManager.GetTranslation("Best Score") + ": N/A";
		}
		else
		{
			highScoreText.text = LocalizationManager.GetTranslation("Best Score") + ": " + num;
		}
		mapLevelsRenderer.material.SetFloat("_selectVal", 255f - (float)buttonIndex);
		StopAllCoroutines();
	}

	public virtual void SetBossCampaignPanel(CampaignHoleButton chb, int buttonIndex)
	{
		pickedCampaignHole = chb;
		holeIndex = 18;
		bossIndex = chb.holeIndex;
		data = chb.workshopData;
		difficultyText.text = "";
		highScoreText.text = "";
		screenshot.texture = data.screenshot;
		difficulty = chb.difficulty;
		boss = true;
		if (difficulty == Difficulty.Easy)
		{
			holeNameText.text = LocalizationManager.GetTranslation("Boss: Grugg");
		}
		else if (difficulty == Difficulty.Medium)
		{
			holeNameText.text = LocalizationManager.GetTranslation("Boss: Magician");
		}
		else if (difficulty == Difficulty.Hard)
		{
			holeNameText.text = LocalizationManager.GetTranslation("Boss: Reaper");
		}
		int num = SaveFileManager.instance.saveFile.bossScore[bossIndex];
		if (num == 0)
		{
			parText.text = LocalizationManager.GetTranslation("Best Score") + ": N/A";
		}
		else
		{
			parText.text = LocalizationManager.GetTranslation("Best Score") + ": " + num;
		}
		mapLevelsRenderer.material.SetFloat("_selectVal", 255f - (float)buttonIndex);
		StopAllCoroutines();
	}

	public void StartCampaign()
	{
		SetCampaignHoleData();
		ScoreManager.instance.SetCampaignHighScore();
		if (boss)
		{
			if (bossIndex == 0)
			{
				GameManager.instance.holeIndex = 18;
			}
			else if (bossIndex == 1)
			{
				GameManager.instance.holeIndex = 36;
			}
			else if (bossIndex == 2)
			{
				GameManager.instance.holeIndex = 54;
			}
		}
		else if (holeIndex < 18)
		{
			GameManager.instance.holeIndex = holeIndex;
		}
		else if (holeIndex >= 36)
		{
			GameManager.instance.holeIndex = holeIndex - 36;
		}
		else if (holeIndex >= 18)
		{
			GameManager.instance.holeIndex = holeIndex - 18;
		}
		ScoreManager.instance.SetHolePars();
		GameManager.instance.SetMulligans();
		if (GameManager.instance.hideBosses)
		{
			GameManager.instance.SwitchToScene("CustomHoleScene");
		}
		else if (boss)
		{
			if (bossIndex == 1)
			{
				GameManager.instance.SwitchToScene("Boss2 New Mechanic Test");
			}
			else
			{
				GameManager.instance.SwitchToScene("Boss" + (bossIndex + 1));
			}
		}
		else
		{
			GameManager.instance.SwitchToScene("CustomHoleScene");
		}
	}

	internal void SetCampaignHoleData()
	{
		GameManager.instance.holeData.Clear();
		GameManager.instance.gameMode = GameMode.Campaign;
		if (boss)
		{
			GameManager.instance.campaignDifficulty = bossHoles[bossIndex].difficulty;
		}
		else
		{
			GameManager.instance.campaignDifficulty = campaignHoles[holeIndex].difficulty;
		}
		if (!GameManager.instance.hideBosses)
		{
			int num = ScoreManager.instance.currentScoreCard.ReturnStartingCampaignHole();
			for (int i = 0; i < 18; i++)
			{
				GameManager.instance.holeData.Add(campaignHoles[num + i].workshopData);
			}
			switch (num)
			{
			case 0:
				GameManager.instance.holeData.Add(bossHoles[0].workshopData);
				break;
			case 18:
				GameManager.instance.holeData.Add(bossHoles[1].workshopData);
				break;
			case 36:
				GameManager.instance.holeData.Add(bossHoles[2].workshopData);
				break;
			}
		}
		else
		{
			int num2 = ScoreManager.instance.currentScoreCard.ReturnStartingCampaignHole();
			for (int j = 0; j < 18; j++)
			{
				GameManager.instance.holeData.Add(campaignHoles[num2 + j].workshopData);
			}
		}
	}

	public void SetCampaignHoleButtons()
	{
		CampaignHoleButton[] array = campaignHoles;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].CheckUnlockHole();
		}
	}

	internal void ShowMap()
	{
		int num = 0;
		int num2 = 0;
		SaveFile saveFile = SaveFileManager.instance.saveFile;
		if (GameManager.instance.unlockAllHoles)
		{
			num = 54;
		}
		else
		{
			for (int i = 0; i < 54; i++)
			{
				if (campaignHoles[i].difficulty == Difficulty.Easy)
				{
					if (saveFile.campaignHoleScore[i] > 0)
					{
						num++;
					}
				}
				else if (campaignHoles[i].difficulty == Difficulty.Medium)
				{
					if (saveFile.campaignHoleScore[i] <= campaignHoles[i].workshopData.par + 3 && saveFile.campaignHoleScore[i] != 0)
					{
						if (GameManager.instance.hideBosses)
						{
							num++;
						}
						else if (saveFile.bossScore[0] > 0)
						{
							num++;
						}
					}
				}
				else if (campaignHoles[i].difficulty == Difficulty.Hard && saveFile.campaignHoleScore[i] <= campaignHoles[i].workshopData.par + 2 && saveFile.campaignHoleScore[i] != 0)
				{
					if (GameManager.instance.hideBosses)
					{
						num++;
					}
					else if (saveFile.bossScore[1] > 0)
					{
						num++;
					}
				}
			}
		}
		if (num >= 54)
		{
			num2 = 3;
		}
		else if (num >= 36)
		{
			num2 = 2;
		}
		else if (num >= 18)
		{
			num2 = 1;
		}
		if (!GameManager.instance.hideBosses)
		{
			for (int j = 0; j < bossHoles.Length; j++)
			{
				if (j < num2)
				{
					bossHoles[j].CheckUnlockHole();
				}
			}
		}
		if (GameManager.instance.hideBosses)
		{
			num += num2;
		}
		else
		{
			int[] bossScore = saveFile.bossScore;
			for (int k = 0; k < bossScore.Length; k++)
			{
				if (bossScore[k] > 0)
				{
					num++;
				}
			}
		}
		mapLevelsRenderer.material.SetFloat("_alphaVal", (254.5f - (float)num) / 255f);
	}

	public void HighlightButton(int x)
	{
		mapLevelsRenderer.material.SetFloat("_highlightVal", 255f - (float)x);
	}

	public void UnHighlight()
	{
		mapLevelsRenderer.material.SetFloat("_highlightVal", 0f);
	}

	private void OnLocalizationCall()
	{
		if (boss)
		{
			if (this.difficulty == Difficulty.Easy)
			{
				holeNameText.text = LocalizationManager.GetTranslation("Boss: Grugg");
			}
			else if (this.difficulty == Difficulty.Medium)
			{
				holeNameText.text = LocalizationManager.GetTranslation("Boss: Magician");
			}
			else if (this.difficulty == Difficulty.Hard)
			{
				holeNameText.text = LocalizationManager.GetTranslation("Boss: Reaper");
			}
			int num = SaveFileManager.instance.saveFile.bossScore[bossIndex];
			if (num == 0)
			{
				parText.text = LocalizationManager.GetTranslation("Best Score") + ": N/A";
			}
			else
			{
				parText.text = LocalizationManager.GetTranslation("Best Score") + ": " + num;
			}
			return;
		}
		TextMeshPro textMeshPro = difficultyText;
		string translation = LocalizationManager.GetTranslation("Difficulty");
		Difficulty difficulty = (Difficulty)data.difficulty;
		textMeshPro.text = translation + ": " + LocalizationManager.GetTranslation(difficulty.ToString());
		highScoreText.text = LocalizationManager.GetTranslation("Best Score") + ": N/A";
		if (this.difficulty == Difficulty.Easy)
		{
			parText.text = LocalizationManager.GetTranslation("Par") + ": " + data.par + " (" + LocalizationManager.GetTranslation("Complete Hole To Pass") + ")";
		}
		else if (this.difficulty == Difficulty.Medium)
		{
			parText.text = LocalizationManager.GetTranslation("Par") + ": " + data.par + " (" + string.Format(LocalizationManager.GetTranslation("Require {0} To Pass"), data.par + 3) + ")";
		}
		else if (this.difficulty == Difficulty.Hard)
		{
			parText.text = LocalizationManager.GetTranslation("Par") + ": " + data.par + " (" + string.Format(LocalizationManager.GetTranslation("Require {0} To Pass"), data.par + 2) + ")";
		}
		int num2 = SaveFileManager.instance.saveFile.campaignHoleScore[holeIndex];
		if (num2 == 0)
		{
			highScoreText.text = LocalizationManager.GetTranslation("Best Score") + ": N/A";
		}
		else
		{
			highScoreText.text = LocalizationManager.GetTranslation("Best Score") + ": " + num2;
		}
	}
}
public class ClubProfileButton : MonoBehaviour
{
	public TextMeshProUGUI profileName;

	public TextMeshProUGUI height;

	public ClubProfile clubProfile = new ClubProfile();

	public void SetProfile(FileInfo file)
	{
		clubProfile.filePath = file.FullName;
		int bufferIndex = 0;
		byte[] buffer = File.ReadAllBytes(file.FullName);
		clubProfile.feet = kBufferUtil.ReadS32(ref buffer, ref bufferIndex);
		clubProfile.inches = kBufferUtil.ReadS32(ref buffer, ref bufferIndex);
		clubProfile.driverLength = kBufferUtil.ReadFloat(ref buffer, ref bufferIndex);
		clubProfile.ironLength = kBufferUtil.ReadFloat(ref buffer, ref bufferIndex);
		clubProfile.putterLength = kBufferUtil.ReadFloat(ref buffer, ref bufferIndex);
		int stringLength = kBufferUtil.ReadS32(ref buffer, ref bufferIndex);
		clubProfile.profileName = kBufferUtil.ReadString(ref buffer, ref bufferIndex, stringLength);
		height.text = clubProfile.feet + "' " + clubProfile.inches + "''";
		profileName.text = clubProfile.profileName;
	}

	public void LoadClubProfile()
	{
		if (GetComponentInParent<PauseMenu>() != null)
		{
			ScoreManager.instance.playerTurn[GameManager.instance.playerIndex].clubProfile = clubProfile;
			if (Player.instance.clubSwitcher.currentType == ClubType.Driver)
			{
				Player.instance.clubSwitcher.currentClub.clubScaler.SetClubLength(ClubType.Driver, clubProfile.driverLength);
			}
			else if (Player.instance.clubSwitcher.currentType == ClubType.Iron)
			{
				Player.instance.clubSwitcher.currentClub.clubScaler.SetClubLength(ClubType.Iron, clubProfile.ironLength);
			}
			else
			{
				Player.instance.clubSwitcher.currentClub.clubScaler.SetClubLength(ClubType.Putter, clubProfile.putterLength);
			}
			GameManager.instance.SetClubLength(clubProfile.filePath);
			GameManager.instance.pauseMenu.HighlightClubProfileButtons();
		}
		else if (GameManager.instance.currentSceneName == "MainMenu")
		{
			MainMenu.instance.clubProfileMenu.GetComponent<ClubLengthBasedOnHeight>().LoadClubProfile(clubProfile);
		}
	}
}
public class ClubTypePicker : PauseButton
{
	public ClubType type;

	public int index;

	public ClubTypePicker[] buttons;

	private void Start()
	{
		buttons = base.transform.parent.GetComponentsInChildren<ClubTypePicker>();
	}

	public void SetClub()
	{
		ClubTypePicker[] array = buttons;
		foreach (ClubTypePicker obj in array)
		{
			obj.stayHighlighted = false;
			obj.UnHighlight();
		}
		stayHighlighted = true;
		Highlight();
		if (type == ClubType.Driver)
		{
			Player.instance.clubSwitcher.driverType = (DriverType)index;
			Player.instance.clubSwitcher.SwitchToClubType(ClubType.Driver);
		}
		else if (type == ClubType.Iron)
		{
			Player.instance.clubSwitcher.ironType = (IronType)index;
			Player.instance.clubSwitcher.SwitchToClubType(ClubType.Iron);
		}
		else if (type == ClubType.Putter)
		{
			Player.instance.clubSwitcher.putterType = (PutterType)index;
			Player.instance.clubSwitcher.SwitchToClubType(ClubType.Putter);
		}
	}
}
public class ClubTypePickerCanvas : TextButton
{
	public ClubType type;

	public int index;

	public ClubTypePickerCanvas[] buttons;

	private Color unavailableColor = Color.gray;

	public AudioClip changeClubSFX;

	private AudioSource audioSource;

	private void Start()
	{
		buttons = base.transform.parent.GetComponentsInChildren<ClubTypePickerCanvas>();
		audioSource = GetComponent<AudioSource>();
	}

	private void OnEnable()
	{
		if (GameManager.instance.IsCloudlands1Hole())
		{
			DisableOnMinigolf();
			if (type == ClubType.Putter && index == (int)Player.instance.clubSwitcher.putterType)
			{
				stayHighlighted = true;
				Highlight();
			}
			return;
		}
		clickable = true;
		UnHighlight();
		if (type != Player.instance.clubSwitcher.currentType)
		{
			return;
		}
		if (type == ClubType.Driver)
		{
			if (index == (int)Player.instance.clubSwitcher.driverType)
			{
				stayHighlighted = true;
				Highlight();
			}
		}
		else if (type == ClubType.Iron)
		{
			if (index == (int)Player.instance.clubSwitcher.ironType)
			{
				stayHighlighted = true;
				Highlight();
			}
		}
		else if (type == ClubType.Putter && index == (int)Player.instance.clubSwitcher.putterType)
		{
			stayHighlighted = true;
			Highlight();
		}
	}

	public void SetClub()
	{
		ClubTypePickerCanvas[] array = buttons;
		foreach (ClubTypePickerCanvas obj in array)
		{
			obj.stayHighlighted = false;
			obj.UnHighlight();
		}
		stayHighlighted = true;
		Highlight();
		if (type == ClubType.Driver)
		{
			Player.instance.clubSwitcher.driverType = (DriverType)index;
			Player.instance.clubSwitcher.SwitchToClubType(ClubType.Driver);
			SaveFileManager.instance.saveFile.driverType = (DriverType)index;
		}
		else if (type == ClubType.Iron)
		{
			Player.instance.clubSwitcher.ironType = (IronType)index;
			Player.instance.clubSwitcher.SwitchToClubType(ClubType.Iron);
			SaveFileManager.instance.saveFile.ironType = (IronType)index;
		}
		else if (type == ClubType.Putter)
		{
			Player.instance.clubSwitcher.putterType = (PutterType)index;
			Player.instance.clubSwitcher.SwitchToClubType(ClubType.Putter);
			SaveFileManager.instance.saveFile.putterType = (PutterType)index;
		}
		GameManager.instance.pauseMenu.aSource.PlayOneShot(changeClubSFX);
		Player.instance.clubSwitcher.preventClubSwitchOnWarp = true;
		SaveFileManager.instance.SaveFile();
	}

	private void DisableOnMinigolf()
	{
		if (type != ClubType.Putter)
		{
			clickable = false;
			if (textUI != null)
			{
				textUI.color = unavailableColor;
			}
			else if (textMeshProUGUI != null)
			{
				textMeshProUGUI.color = unavailableColor;
			}
			else if (textMeshPro != null)
			{
				textMeshPro.color = unavailableColor;
			}
		}
	}
}
public class DeleteMenu : MonoBehaviour
{
	public ScrollList buttonScrollList;

	public GameObject holeButtonPrefab;

	public RectTransform usedAvailableHoleObjects;

	public List<GameObject> holeButtons = new List<GameObject>();

	private List<LocalFiles> localCL1HoleFiles = new List<LocalFiles>();

	private List<LocalFiles> localCL2HoleFiles = new List<LocalFiles>();

	private List<LocalFiles> localCL2PlaylistFiles = new List<LocalFiles>();

	public CurrentTag currentTag;

	public int currentCloudlandsVersion = 2;

	public int currentPage = 1;

	public int itemsPerPage = 20;

	public Text errorMsg;

	public GameObject pageNavigation;

	public Text pageText;

	public PointerButton pageBackButton;

	public PointerButton pageNextButton;

	private string downloadsDirectoryNoSlashes;

	public GameObject deleteBoardMenuScreen;

	public GameObject deleteSelectionScreen;

	public GameObject confirmDeleteOnlineScreen;

	public GameObject confirmDeleteLocalScreen;

	public GameObject deleteErrorScreen;

	public Text confirmDeleteOnlineConfirmMessage;

	public GameObject deleteUploadedItemMessage;

	public GameObject selectionButtons;

	public GameObject deleteAllLocalButtons;

	public Transform loadingCircle;

	public TabButton holesTab;

	public TabButton playlistsTab;

	public TabButton Cloudlands1Tab;

	public TabButton Cloudlands2Tab;

	private List<AvatarStore> avatarImages = new List<AvatarStore>();

	private List<ImageStore> screenshotImages = new List<ImageStore>();

	private string currentErrorMsg = "";

	private bool queryingServer;

	private GameObject pickedDeletebutton;

	private WorkshopData pickedWorkshopData;

	private Coroutine downloadScreenshotsCoroutine;

	private Coroutine downloadAvatarsCoroutine;

	private Thread thread;

	private string dataPath = "";

	private void OnEnable()
	{
		LocalizationManager.OnLocalizeEvent += OnLocalizationCall;
	}

	private void Start()
	{
		downloadsDirectoryNoSlashes = UnityEngine.Application.persistentDataPath.Replace("/", "").Replace("\\", "") + "Downloads";
	}

	private void Update()
	{
		if (loadingCircle.gameObject.activeSelf)
		{
			loadingCircle.localEulerAngles = new Vector3(0f, 0f, Time.time % 360f * 250f);
		}
	}

	public void OnDownloadedButton()
	{
		SelectHoles();
		Cloudlands1Tab.gameObject.SetActive(value: true);
		Cloudlands2Tab.gameObject.SetActive(value: true);
		deleteAllLocalButtons.SetActive(value: true);
		deleteUploadedItemMessage.SetActive(value: false);
	}

	public void OnCreatedButton()
	{
		currentCloudlandsVersion = 2;
		QueryUserCreatedHoles();
		playlistsTab.gameObject.SetActive(value: true);
		Cloudlands1Tab.gameObject.SetActive(value: false);
		Cloudlands2Tab.gameObject.SetActive(value: false);
		deleteAllLocalButtons.SetActive(value: false);
		deleteUploadedItemMessage.SetActive(value: true);
	}

	public void SelectHoles()
	{
		errorMsg.gameObject.SetActive(value: false);
		currentPage = 1;
		currentTag = CurrentTag.Holes;
		holesTab.Active(x: true);
		playlistsTab.Active(x: false);
		StopCoroutine(PopulatePlaylistList());
		if (queryingServer)
		{
			QueryUserCreatedHoles();
		}
		else
		{
			StartCoroutine(LoadAllLocalHoles());
		}
	}

	public void SelectPlaylists()
	{
		errorMsg.gameObject.SetActive(value: false);
		currentPage = 1;
		currentTag = CurrentTag.Playlists;
		holesTab.Active(x: false);
		playlistsTab.Active(x: true);
		StopCoroutine(PopulateHoleList());
		if (queryingServer)
		{
			QueryUserCreatedPlaylists();
			deleteAllLocalButtons.SetActive(value: false);
		}
		else
		{
			StartCoroutine(LoadAllLocalPlaylists());
			deleteAllLocalButtons.SetActive(value: true);
		}
	}

	public void OnCloudlandsVersion(int version)
	{
		ClearAvailableList();
		if (version == 1)
		{
			Cloudlands1Tab.Active(x: true);
			Cloudlands2Tab.Active(x: false);
		}
		else
		{
			Cloudlands1Tab.Active(x: false);
			Cloudlands2Tab.Active(x: true);
		}
		if (version == 1)
		{
			playlistsTab.gameObject.SetActive(value: false);
			holesTab.Active(x: true);
			currentTag = CurrentTag.Holes;
		}
		else
		{
			if (currentCloudlandsVersion == 1)
			{
				holesTab.Active(x: true);
			}
			playlistsTab.gameObject.SetActive(value: true);
		}
		if (currentTag == CurrentTag.Holes)
		{
			holesTab.Active(x: true);
			currentCloudlandsVersion = version;
			SelectHoles();
		}
		else if (currentTag == CurrentTag.Playlists)
		{
			playlistsTab.Active(x: true);
			currentCloudlandsVersion = 2;
			SelectPlaylists();
		}
	}

	public void QueryUserCreatedHoles()
	{
		ClearAvailableList();
		errorMsg.gameObject.SetActive(value: false);
		currentPage = 1;
		currentTag = CurrentTag.Holes;
		holesTab.Active(x: true);
		playlistsTab.Active(x: false);
		StopCoroutine(PopulatePlaylistList());
		deleteBoardMenuScreen.SetActive(value: false);
		deleteSelectionScreen.SetActive(value: true);
		queryingServer = true;
		loadingCircle.gameObject.SetActive(value: true);
		SearchFilters searchFilters = new SearchFilters();
		searchFilters.CloudlandsVersion = currentCloudlandsVersion;
		StartCoroutine(RemoteServerManager.instance.QueryUserHoles((uint)currentPage, searchFilters, delegate(bool complete)
		{
			if (complete)
			{
				CreateLevelsFromWorkshopData(RemoteServerManager.instance.workshopDetails);
				buttonScrollList.UpdateButtonColliders();
				SetPageButtons(RemoteServerManager.instance.workshopDetails.Count);
				List<HoleButton> list = new List<HoleButton>();
				foreach (Transform usedAvailableHoleObject in usedAvailableHoleObjects)
				{
					list.Add(usedAvailableHoleObject.GetComponent<HoleButton>());
				}
				GetAvatars(list);
				DownloadScreenshot(usedAvailableHoleObjects);
				SetHoleOrderNumber(usedAvailableHoleObjects);
			}
			else if (UnityEngine.Application.internetReachability == NetworkReachability.NotReachable)
			{
				errorMsg.text = LocalizationManager.GetTranslation("Could not connect to server. Please check internet connectivity or try again later.");
			}
			else
			{
				errorMsg.text = LocalizationManager.GetTranslation("Could not find any holes");
			}
			loadingCircle.gameObject.SetActive(value: false);
		}));
	}

	public void QueryUserCreatedPlaylists()
	{
		errorMsg.gameObject.SetActive(value: false);
		currentPage = 1;
		currentTag = CurrentTag.Playlists;
		holesTab.Active(x: false);
		playlistsTab.Active(x: true);
		StopCoroutine(PopulateHoleList());
		deleteBoardMenuScreen.SetActive(value: false);
		deleteSelectionScreen.SetActive(value: true);
		queryingServer = true;
		loadingCircle.gameObject.SetActive(value: true);
		SearchFilters searchFilters = new SearchFilters();
		searchFilters.CloudlandsVersion = 2;
		searchFilters.CloudlandsVersion = currentCloudlandsVersion;
		ClearAvailableList();
		StartCoroutine(RemoteServerManager.instance.QueryUserPlaylists((uint)currentPage, searchFilters, delegate(bool complete)
		{
			if (complete)
			{
				CreatePlaylistsFromWorkshopData(RemoteServerManager.instance.workshopDetails);
				buttonScrollList.UpdateButtonColliders();
				SetPageButtons(RemoteServerManager.instance.workshopDetails.Count);
				List<HoleButton> list = new List<HoleButton>();
				foreach (Transform usedAvailableHoleObject in usedAvailableHoleObjects)
				{
					list.Add(usedAvailableHoleObject.GetComponent<HoleButton>());
				}
				GetAvatars(list);
				DownloadScreenshot(usedAvailableHoleObjects);
				SetHoleOrderNumber(usedAvailableHoleObjects);
			}
			else if (UnityEngine.Application.internetReachability == NetworkReachability.NotReachable)
			{
				SetErrorMessage("Could not connect to server. Please check internet connectivity or try again later.");
			}
			else
			{
				SetErrorMessage("Could not find any playlists");
			}
			loadingCircle.gameObject.SetActive(value: false);
		}));
	}

	public void OpenDeleteBoard()
	{
		base.gameObject.SetActive(value: true);
		selectionButtons.SetActive(value: true);
		deleteBoardMenuScreen.SetActive(value: true);
		deleteSelectionScreen.SetActive(value: false);
		errorMsg.gameObject.SetActive(value: false);
		ClearAvailableList();
	}

	public void BackToEditorMenu()
	{
		deleteBoardMenuScreen.SetActive(value: false);
		MainMenu.instance.levelEditorMenu.SetActive(value: true);
	}

	public void OpenMainScreen()
	{
		if (GameManager.instance.publishedPlatform == PublishedPlatform.XR)
		{
			deleteBoardMenuScreen.SetActive(value: false);
			base.gameObject.SetActive(value: false);
			MainMenu.instance.OpenRootMenu();
		}
		else
		{
			deleteBoardMenuScreen.SetActive(value: true);
			selectionButtons.SetActive(value: true);
			deleteSelectionScreen.SetActive(value: false);
			errorMsg.gameObject.SetActive(value: false);
		}
		queryingServer = false;
		if (downloadScreenshotsCoroutine != null)
		{
			StopCoroutine(downloadScreenshotsCoroutine);
		}
		if (downloadAvatarsCoroutine != null)
		{
			StopCoroutine(downloadAvatarsCoroutine);
		}
	}

	private void ThreadedLocalPlaylists()
	{
		DirectoryInfo[] array = (from p in new DirectoryInfo(dataPath).GetDirectories()
			orderby p.CreationTimeUtc descending
			select p).ToArray();
		for (int i = 0; i < array.Length; i++)
		{
			FileInfo[] files = array[i].GetFiles("*");
			if (files.Length == 0)
			{
				continue;
			}
			LocalFiles localFiles = new LocalFiles();
			FileInfo[] array2 = files;
			foreach (FileInfo fileInfo in array2)
			{
				string extension = fileInfo.Extension;
				if (extension == ".clp")
				{
					localFiles.path = fileInfo.FullName;
				}
				else if (extension == ".jpg")
				{
					localFiles.jpgPath = fileInfo.FullName;
				}
			}
			localFiles.playlistData = CustomPlaylist.LoadPlaylistData(localFiles.path);
			if (currentCloudlandsVersion == 2)
			{
				localCL2PlaylistFiles.Add(localFiles);
			}
		}
		MonoBehaviour.print("Finished loading threaded playlists");
		thread.Abort();
		thread = null;
	}

	private IEnumerator LoadAllLocalPlaylists()
	{
		bool flag = true;
		if (currentCloudlandsVersion == 2 && localCL2PlaylistFiles.Count > 0)
		{
			flag = false;
		}
		if (flag)
		{
			selectionButtons.SetActive(value: false);
			loadingCircle.gameObject.SetActive(value: true);
			dataPath = UnityEngine.Application.persistentDataPath + "/Downloads/Cloudlands" + currentCloudlandsVersion + "/Playlists/";
			if (Directory.Exists(dataPath))
			{
				if (thread != null)
				{
					thread.Abort();
					thread = null;
				}
				thread = new Thread(ThreadedLocalPlaylists);
				thread.Start();
				while (thread.IsAlive)
				{
					yield return null;
				}
			}
			dataPath = UnityEngine.Application.persistentDataPath + "/playlists/";
			if (Directory.Exists(dataPath))
			{
				if (thread != null)
				{
					thread.Abort();
					thread = null;
				}
				thread = new Thread(ThreadedLocalPlaylists);
				thread.Start();
				while (thread.IsAlive)
				{
					yield return null;
				}
				loadingCircle.gameObject.SetActive(value: false);
			}
			else
			{
				loadingCircle.gameObject.SetActive(value: false);
			}
		}
		StartCoroutine(PopulatePlaylistList());
		deleteBoardMenuScreen.SetActive(value: false);
		selectionButtons.SetActive(value: true);
		deleteSelectionScreen.SetActive(value: true);
	}

	private IEnumerator PopulatePlaylistList()
	{
		List<LocalFiles> localPlaylistFiles = new List<LocalFiles>();
		if (currentCloudlandsVersion == 2)
		{
			localPlaylistFiles = localCL2PlaylistFiles;
		}
		yield return null;
		if (localPlaylistFiles.Count > 0)
		{
			ClearAvailableList();
			SetPageButtons(localPlaylistFiles.Count);
			List<HoleButton> list = new List<HoleButton>();
			int num = 0;
			for (int i = itemsPerPage * (currentPage - 1); i < itemsPerPage + itemsPerPage * (currentPage - 1) && i < localPlaylistFiles.Count; i++)
			{
				GameObject gameObject = holeButtons[num];
				num++;
				FillPlaylistButtonAndAddToPanel(gameObject, localPlaylistFiles[i]);
				list.Add(gameObject.GetComponent<HoleButton>());
			}
			GetAvatars(list);
			DownloadScreenshot(usedAvailableHoleObjects);
			SetHoleOrderNumber(usedAvailableHoleObjects);
		}
		else
		{
			SetErrorMessage("No downloaded playlists found");
		}
		StartCoroutine(ScrollToTop(buttonScrollList));
		deleteBoardMenuScreen.SetActive(value: false);
		deleteSelectionScreen.SetActive(value: true);
	}

	public void FillPlaylistButtonAndAddToPanel(GameObject button, LocalFiles lf)
	{
		button.GetComponent<HoleButton>().SetPlaylistData(HoleSelectPanel.CreateButtonFromPlaylistData(lf.playlistData, lf.path, lf.jpgPath));
		button.SetActive(value: true);
	}

	private void ThreadedLocalHoles()
	{
		DirectoryInfo[] array = (from p in new DirectoryInfo(dataPath).GetDirectories()
			orderby p.CreationTimeUtc descending
			select p).ToArray();
		for (int i = 0; i < array.Length; i++)
		{
			FileInfo[] files = array[i].GetFiles("*");
			if (files.Length == 0)
			{
				continue;
			}
			bool flag = false;
			CustomLevelCL1 customLevelCL = default(CustomLevelCL1);
			CustomLevel customLevel = default(CustomLevel);
			string path = "";
			string jpgPath = "";
			FileInfo[] array2 = files;
			foreach (FileInfo fileInfo in array2)
			{
				string extension = fileInfo.Extension;
				if (extension == ".dat")
				{
					path = fileInfo.FullName;
					if (currentCloudlandsVersion == 1)
					{
						customLevelCL = LevelEditor.LoadCL1LevelData(path);
						if (customLevelCL.valid)
						{
							flag = true;
						}
					}
					else
					{
						customLevel = LevelEditor.LoadLevelData(path);
						if (customLevel.valid)
						{
							flag = true;
						}
					}
				}
				else if (extension == ".jpg")
				{
					jpgPath = fileInfo.FullName;
				}
			}
			if (flag)
			{
				LocalFiles localFiles = new LocalFiles();
				localFiles.path = path;
				if (currentCloudlandsVersion == 1)
				{
					localFiles.customLevelCL1 = customLevelCL;
				}
				else
				{
					localFiles.customLevel = customLevel;
				}
				localFiles.jpgPath = jpgPath;
				if (currentCloudlandsVersion == 1)
				{
					localCL1HoleFiles.Add(localFiles);
				}
				else
				{
					localCL2HoleFiles.Add(localFiles);
				}
			}
		}
		MonoBehaviour.print("Finished loading threaded holes");
		thread.Abort();
		thread = null;
	}

	private IEnumerator LoadAllLocalHoles()
	{
		bool flag = true;
		if (currentCloudlandsVersion == 1 && localCL1HoleFiles.Count > 0)
		{
			flag = false;
		}
		else if (currentCloudlandsVersion == 2 && localCL2HoleFiles.Count > 0)
		{
			flag = false;
		}
		if (flag)
		{
			selectionButtons.SetActive(value: false);
			dataPath = UnityEngine.Application.persistentDataPath + "/Downloads/Cloudlands" + currentCloudlandsVersion + "/Holes/";
			if (Directory.Exists(dataPath))
			{
				loadingCircle.gameObject.SetActive(value: true);
				if (thread != null)
				{
					thread.Abort();
					thread = null;
				}
				thread = new Thread(ThreadedLocalHoles);
				thread.Start();
				while (thread.IsAlive)
				{
					yield return null;
				}
				loadingCircle.gameObject.SetActive(value: false);
			}
			else
			{
				loadingCircle.gameObject.SetActive(value: false);
			}
		}
		StartCoroutine(PopulateHoleList());
		deleteBoardMenuScreen.SetActive(value: false);
		selectionButtons.SetActive(value: true);
		deleteSelectionScreen.SetActive(value: true);
	}

	private IEnumerator PopulateHoleList()
	{
		new List<LocalFiles>();
		List<LocalFiles> localHoleFiles = ((currentCloudlandsVersion != 1) ? localCL2HoleFiles : localCL1HoleFiles);
		ClearAvailableList();
		yield return null;
		List<int> list = new List<int>();
		if (localHoleFiles.Count > 0)
		{
			SetPageButtons(localHoleFiles.Count);
			List<HoleButton> list2 = new List<HoleButton>();
			int num = 0;
			for (int i = itemsPerPage * (currentPage - 1); i < itemsPerPage + itemsPerPage * (currentPage - 1) && i < localHoleFiles.Count; i++)
			{
				GameObject gameObject = holeButtons[num];
				num++;
				FillHoleButtonAndAddToPanel(gameObject, localHoleFiles[i]);
				HoleButton component = gameObject.GetComponent<HoleButton>();
				list.Add(component.workshopData.publishID);
				list2.Add(component);
			}
			DownloadScreenshot(usedAvailableHoleObjects);
			GetAvatars(list2);
		}
		else
		{
			SetErrorMessage("No downloaded holes found");
		}
		StartCoroutine(ScrollToTop(buttonScrollList));
		SearchFilters searchFilters = new SearchFilters();
		searchFilters.CloudlandsVersion = currentCloudlandsVersion;
		SetHoleOrderNumber(usedAvailableHoleObjects);
		RemoteServerManager.instance.queryPlaylistHolesCoroutine = StartCoroutine(RemoteServerManager.instance.QueryPlaylistHoles(list, showAllHoles: false, searchFilters, delegate
		{
			SetButtonRatings(usedAvailableHoleObjects);
		}));
	}

	private void FillHoleButtonAndAddToPanel(GameObject button, LocalFiles lf)
	{
		if (currentCloudlandsVersion == 1)
		{
			button.GetComponent<HoleButton>().SetHoleData(HoleSelectPanel.CreateButtonFromCustomLevelCL1(lf.customLevelCL1, lf.path, lf.jpgPath));
		}
		else
		{
			button.GetComponent<HoleButton>().SetHoleData(HoleSelectPanel.CreateButtonFromCustomLevel(lf.customLevel, lf.path, lf.jpgPath));
		}
		button.SetActive(value: true);
	}

	private IEnumerator ScrollToTop(ScrollList list)
	{
		yield return new WaitForEndOfFrame();
		list.sr.verticalNormalizedPosition = 1f;
		list.UpdateButtonColliders();
	}

	private void ClearAvailableList()
	{
		foreach (Transform usedAvailableHoleObject in usedAvailableHoleObjects)
		{
			WorkshopData workshopData = usedAvailableHoleObject.GetComponent<HoleButton>().workshopData;
			if (workshopData.screenshot != null)
			{
				UnityEngine.Object.DestroyImmediate(workshopData.screenshot);
			}
			if (workshopData.avatar != null)
			{
				UnityEngine.Object.DestroyImmediate(workshopData.avatar);
			}
			usedAvailableHoleObject.gameObject.SetActive(value: false);
		}
	}

	public void SetPageButtons(int numTotal)
	{
		if (numTotal <= itemsPerPage)
		{
			pageNavigation.SetActive(value: false);
			buttonScrollList.sr.GetComponent<RectTransform>().anchorMin = new Vector2(0f, 0f);
			pageText.text = "1/1";
			return;
		}
		int num = Mathf.CeilToInt((float)numTotal / (float)itemsPerPage);
		pageNavigation.SetActive(value: true);
		buttonScrollList.sr.GetComponent<RectTransform>().anchorMin = new Vector2(0f, 0.16f);
		pageText.text = currentPage + "/" + num;
		if (currentPage == num)
		{
			pageNextButton.gameObject.SetActive(value: false);
			pageBackButton.gameObject.SetActive(value: true);
		}
		else if (currentPage == 1)
		{
			pageNextButton.gameObject.SetActive(value: true);
			pageBackButton.gameObject.SetActive(value: false);
		}
		else
		{
			pageNextButton.gameObject.SetActive(value: true);
			pageBackButton.gameObject.SetActive(value: true);
		}
	}

	public void SetErrorMessage(string x)
	{
		errorMsg.gameObject.SetActive(value: true);
		currentErrorMsg = x;
		errorMsg.text = LocalizationManager.GetTranslation(x);
		pageNavigation.SetActive(value: false);
	}

	public void DeleteItem(HoleButton tb)
	{
		if (queryingServer)
		{
			OpenConfirmDeleteMenu(tb);
			return;
		}
		string text = "";
		List<LocalFiles> list = new List<LocalFiles>();
		if (currentTag == CurrentTag.Holes)
		{
			list = ((currentCloudlandsVersion != 1) ? localCL2HoleFiles : localCL1HoleFiles);
		}
		else if (currentTag == CurrentTag.Playlists && currentCloudlandsVersion == 2)
		{
			list = localCL2PlaylistFiles;
		}
		text = tb.workshopData.fileLocation;
		if (text.Replace("/", "").Replace("\\", "").Contains(downloadsDirectoryNoSlashes))
		{
			Directory.Delete(new FileInfo(text).Directory.FullName, recursive: true);
		}
		int num = Mathf.Min(list.Count, itemsPerPage * currentPage);
		for (int i = itemsPerPage * (currentPage - 1); i < num; i++)
		{
			if (text == list[i].path)
			{
				list.RemoveAt(i);
				break;
			}
		}
		if (list.Count > currentPage * itemsPerPage)
		{
			int index = currentPage * itemsPerPage - 1;
			if (currentTag == CurrentTag.Holes)
			{
				FillHoleButtonAndAddToPanel(tb.gameObject, list[index]);
			}
			else if (currentTag == CurrentTag.Playlists)
			{
				FillPlaylistButtonAndAddToPanel(tb.gameObject, list[index]);
			}
		}
		tb.gameObject.SetActive(value: false);
		if (currentPage > 1 && (currentPage - 1) * itemsPerPage >= list.Count)
		{
			OnPageBackButton();
		}
		SetPageButtons(list.Count);
		buttonScrollList.UpdateButtonColliders();
		SetHoleOrderNumber(usedAvailableHoleObjects);
	}

	public void OpenDeleteAllLocalScreen()
	{
		deleteSelectionScreen.SetActive(value: false);
		confirmDeleteLocalScreen.SetActive(value: true);
	}

	public void DeleteAllLocal()
	{
		if (currentTag == CurrentTag.Holes)
		{
			dataPath = UnityEngine.Application.persistentDataPath + "/Downloads/Cloudlands" + currentCloudlandsVersion + "/Holes/";
			if (!Directory.Exists(dataPath))
			{
				return;
			}
			DirectoryInfo[] directories = new DirectoryInfo(dataPath).GetDirectories();
			if (directories.Length == 0)
			{
				return;
			}
			for (int i = 0; i < directories.Length; i++)
			{
				if (directories[i].GetFiles("*.dat").Length != 0 && directories[i].FullName.Replace("/", "").Replace("\\", "").Contains(downloadsDirectoryNoSlashes))
				{
					Directory.Delete(directories[i].FullName, recursive: true);
				}
			}
			SetErrorMessage("Successfully deleted all downloaded holes");
			BackToDeleteSelectionMenu();
			ClearAvailableList();
			return;
		}
		string path = UnityEngine.Application.persistentDataPath + "/Downloads/Cloudlands" + currentCloudlandsVersion + "/Playlists/";
		if (!Directory.Exists(path))
		{
			return;
		}
		DirectoryInfo[] directories2 = new DirectoryInfo(path).GetDirectories();
		if (directories2.Length == 0)
		{
			return;
		}
		for (int j = 0; j < directories2.Length; j++)
		{
			if (directories2[j].GetFiles("*.clp").Length != 0 && directories2[j].FullName.Replace("/", "").Replace("\\", "").Contains(downloadsDirectoryNoSlashes))
			{
				Directory.Delete(directories2[j].FullName, recursive: true);
			}
		}
		SetErrorMessage("Successfully deleted all downloaded playlists");
		BackToDeleteSelectionMenu();
		ClearAvailableList();
	}

	public void OnPageNextButton()
	{
		currentPage++;
		if (currentTag == CurrentTag.Holes)
		{
			StartCoroutine(PopulateHoleList());
		}
		else if (currentTag == CurrentTag.Playlists)
		{
			StartCoroutine(PopulatePlaylistList());
		}
		StartCoroutine(ScrollToTop(buttonScrollList));
	}

	public void OnPageBackButton()
	{
		currentPage--;
		if (currentTag == CurrentTag.Holes)
		{
			StartCoroutine(PopulateHoleList());
		}
		else if (currentTag == CurrentTag.Playlists)
		{
			StartCoroutine(PopulatePlaylistList());
		}
		StartCoroutine(ScrollToTop(buttonScrollList));
	}

	private void GetAvatars(List<HoleButton> tb)
	{
		if (downloadAvatarsCoroutine != null)
		{
			StopCoroutine(downloadAvatarsCoroutine);
		}
		downloadAvatarsCoroutine = StartCoroutine(_GetAvatars(tb));
	}

	private void DownloadScreenshot(RectTransform list)
	{
		if (downloadScreenshotsCoroutine != null)
		{
			StopCoroutine(downloadScreenshotsCoroutine);
		}
		downloadScreenshotsCoroutine = StartCoroutine(_DownloadScreenshot(list));
	}

	private IEnumerator _GetAvatars(List<HoleButton> tb)
	{
		for (int i = 0; i < tb.Count; i++)
		{
			bool foundAvatar = false;
			for (int j = 0; j < avatarImages.Count; j++)
			{
				if (avatarImages[j].uid == tb[i].workshopData.creatorID)
				{
					Texture2D texture2D = new Texture2D(0, 0, TextureFormat.RGB24, mipChain: false);
					texture2D.LoadImage(avatarImages[j].jpgData);
					tb[i].profilePicture.sprite = Sprite.Create(texture2D, new Rect(0f, 0f, texture2D.width, texture2D.height), new Vector2(0.5f, 0.5f), 100f, 0u, SpriteMeshType.FullRect);
					tb[i].workshopData.avatar = texture2D;
					foundAvatar = true;
					yield return null;
					break;
				}
			}
			if (foundAvatar)
			{
				continue;
			}
			string startingID = tb[i].workshopData.creatorID;
			bool downloadingAvatar = true;
			if (tb[i].workshopData.publishPlatform == 0)
			{
				StartCoroutine(RemoteServerManager.instance.GetSteamUser(tb[i].workshopData.creatorID, delegate(string complete)
				{
					if (string.IsNullOrEmpty(complete))
					{
						downloadingAvatar = false;
					}
					else
					{
						StartCoroutine(RemoteServerManager.instance.GetAvatarSprite(complete, delegate(byte[] complete2)
						{
							if (complete2 != null)
							{
								if (startingID == tb[i].workshopData.creatorID)
								{
									Texture2D texture2D3 = new Texture2D(0, 0, TextureFormat.RGB24, mipChain: false);
									texture2D3.LoadImage(complete2);
									tb[i].profilePicture.sprite = Sprite.Create(texture2D3, new Rect(0f, 0f, texture2D3.width, texture2D3.height), new Vector2(0.5f, 0.5f), 100f, 0u, SpriteMeshType.FullRect);
									tb[i].workshopData.avatar = texture2D3;
									avatarImages.Add(new AvatarStore(startingID, complete2));
									complete2 = null;
								}
								downloadingAvatar = false;
							}
							else
							{
								downloadingAvatar = false;
							}
						}));
					}
				}));
			}
			else if (tb[i].workshopData.publishPlatform == 1)
			{
				StartCoroutine(RemoteServerManager.instance.GetOculusUser(tb[i].workshopData.creatorID, tb[i].workshopData.cloudlandsVersion, delegate
				{
				}, delegate(string profileImage)
				{
					StartCoroutine(RemoteServerManager.instance.GetAvatarSprite(profileImage, delegate(byte[] complete2)
					{
						if (complete2 != null)
						{
							if (startingID == tb[i].workshopData.creatorID)
							{
								Texture2D texture2D2 = new Texture2D(0, 0, TextureFormat.RGB24, mipChain: false);
								texture2D2.LoadImage(complete2);
								tb[i].profilePicture.sprite = Sprite.Create(texture2D2, new Rect(0f, 0f, texture2D2.width, texture2D2.height), new Vector2(0.5f, 0.5f), 100f, 0u, SpriteMeshType.FullRect);
								tb[i].workshopData.avatar = texture2D2;
								avatarImages.Add(new AvatarStore(startingID, complete2));
								complete2 = null;
							}
							downloadingAvatar = false;
						}
						else
						{
							downloadingAvatar = false;
						}
					}));
				}));
			}
			else
			{
				downloadingAvatar = false;
			}
			while (downloadingAvatar)
			{
				yield return null;
			}
		}
	}

	private IEnumerator _DownloadScreenshot(RectTransform list)
	{
		bool flag = true;
		while (flag)
		{
			for (int i = 0; i < list.childCount; i++)
			{
				HoleButton button = list.GetChild(i).GetComponent<HoleButton>();
				if (!(button.workshopData.screenshot == null) || button.workshopData.defaultHole)
				{
					continue;
				}
				bool local = button.workshopData.localItem;
				bool imageFound = false;
				if (!local)
				{
					for (int j = 0; j < screenshotImages.Count; j++)
					{
						if (screenshotImages[j].uid == button.workshopData.publishID && screenshotImages[j].isHole == button.isHole)
						{
							button.workshopData.screenshot = new Texture2D(0, 0, TextureFormat.RGB24, mipChain: false);
							button.workshopData.screenshot.LoadImage(screenshotImages[j].jpgData);
							button.screenshot.texture = button.workshopData.screenshot;
							imageFound = true;
							yield return null;
							break;
						}
					}
				}
				if (imageFound)
				{
					continue;
				}
				string imageLocation = button.workshopData.imageLocation;
				string text = "";
				if (local)
				{
					text = "file:///";
				}
				int startingID = button.workshopData.publishID;
				bool startingLocal = local;
				bool isHole = button.isHole;
				WWW www = new WWW(text + imageLocation);
				yield return www;
				if (startingID == button.workshopData.publishID)
				{
					if (button.workshopData.screenshot != null)
					{
						UnityEngine.Object.DestroyImmediate(button.workshopData.screenshot);
					}
					if (string.IsNullOrEmpty(www.error))
					{
						button.workshopData.screenshot = new Texture2D(0, 0, TextureFormat.RGB24, mipChain: false);
						byte[] bytes = www.bytes;
						if (!local)
						{
							ImageStore imageStore = new ImageStore(button.workshopData.publishID, isHole, button.workshopData.cloudlandsVersion, bytes);
							screenshotImages.Add(imageStore);
							if (isHole)
							{
								StartCoroutine(UpdatePickedListScreenshots(imageStore));
							}
							else
							{
								StartCoroutine(UpdatePlaylistPreviewListScreenshots(imageStore));
							}
						}
						button.workshopData.screenshot.LoadImage(bytes);
						button.UpdateScreenshot();
					}
				}
				else if (!startingLocal && string.IsNullOrEmpty(www.error))
				{
					_ = www.bytes;
					ImageStore imageStore2 = new ImageStore(startingID, isHole, button.workshopData.cloudlandsVersion, www.bytes);
					screenshotImages.Add(imageStore2);
					if (isHole)
					{
						StartCoroutine(UpdatePickedListScreenshots(imageStore2));
					}
					else
					{
						StartCoroutine(UpdatePlaylistPreviewListScreenshots(imageStore2));
					}
				}
				www.Dispose();
			}
			flag = false;
		}
	}

	private IEnumerator UpdatePickedListScreenshots(ImageStore imgS)
	{
		for (int x = 0; x < 2; x++)
		{
			for (int i = 0; i < usedAvailableHoleObjects.childCount; i++)
			{
				HoleButton component = usedAvailableHoleObjects.GetChild(i).GetComponent<HoleButton>();
				if (component.workshopData.screenshot == null && component.workshopData.publishID == imgS.uid)
				{
					component.workshopData.screenshot = new Texture2D(0, 0, TextureFormat.RGB24, mipChain: false);
					component.workshopData.screenshot.LoadImage(imgS.jpgData);
					component.UpdateScreenshot();
				}
			}
			yield return null;
		}
	}

	private IEnumerator UpdatePlaylistPreviewListScreenshots(ImageStore imgS)
	{
		for (int x = 0; x < 2; x++)
		{
			for (int i = 0; i < usedAvailableHoleObjects.childCount; i++)
			{
				HoleButton component = usedAvailableHoleObjects.GetChild(i).GetComponent<HoleButton>();
				if (component.workshopData.screenshot == null && component.workshopData.publishID == imgS.uid && component.isHole == imgS.isHole)
				{
					component.workshopData.screenshot = new Texture2D(0, 0, TextureFormat.RGB24, mipChain: false);
					component.workshopData.screenshot.LoadImage(imgS.jpgData);
					component.UpdateScreenshot();
				}
			}
			yield return null;
		}
	}

	private void CreateLevelsFromWorkshopData(List<WorkshopData> data)
	{
		if (data.Count > 0)
		{
			for (int i = 0; i < data.Count; i++)
			{
				holeButtons[i].SetActive(value: true);
				SetHoleButton(holeButtons[i], data[i], usedAvailableHoleObjects);
			}
		}
		else
		{
			SetErrorMessage("Could not find any holes");
		}
	}

	private void CreatePlaylistsFromWorkshopData(List<WorkshopData> data)
	{
		if (data.Count > 0)
		{
			for (int i = 0; i < data.Count; i++)
			{
				holeButtons[i].SetActive(value: true);
				holeButtons[i].GetComponent<HoleButton>().SetPlaylistData(data[i]);
			}
		}
		else
		{
			SetErrorMessage("Could not find any playlists");
		}
	}

	private void SetHoleButton(GameObject button, WorkshopData holeData, Transform parent, bool duplicate = false)
	{
		button.GetComponent<HoleButton>().SetHoleData(holeData, duplicate);
		button.transform.SetParent(parent);
		button.SetActive(value: true);
	}

	public void BackToDeleteSelectionMenu()
	{
		deleteSelectionScreen.SetActive(value: true);
		confirmDeleteLocalScreen.SetActive(value: false);
		confirmDeleteOnlineScreen.SetActive(value: false);
		deleteErrorScreen.SetActive(value: false);
		pickedDeletebutton = null;
		pickedWorkshopData = null;
	}

	private void OpenDeleteErrorMenu()
	{
		confirmDeleteLocalScreen.SetActive(value: false);
		confirmDeleteOnlineScreen.SetActive(value: false);
		deleteErrorScreen.SetActive(value: true);
	}

	private void OpenConfirmDeleteMenu(HoleButton hb)
	{
		pickedDeletebutton = hb.gameObject;
		pickedWorkshopData = HoleButton.DeepCopyWorkshopData(hb.workshopData);
		confirmDeleteOnlineScreen.SetActive(value: true);
		deleteSelectionScreen.SetActive(value: false);
		if (currentTag == CurrentTag.Holes)
		{
			confirmDeleteOnlineConfirmMessage.text = LocalizationManager.GetTranslation("Are you sure you want to remove the hole from online? Players that have already downloaded your hole can still play.");
		}
		else
		{
			confirmDeleteOnlineConfirmMessage.text = LocalizationManager.GetTranslation("Are you sure you want to remove the playlist from online? Players that have already downloaded your playlist can still play.");
		}
	}

	public void ConfirmDeleteOnline()
	{
		loadingCircle.gameObject.SetActive(value: true);
		if (currentTag == CurrentTag.Holes)
		{
			StartCoroutine(RemoteServerManager.instance.RemoveHole(pickedWorkshopData.publishID, delegate(bool complete)
			{
				if (complete)
				{
					loadingCircle.gameObject.SetActive(value: false);
					pickedDeletebutton.gameObject.SetActive(value: false);
					BackToDeleteSelectionMenu();
					QueryUserCreatedHoles();
					if (usedAvailableHoleObjects.childCount == 1)
					{
						SetErrorMessage("Could not find any holes");
					}
				}
				else
				{
					OpenDeleteErrorMenu();
				}
			}));
			return;
		}
		StartCoroutine(RemoteServerManager.instance.RemovePlaylist(pickedWorkshopData.publishID, delegate(bool complete)
		{
			if (complete)
			{
				loadingCircle.gameObject.SetActive(value: false);
				pickedDeletebutton.gameObject.SetActive(value: false);
				BackToDeleteSelectionMenu();
				QueryUserCreatedPlaylists();
				if (usedAvailableHoleObjects.childCount == 1)
				{
					SetErrorMessage("Could not find any playlists");
				}
			}
			else
			{
				OpenDeleteErrorMenu();
			}
		}));
	}

	private void SetButtonRatings(RectTransform list)
	{
		for (int i = 0; i < list.childCount; i++)
		{
			HoleButton component = list.GetChild(i).GetComponent<HoleButton>();
			for (int j = 0; j < RemoteServerManager.instance.workshopDetails.Count; j++)
			{
				if (component.workshopData.publishID == RemoteServerManager.instance.workshopDetails[j].publishID)
				{
					component.workshopData.upvotes = RemoteServerManager.instance.workshopDetails[j].upvotes;
					component.workshopData.downvotes = RemoteServerManager.instance.workshopDetails[j].downvotes;
					component.SetRatings(component.workshopData.upvotes, component.workshopData.downvotes);
					component.localItemText.SetActive(value: false);
				}
			}
		}
	}

	private void SetHoleOrderNumber(RectTransform list)
	{
		int num = (currentPage - 1) * itemsPerPage + 1;
		foreach (RectTransform item in list)
		{
			HoleButton component = item.GetComponent<HoleButton>();
			if (component != null && component.gameObject.activeSelf && !component.isError)
			{
				component.SetHoleNumber(num);
				num++;
			}
		}
	}

	private void OnApplicationQuit()
	{
		if (thread != null)
		{
			thread.Abort();
			MonoBehaviour.print("DeleteMenu Thread Aborted: " + !thread.IsAlive);
			thread = null;
		}
	}

	private void OnDisable()
	{
		LocalizationManager.OnLocalizeEvent -= OnLocalizationCall;
		if (thread != null)
		{
			thread.Abort();
			MonoBehaviour.print("DeleteMenu Thread Aborted: " + !thread.IsAlive);
			thread = null;
		}
	}

	private void OnLocalizationCall()
	{
		if (errorMsg.gameObject.activeSelf)
		{
			MonoBehaviour.print(currentErrorMsg);
			errorMsg.text = LocalizationManager.GetTranslation(currentErrorMsg);
		}
	}
}
public class MainMenu : MonoBehaviour
{
	public static MainMenu instance;

	public GameObject rootMenu;

	public GameObject rootMenuWithoutEditor;

	public GameObject playMenu;

	public GameObject quickPlayMenu;

	public GameObject nineHolesMenu;

	public GameObject playerCountMenu;

	public GameObject singlePlayerGameModeMenu;

	public GameObject localMultiplayerGameModeMenu;

	public GameObject levelEditorMenu;

	public GameObject onlineOrOfflineMenu;

	public GameObject campaignMenu;

	public GameObject storeMenu;

	public GameObject clubProfileMenu;

	public GameObject confirmMenu;

	public GameObject creditsMenu;

	public DeleteMenu deleteMenu;

	public Dictionary<string, RoomInfo> cachedRoomList = new Dictionary<string, RoomInfo>();

	private int playerCount = 1;

	public GolfballSpawner puttingGreenSpawnPos;

	public GolfballSpawner drivingRangeSpawnPos;

	public Transform spawnPos;

	public GameObject pointerLineActivation;

	public GameObject[] obTriggers;

	private bool respawningBall;

	private void Awake()
	{
		instance = this;
	}

	public void Update()
	{
	}

	public void Perm()
	{
		UnityEngine.Debug.LogError("******************* perm: " + Permission.HasUserAuthorizedPermission("android.permission.RECORD_AUDIO"));
		if (!Permission.HasUserAuthorizedPermission("android.permission.RECORD_AUDIO"))
		{
			Permission.RequestUserPermission("android.permission.RECORD_AUDIO");
		}
	}

	private void Start()
	{
		if (Player.instance != null)
		{
			Player.instance.editorTools.SetActive(value: false);
			if (GameManager.instance.controllerType == ControllerType.XR && !GameManager.instance.hasRecenteredXRController)
			{
				GameManager.instance.hasRecenteredXRController = true;
			}
		}
		GameManager.instance.gameMode = GameMode.None;
		GameObject[] array = obTriggers;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: false);
		}
		if (GameManager.instance.publishedPlatform == PublishedPlatform.XR)
		{
			OpenMenu(rootMenuWithoutEditor);
		}
		else
		{
			OpenMenu(rootMenu);
		}
		if (GameManager.instance.finishedCampaign)
		{
			GameManager.instance.finishedCampaign = false;
			GameManager.instance.SetShowedFinishedCampaignMessage(x: true);
			GameManager.instance.SpawnMainMenuNotification("Congratulations. You have completed the campaign!");
		}
	}

	public void GoToScene(string scene)
	{
		GameManager.instance.SwitchToScene(scene, 1f);
	}

	public void OpenMenu(GameObject menu)
	{
		rootMenu.SetActive(value: false);
		rootMenuWithoutEditor.SetActive(value: false);
		playMenu.SetActive(value: false);
		quickPlayMenu.SetActive(value: false);
		nineHolesMenu.SetActive(value: false);
		playerCountMenu.SetActive(value: false);
		singlePlayerGameModeMenu.SetActive(value: false);
		localMultiplayerGameModeMenu.SetActive(value: false);
		levelEditorMenu.SetActive(value: false);
		onlineOrOfflineMenu.SetActive(value: false);
		campaignMenu.SetActive(value: false);
		storeMenu.SetActive(value: false);
		clubProfileMenu.SetActive(value: false);
		confirmMenu.SetActive(value: false);
		creditsMenu.SetActive(value: false);
		menu.SetActive(value: true);
	}

	public void OnLocalMultiplayerButton(int players)
	{
		playerCount = players;
		if (players == 1)
		{
			OpenMenu(singlePlayerGameModeMenu);
		}
		else
		{
			OpenMenu(localMultiplayerGameModeMenu);
		}
	}

	public void OnCustomButton()
	{
		GameManager.instance.gameMode = GameMode.Custom;
		GameManager.instance.playerCount = playerCount;
		GameManager.instance.BackToRoomPrepScene();
	}

	public void OnCreateLevelsButton()
	{
		GameManager.instance.playerCount = 1;
		GameManager.instance.SwitchToScene("LevelEditor");
	}

	public void OnOnlineButton()
	{
		if (UnityEngine.Application.internetReachability == NetworkReachability.NotReachable)
		{
			Notification.instance.AddNotification("An internet connection is required to play online. Please check your internet settings.", 0f, closeButton: true);
			return;
		}
		GameManager.instance.playerCount = 1;
		GameManager.instance.BackToLobby();
	}

	public void OnCampaignButton()
	{
		SaveFileManager.instance.LoadSaveFile();
		OpenMenu(campaignMenu);
		if (SaveFileManager.instance.playerID == "Guest")
		{
			Notification.instance.AddNotification("You are not logged in. Please check your internet connection or restart the game. Guest save file used", 9999f, closeButton: true);
		}
	}

	private void CreatePlaylistData(string mode, Difficulty difficulty)
	{
		GameManager.instance.holeData.Clear();
		List<int> list = new List<int>();
		if (mode == "Random9")
		{
			GameManager.instance.gameMode = GameMode.NineHoles;
			switch (difficulty)
			{
			case Difficulty.Easy:
				list = GameManager.instance.GenerateRandomNumbers(9, 0, 18);
				break;
			case Difficulty.Medium:
				list = GameManager.instance.GenerateRandomNumbers(9, 19, 35);
				break;
			case Difficulty.Hard:
				list = GameManager.instance.GenerateRandomNumbers(9, 36, 54);
				break;
			}
		}
		else if (mode == "Full18")
		{
			GameManager.instance.gameMode = GameMode.Full18;
			list = GameManager.instance.GenerateRandomNumbers(6, 0, 18);
			list.AddRange(GameManager.instance.GenerateRandomNumbers(6, 19, 36));
			list.AddRange(GameManager.instance.GenerateRandomNumbers(6, 37, 54));
		}
		for (int i = 0; i < list.Count; i++)
		{
			GameManager.instance.holeData.Add(GameManager.instance.campaignWorkshopData[list[i]]);
		}
	}

	public void OnStartEasyHoles(string mode)
	{
		CreatePlaylistData(mode, Difficulty.Easy);
		ScoreManager.instance.SetHolePars();
		GameManager.instance.SetMulligans();
		GameManager.instance.playerCount = playerCount;
		GameManager.instance.SwitchToScene("CustomHoleScene");
	}

	public void OnStartMediumHoles(string mode)
	{
		CreatePlaylistData(mode, Difficulty.Medium);
		ScoreManager.instance.SetHolePars();
		GameManager.instance.SetMulligans();
		GameManager.instance.playerCount = playerCount;
		GameManager.instance.SwitchToScene("CustomHoleScene");
	}

	public void OnStartHardHoles(string mode)
	{
		CreatePlaylistData(mode, Difficulty.Hard);
		ScoreManager.instance.SetHolePars();
		GameManager.instance.SetMulligans();
		GameManager.instance.playerCount = playerCount;
		GameManager.instance.SwitchToScene("CustomHoleScene");
	}

	public void On18HoleChallenge()
	{
		CreatePlaylistData("Full18", Difficulty.Easy);
		ScoreManager.instance.SetHolePars();
		GameManager.instance.SetMulligans();
		GameManager.instance.playerCount = playerCount;
		GameManager.instance.SwitchToScene("CustomHoleScene");
	}

	public void OnStartRandomAllDifficulty()
	{
		GameManager.instance.gameMode = GameMode.NineHoles;
		GameManager.instance.holeData.Clear();
		List<int> list = new List<int>();
		list.AddRange(GameManager.instance.GenerateRandomNumbers(9, 0, 54));
		for (int i = 0; i < list.Count; i++)
		{
			GameManager.instance.holeData.Add(GameManager.instance.campaignWorkshopData[list[i]]);
		}
		ScoreManager.instance.SetHolePars();
		GameManager.instance.SetMulligans();
		GameManager.instance.playerCount = playerCount;
		GameManager.instance.SwitchToScene("CustomHoleScene");
	}

	public void OnPuttingGreenButton()
	{
		pointerLineActivation.SetActive(value: false);
		Player.instance.transform.position = puttingGreenSpawnPos.transform.position;
		Player.instance.SwitchToClub();
		Player.instance.clubSwitcher.SwitchToClubType(ClubType.Putter);
		StartCoroutine(puttingGreenSpawnPos.SpawnBall());
		GameObject[] array = obTriggers;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: true);
		}
	}

	public void OnDrivingRangeButton()
	{
		pointerLineActivation.SetActive(value: false);
		Player.instance.transform.position = drivingRangeSpawnPos.transform.position;
		Player.instance.SwitchToClub();
		Player.instance.clubSwitcher.SwitchToClubType(ClubType.Driver);
		StartCoroutine(drivingRangeSpawnPos.SpawnBall());
		GameObject[] array = obTriggers;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: true);
		}
	}

	public void OnTutorialButton()
	{
		GameManager.instance.SwitchToScene("Tutorial");
	}

	public void OnBackToMainMenuButton()
	{
		pointerLineActivation.SetActive(value: true);
		Player.instance.transform.position = spawnPos.position;
		Player.instance.currentController.SwitchToPointer();
		UnityEngine.Object.Destroy(UnityEngine.Object.FindObjectOfType<Golfball>().gameObject);
		GameObject[] array = obTriggers;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: false);
		}
	}

	private IEnumerator CreateRoom()
	{
		PhotonManager.instance.Connect();
		while (PhotonNetwork.NetworkClientState != ClientState.JoinedLobby)
		{
			yield return null;
		}
		PhotonNetwork.JoinLobby();
		while (!PhotonNetwork.InLobby)
		{
			yield return null;
		}
		RoomHelper.CreateRoom();
		while (!PhotonNetwork.InRoom)
		{
			yield return null;
		}
		PhotonNetwork.LocalPlayer.NickName = RemoteServerManager.instance.playerUserName;
		PhotonNetwork.InstantiateSceneObject("RoomRPC", Vector3.zero, Quaternion.identity, 0);
		if (GameManager.instance.gameMode == GameMode.Custom)
		{
			GameManager.instance.BackToRoomPrepScene();
		}
	}

	public void RespawnBallToDrivingRange()
	{
		if (!respawningBall)
		{
			respawningBall = true;
			StartCoroutine(_RespawnBallToDrivingRange());
		}
	}

	private IEnumerator _RespawnBallToDrivingRange()
	{
		Golfball ball = GameManager.instance.golfball;
		if (ball != null)
		{
			yield return new WaitForSeconds(2f);
			ball.transform.position = drivingRangeSpawnPos.transform.position;
			ball.DestroyTrailRenderer();
		}
		respawningBall = false;
	}

	public void ExitGame()
	{
		StartCoroutine(GameManager.instance._ExitGame());
	}

	public void OnBackToGameModeMenu()
	{
		if (playerCount == 1)
		{
			OpenMenu(singlePlayerGameModeMenu);
		}
		else
		{
			OpenMenu(localMultiplayerGameModeMenu);
		}
	}

	public void OpenDeleteHolesMenu()
	{
		if (GameManager.instance.publishedPlatform == PublishedPlatform.XR)
		{
			rootMenuWithoutEditor.SetActive(value: false);
			deleteMenu.gameObject.SetActive(value: true);
			deleteMenu.OnDownloadedButton();
		}
		else
		{
			levelEditorMenu.SetActive(value: false);
			deleteMenu.OpenDeleteBoard();
		}
	}

	public void OpenRootMenu()
	{
		OpenMenu(rootMenu);
	}
}
public class MutePlayerMenu : MonoBehaviour
{
	public Text[] playerNames;

	public GameObject[] players;

	private List<PhotonView> pViews = new List<PhotonView>();

	private int playerCount = -1;

	public Color activeColor;

	private void OnEnable()
	{
		GetPView();
		ChangeDescription();
	}

	private void Update()
	{
		if (playerCount != PhotonNetwork.PlayerList.Length)
		{
			playerCount = PhotonNetwork.PlayerList.Length;
			GetPView();
			UpdateMuteList();
		}
	}

	private void UpdateMuteList()
	{
		for (int i = 0; i < 3; i++)
		{
			players[i].SetActive(value: false);
		}
		for (int j = 0; j < PhotonNetwork.PlayerList.Length - 1; j++)
		{
			players[j].SetActive(value: true);
		}
		int num = 0;
		foreach (PhotonView pView in pViews)
		{
			if (!pView.IsMine)
			{
				playerNames[num].text = pView.Owner.NickName;
				num++;
			}
		}
	}

	private void ChangeDescription()
	{
		int num = 0;
		foreach (PhotonView pView in pViews)
		{
			if (!pView.IsMine)
			{
				if (pView.GetComponent<AudioSource>().enabled)
				{
					playerNames[num].color = activeColor;
					playerNames[num].text = pView.Owner.NickName;
				}
				else
				{
					playerNames[num].color = Color.gray;
					playerNames[num].text = pView.Owner.NickName + " (" + LocalizationManager.GetTranslation("muted") + ")";
				}
				num++;
			}
		}
	}

	public void OnBackButton()
	{
		GameManager.instance.pauseMenu.SwitchToMicrophoneMenu();
	}

	public void MutePlayer(int x)
	{
		foreach (PhotonView pView in pViews)
		{
			if (!pView.IsMine)
			{
				if (!pView.GetComponent<PhotonAvatarView>().muted)
				{
					pView.GetComponent<PhotonAvatarView>().muted = true;
					playerNames[x].color = Color.gray;
					playerNames[x].text = pView.Owner.NickName + " (" + LocalizationManager.GetTranslation("muted") + ")";
				}
				else
				{
					pView.GetComponent<PhotonAvatarView>().muted = false;
					playerNames[x].color = activeColor;
					playerNames[x].text = pView.Owner.NickName;
				}
			}
		}
	}

	private void GetPView()
	{
		pViews.Clear();
		Speaker[] array = UnityEngine.Object.FindObjectsOfType<Speaker>();
		foreach (Speaker speaker in array)
		{
			pViews.Add(speaker.GetComponent<PhotonView>());
		}
	}
}
public class PauseMenu : MonoBehaviour
{
	[HideInInspector]
	public delegate void ConfirmFunction();

	public bool paused;

	public bool allowPausing = true;

	private int distanceToBall = 1;

	[Header("=====Menus=====")]
	public GameObject mainPauseMenu;

	public GameObject settingsMenu;

	public GameObject audioMenu;

	public GameObject languageMenu;

	public GameObject controlSettingsMenu;

	public GameObject gameplaySettingsMenu;

	public GameObject kickMenu;

	public GameObject microphoneMenu;

	public GameObject muteMenu;

	public GameObject confirmMenu;

	public GameObject itemMenu;

	public GameObject levelEditorMenu;

	public GameObject clubPowerMenu;

	public GameObject clubAngleMenu;

	public GameObject bossMenu;

	public Transform scoreCardTransform;

	public Transform scoreCardTransformBoss;

	[Header("=====Buttons=====")]
	public GameObject backToMainMenuButtonObject;

	public GameObject backToLobbyButtonObject;

	public GameObject concedeButtonObject;

	public GameObject mulliganButtonObject;

	public GameObject holeInfoButtonObject;

	public GameObject kickButtonObject;

	public GameObject microphoneButtonObject;

	public GameObject restartHoleButtonObject;

	public GameObject clubPowerButtonObject;

	public GameObject changeClubOnWarpButtonObject;

	public GameObject aimLineButtonObject;

	public GameObject distanceToBallButtonObject;

	public GameObject warpOrientationButtonObject;

	public GameObject editorPreviewRestartHoleButtonObject;

	public TextButton concedeButton;

	public TextButton mulliganButton;

	public TextButton kickButton;

	public TextButton microphoneButton;

	public TextButton muteButton;

	public GridLayoutGroup gridLayout;

	[Header("=====Text=====")]
	public Text mulliganText;

	public Text concedeText;

	public Text musicText;

	public Text sfxText;

	public Text ambientText;

	public Text kickText;

	public Text micStateText;

	public Text muteText;

	public Text handedText;

	public Text constrainedText;

	public Text warpToCenterText;

	public Text warpInAirText;

	public Text rotateDirectionText;

	public Text warpOrientationText;

	public Text distanceToBallText;

	public Text ballTrailText;

	public Text touchpadText;

	public Text clubChangeText;

	public Text clubAngleText;

	public Text greenSlopeLinesText;

	public Text clubShadowText;

	public Text showPuttLineText;

	[Header("=====Kicking Players=====")]
	public GameObject[] onlinePlayers;

	private int kickedPlayer;

	private Photon.Realtime.Player[] playerInfo;

	[Header("=====Club Profiles=====")]
	public GameObject clubProfileParent;

	public Transform clubProfilebuttonContainer;

	public GameObject clubProfileButtonPrefab;

	private FileInfo[] clubLengthProfiles;

	private List<GameObject> clubProfileButtons = new List<GameObject>();

	private ConfirmFunction confirmFunc;

	public Text confirmText;

	public AudioClip openSFX;

	[HideInInspector]
	public AudioSource aSource;

	private ControllerMode savedMode;

	public Transform tutorialBoardAnchors;

	public static event Action onPaused;

	public static event Action onUnpaused;

	public static event Action onMicTextChange;

	private void OnEnable()
	{
		MicBoard.onMicTextChange += ChangeMicText;
		LocalizationManager.OnLocalizeEvent += OnLocalizationCall;
	}

	private void OnDisable()
	{
		MicBoard.onMicTextChange -= ChangeMicText;
		LocalizationManager.OnLocalizeEvent -= OnLocalizationCall;
	}

	private void Start()
	{
		aSource = GetComponent<AudioSource>();
		if (GameManager.instance.publishedPlatform == PublishedPlatform.XR)
		{
			clubProfileParent.SetActive(value: false);
		}
		GetAllClubLengthProfiles();
		CloseAllMenus();
		if (PlayerPrefs.GetFloat("MusicVolume") == -80f)
		{
			ToggleMusic();
		}
		if (PlayerPrefs.GetFloat("SFXVolume") == -80f)
		{
			ToggleSFX();
		}
		if (PlayerPrefs.GetFloat("AmbientVolume") == -80f)
		{
			ToggleAmbient();
		}
		if (PlayerPrefs.GetInt("InvertedRotation", 0) == 1)
		{
			ToggleRotateDirection();
		}
		if (PlayerPrefs.GetInt("WarpOrientationLookAtHole", 0) == 1)
		{
			ToggleWarpOrientation();
		}
		if (Player.instance.currentController.constrainedSwing)
		{
			ToggleDistanceToBall();
			ToggleDistanceToBall();
		}
		else if (PlayerPrefs.GetInt("DistanceToBall", 1) == 0)
		{
			ToggleDistanceToBall();
			ToggleDistanceToBall();
		}
		else if (PlayerPrefs.GetInt("DistanceToBall", 1) == 2)
		{
			ToggleDistanceToBall();
		}
		if (!PlayerPrefsX.GetBool("TouchpadHelperEnabled", defaultValue: true))
		{
			Player.instance.currentController.touchLocationIndicator.transform.parent.gameObject.SetActive(value: false);
		}
	}

	private void Update()
	{
		if (Player.instance.currentControllerInput.startButton.wasPressed || (GameManager.instance.controllerType == ControllerType.FPS && Input.GetKeyDown(KeyCode.P)))
		{
			if (GameManager.instance.quickMenu.menu.activeSelf)
			{
				GameManager.instance.quickMenu.menu.SetActive(value: false);
			}
			if (paused)
			{
				if (mainPauseMenu.activeSelf || levelEditorMenu.activeSelf || bossMenu.activeSelf)
				{
					TogglePause();
				}
				else if (controlSettingsMenu.activeSelf || gameplaySettingsMenu.activeSelf || languageMenu.activeSelf || audioMenu.activeSelf)
				{
					OpenMenu(settingsMenu);
				}
				else if (muteMenu.activeSelf)
				{
					OpenMenu(microphoneMenu);
				}
				else if (clubPowerMenu.activeSelf)
				{
					OpenMenu(gameplaySettingsMenu);
				}
				else if (clubAngleMenu.activeSelf)
				{
					OpenMenu(controlSettingsMenu);
					SaveFileManager.instance.SaveFile();
					Player.instance.clubs.SetActive(value: false);
				}
				else if (GameManager.instance.currentSceneName == "LevelEditor")
				{
					OpenMenu(levelEditorMenu);
				}
				else if (GameManager.instance.currentSceneName.Contains("Boss"))
				{
					SwitchToBossMenu();
				}
				else
				{
					SwitchToMainPauseMenu();
				}
			}
			else if (allowPausing)
			{
				TogglePause();
			}
		}
		if (TutorialManager.instance != null)
		{
			if (gameplaySettingsMenu.activeSelf || controlSettingsMenu.activeSelf)
			{
				tutorialBoardAnchors.localPosition = new Vector3(0f, 1.2f, 0.3f);
				tutorialBoardAnchors.localEulerAngles = new Vector3(20f, 0f, 0f);
			}
			else if (confirmMenu.activeSelf)
			{
				tutorialBoardAnchors.localPosition = new Vector3(0f, 1.35f, 0.3f);
				tutorialBoardAnchors.localEulerAngles = new Vector3(20f, 0f, 0f);
			}
			else if (clubAngleMenu.activeSelf)
			{
				tutorialBoardAnchors.localPosition = new Vector3(0f, 0.8f, 0.05f);
				tutorialBoardAnchors.localEulerAngles = new Vector3(10f, 0f, 0f);
			}
			else
			{
				tutorialBoardAnchors.localPosition = new Vector3(0f, 1f, 0.3f);
				tutorialBoardAnchors.localEulerAngles = new Vector3(20f, 0f, 0f);
			}
		}
	}

	public void SwitchToMuteMenu()
	{
		CloseAllMenus();
		muteMenu.SetActive(value: true);
	}

	public void TogglePause()
	{
		if (GameManager.instance.loadingLevel)
		{
			return;
		}
		if (GameManager.instance.currentSceneName == "LevelEditor" || GameManager.instance.currentSceneName == "LevelEditorArt")
		{
			if (!paused)
			{
				SwitchToEditorPauseMenu();
				GameManager.instance.CenterNotification(base.gameObject);
				Player.instance.currentController.SwitchToPointer();
				paused = true;
				if (PauseMenu.onPaused != null)
				{
					PauseMenu.onPaused();
				}
			}
			else
			{
				Resume();
			}
		}
		else
		{
			if (!(GameManager.instance.currentSceneName != "Splash"))
			{
				return;
			}
			aSource.PlayOneShot(openSFX);
			if (!paused)
			{
				GameManager.instance.CenterNotification(base.gameObject);
				Player.instance.currentController.SwitchToPointer();
				paused = true;
				if (PauseMenu.onPaused != null)
				{
					PauseMenu.onPaused();
				}
				if (GameManager.instance.currentSceneName.Contains("Boss"))
				{
					SwitchToBossMenu();
				}
				else
				{
					SwitchToRootMenu();
				}
				if (Player.instance.currentController.constrainedSwing)
				{
					savedMode = Player.instance.currentController.controllerMode;
					Player.instance.currentController.SwitchControllerMode(ControllerMode.FollowMode);
				}
				ScoreManager.instance.currentScoreCard.ToggleScoreCard(x: true);
				SetMulliganCount();
				if (PhotonNetwork.IsConnected && playerInfo != PhotonNetwork.PlayerListOthers && kickMenu.activeSelf)
				{
					UpdateKickList();
				}
				if (TutorialManager.instance != null)
				{
					TutorialManager.instance.PauseOpened();
				}
			}
			else
			{
				Resume();
			}
		}
	}

	public void CloseAllMenus()
	{
		mainPauseMenu.SetActive(value: false);
		settingsMenu.SetActive(value: false);
		audioMenu.SetActive(value: false);
		languageMenu.SetActive(value: false);
		controlSettingsMenu.SetActive(value: false);
		gameplaySettingsMenu.SetActive(value: false);
		kickMenu.SetActive(value: false);
		microphoneMenu.SetActive(value: false);
		muteMenu.SetActive(value: false);
		confirmMenu.SetActive(value: false);
		itemMenu.SetActive(value: false);
		levelEditorMenu.SetActive(value: false);
		clubPowerMenu.SetActive(value: false);
		clubAngleMenu.SetActive(value: false);
		bossMenu.SetActive(value: false);
	}

	public void OpenMenu(GameObject menu)
	{
		CloseAllMenus();
		menu.SetActive(value: true);
	}

	public void HighlightClubProfileButtons()
	{
		foreach (Transform item in clubProfilebuttonContainer)
		{
			ClubProfileButton component = item.GetComponent<ClubProfileButton>();
			if (component.clubProfile.filePath == GameManager.instance.GetClubProfile().filePath)
			{
				component.GetComponent<TextButton>().stayHighlighted = true;
				component.GetComponent<TextButton>().Highlight();
			}
			else
			{
				component.GetComponent<TextButton>().stayHighlighted = false;
				component.GetComponent<TextButton>().UnHighlight();
			}
		}
	}

	private void SwitchToBossMenu()
	{
		OpenMenu(bossMenu);
		if (ScoreManager.instance.currentScoreCard.transform.parent != GameManager.instance.pauseMenu.scoreCardTransformBoss)
		{
			ScoreManager.instance.currentScoreCard.transform.SetParent(GameManager.instance.pauseMenu.scoreCardTransformBoss);
			ScoreManager.instance.currentScoreCard.transform.localPosition = Vector3.zero;
			ScoreManager.instance.currentScoreCard.transform.localRotation = Quaternion.identity;
		}
	}

	public void SwitchToRootMenu()
	{
		if (GameManager.instance.currentSceneName.Contains("Boss"))
		{
			SwitchToBossMenu();
			return;
		}
		SwitchToMainPauseMenu();
		if (ScoreManager.instance.currentScoreCard.transform.parent != GameManager.instance.pauseMenu.scoreCardTransform)
		{
			ScoreManager.instance.currentScoreCard.transform.SetParent(GameManager.instance.pauseMenu.scoreCardTransform);
			ScoreManager.instance.currentScoreCard.transform.localPosition = Vector3.zero;
			ScoreManager.instance.currentScoreCard.transform.localRotation = Quaternion.identity;
		}
	}

	public void SwitchToMainPauseMenu()
	{
		CloseAllMenus();
		GetAllClubLengthProfiles();
		if (PhotonNetwork.IsConnected)
		{
			ShowOnlineMenuOptions();
		}
		else
		{
			ChangeGridLayoutSize(1);
			kickButtonObject.SetActive(value: false);
			microphoneButtonObject.SetActive(value: false);
			HighlightClubProfileButtons();
		}
		if (GameManager.instance.currentSceneName == "LevelEditor")
		{
			SwitchToEditorPauseMenu();
			return;
		}
		if (GameManager.instance.currentSceneName == "MainMenu")
		{
			backToMainMenuButtonObject.SetActive(value: false);
			backToLobbyButtonObject.SetActive(value: false);
			concedeButtonObject.SetActive(value: false);
			mulliganButtonObject.SetActive(value: false);
			holeInfoButtonObject.SetActive(value: false);
			restartHoleButtonObject.SetActive(value: false);
		}
		else if (GameManager.instance.currentSceneName == "RoomPrepScene")
		{
			if (PhotonNetwork.IsConnected)
			{
				backToLobbyButtonObject.SetActive(value: true);
				backToMainMenuButtonObject.SetActive(value: false);
			}
			else
			{
				backToLobbyButtonObject.SetActive(value: false);
				backToMainMenuButtonObject.SetActive(value: true);
			}
			concedeButtonObject.SetActive(value: false);
			mulliganButtonObject.SetActive(value: false);
			holeInfoButtonObject.SetActive(value: false);
			restartHoleButtonObject.SetActive(value: false);
		}
		else if (GameManager.instance.currentSceneName.Contains("Hole"))
		{
			if (PhotonNetwork.IsConnected)
			{
				backToLobbyButtonObject.SetActive(value: true);
				backToMainMenuButtonObject.SetActive(value: false);
				holeInfoButtonObject.SetActive(value: true);
				concedeButtonObject.SetActive(value: true);
				restartHoleButtonObject.SetActive(value: false);
			}
			else
			{
				backToLobbyButtonObject.SetActive(value: false);
				if (GameManager.instance.gameMode == GameMode.Campaign)
				{
					restartHoleButtonObject.SetActive(value: true);
					concedeButtonObject.SetActive(value: false);
				}
				else
				{
					restartHoleButtonObject.SetActive(value: false);
					concedeButtonObject.SetActive(value: true);
				}
				backToMainMenuButtonObject.SetActive(value: true);
				holeInfoButtonObject.SetActive(value: true);
			}
			mulliganButtonObject.SetActive(value: true);
		}
		else if (GameManager.instance.currentSceneName == "Tutorial")
		{
			backToMainMenuButtonObject.SetActive(value: true);
			backToLobbyButtonObject.SetActive(value: false);
			concedeButtonObject.SetActive(value: false);
			mulliganButtonObject.SetActive(value: true);
			kickButtonObject.SetActive(value: false);
			microphoneButtonObject.SetActive(value: false);
			holeInfoButtonObject.SetActive(value: false);
			mulliganButtonObject.SetActive(value: true);
			restartHoleButtonObject.SetActive(value: false);
		}
		else
		{
			if (PhotonNetwork.InRoom)
			{
				backToLobbyButtonObject.SetActive(value: true);
				backToMainMenuButtonObject.SetActive(value: false);
			}
			else
			{
				backToLobbyButtonObject.SetActive(value: false);
				backToMainMenuButtonObject.SetActive(value: true);
			}
			concedeButtonObject.SetActive(value: false);
			mulliganButtonObject.SetActive(value: false);
			holeInfoButtonObject.SetActive(value: false);
			restartHoleButtonObject.SetActive(value: false);
		}
		mainPauseMenu.SetActive(value: true);
		GameObject nearestHoleFromPos = GameManager.instance.GetNearestHoleFromPos(Player.instance.transform.position);
		if (ScoreManager.instance.ballScored || nearestHoleFromPos == null)
		{
			concedeButton.clickable = false;
			concedeButton.Greyed();
		}
		else
		{
			concedeButton.clickable = true;
			concedeButton.UnHighlight();
		}
	}

	public void ShowOnlineMenuOptions()
	{
		microphoneButtonObject.SetActive(value: true);
		if (PhotonNetwork.InRoom && GameManager.instance.currentSceneName != "LobbyScene")
		{
			kickButtonObject.SetActive(value: true);
		}
		else
		{
			kickButtonObject.SetActive(value: false);
		}
		if (GameManager.instance.currentSceneName == "CustomHoleScene")
		{
			ChangeGridLayoutSize(1);
		}
		else
		{
			ChangeGridLayoutSize(1);
		}
		if (PhotonNetwork.IsMasterClient)
		{
			if (PhotonManager.instance.GetUsablePlayers(includeSelf: false).Count == 0)
			{
				kickButton.clickable = false;
				kickButton.Greyed();
			}
			else
			{
				kickButton.clickable = true;
				kickButton.UnHighlight();
			}
		}
		else
		{
			kickButton.clickable = false;
			kickButton.Greyed();
		}
	}

	public void SwitchToSettingsMenu()
	{
		OpenMenu(settingsMenu);
	}

	public void SwitchToControllerSettingsMenu()
	{
		if (clubAngleMenu.activeSelf)
		{
			_ = GameManager.instance.controllerType;
			_ = 4;
		}
		OpenMenu(controlSettingsMenu);
		Player.instance.clubs.SetActive(value: false);
		bool activeSelf = Player.instance.currentController.touchLocationIndicator.transform.parent.gameObject.activeSelf;
		string translation = LocalizationManager.GetTranslation("Touchpad");
		if (GameManager.instance.controllerType == ControllerType.Quest)
		{
			translation = LocalizationManager.GetTranslation("Joystick");
		}
		if (activeSelf)
		{
			touchpadText.text = translation + " " + LocalizationManager.GetTranslation("Helper: Visible");
		}
		else
		{
			touchpadText.text = translation + " " + LocalizationManager.GetTranslation("Helper: Hidden");
		}
		bool handedness = GameManager.instance.GetHandedness();
		if (Player.instance.currentController.constrainedSwing)
		{
			constrainedText.text = LocalizationManager.GetTranslation("Swing Style: Constrained");
		}
		else
		{
			constrainedText.text = LocalizationManager.GetTranslation("Swing Style: Free");
		}
		if (handedness)
		{
			handedText.text = LocalizationManager.GetTranslation("Handedness: Right Handed");
		}
		else
		{
			handedText.text = LocalizationManager.GetTranslation("Handedness: Left Handed");
		}
		if (GameManager.instance.player.GetComponent<Player>().ToggleRotateDirection())
		{
			rotateDirectionText.text = LocalizationManager.GetTranslation("Rotation: Inverted");
		}
		else
		{
			rotateDirectionText.text = LocalizationManager.GetTranslation("Rotation: Standard");
		}
		SaveFileManager.instance.SaveFile();
	}

	public void SwitchToGameplaySettingsMenu()
	{
		OpenMenu(gameplaySettingsMenu);
		if (GameManager.instance.GetBallTrail())
		{
			ballTrailText.text = LocalizationManager.GetTranslation("Ball Trail: On");
		}
		else
		{
			ballTrailText.text = LocalizationManager.GetTranslation("Ball Trail: Off");
		}
		if (GameManager.instance.GetClubChangeOnWarp())
		{
			clubChangeText.text = LocalizationManager.GetTranslation("Change Club On Warp: On");
		}
		else
		{
			clubChangeText.text = LocalizationManager.GetTranslation("Change Club On Warp: Off");
		}
		if (GameManager.instance.GetGreenSlopeLines())
		{
			greenSlopeLinesText.text = LocalizationManager.GetTranslation("Green Slope Lines: On");
		}
		else
		{
			greenSlopeLinesText.text = LocalizationManager.GetTranslation("Green Slope Lines: Off");
		}
		if (GameManager.instance.GetClubShadows())
		{
			clubShadowText.text = LocalizationManager.GetTranslation("Club Shadows: On");
		}
		else
		{
			clubShadowText.text = LocalizationManager.GetTranslation("Club Shadows: Off");
		}
		if (GameManager.instance.GetWarpToCenter())
		{
			warpToCenterText.text = LocalizationManager.GetTranslation("Warp: Center Of Play Space");
		}
		else if (Player.instance.currentController.constrainedSwing)
		{
			warpToCenterText.text = LocalizationManager.GetTranslation("Warp: Head Position");
		}
		else
		{
			warpToCenterText.text = LocalizationManager.GetTranslation("Warp: Last Hit Position");
		}
		if (GameManager.instance.GetWarpInAir())
		{
			warpInAirText.text = LocalizationManager.GetTranslation("Warp Mid-Air: On");
		}
		else
		{
			warpInAirText.text = LocalizationManager.GetTranslation("Warp Mid-Air: Off");
		}
		if (Player.instance.currentController.constrainedSwing)
		{
			aimLineButtonObject.SetActive(value: true);
			distanceToBallButtonObject.SetActive(value: false);
			changeClubOnWarpButtonObject.SetActive(value: false);
			if (distanceToBall == 0)
			{
				distanceToBallText.text = LocalizationManager.GetTranslation("Distance To Ball: Near");
			}
			else if (distanceToBall == 1)
			{
				distanceToBallText.text = LocalizationManager.GetTranslation("Distance To Ball: Normal");
			}
			else
			{
				distanceToBallText.text = LocalizationManager.GetTranslation("Distance To Ball: Far");
			}
			if (PlayerPrefsX.GetBool("ShowAimLine", defaultValue: true))
			{
				showPuttLineText.text = LocalizationManager.GetTranslation("Aim Line: Visible");
			}
			else
			{
				showPuttLineText.text = LocalizationManager.GetTranslation("Aim Line: Hidden");
			}
		}
		else
		{
			aimLineButtonObject.SetActive(value: false);
			distanceToBallButtonObject.SetActive(value: false);
			changeClubOnWarpButtonObject.SetActive(value: true);
		}
		if (TutorialManager.instance != null)
		{
			TutorialManager.instance.PauseOpened();
		}
	}

	public void SwitchToEditorPauseMenu()
	{
		Player.instance.editorGrabber.GoingToPauseMenu();
		OpenMenu(levelEditorMenu);
		if (LevelEditor.instance.previewing)
		{
			editorPreviewRestartHoleButtonObject.SetActive(value: true);
		}
		else
		{
			editorPreviewRestartHoleButtonObject.SetActive(value: false);
		}
	}

	public void Resume()
	{
		if (GameManager.instance.currentSceneName == "LevelEditor" || GameManager.instance.currentSceneName == "LevelEditorArt")
		{
			if (LevelEditor.instance != null && LevelEditor.instance.previewing)
			{
				Player.instance.currentController.SwitchToClubs();
				Player.instance.clubSwitcher.ResetClubVelocities();
			}
			else
			{
				Player.instance.currentController.SwitchToPointer();
			}
		}
		else if (Player.instance.currentController.constrainedSwing)
		{
			Player.instance.currentController.SwitchToClubs();
			if (!ScoreManager.instance.ballScored)
			{
				Player.instance.currentController.SwitchControllerMode(savedMode);
			}
			else
			{
				Player.instance.currentController.SwitchControllerMode(ControllerMode.FollowMode);
			}
			Player.instance.clubSwitcher.ResetClubVelocities();
		}
		else if (Player.instance.currentController.pointerLineActivationInScene)
		{
			Player.instance.currentController.SwitchToPointer();
		}
		else
		{
			Player.instance.currentController.SwitchToClubs();
			Player.instance.clubSwitcher.ResetClubVelocities();
		}
		CloseAllMenus();
		paused = false;
		if (PauseMenu.onUnpaused != null)
		{
			PauseMenu.onUnpaused();
		}
		if (TutorialManager.instance != null)
		{
			TutorialManager.instance.PauseClosed();
		}
	}

	public void Concede()
	{
		ShowConfirm(_Concede, "Concede and receive double par?");
	}

	private void _Concede()
	{
		GameManager.instance.Concede();
		CloseAllMenus();
		Player.instance.currentController.SwitchToClubs();
		paused = false;
	}

	public void Mulligan()
	{
		if (ScoreManager.instance.playerTurn[GameManager.instance.playerIndex].mulligansLeft <= 0 && !ScoreManager.instance.playerTurn[GameManager.instance.playerIndex].infiniteMulligan && GameManager.instance.gameMode != GameMode.Campaign)
		{
			ShowConfirm(SetInfiniteMulligan, "Infinite Mulligans? You will not be able to upload your score online.");
			return;
		}
		GameManager.instance.Mulligan();
		CloseAllMenus();
		Player.instance.currentController.SwitchToClubs();
		paused = false;
	}

	private void SetInfiniteMulligan()
	{
		ScoreManager.instance.playerTurn[GameManager.instance.playerIndex].infiniteMulligan = true;
		Mulligan();
	}

	private void SetMulliganCount()
	{
		if (GameManager.instance.canMulligan)
		{
			if (ScoreManager.instance.playerTurn[GameManager.instance.playerIndex].infiniteMulligan)
			{
				mulliganText.text = LocalizationManager.GetTranslation("Mulligans: Infinite Mulligans");
				mulliganButton.clickable = true;
				mulliganButton.UnHighlight();
				return;
			}
			if (ScoreManager.instance.playerTurn[GameManager.instance.playerIndex].mulligansLeft <= 0 && GameManager.instance.playerCount == 1 && !PhotonNetwork.IsConnected && !GameManager.instance.IsPlaylist())
			{
				mulliganText.text = LocalizationManager.GetTranslation("Mulligans: Infinite Mulligans") + "?";
				mulliganButton.clickable = true;
				mulliganButton.UnHighlight();
				return;
			}
			if (GameManager.instance.currentSceneName == "Tutorial")
			{
				mulliganText.text = LocalizationManager.GetTranslation("Mulligans: Infinite Mulligans");
				mulliganButton.clickable = true;
				mulliganButton.UnHighlight();
				return;
			}
			mulliganButton.clickable = true;
			mulliganButton.UnHighlight();
			if (PhotonNetwork.IsConnected || GameManager.instance.gameMode != 0)
			{
				mulliganText.text = string.Format(LocalizationManager.GetTranslation("Mulligans {0} remaining"), ScoreManager.instance.playerTurn[GameManager.instance.playerIndex].mulligansLeft);
			}
			mulliganButton.clickable = true;
		}
		else
		{
			mulliganButton.Greyed();
			if (ScoreManager.instance.playerTurn[GameManager.instance.playerIndex].mulligansLeft <= 0)
			{
				mulliganText.text = LocalizationManager.GetTranslation("Mulligans: None Left");
				mulliganButton.clickable = false;
			}
			else
			{
				mulliganText.text = LocalizationManager.GetTranslation("Mulligans: Currently Unavailable");
				mulliganButton.clickable = false;
			}
		}
	}

	public void BackToMainMenu()
	{
		ShowConfirm(_BackToMainMenu, "Go back to main menu?");
	}

	public void _BackToMainMenu()
	{
		CloseAllMenus();
		paused = false;
		if (PauseMenu.onUnpaused != null)
		{
			PauseMenu.onUnpaused();
		}
		GameManager.instance.BackToMainMenu();
		if (GameManager.instance.currentSceneName == "Tutorial")
		{
			GameManager.instance.SetTutorial(x: true);
		}
	}

	private void ShowConfirm(ConfirmFunction function, string confirmMessage)
	{
		CloseAllMenus();
		confirmText.text = LocalizationManager.GetTranslation(confirmMessage);
		confirmFunc = function;
		confirmMenu.SetActive(value: true);
	}

	public void Confirm()
	{
		confirmFunc();
		HideConfirm();
	}

	public void Unconfirm()
	{
		HideConfirm(openPreviousMenu: true);
	}

	private void HideConfirm(bool openPreviousMenu = false)
	{
		confirmFunc = null;
		confirmMenu.SetActive(value: false);
		confirmText.text = LocalizationManager.GetTranslation("Confirm") + "?";
		if (openPreviousMenu)
		{
			if (GameManager.instance.currentSceneName.Contains("Boss"))
			{
				SwitchToBossMenu();
			}
			else
			{
				SwitchToRootMenu();
			}
		}
	}

	public void ToggleShadows()
	{
	}

	public void SwitchToAudioMenu()
	{
		OpenMenu(audioMenu);
		if (GameManager.instance.audioManager.GetSFXOn())
		{
			sfxText.text = LocalizationManager.GetTranslation("SFX: On");
		}
		else
		{
			sfxText.text = LocalizationManager.GetTranslation("SFX: Off");
		}
		if (GameManager.instance.audioManager.GetAmbientOn())
		{
			ambientText.text = LocalizationManager.GetTranslation("Ambient: On");
		}
		else
		{
			ambientText.text = LocalizationManager.GetTranslation("Ambient: Off");
		}
		if (GameManager.instance.audioManager.GetMusicOn())
		{
			musicText.text = LocalizationManager.GetTranslation("Music: On");
		}
		else
		{
			musicText.text = LocalizationManager.GetTranslation("Music: Off");
		}
	}

	public void SwitchToLanguageMenu()
	{
		OpenMenu(languageMenu);
	}

	public void SwitchToKickMenu()
	{
		OpenMenu(kickMenu);
		UpdateKickList();
	}

	public void SwitchToMicrophoneMenu()
	{
		CloseAllMenus();
		microphoneMenu.SetActive(value: true);
		ChangeMicText();
		if (PhotonNetwork.PlayerListOthers.Length == 0)
		{
			muteButton.clickable = false;
			muteButton.Greyed();
		}
		else
		{
			muteButton.clickable = true;
			muteButton.UnHighlight();
		}
	}

	public void SwitchToClubAngleMenu()
	{
		_ = GameManager.instance.controllerType;
		_ = 4;
		OpenMenu(clubAngleMenu);
		clubAngleText.text = -SaveFileManager.instance.saveFile.clubAngle + "";
		Player.instance.clubs.SetActive(value: true);
	}

	public void OnMicStateButton()
	{
		GameManager.instance.SetMicState(!GameManager.instance.GetMicState());
		ChangeMicText();
		if (PauseMenu.onMicTextChange != null)
		{
			PauseMenu.onMicTextChange();
		}
	}

	private void ChangeMicText()
	{
		if (GameManager.instance.GetMicState())
		{
			micStateText.text = LocalizationManager.GetTranslation("Mic On");
		}
		else
		{
			micStateText.text = LocalizationManager.GetTranslation("Mic Off");
		}
	}

	private void UpdateKickList()
	{
		playerInfo = PhotonNetwork.PlayerListOthers;
		for (int i = 0; i < 3; i++)
		{
			onlinePlayers[i].SetActive(value: false);
		}
		for (int j = 0; j < PhotonManager.instance.GetUsablePlayers(includeSelf: false).Count; j++)
		{
			onlinePlayers[j].SetActive(value: true);
			onlinePlayers[j].GetComponentInChildren<Text>().text = PhotonManager.instance.GetUsablePlayers(includeSelf: false)[j].NickName;
		}
	}

	public void OnKickButton(int x)
	{
		kickedPlayer = x;
		RoomRPC.instance.pView.RPC("ShowKickNotification", PhotonNetwork.PlayerListOthers[kickedPlayer]);
		PhotonNetwork.CurrentRoom.AddKickedPlayers(PhotonNetwork.PlayerListOthers[kickedPlayer]);
		PhotonNetwork.PlayerListOthers[kickedPlayer].SetKicked(kicked: true);
		PhotonNetwork.CloseConnection(PhotonNetwork.PlayerListOthers[kickedPlayer]);
		GameManager.instance.pauseMenu.TogglePause();
	}

	public void ChangeLanguage(string language)
	{
		GameManager.instance.SetLanguage(language);
		SetMulliganCount();
		OpenMenu(settingsMenu);
	}

	public void ToggleMusic()
	{
		if (GameManager.instance.audioManager.ToggleMusic())
		{
			musicText.text = LocalizationManager.GetTranslation("Music: On");
		}
		else
		{
			musicText.text = LocalizationManager.GetTranslation("Music: Off");
		}
	}

	public void ToggleSFX()
	{
		if (GameManager.instance.audioManager.ToggleSFX())
		{
			sfxText.text = LocalizationManager.GetTranslation("SFX: On");
		}
		else
		{
			sfxText.text = LocalizationManager.GetTranslation("SFX: Off");
		}
	}

	public void ToggleAmbient()
	{
		if (GameManager.instance.audioManager.ToggleAmbient())
		{
			ambientText.text = LocalizationManager.GetTranslation("Ambient: On");
		}
		else
		{
			ambientText.text = LocalizationManager.GetTranslation("Ambient: Off");
		}
	}

	public void BackToLobby()
	{
		ShowConfirm(_BackToLobby, "Back To Lobby");
	}

	public void ChangeFFR()
	{
		int tiledMultiResLevel = (int)OVRManager.tiledMultiResLevel;
		tiledMultiResLevel++;
		if (tiledMultiResLevel >= Enum.GetNames(typeof(OVRManager.TiledMultiResLevel)).Length)
		{
			tiledMultiResLevel = 0;
		}
		OVRManager.tiledMultiResLevel = (OVRManager.TiledMultiResLevel)tiledMultiResLevel;
		Notification.instance.AddNotification(Enum.GetName(typeof(OVRManager.TiledMultiResLevel), OVRManager.tiledMultiResLevel), 0.5f);
	}

	private void _BackToLobby()
	{
		CloseAllMenus();
		Player.instance.currentController.SwitchToClubs();
		paused = false;
		GameManager.instance.BackToLobby();
	}

	private void ChangeGridLayoutSize(int rows)
	{
		int num = 0;
		num = 2 / rows;
		gridLayout.cellSize = new Vector2(num, 0.2f);
		gridLayout.constraintCount = rows;
		foreach (Transform item in gridLayout.transform)
		{
			BoxCollider component = item.GetComponent<BoxCollider>();
			item.GetComponent<BoxCollider>().size = new Vector3(num, component.size.y, component.size.z);
		}
	}

	public void ToggleEditorPreview()
	{
		if (LevelEditor.instance.previewing || (!LevelEditor.instance.previewing && LevelEditor.instance.CheckCanPreview()))
		{
			LevelEditor.instance.TogglePreview();
			CloseAllMenus();
			paused = false;
		}
	}

	public void RestartEditorHole()
	{
		if (LevelEditor.instance.previewing)
		{
			LevelEditor.instance.ResetLevel();
			CloseAllMenus();
			Player.instance.SwitchToClub();
			Player.instance.clubSwitcher.ResetClubVelocities();
			paused = false;
		}
	}

	public void ExitLevelEditor()
	{
		if (LevelEditor.instance.unsavedChanges)
		{
			ShowConfirm(_BackToMainMenu, "There are unsaved changes to your current level. Go back to main menu and lose your changes?");
		}
		else
		{
			BackToMainMenu();
		}
	}

	public void GetAllClubLengthProfiles()
	{
		if (GameManager.instance.publishedPlatform == PublishedPlatform.XR || !Directory.Exists(UnityEngine.Application.persistentDataPath + "/club profiles/"))
		{
			return;
		}
		DirectoryInfo directoryInfo = new DirectoryInfo(UnityEngine.Application.persistentDataPath + "/club profiles/");
		clubLengthProfiles = null;
		clubLengthProfiles = directoryInfo.GetFiles("*.profile");
		foreach (GameObject clubProfileButton in clubProfileButtons)
		{
			UnityEngine.Object.Destroy(clubProfileButton);
		}
		clubProfileButtons.Clear();
		FileInfo[] array = clubLengthProfiles;
		foreach (FileInfo profile in array)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(clubProfileButtonPrefab);
			gameObject.transform.parent = clubProfilebuttonContainer;
			gameObject.transform.localPosition = Vector3.zero;
			gameObject.transform.localRotation = Quaternion.identity;
			gameObject.GetComponent<ClubProfileButton>().SetProfile(profile);
			clubProfileButtons.Add(gameObject);
		}
	}

	public void ChangeHand()
	{
		if (GameManager.instance.controllerType == ControllerType.Vive)
		{
			if (!GameManager.instance.GetHandedness())
			{
				handedText.text = LocalizationManager.GetTranslation("Handedness: Right Handed");
			}
			else
			{
				handedText.text = LocalizationManager.GetTranslation("Handedness: Left Handed");
			}
			Player.instance.SwapControllers();
		}
		else if (GameManager.instance.controllerType == ControllerType.Quest)
		{
			if (OVRInput.IsControllerConnected(OVRInput.Controller.LTouch) && OVRInput.IsControllerConnected(OVRInput.Controller.RTouch))
			{
				if (!GameManager.instance.GetHandedness())
				{
					handedText.text = LocalizationManager.GetTranslation("Handedness: Right Handed");
				}
				else
				{
					handedText.text = LocalizationManager.GetTranslation("Handedness: Left Handed");
				}
				Player.instance.SwapControllers();
			}
		}
		else if (GameManager.instance.controllerType == ControllerType.XR)
		{
			bool flag = !GameManager.instance.GetHandedness();
			if (flag)
			{
				handedText.text = LocalizationManager.GetTranslation("Handedness: Right Handed");
			}
			else
			{
				handedText.text = LocalizationManager.GetTranslation("Handedness: Left Handed");
			}
			Player.instance.SwapXRControllerHandedness(flag);
		}
	}

	public void ToggleSwingConstraint()
	{
		if (Player.instance.currentController.ToggleSwingConstraint())
		{
			constrainedText.text = LocalizationManager.GetTranslation("Swing Style: Constrained");
		}
		else
		{
			constrainedText.text = LocalizationManager.GetTranslation("Swing Style: Free");
		}
		savedMode = ControllerMode.FollowMode;
	}

	public void ToggleWarpToCenter()
	{
		if (Player.instance.autoWarp.ToggleWarpToCenter())
		{
			warpToCenterText.text = LocalizationManager.GetTranslation("Warp: Center Of Play Space");
		}
		else if (Player.instance.currentController.constrainedSwing)
		{
			warpToCenterText.text = LocalizationManager.GetTranslation("Warp: Head Position");
		}
		else
		{
			warpToCenterText.text = LocalizationManager.GetTranslation("Warp: Last Hit Position");
		}
	}

	public void ToggleWarpInAir()
	{
		if (Player.instance.autoWarp.ToggleWarpInAir())
		{
			warpInAirText.text = LocalizationManager.GetTranslation("Warp Mid-Air: On");
		}
		else
		{
			warpInAirText.text = LocalizationManager.GetTranslation("Warp Mid-Air: Off");
		}
	}

	public void OpenHoleInfo()
	{
		Resume();
		if (ScoreManager.instance.ballScored && !GameManager.instance.holeData[GameManager.instance.holeIndex].defaultHole && RemoteServerManager.instance.playerID != "")
		{
			GameManager.instance.SpawnHoleInfoNotification(rating: true);
		}
		else
		{
			GameManager.instance.SpawnHoleInfoNotification(rating: false);
		}
	}

	public void ToggleRotateDirection()
	{
		bool flag = GameManager.instance.player.GetComponent<Player>().ToggleRotateDirection();
		PlayerPrefs.SetInt("InvertedRotation", flag ? 1 : 0);
		if (flag)
		{
			rotateDirectionText.text = LocalizationManager.GetTranslation("Rotation: Inverted");
		}
		else
		{
			rotateDirectionText.text = LocalizationManager.GetTranslation("Rotation: Standard");
		}
	}

	public void ToggleWarpOrientation()
	{
		bool flag = Player.instance.autoWarp.ToggleWarpOrientation();
		PlayerPrefs.SetInt("WarpOrientationLookAtHole", flag ? 1 : 0);
		if (flag)
		{
			warpOrientationText.text = LocalizationManager.GetTranslation("Warp Orientiation: Orient to Hole");
		}
		else
		{
			warpOrientationText.text = LocalizationManager.GetTranslation("Warp Orientiation: Keep Orientation");
		}
	}

	public void ToggleDistanceToBall()
	{
		distanceToBall++;
		if (distanceToBall >= 3)
		{
			distanceToBall = 0;
		}
		if (distanceToBall == 0)
		{
			distanceToBallText.text = LocalizationManager.GetTranslation("Distance To Ball: Near");
			Player.instance.autoWarp.SetDistanceToBallClose();
		}
		else if (distanceToBall == 1)
		{
			distanceToBallText.text = LocalizationManager.GetTranslation("Distance To Ball: Normal");
			Player.instance.autoWarp.SetDistanceToBallNormal();
		}
		else
		{
			distanceToBallText.text = LocalizationManager.GetTranslation("Distance To Ball: Far");
			Player.instance.autoWarp.SetDistanceToBallFar();
		}
		PlayerPrefs.SetInt("DistanceToBall", distanceToBall);
	}

	public void ToggleBallTrail()
	{
		if (GameManager.instance.GetBallTrail())
		{
			if (GameManager.instance.golfball != null)
			{
				GameManager.instance.golfball.DestroyTrailRenderer();
			}
			GameManager.instance.SetBallTrail(toggle: false);
			ballTrailText.text = LocalizationManager.GetTranslation("Ball Trail: Off");
		}
		else
		{
			GameManager.instance.SetBallTrail(toggle: true);
			ballTrailText.text = LocalizationManager.GetTranslation("Ball Trail: On");
		}
	}

	public void ToggleGreenSlopeLines()
	{
		if (GameManager.instance.GetGreenSlopeLines())
		{
			GameManager.instance.SetGreenSlopeLines(x: false);
			greenSlopeLinesText.text = LocalizationManager.GetTranslation("Green Slope Lines: Off");
		}
		else
		{
			GameManager.instance.SetGreenSlopeLines(x: true);
			greenSlopeLinesText.text = LocalizationManager.GetTranslation("Green Slope Lines: On");
		}
		Player.instance.autoWarp.OnAutoWarp();
	}

	public void ToggleTouchpadHelper()
	{
		bool flag = !Player.instance.currentController.touchLocationIndicator.transform.parent.gameObject.activeSelf;
		if (flag)
		{
			Player.instance.currentController.touchLocationIndicator.transform.parent.gameObject.SetActive(value: true);
		}
		else
		{
			Player.instance.currentController.touchLocationIndicator.transform.parent.gameObject.SetActive(value: false);
		}
		PlayerPrefsX.SetBool("TouchpadHelperEnabled", flag);
		string translation = LocalizationManager.GetTranslation("Touchpad");
		if (GameManager.instance.controllerType == ControllerType.Quest)
		{
			translation = LocalizationManager.GetTranslation("Joystick");
		}
		if (flag)
		{
			touchpadText.text = translation + " " + LocalizationManager.GetTranslation("Helper: Visible");
		}
		else
		{
			touchpadText.text = translation + " " + LocalizationManager.GetTranslation("Helper: Hidden");
		}
	}

	public void ToggleClubChangeOnWarp()
	{
		bool clubChangeOnWarp = GameManager.instance.GetClubChangeOnWarp();
		if (clubChangeOnWarp)
		{
			clubChangeText.text = LocalizationManager.GetTranslation("Change Club On Warp: Off");
		}
		else
		{
			clubChangeText.text = LocalizationManager.GetTranslation("Change Club On Warp: On");
		}
		GameManager.instance.SetClubChangeOnWarp(!clubChangeOnWarp);
	}

	public void RestartHole()
	{
		if (GameManager.instance.currentSceneName.Contains("Boss"))
		{
			ShowConfirm(_RestartBoss, LocalizationManager.GetTranslation("Restart boss from the beginning?"));
		}
		else
		{
			ShowConfirm(_RestartHole, LocalizationManager.GetTranslation("Restart hole from the beginning?"));
		}
	}

	private void _RestartHole()
	{
		GameManager.instance.LoadNextHole(incrementHole: false);
	}

	private void _RestartBoss()
	{
		GameManager.instance.LoadNextHole(incrementHole: false);
	}

	public void OnClubAngleButton(int x)
	{
		int clubAngle = SaveFileManager.instance.saveFile.clubAngle;
		clubAngle += x;
		if (clubAngle < -45)
		{
			clubAngle = -45;
		}
		else if (clubAngle > 45)
		{
			clubAngle = 45;
		}
		SaveFileManager.instance.saveFile.clubAngle = clubAngle;
		clubAngleText.text = -clubAngle + "";
		if (GameManager.instance.controllerType == ControllerType.Quest)
		{
			clubAngle += -25;
		}
		if (GameManager.instance.controllerType == ControllerType.Pico)
		{
			clubAngle += -30;
		}
		Vector3 localEulerAngles = new Vector3(clubAngle, 0f, 0f);
		Player.instance.currentController.transform.localEulerAngles = localEulerAngles;
	}

	public void ToggleClubShadow()
	{
		bool flag = !GameManager.instance.GetClubShadows();
		GameManager.instance.SetClubShadows(flag);
		if (flag)
		{
			clubShadowText.text = LocalizationManager.GetTranslation("Club Shadows: On");
		}
		else
		{
			clubShadowText.text = LocalizationManager.GetTranslation("Club Shadows: Off");
		}
	}

	private void OnInputFocusLost()
	{
		if (!PhotonNetwork.IsConnected && !paused)
		{
			TogglePause();
		}
	}

	public void TogglePuttLine()
	{
		bool @bool = PlayerPrefsX.GetBool("ShowAimLine", defaultValue: true);
		@bool = !@bool;
		PlayerPrefsX.SetBool("ShowAimLine", @bool);
		if (@bool)
		{
			showPuttLineText.text = LocalizationManager.GetTranslation("Aim Line: Visible");
		}
		else
		{
			showPuttLineText.text = LocalizationManager.GetTranslation("Aim Line: Hidden");
		}
	}

	private void OnLocalizationCall()
	{
		if (controlSettingsMenu.activeSelf)
		{
			SwitchToControllerSettingsMenu();
		}
		else if (gameplaySettingsMenu.activeSelf)
		{
			SwitchToGameplaySettingsMenu();
		}
		else if (audioMenu.activeSelf)
		{
			SwitchToAudioMenu();
		}
	}
}
public class QuickMenu : MonoBehaviour
{
	public GameObject menu;

	[Header("Text")]
	public Text itemText;

	public Text ballText;

	public Text driverText;

	public Text ironText;

	public Text putterText;

	public Text holeDistanceText;

	public Text windSpeedText;

	[Header("Use Buttons")]
	public PointerButton itemUseButton;

	public PointerButton ballUseButton;

	public PointerButton driverUseButton;

	public PointerButton ironUseButton;

	public PointerButton putterUseButton;

	private ItemType itemType;

	private BallType ballType;

	private DriverType driverType;

	private IronType ironType;

	private PutterType putterType;

	private ControllerMode savedMode;

	public Transform tutorialBoardAnchors;

	public GameObject minimap;

	public GameObject quickMenu;

	public PointerButton switchToMinimapButton;

	public RenderTexture minimapTexture;

	public RenderTexture iconLayerTexture;

	public Texture noScreenshotTexture;

	public RawImage minimapImage;

	public RawImage iconLayerImage;

	public AudioClip openSFX;

	[HideInInspector]
	public AudioSource aSource;

	public float[] zoomLevel = new float[5] { 30f, 50f, 100f, 150f, 200f };

	private int zoomIndex = 2;

	private void Start()
	{
		menu.SetActive(value: false);
		aSource = GetComponent<AudioSource>();
	}

	private void Update()
	{
		if (!(GameManager.instance != null) || (!(GameManager.instance.currentSceneName == "CustomHoleScene") && (!(GameManager.instance.currentSceneName == "Tutorial") || !TutorialManager.instance.autoWarped) && (!(GameManager.instance.currentSceneName == "LevelEditor") || !LevelEditor.instance.previewing)) || Player.instance.currentControllerInput.bButton.down || (!Player.instance.currentControllerInput.touchpadStatus.downTouchpadButtonStatus.wasPressed && (GameManager.instance.controllerType != ControllerType.FPS || !Input.GetKeyDown(KeyCode.DownArrow))))
		{
			return;
		}
		if (GameManager.instance.pauseMenu.paused)
		{
			GameManager.instance.pauseMenu.Resume();
		}
		if (menu.activeSelf)
		{
			CloseMenu();
			return;
		}
		menu.SetActive(value: true);
		SetPage();
		GameManager.instance.CenterNotification(base.gameObject);
		Player.instance.currentController.SwitchToPointer();
		if (TutorialManager.instance != null)
		{
			TutorialManager.instance.boardObjectTransform.transform.position = tutorialBoardAnchors.position;
			TutorialManager.instance.boardObjectTransform.transform.rotation = tutorialBoardAnchors.rotation;
		}
		aSource.PlayOneShot(openSFX);
	}

	private void SetPage()
	{
		if (GameManager.instance.currentSceneName != "CustomHoleScene")
		{
			SwitchToQuickMenu();
			switchToMinimapButton.Greyed();
			switchToMinimapButton.clickable = false;
		}
		else
		{
			switchToMinimapButton.UnHighlight();
			switchToMinimapButton.clickable = true;
		}
		if (quickMenu.activeSelf)
		{
			itemType = ItemManager.instance.currentlyUsedItem;
			ballType = SaveFileManager.instance.saveFile.equippedBall;
			driverType = Player.instance.clubSwitcher.driverType;
			ironType = Player.instance.clubSwitcher.ironType;
			putterType = Player.instance.clubSwitcher.putterType;
			ballText.text = Enum.GetName(typeof(BallType), ballType);
			driverText.text = Enum.GetName(typeof(DriverType), driverType);
			ironText.text = Enum.GetName(typeof(IronType), ironType);
			putterText.text = Enum.GetName(typeof(PutterType), putterType);
			if (GameManager.instance.GetNearestHoleFromPos(Player.instance.head.position) != null)
			{
				float num = Vector3.Distance(Player.instance.head.position, GameManager.instance.GetNearestHoleFromPos(Player.instance.head.position).transform.position);
				holeDistanceText.text = "Hole Distance: " + (num * 1.09361f).ToString("#.0") + " Yards";
			}
			else
			{
				holeDistanceText.text = "Hole Distance: N/A";
			}
			if (GameManager.instance.currentSceneName == "CustomHoleScene")
			{
				CustomHoleScene customHoleScene = UnityEngine.Object.FindObjectOfType<CustomHoleScene>();
				windSpeedText.text = customHoleScene.wind.GetWindSpeedText();
			}
			else
			{
				windSpeedText.text = "Wind: 0 mph";
			}
			ItemManager.instance.GetStock();
			GetItemStock();
			GetBallStock();
			GetUsableClubs();
			SwitchToMiniMap();
		}
		else
		{
			SwitchToMiniMap();
		}
		savedMode = Player.instance.currentController.controllerMode;
		Player.instance.currentController.SwitchControllerMode(ControllerMode.FollowMode);
	}

	public void OnItemPageButton(int x)
	{
		int num = (int)itemType;
		int length = Enum.GetValues(typeof(ItemType)).Length;
		num += x;
		if (num < 0)
		{
			num = length - 1;
		}
		else if (num > length - 1)
		{
			num = 0;
		}
		itemType = (ItemType)num;
		GetItemStock();
	}

	public void OnBallPageButton(int x)
	{
		int num = (int)ballType;
		int length = Enum.GetValues(typeof(BallType)).Length;
		num += x;
		if (num < 0)
		{
			num = length - 1;
		}
		else if (num > length - 1)
		{
			num = 0;
		}
		ballText.text = Enum.GetName(typeof(BallType), num);
		ballType = (BallType)num;
		GetBallStock();
	}

	public void OnDriverPageButton(int x)
	{
		int num = (int)driverType;
		int length = Enum.GetValues(typeof(DriverType)).Length;
		num += x;
		if (num < 0)
		{
			num = length - 1;
		}
		else if (num > length - 1)
		{
			num = 0;
		}
		driverText.text = Enum.GetName(typeof(DriverType), num);
		driverType = (DriverType)num;
	}

	public void OnIronPageButton(int x)
	{
		int num = (int)ironType;
		int length = Enum.GetValues(typeof(IronType)).Length;
		num += x;
		if (num < 0)
		{
			num = length - 1;
		}
		else if (num > length - 1)
		{
			num = 0;
		}
		ironText.text = Enum.GetName(typeof(IronType), num);
		ironType = (IronType)num;
	}

	public void OnPutterPageButton(int x)
	{
		int num = (int)putterType;
		int length = Enum.GetValues(typeof(PutterType)).Length;
		num += x;
		if (num < 0)
		{
			num = length - 1;
		}
		else if (num > length - 1)
		{
			num = 0;
		}
		putterText.text = Enum.GetName(typeof(PutterType), num);
		putterType = (PutterType)num;
	}

	public void UseItem()
	{
		if (itemType == ItemType.NullifyWind)
		{
			ItemManager.instance.UseNullifyWind();
		}
		else if (itemType == ItemType.TeeGolfingSurface)
		{
			ItemManager.instance.UseTeeGolfingSurface();
		}
		else if (itemType == ItemType.PuttLine)
		{
			ItemManager.instance.UsePuttLine();
		}
		else if (itemType == ItemType.Bomb)
		{
			ItemManager.instance.UseBomb();
		}
		else if (itemType == ItemType.Smoke)
		{
			ItemManager.instance.UseSmoke();
		}
		SaveFileManager.instance.SaveFile();
		GetItemStock();
	}

	public void UseBall()
	{
		GameManager.instance.SetBallType(ballType);
	}

	public void SwitchDriver()
	{
		Player.instance.clubSwitcher.driverType = driverType;
		Player.instance.clubSwitcher.SwitchToClubType(ClubType.Driver);
		Player.instance.clubSwitcher.preventClubSwitchOnWarp = true;
		OBManager.instance.revertLastClubOnOB = true;
		OBManager.instance.clubTypeBeforeHit = ClubType.Driver;
		SaveFileManager.instance.saveFile.driverType = driverType;
		SaveFileManager.instance.SaveFile();
		CloseMenu();
	}

	public void SwitchIron()
	{
		Player.instance.clubSwitcher.ironType = ironType;
		Player.instance.clubSwitcher.SwitchToClubType(ClubType.Iron);
		Player.instance.clubSwitcher.preventClubSwitchOnWarp = true;
		OBManager.instance.revertLastClubOnOB = true;
		OBManager.instance.clubTypeBeforeHit = ClubType.Iron;
		SaveFileManager.instance.saveFile.ironType = ironType;
		SaveFileManager.instance.SaveFile();
		CloseMenu();
	}

	public void SwitchPutter()
	{
		Player.instance.clubSwitcher.putterType = putterType;
		Player.instance.clubSwitcher.SwitchToClubType(ClubType.Putter);
		Player.instance.clubSwitcher.preventClubSwitchOnWarp = true;
		OBManager.instance.revertLastClubOnOB = true;
		OBManager.instance.clubTypeBeforeHit = ClubType.Putter;
		SaveFileManager.instance.saveFile.putterType = putterType;
		SaveFileManager.instance.SaveFile();
		CloseMenu();
	}

	private void GetItemStock()
	{
		int num = 0;
		if (itemType == ItemType.None)
		{
			num = 0;
		}
		if (itemType == ItemType.NullifyWind)
		{
			num = ItemManager.instance.nullifyWindStock;
		}
		else if (itemType == ItemType.PuttLine)
		{
			num = ItemManager.instance.puttLineStock;
		}
		else if (itemType == ItemType.TeeGolfingSurface)
		{
			num = ItemManager.instance.teeSurfaceStock;
		}
		else if (itemType == ItemType.Smoke)
		{
			num = ItemManager.instance.smokeStock;
		}
		else if (itemType == ItemType.Bomb)
		{
			num = ItemManager.instance.bombStock;
		}
		if (num == 0)
		{
			itemUseButton.clickable = false;
			itemUseButton.Greyed();
		}
		else if (GameManager.instance.currentSceneName != "CustomHoleScene")
		{
			itemUseButton.clickable = false;
			itemUseButton.Greyed();
		}
		else
		{
			itemUseButton.clickable = true;
			itemUseButton.UnHighlight();
		}
		itemText.text = Enum.GetName(typeof(ItemType), itemType) + " x" + num;
	}

	private void GetBallStock()
	{
		if (GameManager.instance.currentSceneName != "CustomHoleScene")
		{
			ballUseButton.clickable = false;
			ballUseButton.Greyed();
			return;
		}
		int num = 0;
		if (ballType == BallType.Normal)
		{
			num = 1;
		}
		else if (ballType == BallType.Gumball)
		{
			num = SaveFileManager.instance.saveFile.Gumball;
		}
		else if (ballType == BallType.Iceball)
		{
			num = SaveFileManager.instance.saveFile.Iceball;
		}
		else if (ballType == BallType.Airball)
		{
			num = SaveFileManager.instance.saveFile.Airball;
		}
		if (num == 0)
		{
			ballUseButton.clickable = false;
			ballUseButton.Greyed();
		}
		else
		{
			ballUseButton.clickable = true;
			ballUseButton.UnHighlight();
		}
	}

	private void GetUsableClubs()
	{
		if (GameManager.instance.currentSceneName == "CustomHoleScene" || GameManager.instance.currentSceneName == "LevelEditor")
		{
			GolfClubType golfClubType = GolfClubType.Putter | GolfClubType.Iron | GolfClubType.Driver;
			if (GameManager.instance.currentSceneName == "CustomHoleScene")
			{
				golfClubType = GameManager.instance.holeData[GameManager.instance.holeIndex].golfClubType;
			}
			else if (GameManager.instance.currentSceneName == "LevelEditor")
			{
				golfClubType = LevelEditor.instance.currentLevel.allowedClubs;
			}
			if ((golfClubType & GolfClubType.Driver) == GolfClubType.Driver)
			{
				driverUseButton.clickable = true;
				driverUseButton.UnHighlight();
			}
			else
			{
				driverUseButton.clickable = false;
				driverUseButton.Greyed();
			}
			if ((golfClubType & GolfClubType.Iron) == GolfClubType.Iron)
			{
				ironUseButton.clickable = true;
				ironUseButton.UnHighlight();
			}
			else
			{
				ironUseButton.clickable = false;
				ironUseButton.Greyed();
			}
			if ((golfClubType & GolfClubType.Putter) == GolfClubType.Putter)
			{
				putterUseButton.clickable = true;
				putterUseButton.UnHighlight();
			}
			else
			{
				putterUseButton.clickable = false;
				putterUseButton.Greyed();
			}
			return;
		}
		driverUseButton.clickable = true;
		driverUseButton.UnHighlight();
		ironUseButton.clickable = true;
		ironUseButton.UnHighlight();
		if (GameManager.instance.currentSceneName == "Tutorial")
		{
			if (!TutorialManager.instance.adjustAim && TutorialManager.instance.secondaryJoystickFunction)
			{
				putterUseButton.clickable = false;
				putterUseButton.Greyed();
			}
			else
			{
				putterUseButton.clickable = true;
				putterUseButton.UnHighlight();
			}
		}
	}

	public void SwitchToMiniMap()
	{
		MinimapCamera minimapCamera = null;
		if (GameManager.instance.currentSceneName == "CustomHoleScene")
		{
			minimapCamera = CustomHoleScene.instance.minimapCamera.GetComponent<MinimapCamera>();
		}
		else if (GameManager.instance.currentSceneName == "Tutorial")
		{
			minimapCamera = TutorialManager.instance.minimapCamera.GetComponent<MinimapCamera>();
		}
		else if (GameManager.instance.currentSceneName == "LevelEditor")
		{
			minimapCamera = LevelEditor.instance.minimapCamera.GetComponent<MinimapCamera>();
		}
		if (minimapCamera != null)
		{
			Vector3 position = Player.instance.head.position;
			position.y = 500f;
			minimapCamera.gameObject.transform.position = position;
			minimapCamera.cam.orthographicSize = zoomLevel[zoomIndex];
			minimapCamera.RenderToTex(minimapTexture);
			minimapImage.texture = minimapTexture;
			iconLayerImage.texture = iconLayerTexture;
			iconLayerImage.enabled = true;
		}
		else
		{
			minimapImage.texture = noScreenshotTexture;
			iconLayerImage.enabled = false;
		}
	}

	public void SwitchToQuickMenu()
	{
		quickMenu.SetActive(value: true);
		minimap.SetActive(value: false);
	}

	public void CloseMenu()
	{
		menu.SetActive(value: false);
		Player.instance.currentController.SwitchToClubs();
		if (!ScoreManager.instance.ballScored)
		{
			Player.instance.currentController.SwitchControllerMode(savedMode);
		}
		else
		{
			Player.instance.currentController.SwitchControllerMode(ControllerMode.FollowMode);
		}
		if (TutorialManager.instance != null)
		{
			TutorialManager.instance.QuickMenu();
		}
	}

	public void ZoomOut()
	{
		if (zoomIndex < 4)
		{
			zoomIndex++;
		}
		SwitchToMiniMap();
	}

	public void ZoomIn()
	{
		if (zoomIndex > 0)
		{
			zoomIndex--;
		}
		SwitchToMiniMap();
	}
}
public class StoreItem : TextButton
{
	public int cost;

	[Header("===Items===")]
	public bool isItem;

	public ItemType itemType;

	[Header("===Balls===")]
	public bool isBall;

	public BallType ballType;

	[Header("===Clubs===")]
	public bool isClub;

	public ClubType clubType;

	public DriverType driverType;

	public IronType ironType;

	public PutterType putterType;

	private void OnEnable()
	{
		string itemName = "";
		if (isClub)
		{
			if (clubType == ClubType.Driver)
			{
				itemName = driverType.ToString();
			}
			else if (clubType == ClubType.Iron)
			{
				itemName = ironType.ToString();
			}
			else if (clubType == ClubType.Putter)
			{
				itemName = putterType.ToString();
			}
			if (MoneyManager.instance.GetItemAmount(itemName) > 0)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}
		else if (isBall)
		{
			itemName = ballType.ToString();
			if (MoneyManager.instance.GetItemAmount(itemName) > 0)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}
	}
}
public class StoreMenu : MonoBehaviour
{
	public TextMeshProUGUI moneyText;

	public Transform clubParent;

	public GameObject driver;

	public GameObject iron;

	public GameObject putter;

	private AudioSource audioSource;

	private int money;

	private bool showingInsufficientFunds;

	private void OnEnable()
	{
		money = SaveFileManager.instance.saveFile.money;
		moneyText.text = "$" + money;
	}

	private void Start()
	{
		audioSource = GetComponent<AudioSource>();
		StartCoroutine(DelayStart());
	}

	private IEnumerator DelayStart()
	{
		yield return null;
		RemoveClubHeader(ClubType.Driver);
		RemoveClubHeader(ClubType.Iron);
		RemoveClubHeader(ClubType.Putter);
	}

	public void BuyItem(StoreItem item)
	{
		string itemName = "";
		if (item.isClub)
		{
			if (item.clubType == ClubType.Driver)
			{
				itemName = item.driverType.ToString();
			}
			else if (item.clubType == ClubType.Iron)
			{
				itemName = item.ironType.ToString();
			}
			else if (item.clubType == ClubType.Putter)
			{
				itemName = item.putterType.ToString();
			}
		}
		else if (item.isBall)
		{
			itemName = item.ballType.ToString();
		}
		else if (item.isItem)
		{
			itemName = item.itemType.ToString();
		}
		if (MoneyManager.instance.BuyItem(item.cost, itemName))
		{
			money -= item.cost;
			moneyText.text = "$" + money;
			if (item.isClub || item.isBall)
			{
				UnityEngine.Object.Destroy(item.gameObject);
			}
		}
		else
		{
			StartCoroutine(InsufficientFunds());
		}
	}

	private IEnumerator InsufficientFunds()
	{
		if (!showingInsufficientFunds)
		{
			showingInsufficientFunds = true;
			Color c = moneyText.color;
			moneyText.color = Color.red;
			audioSource.Play();
			yield return new WaitForSeconds(1f);
			moneyText.color = c;
			showingInsufficientFunds = false;
		}
	}

	private void RemoveClubHeader(ClubType club)
	{
		int num = 0;
		foreach (Transform item in clubParent)
		{
			if (item.GetComponent<StoreItem>() != null && club == item.GetComponent<StoreItem>().clubType)
			{
				num++;
			}
		}
		if (num == 0)
		{
			switch (club)
			{
			case ClubType.Driver:
				UnityEngine.Object.Destroy(driver);
				break;
			case ClubType.Iron:
				UnityEngine.Object.Destroy(iron);
				break;
			case ClubType.Putter:
				UnityEngine.Object.Destroy(putter);
				break;
			}
		}
	}
}
public class CannonRingMinigame : Minigame
{
	public TextMeshPro rewardText;

	public float spawnStartPos = -43.4f;

	public float spawnEndPos = 46.6f;

	public float moveSpeed = 10f;

	private string rewardWon;

	private void Start()
	{
		Player.instance.clubSwitcher.SwitchToClubType(ClubType.Putter);
	}

	private void Update()
	{
		MoveRings();
		if (!finishedMinigame)
		{
			CheckFinishedMinigame();
		}
	}

	public override void ShowFinishedText()
	{
		base.ShowFinishedText();
		rewardText.text = "You received $" + rewardWon;
	}

	public override void CheckFinishedMinigame()
	{
		TargetRing[] array = rings;
		foreach (TargetRing targetRing in array)
		{
			if (targetRing.scored)
			{
				rewardWon = targetRing.moneyAmount.ToString();
				finishedMinigame = true;
				ShowFinishedText();
				UnityEngine.Object.Destroy(GameManager.instance.golfball.gameObject);
				break;
			}
		}
	}

	private void MoveRings()
	{
		TargetRing[] array = rings;
		foreach (TargetRing targetRing in array)
		{
			if (!targetRing.scored)
			{
				targetRing.transform.Translate(Vector3.right * moveSpeed * Time.deltaTime);
				if (targetRing.transform.localPosition.x > spawnEndPos)
				{
					Vector3 localPosition = targetRing.transform.localPosition;
					localPosition.x = spawnStartPos;
					targetRing.transform.localPosition = localPosition;
				}
			}
		}
	}
}
public abstract class Minigame : MonoBehaviour
{
	public TargetRing[] rings;

	public GameObject finishedText;

	internal bool finishedMinigame;

	public virtual void ShowFinishedText()
	{
		finishedText.SetActive(value: true);
	}

	public abstract void CheckFinishedMinigame();

	private void OnTriggerEnter(Collider other)
	{
		if (other.tag == "Golfball")
		{
			OBManager.instance.TouchedBounds();
		}
	}
}
public class RingMinigame : Minigame
{
	public TextMeshPro timerText;

	private float timer;

	private void Update()
	{
		if (!finishedMinigame)
		{
			CheckFinishedMinigame();
			timer += Time.deltaTime;
		}
	}

	public override void ShowFinishedText()
	{
		base.ShowFinishedText();
		timerText.text = (int)timer + " seconds";
	}

	public override void CheckFinishedMinigame()
	{
		bool flag = true;
		TargetRing[] array = rings;
		for (int i = 0; i < array.Length; i++)
		{
			if (!array[i].scored)
			{
				flag = false;
				break;
			}
		}
		if (flag)
		{
			finishedMinigame = true;
			ShowFinishedText();
			UnityEngine.Object.Destroy(GameManager.instance.golfball.gameObject);
		}
	}
}
public class OBTrigger : MonoBehaviour
{
	private void OnTriggerEnter(Collider other)
	{
		if (other.tag == "Golfball")
		{
			if (other.GetComponent<BombBall>() != null)
			{
				other.GetComponent<BombBall>().HasGoneOB();
			}
			else
			{
				OBManager.instance.TouchedBounds();
			}
		}
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (!(collision.transform.tag == "Golfball"))
		{
			return;
		}
		if (collision.transform.GetComponent<BombBall>() != null)
		{
			collision.transform.GetComponent<BombBall>().HasGoneOB();
		}
		else if (base.gameObject.layer == LayerMask.NameToLayer("GolfingSurface"))
		{
			OBManager.instance.TouchedBounds();
		}
		else
		{
			OBManager.instance.TouchedBounds(playSFX: false);
		}
		if (base.gameObject.layer == LayerMask.NameToLayer("Water"))
		{
			if (base.transform.parent.name.Contains("Hard"))
			{
				GameManager.instance.golfball.PlayWaterSplashPFX(2);
			}
			else if (base.transform.parent.name.Contains("Medium"))
			{
				GameManager.instance.golfball.PlayWaterSplashPFX(1);
			}
			else
			{
				GameManager.instance.golfball.PlayWaterSplashPFX(0);
			}
		}
	}
}
public class Player : MonoBehaviour
{
	public static Player instance;

	public Transform head;

	public ControllerInput currentControllerInput;

	public ControllerInput rightController;

	public ControllerInput leftController;

	public Controller currentController;

	public GameObject clubs;

	public GameObject editorTools;

	public EditorGrabber editorGrabber;

	public ClubSwitcher clubSwitcher;

	public bool invertedRotation;

	private float rotateViewAngle = 30f;

	private float rotateAroundBallDistance = 1.5f;

	[Header("FADE")]
	public Renderer fadeSphereRenderer;

	public CanvasGroup loadingCanvas;

	public GameObject loadingIcon;

	public bool isFading;

	private float fadeTime = 1f;

	private bool finishedQuestSplashFade;

	private float timeTillNextSwap = 0.5f;

	private float timeTillReconnectController = 5f;

	public bool rightHanded = true;

	public Transform controllerRestPosition;

	public Transform puttRadiusTransform;

	public float puttRadius = 2f;

	public float puttDiameter;

	public float puttRadiusStartAngle = 5f;

	public float puttRadiusEndAngle = 7.5f;

	public float puttRadiusSlope;

	public Transform feet;

	public LayerMask feetLayerMask;

	private RaycastHit feetHit;

	[HideInInspector]
	public Autowarp autoWarp;

	public DistanceBlips blips;

	public Image minimapPlayerMarker;

	[Header("Fake Boss Loading Screen")]
	public TextMeshProUGUI bossText;

	public Image bossImage;

	public Sprite boss1Image;

	public Sprite boss2Image;

	public Sprite boss3Image;

	[Header("XR Player")]
	public GameObject rightHandXRModel;

	public GameObject leftHandXRModel;

	private void Awake()
	{
		instance = this;
	}

	private IEnumerator Start()
	{
		autoWarp = GetComponent<Autowarp>();
		yield return new WaitForEndOfFrame();
		rightHanded = GameManager.instance.GetHandedness();
		if (GameManager.instance.controllerType == ControllerType.Vive)
		{
			if (rightController.gameObject.activeSelf && !leftController.gameObject.activeSelf)
			{
				currentController.transform.SetParent(rightController.transform);
			}
			else if (!rightController.gameObject.activeSelf && leftController.gameObject.activeSelf)
			{
				currentController.transform.SetParent(leftController.transform);
			}
			else if (rightController.gameObject.activeSelf && leftController.gameObject.activeSelf)
			{
				if (rightHanded)
				{
					currentController.transform.SetParent(rightController.transform);
				}
				else
				{
					currentController.transform.SetParent(leftController.transform);
				}
			}
		}
		else if (GameManager.instance.controllerType == ControllerType.XR)
		{
			if (!rightHanded)
			{
				SwapXRControllerHandedness(right: false);
			}
		}
		else if (!rightHanded)
		{
			currentController.transform.SetParent(leftController.transform);
		}
		if (rightHanded)
		{
			clubSwitcher.clubContainer.localScale = new Vector3(1f, 1f, 1f);
		}
		else
		{
			clubSwitcher.clubContainer.localScale = new Vector3(-1f, 1f, 1f);
		}
		currentController.transform.localPosition = Vector3.zero;
		currentController.transform.localEulerAngles = SaveFileManager.instance.GetClubAngle();
		ControllerInput componentInParent = currentController.GetComponentInParent<ControllerInput>();
		if (componentInParent != null)
		{
			currentControllerInput = componentInParent;
			currentController.controllerInput = componentInParent;
		}
		minimapPlayerMarker.color = GameManager.instance.GetBallColor();
		if (currentController.constrainedSwing)
		{
			puttDiameter = puttRadius * 0.5f;
			puttRadiusTransform.gameObject.SetActive(value: true);
			puttRadiusTransform.localScale = new Vector3(puttDiameter, 0.2f, puttDiameter);
			puttRadiusSlope = -1f / (puttRadiusEndAngle - puttRadiusStartAngle);
		}
	}

	private void Update()
	{
		if (GameManager.instance.currentSceneName != "Splash")
		{
			if (!editorTools.activeSelf && currentControllerInput != null && !currentControllerInput.bButton.down)
			{
				if (currentControllerInput.touchpadStatus.leftTouchpadButtonStatus.wasPressed)
				{
					RotateView(cw: false);
				}
				else if (currentControllerInput.touchpadStatus.rightTouchpadButtonStatus.wasPressed)
				{
					RotateView();
				}
			}
			if (timeTillNextSwap <= 0f)
			{
				ReconnectController();
				DetectControllerPress();
			}
			else
			{
				timeTillNextSwap -= Time.deltaTime;
			}
			if (currentController.constrainedSwing)
			{
				PuttRadius();
			}
		}
		if (GameManager.instance.controllerType != ControllerType.FPS)
		{
			minimapPlayerMarker.transform.position = new Vector3(base.transform.position.x, base.transform.position.y + 300f, base.transform.position.z);
			minimapPlayerMarker.transform.parent.eulerAngles = new Vector3(90f, head.eulerAngles.y, 0f);
		}
		if (GameManager.instance.controllerType == ControllerType.XR)
		{
			Vector3 localPosition = head.localPosition;
			localPosition.y = 0f;
			head.localPosition = localPosition;
		}
	}

	private void OculusRecenter()
	{
		if (!OVRInput.GetControllerWasRecentered(currentControllerInput.oculusController))
		{
			return;
		}
		if (GameManager.instance.currentSceneName == "CustomHoleScene")
		{
			base.transform.rotation = CustomHoleScene.instance.teeboxes[0].teeLocation.rotation;
		}
		else if (GameManager.instance.currentSceneName == "LevelEditor")
		{
			if (LevelEditor.instance.previewing)
			{
				base.transform.rotation = LevelEditor.instance.GetStartPoint().transform.rotation;
			}
			else
			{
				base.transform.rotation = Quaternion.identity;
			}
		}
		else
		{
			base.transform.rotation = Quaternion.identity;
		}
	}

	public void SwitchToClub()
	{
		clubs.SetActive(value: true);
		editorTools.SetActive(value: false);
		autoWarp.enabled = true;
		currentController.pointerActive = false;
		currentController.SetupTouchpadButtons(secondaryButtons: false);
	}

	public void SwitchToEditorTools()
	{
		clubs.SetActive(value: false);
		editorTools.SetActive(value: true);
		autoWarp.enabled = false;
		currentController.SwitchToEditorButtons();
	}

	public void RotateView(bool cw = true)
	{
		if (currentController.constrainedSwing && currentController.controllerMode == ControllerMode.PuttingMode)
		{
			return;
		}
		if (invertedRotation)
		{
			cw = !cw;
		}
		float num = rotateViewAngle;
		if (!cw)
		{
			num = 0f - num;
		}
		Vector3 point = ((!currentController.constrainedSwing) ? head.position : ((!(GameManager.instance.golfball != null) || currentController.controllerMode == ControllerMode.FollowMode) ? base.transform.position : GameManager.instance.golfball.transform.position));
		if (GameManager.instance.golfball != null)
		{
			Vector3 position = head.position;
			position.y = GameManager.instance.golfball.transform.position.y;
			if (Vector3.Distance(position, GameManager.instance.golfball.transform.position) < rotateAroundBallDistance)
			{
				base.transform.RotateAround(GameManager.instance.golfball.transform.position, Vector3.up, num);
			}
			else
			{
				base.transform.RotateAround(point, Vector3.up, num);
			}
		}
		else
		{
			base.transform.RotateAround(point, Vector3.up, num);
		}
		clubSwitcher.ResetClubVelocities();
		if (TutorialManager.instance != null)
		{
			TutorialManager.instance.RotatedView();
		}
	}

	public IEnumerator FadeOut()
	{
		if (GameManager.instance.currentSceneName == "Splash" || (GameManager.instance.currentSceneName == "Tutorial" && !GameManager.instance.pieceHashGenerated))
		{
			currentController.gameObject.SetActive(value: false);
			loadingCanvas.gameObject.SetActive(value: true);
			loadingIcon.gameObject.SetActive(value: true);
		}
		loadingCanvas.alpha = 0f;
		Color c = Color.black;
		c.a = 0f;
		fadeSphereRenderer.gameObject.SetActive(value: true);
		fadeSphereRenderer.material.color = c;
		float elapsedTime = 0f;
		isFading = true;
		finishedQuestSplashFade = true;
		GameManager.instance.finishedFadeOut = false;
		while (elapsedTime < fadeTime)
		{
			elapsedTime += Time.deltaTime;
			float num = 1f - Mathf.Clamp01((fadeTime - elapsedTime) / fadeTime);
			loadingCanvas.alpha = num;
			c.a = num;
			fadeSphereRenderer.material.color = c;
			yield return null;
		}
		GameManager.instance.finishedFadeOut = true;
	}

	public IEnumerator ShowBossLoadingScreen(string scene, UnityEngine.AsyncOperation async)
	{
		StartCoroutine(GameManager.instance.audioManager.FadeOutAllSounds());
		currentController.gameObject.SetActive(value: false);
		GameManager.instance.pauseMenu.allowPausing = false;
		loadingCanvas.gameObject.SetActive(value: true);
		bossImage.gameObject.SetActive(value: true);
		bossText.gameObject.SetActive(value: true);
		loadingIcon.gameObject.SetActive(value: false);
		if (scene == "Boss1")
		{
			bossImage.sprite = boss1Image;
		}
		else if (scene.Contains("Boss2"))
		{
			bossImage.sprite = boss2Image;
		}
		else if (scene == "Boss3")
		{
			bossImage.sprite = boss3Image;
		}
		float seconds = 0f;
		int numPeriods = 0;
		string loading = LocalizationManager.GetTranslation("Loading");
		float boss3Timer = 5f;
		bool boss3HintChange = true;
		while (async.progress < 0.9f)
		{
			if (scene == "Boss1")
			{
				bossText.text = LocalizationManager.GetTranslation("Rocks will fall from the ceiling and block your path") + " \n" + loading;
			}
			else if (scene.Contains("Boss2"))
			{
				bossText.text = LocalizationManager.GetTranslation("Hit the magic orbs back with your club") + " \n" + loading;
			}
			else if (scene == "Boss3")
			{
				boss3Timer -= Time.deltaTime;
				if (boss3Timer <= 0f)
				{
					boss3Timer = 5f;
					boss3HintChange = !boss3HintChange;
				}
				if (boss3HintChange)
				{
					bossText.text = LocalizationManager.GetTranslation("Stay safe in the shadows") + " \n" + loading;
				}
				else
				{
					bossText.text = LocalizationManager.GetTranslation("The Reaper cannot be hit by the golfball") + " \n" + loading;
				}
			}
			seconds += Time.deltaTime;
			if (seconds > 1f)
			{
				seconds = 0f;
				numPeriods++;
				if (numPeriods > 3)
				{
					numPeriods = 0;
				}
				loading = LocalizationManager.GetTranslation("Loading");
				for (int i = 0; i < numPeriods; i++)
				{
					loading += ".";
				}
			}
			yield return null;
		}
		if (scene == "Boss1")
		{
			bossText.text = LocalizationManager.GetTranslation("Rocks will fall from the ceiling and block your path") + " \n(" + LocalizationManager.GetTranslation("Press Any Button to Continue") + ")";
		}
		else if (scene.Contains("Boss2"))
		{
			bossText.text = LocalizationManager.GetTranslation("Hit the magic orbs back with your club") + " \n(" + LocalizationManager.GetTranslation("Press Any Button to Continue") + ")";
		}
		while (!currentControllerInput.AnyButtonPressed())
		{
			if (scene == "Boss3")
			{
				boss3Timer -= Time.deltaTime;
				if (boss3Timer <= 0f)
				{
					boss3Timer = 5f;
					boss3HintChange = !boss3HintChange;
				}
				if (boss3HintChange)
				{
					bossText.text = LocalizationManager.GetTranslation("Stay safe in the shadows") + " \n(" + LocalizationManager.GetTranslation("Press Any Button to Continue") + ")";
				}
				else
				{
					bossText.text = LocalizationManager.GetTranslation("The Reaper cannot be hit by the golfball") + " \n(" + LocalizationManager.GetTranslation("Press Any Button to Continue") + ")";
				}
			}
			yield return null;
		}
		bossText.gameObject.SetActive(value: false);
		bossImage.gameObject.SetActive(value: false);
		currentController.gameObject.SetActive(value: true);
		GameManager.instance.pauseMenu.allowPausing = true;
		GameManager.instance.canProceedThroughBossLoadingScreen = true;
		StartCoroutine(GameManager.instance.audioManager.FadeInAllSounds());
	}

	public IEnumerator FadeIn()
	{
		if (GameManager.instance.currentSceneName != "Splash")
		{
			loadingCanvas.gameObject.SetActive(value: false);
			currentController.gameObject.SetActive(value: true);
		}
		float elapsedTime = 0f;
		isFading = true;
		Color c = Color.black;
		while (elapsedTime < fadeTime)
		{
			elapsedTime += Time.deltaTime;
			float num = 1f - Mathf.Clamp01(elapsedTime / fadeTime);
			loadingCanvas.alpha = num;
			c.a = num;
			fadeSphereRenderer.material.color = c;
			yield return null;
		}
		loadingCanvas.gameObject.SetActive(value: false);
		fadeSphereRenderer.gameObject.SetActive(value: false);
		isFading = false;
		GameManager.instance.loadingLevel = false;
		yield return null;
	}

	private void ReconnectController()
	{
		bool flag = false;
		if (GameManager.instance.controllerType == ControllerType.Vive)
		{
			if (!currentControllerInput.gameObject.activeSelf)
			{
				if (rightHanded && leftController.gameObject.activeSelf)
				{
					flag = true;
				}
				else if (!rightHanded && rightController.gameObject.activeSelf)
				{
					flag = true;
				}
			}
		}
		else if (GameManager.instance.controllerType == ControllerType.Quest)
		{
			if (!OVRInput.IsControllerConnected(OVRInput.Controller.RTouch) && rightHanded)
			{
				if (OVRInput.IsControllerConnected(OVRInput.Controller.LTouch))
				{
					flag = true;
				}
			}
			else if (!OVRInput.IsControllerConnected(OVRInput.Controller.LTouch) && !rightHanded && OVRInput.IsControllerConnected(OVRInput.Controller.RTouch))
			{
				flag = true;
			}
		}
		else if (GameManager.instance.controllerType != ControllerType.XR && GameManager.instance.controllerType == ControllerType.Pico)
		{
			if (Pvr_UnitySDKAPI.Controller.UPvr_GetControllerState(1) != ControllerState.Connected && rightHanded)
			{
				if (Pvr_UnitySDKAPI.Controller.UPvr_GetControllerState(0) == ControllerState.Connected)
				{
					flag = true;
				}
			}
			else if (Pvr_UnitySDKAPI.Controller.UPvr_GetControllerState(0) != ControllerState.Connected && !rightHanded && Pvr_UnitySDKAPI.Controller.UPvr_GetControllerState(1) == ControllerState.Connected)
			{
				flag = true;
			}
		}
		if (flag)
		{
			timeTillReconnectController -= Time.deltaTime;
			if (timeTillReconnectController <= 0f)
			{
				if (GameManager.instance.controllerType == ControllerType.XR)
				{
					Notification.instance.AddMultipleChoiceNotification("Controller lost connectivity. Please reconnect or quit game.", ExitGame, Notification.instance.CloseSign, "Exit Game", "Close");
					return;
				}
				timeTillReconnectController = 5f;
				Notification.instance.AddNotification("Controller lost connectivity. Switching to available controller.", 0f, closeButton: true);
				SwapControllers();
			}
		}
		else
		{
			timeTillReconnectController = 5f;
		}
	}

	public void SwapControllers()
	{
		if (!(timeTillNextSwap <= 0f))
		{
			return;
		}
		Transform transform = currentController.transform;
		if (GameManager.instance.controllerType == ControllerType.Vive)
		{
			if (!rightHanded)
			{
				rightHanded = true;
				GameManager.instance.SetHandedness(rightHanded: true);
				clubSwitcher.clubContainer.localScale = new Vector3(1f, 1f, 1f);
			}
			else
			{
				rightHanded = false;
				GameManager.instance.SetHandedness(rightHanded: false);
				clubSwitcher.clubContainer.localScale = new Vector3(-1f, 1f, 1f);
			}
			if (rightController.gameObject.activeSelf && !leftController.gameObject.activeSelf)
			{
				transform.SetParent(rightController.transform);
			}
			else if (!rightController.gameObject.activeSelf && leftController.gameObject.activeSelf)
			{
				transform.SetParent(leftController.transform);
			}
			else if (rightController.gameObject.activeSelf && leftController.gameObject.activeSelf)
			{
				if (rightHanded)
				{
					transform.SetParent(rightController.transform);
				}
				else
				{
					transform.SetParent(leftController.transform);
				}
			}
		}
		else if (GameManager.instance.controllerType == ControllerType.Quest)
		{
			if (!rightHanded)
			{
				rightHanded = true;
				GameManager.instance.SetHandedness(rightHanded: true);
				transform.SetParent(rightController.transform);
				clubSwitcher.clubContainer.localScale = new Vector3(1f, 1f, 1f);
			}
			else
			{
				rightHanded = false;
				GameManager.instance.SetHandedness(rightHanded: false);
				transform.SetParent(leftController.transform);
				clubSwitcher.clubContainer.localScale = new Vector3(-1f, 1f, 1f);
			}
		}
		else if (GameManager.instance.controllerType == ControllerType.Pico)
		{
			if (!rightHanded)
			{
				rightHanded = true;
				GameManager.instance.SetHandedness(rightHanded: true);
				transform.SetParent(rightController.transform);
				clubSwitcher.clubContainer.localScale = new Vector3(1f, 1f, 1f);
			}
			else
			{
				rightHanded = false;
				GameManager.instance.SetHandedness(rightHanded: false);
				transform.SetParent(leftController.transform);
				clubSwitcher.clubContainer.localScale = new Vector3(-1f, 1f, 1f);
			}
		}
		ControllerInput controllerInput = (currentControllerInput = currentController.GetComponentInParent<ControllerInput>());
		currentController.controllerInput = controllerInput;
		transform.transform.localPosition = Vector3.zero;
		transform.transform.localEulerAngles = SaveFileManager.instance.GetClubAngle();
		timeTillNextSwap = 0.5f;
	}

	public void SwapXRControllerHandedness(bool right)
	{
		if (rightHanded != right)
		{
			rightHanded = right;
			GameManager.instance.SetHandedness(rightHanded);
			if (rightHanded)
			{
				clubSwitcher.clubContainer.localScale = new Vector3(1f, 1f, 1f);
			}
			else
			{
				clubSwitcher.clubContainer.localScale = new Vector3(-1f, 1f, 1f);
			}
		}
	}

	private void DetectControllerPress()
	{
		bool flag = false;
		if (GameManager.instance.controllerType == ControllerType.Vive)
		{
			if (leftController.gameObject.activeSelf && rightController.gameObject.activeSelf)
			{
				flag = true;
			}
		}
		else if (GameManager.instance.controllerType == ControllerType.Quest)
		{
			if (OVRInput.IsControllerConnected(OVRInput.Controller.LTouch) && OVRInput.IsControllerConnected(OVRInput.Controller.RTouch))
			{
				flag = true;
			}
		}
		else if (GameManager.instance.controllerType == ControllerType.Pico && Pvr_UnitySDKAPI.Controller.UPvr_GetControllerState(0) == ControllerState.Connected && Pvr_UnitySDKAPI.Controller.UPvr_GetControllerState(1) == ControllerState.Connected)
		{
			flag = true;
		}
		if (!flag)
		{
			return;
		}
		if (GameManager.instance.controllerType == ControllerType.Quest)
		{
			if (rightHanded && leftController.xButton.wasReleased && currentControllerInput == rightController)
			{
				Notification.instance.AddNotification("Other controller pressed. Swapping to other controller", 0f, closeButton: true);
				SwapControllers();
			}
			else if (!rightHanded && rightController.xButton.wasReleased && currentControllerInput == leftController)
			{
				Notification.instance.AddNotification("Other controller pressed. Swapping to other controller", 0f, closeButton: true);
				SwapControllers();
			}
		}
		else if (GameManager.instance.controllerType == ControllerType.Vive)
		{
			if (!rightHanded && leftController.xButton.wasReleased && currentControllerInput == rightController)
			{
				Notification.instance.AddNotification("Other controller pressed. Swapping to other controller", 0f, closeButton: true);
				SwapControllers();
			}
			else if (rightHanded && rightController.xButton.wasReleased && currentControllerInput == leftController)
			{
				Notification.instance.AddNotification("Other controller pressed. Swapping to other controller", 0f, closeButton: true);
				SwapControllers();
			}
			else if (rightHanded && leftController.xButton.wasReleased && currentControllerInput == rightController)
			{
				Notification.instance.AddNotification("Other controller pressed. Swapping to other controller", 0f, closeButton: true);
				SwapControllers();
			}
			else if (!rightHanded && rightController.xButton.wasReleased && currentControllerInput == leftController)
			{
				Notification.instance.AddNotification("Other controller pressed. Swapping to other controller", 0f, closeButton: true);
				SwapControllers();
			}
		}
		else if (GameManager.instance.controllerType == ControllerType.Pico)
		{
			if (rightHanded && currentControllerInput == rightController && (leftController.xButton.wasReleased || leftController.startButton.wasReleased))
			{
				Notification.instance.AddNotification("Other controller pressed. Swapping to other controller", 0f, closeButton: true);
				SwapControllers();
			}
			else if (!rightHanded && currentControllerInput == leftController && (rightController.xButton.wasReleased || rightController.startButton.wasReleased))
			{
				Notification.instance.AddNotification("Other controller pressed. Swapping to other controller", 0f, closeButton: true);
				SwapControllers();
			}
		}
	}

	public bool InPuttRadius()
	{
		bool result = false;
		Vector3 position = head.position;
		position.y = base.transform.position.y;
		if (GameManager.instance.golfball != null && (GameManager.instance.golfball.transform.position - position).magnitude < puttRadius)
		{
			result = true;
		}
		return result;
	}

	private void PuttRadius()
	{
		if (GameManager.instance.golfball != null && !ScoreManager.instance.ballScored)
		{
			Golfball component = GameManager.instance.golfball.GetComponent<Golfball>();
			if (Physics.Raycast(component.transform.position + Vector3.up * 0.1f, Vector3.down, out feetHit, 0.5f, feetLayerMask))
			{
				puttRadiusTransform.position = feetHit.point + Vector3.up * 0.001f;
				puttRadiusTransform.rotation = Quaternion.LookRotation(Vector3.Cross(feetHit.normal, Vector3.forward), feetHit.normal);
				float num = Vector3.Angle(feetHit.normal, Vector3.up);
				Vector3 position = head.position;
				position.y = base.transform.position.y;
				float magnitude = (GameManager.instance.golfball.transform.position - position).magnitude;
				float num2 = 0.2f;
				if (magnitude < puttRadius)
				{
					puttRadiusTransform.localScale = Vector3.zero;
					return;
				}
				float num3 = Mathf.Min(magnitude - puttRadius, 1f) * num2;
				float num4 = 1f;
				float num5 = 1f;
				if (component.rb.velocity.magnitude > 0f)
				{
					num4 = 1f - Mathf.Min(component.rb.velocity.magnitude, 1f);
					if (num <= puttRadiusStartAngle)
					{
						num5 = 1f;
					}
					else if (num < puttRadiusEndAngle)
					{
						num5 = 1f + puttRadiusSlope * (num - puttRadiusStartAngle);
						num5 = Mathf.Clamp01(num5);
					}
					else
					{
						num5 = 0f;
					}
				}
				puttRadiusTransform.localScale = new Vector3(puttDiameter, num3 * num4 * num5, puttDiameter);
			}
			else
			{
				puttRadiusTransform.localScale = Vector3.zero;
			}
		}
		else
		{
			puttRadiusTransform.localScale = Vector3.zero;
		}
	}

	public bool ToggleRotateDirection()
	{
		invertedRotation = !invertedRotation;
		return invertedRotation;
	}

	public void RotateHeadToFaceBall()
	{
		if (!(GameManager.instance.golfball != null))
		{
			return;
		}
		Quaternion rotation = base.transform.rotation;
		UnityEngine.Debug.DrawLine(base.transform.position, base.transform.position + base.transform.forward * 1.5f, Color.yellow, 10f);
		Vector3 vector = head.forward;
		vector.y = 0f;
		if (Vector3.Project(head.up, Vector3.up).y < 0f)
		{
			vector = -vector;
		}
		if (vector == Vector3.zero)
		{
			if (Vector3.Project(head.forward, Vector3.up).y > 0f)
			{
				vector -= head.up;
			}
			else
			{
				vector += head.up;
			}
			vector.y = 0f;
		}
		Vector3 position = GameManager.instance.golfball.transform.position;
		position.y = base.transform.position.y;
		Quaternion quaternion = Quaternion.FromToRotation(vector, position - base.transform.position);
		rotation *= quaternion;
		base.transform.rotation = rotation;
		Vector3 eulerAngles = base.transform.rotation.eulerAngles;
		eulerAngles.x = 0f;
		eulerAngles.y -= 90f;
		eulerAngles.z = 0f;
		base.transform.eulerAngles = eulerAngles;
	}

	public void RotateHeadToFacePosition(Transform pos)
	{
		base.transform.eulerAngles = Vector3.zero;
		Vector3 eulerAngles = pos.eulerAngles;
		Vector3 eulerAngles2 = head.eulerAngles;
		eulerAngles.x = 0f;
		eulerAngles.z = 0f;
		eulerAngles2.x = 0f;
		eulerAngles2.z = 0f;
		Vector3 eulerAngles3 = eulerAngles - eulerAngles2;
		base.transform.eulerAngles = eulerAngles3;
	}

	private void ExitGame()
	{
		StartCoroutine(GameManager.instance._ExitGame());
	}
}
public class PracticeGolfhole : MonoBehaviour
{
	private AudioSource audioSource;

	public AudioClip sfxGolfBallDrop;

	public AudioClip sfxTickAudio;

	public Transform respawnPoint;

	private bool ballScoredInHole;

	private void Start()
	{
		audioSource = GetComponent<AudioSource>();
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.tag == "Golfball")
		{
			BallScored();
		}
	}

	private void BallScored()
	{
		if (!ballScoredInHole)
		{
			ballScoredInHole = true;
			audioSource.PlayOneShot(sfxGolfBallDrop);
			if (GameManager.instance.currentSceneName == "Tutorial")
			{
				StartCoroutine(NextHoleCountdown());
			}
			else if (GameManager.instance.currentSceneName == "MainMenu")
			{
				StartCoroutine(RespawnBall());
			}
		}
	}

	private IEnumerator RespawnBall()
	{
		yield return new WaitForSeconds(2f);
		ballScoredInHole = false;
		Golfball golfball = UnityEngine.Object.FindObjectOfType<Golfball>();
		golfball.FreezeVelocity();
		golfball.transform.position = respawnPoint.position;
		golfball.DestroyTrailRenderer();
	}

	private IEnumerator NextHoleCountdown()
	{
		yield return new WaitForSeconds(3f);
		int ticks = 3;
		while (ticks > 0)
		{
			ticks--;
			audioSource.PlayOneShot(sfxTickAudio);
			yield return new WaitForSeconds(1f);
		}
		GameManager.instance.BackToMainMenu();
	}
}
public class ScoreCard : MonoBehaviour
{
	public TextMeshPro[] holes;

	public TextMeshPro[] pars;

	public TextMeshPro parTotal;

	public TextMeshPro currentHole;

	public TextMeshPro currentStroke;

	public TextMeshPro bossScore;

	public TextMeshPro bossPar;

	public Renderer bossScoreSymbol;

	[Header("===In Out===")]
	public TextMeshPro inParTotal;

	public TextMeshPro out1ParTotal;

	public TextMeshPro out2ParTotal;

	public TextMeshPro[] strokeTotal;

	public TextMeshPro[] inStrokeTotal;

	public TextMeshPro[] out1StrokeTotal;

	public TextMeshPro[] out2StrokeTotal;

	public Row[] strokes = new Row[4];

	public Text[] playerNames = new Text[4];

	public Image[] playerGolfballs = new Image[4];

	public Texture[] symbolTextures;

	public bool isCampaignScorecard;

	private void OnEnable()
	{
		OnLocalizationCall();
	}

	private void SetPars()
	{
		for (int i = 0; i < 18; i++)
		{
			if (i < GameManager.instance.holeData.Count && ScoreManager.instance.pars[i] != -1)
			{
				pars[i].text = ScoreManager.instance.pars[i].ToString();
			}
			else
			{
				pars[i].text = "";
			}
		}
		SetInOutParTotal();
	}

	private void SetHoles()
	{
		for (int i = 0; i < 18; i++)
		{
			if (GameManager.instance.currentSceneName == "RoomPrepScene")
			{
				holes[i].text = "";
			}
			else if (i < GameManager.instance.holeData.Count)
			{
				holes[i].text = (i + 1).ToString();
			}
			else
			{
				holes[i].text = "";
			}
		}
	}

	private void SetInOutParTotal()
	{
		int num = 0;
		int num2 = 0;
		for (int i = 0; i < 18; i++)
		{
			if (i < GameManager.instance.holeData.Count)
			{
				if (i < 9)
				{
					if (ScoreManager.instance.pars[i] != -1)
					{
						num += ScoreManager.instance.pars[i];
					}
				}
				else if (ScoreManager.instance.pars[i] != -1)
				{
					num2 += ScoreManager.instance.pars[i];
				}
			}
			out1ParTotal.text = num.ToString();
			inParTotal.text = num2.ToString();
			out2ParTotal.text = num.ToString();
		}
		if (GameManager.instance.gameMode == GameMode.Campaign && !GameManager.instance.hideBosses)
		{
			int result = 0;
			int.TryParse(bossPar.text.ToString(), out result);
			parTotal.text = (num + num2 + result).ToString();
		}
		else
		{
			parTotal.text = (num + num2).ToString();
		}
	}

	public void SetStrokes()
	{
		for (int i = 0; i < 4; i++)
		{
			int num = 0;
			if (GameManager.instance.currentSceneName.Contains("Boss"))
			{
				num = 0;
			}
			else
			{
				num = GameManager.instance.holeIndex;
				if (GameManager.instance.playerCount > 1)
				{
					num = ScoreManager.instance.playerTurn[i].holeIndex;
				}
			}
			if (i >= strokes.Length)
			{
				continue;
			}
			for (int j = 0; j < 18; j++)
			{
				if (((j <= num || GameManager.instance.currentSceneName == "ScoreScene") && ScoreManager.instance.strokeTable[i][j] != -1 && GameManager.instance.gameMode != GameMode.Campaign) || (GameManager.instance.gameMode == GameMode.Campaign && ScoreManager.instance.strokeTable[0][j] != 0))
				{
					strokes[i].holeStrokes[j].text = ScoreManager.instance.strokeTable[i][j].ToString();
				}
				else
				{
					strokes[i].holeStrokes[j].text = "";
				}
			}
		}
		SetInOutStrokeTotal();
	}

	private void SetInOutStrokeTotal()
	{
		for (int i = 0; i < 4; i++)
		{
			if (i >= strokes.Length)
			{
				continue;
			}
			if ((PhotonNetwork.IsConnected && i < PhotonManager.instance.GetUsablePlayers().Count) || (!PhotonNetwork.IsConnected && i < GameManager.instance.playerCount))
			{
				out1StrokeTotal[i].text = ScoreManager.instance.GetInOutTotal(i, "out").ToString();
				inStrokeTotal[i].text = ScoreManager.instance.GetInOutTotal(i, "in").ToString();
				out2StrokeTotal[i].text = ScoreManager.instance.GetInOutTotal(i, "out").ToString();
				if (GameManager.instance.gameMode == GameMode.Campaign && !GameManager.instance.hideBosses)
				{
					int result = 0;
					int.TryParse(bossScore.text.ToString(), out result);
					strokeTotal[i].text = (ScoreManager.instance.GetInOutTotal(i, "") + result).ToString();
				}
				else
				{
					strokeTotal[i].text = ScoreManager.instance.GetInOutTotal(i, "").ToString();
				}
			}
			else
			{
				out1StrokeTotal[i].text = "";
				inStrokeTotal[i].text = "";
				out2StrokeTotal[i].text = "";
				strokeTotal[i].text = "";
			}
		}
	}

	private void SetCurrentStroke()
	{
		if (GameManager.instance.currentSceneName.Contains("Hole") || GameManager.instance.currentSceneName.Contains("Boss"))
		{
			currentStroke.text = LocalizationManager.GetTranslation("Current Stroke:") + " " + ScoreManager.instance.currentStrokeCount;
		}
		else
		{
			currentStroke.text = "";
		}
	}

	private void SetCurrentHole()
	{
		if (GameManager.instance.currentSceneName == "CustomHoleScene")
		{
			currentHole.text = LocalizationManager.GetTranslation("Current Hole:") + " " + (GameManager.instance.holeIndex + 1);
		}
		else if (GameManager.instance.currentSceneName.Contains("Boss"))
		{
			if (GameManager.instance.holeIndex == 18)
			{
				currentHole.text = LocalizationManager.GetTranslation("Boss: Grugg");
			}
			else if (GameManager.instance.holeIndex == 36)
			{
				currentHole.text = LocalizationManager.GetTranslation("Boss: Magician");
			}
			else if (GameManager.instance.holeIndex == 54)
			{
				currentHole.text = LocalizationManager.GetTranslation("Boss: Reaper");
			}
		}
		else
		{
			currentHole.text = "";
		}
	}

	public void SetPlayerNames()
	{
		for (int i = 0; i < 4; i++)
		{
			if (i >= playerNames.Length)
			{
				continue;
			}
			if (PhotonNetwork.IsConnected)
			{
				List<Photon.Realtime.Player> usablePlayers = PhotonManager.instance.GetUsablePlayers(includeSelf: false);
				if (i != 0)
				{
					playerGolfballs[i].enabled = false;
				}
				if (i == 0)
				{
					if (PhotonNetwork.InRoom)
					{
						playerGolfballs[i].enabled = true;
					}
					else
					{
						playerGolfballs[i].enabled = false;
					}
					playerGolfballs[i].color = ScoreManager.instance.playerTurn[i].ballColor;
					playerNames[i].text = PhotonNetwork.LocalPlayer.NickName;
				}
				else if (i - 1 < usablePlayers.Count)
				{
					playerNames[i].text = usablePlayers[i - 1].NickName;
				}
				else
				{
					playerNames[i].text = "";
				}
			}
			else if (i < GameManager.instance.playerCount)
			{
				if (i == GameManager.instance.playerIndex)
				{
					playerGolfballs[i].color = ScoreManager.instance.playerTurn[i].ballColor;
					playerGolfballs[i].enabled = true;
				}
				else
				{
					playerGolfballs[i].enabled = false;
				}
				if (ScoreManager.instance.playerTurn[i].playerName == "")
				{
					playerNames[i].text = "P" + (i + 1);
				}
				else
				{
					playerNames[i].text = ScoreManager.instance.playerTurn[i].playerName;
				}
			}
			else
			{
				playerGolfballs[i].enabled = false;
				playerNames[i].text = "";
			}
		}
	}

	private void SetSymbols()
	{
		for (int i = 0; i < 4; i++)
		{
			if (i >= strokes.Length)
			{
				continue;
			}
			for (int j = 0; j < 18; j++)
			{
				if ((j <= GameManager.instance.holeIndex && ScoreManager.instance.strokeTable[i][j] != -1 && GameManager.instance.gameMode != GameMode.Campaign) || (GameManager.instance.gameMode == GameMode.Campaign && ScoreManager.instance.strokeTable[0][j] != 0))
				{
					if (ScoreManager.instance.strokeTable[i][j] == 1)
					{
						strokes[i].scoreSymbols[j].material.mainTexture = symbolTextures[1];
					}
					else if (ScoreManager.instance.strokeTable[i][j] < ScoreManager.instance.pars[j] - 1)
					{
						strokes[i].scoreSymbols[j].material.mainTexture = symbolTextures[2];
					}
					else if (ScoreManager.instance.strokeTable[i][j] == ScoreManager.instance.pars[j] - 1)
					{
						strokes[i].scoreSymbols[j].material.mainTexture = symbolTextures[3];
					}
					else
					{
						strokes[i].scoreSymbols[j].material.mainTexture = symbolTextures[0];
					}
				}
				else
				{
					strokes[i].scoreSymbols[j].material.mainTexture = symbolTextures[0];
				}
			}
			if (!isCampaignScorecard || GameManager.instance.hideBosses)
			{
				continue;
			}
			int[] array = SaveFileManager.instance.saveFile.bossScore;
			int num = 0;
			if (GameManager.instance.campaignDifficulty == Difficulty.Easy)
			{
				num = array[0];
			}
			else if (GameManager.instance.campaignDifficulty == Difficulty.Medium)
			{
				num = array[1];
			}
			else if (GameManager.instance.campaignDifficulty == Difficulty.Hard)
			{
				num = array[2];
			}
			switch (num)
			{
			case 1:
				bossScoreSymbol.material.mainTexture = symbolTextures[1];
				continue;
			case 0:
				bossScoreSymbol.material.mainTexture = symbolTextures[0];
				continue;
			}
			if (num < GameManager.instance.holeData[GameManager.instance.holeData.Count - 1].par - 1)
			{
				bossScoreSymbol.material.mainTexture = symbolTextures[2];
			}
			else if (num == GameManager.instance.holeData[GameManager.instance.holeData.Count - 1].par - 1)
			{
				bossScoreSymbol.material.mainTexture = symbolTextures[3];
			}
			else
			{
				bossScoreSymbol.material.mainTexture = symbolTextures[0];
			}
		}
	}

	public void ToggleScoreCard(bool x)
	{
		base.gameObject.SetActive(x);
		if (x)
		{
			UpdateAllValues();
		}
	}

	public int ReturnStartingCampaignHole()
	{
		int result = 0;
		if (GameManager.instance.campaignDifficulty == Difficulty.Medium)
		{
			result = 18;
		}
		else if (GameManager.instance.campaignDifficulty == Difficulty.Hard)
		{
			result = 36;
		}
		return result;
	}

	public void UpdateAllValues()
	{
		if (isCampaignScorecard && !GameManager.instance.hideBosses)
		{
			SetBossValues();
		}
		SetCurrentStroke();
		SetStrokes();
		SetHoles();
		SetPars();
		SetCurrentHole();
		SetPlayerNames();
		SetSymbols();
	}

	private void SetBossValues()
	{
		bossPar.text = GameManager.instance.holeData[GameManager.instance.holeData.Count - 1].par.ToString();
		int[] array = SaveFileManager.instance.saveFile.bossScore;
		if (GameManager.instance.campaignDifficulty == Difficulty.Easy)
		{
			if (array[0] == 0)
			{
				bossScore.text = "";
			}
			else
			{
				bossScore.text = array[0].ToString();
			}
		}
		else if (GameManager.instance.campaignDifficulty == Difficulty.Medium)
		{
			if (array[0] == 0)
			{
				bossScore.text = "";
			}
			else
			{
				bossScore.text = array[1].ToString();
			}
		}
		else if (GameManager.instance.campaignDifficulty == Difficulty.Hard)
		{
			if (array[0] == 0)
			{
				bossScore.text = "";
			}
			else
			{
				bossScore.text = array[2].ToString();
			}
		}
	}

	private void OnLocalizationCall()
	{
		SetCurrentStroke();
		SetCurrentHole();
	}
}
[Serializable]
public class Row
{
	public TextMeshPro[] holeStrokes;

	public Renderer[] scoreSymbols;
}
public class TreeDampener : MonoBehaviour
{
	public GameObject leavesPrefab;

	private ParticleSystem[] leavesPFX;

	public AudioClip leavesSFX;

	private AudioSource aSource;

	private bool isPlayingPFX;

	private Golfball ball;

	private void Start()
	{
		aSource = GetComponent<AudioSource>();
		leavesPFX = UnityEngine.Object.Instantiate(leavesPrefab, base.transform).transform.GetComponentsInChildren<ParticleSystem>();
	}

	private void Update()
	{
		if (ball != null)
		{
			Vector3 velocity = ball.rb.velocity;
			if (velocity.magnitude > 5f)
			{
				velocity *= 0.1f;
			}
			ball.rb.velocity = velocity;
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.CompareTag("Golfball") && !isPlayingPFX)
		{
			ball = other.GetComponent<Golfball>();
			isPlayingPFX = true;
			aSource.PlayOneShot(leavesSFX);
			if (PhotonNetwork.IsConnected)
			{
				RoomRPC.instance.PlaySound(other.transform.position, leavesSFX.name);
			}
			leavesPFX[0].transform.parent.position = other.transform.position;
			ParticleSystem[] array = leavesPFX;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].Play();
			}
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (other.CompareTag("Golfball"))
		{
			ball = null;
			isPlayingPFX = false;
		}
	}
}
public class Wind : MonoBehaviour
{
	public float windSpeed = 5f;

	public ParticleSystem windPFX;

	[HideInInspector]
	public float originalWindSpeed = 5f;

	private float windMultiplier = 10f;

	public Vector3 direction;

	private ParticleSystem.EmissionModule emission;

	private void Start()
	{
		if (GameManager.instance.IsCloudlands1Hole())
		{
			base.gameObject.SetActive(value: false);
		}
		else
		{
			SetWindSpeed(direction * windSpeed, base.transform);
		}
	}

	private void FixedUpdate()
	{
		windPFX.transform.position = Player.instance.transform.position;
		if (GameManager.instance.golfball != null && !GameManager.instance.golfball.IsGrounded())
		{
			Vector3 vector = direction * windSpeed * windMultiplier;
			GameManager.instance.golfball.rb.AddForce(vector * Time.deltaTime);
		}
	}

	public Vector3 GetWindVector()
	{
		return direction * windSpeed * windMultiplier;
	}

	public void SetRandomWind()
	{
	}

	public void SetWindSpeed(Vector3 speed, Transform trans)
	{
		bool flag = false;
		if (speed.x > 100f && speed.y > 100f)
		{
			windSpeed = UnityEngine.Random.Range(0, (int)(speed.z + 1f));
			originalWindSpeed = windSpeed;
			direction = Quaternion.AngleAxis(UnityEngine.Random.value * 360f, Vector3.up) * Vector3.forward;
			flag = true;
		}
		else
		{
			speed = trans.TransformDirection(speed);
			windSpeed = speed.magnitude;
			originalWindSpeed = windSpeed;
			direction = speed.normalized;
		}
		if ((!(GameManager.instance.currentSceneName == "LevelEditor") || flag) && direction != Vector3.zero)
		{
			base.transform.rotation = Quaternion.LookRotation(direction);
		}
		if (speed.magnitude == 0f)
		{
			windPFX.gameObject.SetActive(value: false);
			return;
		}
		windPFX.gameObject.SetActive(value: true);
		emission = windPFX.emission;
		emission.rateOverTime = windSpeed * 12f;
		ParticleSystem.MainModule main = windPFX.main;
		main.startSpeed = windSpeed * 1.5f;
		float num = 3.22222f - 0.22222f * windSpeed;
		ParticleSystem.MinMaxCurve startLifetime = new ParticleSystem.MinMaxCurve(num, num * 2f);
		main.startLifetime = startLifetime;
	}

	public void ResetWind()
	{
		windSpeed = originalWindSpeed;
	}

	public void NullifyWind()
	{
		windSpeed = 0f;
	}

	public string GetWindSpeedText()
	{
		string text = LocalizationManager.GetTranslation("Wind") + ": 0 mph";
		if (windSpeed == 0f)
		{
			if (originalWindSpeed != 0f)
			{
				return 0 + "(" + originalWindSpeed.ToString("F1") + ") mph";
			}
			return LocalizationManager.GetTranslation("Wind") + ": 0 mph";
		}
		return LocalizationManager.GetTranslation("Wind") + ": " + windSpeed.ToString("F1") + "mph";
	}
}
public class GeneratePieceHash : MonoBehaviour
{
	public GameObject[] editorPieces;

	private void Awake()
	{
		if (GameManager.instance != null && GameManager.instance.pieceHashGenerated)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	private void Start()
	{
		if (!GameManager.instance.pieceHashGenerated)
		{
			GameManager.instance.pieceHashGenerated = true;
			GameManager.instance.GeneratePieceHashTable(editorPieces);
		}
	}
}
public class GetAndroidIntent : MonoBehaviour
{
	public static GetAndroidIntent instance;

	public bool isDefaultAccount = true;

	private void Awake()
	{
		instance = this;
	}

	public void SetAvatarInfo(string avatarFormat)
	{
	}

	public string GetNickname()
	{
		return "";
	}

	public string GetPlayerID()
	{
		return "";
	}
}
public class LevelFileEditor : MonoBehaviour
{
	public string levelLocation;

	public CustomLevel currentLevel;

	public string newLevelName;

	public Song song;

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.J))
		{
			ChangeSong();
		}
	}

	public void LoadInLevel()
	{
		currentLevel = LevelEditor.LoadLevelData(levelLocation);
	}

	public void ChangeSong()
	{
		string path = levelLocation;
		byte[] array = File.ReadAllBytes(path);
		MemoryStream memoryStream = new MemoryStream();
		memoryStream.SetLength(array.Length);
		int num = 27;
		memoryStream.Write(array, 0, num);
		memoryStream.Write(BitConverter.GetBytes((ushort)song), 0, 2);
		memoryStream.Write(array, num + 2, array.Length - num - 2);
		FileStream fileStream = new FileStream(path, FileMode.Create);
		memoryStream.WriteTo(fileStream);
		fileStream.Flush();
		memoryStream.Dispose();
		fileStream.Dispose();
	}

	public void RenameLevel()
	{
		string path = levelLocation;
		byte[] array = File.ReadAllBytes(path);
		byte[] bytes = Encoding.Unicode.GetBytes(newLevelName);
		int num = bytes.Length;
		int num2 = Encoding.Unicode.GetBytes(currentLevel.levelName).Length;
		int value = Encoding.Unicode.GetBytes(currentLevel.creatorName).Length;
		int value2 = Encoding.Unicode.GetBytes(currentLevel.creatorId).Length;
		int num3 = num - num2;
		int num4 = 100;
		int num5 = array.Length + num3;
		MemoryStream memoryStream = new MemoryStream();
		memoryStream.SetLength(num5);
		memoryStream.Write(array, 0, num4);
		memoryStream.Write(BitConverter.GetBytes(num), 0, 4);
		memoryStream.Write(BitConverter.GetBytes(value), 0, 4);
		memoryStream.Write(BitConverter.GetBytes(value2), 0, 4);
		memoryStream.Write(bytes, 0, num);
		int num6 = num4 + 12 + num2;
		int count = array.Length - num6;
		memoryStream.Write(array, num6, count);
		FileStream fileStream = new FileStream(path, FileMode.Create);
		memoryStream.WriteTo(fileStream);
		fileStream.Flush();
		memoryStream.Dispose();
		fileStream.Dispose();
	}
}
public class LevelTest : MonoBehaviour
{
	public string allLevelsPath;

	public string canonsLevelsPath;

	public GameObject[] piecesToFind;

	public List<string> levels = new List<string>();

	public string testFolder;

	public int startlevel;

	private void Start()
	{
	}

	private void Update()
	{
		if (!Input.GetKeyDown(KeyCode.O))
		{
			return;
		}
		MonoBehaviour.print("finding");
		int num = 0;
		int num2 = GameManager.Hash(piecesToFind[0].name);
		DirectoryInfo[] directories = new DirectoryInfo(allLevelsPath).GetDirectories();
		for (int i = 0; i < directories.Length; i++)
		{
			FileInfo[] files = directories[i].GetFiles("*.dat");
			if (files.Length == 0)
			{
				continue;
			}
			CustomLevel customLevel = LevelEditor.LoadLevelData(files[0].FullName);
			for (int j = 0; j < customLevel.pieces.Length; j++)
			{
				if (customLevel.pieces[j].nameHash == num2)
				{
					string text = canonsLevelsPath + files[0].Name;
					int num3 = 1;
					while (File.Exists(text))
					{
						text = canonsLevelsPath + files[0].Name + num3++;
					}
					MonoBehaviour.print(files[0].FullName + " : " + text);
					File.Copy(files[0].FullName, text);
					num++;
					break;
				}
			}
		}
		MonoBehaviour.print("found " + num + " levels");
	}
}
public class PlayerPrefsX
{
	private enum ArrayType
	{
		Float,
		Int32,
		Bool,
		String,
		Vector2,
		Vector3,
		Quaternion,
		Color
	}

	private static int endianDiff1;

	private static int endianDiff2;

	private static int idx;

	private static byte[] byteBlock;

	public static bool SetBool(string name, bool value)
	{
		try
		{
			PlayerPrefs.SetInt(name, value ? 1 : 0);
		}
		catch
		{
			return false;
		}
		return true;
	}

	public static bool GetBool(string name)
	{
		return PlayerPrefs.GetInt(name) == 1;
	}

	public static bool GetBool(string name, bool defaultValue)
	{
		return 1 == PlayerPrefs.GetInt(name, defaultValue ? 1 : 0);
	}

	public static long GetLong(string key, long defaultValue)
	{
		SplitLong(defaultValue, out var lowBits, out var highBits);
		lowBits = PlayerPrefs.GetInt(key + "_lowBits", lowBits);
		highBits = PlayerPrefs.GetInt(key + "_highBits", highBits);
		return (long)(((ulong)(uint)highBits << 32) | (uint)lowBits);
	}

	public static long GetLong(string key)
	{
		int @int = PlayerPrefs.GetInt(key + "_lowBits");
		return (long)(((ulong)(uint)PlayerPrefs.GetInt(key + "_highBits") << 32) | (uint)@int);
	}

	private static void SplitLong(long input, out int lowBits, out int highBits)
	{
		lowBits = (int)input;
		highBits = (int)(input >> 32);
	}

	public static void SetLong(string key, long value)
	{
		SplitLong(value, out var lowBits, out var highBits);
		PlayerPrefs.SetInt(key + "_lowBits", lowBits);
		PlayerPrefs.SetInt(key + "_highBits", highBits);
	}

	public static bool SetVector2(string key, Vector2 vector)
	{
		return SetFloatArray(key, new float[2] { vector.x, vector.y });
	}

	private static Vector2 GetVector2(string key)
	{
		float[] floatArray = GetFloatArray(key);
		if (floatArray.Length < 2)
		{
			return Vector2.zero;
		}
		return new Vector2(floatArray[0], floatArray[1]);
	}

	public static Vector2 GetVector2(string key, Vector2 defaultValue)
	{
		if (PlayerPrefs.HasKey(key))
		{
			return GetVector2(key);
		}
		return defaultValue;
	}

	public static bool SetVector3(string key, Vector3 vector)
	{
		return SetFloatArray(key, new float[3] { vector.x, vector.y, vector.z });
	}

	public static Vector3 GetVector3(string key)
	{
		float[] floatArray = GetFloatArray(key);
		if (floatArray.Length < 3)
		{
			return Vector3.zero;
		}
		return new Vector3(floatArray[0], floatArray[1], floatArray[2]);
	}

	public static Vector3 GetVector3(string key, Vector3 defaultValue)
	{
		if (PlayerPrefs.HasKey(key))
		{
			return GetVector3(key);
		}
		return defaultValue;
	}

	public static bool SetQuaternion(string key, Quaternion vector)
	{
		return SetFloatArray(key, new float[4] { vector.x, vector.y, vector.z, vector.w });
	}

	public static Quaternion GetQuaternion(string key)
	{
		float[] floatArray = GetFloatArray(key);
		if (floatArray.Length < 4)
		{
			return Quaternion.identity;
		}
		return new Quaternion(floatArray[0], floatArray[1], floatArray[2], floatArray[3]);
	}

	public static Quaternion GetQuaternion(string key, Quaternion defaultValue)
	{
		if (PlayerPrefs.HasKey(key))
		{
			return GetQuaternion(key);
		}
		return defaultValue;
	}

	public static bool SetColor(string key, Color color)
	{
		return SetFloatArray(key, new float[4] { color.r, color.g, color.b, color.a });
	}

	public static Color GetColor(string key)
	{
		float[] floatArray = GetFloatArray(key);
		if (floatArray.Length < 4)
		{
			return new Color(0f, 0f, 0f, 0f);
		}
		return new Color(floatArray[0], floatArray[1], floatArray[2], floatArray[3]);
	}

	public static Color GetColor(string key, Color defaultValue)
	{
		if (PlayerPrefs.HasKey(key))
		{
			return GetColor(key);
		}
		return defaultValue;
	}

	public static bool SetBoolArray(string key, bool[] boolArray)
	{
		byte[] array = new byte[(boolArray.Length + 7) / 8 + 5];
		array[0] = Convert.ToByte(ArrayType.Bool);
		new BitArray(boolArray).CopyTo(array, 5);
		Initialize();
		ConvertInt32ToBytes(boolArray.Length, array);
		return SaveBytes(key, array);
	}

	public static bool[] GetBoolArray(string key)
	{
		if (PlayerPrefs.HasKey(key))
		{
			byte[] array = Convert.FromBase64String(PlayerPrefs.GetString(key));
			if (array.Length < 5)
			{
				UnityEngine.Debug.LogError("Corrupt preference file for " + key);
				return new bool[0];
			}
			if (array[0] != 2)
			{
				UnityEngine.Debug.LogError(key + " is not a boolean array");
				return new bool[0];
			}
			Initialize();
			byte[] array2 = new byte[array.Length - 5];
			Array.Copy(array, 5, array2, 0, array2.Length);
			BitArray obj = new BitArray(array2)
			{
				Length = ConvertBytesToInt32(array)
			};
			bool[] array3 = new bool[obj.Count];
			obj.CopyTo(array3, 0);
			return array3;
		}
		return new bool[0];
	}

	public static bool[] GetBoolArray(string key, bool defaultValue, int defaultSize)
	{
		if (PlayerPrefs.HasKey(key))
		{
			return GetBoolArray(key);
		}
		bool[] array = new bool[defaultSize];
		for (int i = 0; i < defaultSize; i++)
		{
			array[i] = defaultValue;
		}
		return array;
	}

	public static bool SetStringArray(string key, string[] stringArray)
	{
		byte[] array = new byte[stringArray.Length + 1];
		array[0] = Convert.ToByte(ArrayType.String);
		Initialize();
		for (int i = 0; i < stringArray.Length; i++)
		{
			if (stringArray[i] == null)
			{
				UnityEngine.Debug.LogError("Can't save null entries in the string array when setting " + key);
				return false;
			}
			if (stringArray[i].Length > 255)
			{
				UnityEngine.Debug.LogError("Strings cannot be longer than 255 characters when setting " + key);
				return false;
			}
			array[idx++] = (byte)stringArray[i].Length;
		}
		try
		{
			PlayerPrefs.SetString(key, Convert.ToBase64String(array) + "|" + string.Join("", stringArray));
		}
		catch
		{
			return false;
		}
		return true;
	}

	public static string[] GetStringArray(string key)
	{
		if (PlayerPrefs.HasKey(key))
		{
			string @string = PlayerPrefs.GetString(key);
			int num = @string.IndexOf("|"[0]);
			if (num < 4)
			{
				UnityEngine.Debug.LogError("Corrupt preference file for " + key);
				return new string[0];
			}
			byte[] array = Convert.FromBase64String(@string.Substring(0, num));
			if (array[0] != 3)
			{
				UnityEngine.Debug.LogError(key + " is not a string array");
				return new string[0];
			}
			Initialize();
			int num2 = array.Length - 1;
			string[] array2 = new string[num2];
			int num3 = num + 1;
			for (int i = 0; i < num2; i++)
			{
				int num4 = array[idx++];
				if (num3 + num4 > @string.Length)
				{
					UnityEngine.Debug.LogError("Corrupt preference file for " + key);
					return new string[0];
				}
				array2[i] = @string.Substring(num3, num4);
				num3 += num4;
			}
			return array2;
		}
		return new string[0];
	}

	public static string[] GetStringArray(string key, string defaultValue, int defaultSize)
	{
		if (PlayerPrefs.HasKey(key))
		{
			return GetStringArray(key);
		}
		string[] array = new string[defaultSize];
		for (int i = 0; i < defaultSize; i++)
		{
			array[i] = defaultValue;
		}
		return array;
	}

	public static bool SetIntArray(string key, int[] intArray)
	{
		return SetValue(key, intArray, ArrayType.Int32, 1, ConvertFromInt);
	}

	public static bool SetFloatArray(string key, float[] floatArray)
	{
		return SetValue(key, floatArray, ArrayType.Float, 1, ConvertFromFloat);
	}

	public static bool SetVector2Array(string key, Vector2[] vector2Array)
	{
		return SetValue(key, vector2Array, ArrayType.Vector2, 2, ConvertFromVector2);
	}

	public static bool SetVector3Array(string key, Vector3[] vector3Array)
	{
		return SetValue(key, vector3Array, ArrayType.Vector3, 3, ConvertFromVector3);
	}

	public static bool SetQuaternionArray(string key, Quaternion[] quaternionArray)
	{
		return SetValue(key, quaternionArray, ArrayType.Quaternion, 4, ConvertFromQuaternion);
	}

	public static bool SetColorArray(string key, Color[] colorArray)
	{
		return SetValue(key, colorArray, ArrayType.Color, 4, ConvertFromColor);
	}

	private static bool SetValue<T>(string key, T array, ArrayType arrayType, int vectorNumber, Action<T, byte[], int> convert) where T : IList
	{
		byte[] array2 = new byte[4 * array.Count * vectorNumber + 1];
		array2[0] = Convert.ToByte(arrayType);
		Initialize();
		for (int i = 0; i < array.Count; i++)
		{
			convert(array, array2, i);
		}
		return SaveBytes(key, array2);
	}

	private static void ConvertFromInt(int[] array, byte[] bytes, int i)
	{
		ConvertInt32ToBytes(array[i], bytes);
	}

	private static void ConvertFromFloat(float[] array, byte[] bytes, int i)
	{
		ConvertFloatToBytes(array[i], bytes);
	}

	private static void ConvertFromVector2(Vector2[] array, byte[] bytes, int i)
	{
		ConvertFloatToBytes(array[i].x, bytes);
		ConvertFloatToBytes(array[i].y, bytes);
	}

	private static void ConvertFromVector3(Vector3[] array, byte[] bytes, int i)
	{
		ConvertFloatToBytes(array[i].x, bytes);
		ConvertFloatToBytes(array[i].y, bytes);
		ConvertFloatToBytes(array[i].z, bytes);
	}

	private static void ConvertFromQuaternion(Quaternion[] array, byte[] bytes, int i)
	{
		ConvertFloatToBytes(array[i].x, bytes);
		ConvertFloatToBytes(array[i].y, bytes);
		ConvertFloatToBytes(array[i].z, bytes);
		ConvertFloatToBytes(array[i].w, bytes);
	}

	private static void ConvertFromColor(Color[] array, byte[] bytes, int i)
	{
		ConvertFloatToBytes(array[i].r, bytes);
		ConvertFloatToBytes(array[i].g, bytes);
		ConvertFloatToBytes(array[i].b, bytes);
		ConvertFloatToBytes(array[i].a, bytes);
	}

	public static int[] GetIntArray(string key)
	{
		List<int> list = new List<int>();
		GetValue(key, list, ArrayType.Int32, 1, ConvertToInt);
		return list.ToArray();
	}

	public static int[] GetIntArray(string key, int defaultValue, int defaultSize)
	{
		if (PlayerPrefs.HasKey(key))
		{
			return GetIntArray(key);
		}
		int[] array = new int[defaultSize];
		for (int i = 0; i < defaultSize; i++)
		{
			array[i] = defaultValue;
		}
		return array;
	}

	public static float[] GetFloatArray(string key)
	{
		List<float> list = new List<float>();
		GetValue(key, list, ArrayType.Float, 1, ConvertToFloat);
		return list.ToArray();
	}

	public static float[] GetFloatArray(string key, float defaultValue, int defaultSize)
	{
		if (PlayerPrefs.HasKey(key))
		{
			return GetFloatArray(key);
		}
		float[] array = new float[defaultSize];
		for (int i = 0; i < defaultSize; i++)
		{
			array[i] = defaultValue;
		}
		return array;
	}

	public static Vector2[] GetVector2Array(string key)
	{
		List<Vector2> list = new List<Vector2>();
		GetValue(key, list, ArrayType.Vector2, 2, ConvertToVector2);
		return list.ToArray();
	}

	public static Vector2[] GetVector2Array(string key, Vector2 defaultValue, int defaultSize)
	{
		if (PlayerPrefs.HasKey(key))
		{
			return GetVector2Array(key);
		}
		Vector2[] array = new Vector2[defaultSize];
		for (int i = 0; i < defaultSize; i++)
		{
			array[i] = defaultValue;
		}
		return array;
	}

	public static Vector3[] GetVector3Array(string key)
	{
		List<Vector3> list = new List<Vector3>();
		GetValue(key, list, ArrayType.Vector3, 3, ConvertToVector3);
		return list.ToArray();
	}

	public static Vector3[] GetVector3Array(string key, Vector3 defaultValue, int defaultSize)
	{
		if (PlayerPrefs.HasKey(key))
		{
			return GetVector3Array(key);
		}
		Vector3[] array = new Vector3[defaultSize];
		for (int i = 0; i < defaultSize; i++)
		{
			array[i] = defaultValue;
		}
		return array;
	}

	public static Quaternion[] GetQuaternionArray(string key)
	{
		List<Quaternion> list = new List<Quaternion>();
		GetValue(key, list, ArrayType.Quaternion, 4, ConvertToQuaternion);
		return list.ToArray();
	}

	public static Quaternion[] GetQuaternionArray(string key, Quaternion defaultValue, int defaultSize)
	{
		if (PlayerPrefs.HasKey(key))
		{
			return GetQuaternionArray(key);
		}
		Quaternion[] array = new Quaternion[defaultSize];
		for (int i = 0; i < defaultSize; i++)
		{
			array[i] = defaultValue;
		}
		return array;
	}

	public static Color[] GetColorArray(string key)
	{
		List<Color> list = new List<Color>();
		GetValue(key, list, ArrayType.Color, 4, ConvertToColor);
		return list.ToArray();
	}

	public static Color[] GetColorArray(string key, Color defaultValue, int defaultSize)
	{
		if (PlayerPrefs.HasKey(key))
		{
			return GetColorArray(key);
		}
		Color[] array = new Color[defaultSize];
		for (int i = 0; i < defaultSize; i++)
		{
			array[i] = defaultValue;
		}
		return array;
	}

	private static void GetValue<T>(string key, T list, ArrayType arrayType, int vectorNumber, Action<T, byte[]> convert) where T : IList
	{
		if (!PlayerPrefs.HasKey(key))
		{
			return;
		}
		byte[] array = Convert.FromBase64String(PlayerPrefs.GetString(key));
		if ((array.Length - 1) % (vectorNumber * 4) != 0)
		{
			UnityEngine.Debug.LogError("Corrupt preference file for " + key);
			return;
		}
		if ((ArrayType)array[0] != arrayType)
		{
			UnityEngine.Debug.LogError(key + " is not a " + arrayType.ToString() + " array");
			return;
		}
		Initialize();
		int num = (array.Length - 1) / (vectorNumber * 4);
		for (int i = 0; i < num; i++)
		{
			convert(list, array);
		}
	}

	private static void ConvertToInt(List<int> list, byte[] bytes)
	{
		list.Add(ConvertBytesToInt32(bytes));
	}

	private static void ConvertToFloat(List<float> list, byte[] bytes)
	{
		list.Add(ConvertBytesToFloat(bytes));
	}

	private static void ConvertToVector2(List<Vector2> list, byte[] bytes)
	{
		list.Add(new Vector2(ConvertBytesToFloat(bytes), ConvertBytesToFloat(bytes)));
	}

	private static void ConvertToVector3(List<Vector3> list, byte[] bytes)
	{
		list.Add(new Vector3(ConvertBytesToFloat(bytes), ConvertBytesToFloat(bytes), ConvertBytesToFloat(bytes)));
	}

	private static void ConvertToQuaternion(List<Quaternion> list, byte[] bytes)
	{
		list.Add(new Quaternion(ConvertBytesToFloat(bytes), ConvertBytesToFloat(bytes), ConvertBytesToFloat(bytes), ConvertBytesToFloat(bytes)));
	}

	private static void ConvertToColor(List<Color> list, byte[] bytes)
	{
		list.Add(new Color(ConvertBytesToFloat(bytes), ConvertBytesToFloat(bytes), ConvertBytesToFloat(bytes), ConvertBytesToFloat(bytes)));
	}

	public static void ShowArrayType(string key)
	{
		byte[] array = Convert.FromBase64String(PlayerPrefs.GetString(key));
		if (array.Length != 0)
		{
			ArrayType arrayType = (ArrayType)array[0];
			UnityEngine.Debug.Log(key + " is a " + arrayType.ToString() + " array");
		}
	}

	private static void Initialize()
	{
		if (BitConverter.IsLittleEndian)
		{
			endianDiff1 = 0;
			endianDiff2 = 0;
		}
		else
		{
			endianDiff1 = 3;
			endianDiff2 = 1;
		}
		if (byteBlock == null)
		{
			byteBlock = new byte[4];
		}
		idx = 1;
	}

	private static bool SaveBytes(string key, byte[] bytes)
	{
		try
		{
			PlayerPrefs.SetString(key, Convert.ToBase64String(bytes));
		}
		catch
		{
			return false;
		}
		return true;
	}

	private static void ConvertFloatToBytes(float f, byte[] bytes)
	{
		byteBlock = BitConverter.GetBytes(f);
		ConvertTo4Bytes(bytes);
	}

	private static float ConvertBytesToFloat(byte[] bytes)
	{
		ConvertFrom4Bytes(bytes);
		return BitConverter.ToSingle(byteBlock, 0);
	}

	private static void ConvertInt32ToBytes(int i, byte[] bytes)
	{
		byteBlock = BitConverter.GetBytes(i);
		ConvertTo4Bytes(bytes);
	}

	private static int ConvertBytesToInt32(byte[] bytes)
	{
		ConvertFrom4Bytes(bytes);
		return BitConverter.ToInt32(byteBlock, 0);
	}

	private static void ConvertTo4Bytes(byte[] bytes)
	{
		bytes[idx] = byteBlock[endianDiff1];
		bytes[idx + 1] = byteBlock[1 + endianDiff2];
		bytes[idx + 2] = byteBlock[2 - endianDiff2];
		bytes[idx + 3] = byteBlock[3 - endianDiff1];
		idx += 4;
	}

	private static void ConvertFrom4Bytes(byte[] bytes)
	{
		byteBlock[endianDiff1] = bytes[idx];
		byteBlock[1 + endianDiff2] = bytes[idx + 1];
		byteBlock[2 - endianDiff2] = bytes[idx + 2];
		byteBlock[3 - endianDiff1] = bytes[idx + 3];
		idx += 4;
	}
}
public class HoleInfo : MonoBehaviour
{
	[Header("Hole Info")]
	public RawImage screenshot;

	public Text levelName;

	public Text holeNumber;

	public Text par;

	public Text parsNeededToPass;

	public Text creatorName;

	public Text difficulty;

	public Text numberRated;

	public Image[] stars;

	public Sprite starNoFill;

	public Sprite starHalfFill;

	public Sprite starFullFill;

	private Color easyColor = new Color32(96, 142, 8, byte.MaxValue);

	private Color mediumColor = new Color32(232, 149, 1, byte.MaxValue);

	private Color hardColor = new Color32(170, 19, 0, byte.MaxValue);

	private Color superHardColor = new Color32(241, 61, 37, byte.MaxValue);

	public TextMeshPro closeButtonText;

	public bool autoClose;

	public float counter = 15f;

	[HideInInspector]
	public WorkshopData wsd;

	public GameObject leaderboard;

	public GameObject moneyObject;

	public TextMeshPro moneyText;

	public virtual void Start()
	{
		if (GameManager.instance.playerCount > 1 && ScoreManager.instance.playerTurn[GameManager.instance.playerIndex].playerName == "")
		{
			GameManager.instance.pauseMenu.allowPausing = false;
		}
		if (GameManager.instance.currentSceneName == "ScoreScene")
		{
			wsd = GameManager.instance.playlistLeaderboardData;
		}
		else
		{
			wsd = GameManager.instance.holeData[GameManager.instance.holeIndex];
		}
		if (GameManager.instance.currentSceneName != "ScoreScene")
		{
			UpdateHoleInfo();
		}
		else
		{
			UpdatePlaylistInfo();
		}
		moneyObject.SetActive(value: false);
	}

	private void Update()
	{
		if ((GameManager.instance.pauseMenu.paused && GameManager.instance.pauseMenu.allowPausing) || GameManager.instance.quickMenu.menu.activeSelf)
		{
			CloseInfo();
		}
		if (autoClose)
		{
			counter -= Time.deltaTime;
			closeButtonText.text = LocalizationManager.GetTranslation("Close") + "(" + (int)counter + ")";
			if (counter <= 0f)
			{
				CloseInfo();
			}
		}
	}

	public void UpdatePlaylistInfo()
	{
		numberRated.text = "";
		difficulty.text = "";
		levelName.text = "";
		holeNumber.text = "";
		par.text = "";
		parsNeededToPass.text = "";
		creatorName.text = "";
		screenshot.texture = GameManager.instance.playlistLeaderboardData.screenshot;
	}

	public void UpdateHoleInfo()
	{
		if (!string.IsNullOrEmpty(wsd.fileLocation))
		{
			numberRated.text = "";
			this.difficulty.text = "";
			holeNumber.text = "";
			par.text = "";
			parsNeededToPass.text = "";
			creatorName.text = "";
		}
		if (wsd.upvotes + wsd.downvotes > 0)
		{
			numberRated.text = (wsd.upvotes + wsd.downvotes).ToString();
			SetRatings(wsd.upvotes, wsd.downvotes);
		}
		screenshot.texture = wsd.screenshot;
		if (wsd.difficulty == 0)
		{
			this.difficulty.color = easyColor;
		}
		else if (wsd.difficulty == 1)
		{
			this.difficulty.color = mediumColor;
		}
		else if (wsd.difficulty == 2)
		{
			this.difficulty.color = hardColor;
		}
		else if (wsd.difficulty == 3)
		{
			this.difficulty.color = superHardColor;
		}
		Text text = this.difficulty;
		string translation = LocalizationManager.GetTranslation("Difficulty");
		Difficulty difficulty = (Difficulty)wsd.difficulty;
		text.text = translation + ": " + LocalizationManager.GetTranslation(difficulty.ToString());
		levelName.text = wsd.levelName;
		if (string.IsNullOrEmpty(wsd.fileLocation))
		{
			holeNumber.text = LocalizationManager.GetTranslation("Hole") + " " + (GameManager.instance.holeIndex + 1);
		}
		else
		{
			holeNumber.text = "";
		}
		if (GameManager.instance.gameMode == GameMode.Campaign)
		{
			if (wsd.difficulty == 0)
			{
				parsNeededToPass.text = "(" + LocalizationManager.GetTranslation("Complete Hole To Pass") + ")";
				par.text = LocalizationManager.GetTranslation("Par") + ": " + wsd.par;
			}
			else if (wsd.difficulty == 1)
			{
				parsNeededToPass.text = string.Format(LocalizationManager.GetTranslation("Require {0} To Pass"), wsd.par + 3);
				par.text = LocalizationManager.GetTranslation("Par") + ": " + wsd.par;
			}
			else if (wsd.difficulty == 2)
			{
				parsNeededToPass.text = string.Format(LocalizationManager.GetTranslation("Require {0} To Pass"), wsd.par + 2);
				par.text = LocalizationManager.GetTranslation("Par") + ": " + wsd.par;
			}
		}
		else
		{
			par.text = LocalizationManager.GetTranslation("Par") + ": " + wsd.par;
		}
		creatorName.text = wsd.creatorName;
	}

	public void CloseInfo()
	{
		if (GameManager.instance.playerCount > 1 && ScoreManager.instance.playerTurn[GameManager.instance.playerIndex].inputName && !ScoreManager.instance.ballScored)
		{
			GameManager.instance.initialsKeyboard = UnityEngine.Object.Instantiate(GameManager.instance.keyboardPrefab);
		}
		if (ScoreManager.instance.ballScored)
		{
			PhotonNetwork.LocalPlayer.SetRatingHole(value: true);
		}
		if (GameManager.instance.currentSceneName == "ScoreScene")
		{
			GetComponent<PointerLineActivation>().disableOnDestroy = false;
		}
		UnityEngine.Object.Destroy(base.gameObject);
		if (GameManager.instance.gameMode == GameMode.Campaign && ScoreManager.instance.ballScored)
		{
			GameManager.instance.SpawnCampaignMapNotification();
		}
	}

	public void SetRatings(float upvotes, float downvotes)
	{
		Image[] array = stars;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].gameObject.SetActive(value: true);
		}
		numberRated.text = (upvotes + downvotes).ToString();
		float num = 0f;
		if (upvotes + downvotes != 0f)
		{
			num = upvotes / (upvotes + downvotes) * 5f;
		}
		for (int j = 0; j <= (int)num; j++)
		{
			if (num < 1.25f && num > 0f)
			{
				stars[0].sprite = starFullFill;
			}
			else if (num >= (float)(int)num + 0.25f && num <= (float)(int)num + 0.75f)
			{
				if (j < (int)num)
				{
					stars[j].sprite = starFullFill;
				}
				else
				{
					stars[j].sprite = starHalfFill;
				}
			}
			else if (num >= (float)(int)num + 0.75f && num <= (float)(int)num + 1.25f)
			{
				if (j < (int)num)
				{
					stars[j].sprite = starFullFill;
				}
				else
				{
					stars[j].sprite = starHalfFill;
				}
			}
			else if (num >= (float)(int)num - 0.25f && num <= (float)(int)num + 0.25f && j < (int)num)
			{
				stars[j].sprite = starFullFill;
			}
		}
	}
}
public class HoleLeaderboard : MonoBehaviour
{
	public HoleLeaderboardEntry[] holeLeaderboardEntry;

	public GameObject loadingCircles;

	public Text message;

	public bool updatingLeaderboard;

	public bool updatingPlaylist;

	public List<Leaderboard> holeLeaderboard;

	private WorkshopData wsd;

	private int score;

	public Color rankColor;

	private int retryFetchingLeaderboardTries = 3;

	private void Start()
	{
		if (UnityEngine.Application.internetReachability == NetworkReachability.NotReachable)
		{
			message.text = LocalizationManager.GetTranslation("Could not connect to server. Please check internet connectivity or try again later.");
			return;
		}
		if (updatingPlaylist)
		{
			wsd = GameManager.instance.playlistLeaderboardData;
			score = ScoreManager.instance.GetTotalStrokes();
		}
		else
		{
			wsd = GameManager.instance.holeData[GameManager.instance.holeIndex];
			score = ScoreManager.instance.currentStrokeCount;
		}
		if (wsd.publishID == 0 && !wsd.defaultHole && !wsd.cloudlandsPlaylist)
		{
			message.text = LocalizationManager.GetTranslation("Upload your hole online to see the leaderboard");
			loadingCircles.gameObject.SetActive(value: false);
			return;
		}
		loadingCircles.gameObject.SetActive(value: true);
		if ((updatingLeaderboard || updatingPlaylist) && !ScoreManager.instance.playerTurn[GameManager.instance.playerIndex].infiniteMulligan)
		{
			UploadLeaderboard();
		}
		else
		{
			GetLeaderboard();
		}
	}

	private void GetLeaderboard()
	{
		StartCoroutine(RemoteServerManager.instance.GetLeaderBoardData(wsd, updatingPlaylist, delegate(List<Leaderboard> completed2)
		{
			loadingCircles.gameObject.SetActive(value: false);
			if (completed2 != null)
			{
				holeLeaderboard = completed2;
				SetHoleLeaderboardDetails();
			}
			else
			{
				message.text = LocalizationManager.GetTranslation("Error loading the leaderboard. Please try again later.");
			}
		}));
	}

	private void UploadLeaderboard()
	{
		StartCoroutine(RemoteServerManager.instance.UploadScore(wsd, score, updatingPlaylist, delegate(bool completed)
		{
			if (completed)
			{
				StartCoroutine(RemoteServerManager.instance.GetLeaderBoardData(wsd, updatingPlaylist, delegate(List<Leaderboard> completed2)
				{
					if (completed2 != null)
					{
						holeLeaderboard = completed2;
						SetHoleLeaderboardDetails();
					}
					else
					{
						message.text = LocalizationManager.GetTranslation("Error loading the leaderboard. Please try again later.");
						loadingCircles.gameObject.SetActive(value: false);
					}
				}));
			}
			else
			{
				loadingCircles.gameObject.SetActive(value: false);
				SetHoleLeaderboardDetails();
			}
		}));
	}

	private void SetHoleLeaderboardDetails()
	{
		if (holeLeaderboard == null || holeLeaderboard.Count == 0)
		{
			if (ScoreManager.instance.playerTurn[GameManager.instance.playerIndex].infiniteMulligan)
			{
				message.text = LocalizationManager.GetTranslation("You can not upload your score if you used infinite mulligans");
				loadingCircles.gameObject.SetActive(value: false);
			}
			else if (RemoteServerManager.instance.playerID == "")
			{
				message.text = LocalizationManager.GetTranslation("Log in to add your score to the leaderboard");
				loadingCircles.gameObject.SetActive(value: false);
			}
			else if (updatingLeaderboard && retryFetchingLeaderboardTries > 0)
			{
				MonoBehaviour.print("Error: failed to properly get leaderboard. Retrying. Tries Left: " + retryFetchingLeaderboardTries);
				retryFetchingLeaderboardTries--;
				UploadLeaderboard();
			}
			else if (retryFetchingLeaderboardTries == 0)
			{
				MonoBehaviour.print("Error: failed to properly get leaderboard");
				message.text = LocalizationManager.GetTranslation("Error loading the leaderboard. Please try again later.");
			}
			else
			{
				message.text = LocalizationManager.GetTranslation("Be the first to get your name on the leaderboard");
				loadingCircles.gameObject.SetActive(value: false);
			}
			return;
		}
		loadingCircles.gameObject.SetActive(value: false);
		for (int i = 0; i < 10; i++)
		{
			if (i < holeLeaderboard.Count)
			{
				Leaderboard leaderboard = ((i != 9 || holeLeaderboard.Count != 11) ? holeLeaderboard[i] : holeLeaderboard[10]);
				holeLeaderboardEntry[i].playerName.text = leaderboard.playerName;
				holeLeaderboardEntry[i].date.text = leaderboard.date;
				if (leaderboard.score < wsd.par)
				{
					holeLeaderboardEntry[i].score.text = leaderboard.score + "(" + (leaderboard.score - wsd.par) + ")";
				}
				else if (leaderboard.score > wsd.par)
				{
					holeLeaderboardEntry[i].score.text = leaderboard.score + "(+" + (leaderboard.score - wsd.par) + ")";
				}
				else
				{
					holeLeaderboardEntry[i].score.text = leaderboard.score + "(+0)";
				}
				string text = "";
				string text2 = "";
				if (GameManager.instance.publishedPlatform == PublishedPlatform.OCULUS)
				{
					text = RemoteServerManager.instance.oculusOrgScopedID;
					text2 = leaderboard.oculusOrgScopeID;
				}
				else
				{
					text = RemoteServerManager.instance.playerID;
					text2 = leaderboard.playerID;
				}
				if (text != "" && text2 == text)
				{
					Color32 color = new Color32(195, 157, 0, 162);
					holeLeaderboardEntry[i].playerName.color = color;
					holeLeaderboardEntry[i].date.color = color;
					holeLeaderboardEntry[i].score.color = color;
					holeLeaderboardEntry[i].rank.color = color;
					holeLeaderboardEntry[i].rank.text = "#" + leaderboard.rank;
				}
				else
				{
					holeLeaderboardEntry[i].playerName.color = rankColor;
					holeLeaderboardEntry[i].date.color = rankColor;
					holeLeaderboardEntry[i].score.color = rankColor;
					holeLeaderboardEntry[i].rank.color = rankColor;
				}
				holeLeaderboardEntry[i].container.SetActive(value: true);
			}
			else
			{
				holeLeaderboardEntry[i].container.SetActive(value: false);
			}
		}
	}
}
[Serializable]
public class HoleLeaderboardEntry
{
	public GameObject container;

	public Text rank;

	public Text playerName;

	public Text score;

	public Text date;
}
public class HoleRating : HoleInfo
{
	public TextMeshProUGUI timerText;

	public PauseButton upvoteButton;

	public PauseButton downvoteButton;

	public PauseButton favoriteButton;

	private bool hasFavorited;

	private bool fetchedFavorite;

	private WorkshopRating wsr;

	public override void Start()
	{
		base.Start();
		if (wsd.workshopRating != null)
		{
			wsr = new WorkshopRating
			{
				hasFavorited = wsd.workshopRating.hasFavorited,
				publishedFileId = wsd.workshopRating.publishedFileId,
				voteUp = wsd.workshopRating.voteUp,
				voteDown = wsd.workshopRating.voteDown
			};
			if (wsd.workshopRating.voteUp)
			{
				upvoteButton.stayHighlighted = true;
				upvoteButton.Highlight();
			}
			else if (wsd.workshopRating.voteDown)
			{
				downvoteButton.stayHighlighted = true;
				downvoteButton.Highlight();
			}
			if (wsd.workshopRating.hasFavorited)
			{
				fetchedFavorite = true;
				hasFavorited = true;
				favoriteButton.stayHighlighted = true;
				favoriteButton.Highlight();
			}
		}
	}

	private void Update()
	{
		counter -= Time.deltaTime;
		timerText.text = ((int)counter).ToString();
		if (counter <= 0f || GameManager.instance.pauseMenu.paused)
		{
			CloseNotification();
		}
	}

	public void Upvote()
	{
		wsr.voteUp = true;
		wsr.voteDown = false;
		upvoteButton.stayHighlighted = true;
		upvoteButton.Highlight();
		downvoteButton.stayHighlighted = false;
		downvoteButton.UnHighlight();
	}

	public void DownVote()
	{
		wsr.voteUp = false;
		wsr.voteDown = true;
		upvoteButton.stayHighlighted = false;
		upvoteButton.UnHighlight();
		downvoteButton.stayHighlighted = true;
		downvoteButton.Highlight();
	}

	public void Favorite()
	{
		if (!hasFavorited)
		{
			hasFavorited = true;
			favoriteButton.stayHighlighted = hasFavorited;
			favoriteButton.Highlight();
		}
		else
		{
			hasFavorited = false;
			favoriteButton.stayHighlighted = hasFavorited;
			favoriteButton.UnHighlight();
		}
	}

	public void CloseNotification()
	{
		string text = "";
		string text2 = "";
		if (wsr.voteUp != wsd.workshopRating.voteUp || wsr.voteDown != wsd.workshopRating.voteDown)
		{
			if (wsr.voteUp)
			{
				text = "Upvote()";
			}
			else if (wsr.voteDown)
			{
				text = "Downvote()";
			}
		}
		if (hasFavorited != fetchedFavorite)
		{
			if (text == "")
			{
				text = "Favorite()";
			}
			else
			{
				text2 = "Favorite()";
			}
			if (GameManager.instance.currentSceneName != "ScoreScene")
			{
				if (hasFavorited)
				{
					wsr.hasFavorited = true;
					GameManager.instance.holeData[GameManager.instance.holeIndex].workshopRating.hasFavorited = true;
				}
				else
				{
					wsr.hasFavorited = false;
					GameManager.instance.holeData[GameManager.instance.holeIndex].workshopRating.hasFavorited = false;
				}
			}
		}
		if (text != "")
		{
			if (text2 == "")
			{
				StartCoroutine(RemoteServerManager.instance.UpdateItemVoteData(text));
			}
			else
			{
				StartCoroutine(RemoteServerManager.instance.UpdateItemVoteData(text, text2));
			}
		}
		if (GameManager.instance.currentSceneName != "ScoreScene")
		{
			for (int i = 0; i < GameManager.instance.holeData.Count; i++)
			{
				if ((ulong)GameManager.instance.holeData[i].publishID == wsr.publishedFileId && !GameManager.instance.holeData[i].defaultHole)
				{
					GameManager.instance.holeData[i].workshopRating = wsr;
				}
			}
		}
		PhotonNetwork.LocalPlayer.SetRatingHole(value: true);
		UnityEngine.Object.Destroy(base.gameObject);
	}
}
public class LanguageMenu : MonoBehaviour
{
	public void ChangeLanguage(string language)
	{
		GameManager.instance.SetLanguage(language);
	}
}
public class CustomHoleScene : MonoBehaviour
{
	public static CustomHoleScene instance;

	public Transform levelParent;

	public List<GameObject> spawnedPieces = new List<GameObject>();

	public LevelEditorOBTriggers OBscript;

	public float levelScale;

	public GameObject startFloor;

	public List<Teebox> teeboxes = new List<Teebox>();

	public string testLevelFilePath;

	public GameObject golfBallSpawnerPrefab;

	public Camera minimapCamera;

	public Wind wind;

	public Light directionalLight;

	private void Awake()
	{
		instance = this;
	}

	private void Start()
	{
		StartCoroutine(DelayStart());
		PhotonNetwork.LocalPlayer.SetHoleFinished(value: false);
		if (RemoteServerManager.instance.playerID == "")
		{
			PhotonNetwork.LocalPlayer.SetRatingHole(value: true);
		}
		else
		{
			PhotonNetwork.LocalPlayer.SetRatingHole(value: false);
		}
		if (!GameManager.instance.IsPlaylist() && GameManager.instance.playerCount == 1 && !PhotonNetwork.IsConnected)
		{
			GameManager.instance.ResetMulligans(resetEveryHole: true);
		}
		if (PhotonNetwork.IsConnected)
		{
			RichPresenceManager.instance.SetOnlineRoomDestination(PhotonNetwork.CurrentRoom.Name, PhotonNetwork.CurrentRoom.PlayerCount);
		}
	}

	private IEnumerator DelayStart()
	{
		yield return null;
		WorkshopData workshopData = GameManager.instance.holeData[GameManager.instance.holeIndex];
		if (workshopData.cloudlandsVersion == 2)
		{
			Player.instance.clubSwitcher.usableClubs = workshopData.golfClubType;
			Player.instance.autoWarp.switchClubsOnWarp = GameManager.instance.GetClubChangeOnWarp();
			if ((workshopData.golfClubType & GolfClubType.Driver) == GolfClubType.Driver)
			{
				Player.instance.clubSwitcher.SwitchToClubType(ClubType.Driver);
			}
			else if ((workshopData.golfClubType & GolfClubType.Iron) == GolfClubType.Iron)
			{
				Player.instance.clubSwitcher.SwitchToClubType(ClubType.Iron);
			}
			else if ((workshopData.golfClubType & GolfClubType.Putter) == GolfClubType.Putter)
			{
				Player.instance.clubSwitcher.SwitchToClubType(ClubType.Putter);
			}
			CustomLevel levelData = ((!workshopData.defaultHole) ? LevelEditor.LoadLevelData(workshopData.fileLocation) : LevelEditor.LoadLevelData(workshopData.fileLocation, cloudlandsHole: true));
			LoadLevel(levelData);
			wind.SetWindSpeed(levelData.windVector, levelParent);
			Vector3 vector = levelParent.TransformDirection(wind.GetWindVector());
			if (vector == Vector3.zero)
			{
				vector = Vector3.right;
			}
			Golfhole[] componentsInChildren = levelParent.GetComponentsInChildren<Golfhole>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				componentsInChildren[i].ChangeFlagDirection(vector);
			}
		}
		else if (workshopData.cloudlandsVersion == 1)
		{
			Player.instance.autoWarp.switchClubsOnWarp = false;
			Player.instance.clubSwitcher.SwitchToClubType(ClubType.Putter);
			if (workshopData.defaultHole)
			{
				LoadCL1Level(LevelEditor.LoadCL1LevelData(workshopData.fileLocation, cloudlandsHole: true));
			}
			else
			{
				LoadCL1Level(LevelEditor.LoadCL1LevelData(workshopData.fileLocation));
			}
		}
	}

	private void Update()
	{
	}

	public void LoadLevel(CustomLevel levelData)
	{
		if (levelData.pieces.Length != 0)
		{
			levelParent.position = levelData.originPosition;
			levelParent.localScale = new Vector3(levelScale, levelScale, levelScale);
			levelParent.rotation = levelData.originRotation;
			for (int i = 0; i < levelData.pieces.Length; i++)
			{
				SpawnPiece(levelData.pieces[i]);
			}
			if (levelData.placeableData != null && levelData.placeableData.Length != 0)
			{
				for (int j = 0; j < levelData.placeableData.Length; j++)
				{
					ApplyPlaceableData(levelData.placeableData[j]);
				}
			}
			if (levelData.dynamicData != null && levelData.dynamicData.Length != 0)
			{
				for (int k = 0; k < levelData.dynamicData.Length; k++)
				{
					ApplyDynamicData(levelData.dynamicData[k]);
				}
			}
			ApplyLighting((int)levelData.skybox);
			StartCoroutine(ChangeSky((int)levelData.skybox));
			CenterLevel();
			StartCoroutine(Relocate());
			GameManager.instance.SpawnHoleInfoNotification(rating: false);
		}
		else
		{
			UnityEngine.Debug.Log("no pieces in level file");
		}
	}

	private IEnumerator ChangeSky(int skybox)
	{
		yield return null;
		ApplyLighting(skybox);
	}

	public void ApplyLighting(int skybox)
	{
		LightingData lightingData = GameManager.instance.LightingSettings[skybox];
		directionalLight.intensity = lightingData.lightIntensity;
		directionalLight.shadowStrength = lightingData.shadowStrength;
		RenderSettings.skybox = lightingData.skyboxMat;
		RenderSettings.ambientIntensity = lightingData.intensityMultiplier;
		DynamicGI.UpdateEnvironment();
	}

	public void CenterLevel()
	{
		if (spawnedPieces.Count > 0)
		{
			Vector3 position = default(Vector3);
			for (int i = 0; i < spawnedPieces.Count; i++)
			{
				position += spawnedPieces[i].transform.position;
			}
			position /= (float)spawnedPieces.Count;
			levelParent.DetachChildren();
			levelParent.position = position;
			for (int j = 0; j < spawnedPieces.Count; j++)
			{
				spawnedPieces[j].transform.SetParent(levelParent);
			}
		}
		levelParent.position = Vector3.zero;
	}

	public EditorPiece SpawnPiece(LevelPiece pieceData)
	{
		GameObject editorPieceByNameHash = GameManager.instance.GetEditorPieceByNameHash(pieceData.nameHash);
		if (editorPieceByNameHash != null)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(editorPieceByNameHash);
			gameObject.name = editorPieceByNameHash.name;
			spawnedPieces.Add(gameObject);
			gameObject.transform.parent = levelParent;
			gameObject.transform.localScale = pieceData.scale;
			gameObject.transform.localPosition = pieceData.position;
			gameObject.transform.localRotation = pieceData.rotation;
			EditorPiece component = gameObject.GetComponent<EditorPiece>();
			component.showSnapPoints = false;
			if (gameObject.GetComponent<Collider>() != null)
			{
				gameObject.GetComponent<Collider>().enabled = false;
			}
			for (int i = 0; i < component.snapPoints.Length; i++)
			{
				component.snapPoints[i].GetComponent<Renderer>().enabled = false;
				component.snapPoints[i].GetComponent<Collider>().enabled = false;
			}
			for (int j = 0; j < component.rotateHandles.Length; j++)
			{
				component.rotateHandles[j].GetComponent<Renderer>().enabled = false;
				component.rotateHandles[j].GetComponent<Collider>().enabled = false;
			}
			EditPoint[] componentsInChildren = gameObject.GetComponentsInChildren<EditPoint>();
			for (int k = 0; k < componentsInChildren.Length; k++)
			{
				if ((bool)componentsInChildren[k].GetComponent<Renderer>())
				{
					componentsInChildren[k].GetComponent<Renderer>().enabled = false;
				}
				if ((bool)componentsInChildren[k].GetComponent<Collider>())
				{
					componentsInChildren[k].GetComponent<Collider>().enabled = false;
				}
			}
			if (gameObject.GetComponent<EditorMoveTriangle>() != null)
			{
				gameObject.GetComponent<EditorMoveTriangle>().ResetTime();
				if (gameObject.GetComponent<EditorMoveTriangle>().startPoint.GetComponent<Renderer>() != null)
				{
					gameObject.GetComponent<EditorMoveTriangle>().startPoint.GetComponent<Renderer>().enabled = false;
				}
			}
			else if (gameObject.GetComponent<EditorCannon>() != null)
			{
				gameObject.GetComponent<EditorCannon>().trajectoryLineRenderer.enabled = false;
				gameObject.GetComponent<EditorCannon>().ResetTime();
			}
			else if (gameObject.GetComponent<EditorFan>() != null)
			{
				gameObject.GetComponent<EditorFan>().ResetTime();
			}
			else if (gameObject.GetComponentInChildren<UFO>() != null)
			{
				gameObject.GetComponentInChildren<UFO>().Reset();
				gameObject.GetComponentInChildren<UFO>().active = true;
			}
			return component;
		}
		Notification.instance.AddNotification("There was a piece that could not be loaded", 0f, closeButton: true);
		return null;
	}

	public void ApplyPlaceableData(PlaceableData placeableData)
	{
		if (placeableData.pieceIndex == -1 || !(spawnedPieces[placeableData.pieceIndex] != null))
		{
			return;
		}
		EditorPiece component = spawnedPieces[placeableData.pieceIndex].GetComponent<EditorPiece>();
		if (component.placeableObject != null)
		{
			component.placeableObject.transform.localPosition = placeableData.piecePosition;
			component.placeableObject.transform.localRotation = placeableData.pieceRotation;
			if (component.grabPoint.GetComponent<Renderer>() != null)
			{
				component.grabPoint.GetComponent<Renderer>().enabled = false;
			}
			component.placementLine.enabled = false;
		}
		else
		{
			MonoBehaviour.print("placeableData was incorrect");
		}
	}

	public void ApplyDynamicData(DynamicData dynamicData)
	{
		if (dynamicData.linkedPieceIndex != -1)
		{
			if (spawnedPieces[dynamicData.pieceIndex] != null && spawnedPieces[dynamicData.linkedPieceIndex] != null)
			{
				WarpNode.LinkPieces(spawnedPieces[dynamicData.pieceIndex].GetComponent<EditorPiece>(), spawnedPieces[dynamicData.linkedPieceIndex].GetComponent<EditorPiece>());
			}
			else
			{
				Notification.instance.AddNotification("There was corrupted data in the level", 0f, closeButton: true);
			}
		}
		else if (spawnedPieces[dynamicData.pieceIndex] != null)
		{
			EditPoint componentInChildren = spawnedPieces[dynamicData.pieceIndex].GetComponentInChildren<EditPoint>();
			if (componentInChildren != null)
			{
				componentInChildren.transform.localPosition = dynamicData.grabPosition;
				componentInChildren.transform.rotation = dynamicData.grabRotation;
				StartCoroutine(DelayUpdateGrabbable(componentInChildren));
			}
		}
		else
		{
			Notification.instance.AddNotification("There was corrupted data in the level", 0f, closeButton: true);
		}
	}

	public IEnumerator Relocate()
	{
		yield return null;
		for (int i = 0; i < spawnedPieces.Count; i++)
		{
			if (spawnedPieces[i].GetComponent<Teebox>() != null)
			{
				teeboxes.Add(spawnedPieces[i].GetComponent<Teebox>());
			}
		}
		if (teeboxes.Count > 0)
		{
			Vector3 position = teeboxes[0].teeLocation.position;
			UnityEngine.Object.Instantiate(GameManager.instance.golfBallSpawnerPrefab, position, Quaternion.identity);
			Player.instance.RotateHeadToFacePosition(teeboxes[0].teeLocation);
			if (GameManager.instance.publishedPlatform == PublishedPlatform.XR && !Player.instance.autoWarp.warpToCenter)
			{
				Player.instance.transform.position = Player.instance.autoWarp.ReturnHeadToTargetWarp(position);
				while (GameManager.instance.golfball == null || (GameManager.instance.golfball != null && !GameManager.instance.golfball.IsGrounded()))
				{
					yield return null;
				}
				yield return new WaitForEndOfFrame();
				Player.instance.autoWarp.Warp(warpToClosestBallMat: false, forceWarp: true);
			}
			else
			{
				Player.instance.transform.position = position;
			}
		}
		else
		{
			MonoBehaviour.print("no teeboxes found");
		}
		OBscript.SetOB();
	}

	public void SetMinimap()
	{
		Vector3 center = OBscript.bounds.center;
		center.y = 500f;
		minimapCamera.transform.position = center;
		float num = 0f;
		num = ((!(OBscript.bounds.extents.x > OBscript.bounds.extents.z)) ? OBscript.bounds.extents.z : OBscript.bounds.extents.x);
		minimapCamera.orthographicSize = num * levelScale;
	}

	public void LoadCL1Level(CustomLevelCL1 levelData)
	{
		if (levelData.pieces == null)
		{
			return;
		}
		levelParent.position = levelData.originPosition;
		levelParent.rotation = levelData.originRotation;
		for (int i = 0; i < levelData.pieces.Length; i++)
		{
			SpawnCL1Piece(levelData.pieces[i]);
		}
		if (levelData.placeableData != null && levelData.placeableData.Length != 0)
		{
			for (int j = 0; j < levelData.placeableData.Length; j++)
			{
				ApplyCL1PlaceableData(levelData.placeableData[j]);
			}
		}
		if (levelData.dynamicData != null && levelData.dynamicData.Length != 0)
		{
			for (int k = 0; k < levelData.dynamicData.Length; k++)
			{
				ApplyCL1DynamicData(levelData.dynamicData[k]);
			}
		}
		for (int l = 0; l < spawnedPieces.Count; l++)
		{
		}
		ApplyLighting(0);
		levelParent.localScale = new Vector3(levelScale, levelScale, levelScale);
		StartCoroutine(RelocateCL1());
		GameManager.instance.SpawnHoleInfoNotification(rating: false);
	}

	public void SpawnCL1Piece(LevelPieceCL1 pieceData)
	{
		LevelPiece pieceData2 = default(LevelPiece);
		pieceData2.nameHash = pieceData.nameHash;
		pieceData2.position = pieceData.position;
		pieceData2.rotation = pieceData.rotation;
		pieceData2.scale = pieceData.scale;
		EditorPiece editorPiece = SpawnPiece(pieceData2);
		if (editorPiece != null)
		{
			editorPiece.transform.rotation = pieceData.rotation;
			editorPiece.ChangeSeason(pieceData.season);
		}
	}

	public void ApplyCL1PlaceableData(PlaceableData placeableData)
	{
		ApplyPlaceableData(placeableData);
	}

	public void ApplyCL1DynamicData(DynamicDataCL1 dynamicData)
	{
		DynamicData dynamicData2 = default(DynamicData);
		dynamicData2.pieceIndex = dynamicData.pieceIndex;
		dynamicData2.grabPosition = dynamicData.grabPosition;
		dynamicData2.grabRotation = dynamicData.grabRotation;
		dynamicData2.linkedPieceIndex = dynamicData.linkedPieceIndex;
		ApplyDynamicData(dynamicData2);
	}

	private IEnumerator DelayUpdateGrabbable(EditPoint grabbable)
	{
		yield return null;
		grabbable.UpdateDynamicParts();
	}

	private IEnumerator RelocateCL1()
	{
		yield return null;
		GameObject gameObject = GameObject.Find("HoleStart");
		Vector3 position = gameObject.transform.position;
		if (gameObject.GetComponent<HoleStart>() != null)
		{
			position = gameObject.GetComponent<HoleStart>().spawnPoint.position;
		}
		GameObject gameObject2 = UnityEngine.Object.Instantiate(golfBallSpawnerPrefab, position, Quaternion.identity);
		GameManager.instance.player.transform.rotation = gameObject2.GetComponent<GolfballSpawner>().transform.rotation;
		if (GameManager.instance.publishedPlatform == PublishedPlatform.XR && !Player.instance.autoWarp.warpToCenter)
		{
			Player.instance.transform.position = Player.instance.autoWarp.ReturnHeadToTargetWarp(gameObject2.GetComponent<GolfballSpawner>().transform.position);
		}
		else
		{
			GameManager.instance.player.transform.position = gameObject2.GetComponent<GolfballSpawner>().transform.position;
		}
		OBscript.SetOB();
	}
}
public class DebugTestSuite : MonoBehaviour
{
	private LevelEditorMenu lem;

	private bool grabbing;

	private bool finished;

	public TextMeshPro debugText;

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.I))
		{
			lem = LevelEditor.instance.levelEditorMenu;
			LevelEditor.instance.complexityLimit = float.PositiveInfinity;
			StartCoroutine(PlacePieces());
			StartCoroutine(Inputs());
		}
		if (Input.GetKeyDown(KeyCode.P))
		{
			MonoBehaviour.print("count: " + LevelEditor.instance.levelParent.childCount);
		}
	}

	private IEnumerator PlacePieces()
	{
		Vector3 localPos = Player.instance.editorGrabber.transform.localPosition;
		Transform grabberParent = Player.instance.editorGrabber.transform.parent;
		Player.instance.editorGrabber.transform.parent = null;
		for (int i = 1; i < lem.basicPiecePage.Length; i++)
		{
			lem.OpenBasicPiecesPage(i);
			PieceSpawner[] pss = lem.basicPiecePage[i].GetComponentsInChildren<PieceSpawner>();
			for (int j = 0; j < pss.Length; j++)
			{
				GameObject go = pss[j].currentPiece;
				if ((bool)go)
				{
					Player.instance.editorGrabber.transform.position = go.GetComponent<Collider>().bounds.center;
					int nameHash = GameManager.Hash(go.name);
					if (GameManager.instance.GetEditorPieceByNameHash(nameHash) == null)
					{
						MonoBehaviour.print(go.name + ": is not in gamemanager hash table");
					}
					yield return new WaitForEndOfFrame();
					Player.instance.currentControllerInput.xButton.wasPressed = true;
					Player.instance.currentControllerInput.xButton.down = true;
					grabbing = true;
					MonoBehaviour.print("pressed");
					yield return null;
					Player.instance.editorGrabber.transform.position = new Vector3(j, i, 0f);
					Player.instance.currentControllerInput.xButton.down = true;
					MonoBehaviour.print("moved");
					yield return null;
					grabbing = false;
					MonoBehaviour.print("released");
					yield return null;
					yield return null;
					if (go.transform.parent != LevelEditor.instance.levelParent)
					{
						MonoBehaviour.print("not in: " + go.name);
					}
				}
				else
				{
					MonoBehaviour.print(pss[j].name + " does not have a piece");
				}
			}
		}
		yield return null;
		Player.instance.editorGrabber.transform.parent = grabberParent;
		Player.instance.editorGrabber.transform.localPosition = localPos;
		MonoBehaviour.print("finished placing pieces");
	}

	private IEnumerator Inputs()
	{
		while (!finished)
		{
			if (grabbing)
			{
				Player.instance.currentControllerInput.xButton.down = true;
				Player.instance.currentControllerInput.xButton.wasReleased = false;
			}
			yield return new WaitForFixedUpdate();
		}
	}
}
public class DetailPanel : MonoBehaviour
{
	public Text title;

	public Text val;

	public UnityEngine.Object piece;

	public FieldInfo fi;

	public PropertyInfo pi;

	public PointerButton b1;

	public PointerButton b2;
}
public class EditorCannon : MonoBehaviour
{
	public GameObject cannonKart;

	public GameObject cannonPipe;

	public Cannon cannon;

	public GameObject aimPoint;

	public float aimPointMinRadius;

	public float aimPointMaxRadius;

	[HideInInspector]
	public float power;

	public Transform rotatePoint;

	public LineRenderer trajectoryLineRenderer;

	public int trajectorySteps;

	public float trajectoryTime = 1f;

	public LayerMask editorPieceLayer;

	public Transform launchPoint;

	public float minPower = 0.1f;

	public float powerMultiplier = 2f;

	public bool isRotating;

	public float angle;

	public float halfDuration;

	private float timer;

	private int direction = 1;

	private void OnDrawGizmosSelected()
	{
		Gizmos.color = Color.white;
		Gizmos.DrawWireSphere(cannonPipe.transform.position, aimPointMaxRadius);
		Gizmos.color = Color.green;
		Gizmos.DrawWireSphere(cannonPipe.transform.position, aimPointMinRadius);
	}

	private void Start()
	{
		trajectoryLineRenderer.positionCount = trajectorySteps;
		for (int i = 0; i < trajectorySteps; i++)
		{
			trajectoryLineRenderer.SetPosition(i, launchPoint.position);
		}
		UpdateDynamicParts();
	}

	private void Update()
	{
		if (isRotating)
		{
			timer += Time.deltaTime * (float)direction;
			float num = Interpolation.QuadEaseInOut(timer, (0f - angle) / 2f, angle, halfDuration);
			Quaternion quaternion = Quaternion.LookRotation(-Vector3.ProjectOnPlane(aimPoint.transform.position - rotatePoint.transform.position, rotatePoint.transform.up), rotatePoint.transform.up);
			cannonKart.transform.rotation = Quaternion.AngleAxis(num, rotatePoint.transform.up) * quaternion;
			if (direction == 1 && timer > halfDuration)
			{
				direction = -1;
			}
			else if (direction == -1 && timer < 0f)
			{
				direction = 1;
			}
		}
		if (trajectoryLineRenderer.enabled)
		{
			DrawTrajectory();
		}
	}

	public void ResetTime()
	{
		if (isRotating)
		{
			timer = 0f;
			direction = 1;
			Quaternion rotation = Quaternion.LookRotation(-Vector3.ProjectOnPlane(aimPoint.transform.position - rotatePoint.transform.position, rotatePoint.transform.up), rotatePoint.transform.up);
			cannonKart.transform.rotation = rotation;
		}
	}

	public void UpdateDynamicParts()
	{
		Vector3 vector = aimPoint.transform.position - rotatePoint.position;
		power = vector.magnitude / base.transform.lossyScale.x - aimPointMinRadius + minPower;
		cannon.speed = power * powerMultiplier;
		if (vector != Vector3.zero)
		{
			Vector3 vector2 = -Vector3.ProjectOnPlane(vector, rotatePoint.up);
			if (vector2 != Vector3.zero)
			{
				cannonKart.transform.rotation = Quaternion.LookRotation(vector2, cannonKart.transform.up);
			}
			Vector3 vector3 = Vector3.ProjectOnPlane(vector, cannonKart.transform.right);
			if (vector3 != Vector3.zero)
			{
				cannonPipe.transform.rotation = Quaternion.LookRotation(vector3, cannonPipe.transform.up);
			}
		}
	}

	public void ApplyConstraints(Vector3 position)
	{
		Vector3 vector = Vector3.ClampMagnitude(aimPoint.transform.position - rotatePoint.position, aimPointMaxRadius * base.transform.lossyScale.x);
		if ((aimPoint.transform.position - rotatePoint.position).magnitude < aimPointMinRadius * base.transform.lossyScale.x)
		{
			vector = (aimPoint.transform.position - rotatePoint.position).normalized * (aimPointMinRadius * base.transform.lossyScale.x);
		}
		vector = Quaternion.Inverse(rotatePoint.rotation) * vector;
		if (vector.y < 0f)
		{
			vector.y = 0f;
		}
		vector = rotatePoint.rotation * vector;
		aimPoint.transform.position = rotatePoint.transform.position + vector;
	}

	private void DrawTrajectory()
	{
		trajectoryLineRenderer.positionCount = trajectorySteps;
		Vector3 vector = cannon.speed * launchPoint.forward;
		float num = 0.4f;
		Vector3 vector2 = vector / num;
		float num2 = 0.05f;
		float num3 = trajectoryTime / (float)trajectorySteps;
		Vector3 position = launchPoint.position;
		float num4 = 2f / 3f * base.transform.lossyScale.x;
		Vector3 vector3 = position;
		Vector3 vector4 = Physics.gravity * num3;
		Vector3 vector5 = num * LevelEditor.instance.editorWind.wind.GetWindVector() * 0.008328f;
		Vector3 vector6 = vector4 + vector5;
		Vector3 vector7 = position;
		trajectoryLineRenderer.SetPosition(0, vector7);
		float num5 = num3 * num4;
		float num6 = num3 * num2;
		Vector3 vector8 = (vector2 + vector6 * 0.525f) * (1f - num6);
		if (Physics.Raycast(vector7 + vector8 * num5, -(vector8 * num5), out var hitInfo, (vector8 * num3 * num4).magnitude, editorPieceLayer, QueryTriggerInteraction.Ignore))
		{
			trajectoryLineRenderer.SetPosition(1, hitInfo.point);
			trajectoryLineRenderer.positionCount = 2;
			return;
		}
		for (int i = 1; i < trajectorySteps; i++)
		{
			Vector3 vector9 = vector8 * num5;
			if (Physics.Raycast(vector7, vector9, out hitInfo, vector9.magnitude, editorPieceLayer, QueryTriggerInteraction.Ignore))
			{
				trajectoryLineRenderer.SetPosition(i, hitInfo.point);
				trajectoryLineRenderer.positionCount = i + 1;
				break;
			}
			vector3 += vector8 * num3;
			vector8 = (vector8 + vector6) * (1f - num6);
			vector7 = position + (vector3 - position) * num4;
			trajectoryLineRenderer.SetPosition(i, vector7);
		}
	}
}
public class EditorFan : MonoBehaviour
{
	public GameObject fanHead;

	public GameObject aimPoint;

	public float aimPointMinRadius;

	public float aimPointMaxRadius;

	public float minPower = 0.25f;

	public float minSpeed = 50f;

	public float speedMultiplier = 500f;

	public Fan fan;

	public GameObject mesh;

	public bool isRotating;

	public float angle;

	public float halfDuration;

	private float timer;

	private int direction = 1;

	private void OnDrawGizmosSelected()
	{
		Gizmos.color = Color.white;
		Gizmos.DrawWireSphere(fanHead.transform.position, aimPointMaxRadius);
		Gizmos.color = Color.green;
		Gizmos.DrawWireSphere(fanHead.transform.position, aimPointMinRadius);
	}

	public void ResetTime()
	{
		timer = 0f;
		direction = 1;
	}

	public void ApplyConstraints(Vector3 position)
	{
		if ((aimPoint.transform.position - fanHead.transform.position).magnitude != 0f)
		{
			Vector3 vector = Vector3.ClampMagnitude(aimPoint.transform.position - fanHead.transform.position, aimPointMaxRadius * base.transform.lossyScale.x);
			if ((aimPoint.transform.position - fanHead.transform.position).magnitude < aimPointMinRadius * base.transform.lossyScale.x)
			{
				vector = (aimPoint.transform.position - fanHead.transform.position).normalized * (aimPointMinRadius * base.transform.lossyScale.x);
			}
			vector = Quaternion.Inverse(base.transform.rotation) * vector;
			if (vector.x < 0f)
			{
				vector.x = 0f;
			}
			vector = base.transform.rotation * vector;
			vector = Vector3.ProjectOnPlane(vector, base.transform.forward);
			aimPoint.transform.position = vector + fanHead.transform.position;
		}
	}

	public void UpdateDynamicParts()
	{
		Vector3 vector = aimPoint.transform.position - fanHead.transform.position;
		if (vector != Vector3.zero)
		{
			Vector3 forward = Vector3.ProjectOnPlane(vector, mesh.transform.forward);
			fanHead.transform.rotation = Quaternion.LookRotation(forward, fanHead.transform.up);
		}
		float num = vector.magnitude / base.transform.lossyScale.x;
		fan.windmillArmsSpeed = (num - aimPointMinRadius) * speedMultiplier + minSpeed;
		fan.userThrust = num - aimPointMinRadius + minPower;
	}

	private void Update()
	{
		if (!isRotating)
		{
			return;
		}
		Vector3 vector = aimPoint.transform.position - base.transform.position;
		if (Vector3.Angle(vector, base.transform.right) == 0f)
		{
			vector = base.transform.up + base.transform.forward * 0.01f;
		}
		Vector3 vector2 = Vector3.ProjectOnPlane(vector, base.transform.right);
		Vector3 vector3 = Vector3.Cross(base.transform.right, vector2);
		if (vector2 != Vector3.zero && vector3 != Vector3.zero)
		{
			Quaternion quaternion = Quaternion.LookRotation(vector3, vector2);
			timer += Time.deltaTime * (float)direction;
			float num = Interpolation.QuadEaseInOut(timer, (0f - angle) / 2f, angle, halfDuration);
			mesh.transform.rotation = Quaternion.AngleAxis(num, base.transform.right) * quaternion;
			if (direction == 1 && timer > halfDuration)
			{
				direction = -1;
			}
			else if (direction == -1 && timer < 0f)
			{
				direction = 1;
			}
		}
	}
}
public class EditorGrabber : MonoBehaviour
{
	[Header("Controller")]
	private ControllerInput controllerInput;

	public bool pointingAtUI;

	public GameObject grabberManipObj;

	public GameObject terrainManipObj;

	public GameObject pointerManipObj;

	public GameObject addManipObj;

	public GameObject selectManipObj;

	public AudioSource audioSource;

	public LineRenderer lineRenderer;

	[Header("Details")]
	public GameObject currentActiveObject;

	private List<GameObject> hoveringObjects = new List<GameObject>();

	public bool grabbing;

	public bool originGrabbed;

	public bool selectionGrabbed;

	public bool menuGrabbing;

	public bool editingWind;

	public bool windGrabbing;

	private bool intersectingCurrentActiveObject;

	private PieceState[] connectedPieceStates;

	private Vector3 startPosition;

	private Quaternion startRotation;

	public bool keepFlat = true;

	public float duplicateOffsetDistance;

	private float linkedPieceOffset = -0.025f;

	private Vector3 startPlaceablePiecePos;

	private Quaternion startPlaceablePieceRot;

	private int startPlacementPieceIndex;

	private List<PlaceableData> startPlaceableData = new List<PlaceableData>();

	public List<GameObject> selectedObjects = new List<GameObject>();

	public List<GameObject> selectedConnectedObjects = new List<GameObject>();

	public Color highlightColor;

	[Header("Snap")]
	public bool snapped;

	private Vector3 snappedStart;

	public float breakThreshold = 0.05f;

	public List<SnapPoint> currentSnapPoints;

	private SnapData[][] startSnapData;

	private bool activateSnapPoints = true;

	private Vector3 snapPointStartPosition;

	private Quaternion snapPointStartRotation;

	public AudioClip rotateSFX0Degrees;

	public AudioClip rotateSFX;

	[Header("Fairway")]
	public bool fairwayDrawing;

	public bool fairwayPainting;

	public GameObject fairwayPrefab;

	public Color paintColor;

	private void Update()
	{
		if (controllerInput != Player.instance.currentControllerInput)
		{
			controllerInput = Player.instance.currentControllerInput;
		}
		if (!pointingAtUI && !originGrabbed && !windGrabbing && !grabbing && !selectionGrabbed && controllerInput.xButton.wasPressed)
		{
			controllerInput.Vibrate();
			if (currentActiveObject != null && currentActiveObject.GetComponent<LevelEditorMenu>() != null)
			{
				menuGrabbing = true;
				connectedPieceStates = new PieceState[1];
				connectedPieceStates[0].gameObject = currentActiveObject;
				connectedPieceStates[0].posOffset = Quaternion.Inverse(currentActiveObject.transform.rotation) * (currentActiveObject.transform.position - base.transform.position);
				connectedPieceStates[0].rotOffset = Quaternion.Inverse(base.transform.rotation) * currentActiveObject.transform.rotation;
			}
		}
		if (controllerInput.touchpadStatus.downTouchpadButtonStatus.wasPressed)
		{
			keepFlat = !keepFlat;
			Player.instance.currentController.SwitchToSnapMode(keepFlat);
		}
		if (LevelEditor.instance.canEdit)
		{
			if (editingWind && controllerInput.xButton.wasPressed && currentActiveObject != null && (bool)currentActiveObject.GetComponent<EditorWind>())
			{
				windGrabbing = true;
				connectedPieceStates = new PieceState[1];
				connectedPieceStates[0].gameObject = currentActiveObject;
				connectedPieceStates[0].posOffset = Quaternion.Inverse(currentActiveObject.transform.rotation) * (currentActiveObject.transform.position - base.transform.position);
				connectedPieceStates[0].rotOffset = Quaternion.Inverse(base.transform.rotation) * currentActiveObject.transform.rotation;
			}
			if (currentActiveObject != null && currentActiveObject.GetComponent<EditorWind>() == null)
			{
				if (controllerInput.touchpadStatus.upTouchpadButtonStatus.wasPressed)
				{
					SelectPressed();
				}
				if (controllerInput.touchpadStatus.rightTouchpadButtonStatus.wasPressed)
				{
					DuplicatePressed();
				}
				if (controllerInput.touchpadStatus.leftTouchpadButtonStatus.wasPressed)
				{
					DeletePressed();
				}
			}
			if (!pointingAtUI && !originGrabbed && !windGrabbing && controllerInput.xButton.wasPressed)
			{
				controllerInput.Vibrate();
				if (currentActiveObject != null)
				{
					if (currentActiveObject.GetComponent<EditorPiece>() != null)
					{
						EditorPiece component = currentActiveObject.GetComponent<EditorPiece>();
						bool flag = true;
						if (component.spawner != null)
						{
							if (LevelEditor.instance.currentComplexity >= LevelEditor.instance.complexityLimit)
							{
								audioSource.PlayOneShot(GameManager.instance.audioManager.blockedSfx);
								Notification.instance.AddNotification("Level complexity reached. Delete pieces to reduce complexity to be able to place new pieces.", 0f, closeButton: true);
								flag = false;
							}
							else if ((bool)component.GetComponent<Teebox>())
							{
								bool flag2 = false;
								for (int i = 0; i < LevelEditor.instance.pieces.Count; i++)
								{
									if ((bool)LevelEditor.instance.pieces[i].GetComponent<Teebox>())
									{
										flag2 = true;
										break;
									}
								}
								if (flag2)
								{
									audioSource.PlayOneShot(GameManager.instance.audioManager.blockedSfx);
									Notification.instance.AddNotification("Only one starting piece allowed per level.", 0f, closeButton: true);
									flag = false;
								}
							}
						}
						if (flag)
						{
							component.Grab(this);
							startPosition = component.transform.localPosition;
							startRotation = component.transform.rotation;
							grabbing = true;
							if (component.snapped)
							{
								snappedStart = base.transform.position;
								currentSnapPoints.Clear();
								snapped = true;
							}
							if (component.placeableObject != null)
							{
								if (component.placementPiece == null)
								{
									startPlacementPieceIndex = -1;
								}
								else
								{
									startPlacementPieceIndex = LevelEditor.instance.stepPieces.IndexOf(component.placementPiece);
								}
								startPlaceablePiecePos = component.placeableObject.transform.localPosition;
								startPlaceablePieceRot = component.placeableObject.transform.rotation;
							}
							if (component.placedPieces.Count > 0)
							{
								connectedPieceStates = new PieceState[component.placedPieces.Count + 1];
								for (int j = 0; j < component.placedPieces.Count; j++)
								{
									connectedPieceStates[j + 1].gameObject = component.placedPieces[j];
									connectedPieceStates[j + 1].posOffset = Quaternion.Inverse(component.placedPieces[j].transform.rotation) * (component.placedPieces[j].transform.position - component.transform.position);
									connectedPieceStates[j + 1].rotOffset = Quaternion.Inverse(component.transform.rotation) * component.placedPieces[j].transform.rotation;
								}
							}
							else
							{
								connectedPieceStates = new PieceState[1];
							}
							connectedPieceStates[0].gameObject = currentActiveObject;
							connectedPieceStates[0].posOffset = Quaternion.Inverse(currentActiveObject.transform.rotation) * (currentActiveObject.transform.position - base.transform.position);
							connectedPieceStates[0].rotOffset = Quaternion.Inverse(base.transform.rotation) * currentActiveObject.transform.rotation;
							startSnapData = new SnapData[connectedPieceStates.Length][];
							for (int k = 0; k < connectedPieceStates.Length; k++)
							{
								startSnapData[k] = LevelEditor.instance.GetSnappedPoints(connectedPieceStates[k].gameObject.GetComponent<EditorPiece>());
								for (int l = 0; l < connectedPieceStates[k].gameObject.GetComponent<EditorPiece>().snapPoints.Length; l++)
								{
									if (connectedPieceStates[k].gameObject.GetComponent<EditorPiece>().snapPoints[l].snappedPoint != null)
									{
										currentSnapPoints.Add(connectedPieceStates[k].gameObject.GetComponent<EditorPiece>().snapPoints[l]);
									}
								}
							}
						}
					}
					else if ((bool)currentActiveObject.GetComponent<EditPoint>())
					{
						grabbing = true;
						startPosition = currentActiveObject.transform.localPosition;
						startRotation = currentActiveObject.transform.rotation;
						connectedPieceStates = new PieceState[1];
						connectedPieceStates[0].gameObject = currentActiveObject;
						connectedPieceStates[0].posOffset = Quaternion.Inverse(currentActiveObject.transform.rotation) * (currentActiveObject.transform.position - base.transform.position);
						connectedPieceStates[0].rotOffset = Quaternion.Inverse(base.transform.rotation) * currentActiveObject.transform.rotation;
					}
					else if (currentActiveObject.GetComponent<RotateHandle>() != null)
					{
						RotateHandle component2 = currentActiveObject.GetComponent<RotateHandle>();
						grabbing = true;
						snapPointStartPosition = component2.snapPoint.transform.position;
						snapPointStartRotation = component2.piece.transform.rotation;
						startPosition = component2.piece.transform.localPosition;
						startRotation = component2.piece.transform.rotation;
						startSnapData = new SnapData[1][];
						startSnapData[0] = LevelEditor.instance.GetSnappedPoints(component2.piece);
						if (component2.piece.placedPieces.Count > 0)
						{
							connectedPieceStates = new PieceState[component2.piece.placedPieces.Count];
							for (int m = 0; m < component2.piece.placedPieces.Count; m++)
							{
								connectedPieceStates[m].gameObject = component2.piece.placedPieces[m];
								connectedPieceStates[m].posOffset = Quaternion.Inverse(component2.piece.placedPieces[m].transform.rotation) * (component2.piece.placedPieces[m].transform.position - component2.piece.transform.position);
								connectedPieceStates[m].rotOffset = Quaternion.Inverse(component2.piece.transform.rotation) * component2.piece.placedPieces[m].transform.rotation;
							}
						}
						else
						{
							connectedPieceStates = null;
						}
					}
				}
			}
			else if (!grabbing && !menuGrabbing && controllerInput.bButton.wasPressed)
			{
				if (currentActiveObject != null && currentActiveObject.GetComponent<LevelEditorMenu>() != null)
				{
					menuGrabbing = true;
					connectedPieceStates = new PieceState[1];
					connectedPieceStates[0].gameObject = currentActiveObject;
					connectedPieceStates[0].posOffset = Quaternion.Inverse(currentActiveObject.transform.rotation) * (currentActiveObject.transform.position - base.transform.position);
					connectedPieceStates[0].rotOffset = Quaternion.Inverse(base.transform.rotation) * currentActiveObject.transform.rotation;
				}
				else if (selectedObjects.Count > 0)
				{
					selectionGrabbed = true;
					Transform groupSelectTransform = LevelEditor.instance.groupSelectTransform;
					groupSelectTransform.position = base.transform.position;
					groupSelectTransform.rotation = Quaternion.identity;
					startPosition = groupSelectTransform.position;
					startRotation = groupSelectTransform.rotation;
					startSnapData = new SnapData[selectedObjects.Count + selectedConnectedObjects.Count][];
					connectedPieceStates = new PieceState[selectedObjects.Count + selectedConnectedObjects.Count + 1];
					connectedPieceStates[0].gameObject = groupSelectTransform.gameObject;
					connectedPieceStates[0].posOffset = Quaternion.Inverse(groupSelectTransform.rotation) * (groupSelectTransform.position - base.transform.position);
					connectedPieceStates[0].rotOffset = Quaternion.Inverse(base.transform.rotation) * groupSelectTransform.rotation;
					bool flag3 = false;
					List<GameObject> list = new List<GameObject>();
					list.AddRange(selectedObjects);
					list.AddRange(selectedConnectedObjects);
					startPlaceableData.Clear();
					for (int n = 0; n < list.Count; n++)
					{
						Transform transform = list[n].transform;
						connectedPieceStates[n + 1].gameObject = transform.gameObject;
						connectedPieceStates[n + 1].posOffset = Quaternion.Inverse(transform.rotation) * (transform.position - groupSelectTransform.position);
						connectedPieceStates[n + 1].rotOffset = Quaternion.Inverse(groupSelectTransform.rotation) * transform.rotation;
						EditorPiece component3 = list[n].GetComponent<EditorPiece>();
						if (component3.placeableObject != null)
						{
							PlaceableData item = default(PlaceableData);
							item.pieceIndex = (short)LevelEditor.instance.stepPieces.IndexOf(component3.gameObject);
							if (component3.placementPiece == null)
							{
								item.placementPieceIndex = -1;
							}
							else
							{
								item.placementPieceIndex = (short)LevelEditor.instance.stepPieces.IndexOf(component3.placementPiece);
							}
							item.piecePosition = component3.placeableObject.transform.localPosition;
							item.pieceRotation = component3.placeableObject.transform.rotation;
							startPlaceableData.Add(item);
						}
						if (component3.placeableObject == null || (component3.placeableObject != null && component3.placementPiece != null && !list.Contains(component3.placementPiece)))
						{
							component3.Grab(this);
						}
						startSnapData[n] = LevelEditor.instance.GetSnappedPoints(component3);
						for (int num = 0; num < component3.snapPoints.Length; num++)
						{
							if (component3.snapPoints[num].snappedPoint != null)
							{
								currentSnapPoints.Add(component3.snapPoints[num]);
								if (!list.Contains(component3.snapPoints[num].snappedPoint.piece.gameObject))
								{
									flag3 = true;
								}
							}
						}
						if (!snapped && component3.snapped)
						{
							snappedStart = base.transform.position;
							snapped = true;
						}
					}
					if (snapped && !flag3)
					{
						snapped = false;
					}
				}
				else if (currentActiveObject == null && !string.IsNullOrEmpty(LevelEditor.instance.levelEditorMenu.currentLevelPath))
				{
					originGrabbed = true;
					startPosition = LevelEditor.instance.levelParent.position;
					startRotation = LevelEditor.instance.levelParent.rotation;
					connectedPieceStates = new PieceState[1];
					connectedPieceStates[0].gameObject = LevelEditor.instance.levelParent.gameObject;
					connectedPieceStates[0].posOffset = Quaternion.Inverse(LevelEditor.instance.levelParent.rotation) * (LevelEditor.instance.levelParent.position - base.transform.position);
					connectedPieceStates[0].rotOffset = Quaternion.Inverse(base.transform.rotation) * LevelEditor.instance.levelParent.rotation;
				}
			}
			if (grabbing)
			{
				if (controllerInput.xButton.wasReleased)
				{
					UnGrab();
				}
				else if ((bool)currentActiveObject.GetComponent<EditPoint>())
				{
					MovePieces(keepFlat);
					currentActiveObject.GetComponent<EditPoint>().Grab();
					lineRenderer.enabled = true;
					lineRenderer.SetPosition(0, base.transform.position);
					lineRenderer.SetPosition(1, currentActiveObject.transform.position);
				}
				else if (currentActiveObject.GetComponent<EditorPiece>() != null)
				{
					MovePieces(keepFlat);
				}
				else if (currentActiveObject.GetComponent<LevelEditorMenu>() != null)
				{
					MovePieces(rotateFlat: false);
				}
				else if (currentActiveObject.GetComponent<RotateHandle>() != null)
				{
					RotateHandle component4 = currentActiveObject.GetComponent<RotateHandle>();
					if (keepFlat)
					{
						Vector3 rhs = base.transform.position - snapPointStartPosition;
						Vector3 toDirection = Vector3.Cross(component4.snapPoint.transform.right, rhs);
						if (component4.side)
						{
							toDirection = Vector3.Cross(component4.snapPoint.transform.up, rhs);
						}
						Quaternion quaternion = Quaternion.FromToRotation(component4.snapPoint.transform.up, toDirection);
						if (component4.upNormal)
						{
							quaternion = Quaternion.FromToRotation(component4.snapPoint.transform.forward, toDirection);
						}
						else if (component4.downNormal)
						{
							quaternion = Quaternion.FromToRotation(-component4.snapPoint.transform.forward, toDirection);
						}
						if (component4.side)
						{
							quaternion = Quaternion.FromToRotation(-component4.snapPoint.transform.right, toDirection);
						}
						Quaternion b = quaternion * component4.piece.transform.rotation;
						float num2 = 5f;
						float num3 = Quaternion.Angle(snapPointStartRotation, b);
						float num4 = num3 % num2;
						float num5 = ((num4 >= num2 / 2f) ? (num3 - num4 + num2) : (num3 - num4));
						Quaternion quaternion2 = snapPointStartRotation;
						if (num3 != 0f)
						{
							quaternion2 = Quaternion.SlerpUnclamped(snapPointStartRotation, b, num5 / num3);
						}
						if (component4.piece.transform.rotation != quaternion2)
						{
							component4.piece.UnSnapAllPointsExcludingHandle(component4);
							component4.piece.transform.rotation = quaternion2;
							Vector3 vector = snapPointStartPosition - component4.snapPoint.transform.position;
							component4.piece.transform.position += vector;
							if (num5 == 0f)
							{
								audioSource.PlayOneShot(rotateSFX0Degrees);
							}
							else
							{
								audioSource.PlayOneShot(rotateSFX);
							}
						}
						lineRenderer.enabled = true;
						lineRenderer.SetPosition(0, base.transform.position);
						lineRenderer.SetPosition(1, component4.transform.position);
						if (connectedPieceStates != null && connectedPieceStates.Length != 0)
						{
							for (int num6 = 0; num6 < connectedPieceStates.Length; num6++)
							{
								connectedPieceStates[num6].gameObject.transform.rotation = component4.piece.gameObject.transform.rotation * connectedPieceStates[num6].rotOffset;
								connectedPieceStates[num6].gameObject.transform.position = component4.piece.gameObject.transform.position + connectedPieceStates[num6].gameObject.transform.rotation * connectedPieceStates[num6].posOffset;
							}
						}
					}
				}
			}
		}
		if (menuGrabbing)
		{
			if ((controllerInput.bButton.wasReleased && !controllerInput.xButton.down) || (controllerInput.xButton.wasReleased && !controllerInput.bButton.down))
			{
				UnGrab();
				menuGrabbing = false;
			}
			else
			{
				MovePieces(rotateFlat: false);
			}
		}
		if (originGrabbed)
		{
			if (controllerInput.bButton.wasReleased)
			{
				UnGrabOrigin();
			}
			else
			{
				MovePieces(rotateFlat: true);
				if (!LevelEditor.instance.randomWind)
				{
					LevelEditor.instance.levelEditorMenu.SetWindVector();
				}
			}
		}
		if (selectionGrabbed)
		{
			if (controllerInput.bButton.wasReleased)
			{
				UnGrabSelection();
			}
			else
			{
				MovePieces(keepFlat);
			}
		}
		if (!windGrabbing)
		{
			return;
		}
		if (controllerInput.xButton.wasReleased)
		{
			windGrabbing = false;
			connectedPieceStates = null;
			return;
		}
		MovePieces(rotateFlat: false);
		if (!LevelEditor.instance.randomWind)
		{
			LevelEditor.instance.levelEditorMenu.SetWindVector();
			LevelEditor.instance.editorWind.wind.SetWindSpeed(LevelEditor.instance.currentLevel.windVector, LevelEditor.instance.levelParent);
		}
		LevelEditor.instance.UpdateFlagDirections();
	}

	public void PrepareForPreview()
	{
		if (grabbing)
		{
			UnGrab();
		}
		else if (originGrabbed)
		{
			connectedPieceStates = null;
			originGrabbed = false;
		}
	}

	private void MovePieces(bool rotateFlat)
	{
		if (snapped)
		{
			if ((base.transform.position - snappedStart).magnitude < breakThreshold)
			{
				float t = (base.transform.position - snappedStart).magnitude / breakThreshold;
				for (int i = 0; i < currentSnapPoints.Count; i++)
				{
					currentSnapPoints[i].BreakPercent(t);
				}
				return;
			}
			for (int j = 0; j < currentSnapPoints.Count; j++)
			{
				currentSnapPoints[j].BreakPercent(0f);
				if (!selectionGrabbed || !selectedObjects.Contains(currentSnapPoints[j].snappedPoint.piece.gameObject))
				{
					currentSnapPoints[j].snappedPoint.piece.UnSnapPoint(currentSnapPoints[j].snappedPoint);
					currentSnapPoints[j].piece.UnSnapPoint(currentSnapPoints[j]);
				}
			}
			currentSnapPoints.Clear();
			snapped = false;
			return;
		}
		Quaternion quaternion = base.transform.rotation * connectedPieceStates[0].rotOffset;
		Quaternion quaternion2 = Quaternion.identity;
		if (rotateFlat)
		{
			quaternion2 = Quaternion.FromToRotation(quaternion * Vector3.up, Vector3.up);
		}
		connectedPieceStates[0].gameObject.transform.rotation = quaternion2 * quaternion;
		connectedPieceStates[0].gameObject.transform.position = base.transform.position + connectedPieceStates[0].gameObject.transform.rotation * connectedPieceStates[0].posOffset;
		List<Golfhole> list = new List<Golfhole>();
		Golfhole componentInChildren = connectedPieceStates[0].gameObject.GetComponentInChildren<Golfhole>();
		if (componentInChildren != null)
		{
			list.Add(componentInChildren);
		}
		for (int k = 1; k < connectedPieceStates.Length; k++)
		{
			connectedPieceStates[k].gameObject.transform.rotation = connectedPieceStates[0].gameObject.transform.rotation * connectedPieceStates[k].rotOffset;
			connectedPieceStates[k].gameObject.transform.position = connectedPieceStates[0].gameObject.transform.position + connectedPieceStates[k].gameObject.transform.rotation * connectedPieceStates[k].posOffset;
			Golfhole componentInChildren2 = connectedPieceStates[k].gameObject.GetComponentInChildren<Golfhole>();
			if (componentInChildren2 != null)
			{
				list.Add(componentInChildren2);
			}
		}
		if (list.Count > 0)
		{
			Vector3 vector = LevelEditor.instance.levelParent.TransformDirection(LevelEditor.instance.currentLevel.windVector);
			if (vector == Vector3.zero)
			{
				vector = Vector3.right;
			}
			for (int l = 0; l < list.Count; l++)
			{
				list[l].ChangeFlagDirection(vector);
			}
		}
	}

	public void UnGrab()
	{
		grabbing = false;
		EditorPiece component = currentActiveObject.GetComponent<EditorPiece>();
		if (component != null)
		{
			if (component.spawner == null)
			{
				CreateMoveStep(component);
			}
			component.LetGo();
		}
		else if (currentActiveObject.GetComponent<EditPoint>() != null)
		{
			EditPoint component2 = currentActiveObject.GetComponent<EditPoint>();
			component2.ApplyConstraintsAndUpdateDynamics(currentActiveObject.transform.position);
			EditorStep step = default(EditorStep);
			step.stepType = StepType.editPointMove;
			step.pieceIndex = LevelEditor.instance.stepPieces.IndexOf(component2.piece.gameObject);
			step.position = component2.transform.localPosition - startPosition;
			step.rotation = Quaternion.Inverse(component2.transform.rotation) * startRotation;
			LevelEditor.instance.AddStep(step);
			lineRenderer.enabled = false;
		}
		else if (currentActiveObject.GetComponent<RotateHandle>() != null)
		{
			RotateHandle component3 = currentActiveObject.GetComponent<RotateHandle>();
			_ = component3.piece.transform.localPosition - startPosition;
			_ = Quaternion.Inverse(component3.piece.transform.rotation) * startRotation;
			LevelEditor.SnapDataSub(LevelEditor.instance.GetSnappedPoints(component3.piece), startSnapData[0]);
			CreateMoveStep(component3.piece);
			lineRenderer.enabled = false;
			connectedPieceStates = null;
		}
		connectedPieceStates = null;
		currentSnapPoints.Clear();
		snapped = false;
		if (!intersectingCurrentActiveObject)
		{
			if ((bool)currentActiveObject.GetComponent<EditorPiece>())
			{
				if (selectedObjects.Contains(currentActiveObject))
				{
					currentActiveObject.GetComponent<EditorPiece>().SelectHighlight();
				}
				else
				{
					currentActiveObject.GetComponent<EditorPiece>().UnHighlight();
				}
			}
			else if ((bool)currentActiveObject.GetComponent<RotateHandle>())
			{
				currentActiveObject.GetComponent<RotateHandle>().UnHighlight();
			}
			currentActiveObject = null;
		}
		else if ((bool)currentActiveObject.GetComponent<EditorPiece>())
		{
			currentActiveObject.GetComponent<EditorPiece>().Highlight();
		}
		else if ((bool)currentActiveObject.GetComponent<RotateHandle>())
		{
			currentActiveObject.GetComponent<RotateHandle>().Highlight();
		}
	}

	public void UnGrabOrigin()
	{
		EditorStep step = default(EditorStep);
		step.stepType = StepType.originMove;
		step.position = LevelEditor.instance.levelParent.localPosition - startPosition;
		step.rotation = Quaternion.Inverse(LevelEditor.instance.levelParent.rotation) * startRotation;
		LevelEditor.instance.AddStep(step);
		connectedPieceStates = null;
		originGrabbed = false;
	}

	public void UnGrabSelection()
	{
		EditorStep step = default(EditorStep);
		step.stepType = StepType.selectedMove;
		step.position = LevelEditor.instance.groupSelectTransform.position - startPosition;
		step.rotation = Quaternion.Inverse(LevelEditor.instance.groupSelectTransform.rotation) * startRotation;
		step.endPosition = LevelEditor.instance.groupSelectTransform.position;
		step.endRotation = LevelEditor.instance.groupSelectTransform.rotation;
		List<GameObject> list = new List<GameObject>();
		list.AddRange(selectedObjects);
		list.AddRange(selectedConnectedObjects);
		int[] array = new int[list.Count];
		for (int i = 0; i < list.Count; i++)
		{
			array[i] = LevelEditor.instance.stepPieces.IndexOf(list[i]);
			connectedPieceStates[i + 1].gameObject.GetComponent<EditorPiece>().SetSnapPointActive(value: false);
			list[i].GetComponent<EditorPiece>().LetGo();
		}
		PlaceableData[] array2 = new PlaceableData[startPlaceableData.Count];
		for (int j = 0; j < startPlaceableData.Count; j++)
		{
			EditorPiece component = LevelEditor.instance.stepPieces[startPlaceableData[j].pieceIndex].GetComponent<EditorPiece>();
			if (component.placeableObject != null)
			{
				PlaceableData placeableData = default(PlaceableData);
				placeableData.pieceIndex = startPlaceableData[j].pieceIndex;
				placeableData.piecePosition = component.placeableObject.transform.localPosition - startPlaceableData[j].piecePosition;
				placeableData.pieceRotation = Quaternion.Inverse(component.placeableObject.transform.rotation) * startPlaceableData[j].pieceRotation;
				if (component.placementPiece == null)
				{
					placeableData.placementPieceIndex = (short)(startPlaceableData[j].placementPieceIndex + 1);
				}
				else
				{
					placeableData.placementPieceIndex = (short)(startPlaceableData[j].placementPieceIndex - LevelEditor.instance.stepPieces.IndexOf(component.placementPiece));
				}
				array2[j] = placeableData;
			}
		}
		step.placeableData = array2;
		SnapData[][] array3 = new SnapData[list.Count][];
		for (int k = 0; k < array3.Length; k++)
		{
			if (startSnapData[k] != null)
			{
				array3[k] = LevelEditor.SnapDataSub(LevelEditor.instance.GetSnappedPoints(list[k].GetComponent<EditorPiece>()), startSnapData[k]);
			}
		}
		step.snappedPoints = array3;
		step.groupPieces = array;
		LevelEditor.instance.AddStep(step);
		connectedPieceStates = null;
		selectionGrabbed = false;
		snapped = false;
		currentSnapPoints.Clear();
	}

	public void GrabMenu()
	{
		menuGrabbing = true;
		currentActiveObject = LevelEditor.instance.levelEditorMenu.gameObject;
		connectedPieceStates = new PieceState[1];
		connectedPieceStates[0].gameObject = currentActiveObject;
		connectedPieceStates[0].posOffset = Quaternion.Inverse(currentActiveObject.transform.rotation) * (currentActiveObject.transform.position - base.transform.position);
		connectedPieceStates[0].rotOffset = Quaternion.Inverse(base.transform.rotation) * currentActiveObject.transform.rotation;
	}

	public void ClearSelectedObjects()
	{
		selectedObjects.Clear();
		selectedConnectedObjects.Clear();
		UpdateSelectionMenu();
	}

	public void CreateMoveStep(EditorPiece piece)
	{
		EditorStep step = default(EditorStep);
		step.pieceIndex = LevelEditor.instance.stepPieces.IndexOf(piece.gameObject);
		step.stepType = StepType.move;
		step.position = piece.transform.localPosition - startPosition;
		step.rotation = Quaternion.Inverse(piece.transform.rotation) * startRotation;
		SnapData[] array = LevelEditor.SnapDataSub(LevelEditor.instance.GetSnappedPoints(piece), startSnapData[0]);
		step.snappedPoints = new SnapData[1][] { array };
		if (piece.placeableObject != null)
		{
			PlaceableData placeableData = default(PlaceableData);
			placeableData.pieceIndex = (short)LevelEditor.instance.stepPieces.IndexOf(piece.gameObject);
			placeableData.piecePosition = piece.placeableObject.transform.localPosition - startPlaceablePiecePos;
			placeableData.pieceRotation = Quaternion.Inverse(piece.placeableObject.transform.rotation) * startPlaceablePieceRot;
			if (piece.placementPiece == null)
			{
				placeableData.placementPieceIndex = (short)(startPlacementPieceIndex + 1);
			}
			else
			{
				placeableData.placementPieceIndex = (short)(startPlacementPieceIndex - LevelEditor.instance.stepPieces.IndexOf(piece.placementPiece));
			}
			step.placeableData = new PlaceableData[1];
			step.placeableData[0] = placeableData;
		}
		LevelEditor.instance.AddStep(step);
	}

	public void DuplicatePressed()
	{
		if (!(currentActiveObject != null))
		{
			return;
		}
		EditorPiece component = currentActiveObject.GetComponent<EditorPiece>();
		if (!(component != null) || !(component.spawner == null))
		{
			return;
		}
		if (LevelEditor.instance.currentComplexity >= LevelEditor.instance.complexityLimit)
		{
			audioSource.PlayOneShot(GameManager.instance.audioManager.blockedSfx);
			Notification.instance.AddNotification("Level complexity reached. Delete pieces to reduce complexity to be able to duplicate.", 0f, closeButton: true);
			return;
		}
		if ((bool)component.GetComponent<Teebox>())
		{
			audioSource.PlayOneShot(GameManager.instance.audioManager.blockedSfx);
			Notification.instance.AddNotification("Only one starting piece allowed per level.", 0f, closeButton: true);
			return;
		}
		Vector3 offset = base.transform.forward * duplicateOffsetDistance;
		if (component.linkedPiece != null)
		{
			GameObject gameObject = LevelEditor.instance.DuplicatePiece(currentActiveObject, offset);
			GameObject gameObject2 = LevelEditor.instance.DuplicatePiece(gameObject, gameObject.transform.right * linkedPieceOffset * LevelEditor.instance.editScale);
			WarpNode.LinkPieces(gameObject.GetComponent<EditorPiece>(), gameObject2.GetComponent<EditorPiece>());
			LevelEditor.instance.AddStep(gameObject.GetComponent<EditorPiece>(), StepType.createLinked);
			LevelEditor.instance.AddStep(gameObject2.GetComponent<EditorPiece>(), StepType.createLinked);
		}
		else
		{
			GameObject gameObject3 = LevelEditor.instance.DuplicatePiece(currentActiveObject, offset);
			LevelEditor.instance.AddStep(gameObject3.GetComponent<EditorPiece>(), StepType.create);
		}
	}

	public void DeletePressed()
	{
		if (!originGrabbed && currentActiveObject != null)
		{
			EditorPiece component = currentActiveObject.GetComponent<EditorPiece>();
			if (component != null)
			{
				if (selectedObjects.Contains(currentActiveObject))
				{
					RemoveSelected(currentActiveObject);
				}
				if (component.spawner == null)
				{
					if (component.linkedPiece != null)
					{
						LevelEditor.instance.AddStep(component, StepType.deleteLinked);
						LevelEditor.instance.AddStep(component.linkedPiece, StepType.deleteLinked);
						LevelEditor.instance.RemovePiece(component.linkedPiece.gameObject, destroyObject: true);
						LevelEditor.instance.RemovePiece(component.gameObject, destroyObject: true);
						currentActiveObject = null;
					}
					else
					{
						if (component.grabbed)
						{
							CreateMoveStep(component);
						}
						LevelEditor.instance.AddStep(component, StepType.delete);
						component.UnSnapAll();
						LevelEditor.instance.RemovePiece(component.gameObject, destroyObject: true);
						currentActiveObject = null;
					}
					if (selectionGrabbed && connectedPieceStates.Length != 0)
					{
						for (int i = 0; i < connectedPieceStates.Length; i++)
						{
							connectedPieceStates[i].gameObject.GetComponent<EditorPiece>().SetSnapPointActive(value: false);
						}
					}
				}
				else if (component.grabbed)
				{
					UnityEngine.Object.Destroy(component.gameObject);
				}
			}
		}
		if (grabbing)
		{
			grabbing = false;
		}
	}

	public void GoingToPauseMenu()
	{
		if (originGrabbed)
		{
			UnGrabOrigin();
		}
		else if (grabbing)
		{
			UnGrab();
		}
		else if (selectionGrabbed)
		{
			UnGrabSelection();
		}
		else if (windGrabbing)
		{
			windGrabbing = false;
			connectedPieceStates = null;
		}
	}

	public void SelectPressed()
	{
		if (grabbing || originGrabbed || !(currentActiveObject != null))
		{
			return;
		}
		EditorPiece component = currentActiveObject.GetComponent<EditorPiece>();
		if (!(component != null) || !(component.spawner == null))
		{
			return;
		}
		if (selectedObjects.Contains(component.gameObject))
		{
			if (component.placementPiece != null && selectedObjects.Contains(component.placementPiece))
			{
				component.ConnectedHighlight();
				selectedConnectedObjects.Add(component.gameObject);
			}
			else
			{
				component.Highlight();
			}
			selectedObjects.Remove(component.gameObject);
			for (int i = 0; i < component.placedPieces.Count; i++)
			{
				if (!selectedObjects.Contains(component.placedPieces[i]) && selectedConnectedObjects.Contains(component.placedPieces[i]))
				{
					selectedConnectedObjects.Remove(component.placedPieces[i]);
					component.placedPieces[i].GetComponent<EditorPiece>().UnHighlight();
				}
			}
		}
		else
		{
			component.SelectHighlight();
			selectedObjects.Add(component.gameObject);
			if (selectedConnectedObjects.Contains(component.gameObject))
			{
				selectedConnectedObjects.Remove(component.gameObject);
			}
			for (int j = 0; j < component.placedPieces.Count; j++)
			{
				if (!selectedObjects.Contains(component.placedPieces[j]))
				{
					component.placedPieces[j].GetComponent<EditorPiece>().ConnectedHighlight();
					selectedConnectedObjects.Add(component.placedPieces[j]);
				}
			}
		}
		UpdateSelectionMenu();
	}

	public void RemoveSelected(GameObject go)
	{
		if (selectedObjects.Contains(go))
		{
			selectedObjects.Remove(go);
			if ((bool)go.GetComponent<EditorPiece>())
			{
				go.GetComponent<EditorPiece>().UnHighlight();
			}
			UpdateSelectionMenu();
		}
	}

	public void UpdateSelectionMenu()
	{
		if (selectedObjects.Count == 0)
		{
			LevelEditor.instance.levelEditorMenu.noPieceSelectedPanel.SetActive(value: true);
			LevelEditor.instance.levelEditorMenu.pieceSelectedPanel.SetActive(value: false);
			LevelEditor.instance.levelEditorMenu.multipleSeletedPanel.SetActive(value: false);
		}
		else if (selectedObjects.Count == 1)
		{
			LevelEditor.instance.detailMenu.FillDetails(selectedObjects[0].GetComponent<EditorPiece>());
			if (selectedObjects[0].GetComponent<EditorPiece>().HasConnectedPieces())
			{
				LevelEditor.instance.levelEditorMenu.selectConnectedButton.SetActive(value: true);
			}
			else
			{
				LevelEditor.instance.levelEditorMenu.selectConnectedButton.SetActive(value: false);
			}
			LevelEditor.instance.levelEditorMenu.noPieceSelectedPanel.SetActive(value: false);
			LevelEditor.instance.levelEditorMenu.pieceSelectedPanel.SetActive(value: true);
			LevelEditor.instance.levelEditorMenu.multipleSeletedPanel.SetActive(value: false);
		}
		else
		{
			LevelEditor.instance.levelEditorMenu.selectedPieceCountText.text = selectedObjects.Count.ToString();
			LevelEditor.instance.levelEditorMenu.noPieceSelectedPanel.SetActive(value: false);
			LevelEditor.instance.levelEditorMenu.pieceSelectedPanel.SetActive(value: false);
			LevelEditor.instance.levelEditorMenu.multipleSeletedPanel.SetActive(value: true);
		}
	}

	public void ClearSelected()
	{
		for (int i = 0; i < selectedObjects.Count; i++)
		{
			selectedObjects[i].GetComponent<EditorPiece>().UnHighlight();
		}
		selectedObjects.Clear();
		for (int j = 0; j < selectedConnectedObjects.Count; j++)
		{
			selectedConnectedObjects[j].GetComponent<EditorPiece>().UnHighlight();
		}
		selectedConnectedObjects.Clear();
	}

	public void NewFairway()
	{
	}

	public void ToggleFairwayEdit()
	{
		fairwayDrawing = !fairwayDrawing;
		if (fairwayDrawing)
		{
			SwitchToManip(terrainManipObj);
		}
		else
		{
			SwitchToManip(grabberManipObj);
		}
	}

	public void ToggleFairwayPaint()
	{
	}

	public void SwitchToManip(GameObject go)
	{
		grabberManipObj.SetActive(value: false);
		terrainManipObj.SetActive(value: false);
		pointerManipObj.SetActive(value: false);
		addManipObj.SetActive(value: false);
		go.SetActive(value: true);
	}

	public void Snap(SnapPoint groupPoint, SnapPoint foreignPoint)
	{
		if (!snapped)
		{
			snapped = true;
			snappedStart = base.transform.position;
			EditorPiece piece = groupPoint.piece;
			int num = 0;
			for (int i = 0; i < connectedPieceStates.Length; i++)
			{
				if (connectedPieceStates[i].gameObject == piece.gameObject)
				{
					num = i;
					break;
				}
			}
			Quaternion quaternion = Quaternion.FromToRotation(piece.transform.up, Vector3.up);
			piece.transform.rotation = quaternion * piece.transform.rotation;
			Quaternion quaternion2 = Quaternion.FromToRotation(piece.transform.up, foreignPoint.transform.up) * piece.transform.rotation;
			Quaternion quaternion3 = Quaternion.FromToRotation(quaternion2 * groupPoint.transform.forward, -foreignPoint.transform.forward);
			piece.transform.rotation = quaternion3 * quaternion2 * piece.transform.rotation;
			Vector3 position = foreignPoint.transform.position + foreignPoint.transform.forward;
			piece.transform.position = position;
			Vector3 vector = piece.transform.position - groupPoint.transform.position;
			audioSource.PlayOneShot(LevelEditor.instance.snapSFX);
			piece.transform.position = foreignPoint.transform.position + vector;
			if (num != 0)
			{
				connectedPieceStates[0].gameObject.transform.position = piece.transform.position - piece.transform.rotation * connectedPieceStates[num].posOffset;
				connectedPieceStates[0].gameObject.transform.rotation = piece.transform.rotation * Quaternion.Inverse(connectedPieceStates[num].rotOffset);
			}
			for (int j = 1; j < connectedPieceStates.Length; j++)
			{
				if (j != num)
				{
					connectedPieceStates[j].gameObject.transform.rotation = connectedPieceStates[0].gameObject.transform.rotation * connectedPieceStates[j].rotOffset;
					connectedPieceStates[j].gameObject.transform.position = connectedPieceStates[0].gameObject.transform.position + connectedPieceStates[j].gameObject.transform.rotation * connectedPieceStates[j].posOffset;
				}
			}
		}
		if (groupPoint.SnapToPointIfClose(foreignPoint))
		{
			currentSnapPoints.Add(groupPoint);
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (!other.GetComponent<EditorPiece>() && !other.GetComponent<EditPoint>() && !other.GetComponent<LevelEditorMenu>() && !other.GetComponent<RotateHandle>())
		{
			return;
		}
		if (!hoveringObjects.Contains(other.gameObject))
		{
			hoveringObjects.Add(other.gameObject);
		}
		controllerInput.Vibrate();
		if (!grabbing && !originGrabbed && !selectionGrabbed)
		{
			if (!(currentActiveObject != other.gameObject))
			{
				return;
			}
			if (currentActiveObject != null)
			{
				if ((bool)currentActiveObject.GetComponent<EditorPiece>())
				{
					if (selectedObjects.Contains(currentActiveObject.gameObject))
					{
						currentActiveObject.GetComponent<EditorPiece>().SelectHighlight();
					}
					else if (selectedConnectedObjects.Contains(currentActiveObject.gameObject))
					{
						currentActiveObject.GetComponent<EditorPiece>().ConnectedHighlight();
					}
					else
					{
						currentActiveObject.GetComponent<EditorPiece>().UnHighlight();
					}
				}
				else if ((bool)currentActiveObject.GetComponent<RotateHandle>())
				{
					currentActiveObject.GetComponent<RotateHandle>().UnHighlight();
				}
				else if ((bool)currentActiveObject.GetComponent<EditorWind>())
				{
					currentActiveObject.GetComponent<EditorWind>().UnHighlight();
				}
				else if ((bool)currentActiveObject.GetComponent<EditPoint>())
				{
					currentActiveObject.GetComponent<EditPoint>().UnHighlight();
				}
				else if ((bool)currentActiveObject.GetComponent<LevelEditorMenu>())
				{
					currentActiveObject.GetComponent<LevelEditorMenu>().UnHighlight();
				}
			}
			currentActiveObject = other.gameObject;
			if ((bool)currentActiveObject.GetComponent<EditorPiece>())
			{
				currentActiveObject.GetComponent<EditorPiece>().Highlight();
			}
			else if ((bool)currentActiveObject.GetComponent<RotateHandle>())
			{
				currentActiveObject.GetComponent<RotateHandle>().Highlight();
			}
			else if ((bool)currentActiveObject.GetComponent<EditorWind>())
			{
				currentActiveObject.GetComponent<EditorWind>().Highlight();
			}
			else if ((bool)currentActiveObject.GetComponent<EditPoint>())
			{
				currentActiveObject.GetComponent<EditPoint>().Highlight();
			}
			else if ((bool)currentActiveObject.GetComponent<LevelEditorMenu>())
			{
				currentActiveObject.GetComponent<LevelEditorMenu>().Highlight();
			}
			intersectingCurrentActiveObject = true;
		}
		else if (currentActiveObject == other.gameObject)
		{
			intersectingCurrentActiveObject = true;
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (!other.GetComponent<EditorPiece>() && !other.GetComponent<EditPoint>() && !other.GetComponent<LevelEditorMenu>() && !other.GetComponent<RotateHandle>())
		{
			return;
		}
		if (hoveringObjects.Contains(other.gameObject))
		{
			hoveringObjects.Remove(other.gameObject);
		}
		controllerInput.Vibrate();
		if (!grabbing && !originGrabbed && !selectionGrabbed)
		{
			if ((bool)other.GetComponent<EditorPiece>())
			{
				if (selectedObjects.Contains(other.gameObject))
				{
					other.GetComponent<EditorPiece>().SelectHighlight();
				}
				else if (selectedConnectedObjects.Contains(other.gameObject))
				{
					other.GetComponent<EditorPiece>().ConnectedHighlight();
				}
				else
				{
					other.GetComponent<EditorPiece>().UnHighlight();
				}
			}
			else if ((bool)other.GetComponent<RotateHandle>())
			{
				other.GetComponent<RotateHandle>().UnHighlight();
			}
			else if ((bool)other.GetComponent<EditorWind>())
			{
				other.GetComponent<EditorWind>().UnHighlight();
			}
			else if ((bool)other.GetComponent<EditPoint>())
			{
				other.GetComponent<EditPoint>().UnHighlight();
			}
			else if ((bool)other.GetComponent<LevelEditorMenu>())
			{
				other.GetComponent<LevelEditorMenu>().UnHighlight();
			}
			if (!(currentActiveObject == other.gameObject))
			{
				return;
			}
			while (hoveringObjects.Count > 0 && (hoveringObjects[hoveringObjects.Count - 1] == null || !hoveringObjects[hoveringObjects.Count - 1].activeSelf))
			{
				hoveringObjects.RemoveAt(hoveringObjects.Count - 1);
			}
			if (hoveringObjects.Count > 0)
			{
				currentActiveObject = hoveringObjects[hoveringObjects.Count - 1];
				if ((bool)currentActiveObject.GetComponent<EditorPiece>())
				{
					currentActiveObject.GetComponent<EditorPiece>().Highlight();
				}
				else if ((bool)currentActiveObject.GetComponent<RotateHandle>())
				{
					currentActiveObject.GetComponent<RotateHandle>().Highlight();
				}
				else if ((bool)currentActiveObject.GetComponent<EditorWind>())
				{
					currentActiveObject.GetComponent<EditorWind>().Highlight();
				}
				else if ((bool)currentActiveObject.GetComponent<EditPoint>())
				{
					currentActiveObject.GetComponent<EditPoint>().Highlight();
				}
				else if ((bool)currentActiveObject.GetComponent<LevelEditorMenu>())
				{
					currentActiveObject.GetComponent<LevelEditorMenu>().Highlight();
				}
			}
			else
			{
				currentActiveObject = null;
				intersectingCurrentActiveObject = false;
			}
		}
		else if (currentActiveObject == other.gameObject)
		{
			intersectingCurrentActiveObject = false;
		}
	}
}
public struct PieceState
{
	public GameObject gameObject;

	public Vector3 posOffset;

	public Quaternion rotOffset;
}
public class EditorMoveTriangle : MonoBehaviour
{
	public Transform startPointObject;

	public Transform startPoint;

	public Transform endPoint;

	public GameObject triangle;

	private Rigidbody triangleRb;

	public Quaternion startRotation;

	public float halfDuration;

	private float timer;

	private int direction = 1;

	public float rotateSpeed;

	public void ResetTime()
	{
		timer = 0f;
		direction = 1;
		triangle.transform.localRotation = startRotation;
		triangle.transform.position = startPoint.position;
	}

	private void Start()
	{
		triangleRb = triangle.GetComponent<Rigidbody>();
	}

	private void Update()
	{
		timer += Time.deltaTime * (float)direction;
		triangleRb.MovePosition(Interpolation.QuadEaseInOut(timer, startPoint.position, endPoint.position - startPoint.position, halfDuration));
		triangleRb.MoveRotation(triangleRb.rotation * Quaternion.AngleAxis(rotateSpeed * Time.deltaTime, Vector3.up));
		if (direction == 1 && timer > halfDuration)
		{
			direction = -1;
		}
		else if (direction == -1 && timer < 0f)
		{
			direction = 1;
		}
	}
}
public class EditorPiece : MonoBehaviour
{
	public GameObject springFloor;

	public GameObject autumnFloor;

	public GameObject winterFloor;

	[Header("Generic")]
	public string displayName;

	public float complexity;

	public PieceSpawner spawner;

	public bool grabbed;

	public bool duplicated;

	[Header("Snap")]
	public bool snapped;

	public SnapPoint[] snapPoints;

	public RotateHandle[] rotateHandles;

	[Header("Placeable")]
	public GameObject placeableObject;

	public GameObject grabPoint;

	public LineRenderer placementLine;

	public Vector3 initialPiecePos;

	public GameObject placementPiece;

	public List<GameObject> placedPieces = new List<GameObject>();

	[Header("Dynamic")]
	public EditorPiece linkedPiece;

	[Header("Fairway")]
	public EditorFairway fairway;

	public Season season;

	[Header("InEditor")]
	private MeshRenderer[] originalObjects;

	[HideInInspector]
	public Material[] mats;

	[HideInInspector]
	public bool showSnapPoints;

	private void Start()
	{
		if (!showSnapPoints)
		{
			TurnOffSnapPointsAndHingeHandles();
		}
		if (base.gameObject.scene.name == "LevelEditor" || base.gameObject.scene.name == "LevelEditorArt")
		{
			if (placeableObject != null)
			{
				if (!duplicated)
				{
					initialPiecePos = placeableObject.transform.localPosition;
					placementLine.startWidth = LevelEditor.instance.lineWidth;
				}
			}
			else
			{
				base.enabled = false;
			}
			originalObjects = GetComponentsInChildren<MeshRenderer>();
			if (mats.Length == 0)
			{
				mats = new Material[originalObjects.Length];
				for (int i = 0; i < originalObjects.Length; i++)
				{
					mats[i] = originalObjects[i].sharedMaterial;
				}
			}
			UnHighlight();
		}
		else
		{
			base.enabled = false;
		}
	}

	private void LateUpdate()
	{
		if (placeableObject != null)
		{
			if (grabbed)
			{
				PlacePiece();
			}
			placementLine.SetPosition(0, grabPoint.transform.position);
			if (spawner != null && !grabbed)
			{
				placementLine.SetPosition(1, grabPoint.transform.position);
			}
			else if (placementPiece != null)
			{
				placementLine.SetPosition(1, placeableObject.transform.position);
				placementLine.endColor = LevelEditor.instance.placementLineSolid;
			}
			else if (LevelEditor.instance != null)
			{
				placementLine.SetPosition(1, base.transform.position + -base.transform.up * LevelEditor.instance.lineMissLength);
				placementLine.endColor = LevelEditor.instance.placementLineFade;
			}
		}
	}

	public void Grab(EditorGrabber grabber, bool activateSnapPoints = true)
	{
		if (spawner != null)
		{
			spawner.Grab(grabber);
			if (linkedPiece != null)
			{
				linkedPiece.transform.SetParent(base.transform);
				linkedPiece.transform.localScale = Vector3.one;
			}
		}
		SetSnapPointActive(activateSnapPoints);
		grabbed = true;
	}

	public void LetGo()
	{
		for (int i = 0; i < snapPoints.Length; i++)
		{
			snapPoints[i].active = false;
		}
		grabbed = false;
		if (spawner != null)
		{
			spawner = null;
			LevelEditor.instance.AddPiece(this);
			if (linkedPiece != null)
			{
				linkedPiece.spawner = null;
				LevelEditor.instance.AddPiece(linkedPiece);
				LevelEditor.instance.AddStep(this, StepType.createLinked);
				LevelEditor.instance.AddStep(linkedPiece, StepType.createLinked);
			}
			else
			{
				LevelEditor.instance.AddStep(this, StepType.create);
			}
		}
	}

	public void PlacePiece()
	{
		bool flag = true;
		RaycastHit[] array = Physics.RaycastAll(grabPoint.transform.position, -base.transform.up, float.PositiveInfinity, LevelEditor.instance.golfingSurfaceLayer, QueryTriggerInteraction.Ignore);
		if (array.Length != 0)
		{
			RaycastHit raycastHit = array[0];
			for (int i = 1; i < array.Length; i++)
			{
				if (!array[i].transform.IsChildOf(base.transform) && (array[i].distance < raycastHit.distance || raycastHit.transform.IsChildOf(base.transform)))
				{
					raycastHit = array[i];
				}
			}
			if (!raycastHit.transform.IsChildOf(base.transform))
			{
				EditorPiece componentInParent = raycastHit.transform.GetComponentInParent<EditorPiece>();
				if (componentInParent != null && componentInParent.spawner == null)
				{
					flag = false;
					placeableObject.transform.position = raycastHit.point;
					placeableObject.transform.rotation = Quaternion.FromToRotation(base.transform.up, raycastHit.normal) * base.transform.rotation;
					if (placementPiece != raycastHit.collider.transform.parent.gameObject)
					{
						if (placementPiece != null && placementPiece.GetComponent<EditorPiece>() != null)
						{
							placementPiece.GetComponent<EditorPiece>().RemovePlacedPiece(base.gameObject);
							if (Player.instance.editorGrabber.selectedObjects.Contains(placementPiece) && Player.instance.editorGrabber.selectedConnectedObjects.Contains(base.gameObject))
							{
								Player.instance.editorGrabber.selectedConnectedObjects.Remove(base.gameObject);
							}
						}
						placementPiece = raycastHit.collider.transform.parent.gameObject;
						if (placementPiece.GetComponent<EditorPiece>() != null)
						{
							placementPiece.GetComponent<EditorPiece>().AddPlacedPiece(base.gameObject);
							if (Player.instance.editorGrabber.selectedObjects.Contains(placementPiece) && !Player.instance.editorGrabber.selectedObjects.Contains(base.gameObject) && !Player.instance.editorGrabber.selectedConnectedObjects.Contains(base.gameObject))
							{
								Player.instance.editorGrabber.selectedConnectedObjects.Add(base.gameObject);
							}
						}
					}
				}
			}
		}
		if (!flag)
		{
			return;
		}
		placeableObject.transform.localPosition = initialPiecePos;
		placeableObject.transform.localRotation = Quaternion.identity;
		placementLine.SetPosition(1, base.transform.position + -base.transform.up * LevelEditor.instance.lineMissLength);
		placementLine.endColor = LevelEditor.instance.placementLineFade;
		if (placementPiece != null && placementPiece.GetComponent<EditorPiece>() != null)
		{
			placementPiece.GetComponent<EditorPiece>().RemovePlacedPiece(base.gameObject);
			if (Player.instance.editorGrabber.selectedObjects.Contains(placementPiece) && Player.instance.editorGrabber.selectedConnectedObjects.Contains(base.gameObject))
			{
				Player.instance.editorGrabber.selectedConnectedObjects.Remove(base.gameObject);
			}
		}
		placementPiece = null;
	}

	public void AddPlacedPiece(GameObject g)
	{
		placedPieces.Add(g);
	}

	public void RemovePlacedPiece(GameObject g)
	{
		placedPieces.Remove(g);
	}

	public void AddPlacementPiece(GameObject g)
	{
		g.GetComponent<EditorPiece>().AddPlacedPiece(base.gameObject);
		placementPiece = g;
	}

	public void RemovePlacementPiece()
	{
		if (placementPiece != null)
		{
			placementPiece.GetComponent<EditorPiece>().RemovePlacedPiece(base.gameObject);
			placementPiece = null;
		}
	}

	public void Highlight()
	{
		if (originalObjects != null)
		{
			for (int i = 0; i < originalObjects.Length; i++)
			{
				originalObjects[i].material = LevelEditor.instance.highlightMat;
			}
		}
	}

	public void UnHighlight()
	{
		if (originalObjects != null)
		{
			for (int i = 0; i < originalObjects.Length; i++)
			{
				originalObjects[i].material = mats[i];
			}
		}
	}

	public void SelectHighlight()
	{
		if (originalObjects != null)
		{
			for (int i = 0; i < originalObjects.Length; i++)
			{
				originalObjects[i].material = LevelEditor.instance.selectHighlightMat;
			}
		}
	}

	public void ConnectedHighlight()
	{
		if (originalObjects != null)
		{
			for (int i = 0; i < originalObjects.Length; i++)
			{
				originalObjects[i].material = LevelEditor.instance.connectedHighlightMat;
			}
		}
	}

	public void CheckAndSetRotationHandles(bool showHandles = true)
	{
		bool[] array = new bool[rotateHandles.Length];
		for (int i = 0; i < snapPoints.Length; i++)
		{
			if (snapPoints[i].snappedPoint != null)
			{
				int num = Array.IndexOf(rotateHandles, snapPoints[i].rotationHandle);
				if (num > -1 && num < array.Length)
				{
					array[num] = true;
				}
			}
		}
		for (int j = 0; j < rotateHandles.Length; j++)
		{
			if (showHandles && array[j] && (rotateHandles[j].oppositeHandle == null || !array[Array.IndexOf(rotateHandles, rotateHandles[j].oppositeHandle)]))
			{
				rotateHandles[j].gameObject.SetActive(value: true);
			}
			else
			{
				rotateHandles[j].gameObject.SetActive(value: false);
			}
		}
	}

	public void SetSnapStatus(SnapPoint localPoint, SnapPoint foreignPoint, bool showHingeHandles)
	{
		bool num = snapped;
		localPoint.snappedPoint = foreignPoint;
		CheckAndSetSnapped();
		foreignPoint.snappedPoint = localPoint;
		foreignPoint.piece.CheckAndSetSnapped();
		if (!num && snapped && LevelEditor.instance.canPlaySnapSFX)
		{
			LevelEditor.instance.canPlaySnapSFX = false;
			Player.instance.editorGrabber.audioSource.PlayOneShot(LevelEditor.instance.snapSFX);
		}
		if (showHingeHandles)
		{
			CheckAndSetRotationHandles();
			foreignPoint.piece.CheckAndSetRotationHandles();
		}
	}

	public void TurnOffSnapPointsAndHingeHandles()
	{
		showSnapPoints = false;
		for (int i = 0; i < snapPoints.Length; i++)
		{
			snapPoints[i].GetComponent<Renderer>().enabled = false;
		}
		for (int j = 0; j < rotateHandles.Length; j++)
		{
			rotateHandles[j].gameObject.SetActive(value: false);
		}
	}

	public void SetSnapPointActive(bool value)
	{
		for (int i = 0; i < snapPoints.Length; i++)
		{
			snapPoints[i].active = value;
		}
	}

	public void UnSnapPoint(SnapPoint point)
	{
		point.snappedPoint = null;
		CheckAndSetRotationHandles();
		CheckAndSetSnapped();
		if (LevelEditor.instance.canPlaySnapSFX)
		{
			LevelEditor.instance.canPlaySnapSFX = false;
			Player.instance.editorGrabber.audioSource.PlayOneShot(LevelEditor.instance.snapSFX);
		}
	}

	public void UnSnapAll()
	{
		for (int i = 0; i < snapPoints.Length; i++)
		{
			if (snapPoints[i].snappedPoint != null)
			{
				snapPoints[i].snappedPoint.piece.UnSnapPoint(snapPoints[i].snappedPoint);
				UnSnapPoint(snapPoints[i]);
			}
		}
		snapped = false;
	}

	public void UnsetSnapPoints()
	{
		for (int i = 0; i < snapPoints.Length; i++)
		{
			UnSnapPoint(snapPoints[i]);
		}
		snapped = false;
	}

	public void UnSnapAllPointsExcludingHandle(RotateHandle handle)
	{
		for (int i = 0; i < snapPoints.Length; i++)
		{
			if (snapPoints[i].snappedPoint != null && snapPoints[i].rotationHandle != handle)
			{
				snapPoints[i].snappedPoint.piece.UnSnapPoint(snapPoints[i].snappedPoint);
				UnSnapPoint(snapPoints[i]);
			}
		}
	}

	public void CheckAndSetSnapped()
	{
		bool flag = false;
		for (int i = 0; i < snapPoints.Length; i++)
		{
			if (snapPoints[i].snappedPoint != null)
			{
				flag = true;
				break;
			}
		}
		snapped = flag;
	}

	public List<GameObject> GetAllConnectedPieces()
	{
		List<GameObject> list = new List<GameObject>();
		for (int i = 0; i < snapPoints.Length; i++)
		{
			if (snapPoints[i].snappedPoint != null)
			{
				list.Add(snapPoints[i].snappedPoint.piece.gameObject);
			}
		}
		for (int j = 0; j < placedPieces.Count; j++)
		{
			list.Add(placedPieces[j]);
		}
		return list;
	}

	public bool HasConnectedPieces()
	{
		bool flag = false;
		if (placedPieces.Count > 0)
		{
			flag = true;
		}
		if (!flag)
		{
			for (int i = 0; i < snapPoints.Length; i++)
			{
				if (snapPoints[i].snappedPoint != null)
				{
					flag = true;
					break;
				}
			}
		}
		return flag;
	}

	public void ChangeSeason(Season newSeason)
	{
		if (springFloor != null && autumnFloor != null && winterFloor != null)
		{
			switch (newSeason)
			{
			case Season.spring:
				springFloor.SetActive(value: true);
				autumnFloor.SetActive(value: false);
				winterFloor.SetActive(value: false);
				break;
			case Season.autumn:
				springFloor.SetActive(value: false);
				autumnFloor.SetActive(value: true);
				winterFloor.SetActive(value: false);
				break;
			case Season.winter:
				springFloor.SetActive(value: false);
				autumnFloor.SetActive(value: false);
				winterFloor.SetActive(value: true);
				break;
			default:
				springFloor.SetActive(value: true);
				autumnFloor.SetActive(value: false);
				winterFloor.SetActive(value: false);
				break;
			}
		}
	}
}
public enum Season
{
	none,
	spring,
	autumn,
	winter
}
public class EditorPlaceable : MonoBehaviour
{
	public GameObject piece;

	public GameObject grabPoint;
}
public class EditorWind : MonoBehaviour
{
	public Wind wind;

	public GameObject visuals;

	public TextMeshPro windSpeedText;

	public int maxSpeed;

	public int currentSpeed;

	public bool randomWind;

	public GameObject randomWindCheckMark;

	public TextMeshPro windSpeedTitleText;

	public Renderer windArrow;

	public Collider arrowCollider;

	private Material windArrowMat;

	public Renderer windSphere;

	public Collider sphereCollider;

	private Material windSphereMat;

	private void Start()
	{
		if (windArrow != null)
		{
			windArrowMat = windArrow.material;
		}
		if (windSphere != null)
		{
			windSphereMat = windSphere.material;
		}
	}

	public void Reset()
	{
		wind.gameObject.transform.rotation = Quaternion.identity;
		wind.windSpeed = 0f;
		wind.direction = Vector3.forward;
		SetSpeed(0f);
		windSpeedTitleText.text = LocalizationManager.GetTranslation("Wind Speed:");
		SwitchToWindArrow();
	}

	public void ToggleRandomWind()
	{
		randomWind = !randomWind;
		if (randomWind)
		{
			windSpeedTitleText.text = LocalizationManager.GetTranslation("Max Wind Speed") + ":";
			SwitchToWindSphere();
			randomWindCheckMark.SetActive(value: true);
			wind.SetWindSpeed(Vector3.zero, LevelEditor.instance.levelParent);
		}
		else
		{
			windSpeedTitleText.text = LocalizationManager.GetTranslation("Wind Speed:");
			if (currentSpeed != 0)
			{
				SwitchToWindArrow();
			}
			randomWindCheckMark.SetActive(value: false);
			wind.SetWindSpeed(LevelEditor.instance.currentLevel.windVector, LevelEditor.instance.levelParent);
		}
		LevelEditor.instance.randomWind = randomWind;
	}

	public void SwitchToWindSphere()
	{
		windArrow.gameObject.SetActive(value: false);
		windSphere.gameObject.SetActive(value: true);
		arrowCollider.enabled = false;
		sphereCollider.enabled = true;
	}

	public void SwitchToWindArrow()
	{
		windArrow.gameObject.SetActive(value: true);
		windSphere.gameObject.SetActive(value: false);
		arrowCollider.enabled = true;
		sphereCollider.enabled = false;
	}

	public void SetSpeed(float speed)
	{
		int num = (int)speed;
		windSpeedText.text = num + " kph";
		currentSpeed = num;
	}

	public void LoadWindSpeed(Vector3 speed)
	{
		int num;
		if (speed.x > 100f && speed.y > 100f)
		{
			if (!randomWind)
			{
				ToggleRandomWind();
			}
			num = (int)speed.z;
		}
		else
		{
			if (randomWind)
			{
				ToggleRandomWind();
			}
			num = (int)speed.magnitude;
		}
		SetSpeed(num);
	}

	public void IncreaseWindSpeed(int x)
	{
		int num = int.Parse(windSpeedText.text.Split(' ')[0]);
		int num2 = num + x;
		if (num2 > maxSpeed)
		{
			num2 = maxSpeed;
		}
		if (num2 < 0)
		{
			num2 = 0;
		}
		windSpeedText.text = num2 + " kph";
		currentSpeed = num2;
		LevelEditor.instance.levelEditorMenu.SetWindVector(randomWind);
		LevelEditor.instance.UpdateFlagDirections();
		if (!randomWind)
		{
			if (num == 0)
			{
				if (num2 > 0)
				{
					SwitchToWindArrow();
				}
			}
			else if (num2 == 0)
			{
				SwitchToWindSphere();
			}
			wind.SetWindSpeed(LevelEditor.instance.currentLevel.windVector, LevelEditor.instance.levelParent);
		}
		else
		{
			wind.SetWindSpeed(Vector3.zero, LevelEditor.instance.levelParent);
		}
	}

	public void CloseControls()
	{
		LevelEditor.instance.levelEditorMenu.EndSetWind();
	}

	public void ShowWindControl()
	{
		if (randomWind || currentSpeed == 0)
		{
			SwitchToWindSphere();
		}
		else
		{
			SwitchToWindArrow();
		}
		visuals.SetActive(value: true);
	}

	public void HideWindControls()
	{
		arrowCollider.enabled = false;
		sphereCollider.enabled = false;
		visuals.SetActive(value: false);
	}

	public void Highlight()
	{
		windSphere.material = LevelEditor.instance.highlightMat;
		windArrow.material = LevelEditor.instance.highlightMat;
	}

	public void UnHighlight()
	{
		windSphere.material = windSphereMat;
		windArrow.material = windArrowMat;
	}
}
public class EditPoint : MonoBehaviour
{
	public EditorFairway ef;

	public EditorPiece piece;

	public Vector3 scale;

	public void OpenDetailMenu()
	{
		PieceDetails details = default(PieceDetails);
		details.name = base.gameObject.name;
		details.piece = this;
		details.fi = new FieldInfo[1] { typeof(EditPoint).GetField("scale") };
		LevelEditor.instance.detailMenu.OpenMenu(details);
	}

	public void Grab()
	{
		ApplyConstraintsAndUpdateDynamics(base.transform.position);
	}

	public void Highlight()
	{
		GetComponent<Renderer>().material = LevelEditor.instance.rotateHighlightMat;
		Player.instance.currentControllerInput.Vibrate();
	}

	public void UnHighlight()
	{
		GetComponent<Renderer>().material = LevelEditor.instance.rotateOriginalMat;
	}

	public void ApplyConstraintsAndUpdateDynamics(Vector3 position)
	{
		if (piece != null)
		{
			if ((bool)piece.GetComponent<EditorCannon>())
			{
				piece.GetComponent<EditorCannon>().ApplyConstraints(position);
				piece.GetComponent<EditorCannon>().UpdateDynamicParts();
			}
			else if ((bool)piece.GetComponent<EditorFan>())
			{
				piece.GetComponent<EditorFan>().ApplyConstraints(position);
				piece.GetComponent<EditorFan>().UpdateDynamicParts();
			}
		}
	}

	public void UpdateDynamicParts()
	{
		if ((bool)piece.GetComponent<EditorCannon>())
		{
			piece.GetComponent<EditorCannon>().UpdateDynamicParts();
		}
		else if ((bool)piece.GetComponent<EditorFan>())
		{
			piece.GetComponent<EditorFan>().UpdateDynamicParts();
		}
	}
}
public class Grabbable : MonoBehaviour
{
	public EditorPiece piece;

	public bool active;

	public void ApplyConstraintsAndUpdateDynamics(Vector3 position)
	{
		if ((bool)piece.GetComponent<EditorCannon>())
		{
			piece.GetComponent<EditorCannon>().ApplyConstraints(position);
			piece.GetComponent<EditorCannon>().UpdateDynamicParts();
		}
		else if ((bool)piece.GetComponent<EditorFan>())
		{
			piece.GetComponent<EditorFan>().ApplyConstraints(position);
			piece.GetComponent<EditorFan>().UpdateDynamicParts();
		}
	}

	public void UpdateDynamicParts()
	{
		if ((bool)piece.GetComponent<EditorCannon>())
		{
			piece.GetComponent<EditorCannon>().UpdateDynamicParts();
		}
		else if ((bool)piece.GetComponent<EditorFan>())
		{
			piece.GetComponent<EditorFan>().UpdateDynamicParts();
		}
	}
}
public class HoleStart : MonoBehaviour
{
	public Transform spawnPoint;
}
public static class kBufferUtil
{
	public static bool ReadBool(ref byte[] buffer, ref int bufferIndex)
	{
		bool result = BitConverter.ToBoolean(buffer, bufferIndex);
		bufferIndex++;
		return result;
	}

	public static byte ReadByte(ref byte[] buffer, ref int bufferIndex)
	{
		byte result = buffer[bufferIndex];
		bufferIndex++;
		return result;
	}

	public static sbyte ReadSByte(ref byte[] buffer, ref int bufferIndex)
	{
		sbyte result = (sbyte)buffer[bufferIndex];
		bufferIndex++;
		return result;
	}

	public static char ReadChar(ref byte[] buffer, ref int bufferIndex)
	{
		byte result = buffer[bufferIndex];
		bufferIndex += 2;
		return (char)result;
	}

	public static short ReadS16(ref byte[] buffer, ref int bufferIndex)
	{
		short result = BitConverter.ToInt16(buffer, bufferIndex);
		bufferIndex += 2;
		return result;
	}

	public static ushort ReadU16(ref byte[] buffer, ref int bufferIndex)
	{
		ushort result = BitConverter.ToUInt16(buffer, bufferIndex);
		bufferIndex += 2;
		return result;
	}

	public static int ReadS32(ref byte[] buffer, ref int bufferIndex)
	{
		int result = BitConverter.ToInt32(buffer, bufferIndex);
		bufferIndex += 4;
		return result;
	}

	public static uint ReadU32(ref byte[] buffer, ref int bufferIndex)
	{
		uint result = BitConverter.ToUInt32(buffer, bufferIndex);
		bufferIndex += 4;
		return result;
	}

	public static long ReadS64(ref byte[] buffer, ref int bufferIndex)
	{
		long result = BitConverter.ToInt64(buffer, bufferIndex);
		bufferIndex += 8;
		return result;
	}

	public static ulong ReadU64(ref byte[] buffer, ref int bufferIndex)
	{
		ulong result = BitConverter.ToUInt64(buffer, bufferIndex);
		bufferIndex += 8;
		return result;
	}

	public static string ReadString(ref byte[] buffer, ref int bufferIndex, int stringLength)
	{
		string @string = Encoding.Unicode.GetString(buffer, bufferIndex, stringLength);
		bufferIndex += stringLength;
		return @string;
	}

	public static Vector3 ReadVector3(ref byte[] buffer, ref int bufferIndex)
	{
		Vector3 result = default(Vector3);
		result.x = BitConverter.ToSingle(buffer, bufferIndex);
		result.y = BitConverter.ToSingle(buffer, bufferIndex + 4);
		result.z = BitConverter.ToSingle(buffer, bufferIndex + 8);
		bufferIndex += 12;
		return result;
	}

	public static Quaternion ReadQuaternion(ref byte[] buffer, ref int bufferIndex)
	{
		Quaternion result = default(Quaternion);
		result.x = BitConverter.ToSingle(buffer, bufferIndex);
		result.y = BitConverter.ToSingle(buffer, bufferIndex + 4);
		result.z = BitConverter.ToSingle(buffer, bufferIndex + 8);
		result.w = BitConverter.ToSingle(buffer, bufferIndex + 12);
		bufferIndex += 16;
		return result;
	}

	public static LevelPiece ReadLevelPiece(ref byte[] buffer, ref int bufferIndex)
	{
		LevelPiece result = default(LevelPiece);
		result.nameHash = ReadS32(ref buffer, ref bufferIndex);
		result.position = ReadVector3(ref buffer, ref bufferIndex);
		result.rotation = ReadQuaternion(ref buffer, ref bufferIndex);
		result.scale = ReadVector3(ref buffer, ref bufferIndex);
		return result;
	}

	public static float ReadFloat(ref byte[] buffer, ref int bufferIndex)
	{
		float result = BitConverter.ToSingle(buffer, bufferIndex);
		bufferIndex += 4;
		return result;
	}

	public static DynamicData ReadDynamicData(ref byte[] buffer, ref int bufferIndex)
	{
		DynamicData result = default(DynamicData);
		result.pieceIndex = ReadS16(ref buffer, ref bufferIndex);
		result.grabPosition = ReadVector3(ref buffer, ref bufferIndex);
		result.grabRotation = ReadQuaternion(ref buffer, ref bufferIndex);
		result.linkedPieceIndex = ReadS16(ref buffer, ref bufferIndex);
		return result;
	}

	public static DynamicDataCL1 ReadCL1DynamicData(ref byte[] buffer, ref int bufferIndex)
	{
		DynamicDataCL1 result = default(DynamicDataCL1);
		result.pieceIndex = ReadS16(ref buffer, ref bufferIndex);
		result.grabPosition = ReadVector3(ref buffer, ref bufferIndex);
		result.grabRotation = ReadQuaternion(ref buffer, ref bufferIndex);
		result.linkedPieceIndex = ReadS16(ref buffer, ref bufferIndex);
		return result;
	}

	public static PlaceableData ReadPlaceableData(ref byte[] buffer, ref int bufferIndex)
	{
		PlaceableData result = default(PlaceableData);
		result.pieceIndex = ReadS16(ref buffer, ref bufferIndex);
		result.piecePosition = ReadVector3(ref buffer, ref bufferIndex);
		result.pieceRotation = ReadQuaternion(ref buffer, ref bufferIndex);
		result.placementPieceIndex = ReadS16(ref buffer, ref bufferIndex);
		return result;
	}

	public static SnapPieceData ReadSnapPieceData(ref byte[] buffer, ref int bufferIndex)
	{
		SnapPieceData result = default(SnapPieceData);
		result.pieceIndex = ReadS16(ref buffer, ref bufferIndex);
		int num = ReadByte(ref buffer, ref bufferIndex);
		result.snapData = new SnapData[num];
		for (int i = 0; i < num; i++)
		{
			result.snapData[i].pieceIndex = ReadS16(ref buffer, ref bufferIndex);
			result.snapData[i].snapPointIndex = ReadSByte(ref buffer, ref bufferIndex);
		}
		return result;
	}

	public static SnapPieceData ReadCL1SnapPieceData(ref byte[] buffer, ref int bufferIndex)
	{
		SnapPieceData result = default(SnapPieceData);
		result.pieceIndex = ReadS16(ref buffer, ref bufferIndex);
		int num = ReadByte(ref buffer, ref bufferIndex);
		result.snapData = new SnapData[num];
		for (int i = 0; i < num; i++)
		{
			result.snapData[i].pieceIndex = ReadS16(ref buffer, ref bufferIndex);
			result.snapData[i].snapPointIndex = ReadSByte(ref buffer, ref bufferIndex);
		}
		return result;
	}

	public static LevelPieceCL1 ReadCL1LevelPiece(ref byte[] buffer, ref int bufferIndex)
	{
		LevelPieceCL1 result = default(LevelPieceCL1);
		result.nameHash = ReadS32(ref buffer, ref bufferIndex);
		result.position = ReadVector3(ref buffer, ref bufferIndex);
		result.rotation = ReadQuaternion(ref buffer, ref bufferIndex);
		result.scale = ReadVector3(ref buffer, ref bufferIndex);
		result.season = (Season)buffer[bufferIndex];
		bufferIndex++;
		return result;
	}
}
public class LevelButton : PointerButton
{
	public LevelEditorMenu levelMenu;

	public CustomLevel levelData;

	public string path;

	public Image background;

	public Text levelName;

	public Text creatorName;

	public RawImage levelScreenshot;

	public byte[] screenshotBytes;

	public Image finalizeIcon;

	public Image uploadedIcon;

	public Color highLightColor = Color.gray;

	public Color unHighLightColor = Color.white;

	public override void Highlight()
	{
		base.Highlight();
		background.color = highLightColor;
	}

	public override void UnHighlight()
	{
		background.color = unHighLightColor;
	}
}
public class LevelEditor : MonoBehaviour
{
	public static LevelEditor instance;

	public AudioSource audioSource;

	[HideInInspector]
	public List<GameObject> pieces = new List<GameObject>();

	public Transform playerSpawnLocation;

	public GameObject buildingEnvironment;

	public PieceDetailMenu detailMenu;

	public LevelEditorMenu levelEditorMenu;

	public Transform levelSpawnLocation;

	public EditorWind editorWind;

	public Light directionalLight;

	public Camera minimapCamera;

	public LevelEditorOBTriggers levelEditorOB;

	[Header("Editor Details")]
	public float pieceScale = 0.04f;

	public float editScale = 1f;

	public float minEditScale = 0.25f;

	public float maxEditScale = 5f;

	[HideInInspector]
	public Vector3 pieceScaleV3;

	public Vector3 levelPreviewScale;

	public Vector3 levelEditStartPos;

	public Transform groupSelectTransform;

	public bool canEdit = true;

	public bool editingOtherCreator;

	public float complexityLimit = 300f;

	public float currentComplexity;

	public bool randomWind;

	[Header("Current Level")]
	public CustomLevel currentLevel;

	public Transform levelParent;

	public int pieceCount;

	public bool previewing;

	public GameObject ballSpawner;

	public bool finalizing;

	public int currentStrokeCount;

	public byte[] currentScreenshotBytes;

	public bool screenshotSaved;

	[Header("Save System")]
	public bool unsavedChanges;

	private uint saveFileVersionNumber = 200u;

	public static int bytesPerPiece = 44;

	public static int bytesPerPlaceableData = 32;

	public static int bytesPerDynamicData = 32;

	public static int bytesPerSnapPiece = 3;

	public static int bytesPerSnapPoint = 3;

	[Header("Misc")]
	public Material highlightMat;

	public Material selectHighlightMat;

	public Material connectedHighlightMat;

	public Material rotateOriginalMat;

	public Material rotateHighlightMat;

	public AudioClip snapSFX;

	public bool canPlaySnapSFX;

	[Header("Placeable Details")]
	public LayerMask golfingSurfaceLayer;

	public Color placementLineSolid;

	public Color placementLineFade;

	public float lineWidth = 0.008f;

	public float lineMissLength = 0.5f;

	[Header("Undo/Redo")]
	public int stepIndex;

	public List<EditorStep> editorSteps = new List<EditorStep>();

	public List<GameObject> stepPieces = new List<GameObject>();

	public int lastSavedStepIndex;

	[Header("Ball Placement")]
	public LayerMask ballPlacementLayerMask;

	public Color ballWarpGoodColor;

	public Color ballWarpBadColor;

	private int ballLineNumSteps = 50;

	private float warpLineLength = 2f;

	private float ballPlacementTrajectoryForce = 15f;

	private int endNumSteps;

	private Vector3 manualWarpGravity = new Vector3(0f, -8f, 0f);

	private RaycastHit trajectoryHit;

	private bool validBallPosition;

	private LineRenderer ballWarpIndicator;

	public GameObject ghostBallPrefab;

	private GameObject ghostBall;

	[Header("FPS Checker")]
	public float timeUnderFrameRate;

	private float lowFPSThreshold = 80f;

	public float lowFPSThresholdVive = 80f;

	public float lowFPSThresholdQuest = 60f;

	public float lowFPSThresholdPico = 60f;

	public float timeToShowLowFPSWarning = 3f;

	public int framesToAverage = 10;

	private float[] pastFrameTimes;

	private int frameTimeIndex;

	private float accumulatedFrameTime;

	private void Awake()
	{
		instance = this;
		canEdit = false;
		pieceScaleV3 = new Vector3(pieceScale, pieceScale, pieceScale);
		levelParent.localScale = pieceScaleV3;
		levelEditStartPos = levelParent.position;
		editorSteps.Add(default(EditorStep));
		currentLevel = default(CustomLevel);
		UpdateUndoRedoButtons();
		UpdateSaveStatus(saved: false);
		unsavedChanges = false;
		screenshotSaved = true;
		ResetFPSChecker();
	}

	public static void InitializeCustomLevelDetails()
	{
		ushort num = 12;
		ushort num2 = 16;
		ushort num3 = 12;
		bytesPerPiece = 4 + num + num2 + num3;
		bytesPerPlaceableData = 32;
	}

	private void Start()
	{
		StartCoroutine(DelayStart());
		ghostBall = UnityEngine.Object.Instantiate(ghostBallPrefab);
		ghostBall.SetActive(value: false);
	}

	private IEnumerator DelayStart()
	{
		yield return null;
		Player.instance.currentController.snapping = true;
		ballWarpIndicator = Player.instance.autoWarp.lineRenderer;
		GameManager.instance.player.SwitchToEditorTools();
		if (GameManager.instance.controllerType == ControllerType.Quest)
		{
			lowFPSThreshold = lowFPSThresholdQuest;
		}
		else if (GameManager.instance.controllerType == ControllerType.Pico)
		{
			lowFPSThreshold = lowFPSThresholdQuest;
		}
		else
		{
			lowFPSThreshold = lowFPSThresholdVive;
		}
	}

	private void Update()
	{
		if (levelEditorMenu.levelLoaded && !levelEditorMenu.lowFPSWarningShown)
		{
			EvaluateFPS();
		}
		canPlaySnapSFX = true;
		if (instance.previewing && !instance.finalizing)
		{
			if (Player.instance.currentControllerInput.bButton.down)
			{
				if (Player.instance.currentControllerInput.touchpadStatus.upTouchpadButtonStatus.wasReleased)
				{
					ghostBall.SetActive(value: false);
					ballWarpIndicator.enabled = false;
					if (validBallPosition)
					{
						Golfball golfball = GameManager.instance.golfball;
						golfball.DestroyTrailRenderer();
						golfball.rb.velocity = Vector3.zero;
						golfball.rb.angularVelocity = Vector3.zero;
						Vector3 position = (golfball.previousPosition = new Vector3(ghostBall.transform.position.x, ghostBall.transform.position.y + 0.03f, ghostBall.transform.position.z));
						golfball.transform.position = position;
					}
				}
				if (Player.instance.currentControllerInput.touchpadStatus.upTouchpadButtonStatus.down)
				{
					ghostBall.SetActive(value: true);
					ballWarpIndicator.enabled = true;
					Color color = GameManager.instance.golfball.ballRenderer.material.color;
					color.a = 0.4f;
					ghostBall.GetComponent<MeshRenderer>().material.color = color;
					DoBallPlacementTrajectory();
				}
			}
			else if (ghostBall.activeSelf)
			{
				ghostBall.SetActive(value: false);
			}
		}
		else if (ghostBall.activeSelf)
		{
			ghostBall.SetActive(value: false);
		}
	}

	public void ResetFPSChecker()
	{
		pastFrameTimes = new float[framesToAverage];
		accumulatedFrameTime = 0f;
		timeUnderFrameRate = 0f;
	}

	public void EvaluateFPS()
	{
		float deltaTime = Time.deltaTime;
		accumulatedFrameTime -= pastFrameTimes[frameTimeIndex];
		pastFrameTimes[frameTimeIndex++] = deltaTime;
		accumulatedFrameTime += deltaTime;
		if (frameTimeIndex == pastFrameTimes.Length)
		{
			frameTimeIndex = 0;
		}
		if (1f / (accumulatedFrameTime / (float)pastFrameTimes.Length) < lowFPSThreshold)
		{
			timeUnderFrameRate += deltaTime;
			if (timeUnderFrameRate > timeToShowLowFPSWarning)
			{
				if (!previewing)
				{
					levelEditorMenu.EditingUnderFrameRate();
				}
				else if (finalizing)
				{
					levelEditorMenu.FinalizingUnderFramRate();
				}
				else
				{
					levelEditorMenu.PreviewingUnderFrameRate();
				}
				timeUnderFrameRate = 0f;
			}
		}
		else
		{
			timeUnderFrameRate -= Time.deltaTime;
			if (timeUnderFrameRate < 0f)
			{
				timeUnderFrameRate = 0f;
			}
		}
	}

	public void DoBallPlacementTrajectory()
	{
		ballWarpIndicator.positionCount = ballLineNumSteps;
		float num = warpLineLength / (float)ballLineNumSteps;
		Vector3 position = Player.instance.currentController.transform.position;
		Vector3 vector = Player.instance.currentController.transform.forward * ballPlacementTrajectoryForce;
		Vector3 position2 = Vector3.zero;
		bool flag = false;
		endNumSteps = ballLineNumSteps;
		for (int i = 0; i < ballLineNumSteps; i++)
		{
			ballWarpIndicator.SetPosition(i, position);
			vector += manualWarpGravity * num;
			Vector3 vector2 = vector * num;
			if (Physics.Raycast(position, vector, out trajectoryHit, vector2.magnitude, ballPlacementLayerMask))
			{
				if (Vector3.Project(trajectoryHit.normal, Vector3.up).y > 0f)
				{
					position2 = trajectoryHit.point;
					flag = true;
					ballWarpIndicator.SetPosition(i, position2);
					endNumSteps = i + 1;
					break;
				}
			}
			else if (Physics.Raycast(position + vector2, -vector, out trajectoryHit, vector2.magnitude, ballPlacementLayerMask) && Vector3.Project(trajectoryHit.normal, Vector3.up).y > 0f)
			{
				position2 = trajectoryHit.point;
				flag = true;
				ballWarpIndicator.SetPosition(i, position2);
				endNumSteps = i + 1;
				break;
			}
			position += vector * num;
			if (i == ballLineNumSteps - 1)
			{
				position2 = position;
			}
		}
		ballWarpIndicator.positionCount = endNumSteps;
		if (flag)
		{
			ghostBall.transform.position = new Vector3(position2.x, position2.y + 0.03f, position2.z);
			validBallPosition = true;
			ballWarpIndicator.material.color = ballWarpGoodColor;
		}
		else
		{
			validBallPosition = false;
			ballWarpIndicator.material.color = ballWarpBadColor;
		}
	}

	public GameObject DuplicatePiece(GameObject go, Vector3 offset)
	{
		GameObject obj = UnityEngine.Object.Instantiate(go, go.transform.position + offset, go.transform.rotation);
		obj.name = go.name;
		EditorPiece component = obj.GetComponent<EditorPiece>();
		component.UnsetSnapPoints();
		component.SetSnapPointActive(value: false);
		component.grabbed = false;
		component.spawner = null;
		component.placedPieces.Clear();
		component.enabled = true;
		component.mats = go.GetComponent<EditorPiece>().mats;
		AddPiece(component);
		obj.transform.localScale = go.transform.localScale;
		if (component.placeableObject != null)
		{
			component.initialPiecePos = go.GetComponent<EditorPiece>().initialPiecePos;
			component.placementPiece = null;
		}
		component.duplicated = true;
		return obj;
	}

	public void TogglePreview()
	{
		if (previewing)
		{
			GoToEditMode();
			Player.instance.SwitchToEditorTools();
			buildingEnvironment.SetActive(value: true);
			previewing = false;
		}
		else
		{
			GoToPreview();
		}
	}

	public Transform GetStartPoint()
	{
		Transform result = null;
		for (int i = 0; i < pieces.Count; i++)
		{
			if ((bool)pieces[i].GetComponent<Teebox>())
			{
				result = pieces[i].GetComponent<Teebox>().teeLocation;
			}
		}
		return result;
	}

	public bool CheckCanPreview()
	{
		bool flag = false;
		for (int i = 0; i < pieces.Count; i++)
		{
			if ((bool)pieces[i].GetComponent<Teebox>())
			{
				flag = true;
				break;
			}
		}
		if (!flag)
		{
			Notification.instance.AddNotification("Need a tee in level to preview", 0f, closeButton: true);
		}
		return flag;
	}

	public bool CheckCanFinalize()
	{
		bool result = false;
		bool flag = false;
		bool flag2 = false;
		for (int i = 0; i < pieces.Count; i++)
		{
			if ((bool)pieces[i].GetComponent<Teebox>())
			{
				flag = true;
			}
			if ((bool)pieces[i].GetComponentInChildren<Golfhole>())
			{
				flag2 = true;
			}
			if (flag && flag2)
			{
				break;
			}
		}
		if (flag && flag2)
		{
			if (currentScreenshotBytes != null && currentScreenshotBytes.Length != 0)
			{
				result = true;
			}
			else
			{
				Notification.instance.AddNotification("Need to take a screenshot to finalize", 0f, closeButton: true);
			}
		}
		else
		{
			Notification.instance.AddNotification("Need a tee and a hole in level to finalize", 0f, closeButton: true);
		}
		return result;
	}

	public void GoToPreview()
	{
		ResetLevelPivot();
		Transform transform = null;
		for (int i = 0; i < pieces.Count; i++)
		{
			if ((bool)pieces[i].GetComponent<Teebox>())
			{
				transform = pieces[i].GetComponent<Teebox>().teeLocation;
				break;
			}
		}
		if (!(transform != null))
		{
			return;
		}
		Player.instance.editorGrabber.ClearSelectedObjects();
		for (int j = 0; j < pieces.Count; j++)
		{
			EditorPiece component = pieces[j].GetComponent<EditorPiece>();
			component.UnHighlight();
			if (component.grabPoint != null)
			{
				component.grabPoint.GetComponent<Renderer>().enabled = false;
				component.placementLine.enabled = false;
			}
			if (component.snapPoints.Length != 0)
			{
				for (int k = 0; k < component.snapPoints.Length; k++)
				{
					component.snapPoints[k].GetComponent<Renderer>().enabled = false;
					component.snapPoints[k].GetComponent<Collider>().enabled = false;
				}
			}
			if (component.rotateHandles.Length != 0)
			{
				for (int l = 0; l < component.rotateHandles.Length; l++)
				{
					component.rotateHandles[l].GetComponent<Renderer>().enabled = false;
					component.rotateHandles[l].GetComponent<Collider>().enabled = false;
				}
			}
			EditPoint[] componentsInChildren = pieces[j].GetComponentsInChildren<EditPoint>();
			if (componentsInChildren.Length != 0)
			{
				for (int m = 0; m < componentsInChildren.Length; m++)
				{
					if ((bool)componentsInChildren[m].GetComponent<Renderer>())
					{
						componentsInChildren[m].GetComponent<Renderer>().enabled = false;
					}
					if ((bool)componentsInChildren[m].GetComponent<Collider>())
					{
						componentsInChildren[m].GetComponent<Collider>().enabled = false;
					}
				}
			}
			if (component.GetComponent<EditorMoveTriangle>() != null)
			{
				component.GetComponent<EditorMoveTriangle>().ResetTime();
				if (component.GetComponent<EditorMoveTriangle>().startPoint.GetComponent<MeshRenderer>() != null)
				{
					component.GetComponent<EditorMoveTriangle>().startPoint.GetComponent<MeshRenderer>().enabled = false;
				}
			}
			else if (component.GetComponent<EditorCannon>() != null)
			{
				component.GetComponent<EditorCannon>().trajectoryLineRenderer.enabled = false;
				component.GetComponent<EditorCannon>().ResetTime();
			}
			else if (component.GetComponent<EditorFan>() != null)
			{
				component.GetComponent<EditorFan>().fan.fanAudioSource.Play();
				component.GetComponent<EditorFan>().ResetTime();
			}
			if (component.GetComponent<EditorFairway>() == null)
			{
				component.GetComponent<Collider>().enabled = false;
			}
			else
			{
				component.GetComponent<EditorFairway>().GenerateCollision();
			}
			if (component.GetComponentInChildren<SlopeLines>() != null)
			{
				component.GetComponentInChildren<SlopeLines>().SetLines();
			}
			if (component.GetComponentInChildren<UFO>() != null)
			{
				component.GetComponentInChildren<UFO>().Reset();
				component.GetComponentInChildren<UFO>().active = true;
			}
			Golfhole componentInChildren = component.GetComponentInChildren<Golfhole>();
			if (componentInChildren != null)
			{
				componentInChildren.DelayToggleBeacon();
			}
		}
		float num = levelPreviewScale.magnitude / levelParent.localScale.magnitude;
		levelEditStartPos = levelParent.position;
		Vector3 vector = (transform.position - levelParent.position) * num;
		Vector3 vector2 = Player.instance.transform.position - levelParent.position;
		Vector3 position = levelParent.position + vector2 - vector;
		levelParent.position = position;
		levelParent.localScale = levelPreviewScale;
		ballSpawner = UnityEngine.Object.Instantiate(GameManager.instance.golfBallSpawnerPrefab);
		ballSpawner.transform.position = transform.position + new Vector3(0f, 0.05f, 0f);
		ScoreManager.instance.ResetStrokes();
		ScoreManager.instance.ballScored = false;
		Player.instance.SwitchToClub();
		Player.instance.clubSwitcher.ResetClubVelocities();
		buildingEnvironment.SetActive(value: false);
		previewing = true;
		levelEditorOB.SetOB();
		levelEditorMenu.EndSetWind();
		editorWind.wind.SetWindSpeed(currentLevel.windVector, levelParent);
		editorWind.wind.windPFX.gameObject.SetActive(value: true);
		editorWind.transform.localScale = Vector3.one;
		Player.instance.RotateHeadToFacePosition(transform);
		Player.instance.clubSwitcher.usableClubs = currentLevel.allowedClubs;
		Player.instance.autoWarp.switchClubsOnWarp = GameManager.instance.GetClubChangeOnWarp();
		if ((currentLevel.allowedClubs & GolfClubType.Driver) == GolfClubType.Driver)
		{
			Player.instance.clubSwitcher.SwitchToClubType(ClubType.Driver);
		}
		else if ((currentLevel.allowedClubs & GolfClubType.Iron) == GolfClubType.Iron)
		{
			Player.instance.clubSwitcher.SwitchToClubType(ClubType.Iron);
		}
		else if ((currentLevel.allowedClubs & GolfClubType.Putter) == GolfClubType.Putter)
		{
			Player.instance.clubSwitcher.SwitchToClubType(ClubType.Putter);
		}
		levelEditorMenu.levelEditorTutorialManager.SetTutorialStep(EditorTutorialStep.PreviewStarted);
	}

	public void GoToEditMode()
	{
		levelParent.GetComponent<LevelEditorOBTriggers>().DestroyOB();
		for (int i = 0; i < pieces.Count; i++)
		{
			pieces[i].GetComponent<Collider>().enabled = true;
			EditorPiece component = pieces[i].GetComponent<EditorPiece>();
			if (component.grabPoint != null)
			{
				component.grabPoint.GetComponent<Renderer>().enabled = true;
				component.placementLine.enabled = true;
			}
			if (component.snapPoints.Length != 0)
			{
				for (int j = 0; j < component.snapPoints.Length; j++)
				{
					component.snapPoints[j].GetComponent<Renderer>().enabled = true;
					component.snapPoints[j].GetComponent<Collider>().enabled = true;
				}
			}
			if (component.rotateHandles.Length != 0)
			{
				for (int k = 0; k < component.rotateHandles.Length; k++)
				{
					component.rotateHandles[k].GetComponent<Renderer>().enabled = true;
					component.rotateHandles[k].GetComponent<Collider>().enabled = true;
				}
			}
			EditPoint[] componentsInChildren = pieces[i].GetComponentsInChildren<EditPoint>();
			if (componentsInChildren.Length != 0)
			{
				for (int l = 0; l < componentsInChildren.Length; l++)
				{
					if ((bool)componentsInChildren[l].GetComponent<Renderer>())
					{
						componentsInChildren[l].GetComponent<Renderer>().enabled = true;
					}
					if ((bool)componentsInChildren[l].GetComponent<Collider>())
					{
						componentsInChildren[l].GetComponent<Collider>().enabled = true;
					}
				}
			}
			if (component.GetComponent<EditorMoveTriangle>() != null)
			{
				component.GetComponent<EditorMoveTriangle>().startPoint.GetComponent<MeshRenderer>().enabled = true;
			}
			else if (component.GetComponent<EditorCannon>() != null)
			{
				component.GetComponent<EditorCannon>().trajectoryLineRenderer.enabled = true;
			}
			else if (component.GetComponent<EditorFan>() != null)
			{
				component.GetComponent<EditorFan>().fan.fanAudioSource.Stop();
			}
			if (component.GetComponentInChildren<SlopeLines>() != null)
			{
				component.GetComponentInChildren<SlopeLines>().DisableLines();
			}
			if (component.GetComponentInChildren<UFO>() != null)
			{
				component.GetComponentInChildren<UFO>().Reset();
				component.GetComponentInChildren<UFO>().active = false;
			}
			Golfhole componentInChildren = component.GetComponentInChildren<Golfhole>();
			if (componentInChildren != null)
			{
				componentInChildren.ResetHole();
				componentInChildren.TurnOffBeacon();
			}
		}
		levelParent.position = levelEditStartPos;
		levelParent.localScale = pieceScaleV3 * editScale;
		UnityEngine.Object.Destroy(GameManager.instance.unparentedTrails);
		UnityEngine.Object.Destroy(ballSpawner);
		GameManager.instance.swingAnalysis.HideSwingAnalysis();
		if (GameManager.instance.golfball != null)
		{
			UnityEngine.Object.Destroy(GameManager.instance.golfball.gameObject);
		}
		Player.instance.transform.position = playerSpawnLocation.position;
		Player.instance.transform.rotation = Quaternion.identity;
		editorWind.wind.windPFX.gameObject.SetActive(value: false);
		finalizing = false;
		levelEditorMenu.levelEditorTutorialManager.SetTutorialStep(EditorTutorialStep.PreviewEnded);
	}

	public void ResetLevel()
	{
		if (previewing)
		{
			ScoreManager.instance.ResetStrokes();
			ballSpawner.GetComponent<GolfballSpawner>().ResetBall();
			Player.instance.transform.position = ballSpawner.transform.position;
		}
	}

	public void AddPiece(EditorPiece piece)
	{
		pieceCount++;
		if (piece.complexity == 0f)
		{
			currentComplexity += 300f;
		}
		else
		{
			currentComplexity += piece.complexity;
		}
		levelEditorMenu.UpdateComplexityBar();
		pieces.Add(piece.gameObject);
		piece.transform.SetParent(levelParent);
		levelEditorMenu.pieceCountText.text = pieceCount.ToString();
		if (levelEditorMenu.levelEditorTutorialManager.inTutorial)
		{
			if ((bool)piece.GetComponent<Teebox>())
			{
				levelEditorMenu.levelEditorTutorialManager.SetTutorialStep(EditorTutorialStep.StartPiecePlaced);
			}
			if ((bool)piece.GetComponentInChildren<Golfhole>())
			{
				levelEditorMenu.levelEditorTutorialManager.SetTutorialStep(EditorTutorialStep.GolfHolePlaced);
			}
		}
	}

	public void RemovePiece(GameObject piece, bool destroyObject = false)
	{
		if (pieceCount > 0)
		{
			pieceCount--;
			if (piece.GetComponent<EditorPiece>().complexity == 0f)
			{
				currentComplexity -= 300f;
			}
			else
			{
				currentComplexity -= piece.GetComponent<EditorPiece>().complexity;
			}
			levelEditorMenu.UpdateComplexityBar();
			pieces.Remove(piece);
		}
		else
		{
			UnityEngine.Debug.LogError("removing piece with pieceCount = 0");
		}
		if (destroyObject)
		{
			UnityEngine.Object.Destroy(piece.gameObject);
		}
		levelEditorMenu.pieceCountText.text = pieceCount.ToString();
	}

	public void UpdateFlagDirections()
	{
		Vector3 vector = levelParent.TransformDirection(currentLevel.windVector);
		if (vector == Vector3.zero)
		{
			vector = Vector3.right;
		}
		Golfhole[] componentsInChildren = levelParent.GetComponentsInChildren<Golfhole>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].ChangeFlagDirection(vector);
		}
	}

	public void ResetUndoRedo()
	{
		stepPieces.Clear();
		editorSteps.Clear();
		editorSteps.Add(default(EditorStep));
		stepIndex = 0;
		UpdateUndoRedoButtons();
		lastSavedStepIndex = 0;
	}

	public void UpdateSaveStatus(bool saved)
	{
		levelEditorMenu.SetSaveStatus(saved);
	}

	private void CheckAndRemoveOverwrittenSteps()
	{
		if (stepIndex < editorSteps.Count - 1)
		{
			int count = editorSteps.Count - stepIndex - 1;
			editorSteps.RemoveRange(stepIndex + 1, count);
		}
	}

	private void UpdateSteps()
	{
		if (stepIndex <= lastSavedStepIndex)
		{
			lastSavedStepIndex = -1;
		}
		UpdateUndoRedoButtons();
		SetUnsavedChangesStatus();
		UpdateSaveStatus(!unsavedChanges);
	}

	public void SetUnsavedChangesStatus()
	{
		unsavedChanges = true;
		if (Directory.Exists(levelEditorMenu.currentLevelPath) && lastSavedStepIndex == stepIndex && screenshotSaved)
		{
			unsavedChanges = false;
		}
	}

	public void AddStep(EditorStep step)
	{
		CheckAndRemoveOverwrittenSteps();
		editorSteps.Add(step);
		stepIndex++;
		UpdateSteps();
	}

	public void AddStep(EditorPiece piece, StepType stepType)
	{
		CheckAndRemoveOverwrittenSteps();
		EditorStep item = default(EditorStep);
		switch (stepType)
		{
		case StepType.create:
			stepPieces.Add(piece.gameObject);
			item.pieceIndex = stepPieces.Count - 1;
			item.pieceHash = GameManager.Hash(piece.gameObject.name);
			item.stepType = stepType;
			item.position = piece.transform.localPosition;
			item.rotation = piece.transform.rotation;
			item.scale = piece.transform.localScale;
			item.snappedPoints = new SnapData[1][] { SnapDataSub(GetSnappedPoints(piece), NewBlankSnapData(piece.snapPoints.Length)) };
			if (piece.placeableObject != null)
			{
				PlaceableData placeableData3 = default(PlaceableData);
				placeableData3.piecePosition = piece.placeableObject.transform.localPosition;
				placeableData3.pieceRotation = piece.placeableObject.transform.localRotation;
				if (piece.placementPiece == null)
				{
					placeableData3.placementPieceIndex = -1;
				}
				else
				{
					placeableData3.placementPieceIndex = (short)instance.stepPieces.IndexOf(piece.placementPiece);
				}
				item.placeableData = new PlaceableData[1];
				item.placeableData[0] = placeableData3;
			}
			else if (piece.placedPieces.Count <= 0)
			{
			}
			break;
		case StepType.delete:
			item.pieceIndex = stepPieces.IndexOf(piece.gameObject);
			stepPieces[item.pieceIndex] = null;
			item.pieceHash = GameManager.Hash(piece.gameObject.name);
			item.stepType = stepType;
			item.position = piece.transform.localPosition;
			item.rotation = piece.transform.rotation;
			item.scale = piece.transform.localScale;
			item.snappedPoints = new SnapData[1][] { SnapDataSub(NewBlankSnapData(piece.snapPoints.Length), GetSnappedPoints(piece)) };
			if (piece.placeableObject != null)
			{
				PlaceableData placeableData4 = default(PlaceableData);
				placeableData4.piecePosition = piece.placeableObject.transform.localPosition;
				placeableData4.pieceRotation = piece.placeableObject.transform.localRotation;
				if (piece.placementPiece != null)
				{
					placeableData4.placementPieceIndex = (short)stepPieces.IndexOf(piece.placementPiece);
				}
				else
				{
					placeableData4.placementPieceIndex = -1;
				}
				item.placeableData = new PlaceableData[1];
				item.placeableData[0] = placeableData4;
			}
			else if (piece.placedPieces.Count > 0)
			{
				item.placeableData = new PlaceableData[piece.placedPieces.Count];
				for (int i = 0; i < piece.placedPieces.Count; i++)
				{
					item.placeableData[i].pieceIndex = (short)stepPieces.IndexOf(piece.placedPieces[i]);
				}
			}
			break;
		case StepType.createLinked:
			stepPieces.Add(piece.gameObject);
			item.pieceIndex = stepPieces.Count - 1;
			item.pieceHash = GameManager.Hash(piece.gameObject.name);
			item.stepType = stepType;
			item.position = piece.transform.localPosition;
			item.rotation = piece.transform.rotation;
			item.scale = piece.transform.localScale;
			item.snappedPoints = new SnapData[1][] { SnapDataSub(GetSnappedPoints(piece), NewBlankSnapData(piece.snapPoints.Length)) };
			if (piece.placeableObject != null)
			{
				PlaceableData placeableData2 = default(PlaceableData);
				placeableData2.piecePosition = piece.placeableObject.transform.localPosition;
				placeableData2.pieceRotation = piece.placeableObject.transform.localRotation;
				if (piece.placementPiece != null)
				{
					placeableData2.placementPieceIndex = (short)stepPieces.IndexOf(piece.placementPiece);
				}
				else
				{
					placeableData2.placementPieceIndex = -1;
				}
				item.placeableData = new PlaceableData[1];
				item.placeableData[0] = placeableData2;
			}
			break;
		case StepType.deleteLinked:
			item.pieceIndex = stepPieces.IndexOf(piece.gameObject);
			stepPieces[item.pieceIndex] = null;
			item.pieceHash = GameManager.Hash(piece.gameObject.name);
			item.stepType = stepType;
			item.position = piece.transform.localPosition;
			item.rotation = piece.transform.rotation;
			item.scale = piece.transform.localScale;
			item.snappedPoints = new SnapData[1][] { SnapDataSub(NewBlankSnapData(piece.snapPoints.Length), GetSnappedPoints(piece)) };
			if (piece.placeableObject != null)
			{
				PlaceableData placeableData = default(PlaceableData);
				placeableData.piecePosition = piece.placeableObject.transform.localPosition;
				placeableData.pieceRotation = piece.placeableObject.transform.localRotation;
				if (piece.placementPiece != null)
				{
					placeableData.placementPieceIndex = (short)stepPieces.IndexOf(piece.placementPiece);
				}
				else
				{
					placeableData.placementPieceIndex = -1;
				}
				item.placeableData = new PlaceableData[1];
				item.placeableData[0] = placeableData;
			}
			break;
		}
		editorSteps.Add(item);
		stepIndex++;
		UpdateSteps();
	}

	public void Undo()
	{
		if (stepIndex > 0 && stepIndex < editorSteps.Count)
		{
			EditorStep step = editorSteps[stepIndex];
			switch (step.stepType)
			{
			case StepType.move:
			{
				GameObject gameObject3 = stepPieces[step.pieceIndex];
				Vector3 localPosition = gameObject3.transform.localPosition;
				Quaternion localRotation = gameObject3.transform.localRotation;
				gameObject3.transform.localPosition -= step.position;
				gameObject3.transform.rotation = gameObject3.transform.rotation * step.rotation;
				EditorPiece component4 = gameObject3.GetComponent<EditorPiece>();
				SnapData[] snapData3 = SnapDataSub(GetSnappedPoints(component4), step.snappedPoints[0]);
				ApplySnapData(component4, snapData3);
				if (component4.placeableObject != null)
				{
					if (step.placeableData[0].placementPieceIndex != 0)
					{
						int num3 = -1;
						if (component4.placementPiece != null)
						{
							num3 = stepPieces.IndexOf(component4.placementPiece);
						}
						int num4 = num3 + step.placeableData[0].placementPieceIndex;
						if (num4 >= 0)
						{
							component4.RemovePlacementPiece();
							component4.AddPlacementPiece(stepPieces[num4]);
							if (Player.instance.editorGrabber.selectedObjects.Contains(component4.placementPiece) && !Player.instance.editorGrabber.selectedObjects.Contains(gameObject3) && !Player.instance.editorGrabber.selectedConnectedObjects.Contains(gameObject3))
							{
								Player.instance.editorGrabber.selectedConnectedObjects.Add(gameObject3);
								component4.ConnectedHighlight();
							}
						}
						else
						{
							if (Player.instance.editorGrabber.selectedObjects.Contains(component4.placementPiece) && Player.instance.editorGrabber.selectedConnectedObjects.Contains(gameObject3))
							{
								Player.instance.editorGrabber.selectedConnectedObjects.Remove(gameObject3);
								component4.UnHighlight();
							}
							component4.RemovePlacementPiece();
						}
					}
					component4.placeableObject.transform.localPosition -= step.placeableData[0].piecePosition;
					component4.placeableObject.transform.rotation = component4.placeableObject.transform.rotation * step.placeableData[0].pieceRotation;
				}
				if (component4.placedPieces.Count > 0)
				{
					for (int num5 = 0; num5 < component4.placedPieces.Count; num5++)
					{
						Vector3 vector3 = Quaternion.Inverse(localRotation) * (component4.placedPieces[num5].transform.localPosition - localPosition);
						Quaternion quaternion3 = Quaternion.Inverse(localRotation) * component4.placedPieces[num5].transform.localRotation;
						component4.placedPieces[num5].transform.localRotation = gameObject3.transform.localRotation * quaternion3;
						component4.placedPieces[num5].transform.localPosition = gameObject3.transform.localPosition + gameObject3.transform.localRotation * vector3;
					}
				}
				break;
			}
			case StepType.originMove:
				levelParent.localPosition -= step.position;
				levelParent.rotation *= step.rotation;
				break;
			case StepType.selectedMove:
			{
				Vector3 vector = step.endPosition - step.position;
				Quaternion quaternion = step.endRotation * step.rotation;
				for (int m = 0; m < step.groupPieces.Length; m++)
				{
					GameObject gameObject2 = stepPieces[step.groupPieces[m]];
					Vector3 vector2 = Quaternion.Inverse(step.endRotation) * (gameObject2.transform.position - step.endPosition);
					Quaternion quaternion2 = Quaternion.Inverse(step.endRotation) * gameObject2.transform.rotation;
					gameObject2.transform.rotation = quaternion * quaternion2;
					gameObject2.transform.position = vector + quaternion * vector2;
					EditorPiece component2 = gameObject2.GetComponent<EditorPiece>();
					if (step.snappedPoints[m] != null)
					{
						SnapData[] snapData2 = SnapDataSub(GetSnappedPoints(component2), step.snappedPoints[m]);
						ApplySnapData(component2, snapData2);
					}
				}
				for (int n = 0; n < step.placeableData.Length; n++)
				{
					EditorPiece component3 = instance.stepPieces[step.placeableData[n].pieceIndex].GetComponent<EditorPiece>();
					if (!(component3.placeableObject != null))
					{
						continue;
					}
					if (step.placeableData[n].placementPieceIndex != 0)
					{
						int num = -1;
						if (component3.placementPiece != null)
						{
							num = stepPieces.IndexOf(component3.placementPiece);
						}
						int num2 = num + step.placeableData[n].placementPieceIndex;
						if (num2 >= 0)
						{
							component3.RemovePlacementPiece();
							component3.AddPlacementPiece(stepPieces[num2]);
							if (Player.instance.editorGrabber.selectedObjects.Contains(component3.placementPiece) && !Player.instance.editorGrabber.selectedObjects.Contains(component3.gameObject) && !Player.instance.editorGrabber.selectedConnectedObjects.Contains(component3.gameObject))
							{
								Player.instance.editorGrabber.selectedConnectedObjects.Add(component3.gameObject);
								component3.ConnectedHighlight();
							}
						}
						else
						{
							if (Player.instance.editorGrabber.selectedObjects.Contains(component3.placementPiece) && Player.instance.editorGrabber.selectedConnectedObjects.Contains(component3.gameObject))
							{
								Player.instance.editorGrabber.selectedConnectedObjects.Remove(component3.gameObject);
								component3.UnHighlight();
							}
							component3.RemovePlacementPiece();
						}
					}
					component3.placeableObject.transform.localPosition -= step.placeableData[n].piecePosition;
					component3.placeableObject.transform.rotation = component3.placeableObject.transform.rotation * step.placeableData[n].pieceRotation;
				}
				break;
			}
			case StepType.create:
				RemovePieceFromStep(step);
				break;
			case StepType.delete:
				CreatePieceFromStep(step);
				break;
			case StepType.createLinked:
				RemovePieceFromStep(step);
				RemovePieceFromStep(editorSteps[stepIndex - 1]);
				stepIndex--;
				break;
			case StepType.deleteLinked:
			{
				EditorPiece p = CreatePieceFromStep(step);
				EditorPiece p2 = CreatePieceFromStep(editorSteps[stepIndex - 1]);
				WarpNode.LinkPieces(p, p2);
				stepIndex--;
				break;
			}
			case StepType.editPointMove:
			{
				GameObject gameObject = stepPieces[step.pieceIndex].GetComponentInChildren<EditPoint>().gameObject;
				gameObject.transform.localPosition -= step.position;
				gameObject.transform.rotation = gameObject.transform.rotation * step.rotation;
				gameObject.GetComponent<EditPoint>().UpdateDynamicParts();
				break;
			}
			case StepType.scale:
			{
				GameObject[] array = new GameObject[step.groupPieces.Length];
				for (int i = 0; i < step.groupPieces.Length; i++)
				{
					array[i] = stepPieces[step.groupPieces[i]];
				}
				for (int j = 1; j < array.Length; j++)
				{
					array[j].transform.parent = array[0].transform;
				}
				array[0].transform.localScale -= step.scale;
				for (int k = 1; k < array.Length; k++)
				{
					array[k].transform.parent = levelParent;
				}
				if (Player.instance.editorGrabber.selectedObjects.Count == 1 && array[0] == Player.instance.editorGrabber.selectedObjects[0])
				{
					detailMenu.FillDetails(array[0].GetComponent<EditorPiece>());
				}
				for (int l = 0; l < array.Length; l++)
				{
					if (step.snappedPoints[l] != null)
					{
						EditorPiece component = array[l].GetComponent<EditorPiece>();
						SnapData[] snapData = SnapDataSub(GetSnappedPoints(component), step.snappedPoints[l]);
						ApplySnapData(component, snapData);
					}
				}
				break;
			}
			}
			stepIndex--;
		}
		UpdateUndoRedoButtons();
		SetUnsavedChangesStatus();
		UpdateSaveStatus(!unsavedChanges);
	}

	public void Redo()
	{
		if (stepIndex + 1 < editorSteps.Count)
		{
			stepIndex++;
			EditorStep step = editorSteps[stepIndex];
			switch (step.stepType)
			{
			case StepType.move:
			{
				GameObject gameObject3 = stepPieces[step.pieceIndex];
				Vector3 localPosition = gameObject3.transform.localPosition;
				Quaternion localRotation = gameObject3.transform.localRotation;
				gameObject3.transform.localPosition += step.position;
				gameObject3.transform.rotation = gameObject3.transform.rotation * Quaternion.Inverse(step.rotation);
				EditorPiece component4 = gameObject3.GetComponent<EditorPiece>();
				SnapData[] snapData3 = SnapDataAdd(GetSnappedPoints(component4), step.snappedPoints[0]);
				ApplySnapData(component4, snapData3);
				if (component4.placeableObject != null)
				{
					if (step.placeableData[0].placementPieceIndex != 0)
					{
						int num3 = -1;
						if (component4.placementPiece != null)
						{
							num3 = stepPieces.IndexOf(component4.placementPiece);
						}
						int num4 = num3 - step.placeableData[0].placementPieceIndex;
						if (num4 >= 0)
						{
							component4.RemovePlacementPiece();
							component4.AddPlacementPiece(stepPieces[num4]);
							if (Player.instance.editorGrabber.selectedObjects.Contains(component4.placementPiece) && !Player.instance.editorGrabber.selectedObjects.Contains(gameObject3) && !Player.instance.editorGrabber.selectedConnectedObjects.Contains(gameObject3))
							{
								Player.instance.editorGrabber.selectedConnectedObjects.Add(gameObject3);
								component4.ConnectedHighlight();
							}
						}
						else
						{
							if (Player.instance.editorGrabber.selectedObjects.Contains(component4.placementPiece) && Player.instance.editorGrabber.selectedConnectedObjects.Contains(gameObject3))
							{
								Player.instance.editorGrabber.selectedConnectedObjects.Remove(gameObject3);
								component4.UnHighlight();
							}
							component4.RemovePlacementPiece();
						}
					}
					component4.placeableObject.transform.localPosition += step.placeableData[0].piecePosition;
					component4.placeableObject.transform.rotation = component4.placeableObject.transform.rotation * Quaternion.Inverse(step.placeableData[0].pieceRotation);
				}
				_ = component4 != null;
				if (component4.placedPieces.Count > 0)
				{
					for (int num5 = 0; num5 < component4.placedPieces.Count; num5++)
					{
						Vector3 vector3 = Quaternion.Inverse(localRotation) * (component4.placedPieces[num5].transform.localPosition - localPosition);
						Quaternion quaternion2 = Quaternion.Inverse(localRotation) * component4.placedPieces[num5].transform.localRotation;
						component4.placedPieces[num5].transform.localRotation = gameObject3.transform.localRotation * quaternion2;
						component4.placedPieces[num5].transform.localPosition = gameObject3.transform.localPosition + gameObject3.transform.localRotation * vector3;
					}
				}
				break;
			}
			case StepType.originMove:
				levelParent.localPosition += step.position;
				levelParent.rotation *= Quaternion.Inverse(step.rotation);
				break;
			case StepType.selectedMove:
			{
				Vector3 vector = step.endPosition - step.position;
				Quaternion rotation = step.endRotation * step.rotation;
				for (int m = 0; m < step.groupPieces.Length; m++)
				{
					GameObject gameObject2 = stepPieces[step.groupPieces[m]];
					Vector3 vector2 = Quaternion.Inverse(rotation) * (gameObject2.transform.position - vector);
					Quaternion quaternion = Quaternion.Inverse(rotation) * gameObject2.transform.rotation;
					gameObject2.transform.rotation = step.endRotation * quaternion;
					gameObject2.transform.position = step.endPosition + step.endRotation * vector2;
					EditorPiece component2 = gameObject2.GetComponent<EditorPiece>();
					if (step.snappedPoints[m] != null)
					{
						SnapData[] snapData2 = SnapDataAdd(GetSnappedPoints(component2), step.snappedPoints[m]);
						ApplySnapData(component2, snapData2);
					}
				}
				for (int n = 0; n < step.placeableData.Length; n++)
				{
					EditorPiece component3 = instance.stepPieces[step.placeableData[n].pieceIndex].GetComponent<EditorPiece>();
					if (!(component3.placeableObject != null))
					{
						continue;
					}
					if (step.placeableData[n].placementPieceIndex != 0)
					{
						int num = -1;
						if (component3.placementPiece != null)
						{
							num = stepPieces.IndexOf(component3.placementPiece);
						}
						int num2 = num - step.placeableData[n].placementPieceIndex;
						if (num2 >= 0)
						{
							component3.RemovePlacementPiece();
							component3.AddPlacementPiece(stepPieces[num2]);
							if (Player.instance.editorGrabber.selectedObjects.Contains(component3.placementPiece) && !Player.instance.editorGrabber.selectedObjects.Contains(component3.gameObject) && !Player.instance.editorGrabber.selectedConnectedObjects.Contains(component3.gameObject))
							{
								Player.instance.editorGrabber.selectedConnectedObjects.Add(component3.gameObject);
								component3.ConnectedHighlight();
							}
						}
						else
						{
							if (Player.instance.editorGrabber.selectedObjects.Contains(component3.placementPiece) && Player.instance.editorGrabber.selectedConnectedObjects.Contains(component3.gameObject))
							{
								Player.instance.editorGrabber.selectedConnectedObjects.Remove(component3.gameObject);
								component3.UnHighlight();
							}
							component3.RemovePlacementPiece();
						}
					}
					component3.placeableObject.transform.localPosition += step.placeableData[n].piecePosition;
					component3.placeableObject.transform.rotation = component3.placeableObject.transform.rotation * Quaternion.Inverse(step.placeableData[n].pieceRotation);
				}
				break;
			}
			case StepType.create:
				CreatePieceFromStep(step, snapAdd: true);
				break;
			case StepType.delete:
				RemovePieceFromStep(step, snapAdd: true);
				break;
			case StepType.createLinked:
			{
				EditorPiece p = CreatePieceFromStep(step);
				EditorPiece p2 = CreatePieceFromStep(editorSteps[stepIndex + 1]);
				WarpNode.LinkPieces(p, p2);
				stepIndex++;
				break;
			}
			case StepType.deleteLinked:
				RemovePieceFromStep(step);
				RemovePieceFromStep(editorSteps[stepIndex + 1]);
				stepIndex++;
				break;
			case StepType.editPointMove:
			{
				GameObject gameObject = stepPieces[step.pieceIndex].GetComponentInChildren<EditPoint>().gameObject;
				gameObject.transform.localPosition += step.position;
				gameObject.transform.rotation = gameObject.transform.rotation * Quaternion.Inverse(step.rotation);
				gameObject.GetComponent<EditPoint>().UpdateDynamicParts();
				break;
			}
			case StepType.scale:
			{
				GameObject[] array = new GameObject[step.groupPieces.Length];
				for (int i = 0; i < step.groupPieces.Length; i++)
				{
					array[i] = stepPieces[step.groupPieces[i]];
				}
				for (int j = 1; j < array.Length; j++)
				{
					array[j].transform.parent = array[0].transform;
				}
				array[0].transform.localScale += step.scale;
				for (int k = 1; k < array.Length; k++)
				{
					array[k].transform.parent = levelParent;
				}
				if (Player.instance.editorGrabber.selectedObjects.Count == 1 && array[0] == Player.instance.editorGrabber.selectedObjects[0])
				{
					detailMenu.FillDetails(array[0].GetComponent<EditorPiece>());
				}
				for (int l = 0; l < array.Length; l++)
				{
					if (step.snappedPoints[l] != null)
					{
						EditorPiece component = array[l].GetComponent<EditorPiece>();
						SnapData[] snapData = SnapDataAdd(GetSnappedPoints(component), step.snappedPoints[l]);
						ApplySnapData(component, snapData);
					}
				}
				break;
			}
			}
		}
		UpdateUndoRedoButtons();
		SetUnsavedChangesStatus();
		UpdateSaveStatus(!unsavedChanges);
	}

	public void UpdateUndoRedoButtons()
	{
		if (stepIndex > 0)
		{
			levelEditorMenu.undoButton.textMeshProUGUI.color = levelEditorMenu.buttonAvailable;
			levelEditorMenu.undoButton.unhighlightColor = levelEditorMenu.buttonAvailable;
			levelEditorMenu.undoButton.clickable = true;
		}
		else
		{
			levelEditorMenu.undoButton.textMeshProUGUI.color = levelEditorMenu.buttonDisabled;
			levelEditorMenu.undoButton.clickable = false;
		}
		if (stepIndex < editorSteps.Count - 1)
		{
			levelEditorMenu.redoButton.textMeshProUGUI.color = levelEditorMenu.buttonAvailable;
			levelEditorMenu.redoButton.unhighlightColor = levelEditorMenu.buttonAvailable;
			levelEditorMenu.redoButton.clickable = true;
		}
		else
		{
			levelEditorMenu.redoButton.textMeshProUGUI.color = levelEditorMenu.buttonDisabled;
			levelEditorMenu.redoButton.clickable = false;
		}
	}

	public EditorPiece CreatePieceFromStep(EditorStep step, bool snapAdd = false)
	{
		EditorPiece editorPiece = null;
		GameObject editorPieceByNameHash = GameManager.instance.GetEditorPieceByNameHash(step.pieceHash);
		if (editorPieceByNameHash != null)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(editorPieceByNameHash);
			gameObject.name = editorPieceByNameHash.name;
			stepPieces[step.pieceIndex] = gameObject;
			editorPiece = gameObject.GetComponent<EditorPiece>();
			AddPiece(editorPiece);
			gameObject.transform.localPosition = step.position;
			gameObject.transform.rotation = step.rotation;
			gameObject.transform.localScale = step.scale;
			if (editorPiece.placeableObject != null)
			{
				if (step.placeableData[0].placementPieceIndex != -1)
				{
					editorPiece.AddPlacementPiece(stepPieces[step.placeableData[0].placementPieceIndex]);
				}
				editorPiece.placeableObject.transform.localPosition = step.placeableData[0].piecePosition;
				editorPiece.placeableObject.transform.localRotation = step.placeableData[0].pieceRotation;
			}
			else
			{
				if (step.placeableData != null && step.placeableData.Length != 0)
				{
					for (int i = 0; i < step.placeableData.Length; i++)
					{
						stepPieces[step.placeableData[i].pieceIndex].GetComponent<EditorPiece>().AddPlacementPiece(gameObject);
					}
				}
				if (editorPiece != null)
				{
					if (snapAdd)
					{
						SnapData[] snapData = SnapDataAdd(GetSnappedPoints(editorPiece), step.snappedPoints[0]);
						ApplySnapData(editorPiece, snapData);
					}
					else
					{
						SnapData[] snapData2 = SnapDataSub(GetSnappedPoints(editorPiece), step.snappedPoints[0]);
						ApplySnapData(editorPiece, snapData2);
					}
				}
			}
		}
		else
		{
			MonoBehaviour.print("couldn't find piece by hash");
		}
		return editorPiece;
	}

	public void RemovePieceFromStep(EditorStep step, bool snapAdd = false)
	{
		GameObject gameObject = stepPieces[step.pieceIndex];
		EditorPiece component = gameObject.GetComponent<EditorPiece>();
		if (component.placeableObject != null && component.placementPiece != null)
		{
			component.RemovePlacementPiece();
		}
		else
		{
			if (component.placedPieces.Count > 0)
			{
				for (int i = 0; i < component.placedPieces.Count; i++)
				{
					component.placedPieces[i].GetComponent<EditorPiece>().RemovePlacementPiece();
				}
			}
			if (component != null)
			{
				if (snapAdd)
				{
					SnapData[] snapData = SnapDataAdd(GetSnappedPoints(component), step.snappedPoints[0]);
					ApplySnapData(component, snapData);
				}
				else
				{
					SnapData[] snapData2 = SnapDataSub(GetSnappedPoints(component), step.snappedPoints[0]);
					ApplySnapData(component, snapData2);
				}
			}
		}
		if (Player.instance.editorGrabber.selectedObjects.Contains(gameObject))
		{
			Player.instance.editorGrabber.RemoveSelected(gameObject);
		}
		RemovePiece(gameObject, destroyObject: true);
		stepPieces[step.pieceIndex] = null;
	}

	public SnapData[] GetSnappedPoints(EditorPiece piece, bool fromStepPieces = true)
	{
		SnapData[] array = new SnapData[piece.snapPoints.Length];
		for (int i = 0; i < piece.snapPoints.Length; i++)
		{
			SnapPoint snapPoint = piece.snapPoints[i];
			if (snapPoint.snappedPoint != null)
			{
				SnapPoint snappedPoint = snapPoint.snappedPoint;
				if (fromStepPieces)
				{
					array[i].pieceIndex = stepPieces.IndexOf(snappedPoint.piece.gameObject);
				}
				else
				{
					array[i].pieceIndex = pieces.IndexOf(snappedPoint.piece.gameObject);
				}
				array[i].snapPointIndex = Array.IndexOf(snappedPoint.piece.snapPoints, snappedPoint);
			}
			else
			{
				array[i] = SnapData.EmptySnapData();
			}
		}
		return array;
	}

	public static SnapData[] NewBlankSnapData(int snapCount)
	{
		SnapData[] array = new SnapData[snapCount];
		for (int i = 0; i < snapCount; i++)
		{
			array[i] = SnapData.EmptySnapData();
		}
		return array;
	}

	public static SnapData[] SnapDataSub(SnapData[] snapDataStart, SnapData[] snapDataEnd)
	{
		SnapData[] array = new SnapData[snapDataStart.Length];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = snapDataStart[i] - snapDataEnd[i];
		}
		return array;
	}

	public static SnapData[] SnapDataAdd(SnapData[] snapDataStart, SnapData[] snapDataEnd)
	{
		SnapData[] array = new SnapData[snapDataStart.Length];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = snapDataStart[i] + snapDataEnd[i];
		}
		return array;
	}

	public SnapPoint GetSnapPoint(SnapData snapData)
	{
		return stepPieces[snapData.pieceIndex].GetComponent<EditorPiece>().snapPoints[snapData.snapPointIndex];
	}

	public SnapPoint GetSnapPointFromPieces(SnapData snapData)
	{
		return pieces[snapData.pieceIndex].GetComponent<EditorPiece>().snapPoints[snapData.snapPointIndex];
	}

	public bool ActiveSnap(EditorPiece piece)
	{
		bool result = false;
		for (int i = 0; i < piece.snapPoints.Length; i++)
		{
			if (piece.snapPoints[i].active)
			{
				result = true;
				break;
			}
		}
		return result;
	}

	public void ApplySnapData(EditorPiece piece, SnapData[] snapData, bool fromStepPieces = true)
	{
		for (int i = 0; i < snapData.Length; i++)
		{
			if (i >= piece.snapPoints.Length)
			{
				continue;
			}
			if (snapData[i].pieceIndex == -1)
			{
				if (piece.snapPoints[i].snappedPoint != null)
				{
					piece.snapPoints[i].snappedPoint.piece.UnSnapPoint(piece.snapPoints[i].snappedPoint);
					piece.UnSnapPoint(piece.snapPoints[i]);
				}
				continue;
			}
			if (piece.snapPoints[i].snappedPoint != null)
			{
				piece.snapPoints[i].snappedPoint.piece.UnSnapPoint(piece.snapPoints[i].snappedPoint);
			}
			SnapPoint foreignPoint = ((!fromStepPieces) ? GetSnapPointFromPieces(snapData[i]) : GetSnapPoint(snapData[i]));
			bool showHingeHandles = true;
			piece.SetSnapStatus(piece.snapPoints[i], foreignPoint, showHingeHandles);
			piece.showSnapPoints = true;
		}
	}

	public void ApplySnapData(SnapPieceData snapPieceData, bool fromStepPieces = true)
	{
		EditorPiece component = stepPieces[snapPieceData.pieceIndex].GetComponent<EditorPiece>();
		ApplySnapData(component, snapPieceData.snapData, fromStepPieces);
	}

	public bool IsAnyNegative(SnapData[] snapData)
	{
		bool flag = false;
		for (int i = 0; i < snapData.Length; i++)
		{
			if (snapData[i].pieceIndex <= -2 || snapData[i].snapPointIndex <= -2)
			{
				flag = true;
				break;
			}
			if (flag)
			{
				break;
			}
		}
		return flag;
	}

	public void SetSong(Song song)
	{
		currentLevel.song = song;
		GameManager.instance.audioManager.ChangeMusic(song);
	}

	public void SetSkybox(Skybox skybox)
	{
		currentLevel.skybox = skybox;
		ApplyLighting((int)skybox);
	}

	public void ApplyLighting(int skybox)
	{
		LightingData lightingData = GameManager.instance.LightingSettings[skybox];
		directionalLight.intensity = lightingData.lightIntensity;
		directionalLight.shadowStrength = lightingData.shadowStrength;
		RenderSettings.skybox = lightingData.skyboxMat;
		RenderSettings.ambientIntensity = lightingData.intensityMultiplier;
		DynamicGI.UpdateEnvironment();
	}

	public void CloseLevel()
	{
		ClearAllPieces();
		currentLevel = default(CustomLevel);
		editingOtherCreator = false;
	}

	public void NewLevel()
	{
		ClearAllPieces();
		ResetUndoRedo();
		unsavedChanges = true;
		screenshotSaved = false;
		editingOtherCreator = false;
		editScale = 1f;
		currentComplexity = 0f;
		levelEditorMenu.UpdateComplexityBar();
		currentLevel = default(CustomLevel);
		currentLevel.levelName = "";
		currentLevel.allowedClubs = GolfClubType.Putter | GolfClubType.Iron | GolfClubType.Driver;
		currentLevel.song = Song.easyCampaign1;
		levelParent.position = Vector3.zero;
		levelParent.rotation = Quaternion.identity;
		levelParent.localScale = pieceScaleV3;
		levelEditorMenu.editorWind.Reset();
		randomWind = false;
		ApplyLighting(0);
		GameManager.instance.audioManager.ChangeMusic(Song.easyCampaign1);
		canEdit = true;
	}

	public void SaveLevel(string path)
	{
		if (string.IsNullOrEmpty(path))
		{
			path = levelEditorMenu.GetAndCreateNewLevelPath();
		}
		string path2 = path + currentLevel.levelName + ".dat";
		if (Directory.Exists(path))
		{
			string fileNameWithoutExtension = Path.GetFileNameWithoutExtension(path2);
			string[] files = Directory.GetFiles(path, "*.dat");
			string[] files2 = Directory.GetFiles(path, "*.info");
			for (int i = 0; i < files.Length; i++)
			{
				if (Path.GetFileNameWithoutExtension(files[i]) != fileNameWithoutExtension)
				{
					File.Delete(files[i]);
				}
			}
			for (int j = 0; j < files2.Length; j++)
			{
				if (Path.GetFileNameWithoutExtension(files2[j]) != fileNameWithoutExtension)
				{
					File.Delete(files2[j]);
				}
			}
		}
		else
		{
			Directory.CreateDirectory(path);
		}
		byte[] bytes = Encoding.Unicode.GetBytes(currentLevel.levelName);
		int num = bytes.Length;
		string s = "Guest";
		string s2 = "";
		if (editingOtherCreator)
		{
			s = currentLevel.creatorName;
			s2 = currentLevel.creatorId;
		}
		else
		{
			if (!string.IsNullOrEmpty(RemoteServerManager.instance.playerUserName))
			{
				s = RemoteServerManager.instance.playerUserName;
			}
			if (!string.IsNullOrEmpty(RemoteServerManager.instance.playerID))
			{
				s2 = RemoteServerManager.instance.playerID;
			}
		}
		byte[] bytes2 = Encoding.Unicode.GetBytes(s);
		int num2 = bytes2.Length;
		byte[] bytes3 = Encoding.Unicode.GetBytes(s2);
		int num3 = bytes3.Length;
		ushort num4 = (ushort)pieces.Count;
		ushort num5 = 0;
		ushort num6 = 0;
		ushort num7 = 0;
		int num8 = 0;
		for (int k = 0; k < pieces.Count; k++)
		{
			EditorPiece component = pieces[k].GetComponent<EditorPiece>();
			if (component.snapPoints.Length != 0)
			{
				num7++;
				num8 += component.snapPoints.Length;
			}
			if (component.linkedPiece != null || component.GetComponentInChildren<EditPoint>() != null)
			{
				num6++;
			}
			if (component.placeableObject != null)
			{
				num5++;
			}
		}
		int num9 = 112 + num + num2 + num3 + num4 * bytesPerPiece + num5 * bytesPerPlaceableData + num6 * bytesPerDynamicData + num7 * bytesPerSnapPiece + num8 * bytesPerSnapPoint;
		MemoryStream memoryStream = new MemoryStream();
		memoryStream.SetLength(num9);
		memoryStream.Write(BitConverter.GetBytes(saveFileVersionNumber), 0, 4);
		memoryStream.Write(BitConverter.GetBytes(DateTime.UtcNow.Ticks), 0, 8);
		memoryStream.Write(BitConverter.GetBytes((ushort)GameManager.instance.publishedPlatform), 0, 2);
		memoryStream.Write(BitConverter.GetBytes(currentLevel.publishedFileId), 0, 8);
		memoryStream.Write(BitConverter.GetBytes(currentLevel.completed), 0, 1);
		memoryStream.Write(BitConverter.GetBytes(currentLevel.published), 0, 1);
		memoryStream.Write(BitConverter.GetBytes(currentLevel.par), 0, 2);
		memoryStream.Write(BitConverter.GetBytes((byte)currentLevel.difficulty), 0, 1);
		memoryStream.Write(BitConverter.GetBytes((ushort)currentLevel.song), 0, 2);
		memoryStream.Write(BitConverter.GetBytes((byte)currentLevel.skybox), 0, 1);
		memoryStream.Write(BitConverter.GetBytes(currentLevel.gravity), 0, 4);
		memoryStream.Write(BitConverter.GetBytes((int)currentLevel.allowedClubs), 0, 4);
		memoryStream.Write(GetWindBytes(), 0, 12);
		memoryStream.Write(GetOriginBytes(), 0, 40);
		memoryStream.Write(BitConverter.GetBytes(num4), 0, 2);
		memoryStream.Write(BitConverter.GetBytes(num5), 0, 2);
		memoryStream.Write(BitConverter.GetBytes(num6), 0, 2);
		memoryStream.Write(BitConverter.GetBytes(num7), 0, 2);
		memoryStream.Write(BitConverter.GetBytes((ushort)num8), 0, 2);
		memoryStream.Write(BitConverter.GetBytes(num), 0, 4);
		memoryStream.Write(BitConverter.GetBytes(num2), 0, 4);
		memoryStream.Write(BitConverter.GetBytes(num3), 0, 4);
		memoryStream.Write(bytes, 0, num);
		memoryStream.Write(bytes2, 0, num2);
		memoryStream.Write(bytes3, 0, num3);
		for (ushort num10 = 0; num10 < num4; num10++)
		{
			WritePieceToMemStream(pieces[num10].transform, memoryStream);
		}
		for (ushort num11 = 0; num11 < num4; num11++)
		{
			CheckAndWritePlaceableDataToMemStream(pieces[num11].GetComponent<EditorPiece>(), memoryStream);
		}
		for (ushort num12 = 0; num12 < num4; num12++)
		{
			CheckAndWriteDynamicDataToMemStream(pieces[num12].GetComponent<EditorPiece>(), memoryStream);
		}
		for (ushort num13 = 0; num13 < num4; num13++)
		{
			CheckAndWriteSnapDataToMemStream(pieces[num13].GetComponent<EditorPiece>(), memoryStream);
		}
		FileStream fileStream = new FileStream(path2, FileMode.Create);
		memoryStream.WriteTo(fileStream);
		fileStream.Flush();
		memoryStream.Dispose();
		fileStream.Dispose();
		unsavedChanges = false;
		if (!screenshotSaved && currentScreenshotBytes != null && currentScreenshotBytes.Length != 0)
		{
			string[] files3 = Directory.GetFiles(path, "*.jpg");
			for (int l = 0; l < files3.Length; l++)
			{
				File.Delete(files3[l]);
			}
			string text = path + currentLevel.levelName + ".jpg";
			File.WriteAllBytes(text, currentScreenshotBytes);
			UnityEngine.Debug.Log("Took screenshot to: " + text);
		}
		screenshotSaved = true;
		UpdateSaveStatus(saved: true);
		lastSavedStepIndex = stepIndex;
	}

	public static CustomLevel LoadLevelData(string path, bool cloudlandsHole = false)
	{
		CustomLevel result = default(CustomLevel);
		result.valid = false;
		byte[] buffer = null;
		if (cloudlandsHole)
		{
			TextAsset textAsset = Resources.LoadAll<TextAsset>("Holes/" + path)[0];
			if (textAsset != null)
			{
				buffer = textAsset.bytes;
			}
		}
		else if (File.Exists(path))
		{
			buffer = File.ReadAllBytes(path);
		}
		if (buffer != null)
		{
			if (buffer.Length < 4)
			{
				return result;
			}
			int bufferIndex = 0;
			if (kBufferUtil.ReadU32(ref buffer, ref bufferIndex) != 200)
			{
				MonoBehaviour.print("unsupported version number, update Cloudlands 2 to play this level");
				return result;
			}
			int num = 108;
			if (buffer.Length < num)
			{
				return result;
			}
			long num2 = kBufferUtil.ReadS64(ref buffer, ref bufferIndex);
			if (num2 < DateTime.MinValue.Ticks || num2 > DateTime.MaxValue.Ticks)
			{
				return result;
			}
			result.saveDate = new DateTime(num2, DateTimeKind.Utc);
			result.publishedPlatform = (PublishedPlatform)kBufferUtil.ReadU16(ref buffer, ref bufferIndex);
			result.publishedFileId = kBufferUtil.ReadU64(ref buffer, ref bufferIndex);
			result.completed = kBufferUtil.ReadBool(ref buffer, ref bufferIndex);
			result.published = kBufferUtil.ReadBool(ref buffer, ref bufferIndex);
			result.par = kBufferUtil.ReadU16(ref buffer, ref bufferIndex);
			result.difficulty = (Difficulty)kBufferUtil.ReadByte(ref buffer, ref bufferIndex);
			result.song = (Song)kBufferUtil.ReadU16(ref buffer, ref bufferIndex);
			result.skybox = (Skybox)kBufferUtil.ReadByte(ref buffer, ref bufferIndex);
			result.gravity = kBufferUtil.ReadFloat(ref buffer, ref bufferIndex);
			result.allowedClubs = (GolfClubType)kBufferUtil.ReadS32(ref buffer, ref bufferIndex);
			result.windVector = kBufferUtil.ReadVector3(ref buffer, ref bufferIndex);
			result.originPosition = kBufferUtil.ReadVector3(ref buffer, ref bufferIndex);
			result.originScale = kBufferUtil.ReadVector3(ref buffer, ref bufferIndex);
			result.originRotation = kBufferUtil.ReadQuaternion(ref buffer, ref bufferIndex);
			ushort num3 = kBufferUtil.ReadU16(ref buffer, ref bufferIndex);
			ushort num4 = kBufferUtil.ReadU16(ref buffer, ref bufferIndex);
			ushort num5 = kBufferUtil.ReadU16(ref buffer, ref bufferIndex);
			ushort num6 = kBufferUtil.ReadU16(ref buffer, ref bufferIndex);
			ushort num7 = kBufferUtil.ReadU16(ref buffer, ref bufferIndex);
			int num8 = kBufferUtil.ReadS32(ref buffer, ref bufferIndex);
			int num9 = kBufferUtil.ReadS32(ref buffer, ref bufferIndex);
			int num10 = kBufferUtil.ReadS32(ref buffer, ref bufferIndex);
			int num11 = num + num8 + num9 + num10;
			if (buffer.Length < num11)
			{
				return result;
			}
			result.levelName = kBufferUtil.ReadString(ref buffer, ref bufferIndex, num8);
			result.creatorName = kBufferUtil.ReadString(ref buffer, ref bufferIndex, num9);
			result.creatorId = kBufferUtil.ReadString(ref buffer, ref bufferIndex, num10);
			int num12 = num11 + num3 * bytesPerPiece;
			if (buffer.Length < num12)
			{
				return result;
			}
			result.pieces = new LevelPiece[num3];
			for (int i = 0; i < num3; i++)
			{
				result.pieces[i] = kBufferUtil.ReadLevelPiece(ref buffer, ref bufferIndex);
			}
			int num13 = num12 + num4 * bytesPerPlaceableData;
			if (buffer.Length < num13)
			{
				return result;
			}
			if (num4 > 0)
			{
				result.placeableData = new PlaceableData[num4];
				for (int j = 0; j < num4; j++)
				{
					result.placeableData[j] = kBufferUtil.ReadPlaceableData(ref buffer, ref bufferIndex);
				}
			}
			int num14 = num13 + num5 * bytesPerDynamicData;
			if (buffer.Length < num14)
			{
				return result;
			}
			if (num5 > 0)
			{
				result.dynamicData = new DynamicData[num5];
				for (int k = 0; k < num5; k++)
				{
					result.dynamicData[k] = kBufferUtil.ReadDynamicData(ref buffer, ref bufferIndex);
				}
			}
			int num15 = num14 + num6 * bytesPerSnapPiece + num7 * bytesPerSnapPoint;
			if (buffer.Length < num15)
			{
				return result;
			}
			if (num6 > 0)
			{
				result.snapPieceData = new SnapPieceData[num6];
				for (int l = 0; l < num6; l++)
				{
					result.snapPieceData[l] = kBufferUtil.ReadSnapPieceData(ref buffer, ref bufferIndex);
				}
			}
			result.valid = true;
		}
		else
		{
			MonoBehaviour.print("file doesn't exist");
		}
		return result;
	}

	public void LoadLevel(CustomLevel cl)
	{
		if (cl.pieces != null)
		{
			Player.instance.editorGrabber.PrepareForPreview();
			ClearAllPieces();
			currentComplexity = 0f;
			ResetUndoRedo();
			canPlaySnapSFX = false;
			editScale = 1f;
			levelParent.localScale = pieceScaleV3;
			levelParent.rotation = cl.originRotation;
			for (int i = 0; i < cl.pieces.Length; i++)
			{
				SpawnPiece(cl.pieces[i]);
			}
			if (cl.snapPieceData != null && cl.snapPieceData.Length != 0)
			{
				for (int j = 0; j < cl.snapPieceData.Length; j++)
				{
					ApplySnapData(cl.snapPieceData[j]);
				}
			}
			if (cl.placeableData != null && cl.placeableData.Length != 0)
			{
				for (int k = 0; k < cl.placeableData.Length; k++)
				{
					ApplyPlaceableData(cl.placeableData[k]);
				}
			}
			if (cl.dynamicData != null && cl.dynamicData.Length != 0)
			{
				for (int l = 0; l < cl.dynamicData.Length; l++)
				{
					ApplyDynamicData(cl.dynamicData[l]);
				}
			}
			CenterLevel();
			editorWind.gameObject.transform.localRotation = Quaternion.LookRotation(cl.windVector);
			editorWind.LoadWindSpeed(cl.windVector);
			ApplyLighting((int)cl.skybox);
			GameManager.instance.audioManager.ChangeMusic(cl.song);
			currentLevel = cl;
			UpdateFlagDirections();
			unsavedChanges = false;
		}
		else
		{
			MonoBehaviour.print("tried to load level with no pieces");
		}
		unsavedChanges = false;
		screenshotSaved = true;
		UpdateSaveStatus(saved: true);
		canEdit = true;
		levelEditorMenu.UpdateComplexityBar();
		if (currentLevel.creatorId != RemoteServerManager.instance.playerID || currentLevel.creatorId == "")
		{
			editingOtherCreator = true;
		}
		else
		{
			editingOtherCreator = false;
		}
	}

	public void SpawnPiece(LevelPiece pieceData)
	{
		GameObject editorPieceByNameHash = GameManager.instance.GetEditorPieceByNameHash(pieceData.nameHash);
		if (editorPieceByNameHash != null)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(editorPieceByNameHash);
			gameObject.name = editorPieceByNameHash.name;
			AddPiece(gameObject.GetComponent<EditorPiece>());
			gameObject.GetComponent<EditorPiece>().showSnapPoints = true;
			gameObject.transform.localScale = pieceData.scale;
			gameObject.transform.localPosition = pieceData.position;
			gameObject.transform.localRotation = pieceData.rotation;
			stepPieces.Add(gameObject);
		}
		else
		{
			Notification.instance.AddNotification("There was a piece that could not be loaded", 0f, closeButton: true);
		}
	}

	public void ApplyPlaceableData(PlaceableData placeableData)
	{
		if (placeableData.pieceIndex == -1)
		{
			return;
		}
		EditorPiece component = pieces[placeableData.pieceIndex].GetComponent<EditorPiece>();
		if (component.placeableObject != null)
		{
			component.placeableObject.transform.localPosition = placeableData.piecePosition;
			component.placeableObject.transform.localRotation = placeableData.pieceRotation;
			if (placeableData.placementPieceIndex >= 0)
			{
				component.AddPlacementPiece(pieces[placeableData.placementPieceIndex]);
			}
		}
		else
		{
			MonoBehaviour.print("placeableData was incorrect");
		}
	}

	public void ApplyDynamicData(DynamicData dynamicData)
	{
		if (dynamicData.linkedPieceIndex != -1)
		{
			WarpNode.LinkPieces(pieces[dynamicData.pieceIndex].GetComponent<EditorPiece>(), pieces[dynamicData.linkedPieceIndex].GetComponent<EditorPiece>());
			return;
		}
		EditPoint componentInChildren = pieces[dynamicData.pieceIndex].GetComponentInChildren<EditPoint>();
		if (componentInChildren != null)
		{
			componentInChildren.transform.localPosition = dynamicData.grabPosition;
			componentInChildren.transform.rotation = dynamicData.grabRotation;
			StartCoroutine(DelayUpdateEditPoint(componentInChildren));
		}
	}

	private IEnumerator DelayUpdateEditPoint(EditPoint editPoint)
	{
		yield return null;
		editPoint.UpdateDynamicParts();
	}

	public void ClearAllPieces()
	{
		for (int i = 0; i < pieces.Count; i++)
		{
			UnityEngine.Object.Destroy(pieces[i]);
		}
		pieces.Clear();
		pieceCount = 0;
	}

	public void CenterLevel()
	{
		ResetLevelPivot();
		levelParent.position = levelSpawnLocation.position;
	}

	public void ResetLevelPivot()
	{
		if (pieces.Count > 0)
		{
			Vector3 position = default(Vector3);
			for (int i = 0; i < pieces.Count; i++)
			{
				position += pieces[i].transform.position;
			}
			position /= (float)pieces.Count;
			levelParent.DetachChildren();
			levelParent.position = position;
			for (int j = 0; j < pieces.Count; j++)
			{
				pieces[j].transform.SetParent(levelParent);
			}
			editorWind.gameObject.transform.parent = levelParent;
		}
	}

	public byte[] GetOriginBytes()
	{
		byte[] array = new byte[40];
		Buffer.BlockCopy(BitConverter.GetBytes(levelParent.position.x), 0, array, 0, 4);
		Buffer.BlockCopy(BitConverter.GetBytes(levelParent.position.y), 0, array, 4, 4);
		Buffer.BlockCopy(BitConverter.GetBytes(levelParent.position.z), 0, array, 8, 4);
		Buffer.BlockCopy(BitConverter.GetBytes(levelParent.lossyScale.x), 0, array, 12, 4);
		Buffer.BlockCopy(BitConverter.GetBytes(levelParent.lossyScale.y), 0, array, 16, 4);
		Buffer.BlockCopy(BitConverter.GetBytes(levelParent.lossyScale.z), 0, array, 20, 4);
		Buffer.BlockCopy(BitConverter.GetBytes(levelParent.rotation.x), 0, array, 24, 4);
		Buffer.BlockCopy(BitConverter.GetBytes(levelParent.rotation.y), 0, array, 28, 4);
		Buffer.BlockCopy(BitConverter.GetBytes(levelParent.rotation.z), 0, array, 32, 4);
		Buffer.BlockCopy(BitConverter.GetBytes(levelParent.rotation.w), 0, array, 36, 4);
		return array;
	}

	public byte[] GetWindBytes()
	{
		byte[] array = new byte[12];
		Buffer.BlockCopy(BitConverter.GetBytes(currentLevel.windVector.x), 0, array, 0, 4);
		Buffer.BlockCopy(BitConverter.GetBytes(currentLevel.windVector.y), 0, array, 4, 4);
		Buffer.BlockCopy(BitConverter.GetBytes(currentLevel.windVector.z), 0, array, 8, 4);
		return array;
	}

	private static void WritePieceToMemStream(Transform t, MemoryStream memStream)
	{
		int value = GameManager.Hash(t.name);
		memStream.Write(BitConverter.GetBytes(value), 0, 4);
		Vector3 localPosition = t.localPosition;
		memStream.Write(BitConverter.GetBytes(localPosition.x), 0, 4);
		memStream.Write(BitConverter.GetBytes(localPosition.y), 0, 4);
		memStream.Write(BitConverter.GetBytes(localPosition.z), 0, 4);
		Quaternion localRotation = t.localRotation;
		memStream.Write(BitConverter.GetBytes(localRotation.x), 0, 4);
		memStream.Write(BitConverter.GetBytes(localRotation.y), 0, 4);
		memStream.Write(BitConverter.GetBytes(localRotation.z), 0, 4);
		memStream.Write(BitConverter.GetBytes(localRotation.w), 0, 4);
		Vector3 localScale = t.localScale;
		memStream.Write(BitConverter.GetBytes(localScale.x), 0, 4);
		memStream.Write(BitConverter.GetBytes(localScale.y), 0, 4);
		memStream.Write(BitConverter.GetBytes(localScale.z), 0, 4);
	}

	private void CheckAndWritePlaceableDataToMemStream(EditorPiece piece, MemoryStream memStream)
	{
		if (piece.placeableObject != null)
		{
			memStream.Write(BitConverter.GetBytes((short)pieces.IndexOf(piece.gameObject)), 0, 2);
			Vector3 localPosition = piece.placeableObject.transform.localPosition;
			Quaternion localRotation = piece.placeableObject.transform.localRotation;
			memStream.Write(BitConverter.GetBytes(localPosition.x), 0, 4);
			memStream.Write(BitConverter.GetBytes(localPosition.y), 0, 4);
			memStream.Write(BitConverter.GetBytes(localPosition.z), 0, 4);
			memStream.Write(BitConverter.GetBytes(localRotation.x), 0, 4);
			memStream.Write(BitConverter.GetBytes(localRotation.y), 0, 4);
			memStream.Write(BitConverter.GetBytes(localRotation.z), 0, 4);
			memStream.Write(BitConverter.GetBytes(localRotation.w), 0, 4);
			short value = (short)pieces.IndexOf(piece.placementPiece);
			memStream.Write(BitConverter.GetBytes(value), 0, 2);
		}
	}

	private void CheckAndWriteDynamicDataToMemStream(EditorPiece piece, MemoryStream memStream)
	{
		EditPoint componentInChildren = piece.GetComponentInChildren<EditPoint>();
		EditorPiece linkedPiece = piece.linkedPiece;
		if (linkedPiece != null || componentInChildren != null)
		{
			memStream.Write(BitConverter.GetBytes((short)pieces.IndexOf(piece.gameObject)), 0, 2);
			Vector3 vector = Vector3.zero;
			Quaternion quaternion = Quaternion.identity;
			if (componentInChildren != null)
			{
				vector = componentInChildren.transform.localPosition;
				quaternion = componentInChildren.transform.rotation;
			}
			memStream.Write(BitConverter.GetBytes(vector.x), 0, 4);
			memStream.Write(BitConverter.GetBytes(vector.y), 0, 4);
			memStream.Write(BitConverter.GetBytes(vector.z), 0, 4);
			memStream.Write(BitConverter.GetBytes(quaternion.x), 0, 4);
			memStream.Write(BitConverter.GetBytes(quaternion.y), 0, 4);
			memStream.Write(BitConverter.GetBytes(quaternion.z), 0, 4);
			memStream.Write(BitConverter.GetBytes(quaternion.w), 0, 4);
			short value = -1;
			if (linkedPiece != null)
			{
				value = (short)pieces.IndexOf(linkedPiece.gameObject);
			}
			memStream.Write(BitConverter.GetBytes(value), 0, 2);
		}
	}

	private void CheckAndWriteSnapDataToMemStream(EditorPiece piece, MemoryStream memStream)
	{
		if (piece.snapPoints.Length == 0)
		{
			return;
		}
		memStream.Write(BitConverter.GetBytes((short)pieces.IndexOf(piece.gameObject)), 0, 2);
		memStream.Write(BitConverter.GetBytes((byte)piece.snapPoints.Length), 0, 1);
		for (int i = 0; i < piece.snapPoints.Length; i++)
		{
			SnapPoint snapPoint = piece.snapPoints[i];
			if (snapPoint.snappedPoint != null)
			{
				SnapPoint snappedPoint = snapPoint.snappedPoint;
				memStream.Write(BitConverter.GetBytes((short)pieces.IndexOf(snappedPoint.piece.gameObject)), 0, 2);
				memStream.Write(BitConverter.GetBytes((sbyte)Array.IndexOf(snappedPoint.piece.snapPoints, snappedPoint)), 0, 1);
			}
			else
			{
				memStream.Write(BitConverter.GetBytes((short)(-1)), 0, 2);
				memStream.Write(BitConverter.GetBytes((short)(-1)), 0, 1);
			}
		}
	}

	public LevelPiece[] GetLevelPiecesAtUnitScale()
	{
		LevelPiece[] array = new LevelPiece[pieces.Count];
		for (int i = 0; i < pieces.Count; i++)
		{
			array[i] = GameObjectToLevelPieceAtUnitScale(pieces[i], levelParent.lossyScale);
		}
		return array;
	}

	public LevelPiece GameObjectToLevelPieceAtUnitScale(GameObject go, Vector3 scale)
	{
		LevelPiece result = default(LevelPiece);
		result.nameHash = GameManager.Hash(go.name);
		Vector3 vector = new Vector3(1f / levelParent.lossyScale.x, 1f / levelParent.lossyScale.y, 1f / levelParent.lossyScale.z);
		Vector3 position = new Vector3(go.transform.localPosition.x * vector.x, go.transform.localPosition.y * vector.y, go.transform.localPosition.z * vector.z);
		result.position = position;
		result.rotation = go.transform.rotation;
		result.scale = go.transform.localScale;
		return result;
	}

	public static CustomLevelCL1 LoadCL1LevelData(string path, bool cloudlandsHole = false)
	{
		int num = 45;
		int num2 = 3;
		int num3 = 3;
		int num4 = 32;
		int num5 = 32;
		int num6 = 0;
		CustomLevelCL1 result = default(CustomLevelCL1);
		result.valid = false;
		byte[] buffer = null;
		if (cloudlandsHole)
		{
			TextAsset textAsset = Resources.LoadAll<TextAsset>("Holes/" + path)[0];
			if (textAsset != null)
			{
				buffer = textAsset.bytes;
			}
		}
		else if (File.Exists(path))
		{
			buffer = File.ReadAllBytes(path);
		}
		if (buffer != null)
		{
			if (buffer.Length < 4)
			{
				return result;
			}
			int bufferIndex = 0;
			uint num7 = kBufferUtil.ReadU32(ref buffer, ref bufferIndex);
			int num8;
			switch (num7)
			{
			case 1u:
				num8 = 95;
				break;
			case 2u:
				num8 = 101;
				break;
			default:
				MonoBehaviour.print("unsupported version number, update Cloudlands to play this level");
				return result;
			}
			if (buffer.Length < num8)
			{
				return result;
			}
			long num9 = kBufferUtil.ReadS64(ref buffer, ref bufferIndex);
			if (num9 < DateTime.MinValue.Ticks || num9 > DateTime.MaxValue.Ticks)
			{
				return result;
			}
			result.saveDate = new DateTime(num9, DateTimeKind.Utc);
			result.publishedFileId = kBufferUtil.ReadU64(ref buffer, ref bufferIndex);
			result.creatorId = kBufferUtil.ReadU64(ref buffer, ref bufferIndex);
			if (num7 == 2)
			{
				num6 = kBufferUtil.ReadS32(ref buffer, ref bufferIndex);
				result.publishedPlatform = (PublishedPlatform)kBufferUtil.ReadU16(ref buffer, ref bufferIndex);
			}
			result.completed = kBufferUtil.ReadBool(ref buffer, ref bufferIndex);
			result.published = kBufferUtil.ReadBool(ref buffer, ref bufferIndex);
			result.par = kBufferUtil.ReadU16(ref buffer, ref bufferIndex);
			result.difficulty = (Difficulty)kBufferUtil.ReadByte(ref buffer, ref bufferIndex);
			result.song = (Song)kBufferUtil.ReadU16(ref buffer, ref bufferIndex);
			result.originPosition = kBufferUtil.ReadVector3(ref buffer, ref bufferIndex);
			result.originScale = kBufferUtil.ReadVector3(ref buffer, ref bufferIndex);
			result.originRotation = kBufferUtil.ReadQuaternion(ref buffer, ref bufferIndex);
			ushort num10 = kBufferUtil.ReadU16(ref buffer, ref bufferIndex);
			int num11 = kBufferUtil.ReadU16(ref buffer, ref bufferIndex);
			int num12 = kBufferUtil.ReadS32(ref buffer, ref bufferIndex);
			ushort num13 = kBufferUtil.ReadU16(ref buffer, ref bufferIndex);
			ushort num14 = kBufferUtil.ReadU16(ref buffer, ref bufferIndex);
			int num15 = kBufferUtil.ReadS32(ref buffer, ref bufferIndex);
			int num16 = kBufferUtil.ReadS32(ref buffer, ref bufferIndex);
			int num17 = num8 + num6 + num15 + num16;
			if (buffer.Length < num17)
			{
				return result;
			}
			if (num7 == 2 && num6 > 0)
			{
				result.userIdString = kBufferUtil.ReadString(ref buffer, ref bufferIndex, num6);
			}
			result.levelName = kBufferUtil.ReadString(ref buffer, ref bufferIndex, num15);
			result.creatorName = kBufferUtil.ReadString(ref buffer, ref bufferIndex, num16);
			int num18 = num17 + num10 * num;
			if (buffer.Length < num18)
			{
				return result;
			}
			result.pieces = new LevelPieceCL1[num10];
			for (int i = 0; i < num10; i++)
			{
				result.pieces[i] = kBufferUtil.ReadCL1LevelPiece(ref buffer, ref bufferIndex);
			}
			result.valid = true;
			int num19 = num18 + num11 * num2 + num12 * num3;
			if (buffer.Length < num19)
			{
				return result;
			}
			if (num11 > 0)
			{
				result.snapPieceData = new SnapPieceData[num11];
				for (int j = 0; j < num11; j++)
				{
					result.snapPieceData[j] = kBufferUtil.ReadCL1SnapPieceData(ref buffer, ref bufferIndex);
				}
			}
			int num20 = num19 + num13 * num5;
			if (buffer.Length < num20)
			{
				return result;
			}
			if (num13 > 0)
			{
				result.placeableData = new PlaceableData[num13];
				for (int k = 0; k < num13; k++)
				{
					result.placeableData[k] = kBufferUtil.ReadPlaceableData(ref buffer, ref bufferIndex);
				}
			}
			int num21 = num20 + num14 * num4;
			if (buffer.Length < num21)
			{
				return result;
			}
			if (num14 > 0)
			{
				result.dynamicData = new DynamicDataCL1[num14];
				for (int l = 0; l < num14; l++)
				{
					result.dynamicData[l] = kBufferUtil.ReadCL1DynamicData(ref buffer, ref bufferIndex);
				}
			}
		}
		else
		{
			MonoBehaviour.print("file doesn't exist");
			if (PhotonNetwork.IsConnected)
			{
				GameManager.instance.BackToLobby();
			}
			else
			{
				GameManager.instance.BackToRoomPrepScene(clearHoleData: false);
			}
			Notification.instance.AddNotification("File was not found", 0f, closeButton: true);
		}
		return result;
	}
}
public struct CustomLevel
{
	public bool valid;

	public DateTime saveDate;

	public ulong publishedFileId;

	public PublishedPlatform publishedPlatform;

	public bool completed;

	public bool published;

	public ushort par;

	public Difficulty difficulty;

	public Song song;

	public Skybox skybox;

	public float gravity;

	public GolfClubType allowedClubs;

	public Vector3 windVector;

	public Vector3 originPosition;

	public Vector3 originScale;

	public Quaternion originRotation;

	public string levelName;

	public string creatorName;

	public string creatorId;

	public LevelPiece[] pieces;

	public SnapPieceData[] snapPieceData;

	public DynamicData[] dynamicData;

	public PlaceableData[] placeableData;
}
public struct CustomLevelCL1
{
	public bool valid;

	public DateTime saveDate;

	public ulong publishedFileId;

	public ulong creatorId;

	public string userIdString;

	public PublishedPlatform publishedPlatform;

	public bool completed;

	public bool published;

	public ushort par;

	public Difficulty difficulty;

	public Song song;

	public Vector3 originPosition;

	public Vector3 originScale;

	public Quaternion originRotation;

	public string levelName;

	public string creatorName;

	public LevelPieceCL1[] pieces;

	public SnapPieceData[] snapPieceData;

	public DynamicDataCL1[] dynamicData;

	public PlaceableData[] placeableData;
}
internal struct CustomLevelData
{
	public uint versionNumber;

	public long dateTimeTicksUTC;

	public bool completed;

	public bool published;

	public ushort par;

	public byte difficulty;

	public ushort song;

	public byte[] originBytes;

	public ushort pieceCount;

	public ushort placeableDataCount;

	public ushort dynamicDataCount;

	public int levelNameByteCount;

	public byte[] levelNameBytes;
}
public struct LevelPiece
{
	public int nameHash;

	public Vector3 position;

	public Quaternion rotation;

	public Vector3 scale;
}
public struct LevelPieceCL1
{
	public int nameHash;

	public Vector3 position;

	public Quaternion rotation;

	public Vector3 scale;

	public Season season;
}
public struct SnapData
{
	public int pieceIndex;

	public int snapPointIndex;

	public static SnapData EmptySnapData()
	{
		return new SnapData(-1, -1);
	}

	private SnapData(int pieceIndex = 0, int snapPointIndex = 0)
	{
		this.pieceIndex = pieceIndex;
		this.snapPointIndex = snapPointIndex;
	}

	public static SnapData operator +(SnapData a, SnapData b)
	{
		return new SnapData(a.pieceIndex + b.pieceIndex, a.snapPointIndex + b.snapPointIndex);
	}

	public static SnapData operator -(SnapData a, SnapData b)
	{
		return new SnapData(a.pieceIndex - b.pieceIndex, a.snapPointIndex - b.snapPointIndex);
	}
}
public struct PlaceableData
{
	public short pieceIndex;

	public Vector3 piecePosition;

	public Quaternion pieceRotation;

	public short placementPieceIndex;
}
public struct DynamicData
{
	public short pieceIndex;

	public Vector3 grabPosition;

	public Quaternion grabRotation;

	public short linkedPieceIndex;
}
public struct DynamicDataCL1
{
	public short pieceIndex;

	public Vector3 grabPosition;

	public Quaternion grabRotation;

	public short linkedPieceIndex;
}
public struct SnapPieceData
{
	public int pieceIndex;

	public SnapData[] snapData;
}
public enum StepType
{
	delete,
	create,
	move,
	grab,
	letGo,
	originMove,
	deleteLinked,
	createLinked,
	grabPointMove,
	groupMove,
	placeableMove,
	groupDelete,
	groupDuplicate,
	selectedMove,
	editPointMove,
	scale
}
public struct EditorStep
{
	public int pieceIndex;

	public int pieceHash;

	public StepType stepType;

	public Vector3 position;

	public Vector3 scale;

	public Quaternion rotation;

	public PlaceableData[] placeableData;

	public int[] groupPieces;

	public Vector3 endPosition;

	public Quaternion endRotation;

	public SnapData[][] snappedPoints;
}
public enum Skybox
{
	bluesky,
	sky2,
	sky3,
	cloudlands1Sky
}
public class LevelEditorMenu : PointerButton
{
	public delegate void ConfirmFunction();

	public Texture2D noScreenshotImage;

	public Transform windSpawnLocation;

	public Renderer handleRenderer;

	public Material handleHighlightMat;

	private Material handleOriginalMat;

	public LayerMask uiLayerMask;

	public AudioSource menuAudioSource;

	public LevelEditorTutorialManager levelEditorTutorialManager;

	[Header("Load Menu")]
	public LevelButton buttonPrefabGeneric;

	public LevelButton selectedLevelButton;

	public LevelButton currentLevelButton;

	public string currentLevelPath;

	public CustomLevel selectedLevel;

	public Transform buttonPanel;

	private int levelCount;

	public GameObject noLevelsFoundNotification;

	public GameObject loadHolePageNavigation;

	public GameObject loadButton;

	public GameObject noLevelNotification;

	public GameObject selectedLevelDetails;

	public Text selectedLevelName;

	public Text selectedCreatorName;

	public RawImage selectedScreenshot;

	public LevelButton[] loadHoleButtons;

	public int holeButtonCount;

	public int currentHoleButtonPage;

	public int holeButtonPagesCount;

	public Text pageCountText;

	public GameObject loadPageLeftButton;

	public GameObject loadPageRightButton;

	public List<string> holePaths = new List<string>();

	[Header("Side Panels")]
	public GameObject undoRedoPanel;

	public TextButton undoButton;

	public TextButton redoButton;

	public Color buttonAvailable;

	public Color buttonDisabled;

	public TextMeshPro saveStatusText;

	public Image saveStatusIcon;

	public Sprite xSprite;

	public Sprite checkSprite;

	public Image complexityBar;

	public GameObject noPieceSelectedPanel;

	public GameObject pieceSelectedPanel;

	public GameObject multipleSeletedPanel;

	public GameObject selectConnectedButton;

	public Text selectedPieceCountText;

	[Header("Pages")]
	public GameObject landingPage;

	public GameObject newLevelPage;

	public GameObject mainEditingPage;

	public GameObject piecesPage;

	public GameObject loadHolePage;

	public GameObject screenshotCameraPage;

	public GameObject levelDetailsPage;

	public GameObject finalizePage;

	public GameObject confirmPage;

	public GameObject uploadPage;

	public GameObject currentPanel;

	public GameObject returnPanel;

	public GameObject[] basicPiecePage;

	public int currentPiecePage;

	public Text piecesPageTitle;

	public GameObject pageLeftButton;

	public GameObject pageRightButton;

	public PageTab[] tabs;

	public Color tabColor;

	public Color tabHighlightColor;

	[Header("Level Details")]
	public TextButton levelNameButton;

	public TextMeshProUGUI levelName;

	public GameObject detailsPanel;

	public GameObject keyboardPanel;

	public bool capsLock;

	public Text[] alphaKeys;

	public GameObject putterDisabledIcon;

	public GameObject ironDisabledIcon;

	public GameObject driverDisabledIcon;

	public Text putterToggleText;

	public Text ironToggleText;

	public Text driverToggleText;

	public Image[] musicButtonBackground;

	public GameObject[] skyboxBackground;

	public RawImage detailsPageScreenshot;

	public EditorWind editorWind;

	public Text editScaleText;

	public Text pieceCountText;

	private bool editingTitle;

	[Header("Finalizing")]
	public GameObject finalizeDetailsPanel;

	public GameObject finalizeParPanel;

	public GameObject finalizePublishPanel;

	public Image[] difficulyButtonBackground;

	public Color defaultButtonColor;

	public Color highlightButtonColor;

	public GameObject publishPanel;

	public GameObject editingOtherPublishPanel;

	public TextMeshPro publishText;

	[Header("Confirm")]
	public TextMeshPro confirmText;

	private ConfirmFunction confirmFunction;

	[Header("Uploading")]
	public GameObject uploadingProgressPanel;

	public GameObject errorUploadingPanel;

	public Image uploadProgressBar;

	public Text uploadingText;

	public Text uploadPercentText;

	public Text uploadErrorText;

	public GameObject finishedUploadButton;

	public Text minNumberText;

	public Text maxNumberText;

	public Text parNumberText;

	public TextMeshPro levelNameText;

	public RawImage finalizePageScreenshot;

	[Header("Screenshot Camera")]
	public Camera screenshotCamera;

	public Renderer displayScreen;

	public RenderTexture lowResRenderTexture;

	private Texture2D screenShotTexture;

	private RenderTexture rt;

	private int highResWidth = 1024;

	private int highResHeight = 768;

	private Thread thread;

	private string dataPath = "";

	public GameObject lowFPSPanel;

	public bool lowFPSWarningShown;

	public bool fpsLowInFinalize;

	public GameObject lowFPSPublishPanel;

	public bool levelLoaded;

	private void OnEnable()
	{
		LocalizationManager.OnLocalizeEvent += OnLocalizationCall;
	}

	private void Start()
	{
		loadHoleButtons = new LevelButton[holeButtonCount];
		for (int i = 0; i < holeButtonCount; i++)
		{
			loadHoleButtons[i] = UnityEngine.Object.Instantiate(buttonPrefabGeneric, buttonPanel);
			loadHoleButtons[i].levelMenu = this;
		}
		string levelsPath = GameManager.instance.levelsPath;
		if (!Directory.Exists(levelsPath))
		{
			Directory.CreateDirectory(levelsPath);
		}
		DirectoryInfo[] directories = new DirectoryInfo(levelsPath).GetDirectories();
		for (int j = 0; j < directories.Length; j++)
		{
			if (directories[j].GetFiles("*.dat").Length != 0)
			{
				levelCount++;
			}
		}
		screenShotTexture = new Texture2D(highResWidth, highResHeight, TextureFormat.RGB24, mipChain: false);
		displayScreen.material.SetTexture("_MainTex", lowResRenderTexture);
		ShowDisplayScreen();
		currentPanel = landingPage;
		handleOriginalMat = handleRenderer.sharedMaterial;
	}

	public void Update()
	{
		if (editingTitle)
		{
			if ((int)(Time.time * 2f % 2f) == 0)
			{
				levelName.text = "\u200a\u2006\u2006" + LevelEditor.instance.currentLevel.levelName + "|\u2009";
			}
			else
			{
				levelName.text = LevelEditor.instance.currentLevel.levelName;
			}
		}
	}

	public void EditingUnderFrameRate()
	{
		Notification.instance.AddNotification("Low FPS detected. If the frame rate continues to be low consider spacing pieces in your level out more or removing more complex pieces.", 0f, closeButton: true);
		lowFPSPanel.SetActive(value: true);
		lowFPSWarningShown = true;
	}

	public void PreviewingUnderFrameRate()
	{
		Notification.instance.AddNotification("Low FPS detected. If the frame rate continues to be low consider spacing pieces in your level out more or removing more complex pieces.", 0f, closeButton: true);
		lowFPSPanel.SetActive(value: true);
		lowFPSWarningShown = true;
	}

	public void FinalizingUnderFramRate()
	{
		Notification.instance.AddNotification("Low FPS detected. You can continue to finalize your level but you won't be able to publish it online, to publish it online increase the performance of your level by lowering the complexity or spreading our your pieces.", 0f, closeButton: true);
		lowFPSPanel.SetActive(value: true);
		lowFPSWarningShown = true;
		fpsLowInFinalize = true;
	}

	public void ClaimLowFPSFixed()
	{
		lowFPSPanel.SetActive(value: false);
		lowFPSWarningShown = false;
		LevelEditor.instance.ResetFPSChecker();
	}

	public void GoToMainMenuScene()
	{
		GameManager.instance.pauseMenu._BackToMainMenu();
	}

	public override void Highlight()
	{
		base.Highlight();
		handleRenderer.material = handleHighlightMat;
	}

	public override void UnHighlight()
	{
		handleRenderer.material = handleOriginalMat;
	}

	public void OpenMenu(GameObject go, bool storeCurrentPanel = true)
	{
		HideAllPiecePages();
		landingPage.SetActive(value: false);
		newLevelPage.SetActive(value: false);
		mainEditingPage.SetActive(value: false);
		piecesPage.SetActive(value: false);
		loadHolePage.SetActive(value: false);
		screenshotCameraPage.SetActive(value: false);
		levelDetailsPage.SetActive(value: false);
		finalizePage.SetActive(value: false);
		uploadPage.SetActive(value: false);
		confirmPage.SetActive(value: false);
		go.SetActive(value: true);
		if (storeCurrentPanel)
		{
			currentPanel = go;
		}
		LevelEditor.instance.canEdit = true;
	}

	public void ReturnToLandingPage()
	{
		if (!LevelEditor.instance.unsavedChanges && LevelEditor.instance.screenshotSaved)
		{
			_ReturnToLandingPage();
		}
		else
		{
			OpenConfirmationMenu(LocalizationManager.GetTranslation("There are unsaved changes. Exit without saving?"), _ReturnToLandingPage);
		}
	}

	public void _ReturnToLandingPage()
	{
		EndSetWind();
		LevelEditor.instance.CloseLevel();
		LevelEditor.instance.unsavedChanges = false;
		LevelEditor.instance.screenshotSaved = true;
		LevelEditor.instance.currentScreenshotBytes = null;
		OpenMenu(landingPage);
		Player.instance.editorGrabber.selectedObjects.Clear();
		editorWind.LoadWindSpeed(Vector3.zero);
		LevelEditor.instance.ApplyLighting(0);
		GameManager.instance.audioManager.ChangeMusic(Song.levelEditor);
		undoRedoPanel.SetActive(value: false);
		noPieceSelectedPanel.SetActive(value: false);
		pieceSelectedPanel.SetActive(value: false);
		multipleSeletedPanel.SetActive(value: false);
		LevelEditor.instance.canEdit = false;
		ClaimLowFPSFixed();
		fpsLowInFinalize = false;
		levelEditorTutorialManager.OpenTutorialBoard();
		levelLoaded = false;
	}

	public void ReturnToLandingPageFromNewLevelPage()
	{
		OpenMenu(landingPage);
		levelEditorTutorialManager.OpenTutorialBoard();
	}

	public void OpenMainEditingPage()
	{
		OpenMenu(mainEditingPage);
		editScaleText.text = LevelEditor.instance.editScale.ToString();
		pieceCountText.text = LevelEditor.instance.pieceCount.ToString();
		levelEditorTutorialManager.SetTutorialStep(EditorTutorialStep.MainmenuOpenedAgain);
		levelEditorTutorialManager.SetTutorialStep(EditorTutorialStep.PublishOrNotChosen);
		EndSetWind();
	}

	public void OpenBasicPiecesPage(int pageNum)
	{
		currentPiecePage = pageNum;
		OpenMenu(piecesPage);
		piecesPageTitle.text = LocalizationManager.GetTranslation("Basic Pieces") + " " + (pageNum + 1);
		HideAllPiecePages();
		basicPiecePage[pageNum].SetActive(value: true);
		if (currentPiecePage < basicPiecePage.Length - 1)
		{
			pageRightButton.SetActive(value: true);
		}
		else
		{
			pageRightButton.SetActive(value: false);
		}
		if (currentPiecePage > 0)
		{
			pageLeftButton.SetActive(value: true);
		}
		else
		{
			pageLeftButton.SetActive(value: false);
		}
		UpdateTabs();
		levelEditorTutorialManager.SetTutorialStep(EditorTutorialStep.PiecesPageOpened);
	}

	public void UpdateTabs()
	{
		int num = 0;
		for (int i = 1; i < tabs.Length && currentPiecePage >= tabs[i].startPage; i++)
		{
			num = i;
		}
		HighlightTab(tabs[num]);
	}

	public void GoToPage(int pageNum)
	{
		currentPiecePage = pageNum;
		OpenBasicPiecesPage(currentPiecePage);
	}

	public void GoToTab(PageTab tab)
	{
		currentPiecePage = tab.startPage;
		OpenBasicPiecesPage(currentPiecePage);
	}

	public void HighlightTab(PageTab tab)
	{
		for (int i = 0; i < tabs.Length; i++)
		{
			if (tabs[i] != tab)
			{
				tabs[i].UnHighlight();
			}
		}
		tab.Highlight();
	}

	public void GoToPreviousPage()
	{
		currentPiecePage--;
		if (currentPiecePage < 0)
		{
			currentPiecePage = 0;
		}
		OpenBasicPiecesPage(currentPiecePage);
	}

	public void GoToNextPage()
	{
		currentPiecePage++;
		if (currentPiecePage >= basicPiecePage.Length)
		{
			currentPiecePage = basicPiecePage.Length - 1;
		}
		OpenBasicPiecesPage(currentPiecePage);
	}

	public void NextHoleButtonPage()
	{
		currentHoleButtonPage++;
		if (currentHoleButtonPage < holeButtonPagesCount)
		{
			OpenLoadHoleButtonPage(currentHoleButtonPage);
			loadPageLeftButton.SetActive(value: true);
			if (currentHoleButtonPage + 1 < holeButtonPagesCount)
			{
				loadPageRightButton.SetActive(value: true);
			}
			else
			{
				loadPageRightButton.SetActive(value: false);
			}
			pageCountText.text = currentHoleButtonPage + 1 + "/" + holeButtonPagesCount;
		}
		else
		{
			currentHoleButtonPage--;
		}
	}

	public void PreviousHoleButtonPage()
	{
		if (currentHoleButtonPage > 0)
		{
			currentHoleButtonPage--;
			OpenLoadHoleButtonPage(currentHoleButtonPage);
			loadPageRightButton.SetActive(value: true);
			if (currentHoleButtonPage == 0)
			{
				loadPageLeftButton.SetActive(value: false);
			}
			else
			{
				loadPageLeftButton.SetActive(value: true);
			}
			pageCountText.text = currentHoleButtonPage + 1 + "/" + holeButtonPagesCount;
		}
	}

	public void HideAllPiecePages()
	{
		for (int i = 0; i < basicPiecePage.Length; i++)
		{
			basicPiecePage[i].SetActive(value: false);
		}
	}

	private void ThreadedLoadingHoles()
	{
		List<FileInfo> list = new List<FileInfo>();
		DirectoryInfo[] directories = new DirectoryInfo(GameManager.instance.levelsPath).GetDirectories();
		for (int i = 0; i < directories.Length; i++)
		{
			FileInfo[] files = directories[i].GetFiles("*.dat");
			if (files.Length == 0)
			{
				continue;
			}
			bool flag = false;
			for (int j = 0; j < list.Count; j++)
			{
				if (files[0].LastWriteTime >= list[j].LastWriteTime)
				{
					list.Insert(j, files[0]);
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				list.Add(files[0]);
			}
		}
		for (int k = 0; k < list.Count; k++)
		{
			holePaths.Add(Path.GetDirectoryName(list[k].FullName) + "/");
		}
		MonoBehaviour.print("Finished loading threaded holes");
		thread.Abort();
		thread = null;
	}

	private IEnumerator _OpenLoadHolePage()
	{
		holePaths.Clear();
		if (thread != null)
		{
			thread.Abort();
			thread = null;
		}
		thread = new Thread(ThreadedLoadingHoles);
		thread.Start();
		while (thread.IsAlive)
		{
			yield return null;
		}
		currentHoleButtonPage = 0;
		if (holePaths.Count == 0)
		{
			noLevelsFoundNotification.SetActive(value: true);
			buttonPanel.gameObject.SetActive(value: false);
			loadHolePageNavigation.SetActive(value: false);
		}
		else
		{
			buttonPanel.gameObject.SetActive(value: true);
			loadHolePageNavigation.SetActive(value: true);
			holeButtonPagesCount = Mathf.CeilToInt((float)holePaths.Count / (float)loadHoleButtons.Length);
			loadPageLeftButton.SetActive(value: false);
			if (holeButtonPagesCount > 1)
			{
				loadPageRightButton.SetActive(value: true);
			}
			else
			{
				loadPageRightButton.SetActive(value: false);
			}
			noLevelsFoundNotification.SetActive(value: false);
			OpenLoadHoleButtonPage(currentHoleButtonPage);
			pageCountText.text = "1/" + holeButtonPagesCount;
		}
		noLevelNotification.SetActive(value: true);
		selectedLevelDetails.SetActive(value: false);
		selectedLevelButton = null;
		OpenMenu(loadHolePage);
		if (!levelEditorTutorialManager.inTutorial)
		{
			levelEditorTutorialManager.CloseTutorialBoard();
		}
	}

	public void OpenLoadHolePage()
	{
		StartCoroutine(_OpenLoadHolePage());
	}

	public void OpenLoadHoleButtonPage(int x)
	{
		for (int i = 0; i < loadHoleButtons.Length; i++)
		{
			int num = i + x * loadHoleButtons.Length;
			if (num < holePaths.Count)
			{
				loadHoleButtons[i].path = holePaths[num];
				FillButtonDetails(loadHoleButtons[i]);
				loadHoleButtons[i].gameObject.SetActive(value: true);
			}
			else
			{
				loadHoleButtons[i].gameObject.SetActive(value: false);
			}
		}
	}

	public void GrabMenu()
	{
		if (Physics.Raycast(Player.instance.currentController.pointer.pointerLine.transform.position, Player.instance.currentController.pointer.transform.right, out var hitInfo, float.PositiveInfinity, uiLayerMask))
		{
			Vector3 vector = base.transform.position - hitInfo.point;
			base.transform.position = Player.instance.editorGrabber.transform.position + vector;
		}
		else
		{
			MonoBehaviour.print("not hit");
		}
		Player.instance.editorGrabber.GrabMenu();
	}

	public void IncreaseEditScale(float val)
	{
		float num = LevelEditor.instance.editScale + val;
		if (num < LevelEditor.instance.minEditScale)
		{
			num = LevelEditor.instance.minEditScale;
		}
		if (num > LevelEditor.instance.maxEditScale)
		{
			num = LevelEditor.instance.maxEditScale;
		}
		LevelEditor.instance.editScale = num;
		LevelEditor.instance.ResetLevelPivot();
		LevelEditor.instance.levelParent.localScale = LevelEditor.instance.pieceScaleV3 * LevelEditor.instance.editScale;
		editScaleText.text = num.ToString();
	}

	public void SetEditScale(float newScale)
	{
		if (newScale < LevelEditor.instance.minEditScale)
		{
			newScale = LevelEditor.instance.minEditScale;
		}
		if (newScale > LevelEditor.instance.maxEditScale)
		{
			newScale = LevelEditor.instance.maxEditScale;
		}
		LevelEditor.instance.editScale = newScale;
		LevelEditor.instance.ResetLevelPivot();
		LevelEditor.instance.levelParent.localScale = LevelEditor.instance.pieceScaleV3 * LevelEditor.instance.editScale;
		editScaleText.text = newScale.ToString();
	}

	public void OpenScreenshotCameraPage()
	{
		returnPanel = currentPanel;
		OpenMenu(screenshotCameraPage);
	}

	public void ReturnFromScreenshotPage()
	{
		if (LevelEditor.instance.currentScreenshotBytes != null && LevelEditor.instance.currentScreenshotBytes.Length != 0)
		{
			Texture2D texture2D = new Texture2D(highResWidth, highResHeight);
			texture2D.LoadImage(LevelEditor.instance.currentScreenshotBytes);
			texture2D.Apply(updateMipmaps: false, makeNoLongerReadable: true);
			detailsPageScreenshot.texture = texture2D;
			finalizePageScreenshot.texture = texture2D;
		}
		else
		{
			detailsPageScreenshot.texture = noScreenshotImage;
			finalizePageScreenshot.texture = noScreenshotImage;
		}
		OpenMenu(returnPanel);
		returnPanel = null;
	}

	public void OpenNewLevelPage()
	{
		OpenMenu(newLevelPage);
		if (levelEditorTutorialManager.inTutorial)
		{
			levelEditorTutorialManager.SetTutorialStep(EditorTutorialStep.NewPressed);
		}
		else
		{
			levelEditorTutorialManager.CloseTutorialBoard();
		}
	}

	public void OpenLevelDetailsPage()
	{
		OpenMenu(levelDetailsPage);
		CustomLevel currentLevel = LevelEditor.instance.currentLevel;
		if (string.IsNullOrEmpty(currentLevel.levelName))
		{
			levelName.color = Color.gray;
			levelNameButton.unhighlightColor = Color.gray;
			levelName.text = LocalizationManager.GetTranslation("Untitled");
		}
		else
		{
			levelName.text = currentLevel.levelName;
		}
		if (LevelEditor.instance.currentScreenshotBytes != null && LevelEditor.instance.currentScreenshotBytes.Length != 0)
		{
			Texture2D texture2D = new Texture2D(highResWidth, highResHeight);
			texture2D.LoadImage(LevelEditor.instance.currentScreenshotBytes);
			texture2D.Apply(updateMipmaps: false, makeNoLongerReadable: true);
			detailsPageScreenshot.texture = texture2D;
		}
		else
		{
			detailsPageScreenshot.texture = noScreenshotImage;
		}
		if ((currentLevel.allowedClubs & GolfClubType.Putter) == GolfClubType.Putter)
		{
			putterDisabledIcon.SetActive(value: false);
		}
		else
		{
			putterDisabledIcon.SetActive(value: true);
		}
		if ((currentLevel.allowedClubs & GolfClubType.Iron) == GolfClubType.Iron)
		{
			ironDisabledIcon.SetActive(value: false);
		}
		else
		{
			ironDisabledIcon.SetActive(value: true);
		}
		if ((currentLevel.allowedClubs & GolfClubType.Driver) == GolfClubType.Driver)
		{
			driverDisabledIcon.SetActive(value: false);
		}
		else
		{
			driverDisabledIcon.SetActive(value: true);
		}
		SetSong((int)currentLevel.song, changeSong: false);
		SetSkybox((int)currentLevel.skybox);
		levelEditorTutorialManager.SetTutorialStep(EditorTutorialStep.DetailsOpened);
	}

	public void OpenFinalizeMenu()
	{
		OpenMenu(finalizePage);
		finalizeDetailsPanel.SetActive(value: true);
		finalizeParPanel.SetActive(value: false);
		finalizePublishPanel.SetActive(value: false);
		if (string.IsNullOrEmpty(LevelEditor.instance.currentLevel.levelName))
		{
			levelNameText.text = LocalizationManager.GetTranslation("Untitled");
		}
		else
		{
			levelNameText.text = LevelEditor.instance.currentLevel.levelName;
		}
		if (LevelEditor.instance.currentScreenshotBytes != null && LevelEditor.instance.currentScreenshotBytes.Length != 0)
		{
			Texture2D texture2D = new Texture2D(highResWidth, highResHeight);
			texture2D.LoadImage(LevelEditor.instance.currentScreenshotBytes);
			texture2D.Apply(updateMipmaps: false, makeNoLongerReadable: true);
			finalizePageScreenshot.texture = texture2D;
		}
		else
		{
			finalizePageScreenshot.texture = noScreenshotImage;
		}
		levelEditorTutorialManager.SetTutorialStep(EditorTutorialStep.FinalizeOpened);
	}

	public void OpenConfirmationMenu(string confirmMessage, ConfirmFunction cFunc)
	{
		confirmText.text = confirmMessage;
		confirmFunction = cFunc;
		OpenMenu(confirmPage, storeCurrentPanel: false);
	}

	public void Confirm()
	{
		confirmFunction();
	}

	public void Unconfirm()
	{
		ReturnToLastPage();
	}

	public void ReturnToLastPage()
	{
		OpenMenu(currentPanel);
	}

	public void RecenterLevel()
	{
		LevelEditor.instance.CenterLevel();
	}

	public string GetAndCreateNewLevelPath()
	{
		string text = GameManager.instance.levelsPath + levelCount + "/";
		while (Directory.Exists(text))
		{
			levelCount++;
			text = GameManager.instance.levelsPath + levelCount + "/";
		}
		Directory.CreateDirectory(text);
		return text;
	}

	private void AddButton(string filePath)
	{
		LevelButton newButton = UnityEngine.Object.Instantiate(buttonPrefabGeneric, buttonPanel);
		newButton.levelMenu = this;
		newButton.path = Path.GetDirectoryName(filePath) + "/";
		FillButtonDetails(newButton);
		newButton.GetComponent<PointerButton>().onClickEvent.AddListener(delegate
		{
			SelectLevel(newButton);
		});
	}

	public string MakeNewLevel()
	{
		int num = Directory.GetDirectories(GameManager.instance.levelsPath).Length;
		string text = GameManager.instance.levelsPath + num + "/";
		while (Directory.Exists(text))
		{
			string levelsPath = GameManager.instance.levelsPath;
			int num2 = ++num;
			text = levelsPath + num2 + "/";
		}
		return text;
	}

	public void FillButtonDetails(LevelButton lb)
	{
		lb.onClickEvent.RemoveAllListeners();
		FileInfo[] files = new DirectoryInfo(lb.path).GetFiles("*.jpg");
		if (files.Length != 0)
		{
			lb.screenshotBytes = File.ReadAllBytes(files[0].FullName);
		}
		else
		{
			lb.screenshotBytes = null;
		}
		FileInfo[] files2 = new DirectoryInfo(lb.path).GetFiles("*.dat");
		if (files2.Length != 0 && File.Exists(files2[0].FullName))
		{
			lb.levelData = LevelEditor.LoadLevelData(files2[0].FullName);
			if (lb.levelData.valid)
			{
				lb.levelName.text = lb.levelData.levelName;
				lb.creatorName.text = LocalizationManager.GetTranslation("By:") + " " + lb.levelData.creatorName;
				if (lb.levelData.completed)
				{
					lb.finalizeIcon.gameObject.SetActive(value: true);
				}
				else
				{
					lb.finalizeIcon.gameObject.SetActive(value: false);
				}
				if (lb.levelData.published)
				{
					lb.uploadedIcon.gameObject.SetActive(value: true);
				}
				else
				{
					lb.uploadedIcon.gameObject.SetActive(value: false);
				}
			}
			else
			{
				lb.levelName.text = LocalizationManager.GetTranslation("Invalid Level");
				lb.creatorName.text = "";
				lb.finalizeIcon.gameObject.SetActive(value: false);
				lb.uploadedIcon.gameObject.SetActive(value: false);
			}
			lb.onClickEvent.AddListener(delegate
			{
				SelectLevel(lb);
			});
			if (lb.screenshotBytes != null && lb.screenshotBytes.Length != 0)
			{
				Texture2D texture2D = new Texture2D(0, 0);
				texture2D.LoadImage(lb.screenshotBytes);
				texture2D.Apply(updateMipmaps: false, makeNoLongerReadable: true);
				lb.levelScreenshot.texture = texture2D;
			}
			else
			{
				lb.levelScreenshot.texture = noScreenshotImage;
			}
		}
		else
		{
			MonoBehaviour.print("Tried to add a level with a file that doesn't exist");
		}
	}

	public void SelectLevel(LevelButton lb)
	{
		selectedLevel = default(CustomLevel);
		FileInfo[] files = new DirectoryInfo(lb.path).GetFiles("*.dat");
		if (files.Length != 0)
		{
			selectedLevel = LevelEditor.LoadLevelData(files[0].FullName);
		}
		if (selectedLevel.valid)
		{
			selectedLevelButton = lb;
			selectedLevelName.text = selectedLevel.levelName;
			selectedCreatorName.text = selectedLevel.creatorName;
			selectedScreenshot.texture = selectedLevelButton.levelScreenshot.texture;
			loadButton.SetActive(value: true);
		}
		else
		{
			selectedLevelButton = lb;
			selectedLevelName.text = LocalizationManager.GetTranslation("Invalid");
			loadButton.SetActive(value: false);
		}
		noLevelNotification.SetActive(value: false);
		selectedLevelDetails.SetActive(value: true);
	}

	public void LoadSelectedLevel()
	{
		if (selectedLevel.valid)
		{
			if (selectedLevel.creatorId == RemoteServerManager.instance.playerID || string.IsNullOrEmpty(selectedLevel.creatorId))
			{
				_LoadSelectedLevel();
			}
			else
			{
				OpenConfirmationMenu(string.Format(LocalizationManager.GetTranslation("{0} is a published hole from another player. You will be able to edit it but you won't be able to publish it online. Continue?"), selectedLevel.levelName), _LoadSelectedLevel);
			}
		}
		else
		{
			MonoBehaviour.print("Could not load the level because it is corrupted");
		}
	}

	public void _LoadSelectedLevel()
	{
		if (selectedLevelButton.screenshotBytes != null)
		{
			LevelEditor.instance.currentScreenshotBytes = selectedLevelButton.screenshotBytes;
		}
		else
		{
			LevelEditor.instance.currentScreenshotBytes = null;
		}
		currentLevelPath = selectedLevelButton.path;
		LevelEditor.instance.LoadLevel(selectedLevel);
		OpenMainEditingPage();
		undoRedoPanel.SetActive(value: true);
		noPieceSelectedPanel.SetActive(value: true);
		levelLoaded = true;
	}

	public void DeleteSelectedLevel()
	{
		OpenConfirmationMenu(LocalizationManager.GetTranslation("Delete Hole") + ":" + selectedLevelButton.levelName.text + "?", _DeleteSelectLevel);
	}

	public void _DeleteSelectLevel()
	{
		if (Directory.Exists(selectedLevelButton.path))
		{
			string text = new DirectoryInfo(selectedLevelButton.path).Parent.FullName.TrimEnd('\\');
			string value = new DirectoryInfo(GameManager.instance.levelsPath).FullName.TrimEnd('\\');
			string value2 = new DirectoryInfo(UnityEngine.Application.persistentDataPath + "/Downloads/").FullName.TrimEnd('\\');
			if (text.Equals(value) || text.Equals(value2))
			{
				Directory.Delete(selectedLevelButton.path, recursive: true);
				int index = holePaths.IndexOf(selectedLevelButton.path);
				holePaths.RemoveAt(index);
				if (holePaths.Count == 0)
				{
					noLevelsFoundNotification.SetActive(value: true);
				}
				else
				{
					noLevelsFoundNotification.SetActive(value: false);
					holeButtonPagesCount = Mathf.CeilToInt((float)holePaths.Count / (float)loadHoleButtons.Length);
					if (currentHoleButtonPage > holeButtonPagesCount - 1)
					{
						currentHoleButtonPage--;
					}
					OpenLoadHoleButtonPage(currentHoleButtonPage);
					pageCountText.text = currentHoleButtonPage + 1 + "/" + holeButtonPagesCount;
					if (currentHoleButtonPage == 0)
					{
						loadPageLeftButton.SetActive(value: false);
					}
					else
					{
						loadPageLeftButton.SetActive(value: true);
					}
					if (currentHoleButtonPage == holeButtonPagesCount - 1)
					{
						loadPageRightButton.SetActive(value: false);
					}
					else
					{
						loadPageRightButton.SetActive(value: true);
					}
				}
			}
		}
		ReturnToLastPage();
	}

	public void SaveCurrentLevel()
	{
		if (string.IsNullOrEmpty(LevelEditor.instance.currentLevel.levelName))
		{
			Notification.instance.AddNotification("You must give the level a title to be able to save");
			OpenLevelDetailsPage();
			OpenKeyboard();
		}
		else if (LevelEditor.instance.currentLevel.completed)
		{
			OpenConfirmationMenu(LocalizationManager.GetTranslation("You must re-finalize to make the hole playable again. Proceed with saving?"), SetUnfinalizedAndSave);
		}
		else
		{
			_SaveCurrentLevel();
		}
	}

	public void _SaveCurrentLevel()
	{
		if (!string.IsNullOrEmpty(currentLevelPath))
		{
			LevelEditor.instance.SaveLevel(currentLevelPath);
			return;
		}
		currentLevelPath = MakeNewLevel();
		LevelEditor.instance.SaveLevel(currentLevelPath);
	}

	public void SetUnfinalizedAndSave()
	{
		LevelEditor.instance.currentLevel.completed = false;
		SaveCurrentLevel();
		ReturnToLastPage();
	}

	public void NewMinigolfHole()
	{
		NewLevel(minigolf: true);
	}

	public void NewPnPHole()
	{
		NewLevel(minigolf: false);
	}

	public void NewLevel(bool minigolf)
	{
		if (!LevelEditor.instance.unsavedChanges)
		{
			currentLevelPath = MakeNewLevel();
			LevelEditor.instance.NewLevel();
			if (minigolf)
			{
				SetEditScale(3f);
				LevelEditor.instance.currentLevel.allowedClubs = GolfClubType.Putter;
			}
			else
			{
				SetEditScale(1f);
				editorWind.LoadWindSpeed(new Vector3(1000f, 1000f, 5f));
			}
			OpenMainEditingPage();
			undoRedoPanel.SetActive(value: true);
			noPieceSelectedPanel.SetActive(value: true);
			levelEditorTutorialManager.SetTutorialStep(EditorTutorialStep.HoleTypeSelected);
			levelLoaded = true;
		}
		else
		{
			MonoBehaviour.print("there are unsaved changes to the current level");
		}
	}

	public void SetSong(int song)
	{
		SetSong(song, changeSong: true);
	}

	public void SetSong(int song, bool changeSong = true)
	{
		if (changeSong)
		{
			LevelEditor.instance.SetSong((Song)song);
		}
		int num = song - 7;
		for (int i = 0; i < musicButtonBackground.Length; i++)
		{
			if (i == num)
			{
				musicButtonBackground[i].color = highlightButtonColor;
			}
			else
			{
				musicButtonBackground[i].color = defaultButtonColor;
			}
		}
	}

	public void SetSkybox(int skybox)
	{
		LevelEditor.instance.SetSkybox((Skybox)skybox);
		for (int i = 0; i < skyboxBackground.Length; i++)
		{
			if (i == skybox)
			{
				skyboxBackground[i].SetActive(value: true);
			}
			else
			{
				skyboxBackground[i].SetActive(value: false);
			}
		}
	}

	public void UpdateComplexityBar()
	{
		float num = LevelEditor.instance.currentComplexity / LevelEditor.instance.complexityLimit;
		if (num > 1f)
		{
			num = 1f;
		}
		Color color = Color.Lerp(Color.green, Color.red, num);
		complexityBar.transform.localScale = new Vector3(num, 1f, 1f);
		complexityBar.color = color;
	}

	public void ToggleClubAllowed(int club)
	{
		_ = LevelEditor.instance.currentLevel;
		if (((uint)LevelEditor.instance.currentLevel.allowedClubs ^ (uint)club) == 0)
		{
			menuAudioSource.clip = GameManager.instance.audioManager.blockedSfx;
			menuAudioSource.Play();
			return;
		}
		LevelEditor.instance.currentLevel.allowedClubs ^= (GolfClubType)club;
		switch (club)
		{
		case 1:
			if ((LevelEditor.instance.currentLevel.allowedClubs & GolfClubType.Putter) == GolfClubType.Putter)
			{
				putterDisabledIcon.SetActive(value: false);
			}
			else
			{
				putterDisabledIcon.SetActive(value: true);
			}
			break;
		case 2:
			if ((LevelEditor.instance.currentLevel.allowedClubs & GolfClubType.Iron) == GolfClubType.Iron)
			{
				ironDisabledIcon.SetActive(value: false);
			}
			else
			{
				ironDisabledIcon.SetActive(value: true);
			}
			break;
		case 4:
			if ((LevelEditor.instance.currentLevel.allowedClubs & GolfClubType.Driver) == GolfClubType.Driver)
			{
				driverDisabledIcon.SetActive(value: false);
			}
			else
			{
				driverDisabledIcon.SetActive(value: true);
			}
			break;
		}
	}

	public void ShowDisplayScreen()
	{
		displayScreen.material.SetTexture("_MainTex", lowResRenderTexture);
	}

	public void TakeScreenShot()
	{
		StartCoroutine(TakeScreenShotRoutine());
	}

	public void SetScreenShotCameraActive(bool b)
	{
		if (b)
		{
			ShowDisplayScreen();
		}
		else
		{
			TurnOffScreenshotCamera();
		}
	}

	public void TurnOffScreenshotCamera()
	{
	}

	private IEnumerator TakeScreenShotRoutine()
	{
		rt = new RenderTexture(highResWidth, highResHeight, 24);
		rt.antiAliasing = 4;
		screenshotCamera.targetTexture = rt;
		yield return null;
		RenderTexture.active = rt;
		screenShotTexture.ReadPixels(new Rect(0f, 0f, highResWidth, highResHeight), 0, 0);
		RenderTexture.active = null;
		UnityEngine.Object.Destroy(rt);
		byte[] currentScreenshotBytes = screenShotTexture.EncodeToJPG(75);
		screenshotCamera.targetTexture = lowResRenderTexture;
		LevelEditor.instance.currentScreenshotBytes = currentScreenshotBytes;
		LevelEditor.instance.screenshotSaved = false;
		SetScreenShotCameraActive(b: false);
		menuAudioSource.clip = GameManager.instance.audioManager.screenshotSnap;
		menuAudioSource.Play();
	}

	public void TogglePreview()
	{
		if (LevelEditor.instance.CheckCanPreview())
		{
			Player.instance.editorGrabber.PrepareForPreview();
			LevelEditor.instance.TogglePreview();
		}
	}

	public void StartFinalizePlaythrough()
	{
		if (string.IsNullOrEmpty(LevelEditor.instance.currentLevel.levelName))
		{
			Notification.instance.AddNotification("You must give the level a title to be able to finalize");
			OpenLevelDetailsPage();
			OpenKeyboard();
		}
		else if (LevelEditor.instance.CheckCanFinalize())
		{
			LevelEditor.instance.canEdit = true;
			LevelEditor.instance.finalizing = true;
			LevelEditor.instance.TogglePreview();
			ClaimLowFPSFixed();
			fpsLowInFinalize = false;
		}
	}

	public void DeselectPieces()
	{
		Player.instance.editorGrabber.ClearSelected();
		noPieceSelectedPanel.SetActive(value: true);
		pieceSelectedPanel.SetActive(value: false);
		multipleSeletedPanel.SetActive(value: false);
	}

	public void SelectAllConnectedPieces()
	{
		if (Player.instance.editorGrabber.selectedObjects.Count != 1)
		{
			return;
		}
		List<GameObject> list = new List<GameObject>();
		list.Add(Player.instance.editorGrabber.selectedObjects[0]);
		int i = 0;
		if (list[0].GetComponent<EditorPiece>().placementPiece != null)
		{
			list.Add(list[0].GetComponent<EditorPiece>().placementPiece);
			i++;
		}
		for (; i < list.Count; i++)
		{
			List<GameObject> allConnectedPieces = list[i].GetComponent<EditorPiece>().GetAllConnectedPieces();
			for (int j = 0; j < allConnectedPieces.Count; j++)
			{
				if (!list.Contains(allConnectedPieces[j]))
				{
					list.Add(allConnectedPieces[j]);
				}
			}
		}
		for (int k = 0; k < list.Count; k++)
		{
			if (!Player.instance.editorGrabber.selectedObjects.Contains(list[k]))
			{
				Player.instance.editorGrabber.selectedObjects.Add(list[k]);
				if ((bool)list[k].GetComponent<EditorPiece>())
				{
					list[k].GetComponent<EditorPiece>().SelectHighlight();
				}
			}
		}
		if (Player.instance.editorGrabber.selectedObjects.Count > 1)
		{
			selectedPieceCountText.text = Player.instance.editorGrabber.selectedObjects.Count.ToString();
			noPieceSelectedPanel.SetActive(value: false);
			pieceSelectedPanel.SetActive(value: false);
			multipleSeletedPanel.SetActive(value: true);
		}
	}

	public void ToggleFairwayDraw()
	{
		Player.instance.editorGrabber.ToggleFairwayEdit();
	}

	public void SetDifficulty(int d)
	{
		LevelEditor.instance.currentLevel.difficulty = (Difficulty)d;
		for (int i = 0; i < difficulyButtonBackground.Length; i++)
		{
			if (i == d)
			{
				difficulyButtonBackground[i].color = highlightButtonColor;
			}
			else
			{
				difficulyButtonBackground[i].color = defaultButtonColor;
			}
		}
	}

	public void StartSetWind()
	{
		editorWind.ShowWindControl();
		float num = 1f / LevelEditor.instance.levelParent.lossyScale.x;
		if (LevelEditor.instance.levelParent.lossyScale.x != 0f)
		{
			editorWind.gameObject.transform.localScale = LevelEditor.instance.levelParent.lossyScale * num * num;
		}
		editorWind.gameObject.transform.position = windSpawnLocation.position;
		Player.instance.editorGrabber.editingWind = true;
		levelEditorTutorialManager.SetTutorialStep(EditorTutorialStep.SetWindOpened);
	}

	public void EndSetWind()
	{
		editorWind.HideWindControls();
		Player.instance.editorGrabber.editingWind = false;
		SetWindVector(LevelEditor.instance.randomWind);
	}

	public void SetWindVector(bool randomWind = false)
	{
		if (randomWind)
		{
			Vector3 windVector = new Vector3(1000f, 1000f, editorWind.currentSpeed);
			LevelEditor.instance.currentLevel.windVector = windVector;
		}
		else
		{
			Vector3 windVector = editorWind.gameObject.transform.forward;
			windVector *= (float)editorWind.currentSpeed;
			LevelEditor.instance.currentLevel.windVector = LevelEditor.instance.levelParent.InverseTransformDirection(windVector);
		}
	}

	public void SetPar()
	{
		OpenFinalizeMenu();
		finalizeDetailsPanel.SetActive(value: false);
		finalizeParPanel.SetActive(value: true);
		finalizePublishPanel.SetActive(value: false);
		int currentStrokeCount = ScoreManager.instance.currentStrokeCount;
		float num = (((float)currentStrokeCount * 0.2f < 3f) ? 3f : ((float)currentStrokeCount * 0.2f));
		parNumberText.text = currentStrokeCount.ToString();
		if (currentStrokeCount == 0)
		{
			minNumberText.text = "0";
		}
		else if (currentStrokeCount - (int)num <= 0)
		{
			minNumberText.text = "1";
		}
		else
		{
			minNumberText.text = (currentStrokeCount - (int)num).ToString();
		}
		if ((float)currentStrokeCount + num > 99f)
		{
			maxNumberText.text = "99";
		}
		else
		{
			maxNumberText.text = (currentStrokeCount + (int)num).ToString();
		}
		if (LevelEditor.instance.previewing)
		{
			LevelEditor.instance.TogglePreview();
		}
		LevelEditor.instance.canEdit = false;
		SetDifficulty((int)LevelEditor.instance.currentLevel.difficulty);
		levelEditorTutorialManager.SetTutorialStep(EditorTutorialStep.SetParOpened);
	}

	public void IncreasePar()
	{
		int num = int.Parse(parNumberText.text);
		if (num < int.Parse(maxNumberText.text))
		{
			Text text = parNumberText;
			int num2 = ++num;
			text.text = num2.ToString();
		}
	}

	public void DecreasePar()
	{
		int num = int.Parse(parNumberText.text);
		if (num > int.Parse(minNumberText.text))
		{
			Text text = parNumberText;
			int num2 = --num;
			text.text = num2.ToString();
		}
	}

	public void ConfirmPar()
	{
		LevelEditor.instance.currentLevel.par = ushort.Parse(parNumberText.text);
		LevelEditor.instance.currentLevel.completed = true;
		LevelEditor.instance.SaveLevel(currentLevelPath);
		finalizeParPanel.SetActive(value: false);
		finalizePublishPanel.SetActive(value: true);
		if (LevelEditor.instance.editingOtherCreator)
		{
			publishPanel.SetActive(value: false);
			editingOtherPublishPanel.SetActive(value: true);
			lowFPSPublishPanel.SetActive(value: false);
		}
		else if (fpsLowInFinalize)
		{
			publishPanel.SetActive(value: false);
			editingOtherPublishPanel.SetActive(value: false);
			lowFPSPublishPanel.SetActive(value: true);
		}
		else
		{
			if (LevelEditor.instance.currentLevel.published)
			{
				publishText.text = LocalizationManager.GetTranslation("Your level is finalized. This level has previously been uploaded, would you like to update the uploaded level?");
			}
			else
			{
				publishText.text = LocalizationManager.GetTranslation("Your level is finalized. Would you like to also publish the level online?");
			}
			publishPanel.SetActive(value: true);
			editingOtherPublishPanel.SetActive(value: false);
			lowFPSPublishPanel.SetActive(value: false);
			levelEditorTutorialManager.SetTutorialStep(EditorTutorialStep.PublishOpened);
		}
		GameManager.instance.gameAchievements.UnlockAchievement(Achievement.CREATE_EDITOR_HOLE);
	}

	public void OpenPublishOnlinePanel()
	{
		finalizePage.SetActive(value: false);
		errorUploadingPanel.SetActive(value: false);
		uploadPage.SetActive(value: true);
		if (string.IsNullOrEmpty(RemoteServerManager.instance.playerID))
		{
			UploadErrorMessage("You must be logged in to upload.");
			return;
		}
		if (RemoteServerManager.instance.IsBadWord(LevelEditor.instance.currentLevel.levelName) || RemoteServerManager.instance.IsBadWord(RemoteServerManager.instance.playerUserName))
		{
			UploadErrorMessage("Your hole name or user name must not contain a bad word.");
			return;
		}
		uploadingText.text = LocalizationManager.GetTranslation("Uploading");
		uploadingProgressPanel.SetActive(value: true);
		StartCoroutine(RemoteServerManager.instance.UploadHole(currentLevelPath));
		StartCoroutine(GetUploadStatus());
	}

	private IEnumerator GetUploadStatus()
	{
		finishedUploadButton.SetActive(value: false);
		uploadPercentText.text = "0%";
		uploadProgressBar.transform.localScale = new Vector3(0f, 1f, 1f);
		uploadProgressBar.transform.localScale = new Vector3(RemoteServerManager.instance.uploadProgress, 1f, 1f);
		while (RemoteServerManager.instance.uploadProgress < 0f)
		{
			if (uploadingProgressPanel.activeSelf)
			{
				uploadPercentText.text = RemoteServerManager.instance.uploadProgress + "%";
				yield return null;
				continue;
			}
			yield break;
		}
		RemoteServerManager.instance.uploadProgress = 0f;
		uploadPercentText.text = "100%";
		uploadingText.text = LocalizationManager.GetTranslation("Uploaded");
		uploadProgressBar.transform.localScale = new Vector3(1f, 1f, 1f);
		finishedUploadButton.SetActive(value: true);
	}

	public void UploadErrorMessage(string msg)
	{
		uploadingProgressPanel.SetActive(value: false);
		errorUploadingPanel.SetActive(value: true);
		uploadErrorText.text = LocalizationManager.GetTranslation(msg);
		finishedUploadButton.SetActive(value: true);
	}

	public void Undo()
	{
		LevelEditor.instance.Undo();
	}

	public void Redo()
	{
		LevelEditor.instance.Redo();
	}

	public void SetSaveStatus(bool saved)
	{
		if (saved)
		{
			saveStatusText.text = LocalizationManager.GetTranslation("Saved");
			saveStatusText.color = Color.green;
			saveStatusIcon.sprite = checkSprite;
			saveStatusIcon.color = Color.green;
		}
		else
		{
			saveStatusText.text = LocalizationManager.GetTranslation("Not Saved");
			saveStatusText.color = Color.red;
			saveStatusIcon.sprite = xSprite;
			saveStatusIcon.color = Color.red;
		}
	}

	public void OpenKeyboard()
	{
		keyboardPanel.SetActive(value: true);
		detailsPanel.SetActive(value: false);
		editingTitle = true;
		levelName.color = Color.white;
		levelNameButton.unhighlightColor = Color.white;
	}

	public void CloseKeyboard()
	{
		keyboardPanel.SetActive(value: false);
		detailsPanel.SetActive(value: true);
		editingTitle = false;
		if (string.IsNullOrEmpty(LevelEditor.instance.currentLevel.levelName))
		{
			levelName.color = Color.gray;
			levelNameButton.unhighlightColor = Color.gray;
			levelName.text = LocalizationManager.GetTranslation("Untitled");
		}
	}

	public void EnterKeyboardInput(string input)
	{
		switch (input)
		{
		case "Enter":
			CloseKeyboard();
			return;
		case "Space":
			LevelEditor.instance.currentLevel.levelName = LevelEditor.instance.currentLevel.levelName + " ";
			break;
		case "Bksp":
			if (levelName.text.Length > 0)
			{
				LevelEditor.instance.currentLevel.levelName = LevelEditor.instance.currentLevel.levelName.Substring(0, LevelEditor.instance.currentLevel.levelName.Length - 1);
			}
			break;
		default:
			if (capsLock)
			{
				input = input.ToUpper();
			}
			LevelEditor.instance.currentLevel.levelName = LevelEditor.instance.currentLevel.levelName + input;
			break;
		}
		levelName.text = LevelEditor.instance.currentLevel.levelName;
	}

	public void ToggleCapsLock()
	{
		capsLock = !capsLock;
		if (capsLock)
		{
			for (int i = 0; i < alphaKeys.Length; i++)
			{
				alphaKeys[i].text = alphaKeys[i].text.ToUpper();
			}
		}
		else
		{
			for (int j = 0; j < alphaKeys.Length; j++)
			{
				alphaKeys[j].text = alphaKeys[j].text.ToLower();
			}
		}
	}

	private void OnApplicationQuit()
	{
		if (thread != null)
		{
			thread.Abort();
			MonoBehaviour.print("DeleteMenu Thread Aborted: " + !thread.IsAlive);
			thread = null;
		}
	}

	private void OnDisable()
	{
		LocalizationManager.OnLocalizeEvent -= OnLocalizationCall;
		if (thread != null)
		{
			thread.Abort();
			MonoBehaviour.print("DeleteMenu Thread Aborted: " + !thread.IsAlive);
			thread = null;
		}
	}

	private void OnLocalizationCall()
	{
		if (saveStatusText.color == Color.green)
		{
			saveStatusText.text = LocalizationManager.GetTranslation("Saved");
		}
		else
		{
			saveStatusText.text = LocalizationManager.GetTranslation("Not Saved");
		}
	}
}
public class LevelEditorOBTriggers : MonoBehaviour
{
	public GameObject OBPrefab;

	private GameObject OBTriggerBottom;

	private GameObject OBTriggerSideA;

	private GameObject OBTriggerSideB;

	private GameObject OBTriggerSideC;

	private GameObject OBTriggerSideD;

	private BoxCollider obTrigger;

	public Bounds bounds;

	private void OnTriggerExit(Collider c)
	{
		if (c.CompareTag("Golfball"))
		{
			OBManager.instance.TouchedBounds();
		}
	}

	public void SetOB()
	{
		DestroyOB();
		CreateOB();
	}

	public void CreateOB()
	{
		obTrigger = base.gameObject.AddComponent<BoxCollider>();
		Quaternion rotation = base.transform.rotation;
		base.transform.rotation = Quaternion.identity;
		MeshRenderer[] componentsInChildren = base.gameObject.GetComponentsInChildren<MeshRenderer>();
		bool flag = true;
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			if (componentsInChildren[i].GetComponent<TextMeshPro>() == null && componentsInChildren[i].GetComponent<TextMeshProUGUI>() == null && componentsInChildren[i].GetComponent<SnapPoint>() == null && componentsInChildren[i].GetComponent<RotateHandle>() == null)
			{
				if (flag)
				{
					bounds = componentsInChildren[0].bounds;
					flag = false;
				}
				bounds.Encapsulate(componentsInChildren[i].bounds);
			}
		}
		float num = 100f;
		float num2 = 1.1f;
		float num3 = 1f;
		obTrigger.size = new Vector3(bounds.size.x / base.transform.lossyScale.x * num2, bounds.size.y / base.transform.lossyScale.y + num + num3, bounds.size.z / base.transform.lossyScale.z * num2);
		obTrigger.center = new Vector3(bounds.center.x / base.transform.lossyScale.x, bounds.center.y / base.transform.lossyScale.y, bounds.center.z / base.transform.lossyScale.z) - new Vector3(base.transform.position.x / base.transform.lossyScale.x, base.transform.position.y / base.transform.lossyScale.y, base.transform.position.z / base.transform.lossyScale.z) + new Vector3(0f, num / 2f - num3 / 2f, 0f);
		obTrigger.isTrigger = true;
		base.transform.rotation = rotation;
	}

	public void DestroyOB()
	{
		if (obTrigger != null)
		{
			UnityEngine.Object.Destroy(obTrigger);
		}
	}
}
public class LevelEditorTutorialManager : MonoBehaviour
{
	public Transform tutorialBoardParent;

	public Transform tutorialBoard;

	public Transform menuAnchor;

	public Transform boardAnchor;

	public Transform followAnchor;

	public TextMeshPro instructionMessageUpper;

	public Text instructionMessageFull;

	public GameObject startTutorialButton;

	public GameObject closeTutorialButton;

	public GameObject nextTutorialButton;

	public bool inTutorial;

	public bool boardFollowing;

	private bool[] stepBools;

	private void OnEnable()
	{
		LocalizationManager.OnLocalizeEvent += OnLocalizationCall;
	}

	private void OnDisable()
	{
		LocalizationManager.OnLocalizeEvent -= OnLocalizationCall;
	}

	private void Start()
	{
		stepBools = new bool[16];
		instructionMessageUpper.text = LocalizationManager.GetTranslation("Tutorial");
	}

	private void SetInstructions(string s)
	{
		instructionMessageFull.gameObject.SetActive(value: true);
		instructionMessageUpper.gameObject.SetActive(value: false);
		startTutorialButton.SetActive(value: false);
		closeTutorialButton.SetActive(value: false);
		nextTutorialButton.SetActive(value: false);
		instructionMessageFull.text = LocalizationManager.GetTranslation(s);
	}

	private void SetNextInstructions(string s)
	{
		instructionMessageFull.gameObject.SetActive(value: false);
		instructionMessageUpper.gameObject.SetActive(value: true);
		startTutorialButton.SetActive(value: false);
		closeTutorialButton.SetActive(value: false);
		nextTutorialButton.SetActive(value: true);
		instructionMessageUpper.text = LocalizationManager.GetTranslation(s);
	}

	private void SetCloseInstructions(string s)
	{
		instructionMessageFull.gameObject.SetActive(value: false);
		instructionMessageUpper.gameObject.SetActive(value: true);
		startTutorialButton.SetActive(value: false);
		closeTutorialButton.SetActive(value: true);
		nextTutorialButton.SetActive(value: false);
		instructionMessageUpper.text = LocalizationManager.GetTranslation(s);
	}

	public void OpenTutorialBoard()
	{
		tutorialBoardParent.gameObject.SetActive(value: true);
		instructionMessageUpper.gameObject.SetActive(value: true);
		instructionMessageFull.gameObject.SetActive(value: false);
		instructionMessageUpper.text = LocalizationManager.GetTranslation("Tutorial");
		closeTutorialButton.SetActive(value: false);
		startTutorialButton.SetActive(value: true);
		nextTutorialButton.SetActive(value: false);
	}

	public void CloseTutorialBoard()
	{
		tutorialBoardParent.gameObject.SetActive(value: false);
		inTutorial = false;
	}

	public void StartTutorial()
	{
		inTutorial = true;
		stepBools = new bool[16];
		StartCoroutine(Tutorial());
	}

	public void SetTutorialStep(EditorTutorialStep e, bool forceSet = false)
	{
		if (inTutorial)
		{
			if (forceSet || e == EditorTutorialStep.NewPressed || stepBools[(int)(e - 1)])
			{
				stepBools[(int)e] = true;
			}
		}
	}

	public void GoToNextTutorialStep()
	{
		if (!inTutorial)
		{
			return;
		}
		int num = -1;
		for (int i = 0; i < stepBools.Length; i++)
		{
			if (!stepBools[i])
			{
				num = i;
				break;
			}
		}
		if (num != -1)
		{
			stepBools[num] = true;
		}
	}

	private void Update()
	{
		if (boardFollowing)
		{
			GameManager.instance.CenterNotification(tutorialBoardParent.gameObject, useLerp: true);
		}
	}

	public void FollowCamera()
	{
		tutorialBoardParent.SetParent(null);
		tutorialBoard.SetParent(followAnchor);
		tutorialBoard.localPosition = Vector3.zero;
		tutorialBoard.localRotation = Quaternion.identity;
		boardFollowing = true;
	}

	public void AttachToMenu()
	{
		tutorialBoardParent.transform.SetParent(menuAnchor);
		tutorialBoardParent.localPosition = Vector3.zero;
		tutorialBoardParent.localRotation = Quaternion.identity;
		tutorialBoard.SetParent(boardAnchor);
		tutorialBoard.localPosition = Vector3.zero;
		tutorialBoard.localRotation = Quaternion.identity;
		boardFollowing = false;
	}

	private IEnumerator Tutorial()
	{
		SetInstructions("Welcome to the Level Editor Tutorial. To begin, select the 'New' button on Editor Menu to create a new level.");
		while (!stepBools[0])
		{
			yield return null;
		}
		SetInstructions("Now select the type of level you want to create. These preset options modify the starting hole details but they can be changed later if you change your mind.");
		while (!stepBools[1])
		{
			yield return null;
		}
		SetInstructions("First lets place some pieces into your level. Select the 'Pieces' button.  If you want to reposition the menu, you can grab the side handles or if it's too far away, you can just point at a handle and press the trigger to summon it to you.");
		while (!stepBools[2])
		{
			yield return null;
		}
		SetInstructions("Every hole needs a starting point, the first page showing here has tee boxes and a starting mat for mini golf. To place a piece into your level, hover your wand over a piece and hold down the trigger. You can then drag the piece and place it anywhere by letting go of the trigger.");
		while (!stepBools[3])
		{
			yield return null;
		}
		if (GameManager.instance.controllerType == ControllerType.Vive)
		{
			SetNextInstructions("Now to explain the editor controls.  If you want to move the entire level around, hold down the grip button and move your hand.  If you want to select one or more pieces to move them as a group, press the up on the touchpad to select pieces, and then hold the grip to move that group.  Deselect by pressing up on the touchpad on highlight pieces, or press the 'Deselect All' button in the menu.  To scale a piece, select it, and adjust the scale on the menu");
		}
		else
		{
			SetNextInstructions("Now to explain the editor controls.  If you want to move the entire level around, hold down the grip button and move your hand.  If you want to select one or more pieces to move them as a group, press the up on the analog stick to select pieces, and then hold the grip to move that group.  Deselect by pressing up on the analog stick on highlight pieces, or press the 'Deselect All' button in the menu.  To scale a piece, select it, and adjust the scale on the menu");
		}
		while (!stepBools[4])
		{
			yield return null;
		}
		if (GameManager.instance.controllerType == ControllerType.Vive)
		{
			SetNextInstructions("To delete or copy a piece, hover it and press left or right on the touchpad. You can undo and redo actions with the buttons below the editor menu. To move from level-ground mode to free-rotation mode, press down on the touchpad. Pieces can now be freely rotated.");
		}
		else
		{
			SetNextInstructions("To delete or copy a piece, hover it and press left or right on the analog stick. You can undo and redo actions with the buttons below the editor menu. To move from level-ground mode to free-rotation mode, press down on the analog stick. Pieces can now be freely rotated.");
		}
		while (!stepBools[5])
		{
			yield return null;
		}
		SetInstructions("Try placing some other pieces in the level. When you're ready to move on with the tutorial, place a golf hole into the level. (Golf holes have a flag on them. You can find some of them in the 'greens' tab.");
		while (!stepBools[6])
		{
			yield return null;
		}
		SetInstructions("Great! Now lets test the level. Press the back icon to go to the main details page, and then click the preview (eye) icon on the top right to test your level.");
		while (!stepBools[7])
		{
			yield return null;
		}
		FollowCamera();
		SetInstructions("You can play your level exactly as it would be played during normal play. When you are done testing you can return to edit mode by opening the pause menu and selecting 'Toggle Preview'.");
		while (!stepBools[8])
		{
			yield return null;
		}
		AttachToMenu();
		SetInstructions("Now lets look at editing some details about the level. Press the 'Edit Level Details' button.");
		while (!stepBools[9])
		{
			yield return null;
		}
		SetInstructions("Here you can edit the level name by pressing on the name at the top and take a cover photo by pressing the camera icon. You can also change the music, sky color, set what clubs are allowed, and set the wind strength. Press the 'Set Wind' button to continue.");
		while (!stepBools[10])
		{
			yield return null;
		}
		SetInstructions("You can set the wind direction by first making sure random wind is not enabled, increasing the wind speed, and then grabbing the yellow arrow and rotating it in the direction you want. You can also set wind direction to be random with the toggle and then choose the max wind speed. When random wind is enabled, it will choose a different wind direction every time the level is played, and the speed will be random between 0 and the speed you chose. Close the wind panel and press the back button on the main panel to continue.");
		while (!stepBools[11])
		{
			yield return null;
		}
		SetInstructions("Lastly, lets finalize the level! Finalizing a level makes it available to be played from the custom course selection menu and if you choose to upload it, other people can download and play it too. You can always re-finalize a level and update the level online. Press the 'Finalize' button when you're ready.");
		while (!stepBools[12])
		{
			yield return null;
		}
		SetInstructions("You need a starting point and a golf hole in the level to be able to finalize, and you also need to name your level and have a cover photo taken. You will need to play through your level to finalize. Try to play well because your the number of strokes you take will determine what par you can set for the course. When you're ready press 'Play' and play through your level.");
		while (!stepBools[13])
		{
			yield return null;
		}
		SetInstructions("Great job finishing your level! Based on how many strokes you took you can now adjust the par of your level. Also set the difficulty you think your level is to help tell other users the difficulty level. Press 'Confirm' to finalize your hole.");
		while (!stepBools[14])
		{
			yield return null;
		}
		SetInstructions("Congratulations! Your level is now finalized and can be played from the custom course menu. If you feel happy with your level you can also publish it online for other people to play and rate! You can always re-finalize your level and re-publish your hole to update the level online.");
		while (!stepBools[15])
		{
			yield return null;
		}
		SetCloseInstructions("You have completed the level editor tutorial! Feel free to continue editing this level or go back and create a brand new one. You can also go to the  custom course menu and play through levels other people have made to get some ideas. Happy editing!");
		inTutorial = false;
	}

	private void OnLocalizationCall()
	{
		if (!inTutorial)
		{
			instructionMessageUpper.text = LocalizationManager.GetTranslation("Tutorial");
		}
	}
}
public enum EditorTutorialStep
{
	NewPressed,
	HoleTypeSelected,
	PiecesPageOpened,
	StartPiecePlaced,
	ControlsTested,
	ControlsTested2,
	GolfHolePlaced,
	PreviewStarted,
	PreviewEnded,
	DetailsOpened,
	SetWindOpened,
	MainmenuOpenedAgain,
	FinalizeOpened,
	SetParOpened,
	PublishOpened,
	PublishOrNotChosen,
	StepAfterLast
}
public class PageTab : MonoBehaviour
{
	public int startPage;

	public Image background;

	public void Highlight()
	{
		background.color = LevelEditor.instance.levelEditorMenu.tabHighlightColor;
	}

	public void UnHighlight()
	{
		background.color = LevelEditor.instance.levelEditorMenu.tabColor;
	}
}
public class PieceDetailMenu : MonoBehaviour
{
	public Transform detailPanel;

	public GameObject floatDetailObj;

	public Text pieceName;

	public EditorPiece currentPiece;

	public void OpenMenu(PieceDetails details)
	{
		for (int num = detailPanel.childCount - 1; num > 0; num--)
		{
			UnityEngine.Object.Destroy(detailPanel.GetChild(num).gameObject);
		}
		pieceName.text = details.name;
		GameObject gameObject = UnityEngine.Object.Instantiate(floatDetailObj, detailPanel);
		DetailPanel dp = gameObject.GetComponent<DetailPanel>();
		dp.piece = details.piece;
		if (details.fi != null)
		{
			dp.fi = details.fi[0];
			dp.title.text = dp.fi.Name + ":";
			dp.val.text = ((Vector3)dp.fi.GetValue(dp.piece)).x.ToString();
			dp.b1.onClickEvent.AddListener(delegate
			{
				DecrementV3X(dp.piece, dp.fi, dp.val);
			});
			dp.b2.onClickEvent.AddListener(delegate
			{
				IncrementV3X(dp.piece, dp.fi, dp.val);
			});
		}
		else if (details.pi != null)
		{
			dp.pi = details.pi[0];
			dp.title.text = dp.pi.Name + ":";
			dp.val.text = ((Vector3)dp.pi.GetValue(dp.piece, null)).x.ToString();
			dp.b1.onClickEvent.AddListener(delegate
			{
				DecrementV3X(dp.piece, dp.pi, dp.val);
			});
			dp.b2.onClickEvent.AddListener(delegate
			{
				IncrementV3X(dp.piece, dp.pi, dp.val);
			});
		}
	}

	public void FillDetails(EditorPiece piece)
	{
		currentPiece = piece;
		for (int num = detailPanel.childCount - 1; num >= 0; num--)
		{
			UnityEngine.Object.Destroy(detailPanel.GetChild(num).gameObject);
		}
		if (string.IsNullOrEmpty(piece.displayName))
		{
			pieceName.text = piece.name;
		}
		else
		{
			pieceName.text = piece.displayName;
		}
		if (!(piece.GetComponent<EditorCannon>() != null))
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(floatDetailObj, detailPanel);
			DetailPanel dp = gameObject.GetComponent<DetailPanel>();
			dp.piece = piece;
			dp.title.text = "Scale:";
			dp.val.text = piece.transform.localScale.x.ToString("F2");
			dp.b1.onClickEvent.AddListener(delegate
			{
				ChangeScale(piece, 0.1f, 5f, -0.05f, dp.val);
			});
			dp.b2.onClickEvent.AddListener(delegate
			{
				ChangeScale(piece, 0.1f, 5f, 0.05f, dp.val);
			});
		}
	}

	public void ChangeScale(EditorPiece piece, float min, float max, float value, Text valToUpdate)
	{
		Vector3 localScale = piece.transform.localScale;
		float num = piece.transform.localScale.x + value;
		if (num < min)
		{
			num = min;
		}
		else if (num > max)
		{
			num = max;
		}
		List<GameObject> list = new List<GameObject>();
		list.Add(piece.gameObject);
		for (int i = 0; i < piece.placedPieces.Count; i++)
		{
			piece.placedPieces[i].transform.parent = piece.transform;
			list.Add(piece.placedPieces[i]);
		}
		piece.transform.localScale = new Vector3(num, num, num);
		for (int j = 0; j < piece.placedPieces.Count; j++)
		{
			piece.placedPieces[j].transform.parent = LevelEditor.instance.levelParent;
		}
		valToUpdate.text = num.ToString("F2");
		SnapData[][] array = new SnapData[list.Count][];
		for (int k = 0; k < list.Count; k++)
		{
			array[k] = LevelEditor.instance.GetSnappedPoints(list[k].GetComponent<EditorPiece>());
		}
		for (int l = 0; l < list.Count; l++)
		{
			list[l].GetComponent<EditorPiece>().UnSnapAll();
		}
		EditorStep step = default(EditorStep);
		step.stepType = StepType.scale;
		step.scale = piece.transform.localScale - localScale;
		int[] array2 = new int[piece.placedPieces.Count + 1];
		for (int m = 0; m < list.Count; m++)
		{
			array2[m] = LevelEditor.instance.stepPieces.IndexOf(list[m]);
		}
		step.groupPieces = array2;
		SnapData[][] array3 = new SnapData[list.Count][];
		for (int n = 0; n < array3.Length; n++)
		{
			if (array[n] != null)
			{
				array3[n] = LevelEditor.SnapDataSub(LevelEditor.instance.GetSnappedPoints(list[n].GetComponent<EditorPiece>()), array[n]);
			}
		}
		step.snappedPoints = array3;
		LevelEditor.instance.AddStep(step);
	}

	public void DecrementV3X(UnityEngine.Object piece, FieldInfo fi, Text valDisplay)
	{
		Vector3 vector = (Vector3)fi.GetValue(piece);
		vector.x -= 0.5f;
		fi.SetValue(piece, vector);
		valDisplay.text = vector.x.ToString();
	}

	public void IncrementV3X(UnityEngine.Object piece, FieldInfo fi, Text valDisplay)
	{
		Vector3 vector = (Vector3)fi.GetValue(piece);
		vector.x += 0.5f;
		fi.SetValue(piece, vector);
		valDisplay.text = vector.x.ToString();
	}

	public void DecrementV3X(UnityEngine.Object piece, PropertyInfo pi, Text valDisplay)
	{
		Vector3 vector = (Vector3)pi.GetValue(piece, null);
		vector.x -= 0.5f;
		pi.SetValue(piece, vector, null);
		valDisplay.text = vector.x.ToString();
	}

	public void IncrementV3X(UnityEngine.Object piece, PropertyInfo pi, Text valDisplay)
	{
		Vector3 vector = (Vector3)pi.GetValue(piece, null);
		vector.x += 0.5f;
		pi.SetValue(piece, vector, null);
		valDisplay.text = vector.x.ToString();
	}
}
public struct PieceDetails
{
	public string name;

	public UnityEngine.Object piece;

	public FieldInfo[] fi;

	public PropertyInfo[] pi;
}
public struct Variables
{
	public string name;

	public float f1;
}
public class PieceSpawner : MonoBehaviour
{
	public GameObject piecePrefab;

	public GameObject currentPiece;

	public Vector3 previewPieceScale;

	public bool pair;

	public Vector3 offset;

	private void Awake()
	{
		SpawnPiece();
	}

	public void SpawnPiece()
	{
		if (piecePrefab != null)
		{
			currentPiece = UnityEngine.Object.Instantiate(piecePrefab, base.transform);
			currentPiece.name = piecePrefab.name;
			currentPiece.transform.localPosition = Vector3.zero;
			currentPiece.transform.localRotation = Quaternion.identity;
			currentPiece.transform.localScale = previewPieceScale;
			currentPiece.GetComponent<EditorPiece>().spawner = this;
			currentPiece.GetComponent<EditorPiece>().showSnapPoints = true;
			currentPiece.GetComponent<Collider>().enabled = false;
			currentPiece.GetComponent<Collider>().enabled = true;
			if (pair)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(currentPiece, base.transform);
				gameObject.name = currentPiece.name;
				gameObject.transform.position = currentPiece.transform.position + offset;
				WarpNode.LinkPieces(currentPiece.GetComponent<EditorPiece>(), gameObject.GetComponent<EditorPiece>());
			}
			EditorCannon component = currentPiece.GetComponent<EditorCannon>();
			if (component != null)
			{
				component.trajectoryLineRenderer.enabled = false;
			}
		}
	}

	public void Grab(EditorGrabber grabber)
	{
		if (previewPieceScale != LevelEditor.instance.pieceScaleV3 * LevelEditor.instance.editScale)
		{
			Vector3 vector = currentPiece.transform.position - grabber.transform.position;
			if (previewPieceScale.x != 0f)
			{
				float num = LevelEditor.instance.pieceScaleV3.x * LevelEditor.instance.editScale / previewPieceScale.x;
				currentPiece.transform.localScale = LevelEditor.instance.pieceScaleV3 * LevelEditor.instance.editScale;
				currentPiece.transform.position = grabber.transform.position + vector * num;
			}
		}
		EditorCannon component = currentPiece.GetComponent<EditorCannon>();
		if (component != null)
		{
			component.trajectoryLineRenderer.enabled = true;
		}
		SpawnPiece();
	}
}
public class RotateHandle : MonoBehaviour
{
	public EditorPiece piece;

	public SnapPoint snapPoint;

	public RotateHandle oppositeHandle;

	public bool upNormal;

	public bool downNormal;

	public bool side;

	public void Highlight()
	{
		GetComponent<Renderer>().material = LevelEditor.instance.rotateHighlightMat;
		Player.instance.currentControllerInput.Vibrate();
	}

	public void UnHighlight()
	{
		GetComponent<Renderer>().material = LevelEditor.instance.rotateOriginalMat;
	}
}
public class SnapPoint : MonoBehaviour
{
	public EditorPiece piece;

	public SnapPoint snappedPoint;

	public bool active;

	public RotateHandle rotationHandle;

	public static float maxSnapDistance = 1E-06f;

	public bool SnapToPointIfClose(SnapPoint foreignPoint)
	{
		bool result = false;
		if ((base.transform.position - foreignPoint.transform.position).magnitude < maxSnapDistance)
		{
			result = true;
			snappedPoint = foreignPoint;
			foreignPoint.snappedPoint = this;
			piece.snapped = true;
			foreignPoint.piece.snapped = true;
			piece.CheckAndSetRotationHandles();
			foreignPoint.piece.CheckAndSetRotationHandles();
		}
		return result;
	}

	public void BreakPercent(float t)
	{
	}

	private void OnTriggerEnter(Collider other)
	{
		if (active && snappedPoint == null && (bool)other.GetComponent<SnapPoint>() && other.GetComponent<SnapPoint>().snappedPoint == null && other.GetComponent<SnapPoint>().piece.spawner == null)
		{
			Player.instance.editorGrabber.Snap(this, other.GetComponent<SnapPoint>());
		}
	}
}
public class Teebox : MonoBehaviour
{
	public Transform teeLocation;
}
public class TempClubSwitch : MonoBehaviour
{
	public void SwitchToClub(int i)
	{
		Player.instance.clubSwitcher.preventClubSwitchOnWarp = true;
		OBManager.instance.revertLastClubOnOB = true;
		OBManager.instance.clubTypeBeforeHit = (ClubType)i;
		Player.instance.clubSwitcher.SwitchToClubType((ClubType)i);
	}
}
public class TrampolineBounce : MonoBehaviour
{
	private AudioSource audioSource;

	private void Start()
	{
		audioSource = GetComponent<AudioSource>();
	}

	private void OnCollisionEnter(Collision other)
	{
		if (other.gameObject.GetComponent<Golfball>() != null)
		{
			Vector3 zero = Vector3.zero;
			float magnitude = other.gameObject.GetComponent<Golfball>().previousVelocity.magnitude;
			float magnitude2 = other.rigidbody.velocity.magnitude;
			zero = ((!(magnitude > magnitude2)) ? other.rigidbody.velocity : other.gameObject.GetComponent<Golfball>().previousVelocity);
			Vector3 velocity = Vector3.Reflect(zero, base.transform.up);
			other.collider.attachedRigidbody.velocity = velocity;
			audioSource.Play();
		}
	}
}
public class WarpNode : MonoBehaviour
{
	public Transform launchPoint;

	[HideInInspector]
	public Transform warpOutPoint;

	public bool portal;

	public float offsetDistance;

	public AudioSource audioSource;

	public void WarpBall(GameObject ball)
	{
		Vector3 position = warpOutPoint.position;
		float num = ball.GetComponent<Rigidbody>().velocity.magnitude * 0.9f;
		Vector3 zero = Vector3.zero;
		if (portal)
		{
			Vector3 vector = Vector3.Project(ball.GetComponent<Rigidbody>().velocity, -base.transform.forward);
			if ((Quaternion.Inverse(base.transform.rotation) * vector).z < 0f)
			{
				zero = -warpOutPoint.transform.forward * num;
				position += -warpOutPoint.transform.forward * (offsetDistance * base.transform.lossyScale.z);
			}
			else
			{
				zero = warpOutPoint.transform.forward * num;
				position += warpOutPoint.transform.forward * (offsetDistance * base.transform.lossyScale.z);
			}
		}
		else
		{
			zero = warpOutPoint.transform.forward * num;
		}
		ball.transform.position = position;
		ball.GetComponent<Rigidbody>().velocity = zero;
		audioSource.Play();
		RoomRPC.PlayOnlineSound(base.transform.position, audioSource.clip.name);
	}

	public static void LinkPieces(EditorPiece p1, EditorPiece p2)
	{
		p1.linkedPiece = p2;
		p2.linkedPiece = p1;
		p1.GetComponentInChildren<WarpNode>().warpOutPoint = p2.GetComponentInChildren<WarpNode>().launchPoint;
		p2.GetComponentInChildren<WarpNode>().warpOutPoint = p1.GetComponentInChildren<WarpNode>().launchPoint;
	}
}
public class LobbyManager : MonoBehaviourPunCallbacks
{
	public static LobbyManager instance;

	public RoomListPanel roomListPanel;

	public GameObject downloadProgressPanel;

	public Text downloadTimerText;

	public DownloadBars downloadBar;

	public bool downloading;

	public int downloadsNeeded;

	private float downloadTimer = 60f;

	private double serverDownloadStartTime;

	private double serverDownloadEndTime;

	public GameObject photonVoiceRecorder;

	public TextMeshProUGUI photonVersion;

	private float secondsToJoinFriendRoom = 5f;

	private bool hasSetDestination;

	private bool joiningDestinationRoom;

	private bool joiningPartyRoom;

	private void Awake()
	{
		instance = this;
	}

	private void Start()
	{
		GameManager.instance.ResetMulligans();
		GameManager.instance.gameMode = GameMode.Custom;
		PhotonManager.instance.Connect();
		StartCoroutine(ScoreManager.instance.SwapScorecards());
		ScoreManager.instance.ResetStrokeTable();
		ResetOnlineVariables();
		RemoteServerManager.instance.downloadsCompleted = 0;
		StartCoroutine(SetAvatarID());
		PhotonNetwork.LocalPlayer.SetDownloadFinished(value: false);
		PhotonNetwork.LocalPlayer.SetDownloadProgress(0);
		photonVersion.text = "v" + PhotonNetwork.GameVersion;
		joiningDestinationRoom = RichPresenceManager.instance.loadIntoRoomFromLobby;
		joiningPartyRoom = RichPresenceManager.instance.createRoomForParty;
		if (RemoteServerManager.instance.playerID == "" || RemoteServerManager.instance.playerID == "0" || string.IsNullOrEmpty(RemoteServerManager.instance.playerUserName))
		{
			PhotonNetwork.LocalPlayer.NickName = "Guest" + UnityEngine.Random.Range(1000, 9999);
		}
		else
		{
			PhotonNetwork.LocalPlayer.NickName = RemoteServerManager.instance.playerUserName;
		}
	}

	private void ResetOnlineVariables()
	{
		PhotonNetwork.LocalPlayer.SetHoleFinished(value: false);
		PhotonNetwork.LocalPlayer.SetReadyToStart(value: false);
		PhotonNetwork.LocalPlayer.SetKicked(kicked: false);
		PhotonNetwork.LocalPlayer.SetStandby(0.0);
	}

	private void Update()
	{
		if (downloading)
		{
			UpdateDownloadProgress();
			if (downloadTimer <= 0f)
			{
				downloading = false;
				StopCoroutine(RemoteServerManager.instance.downloadHolesCoroutine);
				GameManager.instance.BackToMainMenu();
				Notification.instance.AddNotification("Failed to download workshop hole within time limit", 0f, closeButton: true);
			}
		}
		if (!hasSetDestination && PhotonNetwork.InLobby)
		{
			RichPresenceManager.instance.SetLobbyDestination();
			hasSetDestination = true;
		}
		if (!PhotonNetwork.InLobby)
		{
			return;
		}
		if (joiningPartyRoom)
		{
			secondsToJoinFriendRoom -= Time.deltaTime;
			if (secondsToJoinFriendRoom <= 0f)
			{
				RichPresenceManager.instance.createRoomForParty = false;
				joiningPartyRoom = false;
				Notification.instance.AddNotification("Could not join the room.", 0f, closeButton: true);
			}
			RoomHelper.JoinOrCreateRoomForParty(RichPresenceManager.instance.partyRoomID);
		}
		else
		{
			if (!joiningDestinationRoom)
			{
				return;
			}
			secondsToJoinFriendRoom -= Time.deltaTime;
			if (secondsToJoinFriendRoom <= 0f)
			{
				RichPresenceManager.instance.loadIntoRoomFromLobby = false;
				joiningDestinationRoom = false;
				Notification.instance.AddNotification("Could not join the room.", 0f, closeButton: true);
			}
			foreach (RoomInfo value in roomListPanel.cachedRoomList.Values)
			{
				if (value.Name == RichPresenceManager.instance.deepLinkMessage.roomName)
				{
					if (roomListPanel.selectedRoom.PlayerCount < roomListPanel.selectedRoom.MaxPlayers)
					{
						DownloadHoles(value);
						joiningDestinationRoom = false;
					}
					else
					{
						Notification.instance.AddNotification("Room is full.", 0f, closeButton: true);
					}
					break;
				}
			}
		}
	}

	public override void OnJoinedRoom()
	{
		if (PhotonNetwork.IsMasterClient)
		{
			PhotonNetwork.InstantiateSceneObject("RoomRPC", Vector3.zero, Quaternion.identity, 0);
			RoomHelper.LoadCurrentLevel();
		}
		else
		{
			StartCoroutine(JoinRoom());
		}
		RichPresenceManager.instance.loadIntoRoomFromLobby = false;
		RichPresenceManager.instance.createRoomForParty = false;
	}

	public override void OnJoinRoomFailed(short returnCode, string message)
	{
		base.OnJoinRoomFailed(returnCode, message);
		if (joiningPartyRoom)
		{
			PhotonNetwork.JoinRoom(RichPresenceManager.instance.partyRoomID);
			return;
		}
		MonoBehaviour.print("Error: " + message);
		if (message == "Game full")
		{
			Notification.instance.AddNotification("The room has become full", 0f, closeButton: true);
		}
		SwitchToRoomListScreen();
	}

	public void DownloadHoles(RoomInfo roomInfo)
	{
		roomListPanel.roomSelectionScreen.SetActive(value: false);
		int num = (int)roomInfo.CustomProperties["levelIndex"];
		if (num != -1)
		{
			WorkshopData[] source = JsonHelper.FromJson<WorkshopData>((string)roomInfo.CustomProperties["holes"]);
			GameManager.instance.holeData = source.ToList();
			GameManager.instance.holeIndex = num;
			StartDownload();
		}
		else
		{
			PhotonNetwork.JoinRoom(roomInfo.Name);
		}
	}

	private IEnumerator JoinRoom()
	{
		MonoBehaviour.print("joining room");
		roomListPanel.roomSelectionScreen.SetActive(value: false);
		while (RoomRPC.instance == null || PhotonNetwork.CurrentRoom.GetNextHoleCountDown())
		{
			yield return null;
		}
		ScoreManager.instance.SetHolePars();
		ScoreManager.instance.SetDoubleParOnLateJoin();
		PhotonNetwork.LocalPlayer.SetScores(ScoreManager.instance.strokeTable[0]);
		yield return new WaitForEndOfFrame();
		RoomRPC.instance.pView.RPC("SetOtherPlayersPhotonScore", RpcTarget.All, true);
		GameManager.instance.SetMulligans();
		RoomRPC.PlayOnlineSound(GameManager.instance.player.transform.position, "SFX_Online_Join", 1f);
		RoomHelper.LoadCurrentLevel();
	}

	private void StartDownload()
	{
		downloadTimer = 60f;
		downloadsNeeded = 0;
		RemoteServerManager.instance.downloadsCompleted = 0;
		Vector3 localScale = downloadBar.downloadBar.transform.localScale;
		localScale.x = 0f;
		downloadBar.downloadBar.transform.localScale = localScale;
		downloadBar.percent.text = "0%";
		List<WorkshopData> list = new List<WorkshopData>();
		foreach (WorkshopData holeDatum in GameManager.instance.holeData)
		{
			if (!holeDatum.defaultHole)
			{
				list.Add(holeDatum);
			}
		}
		downloading = true;
		downloadProgressPanel.SetActive(value: true);
		serverDownloadStartTime = Environment.TickCount;
		RemoteServerManager.instance.downloadHolesCoroutine = StartCoroutine(RemoteServerManager.instance.DownloadHole(list));
		RemoteServerManager.instance.downloadRatingsCoroutine = StartCoroutine(RemoteServerManager.instance.GetRatingData(list));
	}

	private IEnumerator ApplyScreenshotData()
	{
		for (int i = 0; i < GameManager.instance.holeData.Count; i++)
		{
			WorkshopData data = GameManager.instance.holeData[i];
			if (!data.defaultHole)
			{
				WWW www = new WWW("file:///" + data.imageLocation);
				yield return www;
				if (string.IsNullOrEmpty(www.error))
				{
					data.screenshot = www.texture;
				}
				www.Dispose();
			}
			else
			{
				data.screenshot = (Texture2D)Resources.LoadAll<Texture>("Holes/" + data.imageLocation)[0];
			}
		}
	}

	public void UpdateDownloadProgress()
	{
		serverDownloadEndTime = Environment.TickCount;
		downloadTimer = 60 - (int)((serverDownloadEndTime - serverDownloadStartTime) / 1000.0);
		downloadTimerText.text = ((int)downloadTimer).ToString();
		int downloadsCompleted = RemoteServerManager.instance.downloadsCompleted;
		Vector3 localScale = downloadBar.downloadBar.transform.localScale;
		float num = (localScale.x = ((downloadsNeeded > 0) ? ((float)downloadsCompleted / (float)downloadsNeeded) : 1f));
		downloadBar.downloadBar.transform.localScale = localScale;
		downloadBar.percent.text = Mathf.Clamp((int)(num * 100f), 0, 100) + "%";
	}

	public IEnumerator FinishedDownload()
	{
		if (roomListPanel.selectedRoom.PlayerCount < roomListPanel.selectedRoom.MaxPlayers)
		{
			MonoBehaviour.print("finished download");
			downloadProgressPanel.SetActive(value: false);
			PhotonNetwork.JoinRoom(roomListPanel.selectedRoom.Name);
			while (PhotonNetwork.CurrentRoom == null || PhotonNetwork.CurrentRoom.GetNextHoleCountDown())
			{
				yield return null;
			}
			StartCoroutine(ApplyScreenshotData());
		}
		else
		{
			Notification.instance.AddNotification("Room is full.", 0f, closeButton: true);
			SwitchToRoomListScreen();
		}
	}

	public void SwitchToRoomListScreen()
	{
		downloadProgressPanel.SetActive(value: false);
		roomListPanel.roomSelectionScreen.SetActive(value: true);
		downloading = false;
		downloadTimer = 0f;
	}

	public IEnumerator ShowIncorrectPassword()
	{
		OBManager.instance.PlayOBSFX();
		roomListPanel.incorrectPasswordText.SetActive(value: true);
		roomListPanel.enterRoomPasswordText.SetActive(value: false);
		yield return new WaitForSeconds(3f);
		roomListPanel.incorrectPasswordText.SetActive(value: false);
		roomListPanel.enterRoomPasswordText.SetActive(value: true);
	}

	private IEnumerator SetAvatarID()
	{
		float timer = 10f;
		while (RemoteServerManager.instance.playerID == "")
		{
			timer -= Time.deltaTime;
			if (timer <= 0f)
			{
				yield break;
			}
			yield return null;
		}
		PlayerID playerID = default(PlayerID);
		playerID.playerID = RemoteServerManager.instance.playerID;
		playerID.avatarID = RemoteServerManager.instance.playerID;
		playerID.publishedPlatform = GameManager.instance.publishedPlatform;
		PlayerID playerID2 = playerID;
		PhotonNetwork.LocalPlayer.SetPlayerID(playerID2);
		if (RemoteServerManager.instance.playerID == "" || RemoteServerManager.instance.playerID == "0")
		{
			SetRandomAvatar(playerID2);
		}
		if (GameManager.instance.publishedPlatform == PublishedPlatform.OCULUS)
		{
			CheckAvatar(playerID2);
		}
		else
		{
			SetRandomAvatar(playerID2);
		}
	}

	private void CheckAvatar(PlayerID id)
	{
		StartCoroutine(RemoteServerManager.instance.GetOculusAvatar(id.playerID, delegate(bool hasAvatar)
		{
			if (!hasAvatar)
			{
				SetRandomAvatar(id);
			}
			PhotonNetwork.LocalPlayer.SetPlayerID(id);
		}));
	}

	private void SetRandomAvatar(PlayerID id)
	{
		string[] array = new string[12]
		{
			"10150030458727564", "10150030458738922", "10150030458747067", "10150030458756715", "10150030458762178", "10150030458769900", "10150030458775732", "10150030458785587", "10150030458806683", "10150030458820129",
			"10150030458827644", "10150030458843421"
		};
		int num = UnityEngine.Random.Range(0, array.Length - 1);
		string avatarID = array[num];
		id.avatarID = avatarID;
		PhotonNetwork.LocalPlayer.SetPlayerID(id);
	}

	private void JoinRandomRoom()
	{
	}
}
public class RoomButton : MonoBehaviour
{
	private int playerCount = 1;

	public Text roomName;

	public Text playerCountText;

	public Image[] avatars;

	public Image[] friendIcon;

	public RoomInfo roomInfo;

	private PlayerID[] playerIDs;

	private List<string> friendIDs = new List<string>();

	private void Start()
	{
		GetFriends();
	}

	public void SetData(RoomInfo info)
	{
		roomInfo = info;
		if (LobbyManager.instance.roomListPanel.selectedRoom != null)
		{
			if (info.Name == LobbyManager.instance.roomListPanel.selectedRoom.Name)
			{
				LobbyManager.instance.roomListPanel.selectedRoom = info;
			}
			MonoBehaviour.print("Setting room info:" + info.PlayerCount);
			MonoBehaviour.print("lobby room info:" + LobbyManager.instance.roomListPanel.selectedRoom.PlayerCount);
		}
		roomName.text = string.Format(LocalizationManager.GetTranslation("{0}'s Room"), info.Name);
		playerCount = info.PlayerCount;
		playerCountText.text = playerCount + "/" + roomInfo.MaxPlayers;
		if ((string)roomInfo.CustomProperties["roomPlayerIDs"] != null)
		{
			playerIDs = JsonHelper.FromJson<PlayerID>((string)roomInfo.CustomProperties["roomPlayerIDs"]);
			StopAllCoroutines();
			if (base.gameObject.activeSelf)
			{
				StartCoroutine(SetAvatars());
			}
		}
	}

	private void GetFriends()
	{
	}

	private void CheckFriendInRoom()
	{
		for (int i = 0; i < 4; i++)
		{
			if (i < playerCount)
			{
				if (friendIDs.Contains(playerIDs[i].playerID))
				{
					friendIcon[i].gameObject.SetActive(value: true);
				}
			}
			else
			{
				friendIcon[i].gameObject.SetActive(value: false);
			}
		}
	}

	private IEnumerator SetAvatars()
	{
		for (int i = 0; i < 4; i++)
		{
			bool downloading = false;
			if (i < playerCount)
			{
				avatars[i].gameObject.SetActive(value: true);
				if (playerIDs[i].publishedPlatform == PublishedPlatform.STEAM)
				{
					downloading = true;
					StartCoroutine(RemoteServerManager.instance.GetSteamUser(playerIDs[i].playerID, delegate(string complete)
					{
						if (!string.IsNullOrEmpty(complete))
						{
							StartCoroutine(RemoteServerManager.instance.GetAvatarSprite(complete, delegate(byte[] complete2)
							{
								if (complete2 != null)
								{
									downloading = false;
									Texture2D texture2D2 = new Texture2D(0, 0, TextureFormat.RGB24, mipChain: false);
									texture2D2.LoadImage(complete2);
									avatars[i].sprite = Sprite.Create(texture2D2, new Rect(0f, 0f, texture2D2.width, texture2D2.height), new Vector2(0.5f, 0.5f), 100f, 0u, SpriteMeshType.FullRect);
								}
								else
								{
									downloading = false;
									avatars[i].sprite = RemoteServerManager.instance.steamIcon;
								}
							}));
						}
						else
						{
							downloading = false;
							avatars[i].sprite = RemoteServerManager.instance.steamIcon;
						}
					}));
				}
				else if (playerIDs[i].publishedPlatform == PublishedPlatform.OCULUS)
				{
					downloading = true;
					StartCoroutine(RemoteServerManager.instance.GetOculusUser(playerIDs[i].playerID, 2, delegate
					{
					}, delegate(string profileImage)
					{
						if (!string.IsNullOrEmpty(profileImage))
						{
							StartCoroutine(RemoteServerManager.instance.GetAvatarSprite(profileImage, delegate(byte[] complete2)
							{
								if (complete2 != null)
								{
									downloading = false;
									Texture2D texture2D = new Texture2D(0, 0, TextureFormat.RGB24, mipChain: false);
									texture2D.LoadImage(complete2);
									avatars[i].sprite = Sprite.Create(texture2D, new Rect(0f, 0f, texture2D.width, texture2D.height), new Vector2(0.5f, 0.5f), 100f, 0u, SpriteMeshType.FullRect);
								}
								else
								{
									downloading = false;
									avatars[i].sprite = RemoteServerManager.instance.oculusIcon;
								}
							}));
						}
						else
						{
							downloading = false;
							avatars[i].sprite = RemoteServerManager.instance.oculusIcon;
						}
					}));
				}
				else if (playerIDs[i].publishedPlatform == PublishedPlatform.XR)
				{
					downloading = false;
					avatars[i].sprite = RemoteServerManager.instance.XRSpaceIcon;
				}
				while (downloading)
				{
					yield return null;
				}
			}
			else
			{
				avatars[i].gameObject.SetActive(value: false);
			}
		}
		CheckFriendInRoom();
	}

	public void OnRoomButton()
	{
		if (playerCount < roomInfo.MaxPlayers)
		{
			LobbyManager.instance.roomListPanel.selectedRoom = roomInfo;
			LobbyManager.instance.roomListPanel.passwordInput.text = "";
			if ((bool)roomInfo.CustomProperties["isPrivate"])
			{
				string p = (string)roomInfo.CustomProperties["password"];
				LobbyManager.instance.roomListPanel.InputtingPassword(p, roomInfo.Name);
			}
			else
			{
				LobbyManager.instance.DownloadHoles(roomInfo);
			}
		}
		else
		{
			Notification.instance.AddNotification("Room is full.", 0f, closeButton: true);
		}
	}
}
public class RoomListPanel : MonoBehaviourPunCallbacks
{
	public RoomButton roomButtonPrefab;

	public RectTransform list;

	public Dictionary<string, RoomInfo> cachedRoomList = new Dictionary<string, RoomInfo>();

	private List<RoomButton> roomButtonObjs = new List<RoomButton>();

	private bool isPrivateTab;

	public TabButton privateTab;

	public TabButton publicTab;

	public Text messageDisplayText;

	public GameObject noRoomsFound;

	public GameObject createRoomScreen;

	public GameObject roomSelectionScreen;

	public GameObject keyboard;

	public GameObject createRoomButton;

	public GameObject incorrectPasswordText;

	public GameObject enterRoomPasswordText;

	public Text passwordInput;

	private Action<string> doneCallback;

	private bool joiningRoom;

	public RoomInfo selectedRoom;

	public void Init(Action<string> doneCallback)
	{
		this.doneCallback = doneCallback;
	}

	private void Start()
	{
		createRoomButton.SetActive(value: false);
		messageDisplayText.transform.parent.gameObject.SetActive(value: true);
	}

	private void Update()
	{
		if (PhotonNetwork.InLobby || PhotonNetwork.InRoom)
		{
			if (PhotonNetwork.NetworkClientState == ClientState.Joining)
			{
				joiningRoom = true;
				messageDisplayText.transform.parent.gameObject.SetActive(value: true);
				messageDisplayText.text = LocalizationManager.GetTranslation("Connecting to Room...");
			}
			else if (PhotonNetwork.NetworkClientState == ClientState.Joined)
			{
				messageDisplayText.text = LocalizationManager.GetTranslation("Joined Room!");
			}
			else if (!PhotonNetwork.InRoom)
			{
				createRoomButton.SetActive(value: true);
				messageDisplayText.transform.parent.gameObject.SetActive(value: false);
			}
		}
		else if (!joiningRoom)
		{
			messageDisplayText.text = LocalizationManager.GetTranslation(PhotonNetwork.NetworkClientState.ToString());
			messageDisplayText.transform.parent.gameObject.SetActive(value: true);
			if (!PhotonNetwork.IsConnected)
			{
				createRoomButton.SetActive(value: false);
				keyboard.SetActive(value: false);
				createRoomScreen.SetActive(value: false);
			}
		}
	}

	public override void OnRoomListUpdate(List<RoomInfo> roomList)
	{
		ClearRoomList();
		UpdateCachedRoomList(roomList);
		UpdateRoomList();
	}

	private void UpdateRoomList()
	{
		if (PhotonNetwork.NetworkClientState == ClientState.Disconnected)
		{
			return;
		}
		foreach (RoomInfo value in cachedRoomList.Values)
		{
			if ((isPrivateTab && value.IsPrivate()) || (!isPrivateTab && !value.IsPrivate()))
			{
				RoomButton roomButton = UnityEngine.Object.Instantiate(roomButtonPrefab);
				roomButtonObjs.Add(roomButton);
				roomButton.gameObject.transform.SetParent(list);
				roomButton.transform.localScale = new Vector3(1f, 1f, 1f);
				roomButton.transform.localPosition = Vector3.zero;
				roomButton.SetData(value);
				_ = value.Name;
			}
		}
		if (roomButtonObjs.Count == 0)
		{
			noRoomsFound.SetActive(value: true);
		}
		else
		{
			noRoomsFound.SetActive(value: false);
		}
	}

	private void UpdateCachedRoomList(List<RoomInfo> roomList)
	{
		foreach (RoomInfo room in roomList)
		{
			if (!room.IsOpen || !room.IsVisible || room.RemovedFromList)
			{
				if (cachedRoomList.ContainsKey(room.Name))
				{
					cachedRoomList.Remove(room.Name);
				}
			}
			else if (cachedRoomList.ContainsKey(room.Name))
			{
				cachedRoomList[room.Name] = room;
			}
			else
			{
				cachedRoomList.Add(room.Name, room);
			}
		}
	}

	private void ClearRoomList()
	{
		foreach (RoomButton roomButtonObj in roomButtonObjs)
		{
			UnityEngine.Object.Destroy(roomButtonObj.gameObject);
		}
		roomButtonObjs.Clear();
	}

	public void OnCreateRoomButton()
	{
		roomSelectionScreen.SetActive(value: false);
		createRoomScreen.SetActive(value: true);
	}

	public void OnPublicButton()
	{
		RoomHelper.CreateRoom();
		OnBackToRoomListButton();
		noRoomsFound.SetActive(value: false);
		roomSelectionScreen.SetActive(value: false);
	}

	public void OnPrivateButton()
	{
		roomSelectionScreen.SetActive(value: false);
		keyboard.SetActive(value: true);
		createRoomScreen.SetActive(value: false);
		passwordInput.text = "";
		Init(OnPasswordSet);
	}

	public void OnPublicTab()
	{
		isPrivateTab = false;
		privateTab.Active(x: false);
		publicTab.Active(x: true);
		ClearRoomList();
		UpdateRoomList();
	}

	public void OnPrivateTab()
	{
		isPrivateTab = true;
		privateTab.Active(x: true);
		publicTab.Active(x: false);
		ClearRoomList();
		UpdateRoomList();
	}

	public void OnKeyboardButton(string s)
	{
		if (passwordInput.text.Length < 12)
		{
			passwordInput.text += s;
		}
	}

	public void OnDeleteButton()
	{
		if (passwordInput.text.Length > 0)
		{
			passwordInput.text = passwordInput.text.Substring(0, passwordInput.text.Length - 1);
		}
	}

	public void OnBackToRoomListButton()
	{
		roomSelectionScreen.SetActive(value: true);
		createRoomScreen.SetActive(value: false);
		keyboard.SetActive(value: false);
		if (PhotonNetwork.InRoom)
		{
			PhotonNetwork.LeaveRoom(becomeInactive: false);
		}
	}

	public void OnBackButton()
	{
		GameManager.instance.BackToMainMenu();
	}

	public void OnDoneButton()
	{
		string text = passwordInput.text;
		if (text.Length > 0)
		{
			if (doneCallback != null)
			{
				doneCallback(text);
			}
		}
		else
		{
			OBManager.instance.PlayOBSFX();
		}
	}

	private void OnPasswordSet(string password)
	{
		messageDisplayText.transform.parent.gameObject.SetActive(value: true);
		RoomHelper.CreateRoom(password);
	}

	public void InputtingPassword(string p, string roomName)
	{
		keyboard.SetActive(value: true);
		roomSelectionScreen.SetActive(value: false);
		messageDisplayText.transform.parent.gameObject.SetActive(value: false);
		Init(delegate(string password)
		{
			if (password == p)
			{
				createRoomScreen.SetActive(value: false);
				keyboard.SetActive(value: false);
				noRoomsFound.SetActive(value: false);
				messageDisplayText.transform.parent.gameObject.SetActive(value: true);
				LobbyManager.instance.DownloadHoles(selectedRoom);
			}
			else
			{
				LobbyManager.instance.StartCoroutine(LobbyManager.instance.ShowIncorrectPassword());
			}
		});
	}
}
public class AudioManager : MonoBehaviour
{
	public AudioMixer mixer;

	public AudioSource musicAudioSource;

	public AudioSource ambientAudioSource;

	[Header("==Music==")]
	public AudioClip menuMusic;

	public AudioClip levelEditorMusic;

	public AudioClip springMusic1;

	public AudioClip springMusic2;

	public AudioClip autumnMusic1;

	public AudioClip autumnMusic2;

	public AudioClip winterMusic1;

	public AudioClip winterMusic2;

	public AudioClip easyCampaignMusic1;

	public AudioClip easyCampaignMusic2;

	public AudioClip easyCampaignMusic3;

	public AudioClip mediumCampaignMusic1;

	public AudioClip mediumCampaignMusic2;

	public AudioClip mediumCampaignMusic3;

	public AudioClip hardCampaignMusic1;

	public AudioClip hardCampaignMusic2;

	public AudioClip hardCampaignMusic3;

	public AudioClip minigolfDungeonMusic1;

	public AudioClip minigolfDungeonMusic2;

	public AudioClip scoreMusic;

	public AudioClip boss1Music;

	public AudioClip boss1LoopMusic;

	public AudioClip boss2Music;

	public AudioClip boss3Music;

	public AudioClip boss3LoopMusic;

	public AudioClip victoryMusic;

	[Header("==Ambient==")]
	public AudioClip ambientEasy;

	public AudioClip ambientMedium;

	public AudioClip ambientHard;

	[Header("==SFX==")]
	public AudioClip screenshotSnap;

	public AudioClip blockedSfx;

	private float musicFade = 1f;

	private float step = 0.3f;

	public Song currentSong;

	private float ambientFade = 0.5f;

	private float ambientMaxVolume = 0.5f;

	[Header("==Audio==")]
	public AudioMixer audioMixer;

	public AudioMixerGroup musicMixerGroup;

	public AudioMixerGroup sfxMixerGroup;

	public AudioMixerGroup ambientMixerGroup;

	private bool musicOn = true;

	private bool sfxOn = true;

	private bool ambientOn = true;

	private float musicVolume;

	private float sfxVolume;

	private float ambientVolume;

	private void Awake()
	{
		audioMixer.GetFloat("MusicVolume", out musicVolume);
		audioMixer.GetFloat("SFXVolume", out sfxVolume);
		audioMixer.GetFloat("AmbientVolume", out ambientVolume);
		audioMixer.SetFloat("MusicVolume", PlayerPrefs.GetFloat("MusicVolume", musicVolume));
		audioMixer.SetFloat("SFXVolume", PlayerPrefs.GetFloat("SFXVolume", sfxVolume));
		audioMixer.SetFloat("AmbientVolume", PlayerPrefs.GetFloat("AmbientVolume", ambientVolume));
	}

	private void Start()
	{
		musicAudioSource.clip = menuMusic;
		musicAudioSource.Play();
		ambientAudioSource.clip = null;
		ambientAudioSource.volume = ambientMaxVolume;
		currentSong = Song.menu;
	}

	private void Update()
	{
		LoopBossSong();
	}

	public void UpdateMusic()
	{
		if (GameManager.instance.currentSceneName == "LevelEditor" || GameManager.instance.currentSceneName == "LevelEditorArt")
		{
			if (currentSong != Song.levelEditor)
			{
				StopAllCoroutines();
				StartCoroutine(FadeOut(Song.levelEditor));
			}
		}
		else
		{
			if (GameManager.instance.currentSceneName.Contains("Boss"))
			{
				return;
			}
			if (!GameManager.instance.currentSceneName.Contains("Hole"))
			{
				if (currentSong != Song.menu)
				{
					StopAllCoroutines();
					StartCoroutine(FadeOut(Song.menu));
				}
				return;
			}
			Song song = Song.easyCampaign1;
			WorkshopData workshopData = GameManager.instance.holeData[GameManager.instance.holeIndex];
			if (workshopData.cloudlandsVersion == 1)
			{
				song = ((!workshopData.defaultHole) ? LevelEditor.LoadCL1LevelData(workshopData.fileLocation) : LevelEditor.LoadCL1LevelData(workshopData.fileLocation, cloudlandsHole: true)).song;
			}
			else if (workshopData.cloudlandsVersion == 2)
			{
				song = ((!workshopData.defaultHole) ? LevelEditor.LoadLevelData(workshopData.fileLocation) : LevelEditor.LoadLevelData(workshopData.fileLocation, cloudlandsHole: true)).song;
			}
			if (song != currentSong)
			{
				StopAllCoroutines();
				StartCoroutine(FadeOut(song));
			}
		}
	}

	public void PlayBossSong(Song song)
	{
		musicAudioSource.clip = null;
		ambientAudioSource.clip = null;
		StopAllCoroutines();
		StartCoroutine(FadeOut(song));
	}

	private IEnumerator FadeOut(Song songToPlay)
	{
		currentSong = songToPlay;
		while (musicFade > 0f)
		{
			musicFade -= Time.deltaTime * step;
			musicAudioSource.volume = musicFade;
			if (ambientFade > 0f)
			{
				ambientFade -= Time.deltaTime * step;
				ambientAudioSource.volume = ambientFade;
			}
			yield return null;
		}
		if (songToPlay != Song.noMusic)
		{
			StartCoroutine(FadeIn(songToPlay));
		}
	}

	private IEnumerator FadeIn(Song songToPlay)
	{
		switch (songToPlay)
		{
		default:
			musicAudioSource.clip = springMusic1;
			ambientAudioSource.clip = ambientEasy;
			break;
		case Song.spring2:
			musicAudioSource.clip = springMusic2;
			ambientAudioSource.clip = ambientEasy;
			break;
		case Song.autumn1:
			musicAudioSource.clip = autumnMusic1;
			ambientAudioSource.clip = ambientMedium;
			break;
		case Song.autumn2:
			musicAudioSource.clip = autumnMusic2;
			ambientAudioSource.clip = ambientMedium;
			break;
		case Song.winter1:
			musicAudioSource.clip = winterMusic1;
			ambientAudioSource.clip = ambientHard;
			break;
		case Song.winter2:
			musicAudioSource.clip = winterMusic2;
			ambientAudioSource.clip = ambientHard;
			break;
		case Song.menu:
			musicAudioSource.clip = menuMusic;
			ambientAudioSource.clip = null;
			break;
		case Song.levelEditor:
			musicAudioSource.clip = levelEditorMusic;
			ambientAudioSource.clip = null;
			break;
		case Song.easyCampaign1:
			musicAudioSource.clip = easyCampaignMusic1;
			ambientAudioSource.clip = ambientEasy;
			break;
		case Song.easyCampaign2:
			musicAudioSource.clip = easyCampaignMusic2;
			ambientAudioSource.clip = ambientEasy;
			break;
		case Song.easyCampaign3:
			musicAudioSource.clip = easyCampaignMusic3;
			ambientAudioSource.clip = ambientEasy;
			break;
		case Song.mediumCampaign1:
			musicAudioSource.clip = mediumCampaignMusic1;
			ambientAudioSource.clip = ambientMedium;
			break;
		case Song.mediumCampaign2:
			musicAudioSource.clip = mediumCampaignMusic2;
			ambientAudioSource.clip = ambientMedium;
			break;
		case Song.mediumCampaign3:
			musicAudioSource.clip = mediumCampaignMusic3;
			ambientAudioSource.clip = ambientMedium;
			break;
		case Song.hardCampaign1:
			musicAudioSource.clip = hardCampaignMusic1;
			ambientAudioSource.clip = ambientHard;
			break;
		case Song.hardCampaign2:
			musicAudioSource.clip = hardCampaignMusic2;
			ambientAudioSource.clip = ambientHard;
			break;
		case Song.hardCampaign3:
			musicAudioSource.clip = hardCampaignMusic3;
			ambientAudioSource.clip = ambientHard;
			break;
		case Song.minigolfDungeon1:
			musicAudioSource.clip = minigolfDungeonMusic1;
			ambientAudioSource.clip = ambientEasy;
			break;
		case Song.minigolfDungeon2:
			musicAudioSource.clip = minigolfDungeonMusic2;
			ambientAudioSource.clip = ambientEasy;
			break;
		case Song.score:
			musicAudioSource.clip = scoreMusic;
			ambientAudioSource.clip = null;
			break;
		case Song.boss1:
			musicAudioSource.clip = boss1Music;
			ambientAudioSource.clip = null;
			break;
		case Song.boss2:
			musicAudioSource.clip = boss2Music;
			ambientAudioSource.clip = null;
			break;
		case Song.boss3:
			musicAudioSource.clip = boss3Music;
			ambientAudioSource.clip = null;
			break;
		case Song.victory:
			musicAudioSource.clip = victoryMusic;
			ambientAudioSource.clip = null;
			break;
		case Song.noMusic:
			musicAudioSource.clip = null;
			ambientAudioSource.clip = null;
			break;
		}
		musicAudioSource.Play();
		if (ambientAudioSource.clip != null)
		{
			ambientAudioSource.Play();
		}
		else
		{
			ambientAudioSource.Stop();
		}
		if (currentSong == Song.mediumCampaign1 || currentSong == Song.mediumCampaign2 || currentSong == Song.mediumCampaign3)
		{
			ambientMaxVolume = 0.15f;
		}
		else
		{
			ambientMaxVolume = 0.5f;
		}
		while (musicFade < 1f)
		{
			musicFade += Time.deltaTime * step;
			musicAudioSource.volume = musicFade;
			if (ambientFade < ambientMaxVolume)
			{
				ambientFade += Time.deltaTime * step;
				ambientAudioSource.volume = ambientFade;
			}
			yield return null;
		}
	}

	public void ChangeMusic(Song songToPlay)
	{
		StartCoroutine(FadeIn(songToPlay));
	}

	private void LoopBossSong()
	{
		if (!GameManager.instance.currentSceneName.Contains("Boss"))
		{
			return;
		}
		if (currentSong == Song.boss1 || currentSong == Song.boss3)
		{
			if (musicAudioSource.clip != null && musicAudioSource.time >= musicAudioSource.clip.length)
			{
				if (currentSong == Song.boss1)
				{
					musicAudioSource.loop = false;
					musicAudioSource.clip = boss1LoopMusic;
				}
				else if (currentSong == Song.boss3)
				{
					musicAudioSource.loop = false;
					musicAudioSource.clip = boss3LoopMusic;
				}
				musicAudioSource.time = 0f;
				musicAudioSource.Play();
			}
		}
		else if (currentSong == Song.victory)
		{
			musicAudioSource.loop = false;
		}
		else
		{
			musicAudioSource.loop = true;
		}
	}

	public IEnumerator FadeOutAllSounds()
	{
		float vol = 1f;
		while (vol > 0f)
		{
			vol = (AudioListener.volume = vol - Time.deltaTime);
			yield return null;
		}
	}

	public IEnumerator FadeInAllSounds()
	{
		float vol = 0f;
		while (vol < 1f)
		{
			vol = (AudioListener.volume = vol + Time.deltaTime);
			yield return null;
		}
	}

	public bool ToggleMusic()
	{
		float value = musicVolume;
		if (musicOn)
		{
			value = -80f;
		}
		audioMixer.SetFloat("MusicVolume", value);
		PlayerPrefs.SetFloat("MusicVolume", value);
		musicOn = !musicOn;
		return musicOn;
	}

	public bool ToggleSFX()
	{
		float value = sfxVolume;
		if (sfxOn)
		{
			value = -80f;
		}
		audioMixer.SetFloat("SFXVolume", value);
		PlayerPrefs.SetFloat("SFXVolume", value);
		sfxOn = !sfxOn;
		return sfxOn;
	}

	public bool ToggleAmbient()
	{
		float value = ambientVolume;
		if (ambientOn)
		{
			value = -80f;
		}
		audioMixer.SetFloat("AmbientVolume", value);
		PlayerPrefs.SetFloat("AmbientVolume", value);
		ambientOn = !ambientOn;
		return ambientOn;
	}

	public bool GetMusicOn()
	{
		return musicOn;
	}

	public bool GetSFXOn()
	{
		return sfxOn;
	}

	public bool GetAmbientOn()
	{
		return ambientOn;
	}
}
public enum Song
{
	menu = -1,
	spring1,
	autumn1,
	winter1,
	spring2,
	autumn2,
	winter2,
	levelEditor,
	easyCampaign1,
	easyCampaign2,
	easyCampaign3,
	mediumCampaign1,
	mediumCampaign2,
	mediumCampaign3,
	hardCampaign1,
	hardCampaign2,
	hardCampaign3,
	minigolfDungeon1,
	minigolfDungeon2,
	score,
	boss1,
	boss2,
	boss3,
	noMusic,
	victory
}
public class GameManager : MonoBehaviour
{
	public static GameManager instance;

	public ControllerType controllerType;

	public PublishedPlatform publishedPlatform;

	public GameMode gameMode;

	public Difficulty campaignDifficulty;

	public GameObject VivePlayerPrefab;

	public GameObject QuestPlayerPrefab;

	public GameObject FPSControllerPrefab;

	public GameObject XRPlayerPrefab;

	public GameObject PicoPlayerPrefab;

	public GameObject golfBallSpawnerPrefab;

	public GameObject pauseMenuPrefab;

	public GameObject quickMenuPrefab;

	public GameObject holeInfoPrefab;

	public GameObject holeRatingPrefab;

	public GameObject keyboardPrefab;

	public GameObject playerTurnPromptPrefab;

	public GameObject notificationPrefab;

	public GameObject ballHitDetectorPrefab;

	public GameObject campaignMapPrefab;

	public GameObject beaconPrefab;

	[HideInInspector]
	public AudioManager audioManager;

	[Header("Golfballs")]
	public GameObject golfballPrefab;

	public GameObject gumballPrefab;

	public GameObject iceballPrefab;

	public GameObject airballPrefab;

	[HideInInspector]
	public Player player;

	[HideInInspector]
	public PauseMenu pauseMenu;

	[HideInInspector]
	public QuickMenu quickMenu;

	[HideInInspector]
	public Golfball golfball;

	[HideInInspector]
	public GameObject ballHitDetection;

	[HideInInspector]
	public GameObject holeInfoNotification;

	[HideInInspector]
	public GameObject initialsKeyboard;

	[HideInInspector]
	public SwingAnalysis swingAnalysis;

	[HideInInspector]
	public GameObject unparentedTrails;

	[HideInInspector]
	public GameAchievements gameAchievements;

	public int holeIndex;

	public int photonHoleIndex;

	public string levelsPath;

	private List<GameObject>[] piecesHashTable;

	public GameObject debugLineRendererPrefab;

	[HideInInspector]
	public Scene currentScene;

	[HideInInspector]
	public string currentSceneName;

	[HideInInspector]
	public bool loadingLevel;

	[HideInInspector]
	public bool finishedFadeOut = true;

	public int playerCount = 1;

	public int playerIndex;

	private int mulliganGreater9Holes = 5;

	private int mulliganLess9Holes = 3;

	public bool canMulligan;

	public List<WorkshopData> holeData = new List<WorkshopData>();

	[HideInInspector]
	public List<WorkshopURLLocation> holeDataServerLocation = new List<WorkshopURLLocation>();

	[NonSerialized]
	public WorkshopData playlistLeaderboardData;

	public LightingData[] LightingSettings;

	public bool pieceHashGenerated;

	public bool campaignHolesFetched;

	[HideInInspector]
	public WorkshopData[] campaignWorkshopData = new WorkshopData[54];

	public bool finishedCampaign;

	private bool micState;

	private bool greenSlopeLines;

	public bool hideBosses = true;

	public bool unlockAllHoles;

	[HideInInspector]
	public bool canProceedThroughBossLoadingScreen;

	public bool hasRecenteredXRController;

	private void Awake()
	{
		instance = this;
		SetupHardware();
		levelsPath = UnityEngine.Application.persistentDataPath + "/levels/";
		LevelEditor.InitializeCustomLevelDetails();
		micState = PlayerPrefsX.GetBool("MicState", defaultValue: true);
		greenSlopeLines = PlayerPrefsX.GetBool("GreenSlopeLines", defaultValue: true);
		string @string = PlayerPrefs.GetString("CurrentLanguage", "None");
		MonoBehaviour.print("savedLang: " + @string);
		if (@string.Equals("None"))
		{
			if (UnityEngine.Application.systemLanguage == SystemLanguage.English)
			{
				LocalizationManager.CurrentLanguage = "English";
			}
			else if (UnityEngine.Application.systemLanguage == SystemLanguage.Chinese || UnityEngine.Application.systemLanguage == SystemLanguage.ChineseSimplified || UnityEngine.Application.systemLanguage == SystemLanguage.ChineseTraditional)
			{
				LocalizationManager.CurrentLanguage = "Simplified Chinese";
			}
			else if (UnityEngine.Application.systemLanguage == SystemLanguage.Korean)
			{
				LocalizationManager.CurrentLanguage = "Korean";
			}
			else if (UnityEngine.Application.systemLanguage == SystemLanguage.Japanese)
			{
				LocalizationManager.CurrentLanguage = "Japanese";
			}
			else
			{
				LocalizationManager.CurrentLanguage = "English";
			}
		}
		else
		{
			LocalizationManager.CurrentLanguage = @string;
		}
		SetLanguage(LocalizationManager.CurrentLanguage);
	}

	private void Start()
	{
		swingAnalysis = GetComponentInChildren<SwingAnalysis>();
		gameAchievements = GetComponent<GameAchievements>();
		SpawnPlayer();
		pauseMenu = UnityEngine.Object.Instantiate(pauseMenuPrefab).GetComponent<PauseMenu>();
		SceneManager.MoveGameObjectToScene(pauseMenu.gameObject, SceneManager.GetSceneByName("Main"));
		quickMenu = UnityEngine.Object.Instantiate(quickMenuPrefab).GetComponent<QuickMenu>();
		SceneManager.MoveGameObjectToScene(quickMenu.gameObject, SceneManager.GetSceneByName("Main"));
		SceneManager.MoveGameObjectToScene(UnityEngine.Object.Instantiate(notificationPrefab), SceneManager.GetSceneByName("Main"));
		ballHitDetection = UnityEngine.Object.Instantiate(ballHitDetectorPrefab);
		SceneManager.MoveGameObjectToScene(ballHitDetection, SceneManager.GetSceneByName("Main"));
		audioManager = GetComponent<AudioManager>();
		StartCoroutine(DelaySetLanguage());
	}

	private void Update()
	{
		if (PhotonNetwork.IsConnected && PhotonNetwork.InRoom)
		{
			photonHoleIndex = PhotonNetwork.CurrentRoom.GetHoleIndex();
		}
	}

	public void SetupHardware()
	{
		UnityEngine.Debug.Log("No platform directive specified: staying with set controller type");
	}

	private void SpawnPlayer()
	{
		if (publishedPlatform == PublishedPlatform.XR)
		{
			SetSwingConstraint(x: true);
		}
		else
		{
			SetSwingConstraint(x: false);
		}
		if (controllerType == ControllerType.Vive)
		{
			player = UnityEngine.Object.Instantiate(VivePlayerPrefab).GetComponent<Player>();
		}
		else if (controllerType == ControllerType.FPS)
		{
			player = UnityEngine.Object.Instantiate(FPSControllerPrefab).GetComponent<Player>();
		}
		else if (controllerType == ControllerType.Quest)
		{
			player = UnityEngine.Object.Instantiate(QuestPlayerPrefab).GetComponent<Player>();
		}
		else if (controllerType == ControllerType.XR)
		{
			XRSettings.enabled = false;
			SetClubLength("Medium");
			player = UnityEngine.Object.Instantiate(XRPlayerPrefab).GetComponent<Player>();
		}
		else if (controllerType == ControllerType.Pico)
		{
			player = UnityEngine.Object.Instantiate(PicoPlayerPrefab).GetComponent<Player>();
		}
		SceneManager.MoveGameObjectToScene(player.gameObject, base.gameObject.scene);
	}

	public void LoadNextHole(bool incrementHole = true)
	{
		if (loadingLevel)
		{
			return;
		}
		ScoreManager.instance.currentStrokeCount = 0;
		if (!PhotonNetwork.IsConnected)
		{
			if (playerCount == 1)
			{
				if (incrementHole)
				{
					holeIndex++;
				}
			}
			else
			{
				holeIndex = ScoreManager.instance.playerTurn[playerIndex].holeIndex;
			}
		}
		if (currentSceneName.Contains("Boss"))
		{
			SwitchToScene(currentSceneName);
		}
		else if (holeIndex < holeData.Count && holeIndex != -1)
		{
			SwitchToScene("CustomHoleScene");
			Player.instance.currentController.SwitchToClubs();
		}
		else
		{
			SwitchToScene("ScoreScene");
		}
	}

	public void BackToRoomPrepScene(bool clearHoleData = true)
	{
		holeIndex = 0;
		playlistLeaderboardData = null;
		if (clearHoleData)
		{
			holeData.Clear();
			holeDataServerLocation.Clear();
			ScoreManager.instance.SetHolePars();
		}
		SwitchToScene("RoomPrepScene");
	}

	public void SwitchToScene(string sceneToLoad, float delay = 2f)
	{
		if (!loadingLevel)
		{
			if (pauseMenu.paused)
			{
				pauseMenu.TogglePause();
			}
			loadingLevel = true;
			StartCoroutine(SwitchToScene_(sceneToLoad, delay));
		}
	}

	private IEnumerator SwitchToScene_(string sceneToLoad, float delay = 2f)
	{
		bool updatePhotonScores = false;
		float time2 = Time.realtimeSinceStartup;
		OBManager.instance.ResetOBStatus();
		StartCoroutine(player.FadeOut());
		if (holeInfoNotification != null)
		{
			UnityEngine.Object.Destroy(holeInfoNotification);
		}
		UnityEngine.AsyncOperation async = null;
		if (currentScene.name == "Splash" || (currentScene.name == "Tutorial" && !pieceHashGenerated) || sceneToLoad.Contains("Boss"))
		{
			async = SceneManager.LoadSceneAsync(sceneToLoad, LoadSceneMode.Additive);
			async.allowSceneActivation = false;
		}
		while (!finishedFadeOut)
		{
			yield return null;
		}
		_ = controllerType;
		int sceneToUnload = currentScene.buildIndex;
		if (async != null)
		{
			if (sceneToLoad.Contains("Boss"))
			{
				canProceedThroughBossLoadingScreen = false;
				StartCoroutine(player.ShowBossLoadingScreen(sceneToLoad, async));
			}
			else
			{
				canProceedThroughBossLoadingScreen = true;
			}
			while (async.progress < 0.9f)
			{
				yield return null;
			}
			time2 = Time.realtimeSinceStartup - time2;
			if (time2 < delay)
			{
				yield return new WaitForSeconds(delay - time2);
			}
			while (!canProceedThroughBossLoadingScreen)
			{
				yield return null;
			}
			async.allowSceneActivation = true;
		}
		else
		{
			SceneManager.LoadScene(sceneToLoad, LoadSceneMode.Additive);
		}
		if (PhotonNetwork.InRoom && currentSceneName == "LobbyScene")
		{
			updatePhotonScores = true;
		}
		SceneManager.UnloadSceneAsync(sceneToUnload);
		currentScene = SceneManager.GetSceneByName(sceneToLoad);
		currentSceneName = currentScene.name;
		while (!currentScene.isLoaded)
		{
			yield return null;
		}
		StartCoroutine(ScoreManager.instance.SwapScorecards());
		loadingLevel = false;
		OBManager.instance.ResetOBStatus();
		SceneManager.SetActiveScene(currentScene);
		audioManager.UpdateMusic();
		PhotonNetwork.LocalPlayer.SetScene(currentSceneName);
		if (PhotonNetwork.IsConnected)
		{
			PhotonNetwork.LocalPlayer.SetLoadingLevel(loading: false);
			if (updatePhotonScores)
			{
				RoomRPC.instance.pView.RPC("SetOtherPlayersPhotonScore", RpcTarget.Others, false);
			}
		}
		ItemManager.instance.ResetVariables();
		if (IsCloudlands1Hole())
		{
			OBManager.instance.ballRespawnTimerDelay = OBManager.instance.cloudlands1RespawnTime;
		}
		else
		{
			OBManager.instance.ballRespawnTimerDelay = OBManager.instance.cloudlands2RespawnTime;
		}
		MonoBehaviour.print("Unloading Assets");
		Resources.UnloadUnusedAssets();
		StartCoroutine(Player.instance.FadeIn());
	}

	public static int Hash(string s)
	{
		int num = 7;
		char[] array = s.ToCharArray();
		for (int i = 0; i < array.Length; i++)
		{
			num = 65599 * num + array[i];
		}
		return num;
	}

	public GameObject GetEditorPieceByNameHash(int nameHash)
	{
		GameObject result = null;
		int num = Mathf.Abs(nameHash) % piecesHashTable.Length;
		for (int i = 0; i < piecesHashTable[num].Count; i++)
		{
			if (Hash(piecesHashTable[num][i].name) == nameHash)
			{
				result = piecesHashTable[num][i];
			}
		}
		return result;
	}

	public void GeneratePieceHashTable(GameObject[] pieces)
	{
		piecesHashTable = new List<GameObject>[pieces.Length];
		int num = 0;
		for (int i = 0; i < pieces.Length; i++)
		{
			if (pieces[i] != null)
			{
				int num2 = Mathf.Abs(Hash(pieces[i].name)) % piecesHashTable.Length;
				if (piecesHashTable[num2] == null)
				{
					piecesHashTable[num2] = new List<GameObject>();
					num++;
				}
				piecesHashTable[num2].Add(pieces[i]);
			}
		}
	}

	public void CheckForHashCollisions(GameObject[] pieces)
	{
		bool flag = false;
		int[] array = new int[pieces.Length];
		for (int i = 0; i < pieces.Length; i++)
		{
			if (!(pieces[i] != null))
			{
				continue;
			}
			int num = Hash(pieces[i].name);
			for (int j = 0; j < i; j++)
			{
				if (num == array[j])
				{
					flag = true;
					MonoBehaviour.print("hash collision between: " + pieces[i].name + " and " + GetEditorPieceByNameHash(array[j]).name + "\n at index: " + i + " and " + j);
					break;
				}
			}
			if (!flag)
			{
				array[i] = num;
				continue;
			}
			break;
		}
	}

	public void SetCurrentScene(Scene scene)
	{
		currentScene = scene;
		currentSceneName = scene.name;
	}

	public void Concede(bool doubleStrokes = true)
	{
		golfball.GetComponent<Rigidbody>().velocity = Vector3.zero;
		GameObject nearestHoleFromPos = GetNearestHoleFromPos(player.transform.position);
		golfball.transform.position = nearestHoleFromPos.GetComponent<Golfhole>().holePoint.position;
		golfball.GetComponent<Golfball>().previousPosition = golfball.transform.position;
		if (doubleStrokes)
		{
			if (ScoreManager.instance.pars[holeIndex] == 0)
			{
				ScoreManager.instance.currentStrokeCount = 1;
			}
			else if (ScoreManager.instance.pars[holeIndex] * 2 > ScoreManager.instance.currentStrokeCount)
			{
				ScoreManager.instance.currentStrokeCount = ((ScoreManager.instance.pars[holeIndex] * 2 < 99) ? (ScoreManager.instance.pars[holeIndex] * 2) : 99);
			}
		}
		else if (ScoreManager.instance.currentStrokeCount == 0)
		{
			ScoreManager.instance.currentStrokeCount = 1;
		}
		nearestHoleFromPos.GetComponent<Golfhole>().BallScored();
		if (!PhotonNetwork.IsConnected)
		{
			return;
		}
		PhotonBall[] array = UnityEngine.Object.FindObjectsOfType<PhotonBall>();
		foreach (PhotonBall photonBall in array)
		{
			if (photonBall.photonView.IsMine)
			{
				photonBall.photonView.RPC("ResetTrail", RpcTarget.Others, photonBall.photonView.Owner, true, false);
			}
		}
	}

	public GameObject GetNearestHoleFromPos(Vector3 pos)
	{
		GameObject result = null;
		GameObject[] array = GameObject.FindGameObjectsWithTag("Hole");
		float num = float.PositiveInfinity;
		for (int i = 0; i < array.Length; i++)
		{
			float num2 = Vector3.Distance(array[i].transform.position, pos);
			if (array[i].GetComponent<Golfhole>() != null && num2 < num)
			{
				num = num2;
				result = array[i];
			}
		}
		return result;
	}

	public void CenterNotification(GameObject obj, bool useLerp = false)
	{
		Transform head = player.GetComponent<Player>().head;
		Vector3 forward = head.transform.forward;
		forward.y = 0f;
		forward.Normalize();
		forward *= 2f;
		forward += head.transform.position;
		Vector3 vector = forward;
		vector.y = head.transform.position.y;
		Quaternion quaternion = ((vector - head.transform.position != Vector3.zero) ? Quaternion.LookRotation(vector - head.transform.position) : Quaternion.identity);
		if (useLerp)
		{
			obj.transform.position = Vector3.Slerp(obj.transform.position, forward, Time.deltaTime * 1.75f);
			obj.transform.rotation = Quaternion.Slerp(obj.transform.rotation, quaternion * Quaternion.Euler(0f, 180f, 0f), 0.05f);
		}
		else
		{
			obj.transform.position = forward;
			obj.transform.rotation = quaternion * Quaternion.Euler(0f, 180f, 0f);
		}
		if (Vector3.Distance(Player.instance.head.position, obj.transform.position) > 3f)
		{
			obj.transform.position = forward;
		}
	}

	public void SetBallType(BallType type)
	{
		if (golfball != null)
		{
			GameObject gameObject = null;
			switch (type)
			{
			case BallType.Normal:
				gameObject = UnityEngine.Object.Instantiate(golfballPrefab, golfball.transform.position, golfball.transform.rotation);
				break;
			case BallType.Gumball:
				gameObject = UnityEngine.Object.Instantiate(gumballPrefab, golfball.transform.position, golfball.transform.rotation);
				break;
			case BallType.Iceball:
				gameObject = UnityEngine.Object.Instantiate(iceballPrefab, golfball.transform.position, golfball.transform.rotation);
				break;
			case BallType.Airball:
				gameObject = UnityEngine.Object.Instantiate(airballPrefab, golfball.transform.position, golfball.transform.rotation);
				break;
			}
			UnityEngine.Object.Destroy(golfball.gameObject);
			golfball = gameObject.GetComponent<Golfball>();
			SaveFileManager.instance.saveFile.equippedBall = type;
			SaveFileManager.instance.SaveFile();
		}
	}

	public void BackToMainMenu()
	{
		playerCount = 1;
		playerIndex = 0;
		holeIndex = 0;
		playlistLeaderboardData = null;
		gameMode = GameMode.None;
		holeData.Clear();
		holeDataServerLocation.Clear();
		ScoreManager.instance.SetHolePars();
		ScoreManager.instance.ResetStrokeTable(resetNames: true);
		ResetMulligans();
		ResetPanelsAndDisconnect();
		SwitchToScene("MainMenu");
		RichPresenceManager.instance.inParty = false;
	}

	public void BackToLobby()
	{
		holeIndex = 0;
		playlistLeaderboardData = null;
		holeData.Clear();
		holeDataServerLocation.Clear();
		ResetPanelsAndDisconnect();
		SwitchToScene("LobbyScene");
		RichPresenceManager.instance.inParty = false;
	}

	public void ResetPanelsAndDisconnect()
	{
		if (HoleSelectPanel.instance != null)
		{
			HoleSelectPanel.instance.ClearWorkshopImages();
		}
		if (PhotonNetwork.InRoom)
		{
			if (PhotonVoiceNetwork.Instance != null && PhotonVoiceNetwork.Instance.isActiveAndEnabled)
			{
				PhotonVoiceNetwork.Instance.Disconnect();
			}
			PhotonNetwork.LeaveRoom(becomeInactive: false);
		}
		if (PhotonNetwork.IsConnected)
		{
			PhotonNetwork.Disconnect();
		}
	}

	public void Mulligan()
	{
		if ((canMulligan && ScoreManager.instance.playerTurn[playerIndex].mulligansLeft > 0) || ScoreManager.instance.playerTurn[playerIndex].infiniteMulligan)
		{
			ScoreManager.instance.playerTurn[playerIndex].mulliganUsed = true;
			OBManager.instance.RevertLastPosition();
			ScoreManager.instance.RemoveStroke();
			canMulligan = false;
			if (ScoreManager.instance.playerTurn[playerIndex].mulligansLeft > 0 && (PhotonNetwork.IsConnected || playerCount > 1 || gameMode != 0))
			{
				ScoreManager.instance.playerTurn[playerIndex].mulligansLeft--;
			}
		}
	}

	public void SetMulligans()
	{
		for (int i = 0; i < playerCount; i++)
		{
			if (gameMode == GameMode.Campaign)
			{
				ScoreManager.instance.playerTurn[i].mulligansLeft = mulliganLess9Holes;
			}
			else if (holeData.Count > 9)
			{
				ScoreManager.instance.playerTurn[i].mulligansLeft = mulliganGreater9Holes;
			}
			else
			{
				ScoreManager.instance.playerTurn[i].mulligansLeft = mulliganLess9Holes;
			}
			ScoreManager.instance.playerTurn[i].infiniteMulligan = false;
			ScoreManager.instance.playerTurn[i].mulliganUsed = false;
		}
	}

	public void SetCanMulligan(bool value = true)
	{
		if (playerCount == 1 && !PhotonNetwork.IsConnected)
		{
			if (gameMode == GameMode.Campaign)
			{
				if (ScoreManager.instance.playerTurn[playerIndex].mulligansLeft <= 0)
				{
					canMulligan = false;
				}
				else
				{
					canMulligan = value;
				}
			}
			else if (!IsPlaylist() && !ScoreManager.instance.playerTurn[playerIndex].infiniteMulligan && ScoreManager.instance.playerTurn[playerIndex].mulligansLeft <= 0)
			{
				canMulligan = value;
			}
			else if (ScoreManager.instance.playerTurn[playerIndex].infiniteMulligan || ScoreManager.instance.playerTurn[playerIndex].mulligansLeft > 0)
			{
				canMulligan = value;
			}
			else
			{
				canMulligan = false;
			}
		}
		else if (ScoreManager.instance.playerTurn[playerIndex].mulligansLeft > 0)
		{
			canMulligan = value;
		}
		else
		{
			canMulligan = false;
		}
	}

	public void ResetMulligans(bool resetEveryHole = false)
	{
		for (int i = 0; i < 3; i++)
		{
			if (resetEveryHole)
			{
				ScoreManager.instance.playerTurn[i].mulligansLeft = mulliganLess9Holes;
			}
			else
			{
				ScoreManager.instance.playerTurn[i].mulliganUsed = false;
				if (IsPlaylist())
				{
					if (holeData.Count > 9)
					{
						ScoreManager.instance.playerTurn[i].mulligansLeft = mulliganGreater9Holes;
					}
					else
					{
						ScoreManager.instance.playerTurn[i].mulligansLeft = mulliganLess9Holes;
					}
				}
				else
				{
					ScoreManager.instance.playerTurn[i].mulligansLeft = mulliganLess9Holes;
				}
			}
			ScoreManager.instance.playerTurn[i].infiniteMulligan = false;
		}
		canMulligan = false;
	}

	public List<WorkshopData> ReturnCloudlandsHolesFromIndexArray(int[] indexArray, Difficulty difficulty)
	{
		List<WorkshopData> list = new List<WorkshopData>();
		int num = 0;
		for (int i = 0; i < indexArray.Length; i++)
		{
			string text = "";
			switch (difficulty)
			{
			case Difficulty.Medium:
				num = 17;
				break;
			case Difficulty.Hard:
				num = 36;
				break;
			}
			text = "CampaignHoles/Hole";
			_ = Resources.LoadAll<TextAsset>("Holes/CampaignHoles/Hole" + (indexArray[i] + num))[0];
			CustomLevel customLevel = LevelEditor.LoadLevelData("CampaignHoles/Hole" + indexArray[i], cloudlandsHole: true);
			WorkshopData workshopData = new WorkshopData
			{
				defaultHole = true,
				par = customLevel.par,
				pieceCount = customLevel.pieces.Length,
				difficulty = (int)customLevel.difficulty,
				imageLocation = text + indexArray[i],
				fileLocation = text + indexArray[i],
				publishID = indexArray[i],
				golfClubType = (GolfClubType.Putter | GolfClubType.Iron | GolfClubType.Driver)
			};
			switch (difficulty)
			{
			case Difficulty.Easy:
				workshopData.levelName = "Green Glade " + indexArray[i];
				break;
			case Difficulty.Medium:
				workshopData.levelName = "Magic Meadow " + indexArray[i];
				break;
			default:
				workshopData.levelName = "Reaper Ruins " + indexArray[i];
				break;
			}
			list.Add(workshopData);
		}
		return list;
	}

	public void SpawnHoleInfoNotification(bool rating)
	{
		if (holeInfoNotification != null)
		{
			UnityEngine.Object.Destroy(holeInfoNotification);
		}
		if (rating)
		{
			holeInfoNotification = UnityEngine.Object.Instantiate(holeRatingPrefab);
		}
		else
		{
			holeInfoNotification = UnityEngine.Object.Instantiate(holeInfoPrefab);
		}
	}

	public void SpawnCampaignMapNotification()
	{
		if (holeInfoNotification != null)
		{
			UnityEngine.Object.Destroy(holeInfoNotification);
		}
		holeInfoNotification = UnityEngine.Object.Instantiate(campaignMapPrefab);
		CenterNotification(holeInfoNotification);
	}

	public void SpawnMainMenuNotification(string msg)
	{
		Notification.instance.AddNotification(msg, 0f, closeButton: true);
	}

	public bool ToggleShadows()
	{
		return true;
	}

	private IEnumerator DelaySetLanguage()
	{
		yield return new WaitForSeconds(3f);
		GetLanguage();
	}

	public void SetLanguage(string language)
	{
		PlayerPrefs.SetString("CurrentLanguage", language);
		LocalizationManager.CurrentLanguage = language;
	}

	public string GetLanguage()
	{
		return LocalizationManager.CurrentLanguage = PlayerPrefs.GetString("CurrentLanguage", "English");
	}

	public Color GetBallColor()
	{
		if (playerIndex == 0)
		{
			if (publishedPlatform == PublishedPlatform.XR)
			{
				return PlayerPrefsX.GetColor("BallColor", new Color32(byte.MaxValue, 31, 0, byte.MaxValue));
			}
			return PlayerPrefsX.GetColor("BallColor", new Color32(188, 188, 188, byte.MaxValue));
		}
		return ScoreManager.instance.playerTurn[playerIndex].ballColor;
	}

	public void SetBallColor(Color c, bool saveBallColor = true)
	{
		if (saveBallColor)
		{
			PlayerPrefsX.SetColor("BallColor", c);
		}
		GameObject[] array = GameObject.FindGameObjectsWithTag("Golfball");
		foreach (GameObject gameObject in array)
		{
			if ((bool)gameObject.GetComponent<Golfball>())
			{
				Golfball component = gameObject.GetComponent<Golfball>();
				component.ballRenderer.material.color = c;
				component.ChangeTrailColour(component.trail);
				break;
			}
		}
		if (Player.instance.clubSwitcher.currentType == ClubType.Putter)
		{
			Player.instance.clubSwitcher.currentClub.GetComponent<Putter>().SetAimLineColor(GetBallColor());
		}
	}

	public void SetMicState(bool x)
	{
		PlayerPrefsX.SetBool("MicState", x);
		micState = x;
	}

	public bool GetMicState()
	{
		return micState;
	}

	public bool GetHandedness()
	{
		return PlayerPrefsX.GetBool("RightHanded", defaultValue: true);
	}

	public void SetHandedness(bool rightHanded)
	{
		PlayerPrefsX.SetBool("RightHanded", rightHanded);
	}

	public ClubProfile GetClubProfile()
	{
		ClubProfile clubProfile = new ClubProfile();
		if (playerIndex != 0)
		{
			return ScoreManager.instance.playerTurn[playerIndex].clubProfile;
		}
		string text = (clubProfile.filePath = PlayerPrefs.GetString("ClubLength"));
		if (text == "Short")
		{
			clubProfile.driverLength = 41f;
			clubProfile.ironLength = 36.5f;
			clubProfile.putterLength = 30.5f;
		}
		else if (text == "Medium" || string.IsNullOrEmpty(text))
		{
			clubProfile.driverLength = 44f;
			clubProfile.ironLength = 39.5f;
			clubProfile.putterLength = 33.5f;
		}
		else if (text == "Long")
		{
			clubProfile.driverLength = 47f;
			clubProfile.ironLength = 42.5f;
			clubProfile.putterLength = 36.5f;
		}
		else if (File.Exists(text))
		{
			clubProfile = ReturnClubProfile(text);
			clubProfile.filePath = text;
			int bufferIndex = 0;
			byte[] buffer = File.ReadAllBytes(text);
			clubProfile.feet = kBufferUtil.ReadS32(ref buffer, ref bufferIndex);
			clubProfile.inches = kBufferUtil.ReadS32(ref buffer, ref bufferIndex);
			clubProfile.driverLength = kBufferUtil.ReadFloat(ref buffer, ref bufferIndex);
			clubProfile.ironLength = kBufferUtil.ReadFloat(ref buffer, ref bufferIndex);
			clubProfile.putterLength = kBufferUtil.ReadFloat(ref buffer, ref bufferIndex);
			int stringLength = kBufferUtil.ReadS32(ref buffer, ref bufferIndex);
			clubProfile.profileName = kBufferUtil.ReadString(ref buffer, ref bufferIndex, stringLength);
		}
		else
		{
			SetClubLength("Long");
			clubProfile.driverLength = 47f;
			clubProfile.ironLength = 42.5f;
			clubProfile.putterLength = 36.5f;
		}
		return clubProfile;
	}

	public ClubProfile ReturnClubProfile(string filePath)
	{
		ClubProfile clubProfile = new ClubProfile();
		FileInfo fileInfo = new FileInfo(filePath);
		if (fileInfo.Exists)
		{
			clubProfile.filePath = fileInfo.FullName;
			int bufferIndex = 0;
			byte[] buffer = File.ReadAllBytes(fileInfo.FullName);
			clubProfile.feet = kBufferUtil.ReadS32(ref buffer, ref bufferIndex);
			clubProfile.inches = kBufferUtil.ReadS32(ref buffer, ref bufferIndex);
			clubProfile.driverLength = kBufferUtil.ReadFloat(ref buffer, ref bufferIndex);
			clubProfile.ironLength = kBufferUtil.ReadFloat(ref buffer, ref bufferIndex);
			clubProfile.putterLength = kBufferUtil.ReadFloat(ref buffer, ref bufferIndex);
			int stringLength = kBufferUtil.ReadS32(ref buffer, ref bufferIndex);
			clubProfile.profileName = kBufferUtil.ReadString(ref buffer, ref bufferIndex, stringLength);
		}
		return clubProfile;
	}

	public void SetClubLength(string clubProfilePath)
	{
		if (playerIndex == 0)
		{
			PlayerPrefs.SetString("ClubLength", clubProfilePath);
		}
		ClubProfile clubProfile = ScoreManager.instance.playerTurn[playerIndex].clubProfile;
		if (clubProfilePath == "Short")
		{
			clubProfile.driverLength = 41f;
			clubProfile.ironLength = 36.5f;
			clubProfile.putterLength = 30.5f;
			clubProfile.filePath = "Short";
		}
		else if (clubProfilePath == "Medium" || string.IsNullOrEmpty(clubProfilePath))
		{
			clubProfile.driverLength = 44f;
			clubProfile.ironLength = 39.5f;
			clubProfile.putterLength = 33.5f;
			clubProfile.filePath = "Medium";
		}
		else if (clubProfilePath == "Long")
		{
			clubProfile.driverLength = 47f;
			clubProfile.ironLength = 42.5f;
			clubProfile.putterLength = 36.5f;
			clubProfile.filePath = "Long";
		}
	}

	public void UnlockHole(string course, int index)
	{
		if (index > GetUnlockedHoles(course))
		{
			PlayerPrefs.SetInt(course, index);
		}
	}

	public int GetUnlockedHoles(string course)
	{
		return PlayerPrefs.GetInt(course, 0);
	}

	public void SetUnlockedCampaign(int campaignIndex)
	{
		PlayerPrefsX.SetBool("Campaign" + campaignIndex + "Unlocked", value: true);
	}

	public bool GetUnlockedCampaign(int campaignIndex)
	{
		return PlayerPrefsX.GetBool("Campaign" + campaignIndex + "Unlocked", defaultValue: false);
	}

	public bool GetBallTrail()
	{
		return PlayerPrefsX.GetBool("BallTrail", defaultValue: true);
	}

	public void SetBallTrail(bool toggle)
	{
		PlayerPrefsX.SetBool("BallTrail", toggle);
	}

	public bool GetClubChangeOnWarp()
	{
		return PlayerPrefsX.GetBool("ClubChangeOnWarp", defaultValue: true);
	}

	public void SetClubChangeOnWarp(bool toggle)
	{
		PlayerPrefsX.SetBool("ClubChangeOnWarp", toggle);
	}

	public bool GetWarpToCenter()
	{
		if (publishedPlatform == PublishedPlatform.XR)
		{
			return PlayerPrefsX.GetBool("WarpToCenter", defaultValue: false);
		}
		return PlayerPrefsX.GetBool("WarpToCenter", defaultValue: true);
	}

	public bool GetWarpInAir()
	{
		return PlayerPrefsX.GetBool("WarpInAir", defaultValue: true);
	}

	public void SetClubPower(ClubType type, float power)
	{
		switch (type)
		{
		case ClubType.Driver:
			PlayerPrefs.SetFloat("DriverPower", power);
			break;
		case ClubType.Iron:
			PlayerPrefs.SetFloat("IronPower", power);
			break;
		case ClubType.Putter:
			PlayerPrefs.SetFloat("PutterPower", power);
			break;
		}
	}

	public float GetClubPower(ClubType type)
	{
		return type switch
		{
			ClubType.Driver => PlayerPrefs.GetFloat("DriverPower", 1f), 
			ClubType.Iron => PlayerPrefs.GetFloat("IronPower", 1f), 
			_ => PlayerPrefs.GetFloat("PutterPower", 1f), 
		};
	}

	public bool GetSwingConstraint()
	{
		return PlayerPrefsX.GetBool("ConstrainedSwing", defaultValue: false);
	}

	public void SetSwingConstraint(bool x)
	{
		PlayerPrefsX.SetBool("ConstrainedSwing", x);
	}

	public bool GetTutorial()
	{
		return PlayerPrefsX.GetBool("Tutorial", defaultValue: false);
	}

	public void SetTutorial(bool x)
	{
		PlayerPrefsX.SetBool("Tutorial", x);
	}

	public void SetGreenSlopeLines(bool x)
	{
		PlayerPrefsX.SetBool("GreenSlopeLines", x);
		greenSlopeLines = x;
	}

	public bool GetGreenSlopeLines()
	{
		return greenSlopeLines;
	}

	public void SetClubShadows(bool x)
	{
		PlayerPrefsX.SetBool("ClubShadows", x);
	}

	public bool GetClubShadows()
	{
		return PlayerPrefsX.GetBool("ClubShadows", defaultValue: false);
	}

	public void SetShowedFinishedCampaignMessage(bool x)
	{
		PlayerPrefsX.SetBool("ShowedFinishedCampaignMessage", x);
	}

	public bool GetShowedFinishedCampaignMessage()
	{
		return PlayerPrefsX.GetBool("ShowedFinishedCampaignMessage", defaultValue: false);
	}

	public bool IsCloudlands1Hole()
	{
		if (holeIndex >= 0 && holeIndex < holeData.Count && holeData[holeIndex].cloudlandsVersion == 1)
		{
			return true;
		}
		return false;
	}

	public bool IsPlaylist()
	{
		if (playlistLeaderboardData != null && (playlistLeaderboardData.cloudlandsPlaylist || (!instance.playlistLeaderboardData.localItem && instance.playlistLeaderboardData.publishID != 0)))
		{
			return true;
		}
		return false;
	}

	public void GetCampaignWorkshopData()
	{
		if (!campaignHolesFetched)
		{
			campaignHolesFetched = true;
			for (int i = 1; i <= 54; i++)
			{
				CustomLevel customLevel = LevelEditor.LoadLevelData("CampaignHoles/Hole" + i, cloudlandsHole: true);
				WorkshopData workshopData = new WorkshopData();
				workshopData.difficulty = (int)customLevel.difficulty;
				workshopData.levelName = customLevel.levelName;
				workshopData.par = customLevel.par;
				workshopData.defaultHole = true;
				workshopData.imageLocation = "CampaignHoles/Hole" + i;
				workshopData.fileLocation = "CampaignHoles/Hole" + i;
				Texture texture = Resources.LoadAll<Texture>("Holes/" + workshopData.imageLocation)[0];
				workshopData.screenshot = (Texture2D)texture;
				workshopData.publishID = i;
				workshopData.defaultHole = true;
				workshopData.golfClubType = customLevel.allowedClubs;
				campaignWorkshopData[i - 1] = workshopData;
			}
		}
	}

	public List<int> GenerateRandomNumbers(int count, int min, int max)
	{
		System.Random random = new System.Random();
		HashSet<int> hashSet = new HashSet<int>();
		if (max < count)
		{
			count = max;
		}
		for (int i = max - count; i < max; i++)
		{
			if (!hashSet.Add(random.Next(min, i + 1)))
			{
				hashSet.Add(i);
			}
		}
		List<int> list = hashSet.ToList();
		for (int num = list.Count - 1; num > 0; num--)
		{
			int index = random.Next(num + 1);
			int value = list[index];
			list[index] = list[num];
			list[num] = value;
		}
		return list;
	}

	public IEnumerator _ExitGame()
	{
		StartCoroutine(Player.instance.FadeOut());
		while (finishedFadeOut)
		{
			yield return null;
		}
		UnityEngine.Application.Quit();
		MonoBehaviour.print("Exited Game");
	}
}
public enum ControllerType
{
	Generic = 0,
	FPS = 2,
	Vive = 3,
	Quest = 4,
	XR = 5,
	Pico = 6
}
public enum GameMode
{
	None,
	Full18,
	NineHoles,
	Custom,
	Campaign
}
[Serializable]
public struct LightingData
{
	public Material skyboxMat;

	public float intensityMultiplier;

	public float lightIntensity;

	public float shadowStrength;
}
public class ItemManager : MonoBehaviour
{
	public static ItemManager instance;

	public GameObject teeSurfacePrefab;

	public GameObject smokePrefab;

	public GameObject bombPrefab;

	public int nullifyWindStock;

	public int teeSurfaceStock;

	public int puttLineStock;

	public int smokeStock;

	public int bombStock;

	public bool canUse = true;

	private bool needToHitBallSecondTime;

	public ItemType currentlyUsedItem;

	private GameObject teeSurface;

	private GameObject golfball;

	private CustomHoleScene customHoleScene;

	private void Awake()
	{
		instance = this;
	}

	public void GetStock()
	{
		nullifyWindStock = SaveFileManager.instance.saveFile.NullifyWind;
		teeSurfaceStock = SaveFileManager.instance.saveFile.TeeGolfingSurface;
		puttLineStock = SaveFileManager.instance.saveFile.PuttLine;
		smokeStock = SaveFileManager.instance.saveFile.Smoke;
		bombStock = SaveFileManager.instance.saveFile.Bomb;
	}

	public void UseNullifyWind()
	{
		if (canUse && nullifyWindStock > 0)
		{
			customHoleScene = UnityEngine.Object.FindObjectOfType<CustomHoleScene>();
			nullifyWindStock--;
			SaveFileManager.instance.saveFile.NullifyWind = nullifyWindStock;
			canUse = false;
			needToHitBallSecondTime = false;
			customHoleScene.wind.NullifyWind();
			currentlyUsedItem = ItemType.NullifyWind;
		}
	}

	public void UseTeeGolfingSurface()
	{
	}

	public void UsePuttLine()
	{
		if (canUse && puttLineStock > 0 && Player.instance.clubSwitcher.currentType == ClubType.Putter)
		{
			Player.instance.clubSwitcher.currentClub.GetComponent<Putter>().useAimLine = true;
			puttLineStock--;
			SaveFileManager.instance.saveFile.PuttLine = puttLineStock;
			canUse = false;
			currentlyUsedItem = ItemType.PuttLine;
		}
	}

	public void UseSmoke()
	{
		if (canUse && smokeStock > 0 && GameManager.instance.golfball != null)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(smokePrefab, GameManager.instance.golfball.transform.position, GameManager.instance.golfball.transform.rotation);
			GameManager.instance.golfball.gameObject.SetActive(value: false);
			golfball = GameManager.instance.golfball.gameObject;
			GameManager.instance.golfball = gameObject.GetComponent<Golfball>();
			smokeStock--;
			SaveFileManager.instance.saveFile.Smoke = smokeStock;
			canUse = false;
			currentlyUsedItem = ItemType.Smoke;
		}
	}

	public void UseBomb()
	{
		if (canUse && bombStock > 0 && GameManager.instance.golfball != null)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(bombPrefab, GameManager.instance.golfball.transform.position, GameManager.instance.golfball.transform.rotation);
			GameManager.instance.golfball.gameObject.SetActive(value: false);
			golfball = GameManager.instance.golfball.gameObject;
			GameManager.instance.golfball = gameObject.GetComponent<Golfball>();
			bombStock--;
			SaveFileManager.instance.saveFile.Bomb = bombStock;
			canUse = false;
			currentlyUsedItem = ItemType.Bomb;
		}
	}

	public void FinishedItem()
	{
		if (currentlyUsedItem == ItemType.NullifyWind)
		{
			DelayFinishedItem();
		}
		else if (currentlyUsedItem == ItemType.TeeGolfingSurface)
		{
			canUse = true;
			UnityEngine.Object.Destroy(teeSurface);
		}
		else if (currentlyUsedItem == ItemType.PuttLine)
		{
			canUse = true;
			Player.instance.clubSwitcher.currentClub.GetComponent<Putter>().useAimLine = false;
		}
	}

	public void DelayFinishedItem()
	{
		if (currentlyUsedItem == ItemType.NullifyWind)
		{
			if (!needToHitBallSecondTime)
			{
				needToHitBallSecondTime = true;
			}
			if (!canUse && needToHitBallSecondTime)
			{
				canUse = true;
				customHoleScene.wind.ResetWind();
			}
		}
		else if (currentlyUsedItem == ItemType.Bomb || currentlyUsedItem == ItemType.Smoke)
		{
			canUse = true;
			GameManager.instance.golfball = golfball.GetComponent<Golfball>();
			GameManager.instance.golfball.gameObject.SetActive(value: true);
		}
	}

	public void ResetVariables()
	{
		currentlyUsedItem = ItemType.None;
		canUse = true;
	}
}
public enum ItemType
{
	None,
	NullifyWind,
	TeeGolfingSurface,
	PuttLine,
	Bomb,
	Smoke
}
public class MoneyManager : MonoBehaviour
{
	public static MoneyManager instance;

	private void Awake()
	{
		instance = this;
	}

	public void ReceiveMoney(int amount)
	{
		SaveFileManager.instance.saveFile.money += amount;
		SaveFileManager.instance.SaveFile();
	}

	public void SpendMoney(int amount)
	{
		SaveFileManager.instance.saveFile.money -= amount;
		SaveFileManager.instance.SaveFile();
	}

	public int GetMoneyReceived(int stroke, int par)
	{
		int num = 0;
		if (stroke == 1)
		{
			if (par == 1)
			{
				return 20;
			}
			return 50;
		}
		if (stroke < par - 1)
		{
			return 40;
		}
		if (stroke == par - 1)
		{
			return 30;
		}
		if (stroke == par)
		{
			return 25;
		}
		if (stroke > par && stroke < par * 2)
		{
			return 10;
		}
		return 5;
	}

	public void HoleScoredMoney(int stroke, int par)
	{
		int moneyReceived = GetMoneyReceived(stroke, par);
		ReceiveMoney(moneyReceived);
	}

	public bool BuyItem(int cost, string itemName)
	{
		if (SaveFileManager.instance.saveFile.money >= cost)
		{
			int num = (int)SaveFileManager.instance.saveFile.GetType().GetField(itemName).GetValue(SaveFileManager.instance.saveFile);
			num++;
			SaveFileManager.instance.saveFile.GetType().GetField(itemName).SetValue(SaveFileManager.instance.saveFile, num);
			SpendMoney(cost);
			return true;
		}
		return false;
	}

	public int GetItemAmount(string itemName)
	{
		return (int)SaveFileManager.instance.saveFile.GetType().GetField(itemName).GetValue(SaveFileManager.instance.saveFile);
	}
}
public class OBManager : MonoBehaviour
{
	public static OBManager instance;

	public AudioClip sfxOutOfBounds;

	public AudioSource audioSource;

	private Vector3 lastBallPosition;

	public bool ballIsOB;

	private float ballReturnTimer;

	private float ballReturnDelay = 1f;

	public bool revertLastClubOnOB;

	public ClubType clubTypeBeforeHit;

	public bool hitOnslope;

	public float ballRespawnTimerDelay = 10f;

	public float respawnTimer;

	[HideInInspector]
	public float cloudlands1RespawnTime = 5f;

	[HideInInspector]
	public float cloudlands2RespawnTime = 10f;

	public Vector3 ballScoredPosition = Vector3.zero;

	private void Awake()
	{
		instance = this;
	}

	private void Update()
	{
		if (ballIsOB)
		{
			ballReturnTimer += Time.deltaTime;
			if (ballReturnTimer > ballReturnDelay)
			{
				RevertLastPosition();
			}
		}
		else if (GameManager.instance.golfball != null && !GameManager.instance.golfball.IsGrounded())
		{
			if (!GameManager.instance.currentSceneName.Contains("Boss") || !GameManager.instance.pauseMenu.paused)
			{
				respawnTimer += Time.deltaTime;
				if (respawnTimer >= ballRespawnTimerDelay)
				{
					RevertLastPosition();
					PlayOBSFX();
					respawnTimer = 0f;
				}
			}
		}
		else
		{
			respawnTimer = 0f;
		}
	}

	public void StoreLastPosition(Vector3 position)
	{
		lastBallPosition = position;
	}

	public void RevertLastPosition()
	{
		MonoBehaviour.print("Reverted");
		MoveTrailToObject();
		if (PhotonNetwork.InRoom && RoomRPC.instance.photonBall != null)
		{
			RoomRPC.instance.photonBall.BallWentOB();
		}
		if (GameManager.instance.golfball != null)
		{
			if (ScoreManager.instance.ballScored)
			{
				GameManager.instance.golfball.transform.position = ballScoredPosition;
			}
			else
			{
				GameManager.instance.golfball.transform.position = lastBallPosition;
				GameManager.instance.golfball.previousPosition = lastBallPosition;
			}
			GameManager.instance.golfball.FreezeVelocity();
			GameManager.instance.golfball.ballRenderer.enabled = true;
			if (revertLastClubOnOB)
			{
				Player.instance.clubSwitcher.preventClubSwitchOnWarp = true;
				Player.instance.clubSwitcher.SwitchToClubType(clubTypeBeforeHit);
			}
			if (!GameManager.instance.IsCloudlands1Hole())
			{
				GameManager.instance.golfball.MaxDrag();
			}
		}
		ballIsOB = false;
		ballReturnTimer = 0f;
	}

	public void TouchedBounds(bool playSFX = true)
	{
		if (!ballIsOB)
		{
			ballIsOB = true;
			if (playSFX)
			{
				PlayOBSFX();
			}
			if (GameManager.instance.golfball != null)
			{
				GameManager.instance.golfball.recordEndHitPos = false;
			}
		}
	}

	public void PlayOBSFX()
	{
		audioSource.PlayOneShot(sfxOutOfBounds);
		RoomRPC.PlayOnlineSound(base.transform.position, sfxOutOfBounds.name, 0.5f);
	}

	public void ResetOBStatus()
	{
		ballIsOB = false;
		ballReturnTimer = 0f;
	}

	public void MoveTrailToObject()
	{
		if (!(GameManager.instance.golfball != null))
		{
			return;
		}
		foreach (Transform item in GameManager.instance.golfball.transform)
		{
			if (item.GetComponent<TrailRenderer>() != null)
			{
				if (GameManager.instance.unparentedTrails == null)
				{
					GameManager.instance.unparentedTrails = new GameObject("Ball Trails");
				}
				item.transform.parent = GameManager.instance.unparentedTrails.transform;
			}
		}
	}
}
public class PhotonManager : MonoBehaviourPunCallbacks
{
	public static PhotonManager instance;

	public bool onKicked;

	private double photonTimer;

	private float sendStandbyMessageTimer;

	private double headsetInactiveTimeStart;

	private double headsetInactiveTimeEnd;

	private bool isFocused = true;

	private float roomOwnerShipTimer;

	private float roomOwnerShipInterval = 5f;

	public float timeBeforeMaxVolume = 1f;

	public float timeBeforeMaxVolumeTimer;

	private float duckVolume;

	private bool reconnectingVoice;

	private Coroutine voiceReconnectCoroutine;

	private float updateAvatarTimer = 2f;

	private float updateAvatarInterval = 2f;

	private void Awake()
	{
		if (instance != null)
		{
			UnityEngine.Object.Destroy(base.gameObject);
			return;
		}
		instance = this;
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		SceneManager.MoveGameObjectToScene(base.gameObject, SceneManager.GetSceneByName("Main"));
	}

	private void Start()
	{
		PhotonNetwork.KeepAliveInBackground = 113f;
		PhotonVoiceNetwork.Instance.KeepAliveInBackground = 120;
		OVRManager.HMDMounted += OVRManager_HMDUnmounted;
		Connect();
	}

	private void Update()
	{
		if (!PhotonVoiceNetwork.Instance.Client.IsConnected && PhotonNetwork.InRoom && !reconnectingVoice)
		{
			if (voiceReconnectCoroutine != null)
			{
				StopCoroutine(voiceReconnectCoroutine);
			}
			voiceReconnectCoroutine = StartCoroutine(ReconnectVoice());
		}
		if (GameManager.instance.currentSceneName == "MainMenu")
		{
			Disconnect();
		}
		else if (UnityEngine.Application.internetReachability == NetworkReachability.NotReachable)
		{
			Notification.instance.AddNotification("An internet connection is required to play online. Please check your internet settings.", 0f, closeButton: true);
			Disconnect();
			GameManager.instance.BackToMainMenu();
		}
		if (PhotonNetwork.NetworkClientState == ClientState.ConnectedToMasterServer)
		{
			PhotonNetwork.JoinLobby();
		}
		if (PhotonNetwork.InRoom && GameManager.instance.currentSceneName != "LobbyScene")
		{
			GameManager.instance.holeIndex = PhotonNetwork.CurrentRoom.GetHoleIndex();
		}
		if (onKicked)
		{
			Notification.instance.AddNotification("You have been kicked", 0f, closeButton: true);
		}
		if (timeBeforeMaxVolumeTimer <= 0f)
		{
			LowerMasterVolumeOnVoice(x: false);
		}
		else
		{
			LowerMasterVolumeOnVoice(x: true);
			timeBeforeMaxVolumeTimer -= Time.deltaTime;
		}
		photonTimer = PhotonNetwork.Time;
		sendStandbyMessageTimer += Time.deltaTime;
		if (sendStandbyMessageTimer > 0.5f)
		{
			headsetInactiveTimeStart = 0.0;
			sendStandbyMessageTimer = 0f;
			if (PhotonNetwork.InRoom)
			{
				PhotonNetwork.LocalPlayer.SetStandby(photonTimer);
			}
		}
		if (PhotonNetwork.IsMasterClient)
		{
			SetAvatarsInRoom();
		}
		TransferRoomOwnership();
	}

	private void SetAvatarsInRoom()
	{
		updateAvatarTimer += Time.deltaTime;
		if (!(updateAvatarTimer >= updateAvatarInterval))
		{
			return;
		}
		updateAvatarTimer = 0f;
		bool flag = false;
		PlayerID[] playerIDInRoom = PhotonNetwork.CurrentRoom.GetPlayerIDInRoom();
		List<PlayerID> list = new List<PlayerID>();
		Photon.Realtime.Player[] playerList = PhotonNetwork.PlayerList;
		foreach (Photon.Realtime.Player player in playerList)
		{
			PlayerID playerID = player.GetPlayerID();
			if (!playerIDInRoom.Contains(player.GetPlayerID()) || playerIDInRoom.Length != PhotonNetwork.PlayerList.Length)
			{
				flag = true;
			}
			list.Add(playerID);
		}
		if (flag)
		{
			PhotonNetwork.CurrentRoom.SetPlayerIDInRoom(list.ToArray());
		}
	}

	public void Connect()
	{
		PhotonNetwork.ConnectUsingSettings();
	}

	private void Disconnect()
	{
		if (PhotonNetwork.IsConnected)
		{
			PhotonNetwork.Disconnect();
			PhotonVoiceNetwork.Instance.Disconnect();
		}
		UnityEngine.Object.Destroy(base.gameObject, 1f);
	}

	public List<Photon.Realtime.Player> GetUsablePlayers(bool includeSelf = true)
	{
		List<Photon.Realtime.Player> list = new List<Photon.Realtime.Player>();
		Photon.Realtime.Player[] array = null;
		array = ((!includeSelf) ? PhotonNetwork.PlayerListOthers : PhotonNetwork.PlayerList);
		Photon.Realtime.Player[] array2 = array;
		foreach (Photon.Realtime.Player player in array2)
		{
			if (player.GetScene() != "LobbyScene" && !string.IsNullOrEmpty(player.GetScene()))
			{
				list.Add(player);
			}
		}
		for (int j = 0; j < PhotonNetwork.CurrentRoom.GetKickedPlayers().Length; j++)
		{
			for (int k = 0; k < list.Count; k++)
			{
				if (list[k].ActorNumber == PhotonNetwork.CurrentRoom.GetKickedPlayers()[j])
				{
					list.RemoveAt(k);
					break;
				}
			}
		}
		return list;
	}

	public override void OnPlayerLeftRoom(Photon.Realtime.Player otherPlayer)
	{
		if (otherPlayer.GetScene() != null && !PhotonNetwork.CurrentRoom.GetKickedPlayers().Contains(otherPlayer.ActorNumber))
		{
			RoomRPC.instance.PlayDisconnectSFX();
			ScoreManager.instance.SetPhotonScores();
			PhotonNetwork.CurrentRoom.RemoveKickedPlayers(otherPlayer);
			RichPresenceManager.instance.SetOnlineRoomDestination(PhotonNetwork.CurrentRoom.Name, PhotonNetwork.CurrentRoom.PlayerCount);
		}
		if (GameManager.instance.currentSceneName == "RoomPrepScene")
		{
			HoleSelectPanel.instance.playerListPanel.UpdatePlayerList();
		}
	}

	public override void OnPlayerEnteredRoom(Photon.Realtime.Player newPlayer)
	{
		base.OnPlayerEnteredRoom(newPlayer);
		RichPresenceManager.instance.SetOnlineRoomDestination(PhotonNetwork.CurrentRoom.Name, PhotonNetwork.CurrentRoom.PlayerCount);
	}

	private void LowerMasterVolumeOnVoice(bool x)
	{
		if (x)
		{
			duckVolume = -10f;
		}
		else
		{
			duckVolume = Mathf.Lerp(duckVolume, 0f, 0.02f);
		}
		GameManager.instance.audioManager.audioMixer.SetFloat("MasterVolume", duckVolume);
	}

	public void OnPhotonMaxCccuReached()
	{
		Notification.instance.AddNotification("The server is currently full. Please try again at a later time", 0f, closeButton: true);
	}

	public override void OnDisconnected(DisconnectCause cause)
	{
		StartCoroutine(_OnDisconnected(cause));
		RichPresenceManager.instance.ClearDestination();
	}

	private IEnumerator _OnDisconnected(DisconnectCause cause)
	{
		while (!isFocused)
		{
			yield return null;
		}
		headsetInactiveTimeEnd = Environment.TickCount;
		base.OnDisconnected(cause);
		if (cause != DisconnectCause.DisconnectByClientLogic && GameManager.instance.currentSceneName != "MainMenu")
		{
			if (headsetInactiveTimeStart > 0.0 && (headsetInactiveTimeEnd - headsetInactiveTimeStart) / 1000.0 >= 120.0)
			{
				MonoBehaviour.print("headsetInactiveTimeEnd: " + headsetInactiveTimeEnd);
				MonoBehaviour.print("headsetInactiveTimeStart: " + headsetInactiveTimeStart);
				Notification.instance.AddNotification("You have been disconnected from online due to the headset being inactive for too long", 0f, closeButton: true);
			}
			Notification.instance.AddNotification("You have been disconnected from online. Reason: " + cause, 0f, closeButton: true);
			GameManager.instance.BackToMainMenu();
		}
	}

	public override void OnLeftRoom()
	{
		base.OnLeftRoom();
		Resources.UnloadUnusedAssets();
	}

	private void OVRManager_HMDUnmounted()
	{
		if (voiceReconnectCoroutine != null)
		{
			StopCoroutine(voiceReconnectCoroutine);
		}
		voiceReconnectCoroutine = StartCoroutine(ReconnectVoice());
	}

	private IEnumerator ReconnectVoice()
	{
		MonoBehaviour.print("Voice Reconnecting");
		reconnectingVoice = true;
		if (PhotonVoiceNetwork.Instance.Client.IsConnected)
		{
			PhotonVoiceNetwork.Instance.Disconnect();
		}
		yield return new WaitForSeconds(1f);
		PhotonVoiceNetwork.Instance.ConnectAndJoinRoom();
		RoomRPC.instance.SetupRecorder();
		reconnectingVoice = false;
	}

	private void TransferRoomOwnership()
	{
		if (PhotonNetwork.PlayerList.Length <= 1)
		{
			return;
		}
		if (!PhotonNetwork.IsMasterClient && PhotonNetwork.MasterClient.GetStandby())
		{
			if (roomOwnerShipTimer >= roomOwnerShipInterval)
			{
				List<int> list = new List<int>();
				foreach (Photon.Realtime.Player usablePlayer in GetUsablePlayers())
				{
					list.Add(usablePlayer.ActorNumber);
				}
				list.Sort();
				for (int i = 0; i < list.Count(); i++)
				{
					for (int j = 0; j < PhotonNetwork.PlayerList.Length; j++)
					{
						if (PhotonNetwork.PlayerList[j].ActorNumber == list[i] && !PhotonNetwork.PlayerList[j].GetStandby())
						{
							PhotonNetwork.SetMasterClient(PhotonNetwork.PlayerList[j]);
							StartCoroutine(_TransferRoomOwnership());
							roomOwnerShipTimer = 0f;
							break;
						}
					}
				}
			}
			else
			{
				roomOwnerShipTimer += Time.deltaTime;
			}
		}
		else
		{
			roomOwnerShipTimer = 0f;
		}
	}

	private IEnumerator _TransferRoomOwnership()
	{
		yield return new WaitForSeconds(0.5f);
		RoomRPC.instance.pView.RPC("UpdatePlayerList", RpcTarget.All);
	}

	private void OnApplicationFocus(bool focus)
	{
		if (!focus)
		{
			isFocused = false;
			headsetInactiveTimeStart = Environment.TickCount;
			MonoBehaviour.print("standby");
		}
		else if (focus)
		{
			isFocused = true;
			if (voiceReconnectCoroutine != null)
			{
				StopCoroutine(voiceReconnectCoroutine);
			}
			voiceReconnectCoroutine = StartCoroutine(ReconnectVoice());
			MonoBehaviour.print("not standby");
		}
	}
}
public class RemoteServerManager : MonoBehaviour
{
	public static RemoteServerManager instance;

	public bool disableUploadingHoleLeaderboard;

	public string playerID = "";

	public string oculusOrgScopedID = "";

	public string playerUserName = "";

	public List<WorkshopData> workshopDetails = new List<WorkshopData>();

	private string HoleUploadPHPURL = "http://ugc.futuretown.io/Cloudlands2/PHP/Version_1/Cloudlands_2/CL2HoleUpload_v1.php";

	private string HoleDataPHPURL = "http://ugc.futuretown.io/Cloudlands2/PHP/Version_1/Cloudlands_2/CL2HoleData_v1.php";

	private string CreateWorkshopHoleDataPHPURL = "http://ugc.futuretown.io/Cloudlands2/PHP/Version_1/Cloudlands_2/CL2CreateWorkshopHoleData_v1.php";

	private string GetUserItemVotePHPURL = "http://ugc.futuretown.io/Cloudlands2/PHP/Version_1/Cloudlands_2/CL2GetUserItemVote_v1.php";

	private string PlaylistUploadPHPURL = "http://ugc.futuretown.io/Cloudlands2/PHP/Version_1/Cloudlands_2/CL2PlaylistUpload_v1.php";

	private string CreateWorkshopPlaylistDataPHPURL = "http://ugc.futuretown.io/Cloudlands2/PHP/Version_1/Cloudlands_2/CL2CreateWorkshopPlaylistData_v1.php";

	private string PlaylistDataPHPURL = "http://ugc.futuretown.io/Cloudlands2/PHP/Version_1/Cloudlands_2/CL2PlaylistData_v1.php";

	private string GetLeaderboardPHPURL = "http://ugc.futuretown.io/Cloudlands2/PHP/Version_1/Cloudlands_2/CL2LeaderboardData_v1.php";

	private string SteamAvatarPHPURL = "http://ugc.futuretown.io/Cloudlands2/PHP/Version_1/Cloudlands_1/CL1GetSteamAvatar_v1.php";

	private string Cloudlands1HoleDataPHPURL = "http://ugc.futuretown.io/Cloudlands2/PHP/Version_1/Cloudlands_1/CL1HoleData_v1.php";

	private string Cloudlands1GetUserItemVotePHPURL = "http://ugc.futuretown.io/Cloudlands2/PHP/Version_1/Cloudlands_1/CL1GetUserItemVote_v1.php";

	private string Cloudlands1PlaylistDataPHPURL = "http://ugc.futuretown.io/Cloudlands2/PHP/Version_1/Cloudlands_1/CL1PlaylistData_v1.php";

	private string Cloudlands1GetLeaderboardPHPURL = "http://ugc.futuretown.io/Cloudlands2/PHP/Version_1/Cloudlands_1/CL1HoleLeaderboardData_v1.php";

	public int numReturned;

	public int numTotal;

	public int downloadsCompleted;

	public float uploadProgress;

	public Sprite steamIcon;

	public Sprite oculusIcon;

	public Sprite viveportIcon;

	public Sprite xboxIcon;

	public Sprite XRSpaceIcon;

	public Sprite picoIcon;

	private List<string> badWords;

	private int triesToGetPlayerID = 3;

	public Coroutine queryPlaylistHolesCoroutine;

	public Coroutine downloadHolesCoroutine;

	public Coroutine downloadRatingsCoroutine;

	public static event Action onOculusInitialized;

	private void Awake()
	{
		instance = this;
	}

	private void Start()
	{
		GetListOfBadWords();
		if (GameManager.instance.publishedPlatform == PublishedPlatform.OCULUS)
		{
			GetComponent<RichPresenceManager>().enabled = true;
			Core.AsyncInitialize().OnComplete(delegate(Message<PlatformInitialize> message)
			{
				if (message.IsError)
				{
					RichPresenceManager.UpdateConsole(message.GetError().Message);
				}
				else
				{
					InitializeOculusInfo();
					if (RemoteServerManager.onOculusInitialized != null)
					{
						RemoteServerManager.onOculusInitialized();
					}
				}
			});
		}
		else if (GameManager.instance.publishedPlatform == PublishedPlatform.STEAM)
		{
			GetComponent<RichPresenceManager>().enabled = false;
			InitializeSteamInfo();
		}
		else if (GameManager.instance.publishedPlatform == PublishedPlatform.XR)
		{
			InitializeXRSpaceInfo();
		}
		else if (GameManager.instance.publishedPlatform == PublishedPlatform.Pico)
		{
			InitializePicoInfo();
		}
	}

	private void InitializeXRSpaceInfo()
	{
	}

	private void InitializePicoInfo()
	{
		PicoPaymentSDK.Login();
	}

	private void InitializeOculusInfo()
	{
		if (triesToGetPlayerID <= 0)
		{
			return;
		}
		Users.GetLoggedInUser().OnComplete(delegate(Message<User> msg)
		{
			if (msg.IsError)
			{
				triesToGetPlayerID--;
				MonoBehaviour.print("error: " + msg.GetError().Message);
				Invoke("InitializeOculusInfo", 10f);
			}
			else
			{
				playerUserName = msg.GetUser().OculusID;
				playerID = msg.GetUser().ID.ToString();
				SaveFileManager.instance.CreateSaveFile();
				SaveFileManager.instance.LoadSaveFile();
				Users.GetOrgScopedID(msg.GetUser().ID).OnComplete(delegate(Message<OrgScopedID> msg2)
				{
					if (msg2.IsError)
					{
						triesToGetPlayerID--;
						MonoBehaviour.print("error: " + msg2.GetError().Message);
						Invoke("InitializeOculusInfo", 10f);
					}
					else
					{
						oculusOrgScopedID = msg2.GetOrgScopedID().ID.ToString();
						MonoBehaviour.print("Logged in using Oculus");
					}
				});
			}
		});
	}

	private void InitializeSteamInfo()
	{
	}

	private void GetListOfBadWords()
	{
		badWords = new List<string>();
		string[] array = Resources.Load("BadWords").ToString().Replace("\r\n", "\n")
			.Replace("\r", "\n")
			.Split("\n"[0]);
		foreach (string text in array)
		{
			text.Replace('\r', ' ');
			if (text != "")
			{
				badWords.Add(text);
			}
		}
	}

	private void ResetSearch()
	{
		if (queryPlaylistHolesCoroutine != null)
		{
			StopCoroutine(queryPlaylistHolesCoroutine);
		}
		workshopDetails.Clear();
		numReturned = 0;
		numTotal = 0;
	}

	public IEnumerator UploadHole(string path)
	{
		DirectoryInfo directoryInfo = new DirectoryInfo(path);
		FileInfo[] holeFile = directoryInfo.GetFiles("*.dat");
		FileInfo[] imageFile = directoryInfo.GetFiles("*.jpg");
		if (holeFile.Length == 0 || imageFile.Length == 0)
		{
			yield break;
		}
		CustomLevel levelData = LevelEditor.LoadLevelData(holeFile[0].FullName);
		WWWForm wWWForm = new WWWForm();
		WWW www2;
		if (levelData.publishedFileId == 0L)
		{
			wWWForm.AddField("passphrasePost", "FuturetownServerPassphrase");
			wWWForm.AddField("functionNamePost", "GetLatestPublishID()");
			www2 = new WWW(HoleUploadPHPURL, wWWForm);
			yield return www2;
			if (string.IsNullOrEmpty(www2.error))
			{
				int num = int.Parse(www2.text);
				MonoBehaviour.print("Publish ID: " + num);
				LevelEditor.instance.currentLevel.publishedFileId = (ulong)num;
				LevelEditor.instance.currentLevel.published = true;
				LevelEditor.instance.levelEditorMenu._SaveCurrentLevel();
				yield return new WaitForEndOfFrame();
				levelData = LevelEditor.LoadLevelData(holeFile[0].FullName);
			}
			else
			{
				MonoBehaviour.print("Error: The hole failed to upload to the server. Please try again later.");
				LevelEditor.instance.levelEditorMenu.UploadErrorMessage("The hole failed to upload to the server. Please try again later.");
			}
		}
		byte[] contents = File.ReadAllBytes(holeFile[0].FullName);
		byte[] contents2 = File.ReadAllBytes(imageFile[0].FullName);
		wWWForm = new WWWForm();
		wWWForm.AddField("passphrasePost", "FuturetownServerPassphrase");
		wWWForm.AddField("functionNamePost", "UploadFile()");
		string text = imageFile[0].Name.Substring(0, imageFile[0].Name.Length - 4);
		wWWForm.AddField("jpgName", text);
		wWWForm.AddBinaryData("theImage", contents2, text + ".jpg");
		text = holeFile[0].Name.Substring(0, holeFile[0].Name.Length - 4);
		text = text.Replace(" ", "_");
		wWWForm.AddField("datName", text);
		wWWForm.AddBinaryData("theTrack", contents, text + ".dat");
		wWWForm.AddField("publishID", (int)levelData.publishedFileId);
		www2 = new WWW(HoleUploadPHPURL, wWWForm);
		yield return www2;
		while (www2.progress < 1f)
		{
			uploadProgress = www2.uploadProgress;
		}
		if (!string.IsNullOrEmpty(www2.error))
		{
			MonoBehaviour.print("Error: " + www2.error);
			LevelEditor.instance.levelEditorMenu.UploadErrorMessage("The hole failed to upload to the server. Please try again later.");
			LevelEditor.instance.currentLevel.publishedFileId = 0uL;
			LevelEditor.instance.currentLevel.published = false;
			LevelEditor.instance.levelEditorMenu._SaveCurrentLevel();
		}
		else
		{
			MonoBehaviour.print(www2.text);
			MonoBehaviour.print("Finished uploading hole");
			StartCoroutine(CreateWorkshopHoleItem(www2.text, levelData));
		}
	}

	public IEnumerator RemoveHole(int publishID, Action<bool> onComplete)
	{
		WWWForm wWWForm = new WWWForm();
		wWWForm.AddField("passphrasePost", "FuturetownServerPassphrase");
		wWWForm.AddField("functionNamePost", "RemoveHole()");
		wWWForm.AddField("playerID", playerID.ToString());
		wWWForm.AddField("publishID", publishID);
		WWW www = new WWW(HoleUploadPHPURL, wWWForm);
		yield return www;
		if (string.IsNullOrEmpty(www.error))
		{
			MonoBehaviour.print("Hole unlisted");
			onComplete(obj: true);
		}
		else
		{
			MonoBehaviour.print("Error: Error unlisting Hole" + www.error);
			onComplete(obj: false);
		}
	}

	public IEnumerator RemovePlaylist(int publishID, Action<bool> onComplete)
	{
		WWWForm wWWForm = new WWWForm();
		wWWForm.AddField("passphrasePost", "FuturetownServerPassphrase");
		wWWForm.AddField("functionNamePost", "RemovePlaylist()");
		wWWForm.AddField("playerID", playerID);
		wWWForm.AddField("publishID", publishID);
		WWW www = new WWW(PlaylistUploadPHPURL, wWWForm);
		yield return www;
		if (string.IsNullOrEmpty(www.error))
		{
			MonoBehaviour.print("Playlist unlisted");
			onComplete(obj: true);
		}
		else
		{
			MonoBehaviour.print("Error: Error unlisting Playlist " + www.error);
			onComplete(obj: false);
		}
	}

	public IEnumerator UploadPlaylist(string path)
	{
		DirectoryInfo directoryInfo = new DirectoryInfo(path);
		FileInfo[] trackFile = directoryInfo.GetFiles("*.clp");
		FileInfo[] imageFile = directoryInfo.GetFiles("*.jpg");
		if (trackFile.Length != 0 && imageFile.Length != 0)
		{
			PlaylistData levelData = CustomPlaylist.LoadPlaylistData(trackFile[0].FullName);
			int num;
			WWWForm wWWForm;
			WWW w2;
			if (levelData.publishedFileId == 0L)
			{
				wWWForm = new WWWForm();
				wWWForm.AddField("passphrasePost", "FuturetownServerPassphrase");
				wWWForm.AddField("functionNamePost", "GetLatestPublishID()");
				w2 = new WWW(PlaylistUploadPHPURL, wWWForm);
				yield return w2;
				MonoBehaviour.print(w2.text);
				num = int.Parse(w2.text);
				levelData.publishedFileId = (ulong)num;
				CustomPlaylist.UpdatePlaylistFilePublishedInfo(levelData);
			}
			else
			{
				num = (int)levelData.publishedFileId;
			}
			byte[] contents = File.ReadAllBytes(trackFile[0].FullName);
			byte[] contents2 = File.ReadAllBytes(imageFile[0].FullName);
			wWWForm = new WWWForm();
			wWWForm.AddField("passphrasePost", "FuturetownServerPassphrase");
			string text = imageFile[0].Name.Substring(0, imageFile[0].Name.Length - 4);
			wWWForm.AddField("jpgName", text);
			wWWForm.AddBinaryData("theImage", contents2, text + ".jpg");
			text = trackFile[0].Name.Substring(0, trackFile[0].Name.Length - 4);
			text = text.Replace(" ", "_");
			wWWForm.AddField("clpName", text);
			wWWForm.AddBinaryData("thePlaylist", contents, text + ".clp");
			wWWForm.AddField("publishID", num);
			w2 = new WWW(PlaylistUploadPHPURL, wWWForm);
			while (w2.progress < 1f)
			{
				uploadProgress = w2.uploadProgress;
			}
			yield return w2;
			if (!string.IsNullOrEmpty(w2.error))
			{
				MonoBehaviour.print("Error: Error uploading playlist " + w2.error);
				HoleSelectPanel.instance.customPlaylist.ShowUploadError();
			}
			else
			{
				StartCoroutine(CreateWorkshopPlaylistItem(playlistData: CustomPlaylist.LoadPlaylistData(trackFile[0].FullName), itemDataString: w2.text));
			}
		}
	}

	private IEnumerator CreateWorkshopHoleItem(string itemDataString, CustomLevel levelData)
	{
		UploadData uploadData = ParseToUploadedData(itemDataString);
		int publishID = uploadData.publishID;
		string fileLocation = uploadData.fileLocation;
		string imageLocation = uploadData.imageLocation;
		fileLocation = fileLocation.Replace(" ", "_");
		WWWForm wWWForm = new WWWForm();
		wWWForm.AddField("publishIDPost", publishID);
		wWWForm.AddField("usernamePost", levelData.creatorName);
		wWWForm.AddField("upvotesPost", 0);
		wWWForm.AddField("uploadDatePost", levelData.saveDate.Ticks.ToString());
		wWWForm.AddField("levelNamePost", levelData.levelName);
		wWWForm.AddField("parPost", levelData.par);
		wWWForm.AddField("difficultyPost", (int)levelData.difficulty);
		wWWForm.AddField("pieceCountPost", levelData.pieces.Length);
		wWWForm.AddField("parCountRangePost", GetHoleParRange(levelData.par));
		wWWForm.AddField("pieceCountRangePost", GetPieceCountRange(levelData.pieces.Length));
		wWWForm.AddField("datURLPost", fileLocation);
		wWWForm.AddField("jpgURLPost", imageLocation);
		wWWForm.AddField("publishPlatformPost", (int)GameManager.instance.publishedPlatform);
		wWWForm.AddField("creatorIDPost", levelData.creatorId);
		if (levelData.publishedPlatform == PublishedPlatform.OCULUS)
		{
			wWWForm.AddField("oculusOrgScopeIDPost", oculusOrgScopedID);
		}
		wWWForm.AddField("clubTypePost", (int)levelData.allowedClubs);
		if (levelData.windVector == Vector3.zero)
		{
			wWWForm.AddField("windPost", 0);
		}
		else
		{
			wWWForm.AddField("windPost", 1);
		}
		WWW www = new WWW(CreateWorkshopHoleDataPHPURL, wWWForm);
		yield return www;
		if (string.IsNullOrEmpty(www.error))
		{
			MonoBehaviour.print("Finished creating item");
			GameManager.instance.gameAchievements.UnlockAchievement(Achievement.PUBLISH_EDITOR_HOLE);
			yield break;
		}
		MonoBehaviour.print("Error: error creating workshop data on server" + www.error);
		LevelEditor.instance.levelEditorMenu.UploadErrorMessage("The hole failed to upload to the server. Please try again later.");
		LevelEditor.instance.currentLevel.publishedFileId = 0uL;
		LevelEditor.instance.currentLevel.published = false;
		LevelEditor.instance.levelEditorMenu.SaveCurrentLevel();
	}

	private IEnumerator CreateWorkshopPlaylistItem(string itemDataString, PlaylistData playlistData)
	{
		UploadData uploadData = JsonUtility.FromJson<UploadData>(itemDataString);
		int publishID = uploadData.publishID;
		string fileLocation = uploadData.fileLocation;
		string imageLocation = uploadData.imageLocation;
		string text = "";
		fileLocation = fileLocation.Replace(" ", "_");
		string value = playlistData.creatorName.Replace("'", "\\'");
		for (int i = 0; i < playlistData.holeInfo.Length; i++)
		{
			if (playlistData.holeInfo[i].holeType != 0)
			{
				text = text + playlistData.holeInfo[i].workshopFileId + "|";
			}
		}
		WWWForm wWWForm = new WWWForm();
		wWWForm.AddField("publishIDPost", publishID);
		wWWForm.AddField("usernamePost", value);
		wWWForm.AddField("playlistNamePost", playlistData.playlistName);
		wWWForm.AddField("parPost", playlistData.par);
		wWWForm.AddField("upvotesPost", 0);
		wWWForm.AddField("downvotesPost", 0);
		wWWForm.AddField("uploadDatePost", playlistData.saveDate.Ticks.ToString());
		wWWForm.AddField("holeCountPost", playlistData.holeCount);
		wWWForm.AddField("holeIDsPost", text);
		wWWForm.AddField("holeCountRangePost", GetPlaylistHoleRange(playlistData.holeCount));
		wWWForm.AddField("parCountRangePost", GetPlaylistParRange(playlistData.par));
		wWWForm.AddField("clpURLPost", fileLocation);
		wWWForm.AddField("jpgURLPost", imageLocation);
		if (playlistData.publishedPlatform == PublishedPlatform.STEAM || playlistData.publishedPlatform == PublishedPlatform.OCULUS || playlistData.publishedPlatform == PublishedPlatform.XboxLive)
		{
			wWWForm.AddField("creatorIDPost", playlistData.creatorId.ToString());
		}
		else if (playlistData.publishedPlatform == PublishedPlatform.VIVEPORT)
		{
			wWWForm.AddField("creatorIDPost", playlistData.userIdString);
		}
		if (playlistData.publishedPlatform == PublishedPlatform.OCULUS)
		{
			wWWForm.AddField("oculusOrgScopeIDPost", oculusOrgScopedID);
		}
		wWWForm.AddField("publishPlatformPost", (int)GameManager.instance.publishedPlatform);
		WWW www = new WWW(CreateWorkshopPlaylistDataPHPURL, wWWForm);
		yield return www;
		if (string.IsNullOrEmpty(www.error))
		{
			HoleSelectPanel.instance.customPlaylist.AddWorkshopFileIdToCurrentPlaylist((ulong)publishID);
			HoleSelectPanel.instance.customPlaylist.FinishedUpload();
		}
		else
		{
			HoleSelectPanel.instance.customPlaylist.ShowUploadError();
		}
	}

	public IEnumerator QueryWorkshopHoles(uint currentPage, SearchFilters searchFilter, Action<bool> onComplete)
	{
		int i = -1;
		for (int j = 0; j < Enum.GetValues(typeof(Difficulty)).Length; j++)
		{
			string sortDifficulty = searchFilter.sortDifficulty;
			Difficulty difficulty = (Difficulty)j;
			if (sortDifficulty == difficulty.ToString())
			{
				i = j;
			}
		}
		ResetSearch();
		WWWForm wWWForm = new WWWForm();
		wWWForm.AddField("currentPagePost", (int)currentPage);
		wWWForm.AddField("functionNamePost", "GetPage()");
		wWWForm.AddField("sortNamePost", searchFilter.sortName);
		wWWForm.AddField("sortDifficultyPost", i);
		wWWForm.AddField("sortOrderPost", searchFilter.sortOrder);
		if (searchFilter.sortPars != "")
		{
			wWWForm.AddField("sortParCountRangePost", searchFilter.sortPars + " Pars");
		}
		WWW www;
		if (searchFilter.CloudlandsVersion == 1)
		{
			www = new WWW(Cloudlands1HoleDataPHPURL, wWWForm);
		}
		else
		{
			wWWForm.AddField("clubTypePost", searchFilter.golfClub);
			if (searchFilter.sortWind == -1)
			{
				wWWForm.AddField("sortWindPost", "");
			}
			else
			{
				wWWForm.AddField("sortWindPost", searchFilter.sortWind);
			}
			if (searchFilter.mustIncludeSelected)
			{
				wWWForm.AddField("mustIncludeSelectedClubsPost", "1");
			}
			www = new WWW(HoleDataPHPURL, wWWForm);
		}
		yield return www;
		if (string.IsNullOrEmpty(www.error))
		{
			string text = www.text;
			if (www.text != "")
			{
				string[] array = text.Split('\n');
				for (int k = 0; k < array.Length - 1; k++)
				{
					workshopDetails.Add(ParseToWorkshopHoleData(array[k]));
				}
				numReturned = int.Parse(ParseString(array[^1], "numReturned:"));
				numTotal = int.Parse(ParseString(array[^1], "numTotal:"));
				onComplete(obj: true);
			}
			else
			{
				onComplete(obj: false);
			}
		}
		else
		{
			MonoBehaviour.print("Error: error querying workshop hole " + www.error);
			onComplete(obj: false);
		}
	}

	public IEnumerator QueryWorkshopPlaylists(uint currentPage, SearchFilters searchFilter, Action<bool> onComplete)
	{
		ResetSearch();
		WWWForm wWWForm = new WWWForm();
		wWWForm.AddField("currentPagePost", (int)currentPage);
		wWWForm.AddField("functionNamePost", "GetPage()");
		wWWForm.AddField("sortNamePost", searchFilter.sortName);
		wWWForm.AddField("sortOrderPost", searchFilter.sortOrder);
		wWWForm.AddField("sortParRangePost", searchFilter.sortPars + " Pars");
		wWWForm.AddField("sortHoleCountRangePost", searchFilter.sortHoleCount + " Holes");
		wWWForm.AddField("itemsPerPagePost", 20);
		WWW www = ((searchFilter.CloudlandsVersion != 1) ? new WWW(PlaylistDataPHPURL, wWWForm) : new WWW(Cloudlands1PlaylistDataPHPURL, wWWForm));
		yield return www;
		if (string.IsNullOrEmpty(www.error))
		{
			string text = www.text;
			if (www.text != "")
			{
				string[] array = text.Split('\n');
				for (int i = 0; i < array.Length - 1; i++)
				{
					workshopDetails.Add(ParseToWorkshopPlaylistData(array[i]));
				}
				numReturned = int.Parse(ParseString(array[^1], "numReturned:"));
				numTotal = int.Parse(ParseString(array[^1], "numTotal:"));
				onComplete(obj: true);
			}
			else
			{
				onComplete(obj: false);
			}
		}
		else
		{
			MonoBehaviour.print("Error: error querying workshop playlist " + www.error);
			onComplete(obj: false);
		}
	}

	public IEnumerator QueryPlaylistHoles(List<int> holeIDs, bool showAllHoles, SearchFilters searchFilter, Action<bool> onComplete)
	{
		ResetSearch();
		for (int i = 0; i < holeIDs.Count; i++)
		{
			WWWForm wWWForm = new WWWForm();
			wWWForm.AddField("functionNamePost", "GetPublishID()");
			wWWForm.AddField("publishIDPost", holeIDs[i]);
			if (showAllHoles)
			{
				wWWForm.AddField("visiblePost", "-1");
			}
			WWW www = ((searchFilter.CloudlandsVersion != 1) ? new WWW(HoleDataPHPURL, wWWForm) : new WWW(Cloudlands1HoleDataPHPURL, wWWForm));
			yield return www;
			if (string.IsNullOrEmpty(www.error))
			{
				if (www.text != "")
				{
					string[] array = www.text.Split('\n');
					for (int j = 0; j < array.Length - 1; j++)
					{
						workshopDetails.Add(ParseToWorkshopHoleData(array[j]));
					}
				}
			}
			else
			{
				MonoBehaviour.print("Error: error querying workshop playlist holes" + www.error);
				onComplete(obj: false);
			}
			www.Dispose();
		}
		onComplete(obj: true);
	}

	public IEnumerator QueryFavoriteHoles(uint currentPage, bool isPlaylist, SearchFilters searchFilter, Action<bool> onComplete)
	{
		if (playerID == "")
		{
			onComplete(obj: false);
			yield break;
		}
		ResetSearch();
		WWWForm wWWForm = new WWWForm();
		wWWForm.AddField("userIDPost", playerID);
		wWWForm.AddField("currentPagePost", (int)currentPage);
		if (GameManager.instance.publishedPlatform == PublishedPlatform.OCULUS)
		{
			wWWForm.AddField("oculusOrgScopeIDPost", oculusOrgScopedID);
		}
		if (isPlaylist)
		{
			wWWForm.AddField("functionName1Post", "GetUserFavoritePlaylists()");
		}
		else
		{
			wWWForm.AddField("functionName1Post", "GetUserFavorite()");
			int i = -1;
			for (int j = 0; j < Enum.GetValues(typeof(Difficulty)).Length; j++)
			{
				string sortDifficulty = searchFilter.sortDifficulty;
				Difficulty difficulty = (Difficulty)j;
				if (sortDifficulty == difficulty.ToString())
				{
					i = j;
				}
			}
			wWWForm.AddField("sortDifficultyPost", i);
		}
		wWWForm.AddField("sortNamePost", searchFilter.sortName);
		wWWForm.AddField("sortOrderPost", searchFilter.sortOrder);
		if (searchFilter.sortHoleCount != "")
		{
			wWWForm.AddField("sortHoleCountRangePost", searchFilter.sortHoleCount + " Holes");
		}
		if (searchFilter.sortPars != "")
		{
			wWWForm.AddField("sortParCountRangePost", searchFilter.sortPars + " Pars");
		}
		WWW www;
		if (searchFilter.CloudlandsVersion == 1)
		{
			www = new WWW(Cloudlands1GetUserItemVotePHPURL, wWWForm);
		}
		else
		{
			if (isPlaylist)
			{
				wWWForm.AddField("playlistPost", 1);
			}
			if (searchFilter.mustIncludeSelected)
			{
				wWWForm.AddField("mustIncludeSelectedClubsPost", "1");
			}
			wWWForm.AddField("clubTypePost", searchFilter.golfClub);
			if (searchFilter.sortWind == -1)
			{
				wWWForm.AddField("sortWindPost", "");
			}
			else
			{
				wWWForm.AddField("sortWindPost", searchFilter.sortWind);
			}
			www = new WWW(GetUserItemVotePHPURL, wWWForm);
		}
		yield return www;
		if (string.IsNullOrEmpty(www.error))
		{
			string[] array = www.text.Split('\n');
			MonoBehaviour.print(array[0]);
			numReturned = int.Parse(ParseString(array[^1], "numReturned:"));
			numTotal = int.Parse(ParseString(array[^1], "numTotal:"));
			for (int k = 0; k < array.Length - 1; k++)
			{
				if (array[k] != "")
				{
					workshopDetails.Add(ParseToWorkshopHoleData(array[k]));
				}
			}
			onComplete(obj: true);
		}
		else
		{
			MonoBehaviour.print("QueryFavoriteHoles error: " + www.error);
			onComplete(obj: false);
		}
	}

	public IEnumerator QueryUserHoles(uint currentPage, SearchFilters searchFilter, Action<bool> onComplete)
	{
		ResetSearch();
		if (playerID != "")
		{
			WWWForm wWWForm = new WWWForm();
			wWWForm.AddField("currentPagePost", (int)currentPage);
			wWWForm.AddField("functionNamePost", "GetPage()");
			wWWForm.AddField("userIDPost", playerID);
			if (GameManager.instance.publishedPlatform == PublishedPlatform.OCULUS)
			{
				wWWForm.AddField("oculusOrgScopeIDPost", oculusOrgScopedID);
			}
			int i = -1;
			for (int j = 0; j < Enum.GetValues(typeof(Difficulty)).Length; j++)
			{
				string sortDifficulty = searchFilter.sortDifficulty;
				Difficulty difficulty = (Difficulty)j;
				if (sortDifficulty == difficulty.ToString())
				{
					i = j;
				}
			}
			wWWForm.AddField("sortNamePost", searchFilter.sortName);
			wWWForm.AddField("sortDifficultyPost", i);
			wWWForm.AddField("sortOrderPost", searchFilter.sortOrder);
			if (searchFilter.sortPars != "")
			{
				wWWForm.AddField("sortParCountRangePost", searchFilter.sortPars + " Pars");
			}
			WWW www;
			if (searchFilter.CloudlandsVersion == 1)
			{
				www = new WWW(Cloudlands1HoleDataPHPURL, wWWForm);
			}
			else
			{
				if (searchFilter.mustIncludeSelected)
				{
					wWWForm.AddField("mustIncludeSelectedClubsPost", "1");
				}
				wWWForm.AddField("clubTypePost", searchFilter.golfClub);
				if (searchFilter.sortWind == -1)
				{
					wWWForm.AddField("sortWindPost", "");
				}
				else
				{
					wWWForm.AddField("sortWindPost", searchFilter.sortWind);
				}
				www = new WWW(HoleDataPHPURL, wWWForm);
			}
			yield return www;
			if (string.IsNullOrEmpty(www.error))
			{
				if (www.text != "")
				{
					string[] array = www.text.Split('\n');
					for (int k = 0; k < array.Length - 1; k++)
					{
						workshopDetails.Add(ParseToWorkshopHoleData(array[k]));
					}
					numReturned = int.Parse(ParseString(array[^1], "numReturned:"));
					numTotal = int.Parse(ParseString(array[^1], "numTotal:"));
				}
				onComplete(obj: true);
			}
			else
			{
				MonoBehaviour.print("Error: error querying user holes" + www.error);
				onComplete(obj: false);
			}
		}
		else
		{
			onComplete(obj: false);
		}
	}

	public IEnumerator QueryUserPlaylists(uint currentPage, SearchFilters searchFilter, Action<bool> onComplete)
	{
		ResetSearch();
		if (playerID != "")
		{
			WWWForm wWWForm = new WWWForm();
			wWWForm.AddField("currentPagePost", (int)currentPage);
			if (GameManager.instance.publishedPlatform == PublishedPlatform.OCULUS)
			{
				wWWForm.AddField("oculusOrgScopeIDPost", oculusOrgScopedID);
			}
			wWWForm.AddField("functionNamePost", "GetUserID()");
			wWWForm.AddField("userIDPost", playerID);
			wWWForm.AddField("itemsPerPagePost", 20);
			WWW www = ((searchFilter.CloudlandsVersion != 1) ? new WWW(PlaylistDataPHPURL, wWWForm) : new WWW(Cloudlands1PlaylistDataPHPURL, wWWForm));
			yield return www;
			if (string.IsNullOrEmpty(www.error))
			{
				if (www.text != "")
				{
					string[] array = www.text.Split('\n');
					for (int i = 0; i < array.Length - 1; i++)
					{
						workshopDetails.Add(ParseToWorkshopPlaylistData(array[i]));
					}
					numReturned = int.Parse(ParseString(array[^1], "numReturned:"));
					numTotal = int.Parse(ParseString(array[^1], "numTotal:"));
				}
				onComplete(obj: true);
			}
			else
			{
				MonoBehaviour.print("Error: error querying user playlists" + www.error);
				onComplete(obj: false);
			}
			www.Dispose();
		}
		else
		{
			onComplete(obj: false);
		}
	}

	public IEnumerator DownloadHole(List<WorkshopData> wsd)
	{
		List<WorkshopData> holesWithoutDuplicates = new List<WorkshopData>();
		foreach (WorkshopData item in wsd)
		{
			bool flag = true;
			for (int j = 0; j < holesWithoutDuplicates.Count; j++)
			{
				if (item.publishID == holesWithoutDuplicates[j].publishID)
				{
					flag = false;
					break;
				}
			}
			if (flag)
			{
				holesWithoutDuplicates.Add(item);
			}
		}
		if (GameManager.instance.currentSceneName == "RoomPrepScene")
		{
			HoleSelectPanel.instance.downloadsNeeded = holesWithoutDuplicates.Count;
			HoleSelectPanel.instance.GetWorkshopHoleAmount();
		}
		else if (GameManager.instance.currentSceneName == "LobbyScene")
		{
			LobbyManager.instance.downloadsNeeded = holesWithoutDuplicates.Count;
		}
		List<WorkshopData> errorHoles = new List<WorkshopData>();
		foreach (WorkshopData data2 in holesWithoutDuplicates)
		{
			if (!data2.localItem)
			{
				continue;
			}
			WWWForm wWWForm = new WWWForm();
			wWWForm.AddField("functionNamePost", "GetPublishID()");
			wWWForm.AddField("publishIDPost", data2.publishID);
			WWW www2 = null;
			if (data2.cloudlandsVersion == 1)
			{
				www2 = new WWW(Cloudlands1HoleDataPHPURL, wWWForm);
			}
			else if (data2.cloudlandsVersion == 2)
			{
				www2 = new WWW(HoleDataPHPURL, wWWForm);
			}
			yield return www2;
			string text = www2.text;
			if (www2.text != "")
			{
				string[] array = text.Split('\n');
				for (int k = 0; k < array.Length - 1; k++)
				{
					WorkshopData workshopData = ParseToWorkshopHoleData(array[k]);
					data2.fileLocation = workshopData.fileLocation;
					data2.imageLocation = workshopData.imageLocation;
				}
			}
			else
			{
				errorHoles.Add(data2);
			}
		}
		foreach (WorkshopData item2 in errorHoles)
		{
			holesWithoutDuplicates.Remove(item2);
		}
		for (int i = 0; i < holesWithoutDuplicates.Count; i++)
		{
			if (GameManager.instance.currentSceneName != "RoomPrepScene" && GameManager.instance.currentSceneName != "LobbyScene")
			{
				MonoBehaviour.print("Stopping downloading holes");
				StopCoroutine(downloadHolesCoroutine);
				yield break;
			}
			if (GameManager.instance.currentSceneName == "LobbyScene" && LobbyManager.instance.roomListPanel.selectedRoom != null && LobbyManager.instance.roomListPanel.selectedRoom.PlayerCount >= LobbyManager.instance.roomListPanel.selectedRoom.MaxPlayers)
			{
				LobbyManager.instance.roomListPanel.selectedRoom = null;
				LobbyManager.instance.SwitchToRoomListScreen();
				MonoBehaviour.print("Stopping downloading holes");
			}
			WorkshopData data2 = holesWithoutDuplicates[i];
			WWW www2 = new WWW(data2.imageLocation);
			yield return www2;
			if (www2.error != null)
			{
				MonoBehaviour.print("Error downloading image: " + www2.error);
				Notification.instance.AddNotification("Failed to download custom hole: " + www2.error, 0f, closeButton: true);
				if (PhotonNetwork.IsConnected)
				{
					GameManager.instance.BackToLobby();
				}
				else
				{
					GameManager.instance.BackToMainMenu();
				}
				MonoBehaviour.print("Error downloading image: " + www2.error);
				StopCoroutine(downloadHolesCoroutine);
				yield break;
			}
			WWW holeWWW = new WWW(data2.fileLocation);
			yield return holeWWW;
			if (holeWWW.error != null)
			{
				Notification.instance.AddNotification("Failed to download custom hole: " + holeWWW.error, 0f, closeButton: true);
				if (PhotonNetwork.IsConnected)
				{
					GameManager.instance.BackToLobby();
				}
				else
				{
					GameManager.instance.BackToMainMenu();
				}
				MonoBehaviour.print("Error downloading hole: " + holeWWW.error);
				StopCoroutine(downloadHolesCoroutine);
				yield break;
			}
			string text2 = CreateAndReturnNewHoleFolder(data2.publishID, data2.cloudlandsVersion);
			FileInfo[] files = new DirectoryInfo(text2).GetFiles();
			for (int l = 0; l < files.Length; l++)
			{
				File.Delete(files[l].FullName);
			}
			File.WriteAllBytes(text2 + "image.jpg", www2.bytes);
			File.WriteAllBytes(text2 + "hole.dat", holeWWW.bytes);
			data2.fileLocation = text2 + "hole.dat";
			data2.imageLocation = text2 + "image.jpg";
			foreach (WorkshopData item3 in wsd)
			{
				if (item3.publishID == data2.publishID)
				{
					item3.fileLocation = data2.fileLocation;
					item3.imageLocation = data2.imageLocation;
				}
			}
			downloadsCompleted++;
			if (GameManager.instance.currentSceneName == "RoomPrepScene" && PhotonNetwork.InRoom)
			{
				PhotonNetwork.LocalPlayer.SetDownloadProgress(downloadsCompleted);
			}
			yield return new WaitForSeconds(0.1f);
		}
		if (GameManager.instance.currentSceneName == "RoomPrepScene")
		{
			HoleSelectPanel.instance.SetFilePaths();
		}
		else if (GameManager.instance.currentSceneName == "LobbyScene")
		{
			StartCoroutine(LobbyManager.instance.FinishedDownload());
		}
	}

	public IEnumerator DownloadPlaylist(WorkshopData data, Action<string> onComplete)
	{
		WWW imageWWW = new WWW(data.imageLocation);
		yield return imageWWW;
		if (imageWWW.error != null)
		{
			MonoBehaviour.print("Error downloading image: " + imageWWW.error);
			yield break;
		}
		WWW holeWWW = new WWW(data.fileLocation);
		yield return holeWWW;
		if (holeWWW.error != null)
		{
			MonoBehaviour.print("Error downloading hole: " + holeWWW.error);
			yield break;
		}
		string text = CreateAndReturnNewHoleFolder(data.publishID, data.cloudlandsVersion, playlist: true);
		FileInfo[] files = new DirectoryInfo(text).GetFiles();
		for (int i = 0; i < files.Length; i++)
		{
			File.Delete(files[i].FullName);
		}
		File.WriteAllBytes(text + "image.jpg", imageWWW.bytes);
		File.WriteAllBytes(text + data.levelName + ".clp", holeWWW.bytes);
		onComplete(text + data.levelName + ".clp");
	}

	public IEnumerator UpdateItemVoteData(string function1, string function2 = null)
	{
		if (playerID != "")
		{
			WWWForm wWWForm = new WWWForm();
			WorkshopData workshopData = ((!(GameManager.instance.currentSceneName == "ScoreScene")) ? GameManager.instance.holeData[GameManager.instance.holeIndex] : GameManager.instance.playlistLeaderboardData);
			wWWForm.AddField("userIDPost", playerID);
			wWWForm.AddField("publishIDPost", workshopData.publishID);
			wWWForm.AddField("functionName1Post", function1);
			if (GameManager.instance.publishedPlatform == PublishedPlatform.OCULUS)
			{
				wWWForm.AddField("oculusOrgScopeIDPost", oculusOrgScopedID);
			}
			if (function2 != null)
			{
				wWWForm.AddField("functionName2Post", function2);
			}
			WWW www;
			if (!(GameManager.instance.currentSceneName == "ScoreScene"))
			{
				www = ((workshopData.cloudlandsVersion != 1) ? new WWW(GetUserItemVotePHPURL, wWWForm) : new WWW(Cloudlands1GetUserItemVotePHPURL, wWWForm));
			}
			else
			{
				wWWForm.AddField("playlistPost", 1);
				www = new WWW(GetUserItemVotePHPURL, wWWForm);
			}
			yield return www;
			if (string.IsNullOrEmpty(www.error))
			{
				MonoBehaviour.print("Hole Rating Updated");
				MonoBehaviour.print(www.text);
			}
		}
	}

	public IEnumerator GetRatingData(List<WorkshopData> data, bool isPlaylist = false)
	{
		if (!(playerID != ""))
		{
			yield break;
		}
		for (int i = 0; i < data.Count; i++)
		{
			if (data[i].publishID != 0)
			{
				if (GameManager.instance.currentSceneName != "RoomPrepScene" && GameManager.instance.currentSceneName != "LobbyScene")
				{
					MonoBehaviour.print("Stopping downloading ratings");
					StopCoroutine(downloadRatingsCoroutine);
					break;
				}
				WWWForm wWWForm = new WWWForm();
				wWWForm.AddField("userIDPost", playerID);
				wWWForm.AddField("publishIDPost", data[i].publishID);
				if (isPlaylist)
				{
					wWWForm.AddField("playlistPost", 1);
				}
				wWWForm.AddField("functionName1Post", "GetData()");
				if (GameManager.instance.publishedPlatform == PublishedPlatform.OCULUS)
				{
					wWWForm.AddField("oculusOrgScopeIDPost", oculusOrgScopedID);
				}
				WWW www = ((data[i].cloudlandsVersion != 1) ? new WWW(GetUserItemVotePHPURL, wWWForm) : new WWW(Cloudlands1GetUserItemVotePHPURL, wWWForm));
				yield return www;
				if (string.IsNullOrEmpty(www.error))
				{
					WorkshopRating workshopRating = ParseUserTrackVoteData(www.text);
					data[i].workshopRating = workshopRating;
					data[i].workshopRating.publishedFileId = (ulong)data[i].publishID;
				}
			}
		}
	}

	public IEnumerator GetLeaderBoardData(WorkshopData data, bool playlist, Action<List<Leaderboard>> onComplete)
	{
		WWWForm wWWForm = new WWWForm();
		if (playlist)
		{
			wWWForm.AddField("playlistPost", 1);
		}
		wWWForm.AddField("publishIDPost", data.publishID);
		if (GameManager.instance.publishedPlatform == PublishedPlatform.XR)
		{
			if (GetAndroidIntent.instance.isDefaultAccount)
			{
				wWWForm.AddField("playerIDPost", "");
			}
			else
			{
				wWWForm.AddField("playerIDPost", playerID);
			}
		}
		else
		{
			wWWForm.AddField("playerIDPost", playerID);
		}
		if (GameManager.instance.publishedPlatform == PublishedPlatform.OCULUS)
		{
			wWWForm.AddField("oculusOrgScopeIDPost", oculusOrgScopedID);
		}
		wWWForm.AddField("functionNamePost", "GetLeaderboard()");
		wWWForm.AddField("passphrasePost", "FuturetownServerPassphrase");
		WWW www;
		if (data.cloudlandsVersion == 1)
		{
			wWWForm.AddField("cloudlandsPCHolePost", data.cloudlandsPCHole ? 1 : 0);
			wWWForm.AddField("cloudlandsMobileHolePost", data.cloudlandsMobileHole ? 1 : 0);
			www = new WWW(Cloudlands1GetLeaderboardPHPURL, wWWForm);
		}
		else
		{
			wWWForm.AddField("defaultHolePost", data.defaultHole ? 1 : 0);
			wWWForm.AddField("defaultHoleDifficultyPost", data.difficulty);
			www = new WWW(GetLeaderboardPHPURL, wWWForm);
		}
		yield return www;
		if (string.IsNullOrEmpty(www.error))
		{
			if (www.text != null)
			{
				List<Leaderboard> obj = ParseToHoleLeaderboard(www.text);
				onComplete(obj);
			}
		}
		else
		{
			MonoBehaviour.print("Error getting Hole Leaderboard Data: " + www.error);
			onComplete(null);
		}
	}

	public IEnumerator UploadScore(WorkshopData data, int score, bool playlist, Action<bool> onComplete)
	{
		if (playerID != "" && !disableUploadingHoleLeaderboard && score >= 0 && (data.publishID != 0 || data.defaultHole))
		{
			WWWForm wWWForm = new WWWForm();
			if (playlist)
			{
				wWWForm.AddField("playlistPost", 1);
				wWWForm.AddField("publishIDPost", data.publishID);
			}
			else
			{
				wWWForm.AddField("publishIDPost", data.publishID);
			}
			wWWForm.AddField("publishPlatformPost", (int)GameManager.instance.publishedPlatform);
			wWWForm.AddField("playerNamePost", playerUserName);
			wWWForm.AddField("playerIDPost", playerID);
			if (GameManager.instance.publishedPlatform == PublishedPlatform.OCULUS)
			{
				wWWForm.AddField("oculusOrgScopeIDPost", oculusOrgScopedID);
			}
			wWWForm.AddField("scorePost", score);
			wWWForm.AddField("functionNamePost", "CreateDatabaseItem()");
			wWWForm.AddField("passphrasePost", "FuturetownServerPassphrase");
			WWW www;
			if (data.cloudlandsVersion == 1)
			{
				wWWForm.AddField("cloudlandsPCHolePost", data.cloudlandsPCHole ? 1 : 0);
				wWWForm.AddField("cloudlandsMobileHolePost", data.cloudlandsMobileHole ? 1 : 0);
				www = new WWW(Cloudlands1GetLeaderboardPHPURL, wWWForm);
			}
			else
			{
				wWWForm.AddField("defaultHolePost", data.defaultHole ? 1 : 0);
				wWWForm.AddField("defaultHoleDifficultyPost", data.difficulty);
				www = new WWW(GetLeaderboardPHPURL, wWWForm);
			}
			yield return www;
			if (string.IsNullOrEmpty(www.error))
			{
				MonoBehaviour.print("Hole Leaderboard Uploaded");
				onComplete(obj: true);
			}
			else
			{
				MonoBehaviour.print("Error creating Hole Leaderboard: " + www.error);
				onComplete(obj: false);
			}
		}
		else
		{
			onComplete(obj: false);
		}
	}

	public string CreateAndReturnNewHoleFolder(int publishID, int CloudlandsVersion, bool playlist = false)
	{
		string text = "";
		if (playlist)
		{
			switch (CloudlandsVersion)
			{
			case 1:
				text = UnityEngine.Application.persistentDataPath + "/Downloads/Cloudlands1/Playlists/";
				break;
			case 2:
				text = UnityEngine.Application.persistentDataPath + "/Downloads/Cloudlands2/Playlists/";
				break;
			}
		}
		else
		{
			switch (CloudlandsVersion)
			{
			case 1:
				text = UnityEngine.Application.persistentDataPath + "/Downloads/Cloudlands1/Holes/";
				break;
			case 2:
				text = UnityEngine.Application.persistentDataPath + "/Downloads/Cloudlands2/Holes/";
				break;
			}
		}
		if (!Directory.Exists(text))
		{
			Directory.CreateDirectory(text);
		}
		string text2 = text + publishID + "/";
		if (!Directory.Exists(text2))
		{
			Directory.CreateDirectory(text2);
		}
		return text2;
	}

	private List<Leaderboard> ParseToHoleLeaderboard(string itemDataString)
	{
		string[] array = itemDataString.Split('\n');
		List<Leaderboard> list = new List<Leaderboard>();
		string[] array2 = array;
		foreach (string text in array2)
		{
			if (text != "")
			{
				Leaderboard item = JsonUtility.FromJson<Leaderboard>(text);
				list.Add(item);
			}
		}
		return list;
	}

	private WorkshopData ParseToWorkshopHoleData(string itemDataString)
	{
		if (!string.IsNullOrEmpty(itemDataString))
		{
			try
			{
				return JsonUtility.FromJson<WorkshopData>(itemDataString);
			}
			catch
			{
				return null;
			}
		}
		return null;
	}

	private WorkshopData ParseToWorkshopPlaylistData(string itemDataString)
	{
		if (!string.IsNullOrEmpty(itemDataString))
		{
			return JsonUtility.FromJson<WorkshopData>(itemDataString);
		}
		return null;
	}

	private OculusScopedID ParseToOculusScopedID(string itemDataString)
	{
		if (!string.IsNullOrEmpty(itemDataString))
		{
			OculusScopedID oculusScopedID = JsonUtility.FromJson<OculusScopedID>(itemDataString);
			if (oculusScopedID.id == null || oculusScopedID.org_scoped_id == null)
			{
				return null;
			}
			return oculusScopedID;
		}
		return null;
	}

	private WorkshopRating ParseUserTrackVoteData(string itemDataString)
	{
		if (!string.IsNullOrEmpty(itemDataString))
		{
			return JsonUtility.FromJson<WorkshopRating>(itemDataString);
		}
		return new WorkshopRating();
	}

	private string ParseString(string items, string index)
	{
		if (!string.IsNullOrEmpty(items) && index.Length > 0)
		{
			string text = items.Substring(items.IndexOf(index) + index.Length);
			if (text.Contains("|"))
			{
				text = text.Remove(text.IndexOf("|"));
			}
			return text;
		}
		return "";
	}

	private UploadData ParseToUploadedData(string itemDataString)
	{
		return JsonUtility.FromJson<UploadData>(itemDataString);
	}

	public IEnumerator GetSteamUser(string userID, Action<string> profileImage)
	{
		if (userID != null)
		{
			WWWForm wWWForm = new WWWForm();
			wWWForm.AddField("passphrasePost", "FuturetownServerPassphrase");
			wWWForm.AddField("playerIDPost", userID);
			WWW www = new WWW(SteamAvatarPHPURL, wWWForm);
			yield return www;
			if (string.IsNullOrEmpty(www.error))
			{
				profileImage(www.text);
			}
			else
			{
				profileImage(null);
			}
		}
		else
		{
			profileImage(null);
		}
	}

	public IEnumerator GetOculusUser(string userID, int cloudlandsVersion, Action<string> userName, Action<string> profileImage)
	{
		string imageURL = "";
		string playerName = "";
		WWW www = ((cloudlandsVersion != 1) ? new WWW("https://graph.oculus.com/" + userID + "?access_token=OC|2337198749686376|3f380a33971825fae088c9e467203ea4&fields=id,alias,org_scoped_id,profile_url_small") : new WWW("https://graph.oculus.com/" + userID + "?access_token=OC|956800941101082|6077c4732e8c5dc8149f50c1594f5df1&fields=id,alias,org_scoped_id,profile_url_small"));
		yield return www;
		OculusScopedID oculusScopedID = ParseToOculusScopedID(www.text);
		if (oculusScopedID != null)
		{
			playerName = oculusScopedID.alias;
			imageURL = oculusScopedID.profile_url_small;
		}
		if (!string.IsNullOrEmpty(imageURL))
		{
			profileImage(imageURL);
		}
		else
		{
			profileImage(null);
		}
		if (!string.IsNullOrEmpty(playerName))
		{
			userName(playerName);
		}
		else
		{
			userName("Guest");
		}
	}

	public IEnumerator GetOculusAvatar(string userID, Action<bool> hasAvatar)
	{
		WWW www = new WWW("https://graph.oculus.com/" + userID + "?access_token=OC|2337198749686376|3f380a33971825fae088c9e467203ea4&fields=avatar");
		yield return www;
		MonoBehaviour.print(www.text);
		if (string.IsNullOrEmpty(www.error))
		{
			if (!string.IsNullOrEmpty(www.text))
			{
				if (string.IsNullOrEmpty(JsonUtility.FromJson<OculusAvatar>(www.text).avatar.id))
				{
					hasAvatar(obj: false);
					MonoBehaviour.print("Error: No Avatar ID");
				}
				else
				{
					hasAvatar(obj: true);
				}
			}
			else
			{
				hasAvatar(obj: false);
			}
		}
		else
		{
			hasAvatar(obj: false);
		}
	}

	public string GetXboxUser(string xboxName)
	{
		xboxName = xboxName[..((xboxName.Length <= 15) ? xboxName.Length : 15)];
		return "http://avatar.xboxlive.com/avatar/" + xboxName + "/avatarpic-s.png";
	}

	public IEnumerator GetAvatarSprite(string url, Action<Sprite> img)
	{
		if (!string.IsNullOrEmpty(url))
		{
			WWW www = new WWW(url);
			yield return www;
			if (string.IsNullOrEmpty(www.error))
			{
				Texture2D texture2D = new Texture2D(0, 0);
				www.LoadImageIntoTexture(texture2D);
				texture2D.Apply(updateMipmaps: false, makeNoLongerReadable: true);
				Sprite obj = Sprite.Create(texture2D, new Rect(0f, 0f, texture2D.width, texture2D.height), new Vector2(0.5f, 0.5f), 100f, 0u, SpriteMeshType.FullRect);
				img(obj);
			}
			else
			{
				img(null);
			}
			www.Dispose();
		}
		else
		{
			img(null);
		}
	}

	public IEnumerator GetAvatarSprite(string url, Action<byte[]> jpgData)
	{
		if (!string.IsNullOrEmpty(url))
		{
			WWW www = new WWW(url);
			yield return www;
			if (string.IsNullOrEmpty(www.error))
			{
				jpgData(www.bytes);
			}
			else
			{
				jpgData(null);
			}
			www.Dispose();
		}
		else
		{
			jpgData(null);
		}
	}

	public bool IsBadWord(string name)
	{
		bool flag = false;
		foreach (string badWord in badWords)
		{
			if (name.ToLower().Contains(badWord))
			{
				flag = true;
				break;
			}
		}
		if (flag)
		{
			MonoBehaviour.print(name + " contains a bad word");
			return true;
		}
		MonoBehaviour.print(name + " does not contains a bad word");
		return false;
	}

	public string GetHoleParRange(int par)
	{
		string text = "";
		switch (par)
		{
		case 0:
			text = "zero";
			break;
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
			text = "1-5";
			break;
		default:
			if (par >= 6 && par <= 10)
			{
				text = "6-10";
			}
			else if (par >= 11 && par <= 15)
			{
				text = "11-15";
			}
			else if (par >= 16 && par <= 20)
			{
				text = "16-20";
			}
			else if (par >= 21 && par <= 25)
			{
				text = "21-25";
			}
			else if (par >= 26 && par <= 30)
			{
				text = "26-30";
			}
			else if (par >= 31 && par <= 40)
			{
				text = "31-40";
			}
			else if (par >= 41 && par <= 50)
			{
				text = "41-50";
			}
			else if (par >= 51 && par <= 75)
			{
				text = "51-75";
			}
			else if (par >= 76 && par <= 99)
			{
				text = "76-99";
			}
			break;
		}
		return text + " Pars";
	}

	public string GetPieceCountRange(int pieceCount)
	{
		string text = "";
		if (pieceCount >= 1 && pieceCount <= 25)
		{
			text = "1-25";
		}
		else if (pieceCount >= 26 && pieceCount <= 50)
		{
			text = "26-50";
		}
		else if (pieceCount >= 51 && pieceCount <= 75)
		{
			text = "51-75";
		}
		else if (pieceCount >= 76 && pieceCount <= 100)
		{
			text = "76-100";
		}
		else if (pieceCount >= 101 && pieceCount <= 150)
		{
			text = "101-150";
		}
		else if (pieceCount >= 151 && pieceCount <= 200)
		{
			text = "151-200";
		}
		return text + " Pieces";
	}

	public string GetPlaylistHoleRange(int holeCount)
	{
		string text = "";
		switch (holeCount)
		{
		case 2:
			text = "2";
			break;
		case 3:
		case 4:
			text = "3-4";
			break;
		case 5:
		case 6:
			text = "5-6";
			break;
		case 7:
		case 8:
			text = "7-8";
			break;
		case 9:
		case 10:
			text = "9-10";
			break;
		case 11:
		case 12:
			text = "11-12";
			break;
		case 13:
		case 14:
			text = "13-14";
			break;
		case 15:
		case 16:
			text = "15-16";
			break;
		case 17:
		case 18:
			text = "17-18";
			break;
		}
		return text + " Holes";
	}

	public string GetPlaylistParRange(int par)
	{
		string text = "";
		switch (par)
		{
		case 0:
			text = "zero";
			break;
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
		case 6:
		case 7:
		case 8:
		case 9:
		case 10:
			text = "1-10";
			break;
		default:
			if (par >= 11 && par <= 30)
			{
				text = "11-30";
			}
			else if (par >= 31 && par <= 50)
			{
				text = "31-50";
			}
			else if (par >= 51 && par <= 100)
			{
				text = "51-100";
			}
			else if (par >= 101 && par <= 150)
			{
				text = "101-150";
			}
			else if (par >= 151 && par <= 200)
			{
				text = "151-200";
			}
			else if (par >= 201 && par <= 300)
			{
				text = "201-300";
			}
			else if (par >= 301)
			{
				text = "300+";
			}
			break;
		}
		return text + " Pars";
	}
}
[Serializable]
public class WorkshopData
{
	public int publishID;

	public int publishPlatform;

	public string creatorName;

	public string creatorID;

	public string levelName;

	public int par;

	public int upvotes;

	public int downvotes;

	public int difficulty;

	public int pieceCount;

	public string uploadDate;

	public string fileLocation;

	public string imageLocation;

	public Texture2D screenshot;

	public Texture2D avatar;

	public bool cloudlandsPCHole;

	public bool cloudlandsMobileHole;

	public bool localItem;

	public WorkshopRating workshopRating;

	public bool cloudlandsPlaylist;

	public string holeCount;

	public string holeIds;

	public int cloudlandsVersion = 2;

	public bool defaultHole;

	public GolfClubType golfClubType;

	public bool visible = true;

	public bool wind;
}
public struct WorkshopURLLocation
{
	public string holeLocation;

	public string imageLocation;
}
[Serializable]
public class WorkshopRating
{
	public bool voteUp;

	public bool voteDown;

	public bool hasFavorited;

	public ulong publishedFileId;
}
public class OculusScopedID
{
	public string id;

	public string alias;

	public string org_scoped_id;

	public string profile_url_small;
}
public class OculusAvatar
{
	[Serializable]
	public struct OAvatar
	{
		public string id;
	}

	public OAvatar avatar;
}
[Serializable]
public class SearchFilters
{
	public string sortOrder = "Newest";

	public string sortPars = "";

	public string sortDifficulty = "";

	public string sortPieceCount = "";

	public string sortName = "";

	public string sortHoleCount = "";

	public int sortWind = -1;

	public int golfClub = 7;

	public bool mustIncludeSelected;

	public int CloudlandsVersion = 2;
}
public enum Difficulty
{
	Easy,
	Medium,
	Hard,
	SuperHard
}
public enum PublishedPlatform
{
	STEAM,
	OCULUS,
	VIVEPORT,
	NONE,
	XboxLive,
	XR,
	Pico
}
public struct UploadData
{
	public int publishID;

	public string fileLocation;

	public string imageLocation;
}
[Serializable]
public class Leaderboard
{
	public int rank;

	public int publishID;

	public int publishPlatform;

	public string playerName;

	public string playerID;

	public string oculusOrgScopeID;

	public int score;

	public string date;
}
public class RichPresenceManager : MonoBehaviour
{
	public static RichPresenceManager instance;

	public DeeplinkMessage deepLinkMessage = new DeeplinkMessage();

	public string currentDestinationAPIName;

	public bool gotDeeplinkMessage;

	public bool loadIntoRoomFromLobby;

	public bool createRoomForParty;

	public bool inParty;

	public string partyRoomID = "0";

	public string customHoleID = "";

	private void OnEnable()
	{
		RemoteServerManager.onOculusInitialized += InitializedOculusPlatform;
	}

	private void OnDisable()
	{
		RemoteServerManager.onOculusInitialized -= InitializedOculusPlatform;
	}

	private void Awake()
	{
		instance = this;
	}

	private void Start()
	{
	}

	private void OnLaunchIntentChangeNotif(Message<string> message)
	{
	}

	public static void UpdateConsole(string value)
	{
	}

	private void OnEntitlementCheck(Message message)
	{
	}

	public void ClearDestination()
	{
	}

	public void SetOnlineRoomDestination(string roomName, uint playerCount = 1u)
	{
	}

	public void SetLobbyDestination()
	{
	}

	public void LaunchGameParameters()
	{
	}

	public void GetFriendRichPresence()
	{
	}

	private void InitializedOculusPlatform()
	{
	}
}
public class DeeplinkMessage
{
	public string place = "";

	public string roomName = "";

	public string holeID = "";
}
public class SaveFileManager : MonoBehaviour
{
	public static SaveFileManager instance;

	public SaveFile saveFile;

	private string saveFilePath;

	public string playerID;

	private bool adjustedClubAngle;

	private void Awake()
	{
		instance = this;
		saveFilePath = UnityEngine.Application.persistentDataPath + "/save_data/";
	}

	private void Start()
	{
		playerID = GetLastLoggedInID();
		CreateSaveFile();
		LoadSaveFile();
	}

	public void CreateSaveFile()
	{
		string text = UnityEngine.Application.persistentDataPath + "/save_data/";
		if (RemoteServerManager.instance.playerID != "")
		{
			playerID = RemoteServerManager.instance.playerID;
			SetLastLoggedInID(playerID);
		}
		else
		{
			playerID = "Guest";
		}
		if (!Directory.Exists(text))
		{
			Directory.CreateDirectory(text);
		}
		string path = text + playerID + ".txt";
		if (!File.Exists(path))
		{
			new FileStream(path, FileMode.Create).Close();
			string value = JsonUtility.ToJson(new SaveFile());
			StreamWriter streamWriter = new StreamWriter(path, append: true);
			streamWriter.Write(value);
			streamWriter.Close();
		}
	}

	public void LoadSaveFile()
	{
		if (!Directory.Exists(saveFilePath))
		{
			return;
		}
		if (File.Exists(saveFilePath + playerID + ".txt"))
		{
			using (StreamReader streamReader = File.OpenText(saveFilePath + playerID + ".txt"))
			{
				string json = streamReader.ReadToEnd();
				saveFile = JsonUtility.FromJson<SaveFile>(json);
				ItemManager.instance.GetStock();
				if (!adjustedClubAngle)
				{
					adjustedClubAngle = true;
					Vector3 localEulerAngles = new Vector3(saveFile.clubAngle, 0f, 0f);
					if (GameManager.instance.controllerType == ControllerType.Quest)
					{
						localEulerAngles.x += -25f;
					}
					if (GameManager.instance.controllerType == ControllerType.Pico)
					{
						localEulerAngles.x -= 30f;
					}
					Player.instance.currentController.transform.localEulerAngles = localEulerAngles;
				}
				return;
			}
		}
		playerID = "Guest";
		SetLastLoggedInID(playerID);
		LoadSaveFile();
	}

	public void SaveFile()
	{
		string path = saveFilePath + playerID + ".txt";
		if (File.Exists(path))
		{
			new FileStream(path, FileMode.Create).Close();
			string value = JsonUtility.ToJson(saveFile);
			StreamWriter streamWriter = new StreamWriter(path, append: true);
			streamWriter.Write(value);
			streamWriter.Close();
			MonoBehaviour.print("File saved");
		}
		else
		{
			MonoBehaviour.print("Save file does not exist. Requires UserID");
		}
	}

	public Vector3 GetClubAngle()
	{
		Vector3 result = new Vector3(saveFile.clubAngle, 0f, 0f);
		if (GameManager.instance.controllerType == ControllerType.Quest)
		{
			result.x += -25f;
		}
		if (GameManager.instance.controllerType == ControllerType.Pico)
		{
			result.x -= 30f;
		}
		return result;
	}

	private void SetLastLoggedInID(string ID)
	{
		PlayerPrefs.SetString("LastLoggedInID", ID);
	}

	private string GetLastLoggedInID()
	{
		return PlayerPrefs.GetString("LastLoggedInID", "Guest");
	}
}
[Serializable]
public class SaveFile
{
	public int money;

	public int clubAngle;

	public int Normalball = 1;

	public int Gumball;

	public int Iceball;

	public int Airball;

	public int Heavyball;

	public int Featherball;

	public int AssistDriver;

	public int PowerDriver;

	public int ShortIron;

	public int FarIron;

	public int SuperPutter;

	public int NullifyWind;

	public int PuttLine;

	public int TeeGolfingSurface;

	public int Bomb;

	public int Smoke;

	public int[] campaignHoleScore = new int[54];

	public DriverType driverType;

	public IronType ironType;

	public PutterType putterType;

	public Color ballColor = Color.white;

	public BallType equippedBall;

	public int[] bossScore = new int[3];
}
public class ScoreManager : MonoBehaviour
{
	public static ScoreManager instance;

	public GameObject scoreCardSinglePlayerPrefab;

	public GameObject scoreCardMultiplayerPrefab;

	public GameObject scoreCardCampaignPrefab;

	[HideInInspector]
	public ScoreCard scoreCard;

	[HideInInspector]
	public ScoreCard multiplayerScoreCard;

	[HideInInspector]
	public ScoreCard campaignScoreCard;

	[HideInInspector]
	public ScoreCard currentScoreCard;

	public int[][] strokeTable = new int[4][];

	public int[] pars = new int[18];

	public int currentStrokeCount;

	public bool ballScored;

	public PlayerTurn[] playerTurn = new PlayerTurn[4];

	public int[] strokeTable1;

	public int[] strokeTable2;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
	}

	private void Start()
	{
		StartCoroutine(SwapScorecards());
		ResetStrokeTable(resetNames: true);
		playerTurn[0].clubProfile = GameManager.instance.GetClubProfile();
	}

	private void Update()
	{
		strokeTable1 = strokeTable[0];
		strokeTable2 = strokeTable[1];
	}

	public void AddStroke()
	{
		if (!ballScored)
		{
			currentStrokeCount = Mathf.Min(currentStrokeCount + 1, 99);
		}
	}

	public void RemoveStroke()
	{
		if (!ballScored)
		{
			currentStrokeCount = Mathf.Max(currentStrokeCount - 1, 0);
		}
	}

	public void ResetStrokeTable(bool resetNames = false)
	{
		for (int i = 0; i < 4; i++)
		{
			strokeTable[i] = new int[18];
			playerTurn[i].holeIndex = 0;
			if (resetNames)
			{
				playerTurn[i].playerName = "";
				playerTurn[i].inputName = true;
				if (i == 0)
				{
					playerTurn[i].ballColor = GameManager.instance.GetBallColor();
				}
				else
				{
					playerTurn[i].ballColor = new Color32(188, 188, 188, byte.MaxValue);
				}
			}
			for (int j = 0; j < 18; j++)
			{
				strokeTable[i][j] = -1;
			}
		}
		if (PhotonNetwork.IsConnected)
		{
			PhotonNetwork.LocalPlayer.SetScores(strokeTable[0]);
		}
		currentStrokeCount = 0;
		ResetPar();
	}

	public void ResetPar()
	{
		pars = new int[18];
		for (int i = 0; i < 18; i++)
		{
			pars[i] = -1;
		}
	}

	public void SetCampaignHighScore()
	{
		int num = currentScoreCard.ReturnStartingCampaignHole();
		int[] campaignHoleScore = SaveFileManager.instance.saveFile.campaignHoleScore;
		for (int i = 0; i < 18; i++)
		{
			strokeTable[0][i] = campaignHoleScore[num + i];
		}
	}

	public void SetScore(int playerIndex = 0)
	{
		if (currentStrokeCount == 0)
		{
			currentStrokeCount = 1;
		}
		if (GameManager.instance.gameMode == GameMode.Campaign)
		{
			if (strokeTable[0][GameManager.instance.holeIndex] == 0 || strokeTable[0][GameManager.instance.holeIndex] > currentStrokeCount)
			{
				strokeTable[0][GameManager.instance.holeIndex] = currentStrokeCount;
			}
			return;
		}
		strokeTable[playerIndex][GameManager.instance.holeIndex] = currentStrokeCount;
		if (PhotonNetwork.IsConnected)
		{
			PhotonNetwork.LocalPlayer.SetScores(strokeTable[playerIndex]);
		}
	}

	public IEnumerator SwapScorecards()
	{
		yield return null;
		if (PhotonNetwork.IsConnected || GameManager.instance.currentSceneName == "LobbyScene" || GameManager.instance.playerCount > 1)
		{
			if (multiplayerScoreCard == null)
			{
				multiplayerScoreCard = UnityEngine.Object.Instantiate(scoreCardMultiplayerPrefab).GetComponent<ScoreCard>();
				multiplayerScoreCard.transform.SetParent(GameManager.instance.pauseMenu.scoreCardTransform);
				multiplayerScoreCard.transform.localPosition = Vector3.zero;
				multiplayerScoreCard.transform.localRotation = Quaternion.identity;
			}
			if (scoreCard != null)
			{
				scoreCard.gameObject.SetActive(value: false);
			}
			if (campaignScoreCard != null)
			{
				campaignScoreCard.gameObject.SetActive(value: false);
			}
			multiplayerScoreCard.gameObject.SetActive(value: true);
			currentScoreCard = multiplayerScoreCard;
		}
		else if (GameManager.instance.gameMode == GameMode.Campaign && !GameManager.instance.hideBosses)
		{
			if (campaignScoreCard == null)
			{
				campaignScoreCard = UnityEngine.Object.Instantiate(scoreCardCampaignPrefab).GetComponent<ScoreCard>();
				campaignScoreCard.transform.SetParent(GameManager.instance.pauseMenu.scoreCardTransform);
				campaignScoreCard.transform.localPosition = Vector3.zero;
				campaignScoreCard.transform.localRotation = Quaternion.identity;
			}
			if (scoreCard != null)
			{
				scoreCard.gameObject.SetActive(value: false);
			}
			if (multiplayerScoreCard != null)
			{
				multiplayerScoreCard.gameObject.SetActive(value: false);
			}
			campaignScoreCard.gameObject.SetActive(value: true);
			currentScoreCard = campaignScoreCard;
		}
		else
		{
			if (scoreCard == null)
			{
				scoreCard = UnityEngine.Object.Instantiate(scoreCardSinglePlayerPrefab).GetComponent<ScoreCard>();
				scoreCard.transform.SetParent(GameManager.instance.pauseMenu.scoreCardTransform);
				scoreCard.transform.localPosition = Vector3.zero;
				scoreCard.transform.localRotation = Quaternion.identity;
			}
			if (multiplayerScoreCard != null)
			{
				multiplayerScoreCard.gameObject.SetActive(value: false);
			}
			if (campaignScoreCard != null)
			{
				campaignScoreCard.gameObject.SetActive(value: false);
			}
			scoreCard.gameObject.SetActive(value: true);
			currentScoreCard = scoreCard;
		}
	}

	public void SetHolePars()
	{
		pars = new int[GameManager.instance.holeData.Count];
		for (int i = 0; i < GameManager.instance.holeData.Count; i++)
		{
			pars[i] = GameManager.instance.holeData[i].par;
		}
	}

	public int GetTotalStrokes(int playerIndex = 0)
	{
		int num = 0;
		int[] array = strokeTable[playerIndex];
		foreach (int num2 in array)
		{
			if (num2 != -1)
			{
				num += num2;
			}
		}
		return num;
	}

	public int GetTotalPars()
	{
		int num = 0;
		int[] array = pars;
		foreach (int num2 in array)
		{
			num += num2;
		}
		return num;
	}

	public void ResetStrokes()
	{
		for (int i = 0; i < 4; i++)
		{
			strokeTable[i] = new int[18];
			playerTurn[i].holeIndex = 0;
			for (int j = 0; j < 18; j++)
			{
				strokeTable[i][j] = -1;
			}
		}
		if (PhotonNetwork.IsConnected)
		{
			PhotonNetwork.LocalPlayer.SetScores(strokeTable[0]);
		}
		currentStrokeCount = 0;
	}

	public int GetInOutTotal(int player, string inOut)
	{
		int num = 0;
		int num2 = 0;
		for (int i = 0; i < 18; i++)
		{
			if (GameManager.instance.gameMode == GameMode.Campaign)
			{
				int num3 = currentScoreCard.ReturnStartingCampaignHole();
				int[] campaignHoleScore = SaveFileManager.instance.saveFile.campaignHoleScore;
				if (i < 9)
				{
					num += campaignHoleScore[num3 + i];
				}
				else
				{
					num2 += campaignHoleScore[num3 + i];
				}
			}
			else if (strokeTable[player][i] != -1)
			{
				if (i < 9)
				{
					num += strokeTable[player][i];
				}
				else
				{
					num2 += strokeTable[player][i];
				}
			}
		}
		if (inOut == "in")
		{
			return num2;
		}
		if (inOut == "out")
		{
			return num;
		}
		return num2 + num;
	}

	public void SetPhotonScores(bool fromLobby = false)
	{
		if (!PhotonNetwork.InRoom)
		{
			return;
		}
		ResetOtherPlayerStrokesForOnline();
		List<Photon.Realtime.Player> usablePlayers = PhotonManager.instance.GetUsablePlayers(includeSelf: false);
		int num = usablePlayers.Count;
		if (fromLobby)
		{
			num++;
		}
		for (int i = 0; i < num; i++)
		{
			for (int j = 0; j < 18; j++)
			{
				int[] array = ((!fromLobby) ? usablePlayers[i].GetScores() : ((i != 0) ? usablePlayers[i - 1].GetScores() : PhotonNetwork.LocalPlayer.GetScores()));
				if (j >= array.Length)
				{
					continue;
				}
				if (fromLobby)
				{
					if (i == 0)
					{
						strokeTable[i][j] = PhotonNetwork.LocalPlayer.GetScores()[j];
					}
					else
					{
						strokeTable[i][j] = array[j];
					}
				}
				else
				{
					strokeTable[i + 1][j] = array[j];
				}
			}
		}
	}

	private void ResetOtherPlayerStrokesForOnline()
	{
		for (int i = 0; i < 3; i++)
		{
			strokeTable[i + 1] = new int[18];
			for (int j = 0; j < 18; j++)
			{
				strokeTable[i + 1][j] = -1;
			}
		}
	}

	public void SetDoubleParOnLateJoin()
	{
		for (int i = 0; i < GameManager.instance.holeIndex; i++)
		{
			if (pars[i] == 0)
			{
				strokeTable[0][i] = 1;
			}
			else
			{
				strokeTable[0][i] = pars[i] * 2;
			}
		}
	}
}
[Serializable]
public class PlayerTurn
{
	public string playerName = "";

	public int holeIndex;

	public int mulligansLeft = 5;

	public bool mulliganUsed;

	public bool infiniteMulligan;

	public bool inputName = true;

	public Color ballColor = new Color32(188, 188, 188, byte.MaxValue);

	public ClubProfile clubProfile;
}
public class SplashManager : MonoBehaviour
{
	public static SplashManager instance;

	public GameObject futuretownLogo;

	public GameObject cloudlandsLogo;

	public float futuretownDuration = 3f;

	public float cloudlandsDuration = 3f;

	private bool failedEntitlement;

	private bool oculusInitialized;

	private void Awake()
	{
		instance = this;
	}

	private void Start()
	{
		StartCoroutine(DisplayCloudlandsLogo());
	}

	private void CheckEntitlement()
	{
		Entitlements.IsUserEntitledToApplication().OnComplete(OculusEntitlementCheckCallback);
		oculusInitialized = true;
	}

	private void OculusEntitlementCheckCallback(Message msg)
	{
		if (msg.IsError)
		{
			MonoBehaviour.print("Error: Failed Oculus Entitlement Check");
			StartCoroutine(FailedOculusEntitlement());
		}
		else
		{
			MonoBehaviour.print("Passed Oculus Entitlement Check");
		}
	}

	private IEnumerator FailedOculusEntitlement()
	{
		if (GameManager.instance.currentSceneName == "Splash")
		{
			futuretownLogo.SetActive(value: false);
			failedEntitlement = true;
		}
		Notification.instance.AddNotification("You are playing an illegitimate copy of Cloudlands 2", 0f, closeButton: true);
		yield return new WaitForSeconds(5f);
		UnityEngine.Application.Quit();
		MonoBehaviour.print("Closing app");
	}

	private IEnumerator DisplayFuturetownLogo()
	{
		while (GameManager.instance == null || GameManager.instance.player == null)
		{
			yield return null;
		}
		Player.instance.currentController.gameObject.SetActive(value: false);
		yield return new WaitForSeconds(futuretownDuration);
		futuretownLogo.SetActive(value: false);
		StartCoroutine(DisplayCloudlandsLogo());
	}

	private IEnumerator DisplayCloudlandsLogo()
	{
		cloudlandsLogo.SetActive(value: true);
		yield return new WaitForSeconds(cloudlandsDuration);
		cloudlandsLogo.SetActive(value: false);
		if (GameManager.instance.publishedPlatform == PublishedPlatform.STEAM)
		{
			SceneManager.MoveGameObjectToScene(SteamVR_Render.instance.gameObject, SceneManager.GetSceneByName("Main"));
		}
		if (!failedEntitlement)
		{
			MonoBehaviour.print("Loading scenes");
			GameManager.instance.GetCampaignWorkshopData();
			if (PlayerPrefs.GetInt("Tutorial", 0) == 0)
			{
				GameManager.instance.SwitchToScene("Tutorial");
			}
			else
			{
				GameManager.instance.SwitchToScene("MainMenu");
			}
		}
	}
}
public class TutorialManager : MonoBehaviour
{
	public static TutorialManager instance;

	public GameObject instructionBoard;

	public GameObject constrainedOrFreeSwingButtons;

	public Transform boardObjectTransform;

	public TextMeshPro instructionMessage;

	public Camera minimapCamera;

	private bool setHandiness;

	private bool rotatedView;

	private bool manualWarped;

	[HideInInspector]
	public bool autoWarped;

	private bool ballHit;

	private bool pauseOpened;

	private bool pauseClosed;

	private bool quickMenu;

	[HideInInspector]
	public bool secondaryJoystickFunction;

	[HideInInspector]
	public bool adjustAim;

	private bool changedClubs;

	public Vector3 boardPos = new Vector3(0f, -1f, 0f);

	public Vector3 boardRot = new Vector3(-40f, 0f, 0f);

	private string currentInstruction = "";

	private void OnEnable()
	{
		LocalizationManager.OnLocalizeEvent += OnLocalizationCall;
	}

	private void OnDisable()
	{
		LocalizationManager.OnLocalizeEvent -= OnLocalizationCall;
	}

	private void OnLocalizationCall()
	{
		instructionMessage.text = LocalizationManager.GetTranslation(currentInstruction);
	}

	private void Awake()
	{
		instance = this;
	}

	private void Start()
	{
		StartCoroutine(Tutorial());
	}

	private void Update()
	{
		if (Notification.instance.gameObject.activeSelf)
		{
			instructionBoard.SetActive(value: false);
			return;
		}
		if (!changedClubs)
		{
			instructionBoard.SetActive(value: true);
		}
		if (GameManager.instance.pauseMenu.paused || GameManager.instance.quickMenu.menu.activeSelf)
		{
			if (GameManager.instance.pauseMenu.paused)
			{
				boardObjectTransform.transform.position = GameManager.instance.pauseMenu.tutorialBoardAnchors.position;
				boardObjectTransform.transform.rotation = GameManager.instance.pauseMenu.tutorialBoardAnchors.rotation;
			}
		}
		else if (!GameManager.instance.quickMenu.menu.activeSelf)
		{
			boardObjectTransform.transform.localPosition = boardPos;
			boardObjectTransform.transform.localEulerAngles = boardRot;
			GameManager.instance.CenterNotification(instructionBoard, useLerp: true);
		}
	}

	private IEnumerator Tutorial()
	{
		if (GameManager.instance.publishedPlatform == PublishedPlatform.XR)
		{
			Notification.instance.AddMultipleChoiceNotification("Are you left or right handed?", SetLeftHanded, SetRightHanded, "Left", "Right");
			while (setHandiness)
			{
				yield return null;
			}
		}
		else
		{
			yield return null;
		}
		Player.instance.clubSwitcher.SwitchToClubType(ClubType.Driver);
		OpenInstructions();
		while (!rotatedView)
		{
			if (GameManager.instance.controllerType == ControllerType.Quest)
			{
				SetInstructions("Welcome! To start, flick the joystick left or right to rotate left or right.");
			}
			else if (GameManager.instance.controllerType == ControllerType.Pico)
			{
				SetInstructions("Welcome! To start, flick the joystick left or right to rotate left or right.");
			}
			else if (GameManager.instance.controllerType == ControllerType.Vive)
			{
				SetInstructions("Welcome! To start, press left or right on the touchpad to rotate left or right.");
			}
			else
			{
				SetInstructions("Welcome! To start, press left or right on the touchpad to rotate left or right.");
			}
			yield return null;
		}
		while (!manualWarped)
		{
			if (GameManager.instance.controllerType == ControllerType.Quest)
			{
				SetInstructions("Hold the joystick up to preview where you will teleport. Release to teleport. Try it now and make sure to aim at the ground.");
			}
			else if (GameManager.instance.controllerType == ControllerType.Pico)
			{
				SetInstructions("Hold the joystick up to preview where you will teleport. Release to teleport. Try it now and make sure to aim at the ground.");
			}
			else if (GameManager.instance.controllerType == ControllerType.Vive)
			{
				SetInstructions("Hold touchpad up to preview where you will teleport. Release to teleport. Try it now and make sure to aim at the ground.");
			}
			else
			{
				SetInstructions("Hold touchpad up to preview where you will teleport. Release to teleport. Try it now and make sure to aim at the ground.");
			}
			yield return null;
		}
		while (!autoWarped)
		{
			SetInstructions("You can teleport directly to the ball by pressing the trigger button.");
			yield return null;
		}
		while (!ballHit)
		{
			if (GameManager.instance.publishedPlatform == PublishedPlatform.XR)
			{
				SetInstructions("Rotate the controller to aim. Hold the grab button and swing to hit the ball.");
			}
			else
			{
				SetInstructions("Try hitting the ball by swinging at it with your club.");
			}
			yield return null;
		}
		while (!quickMenu)
		{
			if (GameManager.instance.controllerType == ControllerType.Quest)
			{
				SetInstructions("Moving the joystick down lets you open the quick menu. You can change clubs and view the map. Flick down again to close the menu.");
			}
			else if (GameManager.instance.controllerType == ControllerType.Pico)
			{
				SetInstructions("Moving the joystick down lets you open the quick menu. You can change clubs and view the map. Flick down again to close the menu.");
			}
			else if (GameManager.instance.controllerType == ControllerType.Vive)
			{
				SetInstructions("Pressing down on the touchpad lets you open the quick menu. You can change clubs and view the map. Press down again to close the menu.");
			}
			else
			{
				SetInstructions("Pressing down on the touchpad lets you open the quick menu. You can change clubs and view the map. Press down again to close the menu.");
			}
			yield return null;
		}
		while (!pauseOpened)
		{
			if (GameManager.instance.controllerType == ControllerType.Quest)
			{
				if (Player.instance.rightHanded)
				{
					SetInstructions("Press the A/B button to open the pause menu and view your scorecard and settings.");
				}
				else
				{
					SetInstructions("Press the X/Y button to open the pause menu and view your scorecard and settings.");
				}
			}
			else if (GameManager.instance.controllerType == ControllerType.Vive)
			{
				SetInstructions("Press the menu button to open the pause menu and view your scorecard and settings.");
			}
			else
			{
				SetInstructions("Press the menu button to open the pause menu and view your scorecard and settings.");
			}
			yield return null;
		}
		while (!pauseClosed)
		{
			if (GameManager.instance.controllerType == ControllerType.Quest)
			{
				if (Player.instance.rightHanded)
				{
					SetInstructions("Point at options and press the Trigger to interact. Settings include handedness, club length, and ball color. You can also redo your shot by using a mulligan. Click Resume or press A/B to continue.");
				}
				else
				{
					SetInstructions("Point at options and press the Trigger to interact. Settings include handedness, club length, and ball color. You can also redo your shot by using a mulligan. Click Resume or press X/Y to continue.");
				}
			}
			else if (GameManager.instance.controllerType == ControllerType.Vive)
			{
				SetInstructions("Point at options and press the Trigger to interact. Settings include handedness, club length, and ball color. You can also redo your shot by using a mulligan. Click Resume or press the menu button to continue.");
			}
			else if (GameManager.instance.publishedPlatform == PublishedPlatform.XR)
			{
				SetInstructions("Point at options and press the Trigger to interact. Settings include club power and ball color. You can also redo your shot by using a mulligan. Click Resume or press the menu button to continue.");
			}
			else
			{
				SetInstructions("Point at options and press the Trigger to interact. Settings include handedness, club length, and ball color. You can also redo your shot by using a mulligan. Click Resume or press the menu button to continue.");
			}
			yield return null;
		}
		if (GameManager.instance.publishedPlatform != PublishedPlatform.XR)
		{
			while (!secondaryJoystickFunction)
			{
				if (GameManager.instance.controllerType == ControllerType.Quest)
				{
					SetInstructions("Now for some advance functions. You can change the functionality of the joystick by holding the Grip button");
				}
				else if (GameManager.instance.controllerType == ControllerType.Pico)
				{
					SetInstructions("Now for some advance functions. You can change the functionality of the joystick by holding the Grip button");
				}
				else if (GameManager.instance.controllerType == ControllerType.Vive)
				{
					SetInstructions("Now for some advance functions. You can change the functionality of the touchpad by holding the Grip button");
				}
				else if (GameManager.instance.controllerType == ControllerType.XR)
				{
					SetInstructions("Now for some advance functions. You can change the functionality of the touchpad by holding the Grab button");
				}
				else
				{
					SetInstructions("Now for some advance functions. You can change the functionality of the touchpad by holding the Grip button");
				}
				yield return null;
			}
		}
		else
		{
			secondaryJoystickFunction = true;
		}
		if (GameManager.instance.publishedPlatform != PublishedPlatform.XR)
		{
			while (!adjustAim)
			{
				if (GameManager.instance.controllerType == ControllerType.Quest)
				{
					SetInstructions("To adjust the curve of the ball trajectory, be near the ball and hold the Grip button and down on the joystick. Rotate the controller to adjust the power.");
				}
				else if (GameManager.instance.controllerType == ControllerType.Pico)
				{
					SetInstructions("To adjust the curve of the ball trajectory, be near the ball and hold the Grip button and down on the joystick. Rotate the controller to adjust the power.");
				}
				else if (GameManager.instance.controllerType == ControllerType.Vive)
				{
					SetInstructions("To adjust the curve of the ball trajectory, be near the ball and hold the Grip button and down on the touchpad. Rotate the controller to adjust the power.");
				}
				else
				{
					SetInstructions("To adjust the curve of the ball trajectory, be near the ball and hold the Grip button and down on the touchpad. Rotate the controller to adjust the power.");
				}
				yield return null;
			}
		}
		else
		{
			AdjustAim();
		}
		while (!changedClubs)
		{
			if (GameManager.instance.publishedPlatform == PublishedPlatform.XR)
			{
				SetInstructions("To change clubs, be near the ball, hold the Grab button and press the touchpad left/right.");
			}
			else if (GameManager.instance.controllerType == ControllerType.Quest)
			{
				SetInstructions("To change clubs, hold the Grip button and flick the joystick left/right.");
			}
			else if (GameManager.instance.controllerType == ControllerType.Pico)
			{
				SetInstructions("To change clubs, hold the Grip button and flick the joystick left/right.");
			}
			else if (GameManager.instance.controllerType == ControllerType.Vive)
			{
				SetInstructions("To change clubs, hold the Grip button and press the touchpad left/right.");
			}
			else
			{
				SetInstructions("To change clubs, hold the Grip button and press the touchpad left/right.");
			}
			yield return null;
		}
		SetInstructions("Putt the ball into the hole to complete the tutorial. Have fun!");
		yield return new WaitForSeconds(5f);
		instructionBoard.SetActive(value: false);
	}

	private void OpenInstructions()
	{
		instructionBoard.SetActive(value: true);
	}

	private void SetInstructions(string s)
	{
		currentInstruction = s;
		instructionMessage.text = LocalizationManager.GetTranslation(s);
	}

	public void RotatedView()
	{
		rotatedView = true;
	}

	public void ManualWarped()
	{
		if (rotatedView)
		{
			manualWarped = true;
		}
	}

	public void BallHit()
	{
		if (autoWarped)
		{
			ballHit = true;
		}
	}

	public void AutoWarped()
	{
		if (manualWarped)
		{
			autoWarped = true;
		}
	}

	public void QuickMenu()
	{
		if (autoWarped)
		{
			quickMenu = true;
		}
	}

	public void PauseOpened()
	{
		if (quickMenu)
		{
			pauseOpened = true;
		}
	}

	public void PauseClosed()
	{
		if (pauseOpened)
		{
			pauseClosed = true;
		}
	}

	public void GripHeld()
	{
		if (!pauseClosed)
		{
			return;
		}
		secondaryJoystickFunction = true;
		if (adjustAim)
		{
			return;
		}
		Player.instance.clubSwitcher.usableClubs = GolfClubType.Iron | GolfClubType.Driver;
		if (Player.instance.clubSwitcher.currentType == ClubType.Putter)
		{
			if (GameManager.instance.golfball.currentSurface == SurfaceType.Tee)
			{
				Player.instance.clubSwitcher.SwitchToClubType(ClubType.Driver);
			}
			else if (GameManager.instance.golfball.currentSurface == SurfaceType.Fairway)
			{
				Player.instance.clubSwitcher.SwitchToClubType(ClubType.Iron);
			}
			else
			{
				Player.instance.clubSwitcher.SwitchToClubType(ClubType.Iron);
			}
		}
	}

	public void AdjustAim()
	{
		if (secondaryJoystickFunction)
		{
			Player.instance.clubSwitcher.usableClubs = GolfClubType.Putter | GolfClubType.Iron | GolfClubType.Driver;
			adjustAim = true;
		}
	}

	public void ChangedClubs()
	{
		if (adjustAim)
		{
			changedClubs = true;
			FinishedTutorial();
		}
	}

	public void FinishedTutorial()
	{
		if (changedClubs)
		{
			GameManager.instance.SetTutorial(x: true);
		}
	}

	public void ChildBoardToTransform(Transform t)
	{
		boardObjectTransform.SetParent(t, worldPositionStays: false);
	}

	private void SetRightHanded()
	{
		if (GameManager.instance.controllerType == ControllerType.XR)
		{
			Player.instance.SwapXRControllerHandedness(right: true);
		}
		else if (!GameManager.instance.GetHandedness())
		{
			Player.instance.SwapControllers();
		}
		setHandiness = true;
		Notification.instance.CloseSign();
	}

	private void SetLeftHanded()
	{
		if (GameManager.instance.controllerType == ControllerType.XR)
		{
			Player.instance.SwapXRControllerHandedness(right: false);
		}
		else if (GameManager.instance.GetHandedness())
		{
			Player.instance.SwapControllers();
		}
		setHandiness = true;
		Notification.instance.CloseSign();
	}
}
public class MessageBoard : MonoBehaviour
{
	public Renderer FAQButton;

	public Renderer WhatsNewButton;

	public Material frameMaterial;

	public Material frameHighlightMaterial;

	public Material frameActiveMaterial;

	public GameObject mainCanvas;

	public GameObject WhatsNewPanel;

	public GameObject FAQsPanel;

	public GameObject FAQsList;

	public GameObject FAQEntryPanel;

	public TextMeshProUGUI FAQEntryTitle;

	public TextMeshProUGUI FAQEntryText;

	public FAQ[] faqs;

	public Transform faqButtonParent;

	public FAQButton buttonPrefab;

	public GameObject scrollButtons;

	private int currentFAQEntry;

	private void OnEnable()
	{
		LocalizationManager.OnLocalizeEvent += OnLocalizationCall;
	}

	private void OnDisable()
	{
		LocalizationManager.OnLocalizeEvent -= OnLocalizationCall;
	}

	private void Start()
	{
		SetFAQ();
	}

	private void SetFAQ()
	{
		FAQPlatform fAQPlatform = FAQPlatform.All;
		fAQPlatform = FAQPlatform.Android;
		for (int i = 0; i < faqs.Length; i++)
		{
			if (faqs[i].platform == FAQPlatform.All || faqs[i].platform == fAQPlatform)
			{
				FAQButton fAQButton = UnityEngine.Object.Instantiate(buttonPrefab, faqButtonParent);
				fAQButton.mb = this;
				fAQButton.FAQIndex = i;
				fAQButton.title.text = LocalizationManager.GetTranslation(faqs[i].title);
			}
		}
	}

	public void OpenFAQs()
	{
		mainCanvas.SetActive(value: true);
		WhatsNewPanel.SetActive(value: false);
		FAQsPanel.SetActive(value: true);
		FAQsList.SetActive(value: true);
		FAQEntryPanel.SetActive(value: false);
		scrollButtons.SetActive(value: true);
	}

	public void OpenWhatsNew()
	{
		mainCanvas.SetActive(value: true);
		WhatsNewPanel.SetActive(value: true);
		FAQsPanel.SetActive(value: false);
		FAQsList.SetActive(value: false);
		FAQEntryPanel.SetActive(value: false);
		scrollButtons.SetActive(value: false);
	}

	public void OpenFAQsEntry(int index)
	{
		currentFAQEntry = index;
		mainCanvas.SetActive(value: true);
		WhatsNewPanel.SetActive(value: false);
		FAQsPanel.SetActive(value: true);
		FAQsList.SetActive(value: false);
		FAQEntryPanel.SetActive(value: true);
		scrollButtons.SetActive(value: false);
		FAQEntryTitle.text = LocalizationManager.GetTranslation(faqs[index].title);
		FAQEntryText.text = LocalizationManager.GetTranslation(faqs[index].detail);
	}

	public void CloseBoard()
	{
		mainCanvas.SetActive(value: false);
	}

	private void OnLocalizationCall()
	{
		FAQEntryTitle.text = LocalizationManager.GetTranslation(faqs[currentFAQEntry].title);
		FAQEntryText.text = LocalizationManager.GetTranslation(faqs[currentFAQEntry].detail);
	}
}
[Serializable]
public struct FAQ
{
	public string title;

	public string detail;

	public FAQPlatform platform;
}
public enum FAQPlatform
{
	All,
	Android,
	PC
}
public class MinimapCamera : MonoBehaviour
{
	public Camera cam;

	public bool turnOffShadows;

	public float tempShadowDist;

	public LayerMask minimapLayers;

	public LayerMask minimapIconsLayers;

	public void RenderToTex(RenderTexture tex)
	{
		RenderTexture targetTexture = cam.targetTexture;
		cam.targetTexture = tex;
		cam.cullingMask = minimapLayers;
		cam.clearFlags = CameraClearFlags.Skybox;
		RenderTexture.active = tex;
		cam.Render();
		RenderTexture.active = null;
		cam.targetTexture = targetTexture;
		cam.cullingMask = minimapIconsLayers;
		cam.clearFlags = CameraClearFlags.Color;
	}
}
public class NameInput : MonoBehaviour
{
	public TextMeshPro[] initialsText;

	public int characterIndex = 2;

	public string playerName = "";

	private float blinkSpeed = 1f;

	private float blinkTimer;

	private void Start()
	{
		GameManager.instance.pauseMenu.allowPausing = false;
		if (ScoreManager.instance.playerTurn[GameManager.instance.playerIndex].playerName == "")
		{
			playerName = "P" + (GameManager.instance.playerIndex + 1) + "_";
		}
		else
		{
			playerName = ScoreManager.instance.playerTurn[GameManager.instance.playerIndex].playerName;
			characterIndex = playerName.Length;
			for (int i = 0; i < 3 - characterIndex; i++)
			{
				playerName += "_";
			}
		}
		initialsText[0].text = playerName[0].ToString();
		initialsText[1].text = playerName[1].ToString();
		initialsText[2].text = playerName[2].ToString();
		Player.instance.currentController.SwitchToPointer();
		GameManager.instance.CenterNotification(base.gameObject);
		if (GameManager.instance.playerIndex != 0)
		{
			_ = ScoreManager.instance.playerTurn[GameManager.instance.playerIndex].ballColor;
		}
	}

	private void Update()
	{
		Blinker();
	}

	public void DeleteLetter()
	{
		if (characterIndex <= 0)
		{
			return;
		}
		if (characterIndex < 3)
		{
			playerName = playerName.Remove(characterIndex - 1, 1).Insert(characterIndex - 1, "_");
			characterIndex--;
			return;
		}
		characterIndex--;
		if (characterIndex > 0)
		{
			playerName = playerName.Remove(characterIndex, 1).Insert(characterIndex, "_");
		}
	}

	public void LetterSelected(string letter)
	{
		if (characterIndex < 3)
		{
			playerName = playerName.Remove(characterIndex, 1).Insert(characterIndex, letter);
			characterIndex++;
		}
	}

	public void EnterName()
	{
		string text = playerName;
		for (int num = 2; num >= 0; num--)
		{
			if (text[num] == '_')
			{
				text = text.Remove(num, 1);
			}
		}
		if (text.Length > 0)
		{
			GameManager.instance.pauseMenu.allowPausing = true;
			ScoreManager.instance.playerTurn[GameManager.instance.playerIndex].playerName = text;
			ScoreManager.instance.playerTurn[GameManager.instance.playerIndex].inputName = false;
			Player.instance.currentController.SwitchToClubs();
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	private void Blinker()
	{
		if (characterIndex < 3)
		{
			blinkTimer += Time.deltaTime;
			if (blinkTimer > blinkSpeed)
			{
				blinkTimer = 0f;
			}
			string text = playerName;
			text = ((!(blinkTimer <= blinkSpeed / 2f)) ? text.Remove(characterIndex, 1).Insert(characterIndex, " ") : text.Remove(characterIndex, 1).Insert(characterIndex, "_"));
			for (int i = 0; i < 3; i++)
			{
				initialsText[i].text = text[i].ToString();
			}
		}
		else
		{
			for (int j = 0; j < 3; j++)
			{
				initialsText[j].text = playerName[j].ToString();
			}
		}
	}
}
public class Notification : MonoBehaviour
{
	public static Notification instance;

	public List<NotificationData> notificationQueue = new List<NotificationData>();

	public TextMeshPro message;

	public TextMeshPro choice1Message;

	public TextMeshPro choice2Message;

	public GameObject closeButton;

	public GameObject confirmButtons;

	public GameObject choiceButtons;

	public Action confirmAction;

	public Action cancelAction;

	public Action choice1Action;

	public Action choice2Action;

	private float messageTimer;

	public void Awake()
	{
		base.gameObject.SetActive(value: false);
		if (instance == null)
		{
			instance = this;
		}
		else
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
		FollowSign component = GetComponent<FollowSign>();
		if (component != null)
		{
			component.SetDistance(1.8f);
		}
	}

	public void Update()
	{
		if (!(messageTimer > 0f))
		{
			return;
		}
		messageTimer -= Time.deltaTime;
		if (messageTimer <= 0f)
		{
			messageTimer = 0f;
			if (notificationQueue.Count > 0)
			{
				ShowNextNotification();
			}
			else
			{
				base.gameObject.SetActive(value: false);
			}
		}
	}

	public void AddNotification(string inputMessage, float time = 5f, bool closeButton = false)
	{
		DisplayNotification(new NotificationData(inputMessage, "", time, closeButton));
	}

	public void AddNotification(string inputMessage, string secondMessage, float time = 5f, bool closeButton = false)
	{
		DisplayNotification(new NotificationData(inputMessage, secondMessage, time, closeButton));
	}

	public void AddConfirmNotification(string inputMessage, Action confirmAction, Action cancelAction = null)
	{
		DisplayNotification(new NotificationData(inputMessage, "", 0f, closeButton: false, confirmAction, cancelAction));
	}

	public void AddMultipleChoiceNotification(string inputMessage, Action choice1Action, Action choice2Action, string choice1Message, string choice2Message)
	{
		DisplayNotification(new NotificationData(inputMessage, "", 0f, closeButton: false, confirmAction, cancelAction, choice1Action, choice2Action, choice1Message, choice2Message));
	}

	public void ClearAndHideNotifications()
	{
		notificationQueue = new List<NotificationData>();
		ResetAndHideNotification();
	}

	public void DisplayNotification(NotificationData data)
	{
		bool flag = true;
		if (message.text == data.message)
		{
			flag = false;
		}
		else if (notificationQueue.Count > 0)
		{
			for (int i = 0; i < notificationQueue.Count; i++)
			{
				if (notificationQueue[i].message == data.message)
				{
					flag = false;
					break;
				}
			}
		}
		if (!flag)
		{
			return;
		}
		notificationQueue.Add(data);
		if (!base.gameObject.activeSelf)
		{
			if (GameManager.instance.player != null)
			{
				base.transform.position = GameManager.instance.player.transform.position;
			}
			base.gameObject.SetActive(value: true);
			ShowNextNotification();
		}
	}

	public void ShowNextNotification()
	{
		closeButton.SetActive(value: false);
		confirmButtons.SetActive(value: false);
		choiceButtons.SetActive(value: false);
		if (notificationQueue.Count > 0)
		{
			message.text = LocalizationManager.GetTranslation(notificationQueue[0].message) + notificationQueue[0].secondMessage;
			if (notificationQueue[0].choice1Action != null)
			{
				choice1Action = notificationQueue[0].choice1Action;
				choice2Action = notificationQueue[0].choice2Action;
				choice1Message.text = LocalizationManager.GetTranslation(notificationQueue[0].choice1Message);
				choice2Message.text = LocalizationManager.GetTranslation(notificationQueue[0].choice2Message);
				choiceButtons.SetActive(value: true);
			}
			else if (notificationQueue[0].confirmAction == null)
			{
				messageTimer = notificationQueue[0].time;
				if (notificationQueue[0].showCloseButton)
				{
					closeButton.SetActive(value: true);
				}
			}
			else
			{
				confirmAction = notificationQueue[0].confirmAction;
				cancelAction = notificationQueue[0].cancelAction;
				confirmButtons.SetActive(value: true);
			}
			notificationQueue.RemoveAt(0);
		}
		else
		{
			ResetAndHideNotification();
		}
	}

	public void ResetAndHideNotification()
	{
		messageTimer = 0f;
		message.text = "";
		confirmAction = null;
		cancelAction = null;
		choice1Action = null;
		choice2Action = null;
		confirmButtons.SetActive(value: false);
		closeButton.SetActive(value: false);
		choiceButtons.SetActive(value: false);
		base.gameObject.SetActive(value: false);
		if (GameManager.instance.pauseMenu.clubAngleMenu.activeSelf)
		{
			Player.instance.clubs.SetActive(value: true);
		}
	}

	public void Confirm()
	{
		if (confirmAction != null)
		{
			confirmAction();
		}
		CloseSign();
	}

	public void Unconfirm()
	{
		if (cancelAction != null)
		{
			cancelAction();
		}
		CloseSign();
	}

	public void Choice1()
	{
		if (choice1Action != null)
		{
			choice1Action();
		}
	}

	public void Choice2()
	{
		if (choice2Action != null)
		{
			choice2Action();
		}
	}

	public void CancelLogin()
	{
		MonoBehaviour.print("CancelLogin");
		PlayerPrefs.SetInt("LoginOptOut", 1);
	}

	public void CancelPermissions()
	{
		MonoBehaviour.print("CancelPermissions");
		PlayerPrefs.SetInt("HidePermissions", 1);
	}

	public void CloseSign()
	{
		if (PhotonManager.instance != null && PhotonManager.instance.onKicked)
		{
			PhotonManager.instance.onKicked = false;
		}
		ShowNextNotification();
	}
}
public struct NotificationData
{
	public string message;

	public string secondMessage;

	public float time;

	public bool showCloseButton;

	public Action confirmAction;

	public Action cancelAction;

	public Action choice1Action;

	public Action choice2Action;

	public string choice1Message;

	public string choice2Message;

	public NotificationData(string m, string m2, float t = 0f, bool closeButton = false, Action a1 = null, Action a2 = null, Action choice1 = null, Action choice2 = null, string c1m = null, string c2m = null)
	{
		message = m;
		secondMessage = m2;
		time = t;
		showCloseButton = closeButton;
		confirmAction = a1;
		cancelAction = a2;
		choice1Action = choice1;
		choice2Action = choice2;
		choice1Message = c1m;
		choice2Message = c2m;
	}
}
public class BasePhotonObject : MonoBehaviourPun, IPunObservable
{
	protected Renderer[] objectRenderers;

	protected Text[] unityText;

	private static Dictionary<Type, BasePhotonObject> currentObjects = new Dictionary<Type, BasePhotonObject>();

	private bool meshOn = true;

	protected bool isMyPhotonView => base.photonView.IsMine;

	protected bool isInSameScene
	{
		get
		{
			Photon.Realtime.Player player = ((base.photonView.Owner == null) ? PhotonNetwork.MasterClient : base.photonView.Owner);
			if (!(GameManager.instance.currentSceneName == "LobbyScene"))
			{
				return player.GetScene() == PhotonNetwork.LocalPlayer.GetScene();
			}
			return false;
		}
	}

	protected virtual void Awake()
	{
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		objectRenderers = GetComponentsInChildren<Renderer>();
		unityText = GetComponentsInChildren<Text>();
		if (isMyPhotonView)
		{
			BasePhotonObject value = null;
			currentObjects.TryGetValue(GetType(), out value);
			if (value != null && value != this)
			{
				PhotonNetwork.Destroy(value.gameObject);
			}
			currentObjects[GetType()] = this;
			Renderer[] array = objectRenderers;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].gameObject.SetActive(value: false);
			}
			Text[] array2 = unityText;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i].gameObject.SetActive(value: false);
			}
		}
	}

	protected virtual void Update()
	{
		if (!isMyPhotonView)
		{
			ToggleMesh();
		}
	}

	public virtual void ToggleMesh()
	{
		Renderer[] array = objectRenderers;
		foreach (Renderer renderer in array)
		{
			if (renderer != null)
			{
				if (meshOn && base.photonView.Owner != null && Enumerable.Contains(PhotonNetwork.CurrentRoom.GetKickedPlayers(), base.photonView.Owner.ActorNumber))
				{
					meshOn = false;
					renderer.gameObject.SetActive(value: false);
				}
			}
			else
			{
				meshOn = isInSameScene;
				renderer.gameObject.SetActive(isInSameScene);
			}
		}
		Text[] array2 = unityText;
		foreach (Text text in array2)
		{
			if (text != null)
			{
				if (meshOn && base.photonView.Owner != null && Enumerable.Contains(PhotonNetwork.CurrentRoom.GetKickedPlayers(), base.photonView.Owner.ActorNumber))
				{
					text.gameObject.SetActive(value: false);
				}
				else
				{
					text.gameObject.SetActive(isInSameScene);
				}
			}
		}
	}

	protected string ColorToString(Color c)
	{
		Color.RGBToHSV(c, out var H, out var S, out var V);
		return H + "," + S + "," + V;
	}

	protected Color StringToColor(string s)
	{
		string[] array = s.Split(',');
		return Color.HSVToRGB(float.Parse(array[0]), float.Parse(array[1]), float.Parse(array[2]));
	}

	public virtual void OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info)
	{
	}

	public virtual void OnPlayerConnected(Photon.Realtime.Player otherPlayer)
	{
	}
}
public class ClubMicIndicator : MonoBehaviour
{
	public Image micIcon;

	public Image voiceIcon;

	public Sprite micOn;

	public Sprite micOff;

	public Color onColor;

	public Color offColor;

	public Vector3 clubsPos = new Vector3(0f, 0.016f, 0.35f);

	public Vector3 pointerLinePos = new Vector3(0f, 0.016f, 0.07f);

	private void Update()
	{
		if (PhotonNetwork.InRoom)
		{
			micIcon.enabled = true;
			if (Player.instance.clubSwitcher.gameObject.activeSelf)
			{
				base.transform.localPosition = clubsPos;
			}
			else if (Player.instance.currentController.pointer.pointerLine.enabled)
			{
				base.transform.localPosition = pointerLinePos;
			}
			if (GameManager.instance.GetMicState())
			{
				micIcon.sprite = micOn;
				micIcon.color = onColor;
				if (RoomRPC.instance != null && RoomRPC.instance.rec != null)
				{
					voiceIcon.enabled = RoomRPC.instance.rec.IsCurrentlyTransmitting;
				}
			}
			else
			{
				micIcon.sprite = micOff;
				micIcon.color = offColor;
				voiceIcon.enabled = false;
			}
		}
		else
		{
			micIcon.enabled = false;
			voiceIcon.enabled = false;
		}
	}
}
public static class JsonHelper
{
	[Serializable]
	private class Wrapper<T>
	{
		public T[] Items;
	}

	public static T[] FromJson<T>(string json)
	{
		return JsonUtility.FromJson<Wrapper<T>>(json).Items;
	}

	public static string ToJson<T>(T[] array)
	{
		return JsonUtility.ToJson(new Wrapper<T>
		{
			Items = array
		});
	}
}
public class MicBoard : MonoBehaviour
{
	public Text micState;

	public Image micSymbol;

	public Sprite micOn;

	public Sprite micOff;

	public Color onColor;

	public Color offColor;

	public static event Action onMicTextChange;

	private void OnEnable()
	{
		PauseMenu.onMicTextChange += ChangeText;
		LocalizationManager.OnLocalizeEvent += OnLocalizationCall;
	}

	private void OnDisable()
	{
		PauseMenu.onMicTextChange -= ChangeText;
		LocalizationManager.OnLocalizeEvent -= OnLocalizationCall;
	}

	private void Start()
	{
		ChangeText();
	}

	private void Update()
	{
		if (PhotonNetwork.IsConnected || GameManager.instance.currentSceneName == "LobbyScene")
		{
			base.gameObject.SetActive(value: true);
		}
		else
		{
			base.gameObject.SetActive(value: false);
		}
	}

	public void OnMicState()
	{
		if (GameManager.instance.GetMicState())
		{
			GameManager.instance.SetMicState(x: false);
		}
		else
		{
			GameManager.instance.SetMicState(x: true);
		}
		ChangeText();
		if (MicBoard.onMicTextChange != null)
		{
			MicBoard.onMicTextChange();
		}
	}

	public void ChangeText()
	{
		if (GameManager.instance.GetMicState())
		{
			micState.text = LocalizationManager.GetTranslation("Mic On");
			micSymbol.sprite = micOn;
			micSymbol.color = onColor;
		}
		else
		{
			micState.text = LocalizationManager.GetTranslation("Mic Off");
			micSymbol.sprite = micOff;
			micSymbol.color = offColor;
		}
	}

	private void OnLocalizationCall()
	{
		if (GameManager.instance.GetMicState())
		{
			micState.text = LocalizationManager.GetTranslation("Mic On");
		}
		else
		{
			micState.text = LocalizationManager.GetTranslation("Mic Off");
		}
	}
}
public class PhotonAvatarView : BasePhotonObject
{
	private PhotonView pView;

	public OvrAvatar ovrAvatar;

	public GameObject ovrAvatarPrefab;

	private OvrAvatarLocalDriver localDriver;

	private OvrAvatarRemoteDriver remoteDriver;

	private List<byte[]> packetData = new List<byte[]>();

	private int localSequence;

	private Vector3 correctPos;

	private Quaternion correctRot = Quaternion.identity;

	private float smoothing = 5f;

	[Header("===Photon Info===")]
	public Text nameText;

	private int strokeCount;

	private int inOutTotal;

	private string plusMinus = "";

	private Color ballColor;

	public SphereCollider headDisableSphere;

	private Transform avatarHead;

	private bool hideHead;

	public bool muted;

	public bool micTurnedOn;

	public Transform micIcon;

	private AudioSource aSource;

	private float standbyTimer = 120f;

	private float standbyTimerMax = 120f;

	public Text status;

	public Transform canvas;

	private string nickname = "";

	public float updateInterval = 0.5f;

	private float updateTimer;

	public bool pViewIsMine;

	private bool avatarFinishedLoading = true;

	private float retryAvatarInterval = 10f;

	private float retryAvatarTimer;

	public Image minimapPlayerMarker;

	public float serializationStartTimer = 3f;

	private float enableAvatarAfterSceneChangeInterval = 3f;

	public float enableAvatarAfterSceneChangeTimer = 3f;

	[Header("===XR SPACE AVATARS===")]
	private bool HMDEnable;

	private bool RightHandEnable;

	private bool LeftHandEnable;

	public Vector3 xrAvatarHeadPosition;

	private Quaternion xrAvatarHeadRotation;

	public Vector3 xrAvatarLeftHandPosition;

	private Quaternion xrAvatarLeftHandRotation;

	public Vector3 xrAvatarRightHandPosition;

	private Quaternion xrAvatarRightHandRotation;

	private Animator animator;

	private Vector3 headPos;

	private Quaternion headRot;

	public bool isXRPlayer;

	public RuntimeAnimatorController xrIK;

	[Header("===GENERIC AVATAR===")]
	public GameObject defaultHeadset;

	public void Start()
	{
		pView = GetComponent<PhotonView>();
		pViewIsMine = base.photonView.IsMine;
		aSource = GetComponent<AudioSource>();
		nickname = base.photonView.Owner.NickName;
		StartCoroutine(SetAvatar());
		if (pViewIsMine)
		{
			minimapPlayerMarker.enabled = false;
		}
		base.transform.eulerAngles = new Vector3(0f, 1f, 0f);
	}

	protected override void Update()
	{
		if (pViewIsMine)
		{
			base.transform.position = Player.instance.transform.position;
			base.transform.rotation = Player.instance.transform.rotation;
			xrAvatarHeadPosition = Player.instance.head.position;
			xrAvatarHeadRotation = Player.instance.head.rotation;
			xrAvatarLeftHandPosition = Player.instance.leftController.transform.position;
			xrAvatarLeftHandRotation = Player.instance.leftController.transform.rotation;
			xrAvatarRightHandPosition = Player.instance.rightController.transform.position;
			xrAvatarRightHandRotation = Player.instance.rightController.transform.rotation;
		}
		else if (isXRPlayer)
		{
			Vector3 b = correctPos + headPos;
			b.y = correctPos.y;
			base.transform.position = Vector3.Lerp(base.transform.position, b, Time.deltaTime * smoothing);
			Quaternion b2 = headRot;
			b2.x = (b2.z = 0f);
			base.transform.rotation = Quaternion.Lerp(base.transform.rotation, b2, Time.deltaTime * smoothing);
			defaultHeadset.transform.position = Vector3.Lerp(defaultHeadset.transform.position, headPos, Time.deltaTime * smoothing);
			defaultHeadset.transform.rotation = Quaternion.Lerp(defaultHeadset.transform.rotation, headRot, Time.deltaTime * smoothing);
		}
		else
		{
			base.transform.position = Vector3.Lerp(base.transform.position, correctPos, Time.deltaTime * smoothing);
			if (correctRot != Quaternion.identity)
			{
				base.transform.rotation = Quaternion.Lerp(base.transform.rotation, correctRot, Time.deltaTime * smoothing);
			}
			defaultHeadset.transform.localPosition = Vector3.Lerp(defaultHeadset.transform.localPosition, headPos, Time.deltaTime * smoothing);
			defaultHeadset.transform.rotation = Quaternion.Lerp(defaultHeadset.transform.rotation, headRot, Time.deltaTime * smoothing);
		}
		if (muted)
		{
			aSource.enabled = false;
		}
		else
		{
			aSource.enabled = true;
			aSource.spatialBlend = 0f;
		}
		if (!base.isInSameScene)
		{
			enableAvatarAfterSceneChangeTimer = enableAvatarAfterSceneChangeInterval;
		}
		else if (enableAvatarAfterSceneChangeTimer > 0f)
		{
			enableAvatarAfterSceneChangeTimer -= Time.deltaTime;
		}
		if (updateTimer < updateInterval)
		{
			updateTimer += Time.deltaTime;
		}
		else
		{
			updateTimer = 0f;
			if (!pViewIsMine)
			{
				base.Update();
				if (PhotonNetwork.LocalPlayer.GetLoadingLevel())
				{
					nameText.text = nickname;
					status.text = LocalizationManager.GetTranslation("Loading Next Hole");
					enableAvatarAfterSceneChangeTimer = enableAvatarAfterSceneChangeInterval;
				}
				else if (PhotonNetwork.CurrentRoom.GetHoleIndex() != -1 && base.photonView.Owner.GetHoleFinished() && GameManager.instance.currentSceneName.Contains("Hole"))
				{
					inOutTotal = ScoreManager.instance.pars[GameManager.instance.holeIndex];
					if (strokeCount > inOutTotal)
					{
						plusMinus = "+";
						inOutTotal = strokeCount - inOutTotal;
					}
					else if (strokeCount < inOutTotal)
					{
						plusMinus = "-";
						inOutTotal -= strokeCount;
					}
					else
					{
						inOutTotal = 0;
					}
					nameText.text = ((strokeCount <= 0) ? "" : strokeCount.ToString()) + " (" + plusMinus + inOutTotal + ") \n" + nickname;
				}
				else if (PhotonNetwork.CurrentRoom.GetHoleIndex() != -1 && GameManager.instance.currentSceneName.Contains("Hole"))
				{
					nameText.text = ((strokeCount <= 0) ? "" : strokeCount.ToString()) + "\n" + nickname;
				}
				else
				{
					nameText.text = nickname;
				}
				if (base.photonView.Owner.GetStandby())
				{
					standbyTimer = 123 - ((int)PhotonNetwork.Time - (int)base.photonView.Owner.GetStandbyTime());
					if (standbyTimer > 0f)
					{
						standbyTimer -= Time.deltaTime;
						status.text = LocalizationManager.GetTranslation("Standby") + ": " + (int)standbyTimer;
					}
					else
					{
						status.text = LocalizationManager.GetTranslation("Standby") + ": 0";
					}
				}
				else if (!base.photonView.Owner.GetRatingHole() && base.photonView.Owner.GetHoleFinished())
				{
					status.text = LocalizationManager.GetTranslation("Rating Hole");
				}
				else if (base.photonView.Owner.GetRatingHole() && base.photonView.Owner.GetHoleFinished())
				{
					status.text = LocalizationManager.GetTranslation("Waiting For Players To Finish");
				}
				else
				{
					standbyTimer = standbyTimerMax;
					status.text = "";
				}
			}
			else
			{
				status.text = "";
			}
		}
		Vector3 worldPosition = ((GameManager.instance.controllerType != ControllerType.XR) ? Camera.main.transform.position : Player.instance.head.position);
		worldPosition.y = nameText.transform.position.y;
		nameText.transform.LookAt(worldPosition);
		if (!(avatarHead != null))
		{
			if (pViewIsMine)
			{
				headDisableSphere.enabled = true;
			}
			else
			{
				headDisableSphere.enabled = false;
			}
		}
		if (!pViewIsMine)
		{
			minimapPlayerMarker.transform.position = new Vector3(base.transform.position.x, base.transform.position.y + 300f, base.transform.position.z);
			minimapPlayerMarker.transform.parent.eulerAngles = new Vector3(90f, base.transform.eulerAngles.y, 0f);
		}
		if (serializationStartTimer > 0f)
		{
			serializationStartTimer -= Time.deltaTime;
		}
	}

	private void SetAvatarDriver()
	{
		if (pViewIsMine)
		{
			ovrAvatar.gameObject.AddComponent<OvrAvatarLocalDriver>();
			localDriver = ovrAvatar.GetComponent<OvrAvatarLocalDriver>();
			ovrAvatar.Driver = localDriver;
			packetData = new List<byte[]>();
		}
		else
		{
			ovrAvatar.gameObject.AddComponent<OvrAvatarRemoteDriver>();
			remoteDriver = ovrAvatar.GetComponent<OvrAvatarRemoteDriver>();
			ovrAvatar.Driver = remoteDriver;
		}
	}

	private void RespawnAvatar()
	{
		canvas.parent = base.transform;
		micIcon.parent = base.transform;
		UnityEngine.Object.Destroy(ovrAvatar.gameObject);
		ovrAvatar = UnityEngine.Object.Instantiate(ovrAvatarPrefab, base.transform).GetComponent<OvrAvatar>();
		ovrAvatar.transform.localPosition = Vector3.zero;
		ovrAvatar.transform.localEulerAngles = Vector3.zero;
		SetAvatarDriver();
		StartCoroutine(SetAvatar());
	}

	public void OnDisable()
	{
		if (pView.IsMine)
		{
			ovrAvatar.RecordPackets = false;
		}
	}

	private IEnumerator SetAvatar()
	{
		if (!pViewIsMine)
		{
			defaultHeadset.SetActive(value: true);
			yield return null;
		}
	}

	public void OnLocalAvatarPacketRecorded(object sender, OvrAvatar.PacketEventArgs args)
	{
		using MemoryStream memoryStream = new MemoryStream();
		BinaryWriter binaryWriter = new BinaryWriter(memoryStream);
		uint num = Oculus.Avatar.CAPI.ovrAvatarPacket_GetSize(args.Packet.ovrNativePacket);
		byte[] buffer = new byte[num];
		Oculus.Avatar.CAPI.ovrAvatarPacket_Write(args.Packet.ovrNativePacket, num, buffer);
		binaryWriter.Write(localSequence++);
		binaryWriter.Write(num);
		binaryWriter.Write(buffer);
		packetData.Add(memoryStream.ToArray());
	}

	private void DeserializeAndQueuePacketData(byte[] data)
	{
		using MemoryStream input = new MemoryStream(data);
		BinaryReader binaryReader = new BinaryReader(input);
		int sequence = binaryReader.ReadInt32();
		int count = binaryReader.ReadInt32();
		byte[] buffer = binaryReader.ReadBytes(count);
		IntPtr ovrNativePacket = Oculus.Avatar.CAPI.ovrAvatarPacket_Read((uint)data.Length, buffer);
		remoteDriver.QueuePacket(sequence, new OvrAvatarPacket
		{
			ovrNativePacket = ovrNativePacket
		});
	}

	public override void OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info)
	{
		if (stream.IsWriting)
		{
			stream.SendNext(Player.instance.transform.position);
			stream.SendNext(Player.instance.transform.rotation);
			stream.SendNext(Player.instance.head.transform.localPosition);
			stream.SendNext(Player.instance.head.transform.rotation);
			stream.SendNext(ScoreManager.instance.currentStrokeCount);
			stream.SendNext(GameManager.instance.GetMicState());
			stream.SendNext(ColorToString(GameManager.instance.GetBallColor()));
			stream.SendNext(packetData.Count);
			foreach (byte[] packetDatum in packetData)
			{
				stream.SendNext(packetDatum);
			}
			packetData.Clear();
			return;
		}
		correctPos = (Vector3)stream.ReceiveNext();
		correctRot = (Quaternion)stream.ReceiveNext();
		headPos = (Vector3)stream.ReceiveNext();
		headRot = (Quaternion)stream.ReceiveNext();
		strokeCount = (int)stream.ReceiveNext();
		micTurnedOn = (bool)stream.ReceiveNext();
		Color color = StringToColor((string)stream.ReceiveNext());
		if (color != minimapPlayerMarker.color)
		{
			minimapPlayerMarker.color = color;
			Renderer[] componentsInChildren = defaultHeadset.GetComponentsInChildren<Renderer>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				componentsInChildren[i].material.color = color;
			}
		}
		int num = (int)stream.ReceiveNext();
		for (int j = 0; j < num; j++)
		{
			_ = (byte[])stream.ReceiveNext();
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.GetComponentInParent<Player>() != null && enableAvatarAfterSceneChangeTimer <= 0f)
		{
			hideHead = true;
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (other.GetComponentInParent<Player>() != null)
		{
			hideHead = false;
		}
	}

	public override void OnPlayerConnected(Photon.Realtime.Player otherPlayer)
	{
	}

	private void PlayAnimation(string anim)
	{
		if (animator != null)
		{
			_ = animator.runtimeAnimatorController != null;
		}
	}

	private void PlayIdleAnimation()
	{
		PlayAnimation("Mob_Idle");
	}

	private void PlayWalkAnimation()
	{
		if (animator != null)
		{
			Vector3 b;
			if (base.isMyPhotonView)
			{
				b = Player.instance.transform.position;
			}
			else
			{
				Vector3 vector = correctPos + headPos;
				vector.y = correctPos.y;
				b = vector;
			}
			if (Vector3.Distance(base.transform.position, b) > 3f)
			{
				animator.speed = 2f;
			}
			else
			{
				animator.speed = 1f;
			}
			if (Vector3.Distance(base.transform.position, b) > 0.05f)
			{
				PlayAnimation("Blend Tree");
			}
			else
			{
				PlayIdleAnimation();
			}
		}
	}
}
public class PhotonBall : BasePhotonObject
{
	public float alpha = 0.6f;

	public float smoothing = 5f;

	public TrailRenderer trailPrefab;

	private List<TrailRenderer> currentTrails = new List<TrailRenderer>();

	private Queue<Vector3> positions = new Queue<Vector3>();

	private Vector3 correctPos;

	private Vector3 lastPos;

	private Color c;

	private Golfball ball;

	private bool warpBall;

	public bool ballWentOB;

	private bool hasBeenHit;

	private bool localPlayerHit;

	private void OnEnable()
	{
		ball = UnityEngine.Object.FindObjectOfType<Golfball>();
		objectRenderers[0].gameObject.SetActive(value: false);
		Golfball.onHit += Golfball_onHit;
	}

	private void OnDisable()
	{
		Golfball.onHit -= Golfball_onHit;
	}

	protected override void Update()
	{
		if (GameManager.instance.currentSceneName == "ScoreScene" || GameManager.instance.currentSceneName == "RoomPrepScene")
		{
			objectRenderers[0].gameObject.SetActive(value: false);
			{
				foreach (TrailRenderer currentTrail in currentTrails)
				{
					currentTrail.gameObject.SetActive(value: false);
				}
				return;
			}
		}
		if (!base.photonView.IsMine)
		{
			if (!hasBeenHit && !localPlayerHit)
			{
				objectRenderers[0].gameObject.SetActive(value: false);
			}
			else if (GameManager.instance.holeIndex == -1)
			{
				objectRenderers[0].gameObject.SetActive(value: false);
			}
			else
			{
				base.Update();
			}
		}
	}

	private void FixedUpdate()
	{
		if (base.photonView.IsMine)
		{
			if (ball != null && ball.transform.position != lastPos)
			{
				lastPos = ball.transform.position;
				positions.Enqueue(lastPos);
			}
		}
		else if (positions.Count > 0)
		{
			base.transform.position = positions.Dequeue();
		}
	}

	public override void OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info)
	{
		if (stream.IsWriting)
		{
			if (ball == null)
			{
				if (GameManager.instance.golfball != null)
				{
					ball = GameManager.instance.golfball;
				}
				warpBall = true;
			}
			if (ball == null || ballWentOB)
			{
				if (ballWentOB)
				{
					ballWentOB = false;
				}
				return;
			}
			stream.SendNext(ball.transform.position);
			stream.SendNext(warpBall);
			stream.SendNext(hasBeenHit);
			stream.SendNext(positions.ToArray());
			stream.SendNext(ColorToString(GameManager.instance.GetBallColor()));
			positions.Clear();
			warpBall = false;
			return;
		}
		correctPos = (Vector3)stream.ReceiveNext();
		bool flag = (bool)stream.ReceiveNext();
		hasBeenHit = (bool)stream.ReceiveNext();
		Vector3[] obj = (Vector3[])stream.ReceiveNext();
		c = StringToColor((string)stream.ReceiveNext());
		Vector3[] array = obj;
		foreach (Vector3 item in array)
		{
			positions.Enqueue(item);
		}
		if (!hasBeenHit)
		{
			ResetBall(deleteOldTrail: true);
		}
		if (flag)
		{
			ResetBall(deleteOldTrail: false);
		}
		c.a = alpha;
		objectRenderers[0].material.color = c;
		foreach (TrailRenderer currentTrail in currentTrails)
		{
			if (currentTrail != null)
			{
				currentTrail.GetComponent<Renderer>().material.color = c;
				currentTrail.GetComponent<Renderer>().material.SetColor("_EmissionColor", c);
			}
		}
	}

	private void ResetBall(bool deleteOldTrail)
	{
		ResetTrail(base.gameObject.GetComponent<PhotonView>().Owner, deleteOldTrail);
		base.transform.position = correctPos;
		positions.Clear();
	}

	private void Golfball_onHit()
	{
		if (base.photonView.IsMine)
		{
			base.photonView.RPC("ResetTrail", RpcTarget.Others, base.gameObject.GetComponent<PhotonView>().Owner, true, true);
		}
		hasBeenHit = true;
		localPlayerHit = true;
	}

	public void NewSceneLoaded()
	{
		base.photonView.RPC("ResetTrail", RpcTarget.Others, base.gameObject.GetComponent<PhotonView>().Owner, true, true);
		hasBeenHit = false;
		localPlayerHit = false;
		foreach (TrailRenderer currentTrail in currentTrails)
		{
			UnityEngine.Object.Destroy(currentTrail.gameObject);
		}
		currentTrails.Clear();
	}

	private void Golfball_onCreated()
	{
		hasBeenHit = false;
		localPlayerHit = false;
		foreach (TrailRenderer currentTrail in currentTrails)
		{
			UnityEngine.Object.Destroy(currentTrail.gameObject);
		}
		currentTrails.Clear();
	}

	[PunRPC]
	public void ResetTrail(Photon.Realtime.Player playerBall, bool deleteOldTrail = true, bool makeNewTrail = true)
	{
		objectRenderers[0].gameObject.SetActive(value: true);
		if (deleteOldTrail)
		{
			foreach (TrailRenderer currentTrail in currentTrails)
			{
				if (currentTrail != null)
				{
					UnityEngine.Object.DestroyImmediate(currentTrail.gameObject);
				}
			}
			currentTrails.Clear();
		}
		else if (playerBall != null)
		{
			PhotonTrailContainer[] array = UnityEngine.Object.FindObjectsOfType<PhotonTrailContainer>();
			foreach (PhotonTrailContainer photonTrailContainer in array)
			{
				if (photonTrailContainer.GetComponent<PhotonView>().Owner != playerBall)
				{
					continue;
				}
				foreach (TrailRenderer currentTrail2 in currentTrails)
				{
					if (currentTrail2 != null)
					{
						currentTrail2.transform.SetParent(photonTrailContainer.transform);
					}
				}
				break;
			}
		}
		if (base.isInSameScene && makeNewTrail)
		{
			TrailRenderer trailRenderer = UnityEngine.Object.Instantiate(trailPrefab, base.transform);
			trailRenderer.tag = "Untagged";
			currentTrails.Add(trailRenderer);
			trailRenderer.transform.localPosition = Vector3.zero;
		}
	}

	public void BallWentOB()
	{
		ballWentOB = true;
		warpBall = true;
	}

	private void OBManager_onBallWarp()
	{
		warpBall = true;
	}
}
public class PhotonClub : BasePhotonObject
{
	public float smoothing = 5f;

	private Vector3 correctPos;

	private Quaternion correctRot = Quaternion.Euler(0f, 0f, 0f);

	public GameObject clubParent;

	public GameObject driverParent;

	public GameObject ironParent;

	public GameObject putterParent;

	public GameObject[] drivers;

	public GameObject[] irons;

	public GameObject[] putters;

	private ClubSwitcher clubSwitcher;

	private GameObject currentClub;

	private int clubType = -1;

	private int driverType;

	private int ironType;

	private int putterType;

	private float defaultClubLength;

	private bool pViewIsMine;

	private bool rightHanded = true;

	private new void Awake()
	{
		base.Awake();
		if (base.photonView.IsMine)
		{
			clubSwitcher = Player.instance.clubSwitcher;
		}
	}

	private void Start()
	{
		pViewIsMine = base.photonView.IsMine;
		driverParent.SetActive(value: false);
		ironParent.SetActive(value: false);
		putterParent.SetActive(value: false);
		GameObject[] array = drivers;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: false);
		}
		array = irons;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: false);
		}
		array = putters;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: false);
		}
	}

	protected override void Update()
	{
		if (!pViewIsMine)
		{
			base.transform.position = Vector3.Lerp(base.transform.position, correctPos, Time.deltaTime * smoothing);
			base.transform.rotation = Quaternion.Lerp(base.transform.rotation, correctRot, Time.deltaTime * smoothing);
			ToggleMesh();
			SetHandidness();
		}
	}

	private void SetHandidness()
	{
		if (rightHanded)
		{
			base.transform.localScale = new Vector3(1f, 1f, 1f);
		}
		else
		{
			base.transform.localScale = new Vector3(-1f, 1f, 1f);
		}
	}

	public override void ToggleMesh()
	{
		if (base.photonView.Owner != null && Enumerable.Contains(PhotonNetwork.CurrentRoom.GetKickedPlayers(), base.photonView.Owner.ActorNumber))
		{
			clubParent.gameObject.SetActive(value: false);
		}
		else
		{
			clubParent.gameObject.SetActive(base.isInSameScene);
		}
	}

	private void SwitchToClubType(int type)
	{
		if (currentClub != null)
		{
			currentClub.gameObject.SetActive(value: false);
		}
		switch (type)
		{
		case 0:
		{
			driverParent.SetActive(value: true);
			currentClub = drivers[driverType];
			GameObject[] array = drivers;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].gameObject.SetActive(value: false);
			}
			drivers[driverType].gameObject.SetActive(value: true);
			break;
		}
		case 1:
		{
			ironParent.SetActive(value: true);
			currentClub = irons[ironType];
			GameObject[] array = irons;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].gameObject.SetActive(value: false);
			}
			irons[ironType].gameObject.SetActive(value: true);
			break;
		}
		case 2:
		{
			putterParent.SetActive(value: true);
			currentClub = putters[putterType];
			GameObject[] array = putters;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].gameObject.SetActive(value: false);
			}
			putters[putterType].gameObject.SetActive(value: true);
			break;
		}
		}
	}

	public override void OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info)
	{
		if (stream.IsWriting)
		{
			stream.SendNext(clubSwitcher.transform.position);
			stream.SendNext(clubSwitcher.transform.rotation);
			stream.SendNext((int)clubSwitcher.driverType);
			stream.SendNext((int)clubSwitcher.ironType);
			stream.SendNext((int)clubSwitcher.putterType);
			stream.SendNext((int)clubSwitcher.currentType);
			stream.SendNext(Player.instance.clubSwitcher.currentClub.clubScaler.defaultLengthInMeters);
			stream.SendNext(Player.instance.rightHanded);
			return;
		}
		correctPos = (Vector3)stream.ReceiveNext();
		correctRot = (Quaternion)stream.ReceiveNext();
		driverType = (int)stream.ReceiveNext();
		ironType = (int)stream.ReceiveNext();
		putterType = (int)stream.ReceiveNext();
		int num = (int)stream.ReceiveNext();
		clubType = num;
		SwitchToClubType(clubType);
		float num2 = defaultClubLength;
		defaultClubLength = (float)stream.ReceiveNext();
		if (num2 != defaultClubLength)
		{
			currentClub.GetComponent<ClubScaler>().SetClubLength((ClubType)clubType, defaultClubLength);
		}
		rightHanded = (bool)stream.ReceiveNext();
	}
}
public class PhotonHeadset : BasePhotonObject
{
	public Text nameText;

	public float smoothing = 5f;

	private Vector3 correctPos;

	private Quaternion correctRot = Quaternion.Euler(0f, 0f, 0f);

	private Player player;

	private int strokeCount;

	private int inOutTotal;

	private string plusMinus = "";

	private Color ballColor;

	public GameObject headsetContainer;

	private Renderer[] headsetRenderers;

	public bool muted;

	public bool micTurnedOn;

	private AudioSource aSource;

	private float standbyTimer = 60f;

	private float standbyTimerMax = 60f;

	public Text status;

	public OvrAvatar avatar;

	private bool spawnedAvatar;

	public Transform canvas;

	private string nickname = "";

	protected override void Awake()
	{
		base.Awake();
	}

	private void Start()
	{
		player = GameManager.instance.player.GetComponent<Player>();
		headsetRenderers = headsetContainer.GetComponentsInChildren<Renderer>();
		aSource = GetComponent<AudioSource>();
		if (!base.isMyPhotonView)
		{
			StartCoroutine(SpawnOculusAvatar(base.photonView.Owner.GetPlayerID().avatarID));
		}
		nickname = base.photonView.Owner.NickName;
	}

	protected override void Update()
	{
		base.Update();
		if (muted)
		{
			aSource.enabled = false;
		}
		else
		{
			aSource.enabled = true;
			aSource.spatialBlend = 0f;
		}
		if (!base.isMyPhotonView)
		{
			if (PhotonNetwork.LocalPlayer.GetLoadingLevel())
			{
				nameText.text = nickname;
				status.text = "Loading Next Hole";
			}
			else if (PhotonNetwork.CurrentRoom.GetHoleIndex() != -1 && base.photonView.Owner.GetHoleFinished() && GameManager.instance.currentSceneName.Contains("Hole"))
			{
				inOutTotal = ScoreManager.instance.pars[GameManager.instance.holeIndex];
				if (strokeCount > inOutTotal)
				{
					plusMinus = "+";
					inOutTotal = strokeCount - inOutTotal;
				}
				else if (strokeCount < inOutTotal)
				{
					plusMinus = "-";
					inOutTotal -= strokeCount;
				}
				else
				{
					inOutTotal = 0;
				}
				nameText.text = ((strokeCount <= 0) ? "" : strokeCount.ToString()) + " (" + plusMinus + inOutTotal + ") \n" + nickname;
			}
			else if (PhotonNetwork.CurrentRoom.GetHoleIndex() != -1 && GameManager.instance.currentSceneName.Contains("Hole"))
			{
				nameText.text = ((strokeCount <= 0) ? "" : strokeCount.ToString()) + "\n" + nickname;
			}
			else
			{
				nameText.text = nickname;
			}
			if (base.photonView.Owner.GetStandby())
			{
				if (standbyTimer > 0f)
				{
					standbyTimer -= Time.deltaTime;
					status.text = "Standby: " + (int)standbyTimer;
				}
				else
				{
					status.text = "Standby: 0";
				}
			}
			else if (!base.photonView.Owner.GetRatingHole() && base.photonView.Owner.GetHoleFinished())
			{
				status.text = "Rating Hole";
			}
			else if (base.photonView.Owner.GetRatingHole() && base.photonView.Owner.GetHoleFinished())
			{
				status.text = "Waiting For Players To Finish";
			}
			else
			{
				standbyTimer = standbyTimerMax;
				status.text = "";
			}
		}
		else
		{
			status.text = "";
		}
		base.transform.position = Vector3.Lerp(base.transform.position, correctPos, Time.deltaTime * smoothing);
		base.transform.rotation = Quaternion.Lerp(base.transform.rotation, correctRot, Time.deltaTime * smoothing);
		Vector3 position = Camera.main.transform.position;
		position.y = nameText.transform.position.y;
		nameText.transform.LookAt(position);
	}

	public override void OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info)
	{
		if (stream.IsWriting)
		{
			stream.SendNext(player.head.position);
			stream.SendNext(player.head.rotation);
			stream.SendNext(ScoreManager.instance.currentStrokeCount);
			stream.SendNext(ColorToString(GameManager.instance.GetBallColor()));
			stream.SendNext(GameManager.instance.GetMicState());
			return;
		}
		correctPos = (Vector3)stream.ReceiveNext();
		correctRot = (Quaternion)stream.ReceiveNext();
		strokeCount = (int)stream.ReceiveNext();
		ballColor = StringToColor((string)stream.ReceiveNext());
		micTurnedOn = (bool)stream.ReceiveNext();
		if (headsetRenderers != null)
		{
			Renderer[] array = headsetRenderers;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].material.SetColor("_RimLight_Color", ballColor);
			}
		}
	}

	private void ToggleMesh(bool x)
	{
		if (spawnedAvatar)
		{
			avatar.gameObject.SetActive(x);
			return;
		}
		for (int i = 0; i < objectRenderers.Length; i++)
		{
			objectRenderers[i].enabled = x;
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.GetComponentInParent<Player>() != null)
		{
			ToggleMesh(x: false);
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (other.GetComponentInParent<Player>() != null)
		{
			ToggleMesh(x: true);
		}
	}

	public IEnumerator SpawnOculusAvatar(string id)
	{
		yield return new WaitForSeconds(3f);
		avatar.oculusUserID = id;
		avatar.ShowFirstPerson = false;
		avatar.ShowThirdPerson = true;
		yield return new WaitForSeconds(3f);
		avatar.gameObject.SetActive(value: true);
		avatar.Base.gameObject.SetActive(value: false);
		avatar.transform.localPosition = new Vector3(0f, -1.36f, 0f);
		float timer = 5f;
		bool gotAvatar = true;
		while (avatar.Body.transform.childCount == 0)
		{
			timer -= Time.deltaTime;
			if (timer <= 0f)
			{
				gotAvatar = false;
				break;
			}
			yield return null;
		}
		if (gotAvatar)
		{
			headsetContainer.SetActive(value: false);
			Transform parent = avatar.Body.transform.Find("body_renderPart_0/root_JNT/body_JNT");
			canvas.parent = parent;
			Vector3 newCanvasPos = Vector3.zero;
			newCanvasPos.y = 1.2f;
			avatar.enabled = false;
			yield return null;
			canvas.transform.localPosition = newCanvasPos;
			spawnedAvatar = true;
		}
	}
}
public class PhotonTrailContainer : BasePhotonObject
{
}
public static class RoomHelper
{
	private const int MAX_PLAYERS = 4;

	private const string IS_PRIVATE = "isPrivate";

	private const string LEVEL_INDEX = "levelIndex";

	private const string NEXT_HOLE_COUNTDOWN = "nextHoleCountdown";

	private const string SCENE_NAME = "sceneName";

	private const string HOLES = "holes";

	private const string PLAYLIST = "playlist";

	private const string KICKED_PLAYERS = "kickedPlayers";

	private const string ROOM_PLAYER_IDS = "roomPlayerIDs";

	private const string PASSWORD = "password";

	private const string SCORE = "score";

	private const string IS_HOLE_FINISHED = "isHoleFinished";

	private const string IS_DOWNLOAD_FINISHED = "isDownloadFinished";

	private const string DOWNLOAD_PROGRESS = "downloadProgress";

	private const string IS_RATING_HOLE = "isRatingHole";

	private const string READY = "ready";

	private const string LOADING_LEVEL = "loadingLevel";

	private const string KICKED = "kicked";

	private const string STANDBY = "standby";

	private const string INPUTING_PASSWORD = "inputtingPassword";

	private const string PLAYER_ID = "playerID";

	private const string XR_SPACE_AVATAR_FORMAT = "xrSpaceAvatarFormat";

	private static void RoomSet(Photon.Realtime.Room room, string key, object value)
	{
		ExitGames.Client.Photon.Hashtable hashtable = new ExitGames.Client.Photon.Hashtable();
		hashtable[key] = value;
		room.SetCustomProperties(hashtable);
	}

	private static void PlayerSet(Photon.Realtime.Player player, string key, object value)
	{
		ExitGames.Client.Photon.Hashtable hashtable = new ExitGames.Client.Photon.Hashtable();
		hashtable[key] = value;
		player.SetCustomProperties(hashtable);
	}

	public static void CreateRoom(string _password = null)
	{
		ExitGames.Client.Photon.Hashtable hashtable = new ExitGames.Client.Photon.Hashtable();
		hashtable["password"] = _password;
		hashtable["isPrivate"] = !string.IsNullOrEmpty(_password);
		hashtable["levelIndex"] = -1;
		Photon.Realtime.RoomOptions roomOptions = new Photon.Realtime.RoomOptions();
		roomOptions.CustomRoomProperties = hashtable;
		roomOptions.MaxPlayers = 4;
		roomOptions.CustomRoomPropertiesForLobby = new string[5] { "isPrivate", "roomPlayerIDs", "password", "holes", "levelIndex" };
		Photon.Realtime.RoomOptions roomOptions2 = roomOptions;
		RoomInfo[] array = new RoomInfo[0];
		if (GameManager.instance.currentSceneName == "LobbyScene")
		{
			array = LobbyManager.instance.roomListPanel.cachedRoomList.Values.ToArray();
		}
		else if (GameManager.instance.currentSceneName == "MainMenu")
		{
			array = MainMenu.instance.cachedRoomList.Values.ToArray();
		}
		string text = PhotonNetwork.LocalPlayer.NickName;
		UnityEngine.Debug.Log(text);
		int num = 0;
		for (int i = 0; i < array.Length; i++)
		{
			for (int j = 0; j < array.Length; j++)
			{
				if (array[j].Name == text)
				{
					num++;
					text = text + "(" + num + ")";
				}
			}
		}
		PhotonNetwork.CreateRoom(text, roomOptions2);
	}

	public static void JoinOrCreateRoomForParty(string roomID)
	{
		ExitGames.Client.Photon.Hashtable hashtable = new ExitGames.Client.Photon.Hashtable();
		hashtable["isPrivate"] = true;
		hashtable["levelIndex"] = -1;
		Photon.Realtime.RoomOptions roomOptions = new Photon.Realtime.RoomOptions();
		roomOptions.CustomRoomProperties = hashtable;
		roomOptions.MaxPlayers = 4;
		roomOptions.IsVisible = false;
		roomOptions.CustomRoomPropertiesForLobby = new string[5] { "isPrivate", "roomPlayerIDs", "password", "holes", "levelIndex" };
		Photon.Realtime.RoomOptions roomOptions2 = roomOptions;
		UnityEngine.Debug.Log(roomID);
		PhotonNetwork.JoinOrCreateRoom(roomID, roomOptions2, null);
	}

	public static bool IsPrivate(this RoomInfo room)
	{
		return (bool)room.CustomProperties["isPrivate"];
	}

	public static void LoadCurrentLevel()
	{
		if (PhotonNetwork.CurrentRoom.GetHoleIndex() == -1)
		{
			GameManager.instance.BackToRoomPrepScene();
		}
		else
		{
			GameManager.instance.LoadNextHole(incrementHole: false);
		}
	}

	public static void SetHoles(this Photon.Realtime.Room room, List<WorkshopData> holes)
	{
		RoomSet(room, "holes", JsonHelper.ToJson(holes.ToArray()));
		RoomRPC.instance.pView.RPC("UpdateSelectedHoles", RpcTarget.Others);
	}

	public static WorkshopData[] GetHoles(this Photon.Realtime.Room room)
	{
		if (room == null)
		{
			return new WorkshopData[0];
		}
		string text = (string)room.CustomProperties["holes"];
		if (string.IsNullOrEmpty(text))
		{
			return new WorkshopData[0];
		}
		return JsonHelper.FromJson<WorkshopData>(text);
	}

	public static void SetPlaylist(this Photon.Realtime.Room room, WorkshopData playlist)
	{
		RoomSet(room, "playlist", JsonUtility.ToJson(playlist));
		RoomRPC.instance.pView.RPC("UpdateSelectedPlaylist", RpcTarget.Others);
	}

	public static WorkshopData GetPlaylist(this Photon.Realtime.Room room)
	{
		if (room == null)
		{
			return new WorkshopData();
		}
		string text = (string)room.CustomProperties["playlist"];
		if (string.IsNullOrEmpty(text))
		{
			return new WorkshopData();
		}
		return JsonUtility.FromJson<WorkshopData>(text);
	}

	public static int GetHoleIndex(this Photon.Realtime.Room room)
	{
		if (room.CustomProperties.ContainsKey("levelIndex") && room.CustomProperties["levelIndex"] != null)
		{
			return (int)room.CustomProperties["levelIndex"];
		}
		return -1;
	}

	public static void SetNextHoleCountDown(this Photon.Realtime.Room room, bool value)
	{
		RoomSet(room, "nextHoleCountdown", value);
	}

	public static bool GetNextHoleCountDown(this Photon.Realtime.Room room)
	{
		if (room.CustomProperties.TryGetValue("nextHoleCountdown", out var value))
		{
			return (bool)value;
		}
		return false;
	}

	public static void AddKickedPlayers(this Photon.Realtime.Room room, Photon.Realtime.Player p)
	{
		List<int> list = room.GetKickedPlayers().ToList();
		list.Add(p.ActorNumber);
		int[] value = list.ToArray();
		RoomSet(room, "kickedPlayers", value);
	}

	public static void RemoveKickedPlayers(this Photon.Realtime.Room room, Photon.Realtime.Player p)
	{
		List<int> list = room.GetKickedPlayers().ToList();
		for (int i = 0; i < list.Count; i++)
		{
			if (list[i] == p.ActorNumber)
			{
				list.RemoveAt(i);
				break;
			}
		}
		int[] value = list.ToArray();
		RoomSet(room, "kickedPlayers", value);
	}

	public static int[] GetKickedPlayers(this Photon.Realtime.Room room)
	{
		int[] result = new int[0];
		if (room == null)
		{
			return result;
		}
		if (room.CustomProperties.ContainsKey("kickedPlayers") && room.CustomProperties["kickedPlayers"] != null)
		{
			result = (int[])room.CustomProperties["kickedPlayers"];
		}
		return result;
	}

	public static void LoadNextLevel(this Photon.Realtime.Room room, bool isNewGame = false)
	{
		int holeIndex = PhotonNetwork.CurrentRoom.GetHoleIndex();
		if (isNewGame)
		{
			holeIndex = 0;
			RoomSet(room, "levelIndex", 0);
		}
		else
		{
			holeIndex++;
			if (holeIndex >= room.GetHoles().Length)
			{
				RoomSet(room, "levelIndex", -1);
			}
			else
			{
				RoomSet(room, "levelIndex", holeIndex);
			}
		}
		RoomRPC.instance.LoadNextLevel();
		PhotonNetwork.CurrentRoom.SetNextHoleCountDown(value: false);
	}

	public static void SetPlayerIDInRoom(this Photon.Realtime.Room room, PlayerID[] ids)
	{
		RoomSet(room, "roomPlayerIDs", JsonHelper.ToJson(ids));
	}

	public static PlayerID[] GetPlayerIDInRoom(this Photon.Realtime.Room room)
	{
		PlayerID[] result = new PlayerID[0];
		if (room == null)
		{
			return result;
		}
		if (room.CustomProperties.ContainsKey("roomPlayerIDs") && room.CustomProperties["roomPlayerIDs"] != null)
		{
			string text = (string)room.CustomProperties["roomPlayerIDs"];
			if (string.IsNullOrEmpty(text))
			{
				return result;
			}
			result = JsonHelper.FromJson<PlayerID>(text);
		}
		return result;
	}

	public static void SetRatingHole(this Photon.Realtime.Player player, bool value)
	{
		PlayerSet(player, "isRatingHole", value);
	}

	public static bool GetRatingHole(this Photon.Realtime.Player player)
	{
		if (player.CustomProperties.TryGetValue("isRatingHole", out var value))
		{
			return (bool)value;
		}
		return false;
	}

	public static bool IsReadyToStart(this Photon.Realtime.Player player)
	{
		if (player.CustomProperties.TryGetValue("ready", out var value))
		{
			return (bool)value;
		}
		return false;
	}

	public static void SetReadyToStart(this Photon.Realtime.Player player, bool value)
	{
		PlayerSet(player, "ready", value);
	}

	public static string GetScene(this Photon.Realtime.Player player)
	{
		return (string)player.CustomProperties["sceneName"];
	}

	public static void SetScene(this Photon.Realtime.Player player, string scene)
	{
		PlayerSet(player, "sceneName", scene);
	}

	public static void SetLoadingLevel(this Photon.Realtime.Player player, bool loading)
	{
		PlayerSet(player, "loadingLevel", loading);
	}

	public static bool GetLoadingLevel(this Photon.Realtime.Player player)
	{
		if (player.CustomProperties.TryGetValue("loadingLevel", out var value))
		{
			return (bool)value;
		}
		return false;
	}

	public static void SetStandby(this Photon.Realtime.Player player, double acks)
	{
		PlayerSet(player, "standby", acks);
	}

	public static double GetStandbyTime(this Photon.Realtime.Player player)
	{
		if (player.CustomProperties.TryGetValue("standby", out var value))
		{
			return (double)value;
		}
		return 120.0;
	}

	public static bool GetStandby(this Photon.Realtime.Player player)
	{
		if (player.CustomProperties.TryGetValue("standby", out var value))
		{
			if (PhotonNetwork.Time - (double)value > 3.0)
			{
				return true;
			}
			return false;
		}
		return false;
	}

	public static void SetDownloadFinished(this Photon.Realtime.Player player, bool value)
	{
		PlayerSet(player, "isDownloadFinished", value);
	}

	public static bool IsFinishedDownloading(this Photon.Realtime.Player player)
	{
		if (player.CustomProperties.TryGetValue("isDownloadFinished", out var value))
		{
			return (bool)value;
		}
		return false;
	}

	public static void SetDownloadProgress(this Photon.Realtime.Player player, int downloadsCompleted)
	{
		PlayerSet(player, "downloadProgress", downloadsCompleted);
	}

	public static int GetDownloadProgress(this Photon.Realtime.Player player)
	{
		if (player.CustomProperties.TryGetValue("downloadProgress", out var value))
		{
			return (int)value;
		}
		return 0;
	}

	public static void SetScores(this Photon.Realtime.Player player, int[] scores)
	{
		PlayerSet(player, "score", scores);
	}

	public static int[] GetScores(this Photon.Realtime.Player player)
	{
		if (player.CustomProperties.TryGetValue("score", out var value))
		{
			return (int[])value;
		}
		return new int[0];
	}

	public static void SetHoleFinished(this Photon.Realtime.Player player, bool value)
	{
		PlayerSet(player, "isHoleFinished", value);
	}

	public static bool GetHoleFinished(this Photon.Realtime.Player player)
	{
		if (player.CustomProperties.TryGetValue("isHoleFinished", out var value))
		{
			return (bool)value;
		}
		return false;
	}

	public static void SetKicked(this Photon.Realtime.Player player, bool kicked)
	{
		PlayerSet(player, "kicked", kicked);
	}

	public static bool GetKicked(this Photon.Realtime.Player player)
	{
		if (player.CustomProperties.TryGetValue("kicked", out var value))
		{
			return (bool)value;
		}
		return false;
	}

	public static void SetPlayerID(this Photon.Realtime.Player player, PlayerID id)
	{
		PlayerSet(player, "playerID", JsonUtility.ToJson(id));
	}

	public static PlayerID GetPlayerID(this Photon.Realtime.Player player)
	{
		string text = (string)player.CustomProperties["playerID"];
		if (string.IsNullOrEmpty(text))
		{
			PlayerID result = default(PlayerID);
			result.playerID = "";
			result.publishedPlatform = PublishedPlatform.OCULUS;
			return result;
		}
		return JsonUtility.FromJson<PlayerID>(text);
	}

	public static void SetXRAvatarFormat(this Photon.Realtime.Player player, string value)
	{
		PlayerSet(player, "xrSpaceAvatarFormat", value);
	}

	public static string GetXRAvatarFormat(this Photon.Realtime.Player player)
	{
		string text = (string)player.CustomProperties["xrSpaceAvatarFormat"];
		if (string.IsNullOrEmpty(text))
		{
			return "";
		}
		return text;
	}
}
[Serializable]
public struct PlayerID
{
	public string playerID;

	public string avatarID;

	public PublishedPlatform publishedPlatform;
}
public class RoomRPC : MonoBehaviour
{
	public static RoomRPC instance;

	public GameObject myAvatar;

	public PhotonBall photonBall;

	public PhotonView pView;

	public AudioClip[] audioClips;

	private AudioSource aSource;

	[HideInInspector]
	public Recorder rec;

	private float retryGettingRecorderInterval = 3f;

	private float retryGettingRecorderTimer;

	private bool isMasterClient = true;

	public bool x;

	private void Awake()
	{
		if (instance != null && PhotonNetwork.IsMasterClient)
		{
			PhotonNetwork.Destroy(instance.gameObject);
		}
		instance = this;
		pView = GetComponent<PhotonView>();
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
	}

	private void Start()
	{
		aSource = GetComponent<AudioSource>();
		StartCoroutine(SpawnPhotonObjects());
		SetupRecorder();
		isMasterClient = PhotonNetwork.IsMasterClient;
	}

	private IEnumerator SpawnPhotonObjects()
	{
		Transform player = GameManager.instance.player.transform;
		myAvatar = PhotonNetwork.Instantiate("PhotonAvatar", player.position, player.rotation, 0);
		myAvatar.name = PhotonNetwork.LocalPlayer.NickName + " PhotonAvatar";
		yield return new WaitForSeconds(0.5f);
		PhotonNetwork.Instantiate("PhotonClub", player.position, player.rotation, 0).name = PhotonNetwork.LocalPlayer.NickName + "PhotonClub";
		yield return new WaitForSeconds(0.5f);
		photonBall = PhotonNetwork.Instantiate("PhotonBall", player.position, player.rotation, 0).GetComponent<PhotonBall>();
		photonBall.name = PhotonNetwork.LocalPlayer.NickName + "PhotonBall";
		yield return new WaitForSeconds(0.5f);
		PhotonNetwork.Instantiate("PhotonTrailContainer", player.position, player.rotation, 0).name = PhotonNetwork.LocalPlayer.NickName + "PhotonTrails";
	}

	private void Update()
	{
		if (rec != null)
		{
			rec.VoiceDetection = true;
			rec.TransmitEnabled = GameManager.instance.GetMicState();
			if (rec.RequiresRestart)
			{
				rec.RestartRecording();
			}
		}
		else
		{
			retryGettingRecorderTimer += Time.deltaTime;
			if (retryGettingRecorderTimer >= retryGettingRecorderInterval)
			{
				retryGettingRecorderTimer = 0f;
				PhotonVoiceNetwork.Instance.ConnectAndJoinRoom();
				SetupRecorder();
			}
		}
		if (!isMasterClient && PhotonNetwork.IsMasterClient)
		{
			NewHostMessage(isHost: true);
		}
		else if (isMasterClient && !PhotonNetwork.IsMasterClient)
		{
			NewHostMessage(isHost: false);
		}
		isMasterClient = PhotonNetwork.IsMasterClient;
	}

	public void LoadNextLevel()
	{
		StartCoroutine(_LoadNextLevel());
	}

	public IEnumerator _LoadNextLevel()
	{
		while (GameManager.instance.holeIndex != PhotonNetwork.CurrentRoom.GetHoleIndex())
		{
			yield return null;
		}
		GameManager.instance.LoadNextHole();
		foreach (Photon.Realtime.Player usablePlayer in PhotonManager.instance.GetUsablePlayers(includeSelf: false))
		{
			pView.RPC("OtherPlayersLoadNextLevel", usablePlayer);
		}
	}

	public void PlayDisconnectSFX()
	{
		AudioClip[] array = audioClips;
		foreach (AudioClip audioClip in array)
		{
			if (audioClip.name == "SFX_Online_Leave")
			{
				aSource.transform.position = GameManager.instance.player.transform.position;
				aSource.PlayOneShot(audioClip, 0.5f);
				break;
			}
		}
	}

	private T GetClosestObject<T>(Vector3 pos) where T : MonoBehaviour
	{
		T result = null;
		float num = float.PositiveInfinity;
		T[] array = UnityEngine.Object.FindObjectsOfType<T>();
		foreach (T val in array)
		{
			float num2 = Vector3.Distance(val.transform.position, pos);
			if (num2 < num)
			{
				result = val;
				num = num2;
			}
		}
		return result;
	}

	private void NewHostMessage(bool isHost)
	{
		if (isHost)
		{
			Notification.instance.AddNotification("You are now the new host of this room", 0f, closeButton: true);
			return;
		}
		Notification.instance.AddNotification("Room ownership transferred due to inactivity", 0f, closeButton: true);
		UpdatePlayerList();
	}

	[PunRPC]
	private void OtherPlayersLoadNextLevel()
	{
		StartCoroutine(OtherPlayersLoadNextLevel_());
	}

	private IEnumerator OtherPlayersLoadNextLevel_()
	{
		while (GameManager.instance.holeIndex != PhotonNetwork.CurrentRoom.GetHoleIndex())
		{
			yield return null;
		}
		if (GameManager.instance.currentSceneName == "RoomPrepScene")
		{
			HoleSelectPanel.instance.startMessage.SetActive(value: true);
		}
		GameManager.instance.LoadNextHole();
	}

	public static void PlayOnlineSound(Vector3 pos, string audioName, float volume = 0.2f, bool includeSelf = false)
	{
		if (instance != null)
		{
			MonoBehaviour.print(audioName);
			instance.pView.RPC("PlaySound", (!includeSelf) ? RpcTarget.Others : RpcTarget.All, pos, audioName, volume);
		}
	}

	public void SetupRecorder()
	{
		if (myAvatar.GetComponent<Recorder>() == null)
		{
			rec = myAvatar.AddComponent<Recorder>();
			rec.RestartRecording();
		}
		myAvatar.GetComponent<PhotonVoiceView>().RecorderInUse = rec;
		if (PhotonVoiceNetwork.Instance != null)
		{
			PhotonVoiceNetwork.Instance.PrimaryRecorder = rec;
			rec.Init(PhotonVoiceNetwork.Instance.VoiceClient);
		}
	}

	[PunRPC]
	public void PlaySound(Vector3 pos, string audioName, float volume = 0.2f)
	{
		if (!(PhotonNetwork.LocalPlayer.GetScene() != "LobbyScene") || string.IsNullOrEmpty(PhotonNetwork.LocalPlayer.GetScene()))
		{
			return;
		}
		AudioClip[] array = audioClips;
		foreach (AudioClip audioClip in array)
		{
			if (audioClip.name == audioName)
			{
				MonoBehaviour.print("Volume: " + volume);
				aSource.transform.position = pos;
				aSource.PlayOneShot(audioClip, volume);
				return;
			}
		}
		UnityEngine.Debug.LogWarningFormat("The audio clip {0} was not found in the RoomRPC. Make sure to add it the audioclips in the inspector of the RoomRPC object", audioName);
	}

	[PunRPC]
	public void UpdatePlayerList()
	{
		if (GameManager.instance.currentSceneName == "RoomPrepScene")
		{
			HoleSelectPanel.instance.playerListPanel.UpdatePlayerList();
		}
	}

	[PunRPC]
	public void UpdateSelectedHoles()
	{
		if (GameManager.instance.currentSceneName == "RoomPrepScene")
		{
			HoleSelectPanel.instance.UpdatePickedOnlineLevels();
		}
	}

	[PunRPC]
	public void UpdateSelectedPlaylist()
	{
		if (GameManager.instance.currentSceneName == "RoomPrepScene")
		{
			if (!string.IsNullOrEmpty(PhotonNetwork.CurrentRoom.GetPlaylist().levelName))
			{
				HoleSelectPanel.instance.currentPlaylist = PhotonNetwork.CurrentRoom.GetPlaylist();
				HoleSelectPanel.instance.customPlaylist.holesOrPlaylistText.text = LocalizationManager.GetTranslation("Playlist") + ": " + HoleSelectPanel.instance.currentPlaylist.levelName;
			}
			else
			{
				HoleSelectPanel.instance.currentPlaylist = new WorkshopData();
				HoleSelectPanel.instance.customPlaylist.holesOrPlaylistText.text = LocalizationManager.GetTranslation("Holes");
			}
		}
	}

	[PunRPC]
	public void OnReadyButton()
	{
		if (GameManager.instance.currentSceneName == "RoomPrepScene")
		{
			HoleSelectPanel.instance.DownloadHoles();
		}
	}

	[PunRPC]
	private void SetOtherPlayersPhotonScore(bool fromLobby)
	{
		if (fromLobby)
		{
			ScoreManager.instance.SetPhotonScores(fromLobby: true);
		}
		else
		{
			ScoreManager.instance.SetPhotonScores();
		}
	}

	[PunRPC]
	private void ShowKickNotification()
	{
		PhotonManager.instance.onKicked = true;
		GameManager.instance.BackToLobby();
	}

	[PunRPC]
	public void LaunchCannonOnline(Vector3 pos)
	{
		Cannon closestObject = GetClosestObject<Cannon>(pos);
		if (closestObject != null)
		{
			closestObject.PlaySFX();
		}
	}

	[PunRPC]
	private void HoleInOnePFX(Vector3 pos)
	{
		Golfhole closestObject = GetClosestObject<Golfhole>(pos);
		if (closestObject != null)
		{
			closestObject.HoleInOnePFX();
		}
	}
}
public class VoiceHighlighter : MonoBehaviour
{
	public Speaker speaker;

	public Renderer voiceIcon;

	private PhotonAvatarView avatar;

	private void Start()
	{
		avatar = GetComponent<PhotonAvatarView>();
	}

	private void Update()
	{
		if (speaker != null && !avatar.muted && avatar.micTurnedOn)
		{
			voiceIcon.enabled = speaker.IsPlaying;
			if (speaker.IsPlaying)
			{
				PhotonManager.instance.timeBeforeMaxVolumeTimer = PhotonManager.instance.timeBeforeMaxVolume;
			}
		}
		else
		{
			voiceIcon.enabled = false;
		}
	}
}
public class PicoSplash : MonoBehaviour
{
	private void Start()
	{
		StartCoroutine(ChangeScene());
	}

	private IEnumerator ChangeScene()
	{
		yield return new WaitForSeconds(10f);
		SceneManager.LoadScene("Splash", LoadSceneMode.Single);
	}
}
public class PlayerTurnPrompt : MonoBehaviour
{
	public TextMeshPro nextPlayerText;

	public TextMeshPro passToPlayerText;

	public GameObject keepPlayingButton;

	public GameObject nextPlayerButton;

	public GameObject passToPlayerButton;

	private void Start()
	{
		if (GameManager.instance.playerIndex == GetNextPlayer())
		{
			ScoreManager.instance.playerTurn[GameManager.instance.playerIndex].holeIndex++;
			Golfhole component = GameManager.instance.GetNearestHoleFromPos(GameManager.instance.player.transform.position).GetComponent<Golfhole>();
			component.StartCoroutine(component.NextHoleCountdown());
			return;
		}
		GetComponent<PointerLineActivation>().enabled = true;
		GameManager.instance.pauseMenu.allowPausing = false;
		if (ScoreManager.instance.playerTurn[GameManager.instance.playerIndex].holeIndex == GameManager.instance.holeData.Count - 1)
		{
			passToPlayerButton.SetActive(value: true);
			if (ScoreManager.instance.playerTurn[GetNextPlayer()].playerName == "")
			{
				passToPlayerText.text = string.Format(LocalizationManager.GetTranslation("Pass headset to {0}"), GetNextPlayer() + 1);
			}
			else
			{
				passToPlayerText.text = string.Format(LocalizationManager.GetTranslation("Pass headset to {0}"), ScoreManager.instance.playerTurn[GetNextPlayer()].playerName);
			}
			return;
		}
		keepPlayingButton.SetActive(value: true);
		nextPlayerButton.SetActive(value: true);
		if (ScoreManager.instance.playerTurn[GetNextPlayer()].playerName == "")
		{
			nextPlayerText.text = LocalizationManager.GetTranslation("Next Player") + " \n P" + (GetNextPlayer() + 1);
		}
		else
		{
			nextPlayerText.text = LocalizationManager.GetTranslation("Next Player") + " \n" + ScoreManager.instance.playerTurn[GetNextPlayer()].playerName;
		}
	}

	public void KeepPlaying()
	{
		GameManager.instance.pauseMenu.allowPausing = true;
		ScoreManager.instance.playerTurn[GameManager.instance.playerIndex].holeIndex++;
		Golfhole component = GameManager.instance.GetNearestHoleFromPos(GameManager.instance.player.transform.position).GetComponent<Golfhole>();
		component.StartCoroutine(component.NextHoleCountdown());
		UnityEngine.Object.Destroy(base.gameObject);
	}

	public void NextPlayer()
	{
		GameManager.instance.pauseMenu.allowPausing = true;
		ScoreManager.instance.playerTurn[GameManager.instance.playerIndex].holeIndex++;
		GameManager.instance.playerIndex = GetNextPlayer();
		Golfhole component = GameManager.instance.GetNearestHoleFromPos(GameManager.instance.player.transform.position).GetComponent<Golfhole>();
		component.StartCoroutine(component.NextHoleCountdown());
		UnityEngine.Object.Destroy(base.gameObject);
	}

	private int GetNextPlayer()
	{
		int num = GameManager.instance.playerIndex + 1;
		for (int i = 0; i < GameManager.instance.playerCount; i++)
		{
			if (num == GameManager.instance.playerCount)
			{
				num = 0;
			}
			if (ScoreManager.instance.playerTurn[num].holeIndex < GameManager.instance.holeData.Count)
			{
				return num;
			}
			num++;
		}
		return GameManager.instance.playerIndex;
	}
}
public class Pointer : MonoBehaviour
{
	public LayerMask uiLayerMask;

	private RaycastHit optionHit;

	public LineRenderer pointerLine;

	private AudioSource audioSource;

	public AudioClip hoverSFX;

	public AudioClip clickSFX;

	private float pointerLineLength = 10f;

	private PointerButton currentPointerButton;

	public bool canPress;

	[Header("XR")]
	public XRHandGestureInput xrHandGestureInput;

	private void Start()
	{
		audioSource = GetComponent<AudioSource>();
	}

	private void Update()
	{
		if (Player.instance.currentController.constrainedSwing && pointerLine.enabled)
		{
			Player.instance.currentController.controllerMode = ControllerMode.FollowMode;
		}
		canPress = true;
		if ((GameManager.instance.controllerType != ControllerType.XR || (GameManager.instance.controllerType == ControllerType.XR && pointerLine.enabled)) && Physics.Raycast(pointerLine.transform.position, base.transform.right, out optionHit, float.PositiveInfinity, uiLayerMask))
		{
			if (GameManager.instance.currentSceneName == "LevelEditor" || GameManager.instance.currentSceneName == "LevelEditorArt")
			{
				if (Player.instance.editorGrabber.currentActiveObject != null)
				{
					TurnOffPointerLine();
					Player.instance.editorGrabber.pointingAtUI = false;
					canPress = false;
					if (currentPointerButton != null)
					{
						currentPointerButton.UnHighlight();
						currentPointerButton = null;
					}
				}
				else
				{
					TurnOnPointerLine();
					Player.instance.editorGrabber.pointingAtUI = true;
				}
			}
			if (!canPress)
			{
				return;
			}
			pointerLine.SetPosition(1, new Vector3(optionHit.distance, 0f, 0f));
			PointerButton component = optionHit.collider.GetComponent<PointerButton>();
			if (component != null)
			{
				if (component != currentPointerButton)
				{
					if (currentPointerButton != null)
					{
						currentPointerButton.UnHighlight();
					}
					currentPointerButton = component;
					currentPointerButton.Highlight();
					Player.instance.currentController.toolTip.SetTip(currentPointerButton.tip);
					if (currentPointerButton.clickable)
					{
						audioSource.PlayOneShot(hoverSFX);
					}
				}
				bool flag = false;
				if (GameManager.instance.controllerType != ControllerType.XR || Player.instance.currentControllerInput.usingController)
				{
					flag = Player.instance.currentControllerInput.xButton.wasPressed;
				}
				if (flag)
				{
					if (currentPointerButton.playDefaultClickSFX && currentPointerButton.clickable)
					{
						audioSource.PlayOneShot(clickSFX);
					}
					currentPointerButton.OnClick();
				}
			}
			else if (currentPointerButton != null)
			{
				currentPointerButton.UnHighlight();
				currentPointerButton = null;
			}
		}
		else
		{
			if ((GameManager.instance.currentSceneName == "LevelEditor" || GameManager.instance.currentSceneName == "LevelEditorArt") && !GameManager.instance.pauseMenu.paused)
			{
				TurnOffPointerLine();
				Player.instance.editorGrabber.pointingAtUI = false;
			}
			if (currentPointerButton != null)
			{
				currentPointerButton.UnHighlight();
				currentPointerButton = null;
			}
			Player.instance.currentController.toolTip.SetTip();
			pointerLine.SetPosition(1, new Vector3(pointerLineLength, 0f, 0f));
		}
	}

	public void TurnOffPointerLine()
	{
		pointerLine.enabled = false;
	}

	public void TurnOnPointerLine()
	{
		pointerLine.enabled = true;
	}
}
public class PointerLineActivation : MonoBehaviour
{
	public bool disableOnDestroy = true;

	private void Update()
	{
		if (!Player.instance.currentController.pointerActive)
		{
			Player.instance.currentController.SwitchToPointer();
		}
		Player.instance.currentController.pointerLineActivationInScene = true;
	}

	private IEnumerator ActivatePointer()
	{
		while (Player.instance == null)
		{
			yield return null;
		}
		Player.instance.currentController.SwitchToPointer();
	}

	private void DisablePointer()
	{
		if (((GameManager.instance.currentSceneName == "LevelEditor" && LevelEditor.instance.previewing) || GameManager.instance.currentSceneName != "LevelEditor") && GameManager.instance.pauseMenu != null && GameManager.instance.quickMenu != null && !GameManager.instance.pauseMenu.paused && !GameManager.instance.quickMenu.menu.activeSelf)
		{
			GameManager.instance.player.currentController.SwitchToClubs();
		}
		Player.instance.currentController.pointerLineActivationInScene = false;
	}

	private void OnEnable()
	{
		StartCoroutine(ActivatePointer());
	}

	private void OnDisable()
	{
		DisablePointer();
	}

	private void OnDestroy()
	{
		if (disableOnDestroy && GameManager.instance != null)
		{
			DisablePointer();
		}
	}
}
public class BlackHole : MonoBehaviour
{
	public float pullForce;

	public float pullTimer = 1f;

	private bool pulling;

	private Golfball gb;

	private void Update()
	{
		PullBall();
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.tag == "Golfball")
		{
			pulling = true;
			gb = other.GetComponent<Golfball>();
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (gb != null)
		{
			pulling = false;
			pullTimer = 1f;
			gb = null;
		}
	}

	private void PullBall()
	{
		if (pulling)
		{
			pullTimer -= Time.deltaTime;
			if (pullTimer >= 0f)
			{
				_ = pullForce / Vector3.Distance(gb.transform.position, base.transform.position);
				gb.rb.AddForce((base.transform.position - gb.transform.position) * pullForce * Time.deltaTime, ForceMode.Force);
			}
			else
			{
				pulling = false;
				pullTimer = 1f;
				gb = null;
			}
		}
	}
}
public class Explosion : MonoBehaviour
{
	public ParticleSystem Main;

	public ParticleSystem[] Ring;

	public SparkParticles Sparks;

	public ParticleSystem Flash;

	public ParticleSystem[] Debris;

	private void Start()
	{
		UnityEngine.Object.Destroy(base.gameObject, 5f);
	}

	public void Play()
	{
		Main.Play();
		for (int i = 0; i < Ring.Length; i++)
		{
			Ring[i].Play();
		}
		Sparks.Play();
		Flash.Play();
		for (int j = 0; j < Debris.Length; j++)
		{
			Debris[j].Play();
		}
	}
}
public class SparkParticles : MonoBehaviour
{
	public Transform BillboardTarget;

	private ParticleSystem _particleSystem;

	private ParticleSystem.Particle[] _particles = new ParticleSystem.Particle[25];

	private void Awake()
	{
		_particleSystem = GetComponent<ParticleSystem>();
		if (BillboardTarget == null)
		{
			BillboardTarget = Camera.main.transform;
		}
	}

	private void FixParticleRotations()
	{
		int particles = _particleSystem.GetParticles(_particles);
		for (int i = 0; i < particles; i++)
		{
			Vector3 normalized = _particles[i].velocity.normalized;
			float rotation = Mathf.Atan2(normalized.y, normalized.x) * 57.29578f;
			_particles[i].rotation = rotation;
		}
		_particleSystem.SetParticles(_particles, _particleSystem.particleCount);
	}

	public void Play()
	{
		base.transform.LookAt(BillboardTarget);
		_particleSystem.Play();
		StartCoroutine(LateFix());
	}

	private IEnumerator LateFix()
	{
		yield return null;
		FixParticleRotations();
	}
}
public class BoostPad : MonoBehaviour
{
	public float thrust = 1f;

	public AudioClip ballBoostSFX;

	private AudioSource boostAudio;

	private float boostTimer = 1f;

	private bool allowBoost = true;

	private void Start()
	{
		boostAudio = GetComponent<AudioSource>();
	}

	private void Update()
	{
		if (!allowBoost)
		{
			boostTimer -= Time.deltaTime;
			if (boostTimer <= 0f)
			{
				boostTimer = 1f;
				allowBoost = true;
			}
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.CompareTag("Golfball") && allowBoost)
		{
			other.GetComponent<Golfball>().ResetDrag();
			ApplyBoost(other.GetComponent<Golfball>().rb);
		}
	}

	private void ApplyBoost(Rigidbody ballRigidbody)
	{
		allowBoost = false;
		ballRigidbody.AddForce(base.transform.right * thrust, ForceMode.Impulse);
		PlaySFX();
	}

	public void PlaySFX()
	{
		boostAudio.PlayOneShot(ballBoostSFX);
		RoomRPC.PlayOnlineSound(base.transform.position, ballBoostSFX.name, 0.5f);
	}
}
public class Bumper : MonoBehaviour
{
	public AudioClip bumperSFX;

	public float thrust = 1f;

	private AudioSource bumperSound;

	public static event Action<Vector3> onBounce;

	private void Start()
	{
		bumperSound = GetComponent<AudioSource>();
	}

	public void BounceAway(Collision other)
	{
		if (other.gameObject.CompareTag("Golfball"))
		{
			other.transform.GetComponent<Golfball>().ResetDrag();
			other.collider.attachedRigidbody.AddForce(base.gameObject.transform.forward * thrust, ForceMode.Impulse);
			if (Bumper.onBounce != null)
			{
				Bumper.onBounce(base.transform.position);
			}
			PlaySFX();
		}
	}

	private void OnCollisionEnter(Collision other)
	{
		BounceAway(other);
	}

	public void PlaySFX()
	{
		bumperSound.PlayOneShot(bumperSFX);
		RoomRPC.PlayOnlineSound(base.transform.position, bumperSFX.name, 0.5f);
	}
}
public class Cannon : Interact
{
	public ParticleSystem cannonSmokeFX;

	public GameObject ballPrefab;

	public Transform launchPoint;

	public float speed = 1f;

	public float randomness;

	public float spread = 15f;

	public float launchDelay;

	private float delayTimer;

	protected bool delayTimerSwitch;

	private AudioSource cannonAudio;

	private float distanceFromPlayer = 25f;

	public static event Action onLaunchBall;

	private void Start()
	{
		cannonAudio = GetComponent<AudioSource>();
	}

	private void Update()
	{
		if (delayTimerSwitch)
		{
			delayTimer += Time.deltaTime;
			if (delayTimer >= launchDelay)
			{
				LaunchBall();
				delayTimerSwitch = false;
				delayTimer = 0f;
			}
		}
	}

	public override void DoInteract(Collider Other)
	{
		if (Other.gameObject.CompareTag("Golfball"))
		{
			delayTimerSwitch = true;
			OBManager.instance.MoveTrailToObject();
			OBManager.instance.respawnTimer = 0f;
			UnityEngine.Object.Destroy(Other.gameObject);
			if (Cannon.onLaunchBall != null)
			{
				Cannon.onLaunchBall();
			}
		}
	}

	public virtual void LaunchBall()
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(ballPrefab, launchPoint.position, launchPoint.rotation);
		GameManager.instance.golfball = gameObject.GetComponent<Golfball>();
		gameObject.GetComponent<Golfball>().AddTrailRenderer();
		Vector3 vector = VectorSpread(launchPoint.forward, spread);
		float num = UnityEngine.Random.Range(speed + randomness, speed - randomness);
		gameObject.GetComponent<Rigidbody>().AddForce(vector * num, ForceMode.Impulse);
		PlaySFX();
		if (PhotonNetwork.IsConnected)
		{
			RoomRPC.instance.pView.RPC("LaunchCannonOnline", RpcTarget.Others, base.transform.position);
		}
	}

	public void PlaySFX()
	{
		if (cannonSmokeFX != null)
		{
			cannonSmokeFX.Play();
		}
		float num = (distanceFromPlayer - Mathf.Clamp(Vector3.Distance(Player.instance.transform.position, base.transform.position), 0f, distanceFromPlayer)) / distanceFromPlayer;
		MonoBehaviour.print("DistanceFromCannon: " + num);
		Player.instance.currentControllerInput.Vibrate(0.1f, num);
		cannonAudio.PlayOneShot(cannonAudio.clip);
	}

	private Vector3 VectorSpread(Vector3 origVector, float accuracy)
	{
		float num = UnityEngine.Random.Range(0f - accuracy, accuracy);
		float num2 = UnityEngine.Random.Range(0f - accuracy, accuracy);
		float num3 = UnityEngine.Random.Range(0f - accuracy, accuracy);
		return new Vector3(origVector.x + num, origVector.y + num2, origVector.z + num3);
	}
}
public class Conveyor : MonoBehaviour
{
	public float moveSpeed = 100f;

	private void OnTriggerStay(Collider other)
	{
		if (other.tag == "Golfball")
		{
			other.GetComponent<Golfball>().rb.AddForce(base.transform.forward * moveSpeed * Time.deltaTime);
		}
	}
}
public class Fan : MonoBehaviour
{
	public Transform windmillArms;

	public float windmillArmsSpeed = 20f;

	public Transform boxCollider;

	public float userThrust = 1f;

	public bool fanAlwaysOn;

	public float fanOnInterval;

	public float fanOffInterval;

	protected bool setFanOn;

	private float totalThrust;

	private float fanOffTimer;

	private float fanOnTimer;

	private bool isBallIn;

	private Collider ballCollider;

	public float startDelay;

	private float currentStartDelayTimer;

	private bool startDelayComplete;

	public AudioSource fanAudioSource;

	private bool playSound;

	private float distanceFromFan;

	private void Awake()
	{
		if (fanAlwaysOn)
		{
			fanOnInterval = 1f;
			fanOffInterval = 0f;
		}
		if (!(GameManager.instance.currentSceneName == "LevelEditor") || LevelEditor.instance.previewing)
		{
			fanAudioSource.Play();
		}
	}

	private void Update()
	{
		if (!startDelayComplete)
		{
			currentStartDelayTimer += Time.deltaTime;
			if (!(currentStartDelayTimer > startDelay))
			{
				return;
			}
			startDelayComplete = true;
			fanOffTimer = fanOffInterval;
		}
		fanOffTimer += Time.deltaTime;
		if (!(fanOffTimer >= fanOffInterval))
		{
			return;
		}
		setFanOn = true;
		if (playSound && !fanAlwaysOn)
		{
			fanAudioSource.Play();
			playSound = false;
		}
		windmillArms.Rotate(Vector3.forward, Time.deltaTime * windmillArmsSpeed, Space.Self);
		fanOnTimer += Time.deltaTime;
		if (fanOnTimer > fanOnInterval)
		{
			setFanOn = false;
			fanOffTimer = 0f;
			fanOnTimer = 0f;
			if (!playSound && !fanAlwaysOn)
			{
				playSound = true;
				fanAudioSource.Stop();
			}
		}
	}

	private void FixedUpdate()
	{
		if (setFanOn && isBallIn && ballCollider != null && ballCollider.attachedRigidbody != null)
		{
			ballCollider.attachedRigidbody.AddForce(boxCollider.right * totalThrust, ForceMode.Force);
		}
	}

	public void BlowAway(Collider other)
	{
		if (other.gameObject.CompareTag("Golfball"))
		{
			distanceFromFan = Vector3.Distance(other.gameObject.transform.position, windmillArms.position);
			if (distanceFromFan < 0.1f)
			{
				distanceFromFan = 0.1f;
			}
			totalThrust = userThrust / distanceFromFan;
			isBallIn = true;
			ballCollider = other;
		}
	}

	public void Stop(Collider other)
	{
		isBallIn = false;
	}
}
public class FanCollider : MonoBehaviour
{
	public Fan fan;

	private void OnTriggerStay(Collider other)
	{
		fan.BlowAway(other);
	}

	private void OnTriggerExit(Collider other)
	{
		fan.Stop(other);
	}
}
public class Interact : MonoBehaviour
{
	public virtual void DoInteract(Collider Other)
	{
	}
}
public class Interpolation : MonoBehaviour
{
	public static float Linear(float t, float b, float c, float d)
	{
		return c * t / d + b;
	}

	public static float QuadEaseOut(float t, float b, float c, float d)
	{
		return (0f - c) * (t /= d) * (t - 2f) + b;
	}

	public static float QuadEaseIn(float t, float b, float c, float d)
	{
		return c * (t /= d) * t + b;
	}

	public static float QuadEaseInOut(float t, float b, float c, float d)
	{
		if ((t /= d / 2f) < 1f)
		{
			return c / 2f * t * t + b;
		}
		return (0f - c) / 2f * ((t -= 1f) * (t - 2f) - 1f) + b;
	}

	public static float CubicEaseOut(float t, float b, float c, float d)
	{
		return c * ((t = t / d - 1f) * t * t + 1f) + b;
	}

	public static float CubicEaseIn(float t, float b, float c, float d)
	{
		return c * (t /= d) * t * t + b;
	}

	public static float CubicEaseOutIn(float t, float b, float c, float d)
	{
		if (t < d / 2f)
		{
			return CubicEaseOut(t * 2f, b, c / 2f, d);
		}
		return CubicEaseIn(t * 2f - d, b + c / 2f, c / 2f, d);
	}

	public static float ExpoEaseOut(float t, float b, float c, float d)
	{
		if (t != d)
		{
			return c * (0f - Mathf.Pow(2f, -10f * t / d) + 1f) + b;
		}
		return b + c;
	}

	public static float ExpoEaseIn(float t, float b, float c, float d)
	{
		if (t != 0f)
		{
			return c * Mathf.Pow(2f, 10f * (t / d - 1f)) + b;
		}
		return b;
	}

	public static float ExpoEaseInOut(float t, float b, float c, float d)
	{
		if (t == 0f)
		{
			return b;
		}
		if (t == d)
		{
			return b + c;
		}
		if ((t /= d / 2f) < 1f)
		{
			return c / 2f * Mathf.Pow(2f, 10f * (t - 1f)) + b;
		}
		return c / 2f * (0f - Mathf.Pow(2f, -10f * (t -= 1f)) + 2f) + b;
	}

	public static float BounceEaseOut(float t, float b, float c, float d)
	{
		if ((t /= d) < 0.36363637f)
		{
			return c * (7.5625f * t * t) + b;
		}
		if (t < 0.72727275f)
		{
			return c * (7.5625f * (t -= 0.54545456f) * t + 0.75f) + b;
		}
		if (t < 0.90909094f)
		{
			return c * (7.5625f * (t -= 0.8181818f) * t + 0.9375f) + b;
		}
		return c * (7.5625f * (t -= 21f / 22f) * t + 63f / 64f) + b;
	}

	public static Vector3 Linear(float t, Vector3 b, Vector3 c, float d)
	{
		return c * t / d + b;
	}

	public static Vector3 QuadEaseOut(float t, Vector3 b, Vector3 c, float d)
	{
		return -c * (t /= d) * (t - 2f) + b;
	}

	public static Vector3 QuadEaseIn(float t, Vector3 b, Vector3 c, float d)
	{
		return c * (t /= d) * t + b;
	}

	public static Vector3 QuadEaseInOut(float t, Vector3 b, Vector3 c, float d)
	{
		if ((t /= d / 2f) < 1f)
		{
			return c / 2f * t * t + b;
		}
		return -c / 2f * ((t -= 1f) * (t - 2f) - 1f) + b;
	}
}
public class Mouse : MonoBehaviour
{
	public Transform ballCarryPosition;

	[HideInInspector]
	public Golfball gb;

	public bool getBall;

	public bool carryingBall;

	public bool wasHit;

	private void Update()
	{
		if (gb != null)
		{
			if (carryingBall)
			{
				gb.rb.isKinematic = true;
				gb.transform.position = ballCarryPosition.position;
			}
			else
			{
				gb.rb.isKinematic = false;
				gb = null;
			}
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (wasHit)
		{
			return;
		}
		if (other.tag == "Golfball")
		{
			gb = other.GetComponent<Golfball>();
			if (gb.IsGrounded())
			{
				carryingBall = true;
			}
		}
		else if (other.tag == "ClubHead")
		{
			if (gb != null)
			{
				carryingBall = false;
				gb.rb.isKinematic = false;
				gb = null;
			}
			wasHit = true;
		}
	}
}
public class MouseHole : MonoBehaviour
{
	public Transform center;

	public Mouse mouse;

	public float mouseMoveSpeed = 1f;

	private Transform target;

	private void Update()
	{
		GetBall();
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.tag == "Golfball" && target == null)
		{
			target = other.transform;
			mouse.getBall = true;
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (other.tag == "Golfball" && target == other.transform)
		{
			mouse.getBall = false;
			target = null;
		}
	}

	private void GetBall()
	{
		if (!mouse.carryingBall && mouse.getBall && !mouse.wasHit && target != null)
		{
			MoveTowards(target.position);
		}
		else
		{
			MoveTowards(center.position);
		}
		if (Vector3.Distance(mouse.transform.position, center.position) > 0.1f)
		{
			mouse.gameObject.SetActive(value: true);
			return;
		}
		if (mouse.gb != null)
		{
			OBManager.instance.RevertLastPosition();
			OBManager.instance.PlayOBSFX();
			mouse.gb.rb.isKinematic = false;
			mouse.gb = null;
		}
		mouse.gameObject.SetActive(value: false);
		mouse.carryingBall = false;
		mouse.wasHit = false;
	}

	private void MoveTowards(Vector3 pos)
	{
		Vector3 forward = Vector3.RotateTowards(mouse.transform.forward, pos - mouse.transform.position, 180f * Time.deltaTime, 0f);
		mouse.transform.position = Vector3.MoveTowards(mouse.transform.position, pos, mouseMoveSpeed * Time.deltaTime);
		mouse.transform.rotation = Quaternion.LookRotation(forward);
	}
}
public class Quicksand : MonoBehaviour
{
	public float sinkSpeed = 1f;

	public Transform center;

	public bool sinking;

	private Golfball gb;

	private void Update()
	{
		SinkBall();
	}

	private void SinkBall()
	{
		if (sinking && gb != null)
		{
			if (Vector3.Distance(gb.transform.position, center.transform.position) > 0.1f)
			{
				gb.rb.AddForce((center.position - gb.transform.position).normalized * sinkSpeed * Time.deltaTime, ForceMode.Force);
				return;
			}
			Vector3 position = gb.transform.position;
			position.y -= sinkSpeed * Time.deltaTime;
			gb.transform.position = position;
		}
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (collision.transform.tag == "Golfball")
		{
			sinking = true;
			gb = collision.transform.GetComponent<Golfball>();
			gb.ResetDrag();
		}
	}

	private void OnCollisionExit(Collision collision)
	{
		if (collision.transform.tag == "Golfball")
		{
			sinking = false;
			gb = null;
		}
	}
}
public class RotateObject : MonoBehaviour
{
	public Transform rotationObject;

	public float speed = 1f;

	private RotateObject rotateObjectScript;

	public bool doBob;

	public float floatStrength = 1f;

	private float originalY;

	public float offset;

	public float bobSpeed = 1f;

	private Rigidbody myRigidBody;

	private void Start()
	{
		if (rotationObject == null)
		{
			rotationObject = base.transform;
		}
		myRigidBody = GetComponent<Rigidbody>();
		originalY = rotationObject.position.y;
	}

	private void FixedUpdate()
	{
		if (!GameManager.instance.pauseMenu.paused && !(myRigidBody == null))
		{
			myRigidBody.MoveRotation(myRigidBody.rotation * Quaternion.AngleAxis(speed * Time.deltaTime, Vector3.up));
		}
	}

	private void Update()
	{
		if (!GameManager.instance.pauseMenu.paused && doBob)
		{
			rotationObject.position = new Vector3(rotationObject.position.x, originalY + floatStrength + (float)Math.Sin((Time.time + offset) * bobSpeed) * floatStrength, rotationObject.position.z);
		}
	}

	private void OnCollisionStay(Collision collision)
	{
		if (collision.transform.CompareTag("Golfball"))
		{
			collision.transform.GetComponent<Golfball>().ResetDrag();
		}
	}
}
public class Steam : MonoBehaviour
{
	public float force = 10f;

	public float steamTimer = 3f;

	public float steamRefreshTimer;

	public bool steaming;

	private Golfball gb;

	private ParticleSystem steamPFX;

	private void Start()
	{
		steamPFX = GetComponentInChildren<ParticleSystem>();
	}

	private void Update()
	{
		if (steaming)
		{
			ActivateSteam();
		}
		else if (steamRefreshTimer > 0f)
		{
			steamRefreshTimer -= Time.deltaTime;
		}
	}

	private void ActivateSteam()
	{
		if (steamTimer > 0f)
		{
			steamTimer -= Time.deltaTime;
			steamPFX.Play();
			if (steamTimer <= 0f)
			{
				steaming = false;
				steamRefreshTimer = 3f;
			}
			if (gb != null)
			{
				Vector3 vector = new Vector3(0f, force, 0f);
				gb.rb.AddForce(vector, ForceMode.Acceleration);
			}
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.tag == "Golfball")
		{
			if (steamRefreshTimer <= 0f && steamTimer == 3f)
			{
				steamTimer = 3f;
				steaming = true;
			}
			gb = other.GetComponent<Golfball>();
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (other.tag == "Golfball")
		{
			if (steamRefreshTimer <= 0f && steamTimer <= 0f)
			{
				steamTimer = 3f;
			}
			gb = null;
		}
	}
}
public class TargetRing : MonoBehaviour
{
	public enum RingType
	{
		none,
		money,
		boost
	}

	public float thrust = 1f;

	public AudioClip scoreSFX;

	public Material scoredMaterial;

	public MeshRenderer mesh;

	private Material originalMaterial;

	private AudioSource audioSource;

	private Rigidbody rb;

	public bool scored;

	private float timer;

	private float interval = 0.5f;

	[Header("ITEM Type")]
	public int moneyAmount;

	public RingType ringType;

	private void Start()
	{
		audioSource = GetComponent<AudioSource>();
		rb = GetComponent<Rigidbody>();
		originalMaterial = mesh.material;
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.tag == "Golfball" && !scored)
		{
			scored = true;
			ScoredInRing();
			if (ringType == RingType.money)
			{
				GiveMoney();
			}
			else if (ringType == RingType.boost)
			{
				ApplyBoost(other.GetComponent<Rigidbody>());
			}
		}
	}

	private void GiveMoney()
	{
		MoneyManager.instance.ReceiveMoney(moneyAmount);
		foreach (Transform item in base.transform)
		{
			if (item.GetComponent<MeshCollider>() != null)
			{
				item.GetComponent<MeshCollider>().convex = true;
				break;
			}
		}
		rb.useGravity = true;
		rb.isKinematic = false;
	}

	private void ScoredInRing()
	{
		if (!audioSource.isPlaying)
		{
			audioSource.PlayOneShot(scoreSFX);
		}
		mesh.material = scoredMaterial;
	}

	private void ApplyBoost(Rigidbody ballRigidbody)
	{
		ballRigidbody.AddForce(-base.transform.up * thrust, ForceMode.Impulse);
	}
}
public class Tornado : MonoBehaviour
{
	public float tornadoForce = 50f;

	public Transform midPoint;

	private bool spinBall;

	private float timer;

	private Golfball gb;

	private Vector3 originalVel;

	private float enterHeight;

	private float spinTime = 2f;

	private float shootForce = 50f;

	private float rotateAroundSpeed = 1200f;

	private float randomness = 5f;

	private void Update()
	{
		SpinBall();
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.tag == "Golfball")
		{
			spinBall = true;
			gb = other.GetComponent<Golfball>();
			originalVel = gb.rb.velocity;
			enterHeight = gb.transform.position.y;
		}
	}

	private void SpinBall()
	{
		if (spinBall && gb != null)
		{
			midPoint.RotateAround(base.transform.position, Vector3.up, rotateAroundSpeed * Time.deltaTime);
			Vector3 position = midPoint.position;
			position.y = enterHeight;
			gb.transform.position = Vector3.MoveTowards(gb.transform.position, position, tornadoForce * Time.deltaTime);
			gb.rb.isKinematic = true;
			timer += Time.deltaTime;
			if (timer > spinTime)
			{
				spinBall = false;
				timer = 0f;
				gb.rb.isKinematic = false;
				float num = UnityEngine.Random.Range(shootForce + randomness, shootForce - randomness);
				gb.rb.AddForce(originalVel * num * Time.deltaTime, ForceMode.Impulse);
				gb = null;
			}
		}
	}
}
public class Train : MonoBehaviour
{
	public GameObject trainPrefab;

	public List<GameObject> spawnedTrains = new List<GameObject>();

	public Transform startPos;

	public Transform endPos;

	public float stopInterval = 5f;

	private float stopTimer;

	public float goInterval = 5f;

	private float goTimer;

	private float trainSpawnInterval = 0.5f;

	private float trainSpeed = 10f;

	private float spawnTimer;

	private void Update()
	{
		MoveTrain();
		if (goTimer <= goInterval)
		{
			goTimer += Time.deltaTime;
			SpawnTrain();
		}
		else if (stopTimer <= stopInterval)
		{
			stopTimer += Time.deltaTime;
		}
		else
		{
			stopTimer = 0f;
			goTimer = 0f;
		}
	}

	private void SpawnTrain()
	{
		if (spawnTimer >= trainSpawnInterval)
		{
			spawnTimer = 0f;
			GameObject item = UnityEngine.Object.Instantiate(trainPrefab, startPos.position, startPos.rotation, base.transform);
			spawnedTrains.Add(item);
		}
		else
		{
			spawnTimer += Time.deltaTime;
		}
	}

	private void MoveTrain()
	{
		for (int num = spawnedTrains.Count - 1; num > -1; num--)
		{
			spawnedTrains[num].transform.position = Vector3.MoveTowards(spawnedTrains[num].transform.position, endPos.position, trainSpeed * Time.deltaTime);
			if (Vector3.Distance(spawnedTrains[num].transform.position, endPos.position) < 0.5f)
			{
				UnityEngine.Object.Destroy(spawnedTrains[num]);
				spawnedTrains.RemoveAt(num);
			}
		}
	}
}
public class TransportTube : MonoBehaviour
{
	public float moveSpeed = 100f;

	private void OnTriggerStay(Collider other)
	{
		if (other.tag == "Golfball")
		{
			other.GetComponent<Golfball>().rb.AddForce(base.transform.up * moveSpeed * Time.deltaTime);
			other.GetComponent<Golfball>().rb.useGravity = false;
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (other.tag == "Golfball")
		{
			other.GetComponent<Golfball>().rb.useGravity = true;
		}
	}
}
public class TriggerObject : MonoBehaviour
{
	public Interact objectAction;

	public Interact[] objectActions;

	public UnityEvent eventAction;

	public virtual void OnTriggerEnter(Collider other)
	{
		if (!other.gameObject.CompareTag("Golfball"))
		{
			return;
		}
		if (objectAction != null)
		{
			objectAction.DoInteract(other);
		}
		if (eventAction != null)
		{
			eventAction.Invoke();
		}
		if (objectActions.Length != 0)
		{
			Interact[] array = objectActions;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].DoInteract(other);
			}
		}
	}
}
public class UFO : MonoBehaviour
{
	public float beamForce = 100f;

	public float UFOSpeed = 50f;

	public Transform beamDestination;

	public Transform UFODestination;

	public Transform UFOObj;

	public bool beaming;

	private Golfball gb;

	private float timeTillMove = 1f;

	private bool rechargeBeam;

	private float timeTillBeamAgain = 3f;

	public GameObject beamMesh;

	public bool active;

	private void Update()
	{
		if (!active)
		{
			return;
		}
		if (rechargeBeam)
		{
			beamMesh.SetActive(value: false);
			timeTillBeamAgain -= Time.deltaTime;
			MoveUFOToOriginalPosition();
			if (timeTillBeamAgain <= 0f)
			{
				rechargeBeam = false;
				timeTillBeamAgain = 3f;
			}
		}
		else
		{
			beamMesh.SetActive(value: true);
			BeamBall();
		}
	}

	public void Reset()
	{
		UFOObj.position = base.transform.position;
		beaming = false;
		rechargeBeam = false;
		timeTillMove = 1f;
		timeTillBeamAgain = 3f;
	}

	private void BeamBall()
	{
		if (beaming)
		{
			gb.rb.AddForce((beamDestination.position - gb.transform.position).normalized * beamForce * Time.deltaTime, ForceMode.VelocityChange);
			if (timeTillMove > 0f)
			{
				timeTillMove -= Time.deltaTime;
			}
			else
			{
				MoveUFOToDestination();
			}
		}
		else
		{
			MoveUFOToOriginalPosition();
		}
	}

	private void MoveUFOToDestination()
	{
		UFOObj.position = Vector3.MoveTowards(UFOObj.position, UFODestination.position, UFOSpeed * Time.deltaTime);
		if (Vector3.Distance(UFOObj.position, UFODestination.position) <= 0.1f)
		{
			beaming = false;
			gb = null;
			timeTillMove = 1f;
			rechargeBeam = true;
		}
	}

	private void MoveUFOToOriginalPosition()
	{
		UFOObj.position = base.transform.position;
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.tag == "Golfball")
		{
			beaming = true;
			OBManager.instance.respawnTimer = 0f;
			GameManager.instance.golfball.ResetDrag();
		}
	}

	public void OnTriggerExit(Collider other)
	{
		if (other.tag == "Golfball")
		{
			beaming = false;
			gb = null;
			timeTillMove = 1f;
		}
	}
}
public class Volcano : Cannon
{
	public ParticleSystem explosionPFX;

	public override void LaunchBall()
	{
		base.LaunchBall();
		explosionPFX.Play();
	}
}
public class Waterfall : MonoBehaviour
{
	public float dampeningMultiplier = 2f;

	private void OnTriggerStay(Collider other)
	{
		if (other.tag == "Golfball")
		{
			other.GetComponent<Golfball>().rb.AddForce(Physics.gravity * dampeningMultiplier * Time.deltaTime, ForceMode.Impulse);
		}
	}
}
public class Windmill : MonoBehaviour
{
	public Transform windmillArms;

	public float speed = 1f;

	private MeshRenderer[] bodyMesh;

	private Rigidbody rb;

	private Vector3 m_EulerAngleVelocity = new Vector3(-53f, 0f, 0f);

	public bool useRigidbodyMovement;

	private void Start()
	{
		bodyMesh = GetComponentsInChildren<MeshRenderer>();
		rb = GetComponent<Rigidbody>();
	}

	private void Update()
	{
		if (useRigidbodyMovement)
		{
			Quaternion quaternion = Quaternion.Euler(m_EulerAngleVelocity * Time.deltaTime);
			rb.MoveRotation(quaternion * rb.rotation);
		}
		else
		{
			windmillArms.Rotate(Vector3.up, Time.deltaTime * speed, Space.Self);
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.GetComponent<Camera>() != null)
		{
			MeshRenderer[] array = bodyMesh;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enabled = false;
			}
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (other.GetComponent<Camera>() != null)
		{
			MeshRenderer[] array = bodyMesh;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enabled = true;
			}
		}
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (collision.transform.CompareTag("Golfball"))
		{
			collision.transform.GetComponent<Golfball>().ResetDrag();
		}
	}
}
public class CustomPlaylist : MonoBehaviour
{
	public GameObject keyboard;

	public Text inputText;

	private string tempInputText;

	private Color tempInputColor;

	private ColorBlock tempBackgroundColor;

	private string previousKeyboardText;

	public Text errorMsg;

	public Text createPlaylistInfoText;

	private string playlistsPath;

	private int playlistsCount;

	private static uint playlistSaveFileVersionNumber = 200u;

	private DirectoryInfo[] directories;

	public Camera playlistPreviewImageCamera;

	[HideInInspector]
	public Texture2D playlistPreviewTex;

	private RenderTexture rt;

	public PlaylistPreviewImagePanel playlistPreviewImagePanel;

	public Sprite missingScreenshotSprite;

	public Text holesOrPlaylistText;

	private bool capslock = true;

	private ulong oldPublishID;

	private float caretTimer;

	[Header("Menus")]
	public GameObject updateOrNewMenu;

	public GameObject publishOnlineOrLocalMenu;

	public GameObject confirmPublishMenu;

	public GameObject playlistProgressMenu;

	public GameObject updateExistingPlaylistErrorMenu;

	public Text confirmPublishText;

	[Header("Buttons")]
	public GameObject updatePlaylistButton;

	public GameObject publishBackButton;

	public PlaylistData currentPlaylistData;

	public TextMeshProUGUI[] keyButtons;

	public GameObject createPlaylistButton;

	[Header("Uploading")]
	public GameObject progressBarContainer;

	public Text uploadTimer;

	public Text uploadPercent;

	public Image progressBar;

	private bool startUploadTimer;

	private float timer = 30f;

	private bool publishNew;

	private bool publishOnline;

	public Text playlistCreatedText;

	public Text playlistCreated2Text;

	private bool hasDefaultHoles;

	private bool hasCL1Holes;

	private bool hasCL2Holes;

	private bool hasLocalHoles;

	private void Start()
	{
		rt = new RenderTexture(1024, 768, 0, RenderTextureFormat.ARGB32, RenderTextureReadWrite.sRGB);
		rt.antiAliasing = 4;
		playlistPreviewImageCamera.targetTexture = rt;
		playlistPreviewTex = new Texture2D(1024, 768, TextureFormat.RGB24, mipChain: false);
		playlistsPath = UnityEngine.Application.persistentDataPath + "/playlists/";
		if (!Directory.Exists(playlistsPath))
		{
			Directory.CreateDirectory(playlistsPath);
		}
		DirectoryInfo[] array = (from p in new DirectoryInfo(playlistsPath).GetDirectories()
			orderby p.CreationTime
			select p).ToArray();
		for (int i = 0; i < array.Length; i++)
		{
			FileInfo[] files = array[i].GetFiles("*.clp");
			if (files.Length != 0)
			{
				for (int j = 0; j < files.Length; j++)
				{
					playlistsCount++;
				}
			}
		}
		inputText.text = LocalizationManager.GetTranslation("Name Playlist");
	}

	private void Update()
	{
		if (keyboard.activeSelf)
		{
			inputText.text = CaretText(tempInputText);
		}
		if (startUploadTimer)
		{
			timer -= Time.deltaTime;
			uploadTimer.text = ((int)timer).ToString();
		}
	}

	public void InputKey(string s)
	{
		switch (s)
		{
		case "enter":
			keyboard.SetActive(value: false);
			if (tempInputText.Length == 0 || (tempInputText.Contains("|") && tempInputText.Length == 1))
			{
				tempInputText = LocalizationManager.GetTranslation("Name Playlist");
			}
			else if (tempInputText.Contains("|"))
			{
				tempInputText.Remove(tempInputText.Length - 1);
			}
			inputText.text = tempInputText;
			return;
		case "delete":
			if (tempInputText.Length > 0)
			{
				tempInputText = tempInputText.Substring(0, tempInputText.Length - 1);
			}
			return;
		case "close":
			if (tempInputText.Contains("|"))
			{
				tempInputText.Remove(tempInputText.Length - 1);
			}
			tempInputText = previousKeyboardText;
			inputText.text = tempInputText;
			keyboard.SetActive(value: false);
			return;
		case "caps":
			capslock = !capslock;
			if (capslock)
			{
				TextMeshProUGUI[] array = keyButtons;
				foreach (TextMeshProUGUI obj in array)
				{
					obj.text = obj.text.ToUpper();
				}
			}
			else if (!capslock)
			{
				TextMeshProUGUI[] array = keyButtons;
				foreach (TextMeshProUGUI obj2 in array)
				{
					obj2.text = obj2.text.ToLower();
				}
			}
			return;
		}
		if (tempInputText.Length < 25)
		{
			if (capslock)
			{
				tempInputText += s.ToUpper();
			}
			else
			{
				tempInputText += s.ToLower();
			}
		}
	}

	public void OpenKeyboard()
	{
		if (!keyboard.activeSelf)
		{
			tempInputText = inputText.text;
			previousKeyboardText = inputText.text;
			if (tempInputText == "Name Playlist")
			{
				tempInputText = "";
			}
			keyboard.SetActive(value: true);
		}
	}

	private string CaretText(string text)
	{
		string text2 = text;
		caretTimer += Time.deltaTime;
		if (caretTimer > 1f)
		{
			caretTimer = 0f;
		}
		else if (caretTimer > 0.5f)
		{
			text2 += "|";
		}
		return text2;
	}

	public void UpdateOrNewPlaylist()
	{
		if (inputText.text.Contains("|"))
		{
			inputText.text = inputText.text.Remove(inputText.text.Length - 1);
		}
		hasDefaultHoles = false;
		hasCL1Holes = false;
		hasCL2Holes = false;
		hasLocalHoles = false;
		foreach (Transform usedPickedHoleObject in HoleSelectPanel.instance.usedPickedHoleObjects)
		{
			WorkshopData workshopData = usedPickedHoleObject.GetComponent<HoleButton>().workshopData;
			if (workshopData.defaultHole)
			{
				hasDefaultHoles = true;
			}
			if (workshopData.cloudlandsVersion == 1)
			{
				hasCL1Holes = true;
			}
			if (workshopData.cloudlandsVersion == 2)
			{
				hasCL2Holes = true;
			}
			if (workshopData.localItem)
			{
				hasLocalHoles = true;
			}
			if (hasDefaultHoles && hasCL1Holes && hasCL2Holes)
			{
				break;
			}
		}
		if (hasDefaultHoles)
		{
			StartCoroutine(ShowPlaylistError("Your playlist can only contain custom holes."));
			return;
		}
		if (RemoteServerManager.instance.playerID == "")
		{
			StartCoroutine(ShowPlaylistError("You must be logged in to create playlists."));
			return;
		}
		if (hasCL1Holes)
		{
			StartCoroutine(ShowPlaylistError("You cannot create a playlist with Cloudlands 1 holes"));
			return;
		}
		if (inputText.text.Length == 0 || inputText.text == "Name Playlist")
		{
			StartCoroutine(ShowPlaylistError("You must name your playlist."));
			return;
		}
		if (HoleSelectPanel.instance.usedPickedHoleObjects.childCount < 2)
		{
			StartCoroutine(ShowPlaylistError("You must have at least 2 holes to make a playlist."));
			return;
		}
		if (RemoteServerManager.instance.IsBadWord(inputText.text))
		{
			StartCoroutine(ShowPlaylistError("Your playlist name must not contain a bad word."));
			return;
		}
		if (RemoteServerManager.instance.IsBadWord(RemoteServerManager.instance.playerUserName))
		{
			StartCoroutine(ShowPlaylistError("Your user name must not contain a bad word."));
			return;
		}
		OpenMenu(updateOrNewMenu);
		if (string.IsNullOrEmpty(currentPlaylistData.playlistPath))
		{
			updatePlaylistButton.SetActive(value: false);
			createPlaylistInfoText.text = LocalizationManager.GetTranslation("Would you like to create a new playlist?");
		}
		else
		{
			createPlaylistInfoText.text = LocalizationManager.GetTranslation("Would you like to update the existing playlist or save as a new one?");
			updatePlaylistButton.SetActive(value: true);
			keyboard.SetActive(value: false);
		}
	}

	public void OpenPublishOnlineOrLocal(bool publishAsNew)
	{
		ulong result = 0uL;
		if (RemoteServerManager.instance.playerID != "")
		{
			ulong.TryParse(RemoteServerManager.instance.playerID, out result);
		}
		if (!publishAsNew && currentPlaylistData.creatorId != result && currentPlaylistData.publishedFileId != 0L)
		{
			ShowPlaylistError2("You can only update a playlist that is your own.");
			return;
		}
		OpenMenu(publishOnlineOrLocalMenu);
		publishNew = publishAsNew;
	}

	public void OpenPublishToLocalMenu()
	{
		publishOnline = false;
		ConfirmPublish();
	}

	public void OpenPublishToOnlineMenu()
	{
		if (hasLocalHoles)
		{
			ShowPlaylistError2("Your playlist can only contain holes that have been uploaded online.");
			return;
		}
		OpenMenu(confirmPublishMenu);
		publishOnline = true;
		confirmPublishText.text = LocalizationManager.GetTranslation("Are you sure you want to publish the playlist online?");
	}

	public void ConfirmPublish()
	{
		StartCoroutine(_ConfirmPublish());
	}

	private IEnumerator _ConfirmPublish()
	{
		if (publishOnline)
		{
			playlistCreatedText.text = LocalizationManager.GetTranslation("Publishing...");
			uploadPercent.text = "0%";
			timer = 30f;
			startUploadTimer = true;
			progressBarContainer.SetActive(value: true);
			publishBackButton.SetActive(value: false);
		}
		yield return StartCoroutine(MakePlaylist());
		if (publishOnline)
		{
			string playlistPath = currentPlaylistData.playlistPath;
			playlistPath = playlistPath.Substring(0, currentPlaylistData.playlistPath.Length - currentPlaylistData.playlistName.Length - 4);
			StartCoroutine(RemoteServerManager.instance.UploadPlaylist(playlistPath));
		}
		else
		{
			playlistCreatedText.text = LocalizationManager.GetTranslation("Saved");
			progressBarContainer.SetActive(value: false);
			HoleSelectPanel.instance.customPlaylist.currentPlaylistData = currentPlaylistData;
			HoleSelectPanel.instance.customPlaylist.holesOrPlaylistText.text = LocalizationManager.GetTranslation("Playlist") + ": " + currentPlaylistData.playlistName;
		}
		OpenMenu(playlistProgressMenu);
	}

	public void ShowUploadError()
	{
		playlistCreatedText.text = LocalizationManager.GetTranslation("There was an error uploading the playlist");
		progressBarContainer.SetActive(value: false);
		publishBackButton.SetActive(value: true);
	}

	public void FinishedUpload()
	{
		playlistCreatedText.text = LocalizationManager.GetTranslation("Published");
		uploadPercent.text = "100%";
		Vector3 localScale = progressBar.transform.localScale;
		localScale.x = 1f;
		progressBar.transform.localScale = localScale;
		startUploadTimer = false;
		currentPlaylistData.published = true;
		UpdatePlaylistFilePublishedInfo(currentPlaylistData);
		publishBackButton.SetActive(value: true);
	}

	private IEnumerator ShowPlaylistError(string error)
	{
		errorMsg.transform.parent.gameObject.SetActive(value: true);
		errorMsg.text = LocalizationManager.GetTranslation(error);
		yield return new WaitForSeconds(3f);
		errorMsg.transform.parent.gameObject.SetActive(value: false);
	}

	private void ShowPlaylistError2(string error)
	{
		OpenMenu(updateExistingPlaylistErrorMenu);
		playlistCreated2Text.text = LocalizationManager.GetTranslation(error);
	}

	public void OpenMenu(GameObject x)
	{
		CloseAllMenus();
		x.SetActive(value: true);
	}

	public void CloseAllMenus()
	{
		updateOrNewMenu.SetActive(value: false);
		publishOnlineOrLocalMenu.SetActive(value: false);
		confirmPublishMenu.SetActive(value: false);
		playlistProgressMenu.SetActive(value: false);
		updateExistingPlaylistErrorMenu.SetActive(value: false);
	}

	public void AddWorkshopFileIdToCurrentPlaylist(ulong fileId)
	{
		currentPlaylistData.publishedFileId = fileId;
		if (RemoteServerManager.instance.playerID != "")
		{
			ulong.TryParse(RemoteServerManager.instance.playerID, out currentPlaylistData.creatorId);
		}
		currentPlaylistData.creatorName = RemoteServerManager.instance.playerUserName;
		currentPlaylistData.playlistName = inputText.text;
		UpdatePlaylistFilePublishedInfo(currentPlaylistData);
	}

	private IEnumerator CapturePlaylistPreviewImage(PlaylistData pd)
	{
		playlistPreviewImageCamera.enabled = true;
		playlistPreviewImagePanel.title.text = pd.playlistName;
		playlistPreviewImagePanel.creator.text = LocalizationManager.GetTranslation("By:") + " " + pd.creatorName;
		List<WorkshopData> list = HoleSelectPanel.instance.ReturnWorkshopDataList(HoleSelectPanel.instance.usedPickedHoleObjects);
		for (int i = 0; i < playlistPreviewImagePanel.images.Length; i++)
		{
			if (i < pd.holeCount)
			{
				if (i < list.Count)
				{
					if (list[i].screenshot != null)
					{
						Sprite sprite = Sprite.Create(list[i].screenshot, new Rect(0f, 0f, list[i].screenshot.width, list[i].screenshot.height), new Vector2(0.5f, 0.5f));
						playlistPreviewImagePanel.images[i].sprite = sprite;
					}
					else
					{
						playlistPreviewImagePanel.images[i].sprite = missingScreenshotSprite;
					}
				}
				playlistPreviewImagePanel.images[i].gameObject.SetActive(value: true);
			}
			else
			{
				playlistPreviewImagePanel.images[i].gameObject.SetActive(value: false);
			}
		}
		playlistPreviewImageCamera.targetTexture = rt;
		yield return null;
		yield return null;
		RenderTexture.active = rt;
		playlistPreviewTex.ReadPixels(new Rect(0f, 0f, 1024f, 768f), 0, 0);
		RenderTexture.active = null;
		playlistPreviewImageCamera.targetTexture = null;
		playlistPreviewImageCamera.enabled = false;
	}

	private IEnumerator MakePlaylist()
	{
		if (HoleSelectPanel.instance.usedPickedHoleObjects.childCount > 0 && inputText.text != "" && inputText.text != "Name Playlist")
		{
			Playlist playlist = new Playlist();
			for (int i = 0; i < HoleSelectPanel.instance.usedPickedHoleObjects.childCount; i++)
			{
				WorkshopData workshopData = HoleSelectPanel.instance.usedPickedHoleObjects.GetChild(i).GetComponent<HoleButton>().workshopData;
				playlist.holes.Add(workshopData);
			}
			playlist.playlistName = inputText.text;
			Playlist pl = playlist;
			yield return StartCoroutine(SavePlaylist(pl));
		}
	}

	public static void UpdatePlaylistFilePublishedInfo(PlaylistData pd)
	{
		int num = 12;
		FileStream fileStream = new FileStream(pd.playlistPath, FileMode.Open);
		fileStream.Position = 2L;
		switch ((byte)fileStream.ReadByte())
		{
		case 1:
		{
			int num3 = 28;
			fileStream.Position = num3;
			fileStream.Write(BitConverter.GetBytes(pd.published), 0, 1);
			break;
		}
		case 2:
		{
			int num2 = 34;
			fileStream.Position = num2;
			fileStream.Write(BitConverter.GetBytes(pd.published), 0, 1);
			break;
		}
		default:
			MonoBehaviour.print("unsupported file version");
			break;
		}
		fileStream.Position = num;
		fileStream.Write(BitConverter.GetBytes(pd.publishedFileId), 0, 8);
		fileStream.Flush();
		fileStream.Close();
		HoleSelectPanel.instance.customPlaylist.currentPlaylistData = LoadPlaylistData(pd.playlistPath);
	}

	public IEnumerator SavePlaylist(Playlist pl)
	{
		PlaylistData pd = default(PlaylistData);
		pd.playlistName = inputText.text;
		if (RemoteServerManager.instance.playerID != "")
		{
			pd.creatorName = RemoteServerManager.instance.playerUserName;
		}
		else
		{
			pd.creatorName = "Guest";
		}
		pd.holeCount = (byte)HoleSelectPanel.instance.usedPickedHoleObjects.childCount;
		yield return StartCoroutine(CapturePlaylistPreviewImage(pd));
		oldPublishID = currentPlaylistData.publishedFileId;
		string playlistName = pl.playlistName;
		string creatorName;
		ulong creatorId;
		if (RemoteServerManager.instance.playerID != "")
		{
			creatorName = RemoteServerManager.instance.playerUserName;
			ulong.TryParse(RemoteServerManager.instance.playerID, out creatorId);
		}
		else
		{
			creatorName = "Guest";
			creatorId = 0uL;
		}
		byte[] userIdStringBytes = new byte[0];
		int userIdStringByteCount = 0;
		ushort publishedPlatform = (ushort)GameManager.instance.publishedPlatform;
		ulong publishedFileId = 0uL;
		if (oldPublishID != 0L && !publishNew)
		{
			publishedFileId = oldPublishID;
		}
		bool published = false;
		if (HoleSelectPanel.instance.currentTab != CurrentTab.Local_Holes)
		{
			yield return StartCoroutine(HoleSelectPanel.instance.GetUserCreatedLocalPlaylist(loadUserCreatedPlaylist: false));
			foreach (LocalFiles userCreatedCL2PlaylistFile in HoleSelectPanel.instance.userCreatedCL2PlaylistFiles)
			{
				if (userCreatedCL2PlaylistFile.playlistData.publishedFileId == publishedFileId)
				{
					currentPlaylistData.playlistPath = userCreatedCL2PlaylistFile.path;
				}
			}
		}
		string path;
		if (string.IsNullOrEmpty(currentPlaylistData.playlistPath) || publishNew)
		{
			string text = playlistsPath + playlistsCount + "/";
			while (Directory.Exists(text))
			{
				playlistsCount++;
				text = playlistsPath + playlistsCount + "/";
			}
			playlistsCount++;
			Directory.CreateDirectory(text);
			path = text + playlistName + ".clp";
			if (playlistPreviewTex != null)
			{
				byte[] bytes = playlistPreviewTex.EncodeToJPG(75);
				File.WriteAllBytes(text + "image.jpg", bytes);
			}
		}
		else
		{
			string text = Path.GetDirectoryName(currentPlaylistData.playlistPath);
			if (Directory.Exists(text))
			{
				Directory.Delete(text, recursive: true);
			}
			Directory.CreateDirectory(text);
			path = text + "/" + playlistName + ".clp";
			if (playlistPreviewTex != null)
			{
				byte[] bytes2 = playlistPreviewTex.EncodeToJPG(75);
				File.WriteAllBytes(text + "/" + playlistName + ".jpg", bytes2);
			}
		}
		byte[] bytes3 = Encoding.Unicode.GetBytes(playlistName);
		int num = bytes3.Length;
		byte[] bytes4 = Encoding.Unicode.GetBytes(creatorName);
		int num2 = bytes4.Length;
		int num3 = 46 + num + num2;
		FileStream fileStream = new FileStream(path, FileMode.Create);
		ushort num4 = (ushort)pl.holes.Count;
		bool value = false;
		ushort num5 = 0;
		long ticks = DateTime.UtcNow.Ticks;
		PlaylistHoleInfo[] array = new PlaylistHoleInfo[num4];
		for (int i = 0; i < num4; i++)
		{
			if (pl.holes[i].publishID != 0)
			{
				array[i].holeType = HoleType.Workshop;
				array[i].workshopFileId = (ulong)pl.holes[i].publishID;
				num3 += 9;
				num5 += (ushort)pl.holes[i].par;
			}
			else if (pl.holes[i].localItem && !string.IsNullOrEmpty(pl.holes[i].fileLocation))
			{
				array[i].holeType = HoleType.Local;
				array[i].localFolderPath = pl.holes[i].fileLocation;
				num3 += 5 + Encoding.Unicode.GetBytes(array[i].localFolderPath).Length;
				num5 += (ushort)pl.holes[i].par;
				value = true;
			}
			else if (pl.holes[i].defaultHole)
			{
				array[i].holeType = HoleType.Cloudlands;
				array[i].cloudlandsHole = (byte)pl.holes[i].publishID;
				num3 += 2;
				if (pl.holes[i].publishID >= 0)
				{
					num5 += (ushort)pl.holes[i].par;
				}
			}
		}
		MemoryStream memoryStream = new MemoryStream();
		memoryStream.SetLength(num3);
		memoryStream.Write(BitConverter.GetBytes('C'), 0, 2);
		memoryStream.WriteByte((byte)playlistSaveFileVersionNumber);
		memoryStream.Write(BitConverter.GetBytes(value), 0, 1);
		memoryStream.Write(BitConverter.GetBytes(ticks), 0, 8);
		memoryStream.Write(BitConverter.GetBytes(publishedFileId), 0, 8);
		memoryStream.Write(BitConverter.GetBytes(creatorId), 0, 8);
		memoryStream.Write(BitConverter.GetBytes(userIdStringByteCount), 0, 4);
		memoryStream.Write(BitConverter.GetBytes(publishedPlatform), 0, 2);
		memoryStream.Write(BitConverter.GetBytes(published), 0, 1);
		memoryStream.Write(BitConverter.GetBytes(num5), 0, 2);
		memoryStream.WriteByte((byte)num4);
		memoryStream.Write(BitConverter.GetBytes(num), 0, 4);
		memoryStream.Write(BitConverter.GetBytes(num2), 0, 4);
		if (userIdStringByteCount > 0)
		{
			memoryStream.Write(userIdStringBytes, 0, userIdStringByteCount);
		}
		memoryStream.Write(bytes3, 0, num);
		memoryStream.Write(bytes4, 0, num2);
		for (int j = 0; j < num4; j++)
		{
			memoryStream.WriteByte((byte)array[j].holeType);
			switch (array[j].holeType)
			{
			case HoleType.Cloudlands:
				memoryStream.WriteByte(array[j].cloudlandsHole);
				break;
			case HoleType.Local:
			{
				byte[] bytes5 = Encoding.Unicode.GetBytes(array[j].localFolderPath);
				int value2 = bytes5.Length;
				memoryStream.Write(BitConverter.GetBytes(value2), 0, 4);
				memoryStream.Write(bytes5, 0, bytes5.Length);
				break;
			}
			case HoleType.Workshop:
				memoryStream.Write(BitConverter.GetBytes(array[j].workshopFileId), 0, 8);
				break;
			}
		}
		memoryStream.WriteTo(fileStream);
		fileStream.Flush();
		fileStream.Close();
		memoryStream.Dispose();
		currentPlaylistData = LoadPlaylistData(path);
		if (HoleSelectPanel.instance.currentTab == CurrentTab.Local_Holes && HoleSelectPanel.instance.currentTag == CurrentTag.Playlists)
		{
			StartCoroutine(HoleSelectPanel.instance.GetUserCreatedLocalPlaylist());
		}
	}

	public static PlaylistData LoadPlaylistData(string path, bool cloudlandsPlaylist = false)
	{
		PlaylistData result = default(PlaylistData);
		result.valid = false;
		byte[] buffer = null;
		if (cloudlandsPlaylist)
		{
			TextAsset textAsset = Resources.LoadAll<TextAsset>(path)[0];
			if (textAsset != null)
			{
				buffer = textAsset.bytes;
			}
		}
		else if (File.Exists(path))
		{
			result.playlistPath = path;
			buffer = File.ReadAllBytes(path);
		}
		if (buffer != null)
		{
			if (buffer.Length < 2)
			{
				return result;
			}
			int bufferIndex = 0;
			if (kBufferUtil.ReadChar(ref buffer, ref bufferIndex) != 'C')
			{
				return result;
			}
			if (buffer.Length < 3)
			{
				return result;
			}
			result.versionNumber = kBufferUtil.ReadByte(ref buffer, ref bufferIndex);
			int num = 0;
			if (result.versionNumber != 200)
			{
				MonoBehaviour.print("unsupported version number, update Cloudlands to load this playlist");
				return result;
			}
			int num2 = 46;
			if (buffer.Length < num2)
			{
				return result;
			}
			result.isLocal = kBufferUtil.ReadBool(ref buffer, ref bufferIndex);
			long num3 = kBufferUtil.ReadS64(ref buffer, ref bufferIndex);
			if (num3 < DateTime.MinValue.Ticks || num3 > DateTime.MaxValue.Ticks)
			{
				return result;
			}
			result.saveDate = new DateTime(num3, DateTimeKind.Utc);
			result.publishedFileId = kBufferUtil.ReadU64(ref buffer, ref bufferIndex);
			result.creatorId = kBufferUtil.ReadU64(ref buffer, ref bufferIndex);
			if (result.versionNumber == 200)
			{
				num = kBufferUtil.ReadS32(ref buffer, ref bufferIndex);
				result.publishedPlatform = (PublishedPlatform)kBufferUtil.ReadU16(ref buffer, ref bufferIndex);
			}
			result.published = kBufferUtil.ReadBool(ref buffer, ref bufferIndex);
			result.par = kBufferUtil.ReadU16(ref buffer, ref bufferIndex);
			result.holeCount = kBufferUtil.ReadByte(ref buffer, ref bufferIndex);
			int num4 = kBufferUtil.ReadS32(ref buffer, ref bufferIndex);
			int num5 = kBufferUtil.ReadS32(ref buffer, ref bufferIndex);
			int num6 = num2 + num + num4 + num5;
			if (buffer.Length < num6)
			{
				return result;
			}
			if (result.versionNumber == 200 && num > 0)
			{
				result.userIdString = kBufferUtil.ReadString(ref buffer, ref bufferIndex, num);
			}
			result.playlistName = kBufferUtil.ReadString(ref buffer, ref bufferIndex, num4);
			result.creatorName = kBufferUtil.ReadString(ref buffer, ref bufferIndex, num5);
			result.holeInfo = new PlaylistHoleInfo[result.holeCount];
			for (int i = 0; i < result.holeCount; i++)
			{
				result.holeInfo[i].holeType = (HoleType)kBufferUtil.ReadByte(ref buffer, ref bufferIndex);
				switch (result.holeInfo[i].holeType)
				{
				case HoleType.Cloudlands:
					result.holeInfo[i].cloudlandsHole = kBufferUtil.ReadByte(ref buffer, ref bufferIndex);
					break;
				case HoleType.Local:
				{
					int stringLength = kBufferUtil.ReadS32(ref buffer, ref bufferIndex);
					result.holeInfo[i].localFolderPath = kBufferUtil.ReadString(ref buffer, ref bufferIndex, stringLength);
					break;
				}
				case HoleType.Workshop:
					result.holeInfo[i].workshopFileId = kBufferUtil.ReadU64(ref buffer, ref bufferIndex);
					break;
				}
			}
			result.valid = true;
		}
		else
		{
			MonoBehaviour.print("file doesn't exist");
		}
		return result;
	}
}
public enum HoleType : byte
{
	Cloudlands,
	Local,
	Workshop
}
public struct PlaylistHoleInfo
{
	public HoleType holeType;

	public byte cloudlandsHole;

	public ulong workshopFileId;

	public string localFolderPath;
}
[Serializable]
public struct PlaylistData
{
	public bool valid;

	public byte versionNumber;

	public bool isLocal;

	public DateTime saveDate;

	public ulong publishedFileId;

	public ulong creatorId;

	public PublishedPlatform publishedPlatform;

	public bool published;

	public ushort par;

	public byte holeCount;

	public string userIdString;

	public string playlistName;

	public string creatorName;

	public PlaylistHoleInfo[] holeInfo;

	public string playlistPath;
}
[Serializable]
public class Playlist
{
	public string playlistName;

	public List<WorkshopData> holes = new List<WorkshopData>();
}
public class HoleButton : MonoBehaviour
{
	public Text levelName;

	public Text creatorName;

	public Text pars;

	public Text uploadDate;

	public Text numberRated;

	public Text difficulty;

	public Text holeAmount;

	public RawImage screenshot;

	public Image profilePicture;

	public Image[] stars;

	public GameObject loadingCircles;

	public Color easyColor;

	public Color normalColor;

	public Color hardColor;

	public Color superHardColor;

	public Texture missingScreenshot;

	public Sprite starNoFill;

	public Sprite starHalfFill;

	public Sprite starFullFill;

	public GameObject localItemText;

	public Text holeNumber;

	public WorkshopData workshopData;

	public bool gotScreenshot;

	public bool gotAvatar;

	public bool isError;

	public bool isHole = true;

	public GameObject clubObject;

	public Image driverIcon;

	public Image ironIcon;

	public Image putterIcon;

	public Image windIcon;

	private void OnEnable()
	{
		LocalizationManager.OnLocalizeEvent += OnLocalizationCall;
	}

	private void Update()
	{
		if (!isError && (!gotScreenshot || !gotAvatar))
		{
			GetScreenshotAndAvatar();
		}
	}

	private void OnDisable()
	{
		LocalizationManager.OnLocalizeEvent -= OnLocalizationCall;
		if ((!(GameManager.instance.currentSceneName == "MainMenu") || MainMenu.instance.deleteMenu.confirmDeleteOnlineScreen.activeSelf) && !(GameManager.instance.currentSceneName != "MainMenu"))
		{
			return;
		}
		if (!workshopData.defaultHole && !workshopData.cloudlandsPlaylist)
		{
			if (workshopData.screenshot != null && workshopData.screenshot != missingScreenshot)
			{
				UnityEngine.Object.DestroyImmediate(workshopData.screenshot);
			}
			if (workshopData.avatar != null)
			{
				UnityEngine.Object.DestroyImmediate(workshopData.avatar);
			}
			Sprite sprite = profilePicture.sprite;
			if (sprite != null && sprite.texture != missingScreenshot && sprite != RemoteServerManager.instance.oculusIcon && sprite != RemoteServerManager.instance.steamIcon && sprite != RemoteServerManager.instance.viveportIcon && sprite != RemoteServerManager.instance.xboxIcon && sprite != RemoteServerManager.instance.XRSpaceIcon)
			{
				UnityEngine.Object.DestroyImmediate(profilePicture.sprite);
			}
		}
		workshopData = new WorkshopData();
	}

	public void SetHoleData(WorkshopData data, bool duplicate = false)
	{
		workshopData = DuplicateWorkshopData(data);
		gotScreenshot = false;
		gotAvatar = false;
		SetupHoleType(workshopData);
		levelName.text = workshopData.levelName;
		pars.text = LocalizationManager.GetTranslation("Par") + " " + data.par;
		holeAmount.text = "";
		isHole = true;
		if (workshopData.screenshot != null)
		{
			screenshot.texture = workshopData.screenshot;
		}
		else
		{
			screenshot.texture = missingScreenshot;
		}
		if (workshopData.avatar != null)
		{
			profilePicture.sprite = Sprite.Create(workshopData.avatar, new Rect(0f, 0f, workshopData.avatar.width, workshopData.avatar.height), new Vector2(0.5f, 0.5f), 100f, 0u, SpriteMeshType.FullRect);
		}
	}

	public void SetPlaylistData(WorkshopData data)
	{
		WorkshopData workshopData = DuplicateWorkshopData(data);
		gotScreenshot = false;
		gotAvatar = false;
		isHole = false;
		this.workshopData = workshopData;
		SetupPlaylistType(workshopData);
		levelName.text = workshopData.levelName;
		pars.text = LocalizationManager.GetTranslation("Par") + " " + workshopData.par;
		screenshot.texture = missingScreenshot;
		holeAmount.text = LocalizationManager.GetTranslation("Holes") + ": " + data.holeCount;
		if (workshopData.screenshot != null)
		{
			screenshot.texture = workshopData.screenshot;
		}
		if (workshopData.avatar != null)
		{
			profilePicture.sprite = Sprite.Create(workshopData.avatar, new Rect(0f, 0f, workshopData.avatar.width, workshopData.avatar.height), new Vector2(0.5f, 0.5f), 100f, 0u, SpriteMeshType.FullRect);
		}
	}

	private void SetupPlaylistType(WorkshopData data)
	{
		ResetStars();
		clubObject.SetActive(value: false);
		windIcon.gameObject.SetActive(value: false);
		if (data.cloudlandsPlaylist)
		{
			creatorName.text = "";
			uploadDate.text = "";
			difficulty.text = "";
			profilePicture.gameObject.SetActive(value: false);
			localItemText.SetActive(value: false);
			return;
		}
		creatorName.text = data.creatorName;
		uploadDate.text = data.uploadDate;
		difficulty.text = "";
		SetAvatar(data.publishPlatform);
		if (workshopData.localItem)
		{
			ResetStars();
			localItemText.SetActive(value: true);
		}
		else
		{
			localItemText.SetActive(value: false);
			SetRatings(data.upvotes, data.downvotes);
		}
	}

	private void SetupHoleType(WorkshopData data)
	{
		if (data.defaultHole)
		{
			ResetStars();
			numberRated.text = "";
			creatorName.text = "";
			uploadDate.text = "";
			profilePicture.gameObject.SetActive(value: false);
			localItemText.SetActive(value: false);
		}
		else
		{
			creatorName.text = data.creatorName;
			uploadDate.text = data.uploadDate;
			SetAvatar(data.publishPlatform);
			if (workshopData.localItem)
			{
				ResetStars();
				localItemText.SetActive(value: true);
			}
			else
			{
				localItemText.SetActive(value: false);
				SetRatings(data.upvotes, data.downvotes);
			}
		}
		SetClubIcons();
		SetWindIcon();
		if (data.difficulty == 3)
		{
			this.difficulty.text = LocalizationManager.GetTranslation("Super Hard");
		}
		else
		{
			Text text = this.difficulty;
			Difficulty difficulty = (Difficulty)data.difficulty;
			text.text = LocalizationManager.GetTranslation(difficulty.ToString());
		}
		if (data.difficulty == 0)
		{
			this.difficulty.color = easyColor;
		}
		else if (data.difficulty == 1)
		{
			this.difficulty.color = normalColor;
		}
		else if (data.difficulty == 2)
		{
			this.difficulty.color = hardColor;
		}
		else if (data.difficulty == 3)
		{
			this.difficulty.color = superHardColor;
		}
	}

	private void SetAvatar(int publishPlatform)
	{
		switch (publishPlatform)
		{
		case 0:
			profilePicture.sprite = RemoteServerManager.instance.steamIcon;
			break;
		case 1:
			profilePicture.sprite = RemoteServerManager.instance.oculusIcon;
			break;
		case 2:
			profilePicture.sprite = RemoteServerManager.instance.viveportIcon;
			break;
		case 4:
			profilePicture.sprite = RemoteServerManager.instance.xboxIcon;
			break;
		case 5:
			profilePicture.sprite = RemoteServerManager.instance.XRSpaceIcon;
			break;
		}
		profilePicture.gameObject.SetActive(value: true);
	}

	private void ResetStars()
	{
		numberRated.text = "";
		for (int i = 0; i < stars.Length; i++)
		{
			stars[i].sprite = starNoFill;
			stars[i].gameObject.SetActive(value: false);
		}
	}

	public void SetRatings(float upvotes, float downvotes)
	{
		ResetStars();
		Image[] array = stars;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].gameObject.SetActive(value: true);
		}
		numberRated.text = (upvotes + downvotes).ToString();
		float num = 0f;
		if (upvotes + downvotes != 0f)
		{
			num = upvotes / (upvotes + downvotes) * 5f;
		}
		for (int j = 0; j <= (int)num; j++)
		{
			if (num < 1.25f && num > 0f)
			{
				stars[0].sprite = starFullFill;
			}
			else if (num >= (float)(int)num + 0.25f && num <= (float)(int)num + 0.75f)
			{
				if (j < (int)num)
				{
					stars[j].sprite = starFullFill;
				}
				else
				{
					stars[j].sprite = starHalfFill;
				}
			}
			else if (num >= (float)(int)num + 0.75f && num <= (float)(int)num + 1.25f)
			{
				if (j < (int)num)
				{
					stars[j].sprite = starFullFill;
				}
				else
				{
					stars[j].sprite = starHalfFill;
				}
			}
			else if (num >= (float)(int)num - 0.25f && num <= (float)(int)num + 0.25f && j < (int)num)
			{
				stars[j].sprite = starFullFill;
			}
		}
	}

	private void SetClubIcons()
	{
		clubObject.SetActive(value: true);
		if (workshopData.cloudlandsVersion == 1)
		{
			putterIcon.gameObject.SetActive(value: true);
			driverIcon.gameObject.SetActive(value: false);
			ironIcon.gameObject.SetActive(value: false);
			return;
		}
		GolfClubType golfClubType = workshopData.golfClubType;
		if ((golfClubType & GolfClubType.Driver) == GolfClubType.Driver)
		{
			driverIcon.gameObject.SetActive(value: true);
		}
		else
		{
			driverIcon.gameObject.SetActive(value: false);
		}
		if ((golfClubType & GolfClubType.Iron) == GolfClubType.Iron)
		{
			ironIcon.gameObject.SetActive(value: true);
		}
		else
		{
			ironIcon.gameObject.SetActive(value: false);
		}
		if ((golfClubType & GolfClubType.Putter) == GolfClubType.Putter)
		{
			putterIcon.gameObject.SetActive(value: true);
		}
		else
		{
			putterIcon.gameObject.SetActive(value: false);
		}
	}

	private void SetWindIcon()
	{
		if (workshopData.cloudlandsVersion == 1)
		{
			windIcon.gameObject.SetActive(value: false);
		}
		else if (workshopData.cloudlandsVersion == 2)
		{
			if (workshopData.wind)
			{
				windIcon.gameObject.SetActive(value: true);
			}
			else
			{
				windIcon.gameObject.SetActive(value: false);
			}
		}
	}

	public void UpdateScreenshot()
	{
		loadingCircles.SetActive(value: false);
		gotScreenshot = true;
		screenshot.texture = workshopData.screenshot;
	}

	public WorkshopData DuplicateWorkshopData(WorkshopData data)
	{
		WorkshopData workshopData = new WorkshopData();
		workshopData.cloudlandsMobileHole = data.cloudlandsMobileHole;
		workshopData.cloudlandsPCHole = data.cloudlandsPCHole;
		workshopData.defaultHole = data.defaultHole;
		workshopData.cloudlandsPlaylist = data.cloudlandsPlaylist;
		workshopData.creatorID = data.creatorID;
		workshopData.creatorName = data.creatorName;
		workshopData.difficulty = data.difficulty;
		workshopData.holeCount = data.holeCount;
		workshopData.holeIds = data.holeIds;
		workshopData.imageLocation = data.imageLocation;
		workshopData.levelName = data.levelName;
		workshopData.localItem = data.localItem;
		workshopData.par = data.par;
		workshopData.pieceCount = data.pieceCount;
		workshopData.fileLocation = data.fileLocation;
		workshopData.publishID = data.publishID;
		workshopData.publishPlatform = data.publishPlatform;
		workshopData.uploadDate = data.uploadDate;
		workshopData.downvotes = data.downvotes;
		workshopData.upvotes = data.upvotes;
		workshopData.workshopRating = data.workshopRating;
		workshopData.cloudlandsVersion = data.cloudlandsVersion;
		workshopData.golfClubType = data.golfClubType;
		workshopData.visible = data.visible;
		workshopData.wind = data.wind;
		if (!data.defaultHole || data.cloudlandsPlaylist)
		{
			if (data.screenshot != null && workshopData.screenshot == null && (data.defaultHole || string.IsNullOrEmpty(data.screenshot.name)))
			{
				workshopData.screenshot = new Texture2D(data.screenshot.width, data.screenshot.height, data.screenshot.format, mipChain: false);
				Graphics.CopyTexture(data.screenshot, workshopData.screenshot);
			}
			if (data.avatar != null && workshopData.avatar == null && string.IsNullOrEmpty(data.avatar.name))
			{
				workshopData.avatar = new Texture2D(data.avatar.width, data.avatar.height, data.avatar.format, mipChain: false);
				Graphics.CopyTexture(data.avatar, workshopData.avatar);
			}
		}
		return workshopData;
	}

	public static WorkshopData DeepCopyWorkshopData(WorkshopData data)
	{
		WorkshopData workshopData = new WorkshopData();
		workshopData.cloudlandsPCHole = data.cloudlandsPCHole;
		workshopData.cloudlandsMobileHole = data.cloudlandsMobileHole;
		workshopData.publishID = data.publishID;
		workshopData.publishPlatform = data.publishPlatform;
		workshopData.creatorName = data.creatorName;
		workshopData.creatorID = data.creatorID;
		workshopData.levelName = data.levelName;
		workshopData.par = data.par;
		workshopData.upvotes = data.upvotes;
		workshopData.downvotes = data.downvotes;
		workshopData.difficulty = data.difficulty;
		workshopData.pieceCount = data.pieceCount;
		workshopData.uploadDate = data.uploadDate;
		workshopData.fileLocation = data.fileLocation;
		workshopData.imageLocation = data.imageLocation;
		workshopData.defaultHole = data.defaultHole;
		workshopData.cloudlandsPlaylist = data.cloudlandsPlaylist;
		workshopData.localItem = data.localItem;
		workshopData.workshopRating = data.workshopRating;
		workshopData.holeCount = data.holeCount;
		workshopData.holeIds = data.holeIds;
		workshopData.cloudlandsVersion = data.cloudlandsVersion;
		workshopData.golfClubType = data.golfClubType;
		workshopData.visible = data.visible;
		workshopData.wind = data.wind;
		if (data.screenshot != null && (data.defaultHole || string.IsNullOrEmpty(data.screenshot.name)))
		{
			workshopData.screenshot = new Texture2D(data.screenshot.width, data.screenshot.height, data.screenshot.format, mipChain: false);
			Graphics.CopyTexture(data.screenshot, workshopData.screenshot);
		}
		if (data.avatar != null && string.IsNullOrEmpty(data.avatar.name))
		{
			workshopData.avatar = new Texture2D(data.avatar.width, data.avatar.height, data.avatar.format, mipChain: false);
			if (data.publishPlatform != 2)
			{
				Graphics.CopyTexture(data.avatar, workshopData.avatar);
			}
		}
		return workshopData;
	}

	private void GetScreenshotAndAvatar()
	{
		if (!gotScreenshot)
		{
			if (workshopData.defaultHole || workshopData.cloudlandsPlaylist)
			{
				Texture texture = null;
				if (workshopData.cloudlandsPlaylist)
				{
					texture = Resources.LoadAll<Texture>(workshopData.imageLocation)[0];
				}
				else if (workshopData.defaultHole)
				{
					texture = Resources.LoadAll<Texture>("Holes/" + workshopData.imageLocation)[0];
				}
				workshopData.screenshot = (Texture2D)texture;
				screenshot.texture = workshopData.screenshot;
				gotScreenshot = true;
				gotAvatar = true;
				loadingCircles.SetActive(value: false);
			}
			else
			{
				loadingCircles.SetActive(value: true);
				if (workshopData.screenshot != null)
				{
					loadingCircles.SetActive(value: false);
					gotScreenshot = true;
					screenshot.texture = workshopData.screenshot;
				}
			}
		}
		if (gotAvatar)
		{
			return;
		}
		if (workshopData.avatar != null)
		{
			if (!workshopData.defaultHole && !workshopData.cloudlandsPlaylist)
			{
				gotAvatar = true;
				profilePicture.sprite = Sprite.Create(workshopData.avatar, new Rect(0f, 0f, workshopData.avatar.width, workshopData.avatar.height), new Vector2(0.5f, 0.5f), 100f, 0u, SpriteMeshType.FullRect);
			}
		}
		else if (workshopData.publishPlatform == 2)
		{
			gotAvatar = true;
		}
	}

	public void SetHoleNumber(int num)
	{
		holeNumber.text = "#" + num;
	}

	private void OnLocalizationCall()
	{
		pars.text = LocalizationManager.GetTranslation("Par") + " " + workshopData.par;
		if (isHole)
		{
			if (workshopData.difficulty == 3)
			{
				this.difficulty.text = LocalizationManager.GetTranslation("Super Hard");
				return;
			}
			Text text = this.difficulty;
			Difficulty difficulty = (Difficulty)workshopData.difficulty;
			text.text = LocalizationManager.GetTranslation(difficulty.ToString());
		}
		else
		{
			holeAmount.text = LocalizationManager.GetTranslation("Holes") + ": " + workshopData.holeCount;
		}
	}
}
public class HoleSelectPanel : MonoBehaviour
{
	public static HoleSelectPanel instance;

	public ScrollList availableLevelList;

	public ScrollList pickedLevelList;

	public ScrollList playlistLevelList;

	public GameObject holeButtonPrefab;

	public GameObject errorHoleButtonPrefab;

	public RectTransform unusedAvailableHoleObjects;

	public RectTransform usedAvailableHoleObjects;

	public RectTransform unusedPickedHoleObjects;

	public RectTransform usedPickedHoleObjects;

	public RectTransform unusedPlaylistHoleObjects;

	public RectTransform usedPlaylistHoleObjects;

	public RectTransform unusedPlaylistErrorHoleObjects;

	private List<ImageStore> screenshotImages = new List<ImageStore>();

	private List<AvatarStore> avatarImages = new List<AvatarStore>();

	public uint currentPage = 1u;

	private int itemsPerPage = 50;

	public bool querying;

	private bool downloadingImages;

	private bool gameStarting;

	public CurrentTag currentTag;

	public CurrentTab currentTab;

	public TabButton[] tabButtons;

	public TabButton[] tagButtons;

	public TabButton[] cloudlandVersionButtons;

	public GameObject searchButton;

	public GameObject pageNavigation;

	public GameObject pageBackButton;

	public GameObject pageNextButton;

	public Text pageText;

	public GameObject readyButton;

	public GameObject randomButtons;

	public GameObject searchFilter;

	private SearchFilter searchFilterScript;

	[Header("==Local Files==")]
	private List<LocalFiles> userCreatedCL2HoleFiles = new List<LocalFiles>();

	[HideInInspector]
	public List<LocalFiles> userCreatedCL2PlaylistFiles = new List<LocalFiles>();

	private List<LocalFiles> downloadedCL1HoleFiles = new List<LocalFiles>();

	private List<LocalFiles> downloadedCL1PlaylistFiles = new List<LocalFiles>();

	private List<LocalFiles> downloadedCL2HoleFiles = new List<LocalFiles>();

	private List<LocalFiles> downloadedCL2PlaylistFiles = new List<LocalFiles>();

	private bool hasCheckedLocalCreatedCL2HoleFiles;

	private bool hasCheckedDownloadedCL1HoleFiles;

	private bool hasCheckedDownloadedCL2HoleFiles;

	[Header("==Downloads==")]
	public GameObject downloadProgressPanel;

	public Text downloadTimerText;

	public DownloadBars[] downloadBars;

	public bool downloading;

	public int downloadsNeeded;

	private float downloadTimer;

	private double serverDownloadStartTime;

	[Header("==Playlist Preview==")]
	public CustomPlaylist customPlaylist;

	public PlaylistPreview playlistPreviewScript;

	public bool unsavedPlaylistChanges;

	public WorkshopData currentPlaylist = new WorkshopData();

	[HideInInspector]
	public WorkshopData _currentPlaylist = new WorkshopData();

	public GameObject loadingCircles;

	public GameObject startMessage;

	public Text searchErrorText;

	public PlayerListPanel playerListPanel;

	private Coroutine downloadAvailableListScreenshotsCoroutine;

	private Coroutine downloadPickedListScreenshotsCoroutine;

	private Coroutine downloadPlaylistScreenshotsCoroutine;

	private Coroutine downloadAvatarsCoroutine;

	private Thread thread;

	private string dataPath = "";

	private void Awake()
	{
		instance = this;
	}

	private IEnumerator Start()
	{
		GameManager.instance.gameMode = GameMode.Custom;
		for (int i = 0; i < 54; i++)
		{
			GameObject button2 = UnityEngine.Object.Instantiate(holeButtonPrefab, unusedAvailableHoleObjects);
			button2.GetComponent<PointerButton>().onClickEvent.AddListener(delegate
			{
				OnAvailableButtonSelected(button2.GetComponent<HoleButton>().workshopData);
			});
			button2.SetActive(value: false);
			button2.transform.localPosition = Vector3.zero;
		}
		for (int j = 0; j < 18; j++)
		{
			GameObject button3 = UnityEngine.Object.Instantiate(holeButtonPrefab, unusedPickedHoleObjects);
			button3.GetComponent<PointerButton>().onClickEvent.AddListener(delegate
			{
				OnPickedButtonSelected(button3.transform);
			});
			button3.SetActive(value: false);
			button3.transform.localPosition = Vector3.zero;
		}
		for (int k = 0; k < 18; k++)
		{
			GameObject obj = UnityEngine.Object.Instantiate(errorHoleButtonPrefab, unusedPlaylistErrorHoleObjects);
			obj.SetActive(value: false);
			obj.transform.localPosition = Vector3.zero;
		}
		for (int l = 0; l < 18; l++)
		{
			GameObject button = UnityEngine.Object.Instantiate(holeButtonPrefab, unusedPlaylistHoleObjects);
			button.GetComponent<PointerButton>().onClickEvent.AddListener(delegate
			{
				OnPlaylistPreviewButtonSelected(button.GetComponent<HoleButton>().workshopData);
			});
			button.SetActive(value: false);
			button.transform.localPosition = Vector3.zero;
		}
		searchFilterScript = searchFilter.GetComponent<SearchFilter>();
		yield return new WaitForEndOfFrame();
		SwitchToCloudlandsTab(tabButtons[0]);
		UpdatePickedOnlineLevels();
		GameManager.instance.holeDataServerLocation.Clear();
		RemoteServerManager.instance.downloadsCompleted = 0;
		GameManager.instance.ResetMulligans();
		if (PhotonNetwork.IsConnected)
		{
			tabButtons[2].gameObject.SetActive(value: false);
			tabButtons[5].gameObject.SetActive(value: false);
			PhotonNetwork.LocalPlayer.SetDownloadFinished(value: false);
			PhotonNetwork.LocalPlayer.SetDownloadProgress(0);
			ScoreManager.instance.ResetStrokeTable();
			new List<WorkshopData>();
			RichPresenceManager.instance.SetOnlineRoomDestination(PhotonNetwork.CurrentRoom.Name, PhotonNetwork.CurrentRoom.PlayerCount);
		}
		if (!string.IsNullOrEmpty(RichPresenceManager.instance.customHoleID))
		{
			List<int> holeIDs = new List<int> { int.Parse(RichPresenceManager.instance.customHoleID) };
			RemoteServerManager.instance.queryPlaylistHolesCoroutine = StartCoroutine(RemoteServerManager.instance.QueryPlaylistHoles(holeIDs, showAllHoles: false, searchFilterScript.searchFilters, delegate
			{
				CreateWorkshopLevelInPickedList(RemoteServerManager.instance.workshopDetails);
				if (PhotonNetwork.IsMasterClient)
				{
					PhotonNetwork.CurrentRoom.SetHoles(ReturnWorkshopDataList(usedPickedHoleObjects));
				}
			}));
			RichPresenceManager.instance.customHoleID = "";
		}
		customPlaylist.holesOrPlaylistText.text = LocalizationManager.GetTranslation("Holes");
	}

	private void Update()
	{
		if (downloading)
		{
			UpdateDownloadProgress();
			if (PhotonNetwork.IsConnected && AllPlayersFinishDownloading())
			{
				downloading = false;
				if (PhotonNetwork.IsMasterClient)
				{
					if (!RichPresenceManager.instance.inParty)
					{
						PhotonNetwork.CurrentRoom.IsVisible = true;
					}
					PhotonNetwork.CurrentRoom.LoadNextLevel(isNewGame: true);
					startMessage.SetActive(value: true);
				}
			}
			if (downloadTimer <= 0f)
			{
				downloading = false;
				StopCoroutine(RemoteServerManager.instance.downloadHolesCoroutine);
				if (PhotonNetwork.IsConnected)
				{
					GameManager.instance.BackToLobby();
				}
				else
				{
					GameManager.instance.BackToMainMenu();
				}
				Notification.instance.AddNotification("Failed to download workshop hole within time limit", 0f, closeButton: true);
			}
		}
		ToggleReadyButton();
		if (querying)
		{
			loadingCircles.SetActive(value: true);
		}
	}

	public void OnAvailableButtonSelected(WorkshopData data)
	{
		if (gameStarting)
		{
			return;
		}
		if (currentTag == CurrentTag.Holes)
		{
			if ((PhotonNetwork.IsMasterClient || !PhotonNetwork.InRoom) && usedPickedHoleObjects.childCount < 18)
			{
				SetHoleButton(unusedPickedHoleObjects.GetChild(0).gameObject, data, usedPickedHoleObjects, duplicate: true);
				StartCoroutine(ScrollToBottom(pickedLevelList));
				currentPlaylist = new WorkshopData();
				_currentPlaylist = new WorkshopData();
				customPlaylist.holesOrPlaylistText.text = LocalizationManager.GetTranslation("Holes");
				if (PhotonNetwork.IsMasterClient)
				{
					PhotonNetwork.CurrentRoom.SetHoles(ReturnWorkshopDataList(usedPickedHoleObjects));
					PhotonNetwork.CurrentRoom.SetPlaylist(currentPlaylist);
				}
			}
		}
		else if (currentTag == CurrentTag.Playlists)
		{
			if (currentTab == CurrentTab.Online || currentTab == CurrentTab.Favorite || currentTab == CurrentTab.Your_Holes || currentTab == CurrentTab.Downloaded)
			{
				playlistPreviewScript.loadPlaylistButton.SetActive(value: false);
				StartCoroutine(RemoteServerManager.instance.DownloadPlaylist(data, delegate(string path)
				{
					PlaylistPreview(path, data);
				}));
			}
			else
			{
				PlaylistPreview(data.fileLocation, data);
			}
		}
		SetHoleOrderNumber(usedPickedHoleObjects);
	}

	public void OnAddRandomHoles(int holeAmount)
	{
		if (!PhotonNetwork.IsMasterClient && PhotonNetwork.InRoom)
		{
			return;
		}
		if (currentTag == CurrentTag.Holes)
		{
			ClearPlaylistData();
			searchFilterScript.CloseDropdown();
			List<int> list = GameManager.instance.GenerateRandomNumbers(holeAmount, 0, usedAvailableHoleObjects.childCount);
			for (int i = 0; i < list.Count; i++)
			{
				if (usedPickedHoleObjects.childCount < 18)
				{
					_ = unusedPickedHoleObjects.GetChild(0).gameObject;
					SetHoleButton(unusedPickedHoleObjects.GetChild(0).gameObject, usedAvailableHoleObjects.GetChild(list[i]).GetComponent<HoleButton>().workshopData, usedPickedHoleObjects);
				}
			}
			StartCoroutine(ScrollToBottom(pickedLevelList));
			if (PhotonNetwork.IsMasterClient)
			{
				PhotonNetwork.CurrentRoom.SetHoles(ReturnWorkshopDataList(usedPickedHoleObjects));
				PhotonNetwork.CurrentRoom.SetPlaylist(currentPlaylist);
			}
		}
		SetHoleOrderNumber(usedAvailableHoleObjects);
	}

	public void OnPlaylistPreviewButtonSelected(WorkshopData data)
	{
		if (!gameStarting && (PhotonNetwork.IsMasterClient || !PhotonNetwork.InRoom) && usedPickedHoleObjects.childCount < 18)
		{
			SetHoleButton(unusedPickedHoleObjects.GetChild(0).gameObject, data, usedPickedHoleObjects);
			StartCoroutine(ScrollToBottom(pickedLevelList));
			SetHoleOrderNumber(usedPickedHoleObjects);
			customPlaylist.holesOrPlaylistText.text = LocalizationManager.GetTranslation("Holes");
			if (PhotonNetwork.IsMasterClient)
			{
				PhotonNetwork.CurrentRoom.SetHoles(ReturnWorkshopDataList(usedPickedHoleObjects));
				PhotonNetwork.CurrentRoom.SetPlaylist(currentPlaylist);
			}
		}
	}

	public void OnLoadPlaylistButton()
	{
		if (gameStarting)
		{
			return;
		}
		bool flag = false;
		if (gameStarting || (!PhotonNetwork.IsMasterClient && PhotonNetwork.InRoom))
		{
			return;
		}
		while (usedPickedHoleObjects.childCount > 0)
		{
			usedPickedHoleObjects.GetChild(0).gameObject.SetActive(value: false);
			usedPickedHoleObjects.GetChild(0).SetParent(unusedPickedHoleObjects);
		}
		for (int i = 0; i < usedPlaylistHoleObjects.childCount; i++)
		{
			if (usedPickedHoleObjects.childCount < 18)
			{
				HoleButton component = usedPlaylistHoleObjects.GetChild(i).GetComponent<HoleButton>();
				if (component != null)
				{
					WorkshopData workshopData = component.workshopData;
					SetHoleButton(unusedPickedHoleObjects.GetChild(0).gameObject, workshopData, usedPickedHoleObjects);
				}
				else
				{
					flag = true;
				}
			}
		}
		StartCoroutine(ScrollToBottom(pickedLevelList));
		SetHoleOrderNumber(usedPickedHoleObjects);
		playlistPreviewScript.gameObject.SetActive(value: false);
		DownloadImages(usedPickedHoleObjects);
		if (!flag)
		{
			currentPlaylist = _currentPlaylist;
			customPlaylist.holesOrPlaylistText.text = LocalizationManager.GetTranslation("Playlist") + ": " + currentPlaylist.levelName;
			customPlaylist.currentPlaylistData = CustomPlaylist.LoadPlaylistData(playlistPreviewScript.plData.playlistPath);
			customPlaylist.inputText.text = currentPlaylist.levelName;
		}
		else
		{
			ClearPlaylistData();
		}
		if (PhotonNetwork.IsMasterClient)
		{
			PhotonNetwork.CurrentRoom.SetPlaylist(currentPlaylist);
			PhotonNetwork.CurrentRoom.SetHoles(ReturnWorkshopDataList(usedPickedHoleObjects));
		}
	}

	public void OnBackButton()
	{
		if (PhotonNetwork.IsConnected)
		{
			GameManager.instance.BackToLobby();
		}
		else
		{
			GameManager.instance.BackToMainMenu();
		}
	}

	private void PlaylistPreview(string path, WorkshopData data = null)
	{
		ClearPlaylistPreviewList();
		StartCoroutine(ScrollToTop(playlistLevelList));
		if (currentTab == CurrentTab.Cloudlands)
		{
			PlaylistData playlistData = CustomPlaylist.LoadPlaylistData(path, cloudlandsPlaylist: true);
			new List<WorkshopData>();
			int num = 0;
			if (path == "Playlists/Playlist2")
			{
				num = 18;
			}
			else if (path == "Playlists/Playlist3")
			{
				num = 36;
			}
			for (int i = 0; i < 18; i++)
			{
				SetHoleButton(unusedPlaylistHoleObjects.GetChild(0).gameObject, GameManager.instance.campaignWorkshopData[num + i], usedPlaylistHoleObjects);
			}
			playlistPreviewScript.FillCloudlandPlaylistDetails(playlistData, data);
			SetHoleOrderNumber(usedPlaylistHoleObjects);
			return;
		}
		PlaylistData playlistData2 = CustomPlaylist.LoadPlaylistData(path);
		playlistPreviewScript.FillPlaylistDetails(playlistData2, data);
		List<PlaylistPublishIDOrder> playlistPublishIDOrder = new List<PlaylistPublishIDOrder>();
		List<int> list = new List<int>();
		for (int j = 0; j < playlistData2.holeCount; j++)
		{
			PlaylistPublishIDOrder playlistPublishIDOrder2 = new PlaylistPublishIDOrder();
			if (playlistData2.holeInfo[j].holeType == HoleType.Workshop)
			{
				playlistPublishIDOrder2.publishFileID = (int)playlistData2.holeInfo[j].workshopFileId;
				playlistPublishIDOrder2.order = j;
				playlistPublishIDOrder.Add(playlistPublishIDOrder2);
				list.Add((int)playlistData2.holeInfo[j].workshopFileId);
			}
			else
			{
				if (playlistData2.holeInfo[j].holeType != HoleType.Local)
				{
					continue;
				}
				string imagePath = "";
				DirectoryInfo[] directories = new DirectoryInfo(playlistData2.holeInfo[j].localFolderPath).GetDirectories();
				for (int k = 0; k < directories.Length; k++)
				{
					FileInfo[] files = directories[k].Parent.GetFiles("*.jpg");
					if (files.Length != 0)
					{
						imagePath = files[0].FullName;
					}
				}
				CustomLevel level = LevelEditor.LoadLevelData(playlistData2.holeInfo[j].localFolderPath);
				SetHoleButton(unusedPlaylistHoleObjects.GetChild(0).gameObject, CreateButtonFromCustomLevel(level, playlistData2.holeInfo[j].localFolderPath, imagePath), usedPlaylistHoleObjects);
			}
		}
		RemoteServerManager.instance.queryPlaylistHolesCoroutine = StartCoroutine(RemoteServerManager.instance.QueryPlaylistHoles(list, showAllHoles: true, searchFilterScript.searchFilters, delegate(bool completed)
		{
			if (completed)
			{
				CreateLevelsFromWorkshopData(RemoteServerManager.instance.workshopDetails, downloadImages: false);
				StartCoroutine(ScrollToTop(playlistLevelList));
				_ = playlistPublishIDOrder;
				List<Transform> list2 = new List<Transform>();
				foreach (Transform usedPlaylistHoleObject in usedPlaylistHoleObjects)
				{
					list2.Add(usedPlaylistHoleObject);
				}
				for (int l = 0; l < playlistPublishIDOrder.Count; l++)
				{
					for (int m = 0; m < list2.Count; m++)
					{
						HoleButton component = list2[m].GetComponent<HoleButton>();
						if (component != null && component.workshopData.publishID == playlistPublishIDOrder[l].publishFileID)
						{
							list2[m].SetSiblingIndex(playlistPublishIDOrder[l].order);
							list2.RemoveAt(m);
							break;
						}
					}
				}
				playlistPreviewScript.gotAllHoles = true;
				DownloadImages(usedPlaylistHoleObjects);
				SetHoleOrderNumber(usedPlaylistHoleObjects);
			}
			else
			{
				SetErrorHoleButton("There was an error loading the hole");
				playlistPreviewScript.gotAllHoles = true;
			}
			if (usedPlaylistHoleObjects.childCount == 0)
			{
				MonoBehaviour.print("No playlist holes");
			}
		}));
	}

	public void ClearPlaylistPreviewList()
	{
		while (usedPlaylistHoleObjects.childCount > 0)
		{
			usedPlaylistHoleObjects.GetChild(0).gameObject.SetActive(value: false);
			if (usedPlaylistHoleObjects.GetChild(0).GetComponent<HoleButton>() != null)
			{
				usedPlaylistHoleObjects.GetChild(0).SetParent(unusedPlaylistHoleObjects);
			}
			else
			{
				usedPlaylistHoleObjects.GetChild(0).SetParent(unusedPlaylistErrorHoleObjects);
			}
		}
	}

	public void OnPickedButtonSelected(Transform button)
	{
		if (!gameStarting && (PhotonNetwork.IsMasterClient || !PhotonNetwork.InRoom))
		{
			button.SetParent(unusedPickedHoleObjects);
			button.gameObject.SetActive(value: false);
			pickedLevelList.UpdateButtonColliders();
			SetHoleOrderNumber(usedPickedHoleObjects);
			currentPlaylist = new WorkshopData();
			_currentPlaylist = new WorkshopData();
			customPlaylist.holesOrPlaylistText.text = LocalizationManager.GetTranslation("Holes");
			if (PhotonNetwork.IsMasterClient)
			{
				PhotonNetwork.CurrentRoom.SetHoles(ReturnWorkshopDataList(usedPickedHoleObjects));
				PhotonNetwork.CurrentRoom.SetPlaylist(currentPlaylist);
			}
			SetHoleOrderNumber(usedPickedHoleObjects);
		}
	}

	public void OnReadyButton()
	{
		if (!PhotonNetwork.IsMasterClient && PhotonNetwork.InRoom)
		{
			return;
		}
		if (PhotonNetwork.IsMasterClient)
		{
			if (AllPlayersReady())
			{
				PhotonNetwork.CurrentRoom.IsVisible = false;
				DownloadHoles();
				RoomRPC.instance.pView.RPC("OnReadyButton", RpcTarget.Others);
			}
		}
		else
		{
			DownloadHoles();
		}
	}

	private void ThreadedLocalHoles()
	{
		DirectoryInfo[] array = (from p in new DirectoryInfo(dataPath).GetDirectories()
			orderby p.CreationTimeUtc descending
			select p).ToArray();
		foreach (DirectoryInfo obj in array)
		{
			LocalFiles localFiles = new LocalFiles();
			FileInfo[] files = obj.GetFiles("*.dat");
			FileInfo[] files2 = obj.GetFiles("*.jpg");
			if (files.Length == 0)
			{
				continue;
			}
			localFiles.path = files[0].FullName;
			localFiles.customLevel = LevelEditor.LoadLevelData(files[0].FullName);
			if (localFiles.customLevel.valid && localFiles.customLevel.completed)
			{
				if (files2.Length != 0)
				{
					localFiles.jpgPath = files2[0].FullName;
				}
				userCreatedCL2HoleFiles.Add(localFiles);
			}
		}
		MonoBehaviour.print("Finished loading threaded local holes");
		thread.Abort();
		thread = null;
	}

	public void GetUserCreatedLocalHoles()
	{
		StartCoroutine(_GetUserCreatedLocalHoles());
	}

	private IEnumerator _GetUserCreatedLocalHoles()
	{
		if (!hasCheckedLocalCreatedCL2HoleFiles)
		{
			hasCheckedLocalCreatedCL2HoleFiles = true;
			dataPath = UnityEngine.Application.persistentDataPath + "/levels/";
			if (Directory.Exists(dataPath))
			{
				ClearAvailableList();
				loadingCircles.SetActive(value: true);
				if (thread != null)
				{
					thread.Abort();
					thread = null;
				}
				thread = new Thread(ThreadedLocalHoles);
				thread.Start();
				while (thread.IsAlive)
				{
					yield return null;
				}
				loadingCircles.SetActive(value: false);
				LoadUserCreatedHoles();
			}
			else
			{
				SetErrorMessage("Could not find any holes");
				ClearAvailableList();
				LoadUserCreatedHoles();
			}
		}
		else
		{
			ClearAvailableList();
			LoadUserCreatedHoles();
		}
	}

	private void ThreadedLocalPlaylists()
	{
		DirectoryInfo[] array = (from p in new DirectoryInfo(dataPath).GetDirectories()
			orderby p.CreationTimeUtc descending
			select p).ToArray();
		foreach (DirectoryInfo obj in array)
		{
			LocalFiles localFiles = new LocalFiles();
			FileInfo[] files = obj.GetFiles("*.clp");
			FileInfo[] files2 = obj.GetFiles("*.jpg");
			if (files.Length != 0)
			{
				localFiles.path = files[0].FullName;
				localFiles.playlistData = CustomPlaylist.LoadPlaylistData(localFiles.path);
				if (files2.Length != 0)
				{
					localFiles.jpgPath = files2[0].FullName;
				}
				userCreatedCL2PlaylistFiles.Add(localFiles);
			}
		}
		MonoBehaviour.print("Finished loading threaded local playlists");
		thread.Abort();
	}

	public IEnumerator GetUserCreatedLocalPlaylist(bool loadUserCreatedPlaylist = true)
	{
		dataPath = UnityEngine.Application.persistentDataPath + "/playlists/";
		if (Directory.Exists(dataPath))
		{
			if (loadUserCreatedPlaylist)
			{
				ClearAvailableList();
			}
			userCreatedCL2PlaylistFiles.Clear();
			loadingCircles.SetActive(value: true);
			if (thread != null)
			{
				thread.Abort();
				thread = null;
			}
			thread = new Thread(ThreadedLocalPlaylists);
			thread.Start();
			while (thread.IsAlive)
			{
				yield return null;
			}
			loadingCircles.SetActive(value: false);
			if (loadUserCreatedPlaylist)
			{
				LoadUserCreatedPlaylist();
			}
		}
		else if (loadUserCreatedPlaylist)
		{
			ClearAvailableList();
			LoadUserCreatedPlaylist();
		}
	}

	private void LoadUserCreatedHoles()
	{
		int num = 0;
		List<int> list = new List<int>();
		for (int i = itemsPerPage * (int)(currentPage - 1); i < itemsPerPage + itemsPerPage * (int)(currentPage - 1) && i < userCreatedCL2HoleFiles.Count; i++)
		{
			num++;
		}
		if (num == 0)
		{
			SetErrorMessage("Could not find any holes");
		}
		Mathf.CeilToInt((float)userCreatedCL2HoleFiles.Count / (float)itemsPerPage);
		SetPageButtons(num, userCreatedCL2HoleFiles.Count);
		for (int j = itemsPerPage * (int)(currentPage - 1); j < itemsPerPage + itemsPerPage * (int)(currentPage - 1) && j < userCreatedCL2HoleFiles.Count; j++)
		{
			SetHoleButton(unusedAvailableHoleObjects.GetChild(0).gameObject, CreateButtonFromCustomLevel(userCreatedCL2HoleFiles[j].customLevel, userCreatedCL2HoleFiles[j].path, userCreatedCL2HoleFiles[j].jpgPath), usedAvailableHoleObjects);
			list.Add((int)userCreatedCL2HoleFiles[j].customLevel.publishedFileId);
		}
		RemoteServerManager.instance.queryPlaylistHolesCoroutine = StartCoroutine(RemoteServerManager.instance.QueryPlaylistHoles(list, showAllHoles: false, searchFilterScript.searchFilters, delegate
		{
			SetButtonRatings(usedAvailableHoleObjects);
			SetButtonRatings(usedPickedHoleObjects);
		}));
		SetHoleOrderNumber(usedAvailableHoleObjects);
		StartCoroutine(ScrollToTop(availableLevelList));
		DownloadImages(usedAvailableHoleObjects);
	}

	private void LoadUserCreatedPlaylist()
	{
		ClearAvailableList();
		int num = 0;
		for (int i = itemsPerPage * (int)(currentPage - 1); i < itemsPerPage + itemsPerPage * (int)(currentPage - 1) && i < userCreatedCL2PlaylistFiles.Count; i++)
		{
			num++;
		}
		if (num == 0)
		{
			SetErrorMessage("Could not find any playlists");
		}
		Mathf.CeilToInt((float)userCreatedCL2PlaylistFiles.Count / (float)itemsPerPage);
		SetPageButtons(num, userCreatedCL2PlaylistFiles.Count);
		for (int j = itemsPerPage * (int)(currentPage - 1); j < itemsPerPage + itemsPerPage * (int)(currentPage - 1) && j < userCreatedCL2PlaylistFiles.Count; j++)
		{
			SetPlaylistButton(unusedAvailableHoleObjects.GetChild(0).gameObject, CreateButtonFromPlaylistData(userCreatedCL2PlaylistFiles[j].playlistData, userCreatedCL2PlaylistFiles[j].path, userCreatedCL2PlaylistFiles[j].jpgPath), usedAvailableHoleObjects);
		}
		SetHoleOrderNumber(usedAvailableHoleObjects);
		StartCoroutine(ScrollToTop(availableLevelList));
		DownloadImages(usedAvailableHoleObjects);
	}

	public void DownloadHoles()
	{
		downloadTimer = 300f;
		gameStarting = true;
		GameManager.instance.holeData.Clear();
		ClearWorkshopImages();
		List<WorkshopData> list = new List<WorkshopData>();
		foreach (Transform usedPickedHoleObject in usedPickedHoleObjects)
		{
			if (!usedPickedHoleObject.GetComponent<HoleButton>().workshopData.defaultHole)
			{
				WorkshopData workshopData = usedPickedHoleObject.GetComponent<HoleButton>().workshopData;
				list.Add(workshopData);
				GameManager.instance.holeDataServerLocation.Add(new WorkshopURLLocation
				{
					holeLocation = workshopData.fileLocation,
					imageLocation = workshopData.imageLocation
				});
			}
		}
		GameManager.instance.holeData = ReturnWorkshopDataList(usedPickedHoleObjects);
		RemoteServerManager.instance.downloadHolesCoroutine = StartCoroutine(RemoteServerManager.instance.DownloadHole(list));
		RemoteServerManager.instance.downloadRatingsCoroutine = StartCoroutine(RemoteServerManager.instance.GetRatingData(list));
		GetWorkshopHoleAmount();
	}

	public List<WorkshopData> ReturnWorkshopDataList(RectTransform list, bool deepCopy = false)
	{
		List<WorkshopData> list2 = new List<WorkshopData>();
		for (int i = 0; i < list.childCount; i++)
		{
			HoleButton component = list.GetChild(i).GetComponent<HoleButton>();
			if (component != null)
			{
				if (deepCopy)
				{
					list2.Add(HoleButton.DeepCopyWorkshopData(component.workshopData));
				}
				else
				{
					list2.Add(component.workshopData);
				}
			}
		}
		return list2;
	}

	public void SetFilePaths()
	{
		MonoBehaviour.print("Done download");
		List<WorkshopData> holeData = ReturnWorkshopDataList(usedPickedHoleObjects, deepCopy: true);
		GameManager.instance.holeData = holeData;
		ScoreManager.instance.SetHolePars();
		if (PhotonNetwork.IsConnected)
		{
			PhotonNetwork.LocalPlayer.SetDownloadFinished(value: true);
		}
		else
		{
			downloading = false;
			startMessage.SetActive(value: true);
			GameManager.instance.LoadNextHole(incrementHole: false);
		}
		GameManager.instance.playlistLeaderboardData = currentPlaylist;
		List<WorkshopData> data = new List<WorkshopData> { GameManager.instance.playlistLeaderboardData };
		RemoteServerManager.instance.downloadRatingsCoroutine = StartCoroutine(RemoteServerManager.instance.GetRatingData(data, isPlaylist: true));
		GameManager.instance.SetMulligans();
		StartCoroutine(SetUnfinishedDownloadedQueriedImages());
	}

	public void GetWorkshopHoleAmount()
	{
		if (downloadsNeeded > 0)
		{
			SetupDownloadBars();
		}
		downloading = true;
	}

	private void ThreadedDownloadedHoles()
	{
		DirectoryInfo[] array = (from p in new DirectoryInfo(dataPath).GetDirectories()
			orderby p.CreationTimeUtc descending
			select p).ToArray();
		foreach (DirectoryInfo obj in array)
		{
			FileInfo[] files = obj.GetFiles("*.dat");
			FileInfo[] files2 = obj.GetFiles("*.jpg");
			if (files.Length == 0)
			{
				continue;
			}
			int sortCloudlandsVersion = searchFilterScript.sortCloudlandsVersion;
			bool flag = false;
			LocalFiles localFiles = new LocalFiles();
			switch (sortCloudlandsVersion)
			{
			case 1:
			{
				CustomLevelCL1 customLevelCL = LevelEditor.LoadCL1LevelData(files[0].FullName);
				if (customLevelCL.valid && customLevelCL.completed)
				{
					flag = true;
					localFiles.customLevelCL1 = customLevelCL;
				}
				break;
			}
			case 2:
			{
				CustomLevel customLevel = LevelEditor.LoadLevelData(files[0].FullName);
				if (customLevel.valid && customLevel.completed)
				{
					flag = true;
					localFiles.customLevel = customLevel;
				}
				break;
			}
			}
			if (flag)
			{
				localFiles.path = files[0].FullName;
				if (files2.Length != 0)
				{
					localFiles.jpgPath = files2[0].FullName;
				}
				if (sortCloudlandsVersion == 1)
				{
					downloadedCL1HoleFiles.Add(localFiles);
				}
				else
				{
					downloadedCL2HoleFiles.Add(localFiles);
				}
			}
		}
		MonoBehaviour.print("Finished loading threaded downloaded holes");
		thread.Abort();
		thread = null;
	}

	private IEnumerator GetDownloadedHoleFiles()
	{
		if (searchFilterScript.searchFilters.CloudlandsVersion == 1)
		{
			StartCoroutine(ToggleTags(toggleTags: false, toggleVersion: true, showSearch: false));
		}
		else if (searchFilterScript.searchFilters.CloudlandsVersion == 2)
		{
			StartCoroutine(ToggleTags(toggleTags: true, toggleVersion: true, showSearch: false));
		}
		int num = 2;
		bool flag;
		if (searchFilterScript.sortCloudlandsVersion == 1)
		{
			flag = hasCheckedDownloadedCL1HoleFiles;
			num = 1;
		}
		else
		{
			flag = hasCheckedDownloadedCL2HoleFiles;
		}
		if (!flag)
		{
			if (num == 1)
			{
				hasCheckedDownloadedCL1HoleFiles = true;
			}
			else
			{
				hasCheckedDownloadedCL2HoleFiles = true;
			}
			if (num == 1)
			{
				dataPath = UnityEngine.Application.persistentDataPath + "/Downloads/Cloudlands1/Holes/";
			}
			else
			{
				dataPath = UnityEngine.Application.persistentDataPath + "/Downloads/Cloudlands2/Holes/";
			}
			if (Directory.Exists(dataPath))
			{
				loadingCircles.SetActive(value: true);
				if (thread != null)
				{
					thread.Abort();
					thread = null;
				}
				thread = new Thread(ThreadedDownloadedHoles);
				thread.Start();
				while (thread.IsAlive)
				{
					yield return null;
				}
				loadingCircles.SetActive(value: false);
				PopulateDownloadedTab();
			}
			else
			{
				SetErrorMessage("Could not find any holes");
			}
		}
		else
		{
			PopulateDownloadedTab();
		}
		StartCoroutine(ScrollToTop(availableLevelList));
	}

	private void ThreadedDownloadedPlaylists()
	{
		DirectoryInfo[] array = (from p in new DirectoryInfo(dataPath).GetDirectories()
			orderby p.CreationTimeUtc descending
			select p).ToArray();
		foreach (DirectoryInfo obj in array)
		{
			FileInfo[] files = obj.GetFiles("*.jpg");
			FileInfo[] files2 = obj.GetFiles("*.clp");
			if (files2.Length != 0)
			{
				LocalFiles localFiles = new LocalFiles();
				localFiles.path = files2[0].FullName;
				localFiles.playlistData = CustomPlaylist.LoadPlaylistData(localFiles.path);
				if (files.Length != 0)
				{
					localFiles.jpgPath = files[0].FullName;
				}
				if (searchFilterScript.searchFilters.CloudlandsVersion == 1)
				{
					downloadedCL1PlaylistFiles.Add(localFiles);
				}
				else
				{
					downloadedCL2PlaylistFiles.Add(localFiles);
				}
			}
		}
		MonoBehaviour.print("Finished loading threaded downloaded playlists");
		thread.Abort();
		thread = null;
	}

	private IEnumerator GetDownloadedPlaylistFiles()
	{
		if (searchFilterScript.searchFilters.CloudlandsVersion == 1)
		{
			StartCoroutine(ToggleTags(toggleTags: false, toggleVersion: true, showSearch: false));
		}
		else if (searchFilterScript.searchFilters.CloudlandsVersion == 2)
		{
			StartCoroutine(ToggleTags(toggleTags: true, toggleVersion: true, showSearch: false));
		}
		if (searchFilterScript.searchFilters.CloudlandsVersion == 1)
		{
			dataPath = UnityEngine.Application.persistentDataPath + "/Downloads/Cloudlands1/Playlists/";
		}
		else
		{
			dataPath = UnityEngine.Application.persistentDataPath + "/Downloads/Cloudlands2/Playlists/";
		}
		if (Directory.Exists(dataPath))
		{
			if (searchFilterScript.searchFilters.CloudlandsVersion == 1)
			{
				downloadedCL1PlaylistFiles.Clear();
			}
			else
			{
				downloadedCL2PlaylistFiles.Clear();
			}
			ClearAvailableList();
			loadingCircles.SetActive(value: true);
			if (thread != null)
			{
				thread.Abort();
				thread = null;
			}
			thread = new Thread(ThreadedDownloadedPlaylists);
			thread.Start();
			while (thread.IsAlive)
			{
				yield return null;
			}
			loadingCircles.SetActive(value: false);
		}
		else
		{
			SetErrorMessage("Could not find any playlists");
		}
		PopulateDownloadedTab();
		StartCoroutine(ScrollToTop(availableLevelList));
	}

	public void SwitchToDownloadedTab(TabButton tab)
	{
		ResetNewQueryVariables();
		currentTab = CurrentTab.Downloaded;
		if (searchFilterScript.sortCloudlandsVersion == 1)
		{
			currentTag = CurrentTag.Holes;
		}
		if (currentTag == CurrentTag.Holes)
		{
			SwitchToHolesTag(tab);
		}
		else
		{
			SwitchToPlaylistTag(tab);
		}
		SetActiveTab(tab);
	}

	public void SwitchToCloudlandsTab(TabButton tab)
	{
		ResetNewQueryVariables();
		currentTab = CurrentTab.Cloudlands;
		ClearAvailableList();
		PopulateCloudlandsTab();
		SetActiveTab(tab);
		SetActiveTag();
	}

	public void SwitchToFavoriteTab(TabButton tab)
	{
		ResetNewQueryVariables();
		currentTab = CurrentTab.Favorite;
		ClearAvailableList();
		QueryWorkshopFavorites();
		SetActiveTab(tab);
		SetActiveTag();
	}

	private void PopulateCloudlandsTab()
	{
		StartCoroutine(ToggleTags(toggleTags: true, toggleVersion: false, showSearch: false));
		ClearAvailableList();
		if (currentTag == CurrentTag.Holes)
		{
			for (int i = 0; i < 54; i++)
			{
				SetHoleButton(unusedAvailableHoleObjects.GetChild(0).gameObject, GameManager.instance.campaignWorkshopData[i], usedAvailableHoleObjects);
			}
			SetPageButtons(0, 0);
		}
		else
		{
			for (int j = 0; j < 3; j++)
			{
				PlaylistData level = CustomPlaylist.LoadPlaylistData("Playlists/Playlist" + (j + 1), cloudlandsPlaylist: true);
				WorkshopData workshopData = CreateButtonFromPlaylistData(level, "Playlists/Playlist" + (j + 1), "Playlists/Playlist" + (j + 1));
				level.publishedFileId = (ulong)(j + 1);
				workshopData.publishID = j + 1;
				workshopData.cloudlandsPlaylist = true;
				workshopData.defaultHole = true;
				workshopData.fileLocation = "Playlists/Playlist" + (j + 1);
				SetPlaylistButton(unusedAvailableHoleObjects.GetChild(0).gameObject, workshopData, usedAvailableHoleObjects);
			}
			SetPageButtons(0, 0);
		}
		availableLevelList.UpdateButtonColliders();
		StartCoroutine(ScrollToTop(availableLevelList));
		SetHoleOrderNumber(usedAvailableHoleObjects);
	}

	private void PopulateDownloadedTab()
	{
		ClearAvailableList();
		int num = 0;
		List<LocalFiles> files = new List<LocalFiles>();
		if (currentTag == CurrentTag.Holes)
		{
			if (searchFilterScript.searchFilters.CloudlandsVersion == 1)
			{
				files = downloadedCL1HoleFiles;
			}
			else
			{
				files = downloadedCL2HoleFiles;
			}
			List<int> list = new List<int>();
			if (files.Count > 0)
			{
				WorkshopData workshopData = new WorkshopData();
				for (int i = itemsPerPage * (int)(currentPage - 1); i < itemsPerPage + itemsPerPage * (int)(currentPage - 1) && i < files.Count; i++)
				{
					num++;
					if (searchFilterScript.searchFilters.CloudlandsVersion == 1)
					{
						workshopData = CreateButtonFromCustomLevelCL1(files[i].customLevelCL1, files[i].path, files[i].jpgPath);
					}
					else if (searchFilterScript.searchFilters.CloudlandsVersion == 2)
					{
						workshopData = CreateButtonFromCustomLevel(files[i].customLevel, files[i].path, files[i].jpgPath);
					}
					list.Add(workshopData.publishID);
					SetHoleButton(unusedAvailableHoleObjects.GetChild(0).gameObject, workshopData, usedAvailableHoleObjects);
				}
				if (PhotonNetwork.IsConnected)
				{
					ClearAvailableList();
					RemoteServerManager.instance.queryPlaylistHolesCoroutine = StartCoroutine(RemoteServerManager.instance.QueryPlaylistHoles(list, showAllHoles: true, searchFilterScript.searchFilters, delegate
					{
						CreateLevelsFromWorkshopData(RemoteServerManager.instance.workshopDetails);
						SetPageButtons(RemoteServerManager.instance.workshopDetails.Count, files.Count);
					}));
				}
				else
				{
					DownloadImages(usedAvailableHoleObjects);
					SetPageButtons(num, files.Count);
					RemoteServerManager.instance.queryPlaylistHolesCoroutine = StartCoroutine(RemoteServerManager.instance.QueryPlaylistHoles(list, showAllHoles: false, searchFilterScript.searchFilters, delegate
					{
						SetButtonRatings(usedAvailableHoleObjects);
						SetButtonRatings(usedPickedHoleObjects);
					}));
				}
				SetHoleOrderNumber(usedAvailableHoleObjects);
			}
			else
			{
				SetErrorMessage("Could not find any holes");
			}
		}
		else if (currentTag == CurrentTag.Playlists)
		{
			if (searchFilterScript.searchFilters.CloudlandsVersion == 1)
			{
				files = downloadedCL1PlaylistFiles;
			}
			else
			{
				files = downloadedCL2PlaylistFiles;
			}
			if (files.Count > 0)
			{
				for (int j = itemsPerPage * (int)(currentPage - 1); j < itemsPerPage + itemsPerPage * (int)(currentPage - 1) && j < files.Count; j++)
				{
					num++;
					SetPlaylistButton(unusedAvailableHoleObjects.GetChild(0).gameObject, CreateButtonFromPlaylistData(files[j].playlistData, files[j].path, files[j].jpgPath), usedAvailableHoleObjects);
				}
				DownloadImages(usedAvailableHoleObjects);
				SetPageButtons(num, files.Count);
			}
			else
			{
				SetErrorMessage("Could not find any playlists");
			}
		}
		availableLevelList.UpdateButtonColliders();
	}

	public void SwitchToOnlineTab(TabButton tab)
	{
		ResetNewQueryVariables();
		currentTab = CurrentTab.Online;
		if (searchFilterScript.sortCloudlandsVersion == 1)
		{
			currentTag = CurrentTag.Holes;
		}
		if (currentTag == CurrentTag.Holes)
		{
			SwitchToHolesTag(tab);
		}
		else
		{
			SwitchToPlaylistTag(tab);
		}
		SetActiveTab(tab);
	}

	public void SwitchToYourHolesTab(TabButton tab)
	{
		ResetNewQueryVariables();
		if (searchFilterScript.sortCloudlandsVersion == 1)
		{
			currentTag = CurrentTag.Holes;
		}
		currentTab = CurrentTab.Your_Holes;
		if (currentTag == CurrentTag.Holes)
		{
			SwitchToHolesTag(tab);
		}
		else
		{
			SwitchToPlaylistTag(tab);
		}
		SetActiveTab(tab);
	}

	public void SwitchToLocalHolesTab(TabButton tab)
	{
		ResetNewQueryVariables();
		searchFilterScript.sortCloudlandsVersion = 2;
		currentTab = CurrentTab.Local_Holes;
		if (currentTag == CurrentTag.Holes)
		{
			SwitchToHolesTag(tab);
		}
		else
		{
			SwitchToPlaylistTag(tab);
		}
		SetActiveTab(tab);
	}

	private void QueryWorkshop()
	{
		if (searchFilterScript.searchFilters.CloudlandsVersion == 1)
		{
			StartCoroutine(ToggleTags(toggleTags: false, toggleVersion: true, showSearch: true));
		}
		else if (searchFilterScript.searchFilters.CloudlandsVersion == 2)
		{
			StartCoroutine(ToggleTags(toggleTags: true, toggleVersion: true, showSearch: true));
		}
		if (querying)
		{
			return;
		}
		querying = true;
		downloadingImages = false;
		ClearAvailableList();
		if (currentTag == CurrentTag.Holes)
		{
			StartCoroutine(RemoteServerManager.instance.QueryWorkshopHoles(currentPage, searchFilterScript.searchFilters, delegate(bool complete)
			{
				if (complete)
				{
					CreateLevelsFromWorkshopData(RemoteServerManager.instance.workshopDetails);
					availableLevelList.UpdateButtonColliders();
					SetHoleOrderNumber(usedAvailableHoleObjects);
				}
				else if (UnityEngine.Application.internetReachability == NetworkReachability.NotReachable)
				{
					SetErrorMessage("Could not connect to server. Please check internet connectivity or try again later.");
				}
				else
				{
					SetErrorMessage("Could not find any holes");
				}
				querying = false;
				loadingCircles.SetActive(value: false);
			}));
		}
		else
		{
			if (currentTag != CurrentTag.Playlists)
			{
				return;
			}
			StartCoroutine(RemoteServerManager.instance.QueryWorkshopPlaylists(currentPage, searchFilterScript.searchFilters, delegate(bool complete)
			{
				ClearAvailableList();
				if (complete)
				{
					CreatePlaylistsFromWorkshopData(RemoteServerManager.instance.workshopDetails);
					availableLevelList.UpdateButtonColliders();
					SetHoleOrderNumber(usedAvailableHoleObjects);
				}
				else if (UnityEngine.Application.internetReachability == NetworkReachability.NotReachable)
				{
					SetErrorMessage("Could not connect to server. Please check internet connectivity or try again later.");
				}
				else
				{
					SetErrorMessage("Could not find any playlists");
				}
				querying = false;
				loadingCircles.SetActive(value: false);
			}));
		}
	}

	public void SwitchToCloudlandsVersion(int version)
	{
		ResetNewQueryVariables();
		if ((currentTab == CurrentTab.Online || currentTab == CurrentTab.Downloaded || currentTab == CurrentTab.Your_Holes || currentTab == CurrentTab.Favorite) && currentTag == CurrentTag.Playlists && version == 1)
		{
			currentTag = CurrentTag.Holes;
			SetActiveTag();
		}
		searchFilterScript.SortByCloudlandsVersion(version);
	}

	private void QueryWorkshopFavorites()
	{
		if (searchFilterScript.searchFilters.CloudlandsVersion == 1)
		{
			StartCoroutine(ToggleTags(toggleTags: false, toggleVersion: true, showSearch: true));
		}
		else if (searchFilterScript.searchFilters.CloudlandsVersion == 2)
		{
			StartCoroutine(ToggleTags(toggleTags: true, toggleVersion: true, showSearch: true));
		}
		if (querying)
		{
			return;
		}
		querying = true;
		downloadingImages = false;
		ClearAvailableList();
		StartCoroutine(RemoteServerManager.instance.QueryFavoriteHoles(currentPage, currentTag == CurrentTag.Playlists, searchFilterScript.searchFilters, delegate(bool complete)
		{
			ClearAvailableList();
			if (complete)
			{
				if (RemoteServerManager.instance.workshopDetails.Count == 0)
				{
					if (currentTag == CurrentTag.Holes)
					{
						SetErrorMessage("Could not find any holes");
					}
					else
					{
						SetErrorMessage("Could not find any playlists");
					}
				}
				else
				{
					if (currentTag == CurrentTag.Holes)
					{
						CreateLevelsFromWorkshopData(RemoteServerManager.instance.workshopDetails);
					}
					else
					{
						CreatePlaylistsFromWorkshopData(RemoteServerManager.instance.workshopDetails);
					}
					availableLevelList.UpdateButtonColliders();
					SetHoleOrderNumber(usedAvailableHoleObjects);
				}
			}
			else if (UnityEngine.Application.internetReachability == NetworkReachability.NotReachable)
			{
				SetErrorMessage("Could not connect to server. Please check internet connectivity or try again later.");
			}
			else if (RemoteServerManager.instance.playerID == "")
			{
				SetErrorMessage("You must be logged in to query your favorite holes");
			}
			else if (currentTag == CurrentTag.Holes)
			{
				SetErrorMessage("Could not find any holes");
			}
			else
			{
				SetErrorMessage("Could not find any playlists");
			}
			querying = false;
			loadingCircles.SetActive(value: false);
		}));
	}

	public void QueryUserItems()
	{
		if (searchFilterScript.searchFilters.CloudlandsVersion == 1)
		{
			StartCoroutine(ToggleTags(toggleTags: false, toggleVersion: true, showSearch: true));
		}
		else if (searchFilterScript.searchFilters.CloudlandsVersion == 2)
		{
			StartCoroutine(ToggleTags(toggleTags: true, toggleVersion: true, showSearch: true));
		}
		if (querying)
		{
			return;
		}
		querying = true;
		downloadingImages = false;
		ClearAvailableList();
		if (currentTag == CurrentTag.Holes)
		{
			StartCoroutine(RemoteServerManager.instance.QueryUserHoles(currentPage, searchFilterScript.searchFilters, delegate(bool complete)
			{
				ClearAvailableList();
				if (complete)
				{
					if (RemoteServerManager.instance.workshopDetails.Count == 0)
					{
						SetErrorMessage("Could not find any holes");
					}
					else
					{
						CreateLevelsFromWorkshopData(RemoteServerManager.instance.workshopDetails);
						availableLevelList.UpdateButtonColliders();
						SetHoleOrderNumber(usedAvailableHoleObjects);
					}
				}
				else if (UnityEngine.Application.internetReachability == NetworkReachability.NotReachable)
				{
					SetErrorMessage("Could not connect to server. Please check internet connectivity or try again later.");
				}
				else if (RemoteServerManager.instance.playerID == "")
				{
					SetErrorMessage("You must be logged in to query your holes");
				}
				else
				{
					SetErrorMessage("Could not find any holes");
				}
				querying = false;
				loadingCircles.SetActive(value: false);
			}));
		}
		else
		{
			if (currentTag != CurrentTag.Playlists)
			{
				return;
			}
			StartCoroutine(RemoteServerManager.instance.QueryUserPlaylists(currentPage, searchFilterScript.searchFilters, delegate(bool complete)
			{
				if (complete)
				{
					CreatePlaylistsFromWorkshopData(RemoteServerManager.instance.workshopDetails);
					availableLevelList.UpdateButtonColliders();
					SetHoleOrderNumber(usedAvailableHoleObjects);
				}
				else if (UnityEngine.Application.internetReachability == NetworkReachability.NotReachable)
				{
					SetErrorMessage("Could not connect to server. Please check internet connectivity or try again later.");
				}
				else
				{
					SetErrorMessage("Could not find any playlists");
				}
				querying = false;
				loadingCircles.SetActive(value: false);
			}));
		}
	}

	public void Search(SearchFilters searchFilters)
	{
		searchErrorText.text = "";
		downloadingImages = false;
		currentPage = 1u;
		ClearAvailableList();
		if (currentTab == CurrentTab.Online)
		{
			QueryWorkshop();
		}
		else if (currentTab == CurrentTab.Favorite)
		{
			QueryWorkshopFavorites();
		}
		else if (currentTab == CurrentTab.Downloaded)
		{
			if (currentTag == CurrentTag.Holes)
			{
				StartCoroutine(GetDownloadedHoleFiles());
			}
			else if (currentTag == CurrentTag.Playlists)
			{
				StartCoroutine(GetDownloadedPlaylistFiles());
			}
		}
		else if (currentTab == CurrentTab.Your_Holes)
		{
			QueryUserItems();
		}
	}

	private void ClearAvailableList()
	{
		while (usedAvailableHoleObjects.childCount > 0)
		{
			HoleButton component = usedAvailableHoleObjects.GetChild(0).GetComponent<HoleButton>();
			if (component.workshopData.screenshot != null && !component.workshopData.defaultHole)
			{
				UnityEngine.Object.DestroyImmediate(component.workshopData.screenshot);
			}
			if (component.workshopData.avatar != null)
			{
				UnityEngine.Object.DestroyImmediate(component.workshopData.avatar);
			}
			usedAvailableHoleObjects.GetChild(0).gameObject.SetActive(value: false);
			usedAvailableHoleObjects.GetChild(0).SetParent(unusedAvailableHoleObjects);
		}
	}

	public void ClearPickedList()
	{
		if (PhotonNetwork.IsMasterClient || !PhotonNetwork.InRoom)
		{
			while (usedPickedHoleObjects.childCount > 0)
			{
				usedPickedHoleObjects.GetChild(0).gameObject.SetActive(value: false);
				usedPickedHoleObjects.GetChild(0).SetParent(unusedPickedHoleObjects);
			}
			ClearPlaylistData();
			if (PhotonNetwork.InRoom)
			{
				PhotonNetwork.CurrentRoom.SetHoles(ReturnWorkshopDataList(usedPickedHoleObjects));
				PhotonNetwork.CurrentRoom.SetPlaylist(currentPlaylist);
			}
		}
	}

	private void ClearPlaylistData()
	{
		currentPlaylist = new WorkshopData();
		_currentPlaylist = new WorkshopData();
		customPlaylist.currentPlaylistData = default(PlaylistData);
		customPlaylist.holesOrPlaylistText.text = LocalizationManager.GetTranslation("Holes");
		customPlaylist.inputText.text = LocalizationManager.GetTranslation("Name Playlist");
	}

	private void SetActiveTab(TabButton tab)
	{
		TabButton[] array = tabButtons;
		foreach (TabButton tabButton in array)
		{
			if (tabButton == tab)
			{
				tabButton.Active(x: true);
			}
			else
			{
				tabButton.Active(x: false);
			}
		}
		availableLevelList.UpdateButtonColliders();
	}

	private void SetActiveTag()
	{
		if (currentTag == CurrentTag.Holes)
		{
			tagButtons[0].Active(x: true);
			tagButtons[1].Active(x: false);
			randomButtons.SetActive(value: true);
		}
		else
		{
			tagButtons[0].Active(x: false);
			tagButtons[1].Active(x: true);
			randomButtons.SetActive(value: false);
		}
	}

	public void SwitchToHolesTag(TabButton tab)
	{
		ResetNewQueryVariables();
		currentPage = 1u;
		currentTag = CurrentTag.Holes;
		ClearAvailableList();
		tagButtons[0].Active(x: true);
		tagButtons[1].Active(x: false);
		if (currentTab == CurrentTab.Cloudlands)
		{
			PopulateCloudlandsTab();
		}
		else if (currentTab == CurrentTab.Online)
		{
			SwitchSearchTags();
			QueryWorkshop();
			searchFilterScript.SetCloudlandsVersionTab();
		}
		else if (currentTab == CurrentTab.Downloaded)
		{
			if (currentTag == CurrentTag.Holes)
			{
				StartCoroutine(GetDownloadedHoleFiles());
			}
			else if (currentTag == CurrentTag.Playlists)
			{
				StartCoroutine(GetDownloadedPlaylistFiles());
			}
			searchFilterScript.SetCloudlandsVersionTab();
		}
		else if (currentTab == CurrentTab.Your_Holes)
		{
			QueryUserItems();
			searchFilterScript.SetCloudlandsVersionTab();
		}
		else if (currentTab == CurrentTab.Local_Holes)
		{
			PopulateLocalHolesTab();
		}
		else if (currentTab == CurrentTab.Favorite)
		{
			SwitchSearchTags();
			QueryWorkshopFavorites();
		}
		randomButtons.SetActive(value: true);
	}

	private void PopulateLocalHolesTab()
	{
		if (searchFilterScript.searchFilters.CloudlandsVersion == 1)
		{
			StartCoroutine(ToggleTags(toggleTags: false, toggleVersion: false, showSearch: false));
		}
		else if (searchFilterScript.searchFilters.CloudlandsVersion == 2)
		{
			StartCoroutine(ToggleTags(toggleTags: true, toggleVersion: false, showSearch: false));
		}
		if (currentTag == CurrentTag.Playlists)
		{
			StartCoroutine(GetUserCreatedLocalPlaylist());
		}
		else
		{
			GetUserCreatedLocalHoles();
		}
		StartCoroutine(ScrollToTop(availableLevelList));
	}

	public void SwitchToPlaylistTag(TabButton tab)
	{
		ResetNewQueryVariables();
		currentPage = 1u;
		currentTag = CurrentTag.Playlists;
		ClearAvailableList();
		tagButtons[0].Active(x: false);
		tagButtons[1].Active(x: true);
		if (currentTab == CurrentTab.Cloudlands)
		{
			PopulateCloudlandsTab();
		}
		else if (currentTab == CurrentTab.Downloaded)
		{
			StartCoroutine(GetDownloadedPlaylistFiles());
			searchFilterScript.SetCloudlandsVersionTab();
		}
		else if (currentTab == CurrentTab.Online)
		{
			SwitchSearchTags();
			QueryWorkshop();
			searchFilterScript.SetCloudlandsVersionTab();
		}
		else if (currentTab == CurrentTab.Your_Holes)
		{
			QueryUserItems();
			searchFilterScript.SetCloudlandsVersionTab();
		}
		else if (currentTab == CurrentTab.Local_Holes)
		{
			PopulateLocalHolesTab();
		}
		else if (currentTab == CurrentTab.Favorite)
		{
			SwitchSearchTags();
			QueryWorkshopFavorites();
		}
		randomButtons.SetActive(value: false);
	}

	private IEnumerator ToggleTags(bool toggleTags, bool toggleVersion, bool showSearch)
	{
		TabButton[] array = tagButtons;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].gameObject.SetActive(toggleTags);
		}
		array = cloudlandVersionButtons;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].gameObject.SetActive(toggleVersion);
		}
		searchButton.SetActive(showSearch);
		yield return null;
		Vector3 size = new Vector3(searchButton.GetComponent<RectTransform>().rect.width, searchButton.GetComponent<RectTransform>().rect.height, searchButton.GetComponent<BoxCollider>().size.z);
		searchButton.GetComponent<BoxCollider>().size = size;
	}

	private void ToggleReadyButton()
	{
		if (PhotonNetwork.InRoom)
		{
			if (PhotonNetwork.IsMasterClient)
			{
				if (usedPickedHoleObjects.childCount == 0)
				{
					readyButton.SetActive(value: false);
				}
				else if (!AllPlayersReady())
				{
					readyButton.gameObject.SetActive(value: false);
				}
				else
				{
					readyButton.gameObject.SetActive(value: true);
				}
			}
			else
			{
				readyButton.SetActive(value: false);
			}
		}
		else if (usedPickedHoleObjects.childCount == 0)
		{
			readyButton.SetActive(value: false);
		}
		else
		{
			readyButton.SetActive(value: true);
		}
	}

	private void SetPlaylistButton(GameObject button, WorkshopData holeData, Transform parent)
	{
		button.GetComponent<HoleButton>().SetPlaylistData(holeData);
		button.transform.SetParent(parent);
		button.SetActive(value: true);
	}

	private void ResetNewQueryVariables()
	{
		currentPage = 1u;
		loadingCircles.SetActive(value: false);
		searchErrorText.text = "";
		querying = false;
		downloadingImages = false;
		searchFilterScript.ResetQuery();
	}

	private void SwitchSearchTags()
	{
		if (currentTag == CurrentTag.Holes)
		{
			searchFilterScript.SwitchToHoleFilter();
		}
		else if (currentTag == CurrentTag.Playlists)
		{
			searchFilterScript.SwitchToPlaylistFilter();
		}
	}

	private void SetErrorHoleButton(string msg)
	{
		GameObject obj = unusedPlaylistErrorHoleObjects.GetChild(0).gameObject;
		obj.GetComponentInChildren<Text>().text = LocalizationManager.GetTranslation(msg);
		obj.transform.SetParent(usedPlaylistHoleObjects);
		obj.SetActive(value: true);
	}

	private void CreateLevelsFromWorkshopData(List<WorkshopData> data, bool downloadImages = true)
	{
		if (data.Count <= 0)
		{
			return;
		}
		for (int i = 0; i < data.Count; i++)
		{
			if (playlistPreviewScript.gameObject.activeSelf)
			{
				if (unusedPlaylistHoleObjects.childCount > 0)
				{
					if (!data[i].visible)
					{
						SetErrorHoleButton("The hole creator has removed the hole from online");
					}
					else
					{
						SetHoleButton(unusedPlaylistHoleObjects.GetChild(0).gameObject, data[i], usedPlaylistHoleObjects);
					}
				}
			}
			else if (data[i].visible && unusedAvailableHoleObjects.childCount > 0)
			{
				SetHoleButton(unusedAvailableHoleObjects.GetChild(0).gameObject, data[i], usedAvailableHoleObjects);
			}
		}
		if (downloadImages)
		{
			if (playlistPreviewScript.gameObject.activeSelf)
			{
				DownloadImages(usedPlaylistHoleObjects);
			}
			else
			{
				DownloadImages(usedAvailableHoleObjects);
			}
		}
		if (playlistPreviewScript.gameObject.activeSelf)
		{
			StartCoroutine(ScrollToBottom(playlistLevelList));
		}
		else
		{
			SetPageButtons(RemoteServerManager.instance.numReturned, RemoteServerManager.instance.numTotal);
		}
	}

	private void CreateWorkshopLevelInPickedList(List<WorkshopData> data)
	{
		if (data.Count <= 0)
		{
			return;
		}
		for (int i = 0; i < data.Count; i++)
		{
			if (data[i].visible && unusedPickedHoleObjects.childCount > 0)
			{
				SetHoleButton(unusedPickedHoleObjects.GetChild(0).gameObject, data[i], usedPickedHoleObjects);
			}
		}
		DownloadImages(usedPickedHoleObjects);
	}

	private void CreatePlaylistsFromWorkshopData(List<WorkshopData> data)
	{
		int num = 0;
		if (data.Count > 0)
		{
			for (int i = 0; i < data.Count; i++)
			{
				if (num < 20)
				{
					num++;
					GameObject obj = unusedAvailableHoleObjects.GetChild(0).gameObject;
					obj.transform.SetParent(usedAvailableHoleObjects);
					obj.SetActive(value: true);
					obj.GetComponent<HoleButton>().SetPlaylistData(data[i]);
				}
			}
			DownloadImages(usedAvailableHoleObjects);
		}
		else if (currentTag == CurrentTag.Holes)
		{
			SetErrorMessage("No results found matching your current search");
		}
		else
		{
			SetErrorMessage("Could not find any playlists");
		}
		SetPageButtons(RemoteServerManager.instance.numReturned, RemoteServerManager.instance.numTotal);
	}

	public static WorkshopData CreateButtonFromCustomLevel(CustomLevel level, string datPath, string imagePath)
	{
		WorkshopData workshopData = null;
		workshopData = new WorkshopData
		{
			publishID = (int)level.publishedFileId,
			publishPlatform = (int)level.publishedPlatform,
			creatorName = level.creatorName,
			creatorID = level.creatorId,
			levelName = level.levelName,
			par = level.par,
			difficulty = (int)level.difficulty,
			pieceCount = level.pieces.Length,
			uploadDate = level.saveDate.ToString(),
			imageLocation = imagePath,
			fileLocation = datPath,
			localItem = true,
			cloudlandsVersion = 2,
			golfClubType = level.allowedClubs
		};
		if (level.windVector == Vector3.zero)
		{
			workshopData.wind = false;
		}
		else
		{
			workshopData.wind = true;
		}
		return workshopData;
	}

	public static WorkshopData CreateButtonFromCustomLevelCL1(CustomLevelCL1 level, string datPath, string imagePath)
	{
		return new WorkshopData
		{
			publishID = (int)level.publishedFileId,
			publishPlatform = (int)level.publishedPlatform,
			creatorName = level.creatorName,
			creatorID = level.creatorId.ToString(),
			levelName = level.levelName,
			par = level.par,
			difficulty = (int)level.difficulty,
			uploadDate = level.saveDate.ToString(),
			imageLocation = imagePath,
			fileLocation = datPath,
			localItem = true,
			cloudlandsVersion = 1
		};
	}

	public static WorkshopData CreateButtonFromPlaylistData(PlaylistData level, string datPath, string imagePath)
	{
		return new WorkshopData
		{
			publishID = (int)level.publishedFileId,
			publishPlatform = (int)level.publishedPlatform,
			creatorName = level.creatorName,
			creatorID = level.creatorId.ToString(),
			par = level.par,
			uploadDate = level.saveDate.ToString(),
			imageLocation = imagePath,
			levelName = level.playlistName,
			fileLocation = level.playlistPath,
			localItem = true,
			holeCount = level.holeCount.ToString()
		};
	}

	private void SetHoleButton(GameObject button, WorkshopData holeData, Transform parent, bool duplicate = false)
	{
		button.GetComponent<HoleButton>().SetHoleData(holeData, duplicate);
		button.transform.SetParent(parent);
		button.SetActive(value: true);
	}

	private IEnumerator ScrollToBottom(ScrollList list)
	{
		yield return new WaitForEndOfFrame();
		list.sr.verticalNormalizedPosition = 0f;
		list.UpdateButtonColliders();
	}

	private IEnumerator ScrollToTop(ScrollList list)
	{
		yield return new WaitForEndOfFrame();
		list.sr.verticalNormalizedPosition = 1f;
		list.UpdateButtonColliders();
	}

	private void DownloadImages(RectTransform list)
	{
		if (downloadAvailableListScreenshotsCoroutine != null && list == usedAvailableHoleObjects)
		{
			StopCoroutine(downloadAvailableListScreenshotsCoroutine);
		}
		if (downloadPickedListScreenshotsCoroutine != null && list == usedPickedHoleObjects)
		{
			StopCoroutine(downloadPickedListScreenshotsCoroutine);
		}
		if (downloadAvatarsCoroutine != null)
		{
			StopCoroutine(downloadAvatarsCoroutine);
		}
		if (list == usedAvailableHoleObjects)
		{
			downloadAvailableListScreenshotsCoroutine = StartCoroutine(DownloadScreenshot(list));
		}
		else if (list == usedPickedHoleObjects)
		{
			downloadPickedListScreenshotsCoroutine = StartCoroutine(DownloadScreenshot(list));
		}
		else if (list == usedPlaylistHoleObjects)
		{
			downloadPlaylistScreenshotsCoroutine = StartCoroutine(DownloadScreenshot(list));
		}
		downloadAvatarsCoroutine = StartCoroutine(DownloadAvatars(list));
	}

	private void SetupDownloadBars()
	{
		downloadProgressPanel.SetActive(value: true);
		DownloadBars[] array = downloadBars;
		foreach (DownloadBars obj in array)
		{
			obj.downloadsCompleted = 0;
			obj.container.SetActive(value: false);
		}
		if (PhotonNetwork.IsConnected)
		{
			List<Photon.Realtime.Player> list = new List<Photon.Realtime.Player>();
			Photon.Realtime.Player[] playerList = PhotonNetwork.PlayerList;
			foreach (Photon.Realtime.Player player in playerList)
			{
				if (player.GetScene() == "RoomPrepScene" && !PhotonNetwork.CurrentRoom.GetKickedPlayers().Contains(player.ActorNumber))
				{
					list.Add(player);
				}
			}
			for (int j = 0; j < list.Count; j++)
			{
				downloadBars[j].container.SetActive(value: true);
				downloadBars[j].name.text = list[j].NickName;
				downloadBars[j].nameBackground.enabled = false;
				downloadBars[j].percent.text = "0%";
				Vector3 localScale = downloadBars[j].downloadBar.transform.localScale;
				localScale.x = 0f;
				downloadBars[j].downloadBar.transform.localScale = localScale;
			}
		}
		else
		{
			downloadBars[0].container.SetActive(value: true);
			downloadBars[0].name.text = "";
			downloadBars[0].nameBackground.enabled = false;
			downloadBars[0].percent.text = "0%";
			Vector3 localScale2 = downloadBars[0].downloadBar.transform.localScale;
			localScale2.x = 0f;
			downloadBars[0].downloadBar.transform.localScale = localScale2;
		}
	}

	private void UpdateDownloadProgress()
	{
		if (PhotonNetwork.IsConnected)
		{
			if (serverDownloadStartTime == 0.0)
			{
				serverDownloadStartTime = PhotonNetwork.Time;
			}
			downloadTimer = 300 - (int)(PhotonNetwork.Time - serverDownloadStartTime);
		}
		else
		{
			downloadTimer -= Time.deltaTime;
		}
		downloadTimerText.text = ((int)downloadTimer).ToString();
		if (PhotonNetwork.IsConnected)
		{
			List<Photon.Realtime.Player> usablePlayers = PhotonManager.instance.GetUsablePlayers();
			for (int i = 0; i < usablePlayers.Count; i++)
			{
				int downloadProgress = usablePlayers[i].GetDownloadProgress();
				Vector3 localScale = downloadBars[i].downloadBar.transform.localScale;
				float num = (localScale.x = ((downloadsNeeded > 0) ? ((float)downloadProgress / (float)downloadsNeeded) : 1f));
				downloadBars[i].downloadBar.transform.localScale = localScale;
				downloadBars[i].percent.text = Mathf.Clamp((int)(num * 100f), 0, 100) + "%";
			}
		}
		else
		{
			Vector3 localScale2 = downloadBars[0].downloadBar.transform.localScale;
			float num2 = 1f;
			if (downloadsNeeded > 0)
			{
				num2 = (float)RemoteServerManager.instance.downloadsCompleted / (float)downloadsNeeded;
			}
			localScale2.x = num2;
			downloadBars[0].downloadBar.transform.localScale = localScale2;
			downloadBars[0].percent.text = Mathf.Clamp((int)(num2 * 100f), 0, 100) + "%";
		}
	}

	private IEnumerator DownloadScreenshot(RectTransform list)
	{
		downloadingImages = true;
		while (downloadingImages)
		{
			HoleButton[] button = list.GetComponentsInChildren<HoleButton>(includeInactive: true);
			for (int i = 0; i < button.Length; i++)
			{
				if (button == null || !(button[i].workshopData.screenshot == null) || button[i].workshopData.defaultHole)
				{
					continue;
				}
				bool local = button[i].workshopData.localItem;
				bool imageFound = false;
				if (!local)
				{
					for (int j = 0; j < screenshotImages.Count; j++)
					{
						if (screenshotImages[j].uid == button[i].workshopData.publishID && screenshotImages[j].isHole == button[i].isHole && screenshotImages[j].cloudlandsVersion == button[i].workshopData.cloudlandsVersion)
						{
							button[i].workshopData.screenshot = new Texture2D(0, 0, TextureFormat.RGB24, mipChain: false);
							button[i].workshopData.screenshot.LoadImage(screenshotImages[j].jpgData);
							TextureScaler.scale(button[i].workshopData.screenshot, button[i].workshopData.screenshot.width / 4, button[i].workshopData.screenshot.height / 4, FilterMode.Bilinear);
							button[i].screenshot.texture = button[i].workshopData.screenshot;
							imageFound = true;
							yield return null;
							break;
						}
					}
				}
				if (imageFound)
				{
					continue;
				}
				string imageLocation = button[i].workshopData.imageLocation;
				string text = "";
				if (local)
				{
					text = "file:///";
				}
				int startingID = button[i].workshopData.publishID;
				bool startingLocal = local;
				bool isHole = button[i].isHole;
				WWW www = new WWW(text + imageLocation);
				yield return www;
				if (startingID == button[i].workshopData.publishID)
				{
					if (button[i].workshopData.screenshot != null)
					{
						UnityEngine.Object.DestroyImmediate(button[i].workshopData.screenshot);
					}
					if (string.IsNullOrEmpty(www.error))
					{
						button[i].workshopData.screenshot = new Texture2D(0, 0, TextureFormat.RGB24, mipChain: false);
						byte[] bytes = www.bytes;
						if (!local)
						{
							ImageStore imageStore = new ImageStore(button[i].workshopData.publishID, isHole, button[i].workshopData.cloudlandsVersion, bytes);
							screenshotImages.Add(imageStore);
							if (isHole)
							{
								StartCoroutine(UpdatePickedListScreenshots(imageStore));
							}
							else
							{
								StartCoroutine(UpdatePlaylistPreviewListScreenshots(imageStore));
							}
						}
						button[i].workshopData.screenshot.LoadImage(bytes);
						TextureScaler.scale(button[i].workshopData.screenshot, button[i].workshopData.screenshot.width / 4, button[i].workshopData.screenshot.height / 4, FilterMode.Bilinear);
						button[i].UpdateScreenshot();
					}
				}
				else if (!startingLocal && string.IsNullOrEmpty(www.error))
				{
					_ = www.bytes;
					ImageStore imageStore2 = new ImageStore(startingID, isHole, button[i].workshopData.cloudlandsVersion, www.bytes);
					screenshotImages.Add(imageStore2);
					if (isHole)
					{
						StartCoroutine(UpdatePickedListScreenshots(imageStore2));
					}
					else
					{
						StartCoroutine(UpdatePlaylistPreviewListScreenshots(imageStore2));
					}
				}
				www.Dispose();
			}
			downloadingImages = false;
		}
	}

	private IEnumerator DownloadAvatars(RectTransform list)
	{
		yield return null;
		downloadingImages = true;
		while (downloadingImages)
		{
			HoleButton[] button = list.GetComponentsInChildren<HoleButton>(includeInactive: true);
			for (int i = 0; i < button.Length; i++)
			{
				if (button == null || !(button[i].workshopData.avatar == null) || button[i].workshopData.defaultHole)
				{
					continue;
				}
				_ = button[i].workshopData.localItem;
				bool imageFound = false;
				for (int j = 0; j < avatarImages.Count; j++)
				{
					if (avatarImages[j].uid == button[i].workshopData.creatorID)
					{
						Texture2D texture2D = new Texture2D(0, 0, TextureFormat.RGB24, mipChain: false);
						texture2D.LoadImage(avatarImages[j].jpgData);
						if (texture2D.width > 64)
						{
							TextureScaler.scale(texture2D, 64, 64, FilterMode.Bilinear);
						}
						button[i].profilePicture.sprite = Sprite.Create(texture2D, new Rect(0f, 0f, texture2D.width, texture2D.height), new Vector2(0.5f, 0.5f), 100f, 0u, SpriteMeshType.FullRect);
						button[i].workshopData.avatar = texture2D;
						imageFound = true;
						yield return null;
						break;
					}
				}
				if (imageFound)
				{
					continue;
				}
				string startingID = button[i].workshopData.creatorID;
				bool downloadingAvatar = true;
				if (button[i].workshopData.publishPlatform == 0)
				{
					StartCoroutine(RemoteServerManager.instance.GetSteamUser(button[i].workshopData.creatorID, delegate(string complete)
					{
						if (string.IsNullOrEmpty(complete))
						{
							downloadingAvatar = false;
						}
						else
						{
							StartCoroutine(RemoteServerManager.instance.GetAvatarSprite(complete, delegate(byte[] complete2)
							{
								if (complete2 != null)
								{
									if (startingID == button[i].workshopData.creatorID)
									{
										Texture2D texture2D4 = new Texture2D(0, 0, TextureFormat.RGB24, mipChain: false);
										texture2D4.LoadImage(complete2);
										if (texture2D4.width > 64)
										{
											TextureScaler.scale(texture2D4, 64, 64, FilterMode.Bilinear);
										}
										button[i].profilePicture.sprite = Sprite.Create(texture2D4, new Rect(0f, 0f, texture2D4.width, texture2D4.height), new Vector2(0.5f, 0.5f), 100f, 0u, SpriteMeshType.FullRect);
										button[i].workshopData.avatar = texture2D4;
									}
									AvatarStore avatarStore2 = new AvatarStore(startingID, complete2);
									avatarImages.Add(avatarStore2);
									UpdatePickedListAvatars(avatarStore2);
									downloadingAvatar = false;
								}
								else
								{
									downloadingAvatar = false;
								}
							}));
						}
					}));
				}
				else if (button[i].workshopData.publishPlatform == 1)
				{
					StartCoroutine(RemoteServerManager.instance.GetOculusUser(button[i].workshopData.creatorID, button[i].workshopData.cloudlandsVersion, delegate
					{
					}, delegate(string profileImage)
					{
						if (string.IsNullOrEmpty(profileImage))
						{
							downloadingAvatar = false;
						}
						else
						{
							StartCoroutine(RemoteServerManager.instance.GetAvatarSprite(profileImage, delegate(byte[] complete2)
							{
								if (complete2 != null)
								{
									if (startingID == button[i].workshopData.creatorID)
									{
										Texture2D texture2D3 = new Texture2D(0, 0, TextureFormat.RGB24, mipChain: false);
										texture2D3.LoadImage(complete2);
										if (texture2D3.width > 64)
										{
											TextureScaler.scale(texture2D3, 64, 64, FilterMode.Bilinear);
										}
										button[i].profilePicture.sprite = Sprite.Create(texture2D3, new Rect(0f, 0f, texture2D3.width, texture2D3.height), new Vector2(0.5f, 0.5f), 100f, 0u, SpriteMeshType.FullRect);
										button[i].workshopData.avatar = texture2D3;
									}
									AvatarStore avatarStore = new AvatarStore(startingID, complete2);
									avatarImages.Add(avatarStore);
									UpdatePickedListAvatars(avatarStore);
									downloadingAvatar = false;
								}
								else
								{
									downloadingAvatar = false;
								}
							}));
						}
					}));
				}
				else if (button[i].workshopData.publishPlatform == 2)
				{
					button[i].profilePicture.sprite = RemoteServerManager.instance.viveportIcon;
					downloadingAvatar = false;
				}
				else if (button[i].workshopData.publishPlatform == 6)
				{
					button[i].profilePicture.sprite = RemoteServerManager.instance.picoIcon;
					downloadingAvatar = false;
				}
				else if (button[i].workshopData.publishPlatform == 4)
				{
					StartCoroutine(RemoteServerManager.instance.GetAvatarSprite(RemoteServerManager.instance.GetXboxUser(button[i].workshopData.creatorName), delegate(byte[] complete)
					{
						if (complete != null)
						{
							Texture2D texture2D2 = new Texture2D(0, 0, TextureFormat.RGB24, mipChain: false);
							texture2D2.LoadImage(complete);
							if (texture2D2.width > 64)
							{
								TextureScaler.scale(texture2D2, 64, 64, FilterMode.Bilinear);
							}
							button[i].profilePicture.sprite = Sprite.Create(texture2D2, new Rect(0f, 0f, texture2D2.width, texture2D2.height), new Vector2(0.5f, 0.5f), 100f, 0u, SpriteMeshType.FullRect);
							button[i].workshopData.avatar = texture2D2;
						}
						else
						{
							downloadingAvatar = false;
						}
					}));
					button[i].profilePicture.sprite = RemoteServerManager.instance.xboxIcon;
					downloadingAvatar = false;
				}
				else if (button[i].workshopData.publishPlatform == 5)
				{
					button[i].profilePicture.sprite = RemoteServerManager.instance.XRSpaceIcon;
					downloadingAvatar = false;
				}
				else
				{
					downloadingAvatar = false;
				}
				while (downloadingAvatar)
				{
					yield return null;
				}
			}
			downloadingImages = false;
		}
	}

	private IEnumerator UpdatePlaylistPreviewListScreenshots(ImageStore imgS)
	{
		for (int x = 0; x < 2; x++)
		{
			for (int i = 0; i < usedPlaylistHoleObjects.childCount; i++)
			{
				HoleButton component = usedPlaylistHoleObjects.GetChild(i).GetComponent<HoleButton>();
				if (component != null && component.workshopData.screenshot == null && component.workshopData.publishID == imgS.uid && component.isHole == imgS.isHole && component.workshopData.cloudlandsVersion == imgS.cloudlandsVersion)
				{
					component.workshopData.screenshot = new Texture2D(0, 0, TextureFormat.RGB24, mipChain: false);
					component.workshopData.screenshot.LoadImage(imgS.jpgData);
					TextureScaler.scale(component.workshopData.screenshot, component.workshopData.screenshot.width / 4, component.workshopData.screenshot.height / 4, FilterMode.Bilinear);
					component.UpdateScreenshot();
				}
			}
			yield return null;
		}
	}

	private IEnumerator UpdatePickedListScreenshots(ImageStore imgS)
	{
		for (int x = 0; x < 2; x++)
		{
			for (int i = 0; i < usedPickedHoleObjects.childCount; i++)
			{
				HoleButton component = usedPickedHoleObjects.GetChild(i).GetComponent<HoleButton>();
				if (component.workshopData.screenshot == null && component.workshopData.publishID == imgS.uid)
				{
					component.workshopData.screenshot = new Texture2D(0, 0, TextureFormat.RGB24, mipChain: false);
					component.workshopData.screenshot.LoadImage(imgS.jpgData);
					TextureScaler.scale(component.workshopData.screenshot, component.workshopData.screenshot.width / 4, component.workshopData.screenshot.height / 4, FilterMode.Bilinear);
					component.UpdateScreenshot();
				}
			}
			yield return null;
		}
	}

	public void UpdatePickedListAvatars(AvatarStore avS)
	{
		for (int i = 0; i < usedPickedHoleObjects.childCount; i++)
		{
			HoleButton component = usedPickedHoleObjects.GetChild(i).GetComponent<HoleButton>();
			if (component.workshopData.avatar == null && component.workshopData.creatorID == avS.uid)
			{
				component.workshopData.avatar = new Texture2D(0, 0, TextureFormat.RGB24, mipChain: false);
				component.workshopData.avatar.LoadImage(avS.jpgData);
				if (component.workshopData.avatar.width > 64)
				{
					TextureScaler.scale(component.workshopData.avatar, 64, 64, FilterMode.Bilinear);
				}
			}
		}
	}

	public void ClearWorkshopImages()
	{
		Resources.UnloadUnusedAssets();
	}

	public void SetPageButtons(int numReturned, int numTotal)
	{
		if (numTotal <= itemsPerPage)
		{
			pageNavigation.SetActive(value: false);
			availableLevelList.sr.GetComponent<RectTransform>().anchorMin = new Vector2(0f, 0f);
			pageText.text = "1/1";
			return;
		}
		int num = Mathf.CeilToInt((float)numTotal / (float)itemsPerPage);
		pageNavigation.SetActive(value: true);
		availableLevelList.sr.GetComponent<RectTransform>().anchorMin = new Vector2(0f, 0.16f);
		pageText.text = currentPage + "/" + num;
		if (currentPage == num)
		{
			pageNextButton.gameObject.SetActive(value: false);
			pageBackButton.gameObject.SetActive(value: true);
		}
		else if (currentPage == 1)
		{
			pageNextButton.gameObject.SetActive(value: true);
			pageBackButton.gameObject.SetActive(value: false);
		}
		else
		{
			pageNextButton.gameObject.SetActive(value: true);
			pageBackButton.gameObject.SetActive(value: true);
		}
	}

	public void OnPageNextButton()
	{
		if (querying)
		{
			return;
		}
		currentPage++;
		if (currentTab == CurrentTab.Online)
		{
			QueryWorkshop();
		}
		else if (currentTab == CurrentTab.Downloaded)
		{
			if (currentTag == CurrentTag.Holes)
			{
				StartCoroutine(GetDownloadedHoleFiles());
			}
			else if (currentTag == CurrentTag.Playlists)
			{
				StartCoroutine(GetDownloadedPlaylistFiles());
			}
		}
		else if (currentTab == CurrentTab.Favorite)
		{
			QueryWorkshopFavorites();
		}
		else if (currentTab == CurrentTab.Your_Holes)
		{
			QueryUserItems();
		}
		else if (currentTab == CurrentTab.Local_Holes)
		{
			PopulateLocalHolesTab();
		}
		StartCoroutine(ScrollToTop(availableLevelList));
	}

	public void OnPageBackButton()
	{
		if (querying)
		{
			return;
		}
		if (currentPage > 1)
		{
			currentPage--;
			if (currentTab == CurrentTab.Online)
			{
				QueryWorkshop();
			}
			else if (currentTab == CurrentTab.Downloaded)
			{
				if (currentTag == CurrentTag.Holes)
				{
					StartCoroutine(GetDownloadedHoleFiles());
				}
				else if (currentTag == CurrentTag.Playlists)
				{
					StartCoroutine(GetDownloadedPlaylistFiles());
				}
			}
			else if (currentTab == CurrentTab.Favorite)
			{
				QueryWorkshopFavorites();
			}
			else if (currentTab == CurrentTab.Your_Holes)
			{
				QueryUserItems();
			}
			else if (currentTab == CurrentTab.Local_Holes)
			{
				PopulateLocalHolesTab();
			}
		}
		StartCoroutine(ScrollToTop(availableLevelList));
	}

	public void ToggleSearchFilter()
	{
		if (searchFilter.activeSelf)
		{
			searchFilter.SetActive(value: false);
		}
		else
		{
			searchFilter.SetActive(value: true);
		}
	}

	private bool AllPlayersReady()
	{
		Photon.Realtime.Player[] playerListOthers = PhotonNetwork.PlayerListOthers;
		foreach (Photon.Realtime.Player player in playerListOthers)
		{
			if (!PhotonNetwork.CurrentRoom.GetKickedPlayers().Contains(player.ActorNumber))
			{
				if (!(player.GetScene() == "RoomPrepScene"))
				{
					return false;
				}
				if (!player.IsReadyToStart() || player.GetStandby())
				{
					return false;
				}
			}
		}
		return true;
	}

	private void SetButtonRatings(RectTransform list)
	{
		HoleButton[] componentsInChildren = list.GetComponentsInChildren<HoleButton>(includeInactive: true);
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			for (int j = 0; j < RemoteServerManager.instance.workshopDetails.Count; j++)
			{
				if (componentsInChildren[i].workshopData.publishID == RemoteServerManager.instance.workshopDetails[j].publishID)
				{
					componentsInChildren[i].workshopData.upvotes = RemoteServerManager.instance.workshopDetails[j].upvotes;
					componentsInChildren[i].workshopData.downvotes = RemoteServerManager.instance.workshopDetails[j].downvotes;
					componentsInChildren[i].SetRatings(componentsInChildren[i].workshopData.upvotes, componentsInChildren[i].workshopData.downvotes);
					componentsInChildren[i].localItemText.SetActive(value: false);
				}
			}
		}
	}

	public void UpdatePickedOnlineLevels()
	{
		WorkshopData[] array = new WorkshopData[0];
		if (PhotonNetwork.InRoom)
		{
			array = PhotonNetwork.CurrentRoom.GetHoles();
		}
		else
		{
			array = GameManager.instance.holeData.ToArray();
			int num = 0;
			for (int i = 0; i < GameManager.instance.holeData.Count; i++)
			{
				if (!GameManager.instance.holeData[i].defaultHole)
				{
					GameManager.instance.holeData[i].fileLocation = GameManager.instance.holeDataServerLocation[i - num].holeLocation;
					GameManager.instance.holeData[i].imageLocation = GameManager.instance.holeDataServerLocation[i - num].imageLocation;
				}
				else
				{
					num++;
				}
			}
			WorkshopData[] array2 = array;
			foreach (WorkshopData workshopData in array2)
			{
				if (!workshopData.defaultHole)
				{
					GameManager.instance.holeDataServerLocation.Add(new WorkshopURLLocation
					{
						holeLocation = workshopData.fileLocation,
						imageLocation = workshopData.imageLocation
					});
				}
			}
		}
		while (usedPickedHoleObjects.childCount > 0 && usedPickedHoleObjects.childCount > array.Length)
		{
			usedPickedHoleObjects.GetChild(0).gameObject.SetActive(value: false);
			usedPickedHoleObjects.GetChild(0).SetParent(unusedPickedHoleObjects);
		}
		for (int k = 0; k < array.Length; k++)
		{
			if (k < usedPickedHoleObjects.childCount)
			{
				if (usedPickedHoleObjects.GetChild(k).GetComponent<HoleButton>().workshopData.publishID != array[k].publishID || usedPickedHoleObjects.GetChild(k).GetComponent<HoleButton>().workshopData.defaultHole)
				{
					usedPickedHoleObjects.GetChild(k).GetComponent<HoleButton>().SetHoleData(array[k]);
				}
			}
			else
			{
				SetHoleButton(unusedPickedHoleObjects.GetChild(0).gameObject, array[k], usedPickedHoleObjects);
			}
		}
		pickedLevelList.UpdateButtonColliders();
		DownloadImages(usedPickedHoleObjects);
		SetHoleOrderNumber(usedPickedHoleObjects);
	}

	public bool AllPlayersFinishDownloading()
	{
		foreach (Photon.Realtime.Player usablePlayer in PhotonManager.instance.GetUsablePlayers())
		{
			if (!PhotonNetwork.CurrentRoom.GetKickedPlayers().Contains(usablePlayer.ActorNumber) && usablePlayer.GetScene() == "RoomPrepScene" && !usablePlayer.IsFinishedDownloading())
			{
				return false;
			}
		}
		return true;
	}

	private IEnumerator SetUnfinishedDownloadedQueriedImages()
	{
		foreach (WorkshopData data in GameManager.instance.holeData)
		{
			if (data.screenshot == null)
			{
				WWW www = new WWW("file:///" + data.imageLocation);
				yield return www;
				data.screenshot = new Texture2D(0, 0, TextureFormat.RGB24, mipChain: false);
				www.LoadImageIntoTexture(data.screenshot);
				www.Dispose();
			}
		}
	}

	public void SetErrorMessage(string x)
	{
		searchErrorText.text = LocalizationManager.GetTranslation(x);
		pageNavigation.SetActive(value: false);
	}

	private void SetHoleOrderNumber(RectTransform list)
	{
		int num = (int)(currentPage - 1) * itemsPerPage + 1;
		foreach (RectTransform item in list)
		{
			HoleButton component = item.GetComponent<HoleButton>();
			if (component != null && !component.isError)
			{
				component.SetHoleNumber(num);
				num++;
			}
		}
	}

	private void OnApplicationQuit()
	{
		if (thread != null)
		{
			thread.Abort();
			MonoBehaviour.print("DeleteMenu Thread Aborted: " + !thread.IsAlive);
			thread = null;
		}
	}

	private void OnDisable()
	{
		if (thread != null)
		{
			thread.Abort();
			MonoBehaviour.print("DeleteMenu Thread Aborted: " + !thread.IsAlive);
			thread = null;
		}
	}
}
[Serializable]
public struct ImageStore
{
	public int uid;

	public bool isHole;

	public int cloudlandsVersion;

	public byte[] jpgData;

	public ImageStore(int id, bool hole, int version, byte[] data)
	{
		uid = id;
		isHole = hole;
		cloudlandsVersion = version;
		jpgData = data;
	}
}
[Serializable]
public struct AvatarStore
{
	public string uid;

	public byte[] jpgData;

	public AvatarStore(string id, byte[] data)
	{
		uid = id;
		jpgData = data;
	}
}
public enum CurrentTag
{
	Holes,
	Playlists
}
public enum CurrentTab
{
	Cloudlands,
	Downloaded,
	Online,
	Favorite,
	Your_Holes,
	Local_Holes
}
[Serializable]
public class DownloadBars
{
	public GameObject container;

	public TextMeshProUGUI name;

	public Text percent;

	public Image downloadBar;

	public Image nameBackground;

	public int downloadsCompleted;
}
[Serializable]
public class LocalFiles
{
	public string path;

	public string jpgPath = "No Screenshot.";

	public CustomLevel customLevel;

	public CustomLevelCL1 customLevelCL1;

	public PlaylistData playlistData;
}
public class PlaylistPublishIDOrder
{
	public int publishFileID;

	public int order;
}
public class PlayerListObject : MonoBehaviour
{
	public Text playerName;

	public GameObject checkmark;

	public GameObject hostIcon;

	public GameObject checkBox;

	public void SetData(Photon.Realtime.Player player)
	{
		playerName.text = player.NickName;
		hostIcon.SetActive(player.IsMasterClient);
		if (player.IsMasterClient)
		{
			checkmark.SetActive(value: false);
		}
		else
		{
			checkmark.SetActive(player.IsReadyToStart());
		}
	}
}
public class PlayerListPanel : MonoBehaviour
{
	public RectTransform usedList;

	public RectTransform unusedList;

	private List<Photon.Realtime.Player> currentPlayers = new List<Photon.Realtime.Player>();

	public Text roomTitle;

	public GameObject readyButton;

	private float playerCheckTimer = 0.5f;

	private float playerCheckInverval = 0.5f;

	public Photon.Realtime.Player[] storedPlayerList;

	private void Start()
	{
		if (!PhotonNetwork.InRoom)
		{
			base.gameObject.SetActive(value: false);
			return;
		}
		if (RichPresenceManager.instance.inParty)
		{
			roomTitle.text = string.Format(LocalizationManager.GetTranslation("{0}'s Room"), PhotonNetwork.MasterClient.NickName);
		}
		else
		{
			roomTitle.text = string.Format(LocalizationManager.GetTranslation("{0}'s Room"), PhotonNetwork.CurrentRoom.Name);
		}
		if (PhotonNetwork.IsMasterClient)
		{
			PhotonNetwork.LocalPlayer.SetReadyToStart(value: true);
		}
		else
		{
			Photon.Realtime.Player[] playerListOthers = PhotonNetwork.PlayerListOthers;
			for (int i = 0; i < playerListOthers.Length; i++)
			{
				playerListOthers[i].SetReadyToStart(value: false);
			}
		}
		RoomRPC.instance.pView.RPC("UpdatePlayerList", RpcTarget.All);
	}

	private void Update()
	{
		if (PhotonNetwork.IsMasterClient)
		{
			readyButton.SetActive(value: false);
		}
		else
		{
			readyButton.SetActive(value: true);
		}
		bool flag = true;
		if (currentPlayers.Count != storedPlayerList.Length)
		{
			flag = false;
		}
		else
		{
			for (int i = 0; i < storedPlayerList.Length; i++)
			{
				if (currentPlayers[i] != storedPlayerList[i])
				{
					flag = false;
					break;
				}
			}
		}
		if (!flag)
		{
			UpdatePlayerList();
		}
	}

	public void UpdatePlayerList()
	{
		currentPlayers.Clear();
		storedPlayerList = PhotonNetwork.PlayerList;
		for (int i = 0; i < storedPlayerList.Length; i++)
		{
			if (storedPlayerList[i].GetScene() == "RoomPrepScene" || storedPlayerList[i].GetScene() == "ScoreScene")
			{
				currentPlayers.Add(storedPlayerList[i]);
			}
		}
		for (int j = 0; j < PhotonNetwork.CurrentRoom.GetKickedPlayers().Length; j++)
		{
			for (int k = 0; k < currentPlayers.Count; k++)
			{
				if (currentPlayers[k].ActorNumber == PhotonNetwork.CurrentRoom.GetKickedPlayers()[j])
				{
					currentPlayers.RemoveAt(k);
					break;
				}
			}
		}
		while (currentPlayers.Count < usedList.childCount)
		{
			usedList.GetChild(0).gameObject.SetActive(value: false);
			usedList.GetChild(0).SetParent(unusedList);
		}
		while (currentPlayers.Count > usedList.childCount)
		{
			unusedList.GetChild(0).gameObject.SetActive(value: true);
			unusedList.GetChild(0).SetParent(usedList);
		}
		for (int l = 0; l < currentPlayers.Count; l++)
		{
			usedList.GetChild(l).GetComponent<PlayerListObject>().SetData(currentPlayers[l]);
		}
	}

	public void OnSetReadyButton()
	{
		if (!HoleSelectPanel.instance.downloading)
		{
			PhotonNetwork.LocalPlayer.SetReadyToStart(!PhotonNetwork.LocalPlayer.IsReadyToStart());
			RoomRPC.instance.pView.RPC("UpdatePlayerList", RpcTarget.All);
			RoomRPC.PlayOnlineSound(GameManager.instance.player.transform.position, "SFX_ReadyButton", 1f, includeSelf: true);
		}
	}
}
public class PlaylistPreview : MonoBehaviour
{
	public Text playlistTitle;

	public Text playlistCreatorName;

	public Image playlistCreatorAvatar;

	public Text playlistDate;

	public Text playlistPar;

	public Text playlistHoleCount;

	public GameObject loadPlaylistButton;

	public GameObject loadingCircles;

	public bool isQuerying;

	public bool gotAllHoles;

	private WorkshopData workshopData;

	[HideInInspector]
	public PlaylistData plData;

	private void Update()
	{
		if (isQuerying)
		{
			loadingCircles.SetActive(value: true);
			if (workshopData.screenshot != null && workshopData.avatar != null && gotAllHoles)
			{
				EnableLoadPlaylistButton();
			}
		}
	}

	public void FillPlaylistDetails(PlaylistData playlistData, WorkshopData data)
	{
		plData = playlistData;
		workshopData = data;
		base.gameObject.SetActive(value: true);
		isQuerying = true;
		gotAllHoles = false;
		playlistTitle.text = playlistData.playlistName;
		playlistCreatorName.text = playlistData.creatorName;
		playlistDate.text = playlistData.saveDate.ToString();
		playlistPar.text = LocalizationManager.GetTranslation("Par") + " " + playlistData.par;
		playlistHoleCount.text = playlistData.holeCount + " " + LocalizationManager.GetTranslation("Holes");
		playlistData.playlistPath = data.fileLocation;
		SetAvatar(data.publishPlatform, data);
	}

	public void FillCloudlandPlaylistDetails(PlaylistData playlistData, WorkshopData data)
	{
		plData = playlistData;
		workshopData = data;
		if (PhotonNetwork.IsMasterClient || !PhotonNetwork.IsConnected)
		{
			loadPlaylistButton.SetActive(value: true);
		}
		base.gameObject.SetActive(value: true);
		isQuerying = false;
		gotAllHoles = false;
		playlistTitle.text = playlistData.playlistName;
		playlistCreatorName.text = "";
		playlistDate.text = "";
		playlistPar.text = LocalizationManager.GetTranslation("Par") + " " + playlistData.par;
		playlistHoleCount.text = playlistData.holeCount + " " + LocalizationManager.GetTranslation("Holes");
		playlistCreatorAvatar.gameObject.SetActive(value: false);
		HoleSelectPanel.instance._currentPlaylist = HoleButton.DeepCopyWorkshopData(workshopData);
	}

	private void SetAvatar(int publishPlatform, WorkshopData data)
	{
		playlistCreatorAvatar.gameObject.SetActive(value: true);
		switch (publishPlatform)
		{
		case 0:
			if (data.avatar != null)
			{
				playlistCreatorAvatar.sprite = Sprite.Create(data.avatar, new Rect(0f, 0f, data.avatar.width, data.avatar.height), new Vector2(0.5f, 0.5f), 100f, 0u, SpriteMeshType.FullRect);
				workshopData.avatar = playlistCreatorAvatar.sprite.texture;
				break;
			}
			StartCoroutine(RemoteServerManager.instance.GetSteamUser(data.creatorID, delegate(string complete)
			{
				if (string.IsNullOrEmpty(complete))
				{
					playlistCreatorAvatar.sprite = RemoteServerManager.instance.steamIcon;
					workshopData.avatar = playlistCreatorAvatar.sprite.texture;
				}
				else
				{
					StartCoroutine(RemoteServerManager.instance.GetAvatarSprite(complete, delegate(byte[] complete2)
					{
						if (complete2 != null)
						{
							Texture2D texture2D = new Texture2D(0, 0, TextureFormat.RGB24, mipChain: false);
							texture2D.LoadImage(complete2);
							playlistCreatorAvatar.sprite = Sprite.Create(texture2D, new Rect(0f, 0f, texture2D.width, texture2D.height), new Vector2(0.5f, 0.5f), 100f, 0u, SpriteMeshType.FullRect);
							workshopData.avatar = playlistCreatorAvatar.sprite.texture;
						}
						else
						{
							playlistCreatorAvatar.sprite = RemoteServerManager.instance.steamIcon;
							workshopData.avatar = playlistCreatorAvatar.sprite.texture;
						}
					}));
				}
			}));
			break;
		case 1:
			if (data.avatar != null)
			{
				playlistCreatorAvatar.sprite = Sprite.Create(data.avatar, new Rect(0f, 0f, data.avatar.width, data.avatar.height), new Vector2(0.5f, 0.5f), 100f, 0u, SpriteMeshType.FullRect);
				workshopData.avatar = playlistCreatorAvatar.sprite.texture;
				break;
			}
			StartCoroutine(RemoteServerManager.instance.GetOculusUser(data.creatorID, data.cloudlandsVersion, delegate
			{
			}, delegate(string profileImage)
			{
				if (string.IsNullOrEmpty(profileImage))
				{
					playlistCreatorAvatar.sprite = RemoteServerManager.instance.oculusIcon;
					workshopData.avatar = playlistCreatorAvatar.sprite.texture;
				}
				else
				{
					StartCoroutine(RemoteServerManager.instance.GetAvatarSprite(profileImage, delegate(byte[] complete2)
					{
						if (complete2 != null)
						{
							Texture2D texture2D2 = new Texture2D(0, 0, TextureFormat.RGB24, mipChain: false);
							texture2D2.LoadImage(complete2);
							playlistCreatorAvatar.sprite = Sprite.Create(texture2D2, new Rect(0f, 0f, texture2D2.width, texture2D2.height), new Vector2(0.5f, 0.5f), 100f, 0u, SpriteMeshType.FullRect);
							workshopData.avatar = playlistCreatorAvatar.sprite.texture;
						}
						else
						{
							playlistCreatorAvatar.sprite = RemoteServerManager.instance.oculusIcon;
							workshopData.avatar = playlistCreatorAvatar.sprite.texture;
						}
					}));
				}
			}));
			break;
		case 2:
			playlistCreatorAvatar.sprite = RemoteServerManager.instance.viveportIcon;
			workshopData.avatar = playlistCreatorAvatar.sprite.texture;
			break;
		case 4:
			StartCoroutine(RemoteServerManager.instance.GetAvatarSprite(RemoteServerManager.instance.GetXboxUser(workshopData.creatorName), delegate(byte[] complete)
			{
				if (complete != null)
				{
					Texture2D texture2D3 = new Texture2D(0, 0, TextureFormat.RGB24, mipChain: false);
					texture2D3.LoadImage(complete);
					playlistCreatorAvatar.sprite = Sprite.Create(texture2D3, new Rect(0f, 0f, texture2D3.width, texture2D3.height), new Vector2(0.5f, 0.5f), 100f, 0u, SpriteMeshType.FullRect);
					workshopData.avatar = playlistCreatorAvatar.sprite.texture;
				}
			}));
			break;
		case 5:
			playlistCreatorAvatar.sprite = RemoteServerManager.instance.XRSpaceIcon;
			workshopData.avatar = playlistCreatorAvatar.sprite.texture;
			break;
		}
	}

	public void ClosePreview()
	{
		base.gameObject.SetActive(value: false);
		HoleSelectPanel.instance._currentPlaylist = null;
	}

	private void EnableLoadPlaylistButton()
	{
		if (PhotonNetwork.IsMasterClient || !PhotonNetwork.IsConnected)
		{
			loadPlaylistButton.SetActive(value: true);
			HoleSelectPanel.instance._currentPlaylist = HoleButton.DeepCopyWorkshopData(workshopData);
		}
		isQuerying = false;
		loadingCircles.SetActive(value: false);
	}
}
public class PlaylistPreviewImagePanel : MonoBehaviour
{
	public Image[] images;

	public Text title;

	public Text creator;
}
public class ScrollList : MonoBehaviour
{
	public ScrollRect sr;

	public RectTransform buttonViewContainer;

	public RectTransform buttonContentContainer;

	private Vector3 buttonColliderSize;

	private Vector3 buttonColliderCenter;

	private float prevContainerYPos = 1000000f;

	private int updateCollidersForFrames = 2;

	private float scrollSpeed = 0.3f;

	private float dampening = 0.8f;

	private float movement;

	private Vector2 tempPos;

	private float containerHeight;

	public void UpdateButtonColliders()
	{
		updateCollidersForFrames = 2;
	}

	public void Scroll(float direction)
	{
		movement = scrollSpeed * direction;
		tempPos = buttonContentContainer.anchoredPosition;
	}

	private void Update()
	{
		containerHeight = buttonContentContainer.sizeDelta.y;
		if (containerHeight <= 0f)
		{
			movement = 0f;
		}
		else if (movement > 0.001f || movement < -0.001f)
		{
			movement *= dampening;
			tempPos.y += movement;
			tempPos.y += movement;
			if (tempPos.y < 0f)
			{
				tempPos.y = 0f;
			}
			else if (tempPos.y > containerHeight)
			{
				tempPos.y = containerHeight;
			}
			buttonContentContainer.anchoredPosition = tempPos;
		}
		float height = buttonViewContainer.rect.height;
		float y = buttonContentContainer.anchoredPosition.y;
		if (y == prevContainerYPos && updateCollidersForFrames <= 0)
		{
			return;
		}
		prevContainerYPos = y;
		updateCollidersForFrames--;
		if (buttonContentContainer.childCount <= 0)
		{
			return;
		}
		if (buttonColliderSize == Vector3.zero)
		{
			BoxCollider component = buttonContentContainer.GetChild(0).GetComponent<BoxCollider>();
			buttonColliderSize = new Vector3(component.size.x, component.size.y, component.size.z);
			buttonColliderCenter = new Vector3(component.center.x, 0f, component.center.z);
		}
		bool flag = false;
		for (int i = 0; i < buttonContentContainer.childCount; i++)
		{
			RectTransform component2 = buttonContentContainer.GetChild(i).GetComponent<RectTransform>();
			BoxCollider component3 = component2.GetComponent<BoxCollider>();
			if (flag)
			{
				if (component3.enabled)
				{
					component3.enabled = false;
					ToggleUI(component3.transform, x: false);
				}
				continue;
			}
			float num = component2.anchoredPosition.y + component2.rect.yMax;
			float num2 = component2.anchoredPosition.y + y;
			float num3 = num2 + component2.rect.yMax;
			float num4 = num2 + component2.rect.yMin;
			float height2 = component2.rect.height;
			if (num4 >= 0f)
			{
				if (component3.enabled)
				{
					component3.enabled = false;
					ToggleUI(component3.transform, x: false);
				}
				continue;
			}
			if (num3 <= 0f - height)
			{
				if (component3.enabled)
				{
					component3.enabled = false;
					ToggleUI(component3.transform, x: false);
				}
				flag = true;
				continue;
			}
			if (!component3.enabled)
			{
				component3.enabled = true;
				ToggleUI(component3.transform, x: true);
			}
			if (num3 >= 0f)
			{
				float num5 = y + num;
				float num6 = height2 - num5;
				component3.size = new Vector3(component3.size.x, num6, component3.size.z);
				float y2 = 0f - (height2 / 2f - num6 / 2f);
				component3.center = new Vector3(component3.center.x, y2, component3.center.z);
			}
			else if (num4 <= 0f - height)
			{
				float num7 = 0f - (height + num4);
				float num8 = height2 - num7;
				component3.size = new Vector3(component3.size.x, num8, component3.size.z);
				float y3 = height2 / 2f - num8 / 2f;
				component3.center = new Vector3(component3.center.x, y3, component3.center.z);
			}
			else
			{
				component3.size = buttonColliderSize;
				component3.center = buttonColliderCenter;
			}
		}
	}

	private void ToggleUI(Transform obj, bool x)
	{
		Transform[] componentsInChildren = obj.GetComponentsInChildren<Transform>(includeInactive: true);
		foreach (Transform transform in componentsInChildren)
		{
			if (transform.GetComponent<Text>() != null)
			{
				transform.GetComponent<Text>().enabled = x;
			}
			if (transform.GetComponent<RawImage>() != null)
			{
				transform.GetComponent<RawImage>().enabled = x;
			}
			if (transform.GetComponent<Image>() != null)
			{
				transform.GetComponent<Image>().enabled = x;
			}
		}
	}
}
public class SearchFilter : MonoBehaviour
{
	public string sortOrder = "";

	public string sortPars = "";

	public string sortDifficulty = "";

	public string sortName = "";

	public int sortGolfClub = 7;

	public string sortHoleCount = "";

	public int sortCloudlandsVersion = 2;

	public int sortWind = -1;

	public GameObject[] allDropdowns;

	[Header("Cloudlands 1")]
	public Text CL1OrderText;

	public Text CL1HoleParsText;

	public Text CL1DifficultyText;

	public Text CL1PlaylistParsText;

	public Text CL1HoleCountText;

	public GameObject CL1OrderImage;

	public GameObject CL1HoleParsImage;

	public GameObject CL1DifficultyImage;

	public GameObject CL1PlaylistParsImage;

	public GameObject CL1HoleCountImage;

	[Header("Cloudlands 2")]
	public Text CL2OrderText;

	public Text CL2HoleParsText;

	public Text CL2DifficultyText;

	public Text CL2GolfClubText;

	public Text CL2PlaylistParsText;

	public Text CL2HoleCountText;

	public Text CL2WindText;

	public GameObject CL2OrderImage;

	public GameObject CL2HoleParsImage;

	public GameObject CL2DifficultyImage;

	public GameObject CL2GolfClubImage;

	public GameObject CL2PlaylistParsImage;

	public GameObject CL2HoleCountImage;

	public GameObject CL2WindImage;

	public TabButton cloudlands1Text;

	public TabButton cloudlands2Text;

	public GameObject cloudlands1SearchFilters;

	public GameObject cloudlands2SearchFilters;

	public SearchFilters searchFilters = new SearchFilters();

	public GameObject keyboard;

	public Text inputText;

	private string tempInputText = "";

	private string previousKeyboardText;

	private float caretTimer;

	[Header("Choosing Clubs")]
	public Image driverCheckmark;

	public Image ironCheckmark;

	public Image putterCheckmark;

	public Image mustIncludeSelectedCheckmark;

	private bool driverAllowed = true;

	private bool ironAllowed = true;

	private bool putterAllowed = true;

	private bool mustIncludeSelected;

	private void Start()
	{
		ResetQuery();
	}

	private void Update()
	{
		if (keyboard.activeSelf)
		{
			inputText.text = CaretText(tempInputText);
		}
	}

	public void OpenDropdown(GameObject dropdown)
	{
		bool flag = (dropdown.activeSelf ? true : false);
		CloseDropdown();
		if (!flag)
		{
			dropdown.SetActive(value: true);
		}
	}

	public void CloseDropdown()
	{
		for (int i = 0; i < allDropdowns.Length; i++)
		{
			allDropdowns[i].SetActive(value: false);
		}
	}

	public void SortByOrder(string sortBy)
	{
		CloseDropdown();
		sortOrder = sortBy;
		if (sortBy == "")
		{
			if (sortCloudlandsVersion == 1)
			{
				CL1OrderText.text = LocalizationManager.GetTranslation("Sort: Newest");
			}
			else if (sortCloudlandsVersion == 2)
			{
				CL2OrderText.text = LocalizationManager.GetTranslation("Sort: Newest");
			}
		}
		else if (sortCloudlandsVersion == 1)
		{
			CL1OrderText.text = LocalizationManager.GetTranslation("Sort") + ": " + LocalizationManager.GetTranslation(sortBy);
		}
		else if (sortCloudlandsVersion == 2)
		{
			CL2OrderText.text = LocalizationManager.GetTranslation("Sort") + ": " + LocalizationManager.GetTranslation(sortBy);
		}
	}

	public void SortByPars(string x)
	{
		CloseDropdown();
		sortPars = x;
		if (sortCloudlandsVersion == 1)
		{
			if (HoleSelectPanel.instance.currentTag == CurrentTag.Holes)
			{
				if (x == "zero")
				{
					CL1HoleParsText.text = LocalizationManager.GetTranslation("Pars") + ": 0";
				}
				else if (x == "")
				{
					CL1HoleParsText.text = LocalizationManager.GetTranslation("Pars") + ": All Pars";
				}
				else
				{
					CL1HoleParsText.text = LocalizationManager.GetTranslation("Pars") + ": " + x;
				}
			}
			else if (x == "zero")
			{
				CL1PlaylistParsText.text = LocalizationManager.GetTranslation("Pars") + ": 0";
			}
			else if (x == "")
			{
				CL1PlaylistParsText.text = LocalizationManager.GetTranslation("Pars") + ": " + LocalizationManager.GetTranslation("All Pars");
			}
			else
			{
				CL1PlaylistParsText.text = LocalizationManager.GetTranslation("Pars") + ": " + x;
			}
		}
		else
		{
			if (sortCloudlandsVersion != 2)
			{
				return;
			}
			if (HoleSelectPanel.instance.currentTag == CurrentTag.Holes)
			{
				if (x == "zero")
				{
					CL2HoleParsText.text = LocalizationManager.GetTranslation("Pars") + ": 0";
				}
				else if (x == "")
				{
					CL2HoleParsText.text = LocalizationManager.GetTranslation("Pars") + ": " + LocalizationManager.GetTranslation("All Pars");
				}
				else
				{
					CL2HoleParsText.text = LocalizationManager.GetTranslation("Pars") + ": " + x;
				}
			}
			else if (x == "zero")
			{
				CL2PlaylistParsText.text = LocalizationManager.GetTranslation("Pars") + ": 0";
			}
			else if (x == "")
			{
				CL2PlaylistParsText.text = LocalizationManager.GetTranslation("Pars") + ": " + LocalizationManager.GetTranslation("All Pars");
			}
			else
			{
				CL2PlaylistParsText.text = LocalizationManager.GetTranslation("Pars") + ": " + x;
			}
		}
	}

	public void SortByHoleCount(string x)
	{
		CloseDropdown();
		sortHoleCount = x;
		if (sortCloudlandsVersion == 1)
		{
			if (x == "")
			{
				CL1HoleCountText.text = LocalizationManager.GetTranslation("Hole Count") + ": " + LocalizationManager.GetTranslation("All");
			}
			else
			{
				CL1HoleCountText.text = LocalizationManager.GetTranslation("Hole Count") + ": " + x;
			}
		}
		else if (sortCloudlandsVersion == 2)
		{
			if (x == "")
			{
				CL2HoleCountText.text = LocalizationManager.GetTranslation("Hole Count") + ": " + LocalizationManager.GetTranslation("All");
			}
			else
			{
				CL2HoleCountText.text = LocalizationManager.GetTranslation("Hole Count") + ": " + x;
			}
		}
	}

	public void SortByDifficulty(string x)
	{
		CloseDropdown();
		sortDifficulty = x;
		if (sortCloudlandsVersion == 1)
		{
			if (x == "")
			{
				CL1DifficultyText.text = LocalizationManager.GetTranslation("Difficulty: All");
			}
			else
			{
				CL1DifficultyText.text = LocalizationManager.GetTranslation("Difficulty") + ": " + x;
			}
		}
		else if (sortCloudlandsVersion == 2)
		{
			if (x == "")
			{
				CL2DifficultyText.text = LocalizationManager.GetTranslation("Difficulty: All");
			}
			else
			{
				CL2DifficultyText.text = LocalizationManager.GetTranslation("Difficulty") + ": " + x;
			}
		}
	}

	public void SortByWind(int x)
	{
		CloseDropdown();
		sortWind = x;
		switch (x)
		{
		case -1:
			CL2WindText.text = LocalizationManager.GetTranslation("Wind: All");
			break;
		case 0:
			CL2WindText.text = LocalizationManager.GetTranslation("Wind") + ": " + LocalizationManager.GetTranslation("No Wind");
			break;
		case 1:
			CL2WindText.text = LocalizationManager.GetTranslation("Wind") + ": " + LocalizationManager.GetTranslation("Wind Only");
			break;
		}
	}

	public void ToggleDriver()
	{
		if (putterAllowed || ironAllowed)
		{
			driverAllowed = !driverAllowed;
			driverCheckmark.enabled = driverAllowed;
			AdjustAllowableClubs();
		}
	}

	public void ToggleIron()
	{
		if (driverAllowed || putterAllowed)
		{
			ironAllowed = !ironAllowed;
			ironCheckmark.enabled = ironAllowed;
			AdjustAllowableClubs();
		}
	}

	public void TogglePutter()
	{
		if (driverAllowed || ironAllowed)
		{
			putterAllowed = !putterAllowed;
			putterCheckmark.enabled = putterAllowed;
			AdjustAllowableClubs();
		}
	}

	public void ToggleMustIncludeSelected()
	{
		mustIncludeSelected = !mustIncludeSelected;
		mustIncludeSelectedCheckmark.enabled = mustIncludeSelected;
	}

	private void AdjustAllowableClubs()
	{
		if (sortCloudlandsVersion == 1)
		{
			sortGolfClub = 7;
			return;
		}
		sortGolfClub = 0;
		string text = LocalizationManager.GetTranslation("Clubs") + ": ";
		if (driverAllowed && ironAllowed && putterAllowed)
		{
			sortGolfClub = 7;
			text += LocalizationManager.GetTranslation("All");
		}
		else
		{
			if (driverAllowed)
			{
				sortGolfClub += 4;
				text += LocalizationManager.GetTranslation("Driver");
			}
			if (ironAllowed)
			{
				sortGolfClub += 2;
				text = ((!driverAllowed) ? (text + LocalizationManager.GetTranslation("Iron")) : (text + "/ " + LocalizationManager.GetTranslation("Iron")));
			}
			if (putterAllowed)
			{
				sortGolfClub++;
				text = ((!ironAllowed && !driverAllowed) ? (text + LocalizationManager.GetTranslation("Putter")) : (text + "/ " + LocalizationManager.GetTranslation("Putter")));
			}
		}
		CL2GolfClubText.text = text;
	}

	public void SortByCloudlandsVersion(int x)
	{
		ResetQuery();
		CloseDropdown();
		sortCloudlandsVersion = x;
		if (HoleSelectPanel.instance.currentTag == CurrentTag.Holes)
		{
			SwitchToHoleFilter();
		}
		else
		{
			SwitchToPlaylistFilter();
		}
		SetCloudlandsVersionTab();
		Search();
	}

	public void SetCloudlandsVersionTab()
	{
		if (sortCloudlandsVersion == 1)
		{
			cloudlands1Text.Active(x: true);
			cloudlands2Text.Active(x: false);
			cloudlands1SearchFilters.SetActive(value: true);
			cloudlands2SearchFilters.SetActive(value: false);
		}
		else if (sortCloudlandsVersion == 2)
		{
			cloudlands1Text.Active(x: false);
			cloudlands2Text.Active(x: true);
			cloudlands1SearchFilters.SetActive(value: false);
			cloudlands2SearchFilters.SetActive(value: true);
		}
	}

	public void ResetQuery()
	{
		sortName = "";
		sortOrder = "Newest";
		sortPars = "";
		sortDifficulty = "";
		sortGolfClub = 7;
		sortHoleCount = "";
		inputText.text = LocalizationManager.GetTranslation("Search Name");
		CL1OrderText.text = LocalizationManager.GetTranslation("Sort: Newest");
		CL1HoleParsText.text = LocalizationManager.GetTranslation("Pars") + ": " + LocalizationManager.GetTranslation("All Pars");
		CL1DifficultyText.text = LocalizationManager.GetTranslation("Difficulty: All");
		CL1HoleCountText.text = LocalizationManager.GetTranslation("Hole Count") + ": " + LocalizationManager.GetTranslation("All");
		CL1PlaylistParsText.text = LocalizationManager.GetTranslation("Pars") + ": " + LocalizationManager.GetTranslation("All Pars");
		CL2OrderText.text = LocalizationManager.GetTranslation("Sort: Newest");
		CL2HoleParsText.text = LocalizationManager.GetTranslation("Pars") + ": " + LocalizationManager.GetTranslation("All Pars");
		CL2DifficultyText.text = LocalizationManager.GetTranslation("Difficulty: All");
		CL2GolfClubText.text = LocalizationManager.GetTranslation("Clubs: All");
		CL2HoleCountText.text = LocalizationManager.GetTranslation("Hole Count") + ": " + LocalizationManager.GetTranslation("All");
		CL2PlaylistParsText.text = LocalizationManager.GetTranslation("Pars") + ": " + LocalizationManager.GetTranslation("All Pars");
		CL2WindText.text = LocalizationManager.GetTranslation("Wind: All");
		searchFilters = new SearchFilters();
		searchFilters.CloudlandsVersion = sortCloudlandsVersion;
		CloseDropdown();
		driverAllowed = true;
		ironAllowed = true;
		putterAllowed = true;
		mustIncludeSelected = false;
		driverCheckmark.enabled = true;
		ironCheckmark.enabled = true;
		putterCheckmark.enabled = true;
		mustIncludeSelectedCheckmark.enabled = false;
	}

	public void Search()
	{
		CloseDropdown();
		searchFilters.sortOrder = sortOrder;
		searchFilters.sortPars = sortPars;
		searchFilters.sortDifficulty = sortDifficulty.Replace(" ", "");
		searchFilters.sortName = sortName;
		searchFilters.CloudlandsVersion = sortCloudlandsVersion;
		searchFilters.golfClub = sortGolfClub;
		searchFilters.sortHoleCount = sortHoleCount;
		searchFilters.sortWind = sortWind;
		searchFilters.mustIncludeSelected = mustIncludeSelected;
		HoleSelectPanel.instance.Search(searchFilters);
		CloseSearchMenu();
	}

	public void SwitchToHoleFilter()
	{
		ResetQuery();
		if (sortCloudlandsVersion == 1)
		{
			cloudlands1SearchFilters.SetActive(value: true);
			cloudlands2SearchFilters.SetActive(value: false);
			CL1OrderImage.gameObject.SetActive(value: true);
			CL1HoleParsImage.gameObject.SetActive(value: true);
			CL1DifficultyImage.gameObject.SetActive(value: true);
			CL1PlaylistParsImage.gameObject.SetActive(value: false);
			CL1HoleCountImage.gameObject.SetActive(value: false);
		}
		else if (sortCloudlandsVersion == 2)
		{
			cloudlands1SearchFilters.SetActive(value: false);
			cloudlands2SearchFilters.SetActive(value: true);
			CL2OrderImage.gameObject.SetActive(value: true);
			CL2HoleParsImage.gameObject.SetActive(value: true);
			CL2DifficultyImage.gameObject.SetActive(value: true);
			CL2PlaylistParsImage.gameObject.SetActive(value: false);
			CL2HoleCountImage.gameObject.SetActive(value: false);
			CL2GolfClubImage.gameObject.SetActive(value: true);
			CL2WindImage.gameObject.SetActive(value: true);
		}
	}

	public void SwitchToPlaylistFilter()
	{
		ResetQuery();
		if (sortCloudlandsVersion == 1)
		{
			cloudlands1SearchFilters.SetActive(value: true);
			cloudlands2SearchFilters.SetActive(value: false);
			CL1OrderImage.gameObject.SetActive(value: false);
			CL1HoleParsImage.gameObject.SetActive(value: false);
			CL1DifficultyImage.gameObject.SetActive(value: false);
			CL1PlaylistParsImage.gameObject.SetActive(value: true);
			CL1HoleCountImage.gameObject.SetActive(value: true);
		}
		else if (sortCloudlandsVersion == 2)
		{
			cloudlands1SearchFilters.SetActive(value: false);
			cloudlands2SearchFilters.SetActive(value: true);
			CL2OrderImage.gameObject.SetActive(value: true);
			CL2HoleParsImage.gameObject.SetActive(value: false);
			CL2DifficultyImage.gameObject.SetActive(value: false);
			CL2PlaylistParsImage.gameObject.SetActive(value: true);
			CL2HoleCountImage.gameObject.SetActive(value: true);
			CL2GolfClubImage.gameObject.SetActive(value: false);
			CL2WindImage.gameObject.SetActive(value: false);
		}
	}

	public void CloseSearchMenu()
	{
		CloseDropdown();
		base.gameObject.SetActive(value: false);
	}

	public void OpenSearchMenu()
	{
		CloseDropdown();
		base.gameObject.SetActive(value: true);
	}

	public void OpenKeyboard()
	{
		CloseDropdown();
		if (!keyboard.activeSelf && !keyboard.activeSelf)
		{
			tempInputText = inputText.text;
			previousKeyboardText = inputText.text;
			if (tempInputText == "Search Name")
			{
				tempInputText = "";
			}
			keyboard.SetActive(value: true);
		}
	}

	public void InputKey(string s)
	{
		CloseDropdown();
		switch (s)
		{
		case "enter":
			keyboard.SetActive(value: false);
			if (tempInputText.Length == 0 || (tempInputText.Contains("|") && tempInputText.Length == 1))
			{
				tempInputText = "Search Name";
				sortName = "";
			}
			else if (tempInputText.Contains("|"))
			{
				tempInputText.Remove(tempInputText.Length - 1);
			}
			else
			{
				sortName = tempInputText;
			}
			inputText.text = tempInputText;
			break;
		case "delete":
			if (tempInputText.Length > 0)
			{
				tempInputText = tempInputText.Substring(0, tempInputText.Length - 1);
			}
			break;
		case "close":
			if (tempInputText.Contains("|"))
			{
				tempInputText.Remove(tempInputText.Length - 1);
			}
			inputText.text = previousKeyboardText;
			keyboard.SetActive(value: false);
			break;
		default:
			if (tempInputText.Length < 12)
			{
				tempInputText += s;
			}
			break;
		}
	}

	private string CaretText(string text)
	{
		string text2 = text;
		caretTimer += Time.deltaTime;
		if (caretTimer > 1f)
		{
			caretTimer = 0f;
		}
		else if (caretTimer > 0.5f)
		{
			text2 += "|";
		}
		return text2;
	}
}
public class ScoreSceneManager : MonoBehaviour
{
	public GameObject singlePlayerScoreboard;

	public GameObject multiplayerPlayerScoreboard;

	private void Start()
	{
		PhotonNetwork.LocalPlayer.SetHoleFinished(value: false);
		PhotonNetwork.LocalPlayer.SetReadyToStart(value: false);
		if (PhotonNetwork.IsConnected)
		{
			new List<WorkshopData>();
		}
		if ((PhotonNetwork.IsConnected && PhotonManager.instance.GetUsablePlayers().Count > 1) || GameManager.instance.playerCount > 1)
		{
			multiplayerPlayerScoreboard.SetActive(value: true);
		}
		else
		{
			singlePlayerScoreboard.SetActive(value: true);
		}
		if (GameManager.instance.IsPlaylist())
		{
			if (GameManager.instance.playlistLeaderboardData.cloudlandsPlaylist)
			{
				GameManager.instance.SpawnHoleInfoNotification(rating: false);
			}
			else
			{
				GameManager.instance.SpawnHoleInfoNotification(rating: true);
			}
			GameManager.instance.holeInfoNotification.GetComponentInChildren<HoleLeaderboard>().updatingPlaylist = true;
		}
		CheckAchievements();
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.O))
		{
			GameManager.instance.SpawnHoleInfoNotification(rating: true);
		}
	}

	private void CheckAchievements()
	{
		if (PhotonNetwork.IsConnected && PhotonManager.instance.GetUsablePlayers().Count > 1)
		{
			GameManager.instance.gameAchievements.UnlockAchievement(Achievement.PLAY_ONLINE);
		}
		for (int i = 0; i < GameManager.instance.playerCount; i++)
		{
			if (!ScoreManager.instance.playerTurn[i].mulliganUsed)
			{
				GameManager.instance.gameAchievements.UnlockAchievement(Achievement.NO_MULLIGANS);
			}
		}
	}
}
public class SliderControl : MonoBehaviour
{
	public Transform startPos;

	public Transform endPos;

	public bool dragging;
}
public class StartScene : MonoBehaviour
{
	public Transform playerSpawnLocation;

	private Scene mainScene;

	private float holeShadowDistance = 75f;

	private float defaultShadowDistance = 30f;

	private void Start()
	{
		bool flag = false;
		for (int i = 0; i < SceneManager.sceneCount; i++)
		{
			if (SceneManager.GetSceneAt(i).name == "Main")
			{
				flag = true;
				break;
			}
		}
		if (!flag)
		{
			mainScene = SceneManager.GetSceneByName("Main");
			if (!mainScene.IsValid() || !mainScene.isLoaded)
			{
				SceneManager.LoadScene("Main", LoadSceneMode.Additive);
			}
		}
		StartCoroutine(SetCurrentScene());
	}

	private IEnumerator SetCurrentScene()
	{
		yield return null;
		ScoreManager.instance.ballScored = false;
		GameManager.instance.SetCurrentScene(base.gameObject.scene);
		SetShadowQuality();
		while (GameManager.instance == null)
		{
			yield return null;
		}
		Player.instance.RotateHeadToFacePosition(playerSpawnLocation);
		if (GameManager.instance.controllerType != ControllerType.FPS)
		{
			if (GameManager.instance.publishedPlatform == PublishedPlatform.XR && !Player.instance.autoWarp.warpToCenter)
			{
				if (GameManager.instance.currentSceneName != "CustomHoleScene")
				{
					Player.instance.transform.position = Player.instance.autoWarp.ReturnHeadToTargetWarp(playerSpawnLocation.position);
				}
			}
			else
			{
				Player.instance.transform.position = playerSpawnLocation.position;
			}
		}
		else
		{
			Vector3 position = playerSpawnLocation.position;
			position.y += 0.2f;
			Player.instance.transform.position = position;
		}
		Player.instance.autoWarp.SetSwitchClubs();
		MonoBehaviour.print(GameManager.instance.currentSceneName);
		if (GameManager.instance.currentSceneName != "LevelEditor" && GameManager.instance.currentSceneName != "LevelEditorArt")
		{
			GameManager.instance.player.SwitchToClub();
			Player.instance.clubSwitcher.ResetClubVelocities();
		}
		if (PhotonNetwork.InRoom && (bool)RoomRPC.instance.photonBall)
		{
			RoomRPC.instance.photonBall.NewSceneLoaded();
		}
		if (GameManager.instance.controllerType == ControllerType.XR)
		{
			yield return new WaitForSeconds(0.5f);
		}
	}

	private void SetShadowQuality()
	{
		if (GameManager.instance.currentSceneName == "CustomHoleScene" || GameManager.instance.currentSceneName == "LevelEditor")
		{
			QualitySettings.shadowDistance = holeShadowDistance;
		}
		else
		{
			QualitySettings.shadowDistance = defaultShadowDistance;
		}
	}
}
public class TextureScaler
{
	private static RenderTexture rtt;

	public static Texture2D scaled(Texture2D src, int width, int height, FilterMode mode = FilterMode.Trilinear)
	{
		Rect source = new Rect(0f, 0f, width, height);
		_gpu_scale(src, width, height, mode);
		Texture2D texture2D = new Texture2D(width, height, TextureFormat.ARGB32, mipChain: true);
		texture2D.Resize(width, height);
		texture2D.ReadPixels(source, 0, 0, recalculateMipMaps: false);
		return texture2D;
	}

	public static void scale(Texture2D tex, int width, int height, FilterMode mode = FilterMode.Trilinear)
	{
		Rect source = new Rect(0f, 0f, width, height);
		_gpu_scale(tex, width, height, mode);
		tex.Resize(width, height);
		tex.ReadPixels(source, 0, 0, recalculateMipMaps: false);
		tex.Apply(updateMipmaps: true);
	}

	private static void _gpu_scale(Texture2D src, int width, int height, FilterMode fmode)
	{
		src.filterMode = fmode;
		src.Apply(updateMipmaps: true);
		rtt = new RenderTexture(width, height, 24);
		Graphics.SetRenderTarget(rtt);
		GL.LoadPixelMatrix(0f, 1f, 1f, 0f);
		GL.Clear(clearDepth: true, clearColor: true, new Color(0f, 0f, 0f, 0f));
		Graphics.DrawTexture(new Rect(0f, 0f, 1f, 1f), src);
	}
}
public class ToolTip : MonoBehaviour
{
	public TextMeshPro tipText;

	public Transform tipMesh;

	private Vector3 scale = new Vector3(0.5f, 0.5f, 0.1f);

	private string tip;

	private float scaleSpeed = 10f;

	private bool showTip;

	private void Update()
	{
		if (showTip)
		{
			ShowTip();
		}
		else
		{
			HideTip();
		}
	}

	public void SetTip(string x = null)
	{
		if (string.IsNullOrEmpty(x))
		{
			showTip = false;
			return;
		}
		showTip = true;
		tip = x;
		tipText.text = LocalizationManager.GetTranslation(tip);
	}

	private void ShowTip()
	{
		if (tip != "")
		{
			tipMesh.localScale = Vector3.Lerp(tipMesh.localScale, scale, scaleSpeed * Time.deltaTime);
		}
	}

	private void HideTip()
	{
		showTip = false;
		tipText.text = "";
		tipMesh.localScale = Vector3.Lerp(tipMesh.localScale, Vector3.zero, scaleSpeed * Time.deltaTime);
	}
}
public class WallBounce : MonoBehaviour
{
	private float bounceForce;

	private Vector3 velocity;

	private Vector3 forceVec;

	private float minimumBounceMultiplier = 0.2f;

	private float maximumBounceMultiplier = 0.5f;

	public Collider[] wallColliders;

	public bool slideAgainstWall;

	private void OnCollisionEnter(Collision other)
	{
		if (!(other.gameObject.GetComponent<Golfball>() != null))
		{
			return;
		}
		if (wallColliders == null || wallColliders.Length == 0)
		{
			BounceBack(other);
			return;
		}
		for (int i = 0; i < wallColliders.Length; i++)
		{
			if (wallColliders[i] == other.contacts[0].thisCollider)
			{
				BounceBack(other);
				break;
			}
		}
	}

	private void BounceBack(Collision other)
	{
		float magnitude = other.gameObject.GetComponent<Golfball>().previousVelocity.magnitude;
		float magnitude2 = other.rigidbody.velocity.magnitude;
		if (magnitude > magnitude2)
		{
			forceVec = other.gameObject.GetComponent<Golfball>().previousVelocity;
		}
		else
		{
			forceVec = other.rigidbody.velocity;
		}
		float num = Vector3.Angle(forceVec, other.contacts[0].normal);
		bounceForce = 1f - (Mathf.Abs(num - 90f) / 90f * maximumBounceMultiplier + minimumBounceMultiplier) * (1f / (1f + minimumBounceMultiplier));
		Vector3 zero = Vector3.zero;
		zero = ((slideAgainstWall && num > 30f) ? Vector3.Cross(Vector3.Cross(other.contacts[0].normal, forceVec), other.contacts[0].normal) : ((!(num > 90f)) ? (Vector3.Reflect(forceVec, other.contacts[0].normal) * bounceForce) : (forceVec * bounceForce)));
		other.rigidbody.velocity = zero;
		other.rigidbody.angularVelocity = Vector3.zero;
	}
}
public class XRHandGestureInput : MonoBehaviour
{
	private bool usingController;

	public Pointer pointer;

	public ButtonStatus buttonStatus;
}
public class SteamVR : IDisposable
{
	private static bool _enabled = true;

	private static SteamVR _instance;

	public static bool[] connected = new bool[64];

	public ETextureType textureType;

	public static bool active => _instance != null;

	public static bool enabled
	{
		get
		{
			if (!XRSettings.enabled)
			{
				enabled = false;
			}
			return _enabled;
		}
		set
		{
			_enabled = value;
			if (!_enabled)
			{
				SafeDispose();
			}
		}
	}

	public static SteamVR instance
	{
		get
		{
			if (!enabled)
			{
				return null;
			}
			if (_instance == null)
			{
				_instance = CreateInstance();
				if (_instance == null)
				{
					_enabled = false;
				}
			}
			return _instance;
		}
	}

	public static bool usingNativeSupport => XRDevice.GetNativePtr() != IntPtr.Zero;

	public CVRSystem hmd { get; private set; }

	public CVRCompositor compositor { get; private set; }

	public CVROverlay overlay { get; private set; }

	public static bool initializing { get; private set; }

	public static bool calibrating { get; private set; }

	public static bool outOfRange { get; private set; }

	public float sceneWidth { get; private set; }

	public float sceneHeight { get; private set; }

	public float aspect { get; private set; }

	public float fieldOfView { get; private set; }

	public Vector2 tanHalfFov { get; private set; }

	public VRTextureBounds_t[] textureBounds { get; private set; }

	public SteamVR_Utils.RigidTransform[] eyes { get; private set; }

	public string hmd_TrackingSystemName => GetStringProperty(ETrackedDeviceProperty.Prop_TrackingSystemName_String);

	public string hmd_ModelNumber => GetStringProperty(ETrackedDeviceProperty.Prop_ModelNumber_String);

	public string hmd_SerialNumber => GetStringProperty(ETrackedDeviceProperty.Prop_SerialNumber_String);

	public float hmd_SecondsFromVsyncToPhotons => GetFloatProperty(ETrackedDeviceProperty.Prop_SecondsFromVsyncToPhotons_Float);

	public float hmd_DisplayFrequency => GetFloatProperty(ETrackedDeviceProperty.Prop_DisplayFrequency_Float);

	private static SteamVR CreateInstance()
	{
		try
		{
			EVRInitError peError = EVRInitError.None;
			if (!usingNativeSupport)
			{
				UnityEngine.Debug.Log("OpenVR initialization failed.  Ensure 'Virtual Reality Supported' is checked in Player Settings, and OpenVR is added to the list of Virtual Reality SDKs.");
				return null;
			}
			OpenVR.GetGenericInterface("IVRCompositor_022", ref peError);
			if (peError != 0)
			{
				ReportError(peError);
				return null;
			}
			OpenVR.GetGenericInterface("IVROverlay_018", ref peError);
			if (peError != 0)
			{
				ReportError(peError);
				return null;
			}
		}
		catch (Exception message)
		{
			UnityEngine.Debug.LogError(message);
			return null;
		}
		return new SteamVR();
	}

	private static void ReportError(EVRInitError error)
	{
		switch (error)
		{
		case EVRInitError.VendorSpecific_UnableToConnectToOculusRuntime:
			UnityEngine.Debug.Log("SteamVR Initialization Failed!  Make sure device is on, Oculus runtime is installed, and OVRService_*.exe is running.");
			break;
		case EVRInitError.Init_VRClientDLLNotFound:
			UnityEngine.Debug.Log("SteamVR drivers not found!  They can be installed via Steam under Library > Tools.  Visit http://steampowered.com to install Steam.");
			break;
		case EVRInitError.Driver_RuntimeOutOfDate:
			UnityEngine.Debug.Log("SteamVR Initialization Failed!  Make sure device's runtime is up to date.");
			break;
		default:
			UnityEngine.Debug.Log(OpenVR.GetStringForHmdError(error));
			break;
		case EVRInitError.None:
			break;
		}
	}

	public string GetTrackedDeviceString(uint deviceId)
	{
		ETrackedPropertyError pError = ETrackedPropertyError.TrackedProp_Success;
		uint stringTrackedDeviceProperty = hmd.GetStringTrackedDeviceProperty(deviceId, ETrackedDeviceProperty.Prop_AttachedDeviceId_String, null, 0u, ref pError);
		if (stringTrackedDeviceProperty > 1)
		{
			StringBuilder stringBuilder = new StringBuilder((int)stringTrackedDeviceProperty);
			hmd.GetStringTrackedDeviceProperty(deviceId, ETrackedDeviceProperty.Prop_AttachedDeviceId_String, stringBuilder, stringTrackedDeviceProperty, ref pError);
			return stringBuilder.ToString();
		}
		return null;
	}

	public string GetStringProperty(ETrackedDeviceProperty prop, uint deviceId = 0u)
	{
		ETrackedPropertyError pError = ETrackedPropertyError.TrackedProp_Success;
		uint stringTrackedDeviceProperty = hmd.GetStringTrackedDeviceProperty(deviceId, prop, null, 0u, ref pError);
		if (stringTrackedDeviceProperty > 1)
		{
			StringBuilder stringBuilder = new StringBuilder((int)stringTrackedDeviceProperty);
			hmd.GetStringTrackedDeviceProperty(deviceId, prop, stringBuilder, stringTrackedDeviceProperty, ref pError);
			return stringBuilder.ToString();
		}
		if (pError == ETrackedPropertyError.TrackedProp_Success)
		{
			return "<unknown>";
		}
		return pError.ToString();
	}

	public float GetFloatProperty(ETrackedDeviceProperty prop, uint deviceId = 0u)
	{
		ETrackedPropertyError pError = ETrackedPropertyError.TrackedProp_Success;
		return hmd.GetFloatTrackedDeviceProperty(deviceId, prop, ref pError);
	}

	private void OnInitializing(bool initializing)
	{
		SteamVR.initializing = initializing;
	}

	private void OnCalibrating(bool calibrating)
	{
		SteamVR.calibrating = calibrating;
	}

	private void OnOutOfRange(bool outOfRange)
	{
		SteamVR.outOfRange = outOfRange;
	}

	private void OnDeviceConnected(int i, bool connected)
	{
		SteamVR.connected[i] = connected;
	}

	private void OnNewPoses(TrackedDevicePose_t[] poses)
	{
		eyes[0] = new SteamVR_Utils.RigidTransform(hmd.GetEyeToHeadTransform(EVREye.Eye_Left));
		eyes[1] = new SteamVR_Utils.RigidTransform(hmd.GetEyeToHeadTransform(EVREye.Eye_Right));
		for (int i = 0; i < poses.Length; i++)
		{
			bool bDeviceIsConnected = poses[i].bDeviceIsConnected;
			if (bDeviceIsConnected != connected[i])
			{
				SteamVR_Events.DeviceConnected.Send(i, bDeviceIsConnected);
			}
		}
		if ((long)poses.Length > 0L)
		{
			ETrackingResult eTrackingResult = poses[0].eTrackingResult;
			bool flag = eTrackingResult == ETrackingResult.Uninitialized;
			if (flag != initializing)
			{
				SteamVR_Events.Initializing.Send(flag);
			}
			bool flag2 = eTrackingResult == ETrackingResult.Calibrating_InProgress || eTrackingResult == ETrackingResult.Calibrating_OutOfRange;
			if (flag2 != calibrating)
			{
				SteamVR_Events.Calibrating.Send(flag2);
			}
			bool flag3 = eTrackingResult == ETrackingResult.Running_OutOfRange || eTrackingResult == ETrackingResult.Calibrating_OutOfRange;
			if (flag3 != outOfRange)
			{
				SteamVR_Events.OutOfRange.Send(flag3);
			}
		}
	}

	private SteamVR()
	{
		hmd = OpenVR.System;
		UnityEngine.Debug.Log("Connected to " + hmd_TrackingSystemName + ":" + hmd_SerialNumber);
		compositor = OpenVR.Compositor;
		overlay = OpenVR.Overlay;
		uint pnWidth = 0u;
		uint pnHeight = 0u;
		hmd.GetRecommendedRenderTargetSize(ref pnWidth, ref pnHeight);
		sceneWidth = pnWidth;
		sceneHeight = pnHeight;
		float pfLeft = 0f;
		float pfRight = 0f;
		float pfTop = 0f;
		float pfBottom = 0f;
		hmd.GetProjectionRaw(EVREye.Eye_Left, ref pfLeft, ref pfRight, ref pfTop, ref pfBottom);
		float pfLeft2 = 0f;
		float pfRight2 = 0f;
		float pfTop2 = 0f;
		float pfBottom2 = 0f;
		hmd.GetProjectionRaw(EVREye.Eye_Right, ref pfLeft2, ref pfRight2, ref pfTop2, ref pfBottom2);
		tanHalfFov = new Vector2(Mathf.Max(0f - pfLeft, pfRight, 0f - pfLeft2, pfRight2), Mathf.Max(0f - pfTop, pfBottom, 0f - pfTop2, pfBottom2));
		textureBounds = new VRTextureBounds_t[2];
		textureBounds[0].uMin = 0.5f + 0.5f * pfLeft / tanHalfFov.x;
		textureBounds[0].uMax = 0.5f + 0.5f * pfRight / tanHalfFov.x;
		textureBounds[0].vMin = 0.5f - 0.5f * pfBottom / tanHalfFov.y;
		textureBounds[0].vMax = 0.5f - 0.5f * pfTop / tanHalfFov.y;
		textureBounds[1].uMin = 0.5f + 0.5f * pfLeft2 / tanHalfFov.x;
		textureBounds[1].uMax = 0.5f + 0.5f * pfRight2 / tanHalfFov.x;
		textureBounds[1].vMin = 0.5f - 0.5f * pfBottom2 / tanHalfFov.y;
		textureBounds[1].vMax = 0.5f - 0.5f * pfTop2 / tanHalfFov.y;
		sceneWidth /= Mathf.Max(textureBounds[0].uMax - textureBounds[0].uMin, textureBounds[1].uMax - textureBounds[1].uMin);
		sceneHeight /= Mathf.Max(textureBounds[0].vMax - textureBounds[0].vMin, textureBounds[1].vMax - textureBounds[1].vMin);
		aspect = tanHalfFov.x / tanHalfFov.y;
		fieldOfView = 2f * Mathf.Atan(tanHalfFov.y) * 57.29578f;
		eyes = new SteamVR_Utils.RigidTransform[2]
		{
			new SteamVR_Utils.RigidTransform(hmd.GetEyeToHeadTransform(EVREye.Eye_Left)),
			new SteamVR_Utils.RigidTransform(hmd.GetEyeToHeadTransform(EVREye.Eye_Right))
		};
		switch (SystemInfo.graphicsDeviceType)
		{
		case GraphicsDeviceType.OpenGLES2:
		case GraphicsDeviceType.OpenGLES3:
		case GraphicsDeviceType.OpenGLCore:
			textureType = ETextureType.OpenGL;
			break;
		case GraphicsDeviceType.Vulkan:
			textureType = ETextureType.Vulkan;
			break;
		default:
			textureType = ETextureType.DirectX;
			break;
		}
		SteamVR_Events.Initializing.Listen(OnInitializing);
		SteamVR_Events.Calibrating.Listen(OnCalibrating);
		SteamVR_Events.OutOfRange.Listen(OnOutOfRange);
		SteamVR_Events.DeviceConnected.Listen(OnDeviceConnected);
		SteamVR_Events.NewPoses.Listen(OnNewPoses);
	}

	~SteamVR()
	{
		Dispose(disposing: false);
	}

	public void Dispose()
	{
		Dispose(disposing: true);
		GC.SuppressFinalize(this);
	}

	private void Dispose(bool disposing)
	{
		SteamVR_Events.Initializing.Remove(OnInitializing);
		SteamVR_Events.Calibrating.Remove(OnCalibrating);
		SteamVR_Events.OutOfRange.Remove(OnOutOfRange);
		SteamVR_Events.DeviceConnected.Remove(OnDeviceConnected);
		SteamVR_Events.NewPoses.Remove(OnNewPoses);
		_instance = null;
	}

	public static void SafeDispose()
	{
		if (_instance != null)
		{
			_instance.Dispose();
		}
	}
}
[RequireComponent(typeof(Camera))]
public class SteamVR_Camera : MonoBehaviour
{
	[SerializeField]
	private Transform _head;

	[SerializeField]
	private Transform _ears;

	public bool wireframe;

	private static System.Collections.Hashtable values;

	private const string eyeSuffix = " (eye)";

	private const string earsSuffix = " (ears)";

	private const string headSuffix = " (head)";

	private const string originSuffix = " (origin)";

	public Transform head => _head;

	public Transform offset => _head;

	public Transform origin => _head.parent;

	public Camera camera { get; private set; }

	public Transform ears => _ears;

	public static float sceneResolutionScale
	{
		get
		{
			return XRSettings.eyeTextureResolutionScale;
		}
		set
		{
			XRSettings.eyeTextureResolutionScale = value;
		}
	}

	public string baseName
	{
		get
		{
			if (!base.name.EndsWith(" (eye)"))
			{
				return base.name;
			}
			return base.name.Substring(0, base.name.Length - " (eye)".Length);
		}
	}

	public Ray GetRay()
	{
		return new Ray(_head.position, _head.forward);
	}

	private void OnDisable()
	{
		SteamVR_Render.Remove(this);
	}

	private void OnEnable()
	{
		if (SteamVR.instance == null)
		{
			if (head != null)
			{
				head.GetComponent<SteamVR_TrackedObject>().enabled = false;
			}
			base.enabled = false;
			return;
		}
		Transform transform = base.transform;
		if (head != transform)
		{
			Expand();
			transform.parent = origin;
			while (head.childCount > 0)
			{
				head.GetChild(0).parent = transform;
			}
			head.parent = transform;
			head.localPosition = Vector3.zero;
			head.localRotation = Quaternion.identity;
			head.localScale = Vector3.one;
			head.gameObject.SetActive(value: false);
			_head = transform;
		}
		if (ears == null)
		{
			SteamVR_Ears componentInChildren = base.transform.GetComponentInChildren<SteamVR_Ears>();
			if (componentInChildren != null)
			{
				_ears = componentInChildren.transform;
			}
		}
		if (ears != null)
		{
			ears.GetComponent<SteamVR_Ears>().vrcam = this;
		}
		SteamVR_Render.Add(this);
	}

	private void Awake()
	{
		camera = GetComponent<Camera>();
		ForceLast();
	}

	public void ForceLast()
	{
		if (values != null)
		{
			foreach (DictionaryEntry value in values)
			{
				(value.Key as FieldInfo).SetValue(this, value.Value);
			}
			values = null;
			return;
		}
		UnityEngine.Component[] components = GetComponents<UnityEngine.Component>();
		for (int i = 0; i < components.Length; i++)
		{
			SteamVR_Camera steamVR_Camera = components[i] as SteamVR_Camera;
			if (steamVR_Camera != null && steamVR_Camera != this)
			{
				UnityEngine.Object.DestroyImmediate(steamVR_Camera);
			}
		}
		if (!(this != GetComponents<UnityEngine.Component>()[^1]))
		{
			return;
		}
		values = new System.Collections.Hashtable();
		FieldInfo[] fields = GetType().GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
		foreach (FieldInfo fieldInfo in fields)
		{
			if (fieldInfo.IsPublic || fieldInfo.IsDefined(typeof(SerializeField), inherit: true))
			{
				values[fieldInfo] = fieldInfo.GetValue(this);
			}
		}
		GameObject obj = base.gameObject;
		UnityEngine.Object.DestroyImmediate(this);
		obj.AddComponent<SteamVR_Camera>().ForceLast();
	}

	public void Expand()
	{
		Transform parent = base.transform.parent;
		if (parent == null)
		{
			parent = new GameObject(base.name + " (origin)").transform;
			parent.localPosition = base.transform.localPosition;
			parent.localRotation = base.transform.localRotation;
			parent.localScale = base.transform.localScale;
		}
		if (head == null)
		{
			_head = new GameObject(base.name + " (head)", typeof(SteamVR_TrackedObject)).transform;
			head.parent = parent;
			head.position = base.transform.position;
			head.rotation = base.transform.rotation;
			head.localScale = Vector3.one;
			head.tag = base.tag;
		}
		if (base.transform.parent != head)
		{
			base.transform.parent = head;
			base.transform.localPosition = Vector3.zero;
			base.transform.localRotation = Quaternion.identity;
			base.transform.localScale = Vector3.one;
			while (base.transform.childCount > 0)
			{
				base.transform.GetChild(0).parent = head;
			}
			AudioListener component = GetComponent<AudioListener>();
			if (component != null)
			{
				UnityEngine.Object.DestroyImmediate(component);
				_ears = new GameObject(base.name + " (ears)", typeof(SteamVR_Ears)).transform;
				ears.parent = _head;
				ears.localPosition = Vector3.zero;
				ears.localRotation = Quaternion.identity;
				ears.localScale = Vector3.one;
			}
		}
		if (!base.name.EndsWith(" (eye)"))
		{
			base.name += " (eye)";
		}
	}

	public void Collapse()
	{
		base.transform.parent = null;
		while (head.childCount > 0)
		{
			head.GetChild(0).parent = base.transform;
		}
		if (ears != null)
		{
			while (ears.childCount > 0)
			{
				ears.GetChild(0).parent = base.transform;
			}
			UnityEngine.Object.DestroyImmediate(ears.gameObject);
			_ears = null;
			base.gameObject.AddComponent(typeof(AudioListener));
		}
		if (origin != null)
		{
			if (origin.name.EndsWith(" (origin)"))
			{
				Transform transform = origin;
				while (transform.childCount > 0)
				{
					transform.GetChild(0).parent = transform.parent;
				}
				UnityEngine.Object.DestroyImmediate(transform.gameObject);
			}
			else
			{
				base.transform.parent = origin;
			}
		}
		UnityEngine.Object.DestroyImmediate(head.gameObject);
		_head = null;
		if (base.name.EndsWith(" (eye)"))
		{
			base.name = base.name.Substring(0, base.name.Length - " (eye)".Length);
		}
	}
}
[ExecuteInEditMode]
public class SteamVR_CameraFlip : MonoBehaviour
{
	private void Awake()
	{
		UnityEngine.Debug.Log("SteamVR_CameraFlip is deprecated in Unity 5.4 - REMOVING");
		UnityEngine.Object.DestroyImmediate(this);
	}
}
[ExecuteInEditMode]
public class SteamVR_CameraMask : MonoBehaviour
{
	private void Awake()
	{
		UnityEngine.Debug.Log("SteamVR_CameraMask is deprecated in Unity 5.4 - REMOVING");
		UnityEngine.Object.DestroyImmediate(this);
	}
}
public class SteamVR_Controller
{
	public class ButtonMask
	{
		public const ulong System = 1uL;

		public const ulong ApplicationMenu = 2uL;

		public const ulong Grip = 4uL;

		public const ulong Axis0 = 4294967296uL;

		public const ulong Axis1 = 8589934592uL;

		public const ulong Axis2 = 17179869184uL;

		public const ulong Axis3 = 34359738368uL;

		public const ulong Axis4 = 68719476736uL;

		public const ulong Touchpad = 4294967296uL;

		public const ulong Trigger = 8589934592uL;
	}

	public class Device
	{
		private VRControllerState_t state;

		private VRControllerState_t prevState;

		private TrackedDevicePose_t pose;

		private int prevFrameCount = -1;

		public float hairTriggerDelta = 0.1f;

		private float hairTriggerLimit;

		private bool hairTriggerState;

		private bool hairTriggerPrevState;

		public uint index { get; private set; }

		public bool valid { get; private set; }

		public bool connected
		{
			get
			{
				Update();
				return pose.bDeviceIsConnected;
			}
		}

		public bool hasTracking
		{
			get
			{
				Update();
				return pose.bPoseIsValid;
			}
		}

		public bool outOfRange
		{
			get
			{
				Update();
				if (pose.eTrackingResult != ETrackingResult.Running_OutOfRange)
				{
					return pose.eTrackingResult == ETrackingResult.Calibrating_OutOfRange;
				}
				return true;
			}
		}

		public bool calibrating
		{
			get
			{
				Update();
				if (pose.eTrackingResult != ETrackingResult.Calibrating_InProgress)
				{
					return pose.eTrackingResult == ETrackingResult.Calibrating_OutOfRange;
				}
				return true;
			}
		}

		public bool uninitialized
		{
			get
			{
				Update();
				return pose.eTrackingResult == ETrackingResult.Uninitialized;
			}
		}

		public SteamVR_Utils.RigidTransform transform
		{
			get
			{
				Update();
				return new SteamVR_Utils.RigidTransform(pose.mDeviceToAbsoluteTracking);
			}
		}

		public Vector3 velocity
		{
			get
			{
				Update();
				return new Vector3(pose.vVelocity.v0, pose.vVelocity.v1, 0f - pose.vVelocity.v2);
			}
		}

		public Vector3 angularVelocity
		{
			get
			{
				Update();
				return new Vector3(0f - pose.vAngularVelocity.v0, 0f - pose.vAngularVelocity.v1, pose.vAngularVelocity.v2);
			}
		}

		public Device(uint i)
		{
			index = i;
		}

		public VRControllerState_t GetState()
		{
			Update();
			return state;
		}

		public VRControllerState_t GetPrevState()
		{
			Update();
			return prevState;
		}

		public TrackedDevicePose_t GetPose()
		{
			Update();
			return pose;
		}

		public void Update()
		{
			if (Time.frameCount != prevFrameCount)
			{
				prevFrameCount = Time.frameCount;
				prevState = state;
				CVRSystem system = OpenVR.System;
				if (system != null)
				{
					valid = system.GetControllerStateWithPose(SteamVR_Render.instance.trackingSpace, index, ref state, (uint)Marshal.SizeOf(typeof(VRControllerState_t)), ref pose);
					UpdateHairTrigger();
				}
			}
		}

		public bool GetPress(ulong buttonMask)
		{
			Update();
			return (state.ulButtonPressed & buttonMask) != 0;
		}

		public bool GetPressDown(ulong buttonMask)
		{
			Update();
			if ((state.ulButtonPressed & buttonMask) != 0L)
			{
				return (prevState.ulButtonPressed & buttonMask) == 0;
			}
			return false;
		}

		public bool GetPressUp(ulong buttonMask)
		{
			Update();
			if ((state.ulButtonPressed & buttonMask) == 0L)
			{
				return (prevState.ulButtonPressed & buttonMask) != 0;
			}
			return false;
		}

		public bool GetPress(EVRButtonId buttonId)
		{
			return GetPress((ulong)(1L << (int)buttonId));
		}

		public bool GetPressDown(EVRButtonId buttonId)
		{
			return GetPressDown((ulong)(1L << (int)buttonId));
		}

		public bool GetPressUp(EVRButtonId buttonId)
		{
			return GetPressUp((ulong)(1L << (int)buttonId));
		}

		public bool GetTouch(ulong buttonMask)
		{
			Update();
			return (state.ulButtonTouched & buttonMask) != 0;
		}

		public bool GetTouchDown(ulong buttonMask)
		{
			Update();
			if ((state.ulButtonTouched & buttonMask) != 0L)
			{
				return (prevState.ulButtonTouched & buttonMask) == 0;
			}
			return false;
		}

		public bool GetTouchUp(ulong buttonMask)
		{
			Update();
			if ((state.ulButtonTouched & buttonMask) == 0L)
			{
				return (prevState.ulButtonTouched & buttonMask) != 0;
			}
			return false;
		}

		public bool GetTouch(EVRButtonId buttonId)
		{
			return GetTouch((ulong)(1L << (int)buttonId));
		}

		public bool GetTouchDown(EVRButtonId buttonId)
		{
			return GetTouchDown((ulong)(1L << (int)buttonId));
		}

		public bool GetTouchUp(EVRButtonId buttonId)
		{
			return GetTouchUp((ulong)(1L << (int)buttonId));
		}

		public Vector2 GetAxis(EVRButtonId buttonId = EVRButtonId.k_EButton_Axis0)
		{
			Update();
			return (uint)buttonId switch
			{
				32u => new Vector2(state.rAxis0.x, state.rAxis0.y), 
				33u => new Vector2(state.rAxis1.x, state.rAxis1.y), 
				34u => new Vector2(state.rAxis2.x, state.rAxis2.y), 
				35u => new Vector2(state.rAxis3.x, state.rAxis3.y), 
				36u => new Vector2(state.rAxis4.x, state.rAxis4.y), 
				_ => Vector2.zero, 
			};
		}

		public void TriggerHapticPulse(ushort durationMicroSec = 500, EVRButtonId buttonId = EVRButtonId.k_EButton_Axis0)
		{
			CVRSystem system = OpenVR.System;
			if (system != null)
			{
				uint unAxisId = (uint)(buttonId - 32);
				system.TriggerHapticPulse(index, unAxisId, (char)durationMicroSec);
			}
		}

		private void UpdateHairTrigger()
		{
			hairTriggerPrevState = hairTriggerState;
			float x = state.rAxis1.x;
			if (hairTriggerState)
			{
				if (x < hairTriggerLimit - hairTriggerDelta || x <= 0f)
				{
					hairTriggerState = false;
				}
			}
			else if (x > hairTriggerLimit + hairTriggerDelta || x >= 1f)
			{
				hairTriggerState = true;
			}
			hairTriggerLimit = (hairTriggerState ? Mathf.Max(hairTriggerLimit, x) : Mathf.Min(hairTriggerLimit, x));
		}

		public bool GetHairTrigger()
		{
			Update();
			return hairTriggerState;
		}

		public bool GetHairTriggerDown()
		{
			Update();
			if (hairTriggerState)
			{
				return !hairTriggerPrevState;
			}
			return false;
		}

		public bool GetHairTriggerUp()
		{
			Update();
			if (!hairTriggerState)
			{
				return hairTriggerPrevState;
			}
			return false;
		}
	}

	public enum DeviceRelation
	{
		First,
		Leftmost,
		Rightmost,
		FarthestLeft,
		FarthestRight
	}

	private static Device[] devices;

	public static Device Input(int deviceIndex)
	{
		if (devices == null)
		{
			devices = new Device[64];
			for (uint num = 0u; num < devices.Length; num++)
			{
				devices[num] = new Device(num);
			}
		}
		return devices[deviceIndex];
	}

	public static void Update()
	{
		for (int i = 0; (long)i < 64L; i++)
		{
			Input(i).Update();
		}
	}

	public static int GetDeviceIndex(DeviceRelation relation, ETrackedDeviceClass deviceClass = ETrackedDeviceClass.Controller, int relativeTo = 0)
	{
		int result = -1;
		SteamVR_Utils.RigidTransform rigidTransform = (((uint)relativeTo < 64u) ? Input(relativeTo).transform.GetInverse() : SteamVR_Utils.RigidTransform.identity);
		CVRSystem system = OpenVR.System;
		if (system == null)
		{
			return result;
		}
		float num = float.MinValue;
		for (int i = 0; (long)i < 64L; i++)
		{
			if (i == relativeTo || system.GetTrackedDeviceClass((uint)i) != deviceClass)
			{
				continue;
			}
			Device device = Input(i);
			if (device.connected)
			{
				if (relation == DeviceRelation.First)
				{
					return i;
				}
				Vector3 vector = rigidTransform * device.transform.pos;
				float num3;
				switch (relation)
				{
				case DeviceRelation.FarthestRight:
					num3 = vector.x;
					break;
				case DeviceRelation.FarthestLeft:
					num3 = 0f - vector.x;
					break;
				default:
				{
					Vector3 normalized = new Vector3(vector.x, 0f, vector.z).normalized;
					float num2 = Vector3.Dot(normalized, Vector3.forward);
					Vector3 vector2 = Vector3.Cross(normalized, Vector3.forward);
					num3 = ((relation != DeviceRelation.Leftmost) ? ((vector2.y < 0f) ? (2f - num2) : num2) : ((vector2.y > 0f) ? (2f - num2) : num2));
					break;
				}
				}
				if (num3 > num)
				{
					result = i;
					num = num3;
				}
			}
		}
		return result;
	}
}
public class SteamVR_ControllerManager : MonoBehaviour
{
	public GameObject left;

	public GameObject right;

	[Tooltip("Populate with objects you want to assign to additional controllers")]
	public GameObject[] objects;

	[Tooltip("Set to true if you want objects arbitrarily assigned to controllers before their role (left vs right) is identified")]
	public bool assignAllBeforeIdentified;

	private uint[] indices;

	private bool[] connected = new bool[64];

	private uint leftIndex = uint.MaxValue;

	private uint rightIndex = uint.MaxValue;

	private SteamVR_Events.Action inputFocusAction;

	private SteamVR_Events.Action deviceConnectedAction;

	private SteamVR_Events.Action trackedDeviceRoleChangedAction;

	private static string hiddenPrefix = "hidden (";

	private static string hiddenPostfix = ")";

	private static string[] labels = new string[2] { "left", "right" };

	private void SetUniqueObject(GameObject o, int index)
	{
		for (int i = 0; i < index; i++)
		{
			if (objects[i] == o)
			{
				return;
			}
		}
		objects[index] = o;
	}

	public void UpdateTargets()
	{
		GameObject[] array = objects;
		int num = ((array != null) ? array.Length : 0);
		objects = new GameObject[2 + num];
		SetUniqueObject(right, 0);
		SetUniqueObject(left, 1);
		for (int i = 0; i < num; i++)
		{
			SetUniqueObject(array[i], 2 + i);
		}
		indices = new uint[2 + num];
		for (int j = 0; j < indices.Length; j++)
		{
			indices[j] = uint.MaxValue;
		}
	}

	private void Awake()
	{
		UpdateTargets();
	}

	private SteamVR_ControllerManager()
	{
		inputFocusAction = SteamVR_Events.InputFocusAction(OnInputFocus);
		deviceConnectedAction = SteamVR_Events.DeviceConnectedAction(OnDeviceConnected);
		trackedDeviceRoleChangedAction = SteamVR_Events.SystemAction(EVREventType.VREvent_TrackedDeviceRoleChanged, OnTrackedDeviceRoleChanged);
	}

	private void OnEnable()
	{
		for (int i = 0; i < objects.Length; i++)
		{
			GameObject gameObject = objects[i];
			if (gameObject != null)
			{
				gameObject.SetActive(value: false);
			}
			indices[i] = uint.MaxValue;
		}
		Refresh();
		for (int j = 0; j < SteamVR.connected.Length; j++)
		{
			if (SteamVR.connected[j])
			{
				OnDeviceConnected(j, connected: true);
			}
		}
		inputFocusAction.enabled = true;
		deviceConnectedAction.enabled = true;
		trackedDeviceRoleChangedAction.enabled = true;
	}

	private void OnDisable()
	{
		inputFocusAction.enabled = false;
		deviceConnectedAction.enabled = false;
		trackedDeviceRoleChangedAction.enabled = false;
	}

	private void OnInputFocus(bool hasFocus)
	{
		if (hasFocus)
		{
			for (int i = 0; i < objects.Length; i++)
			{
				GameObject gameObject = objects[i];
				if (gameObject != null)
				{
					string text = ((i < 2) ? labels[i] : (i - 1).ToString());
					ShowObject(gameObject.transform, hiddenPrefix + text + hiddenPostfix);
				}
			}
			return;
		}
		for (int j = 0; j < objects.Length; j++)
		{
			GameObject gameObject2 = objects[j];
			if (gameObject2 != null)
			{
				string text2 = ((j < 2) ? labels[j] : (j - 1).ToString());
				HideObject(gameObject2.transform, hiddenPrefix + text2 + hiddenPostfix);
			}
		}
	}

	private void HideObject(Transform t, string name)
	{
		if (t.gameObject.name.StartsWith(hiddenPrefix))
		{
			UnityEngine.Debug.Log("Ignoring double-hide.");
			return;
		}
		Transform transform = new GameObject(name).transform;
		transform.parent = t.parent;
		t.parent = transform;
		transform.gameObject.SetActive(value: false);
	}

	private void ShowObject(Transform t, string name)
	{
		Transform parent = t.parent;
		if (!(parent.gameObject.name != name))
		{
			t.parent = parent.parent;
			UnityEngine.Object.Destroy(parent.gameObject);
		}
	}

	private void SetTrackedDeviceIndex(int objectIndex, uint trackedDeviceIndex)
	{
		if (trackedDeviceIndex != uint.MaxValue)
		{
			for (int i = 0; i < objects.Length; i++)
			{
				if (i != objectIndex && indices[i] == trackedDeviceIndex)
				{
					GameObject gameObject = objects[i];
					if (gameObject != null)
					{
						gameObject.SetActive(value: false);
					}
					indices[i] = uint.MaxValue;
				}
			}
		}
		if (trackedDeviceIndex == indices[objectIndex])
		{
			return;
		}
		indices[objectIndex] = trackedDeviceIndex;
		GameObject gameObject2 = objects[objectIndex];
		if (gameObject2 != null)
		{
			if (trackedDeviceIndex == uint.MaxValue)
			{
				gameObject2.SetActive(value: false);
				return;
			}
			gameObject2.SetActive(value: true);
			gameObject2.BroadcastMessage("SetDeviceIndex", (int)trackedDeviceIndex, SendMessageOptions.DontRequireReceiver);
		}
	}

	private void OnTrackedDeviceRoleChanged(VREvent_t vrEvent)
	{
		Refresh();
	}

	private void OnDeviceConnected(int index, bool connected)
	{
		bool flag = this.connected[index];
		this.connected[index] = false;
		if (connected)
		{
			CVRSystem system = OpenVR.System;
			if (system != null)
			{
				ETrackedDeviceClass trackedDeviceClass = system.GetTrackedDeviceClass((uint)index);
				if (trackedDeviceClass == ETrackedDeviceClass.Controller || trackedDeviceClass == ETrackedDeviceClass.GenericTracker)
				{
					this.connected[index] = true;
					flag = !flag;
				}
			}
		}
		if (flag)
		{
			Refresh();
		}
	}

	public void Refresh()
	{
		int num = 0;
		CVRSystem system = OpenVR.System;
		if (system != null)
		{
			leftIndex = system.GetTrackedDeviceIndexForControllerRole(ETrackedControllerRole.LeftHand);
			rightIndex = system.GetTrackedDeviceIndexForControllerRole(ETrackedControllerRole.RightHand);
		}
		if (leftIndex == uint.MaxValue && rightIndex == uint.MaxValue)
		{
			for (uint num2 = 0u; num2 < connected.Length; num2++)
			{
				if (num >= objects.Length)
				{
					break;
				}
				if (connected[num2])
				{
					SetTrackedDeviceIndex(num++, num2);
					if (!assignAllBeforeIdentified)
					{
						break;
					}
				}
			}
		}
		else
		{
			SetTrackedDeviceIndex(num++, (rightIndex < connected.Length && connected[rightIndex]) ? rightIndex : uint.MaxValue);
			SetTrackedDeviceIndex(num++, (leftIndex < connected.Length && connected[leftIndex]) ? leftIndex : uint.MaxValue);
			if (leftIndex != uint.MaxValue && rightIndex != uint.MaxValue)
			{
				for (uint num3 = 0u; num3 < connected.Length; num3++)
				{
					if (num >= objects.Length)
					{
						break;
					}
					if (connected[num3] && num3 != leftIndex && num3 != rightIndex)
					{
						SetTrackedDeviceIndex(num++, num3);
					}
				}
			}
		}
		while (num < objects.Length)
		{
			SetTrackedDeviceIndex(num++, uint.MaxValue);
		}
	}
}
[RequireComponent(typeof(AudioListener))]
public class SteamVR_Ears : MonoBehaviour
{
	public SteamVR_Camera vrcam;

	private bool usingSpeakers;

	private Quaternion offset;

	private void OnNewPosesApplied()
	{
		Transform origin = vrcam.origin;
		Quaternion quaternion = ((origin != null) ? origin.rotation : Quaternion.identity);
		base.transform.rotation = quaternion * offset;
	}

	private void OnEnable()
	{
		usingSpeakers = false;
		CVRSettings settings = OpenVR.Settings;
		if (settings != null)
		{
			EVRSettingsError peError = EVRSettingsError.None;
			if (settings.GetBool("steamvr", "usingSpeakers", ref peError))
			{
				usingSpeakers = true;
				float @float = settings.GetFloat("steamvr", "speakersForwardYawOffsetDegrees", ref peError);
				offset = Quaternion.Euler(0f, @float, 0f);
			}
		}
		if (usingSpeakers)
		{
			SteamVR_Events.NewPosesApplied.Listen(OnNewPosesApplied);
		}
	}

	private void OnDisable()
	{
		if (usingSpeakers)
		{
			SteamVR_Events.NewPosesApplied.Remove(OnNewPosesApplied);
		}
	}
}
public static class SteamVR_Events
{
	public abstract class Action
	{
		public bool enabled
		{
			set
			{
				Enable(value);
			}
		}

		public abstract void Enable(bool enabled);
	}

	[Serializable]
	public class ActionNoArgs : Action
	{
		private Event _event;

		private UnityAction action;

		public ActionNoArgs(Event _event, UnityAction action)
		{
			this._event = _event;
			this.action = action;
		}

		public override void Enable(bool enabled)
		{
			if (enabled)
			{
				_event.Listen(action);
			}
			else
			{
				_event.Remove(action);
			}
		}
	}

	[Serializable]
	public class Action<T> : Action
	{
		private Event<T> _event;

		private UnityAction<T> action;

		public Action(Event<T> _event, UnityAction<T> action)
		{
			this._event = _event;
			this.action = action;
		}

		public override void Enable(bool enabled)
		{
			if (enabled)
			{
				_event.Listen(action);
			}
			else
			{
				_event.Remove(action);
			}
		}
	}

	[Serializable]
	public class Action<T0, T1> : Action
	{
		private Event<T0, T1> _event;

		private UnityAction<T0, T1> action;

		public Action(Event<T0, T1> _event, UnityAction<T0, T1> action)
		{
			this._event = _event;
			this.action = action;
		}

		public override void Enable(bool enabled)
		{
			if (enabled)
			{
				_event.Listen(action);
			}
			else
			{
				_event.Remove(action);
			}
		}
	}

	[Serializable]
	public class Action<T0, T1, T2> : Action
	{
		private Event<T0, T1, T2> _event;

		private UnityAction<T0, T1, T2> action;

		public Action(Event<T0, T1, T2> _event, UnityAction<T0, T1, T2> action)
		{
			this._event = _event;
			this.action = action;
		}

		public override void Enable(bool enabled)
		{
			if (enabled)
			{
				_event.Listen(action);
			}
			else
			{
				_event.Remove(action);
			}
		}
	}

	public class Event : UnityEvent
	{
		public void Listen(UnityAction action)
		{
			AddListener(action);
		}

		public void Remove(UnityAction action)
		{
			RemoveListener(action);
		}

		public void Send()
		{
			Invoke();
		}
	}

	public class Event<T> : UnityEvent<T>
	{
		public void Listen(UnityAction<T> action)
		{
			AddListener(action);
		}

		public void Remove(UnityAction<T> action)
		{
			RemoveListener(action);
		}

		public void Send(T arg0)
		{
			Invoke(arg0);
		}
	}

	public class Event<T0, T1> : UnityEvent<T0, T1>
	{
		public void Listen(UnityAction<T0, T1> action)
		{
			AddListener(action);
		}

		public void Remove(UnityAction<T0, T1> action)
		{
			RemoveListener(action);
		}

		public void Send(T0 arg0, T1 arg1)
		{
			Invoke(arg0, arg1);
		}
	}

	public class Event<T0, T1, T2> : UnityEvent<T0, T1, T2>
	{
		public void Listen(UnityAction<T0, T1, T2> action)
		{
			AddListener(action);
		}

		public void Remove(UnityAction<T0, T1, T2> action)
		{
			RemoveListener(action);
		}

		public void Send(T0 arg0, T1 arg1, T2 arg2)
		{
			Invoke(arg0, arg1, arg2);
		}
	}

	public static Event<bool> Calibrating = new Event<bool>();

	public static Event<int, bool> DeviceConnected = new Event<int, bool>();

	public static Event<Color, float, bool> Fade = new Event<Color, float, bool>();

	public static Event FadeReady = new Event();

	public static Event<bool> HideRenderModels = new Event<bool>();

	public static Event<bool> Initializing = new Event<bool>();

	public static Event<bool> InputFocus = new Event<bool>();

	public static Event<bool> Loading = new Event<bool>();

	public static Event<float> LoadingFadeIn = new Event<float>();

	public static Event<float> LoadingFadeOut = new Event<float>();

	public static Event<TrackedDevicePose_t[]> NewPoses = new Event<TrackedDevicePose_t[]>();

	public static Event NewPosesApplied = new Event();

	public static Event<bool> OutOfRange = new Event<bool>();

	public static Event<SteamVR_RenderModel, bool> RenderModelLoaded = new Event<SteamVR_RenderModel, bool>();

	private static Dictionary<EVREventType, Event<VREvent_t>> systemEvents = new Dictionary<EVREventType, Event<VREvent_t>>();

	public static Action CalibratingAction(UnityAction<bool> action)
	{
		return new Action<bool>(Calibrating, action);
	}

	public static Action DeviceConnectedAction(UnityAction<int, bool> action)
	{
		return new Action<int, bool>(DeviceConnected, action);
	}

	public static Action FadeAction(UnityAction<Color, float, bool> action)
	{
		return new Action<Color, float, bool>(Fade, action);
	}

	public static Action FadeReadyAction(UnityAction action)
	{
		return new ActionNoArgs(FadeReady, action);
	}

	public static Action HideRenderModelsAction(UnityAction<bool> action)
	{
		return new Action<bool>(HideRenderModels, action);
	}

	public static Action InitializingAction(UnityAction<bool> action)
	{
		return new Action<bool>(Initializing, action);
	}

	public static Action InputFocusAction(UnityAction<bool> action)
	{
		return new Action<bool>(InputFocus, action);
	}

	public static Action LoadingAction(UnityAction<bool> action)
	{
		return new Action<bool>(Loading, action);
	}

	public static Action LoadingFadeInAction(UnityAction<float> action)
	{
		return new Action<float>(LoadingFadeIn, action);
	}

	public static Action LoadingFadeOutAction(UnityAction<float> action)
	{
		return new Action<float>(LoadingFadeOut, action);
	}

	public static Action NewPosesAction(UnityAction<TrackedDevicePose_t[]> action)
	{
		return new Action<TrackedDevicePose_t[]>(NewPoses, action);
	}

	public static Action NewPosesAppliedAction(UnityAction action)
	{
		return new ActionNoArgs(NewPosesApplied, action);
	}

	public static Action OutOfRangeAction(UnityAction<bool> action)
	{
		return new Action<bool>(OutOfRange, action);
	}

	public static Action RenderModelLoadedAction(UnityAction<SteamVR_RenderModel, bool> action)
	{
		return new Action<SteamVR_RenderModel, bool>(RenderModelLoaded, action);
	}

	public static Event<VREvent_t> System(EVREventType eventType)
	{
		if (!systemEvents.TryGetValue(eventType, out var value))
		{
			value = new Event<VREvent_t>();
			systemEvents.Add(eventType, value);
		}
		return value;
	}

	public static Action SystemAction(EVREventType eventType, UnityAction<VREvent_t> action)
	{
		return new Action<VREvent_t>(System(eventType), action);
	}
}
public class SteamVR_ExternalCamera : MonoBehaviour
{
	[Serializable]
	public struct Config
	{
		public float x;

		public float y;

		public float z;

		public float rx;

		public float ry;

		public float rz;

		public float fov;

		public float near;

		public float far;

		public float sceneResolutionScale;

		public float frameSkip;

		public float nearOffset;

		public float farOffset;

		public float hmdOffset;

		public float r;

		public float g;

		public float b;

		public float a;

		public bool disableStandardAssets;
	}

	public Config config;

	public string configPath;

	private FileSystemWatcher watcher;

	private Camera cam;

	private Transform target;

	private GameObject clipQuad;

	private Material clipMaterial;

	private Material colorMat;

	private Material alphaMat;

	private Camera[] cameras;

	private Rect[] cameraRects;

	private float sceneResolutionScale;

	public void ReadConfig()
	{
		try
		{
			HmdMatrix34_t pose = default(HmdMatrix34_t);
			bool flag = false;
			object obj = config;
			string[] array = File.ReadAllLines(configPath);
			for (int i = 0; i < array.Length; i++)
			{
				string[] array2 = array[i].Split('=');
				if (array2.Length != 2)
				{
					continue;
				}
				string text = array2[0];
				if (text == "m")
				{
					string[] array3 = array2[1].Split(',');
					if (array3.Length == 12)
					{
						pose.m0 = float.Parse(array3[0]);
						pose.m1 = float.Parse(array3[1]);
						pose.m2 = float.Parse(array3[2]);
						pose.m3 = float.Parse(array3[3]);
						pose.m4 = float.Parse(array3[4]);
						pose.m5 = float.Parse(array3[5]);
						pose.m6 = float.Parse(array3[6]);
						pose.m7 = float.Parse(array3[7]);
						pose.m8 = float.Parse(array3[8]);
						pose.m9 = float.Parse(array3[9]);
						pose.m10 = float.Parse(array3[10]);
						pose.m11 = float.Parse(array3[11]);
						flag = true;
					}
				}
				else if (text == "disableStandardAssets")
				{
					FieldInfo field = obj.GetType().GetField(text);
					if (field != null)
					{
						field.SetValue(obj, bool.Parse(array2[1]));
					}
				}
				else
				{
					FieldInfo field2 = obj.GetType().GetField(text);
					if (field2 != null)
					{
						field2.SetValue(obj, float.Parse(array2[1]));
					}
				}
			}
			config = (Config)obj;
			if (flag)
			{
				SteamVR_Utils.RigidTransform rigidTransform = new SteamVR_Utils.RigidTransform(pose);
				config.x = rigidTransform.pos.x;
				config.y = rigidTransform.pos.y;
				config.z = rigidTransform.pos.z;
				Vector3 eulerAngles = rigidTransform.rot.eulerAngles;
				config.rx = eulerAngles.x;
				config.ry = eulerAngles.y;
				config.rz = eulerAngles.z;
			}
		}
		catch
		{
		}
		target = null;
		if (watcher == null)
		{
			FileInfo fileInfo = new FileInfo(configPath);
			watcher = new FileSystemWatcher(fileInfo.DirectoryName, fileInfo.Name);
			watcher.NotifyFilter = NotifyFilters.LastWrite;
			watcher.Changed += OnChanged;
			watcher.EnableRaisingEvents = true;
		}
	}

	private void OnChanged(object source, FileSystemEventArgs e)
	{
		ReadConfig();
	}

	public void AttachToCamera(SteamVR_Camera vrcam)
	{
		if (!(target == vrcam.head))
		{
			target = vrcam.head;
			Transform parent = base.transform.parent;
			Transform parent2 = vrcam.head.parent;
			parent.parent = parent2;
			parent.localPosition = Vector3.zero;
			parent.localRotation = Quaternion.identity;
			parent.localScale = Vector3.one;
			vrcam.enabled = false;
			GameObject gameObject = UnityEngine.Object.Instantiate(vrcam.gameObject);
			vrcam.enabled = true;
			gameObject.name = "camera";
			UnityEngine.Object.DestroyImmediate(gameObject.GetComponent<SteamVR_Camera>());
			UnityEngine.Object.DestroyImmediate(gameObject.GetComponent<SteamVR_Fade>());
			cam = gameObject.GetComponent<Camera>();
			cam.stereoTargetEye = StereoTargetEyeMask.None;
			cam.fieldOfView = config.fov;
			cam.useOcclusionCulling = false;
			cam.enabled = false;
			colorMat = new Material(Shader.Find("Custom/SteamVR_ColorOut"));
			alphaMat = new Material(Shader.Find("Custom/SteamVR_AlphaOut"));
			clipMaterial = new Material(Shader.Find("Custom/SteamVR_ClearAll"));
			Transform transform = gameObject.transform;
			transform.parent = base.transform;
			transform.localPosition = new Vector3(config.x, config.y, config.z);
			transform.localRotation = Quaternion.Euler(config.rx, config.ry, config.rz);
			transform.localScale = Vector3.one;
			while (transform.childCount > 0)
			{
				UnityEngine.Object.DestroyImmediate(transform.GetChild(0).gameObject);
			}
			clipQuad = GameObject.CreatePrimitive(PrimitiveType.Quad);
			clipQuad.name = "ClipQuad";
			UnityEngine.Object.DestroyImmediate(clipQuad.GetComponent<MeshCollider>());
			MeshRenderer component = clipQuad.GetComponent<MeshRenderer>();
			component.material = clipMaterial;
			component.shadowCastingMode = ShadowCastingMode.Off;
			component.receiveShadows = false;
			component.lightProbeUsage = LightProbeUsage.Off;
			component.reflectionProbeUsage = ReflectionProbeUsage.Off;
			Transform obj = clipQuad.transform;
			obj.parent = transform;
			obj.localScale = new Vector3(1000f, 1000f, 1f);
			obj.localRotation = Quaternion.identity;
			clipQuad.SetActive(value: false);
		}
	}

	public float GetTargetDistance()
	{
		if (target == null)
		{
			return config.near + 0.01f;
		}
		Transform transform = cam.transform;
		Vector3 normalized = new Vector3(transform.forward.x, 0f, transform.forward.z).normalized;
		Vector3 inPoint = target.position + new Vector3(target.forward.x, 0f, target.forward.z).normalized * config.hmdOffset;
		return Mathf.Clamp(0f - new Plane(normalized, inPoint).GetDistanceToPoint(transform.position), config.near + 0.01f, config.far - 0.01f);
	}

	public void RenderNear()
	{
		int num = Screen.width / 2;
		int num2 = Screen.height / 2;
		if (cam.targetTexture == null || cam.targetTexture.width != num || cam.targetTexture.height != num2)
		{
			RenderTexture renderTexture = new RenderTexture(num, num2, 24, RenderTextureFormat.ARGB32);
			renderTexture.antiAliasing = ((QualitySettings.antiAliasing == 0) ? 1 : QualitySettings.antiAliasing);
			cam.targetTexture = renderTexture;
		}
		cam.nearClipPlane = config.near;
		cam.farClipPlane = config.far;
		CameraClearFlags clearFlags = cam.clearFlags;
		Color backgroundColor = cam.backgroundColor;
		cam.clearFlags = CameraClearFlags.Color;
		cam.backgroundColor = Color.clear;
		clipMaterial.color = new Color(config.r, config.g, config.b, config.a);
		float num3 = Mathf.Clamp(GetTargetDistance() + config.nearOffset, config.near, config.far);
		Transform parent = clipQuad.transform.parent;
		clipQuad.transform.position = parent.position + parent.forward * num3;
		MonoBehaviour[] array = null;
		bool[] array2 = null;
		if (config.disableStandardAssets)
		{
			array = cam.gameObject.GetComponents<MonoBehaviour>();
			array2 = new bool[array.Length];
			for (int i = 0; i < array.Length; i++)
			{
				MonoBehaviour monoBehaviour = array[i];
				if (monoBehaviour.enabled && monoBehaviour.GetType().ToString().StartsWith("UnityStandardAssets."))
				{
					monoBehaviour.enabled = false;
					array2[i] = true;
				}
			}
		}
		clipQuad.SetActive(value: true);
		cam.Render();
		Graphics.DrawTexture(new Rect(0f, 0f, num, num2), cam.targetTexture, colorMat);
		MonoBehaviour monoBehaviour2 = cam.gameObject.GetComponent("PostProcessingBehaviour") as MonoBehaviour;
		if (monoBehaviour2 != null && monoBehaviour2.enabled)
		{
			monoBehaviour2.enabled = false;
			cam.Render();
			monoBehaviour2.enabled = true;
		}
		Graphics.DrawTexture(new Rect(num, 0f, num, num2), cam.targetTexture, alphaMat);
		clipQuad.SetActive(value: false);
		if (array != null)
		{
			for (int j = 0; j < array.Length; j++)
			{
				if (array2[j])
				{
					array[j].enabled = true;
				}
			}
		}
		cam.clearFlags = clearFlags;
		cam.backgroundColor = backgroundColor;
	}

	public void RenderFar()
	{
		cam.nearClipPlane = config.near;
		cam.farClipPlane = config.far;
		cam.Render();
		int num = Screen.width / 2;
		int num2 = Screen.height / 2;
		Graphics.DrawTexture(new Rect(0f, num2, num, num2), cam.targetTexture, colorMat);
	}

	private void OnGUI()
	{
	}

	private void OnEnable()
	{
		cameras = UnityEngine.Object.FindObjectsOfType<Camera>();
		if (cameras != null)
		{
			int num = cameras.Length;
			cameraRects = new Rect[num];
			for (int i = 0; i < num; i++)
			{
				Camera camera = cameras[i];
				cameraRects[i] = camera.rect;
				if (!(camera == cam) && !(camera.targetTexture != null) && !(camera.GetComponent<SteamVR_Camera>() != null))
				{
					camera.rect = new Rect(0.5f, 0f, 0.5f, 0.5f);
				}
			}
		}
		if (config.sceneResolutionScale > 0f)
		{
			sceneResolutionScale = SteamVR_Camera.sceneResolutionScale;
			SteamVR_Camera.sceneResolutionScale = config.sceneResolutionScale;
		}
	}

	private void OnDisable()
	{
		if (cameras != null)
		{
			int num = cameras.Length;
			for (int i = 0; i < num; i++)
			{
				Camera camera = cameras[i];
				if (camera != null)
				{
					camera.rect = cameraRects[i];
				}
			}
			cameras = null;
			cameraRects = null;
		}
		if (config.sceneResolutionScale > 0f)
		{
			SteamVR_Camera.sceneResolutionScale = sceneResolutionScale;
		}
	}
}
public class SteamVR_Fade : MonoBehaviour
{
	private Color currentColor = new Color(0f, 0f, 0f, 0f);

	private Color targetColor = new Color(0f, 0f, 0f, 0f);

	private Color deltaColor = new Color(0f, 0f, 0f, 0f);

	private bool fadeOverlay;

	private static Material fadeMaterial = null;

	private static int fadeMaterialColorID = -1;

	public static void Start(Color newColor, float duration, bool fadeOverlay = false)
	{
		SteamVR_Events.Fade.Send(newColor, duration, fadeOverlay);
	}

	public static void View(Color newColor, float duration)
	{
		OpenVR.Compositor?.FadeToColor(duration, newColor.r, newColor.g, newColor.b, newColor.a, bBackground: false);
	}

	public void OnStartFade(Color newColor, float duration, bool fadeOverlay)
	{
		if (duration > 0f)
		{
			targetColor = newColor;
			deltaColor = (targetColor - currentColor) / duration;
		}
		else
		{
			currentColor = newColor;
		}
	}

	private void OnEnable()
	{
		if (fadeMaterial == null)
		{
			fadeMaterial = new Material(Shader.Find("Custom/SteamVR_Fade"));
			fadeMaterialColorID = Shader.PropertyToID("fadeColor");
		}
		SteamVR_Events.Fade.Listen(OnStartFade);
		SteamVR_Events.FadeReady.Send();
	}

	private void OnDisable()
	{
		SteamVR_Events.Fade.Remove(OnStartFade);
	}

	private void OnPostRender()
	{
		if (currentColor != targetColor)
		{
			if (Mathf.Abs(currentColor.a - targetColor.a) < Mathf.Abs(deltaColor.a) * Time.deltaTime)
			{
				currentColor = targetColor;
				deltaColor = new Color(0f, 0f, 0f, 0f);
			}
			else
			{
				currentColor += deltaColor * Time.deltaTime;
			}
			if (fadeOverlay)
			{
				SteamVR_Overlay instance = SteamVR_Overlay.instance;
				if (instance != null)
				{
					instance.alpha = 1f - currentColor.a;
				}
			}
		}
		if (currentColor.a > 0f && (bool)fadeMaterial)
		{
			fadeMaterial.SetColor(fadeMaterialColorID, currentColor);
			fadeMaterial.SetPass(0);
			GL.Begin(7);
			GL.Vertex3(-1f, -1f, 0f);
			GL.Vertex3(1f, -1f, 0f);
			GL.Vertex3(1f, 1f, 0f);
			GL.Vertex3(-1f, 1f, 0f);
			GL.End();
		}
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(MeshRenderer), typeof(MeshFilter))]
public class SteamVR_Frustum : MonoBehaviour
{
	public SteamVR_TrackedObject.EIndex index;

	public float fovLeft = 45f;

	public float fovRight = 45f;

	public float fovTop = 45f;

	public float fovBottom = 45f;

	public float nearZ = 0.5f;

	public float farZ = 2.5f;

	public void UpdateModel()
	{
		fovLeft = Mathf.Clamp(fovLeft, 1f, 89f);
		fovRight = Mathf.Clamp(fovRight, 1f, 89f);
		fovTop = Mathf.Clamp(fovTop, 1f, 89f);
		fovBottom = Mathf.Clamp(fovBottom, 1f, 89f);
		farZ = Mathf.Max(farZ, nearZ + 0.01f);
		nearZ = Mathf.Clamp(nearZ, 0.01f, farZ - 0.01f);
		float num = Mathf.Sin((0f - fovLeft) * ((float)Math.PI / 180f));
		float num2 = Mathf.Sin(fovRight * ((float)Math.PI / 180f));
		float num3 = Mathf.Sin(fovTop * ((float)Math.PI / 180f));
		float num4 = Mathf.Sin((0f - fovBottom) * ((float)Math.PI / 180f));
		float num5 = Mathf.Cos((0f - fovLeft) * ((float)Math.PI / 180f));
		float num6 = Mathf.Cos(fovRight * ((float)Math.PI / 180f));
		float num7 = Mathf.Cos(fovTop * ((float)Math.PI / 180f));
		float num8 = Mathf.Cos((0f - fovBottom) * ((float)Math.PI / 180f));
		Vector3[] array = new Vector3[8]
		{
			new Vector3(num * nearZ / num5, num3 * nearZ / num7, nearZ),
			new Vector3(num2 * nearZ / num6, num3 * nearZ / num7, nearZ),
			new Vector3(num2 * nearZ / num6, num4 * nearZ / num8, nearZ),
			new Vector3(num * nearZ / num5, num4 * nearZ / num8, nearZ),
			new Vector3(num * farZ / num5, num3 * farZ / num7, farZ),
			new Vector3(num2 * farZ / num6, num3 * farZ / num7, farZ),
			new Vector3(num2 * farZ / num6, num4 * farZ / num8, farZ),
			new Vector3(num * farZ / num5, num4 * farZ / num8, farZ)
		};
		int[] array2 = new int[48]
		{
			0, 4, 7, 0, 7, 3, 0, 7, 4, 0,
			3, 7, 1, 5, 6, 1, 6, 2, 1, 6,
			5, 1, 2, 6, 0, 4, 5, 0, 5, 1,
			0, 5, 4, 0, 1, 5, 2, 3, 7, 2,
			7, 6, 2, 7, 3, 2, 6, 7
		};
		int num9 = 0;
		Vector3[] array3 = new Vector3[array2.Length];
		Vector3[] array4 = new Vector3[array2.Length];
		for (int i = 0; i < array2.Length / 3; i++)
		{
			Vector3 vector = array[array2[i * 3]];
			Vector3 vector2 = array[array2[i * 3 + 1]];
			Vector3 vector3 = array[array2[i * 3 + 2]];
			array4[i * 3 + 2] = (array4[i * 3 + 1] = (array4[i * 3] = Vector3.Cross(vector2 - vector, vector3 - vector).normalized));
			array3[i * 3] = vector;
			array3[i * 3 + 1] = vector2;
			array3[i * 3 + 2] = vector3;
			array2[i * 3] = num9++;
			array2[i * 3 + 1] = num9++;
			array2[i * 3 + 2] = num9++;
		}
		Mesh mesh = new Mesh();
		mesh.vertices = array3;
		mesh.normals = array4;
		mesh.triangles = array2;
		GetComponent<MeshFilter>().mesh = mesh;
	}

	private void OnDeviceConnected(int i, bool connected)
	{
		if (i != (int)index)
		{
			return;
		}
		GetComponent<MeshFilter>().mesh = null;
		if (!connected)
		{
			return;
		}
		CVRSystem system = OpenVR.System;
		if (system != null && system.GetTrackedDeviceClass((uint)i) == ETrackedDeviceClass.TrackingReference)
		{
			ETrackedPropertyError pError = ETrackedPropertyError.TrackedProp_Success;
			float floatTrackedDeviceProperty = system.GetFloatTrackedDeviceProperty((uint)i, ETrackedDeviceProperty.Prop_FieldOfViewLeftDegrees_Float, ref pError);
			if (pError == ETrackedPropertyError.TrackedProp_Success)
			{
				fovLeft = floatTrackedDeviceProperty;
			}
			floatTrackedDeviceProperty = system.GetFloatTrackedDeviceProperty((uint)i, ETrackedDeviceProperty.Prop_FieldOfViewRightDegrees_Float, ref pError);
			if (pError == ETrackedPropertyError.TrackedProp_Success)
			{
				fovRight = floatTrackedDeviceProperty;
			}
			floatTrackedDeviceProperty = system.GetFloatTrackedDeviceProperty((uint)i, ETrackedDeviceProperty.Prop_FieldOfViewTopDegrees_Float, ref pError);
			if (pError == ETrackedPropertyError.TrackedProp_Success)
			{
				fovTop = floatTrackedDeviceProperty;
			}
			floatTrackedDeviceProperty = system.GetFloatTrackedDeviceProperty((uint)i, ETrackedDeviceProperty.Prop_FieldOfViewBottomDegrees_Float, ref pError);
			if (pError == ETrackedPropertyError.TrackedProp_Success)
			{
				fovBottom = floatTrackedDeviceProperty;
			}
			floatTrackedDeviceProperty = system.GetFloatTrackedDeviceProperty((uint)i, ETrackedDeviceProperty.Prop_TrackingRangeMinimumMeters_Float, ref pError);
			if (pError == ETrackedPropertyError.TrackedProp_Success)
			{
				nearZ = floatTrackedDeviceProperty;
			}
			floatTrackedDeviceProperty = system.GetFloatTrackedDeviceProperty((uint)i, ETrackedDeviceProperty.Prop_TrackingRangeMaximumMeters_Float, ref pError);
			if (pError == ETrackedPropertyError.TrackedProp_Success)
			{
				farZ = floatTrackedDeviceProperty;
			}
			UpdateModel();
		}
	}

	private void OnEnable()
	{
		GetComponent<MeshFilter>().mesh = null;
		SteamVR_Events.DeviceConnected.Listen(OnDeviceConnected);
	}

	private void OnDisable()
	{
		SteamVR_Events.DeviceConnected.Remove(OnDeviceConnected);
		GetComponent<MeshFilter>().mesh = null;
	}
}
[ExecuteInEditMode]
public class SteamVR_GameView : MonoBehaviour
{
	private void Awake()
	{
		UnityEngine.Debug.Log("SteamVR_GameView is deprecated in Unity 5.4 - REMOVING");
		UnityEngine.Object.DestroyImmediate(this);
	}
}
public class SteamVR_IK : MonoBehaviour
{
	public Transform target;

	public Transform start;

	public Transform joint;

	public Transform end;

	public Transform poleVector;

	public Transform upVector;

	public float blendPct = 1f;

	[HideInInspector]
	public Transform startXform;

	[HideInInspector]
	public Transform jointXform;

	[HideInInspector]
	public Transform endXform;

	private void LateUpdate()
	{
		if (blendPct < 0.001f)
		{
			return;
		}
		Vector3 worldUp = (upVector ? upVector.up : Vector3.Cross(end.position - start.position, joint.position - start.position).normalized);
		Vector3 position = target.position;
		Quaternion rotation = target.rotation;
		Vector3 result = joint.position;
		Solve(start.position, position, poleVector.position, (joint.position - start.position).magnitude, (end.position - joint.position).magnitude, ref result, out var _, out var up);
		if (!(up == Vector3.zero))
		{
			Vector3 position2 = start.position;
			Vector3 position3 = joint.position;
			Vector3 position4 = end.position;
			Quaternion localRotation = start.localRotation;
			Quaternion localRotation2 = joint.localRotation;
			Quaternion localRotation3 = end.localRotation;
			Transform parent = start.parent;
			Transform parent2 = joint.parent;
			Transform parent3 = end.parent;
			Vector3 localScale = start.localScale;
			Vector3 localScale2 = joint.localScale;
			Vector3 localScale3 = end.localScale;
			if (startXform == null)
			{
				startXform = new GameObject("startXform").transform;
				startXform.parent = base.transform;
			}
			startXform.position = position2;
			startXform.LookAt(joint, worldUp);
			start.parent = startXform;
			if (jointXform == null)
			{
				jointXform = new GameObject("jointXform").transform;
				jointXform.parent = startXform;
			}
			jointXform.position = position3;
			jointXform.LookAt(end, worldUp);
			joint.parent = jointXform;
			if (endXform == null)
			{
				endXform = new GameObject("endXform").transform;
				endXform.parent = jointXform;
			}
			endXform.position = position4;
			end.parent = endXform;
			startXform.LookAt(result, up);
			jointXform.LookAt(position, up);
			endXform.rotation = rotation;
			start.parent = parent;
			joint.parent = parent2;
			end.parent = parent3;
			end.rotation = rotation;
			if (blendPct < 1f)
			{
				start.localRotation = Quaternion.Slerp(localRotation, start.localRotation, blendPct);
				joint.localRotation = Quaternion.Slerp(localRotation2, joint.localRotation, blendPct);
				end.localRotation = Quaternion.Slerp(localRotation3, end.localRotation, blendPct);
			}
			start.localScale = localScale;
			joint.localScale = localScale2;
			end.localScale = localScale3;
		}
	}

	public static bool Solve(Vector3 start, Vector3 end, Vector3 poleVector, float jointDist, float targetDist, ref Vector3 result, out Vector3 forward, out Vector3 up)
	{
		float num = jointDist + targetDist;
		Vector3 vector = end - start;
		Vector3 normalized = (poleVector - start).normalized;
		float magnitude = vector.magnitude;
		result = start;
		if (magnitude < 0.001f)
		{
			result += normalized * jointDist;
			forward = Vector3.Cross(normalized, Vector3.up);
			up = Vector3.Cross(forward, normalized).normalized;
		}
		else
		{
			forward = vector * (1f / magnitude);
			up = Vector3.Cross(forward, normalized).normalized;
			if (magnitude + 0.001f < num)
			{
				float num2 = (num + magnitude) * 0.5f;
				if (num2 > jointDist + 0.001f && num2 > targetDist + 0.001f)
				{
					float num3 = Mathf.Sqrt(num2 * (num2 - jointDist) * (num2 - targetDist) * (num2 - magnitude));
					float num4 = 2f * num3 / magnitude;
					float num5 = Mathf.Sqrt(jointDist * jointDist - num4 * num4);
					Vector3 vector2 = Vector3.Cross(up, forward);
					result += forward * num5 + vector2 * num4;
					return true;
				}
				result += normalized * jointDist;
			}
			else
			{
				result += forward * jointDist;
			}
		}
		return false;
	}
}
public class SteamVR_LoadLevel : MonoBehaviour
{
	private static SteamVR_LoadLevel _active;

	public string levelName;

	public string internalProcessPath;

	public string internalProcessArgs;

	public bool loadAdditive;

	public bool loadAsync = true;

	public Texture loadingScreen;

	public Texture progressBarEmpty;

	public Texture progressBarFull;

	public float loadingScreenWidthInMeters = 6f;

	public float progressBarWidthInMeters = 3f;

	public float loadingScreenDistance;

	public Transform loadingScreenTransform;

	public Transform progressBarTransform;

	public Texture front;

	public Texture back;

	public Texture left;

	public Texture right;

	public Texture top;

	public Texture bottom;

	public Color backgroundColor = Color.black;

	public bool showGrid;

	public float fadeOutTime = 0.5f;

	public float fadeInTime = 0.5f;

	public float postLoadSettleTime;

	public float loadingScreenFadeInTime = 1f;

	public float loadingScreenFadeOutTime = 0.25f;

	private float fadeRate = 1f;

	private float alpha;

	private UnityEngine.AsyncOperation async;

	private RenderTexture renderTexture;

	private ulong loadingScreenOverlayHandle;

	private ulong progressBarOverlayHandle;

	public bool autoTriggerOnEnable;

	public static bool loading => _active != null;

	public static float progress
	{
		get
		{
			if (!(_active != null) || _active.async == null)
			{
				return 0f;
			}
			return _active.async.progress;
		}
	}

	public static Texture progressTexture
	{
		get
		{
			if (!(_active != null))
			{
				return null;
			}
			return _active.renderTexture;
		}
	}

	private void OnEnable()
	{
		if (autoTriggerOnEnable)
		{
			Trigger();
		}
	}

	public void Trigger()
	{
		if (!loading && !string.IsNullOrEmpty(levelName))
		{
			StartCoroutine(LoadLevel());
		}
	}

	public static void Begin(string levelName, bool showGrid = false, float fadeOutTime = 0.5f, float r = 0f, float g = 0f, float b = 0f, float a = 1f)
	{
		SteamVR_LoadLevel steamVR_LoadLevel = new GameObject("loader").AddComponent<SteamVR_LoadLevel>();
		steamVR_LoadLevel.levelName = levelName;
		steamVR_LoadLevel.showGrid = showGrid;
		steamVR_LoadLevel.fadeOutTime = fadeOutTime;
		steamVR_LoadLevel.backgroundColor = new Color(r, g, b, a);
		steamVR_LoadLevel.Trigger();
	}

	private void OnGUI()
	{
		if (_active != this || !(progressBarEmpty != null) || !(progressBarFull != null))
		{
			return;
		}
		if (progressBarOverlayHandle == 0L)
		{
			progressBarOverlayHandle = GetOverlayHandle("progressBar", (progressBarTransform != null) ? progressBarTransform : base.transform, progressBarWidthInMeters);
		}
		if (progressBarOverlayHandle != 0L)
		{
			float num = ((async != null) ? async.progress : 0f);
			int width = progressBarFull.width;
			int height = progressBarFull.height;
			if (renderTexture == null)
			{
				renderTexture = new RenderTexture(width, height, 0);
				renderTexture.Create();
			}
			RenderTexture active = RenderTexture.active;
			RenderTexture.active = renderTexture;
			if (Event.current.type == EventType.Repaint)
			{
				GL.Clear(clearDepth: false, clearColor: true, Color.clear);
			}
			GUILayout.BeginArea(new Rect(0f, 0f, width, height));
			GUI.DrawTexture(new Rect(0f, 0f, width, height), progressBarEmpty);
			GUI.DrawTextureWithTexCoords(new Rect(0f, 0f, num * (float)width, height), progressBarFull, new Rect(0f, 0f, num, 1f));
			GUILayout.EndArea();
			RenderTexture.active = active;
			CVROverlay overlay = OpenVR.Overlay;
			if (overlay != null)
			{
				Texture_t pTexture = default(Texture_t);
				pTexture.handle = renderTexture.GetNativeTexturePtr();
				pTexture.eType = SteamVR.instance.textureType;
				pTexture.eColorSpace = EColorSpace.Auto;
				overlay.SetOverlayTexture(progressBarOverlayHandle, ref pTexture);
			}
		}
	}

	private void Update()
	{
		if (_active != this)
		{
			return;
		}
		alpha = Mathf.Clamp01(alpha + fadeRate * Time.deltaTime);
		CVROverlay overlay = OpenVR.Overlay;
		if (overlay != null)
		{
			if (loadingScreenOverlayHandle != 0L)
			{
				overlay.SetOverlayAlpha(loadingScreenOverlayHandle, alpha);
			}
			if (progressBarOverlayHandle != 0L)
			{
				overlay.SetOverlayAlpha(progressBarOverlayHandle, alpha);
			}
		}
	}

	private IEnumerator LoadLevel()
	{
		if (loadingScreen != null && loadingScreenDistance > 0f)
		{
			SteamVR_Controller.Device hmd = SteamVR_Controller.Input(0);
			while (!hmd.hasTracking)
			{
				yield return null;
			}
			SteamVR_Utils.RigidTransform rigidTransform = hmd.transform;
			rigidTransform.rot = Quaternion.Euler(0f, rigidTransform.rot.eulerAngles.y, 0f);
			rigidTransform.pos += rigidTransform.rot * new Vector3(0f, 0f, loadingScreenDistance);
			Transform obj = ((loadingScreenTransform != null) ? loadingScreenTransform : base.transform);
			obj.position = rigidTransform.pos;
			obj.rotation = rigidTransform.rot;
		}
		_active = this;
		SteamVR_Events.Loading.Send(arg0: true);
		if (loadingScreenFadeInTime > 0f)
		{
			fadeRate = 1f / loadingScreenFadeInTime;
		}
		else
		{
			alpha = 1f;
		}
		CVROverlay overlay = OpenVR.Overlay;
		if (loadingScreen != null && overlay != null)
		{
			loadingScreenOverlayHandle = GetOverlayHandle("loadingScreen", (loadingScreenTransform != null) ? loadingScreenTransform : base.transform, loadingScreenWidthInMeters);
			if (loadingScreenOverlayHandle != 0L)
			{
				Texture_t pTexture = default(Texture_t);
				pTexture.handle = loadingScreen.GetNativeTexturePtr();
				pTexture.eType = SteamVR.instance.textureType;
				pTexture.eColorSpace = EColorSpace.Auto;
				overlay.SetOverlayTexture(loadingScreenOverlayHandle, ref pTexture);
			}
		}
		bool fadedForeground = false;
		SteamVR_Events.LoadingFadeOut.Send(fadeOutTime);
		CVRCompositor compositor2 = OpenVR.Compositor;
		if (compositor2 != null)
		{
			if (front != null)
			{
				SteamVR_Skybox.SetOverride(front, back, left, right, top, bottom);
				compositor2.FadeGrid(fadeOutTime, bFadeIn: true);
				yield return new WaitForSeconds(fadeOutTime);
			}
			else if (backgroundColor != Color.clear)
			{
				if (showGrid)
				{
					compositor2.FadeToColor(0f, backgroundColor.r, backgroundColor.g, backgroundColor.b, backgroundColor.a, bBackground: true);
					compositor2.FadeGrid(fadeOutTime, bFadeIn: true);
					yield return new WaitForSeconds(fadeOutTime);
				}
				else
				{
					compositor2.FadeToColor(fadeOutTime, backgroundColor.r, backgroundColor.g, backgroundColor.b, backgroundColor.a, bBackground: false);
					yield return new WaitForSeconds(fadeOutTime + 0.1f);
					compositor2.FadeGrid(0f, bFadeIn: true);
					fadedForeground = true;
				}
			}
		}
		SteamVR_Render.pauseRendering = true;
		while (alpha < 1f)
		{
			yield return null;
		}
		base.transform.parent = null;
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		if (!string.IsNullOrEmpty(internalProcessPath))
		{
			UnityEngine.Debug.Log("Launching external application...");
			CVRApplications applications = OpenVR.Applications;
			if (applications == null)
			{
				UnityEngine.Debug.Log("Failed to get OpenVR.Applications interface!");
			}
			else
			{
				string currentDirectory = Directory.GetCurrentDirectory();
				string text = Path.Combine(currentDirectory, internalProcessPath);
				UnityEngine.Debug.Log("LaunchingInternalProcess");
				UnityEngine.Debug.Log("ExternalAppPath = " + internalProcessPath);
				UnityEngine.Debug.Log("FullPath = " + text);
				UnityEngine.Debug.Log("ExternalAppArgs = " + internalProcessArgs);
				UnityEngine.Debug.Log("WorkingDirectory = " + currentDirectory);
				EVRApplicationError eVRApplicationError = applications.LaunchInternalProcess(text, internalProcessArgs, currentDirectory);
				UnityEngine.Debug.Log("LaunchInternalProcessError: " + eVRApplicationError);
				Process.GetCurrentProcess().Kill();
			}
		}
		else
		{
			LoadSceneMode mode = (loadAdditive ? LoadSceneMode.Additive : LoadSceneMode.Single);
			if (loadAsync)
			{
				UnityEngine.Application.backgroundLoadingPriority = UnityEngine.ThreadPriority.Low;
				async = SceneManager.LoadSceneAsync(levelName, mode);
				while (!async.isDone)
				{
					yield return null;
				}
			}
			else
			{
				SceneManager.LoadScene(levelName, mode);
			}
		}
		yield return null;
		GC.Collect();
		yield return null;
		Shader.WarmupAllShaders();
		yield return new WaitForSeconds(postLoadSettleTime);
		SteamVR_Render.pauseRendering = false;
		if (loadingScreenFadeOutTime > 0f)
		{
			fadeRate = -1f / loadingScreenFadeOutTime;
		}
		else
		{
			alpha = 0f;
		}
		SteamVR_Events.LoadingFadeIn.Send(fadeInTime);
		compositor2 = OpenVR.Compositor;
		if (compositor2 != null)
		{
			if (fadedForeground)
			{
				compositor2.FadeGrid(0f, bFadeIn: false);
				compositor2.FadeToColor(fadeInTime, 0f, 0f, 0f, 0f, bBackground: false);
				yield return new WaitForSeconds(fadeInTime);
			}
			else
			{
				compositor2.FadeGrid(fadeInTime, bFadeIn: false);
				yield return new WaitForSeconds(fadeInTime);
				if (front != null)
				{
					SteamVR_Skybox.ClearOverride();
				}
			}
		}
		while (alpha > 0f)
		{
			yield return null;
		}
		if (overlay != null)
		{
			if (progressBarOverlayHandle != 0L)
			{
				overlay.HideOverlay(progressBarOverlayHandle);
			}
			if (loadingScreenOverlayHandle != 0L)
			{
				overlay.HideOverlay(loadingScreenOverlayHandle);
			}
		}
		UnityEngine.Object.Destroy(base.gameObject);
		_active = null;
		SteamVR_Events.Loading.Send(arg0: false);
	}

	private ulong GetOverlayHandle(string overlayName, Transform transform, float widthInMeters = 1f)
	{
		ulong pOverlayHandle = 0uL;
		CVROverlay overlay = OpenVR.Overlay;
		if (overlay == null)
		{
			return pOverlayHandle;
		}
		string pchOverlayKey = SteamVR_Overlay.key + "." + overlayName;
		EVROverlayError eVROverlayError = overlay.FindOverlay(pchOverlayKey, ref pOverlayHandle);
		if (eVROverlayError != 0)
		{
			eVROverlayError = overlay.CreateOverlay(pchOverlayKey, overlayName, ref pOverlayHandle);
		}
		if (eVROverlayError == EVROverlayError.None)
		{
			overlay.ShowOverlay(pOverlayHandle);
			overlay.SetOverlayAlpha(pOverlayHandle, alpha);
			overlay.SetOverlayWidthInMeters(pOverlayHandle, widthInMeters);
			if (SteamVR.instance.textureType == ETextureType.DirectX)
			{
				VRTextureBounds_t pOverlayTextureBounds = default(VRTextureBounds_t);
				pOverlayTextureBounds.uMin = 0f;
				pOverlayTextureBounds.vMin = 1f;
				pOverlayTextureBounds.uMax = 1f;
				pOverlayTextureBounds.vMax = 0f;
				overlay.SetOverlayTextureBounds(pOverlayHandle, ref pOverlayTextureBounds);
			}
			SteamVR_Camera steamVR_Camera = ((loadingScreenDistance == 0f) ? SteamVR_Render.Top() : null);
			if (steamVR_Camera != null && steamVR_Camera.origin != null)
			{
				SteamVR_Utils.RigidTransform rigidTransform = new SteamVR_Utils.RigidTransform(steamVR_Camera.origin, transform);
				rigidTransform.pos.x /= steamVR_Camera.origin.localScale.x;
				rigidTransform.pos.y /= steamVR_Camera.origin.localScale.y;
				rigidTransform.pos.z /= steamVR_Camera.origin.localScale.z;
				HmdMatrix34_t pmatTrackingOriginToOverlayTransform = rigidTransform.ToHmdMatrix34();
				overlay.SetOverlayTransformAbsolute(pOverlayHandle, SteamVR_Render.instance.trackingSpace, ref pmatTrackingOriginToOverlayTransform);
			}
			else
			{
				HmdMatrix34_t pmatTrackingOriginToOverlayTransform2 = new SteamVR_Utils.RigidTransform(transform).ToHmdMatrix34();
				overlay.SetOverlayTransformAbsolute(pOverlayHandle, SteamVR_Render.instance.trackingSpace, ref pmatTrackingOriginToOverlayTransform2);
			}
		}
		return pOverlayHandle;
	}
}
public class SteamVR_Menu : MonoBehaviour
{
	public Texture cursor;

	public Texture background;

	public Texture logo;

	public float logoHeight;

	public float menuOffset;

	public Vector2 scaleLimits = new Vector2(0.1f, 5f);

	public float scaleRate = 0.5f;

	private SteamVR_Overlay overlay;

	private Camera overlayCam;

	private Vector4 uvOffset;

	private float distance;

	private string scaleLimitX;

	private string scaleLimitY;

	private string scaleRateText;

	private CursorLockMode savedCursorLockState;

	private bool savedCursorVisible;

	public RenderTexture texture
	{
		get
		{
			if (!overlay)
			{
				return null;
			}
			return overlay.texture as RenderTexture;
		}
	}

	public float scale { get; private set; }

	private void Awake()
	{
		scaleLimitX = $"{scaleLimits.x:N1}";
		scaleLimitY = $"{scaleLimits.y:N1}";
		scaleRateText = $"{scaleRate:N1}";
		SteamVR_Overlay instance = SteamVR_Overlay.instance;
		if (instance != null)
		{
			uvOffset = instance.uvOffset;
			distance = instance.distance;
		}
	}

	private void OnGUI()
	{
		if (overlay == null)
		{
			return;
		}
		RenderTexture renderTexture = overlay.texture as RenderTexture;
		RenderTexture active = RenderTexture.active;
		RenderTexture.active = renderTexture;
		if (Event.current.type == EventType.Repaint)
		{
			GL.Clear(clearDepth: false, clearColor: true, Color.clear);
		}
		Rect screenRect = new Rect(0f, 0f, renderTexture.width, renderTexture.height);
		if (Screen.width < renderTexture.width)
		{
			screenRect.width = Screen.width;
			overlay.uvOffset.x = (0f - (float)(renderTexture.width - Screen.width)) / (float)(2 * renderTexture.width);
		}
		if (Screen.height < renderTexture.height)
		{
			screenRect.height = Screen.height;
			overlay.uvOffset.y = (float)(renderTexture.height - Screen.height) / (float)(2 * renderTexture.height);
		}
		GUILayout.BeginArea(screenRect);
		if (background != null)
		{
			GUI.DrawTexture(new Rect((screenRect.width - (float)background.width) / 2f, (screenRect.height - (float)background.height) / 2f, background.width, background.height), background);
		}
		GUILayout.BeginHorizontal();
		GUILayout.FlexibleSpace();
		GUILayout.BeginVertical();
		if (logo != null)
		{
			GUILayout.Space(screenRect.height / 2f - logoHeight);
			GUILayout.Box(logo);
		}
		GUILayout.Space(menuOffset);
		bool num = GUILayout.Button("[Esc] - Close menu");
		GUILayout.BeginHorizontal();
		GUILayout.Label($"Scale: {scale:N4}");
		float num2 = GUILayout.HorizontalSlider(scale, scaleLimits.x, scaleLimits.y);
		if (num2 != scale)
		{
			SetScale(num2);
		}
		GUILayout.EndHorizontal();
		GUILayout.BeginHorizontal();
		GUILayout.Label($"Scale limits:");
		string text = GUILayout.TextField(scaleLimitX);
		if (text != scaleLimitX && float.TryParse(text, out scaleLimits.x))
		{
			scaleLimitX = text;
		}
		string text2 = GUILayout.TextField(scaleLimitY);
		if (text2 != scaleLimitY && float.TryParse(text2, out scaleLimits.y))
		{
			scaleLimitY = text2;
		}
		GUILayout.EndHorizontal();
		GUILayout.BeginHorizontal();
		GUILayout.Label($"Scale rate:");
		string text3 = GUILayout.TextField(scaleRateText);
		if (text3 != scaleRateText && float.TryParse(text3, out scaleRate))
		{
			scaleRateText = text3;
		}
		GUILayout.EndHorizontal();
		if (SteamVR.active)
		{
			SteamVR instance = SteamVR.instance;
			GUILayout.BeginHorizontal();
			float sceneResolutionScale = SteamVR_Camera.sceneResolutionScale;
			int num3 = (int)(instance.sceneWidth * sceneResolutionScale);
			int num4 = (int)(instance.sceneHeight * sceneResolutionScale);
			int num5 = (int)(100f * sceneResolutionScale);
			GUILayout.Label($"Scene quality: {num3}x{num4} ({num5}%)");
			int num6 = Mathf.RoundToInt(GUILayout.HorizontalSlider(num5, 50f, 200f));
			if (num6 != num5)
			{
				SteamVR_Camera.sceneResolutionScale = (float)num6 / 100f;
			}
			GUILayout.EndHorizontal();
		}
		overlay.highquality = GUILayout.Toggle(overlay.highquality, "High quality");
		if (overlay.highquality)
		{
			overlay.curved = GUILayout.Toggle(overlay.curved, "Curved overlay");
			overlay.antialias = GUILayout.Toggle(overlay.antialias, "Overlay RGSS(2x2)");
		}
		else
		{
			overlay.curved = false;
			overlay.antialias = false;
		}
		SteamVR_Camera steamVR_Camera = SteamVR_Render.Top();
		if (steamVR_Camera != null)
		{
			steamVR_Camera.wireframe = GUILayout.Toggle(steamVR_Camera.wireframe, "Wireframe");
			SteamVR_Render instance2 = SteamVR_Render.instance;
			if (instance2.trackingSpace == ETrackingUniverseOrigin.TrackingUniverseSeated)
			{
				if (GUILayout.Button("Switch to Standing"))
				{
					instance2.trackingSpace = ETrackingUniverseOrigin.TrackingUniverseStanding;
				}
				if (GUILayout.Button("Center View"))
				{
					OpenVR.System?.ResetSeatedZeroPose();
				}
			}
			else if (GUILayout.Button("Switch to Seated"))
			{
				instance2.trackingSpace = ETrackingUniverseOrigin.TrackingUniverseSeated;
			}
		}
		if (GUILayout.Button("Exit"))
		{
			UnityEngine.Application.Quit();
		}
		GUILayout.Space(menuOffset);
		string environmentVariable = Environment.GetEnvironmentVariable("VR_OVERRIDE");
		if (environmentVariable != null)
		{
			GUILayout.Label("VR_OVERRIDE=" + environmentVariable);
		}
		GUILayout.Label("Graphics device: " + SystemInfo.graphicsDeviceVersion);
		GUILayout.EndVertical();
		GUILayout.FlexibleSpace();
		GUILayout.EndHorizontal();
		GUILayout.EndArea();
		if (cursor != null)
		{
			float x = Input.mousePosition.x;
			float y = (float)Screen.height - Input.mousePosition.y;
			float width = cursor.width;
			float height = cursor.height;
			GUI.DrawTexture(new Rect(x, y, width, height), cursor);
		}
		RenderTexture.active = active;
		if (num)
		{
			HideMenu();
		}
	}

	public void ShowMenu()
	{
		SteamVR_Overlay instance = SteamVR_Overlay.instance;
		if (instance == null)
		{
			return;
		}
		RenderTexture renderTexture = instance.texture as RenderTexture;
		if (renderTexture == null)
		{
			UnityEngine.Debug.LogError("Menu requires overlay texture to be a render texture.");
			return;
		}
		SaveCursorState();
		Cursor.visible = true;
		Cursor.lockState = CursorLockMode.None;
		overlay = instance;
		uvOffset = instance.uvOffset;
		distance = instance.distance;
		Camera[] array = UnityEngine.Object.FindObjectsOfType(typeof(Camera)) as Camera[];
		foreach (Camera camera in array)
		{
			if (camera.enabled && camera.targetTexture == renderTexture)
			{
				overlayCam = camera;
				overlayCam.enabled = false;
				break;
			}
		}
		SteamVR_Camera steamVR_Camera = SteamVR_Render.Top();
		if (steamVR_Camera != null)
		{
			scale = steamVR_Camera.origin.localScale.x;
		}
	}

	public void HideMenu()
	{
		RestoreCursorState();
		if (overlayCam != null)
		{
			overlayCam.enabled = true;
		}
		if (overlay != null)
		{
			overlay.uvOffset = uvOffset;
			overlay.distance = distance;
			overlay = null;
		}
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Escape) || Input.GetKeyDown(KeyCode.Joystick1Button7))
		{
			if (overlay == null)
			{
				ShowMenu();
			}
			else
			{
				HideMenu();
			}
		}
		else if (Input.GetKeyDown(KeyCode.Home))
		{
			SetScale(1f);
		}
		else if (Input.GetKey(KeyCode.PageUp))
		{
			SetScale(Mathf.Clamp(scale + scaleRate * Time.deltaTime, scaleLimits.x, scaleLimits.y));
		}
		else if (Input.GetKey(KeyCode.PageDown))
		{
			SetScale(Mathf.Clamp(scale - scaleRate * Time.deltaTime, scaleLimits.x, scaleLimits.y));
		}
	}

	private void SetScale(float scale)
	{
		this.scale = scale;
		SteamVR_Camera steamVR_Camera = SteamVR_Render.Top();
		if (steamVR_Camera != null)
		{
			steamVR_Camera.origin.localScale = new Vector3(scale, scale, scale);
		}
	}

	private void SaveCursorState()
	{
		savedCursorVisible = Cursor.visible;
		savedCursorLockState = Cursor.lockState;
	}

	private void RestoreCursorState()
	{
		Cursor.visible = savedCursorVisible;
		Cursor.lockState = savedCursorLockState;
	}
}
public class SteamVR_Overlay : MonoBehaviour
{
	public struct IntersectionResults
	{
		public Vector3 point;

		public Vector3 normal;

		public Vector2 UVs;

		public float distance;
	}

	public Texture texture;

	public bool curved = true;

	public bool antialias = true;

	public bool highquality = true;

	[Tooltip("Size of overlay view.")]
	public float scale = 3f;

	[Tooltip("Distance from surface.")]
	public float distance = 1.25f;

	[Tooltip("Opacity")]
	[Range(0f, 1f)]
	public float alpha = 1f;

	public Vector4 uvOffset = new Vector4(0f, 0f, 1f, 1f);

	public Vector2 mouseScale = new Vector2(1f, 1f);

	public Vector2 curvedRange = new Vector2(1f, 2f);

	public VROverlayInputMethod inputMethod;

	private ulong handle;

	public static SteamVR_Overlay instance { get; private set; }

	public static string key => "unity:" + UnityEngine.Application.companyName + "." + UnityEngine.Application.productName;

	private void OnEnable()
	{
		CVROverlay overlay = OpenVR.Overlay;
		if (overlay != null)
		{
			EVROverlayError eVROverlayError = overlay.CreateOverlay(key, base.gameObject.name, ref handle);
			if (eVROverlayError != 0)
			{
				UnityEngine.Debug.Log(overlay.GetOverlayErrorNameFromEnum(eVROverlayError));
				base.enabled = false;
				return;
			}
		}
		instance = this;
	}

	private void OnDisable()
	{
		if (handle != 0L)
		{
			OpenVR.Overlay?.DestroyOverlay(handle);
			handle = 0uL;
		}
		instance = null;
	}

	public void UpdateOverlay()
	{
		CVROverlay overlay = OpenVR.Overlay;
		if (overlay == null)
		{
			return;
		}
		if (texture != null)
		{
			EVROverlayError eVROverlayError = overlay.ShowOverlay(handle);
			if ((eVROverlayError != EVROverlayError.InvalidHandle && eVROverlayError != EVROverlayError.UnknownOverlay) || overlay.FindOverlay(key, ref handle) == EVROverlayError.None)
			{
				Texture_t pTexture = default(Texture_t);
				pTexture.handle = texture.GetNativeTexturePtr();
				pTexture.eType = SteamVR.instance.textureType;
				pTexture.eColorSpace = EColorSpace.Auto;
				overlay.SetOverlayTexture(handle, ref pTexture);
				overlay.SetOverlayAlpha(handle, alpha);
				overlay.SetOverlayWidthInMeters(handle, scale);
				overlay.SetOverlayAutoCurveDistanceRangeInMeters(handle, curvedRange.x, curvedRange.y);
				VRTextureBounds_t pOverlayTextureBounds = default(VRTextureBounds_t);
				pOverlayTextureBounds.uMin = (0f + uvOffset.x) * uvOffset.z;
				pOverlayTextureBounds.vMin = (1f + uvOffset.y) * uvOffset.w;
				pOverlayTextureBounds.uMax = (1f + uvOffset.x) * uvOffset.z;
				pOverlayTextureBounds.vMax = (0f + uvOffset.y) * uvOffset.w;
				overlay.SetOverlayTextureBounds(handle, ref pOverlayTextureBounds);
				HmdVector2_t pvecMouseScale = default(HmdVector2_t);
				pvecMouseScale.v0 = mouseScale.x;
				pvecMouseScale.v1 = mouseScale.y;
				overlay.SetOverlayMouseScale(handle, ref pvecMouseScale);
				SteamVR_Camera steamVR_Camera = SteamVR_Render.Top();
				if (steamVR_Camera != null && steamVR_Camera.origin != null)
				{
					SteamVR_Utils.RigidTransform rigidTransform = new SteamVR_Utils.RigidTransform(steamVR_Camera.origin, base.transform);
					rigidTransform.pos.x /= steamVR_Camera.origin.localScale.x;
					rigidTransform.pos.y /= steamVR_Camera.origin.localScale.y;
					rigidTransform.pos.z /= steamVR_Camera.origin.localScale.z;
					rigidTransform.pos.z += distance;
					HmdMatrix34_t pmatTrackingOriginToOverlayTransform = rigidTransform.ToHmdMatrix34();
					overlay.SetOverlayTransformAbsolute(handle, SteamVR_Render.instance.trackingSpace, ref pmatTrackingOriginToOverlayTransform);
				}
				overlay.SetOverlayInputMethod(handle, inputMethod);
				if (curved || antialias)
				{
					highquality = true;
				}
				if (highquality)
				{
					overlay.SetHighQualityOverlay(handle);
					overlay.SetOverlayFlag(handle, VROverlayFlags.Curved, curved);
					overlay.SetOverlayFlag(handle, VROverlayFlags.RGSS4X, antialias);
				}
				else if (overlay.GetHighQualityOverlay() == handle)
				{
					overlay.SetHighQualityOverlay(0uL);
				}
			}
		}
		else
		{
			overlay.HideOverlay(handle);
		}
	}

	public bool PollNextEvent(ref VREvent_t pEvent)
	{
		CVROverlay overlay = OpenVR.Overlay;
		if (overlay == null)
		{
			return false;
		}
		uint uncbVREvent = (uint)Marshal.SizeOf(typeof(VREvent_t));
		return overlay.PollNextOverlayEvent(handle, ref pEvent, uncbVREvent);
	}

	public bool ComputeIntersection(Vector3 source, Vector3 direction, ref IntersectionResults results)
	{
		CVROverlay overlay = OpenVR.Overlay;
		if (overlay == null)
		{
			return false;
		}
		VROverlayIntersectionParams_t pParams = default(VROverlayIntersectionParams_t);
		pParams.eOrigin = SteamVR_Render.instance.trackingSpace;
		pParams.vSource.v0 = source.x;
		pParams.vSource.v1 = source.y;
		pParams.vSource.v2 = 0f - source.z;
		pParams.vDirection.v0 = direction.x;
		pParams.vDirection.v1 = direction.y;
		pParams.vDirection.v2 = 0f - direction.z;
		VROverlayIntersectionResults_t pResults = default(VROverlayIntersectionResults_t);
		if (!overlay.ComputeOverlayIntersection(handle, ref pParams, ref pResults))
		{
			return false;
		}
		results.point = new Vector3(pResults.vPoint.v0, pResults.vPoint.v1, 0f - pResults.vPoint.v2);
		results.normal = new Vector3(pResults.vNormal.v0, pResults.vNormal.v1, 0f - pResults.vNormal.v2);
		results.UVs = new Vector2(pResults.vUVs.v0, pResults.vUVs.v1);
		results.distance = pResults.fDistance;
		return true;
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(MeshRenderer), typeof(MeshFilter))]
public class SteamVR_PlayArea : MonoBehaviour
{
	public enum Size
	{
		Calibrated,
		_400x300,
		_300x225,
		_200x150
	}

	public float borderThickness = 0.15f;

	public float wireframeHeight = 2f;

	public bool drawWireframeWhenSelectedOnly;

	public bool drawInGame = true;

	public Size size;

	public Color color = Color.cyan;

	[HideInInspector]
	public Vector3[] vertices;

	public static bool GetBounds(Size size, ref HmdQuad_t pRect)
	{
		bool flag;
		int num;
		if (size == Size.Calibrated)
		{
			flag = !SteamVR.active && !SteamVR.usingNativeSupport;
			if (flag)
			{
				EVRInitError peError = EVRInitError.None;
				OpenVR.Init(ref peError, EVRApplicationType.VRApplication_Utility);
			}
			CVRChaperone chaperone = OpenVR.Chaperone;
			if (chaperone != null)
			{
				num = (chaperone.GetPlayAreaRect(ref pRect) ? 1 : 0);
				if (num != 0)
				{
					goto IL_0044;
				}
			}
			else
			{
				num = 0;
			}
			UnityEngine.Debug.LogWarning("Failed to get Calibrated Play Area bounds!  Make sure you have tracking first, and that your space is calibrated.");
			goto IL_0044;
		}
		try
		{
			string[] array = size.ToString().Substring(1).Split(new char[1] { 'x' }, 2);
			float num2 = float.Parse(array[0]) / 200f;
			float num3 = float.Parse(array[1]) / 200f;
			pRect.vCorners0.v0 = num2;
			pRect.vCorners0.v1 = 0f;
			pRect.vCorners0.v2 = 0f - num3;
			pRect.vCorners1.v0 = 0f - num2;
			pRect.vCorners1.v1 = 0f;
			pRect.vCorners1.v2 = 0f - num3;
			pRect.vCorners2.v0 = 0f - num2;
			pRect.vCorners2.v1 = 0f;
			pRect.vCorners2.v2 = num3;
			pRect.vCorners3.v0 = num2;
			pRect.vCorners3.v1 = 0f;
			pRect.vCorners3.v2 = num3;
			return true;
		}
		catch
		{
		}
		return false;
		IL_0044:
		if (flag)
		{
			OpenVR.Shutdown();
		}
		return (byte)num != 0;
	}

	public void BuildMesh()
	{
		HmdQuad_t pRect = default(HmdQuad_t);
		if (!GetBounds(size, ref pRect))
		{
			return;
		}
		HmdVector3_t[] array = new HmdVector3_t[4] { pRect.vCorners0, pRect.vCorners1, pRect.vCorners2, pRect.vCorners3 };
		vertices = new Vector3[array.Length * 2];
		for (int i = 0; i < array.Length; i++)
		{
			HmdVector3_t hmdVector3_t = array[i];
			vertices[i] = new Vector3(hmdVector3_t.v0, 0.01f, hmdVector3_t.v2);
		}
		if (borderThickness == 0f)
		{
			GetComponent<MeshFilter>().mesh = null;
			return;
		}
		for (int j = 0; j < array.Length; j++)
		{
			int num = (j + 1) % array.Length;
			int num2 = (j + array.Length - 1) % array.Length;
			Vector3 normalized = (vertices[num] - vertices[j]).normalized;
			Vector3 normalized2 = (vertices[num2] - vertices[j]).normalized;
			Vector3 vector = vertices[j];
			vector += Vector3.Cross(normalized, Vector3.up) * borderThickness;
			vector += Vector3.Cross(normalized2, Vector3.down) * borderThickness;
			vertices[array.Length + j] = vector;
		}
		int[] triangles = new int[24]
		{
			0, 4, 1, 1, 4, 5, 1, 5, 2, 2,
			5, 6, 2, 6, 3, 3, 6, 7, 3, 7,
			0, 0, 7, 4
		};
		Vector2[] uv = new Vector2[8]
		{
			new Vector2(0f, 0f),
			new Vector2(1f, 0f),
			new Vector2(0f, 0f),
			new Vector2(1f, 0f),
			new Vector2(0f, 1f),
			new Vector2(1f, 1f),
			new Vector2(0f, 1f),
			new Vector2(1f, 1f)
		};
		Color[] colors = new Color[8]
		{
			color,
			color,
			color,
			color,
			new Color(color.r, color.g, color.b, 0f),
			new Color(color.r, color.g, color.b, 0f),
			new Color(color.r, color.g, color.b, 0f),
			new Color(color.r, color.g, color.b, 0f)
		};
		Mesh mesh = new Mesh();
		GetComponent<MeshFilter>().mesh = mesh;
		mesh.vertices = vertices;
		mesh.uv = uv;
		mesh.colors = colors;
		mesh.triangles = triangles;
		MeshRenderer component = GetComponent<MeshRenderer>();
		component.material = new Material(Shader.Find("Sprites/Default"));
		component.reflectionProbeUsage = ReflectionProbeUsage.Off;
		component.shadowCastingMode = ShadowCastingMode.Off;
		component.receiveShadows = false;
		component.lightProbeUsage = LightProbeUsage.Off;
	}

	private void OnDrawGizmos()
	{
		if (!drawWireframeWhenSelectedOnly)
		{
			DrawWireframe();
		}
	}

	private void OnDrawGizmosSelected()
	{
		if (drawWireframeWhenSelectedOnly)
		{
			DrawWireframe();
		}
	}

	public void DrawWireframe()
	{
		if (vertices != null && vertices.Length != 0)
		{
			Vector3 vector = base.transform.TransformVector(Vector3.up * wireframeHeight);
			for (int i = 0; i < 4; i++)
			{
				int num = (i + 1) % 4;
				Vector3 vector2 = base.transform.TransformPoint(vertices[i]);
				Vector3 vector3 = vector2 + vector;
				Vector3 vector4 = base.transform.TransformPoint(vertices[num]);
				Vector3 to = vector4 + vector;
				Gizmos.DrawLine(vector2, vector3);
				Gizmos.DrawLine(vector2, vector4);
				Gizmos.DrawLine(vector3, to);
			}
		}
	}

	public void OnEnable()
	{
		if (UnityEngine.Application.isPlaying)
		{
			GetComponent<MeshRenderer>().enabled = drawInGame;
			base.enabled = false;
			if (drawInGame && size == Size.Calibrated)
			{
				StartCoroutine(UpdateBounds());
			}
		}
	}

	private IEnumerator UpdateBounds()
	{
		GetComponent<MeshFilter>().mesh = null;
		CVRChaperone chaperone = OpenVR.Chaperone;
		if (chaperone != null)
		{
			while (chaperone.GetCalibrationState() != ChaperoneCalibrationState.OK)
			{
				yield return null;
			}
			BuildMesh();
		}
	}
}
public class SteamVR_Render : MonoBehaviour
{
	public bool pauseGameWhenDashboardIsVisible = true;

	public bool lockPhysicsUpdateRateToRenderFrequency = true;

	public SteamVR_ExternalCamera externalCamera;

	public string externalCameraConfigPath = "externalcamera.cfg";

	public ETrackingUniverseOrigin trackingSpace = ETrackingUniverseOrigin.TrackingUniverseStanding;

	private static SteamVR_Render _instance;

	private static bool isQuitting;

	private SteamVR_Camera[] cameras = new SteamVR_Camera[0];

	public TrackedDevicePose_t[] poses = new TrackedDevicePose_t[64];

	public TrackedDevicePose_t[] gamePoses = new TrackedDevicePose_t[0];

	private static bool _pauseRendering;

	private WaitForEndOfFrame waitForEndOfFrame = new WaitForEndOfFrame();

	private float sceneResolutionScale = 1f;

	private float timeScale = 1f;

	public static EVREye eye { get; private set; }

	public static SteamVR_Render instance
	{
		get
		{
			if (_instance == null)
			{
				_instance = UnityEngine.Object.FindObjectOfType<SteamVR_Render>();
				if (_instance == null)
				{
					_instance = new GameObject("[SteamVR]").AddComponent<SteamVR_Render>();
				}
			}
			return _instance;
		}
	}

	public static bool pauseRendering
	{
		get
		{
			return _pauseRendering;
		}
		set
		{
			_pauseRendering = value;
			OpenVR.Compositor?.SuspendRendering(value);
		}
	}

	private void OnDestroy()
	{
		_instance = null;
	}

	private void OnApplicationQuit()
	{
		isQuitting = true;
		SteamVR.SafeDispose();
	}

	public static void Add(SteamVR_Camera vrcam)
	{
		if (!isQuitting)
		{
			instance.AddInternal(vrcam);
		}
	}

	public static void Remove(SteamVR_Camera vrcam)
	{
		if (!isQuitting && _instance != null)
		{
			instance.RemoveInternal(vrcam);
		}
	}

	public static SteamVR_Camera Top()
	{
		if (!isQuitting)
		{
			return instance.TopInternal();
		}
		return null;
	}

	private void AddInternal(SteamVR_Camera vrcam)
	{
		Camera component = vrcam.GetComponent<Camera>();
		int num = cameras.Length;
		SteamVR_Camera[] array = new SteamVR_Camera[num + 1];
		int num2 = 0;
		for (int i = 0; i < num; i++)
		{
			Camera component2 = cameras[i].GetComponent<Camera>();
			if (i == num2 && component2.depth > component.depth)
			{
				array[num2++] = vrcam;
			}
			array[num2++] = cameras[i];
		}
		if (num2 == num)
		{
			array[num2] = vrcam;
		}
		cameras = array;
	}

	private void RemoveInternal(SteamVR_Camera vrcam)
	{
		int num = cameras.Length;
		int num2 = 0;
		for (int i = 0; i < num; i++)
		{
			if (cameras[i] == vrcam)
			{
				num2++;
			}
		}
		if (num2 == 0)
		{
			return;
		}
		SteamVR_Camera[] array = new SteamVR_Camera[num - num2];
		int num3 = 0;
		for (int j = 0; j < num; j++)
		{
			SteamVR_Camera steamVR_Camera = cameras[j];
			if (steamVR_Camera != vrcam)
			{
				array[num3++] = steamVR_Camera;
			}
		}
		cameras = array;
	}

	private SteamVR_Camera TopInternal()
	{
		if (cameras.Length != 0)
		{
			return cameras[cameras.Length - 1];
		}
		return null;
	}

	private IEnumerator RenderLoop()
	{
		while (UnityEngine.Application.isPlaying)
		{
			yield return waitForEndOfFrame;
			if (pauseRendering)
			{
				continue;
			}
			CVRCompositor compositor = OpenVR.Compositor;
			if (compositor != null)
			{
				if (!compositor.CanRenderScene())
				{
					continue;
				}
				compositor.SetTrackingSpace(trackingSpace);
			}
			SteamVR_Overlay steamVR_Overlay = SteamVR_Overlay.instance;
			if (steamVR_Overlay != null)
			{
				steamVR_Overlay.UpdateOverlay();
			}
			RenderExternalCamera();
		}
	}

	private void RenderExternalCamera()
	{
		if (!(externalCamera == null) && externalCamera.gameObject.activeInHierarchy)
		{
			int num = (int)Mathf.Max(externalCamera.config.frameSkip, 0f);
			if (Time.frameCount % (num + 1) == 0)
			{
				externalCamera.AttachToCamera(TopInternal());
				externalCamera.RenderNear();
				externalCamera.RenderFar();
			}
		}
	}

	private void OnInputFocus(bool hasFocus)
	{
		if (hasFocus)
		{
			if (pauseGameWhenDashboardIsVisible)
			{
				Time.timeScale = timeScale;
			}
			SteamVR_Camera.sceneResolutionScale = sceneResolutionScale;
			return;
		}
		if (pauseGameWhenDashboardIsVisible)
		{
			timeScale = Time.timeScale;
			Time.timeScale = 0f;
		}
		sceneResolutionScale = SteamVR_Camera.sceneResolutionScale;
		SteamVR_Camera.sceneResolutionScale = 0.5f;
	}

	private void OnQuit(VREvent_t vrEvent)
	{
		UnityEngine.Application.Quit();
	}

	private string GetScreenshotFilename(uint screenshotHandle, EVRScreenshotPropertyFilenames screenshotPropertyFilename)
	{
		EVRScreenshotError pError = EVRScreenshotError.None;
		uint screenshotPropertyFilename2 = OpenVR.Screenshots.GetScreenshotPropertyFilename(screenshotHandle, screenshotPropertyFilename, null, 0u, ref pError);
		if (pError != 0 && pError != EVRScreenshotError.BufferTooSmall)
		{
			return null;
		}
		if (screenshotPropertyFilename2 > 1)
		{
			StringBuilder stringBuilder = new StringBuilder((int)screenshotPropertyFilename2);
			OpenVR.Screenshots.GetScreenshotPropertyFilename(screenshotHandle, screenshotPropertyFilename, stringBuilder, screenshotPropertyFilename2, ref pError);
			if (pError != 0)
			{
				return null;
			}
			return stringBuilder.ToString();
		}
		return null;
	}

	private void OnRequestScreenshot(VREvent_t vrEvent)
	{
		uint handle = vrEvent.data.screenshot.handle;
		EVRScreenshotType type = (EVRScreenshotType)vrEvent.data.screenshot.type;
		if (type == EVRScreenshotType.StereoPanorama)
		{
			string previewFilename = GetScreenshotFilename(handle, EVRScreenshotPropertyFilenames.Preview);
			string VRFilename = GetScreenshotFilename(handle, EVRScreenshotPropertyFilenames.VR);
			if (previewFilename != null && VRFilename != null)
			{
				GameObject gameObject = new GameObject("screenshotPosition");
				gameObject.transform.position = Top().transform.position;
				gameObject.transform.rotation = Top().transform.rotation;
				gameObject.transform.localScale = Top().transform.lossyScale;
				SteamVR_Utils.TakeStereoScreenshot(handle, gameObject, 32, 0.064f, ref previewFilename, ref VRFilename);
				OpenVR.Screenshots.SubmitScreenshot(handle, type, previewFilename, VRFilename);
			}
		}
	}

	private void OnEnable()
	{
		StartCoroutine(RenderLoop());
		SteamVR_Events.InputFocus.Listen(OnInputFocus);
		SteamVR_Events.System(EVREventType.VREvent_Quit).Listen(OnQuit);
		SteamVR_Events.System(EVREventType.VREvent_RequestScreenshot).Listen(OnRequestScreenshot);
		UnityEngine.Application.onBeforeRender += OnBeforeRender;
		if (SteamVR.instance == null)
		{
			base.enabled = false;
			return;
		}
		EVRScreenshotType[] pSupportedTypes = new EVRScreenshotType[1] { EVRScreenshotType.StereoPanorama };
		OpenVR.Screenshots.HookScreenshot(pSupportedTypes);
	}

	private void OnDisable()
	{
		StopAllCoroutines();
		SteamVR_Events.InputFocus.Remove(OnInputFocus);
		SteamVR_Events.System(EVREventType.VREvent_Quit).Remove(OnQuit);
		SteamVR_Events.System(EVREventType.VREvent_RequestScreenshot).Remove(OnRequestScreenshot);
		UnityEngine.Application.onBeforeRender -= OnBeforeRender;
	}

	private void Awake()
	{
		if (externalCamera == null && File.Exists(externalCameraConfigPath))
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("SteamVR_ExternalCamera"));
			gameObject.gameObject.name = "External Camera";
			externalCamera = gameObject.transform.GetChild(0).GetComponent<SteamVR_ExternalCamera>();
			externalCamera.configPath = externalCameraConfigPath;
			externalCamera.ReadConfig();
		}
	}

	public void UpdatePoses()
	{
		CVRCompositor compositor = OpenVR.Compositor;
		if (compositor != null)
		{
			compositor.GetLastPoses(poses, gamePoses);
			SteamVR_Events.NewPoses.Send(poses);
			SteamVR_Events.NewPosesApplied.Send();
		}
	}

	private void OnBeforeRender()
	{
		UpdatePoses();
	}

	private void Update()
	{
		SteamVR_Controller.Update();
		CVRSystem system = OpenVR.System;
		if (system != null)
		{
			VREvent_t pEvent = default(VREvent_t);
			uint uncbVREvent = (uint)Marshal.SizeOf(typeof(VREvent_t));
			for (int i = 0; i < 64; i++)
			{
				if (!system.PollNextEvent(ref pEvent, uncbVREvent))
				{
					break;
				}
				switch ((EVREventType)pEvent.eventType)
				{
				case EVREventType.VREvent_InputFocusCaptured:
					if (pEvent.data.process.oldPid == 0)
					{
						SteamVR_Events.InputFocus.Send(arg0: false);
					}
					break;
				case EVREventType.VREvent_InputFocusReleased:
					if (pEvent.data.process.pid == 0)
					{
						SteamVR_Events.InputFocus.Send(arg0: true);
					}
					break;
				case EVREventType.VREvent_ShowRenderModels:
					SteamVR_Events.HideRenderModels.Send(arg0: false);
					break;
				case EVREventType.VREvent_HideRenderModels:
					SteamVR_Events.HideRenderModels.Send(arg0: true);
					break;
				default:
					SteamVR_Events.System((EVREventType)pEvent.eventType).Send(pEvent);
					break;
				}
			}
		}
		UnityEngine.Application.targetFrameRate = -1;
		UnityEngine.Application.runInBackground = true;
		QualitySettings.maxQueuedFrames = -1;
		QualitySettings.vSyncCount = 0;
		if (lockPhysicsUpdateRateToRenderFrequency && Time.timeScale > 0f)
		{
			SteamVR steamVR = SteamVR.instance;
			if (steamVR != null)
			{
				Compositor_FrameTiming pTiming = default(Compositor_FrameTiming);
				pTiming.m_nSize = (uint)Marshal.SizeOf(typeof(Compositor_FrameTiming));
				steamVR.compositor.GetFrameTiming(ref pTiming, 0u);
				Time.fixedDeltaTime = Time.timeScale / steamVR.hmd_DisplayFrequency;
			}
		}
	}
}
[ExecuteInEditMode]
public class SteamVR_RenderModel : MonoBehaviour
{
	public class RenderModel
	{
		public Mesh mesh { get; private set; }

		public Material material { get; private set; }

		public RenderModel(Mesh mesh, Material material)
		{
			this.mesh = mesh;
			this.material = material;
		}
	}

	public sealed class RenderModelInterfaceHolder : IDisposable
	{
		private bool needsShutdown;

		private bool failedLoadInterface;

		private CVRRenderModels _instance;

		public CVRRenderModels instance
		{
			get
			{
				if (_instance == null && !failedLoadInterface)
				{
					if (!SteamVR.active && !SteamVR.usingNativeSupport)
					{
						EVRInitError peError = EVRInitError.None;
						OpenVR.Init(ref peError, EVRApplicationType.VRApplication_Utility);
						needsShutdown = true;
					}
					_instance = OpenVR.RenderModels;
					if (_instance == null)
					{
						UnityEngine.Debug.LogError("Failed to load IVRRenderModels interface version IVRRenderModels_005");
						failedLoadInterface = true;
					}
				}
				return _instance;
			}
		}

		public void Dispose()
		{
			if (needsShutdown)
			{
				OpenVR.Shutdown();
			}
		}
	}

	public SteamVR_TrackedObject.EIndex index = SteamVR_TrackedObject.EIndex.None;

	public const string modelOverrideWarning = "Model override is really only meant to be used in the scene view for lining things up; using it at runtime is discouraged.  Use tracked device index instead to ensure the correct model is displayed for all users.";

	[Tooltip("Model override is really only meant to be used in the scene view for lining things up; using it at runtime is discouraged.  Use tracked device index instead to ensure the correct model is displayed for all users.")]
	public string modelOverride;

	[Tooltip("Shader to apply to model.")]
	public Shader shader;

	[Tooltip("Enable to print out when render models are loaded.")]
	public bool verbose;

	[Tooltip("If available, break down into separate components instead of loading as a single mesh.")]
	public bool createComponents = true;

	[Tooltip("Update transforms of components at runtime to reflect user action.")]
	public bool updateDynamically = true;

	public RenderModel_ControllerMode_State_t controllerModeState;

	public const string k_localTransformName = "attach";

	public static System.Collections.Hashtable models = new System.Collections.Hashtable();

	public static System.Collections.Hashtable materials = new System.Collections.Hashtable();

	private SteamVR_Events.Action deviceConnectedAction;

	private SteamVR_Events.Action hideRenderModelsAction;

	private SteamVR_Events.Action modelSkinSettingsHaveChangedAction;

	private Dictionary<int, string> nameCache;

	public string renderModelName { get; private set; }

	private void OnModelSkinSettingsHaveChanged(VREvent_t vrEvent)
	{
		if (!string.IsNullOrEmpty(renderModelName))
		{
			renderModelName = "";
			UpdateModel();
		}
	}

	private void OnHideRenderModels(bool hidden)
	{
		MeshRenderer component = GetComponent<MeshRenderer>();
		if (component != null)
		{
			component.enabled = !hidden;
		}
		MeshRenderer[] componentsInChildren = base.transform.GetComponentsInChildren<MeshRenderer>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].enabled = !hidden;
		}
	}

	private void OnDeviceConnected(int i, bool connected)
	{
		if (i == (int)index && connected)
		{
			UpdateModel();
		}
	}

	public void UpdateModel()
	{
		CVRSystem system = OpenVR.System;
		if (system == null)
		{
			return;
		}
		ETrackedPropertyError pError = ETrackedPropertyError.TrackedProp_Success;
		uint stringTrackedDeviceProperty = system.GetStringTrackedDeviceProperty((uint)index, ETrackedDeviceProperty.Prop_RenderModelName_String, null, 0u, ref pError);
		if (stringTrackedDeviceProperty <= 1)
		{
			UnityEngine.Debug.LogError("Failed to get render model name for tracked object " + index);
			return;
		}
		StringBuilder stringBuilder = new StringBuilder((int)stringTrackedDeviceProperty);
		system.GetStringTrackedDeviceProperty((uint)index, ETrackedDeviceProperty.Prop_RenderModelName_String, stringBuilder, stringTrackedDeviceProperty, ref pError);
		string text = stringBuilder.ToString();
		if (renderModelName != text)
		{
			renderModelName = text;
			StartCoroutine(SetModelAsync(text));
		}
	}

	private IEnumerator SetModelAsync(string renderModelName)
	{
		if (string.IsNullOrEmpty(renderModelName))
		{
			yield break;
		}
		using (RenderModelInterfaceHolder holder = new RenderModelInterfaceHolder())
		{
			CVRRenderModels renderModels = holder.instance;
			if (renderModels == null)
			{
				yield break;
			}
			uint componentCount = renderModels.GetComponentCount(renderModelName);
			string[] renderModelNames;
			if (componentCount == 0)
			{
				renderModelNames = ((models[renderModelName] is RenderModel renderModel && !(renderModel.mesh == null)) ? new string[0] : new string[1] { renderModelName });
			}
			else
			{
				renderModelNames = new string[componentCount];
				for (int i = 0; i < componentCount; i++)
				{
					uint componentName = renderModels.GetComponentName(renderModelName, (uint)i, null, 0u);
					if (componentName == 0)
					{
						continue;
					}
					StringBuilder stringBuilder = new StringBuilder((int)componentName);
					if (renderModels.GetComponentName(renderModelName, (uint)i, stringBuilder, componentName) == 0)
					{
						continue;
					}
					componentName = renderModels.GetComponentRenderModelName(renderModelName, stringBuilder.ToString(), null, 0u);
					if (componentName == 0)
					{
						continue;
					}
					StringBuilder stringBuilder2 = new StringBuilder((int)componentName);
					if (renderModels.GetComponentRenderModelName(renderModelName, stringBuilder.ToString(), stringBuilder2, componentName) != 0)
					{
						string text = stringBuilder2.ToString();
						if (!(models[text] is RenderModel renderModel2) || renderModel2.mesh == null)
						{
							renderModelNames[i] = text;
						}
					}
				}
			}
			while (true)
			{
				bool flag = false;
				string[] array = renderModelNames;
				foreach (string text2 in array)
				{
					if (string.IsNullOrEmpty(text2))
					{
						continue;
					}
					IntPtr ppRenderModel = IntPtr.Zero;
					switch (renderModels.LoadRenderModel_Async(text2, ref ppRenderModel))
					{
					case EVRRenderModelError.Loading:
						flag = true;
						break;
					case EVRRenderModelError.None:
					{
						RenderModel_t renderModel_t = MarshalRenderModel(ppRenderModel);
						Material material = materials[renderModel_t.diffuseTextureId] as Material;
						if (material == null || material.mainTexture == null)
						{
							IntPtr ppTexture = IntPtr.Zero;
							EVRRenderModelError eVRRenderModelError = renderModels.LoadTexture_Async(renderModel_t.diffuseTextureId, ref ppTexture);
							if (eVRRenderModelError == EVRRenderModelError.Loading)
							{
								flag = true;
							}
						}
						break;
					}
					}
				}
				if (!flag)
				{
					break;
				}
				yield return new WaitForSecondsRealtime(0.1f);
			}
		}
		bool arg = SetModel(renderModelName);
		SteamVR_Events.RenderModelLoaded.Send(this, arg);
	}

	private bool SetModel(string renderModelName)
	{
		StripMesh(base.gameObject);
		using (RenderModelInterfaceHolder renderModelInterfaceHolder = new RenderModelInterfaceHolder())
		{
			if (createComponents)
			{
				if (LoadComponents(renderModelInterfaceHolder, renderModelName))
				{
					UpdateComponents(renderModelInterfaceHolder.instance);
					return true;
				}
				UnityEngine.Debug.Log("[" + base.gameObject.name + "] Render model does not support components, falling back to single mesh.");
			}
			if (!string.IsNullOrEmpty(renderModelName))
			{
				RenderModel renderModel = models[renderModelName] as RenderModel;
				if (renderModel == null || renderModel.mesh == null)
				{
					CVRRenderModels instance = renderModelInterfaceHolder.instance;
					if (instance == null)
					{
						return false;
					}
					if (verbose)
					{
						UnityEngine.Debug.Log("Loading render model " + renderModelName);
					}
					renderModel = LoadRenderModel(instance, renderModelName, renderModelName);
					if (renderModel == null)
					{
						return false;
					}
					models[renderModelName] = renderModel;
				}
				base.gameObject.AddComponent<MeshFilter>().mesh = renderModel.mesh;
				base.gameObject.AddComponent<MeshRenderer>().sharedMaterial = renderModel.material;
				return true;
			}
		}
		return false;
	}

	private RenderModel LoadRenderModel(CVRRenderModels renderModels, string renderModelName, string baseName)
	{
		IntPtr ppRenderModel = IntPtr.Zero;
		while (true)
		{
			EVRRenderModelError eVRRenderModelError = renderModels.LoadRenderModel_Async(renderModelName, ref ppRenderModel);
			switch (eVRRenderModelError)
			{
			case EVRRenderModelError.Loading:
				break;
			default:
				UnityEngine.Debug.LogError($"Failed to load render model {renderModelName} - {eVRRenderModelError.ToString()}");
				return null;
			case EVRRenderModelError.None:
			{
				RenderModel_t renderModel_t = MarshalRenderModel(ppRenderModel);
				Vector3[] array = new Vector3[renderModel_t.unVertexCount];
				Vector3[] array2 = new Vector3[renderModel_t.unVertexCount];
				Vector2[] array3 = new Vector2[renderModel_t.unVertexCount];
				Type typeFromHandle = typeof(RenderModel_Vertex_t);
				for (int i = 0; i < renderModel_t.unVertexCount; i++)
				{
					RenderModel_Vertex_t renderModel_Vertex_t = (RenderModel_Vertex_t)Marshal.PtrToStructure(new IntPtr(renderModel_t.rVertexData.ToInt64() + i * Marshal.SizeOf(typeFromHandle)), typeFromHandle);
					array[i] = new Vector3(renderModel_Vertex_t.vPosition.v0, renderModel_Vertex_t.vPosition.v1, 0f - renderModel_Vertex_t.vPosition.v2);
					array2[i] = new Vector3(renderModel_Vertex_t.vNormal.v0, renderModel_Vertex_t.vNormal.v1, 0f - renderModel_Vertex_t.vNormal.v2);
					array3[i] = new Vector2(renderModel_Vertex_t.rfTextureCoord0, renderModel_Vertex_t.rfTextureCoord1);
				}
				uint num = renderModel_t.unTriangleCount * 3;
				short[] array4 = new short[num];
				Marshal.Copy(renderModel_t.rIndexData, array4, 0, array4.Length);
				int[] array5 = new int[num];
				for (int j = 0; j < renderModel_t.unTriangleCount; j++)
				{
					array5[j * 3] = array4[j * 3 + 2];
					array5[j * 3 + 1] = array4[j * 3 + 1];
					array5[j * 3 + 2] = array4[j * 3];
				}
				Mesh mesh = new Mesh();
				mesh.vertices = array;
				mesh.normals = array2;
				mesh.uv = array3;
				mesh.triangles = array5;
				Material material = materials[renderModel_t.diffuseTextureId] as Material;
				if (material == null || material.mainTexture == null)
				{
					IntPtr ppTexture = IntPtr.Zero;
					while (true)
					{
						switch (renderModels.LoadTexture_Async(renderModel_t.diffuseTextureId, ref ppTexture))
						{
						case EVRRenderModelError.Loading:
							goto IL_0230;
						case EVRRenderModelError.None:
						{
							RenderModel_TextureMap_t renderModel_TextureMap_t = MarshalRenderModel_TextureMap(ppTexture);
							Texture2D texture2D = new Texture2D(renderModel_TextureMap_t.unWidth, renderModel_TextureMap_t.unHeight, TextureFormat.RGBA32, mipChain: false);
							if (SystemInfo.graphicsDeviceType == GraphicsDeviceType.Direct3D11)
							{
								texture2D.Apply();
								while (true)
								{
									eVRRenderModelError = renderModels.LoadIntoTextureD3D11_Async(renderModel_t.diffuseTextureId, texture2D.GetNativeTexturePtr());
									if (eVRRenderModelError != EVRRenderModelError.Loading)
									{
										break;
									}
									Sleep();
								}
							}
							else
							{
								byte[] array6 = new byte[renderModel_TextureMap_t.unWidth * renderModel_TextureMap_t.unHeight * 4];
								Marshal.Copy(renderModel_TextureMap_t.rubTextureMapData, array6, 0, array6.Length);
								Color32[] array7 = new Color32[renderModel_TextureMap_t.unWidth * renderModel_TextureMap_t.unHeight];
								int num2 = 0;
								for (int k = 0; k < renderModel_TextureMap_t.unHeight; k++)
								{
									for (int l = 0; l < renderModel_TextureMap_t.unWidth; l++)
									{
										byte r = array6[num2++];
										byte g = array6[num2++];
										byte b = array6[num2++];
										byte a = array6[num2++];
										array7[k * renderModel_TextureMap_t.unWidth + l] = new Color32(r, g, b, a);
									}
								}
								texture2D.SetPixels32(array7);
								texture2D.Apply();
							}
							material = new Material((shader != null) ? shader : Shader.Find("Standard"));
							material.mainTexture = texture2D;
							materials[renderModel_t.diffuseTextureId] = material;
							renderModels.FreeTexture(ppTexture);
							break;
						}
						default:
							UnityEngine.Debug.Log("Failed to load render model texture for render model " + renderModelName);
							break;
						}
						break;
						IL_0230:
						Sleep();
					}
				}
				StartCoroutine(FreeRenderModel(ppRenderModel));
				return new RenderModel(mesh, material);
			}
			}
			Sleep();
		}
	}

	private IEnumerator FreeRenderModel(IntPtr pRenderModel)
	{
		yield return new WaitForSeconds(1f);
		using RenderModelInterfaceHolder renderModelInterfaceHolder = new RenderModelInterfaceHolder();
		renderModelInterfaceHolder.instance.FreeRenderModel(pRenderModel);
	}

	public Transform FindComponent(string componentName)
	{
		Transform transform = base.transform;
		for (int i = 0; i < transform.childCount; i++)
		{
			Transform child = transform.GetChild(i);
			if (child.name == componentName)
			{
				return child;
			}
		}
		return null;
	}

	private void StripMesh(GameObject go)
	{
		MeshRenderer component = go.GetComponent<MeshRenderer>();
		if (component != null)
		{
			UnityEngine.Object.DestroyImmediate(component);
		}
		MeshFilter component2 = go.GetComponent<MeshFilter>();
		if (component2 != null)
		{
			UnityEngine.Object.DestroyImmediate(component2);
		}
	}

	private bool LoadComponents(RenderModelInterfaceHolder holder, string renderModelName)
	{
		Transform transform = base.transform;
		for (int i = 0; i < transform.childCount; i++)
		{
			Transform child = transform.GetChild(i);
			child.gameObject.SetActive(value: false);
			StripMesh(child.gameObject);
		}
		if (string.IsNullOrEmpty(renderModelName))
		{
			return true;
		}
		CVRRenderModels instance = holder.instance;
		if (instance == null)
		{
			return false;
		}
		uint componentCount = instance.GetComponentCount(renderModelName);
		if (componentCount == 0)
		{
			return false;
		}
		for (int j = 0; j < componentCount; j++)
		{
			uint componentName = instance.GetComponentName(renderModelName, (uint)j, null, 0u);
			if (componentName == 0)
			{
				continue;
			}
			StringBuilder stringBuilder = new StringBuilder((int)componentName);
			if (instance.GetComponentName(renderModelName, (uint)j, stringBuilder, componentName) == 0)
			{
				continue;
			}
			transform = FindComponent(stringBuilder.ToString());
			if (transform != null)
			{
				transform.gameObject.SetActive(value: true);
			}
			else
			{
				transform = new GameObject(stringBuilder.ToString()).transform;
				transform.parent = base.transform;
				transform.gameObject.layer = base.gameObject.layer;
				Transform obj = new GameObject("attach").transform;
				obj.parent = transform;
				obj.localPosition = Vector3.zero;
				obj.localRotation = Quaternion.identity;
				obj.localScale = Vector3.one;
				obj.gameObject.layer = base.gameObject.layer;
			}
			transform.localPosition = Vector3.zero;
			transform.localRotation = Quaternion.identity;
			transform.localScale = Vector3.one;
			componentName = instance.GetComponentRenderModelName(renderModelName, stringBuilder.ToString(), null, 0u);
			if (componentName == 0)
			{
				continue;
			}
			StringBuilder stringBuilder2 = new StringBuilder((int)componentName);
			if (instance.GetComponentRenderModelName(renderModelName, stringBuilder.ToString(), stringBuilder2, componentName) == 0)
			{
				continue;
			}
			RenderModel renderModel = models[stringBuilder2] as RenderModel;
			if (renderModel == null || renderModel.mesh == null)
			{
				if (verbose)
				{
					UnityEngine.Debug.Log("Loading render model " + stringBuilder2);
				}
				renderModel = LoadRenderModel(instance, stringBuilder2.ToString(), renderModelName);
				if (renderModel == null)
				{
					continue;
				}
				models[stringBuilder2] = renderModel;
			}
			transform.gameObject.AddComponent<MeshFilter>().mesh = renderModel.mesh;
			transform.gameObject.AddComponent<MeshRenderer>().sharedMaterial = renderModel.material;
		}
		return true;
	}

	private SteamVR_RenderModel()
	{
		deviceConnectedAction = SteamVR_Events.DeviceConnectedAction(OnDeviceConnected);
		hideRenderModelsAction = SteamVR_Events.HideRenderModelsAction(OnHideRenderModels);
		modelSkinSettingsHaveChangedAction = SteamVR_Events.SystemAction(EVREventType.VREvent_ModelSkinSettingsHaveChanged, OnModelSkinSettingsHaveChanged);
	}

	private void OnEnable()
	{
		if (!string.IsNullOrEmpty(modelOverride))
		{
			UnityEngine.Debug.Log("Model override is really only meant to be used in the scene view for lining things up; using it at runtime is discouraged.  Use tracked device index instead to ensure the correct model is displayed for all users.");
			base.enabled = false;
			return;
		}
		CVRSystem system = OpenVR.System;
		if (system != null && system.IsTrackedDeviceConnected((uint)index))
		{
			UpdateModel();
		}
		deviceConnectedAction.enabled = true;
		hideRenderModelsAction.enabled = true;
		modelSkinSettingsHaveChangedAction.enabled = true;
	}

	private void OnDisable()
	{
		deviceConnectedAction.enabled = false;
		hideRenderModelsAction.enabled = false;
		modelSkinSettingsHaveChangedAction.enabled = false;
	}

	private void Update()
	{
		if (updateDynamically)
		{
			UpdateComponents(OpenVR.RenderModels);
		}
	}

	public void UpdateComponents(CVRRenderModels renderModels)
	{
		if (renderModels == null)
		{
			return;
		}
		Transform transform = base.transform;
		if (transform.childCount == 0)
		{
			return;
		}
		VRControllerState_t pControllerState = ((index != SteamVR_TrackedObject.EIndex.None) ? SteamVR_Controller.Input((int)index).GetState() : default(VRControllerState_t));
		if (nameCache == null)
		{
			nameCache = new Dictionary<int, string>();
		}
		for (int i = 0; i < transform.childCount; i++)
		{
			Transform child = transform.GetChild(i);
			if (!nameCache.TryGetValue(child.GetInstanceID(), out var value))
			{
				value = child.name;
				nameCache.Add(child.GetInstanceID(), value);
			}
			RenderModel_ComponentState_t pComponentState = default(RenderModel_ComponentState_t);
			if (renderModels.GetComponentState(renderModelName, value, ref pControllerState, ref controllerModeState, ref pComponentState))
			{
				SteamVR_Utils.RigidTransform rigidTransform = new SteamVR_Utils.RigidTransform(pComponentState.mTrackingToComponentRenderModel);
				child.localPosition = rigidTransform.pos;
				child.localRotation = rigidTransform.rot;
				Transform transform2 = child.Find("attach");
				if (transform2 != null)
				{
					SteamVR_Utils.RigidTransform rigidTransform2 = new SteamVR_Utils.RigidTransform(pComponentState.mTrackingToComponentLocal);
					transform2.position = transform.TransformPoint(rigidTransform2.pos);
					transform2.rotation = transform.rotation * rigidTransform2.rot;
				}
				bool flag = (pComponentState.uProperties & 2) != 0;
				if (flag != child.gameObject.activeSelf)
				{
					child.gameObject.SetActive(flag);
				}
			}
		}
	}

	public void SetDeviceIndex(int index)
	{
		this.index = (SteamVR_TrackedObject.EIndex)index;
		modelOverride = "";
		if (base.enabled)
		{
			UpdateModel();
		}
	}

	private static void Sleep()
	{
		Thread.Sleep(1);
	}

	private RenderModel_t MarshalRenderModel(IntPtr pRenderModel)
	{
		if (Environment.OSVersion.Platform == PlatformID.MacOSX || Environment.OSVersion.Platform == PlatformID.Unix)
		{
			RenderModel_t_Packed renderModel_t_Packed = (RenderModel_t_Packed)Marshal.PtrToStructure(pRenderModel, typeof(RenderModel_t_Packed));
			RenderModel_t unpacked = default(RenderModel_t);
			renderModel_t_Packed.Unpack(ref unpacked);
			return unpacked;
		}
		return (RenderModel_t)Marshal.PtrToStructure(pRenderModel, typeof(RenderModel_t));
	}

	private RenderModel_TextureMap_t MarshalRenderModel_TextureMap(IntPtr pRenderModel)
	{
		if (Environment.OSVersion.Platform == PlatformID.MacOSX || Environment.OSVersion.Platform == PlatformID.Unix)
		{
			RenderModel_TextureMap_t_Packed renderModel_TextureMap_t_Packed = (RenderModel_TextureMap_t_Packed)Marshal.PtrToStructure(pRenderModel, typeof(RenderModel_TextureMap_t_Packed));
			RenderModel_TextureMap_t unpacked = default(RenderModel_TextureMap_t);
			renderModel_TextureMap_t_Packed.Unpack(ref unpacked);
			return unpacked;
		}
		return (RenderModel_TextureMap_t)Marshal.PtrToStructure(pRenderModel, typeof(RenderModel_TextureMap_t));
	}
}
public class SteamVR_Skybox : MonoBehaviour
{
	public enum CellSize
	{
		x1024,
		x64,
		x32,
		x16,
		x8
	}

	public Texture front;

	public Texture back;

	public Texture left;

	public Texture right;

	public Texture top;

	public Texture bottom;

	public CellSize StereoCellSize = CellSize.x32;

	public float StereoIpdMm = 64f;

	public void SetTextureByIndex(int i, Texture t)
	{
		switch (i)
		{
		case 0:
			front = t;
			break;
		case 1:
			back = t;
			break;
		case 2:
			left = t;
			break;
		case 3:
			right = t;
			break;
		case 4:
			top = t;
			break;
		case 5:
			bottom = t;
			break;
		}
	}

	public Texture GetTextureByIndex(int i)
	{
		return i switch
		{
			0 => front, 
			1 => back, 
			2 => left, 
			3 => right, 
			4 => top, 
			5 => bottom, 
			_ => null, 
		};
	}

	public static void SetOverride(Texture front = null, Texture back = null, Texture left = null, Texture right = null, Texture top = null, Texture bottom = null)
	{
		CVRCompositor compositor = OpenVR.Compositor;
		if (compositor == null)
		{
			return;
		}
		Texture[] array = new Texture[6] { front, back, left, right, top, bottom };
		Texture_t[] array2 = new Texture_t[6];
		for (int i = 0; i < 6; i++)
		{
			array2[i].handle = ((array[i] != null) ? array[i].GetNativeTexturePtr() : IntPtr.Zero);
			array2[i].eType = SteamVR.instance.textureType;
			array2[i].eColorSpace = EColorSpace.Auto;
		}
		EVRCompositorError eVRCompositorError = compositor.SetSkyboxOverride(array2);
		if (eVRCompositorError != 0)
		{
			UnityEngine.Debug.LogError("Failed to set skybox override with error: " + eVRCompositorError);
			switch (eVRCompositorError)
			{
			case EVRCompositorError.TextureIsOnWrongDevice:
				UnityEngine.Debug.Log("Set your graphics driver to use the same video card as the headset is plugged into for Unity.");
				break;
			case EVRCompositorError.TextureUsesUnsupportedFormat:
				UnityEngine.Debug.Log("Ensure skybox textures are not compressed and have no mipmaps.");
				break;
			}
		}
	}

	public static void ClearOverride()
	{
		OpenVR.Compositor?.ClearSkyboxOverride();
	}

	private void OnEnable()
	{
		SetOverride(front, back, left, right, top, bottom);
	}

	private void OnDisable()
	{
		ClearOverride();
	}
}
[ExecuteInEditMode]
public class SteamVR_SphericalProjection : MonoBehaviour
{
	private static Material material;

	public void Set(Vector3 N, float phi0, float phi1, float theta0, float theta1, Vector3 uAxis, Vector3 uOrigin, float uScale, Vector3 vAxis, Vector3 vOrigin, float vScale)
	{
		if (material == null)
		{
			material = new Material(Shader.Find("Custom/SteamVR_SphericalProjection"));
		}
		material.SetVector("_N", new Vector4(N.x, N.y, N.z));
		material.SetFloat("_Phi0", phi0 * ((float)Math.PI / 180f));
		material.SetFloat("_Phi1", phi1 * ((float)Math.PI / 180f));
		material.SetFloat("_Theta0", theta0 * ((float)Math.PI / 180f) + (float)Math.PI / 2f);
		material.SetFloat("_Theta1", theta1 * ((float)Math.PI / 180f) + (float)Math.PI / 2f);
		material.SetVector("_UAxis", uAxis);
		material.SetVector("_VAxis", vAxis);
		material.SetVector("_UOrigin", uOrigin);
		material.SetVector("_VOrigin", vOrigin);
		material.SetFloat("_UScale", uScale);
		material.SetFloat("_VScale", vScale);
	}

	private void OnRenderImage(RenderTexture src, RenderTexture dest)
	{
		Graphics.Blit(src, dest, material);
	}
}
[ExecuteInEditMode]
public class SteamVR_Stats : MonoBehaviour
{
	private void Awake()
	{
		UnityEngine.Debug.Log("SteamVR_Stats is deprecated in Unity 2017.2 - REMOVING");
		UnityEngine.Object.DestroyImmediate(this);
	}
}
public class SteamVR_TestController : MonoBehaviour
{
	private List<int> controllerIndices = new List<int>();

	private EVRButtonId[] buttonIds = new EVRButtonId[4]
	{
		EVRButtonId.k_EButton_ApplicationMenu,
		EVRButtonId.k_EButton_Grip,
		EVRButtonId.k_EButton_Axis0,
		EVRButtonId.k_EButton_Axis1
	};

	private EVRButtonId[] axisIds = new EVRButtonId[2]
	{
		EVRButtonId.k_EButton_Axis0,
		EVRButtonId.k_EButton_Axis1
	};

	public Transform point;

	public Transform pointer;

	private void OnDeviceConnected(int index, bool connected)
	{
		CVRSystem system = OpenVR.System;
		if (system != null && system.GetTrackedDeviceClass((uint)index) == ETrackedDeviceClass.Controller)
		{
			if (connected)
			{
				UnityEngine.Debug.Log($"Controller {index} connected.");
				PrintControllerStatus(index);
				controllerIndices.Add(index);
			}
			else
			{
				UnityEngine.Debug.Log($"Controller {index} disconnected.");
				PrintControllerStatus(index);
				controllerIndices.Remove(index);
			}
		}
	}

	private void OnEnable()
	{
		SteamVR_Events.DeviceConnected.Listen(OnDeviceConnected);
	}

	private void OnDisable()
	{
		SteamVR_Events.DeviceConnected.Remove(OnDeviceConnected);
	}

	private void PrintControllerStatus(int index)
	{
		SteamVR_Controller.Device device = SteamVR_Controller.Input(index);
		UnityEngine.Debug.Log("index: " + device.index);
		UnityEngine.Debug.Log("connected: " + device.connected);
		UnityEngine.Debug.Log("hasTracking: " + device.hasTracking);
		UnityEngine.Debug.Log("outOfRange: " + device.outOfRange);
		UnityEngine.Debug.Log("calibrating: " + device.calibrating);
		UnityEngine.Debug.Log("uninitialized: " + device.uninitialized);
		UnityEngine.Debug.Log("pos: " + device.transform.pos);
		UnityEngine.Debug.Log("rot: " + device.transform.rot.eulerAngles);
		UnityEngine.Debug.Log("velocity: " + device.velocity);
		UnityEngine.Debug.Log("angularVelocity: " + device.angularVelocity);
		int deviceIndex = SteamVR_Controller.GetDeviceIndex(SteamVR_Controller.DeviceRelation.Leftmost);
		int deviceIndex2 = SteamVR_Controller.GetDeviceIndex(SteamVR_Controller.DeviceRelation.Rightmost);
		UnityEngine.Debug.Log((deviceIndex == deviceIndex2) ? "first" : ((deviceIndex == index) ? "left" : "right"));
	}

	private void Update()
	{
		foreach (int controllerIndex in controllerIndices)
		{
			SteamVR_Overlay instance = SteamVR_Overlay.instance;
			if ((bool)instance && (bool)point && (bool)pointer)
			{
				SteamVR_Utils.RigidTransform rigidTransform = SteamVR_Controller.Input(controllerIndex).transform;
				pointer.transform.localPosition = rigidTransform.pos;
				pointer.transform.localRotation = rigidTransform.rot;
				SteamVR_Overlay.IntersectionResults results = default(SteamVR_Overlay.IntersectionResults);
				if (instance.ComputeIntersection(rigidTransform.pos, rigidTransform.rot * Vector3.forward, ref results))
				{
					point.transform.localPosition = results.point;
					point.transform.localRotation = Quaternion.LookRotation(results.normal);
				}
				continue;
			}
			EVRButtonId[] array = buttonIds;
			foreach (EVRButtonId eVRButtonId in array)
			{
				if (SteamVR_Controller.Input(controllerIndex).GetPressDown(eVRButtonId))
				{
					UnityEngine.Debug.Log(string.Concat(eVRButtonId, " press down"));
				}
				if (SteamVR_Controller.Input(controllerIndex).GetPressUp(eVRButtonId))
				{
					UnityEngine.Debug.Log(string.Concat(eVRButtonId, " press up"));
					if (eVRButtonId == EVRButtonId.k_EButton_Axis1)
					{
						SteamVR_Controller.Input(controllerIndex).TriggerHapticPulse(500);
						PrintControllerStatus(controllerIndex);
					}
				}
				if (SteamVR_Controller.Input(controllerIndex).GetPress(eVRButtonId))
				{
					UnityEngine.Debug.Log(eVRButtonId);
				}
			}
			array = axisIds;
			foreach (EVRButtonId eVRButtonId2 in array)
			{
				if (SteamVR_Controller.Input(controllerIndex).GetTouchDown(eVRButtonId2))
				{
					UnityEngine.Debug.Log(string.Concat(eVRButtonId2, " touch down"));
				}
				if (SteamVR_Controller.Input(controllerIndex).GetTouchUp(eVRButtonId2))
				{
					UnityEngine.Debug.Log(string.Concat(eVRButtonId2, " touch up"));
				}
				if (SteamVR_Controller.Input(controllerIndex).GetTouch(eVRButtonId2))
				{
					Vector2 axis = SteamVR_Controller.Input(controllerIndex).GetAxis(eVRButtonId2);
					UnityEngine.Debug.Log("axis: " + axis);
				}
			}
		}
	}
}
public class SteamVR_TrackedCamera
{
	public class VideoStreamTexture
	{
		private Texture2D _texture;

		private int prevFrameCount = -1;

		private uint glTextureId;

		private VideoStream videostream;

		private CameraVideoStreamFrameHeader_t header;

		public bool undistorted { get; private set; }

		public uint deviceIndex => videostream.deviceIndex;

		public bool hasCamera => videostream.hasCamera;

		public bool hasTracking
		{
			get
			{
				Update();
				return header.standingTrackedDevicePose.bPoseIsValid;
			}
		}

		public uint frameId
		{
			get
			{
				Update();
				return header.nFrameSequence;
			}
		}

		public VRTextureBounds_t frameBounds { get; private set; }

		public EVRTrackedCameraFrameType frameType
		{
			get
			{
				if (!undistorted)
				{
					return EVRTrackedCameraFrameType.Distorted;
				}
				return EVRTrackedCameraFrameType.Undistorted;
			}
		}

		public Texture2D texture
		{
			get
			{
				Update();
				return _texture;
			}
		}

		public SteamVR_Utils.RigidTransform transform
		{
			get
			{
				Update();
				return new SteamVR_Utils.RigidTransform(header.standingTrackedDevicePose.mDeviceToAbsoluteTracking);
			}
		}

		public Vector3 velocity
		{
			get
			{
				Update();
				TrackedDevicePose_t standingTrackedDevicePose = header.standingTrackedDevicePose;
				return new Vector3(standingTrackedDevicePose.vVelocity.v0, standingTrackedDevicePose.vVelocity.v1, 0f - standingTrackedDevicePose.vVelocity.v2);
			}
		}

		public Vector3 angularVelocity
		{
			get
			{
				Update();
				TrackedDevicePose_t standingTrackedDevicePose = header.standingTrackedDevicePose;
				return new Vector3(0f - standingTrackedDevicePose.vAngularVelocity.v0, 0f - standingTrackedDevicePose.vAngularVelocity.v1, standingTrackedDevicePose.vAngularVelocity.v2);
			}
		}

		public VideoStreamTexture(uint deviceIndex, bool undistorted)
		{
			this.undistorted = undistorted;
			videostream = Stream(deviceIndex);
		}

		public TrackedDevicePose_t GetPose()
		{
			Update();
			return header.standingTrackedDevicePose;
		}

		public ulong Acquire()
		{
			return videostream.Acquire();
		}

		public ulong Release()
		{
			ulong result = videostream.Release();
			if (videostream.handle == 0L)
			{
				UnityEngine.Object.Destroy(_texture);
				_texture = null;
			}
			return result;
		}

		private void Update()
		{
			if (Time.frameCount == prevFrameCount)
			{
				return;
			}
			prevFrameCount = Time.frameCount;
			if (videostream.handle == 0L)
			{
				return;
			}
			SteamVR instance = SteamVR.instance;
			if (instance == null)
			{
				return;
			}
			CVRTrackedCamera trackedCamera = OpenVR.TrackedCamera;
			if (trackedCamera == null)
			{
				return;
			}
			IntPtr ppD3D11ShaderResourceView = IntPtr.Zero;
			Texture2D texture2D = ((_texture != null) ? _texture : new Texture2D(2, 2));
			uint nFrameHeaderSize = (uint)Marshal.SizeOf(header.GetType());
			if (instance.textureType == ETextureType.OpenGL)
			{
				if (glTextureId != 0)
				{
					trackedCamera.ReleaseVideoStreamTextureGL(videostream.handle, glTextureId);
				}
				if (trackedCamera.GetVideoStreamTextureGL(videostream.handle, frameType, ref glTextureId, ref header, nFrameHeaderSize) != 0)
				{
					return;
				}
				ppD3D11ShaderResourceView = (IntPtr)glTextureId;
			}
			else if (instance.textureType == ETextureType.DirectX && trackedCamera.GetVideoStreamTextureD3D11(videostream.handle, frameType, texture2D.GetNativeTexturePtr(), ref ppD3D11ShaderResourceView, ref header, nFrameHeaderSize) != 0)
			{
				return;
			}
			if (_texture == null)
			{
				_texture = Texture2D.CreateExternalTexture((int)header.nWidth, (int)header.nHeight, TextureFormat.RGBA32, mipChain: false, linear: false, ppD3D11ShaderResourceView);
				uint pnWidth = 0u;
				uint pnHeight = 0u;
				VRTextureBounds_t pTextureBounds = default(VRTextureBounds_t);
				if (trackedCamera.GetVideoStreamTextureSize(deviceIndex, frameType, ref pTextureBounds, ref pnWidth, ref pnHeight) == EVRTrackedCameraError.None)
				{
					pTextureBounds.vMin = 1f - pTextureBounds.vMin;
					pTextureBounds.vMax = 1f - pTextureBounds.vMax;
					frameBounds = pTextureBounds;
				}
			}
			else
			{
				_texture.UpdateExternalTexture(ppD3D11ShaderResourceView);
			}
		}
	}

	private class VideoStream
	{
		private ulong _handle;

		private bool _hasCamera;

		private ulong refCount;

		public uint deviceIndex { get; private set; }

		public ulong handle => _handle;

		public bool hasCamera => _hasCamera;

		public VideoStream(uint deviceIndex)
		{
			this.deviceIndex = deviceIndex;
			OpenVR.TrackedCamera?.HasCamera(deviceIndex, ref _hasCamera);
		}

		public ulong Acquire()
		{
			if (_handle == 0L && hasCamera)
			{
				OpenVR.TrackedCamera?.AcquireVideoStreamingService(deviceIndex, ref _handle);
			}
			return ++refCount;
		}

		public ulong Release()
		{
			if (refCount != 0 && --refCount == 0L && _handle != 0L)
			{
				OpenVR.TrackedCamera?.ReleaseVideoStreamingService(_handle);
				_handle = 0uL;
			}
			return refCount;
		}
	}

	private static VideoStreamTexture[] distorted;

	private static VideoStreamTexture[] undistorted;

	private static VideoStream[] videostreams;

	public static VideoStreamTexture Distorted(int deviceIndex = 0)
	{
		if (distorted == null)
		{
			distorted = new VideoStreamTexture[64];
		}
		if (distorted[deviceIndex] == null)
		{
			distorted[deviceIndex] = new VideoStreamTexture((uint)deviceIndex, undistorted: false);
		}
		return distorted[deviceIndex];
	}

	public static VideoStreamTexture Undistorted(int deviceIndex = 0)
	{
		if (undistorted == null)
		{
			undistorted = new VideoStreamTexture[64];
		}
		if (undistorted[deviceIndex] == null)
		{
			undistorted[deviceIndex] = new VideoStreamTexture((uint)deviceIndex, undistorted: true);
		}
		return undistorted[deviceIndex];
	}

	public static VideoStreamTexture Source(bool undistorted, int deviceIndex = 0)
	{
		if (!undistorted)
		{
			return Distorted(deviceIndex);
		}
		return Undistorted(deviceIndex);
	}

	private static VideoStream Stream(uint deviceIndex)
	{
		if (videostreams == null)
		{
			videostreams = new VideoStream[64];
		}
		if (videostreams[deviceIndex] == null)
		{
			videostreams[deviceIndex] = new VideoStream(deviceIndex);
		}
		return videostreams[deviceIndex];
	}
}
public class SteamVR_TrackedObject : MonoBehaviour
{
	public enum EIndex
	{
		None = -1,
		Hmd,
		Device1,
		Device2,
		Device3,
		Device4,
		Device5,
		Device6,
		Device7,
		Device8,
		Device9,
		Device10,
		Device11,
		Device12,
		Device13,
		Device14,
		Device15
	}

	public EIndex index;

	[Tooltip("If not set, relative to parent")]
	public Transform origin;

	private SteamVR_Events.Action newPosesAction;

	public bool isValid { get; private set; }

	private void OnNewPoses(TrackedDevicePose_t[] poses)
	{
		if (index == EIndex.None)
		{
			return;
		}
		int num = (int)index;
		isValid = false;
		if (poses.Length > num && poses[num].bDeviceIsConnected && poses[num].bPoseIsValid)
		{
			isValid = true;
			SteamVR_Utils.RigidTransform rigidTransform = new SteamVR_Utils.RigidTransform(poses[num].mDeviceToAbsoluteTracking);
			if (origin != null)
			{
				base.transform.position = origin.transform.TransformPoint(rigidTransform.pos);
				base.transform.rotation = origin.rotation * rigidTransform.rot;
			}
			else
			{
				base.transform.localPosition = rigidTransform.pos;
				base.transform.localRotation = rigidTransform.rot;
			}
		}
	}

	private SteamVR_TrackedObject()
	{
		newPosesAction = SteamVR_Events.NewPosesAction(OnNewPoses);
	}

	private void OnEnable()
	{
		if (SteamVR_Render.instance == null)
		{
			base.enabled = false;
		}
		else
		{
			newPosesAction.enabled = true;
		}
	}

	private void OnDisable()
	{
		newPosesAction.enabled = false;
		isValid = false;
	}

	public void SetDeviceIndex(int index)
	{
		if (Enum.IsDefined(typeof(EIndex), index))
		{
			this.index = (EIndex)index;
		}
	}
}
[ExecuteInEditMode]
public class SteamVR_UpdatePoses : MonoBehaviour
{
	private void Awake()
	{
		UnityEngine.Debug.Log("SteamVR_UpdatePoses has been deprecated - REMOVING");
		UnityEngine.Object.DestroyImmediate(this);
	}
}
public static class SteamVR_Utils
{
	[Serializable]
	public struct RigidTransform
	{
		public Vector3 pos;

		public Quaternion rot;

		public static RigidTransform identity => new RigidTransform(Vector3.zero, Quaternion.identity);

		public static RigidTransform FromLocal(Transform t)
		{
			return new RigidTransform(t.localPosition, t.localRotation);
		}

		public RigidTransform(Vector3 pos, Quaternion rot)
		{
			this.pos = pos;
			this.rot = rot;
		}

		public RigidTransform(Transform t)
		{
			pos = t.position;
			rot = t.rotation;
		}

		public RigidTransform(Transform from, Transform to)
		{
			Quaternion quaternion = Quaternion.Inverse(from.rotation);
			rot = quaternion * to.rotation;
			pos = quaternion * (to.position - from.position);
		}

		public RigidTransform(HmdMatrix34_t pose)
		{
			Matrix4x4 matrix = Matrix4x4.identity;
			matrix[0, 0] = pose.m0;
			matrix[0, 1] = pose.m1;
			matrix[0, 2] = 0f - pose.m2;
			matrix[0, 3] = pose.m3;
			matrix[1, 0] = pose.m4;
			matrix[1, 1] = pose.m5;
			matrix[1, 2] = 0f - pose.m6;
			matrix[1, 3] = pose.m7;
			matrix[2, 0] = 0f - pose.m8;
			matrix[2, 1] = 0f - pose.m9;
			matrix[2, 2] = pose.m10;
			matrix[2, 3] = 0f - pose.m11;
			pos = matrix.GetPosition();
			rot = matrix.GetRotation();
		}

		public RigidTransform(HmdMatrix44_t pose)
		{
			Matrix4x4 matrix = Matrix4x4.identity;
			matrix[0, 0] = pose.m0;
			matrix[0, 1] = pose.m1;
			matrix[0, 2] = 0f - pose.m2;
			matrix[0, 3] = pose.m3;
			matrix[1, 0] = pose.m4;
			matrix[1, 1] = pose.m5;
			matrix[1, 2] = 0f - pose.m6;
			matrix[1, 3] = pose.m7;
			matrix[2, 0] = 0f - pose.m8;
			matrix[2, 1] = 0f - pose.m9;
			matrix[2, 2] = pose.m10;
			matrix[2, 3] = 0f - pose.m11;
			matrix[3, 0] = pose.m12;
			matrix[3, 1] = pose.m13;
			matrix[3, 2] = 0f - pose.m14;
			matrix[3, 3] = pose.m15;
			pos = matrix.GetPosition();
			rot = matrix.GetRotation();
		}

		public HmdMatrix44_t ToHmdMatrix44()
		{
			Matrix4x4 matrix4x = Matrix4x4.TRS(pos, rot, Vector3.one);
			HmdMatrix44_t result = default(HmdMatrix44_t);
			result.m0 = matrix4x[0, 0];
			result.m1 = matrix4x[0, 1];
			result.m2 = 0f - matrix4x[0, 2];
			result.m3 = matrix4x[0, 3];
			result.m4 = matrix4x[1, 0];
			result.m5 = matrix4x[1, 1];
			result.m6 = 0f - matrix4x[1, 2];
			result.m7 = matrix4x[1, 3];
			result.m8 = 0f - matrix4x[2, 0];
			result.m9 = 0f - matrix4x[2, 1];
			result.m10 = matrix4x[2, 2];
			result.m11 = 0f - matrix4x[2, 3];
			result.m12 = matrix4x[3, 0];
			result.m13 = matrix4x[3, 1];
			result.m14 = 0f - matrix4x[3, 2];
			result.m15 = matrix4x[3, 3];
			return result;
		}

		public HmdMatrix34_t ToHmdMatrix34()
		{
			Matrix4x4 matrix4x = Matrix4x4.TRS(pos, rot, Vector3.one);
			HmdMatrix34_t result = default(HmdMatrix34_t);
			result.m0 = matrix4x[0, 0];
			result.m1 = matrix4x[0, 1];
			result.m2 = 0f - matrix4x[0, 2];
			result.m3 = matrix4x[0, 3];
			result.m4 = matrix4x[1, 0];
			result.m5 = matrix4x[1, 1];
			result.m6 = 0f - matrix4x[1, 2];
			result.m7 = matrix4x[1, 3];
			result.m8 = 0f - matrix4x[2, 0];
			result.m9 = 0f - matrix4x[2, 1];
			result.m10 = matrix4x[2, 2];
			result.m11 = 0f - matrix4x[2, 3];
			return result;
		}

		public override bool Equals(object o)
		{
			if (o is RigidTransform rigidTransform)
			{
				if (pos == rigidTransform.pos)
				{
					return rot == rigidTransform.rot;
				}
				return false;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return pos.GetHashCode() ^ rot.GetHashCode();
		}

		public static bool operator ==(RigidTransform a, RigidTransform b)
		{
			if (a.pos == b.pos)
			{
				return a.rot == b.rot;
			}
			return false;
		}

		public static bool operator !=(RigidTransform a, RigidTransform b)
		{
			if (!(a.pos != b.pos))
			{
				return a.rot != b.rot;
			}
			return true;
		}

		public static RigidTransform operator *(RigidTransform a, RigidTransform b)
		{
			RigidTransform result = default(RigidTransform);
			result.rot = a.rot * b.rot;
			result.pos = a.pos + a.rot * b.pos;
			return result;
		}

		public void Inverse()
		{
			rot = Quaternion.Inverse(rot);
			pos = -(rot * pos);
		}

		public RigidTransform GetInverse()
		{
			RigidTransform result = new RigidTransform(pos, rot);
			result.Inverse();
			return result;
		}

		public void Multiply(RigidTransform a, RigidTransform b)
		{
			rot = a.rot * b.rot;
			pos = a.pos + a.rot * b.pos;
		}

		public Vector3 InverseTransformPoint(Vector3 point)
		{
			return Quaternion.Inverse(rot) * (point - pos);
		}

		public Vector3 TransformPoint(Vector3 point)
		{
			return pos + rot * point;
		}

		public static Vector3 operator *(RigidTransform t, Vector3 v)
		{
			return t.TransformPoint(v);
		}

		public static RigidTransform Interpolate(RigidTransform a, RigidTransform b, float t)
		{
			return new RigidTransform(Vector3.Lerp(a.pos, b.pos, t), Quaternion.Slerp(a.rot, b.rot, t));
		}

		public void Interpolate(RigidTransform to, float t)
		{
			pos = Lerp(pos, to.pos, t);
			rot = Slerp(rot, to.rot, t);
		}
	}

	public delegate object SystemFn(CVRSystem system, params object[] args);

	public static Quaternion Slerp(Quaternion A, Quaternion B, float t)
	{
		float num = Mathf.Clamp(A.x * B.x + A.y * B.y + A.z * B.z + A.w * B.w, -1f, 1f);
		if (num < 0f)
		{
			B = new Quaternion(0f - B.x, 0f - B.y, 0f - B.z, 0f - B.w);
			num = 0f - num;
		}
		float num4;
		float num5;
		if (1f - num > 0.0001f)
		{
			float num2 = Mathf.Acos(num);
			float num3 = Mathf.Sin(num2);
			num4 = Mathf.Sin((1f - t) * num2) / num3;
			num5 = Mathf.Sin(t * num2) / num3;
		}
		else
		{
			num4 = 1f - t;
			num5 = t;
		}
		return new Quaternion(num4 * A.x + num5 * B.x, num4 * A.y + num5 * B.y, num4 * A.z + num5 * B.z, num4 * A.w + num5 * B.w);
	}

	public static Vector3 Lerp(Vector3 A, Vector3 B, float t)
	{
		return new Vector3(Lerp(A.x, B.x, t), Lerp(A.y, B.y, t), Lerp(A.z, B.z, t));
	}

	public static float Lerp(float A, float B, float t)
	{
		return A + (B - A) * t;
	}

	public static double Lerp(double A, double B, double t)
	{
		return A + (B - A) * t;
	}

	public static float InverseLerp(Vector3 A, Vector3 B, Vector3 result)
	{
		return Vector3.Dot(result - A, B - A);
	}

	public static float InverseLerp(float A, float B, float result)
	{
		return (result - A) / (B - A);
	}

	public static double InverseLerp(double A, double B, double result)
	{
		return (result - A) / (B - A);
	}

	public static float Saturate(float A)
	{
		if (!(A < 0f))
		{
			if (!(A > 1f))
			{
				return A;
			}
			return 1f;
		}
		return 0f;
	}

	public static Vector2 Saturate(Vector2 A)
	{
		return new Vector2(Saturate(A.x), Saturate(A.y));
	}

	public static float Abs(float A)
	{
		if (!(A < 0f))
		{
			return A;
		}
		return 0f - A;
	}

	public static Vector2 Abs(Vector2 A)
	{
		return new Vector2(Abs(A.x), Abs(A.y));
	}

	private static float _copysign(float sizeval, float signval)
	{
		if (Mathf.Sign(signval) != 1f)
		{
			return 0f - Mathf.Abs(sizeval);
		}
		return Mathf.Abs(sizeval);
	}

	public static Quaternion GetRotation(this Matrix4x4 matrix)
	{
		Quaternion result = default(Quaternion);
		result.w = Mathf.Sqrt(Mathf.Max(0f, 1f + matrix.m00 + matrix.m11 + matrix.m22)) / 2f;
		result.x = Mathf.Sqrt(Mathf.Max(0f, 1f + matrix.m00 - matrix.m11 - matrix.m22)) / 2f;
		result.y = Mathf.Sqrt(Mathf.Max(0f, 1f - matrix.m00 + matrix.m11 - matrix.m22)) / 2f;
		result.z = Mathf.Sqrt(Mathf.Max(0f, 1f - matrix.m00 - matrix.m11 + matrix.m22)) / 2f;
		result.x = _copysign(result.x, matrix.m21 - matrix.m12);
		result.y = _copysign(result.y, matrix.m02 - matrix.m20);
		result.z = _copysign(result.z, matrix.m10 - matrix.m01);
		return result;
	}

	public static Vector3 GetPosition(this Matrix4x4 matrix)
	{
		float m = matrix.m03;
		float m2 = matrix.m13;
		float m3 = matrix.m23;
		return new Vector3(m, m2, m3);
	}

	public static Vector3 GetScale(this Matrix4x4 m)
	{
		float x = Mathf.Sqrt(m.m00 * m.m00 + m.m01 * m.m01 + m.m02 * m.m02);
		float y = Mathf.Sqrt(m.m10 * m.m10 + m.m11 * m.m11 + m.m12 * m.m12);
		float z = Mathf.Sqrt(m.m20 * m.m20 + m.m21 * m.m21 + m.m22 * m.m22);
		return new Vector3(x, y, z);
	}

	public static object CallSystemFn(SystemFn fn, params object[] args)
	{
		bool flag = !SteamVR.active && !SteamVR.usingNativeSupport;
		if (flag)
		{
			EVRInitError peError = EVRInitError.None;
			OpenVR.Init(ref peError, EVRApplicationType.VRApplication_Utility);
		}
		CVRSystem system = OpenVR.System;
		object result = ((system != null) ? fn(system, args) : null);
		if (flag)
		{
			OpenVR.Shutdown();
		}
		return result;
	}

	public static void TakeStereoScreenshot(uint screenshotHandle, GameObject target, int cellSize, float ipd, ref string previewFilename, ref string VRFilename)
	{
		Texture2D texture2D = new Texture2D(4096, 4096, TextureFormat.ARGB32, mipChain: false);
		Stopwatch stopwatch = new Stopwatch();
		Camera camera = null;
		stopwatch.Start();
		Camera camera2 = target.GetComponent<Camera>();
		if (camera2 == null)
		{
			if (camera == null)
			{
				camera = new GameObject().AddComponent<Camera>();
			}
			camera2 = camera;
		}
		Texture2D texture2D2 = new Texture2D(2048, 2048, TextureFormat.ARGB32, mipChain: false);
		RenderTexture renderTexture = new RenderTexture(2048, 2048, 24);
		RenderTexture targetTexture = camera2.targetTexture;
		bool orthographic = camera2.orthographic;
		float fieldOfView = camera2.fieldOfView;
		float aspect = camera2.aspect;
		StereoTargetEyeMask stereoTargetEye = camera2.stereoTargetEye;
		camera2.stereoTargetEye = StereoTargetEyeMask.None;
		camera2.fieldOfView = 60f;
		camera2.orthographic = false;
		camera2.targetTexture = renderTexture;
		camera2.aspect = 1f;
		camera2.Render();
		RenderTexture.active = renderTexture;
		texture2D2.ReadPixels(new Rect(0f, 0f, renderTexture.width, renderTexture.height), 0, 0);
		RenderTexture.active = null;
		camera2.targetTexture = null;
		UnityEngine.Object.DestroyImmediate(renderTexture);
		SteamVR_SphericalProjection steamVR_SphericalProjection = camera2.gameObject.AddComponent<SteamVR_SphericalProjection>();
		Vector3 localPosition = target.transform.localPosition;
		Quaternion localRotation = target.transform.localRotation;
		Vector3 position = target.transform.position;
		Quaternion quaternion = Quaternion.Euler(0f, target.transform.rotation.eulerAngles.y, 0f);
		Transform transform = camera2.transform;
		int num = 1024 / cellSize;
		float num2 = 90f / (float)num;
		float num3 = num2 / 2f;
		RenderTexture renderTexture2 = new RenderTexture(cellSize, cellSize, 24);
		renderTexture2.wrapMode = TextureWrapMode.Clamp;
		renderTexture2.antiAliasing = 8;
		camera2.fieldOfView = num2;
		camera2.orthographic = false;
		camera2.targetTexture = renderTexture2;
		camera2.aspect = aspect;
		camera2.stereoTargetEye = StereoTargetEyeMask.None;
		for (int i = 0; i < num; i++)
		{
			float num4 = 90f - (float)i * num2 - num3;
			int num5 = 4096 / renderTexture2.width;
			float num6 = 360f / (float)num5;
			float num7 = num6 / 2f;
			int num8 = i * 1024 / num;
			for (int j = 0; j < 2; j++)
			{
				if (j == 1)
				{
					num4 = 0f - num4;
					num8 = 2048 - num8 - cellSize;
				}
				for (int k = 0; k < num5; k++)
				{
					float num9 = -180f + (float)k * num6 + num7;
					int destX = k * 4096 / num5;
					int num10 = 0;
					float num11 = (0f - ipd) / 2f * Mathf.Cos(num4 * ((float)Math.PI / 180f));
					for (int l = 0; l < 2; l++)
					{
						if (l == 1)
						{
							num10 = 2048;
							num11 = 0f - num11;
						}
						Vector3 vector = quaternion * Quaternion.Euler(0f, num9, 0f) * new Vector3(num11, 0f, 0f);
						transform.position = position + vector;
						Quaternion quaternion2 = Quaternion.Euler(num4, num9, 0f);
						transform.rotation = quaternion * quaternion2;
						Vector3 vector2 = quaternion2 * Vector3.forward;
						float num12 = num9 - num6 / 2f;
						float num13 = num12 + num6;
						float num14 = num4 + num2 / 2f;
						float num15 = num14 - num2;
						float y = (num12 + num13) / 2f;
						float x = ((Mathf.Abs(num14) < Mathf.Abs(num15)) ? num14 : num15);
						Vector3 vector3 = Quaternion.Euler(x, num12, 0f) * Vector3.forward;
						Vector3 vector4 = Quaternion.Euler(x, num13, 0f) * Vector3.forward;
						Vector3 vector5 = Quaternion.Euler(num14, y, 0f) * Vector3.forward;
						Vector3 vector6 = Quaternion.Euler(num15, y, 0f) * Vector3.forward;
						Vector3 vector7 = vector3 / Vector3.Dot(vector3, vector2);
						Vector3 vector8 = vector4 / Vector3.Dot(vector4, vector2);
						Vector3 vector9 = vector5 / Vector3.Dot(vector5, vector2);
						Vector3 vector10 = vector6 / Vector3.Dot(vector6, vector2);
						Vector3 vector11 = vector8 - vector7;
						Vector3 vector12 = vector10 - vector9;
						float magnitude = vector11.magnitude;
						float magnitude2 = vector12.magnitude;
						float num16 = 1f / magnitude;
						float num17 = 1f / magnitude2;
						Vector3 uAxis = vector11 * num16;
						Vector3 vAxis = vector12 * num17;
						steamVR_SphericalProjection.Set(vector2, num12, num13, num14, num15, uAxis, vector7, num16, vAxis, vector9, num17);
						camera2.aspect = magnitude / magnitude2;
						camera2.Render();
						RenderTexture.active = renderTexture2;
						texture2D.ReadPixels(new Rect(0f, 0f, renderTexture2.width, renderTexture2.height), destX, num8 + num10);
						RenderTexture.active = null;
					}
					float flProgress = ((float)i * ((float)num5 * 2f) + (float)k + (float)(j * num5)) / ((float)num * ((float)num5 * 2f));
					OpenVR.Screenshots.UpdateScreenshotProgress(screenshotHandle, flProgress);
				}
			}
		}
		OpenVR.Screenshots.UpdateScreenshotProgress(screenshotHandle, 1f);
		previewFilename += ".png";
		VRFilename += ".png";
		texture2D2.Apply();
		File.WriteAllBytes(previewFilename, texture2D2.EncodeToPNG());
		texture2D.Apply();
		File.WriteAllBytes(VRFilename, texture2D.EncodeToPNG());
		if (camera2 != camera)
		{
			camera2.targetTexture = targetTexture;
			camera2.orthographic = orthographic;
			camera2.fieldOfView = fieldOfView;
			camera2.aspect = aspect;
			camera2.stereoTargetEye = stereoTargetEye;
			target.transform.localPosition = localPosition;
			target.transform.localRotation = localRotation;
		}
		else
		{
			camera.targetTexture = null;
		}
		UnityEngine.Object.DestroyImmediate(renderTexture2);
		UnityEngine.Object.DestroyImmediate(steamVR_SphericalProjection);
		stopwatch.Stop();
		UnityEngine.Debug.Log($"Screenshot took {stopwatch.Elapsed} seconds.");
		if (camera != null)
		{
			UnityEngine.Object.DestroyImmediate(camera.gameObject);
		}
		UnityEngine.Object.DestroyImmediate(texture2D2);
		UnityEngine.Object.DestroyImmediate(texture2D);
	}
}
namespace Valve.VR
{
	public struct IVRSystem
	{
		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _GetRecommendedRenderTargetSize(ref uint pnWidth, ref uint pnHeight);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate HmdMatrix44_t _GetProjectionMatrix(EVREye eEye, float fNearZ, float fFarZ);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _GetProjectionRaw(EVREye eEye, ref float pfLeft, ref float pfRight, ref float pfTop, ref float pfBottom);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _ComputeDistortion(EVREye eEye, float fU, float fV, ref DistortionCoordinates_t pDistortionCoordinates);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate HmdMatrix34_t _GetEyeToHeadTransform(EVREye eEye);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _GetTimeSinceLastVsync(ref float pfSecondsSinceLastVsync, ref ulong pulFrameCounter);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate int _GetD3D9AdapterIndex();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _GetDXGIOutputInfo(ref int pnAdapterIndex);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _GetOutputDevice(ref ulong pnDevice, ETextureType textureType, IntPtr pInstance);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _IsDisplayOnDesktop();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _SetDisplayVisibility(bool bIsVisibleOnDesktop);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _GetDeviceToAbsoluteTrackingPose(ETrackingUniverseOrigin eOrigin, float fPredictedSecondsToPhotonsFromNow, [In][Out] TrackedDevicePose_t[] pTrackedDevicePoseArray, uint unTrackedDevicePoseArrayCount);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _ResetSeatedZeroPose();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate HmdMatrix34_t _GetSeatedZeroPoseToStandingAbsoluteTrackingPose();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate HmdMatrix34_t _GetRawZeroPoseToStandingAbsoluteTrackingPose();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetSortedTrackedDeviceIndicesOfClass(ETrackedDeviceClass eTrackedDeviceClass, [In][Out] uint[] punTrackedDeviceIndexArray, uint unTrackedDeviceIndexArrayCount, uint unRelativeToTrackedDeviceIndex);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EDeviceActivityLevel _GetTrackedDeviceActivityLevel(uint unDeviceId);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _ApplyTransform(ref TrackedDevicePose_t pOutputPose, ref TrackedDevicePose_t pTrackedDevicePose, ref HmdMatrix34_t pTransform);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetTrackedDeviceIndexForControllerRole(ETrackedControllerRole unDeviceType);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate ETrackedControllerRole _GetControllerRoleForTrackedDeviceIndex(uint unDeviceIndex);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate ETrackedDeviceClass _GetTrackedDeviceClass(uint unDeviceIndex);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _IsTrackedDeviceConnected(uint unDeviceIndex);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _GetBoolTrackedDeviceProperty(uint unDeviceIndex, ETrackedDeviceProperty prop, ref ETrackedPropertyError pError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate float _GetFloatTrackedDeviceProperty(uint unDeviceIndex, ETrackedDeviceProperty prop, ref ETrackedPropertyError pError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate int _GetInt32TrackedDeviceProperty(uint unDeviceIndex, ETrackedDeviceProperty prop, ref ETrackedPropertyError pError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate ulong _GetUint64TrackedDeviceProperty(uint unDeviceIndex, ETrackedDeviceProperty prop, ref ETrackedPropertyError pError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate HmdMatrix34_t _GetMatrix34TrackedDeviceProperty(uint unDeviceIndex, ETrackedDeviceProperty prop, ref ETrackedPropertyError pError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetArrayTrackedDeviceProperty(uint unDeviceIndex, ETrackedDeviceProperty prop, uint propType, IntPtr pBuffer, uint unBufferSize, ref ETrackedPropertyError pError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetStringTrackedDeviceProperty(uint unDeviceIndex, ETrackedDeviceProperty prop, StringBuilder pchValue, uint unBufferSize, ref ETrackedPropertyError pError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate IntPtr _GetPropErrorNameFromEnum(ETrackedPropertyError error);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _PollNextEvent(ref VREvent_t pEvent, uint uncbVREvent);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _PollNextEventWithPose(ETrackingUniverseOrigin eOrigin, ref VREvent_t pEvent, uint uncbVREvent, ref TrackedDevicePose_t pTrackedDevicePose);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate IntPtr _GetEventTypeNameFromEnum(EVREventType eType);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate HiddenAreaMesh_t _GetHiddenAreaMesh(EVREye eEye, EHiddenAreaMeshType type);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _GetControllerState(uint unControllerDeviceIndex, ref VRControllerState_t pControllerState, uint unControllerStateSize);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _GetControllerStateWithPose(ETrackingUniverseOrigin eOrigin, uint unControllerDeviceIndex, ref VRControllerState_t pControllerState, uint unControllerStateSize, ref TrackedDevicePose_t pTrackedDevicePose);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _TriggerHapticPulse(uint unControllerDeviceIndex, uint unAxisId, char usDurationMicroSec);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate IntPtr _GetButtonIdNameFromEnum(EVRButtonId eButtonId);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate IntPtr _GetControllerAxisTypeNameFromEnum(EVRControllerAxisType eAxisType);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _IsInputAvailable();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _IsSteamVRDrawingControllers();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _ShouldApplicationPause();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _ShouldApplicationReduceRenderingWork();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _DriverDebugRequest(uint unDeviceIndex, string pchRequest, StringBuilder pchResponseBuffer, uint unResponseBufferSize);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRFirmwareError _PerformFirmwareUpdate(uint unDeviceIndex);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _AcknowledgeQuit_Exiting();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _AcknowledgeQuit_UserPrompt();

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetRecommendedRenderTargetSize GetRecommendedRenderTargetSize;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetProjectionMatrix GetProjectionMatrix;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetProjectionRaw GetProjectionRaw;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ComputeDistortion ComputeDistortion;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetEyeToHeadTransform GetEyeToHeadTransform;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetTimeSinceLastVsync GetTimeSinceLastVsync;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetD3D9AdapterIndex GetD3D9AdapterIndex;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetDXGIOutputInfo GetDXGIOutputInfo;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOutputDevice GetOutputDevice;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _IsDisplayOnDesktop IsDisplayOnDesktop;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetDisplayVisibility SetDisplayVisibility;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetDeviceToAbsoluteTrackingPose GetDeviceToAbsoluteTrackingPose;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ResetSeatedZeroPose ResetSeatedZeroPose;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetSeatedZeroPoseToStandingAbsoluteTrackingPose GetSeatedZeroPoseToStandingAbsoluteTrackingPose;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetRawZeroPoseToStandingAbsoluteTrackingPose GetRawZeroPoseToStandingAbsoluteTrackingPose;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetSortedTrackedDeviceIndicesOfClass GetSortedTrackedDeviceIndicesOfClass;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetTrackedDeviceActivityLevel GetTrackedDeviceActivityLevel;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ApplyTransform ApplyTransform;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetTrackedDeviceIndexForControllerRole GetTrackedDeviceIndexForControllerRole;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetControllerRoleForTrackedDeviceIndex GetControllerRoleForTrackedDeviceIndex;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetTrackedDeviceClass GetTrackedDeviceClass;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _IsTrackedDeviceConnected IsTrackedDeviceConnected;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetBoolTrackedDeviceProperty GetBoolTrackedDeviceProperty;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetFloatTrackedDeviceProperty GetFloatTrackedDeviceProperty;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetInt32TrackedDeviceProperty GetInt32TrackedDeviceProperty;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetUint64TrackedDeviceProperty GetUint64TrackedDeviceProperty;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetMatrix34TrackedDeviceProperty GetMatrix34TrackedDeviceProperty;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetArrayTrackedDeviceProperty GetArrayTrackedDeviceProperty;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetStringTrackedDeviceProperty GetStringTrackedDeviceProperty;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetPropErrorNameFromEnum GetPropErrorNameFromEnum;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _PollNextEvent PollNextEvent;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _PollNextEventWithPose PollNextEventWithPose;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetEventTypeNameFromEnum GetEventTypeNameFromEnum;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetHiddenAreaMesh GetHiddenAreaMesh;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetControllerState GetControllerState;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetControllerStateWithPose GetControllerStateWithPose;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _TriggerHapticPulse TriggerHapticPulse;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetButtonIdNameFromEnum GetButtonIdNameFromEnum;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetControllerAxisTypeNameFromEnum GetControllerAxisTypeNameFromEnum;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _IsInputAvailable IsInputAvailable;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _IsSteamVRDrawingControllers IsSteamVRDrawingControllers;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ShouldApplicationPause ShouldApplicationPause;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ShouldApplicationReduceRenderingWork ShouldApplicationReduceRenderingWork;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _DriverDebugRequest DriverDebugRequest;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _PerformFirmwareUpdate PerformFirmwareUpdate;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _AcknowledgeQuit_Exiting AcknowledgeQuit_Exiting;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _AcknowledgeQuit_UserPrompt AcknowledgeQuit_UserPrompt;
	}
	public struct IVRExtendedDisplay
	{
		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _GetWindowBounds(ref int pnX, ref int pnY, ref uint pnWidth, ref uint pnHeight);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _GetEyeOutputViewport(EVREye eEye, ref uint pnX, ref uint pnY, ref uint pnWidth, ref uint pnHeight);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _GetDXGIOutputInfo(ref int pnAdapterIndex, ref int pnAdapterOutputIndex);

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetWindowBounds GetWindowBounds;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetEyeOutputViewport GetEyeOutputViewport;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetDXGIOutputInfo GetDXGIOutputInfo;
	}
	public struct IVRTrackedCamera
	{
		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate IntPtr _GetCameraErrorNameFromEnum(EVRTrackedCameraError eCameraError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRTrackedCameraError _HasCamera(uint nDeviceIndex, ref bool pHasCamera);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRTrackedCameraError _GetCameraFrameSize(uint nDeviceIndex, EVRTrackedCameraFrameType eFrameType, ref uint pnWidth, ref uint pnHeight, ref uint pnFrameBufferSize);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRTrackedCameraError _GetCameraIntrinsics(uint nDeviceIndex, EVRTrackedCameraFrameType eFrameType, ref HmdVector2_t pFocalLength, ref HmdVector2_t pCenter);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRTrackedCameraError _GetCameraProjection(uint nDeviceIndex, EVRTrackedCameraFrameType eFrameType, float flZNear, float flZFar, ref HmdMatrix44_t pProjection);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRTrackedCameraError _AcquireVideoStreamingService(uint nDeviceIndex, ref ulong pHandle);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRTrackedCameraError _ReleaseVideoStreamingService(ulong hTrackedCamera);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRTrackedCameraError _GetVideoStreamFrameBuffer(ulong hTrackedCamera, EVRTrackedCameraFrameType eFrameType, IntPtr pFrameBuffer, uint nFrameBufferSize, ref CameraVideoStreamFrameHeader_t pFrameHeader, uint nFrameHeaderSize);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRTrackedCameraError _GetVideoStreamTextureSize(uint nDeviceIndex, EVRTrackedCameraFrameType eFrameType, ref VRTextureBounds_t pTextureBounds, ref uint pnWidth, ref uint pnHeight);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRTrackedCameraError _GetVideoStreamTextureD3D11(ulong hTrackedCamera, EVRTrackedCameraFrameType eFrameType, IntPtr pD3D11DeviceOrResource, ref IntPtr ppD3D11ShaderResourceView, ref CameraVideoStreamFrameHeader_t pFrameHeader, uint nFrameHeaderSize);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRTrackedCameraError _GetVideoStreamTextureGL(ulong hTrackedCamera, EVRTrackedCameraFrameType eFrameType, ref uint pglTextureId, ref CameraVideoStreamFrameHeader_t pFrameHeader, uint nFrameHeaderSize);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRTrackedCameraError _ReleaseVideoStreamTextureGL(ulong hTrackedCamera, uint glTextureId);

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetCameraErrorNameFromEnum GetCameraErrorNameFromEnum;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _HasCamera HasCamera;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetCameraFrameSize GetCameraFrameSize;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetCameraIntrinsics GetCameraIntrinsics;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetCameraProjection GetCameraProjection;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _AcquireVideoStreamingService AcquireVideoStreamingService;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ReleaseVideoStreamingService ReleaseVideoStreamingService;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetVideoStreamFrameBuffer GetVideoStreamFrameBuffer;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetVideoStreamTextureSize GetVideoStreamTextureSize;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetVideoStreamTextureD3D11 GetVideoStreamTextureD3D11;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetVideoStreamTextureGL GetVideoStreamTextureGL;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ReleaseVideoStreamTextureGL ReleaseVideoStreamTextureGL;
	}
	public struct IVRApplications
	{
		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRApplicationError _AddApplicationManifest(string pchApplicationManifestFullPath, bool bTemporary);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRApplicationError _RemoveApplicationManifest(string pchApplicationManifestFullPath);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _IsApplicationInstalled(string pchAppKey);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetApplicationCount();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRApplicationError _GetApplicationKeyByIndex(uint unApplicationIndex, StringBuilder pchAppKeyBuffer, uint unAppKeyBufferLen);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRApplicationError _GetApplicationKeyByProcessId(uint unProcessId, StringBuilder pchAppKeyBuffer, uint unAppKeyBufferLen);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRApplicationError _LaunchApplication(string pchAppKey);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRApplicationError _LaunchTemplateApplication(string pchTemplateAppKey, string pchNewAppKey, [In][Out] AppOverrideKeys_t[] pKeys, uint unKeys);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRApplicationError _LaunchApplicationFromMimeType(string pchMimeType, string pchArgs);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRApplicationError _LaunchDashboardOverlay(string pchAppKey);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _CancelApplicationLaunch(string pchAppKey);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRApplicationError _IdentifyApplication(uint unProcessId, string pchAppKey);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetApplicationProcessId(string pchAppKey);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate IntPtr _GetApplicationsErrorNameFromEnum(EVRApplicationError error);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetApplicationPropertyString(string pchAppKey, EVRApplicationProperty eProperty, StringBuilder pchPropertyValueBuffer, uint unPropertyValueBufferLen, ref EVRApplicationError peError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _GetApplicationPropertyBool(string pchAppKey, EVRApplicationProperty eProperty, ref EVRApplicationError peError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate ulong _GetApplicationPropertyUint64(string pchAppKey, EVRApplicationProperty eProperty, ref EVRApplicationError peError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRApplicationError _SetApplicationAutoLaunch(string pchAppKey, bool bAutoLaunch);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _GetApplicationAutoLaunch(string pchAppKey);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRApplicationError _SetDefaultApplicationForMimeType(string pchAppKey, string pchMimeType);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _GetDefaultApplicationForMimeType(string pchMimeType, StringBuilder pchAppKeyBuffer, uint unAppKeyBufferLen);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _GetApplicationSupportedMimeTypes(string pchAppKey, StringBuilder pchMimeTypesBuffer, uint unMimeTypesBuffer);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetApplicationsThatSupportMimeType(string pchMimeType, StringBuilder pchAppKeysThatSupportBuffer, uint unAppKeysThatSupportBuffer);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetApplicationLaunchArguments(uint unHandle, StringBuilder pchArgs, uint unArgs);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRApplicationError _GetStartingApplication(StringBuilder pchAppKeyBuffer, uint unAppKeyBufferLen);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRApplicationTransitionState _GetTransitionState();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRApplicationError _PerformApplicationPrelaunchCheck(string pchAppKey);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate IntPtr _GetApplicationsTransitionStateNameFromEnum(EVRApplicationTransitionState state);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _IsQuitUserPromptRequested();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRApplicationError _LaunchInternalProcess(string pchBinaryPath, string pchArguments, string pchWorkingDirectory);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetCurrentSceneProcessId();

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _AddApplicationManifest AddApplicationManifest;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _RemoveApplicationManifest RemoveApplicationManifest;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _IsApplicationInstalled IsApplicationInstalled;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetApplicationCount GetApplicationCount;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetApplicationKeyByIndex GetApplicationKeyByIndex;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetApplicationKeyByProcessId GetApplicationKeyByProcessId;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _LaunchApplication LaunchApplication;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _LaunchTemplateApplication LaunchTemplateApplication;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _LaunchApplicationFromMimeType LaunchApplicationFromMimeType;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _LaunchDashboardOverlay LaunchDashboardOverlay;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _CancelApplicationLaunch CancelApplicationLaunch;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _IdentifyApplication IdentifyApplication;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetApplicationProcessId GetApplicationProcessId;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetApplicationsErrorNameFromEnum GetApplicationsErrorNameFromEnum;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetApplicationPropertyString GetApplicationPropertyString;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetApplicationPropertyBool GetApplicationPropertyBool;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetApplicationPropertyUint64 GetApplicationPropertyUint64;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetApplicationAutoLaunch SetApplicationAutoLaunch;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetApplicationAutoLaunch GetApplicationAutoLaunch;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetDefaultApplicationForMimeType SetDefaultApplicationForMimeType;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetDefaultApplicationForMimeType GetDefaultApplicationForMimeType;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetApplicationSupportedMimeTypes GetApplicationSupportedMimeTypes;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetApplicationsThatSupportMimeType GetApplicationsThatSupportMimeType;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetApplicationLaunchArguments GetApplicationLaunchArguments;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetStartingApplication GetStartingApplication;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetTransitionState GetTransitionState;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _PerformApplicationPrelaunchCheck PerformApplicationPrelaunchCheck;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetApplicationsTransitionStateNameFromEnum GetApplicationsTransitionStateNameFromEnum;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _IsQuitUserPromptRequested IsQuitUserPromptRequested;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _LaunchInternalProcess LaunchInternalProcess;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetCurrentSceneProcessId GetCurrentSceneProcessId;
	}
	public struct IVRChaperone
	{
		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate ChaperoneCalibrationState _GetCalibrationState();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _GetPlayAreaSize(ref float pSizeX, ref float pSizeZ);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _GetPlayAreaRect(ref HmdQuad_t rect);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _ReloadInfo();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _SetSceneColor(HmdColor_t color);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _GetBoundsColor(ref HmdColor_t pOutputColorArray, int nNumOutputColors, float flCollisionBoundsFadeDistance, ref HmdColor_t pOutputCameraColor);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _AreBoundsVisible();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _ForceBoundsVisible(bool bForce);

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetCalibrationState GetCalibrationState;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetPlayAreaSize GetPlayAreaSize;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetPlayAreaRect GetPlayAreaRect;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ReloadInfo ReloadInfo;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetSceneColor SetSceneColor;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetBoundsColor GetBoundsColor;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _AreBoundsVisible AreBoundsVisible;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ForceBoundsVisible ForceBoundsVisible;
	}
	public struct IVRChaperoneSetup
	{
		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _CommitWorkingCopy(EChaperoneConfigFile configFile);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _RevertWorkingCopy();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _GetWorkingPlayAreaSize(ref float pSizeX, ref float pSizeZ);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _GetWorkingPlayAreaRect(ref HmdQuad_t rect);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _GetWorkingCollisionBoundsInfo([In][Out] HmdQuad_t[] pQuadsBuffer, ref uint punQuadsCount);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _GetLiveCollisionBoundsInfo([In][Out] HmdQuad_t[] pQuadsBuffer, ref uint punQuadsCount);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _GetWorkingSeatedZeroPoseToRawTrackingPose(ref HmdMatrix34_t pmatSeatedZeroPoseToRawTrackingPose);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _GetWorkingStandingZeroPoseToRawTrackingPose(ref HmdMatrix34_t pmatStandingZeroPoseToRawTrackingPose);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _SetWorkingPlayAreaSize(float sizeX, float sizeZ);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _SetWorkingCollisionBoundsInfo([In][Out] HmdQuad_t[] pQuadsBuffer, uint unQuadsCount);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _SetWorkingSeatedZeroPoseToRawTrackingPose(ref HmdMatrix34_t pMatSeatedZeroPoseToRawTrackingPose);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _SetWorkingStandingZeroPoseToRawTrackingPose(ref HmdMatrix34_t pMatStandingZeroPoseToRawTrackingPose);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _ReloadFromDisk(EChaperoneConfigFile configFile);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _GetLiveSeatedZeroPoseToRawTrackingPose(ref HmdMatrix34_t pmatSeatedZeroPoseToRawTrackingPose);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _SetWorkingCollisionBoundsTagsInfo([In][Out] byte[] pTagsBuffer, uint unTagCount);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _GetLiveCollisionBoundsTagsInfo([In][Out] byte[] pTagsBuffer, ref uint punTagCount);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _SetWorkingPhysicalBoundsInfo([In][Out] HmdQuad_t[] pQuadsBuffer, uint unQuadsCount);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _GetLivePhysicalBoundsInfo([In][Out] HmdQuad_t[] pQuadsBuffer, ref uint punQuadsCount);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _ExportLiveToBuffer(StringBuilder pBuffer, ref uint pnBufferLength);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _ImportFromBufferToWorking(string pBuffer, uint nImportFlags);

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _CommitWorkingCopy CommitWorkingCopy;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _RevertWorkingCopy RevertWorkingCopy;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetWorkingPlayAreaSize GetWorkingPlayAreaSize;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetWorkingPlayAreaRect GetWorkingPlayAreaRect;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetWorkingCollisionBoundsInfo GetWorkingCollisionBoundsInfo;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetLiveCollisionBoundsInfo GetLiveCollisionBoundsInfo;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetWorkingSeatedZeroPoseToRawTrackingPose GetWorkingSeatedZeroPoseToRawTrackingPose;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetWorkingStandingZeroPoseToRawTrackingPose GetWorkingStandingZeroPoseToRawTrackingPose;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetWorkingPlayAreaSize SetWorkingPlayAreaSize;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetWorkingCollisionBoundsInfo SetWorkingCollisionBoundsInfo;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetWorkingSeatedZeroPoseToRawTrackingPose SetWorkingSeatedZeroPoseToRawTrackingPose;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetWorkingStandingZeroPoseToRawTrackingPose SetWorkingStandingZeroPoseToRawTrackingPose;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ReloadFromDisk ReloadFromDisk;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetLiveSeatedZeroPoseToRawTrackingPose GetLiveSeatedZeroPoseToRawTrackingPose;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetWorkingCollisionBoundsTagsInfo SetWorkingCollisionBoundsTagsInfo;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetLiveCollisionBoundsTagsInfo GetLiveCollisionBoundsTagsInfo;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetWorkingPhysicalBoundsInfo SetWorkingPhysicalBoundsInfo;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetLivePhysicalBoundsInfo GetLivePhysicalBoundsInfo;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ExportLiveToBuffer ExportLiveToBuffer;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ImportFromBufferToWorking ImportFromBufferToWorking;
	}
	public struct IVRCompositor
	{
		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _SetTrackingSpace(ETrackingUniverseOrigin eOrigin);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate ETrackingUniverseOrigin _GetTrackingSpace();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRCompositorError _WaitGetPoses([In][Out] TrackedDevicePose_t[] pRenderPoseArray, uint unRenderPoseArrayCount, [In][Out] TrackedDevicePose_t[] pGamePoseArray, uint unGamePoseArrayCount);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRCompositorError _GetLastPoses([In][Out] TrackedDevicePose_t[] pRenderPoseArray, uint unRenderPoseArrayCount, [In][Out] TrackedDevicePose_t[] pGamePoseArray, uint unGamePoseArrayCount);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRCompositorError _GetLastPoseForTrackedDeviceIndex(uint unDeviceIndex, ref TrackedDevicePose_t pOutputPose, ref TrackedDevicePose_t pOutputGamePose);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRCompositorError _Submit(EVREye eEye, ref Texture_t pTexture, ref VRTextureBounds_t pBounds, EVRSubmitFlags nSubmitFlags);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _ClearLastSubmittedFrame();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _PostPresentHandoff();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _GetFrameTiming(ref Compositor_FrameTiming pTiming, uint unFramesAgo);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetFrameTimings(ref Compositor_FrameTiming pTiming, uint nFrames);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate float _GetFrameTimeRemaining();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _GetCumulativeStats(ref Compositor_CumulativeStats pStats, uint nStatsSizeInBytes);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _FadeToColor(float fSeconds, float fRed, float fGreen, float fBlue, float fAlpha, bool bBackground);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate HmdColor_t _GetCurrentFadeColor(bool bBackground);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _FadeGrid(float fSeconds, bool bFadeIn);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate float _GetCurrentGridAlpha();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRCompositorError _SetSkyboxOverride([In][Out] Texture_t[] pTextures, uint unTextureCount);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _ClearSkyboxOverride();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _CompositorBringToFront();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _CompositorGoToBack();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _CompositorQuit();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _IsFullscreen();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetCurrentSceneFocusProcess();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetLastFrameRenderer();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _CanRenderScene();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _ShowMirrorWindow();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _HideMirrorWindow();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _IsMirrorWindowVisible();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _CompositorDumpImages();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _ShouldAppRenderWithLowResources();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _ForceInterleavedReprojectionOn(bool bOverride);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _ForceReconnectProcess();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _SuspendRendering(bool bSuspend);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRCompositorError _GetMirrorTextureD3D11(EVREye eEye, IntPtr pD3D11DeviceOrResource, ref IntPtr ppD3D11ShaderResourceView);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _ReleaseMirrorTextureD3D11(IntPtr pD3D11ShaderResourceView);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRCompositorError _GetMirrorTextureGL(EVREye eEye, ref uint pglTextureId, IntPtr pglSharedTextureHandle);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _ReleaseSharedGLTexture(uint glTextureId, IntPtr glSharedTextureHandle);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _LockGLSharedTextureForAccess(IntPtr glSharedTextureHandle);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _UnlockGLSharedTextureForAccess(IntPtr glSharedTextureHandle);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetVulkanInstanceExtensionsRequired(StringBuilder pchValue, uint unBufferSize);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetVulkanDeviceExtensionsRequired(IntPtr pPhysicalDevice, StringBuilder pchValue, uint unBufferSize);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _SetExplicitTimingMode(EVRCompositorTimingMode eTimingMode);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRCompositorError _SubmitExplicitTimingData();

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetTrackingSpace SetTrackingSpace;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetTrackingSpace GetTrackingSpace;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _WaitGetPoses WaitGetPoses;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetLastPoses GetLastPoses;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetLastPoseForTrackedDeviceIndex GetLastPoseForTrackedDeviceIndex;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _Submit Submit;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ClearLastSubmittedFrame ClearLastSubmittedFrame;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _PostPresentHandoff PostPresentHandoff;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetFrameTiming GetFrameTiming;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetFrameTimings GetFrameTimings;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetFrameTimeRemaining GetFrameTimeRemaining;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetCumulativeStats GetCumulativeStats;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _FadeToColor FadeToColor;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetCurrentFadeColor GetCurrentFadeColor;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _FadeGrid FadeGrid;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetCurrentGridAlpha GetCurrentGridAlpha;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetSkyboxOverride SetSkyboxOverride;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ClearSkyboxOverride ClearSkyboxOverride;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _CompositorBringToFront CompositorBringToFront;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _CompositorGoToBack CompositorGoToBack;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _CompositorQuit CompositorQuit;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _IsFullscreen IsFullscreen;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetCurrentSceneFocusProcess GetCurrentSceneFocusProcess;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetLastFrameRenderer GetLastFrameRenderer;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _CanRenderScene CanRenderScene;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ShowMirrorWindow ShowMirrorWindow;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _HideMirrorWindow HideMirrorWindow;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _IsMirrorWindowVisible IsMirrorWindowVisible;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _CompositorDumpImages CompositorDumpImages;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ShouldAppRenderWithLowResources ShouldAppRenderWithLowResources;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ForceInterleavedReprojectionOn ForceInterleavedReprojectionOn;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ForceReconnectProcess ForceReconnectProcess;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SuspendRendering SuspendRendering;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetMirrorTextureD3D11 GetMirrorTextureD3D11;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ReleaseMirrorTextureD3D11 ReleaseMirrorTextureD3D11;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetMirrorTextureGL GetMirrorTextureGL;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ReleaseSharedGLTexture ReleaseSharedGLTexture;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _LockGLSharedTextureForAccess LockGLSharedTextureForAccess;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _UnlockGLSharedTextureForAccess UnlockGLSharedTextureForAccess;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetVulkanInstanceExtensionsRequired GetVulkanInstanceExtensionsRequired;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetVulkanDeviceExtensionsRequired GetVulkanDeviceExtensionsRequired;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetExplicitTimingMode SetExplicitTimingMode;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SubmitExplicitTimingData SubmitExplicitTimingData;
	}
	public struct IVROverlay
	{
		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _FindOverlay(string pchOverlayKey, ref ulong pOverlayHandle);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _CreateOverlay(string pchOverlayKey, string pchOverlayName, ref ulong pOverlayHandle);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _DestroyOverlay(ulong ulOverlayHandle);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetHighQualityOverlay(ulong ulOverlayHandle);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate ulong _GetHighQualityOverlay();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetOverlayKey(ulong ulOverlayHandle, StringBuilder pchValue, uint unBufferSize, ref EVROverlayError pError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetOverlayName(ulong ulOverlayHandle, StringBuilder pchValue, uint unBufferSize, ref EVROverlayError pError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetOverlayName(ulong ulOverlayHandle, string pchName);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _GetOverlayImageData(ulong ulOverlayHandle, IntPtr pvBuffer, uint unBufferSize, ref uint punWidth, ref uint punHeight);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate IntPtr _GetOverlayErrorNameFromEnum(EVROverlayError error);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetOverlayRenderingPid(ulong ulOverlayHandle, uint unPID);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetOverlayRenderingPid(ulong ulOverlayHandle);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetOverlayFlag(ulong ulOverlayHandle, VROverlayFlags eOverlayFlag, bool bEnabled);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _GetOverlayFlag(ulong ulOverlayHandle, VROverlayFlags eOverlayFlag, ref bool pbEnabled);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetOverlayColor(ulong ulOverlayHandle, float fRed, float fGreen, float fBlue);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _GetOverlayColor(ulong ulOverlayHandle, ref float pfRed, ref float pfGreen, ref float pfBlue);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetOverlayAlpha(ulong ulOverlayHandle, float fAlpha);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _GetOverlayAlpha(ulong ulOverlayHandle, ref float pfAlpha);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetOverlayTexelAspect(ulong ulOverlayHandle, float fTexelAspect);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _GetOverlayTexelAspect(ulong ulOverlayHandle, ref float pfTexelAspect);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetOverlaySortOrder(ulong ulOverlayHandle, uint unSortOrder);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _GetOverlaySortOrder(ulong ulOverlayHandle, ref uint punSortOrder);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetOverlayWidthInMeters(ulong ulOverlayHandle, float fWidthInMeters);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _GetOverlayWidthInMeters(ulong ulOverlayHandle, ref float pfWidthInMeters);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetOverlayAutoCurveDistanceRangeInMeters(ulong ulOverlayHandle, float fMinDistanceInMeters, float fMaxDistanceInMeters);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _GetOverlayAutoCurveDistanceRangeInMeters(ulong ulOverlayHandle, ref float pfMinDistanceInMeters, ref float pfMaxDistanceInMeters);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetOverlayTextureColorSpace(ulong ulOverlayHandle, EColorSpace eTextureColorSpace);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _GetOverlayTextureColorSpace(ulong ulOverlayHandle, ref EColorSpace peTextureColorSpace);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetOverlayTextureBounds(ulong ulOverlayHandle, ref VRTextureBounds_t pOverlayTextureBounds);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _GetOverlayTextureBounds(ulong ulOverlayHandle, ref VRTextureBounds_t pOverlayTextureBounds);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetOverlayRenderModel(ulong ulOverlayHandle, StringBuilder pchValue, uint unBufferSize, ref HmdColor_t pColor, ref EVROverlayError pError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetOverlayRenderModel(ulong ulOverlayHandle, string pchRenderModel, ref HmdColor_t pColor);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _GetOverlayTransformType(ulong ulOverlayHandle, ref VROverlayTransformType peTransformType);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetOverlayTransformAbsolute(ulong ulOverlayHandle, ETrackingUniverseOrigin eTrackingOrigin, ref HmdMatrix34_t pmatTrackingOriginToOverlayTransform);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _GetOverlayTransformAbsolute(ulong ulOverlayHandle, ref ETrackingUniverseOrigin peTrackingOrigin, ref HmdMatrix34_t pmatTrackingOriginToOverlayTransform);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetOverlayTransformTrackedDeviceRelative(ulong ulOverlayHandle, uint unTrackedDevice, ref HmdMatrix34_t pmatTrackedDeviceToOverlayTransform);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _GetOverlayTransformTrackedDeviceRelative(ulong ulOverlayHandle, ref uint punTrackedDevice, ref HmdMatrix34_t pmatTrackedDeviceToOverlayTransform);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetOverlayTransformTrackedDeviceComponent(ulong ulOverlayHandle, uint unDeviceIndex, string pchComponentName);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _GetOverlayTransformTrackedDeviceComponent(ulong ulOverlayHandle, ref uint punDeviceIndex, StringBuilder pchComponentName, uint unComponentNameSize);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _GetOverlayTransformOverlayRelative(ulong ulOverlayHandle, ref ulong ulOverlayHandleParent, ref HmdMatrix34_t pmatParentOverlayToOverlayTransform);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetOverlayTransformOverlayRelative(ulong ulOverlayHandle, ulong ulOverlayHandleParent, ref HmdMatrix34_t pmatParentOverlayToOverlayTransform);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _ShowOverlay(ulong ulOverlayHandle);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _HideOverlay(ulong ulOverlayHandle);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _IsOverlayVisible(ulong ulOverlayHandle);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _GetTransformForOverlayCoordinates(ulong ulOverlayHandle, ETrackingUniverseOrigin eTrackingOrigin, HmdVector2_t coordinatesInOverlay, ref HmdMatrix34_t pmatTransform);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _PollNextOverlayEvent(ulong ulOverlayHandle, ref VREvent_t pEvent, uint uncbVREvent);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _GetOverlayInputMethod(ulong ulOverlayHandle, ref VROverlayInputMethod peInputMethod);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetOverlayInputMethod(ulong ulOverlayHandle, VROverlayInputMethod eInputMethod);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _GetOverlayMouseScale(ulong ulOverlayHandle, ref HmdVector2_t pvecMouseScale);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetOverlayMouseScale(ulong ulOverlayHandle, ref HmdVector2_t pvecMouseScale);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _ComputeOverlayIntersection(ulong ulOverlayHandle, ref VROverlayIntersectionParams_t pParams, ref VROverlayIntersectionResults_t pResults);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _IsHoverTargetOverlay(ulong ulOverlayHandle);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate ulong _GetGamepadFocusOverlay();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetGamepadFocusOverlay(ulong ulNewFocusOverlay);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetOverlayNeighbor(EOverlayDirection eDirection, ulong ulFrom, ulong ulTo);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _MoveGamepadFocusToNeighbor(EOverlayDirection eDirection, ulong ulFrom);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetOverlayDualAnalogTransform(ulong ulOverlay, EDualAnalogWhich eWhich, IntPtr vCenter, float fRadius);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _GetOverlayDualAnalogTransform(ulong ulOverlay, EDualAnalogWhich eWhich, ref HmdVector2_t pvCenter, ref float pfRadius);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetOverlayTexture(ulong ulOverlayHandle, ref Texture_t pTexture);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _ClearOverlayTexture(ulong ulOverlayHandle);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetOverlayRaw(ulong ulOverlayHandle, IntPtr pvBuffer, uint unWidth, uint unHeight, uint unDepth);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetOverlayFromFile(ulong ulOverlayHandle, string pchFilePath);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _GetOverlayTexture(ulong ulOverlayHandle, ref IntPtr pNativeTextureHandle, IntPtr pNativeTextureRef, ref uint pWidth, ref uint pHeight, ref uint pNativeFormat, ref ETextureType pAPIType, ref EColorSpace pColorSpace, ref VRTextureBounds_t pTextureBounds);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _ReleaseNativeOverlayHandle(ulong ulOverlayHandle, IntPtr pNativeTextureHandle);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _GetOverlayTextureSize(ulong ulOverlayHandle, ref uint pWidth, ref uint pHeight);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _CreateDashboardOverlay(string pchOverlayKey, string pchOverlayFriendlyName, ref ulong pMainHandle, ref ulong pThumbnailHandle);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _IsDashboardVisible();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _IsActiveDashboardOverlay(ulong ulOverlayHandle);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetDashboardOverlaySceneProcess(ulong ulOverlayHandle, uint unProcessId);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _GetDashboardOverlaySceneProcess(ulong ulOverlayHandle, ref uint punProcessId);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _ShowDashboard(string pchOverlayToShow);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetPrimaryDashboardDevice();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _ShowKeyboard(int eInputMode, int eLineInputMode, string pchDescription, uint unCharMax, string pchExistingText, bool bUseMinimalMode, ulong uUserValue);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _ShowKeyboardForOverlay(ulong ulOverlayHandle, int eInputMode, int eLineInputMode, string pchDescription, uint unCharMax, string pchExistingText, bool bUseMinimalMode, ulong uUserValue);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetKeyboardText(StringBuilder pchText, uint cchText);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _HideKeyboard();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _SetKeyboardTransformAbsolute(ETrackingUniverseOrigin eTrackingOrigin, ref HmdMatrix34_t pmatTrackingOriginToKeyboardTransform);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _SetKeyboardPositionForOverlay(ulong ulOverlayHandle, HmdRect2_t avoidRect);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _SetOverlayIntersectionMask(ulong ulOverlayHandle, ref VROverlayIntersectionMaskPrimitive_t pMaskPrimitives, uint unNumMaskPrimitives, uint unPrimitiveSize);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVROverlayError _GetOverlayFlags(ulong ulOverlayHandle, ref uint pFlags);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate VRMessageOverlayResponse _ShowMessageOverlay(string pchText, string pchCaption, string pchButton0Text, string pchButton1Text, string pchButton2Text, string pchButton3Text);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _CloseMessageOverlay();

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _FindOverlay FindOverlay;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _CreateOverlay CreateOverlay;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _DestroyOverlay DestroyOverlay;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetHighQualityOverlay SetHighQualityOverlay;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetHighQualityOverlay GetHighQualityOverlay;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlayKey GetOverlayKey;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlayName GetOverlayName;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetOverlayName SetOverlayName;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlayImageData GetOverlayImageData;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlayErrorNameFromEnum GetOverlayErrorNameFromEnum;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetOverlayRenderingPid SetOverlayRenderingPid;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlayRenderingPid GetOverlayRenderingPid;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetOverlayFlag SetOverlayFlag;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlayFlag GetOverlayFlag;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetOverlayColor SetOverlayColor;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlayColor GetOverlayColor;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetOverlayAlpha SetOverlayAlpha;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlayAlpha GetOverlayAlpha;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetOverlayTexelAspect SetOverlayTexelAspect;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlayTexelAspect GetOverlayTexelAspect;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetOverlaySortOrder SetOverlaySortOrder;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlaySortOrder GetOverlaySortOrder;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetOverlayWidthInMeters SetOverlayWidthInMeters;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlayWidthInMeters GetOverlayWidthInMeters;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetOverlayAutoCurveDistanceRangeInMeters SetOverlayAutoCurveDistanceRangeInMeters;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlayAutoCurveDistanceRangeInMeters GetOverlayAutoCurveDistanceRangeInMeters;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetOverlayTextureColorSpace SetOverlayTextureColorSpace;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlayTextureColorSpace GetOverlayTextureColorSpace;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetOverlayTextureBounds SetOverlayTextureBounds;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlayTextureBounds GetOverlayTextureBounds;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlayRenderModel GetOverlayRenderModel;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetOverlayRenderModel SetOverlayRenderModel;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlayTransformType GetOverlayTransformType;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetOverlayTransformAbsolute SetOverlayTransformAbsolute;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlayTransformAbsolute GetOverlayTransformAbsolute;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetOverlayTransformTrackedDeviceRelative SetOverlayTransformTrackedDeviceRelative;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlayTransformTrackedDeviceRelative GetOverlayTransformTrackedDeviceRelative;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetOverlayTransformTrackedDeviceComponent SetOverlayTransformTrackedDeviceComponent;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlayTransformTrackedDeviceComponent GetOverlayTransformTrackedDeviceComponent;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlayTransformOverlayRelative GetOverlayTransformOverlayRelative;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetOverlayTransformOverlayRelative SetOverlayTransformOverlayRelative;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ShowOverlay ShowOverlay;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _HideOverlay HideOverlay;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _IsOverlayVisible IsOverlayVisible;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetTransformForOverlayCoordinates GetTransformForOverlayCoordinates;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _PollNextOverlayEvent PollNextOverlayEvent;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlayInputMethod GetOverlayInputMethod;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetOverlayInputMethod SetOverlayInputMethod;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlayMouseScale GetOverlayMouseScale;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetOverlayMouseScale SetOverlayMouseScale;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ComputeOverlayIntersection ComputeOverlayIntersection;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _IsHoverTargetOverlay IsHoverTargetOverlay;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetGamepadFocusOverlay GetGamepadFocusOverlay;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetGamepadFocusOverlay SetGamepadFocusOverlay;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetOverlayNeighbor SetOverlayNeighbor;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _MoveGamepadFocusToNeighbor MoveGamepadFocusToNeighbor;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetOverlayDualAnalogTransform SetOverlayDualAnalogTransform;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlayDualAnalogTransform GetOverlayDualAnalogTransform;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetOverlayTexture SetOverlayTexture;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ClearOverlayTexture ClearOverlayTexture;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetOverlayRaw SetOverlayRaw;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetOverlayFromFile SetOverlayFromFile;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlayTexture GetOverlayTexture;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ReleaseNativeOverlayHandle ReleaseNativeOverlayHandle;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlayTextureSize GetOverlayTextureSize;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _CreateDashboardOverlay CreateDashboardOverlay;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _IsDashboardVisible IsDashboardVisible;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _IsActiveDashboardOverlay IsActiveDashboardOverlay;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetDashboardOverlaySceneProcess SetDashboardOverlaySceneProcess;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetDashboardOverlaySceneProcess GetDashboardOverlaySceneProcess;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ShowDashboard ShowDashboard;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetPrimaryDashboardDevice GetPrimaryDashboardDevice;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ShowKeyboard ShowKeyboard;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ShowKeyboardForOverlay ShowKeyboardForOverlay;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetKeyboardText GetKeyboardText;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _HideKeyboard HideKeyboard;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetKeyboardTransformAbsolute SetKeyboardTransformAbsolute;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetKeyboardPositionForOverlay SetKeyboardPositionForOverlay;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetOverlayIntersectionMask SetOverlayIntersectionMask;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetOverlayFlags GetOverlayFlags;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _ShowMessageOverlay ShowMessageOverlay;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _CloseMessageOverlay CloseMessageOverlay;
	}
	public struct IVRRenderModels
	{
		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRRenderModelError _LoadRenderModel_Async(string pchRenderModelName, ref IntPtr ppRenderModel);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _FreeRenderModel(IntPtr pRenderModel);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRRenderModelError _LoadTexture_Async(int textureId, ref IntPtr ppTexture);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _FreeTexture(IntPtr pTexture);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRRenderModelError _LoadTextureD3D11_Async(int textureId, IntPtr pD3D11Device, ref IntPtr ppD3D11Texture2D);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRRenderModelError _LoadIntoTextureD3D11_Async(int textureId, IntPtr pDstTexture);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _FreeTextureD3D11(IntPtr pD3D11Texture2D);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetRenderModelName(uint unRenderModelIndex, StringBuilder pchRenderModelName, uint unRenderModelNameLen);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetRenderModelCount();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetComponentCount(string pchRenderModelName);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetComponentName(string pchRenderModelName, uint unComponentIndex, StringBuilder pchComponentName, uint unComponentNameLen);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate ulong _GetComponentButtonMask(string pchRenderModelName, string pchComponentName);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetComponentRenderModelName(string pchRenderModelName, string pchComponentName, StringBuilder pchComponentRenderModelName, uint unComponentRenderModelNameLen);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _GetComponentState(string pchRenderModelName, string pchComponentName, ref VRControllerState_t pControllerState, ref RenderModel_ControllerMode_State_t pState, ref RenderModel_ComponentState_t pComponentState);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _RenderModelHasComponent(string pchRenderModelName, string pchComponentName);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetRenderModelThumbnailURL(string pchRenderModelName, StringBuilder pchThumbnailURL, uint unThumbnailURLLen, ref EVRRenderModelError peError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetRenderModelOriginalPath(string pchRenderModelName, StringBuilder pchOriginalPath, uint unOriginalPathLen, ref EVRRenderModelError peError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate IntPtr _GetRenderModelErrorNameFromEnum(EVRRenderModelError error);

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _LoadRenderModel_Async LoadRenderModel_Async;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _FreeRenderModel FreeRenderModel;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _LoadTexture_Async LoadTexture_Async;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _FreeTexture FreeTexture;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _LoadTextureD3D11_Async LoadTextureD3D11_Async;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _LoadIntoTextureD3D11_Async LoadIntoTextureD3D11_Async;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _FreeTextureD3D11 FreeTextureD3D11;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetRenderModelName GetRenderModelName;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetRenderModelCount GetRenderModelCount;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetComponentCount GetComponentCount;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetComponentName GetComponentName;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetComponentButtonMask GetComponentButtonMask;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetComponentRenderModelName GetComponentRenderModelName;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetComponentState GetComponentState;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _RenderModelHasComponent RenderModelHasComponent;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetRenderModelThumbnailURL GetRenderModelThumbnailURL;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetRenderModelOriginalPath GetRenderModelOriginalPath;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetRenderModelErrorNameFromEnum GetRenderModelErrorNameFromEnum;
	}
	public struct IVRNotifications
	{
		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRNotificationError _CreateNotification(ulong ulOverlayHandle, ulong ulUserValue, EVRNotificationType type, string pchText, EVRNotificationStyle style, ref NotificationBitmap_t pImage, ref uint pNotificationId);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRNotificationError _RemoveNotification(uint notificationId);

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _CreateNotification CreateNotification;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _RemoveNotification RemoveNotification;
	}
	public struct IVRSettings
	{
		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate IntPtr _GetSettingsErrorNameFromEnum(EVRSettingsError eError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _Sync(bool bForce, ref EVRSettingsError peError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _SetBool(string pchSection, string pchSettingsKey, bool bValue, ref EVRSettingsError peError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _SetInt32(string pchSection, string pchSettingsKey, int nValue, ref EVRSettingsError peError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _SetFloat(string pchSection, string pchSettingsKey, float flValue, ref EVRSettingsError peError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _SetString(string pchSection, string pchSettingsKey, string pchValue, ref EVRSettingsError peError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _GetBool(string pchSection, string pchSettingsKey, ref EVRSettingsError peError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate int _GetInt32(string pchSection, string pchSettingsKey, ref EVRSettingsError peError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate float _GetFloat(string pchSection, string pchSettingsKey, ref EVRSettingsError peError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _GetString(string pchSection, string pchSettingsKey, StringBuilder pchValue, uint unValueLen, ref EVRSettingsError peError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _RemoveSection(string pchSection, ref EVRSettingsError peError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate void _RemoveKeyInSection(string pchSection, string pchSettingsKey, ref EVRSettingsError peError);

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetSettingsErrorNameFromEnum GetSettingsErrorNameFromEnum;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _Sync Sync;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetBool SetBool;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetInt32 SetInt32;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetFloat SetFloat;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SetString SetString;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetBool GetBool;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetInt32 GetInt32;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetFloat GetFloat;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetString GetString;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _RemoveSection RemoveSection;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _RemoveKeyInSection RemoveKeyInSection;
	}
	public struct IVRScreenshots
	{
		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRScreenshotError _RequestScreenshot(ref uint pOutScreenshotHandle, EVRScreenshotType type, string pchPreviewFilename, string pchVRFilename);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRScreenshotError _HookScreenshot([In][Out] EVRScreenshotType[] pSupportedTypes, int numTypes);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRScreenshotType _GetScreenshotPropertyType(uint screenshotHandle, ref EVRScreenshotError pError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetScreenshotPropertyFilename(uint screenshotHandle, EVRScreenshotPropertyFilenames filenameType, StringBuilder pchFilename, uint cchFilename, ref EVRScreenshotError pError);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRScreenshotError _UpdateScreenshotProgress(uint screenshotHandle, float flProgress);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRScreenshotError _TakeStereoScreenshot(ref uint pOutScreenshotHandle, string pchPreviewFilename, string pchVRFilename);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate EVRScreenshotError _SubmitScreenshot(uint screenshotHandle, EVRScreenshotType type, string pchSourcePreviewFilename, string pchSourceVRFilename);

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _RequestScreenshot RequestScreenshot;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _HookScreenshot HookScreenshot;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetScreenshotPropertyType GetScreenshotPropertyType;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetScreenshotPropertyFilename GetScreenshotPropertyFilename;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _UpdateScreenshotProgress UpdateScreenshotProgress;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _TakeStereoScreenshot TakeStereoScreenshot;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _SubmitScreenshot SubmitScreenshot;
	}
	public struct IVRResources
	{
		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _LoadSharedResource(string pchResourceName, string pchBuffer, uint unBufferLen);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetResourceFullPath(string pchResourceName, string pchResourceTypeDirectory, StringBuilder pchPathBuffer, uint unBufferLen);

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _LoadSharedResource LoadSharedResource;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetResourceFullPath GetResourceFullPath;
	}
	public struct IVRDriverManager
	{
		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetDriverCount();

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate uint _GetDriverName(uint nDriver, StringBuilder pchValue, uint unBufferSize);

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetDriverCount GetDriverCount;

		[MarshalAs(UnmanagedType.FunctionPtr)]
		internal _GetDriverName GetDriverName;
	}
	public class CVRSystem
	{
		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _PollNextEventPacked(ref VREvent_t_Packed pEvent, uint uncbVREvent);

		[StructLayout(LayoutKind.Explicit)]
		private struct PollNextEventUnion
		{
			[FieldOffset(0)]
			public IVRSystem._PollNextEvent pPollNextEvent;

			[FieldOffset(0)]
			public _PollNextEventPacked pPollNextEventPacked;
		}

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _GetControllerStatePacked(uint unControllerDeviceIndex, ref VRControllerState_t_Packed pControllerState, uint unControllerStateSize);

		[StructLayout(LayoutKind.Explicit)]
		private struct GetControllerStateUnion
		{
			[FieldOffset(0)]
			public IVRSystem._GetControllerState pGetControllerState;

			[FieldOffset(0)]
			public _GetControllerStatePacked pGetControllerStatePacked;
		}

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _GetControllerStateWithPosePacked(ETrackingUniverseOrigin eOrigin, uint unControllerDeviceIndex, ref VRControllerState_t_Packed pControllerState, uint unControllerStateSize, ref TrackedDevicePose_t pTrackedDevicePose);

		[StructLayout(LayoutKind.Explicit)]
		private struct GetControllerStateWithPoseUnion
		{
			[FieldOffset(0)]
			public IVRSystem._GetControllerStateWithPose pGetControllerStateWithPose;

			[FieldOffset(0)]
			public _GetControllerStateWithPosePacked pGetControllerStateWithPosePacked;
		}

		private IVRSystem FnTable;

		internal CVRSystem(IntPtr pInterface)
		{
			FnTable = (IVRSystem)Marshal.PtrToStructure(pInterface, typeof(IVRSystem));
		}

		public void GetRecommendedRenderTargetSize(ref uint pnWidth, ref uint pnHeight)
		{
			pnWidth = 0u;
			pnHeight = 0u;
			FnTable.GetRecommendedRenderTargetSize(ref pnWidth, ref pnHeight);
		}

		public HmdMatrix44_t GetProjectionMatrix(EVREye eEye, float fNearZ, float fFarZ)
		{
			return FnTable.GetProjectionMatrix(eEye, fNearZ, fFarZ);
		}

		public void GetProjectionRaw(EVREye eEye, ref float pfLeft, ref float pfRight, ref float pfTop, ref float pfBottom)
		{
			pfLeft = 0f;
			pfRight = 0f;
			pfTop = 0f;
			pfBottom = 0f;
			FnTable.GetProjectionRaw(eEye, ref pfLeft, ref pfRight, ref pfTop, ref pfBottom);
		}

		public bool ComputeDistortion(EVREye eEye, float fU, float fV, ref DistortionCoordinates_t pDistortionCoordinates)
		{
			return FnTable.ComputeDistortion(eEye, fU, fV, ref pDistortionCoordinates);
		}

		public HmdMatrix34_t GetEyeToHeadTransform(EVREye eEye)
		{
			return FnTable.GetEyeToHeadTransform(eEye);
		}

		public bool GetTimeSinceLastVsync(ref float pfSecondsSinceLastVsync, ref ulong pulFrameCounter)
		{
			pfSecondsSinceLastVsync = 0f;
			pulFrameCounter = 0uL;
			return FnTable.GetTimeSinceLastVsync(ref pfSecondsSinceLastVsync, ref pulFrameCounter);
		}

		public int GetD3D9AdapterIndex()
		{
			return FnTable.GetD3D9AdapterIndex();
		}

		public void GetDXGIOutputInfo(ref int pnAdapterIndex)
		{
			pnAdapterIndex = 0;
			FnTable.GetDXGIOutputInfo(ref pnAdapterIndex);
		}

		public void GetOutputDevice(ref ulong pnDevice, ETextureType textureType, IntPtr pInstance)
		{
			pnDevice = 0uL;
			FnTable.GetOutputDevice(ref pnDevice, textureType, pInstance);
		}

		public bool IsDisplayOnDesktop()
		{
			return FnTable.IsDisplayOnDesktop();
		}

		public bool SetDisplayVisibility(bool bIsVisibleOnDesktop)
		{
			return FnTable.SetDisplayVisibility(bIsVisibleOnDesktop);
		}

		public void GetDeviceToAbsoluteTrackingPose(ETrackingUniverseOrigin eOrigin, float fPredictedSecondsToPhotonsFromNow, TrackedDevicePose_t[] pTrackedDevicePoseArray)
		{
			FnTable.GetDeviceToAbsoluteTrackingPose(eOrigin, fPredictedSecondsToPhotonsFromNow, pTrackedDevicePoseArray, (uint)pTrackedDevicePoseArray.Length);
		}

		public void ResetSeatedZeroPose()
		{
			FnTable.ResetSeatedZeroPose();
		}

		public HmdMatrix34_t GetSeatedZeroPoseToStandingAbsoluteTrackingPose()
		{
			return FnTable.GetSeatedZeroPoseToStandingAbsoluteTrackingPose();
		}

		public HmdMatrix34_t GetRawZeroPoseToStandingAbsoluteTrackingPose()
		{
			return FnTable.GetRawZeroPoseToStandingAbsoluteTrackingPose();
		}

		public uint GetSortedTrackedDeviceIndicesOfClass(ETrackedDeviceClass eTrackedDeviceClass, uint[] punTrackedDeviceIndexArray, uint unRelativeToTrackedDeviceIndex)
		{
			return FnTable.GetSortedTrackedDeviceIndicesOfClass(eTrackedDeviceClass, punTrackedDeviceIndexArray, (uint)punTrackedDeviceIndexArray.Length, unRelativeToTrackedDeviceIndex);
		}

		public EDeviceActivityLevel GetTrackedDeviceActivityLevel(uint unDeviceId)
		{
			return FnTable.GetTrackedDeviceActivityLevel(unDeviceId);
		}

		public void ApplyTransform(ref TrackedDevicePose_t pOutputPose, ref TrackedDevicePose_t pTrackedDevicePose, ref HmdMatrix34_t pTransform)
		{
			FnTable.ApplyTransform(ref pOutputPose, ref pTrackedDevicePose, ref pTransform);
		}

		public uint GetTrackedDeviceIndexForControllerRole(ETrackedControllerRole unDeviceType)
		{
			return FnTable.GetTrackedDeviceIndexForControllerRole(unDeviceType);
		}

		public ETrackedControllerRole GetControllerRoleForTrackedDeviceIndex(uint unDeviceIndex)
		{
			return FnTable.GetControllerRoleForTrackedDeviceIndex(unDeviceIndex);
		}

		public ETrackedDeviceClass GetTrackedDeviceClass(uint unDeviceIndex)
		{
			return FnTable.GetTrackedDeviceClass(unDeviceIndex);
		}

		public bool IsTrackedDeviceConnected(uint unDeviceIndex)
		{
			return FnTable.IsTrackedDeviceConnected(unDeviceIndex);
		}

		public bool GetBoolTrackedDeviceProperty(uint unDeviceIndex, ETrackedDeviceProperty prop, ref ETrackedPropertyError pError)
		{
			return FnTable.GetBoolTrackedDeviceProperty(unDeviceIndex, prop, ref pError);
		}

		public float GetFloatTrackedDeviceProperty(uint unDeviceIndex, ETrackedDeviceProperty prop, ref ETrackedPropertyError pError)
		{
			return FnTable.GetFloatTrackedDeviceProperty(unDeviceIndex, prop, ref pError);
		}

		public int GetInt32TrackedDeviceProperty(uint unDeviceIndex, ETrackedDeviceProperty prop, ref ETrackedPropertyError pError)
		{
			return FnTable.GetInt32TrackedDeviceProperty(unDeviceIndex, prop, ref pError);
		}

		public ulong GetUint64TrackedDeviceProperty(uint unDeviceIndex, ETrackedDeviceProperty prop, ref ETrackedPropertyError pError)
		{
			return FnTable.GetUint64TrackedDeviceProperty(unDeviceIndex, prop, ref pError);
		}

		public HmdMatrix34_t GetMatrix34TrackedDeviceProperty(uint unDeviceIndex, ETrackedDeviceProperty prop, ref ETrackedPropertyError pError)
		{
			return FnTable.GetMatrix34TrackedDeviceProperty(unDeviceIndex, prop, ref pError);
		}

		public uint GetArrayTrackedDeviceProperty(uint unDeviceIndex, ETrackedDeviceProperty prop, uint propType, IntPtr pBuffer, uint unBufferSize, ref ETrackedPropertyError pError)
		{
			return FnTable.GetArrayTrackedDeviceProperty(unDeviceIndex, prop, propType, pBuffer, unBufferSize, ref pError);
		}

		public uint GetStringTrackedDeviceProperty(uint unDeviceIndex, ETrackedDeviceProperty prop, StringBuilder pchValue, uint unBufferSize, ref ETrackedPropertyError pError)
		{
			return FnTable.GetStringTrackedDeviceProperty(unDeviceIndex, prop, pchValue, unBufferSize, ref pError);
		}

		public string GetPropErrorNameFromEnum(ETrackedPropertyError error)
		{
			return Marshal.PtrToStringAnsi(FnTable.GetPropErrorNameFromEnum(error));
		}

		public bool PollNextEvent(ref VREvent_t pEvent, uint uncbVREvent)
		{
			if (Environment.OSVersion.Platform == PlatformID.MacOSX || Environment.OSVersion.Platform == PlatformID.Unix)
			{
				VREvent_t_Packed pEvent2 = default(VREvent_t_Packed);
				PollNextEventUnion pollNextEventUnion = default(PollNextEventUnion);
				pollNextEventUnion.pPollNextEventPacked = null;
				pollNextEventUnion.pPollNextEvent = FnTable.PollNextEvent;
				bool result = pollNextEventUnion.pPollNextEventPacked(ref pEvent2, (uint)Marshal.SizeOf(typeof(VREvent_t_Packed)));
				pEvent2.Unpack(ref pEvent);
				return result;
			}
			return FnTable.PollNextEvent(ref pEvent, uncbVREvent);
		}

		public bool PollNextEventWithPose(ETrackingUniverseOrigin eOrigin, ref VREvent_t pEvent, uint uncbVREvent, ref TrackedDevicePose_t pTrackedDevicePose)
		{
			return FnTable.PollNextEventWithPose(eOrigin, ref pEvent, uncbVREvent, ref pTrackedDevicePose);
		}

		public string GetEventTypeNameFromEnum(EVREventType eType)
		{
			return Marshal.PtrToStringAnsi(FnTable.GetEventTypeNameFromEnum(eType));
		}

		public HiddenAreaMesh_t GetHiddenAreaMesh(EVREye eEye, EHiddenAreaMeshType type)
		{
			return FnTable.GetHiddenAreaMesh(eEye, type);
		}

		public bool GetControllerState(uint unControllerDeviceIndex, ref VRControllerState_t pControllerState, uint unControllerStateSize)
		{
			if (Environment.OSVersion.Platform == PlatformID.MacOSX || Environment.OSVersion.Platform == PlatformID.Unix)
			{
				VRControllerState_t_Packed pControllerState2 = new VRControllerState_t_Packed(pControllerState);
				GetControllerStateUnion getControllerStateUnion = default(GetControllerStateUnion);
				getControllerStateUnion.pGetControllerStatePacked = null;
				getControllerStateUnion.pGetControllerState = FnTable.GetControllerState;
				bool result = getControllerStateUnion.pGetControllerStatePacked(unControllerDeviceIndex, ref pControllerState2, (uint)Marshal.SizeOf(typeof(VRControllerState_t_Packed)));
				pControllerState2.Unpack(ref pControllerState);
				return result;
			}
			return FnTable.GetControllerState(unControllerDeviceIndex, ref pControllerState, unControllerStateSize);
		}

		public bool GetControllerStateWithPose(ETrackingUniverseOrigin eOrigin, uint unControllerDeviceIndex, ref VRControllerState_t pControllerState, uint unControllerStateSize, ref TrackedDevicePose_t pTrackedDevicePose)
		{
			if (Environment.OSVersion.Platform == PlatformID.MacOSX || Environment.OSVersion.Platform == PlatformID.Unix)
			{
				VRControllerState_t_Packed pControllerState2 = new VRControllerState_t_Packed(pControllerState);
				GetControllerStateWithPoseUnion getControllerStateWithPoseUnion = default(GetControllerStateWithPoseUnion);
				getControllerStateWithPoseUnion.pGetControllerStateWithPosePacked = null;
				getControllerStateWithPoseUnion.pGetControllerStateWithPose = FnTable.GetControllerStateWithPose;
				bool result = getControllerStateWithPoseUnion.pGetControllerStateWithPosePacked(eOrigin, unControllerDeviceIndex, ref pControllerState2, (uint)Marshal.SizeOf(typeof(VRControllerState_t_Packed)), ref pTrackedDevicePose);
				pControllerState2.Unpack(ref pControllerState);
				return result;
			}
			return FnTable.GetControllerStateWithPose(eOrigin, unControllerDeviceIndex, ref pControllerState, unControllerStateSize, ref pTrackedDevicePose);
		}

		public void TriggerHapticPulse(uint unControllerDeviceIndex, uint unAxisId, char usDurationMicroSec)
		{
			FnTable.TriggerHapticPulse(unControllerDeviceIndex, unAxisId, usDurationMicroSec);
		}

		public string GetButtonIdNameFromEnum(EVRButtonId eButtonId)
		{
			return Marshal.PtrToStringAnsi(FnTable.GetButtonIdNameFromEnum(eButtonId));
		}

		public string GetControllerAxisTypeNameFromEnum(EVRControllerAxisType eAxisType)
		{
			return Marshal.PtrToStringAnsi(FnTable.GetControllerAxisTypeNameFromEnum(eAxisType));
		}

		public bool IsInputAvailable()
		{
			return FnTable.IsInputAvailable();
		}

		public bool IsSteamVRDrawingControllers()
		{
			return FnTable.IsSteamVRDrawingControllers();
		}

		public bool ShouldApplicationPause()
		{
			return FnTable.ShouldApplicationPause();
		}

		public bool ShouldApplicationReduceRenderingWork()
		{
			return FnTable.ShouldApplicationReduceRenderingWork();
		}

		public uint DriverDebugRequest(uint unDeviceIndex, string pchRequest, StringBuilder pchResponseBuffer, uint unResponseBufferSize)
		{
			return FnTable.DriverDebugRequest(unDeviceIndex, pchRequest, pchResponseBuffer, unResponseBufferSize);
		}

		public EVRFirmwareError PerformFirmwareUpdate(uint unDeviceIndex)
		{
			return FnTable.PerformFirmwareUpdate(unDeviceIndex);
		}

		public void AcknowledgeQuit_Exiting()
		{
			FnTable.AcknowledgeQuit_Exiting();
		}

		public void AcknowledgeQuit_UserPrompt()
		{
			FnTable.AcknowledgeQuit_UserPrompt();
		}
	}
	public class CVRExtendedDisplay
	{
		private IVRExtendedDisplay FnTable;

		internal CVRExtendedDisplay(IntPtr pInterface)
		{
			FnTable = (IVRExtendedDisplay)Marshal.PtrToStructure(pInterface, typeof(IVRExtendedDisplay));
		}

		public void GetWindowBounds(ref int pnX, ref int pnY, ref uint pnWidth, ref uint pnHeight)
		{
			pnX = 0;
			pnY = 0;
			pnWidth = 0u;
			pnHeight = 0u;
			FnTable.GetWindowBounds(ref pnX, ref pnY, ref pnWidth, ref pnHeight);
		}

		public void GetEyeOutputViewport(EVREye eEye, ref uint pnX, ref uint pnY, ref uint pnWidth, ref uint pnHeight)
		{
			pnX = 0u;
			pnY = 0u;
			pnWidth = 0u;
			pnHeight = 0u;
			FnTable.GetEyeOutputViewport(eEye, ref pnX, ref pnY, ref pnWidth, ref pnHeight);
		}

		public void GetDXGIOutputInfo(ref int pnAdapterIndex, ref int pnAdapterOutputIndex)
		{
			pnAdapterIndex = 0;
			pnAdapterOutputIndex = 0;
			FnTable.GetDXGIOutputInfo(ref pnAdapterIndex, ref pnAdapterOutputIndex);
		}
	}
	public class CVRTrackedCamera
	{
		private IVRTrackedCamera FnTable;

		internal CVRTrackedCamera(IntPtr pInterface)
		{
			FnTable = (IVRTrackedCamera)Marshal.PtrToStructure(pInterface, typeof(IVRTrackedCamera));
		}

		public string GetCameraErrorNameFromEnum(EVRTrackedCameraError eCameraError)
		{
			return Marshal.PtrToStringAnsi(FnTable.GetCameraErrorNameFromEnum(eCameraError));
		}

		public EVRTrackedCameraError HasCamera(uint nDeviceIndex, ref bool pHasCamera)
		{
			pHasCamera = false;
			return FnTable.HasCamera(nDeviceIndex, ref pHasCamera);
		}

		public EVRTrackedCameraError GetCameraFrameSize(uint nDeviceIndex, EVRTrackedCameraFrameType eFrameType, ref uint pnWidth, ref uint pnHeight, ref uint pnFrameBufferSize)
		{
			pnWidth = 0u;
			pnHeight = 0u;
			pnFrameBufferSize = 0u;
			return FnTable.GetCameraFrameSize(nDeviceIndex, eFrameType, ref pnWidth, ref pnHeight, ref pnFrameBufferSize);
		}

		public EVRTrackedCameraError GetCameraIntrinsics(uint nDeviceIndex, EVRTrackedCameraFrameType eFrameType, ref HmdVector2_t pFocalLength, ref HmdVector2_t pCenter)
		{
			return FnTable.GetCameraIntrinsics(nDeviceIndex, eFrameType, ref pFocalLength, ref pCenter);
		}

		public EVRTrackedCameraError GetCameraProjection(uint nDeviceIndex, EVRTrackedCameraFrameType eFrameType, float flZNear, float flZFar, ref HmdMatrix44_t pProjection)
		{
			return FnTable.GetCameraProjection(nDeviceIndex, eFrameType, flZNear, flZFar, ref pProjection);
		}

		public EVRTrackedCameraError AcquireVideoStreamingService(uint nDeviceIndex, ref ulong pHandle)
		{
			pHandle = 0uL;
			return FnTable.AcquireVideoStreamingService(nDeviceIndex, ref pHandle);
		}

		public EVRTrackedCameraError ReleaseVideoStreamingService(ulong hTrackedCamera)
		{
			return FnTable.ReleaseVideoStreamingService(hTrackedCamera);
		}

		public EVRTrackedCameraError GetVideoStreamFrameBuffer(ulong hTrackedCamera, EVRTrackedCameraFrameType eFrameType, IntPtr pFrameBuffer, uint nFrameBufferSize, ref CameraVideoStreamFrameHeader_t pFrameHeader, uint nFrameHeaderSize)
		{
			return FnTable.GetVideoStreamFrameBuffer(hTrackedCamera, eFrameType, pFrameBuffer, nFrameBufferSize, ref pFrameHeader, nFrameHeaderSize);
		}

		public EVRTrackedCameraError GetVideoStreamTextureSize(uint nDeviceIndex, EVRTrackedCameraFrameType eFrameType, ref VRTextureBounds_t pTextureBounds, ref uint pnWidth, ref uint pnHeight)
		{
			pnWidth = 0u;
			pnHeight = 0u;
			return FnTable.GetVideoStreamTextureSize(nDeviceIndex, eFrameType, ref pTextureBounds, ref pnWidth, ref pnHeight);
		}

		public EVRTrackedCameraError GetVideoStreamTextureD3D11(ulong hTrackedCamera, EVRTrackedCameraFrameType eFrameType, IntPtr pD3D11DeviceOrResource, ref IntPtr ppD3D11ShaderResourceView, ref CameraVideoStreamFrameHeader_t pFrameHeader, uint nFrameHeaderSize)
		{
			return FnTable.GetVideoStreamTextureD3D11(hTrackedCamera, eFrameType, pD3D11DeviceOrResource, ref ppD3D11ShaderResourceView, ref pFrameHeader, nFrameHeaderSize);
		}

		public EVRTrackedCameraError GetVideoStreamTextureGL(ulong hTrackedCamera, EVRTrackedCameraFrameType eFrameType, ref uint pglTextureId, ref CameraVideoStreamFrameHeader_t pFrameHeader, uint nFrameHeaderSize)
		{
			pglTextureId = 0u;
			return FnTable.GetVideoStreamTextureGL(hTrackedCamera, eFrameType, ref pglTextureId, ref pFrameHeader, nFrameHeaderSize);
		}

		public EVRTrackedCameraError ReleaseVideoStreamTextureGL(ulong hTrackedCamera, uint glTextureId)
		{
			return FnTable.ReleaseVideoStreamTextureGL(hTrackedCamera, glTextureId);
		}
	}
	public class CVRApplications
	{
		private IVRApplications FnTable;

		internal CVRApplications(IntPtr pInterface)
		{
			FnTable = (IVRApplications)Marshal.PtrToStructure(pInterface, typeof(IVRApplications));
		}

		public EVRApplicationError AddApplicationManifest(string pchApplicationManifestFullPath, bool bTemporary)
		{
			return FnTable.AddApplicationManifest(pchApplicationManifestFullPath, bTemporary);
		}

		public EVRApplicationError RemoveApplicationManifest(string pchApplicationManifestFullPath)
		{
			return FnTable.RemoveApplicationManifest(pchApplicationManifestFullPath);
		}

		public bool IsApplicationInstalled(string pchAppKey)
		{
			return FnTable.IsApplicationInstalled(pchAppKey);
		}

		public uint GetApplicationCount()
		{
			return FnTable.GetApplicationCount();
		}

		public EVRApplicationError GetApplicationKeyByIndex(uint unApplicationIndex, StringBuilder pchAppKeyBuffer, uint unAppKeyBufferLen)
		{
			return FnTable.GetApplicationKeyByIndex(unApplicationIndex, pchAppKeyBuffer, unAppKeyBufferLen);
		}

		public EVRApplicationError GetApplicationKeyByProcessId(uint unProcessId, StringBuilder pchAppKeyBuffer, uint unAppKeyBufferLen)
		{
			return FnTable.GetApplicationKeyByProcessId(unProcessId, pchAppKeyBuffer, unAppKeyBufferLen);
		}

		public EVRApplicationError LaunchApplication(string pchAppKey)
		{
			return FnTable.LaunchApplication(pchAppKey);
		}

		public EVRApplicationError LaunchTemplateApplication(string pchTemplateAppKey, string pchNewAppKey, AppOverrideKeys_t[] pKeys)
		{
			return FnTable.LaunchTemplateApplication(pchTemplateAppKey, pchNewAppKey, pKeys, (uint)pKeys.Length);
		}

		public EVRApplicationError LaunchApplicationFromMimeType(string pchMimeType, string pchArgs)
		{
			return FnTable.LaunchApplicationFromMimeType(pchMimeType, pchArgs);
		}

		public EVRApplicationError LaunchDashboardOverlay(string pchAppKey)
		{
			return FnTable.LaunchDashboardOverlay(pchAppKey);
		}

		public bool CancelApplicationLaunch(string pchAppKey)
		{
			return FnTable.CancelApplicationLaunch(pchAppKey);
		}

		public EVRApplicationError IdentifyApplication(uint unProcessId, string pchAppKey)
		{
			return FnTable.IdentifyApplication(unProcessId, pchAppKey);
		}

		public uint GetApplicationProcessId(string pchAppKey)
		{
			return FnTable.GetApplicationProcessId(pchAppKey);
		}

		public string GetApplicationsErrorNameFromEnum(EVRApplicationError error)
		{
			return Marshal.PtrToStringAnsi(FnTable.GetApplicationsErrorNameFromEnum(error));
		}

		public uint GetApplicationPropertyString(string pchAppKey, EVRApplicationProperty eProperty, StringBuilder pchPropertyValueBuffer, uint unPropertyValueBufferLen, ref EVRApplicationError peError)
		{
			return FnTable.GetApplicationPropertyString(pchAppKey, eProperty, pchPropertyValueBuffer, unPropertyValueBufferLen, ref peError);
		}

		public bool GetApplicationPropertyBool(string pchAppKey, EVRApplicationProperty eProperty, ref EVRApplicationError peError)
		{
			return FnTable.GetApplicationPropertyBool(pchAppKey, eProperty, ref peError);
		}

		public ulong GetApplicationPropertyUint64(string pchAppKey, EVRApplicationProperty eProperty, ref EVRApplicationError peError)
		{
			return FnTable.GetApplicationPropertyUint64(pchAppKey, eProperty, ref peError);
		}

		public EVRApplicationError SetApplicationAutoLaunch(string pchAppKey, bool bAutoLaunch)
		{
			return FnTable.SetApplicationAutoLaunch(pchAppKey, bAutoLaunch);
		}

		public bool GetApplicationAutoLaunch(string pchAppKey)
		{
			return FnTable.GetApplicationAutoLaunch(pchAppKey);
		}

		public EVRApplicationError SetDefaultApplicationForMimeType(string pchAppKey, string pchMimeType)
		{
			return FnTable.SetDefaultApplicationForMimeType(pchAppKey, pchMimeType);
		}

		public bool GetDefaultApplicationForMimeType(string pchMimeType, StringBuilder pchAppKeyBuffer, uint unAppKeyBufferLen)
		{
			return FnTable.GetDefaultApplicationForMimeType(pchMimeType, pchAppKeyBuffer, unAppKeyBufferLen);
		}

		public bool GetApplicationSupportedMimeTypes(string pchAppKey, StringBuilder pchMimeTypesBuffer, uint unMimeTypesBuffer)
		{
			return FnTable.GetApplicationSupportedMimeTypes(pchAppKey, pchMimeTypesBuffer, unMimeTypesBuffer);
		}

		public uint GetApplicationsThatSupportMimeType(string pchMimeType, StringBuilder pchAppKeysThatSupportBuffer, uint unAppKeysThatSupportBuffer)
		{
			return FnTable.GetApplicationsThatSupportMimeType(pchMimeType, pchAppKeysThatSupportBuffer, unAppKeysThatSupportBuffer);
		}

		public uint GetApplicationLaunchArguments(uint unHandle, StringBuilder pchArgs, uint unArgs)
		{
			return FnTable.GetApplicationLaunchArguments(unHandle, pchArgs, unArgs);
		}

		public EVRApplicationError GetStartingApplication(StringBuilder pchAppKeyBuffer, uint unAppKeyBufferLen)
		{
			return FnTable.GetStartingApplication(pchAppKeyBuffer, unAppKeyBufferLen);
		}

		public EVRApplicationTransitionState GetTransitionState()
		{
			return FnTable.GetTransitionState();
		}

		public EVRApplicationError PerformApplicationPrelaunchCheck(string pchAppKey)
		{
			return FnTable.PerformApplicationPrelaunchCheck(pchAppKey);
		}

		public string GetApplicationsTransitionStateNameFromEnum(EVRApplicationTransitionState state)
		{
			return Marshal.PtrToStringAnsi(FnTable.GetApplicationsTransitionStateNameFromEnum(state));
		}

		public bool IsQuitUserPromptRequested()
		{
			return FnTable.IsQuitUserPromptRequested();
		}

		public EVRApplicationError LaunchInternalProcess(string pchBinaryPath, string pchArguments, string pchWorkingDirectory)
		{
			return FnTable.LaunchInternalProcess(pchBinaryPath, pchArguments, pchWorkingDirectory);
		}

		public uint GetCurrentSceneProcessId()
		{
			return FnTable.GetCurrentSceneProcessId();
		}
	}
	public class CVRChaperone
	{
		private IVRChaperone FnTable;

		internal CVRChaperone(IntPtr pInterface)
		{
			FnTable = (IVRChaperone)Marshal.PtrToStructure(pInterface, typeof(IVRChaperone));
		}

		public ChaperoneCalibrationState GetCalibrationState()
		{
			return FnTable.GetCalibrationState();
		}

		public bool GetPlayAreaSize(ref float pSizeX, ref float pSizeZ)
		{
			pSizeX = 0f;
			pSizeZ = 0f;
			return FnTable.GetPlayAreaSize(ref pSizeX, ref pSizeZ);
		}

		public bool GetPlayAreaRect(ref HmdQuad_t rect)
		{
			return FnTable.GetPlayAreaRect(ref rect);
		}

		public void ReloadInfo()
		{
			FnTable.ReloadInfo();
		}

		public void SetSceneColor(HmdColor_t color)
		{
			FnTable.SetSceneColor(color);
		}

		public void GetBoundsColor(ref HmdColor_t pOutputColorArray, int nNumOutputColors, float flCollisionBoundsFadeDistance, ref HmdColor_t pOutputCameraColor)
		{
			FnTable.GetBoundsColor(ref pOutputColorArray, nNumOutputColors, flCollisionBoundsFadeDistance, ref pOutputCameraColor);
		}

		public bool AreBoundsVisible()
		{
			return FnTable.AreBoundsVisible();
		}

		public void ForceBoundsVisible(bool bForce)
		{
			FnTable.ForceBoundsVisible(bForce);
		}
	}
	public class CVRChaperoneSetup
	{
		private IVRChaperoneSetup FnTable;

		internal CVRChaperoneSetup(IntPtr pInterface)
		{
			FnTable = (IVRChaperoneSetup)Marshal.PtrToStructure(pInterface, typeof(IVRChaperoneSetup));
		}

		public bool CommitWorkingCopy(EChaperoneConfigFile configFile)
		{
			return FnTable.CommitWorkingCopy(configFile);
		}

		public void RevertWorkingCopy()
		{
			FnTable.RevertWorkingCopy();
		}

		public bool GetWorkingPlayAreaSize(ref float pSizeX, ref float pSizeZ)
		{
			pSizeX = 0f;
			pSizeZ = 0f;
			return FnTable.GetWorkingPlayAreaSize(ref pSizeX, ref pSizeZ);
		}

		public bool GetWorkingPlayAreaRect(ref HmdQuad_t rect)
		{
			return FnTable.GetWorkingPlayAreaRect(ref rect);
		}

		public bool GetWorkingCollisionBoundsInfo(out HmdQuad_t[] pQuadsBuffer)
		{
			uint punQuadsCount = 0u;
			FnTable.GetWorkingCollisionBoundsInfo(null, ref punQuadsCount);
			pQuadsBuffer = new HmdQuad_t[punQuadsCount];
			return FnTable.GetWorkingCollisionBoundsInfo(pQuadsBuffer, ref punQuadsCount);
		}

		public bool GetLiveCollisionBoundsInfo(out HmdQuad_t[] pQuadsBuffer)
		{
			uint punQuadsCount = 0u;
			FnTable.GetLiveCollisionBoundsInfo(null, ref punQuadsCount);
			pQuadsBuffer = new HmdQuad_t[punQuadsCount];
			return FnTable.GetLiveCollisionBoundsInfo(pQuadsBuffer, ref punQuadsCount);
		}

		public bool GetWorkingSeatedZeroPoseToRawTrackingPose(ref HmdMatrix34_t pmatSeatedZeroPoseToRawTrackingPose)
		{
			return FnTable.GetWorkingSeatedZeroPoseToRawTrackingPose(ref pmatSeatedZeroPoseToRawTrackingPose);
		}

		public bool GetWorkingStandingZeroPoseToRawTrackingPose(ref HmdMatrix34_t pmatStandingZeroPoseToRawTrackingPose)
		{
			return FnTable.GetWorkingStandingZeroPoseToRawTrackingPose(ref pmatStandingZeroPoseToRawTrackingPose);
		}

		public void SetWorkingPlayAreaSize(float sizeX, float sizeZ)
		{
			FnTable.SetWorkingPlayAreaSize(sizeX, sizeZ);
		}

		public void SetWorkingCollisionBoundsInfo(HmdQuad_t[] pQuadsBuffer)
		{
			FnTable.SetWorkingCollisionBoundsInfo(pQuadsBuffer, (uint)pQuadsBuffer.Length);
		}

		public void SetWorkingSeatedZeroPoseToRawTrackingPose(ref HmdMatrix34_t pMatSeatedZeroPoseToRawTrackingPose)
		{
			FnTable.SetWorkingSeatedZeroPoseToRawTrackingPose(ref pMatSeatedZeroPoseToRawTrackingPose);
		}

		public void SetWorkingStandingZeroPoseToRawTrackingPose(ref HmdMatrix34_t pMatStandingZeroPoseToRawTrackingPose)
		{
			FnTable.SetWorkingStandingZeroPoseToRawTrackingPose(ref pMatStandingZeroPoseToRawTrackingPose);
		}

		public void ReloadFromDisk(EChaperoneConfigFile configFile)
		{
			FnTable.ReloadFromDisk(configFile);
		}

		public bool GetLiveSeatedZeroPoseToRawTrackingPose(ref HmdMatrix34_t pmatSeatedZeroPoseToRawTrackingPose)
		{
			return FnTable.GetLiveSeatedZeroPoseToRawTrackingPose(ref pmatSeatedZeroPoseToRawTrackingPose);
		}

		public void SetWorkingCollisionBoundsTagsInfo(byte[] pTagsBuffer)
		{
			FnTable.SetWorkingCollisionBoundsTagsInfo(pTagsBuffer, (uint)pTagsBuffer.Length);
		}

		public bool GetLiveCollisionBoundsTagsInfo(out byte[] pTagsBuffer)
		{
			uint punTagCount = 0u;
			FnTable.GetLiveCollisionBoundsTagsInfo(null, ref punTagCount);
			pTagsBuffer = new byte[punTagCount];
			return FnTable.GetLiveCollisionBoundsTagsInfo(pTagsBuffer, ref punTagCount);
		}

		public bool SetWorkingPhysicalBoundsInfo(HmdQuad_t[] pQuadsBuffer)
		{
			return FnTable.SetWorkingPhysicalBoundsInfo(pQuadsBuffer, (uint)pQuadsBuffer.Length);
		}

		public bool GetLivePhysicalBoundsInfo(out HmdQuad_t[] pQuadsBuffer)
		{
			uint punQuadsCount = 0u;
			FnTable.GetLivePhysicalBoundsInfo(null, ref punQuadsCount);
			pQuadsBuffer = new HmdQuad_t[punQuadsCount];
			return FnTable.GetLivePhysicalBoundsInfo(pQuadsBuffer, ref punQuadsCount);
		}

		public bool ExportLiveToBuffer(StringBuilder pBuffer, ref uint pnBufferLength)
		{
			pnBufferLength = 0u;
			return FnTable.ExportLiveToBuffer(pBuffer, ref pnBufferLength);
		}

		public bool ImportFromBufferToWorking(string pBuffer, uint nImportFlags)
		{
			return FnTable.ImportFromBufferToWorking(pBuffer, nImportFlags);
		}
	}
	public class CVRCompositor
	{
		private IVRCompositor FnTable;

		internal CVRCompositor(IntPtr pInterface)
		{
			FnTable = (IVRCompositor)Marshal.PtrToStructure(pInterface, typeof(IVRCompositor));
		}

		public void SetTrackingSpace(ETrackingUniverseOrigin eOrigin)
		{
			FnTable.SetTrackingSpace(eOrigin);
		}

		public ETrackingUniverseOrigin GetTrackingSpace()
		{
			return FnTable.GetTrackingSpace();
		}

		public EVRCompositorError WaitGetPoses(TrackedDevicePose_t[] pRenderPoseArray, TrackedDevicePose_t[] pGamePoseArray)
		{
			return FnTable.WaitGetPoses(pRenderPoseArray, (uint)pRenderPoseArray.Length, pGamePoseArray, (uint)pGamePoseArray.Length);
		}

		public EVRCompositorError GetLastPoses(TrackedDevicePose_t[] pRenderPoseArray, TrackedDevicePose_t[] pGamePoseArray)
		{
			return FnTable.GetLastPoses(pRenderPoseArray, (uint)pRenderPoseArray.Length, pGamePoseArray, (uint)pGamePoseArray.Length);
		}

		public EVRCompositorError GetLastPoseForTrackedDeviceIndex(uint unDeviceIndex, ref TrackedDevicePose_t pOutputPose, ref TrackedDevicePose_t pOutputGamePose)
		{
			return FnTable.GetLastPoseForTrackedDeviceIndex(unDeviceIndex, ref pOutputPose, ref pOutputGamePose);
		}

		public EVRCompositorError Submit(EVREye eEye, ref Texture_t pTexture, ref VRTextureBounds_t pBounds, EVRSubmitFlags nSubmitFlags)
		{
			return FnTable.Submit(eEye, ref pTexture, ref pBounds, nSubmitFlags);
		}

		public void ClearLastSubmittedFrame()
		{
			FnTable.ClearLastSubmittedFrame();
		}

		public void PostPresentHandoff()
		{
			FnTable.PostPresentHandoff();
		}

		public bool GetFrameTiming(ref Compositor_FrameTiming pTiming, uint unFramesAgo)
		{
			return FnTable.GetFrameTiming(ref pTiming, unFramesAgo);
		}

		public uint GetFrameTimings(ref Compositor_FrameTiming pTiming, uint nFrames)
		{
			return FnTable.GetFrameTimings(ref pTiming, nFrames);
		}

		public float GetFrameTimeRemaining()
		{
			return FnTable.GetFrameTimeRemaining();
		}

		public void GetCumulativeStats(ref Compositor_CumulativeStats pStats, uint nStatsSizeInBytes)
		{
			FnTable.GetCumulativeStats(ref pStats, nStatsSizeInBytes);
		}

		public void FadeToColor(float fSeconds, float fRed, float fGreen, float fBlue, float fAlpha, bool bBackground)
		{
			FnTable.FadeToColor(fSeconds, fRed, fGreen, fBlue, fAlpha, bBackground);
		}

		public HmdColor_t GetCurrentFadeColor(bool bBackground)
		{
			return FnTable.GetCurrentFadeColor(bBackground);
		}

		public void FadeGrid(float fSeconds, bool bFadeIn)
		{
			FnTable.FadeGrid(fSeconds, bFadeIn);
		}

		public float GetCurrentGridAlpha()
		{
			return FnTable.GetCurrentGridAlpha();
		}

		public EVRCompositorError SetSkyboxOverride(Texture_t[] pTextures)
		{
			return FnTable.SetSkyboxOverride(pTextures, (uint)pTextures.Length);
		}

		public void ClearSkyboxOverride()
		{
			FnTable.ClearSkyboxOverride();
		}

		public void CompositorBringToFront()
		{
			FnTable.CompositorBringToFront();
		}

		public void CompositorGoToBack()
		{
			FnTable.CompositorGoToBack();
		}

		public void CompositorQuit()
		{
			FnTable.CompositorQuit();
		}

		public bool IsFullscreen()
		{
			return FnTable.IsFullscreen();
		}

		public uint GetCurrentSceneFocusProcess()
		{
			return FnTable.GetCurrentSceneFocusProcess();
		}

		public uint GetLastFrameRenderer()
		{
			return FnTable.GetLastFrameRenderer();
		}

		public bool CanRenderScene()
		{
			return FnTable.CanRenderScene();
		}

		public void ShowMirrorWindow()
		{
			FnTable.ShowMirrorWindow();
		}

		public void HideMirrorWindow()
		{
			FnTable.HideMirrorWindow();
		}

		public bool IsMirrorWindowVisible()
		{
			return FnTable.IsMirrorWindowVisible();
		}

		public void CompositorDumpImages()
		{
			FnTable.CompositorDumpImages();
		}

		public bool ShouldAppRenderWithLowResources()
		{
			return FnTable.ShouldAppRenderWithLowResources();
		}

		public void ForceInterleavedReprojectionOn(bool bOverride)
		{
			FnTable.ForceInterleavedReprojectionOn(bOverride);
		}

		public void ForceReconnectProcess()
		{
			FnTable.ForceReconnectProcess();
		}

		public void SuspendRendering(bool bSuspend)
		{
			FnTable.SuspendRendering(bSuspend);
		}

		public EVRCompositorError GetMirrorTextureD3D11(EVREye eEye, IntPtr pD3D11DeviceOrResource, ref IntPtr ppD3D11ShaderResourceView)
		{
			return FnTable.GetMirrorTextureD3D11(eEye, pD3D11DeviceOrResource, ref ppD3D11ShaderResourceView);
		}

		public void ReleaseMirrorTextureD3D11(IntPtr pD3D11ShaderResourceView)
		{
			FnTable.ReleaseMirrorTextureD3D11(pD3D11ShaderResourceView);
		}

		public EVRCompositorError GetMirrorTextureGL(EVREye eEye, ref uint pglTextureId, IntPtr pglSharedTextureHandle)
		{
			pglTextureId = 0u;
			return FnTable.GetMirrorTextureGL(eEye, ref pglTextureId, pglSharedTextureHandle);
		}

		public bool ReleaseSharedGLTexture(uint glTextureId, IntPtr glSharedTextureHandle)
		{
			return FnTable.ReleaseSharedGLTexture(glTextureId, glSharedTextureHandle);
		}

		public void LockGLSharedTextureForAccess(IntPtr glSharedTextureHandle)
		{
			FnTable.LockGLSharedTextureForAccess(glSharedTextureHandle);
		}

		public void UnlockGLSharedTextureForAccess(IntPtr glSharedTextureHandle)
		{
			FnTable.UnlockGLSharedTextureForAccess(glSharedTextureHandle);
		}

		public uint GetVulkanInstanceExtensionsRequired(StringBuilder pchValue, uint unBufferSize)
		{
			return FnTable.GetVulkanInstanceExtensionsRequired(pchValue, unBufferSize);
		}

		public uint GetVulkanDeviceExtensionsRequired(IntPtr pPhysicalDevice, StringBuilder pchValue, uint unBufferSize)
		{
			return FnTable.GetVulkanDeviceExtensionsRequired(pPhysicalDevice, pchValue, unBufferSize);
		}

		public void SetExplicitTimingMode(EVRCompositorTimingMode eTimingMode)
		{
			FnTable.SetExplicitTimingMode(eTimingMode);
		}

		public EVRCompositorError SubmitExplicitTimingData()
		{
			return FnTable.SubmitExplicitTimingData();
		}
	}
	public class CVROverlay
	{
		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _PollNextOverlayEventPacked(ulong ulOverlayHandle, ref VREvent_t_Packed pEvent, uint uncbVREvent);

		[StructLayout(LayoutKind.Explicit)]
		private struct PollNextOverlayEventUnion
		{
			[FieldOffset(0)]
			public IVROverlay._PollNextOverlayEvent pPollNextOverlayEvent;

			[FieldOffset(0)]
			public _PollNextOverlayEventPacked pPollNextOverlayEventPacked;
		}

		private IVROverlay FnTable;

		internal CVROverlay(IntPtr pInterface)
		{
			FnTable = (IVROverlay)Marshal.PtrToStructure(pInterface, typeof(IVROverlay));
		}

		public EVROverlayError FindOverlay(string pchOverlayKey, ref ulong pOverlayHandle)
		{
			pOverlayHandle = 0uL;
			return FnTable.FindOverlay(pchOverlayKey, ref pOverlayHandle);
		}

		public EVROverlayError CreateOverlay(string pchOverlayKey, string pchOverlayName, ref ulong pOverlayHandle)
		{
			pOverlayHandle = 0uL;
			return FnTable.CreateOverlay(pchOverlayKey, pchOverlayName, ref pOverlayHandle);
		}

		public EVROverlayError DestroyOverlay(ulong ulOverlayHandle)
		{
			return FnTable.DestroyOverlay(ulOverlayHandle);
		}

		public EVROverlayError SetHighQualityOverlay(ulong ulOverlayHandle)
		{
			return FnTable.SetHighQualityOverlay(ulOverlayHandle);
		}

		public ulong GetHighQualityOverlay()
		{
			return FnTable.GetHighQualityOverlay();
		}

		public uint GetOverlayKey(ulong ulOverlayHandle, StringBuilder pchValue, uint unBufferSize, ref EVROverlayError pError)
		{
			return FnTable.GetOverlayKey(ulOverlayHandle, pchValue, unBufferSize, ref pError);
		}

		public uint GetOverlayName(ulong ulOverlayHandle, StringBuilder pchValue, uint unBufferSize, ref EVROverlayError pError)
		{
			return FnTable.GetOverlayName(ulOverlayHandle, pchValue, unBufferSize, ref pError);
		}

		public EVROverlayError SetOverlayName(ulong ulOverlayHandle, string pchName)
		{
			return FnTable.SetOverlayName(ulOverlayHandle, pchName);
		}

		public EVROverlayError GetOverlayImageData(ulong ulOverlayHandle, IntPtr pvBuffer, uint unBufferSize, ref uint punWidth, ref uint punHeight)
		{
			punWidth = 0u;
			punHeight = 0u;
			return FnTable.GetOverlayImageData(ulOverlayHandle, pvBuffer, unBufferSize, ref punWidth, ref punHeight);
		}

		public string GetOverlayErrorNameFromEnum(EVROverlayError error)
		{
			return Marshal.PtrToStringAnsi(FnTable.GetOverlayErrorNameFromEnum(error));
		}

		public EVROverlayError SetOverlayRenderingPid(ulong ulOverlayHandle, uint unPID)
		{
			return FnTable.SetOverlayRenderingPid(ulOverlayHandle, unPID);
		}

		public uint GetOverlayRenderingPid(ulong ulOverlayHandle)
		{
			return FnTable.GetOverlayRenderingPid(ulOverlayHandle);
		}

		public EVROverlayError SetOverlayFlag(ulong ulOverlayHandle, VROverlayFlags eOverlayFlag, bool bEnabled)
		{
			return FnTable.SetOverlayFlag(ulOverlayHandle, eOverlayFlag, bEnabled);
		}

		public EVROverlayError GetOverlayFlag(ulong ulOverlayHandle, VROverlayFlags eOverlayFlag, ref bool pbEnabled)
		{
			pbEnabled = false;
			return FnTable.GetOverlayFlag(ulOverlayHandle, eOverlayFlag, ref pbEnabled);
		}

		public EVROverlayError SetOverlayColor(ulong ulOverlayHandle, float fRed, float fGreen, float fBlue)
		{
			return FnTable.SetOverlayColor(ulOverlayHandle, fRed, fGreen, fBlue);
		}

		public EVROverlayError GetOverlayColor(ulong ulOverlayHandle, ref float pfRed, ref float pfGreen, ref float pfBlue)
		{
			pfRed = 0f;
			pfGreen = 0f;
			pfBlue = 0f;
			return FnTable.GetOverlayColor(ulOverlayHandle, ref pfRed, ref pfGreen, ref pfBlue);
		}

		public EVROverlayError SetOverlayAlpha(ulong ulOverlayHandle, float fAlpha)
		{
			return FnTable.SetOverlayAlpha(ulOverlayHandle, fAlpha);
		}

		public EVROverlayError GetOverlayAlpha(ulong ulOverlayHandle, ref float pfAlpha)
		{
			pfAlpha = 0f;
			return FnTable.GetOverlayAlpha(ulOverlayHandle, ref pfAlpha);
		}

		public EVROverlayError SetOverlayTexelAspect(ulong ulOverlayHandle, float fTexelAspect)
		{
			return FnTable.SetOverlayTexelAspect(ulOverlayHandle, fTexelAspect);
		}

		public EVROverlayError GetOverlayTexelAspect(ulong ulOverlayHandle, ref float pfTexelAspect)
		{
			pfTexelAspect = 0f;
			return FnTable.GetOverlayTexelAspect(ulOverlayHandle, ref pfTexelAspect);
		}

		public EVROverlayError SetOverlaySortOrder(ulong ulOverlayHandle, uint unSortOrder)
		{
			return FnTable.SetOverlaySortOrder(ulOverlayHandle, unSortOrder);
		}

		public EVROverlayError GetOverlaySortOrder(ulong ulOverlayHandle, ref uint punSortOrder)
		{
			punSortOrder = 0u;
			return FnTable.GetOverlaySortOrder(ulOverlayHandle, ref punSortOrder);
		}

		public EVROverlayError SetOverlayWidthInMeters(ulong ulOverlayHandle, float fWidthInMeters)
		{
			return FnTable.SetOverlayWidthInMeters(ulOverlayHandle, fWidthInMeters);
		}

		public EVROverlayError GetOverlayWidthInMeters(ulong ulOverlayHandle, ref float pfWidthInMeters)
		{
			pfWidthInMeters = 0f;
			return FnTable.GetOverlayWidthInMeters(ulOverlayHandle, ref pfWidthInMeters);
		}

		public EVROverlayError SetOverlayAutoCurveDistanceRangeInMeters(ulong ulOverlayHandle, float fMinDistanceInMeters, float fMaxDistanceInMeters)
		{
			return FnTable.SetOverlayAutoCurveDistanceRangeInMeters(ulOverlayHandle, fMinDistanceInMeters, fMaxDistanceInMeters);
		}

		public EVROverlayError GetOverlayAutoCurveDistanceRangeInMeters(ulong ulOverlayHandle, ref float pfMinDistanceInMeters, ref float pfMaxDistanceInMeters)
		{
			pfMinDistanceInMeters = 0f;
			pfMaxDistanceInMeters = 0f;
			return FnTable.GetOverlayAutoCurveDistanceRangeInMeters(ulOverlayHandle, ref pfMinDistanceInMeters, ref pfMaxDistanceInMeters);
		}

		public EVROverlayError SetOverlayTextureColorSpace(ulong ulOverlayHandle, EColorSpace eTextureColorSpace)
		{
			return FnTable.SetOverlayTextureColorSpace(ulOverlayHandle, eTextureColorSpace);
		}

		public EVROverlayError GetOverlayTextureColorSpace(ulong ulOverlayHandle, ref EColorSpace peTextureColorSpace)
		{
			return FnTable.GetOverlayTextureColorSpace(ulOverlayHandle, ref peTextureColorSpace);
		}

		public EVROverlayError SetOverlayTextureBounds(ulong ulOverlayHandle, ref VRTextureBounds_t pOverlayTextureBounds)
		{
			return FnTable.SetOverlayTextureBounds(ulOverlayHandle, ref pOverlayTextureBounds);
		}

		public EVROverlayError GetOverlayTextureBounds(ulong ulOverlayHandle, ref VRTextureBounds_t pOverlayTextureBounds)
		{
			return FnTable.GetOverlayTextureBounds(ulOverlayHandle, ref pOverlayTextureBounds);
		}

		public uint GetOverlayRenderModel(ulong ulOverlayHandle, StringBuilder pchValue, uint unBufferSize, ref HmdColor_t pColor, ref EVROverlayError pError)
		{
			return FnTable.GetOverlayRenderModel(ulOverlayHandle, pchValue, unBufferSize, ref pColor, ref pError);
		}

		public EVROverlayError SetOverlayRenderModel(ulong ulOverlayHandle, string pchRenderModel, ref HmdColor_t pColor)
		{
			return FnTable.SetOverlayRenderModel(ulOverlayHandle, pchRenderModel, ref pColor);
		}

		public EVROverlayError GetOverlayTransformType(ulong ulOverlayHandle, ref VROverlayTransformType peTransformType)
		{
			return FnTable.GetOverlayTransformType(ulOverlayHandle, ref peTransformType);
		}

		public EVROverlayError SetOverlayTransformAbsolute(ulong ulOverlayHandle, ETrackingUniverseOrigin eTrackingOrigin, ref HmdMatrix34_t pmatTrackingOriginToOverlayTransform)
		{
			return FnTable.SetOverlayTransformAbsolute(ulOverlayHandle, eTrackingOrigin, ref pmatTrackingOriginToOverlayTransform);
		}

		public EVROverlayError GetOverlayTransformAbsolute(ulong ulOverlayHandle, ref ETrackingUniverseOrigin peTrackingOrigin, ref HmdMatrix34_t pmatTrackingOriginToOverlayTransform)
		{
			return FnTable.GetOverlayTransformAbsolute(ulOverlayHandle, ref peTrackingOrigin, ref pmatTrackingOriginToOverlayTransform);
		}

		public EVROverlayError SetOverlayTransformTrackedDeviceRelative(ulong ulOverlayHandle, uint unTrackedDevice, ref HmdMatrix34_t pmatTrackedDeviceToOverlayTransform)
		{
			return FnTable.SetOverlayTransformTrackedDeviceRelative(ulOverlayHandle, unTrackedDevice, ref pmatTrackedDeviceToOverlayTransform);
		}

		public EVROverlayError GetOverlayTransformTrackedDeviceRelative(ulong ulOverlayHandle, ref uint punTrackedDevice, ref HmdMatrix34_t pmatTrackedDeviceToOverlayTransform)
		{
			punTrackedDevice = 0u;
			return FnTable.GetOverlayTransformTrackedDeviceRelative(ulOverlayHandle, ref punTrackedDevice, ref pmatTrackedDeviceToOverlayTransform);
		}

		public EVROverlayError SetOverlayTransformTrackedDeviceComponent(ulong ulOverlayHandle, uint unDeviceIndex, string pchComponentName)
		{
			return FnTable.SetOverlayTransformTrackedDeviceComponent(ulOverlayHandle, unDeviceIndex, pchComponentName);
		}

		public EVROverlayError GetOverlayTransformTrackedDeviceComponent(ulong ulOverlayHandle, ref uint punDeviceIndex, StringBuilder pchComponentName, uint unComponentNameSize)
		{
			punDeviceIndex = 0u;
			return FnTable.GetOverlayTransformTrackedDeviceComponent(ulOverlayHandle, ref punDeviceIndex, pchComponentName, unComponentNameSize);
		}

		public EVROverlayError GetOverlayTransformOverlayRelative(ulong ulOverlayHandle, ref ulong ulOverlayHandleParent, ref HmdMatrix34_t pmatParentOverlayToOverlayTransform)
		{
			ulOverlayHandleParent = 0uL;
			return FnTable.GetOverlayTransformOverlayRelative(ulOverlayHandle, ref ulOverlayHandleParent, ref pmatParentOverlayToOverlayTransform);
		}

		public EVROverlayError SetOverlayTransformOverlayRelative(ulong ulOverlayHandle, ulong ulOverlayHandleParent, ref HmdMatrix34_t pmatParentOverlayToOverlayTransform)
		{
			return FnTable.SetOverlayTransformOverlayRelative(ulOverlayHandle, ulOverlayHandleParent, ref pmatParentOverlayToOverlayTransform);
		}

		public EVROverlayError ShowOverlay(ulong ulOverlayHandle)
		{
			return FnTable.ShowOverlay(ulOverlayHandle);
		}

		public EVROverlayError HideOverlay(ulong ulOverlayHandle)
		{
			return FnTable.HideOverlay(ulOverlayHandle);
		}

		public bool IsOverlayVisible(ulong ulOverlayHandle)
		{
			return FnTable.IsOverlayVisible(ulOverlayHandle);
		}

		public EVROverlayError GetTransformForOverlayCoordinates(ulong ulOverlayHandle, ETrackingUniverseOrigin eTrackingOrigin, HmdVector2_t coordinatesInOverlay, ref HmdMatrix34_t pmatTransform)
		{
			return FnTable.GetTransformForOverlayCoordinates(ulOverlayHandle, eTrackingOrigin, coordinatesInOverlay, ref pmatTransform);
		}

		public bool PollNextOverlayEvent(ulong ulOverlayHandle, ref VREvent_t pEvent, uint uncbVREvent)
		{
			if (Environment.OSVersion.Platform == PlatformID.MacOSX || Environment.OSVersion.Platform == PlatformID.Unix)
			{
				VREvent_t_Packed pEvent2 = default(VREvent_t_Packed);
				PollNextOverlayEventUnion pollNextOverlayEventUnion = default(PollNextOverlayEventUnion);
				pollNextOverlayEventUnion.pPollNextOverlayEventPacked = null;
				pollNextOverlayEventUnion.pPollNextOverlayEvent = FnTable.PollNextOverlayEvent;
				bool result = pollNextOverlayEventUnion.pPollNextOverlayEventPacked(ulOverlayHandle, ref pEvent2, (uint)Marshal.SizeOf(typeof(VREvent_t_Packed)));
				pEvent2.Unpack(ref pEvent);
				return result;
			}
			return FnTable.PollNextOverlayEvent(ulOverlayHandle, ref pEvent, uncbVREvent);
		}

		public EVROverlayError GetOverlayInputMethod(ulong ulOverlayHandle, ref VROverlayInputMethod peInputMethod)
		{
			return FnTable.GetOverlayInputMethod(ulOverlayHandle, ref peInputMethod);
		}

		public EVROverlayError SetOverlayInputMethod(ulong ulOverlayHandle, VROverlayInputMethod eInputMethod)
		{
			return FnTable.SetOverlayInputMethod(ulOverlayHandle, eInputMethod);
		}

		public EVROverlayError GetOverlayMouseScale(ulong ulOverlayHandle, ref HmdVector2_t pvecMouseScale)
		{
			return FnTable.GetOverlayMouseScale(ulOverlayHandle, ref pvecMouseScale);
		}

		public EVROverlayError SetOverlayMouseScale(ulong ulOverlayHandle, ref HmdVector2_t pvecMouseScale)
		{
			return FnTable.SetOverlayMouseScale(ulOverlayHandle, ref pvecMouseScale);
		}

		public bool ComputeOverlayIntersection(ulong ulOverlayHandle, ref VROverlayIntersectionParams_t pParams, ref VROverlayIntersectionResults_t pResults)
		{
			return FnTable.ComputeOverlayIntersection(ulOverlayHandle, ref pParams, ref pResults);
		}

		public bool IsHoverTargetOverlay(ulong ulOverlayHandle)
		{
			return FnTable.IsHoverTargetOverlay(ulOverlayHandle);
		}

		public ulong GetGamepadFocusOverlay()
		{
			return FnTable.GetGamepadFocusOverlay();
		}

		public EVROverlayError SetGamepadFocusOverlay(ulong ulNewFocusOverlay)
		{
			return FnTable.SetGamepadFocusOverlay(ulNewFocusOverlay);
		}

		public EVROverlayError SetOverlayNeighbor(EOverlayDirection eDirection, ulong ulFrom, ulong ulTo)
		{
			return FnTable.SetOverlayNeighbor(eDirection, ulFrom, ulTo);
		}

		public EVROverlayError MoveGamepadFocusToNeighbor(EOverlayDirection eDirection, ulong ulFrom)
		{
			return FnTable.MoveGamepadFocusToNeighbor(eDirection, ulFrom);
		}

		public EVROverlayError SetOverlayDualAnalogTransform(ulong ulOverlay, EDualAnalogWhich eWhich, IntPtr vCenter, float fRadius)
		{
			return FnTable.SetOverlayDualAnalogTransform(ulOverlay, eWhich, vCenter, fRadius);
		}

		public EVROverlayError GetOverlayDualAnalogTransform(ulong ulOverlay, EDualAnalogWhich eWhich, ref HmdVector2_t pvCenter, ref float pfRadius)
		{
			pfRadius = 0f;
			return FnTable.GetOverlayDualAnalogTransform(ulOverlay, eWhich, ref pvCenter, ref pfRadius);
		}

		public EVROverlayError SetOverlayTexture(ulong ulOverlayHandle, ref Texture_t pTexture)
		{
			return FnTable.SetOverlayTexture(ulOverlayHandle, ref pTexture);
		}

		public EVROverlayError ClearOverlayTexture(ulong ulOverlayHandle)
		{
			return FnTable.ClearOverlayTexture(ulOverlayHandle);
		}

		public EVROverlayError SetOverlayRaw(ulong ulOverlayHandle, IntPtr pvBuffer, uint unWidth, uint unHeight, uint unDepth)
		{
			return FnTable.SetOverlayRaw(ulOverlayHandle, pvBuffer, unWidth, unHeight, unDepth);
		}

		public EVROverlayError SetOverlayFromFile(ulong ulOverlayHandle, string pchFilePath)
		{
			return FnTable.SetOverlayFromFile(ulOverlayHandle, pchFilePath);
		}

		public EVROverlayError GetOverlayTexture(ulong ulOverlayHandle, ref IntPtr pNativeTextureHandle, IntPtr pNativeTextureRef, ref uint pWidth, ref uint pHeight, ref uint pNativeFormat, ref ETextureType pAPIType, ref EColorSpace pColorSpace, ref VRTextureBounds_t pTextureBounds)
		{
			pWidth = 0u;
			pHeight = 0u;
			pNativeFormat = 0u;
			return FnTable.GetOverlayTexture(ulOverlayHandle, ref pNativeTextureHandle, pNativeTextureRef, ref pWidth, ref pHeight, ref pNativeFormat, ref pAPIType, ref pColorSpace, ref pTextureBounds);
		}

		public EVROverlayError ReleaseNativeOverlayHandle(ulong ulOverlayHandle, IntPtr pNativeTextureHandle)
		{
			return FnTable.ReleaseNativeOverlayHandle(ulOverlayHandle, pNativeTextureHandle);
		}

		public EVROverlayError GetOverlayTextureSize(ulong ulOverlayHandle, ref uint pWidth, ref uint pHeight)
		{
			pWidth = 0u;
			pHeight = 0u;
			return FnTable.GetOverlayTextureSize(ulOverlayHandle, ref pWidth, ref pHeight);
		}

		public EVROverlayError CreateDashboardOverlay(string pchOverlayKey, string pchOverlayFriendlyName, ref ulong pMainHandle, ref ulong pThumbnailHandle)
		{
			pMainHandle = 0uL;
			pThumbnailHandle = 0uL;
			return FnTable.CreateDashboardOverlay(pchOverlayKey, pchOverlayFriendlyName, ref pMainHandle, ref pThumbnailHandle);
		}

		public bool IsDashboardVisible()
		{
			return FnTable.IsDashboardVisible();
		}

		public bool IsActiveDashboardOverlay(ulong ulOverlayHandle)
		{
			return FnTable.IsActiveDashboardOverlay(ulOverlayHandle);
		}

		public EVROverlayError SetDashboardOverlaySceneProcess(ulong ulOverlayHandle, uint unProcessId)
		{
			return FnTable.SetDashboardOverlaySceneProcess(ulOverlayHandle, unProcessId);
		}

		public EVROverlayError GetDashboardOverlaySceneProcess(ulong ulOverlayHandle, ref uint punProcessId)
		{
			punProcessId = 0u;
			return FnTable.GetDashboardOverlaySceneProcess(ulOverlayHandle, ref punProcessId);
		}

		public void ShowDashboard(string pchOverlayToShow)
		{
			FnTable.ShowDashboard(pchOverlayToShow);
		}

		public uint GetPrimaryDashboardDevice()
		{
			return FnTable.GetPrimaryDashboardDevice();
		}

		public EVROverlayError ShowKeyboard(int eInputMode, int eLineInputMode, string pchDescription, uint unCharMax, string pchExistingText, bool bUseMinimalMode, ulong uUserValue)
		{
			return FnTable.ShowKeyboard(eInputMode, eLineInputMode, pchDescription, unCharMax, pchExistingText, bUseMinimalMode, uUserValue);
		}

		public EVROverlayError ShowKeyboardForOverlay(ulong ulOverlayHandle, int eInputMode, int eLineInputMode, string pchDescription, uint unCharMax, string pchExistingText, bool bUseMinimalMode, ulong uUserValue)
		{
			return FnTable.ShowKeyboardForOverlay(ulOverlayHandle, eInputMode, eLineInputMode, pchDescription, unCharMax, pchExistingText, bUseMinimalMode, uUserValue);
		}

		public uint GetKeyboardText(StringBuilder pchText, uint cchText)
		{
			return FnTable.GetKeyboardText(pchText, cchText);
		}

		public void HideKeyboard()
		{
			FnTable.HideKeyboard();
		}

		public void SetKeyboardTransformAbsolute(ETrackingUniverseOrigin eTrackingOrigin, ref HmdMatrix34_t pmatTrackingOriginToKeyboardTransform)
		{
			FnTable.SetKeyboardTransformAbsolute(eTrackingOrigin, ref pmatTrackingOriginToKeyboardTransform);
		}

		public void SetKeyboardPositionForOverlay(ulong ulOverlayHandle, HmdRect2_t avoidRect)
		{
			FnTable.SetKeyboardPositionForOverlay(ulOverlayHandle, avoidRect);
		}

		public EVROverlayError SetOverlayIntersectionMask(ulong ulOverlayHandle, ref VROverlayIntersectionMaskPrimitive_t pMaskPrimitives, uint unNumMaskPrimitives, uint unPrimitiveSize)
		{
			return FnTable.SetOverlayIntersectionMask(ulOverlayHandle, ref pMaskPrimitives, unNumMaskPrimitives, unPrimitiveSize);
		}

		public EVROverlayError GetOverlayFlags(ulong ulOverlayHandle, ref uint pFlags)
		{
			pFlags = 0u;
			return FnTable.GetOverlayFlags(ulOverlayHandle, ref pFlags);
		}

		public VRMessageOverlayResponse ShowMessageOverlay(string pchText, string pchCaption, string pchButton0Text, string pchButton1Text, string pchButton2Text, string pchButton3Text)
		{
			return FnTable.ShowMessageOverlay(pchText, pchCaption, pchButton0Text, pchButton1Text, pchButton2Text, pchButton3Text);
		}

		public void CloseMessageOverlay()
		{
			FnTable.CloseMessageOverlay();
		}
	}
	public class CVRRenderModels
	{
		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate bool _GetComponentStatePacked(string pchRenderModelName, string pchComponentName, ref VRControllerState_t_Packed pControllerState, ref RenderModel_ControllerMode_State_t pState, ref RenderModel_ComponentState_t pComponentState);

		[StructLayout(LayoutKind.Explicit)]
		private struct GetComponentStateUnion
		{
			[FieldOffset(0)]
			public IVRRenderModels._GetComponentState pGetComponentState;

			[FieldOffset(0)]
			public _GetComponentStatePacked pGetComponentStatePacked;
		}

		private IVRRenderModels FnTable;

		internal CVRRenderModels(IntPtr pInterface)
		{
			FnTable = (IVRRenderModels)Marshal.PtrToStructure(pInterface, typeof(IVRRenderModels));
		}

		public EVRRenderModelError LoadRenderModel_Async(string pchRenderModelName, ref IntPtr ppRenderModel)
		{
			return FnTable.LoadRenderModel_Async(pchRenderModelName, ref ppRenderModel);
		}

		public void FreeRenderModel(IntPtr pRenderModel)
		{
			FnTable.FreeRenderModel(pRenderModel);
		}

		public EVRRenderModelError LoadTexture_Async(int textureId, ref IntPtr ppTexture)
		{
			return FnTable.LoadTexture_Async(textureId, ref ppTexture);
		}

		public void FreeTexture(IntPtr pTexture)
		{
			FnTable.FreeTexture(pTexture);
		}

		public EVRRenderModelError LoadTextureD3D11_Async(int textureId, IntPtr pD3D11Device, ref IntPtr ppD3D11Texture2D)
		{
			return FnTable.LoadTextureD3D11_Async(textureId, pD3D11Device, ref ppD3D11Texture2D);
		}

		public EVRRenderModelError LoadIntoTextureD3D11_Async(int textureId, IntPtr pDstTexture)
		{
			return FnTable.LoadIntoTextureD3D11_Async(textureId, pDstTexture);
		}

		public void FreeTextureD3D11(IntPtr pD3D11Texture2D)
		{
			FnTable.FreeTextureD3D11(pD3D11Texture2D);
		}

		public uint GetRenderModelName(uint unRenderModelIndex, StringBuilder pchRenderModelName, uint unRenderModelNameLen)
		{
			return FnTable.GetRenderModelName(unRenderModelIndex, pchRenderModelName, unRenderModelNameLen);
		}

		public uint GetRenderModelCount()
		{
			return FnTable.GetRenderModelCount();
		}

		public uint GetComponentCount(string pchRenderModelName)
		{
			return FnTable.GetComponentCount(pchRenderModelName);
		}

		public uint GetComponentName(string pchRenderModelName, uint unComponentIndex, StringBuilder pchComponentName, uint unComponentNameLen)
		{
			return FnTable.GetComponentName(pchRenderModelName, unComponentIndex, pchComponentName, unComponentNameLen);
		}

		public ulong GetComponentButtonMask(string pchRenderModelName, string pchComponentName)
		{
			return FnTable.GetComponentButtonMask(pchRenderModelName, pchComponentName);
		}

		public uint GetComponentRenderModelName(string pchRenderModelName, string pchComponentName, StringBuilder pchComponentRenderModelName, uint unComponentRenderModelNameLen)
		{
			return FnTable.GetComponentRenderModelName(pchRenderModelName, pchComponentName, pchComponentRenderModelName, unComponentRenderModelNameLen);
		}

		public bool GetComponentState(string pchRenderModelName, string pchComponentName, ref VRControllerState_t pControllerState, ref RenderModel_ControllerMode_State_t pState, ref RenderModel_ComponentState_t pComponentState)
		{
			if (Environment.OSVersion.Platform == PlatformID.MacOSX || Environment.OSVersion.Platform == PlatformID.Unix)
			{
				VRControllerState_t_Packed pControllerState2 = new VRControllerState_t_Packed(pControllerState);
				GetComponentStateUnion getComponentStateUnion = default(GetComponentStateUnion);
				getComponentStateUnion.pGetComponentStatePacked = null;
				getComponentStateUnion.pGetComponentState = FnTable.GetComponentState;
				bool result = getComponentStateUnion.pGetComponentStatePacked(pchRenderModelName, pchComponentName, ref pControllerState2, ref pState, ref pComponentState);
				pControllerState2.Unpack(ref pControllerState);
				return result;
			}
			return FnTable.GetComponentState(pchRenderModelName, pchComponentName, ref pControllerState, ref pState, ref pComponentState);
		}

		public bool RenderModelHasComponent(string pchRenderModelName, string pchComponentName)
		{
			return FnTable.RenderModelHasComponent(pchRenderModelName, pchComponentName);
		}

		public uint GetRenderModelThumbnailURL(string pchRenderModelName, StringBuilder pchThumbnailURL, uint unThumbnailURLLen, ref EVRRenderModelError peError)
		{
			return FnTable.GetRenderModelThumbnailURL(pchRenderModelName, pchThumbnailURL, unThumbnailURLLen, ref peError);
		}

		public uint GetRenderModelOriginalPath(string pchRenderModelName, StringBuilder pchOriginalPath, uint unOriginalPathLen, ref EVRRenderModelError peError)
		{
			return FnTable.GetRenderModelOriginalPath(pchRenderModelName, pchOriginalPath, unOriginalPathLen, ref peError);
		}

		public string GetRenderModelErrorNameFromEnum(EVRRenderModelError error)
		{
			return Marshal.PtrToStringAnsi(FnTable.GetRenderModelErrorNameFromEnum(error));
		}
	}
	public class CVRNotifications
	{
		private IVRNotifications FnTable;

		internal CVRNotifications(IntPtr pInterface)
		{
			FnTable = (IVRNotifications)Marshal.PtrToStructure(pInterface, typeof(IVRNotifications));
		}

		public EVRNotificationError CreateNotification(ulong ulOverlayHandle, ulong ulUserValue, EVRNotificationType type, string pchText, EVRNotificationStyle style, ref NotificationBitmap_t pImage, ref uint pNotificationId)
		{
			pNotificationId = 0u;
			return FnTable.CreateNotification(ulOverlayHandle, ulUserValue, type, pchText, style, ref pImage, ref pNotificationId);
		}

		public EVRNotificationError RemoveNotification(uint notificationId)
		{
			return FnTable.RemoveNotification(notificationId);
		}
	}
	public class CVRSettings
	{
		private IVRSettings FnTable;

		internal CVRSettings(IntPtr pInterface)
		{
			FnTable = (IVRSettings)Marshal.PtrToStructure(pInterface, typeof(IVRSettings));
		}

		public string GetSettingsErrorNameFromEnum(EVRSettingsError eError)
		{
			return Marshal.PtrToStringAnsi(FnTable.GetSettingsErrorNameFromEnum(eError));
		}

		public bool Sync(bool bForce, ref EVRSettingsError peError)
		{
			return FnTable.Sync(bForce, ref peError);
		}

		public void SetBool(string pchSection, string pchSettingsKey, bool bValue, ref EVRSettingsError peError)
		{
			FnTable.SetBool(pchSection, pchSettingsKey, bValue, ref peError);
		}

		public void SetInt32(string pchSection, string pchSettingsKey, int nValue, ref EVRSettingsError peError)
		{
			FnTable.SetInt32(pchSection, pchSettingsKey, nValue, ref peError);
		}

		public void SetFloat(string pchSection, string pchSettingsKey, float flValue, ref EVRSettingsError peError)
		{
			FnTable.SetFloat(pchSection, pchSettingsKey, flValue, ref peError);
		}

		public void SetString(string pchSection, string pchSettingsKey, string pchValue, ref EVRSettingsError peError)
		{
			FnTable.SetString(pchSection, pchSettingsKey, pchValue, ref peError);
		}

		public bool GetBool(string pchSection, string pchSettingsKey, ref EVRSettingsError peError)
		{
			return FnTable.GetBool(pchSection, pchSettingsKey, ref peError);
		}

		public int GetInt32(string pchSection, string pchSettingsKey, ref EVRSettingsError peError)
		{
			return FnTable.GetInt32(pchSection, pchSettingsKey, ref peError);
		}

		public float GetFloat(string pchSection, string pchSettingsKey, ref EVRSettingsError peError)
		{
			return FnTable.GetFloat(pchSection, pchSettingsKey, ref peError);
		}

		public void GetString(string pchSection, string pchSettingsKey, StringBuilder pchValue, uint unValueLen, ref EVRSettingsError peError)
		{
			FnTable.GetString(pchSection, pchSettingsKey, pchValue, unValueLen, ref peError);
		}

		public void RemoveSection(string pchSection, ref EVRSettingsError peError)
		{
			FnTable.RemoveSection(pchSection, ref peError);
		}

		public void RemoveKeyInSection(string pchSection, string pchSettingsKey, ref EVRSettingsError peError)
		{
			FnTable.RemoveKeyInSection(pchSection, pchSettingsKey, ref peError);
		}
	}
	public class CVRScreenshots
	{
		private IVRScreenshots FnTable;

		internal CVRScreenshots(IntPtr pInterface)
		{
			FnTable = (IVRScreenshots)Marshal.PtrToStructure(pInterface, typeof(IVRScreenshots));
		}

		public EVRScreenshotError RequestScreenshot(ref uint pOutScreenshotHandle, EVRScreenshotType type, string pchPreviewFilename, string pchVRFilename)
		{
			pOutScreenshotHandle = 0u;
			return FnTable.RequestScreenshot(ref pOutScreenshotHandle, type, pchPreviewFilename, pchVRFilename);
		}

		public EVRScreenshotError HookScreenshot(EVRScreenshotType[] pSupportedTypes)
		{
			return FnTable.HookScreenshot(pSupportedTypes, pSupportedTypes.Length);
		}

		public EVRScreenshotType GetScreenshotPropertyType(uint screenshotHandle, ref EVRScreenshotError pError)
		{
			return FnTable.GetScreenshotPropertyType(screenshotHandle, ref pError);
		}

		public uint GetScreenshotPropertyFilename(uint screenshotHandle, EVRScreenshotPropertyFilenames filenameType, StringBuilder pchFilename, uint cchFilename, ref EVRScreenshotError pError)
		{
			return FnTable.GetScreenshotPropertyFilename(screenshotHandle, filenameType, pchFilename, cchFilename, ref pError);
		}

		public EVRScreenshotError UpdateScreenshotProgress(uint screenshotHandle, float flProgress)
		{
			return FnTable.UpdateScreenshotProgress(screenshotHandle, flProgress);
		}

		public EVRScreenshotError TakeStereoScreenshot(ref uint pOutScreenshotHandle, string pchPreviewFilename, string pchVRFilename)
		{
			pOutScreenshotHandle = 0u;
			return FnTable.TakeStereoScreenshot(ref pOutScreenshotHandle, pchPreviewFilename, pchVRFilename);
		}

		public EVRScreenshotError SubmitScreenshot(uint screenshotHandle, EVRScreenshotType type, string pchSourcePreviewFilename, string pchSourceVRFilename)
		{
			return FnTable.SubmitScreenshot(screenshotHandle, type, pchSourcePreviewFilename, pchSourceVRFilename);
		}
	}
	public class CVRResources
	{
		private IVRResources FnTable;

		internal CVRResources(IntPtr pInterface)
		{
			FnTable = (IVRResources)Marshal.PtrToStructure(pInterface, typeof(IVRResources));
		}

		public uint LoadSharedResource(string pchResourceName, string pchBuffer, uint unBufferLen)
		{
			return FnTable.LoadSharedResource(pchResourceName, pchBuffer, unBufferLen);
		}

		public uint GetResourceFullPath(string pchResourceName, string pchResourceTypeDirectory, StringBuilder pchPathBuffer, uint unBufferLen)
		{
			return FnTable.GetResourceFullPath(pchResourceName, pchResourceTypeDirectory, pchPathBuffer, unBufferLen);
		}
	}
	public class CVRDriverManager
	{
		private IVRDriverManager FnTable;

		internal CVRDriverManager(IntPtr pInterface)
		{
			FnTable = (IVRDriverManager)Marshal.PtrToStructure(pInterface, typeof(IVRDriverManager));
		}

		public uint GetDriverCount()
		{
			return FnTable.GetDriverCount();
		}

		public uint GetDriverName(uint nDriver, StringBuilder pchValue, uint unBufferSize)
		{
			return FnTable.GetDriverName(nDriver, pchValue, unBufferSize);
		}
	}
	public class OpenVRInterop
	{
		[DllImport("openvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "VR_InitInternal")]
		internal static extern uint InitInternal(ref EVRInitError peError, EVRApplicationType eApplicationType);

		[DllImport("openvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "VR_ShutdownInternal")]
		internal static extern void ShutdownInternal();

		[DllImport("openvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "VR_IsHmdPresent")]
		internal static extern bool IsHmdPresent();

		[DllImport("openvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "VR_IsRuntimeInstalled")]
		internal static extern bool IsRuntimeInstalled();

		[DllImport("openvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "VR_GetStringForHmdError")]
		internal static extern IntPtr GetStringForHmdError(EVRInitError error);

		[DllImport("openvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "VR_GetGenericInterface")]
		internal static extern IntPtr GetGenericInterface([In][MarshalAs(UnmanagedType.LPStr)] string pchInterfaceVersion, ref EVRInitError peError);

		[DllImport("openvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "VR_IsInterfaceVersionValid")]
		internal static extern bool IsInterfaceVersionValid([In][MarshalAs(UnmanagedType.LPStr)] string pchInterfaceVersion);

		[DllImport("openvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "VR_GetInitToken")]
		internal static extern uint GetInitToken();
	}
	public enum EVREye
	{
		Eye_Left,
		Eye_Right
	}
	public enum ETextureType
	{
		DirectX,
		OpenGL,
		Vulkan,
		IOSurface,
		DirectX12
	}
	public enum EColorSpace
	{
		Auto,
		Gamma,
		Linear
	}
	public enum ETrackingResult
	{
		Uninitialized = 1,
		Calibrating_InProgress = 100,
		Calibrating_OutOfRange = 101,
		Running_OK = 200,
		Running_OutOfRange = 201
	}
	public enum ETrackedDeviceClass
	{
		Invalid,
		HMD,
		Controller,
		GenericTracker,
		TrackingReference,
		DisplayRedirect
	}
	public enum ETrackedControllerRole
	{
		Invalid,
		LeftHand,
		RightHand
	}
	public enum ETrackingUniverseOrigin
	{
		TrackingUniverseSeated,
		TrackingUniverseStanding,
		TrackingUniverseRawAndUncalibrated
	}
	public enum ETrackedDeviceProperty
	{
		Prop_Invalid = 0,
		Prop_TrackingSystemName_String = 1000,
		Prop_ModelNumber_String = 1001,
		Prop_SerialNumber_String = 1002,
		Prop_RenderModelName_String = 1003,
		Prop_WillDriftInYaw_Bool = 1004,
		Prop_ManufacturerName_String = 1005,
		Prop_TrackingFirmwareVersion_String = 1006,
		Prop_HardwareRevision_String = 1007,
		Prop_AllWirelessDongleDescriptions_String = 1008,
		Prop_ConnectedWirelessDongle_String = 1009,
		Prop_DeviceIsWireless_Bool = 1010,
		Prop_DeviceIsCharging_Bool = 1011,
		Prop_DeviceBatteryPercentage_Float = 1012,
		Prop_StatusDisplayTransform_Matrix34 = 1013,
		Prop_Firmware_UpdateAvailable_Bool = 1014,
		Prop_Firmware_ManualUpdate_Bool = 1015,
		Prop_Firmware_ManualUpdateURL_String = 1016,
		Prop_HardwareRevision_Uint64 = 1017,
		Prop_FirmwareVersion_Uint64 = 1018,
		Prop_FPGAVersion_Uint64 = 1019,
		Prop_VRCVersion_Uint64 = 1020,
		Prop_RadioVersion_Uint64 = 1021,
		Prop_DongleVersion_Uint64 = 1022,
		Prop_BlockServerShutdown_Bool = 1023,
		Prop_CanUnifyCoordinateSystemWithHmd_Bool = 1024,
		Prop_ContainsProximitySensor_Bool = 1025,
		Prop_DeviceProvidesBatteryStatus_Bool = 1026,
		Prop_DeviceCanPowerOff_Bool = 1027,
		Prop_Firmware_ProgrammingTarget_String = 1028,
		Prop_DeviceClass_Int32 = 1029,
		Prop_HasCamera_Bool = 1030,
		Prop_DriverVersion_String = 1031,
		Prop_Firmware_ForceUpdateRequired_Bool = 1032,
		Prop_ViveSystemButtonFixRequired_Bool = 1033,
		Prop_ParentDriver_Uint64 = 1034,
		Prop_ResourceRoot_String = 1035,
		Prop_RegisteredDeviceType_String = 1036,
		Prop_InputProfilePath_String = 1037,
		Prop_ReportsTimeSinceVSync_Bool = 2000,
		Prop_SecondsFromVsyncToPhotons_Float = 2001,
		Prop_DisplayFrequency_Float = 2002,
		Prop_UserIpdMeters_Float = 2003,
		Prop_CurrentUniverseId_Uint64 = 2004,
		Prop_PreviousUniverseId_Uint64 = 2005,
		Prop_DisplayFirmwareVersion_Uint64 = 2006,
		Prop_IsOnDesktop_Bool = 2007,
		Prop_DisplayMCType_Int32 = 2008,
		Prop_DisplayMCOffset_Float = 2009,
		Prop_DisplayMCScale_Float = 2010,
		Prop_EdidVendorID_Int32 = 2011,
		Prop_DisplayMCImageLeft_String = 2012,
		Prop_DisplayMCImageRight_String = 2013,
		Prop_DisplayGCBlackClamp_Float = 2014,
		Prop_EdidProductID_Int32 = 2015,
		Prop_CameraToHeadTransform_Matrix34 = 2016,
		Prop_DisplayGCType_Int32 = 2017,
		Prop_DisplayGCOffset_Float = 2018,
		Prop_DisplayGCScale_Float = 2019,
		Prop_DisplayGCPrescale_Float = 2020,
		Prop_DisplayGCImage_String = 2021,
		Prop_LensCenterLeftU_Float = 2022,
		Prop_LensCenterLeftV_Float = 2023,
		Prop_LensCenterRightU_Float = 2024,
		Prop_LensCenterRightV_Float = 2025,
		Prop_UserHeadToEyeDepthMeters_Float = 2026,
		Prop_CameraFirmwareVersion_Uint64 = 2027,
		Prop_CameraFirmwareDescription_String = 2028,
		Prop_DisplayFPGAVersion_Uint64 = 2029,
		Prop_DisplayBootloaderVersion_Uint64 = 2030,
		Prop_DisplayHardwareVersion_Uint64 = 2031,
		Prop_AudioFirmwareVersion_Uint64 = 2032,
		Prop_CameraCompatibilityMode_Int32 = 2033,
		Prop_ScreenshotHorizontalFieldOfViewDegrees_Float = 2034,
		Prop_ScreenshotVerticalFieldOfViewDegrees_Float = 2035,
		Prop_DisplaySuppressed_Bool = 2036,
		Prop_DisplayAllowNightMode_Bool = 2037,
		Prop_DisplayMCImageWidth_Int32 = 2038,
		Prop_DisplayMCImageHeight_Int32 = 2039,
		Prop_DisplayMCImageNumChannels_Int32 = 2040,
		Prop_DisplayMCImageData_Binary = 2041,
		Prop_SecondsFromPhotonsToVblank_Float = 2042,
		Prop_DriverDirectModeSendsVsyncEvents_Bool = 2043,
		Prop_DisplayDebugMode_Bool = 2044,
		Prop_GraphicsAdapterLuid_Uint64 = 2045,
		Prop_DriverProvidedChaperonePath_String = 2048,
		Prop_ExpectedTrackingReferenceCount_Int32 = 2049,
		Prop_ExpectedControllerCount_Int32 = 2050,
		Prop_NamedIconPathControllerLeftDeviceOff_String = 2051,
		Prop_NamedIconPathControllerRightDeviceOff_String = 2052,
		Prop_NamedIconPathTrackingReferenceDeviceOff_String = 2053,
		Prop_DoNotApplyPrediction_Bool = 2054,
		Prop_CameraToHeadTransforms_Matrix34_Array = 2055,
		Prop_DriverIsDrawingControllers_Bool = 2057,
		Prop_DriverRequestsApplicationPause_Bool = 2058,
		Prop_DriverRequestsReducedRendering_Bool = 2059,
		Prop_AttachedDeviceId_String = 3000,
		Prop_SupportedButtons_Uint64 = 3001,
		Prop_Axis0Type_Int32 = 3002,
		Prop_Axis1Type_Int32 = 3003,
		Prop_Axis2Type_Int32 = 3004,
		Prop_Axis3Type_Int32 = 3005,
		Prop_Axis4Type_Int32 = 3006,
		Prop_ControllerRoleHint_Int32 = 3007,
		Prop_FieldOfViewLeftDegrees_Float = 4000,
		Prop_FieldOfViewRightDegrees_Float = 4001,
		Prop_FieldOfViewTopDegrees_Float = 4002,
		Prop_FieldOfViewBottomDegrees_Float = 4003,
		Prop_TrackingRangeMinimumMeters_Float = 4004,
		Prop_TrackingRangeMaximumMeters_Float = 4005,
		Prop_ModeLabel_String = 4006,
		Prop_IconPathName_String = 5000,
		Prop_NamedIconPathDeviceOff_String = 5001,
		Prop_NamedIconPathDeviceSearching_String = 5002,
		Prop_NamedIconPathDeviceSearchingAlert_String = 5003,
		Prop_NamedIconPathDeviceReady_String = 5004,
		Prop_NamedIconPathDeviceReadyAlert_String = 5005,
		Prop_NamedIconPathDeviceNotReady_String = 5006,
		Prop_NamedIconPathDeviceStandby_String = 5007,
		Prop_NamedIconPathDeviceAlertLow_String = 5008,
		Prop_DisplayHiddenArea_Binary_Start = 5100,
		Prop_DisplayHiddenArea_Binary_End = 5150,
		Prop_ParentContainer = 5151,
		Prop_UserConfigPath_String = 6000,
		Prop_InstallPath_String = 6001,
		Prop_HasDisplayComponent_Bool = 6002,
		Prop_HasControllerComponent_Bool = 6003,
		Prop_HasCameraComponent_Bool = 6004,
		Prop_HasDriverDirectModeComponent_Bool = 6005,
		Prop_HasVirtualDisplayComponent_Bool = 6006,
		Prop_ControllerType_String = 7000,
		Prop_LegacyInputProfile_String = 7001,
		Prop_VendorSpecific_Reserved_Start = 10000,
		Prop_VendorSpecific_Reserved_End = 10999,
		Prop_TrackedDeviceProperty_Max = 1000000
	}
	public enum ETrackedPropertyError
	{
		TrackedProp_Success,
		TrackedProp_WrongDataType,
		TrackedProp_WrongDeviceClass,
		TrackedProp_BufferTooSmall,
		TrackedProp_UnknownProperty,
		TrackedProp_InvalidDevice,
		TrackedProp_CouldNotContactServer,
		TrackedProp_ValueNotProvidedByDevice,
		TrackedProp_StringExceedsMaximumLength,
		TrackedProp_NotYetAvailable,
		TrackedProp_PermissionDenied,
		TrackedProp_InvalidOperation,
		TrackedProp_CannotWriteToWildcards
	}
	public enum EVRSubmitFlags
	{
		Submit_Default = 0,
		Submit_LensDistortionAlreadyApplied = 1,
		Submit_GlRenderBuffer = 2,
		Submit_Reserved = 4,
		Submit_TextureWithPose = 8,
		Submit_TextureWithDepth = 0x10
	}
	public enum EVRState
	{
		Undefined = -1,
		Off,
		Searching,
		Searching_Alert,
		Ready,
		Ready_Alert,
		NotReady,
		Standby,
		Ready_Alert_Low
	}
	public enum EVREventType
	{
		VREvent_None = 0,
		VREvent_TrackedDeviceActivated = 100,
		VREvent_TrackedDeviceDeactivated = 101,
		VREvent_TrackedDeviceUpdated = 102,
		VREvent_TrackedDeviceUserInteractionStarted = 103,
		VREvent_TrackedDeviceUserInteractionEnded = 104,
		VREvent_IpdChanged = 105,
		VREvent_EnterStandbyMode = 106,
		VREvent_LeaveStandbyMode = 107,
		VREvent_TrackedDeviceRoleChanged = 108,
		VREvent_WatchdogWakeUpRequested = 109,
		VREvent_LensDistortionChanged = 110,
		VREvent_PropertyChanged = 111,
		VREvent_WirelessDisconnect = 112,
		VREvent_WirelessReconnect = 113,
		VREvent_ButtonPress = 200,
		VREvent_ButtonUnpress = 201,
		VREvent_ButtonTouch = 202,
		VREvent_ButtonUntouch = 203,
		VREvent_DualAnalog_Press = 250,
		VREvent_DualAnalog_Unpress = 251,
		VREvent_DualAnalog_Touch = 252,
		VREvent_DualAnalog_Untouch = 253,
		VREvent_DualAnalog_Move = 254,
		VREvent_DualAnalog_ModeSwitch1 = 255,
		VREvent_DualAnalog_ModeSwitch2 = 256,
		VREvent_DualAnalog_Cancel = 257,
		VREvent_MouseMove = 300,
		VREvent_MouseButtonDown = 301,
		VREvent_MouseButtonUp = 302,
		VREvent_FocusEnter = 303,
		VREvent_FocusLeave = 304,
		VREvent_Scroll = 305,
		VREvent_TouchPadMove = 306,
		VREvent_OverlayFocusChanged = 307,
		VREvent_InputFocusCaptured = 400,
		VREvent_InputFocusReleased = 401,
		VREvent_SceneFocusLost = 402,
		VREvent_SceneFocusGained = 403,
		VREvent_SceneApplicationChanged = 404,
		VREvent_SceneFocusChanged = 405,
		VREvent_InputFocusChanged = 406,
		VREvent_SceneApplicationSecondaryRenderingStarted = 407,
		VREvent_HideRenderModels = 410,
		VREvent_ShowRenderModels = 411,
		VREvent_ConsoleOpened = 420,
		VREvent_ConsoleClosed = 421,
		VREvent_OverlayShown = 500,
		VREvent_OverlayHidden = 501,
		VREvent_DashboardActivated = 502,
		VREvent_DashboardDeactivated = 503,
		VREvent_DashboardThumbSelected = 504,
		VREvent_DashboardRequested = 505,
		VREvent_ResetDashboard = 506,
		VREvent_RenderToast = 507,
		VREvent_ImageLoaded = 508,
		VREvent_ShowKeyboard = 509,
		VREvent_HideKeyboard = 510,
		VREvent_OverlayGamepadFocusGained = 511,
		VREvent_OverlayGamepadFocusLost = 512,
		VREvent_OverlaySharedTextureChanged = 513,
		VREvent_DashboardGuideButtonDown = 514,
		VREvent_DashboardGuideButtonUp = 515,
		VREvent_ScreenshotTriggered = 516,
		VREvent_ImageFailed = 517,
		VREvent_DashboardOverlayCreated = 518,
		VREvent_RequestScreenshot = 520,
		VREvent_ScreenshotTaken = 521,
		VREvent_ScreenshotFailed = 522,
		VREvent_SubmitScreenshotToDashboard = 523,
		VREvent_ScreenshotProgressToDashboard = 524,
		VREvent_PrimaryDashboardDeviceChanged = 525,
		VREvent_Notification_Shown = 600,
		VREvent_Notification_Hidden = 601,
		VREvent_Notification_BeginInteraction = 602,
		VREvent_Notification_Destroyed = 603,
		VREvent_Quit = 700,
		VREvent_ProcessQuit = 701,
		VREvent_QuitAborted_UserPrompt = 702,
		VREvent_QuitAcknowledged = 703,
		VREvent_DriverRequestedQuit = 704,
		VREvent_ChaperoneDataHasChanged = 800,
		VREvent_ChaperoneUniverseHasChanged = 801,
		VREvent_ChaperoneTempDataHasChanged = 802,
		VREvent_ChaperoneSettingsHaveChanged = 803,
		VREvent_SeatedZeroPoseReset = 804,
		VREvent_AudioSettingsHaveChanged = 820,
		VREvent_BackgroundSettingHasChanged = 850,
		VREvent_CameraSettingsHaveChanged = 851,
		VREvent_ReprojectionSettingHasChanged = 852,
		VREvent_ModelSkinSettingsHaveChanged = 853,
		VREvent_EnvironmentSettingsHaveChanged = 854,
		VREvent_PowerSettingsHaveChanged = 855,
		VREvent_EnableHomeAppSettingsHaveChanged = 856,
		VREvent_SteamVRSectionSettingChanged = 857,
		VREvent_LighthouseSectionSettingChanged = 858,
		VREvent_NullSectionSettingChanged = 859,
		VREvent_UserInterfaceSectionSettingChanged = 860,
		VREvent_NotificationsSectionSettingChanged = 861,
		VREvent_KeyboardSectionSettingChanged = 862,
		VREvent_PerfSectionSettingChanged = 863,
		VREvent_DashboardSectionSettingChanged = 864,
		VREvent_WebInterfaceSectionSettingChanged = 865,
		VREvent_StatusUpdate = 900,
		VREvent_WebInterface_InstallDriverCompleted = 950,
		VREvent_MCImageUpdated = 1000,
		VREvent_FirmwareUpdateStarted = 1100,
		VREvent_FirmwareUpdateFinished = 1101,
		VREvent_KeyboardClosed = 1200,
		VREvent_KeyboardCharInput = 1201,
		VREvent_KeyboardDone = 1202,
		VREvent_ApplicationTransitionStarted = 1300,
		VREvent_ApplicationTransitionAborted = 1301,
		VREvent_ApplicationTransitionNewAppStarted = 1302,
		VREvent_ApplicationListUpdated = 1303,
		VREvent_ApplicationMimeTypeLoad = 1304,
		VREvent_ApplicationTransitionNewAppLaunchComplete = 1305,
		VREvent_ProcessConnected = 1306,
		VREvent_ProcessDisconnected = 1307,
		VREvent_Compositor_MirrorWindowShown = 1400,
		VREvent_Compositor_MirrorWindowHidden = 1401,
		VREvent_Compositor_ChaperoneBoundsShown = 1410,
		VREvent_Compositor_ChaperoneBoundsHidden = 1411,
		VREvent_TrackedCamera_StartVideoStream = 1500,
		VREvent_TrackedCamera_StopVideoStream = 1501,
		VREvent_TrackedCamera_PauseVideoStream = 1502,
		VREvent_TrackedCamera_ResumeVideoStream = 1503,
		VREvent_TrackedCamera_EditingSurface = 1550,
		VREvent_PerformanceTest_EnableCapture = 1600,
		VREvent_PerformanceTest_DisableCapture = 1601,
		VREvent_PerformanceTest_FidelityLevel = 1602,
		VREvent_MessageOverlay_Closed = 1650,
		VREvent_MessageOverlayCloseRequested = 1651,
		VREvent_Input_HapticVibration = 1700,
		VREvent_VendorSpecific_Reserved_Start = 10000,
		VREvent_VendorSpecific_Reserved_End = 19999
	}
	public enum EDeviceActivityLevel
	{
		k_EDeviceActivityLevel_Unknown = -1,
		k_EDeviceActivityLevel_Idle,
		k_EDeviceActivityLevel_UserInteraction,
		k_EDeviceActivityLevel_UserInteraction_Timeout,
		k_EDeviceActivityLevel_Standby
	}
	public enum EVRButtonId
	{
		k_EButton_System = 0,
		k_EButton_ApplicationMenu = 1,
		k_EButton_Grip = 2,
		k_EButton_DPad_Left = 3,
		k_EButton_DPad_Up = 4,
		k_EButton_DPad_Right = 5,
		k_EButton_DPad_Down = 6,
		k_EButton_A = 7,
		k_EButton_ProximitySensor = 31,
		k_EButton_Axis0 = 32,
		k_EButton_Axis1 = 33,
		k_EButton_Axis2 = 34,
		k_EButton_Axis3 = 35,
		k_EButton_Axis4 = 36,
		k_EButton_SteamVR_Touchpad = 32,
		k_EButton_SteamVR_Trigger = 33,
		k_EButton_Dashboard_Back = 2,
		k_EButton_Max = 64
	}
	public enum EVRMouseButton
	{
		Left = 1,
		Right = 2,
		Middle = 4
	}
	public enum EDualAnalogWhich
	{
		k_EDualAnalog_Left,
		k_EDualAnalog_Right
	}
	public enum EVRInputError
	{
		None,
		NameNotFound,
		WrongType,
		InvalidHandle,
		InvalidParam,
		NoSteam,
		MaxCapacityReached,
		IPCError,
		NoActiveActionSet,
		InvalidDevice
	}
	public enum EHiddenAreaMeshType
	{
		k_eHiddenAreaMesh_Standard,
		k_eHiddenAreaMesh_Inverse,
		k_eHiddenAreaMesh_LineLoop,
		k_eHiddenAreaMesh_Max
	}
	public enum EVRControllerAxisType
	{
		k_eControllerAxis_None,
		k_eControllerAxis_TrackPad,
		k_eControllerAxis_Joystick,
		k_eControllerAxis_Trigger
	}
	public enum EVRControllerEventOutputType
	{
		ControllerEventOutput_OSEvents,
		ControllerEventOutput_VREvents
	}
	public enum ECollisionBoundsStyle
	{
		COLLISION_BOUNDS_STYLE_BEGINNER,
		COLLISION_BOUNDS_STYLE_INTERMEDIATE,
		COLLISION_BOUNDS_STYLE_SQUARES,
		COLLISION_BOUNDS_STYLE_ADVANCED,
		COLLISION_BOUNDS_STYLE_NONE,
		COLLISION_BOUNDS_STYLE_COUNT
	}
	public enum EVROverlayError
	{
		None = 0,
		UnknownOverlay = 10,
		InvalidHandle = 11,
		PermissionDenied = 12,
		OverlayLimitExceeded = 13,
		WrongVisibilityType = 14,
		KeyTooLong = 15,
		NameTooLong = 16,
		KeyInUse = 17,
		WrongTransformType = 18,
		InvalidTrackedDevice = 19,
		InvalidParameter = 20,
		ThumbnailCantBeDestroyed = 21,
		ArrayTooSmall = 22,
		RequestFailed = 23,
		InvalidTexture = 24,
		UnableToLoadFile = 25,
		KeyboardAlreadyInUse = 26,
		NoNeighbor = 27,
		TooManyMaskPrimitives = 29,
		BadMaskPrimitive = 30,
		TextureAlreadyLocked = 31,
		TextureLockCapacityReached = 32,
		TextureNotLocked = 33
	}
	public enum EVRApplicationType
	{
		VRApplication_Other,
		VRApplication_Scene,
		VRApplication_Overlay,
		VRApplication_Background,
		VRApplication_Utility,
		VRApplication_VRMonitor,
		VRApplication_SteamWatchdog,
		VRApplication_Bootstrapper,
		VRApplication_Max
	}
	public enum EVRFirmwareError
	{
		None,
		Success,
		Fail
	}
	public enum EVRNotificationError
	{
		OK = 0,
		InvalidNotificationId = 100,
		NotificationQueueFull = 101,
		InvalidOverlayHandle = 102,
		SystemWithUserValueAlreadyExists = 103
	}
	public enum EVRInitError
	{
		None = 0,
		Unknown = 1,
		Init_InstallationNotFound = 100,
		Init_InstallationCorrupt = 101,
		Init_VRClientDLLNotFound = 102,
		Init_FileNotFound = 103,
		Init_FactoryNotFound = 104,
		Init_InterfaceNotFound = 105,
		Init_InvalidInterface = 106,
		Init_UserConfigDirectoryInvalid = 107,
		Init_HmdNotFound = 108,
		Init_NotInitialized = 109,
		Init_PathRegistryNotFound = 110,
		Init_NoConfigPath = 111,
		Init_NoLogPath = 112,
		Init_PathRegistryNotWritable = 113,
		Init_AppInfoInitFailed = 114,
		Init_Retry = 115,
		Init_InitCanceledByUser = 116,
		Init_AnotherAppLaunching = 117,
		Init_SettingsInitFailed = 118,
		Init_ShuttingDown = 119,
		Init_TooManyObjects = 120,
		Init_NoServerForBackgroundApp = 121,
		Init_NotSupportedWithCompositor = 122,
		Init_NotAvailableToUtilityApps = 123,
		Init_Internal = 124,
		Init_HmdDriverIdIsNone = 125,
		Init_HmdNotFoundPresenceFailed = 126,
		Init_VRMonitorNotFound = 127,
		Init_VRMonitorStartupFailed = 128,
		Init_LowPowerWatchdogNotSupported = 129,
		Init_InvalidApplicationType = 130,
		Init_NotAvailableToWatchdogApps = 131,
		Init_WatchdogDisabledInSettings = 132,
		Init_VRDashboardNotFound = 133,
		Init_VRDashboardStartupFailed = 134,
		Init_VRHomeNotFound = 135,
		Init_VRHomeStartupFailed = 136,
		Init_RebootingBusy = 137,
		Init_FirmwareUpdateBusy = 138,
		Init_FirmwareRecoveryBusy = 139,
		Init_USBServiceBusy = 140,
		Driver_Failed = 200,
		Driver_Unknown = 201,
		Driver_HmdUnknown = 202,
		Driver_NotLoaded = 203,
		Driver_RuntimeOutOfDate = 204,
		Driver_HmdInUse = 205,
		Driver_NotCalibrated = 206,
		Driver_CalibrationInvalid = 207,
		Driver_HmdDisplayNotFound = 208,
		Driver_TrackedDeviceInterfaceUnknown = 209,
		Driver_HmdDriverIdOutOfBounds = 211,
		Driver_HmdDisplayMirrored = 212,
		IPC_ServerInitFailed = 300,
		IPC_ConnectFailed = 301,
		IPC_SharedStateInitFailed = 302,
		IPC_CompositorInitFailed = 303,
		IPC_MutexInitFailed = 304,
		IPC_Failed = 305,
		IPC_CompositorConnectFailed = 306,
		IPC_CompositorInvalidConnectResponse = 307,
		IPC_ConnectFailedAfterMultipleAttempts = 308,
		Compositor_Failed = 400,
		Compositor_D3D11HardwareRequired = 401,
		Compositor_FirmwareRequiresUpdate = 402,
		Compositor_OverlayInitFailed = 403,
		Compositor_ScreenshotsInitFailed = 404,
		Compositor_UnableToCreateDevice = 405,
		VendorSpecific_UnableToConnectToOculusRuntime = 1000,
		VendorSpecific_WindowsNotInDevMode = 1001,
		VendorSpecific_HmdFound_CantOpenDevice = 1101,
		VendorSpecific_HmdFound_UnableToRequestConfigStart = 1102,
		VendorSpecific_HmdFound_NoStoredConfig = 1103,
		VendorSpecific_HmdFound_ConfigTooBig = 1104,
		VendorSpecific_HmdFound_ConfigTooSmall = 1105,
		VendorSpecific_HmdFound_UnableToInitZLib = 1106,
		VendorSpecific_HmdFound_CantReadFirmwareVersion = 1107,
		VendorSpecific_HmdFound_UnableToSendUserDataStart = 1108,
		VendorSpecific_HmdFound_UnableToGetUserDataStart = 1109,
		VendorSpecific_HmdFound_UnableToGetUserDataNext = 1110,
		VendorSpecific_HmdFound_UserDataAddressRange = 1111,
		VendorSpecific_HmdFound_UserDataError = 1112,
		VendorSpecific_HmdFound_ConfigFailedSanityCheck = 1113,
		Steam_SteamInstallationNotFound = 2000
	}
	public enum EVRScreenshotType
	{
		None,
		Mono,
		Stereo,
		Cubemap,
		MonoPanorama,
		StereoPanorama
	}
	public enum EVRScreenshotPropertyFilenames
	{
		Preview,
		VR
	}
	public enum EVRTrackedCameraError
	{
		None = 0,
		OperationFailed = 100,
		InvalidHandle = 101,
		InvalidFrameHeaderVersion = 102,
		OutOfHandles = 103,
		IPCFailure = 104,
		NotSupportedForThisDevice = 105,
		SharedMemoryFailure = 106,
		FrameBufferingFailure = 107,
		StreamSetupFailure = 108,
		InvalidGLTextureId = 109,
		InvalidSharedTextureHandle = 110,
		FailedToGetGLTextureId = 111,
		SharedTextureFailure = 112,
		NoFrameAvailable = 113,
		InvalidArgument = 114,
		InvalidFrameBufferSize = 115
	}
	public enum EVRTrackedCameraFrameType
	{
		Distorted,
		Undistorted,
		MaximumUndistorted,
		MAX_CAMERA_FRAME_TYPES
	}
	public enum EVRApplicationError
	{
		None = 0,
		AppKeyAlreadyExists = 100,
		NoManifest = 101,
		NoApplication = 102,
		InvalidIndex = 103,
		UnknownApplication = 104,
		IPCFailed = 105,
		ApplicationAlreadyRunning = 106,
		InvalidManifest = 107,
		InvalidApplication = 108,
		LaunchFailed = 109,
		ApplicationAlreadyStarting = 110,
		LaunchInProgress = 111,
		OldApplicationQuitting = 112,
		TransitionAborted = 113,
		IsTemplate = 114,
		SteamVRIsExiting = 115,
		BufferTooSmall = 200,
		PropertyNotSet = 201,
		UnknownProperty = 202,
		InvalidParameter = 203
	}
	public enum EVRApplicationProperty
	{
		Name_String = 0,
		LaunchType_String = 11,
		WorkingDirectory_String = 12,
		BinaryPath_String = 13,
		Arguments_String = 14,
		URL_String = 15,
		Description_String = 50,
		NewsURL_String = 51,
		ImagePath_String = 52,
		Source_String = 53,
		ActionManifestURL_String = 54,
		IsDashboardOverlay_Bool = 60,
		IsTemplate_Bool = 61,
		IsInstanced_Bool = 62,
		IsInternal_Bool = 63,
		WantsCompositorPauseInStandby_Bool = 64,
		LastLaunchTime_Uint64 = 70
	}
	public enum EVRApplicationTransitionState
	{
		VRApplicationTransition_None = 0,
		VRApplicationTransition_OldAppQuitSent = 10,
		VRApplicationTransition_WaitingForExternalLaunch = 11,
		VRApplicationTransition_NewAppLaunched = 20
	}
	public enum ChaperoneCalibrationState
	{
		OK = 1,
		Warning = 100,
		Warning_BaseStationMayHaveMoved = 101,
		Warning_BaseStationRemoved = 102,
		Warning_SeatedBoundsInvalid = 103,
		Error = 200,
		Error_BaseStationUninitialized = 201,
		Error_BaseStationConflict = 202,
		Error_PlayAreaInvalid = 203,
		Error_CollisionBoundsInvalid = 204
	}
	public enum EChaperoneConfigFile
	{
		Live = 1,
		Temp
	}
	public enum EChaperoneImportFlags
	{
		EChaperoneImport_BoundsOnly = 1
	}
	public enum EVRCompositorError
	{
		None = 0,
		RequestFailed = 1,
		IncompatibleVersion = 100,
		DoNotHaveFocus = 101,
		InvalidTexture = 102,
		IsNotSceneApplication = 103,
		TextureIsOnWrongDevice = 104,
		TextureUsesUnsupportedFormat = 105,
		SharedTexturesNotSupported = 106,
		IndexOutOfRange = 107,
		AlreadySubmitted = 108,
		InvalidBounds = 109
	}
	public enum EVRCompositorTimingMode
	{
		Implicit,
		Explicit_RuntimePerformsPostPresentHandoff,
		Explicit_ApplicationPerformsPostPresentHandoff
	}
	public enum VROverlayInputMethod
	{
		None,
		Mouse,
		DualAnalog
	}
	public enum VROverlayTransformType
	{
		VROverlayTransform_Absolute,
		VROverlayTransform_TrackedDeviceRelative,
		VROverlayTransform_SystemOverlay,
		VROverlayTransform_TrackedComponent
	}
	public enum VROverlayFlags
	{
		None,
		Curved,
		RGSS4X,
		NoDashboardTab,
		AcceptsGamepadEvents,
		ShowGamepadFocus,
		SendVRScrollEvents,
		SendVRTouchpadEvents,
		ShowTouchPadScrollWheel,
		TransferOwnershipToInternalProcess,
		SideBySide_Parallel,
		SideBySide_Crossed,
		Panorama,
		StereoPanorama,
		SortWithNonSceneOverlays,
		VisibleInDashboard
	}
	public enum VRMessageOverlayResponse
	{
		ButtonPress_0,
		ButtonPress_1,
		ButtonPress_2,
		ButtonPress_3,
		CouldntFindSystemOverlay,
		CouldntFindOrCreateClientOverlay,
		ApplicationQuit
	}
	public enum EGamepadTextInputMode
	{
		k_EGamepadTextInputModeNormal,
		k_EGamepadTextInputModePassword,
		k_EGamepadTextInputModeSubmit
	}
	public enum EGamepadTextInputLineMode
	{
		k_EGamepadTextInputLineModeSingleLine,
		k_EGamepadTextInputLineModeMultipleLines
	}
	public enum EOverlayDirection
	{
		Up,
		Down,
		Left,
		Right,
		Count
	}
	public enum EVROverlayIntersectionMaskPrimitiveType
	{
		OverlayIntersectionPrimitiveType_Rectangle,
		OverlayIntersectionPrimitiveType_Circle
	}
	public enum EVRRenderModelError
	{
		None = 0,
		Loading = 100,
		NotSupported = 200,
		InvalidArg = 300,
		InvalidModel = 301,
		NoShapes = 302,
		MultipleShapes = 303,
		TooManyVertices = 304,
		MultipleTextures = 305,
		BufferTooSmall = 306,
		NotEnoughNormals = 307,
		NotEnoughTexCoords = 308,
		InvalidTexture = 400
	}
	public enum EVRComponentProperty
	{
		IsStatic = 1,
		IsVisible = 2,
		IsTouched = 4,
		IsPressed = 8,
		IsScrolled = 0x10
	}
	public enum EVRNotificationType
	{
		Transient,
		Persistent,
		Transient_SystemWithUserValue
	}
	public enum EVRNotificationStyle
	{
		None = 0,
		Application = 100,
		Contact_Disabled = 200,
		Contact_Enabled = 201,
		Contact_Active = 202
	}
	public enum EVRSettingsError
	{
		None,
		IPCFailed,
		WriteFailed,
		ReadFailed,
		JsonParseFailed,
		UnsetSettingHasNoDefault
	}
	public enum EVRScreenshotError
	{
		None = 0,
		RequestFailed = 1,
		IncompatibleVersion = 100,
		NotFound = 101,
		BufferTooSmall = 102,
		ScreenshotAlreadyInProgress = 108
	}
	[StructLayout(LayoutKind.Explicit)]
	public struct VREvent_Data_t
	{
		[FieldOffset(0)]
		public VREvent_Reserved_t reserved;

		[FieldOffset(0)]
		public VREvent_Controller_t controller;

		[FieldOffset(0)]
		public VREvent_Mouse_t mouse;

		[FieldOffset(0)]
		public VREvent_Scroll_t scroll;

		[FieldOffset(0)]
		public VREvent_Process_t process;

		[FieldOffset(0)]
		public VREvent_Notification_t notification;

		[FieldOffset(0)]
		public VREvent_Overlay_t overlay;

		[FieldOffset(0)]
		public VREvent_Status_t status;

		[FieldOffset(0)]
		public VREvent_Ipd_t ipd;

		[FieldOffset(0)]
		public VREvent_Chaperone_t chaperone;

		[FieldOffset(0)]
		public VREvent_PerformanceTest_t performanceTest;

		[FieldOffset(0)]
		public VREvent_TouchPadMove_t touchPadMove;

		[FieldOffset(0)]
		public VREvent_SeatedZeroPoseReset_t seatedZeroPoseReset;

		[FieldOffset(0)]
		public VREvent_Screenshot_t screenshot;

		[FieldOffset(0)]
		public VREvent_ScreenshotProgress_t screenshotProgress;

		[FieldOffset(0)]
		public VREvent_ApplicationLaunch_t applicationLaunch;

		[FieldOffset(0)]
		public VREvent_EditingCameraSurface_t cameraSurface;

		[FieldOffset(0)]
		public VREvent_MessageOverlay_t messageOverlay;

		[FieldOffset(0)]
		public VREvent_Property_t property;

		[FieldOffset(0)]
		public VREvent_DualAnalog_t dualAnalog;

		[FieldOffset(0)]
		public VREvent_HapticVibration_t hapticVibration;

		[FieldOffset(0)]
		public VREvent_Keyboard_t keyboard;
	}
	[StructLayout(LayoutKind.Explicit)]
	public struct VROverlayIntersectionMaskPrimitive_Data_t
	{
		[FieldOffset(0)]
		public IntersectionMaskRectangle_t m_Rectangle;

		[FieldOffset(0)]
		public IntersectionMaskCircle_t m_Circle;
	}
	public struct HmdMatrix34_t
	{
		public float m0;

		public float m1;

		public float m2;

		public float m3;

		public float m4;

		public float m5;

		public float m6;

		public float m7;

		public float m8;

		public float m9;

		public float m10;

		public float m11;
	}
	public struct HmdMatrix44_t
	{
		public float m0;

		public float m1;

		public float m2;

		public float m3;

		public float m4;

		public float m5;

		public float m6;

		public float m7;

		public float m8;

		public float m9;

		public float m10;

		public float m11;

		public float m12;

		public float m13;

		public float m14;

		public float m15;
	}
	public struct HmdVector3_t
	{
		public float v0;

		public float v1;

		public float v2;
	}
	public struct HmdVector4_t
	{
		public float v0;

		public float v1;

		public float v2;

		public float v3;
	}
	public struct HmdVector3d_t
	{
		public double v0;

		public double v1;

		public double v2;
	}
	public struct HmdVector2_t
	{
		public float v0;

		public float v1;
	}
	public struct HmdQuaternion_t
	{
		public double w;

		public double x;

		public double y;

		public double z;
	}
	public struct HmdColor_t
	{
		public float r;

		public float g;

		public float b;

		public float a;
	}
	public struct HmdQuad_t
	{
		public HmdVector3_t vCorners0;

		public HmdVector3_t vCorners1;

		public HmdVector3_t vCorners2;

		public HmdVector3_t vCorners3;
	}
	public struct HmdRect2_t
	{
		public HmdVector2_t vTopLeft;

		public HmdVector2_t vBottomRight;
	}
	public struct DistortionCoordinates_t
	{
		public float rfRed0;

		public float rfRed1;

		public float rfGreen0;

		public float rfGreen1;

		public float rfBlue0;

		public float rfBlue1;
	}
	public struct Texture_t
	{
		public IntPtr handle;

		public ETextureType eType;

		public EColorSpace eColorSpace;
	}
	public struct TrackedDevicePose_t
	{
		public HmdMatrix34_t mDeviceToAbsoluteTracking;

		public HmdVector3_t vVelocity;

		public HmdVector3_t vAngularVelocity;

		public ETrackingResult eTrackingResult;

		[MarshalAs(UnmanagedType.I1)]
		public bool bPoseIsValid;

		[MarshalAs(UnmanagedType.I1)]
		public bool bDeviceIsConnected;
	}
	public struct VRTextureBounds_t
	{
		public float uMin;

		public float vMin;

		public float uMax;

		public float vMax;
	}
	public struct VRTextureWithPose_t
	{
		public HmdMatrix34_t mDeviceToAbsoluteTracking;
	}
	public struct VRTextureDepthInfo_t
	{
		public IntPtr handle;

		public HmdMatrix44_t mProjection;

		public HmdVector2_t vRange;
	}
	public struct VRTextureWithDepth_t
	{
		public VRTextureDepthInfo_t depth;
	}
	public struct VRTextureWithPoseAndDepth_t
	{
		public VRTextureDepthInfo_t depth;
	}
	public struct VRVulkanTextureData_t
	{
		public ulong m_nImage;

		public IntPtr m_pDevice;

		public IntPtr m_pPhysicalDevice;

		public IntPtr m_pInstance;

		public IntPtr m_pQueue;

		public uint m_nQueueFamilyIndex;

		public uint m_nWidth;

		public uint m_nHeight;

		public uint m_nFormat;

		public uint m_nSampleCount;
	}
	public struct D3D12TextureData_t
	{
		public IntPtr m_pResource;

		public IntPtr m_pCommandQueue;

		public uint m_nNodeMask;
	}
	public struct VREvent_Controller_t
	{
		public uint button;
	}
	public struct VREvent_Mouse_t
	{
		public float x;

		public float y;

		public uint button;
	}
	public struct VREvent_Scroll_t
	{
		public float xdelta;

		public float ydelta;

		public uint repeatCount;
	}
	public struct VREvent_TouchPadMove_t
	{
		[MarshalAs(UnmanagedType.I1)]
		public bool bFingerDown;

		public float flSecondsFingerDown;

		public float fValueXFirst;

		public float fValueYFirst;

		public float fValueXRaw;

		public float fValueYRaw;
	}
	public struct VREvent_Notification_t
	{
		public ulong ulUserValue;

		public uint notificationId;
	}
	public struct VREvent_Process_t
	{
		public uint pid;

		public uint oldPid;

		[MarshalAs(UnmanagedType.I1)]
		public bool bForced;
	}
	public struct VREvent_Overlay_t
	{
		public ulong overlayHandle;
	}
	public struct VREvent_Status_t
	{
		public uint statusState;
	}
	public struct VREvent_Keyboard_t
	{
		public byte cNewInput0;

		public byte cNewInput1;

		public byte cNewInput2;

		public byte cNewInput3;

		public byte cNewInput4;

		public byte cNewInput5;

		public byte cNewInput6;

		public byte cNewInput7;

		public ulong uUserValue;
	}
	public struct VREvent_Ipd_t
	{
		public float ipdMeters;
	}
	public struct VREvent_Chaperone_t
	{
		public ulong m_nPreviousUniverse;

		public ulong m_nCurrentUniverse;
	}
	public struct VREvent_Reserved_t
	{
		public ulong reserved0;

		public ulong reserved1;
	}
	public struct VREvent_PerformanceTest_t
	{
		public uint m_nFidelityLevel;
	}
	public struct VREvent_SeatedZeroPoseReset_t
	{
		[MarshalAs(UnmanagedType.I1)]
		public bool bResetBySystemMenu;
	}
	public struct VREvent_Screenshot_t
	{
		public uint handle;

		public uint type;
	}
	public struct VREvent_ScreenshotProgress_t
	{
		public float progress;
	}
	public struct VREvent_ApplicationLaunch_t
	{
		public uint pid;

		public uint unArgsHandle;
	}
	public struct VREvent_EditingCameraSurface_t
	{
		public ulong overlayHandle;

		public uint nVisualMode;
	}
	public struct VREvent_MessageOverlay_t
	{
		public uint unVRMessageOverlayResponse;
	}
	public struct VREvent_Property_t
	{
		public ulong container;

		public ETrackedDeviceProperty prop;
	}
	public struct VREvent_DualAnalog_t
	{
		public float x;

		public float y;

		public float transformedX;

		public float transformedY;

		public EDualAnalogWhich which;
	}
	public struct VREvent_HapticVibration_t
	{
		public ulong containerHandle;

		public ulong componentHandle;

		public float fDurationSeconds;

		public float fFrequency;

		public float fAmplitude;
	}
	public struct VREvent_t
	{
		public uint eventType;

		public uint trackedDeviceIndex;

		public float eventAgeSeconds;

		public VREvent_Data_t data;
	}
	[StructLayout(LayoutKind.Sequential, Pack = 4)]
	public struct VREvent_t_Packed
	{
		public uint eventType;

		public uint trackedDeviceIndex;

		public float eventAgeSeconds;

		public VREvent_Data_t data;

		public VREvent_t_Packed(VREvent_t unpacked)
		{
			eventType = unpacked.eventType;
			trackedDeviceIndex = unpacked.trackedDeviceIndex;
			eventAgeSeconds = unpacked.eventAgeSeconds;
			data = unpacked.data;
		}

		public void Unpack(ref VREvent_t unpacked)
		{
			unpacked.eventType = eventType;
			unpacked.trackedDeviceIndex = trackedDeviceIndex;
			unpacked.eventAgeSeconds = eventAgeSeconds;
			unpacked.data = data;
		}
	}
	public struct HiddenAreaMesh_t
	{
		public IntPtr pVertexData;

		public uint unTriangleCount;
	}
	public struct VRControllerAxis_t
	{
		public float x;

		public float y;
	}
	public struct VRControllerState_t
	{
		public uint unPacketNum;

		public ulong ulButtonPressed;

		public ulong ulButtonTouched;

		public VRControllerAxis_t rAxis0;

		public VRControllerAxis_t rAxis1;

		public VRControllerAxis_t rAxis2;

		public VRControllerAxis_t rAxis3;

		public VRControllerAxis_t rAxis4;
	}
	[StructLayout(LayoutKind.Sequential, Pack = 4)]
	public struct VRControllerState_t_Packed
	{
		public uint unPacketNum;

		public ulong ulButtonPressed;

		public ulong ulButtonTouched;

		public VRControllerAxis_t rAxis0;

		public VRControllerAxis_t rAxis1;

		public VRControllerAxis_t rAxis2;

		public VRControllerAxis_t rAxis3;

		public VRControllerAxis_t rAxis4;

		public VRControllerState_t_Packed(VRControllerState_t unpacked)
		{
			unPacketNum = unpacked.unPacketNum;
			ulButtonPressed = unpacked.ulButtonPressed;
			ulButtonTouched = unpacked.ulButtonTouched;
			rAxis0 = unpacked.rAxis0;
			rAxis1 = unpacked.rAxis1;
			rAxis2 = unpacked.rAxis2;
			rAxis3 = unpacked.rAxis3;
			rAxis4 = unpacked.rAxis4;
		}

		public void Unpack(ref VRControllerState_t unpacked)
		{
			unpacked.unPacketNum = unPacketNum;
			unpacked.ulButtonPressed = ulButtonPressed;
			unpacked.ulButtonTouched = ulButtonTouched;
			unpacked.rAxis0 = rAxis0;
			unpacked.rAxis1 = rAxis1;
			unpacked.rAxis2 = rAxis2;
			unpacked.rAxis3 = rAxis3;
			unpacked.rAxis4 = rAxis4;
		}
	}
	public struct Compositor_OverlaySettings
	{
		public uint size;

		[MarshalAs(UnmanagedType.I1)]
		public bool curved;

		[MarshalAs(UnmanagedType.I1)]
		public bool antialias;

		public float scale;

		public float distance;

		public float alpha;

		public float uOffset;

		public float vOffset;

		public float uScale;

		public float vScale;

		public float gridDivs;

		public float gridWidth;

		public float gridScale;

		public HmdMatrix44_t transform;
	}
	public struct CameraVideoStreamFrameHeader_t
	{
		public EVRTrackedCameraFrameType eFrameType;

		public uint nWidth;

		public uint nHeight;

		public uint nBytesPerPixel;

		public uint nFrameSequence;

		public TrackedDevicePose_t standingTrackedDevicePose;
	}
	public struct DriverDirectMode_FrameTiming
	{
		public uint m_nSize;

		public uint m_nNumFramePresents;

		public uint m_nNumMisPresented;

		public uint m_nNumDroppedFrames;

		public uint m_nReprojectionFlags;
	}
	public struct AppOverrideKeys_t
	{
		public IntPtr pchKey;

		public IntPtr pchValue;
	}
	public struct Compositor_FrameTiming
	{
		public uint m_nSize;

		public uint m_nFrameIndex;

		public uint m_nNumFramePresents;

		public uint m_nNumMisPresented;

		public uint m_nNumDroppedFrames;

		public uint m_nReprojectionFlags;

		public double m_flSystemTimeInSeconds;

		public float m_flPreSubmitGpuMs;

		public float m_flPostSubmitGpuMs;

		public float m_flTotalRenderGpuMs;

		public float m_flCompositorRenderGpuMs;

		public float m_flCompositorRenderCpuMs;

		public float m_flCompositorIdleCpuMs;

		public float m_flClientFrameIntervalMs;

		public float m_flPresentCallCpuMs;

		public float m_flWaitForPresentCpuMs;

		public float m_flSubmitFrameMs;

		public float m_flWaitGetPosesCalledMs;

		public float m_flNewPosesReadyMs;

		public float m_flNewFrameReadyMs;

		public float m_flCompositorUpdateStartMs;

		public float m_flCompositorUpdateEndMs;

		public float m_flCompositorRenderStartMs;

		public TrackedDevicePose_t m_HmdPose;
	}
	public struct Compositor_CumulativeStats
	{
		public uint m_nPid;

		public uint m_nNumFramePresents;

		public uint m_nNumDroppedFrames;

		public uint m_nNumReprojectedFrames;

		public uint m_nNumFramePresentsOnStartup;

		public uint m_nNumDroppedFramesOnStartup;

		public uint m_nNumReprojectedFramesOnStartup;

		public uint m_nNumLoading;

		public uint m_nNumFramePresentsLoading;

		public uint m_nNumDroppedFramesLoading;

		public uint m_nNumReprojectedFramesLoading;

		public uint m_nNumTimedOut;

		public uint m_nNumFramePresentsTimedOut;

		public uint m_nNumDroppedFramesTimedOut;

		public uint m_nNumReprojectedFramesTimedOut;
	}
	public struct VROverlayIntersectionParams_t
	{
		public HmdVector3_t vSource;

		public HmdVector3_t vDirection;

		public ETrackingUniverseOrigin eOrigin;
	}
	public struct VROverlayIntersectionResults_t
	{
		public HmdVector3_t vPoint;

		public HmdVector3_t vNormal;

		public HmdVector2_t vUVs;

		public float fDistance;
	}
	public struct IntersectionMaskRectangle_t
	{
		public float m_flTopLeftX;

		public float m_flTopLeftY;

		public float m_flWidth;

		public float m_flHeight;
	}
	public struct IntersectionMaskCircle_t
	{
		public float m_flCenterX;

		public float m_flCenterY;

		public float m_flRadius;
	}
	public struct VROverlayIntersectionMaskPrimitive_t
	{
		public EVROverlayIntersectionMaskPrimitiveType m_nPrimitiveType;

		public VROverlayIntersectionMaskPrimitive_Data_t m_Primitive;
	}
	public struct RenderModel_ComponentState_t
	{
		public HmdMatrix34_t mTrackingToComponentRenderModel;

		public HmdMatrix34_t mTrackingToComponentLocal;

		public uint uProperties;
	}
	public struct RenderModel_Vertex_t
	{
		public HmdVector3_t vPosition;

		public HmdVector3_t vNormal;

		public float rfTextureCoord0;

		public float rfTextureCoord1;
	}
	public struct RenderModel_TextureMap_t
	{
		public char unWidth;

		public char unHeight;

		public IntPtr rubTextureMapData;
	}
	[StructLayout(LayoutKind.Sequential, Pack = 4)]
	public struct RenderModel_TextureMap_t_Packed
	{
		public char unWidth;

		public char unHeight;

		public IntPtr rubTextureMapData;

		public RenderModel_TextureMap_t_Packed(RenderModel_TextureMap_t unpacked)
		{
			unWidth = unpacked.unWidth;
			unHeight = unpacked.unHeight;
			rubTextureMapData = unpacked.rubTextureMapData;
		}

		public void Unpack(ref RenderModel_TextureMap_t unpacked)
		{
			unpacked.unWidth = unWidth;
			unpacked.unHeight = unHeight;
			unpacked.rubTextureMapData = rubTextureMapData;
		}
	}
	public struct RenderModel_t
	{
		public IntPtr rVertexData;

		public uint unVertexCount;

		public IntPtr rIndexData;

		public uint unTriangleCount;

		public int diffuseTextureId;
	}
	[StructLayout(LayoutKind.Sequential, Pack = 4)]
	public struct RenderModel_t_Packed
	{
		public IntPtr rVertexData;

		public uint unVertexCount;

		public IntPtr rIndexData;

		public uint unTriangleCount;

		public int diffuseTextureId;

		public RenderModel_t_Packed(RenderModel_t unpacked)
		{
			rVertexData = unpacked.rVertexData;
			unVertexCount = unpacked.unVertexCount;
			rIndexData = unpacked.rIndexData;
			unTriangleCount = unpacked.unTriangleCount;
			diffuseTextureId = unpacked.diffuseTextureId;
		}

		public void Unpack(ref RenderModel_t unpacked)
		{
			unpacked.rVertexData = rVertexData;
			unpacked.unVertexCount = unVertexCount;
			unpacked.rIndexData = rIndexData;
			unpacked.unTriangleCount = unTriangleCount;
			unpacked.diffuseTextureId = diffuseTextureId;
		}
	}
	public struct RenderModel_ControllerMode_State_t
	{
		[MarshalAs(UnmanagedType.I1)]
		public bool bScrollWheelVisible;
	}
	public struct NotificationBitmap_t
	{
		public IntPtr m_pImageData;

		public int m_nWidth;

		public int m_nHeight;

		public int m_nBytesPerPixel;
	}
	public struct COpenVRContext
	{
		public IntPtr m_pVRSystem;

		public IntPtr m_pVRChaperone;

		public IntPtr m_pVRChaperoneSetup;

		public IntPtr m_pVRCompositor;

		public IntPtr m_pVROverlay;

		public IntPtr m_pVRResources;

		public IntPtr m_pVRRenderModels;

		public IntPtr m_pVRExtendedDisplay;

		public IntPtr m_pVRSettings;

		public IntPtr m_pVRApplications;

		public IntPtr m_pVRTrackedCamera;

		public IntPtr m_pVRScreenshots;

		public IntPtr m_pVRDriverManager;
	}
	public class OpenVR
	{
		private class COpenVRContext
		{
			private CVRSystem m_pVRSystem;

			private CVRChaperone m_pVRChaperone;

			private CVRChaperoneSetup m_pVRChaperoneSetup;

			private CVRCompositor m_pVRCompositor;

			private CVROverlay m_pVROverlay;

			private CVRRenderModels m_pVRRenderModels;

			private CVRExtendedDisplay m_pVRExtendedDisplay;

			private CVRSettings m_pVRSettings;

			private CVRApplications m_pVRApplications;

			private CVRScreenshots m_pVRScreenshots;

			private CVRTrackedCamera m_pVRTrackedCamera;

			public COpenVRContext()
			{
				Clear();
			}

			public void Clear()
			{
				m_pVRSystem = null;
				m_pVRChaperone = null;
				m_pVRChaperoneSetup = null;
				m_pVRCompositor = null;
				m_pVROverlay = null;
				m_pVRRenderModels = null;
				m_pVRExtendedDisplay = null;
				m_pVRSettings = null;
				m_pVRApplications = null;
				m_pVRScreenshots = null;
				m_pVRTrackedCamera = null;
			}

			private void CheckClear()
			{
				if (VRToken != GetInitToken())
				{
					Clear();
					VRToken = GetInitToken();
				}
			}

			public CVRSystem VRSystem()
			{
				CheckClear();
				if (m_pVRSystem == null)
				{
					EVRInitError peError = EVRInitError.None;
					IntPtr genericInterface = OpenVRInterop.GetGenericInterface("FnTable:IVRSystem_019", ref peError);
					if (genericInterface != IntPtr.Zero && peError == EVRInitError.None)
					{
						m_pVRSystem = new CVRSystem(genericInterface);
					}
				}
				return m_pVRSystem;
			}

			public CVRChaperone VRChaperone()
			{
				CheckClear();
				if (m_pVRChaperone == null)
				{
					EVRInitError peError = EVRInitError.None;
					IntPtr genericInterface = OpenVRInterop.GetGenericInterface("FnTable:IVRChaperone_003", ref peError);
					if (genericInterface != IntPtr.Zero && peError == EVRInitError.None)
					{
						m_pVRChaperone = new CVRChaperone(genericInterface);
					}
				}
				return m_pVRChaperone;
			}

			public CVRChaperoneSetup VRChaperoneSetup()
			{
				CheckClear();
				if (m_pVRChaperoneSetup == null)
				{
					EVRInitError peError = EVRInitError.None;
					IntPtr genericInterface = OpenVRInterop.GetGenericInterface("FnTable:IVRChaperoneSetup_005", ref peError);
					if (genericInterface != IntPtr.Zero && peError == EVRInitError.None)
					{
						m_pVRChaperoneSetup = new CVRChaperoneSetup(genericInterface);
					}
				}
				return m_pVRChaperoneSetup;
			}

			public CVRCompositor VRCompositor()
			{
				CheckClear();
				if (m_pVRCompositor == null)
				{
					EVRInitError peError = EVRInitError.None;
					IntPtr genericInterface = OpenVRInterop.GetGenericInterface("FnTable:IVRCompositor_022", ref peError);
					if (genericInterface != IntPtr.Zero && peError == EVRInitError.None)
					{
						m_pVRCompositor = new CVRCompositor(genericInterface);
					}
				}
				return m_pVRCompositor;
			}

			public CVROverlay VROverlay()
			{
				CheckClear();
				if (m_pVROverlay == null)
				{
					EVRInitError peError = EVRInitError.None;
					IntPtr genericInterface = OpenVRInterop.GetGenericInterface("FnTable:IVROverlay_018", ref peError);
					if (genericInterface != IntPtr.Zero && peError == EVRInitError.None)
					{
						m_pVROverlay = new CVROverlay(genericInterface);
					}
				}
				return m_pVROverlay;
			}

			public CVRRenderModels VRRenderModels()
			{
				CheckClear();
				if (m_pVRRenderModels == null)
				{
					EVRInitError peError = EVRInitError.None;
					IntPtr genericInterface = OpenVRInterop.GetGenericInterface("FnTable:IVRRenderModels_005", ref peError);
					if (genericInterface != IntPtr.Zero && peError == EVRInitError.None)
					{
						m_pVRRenderModels = new CVRRenderModels(genericInterface);
					}
				}
				return m_pVRRenderModels;
			}

			public CVRExtendedDisplay VRExtendedDisplay()
			{
				CheckClear();
				if (m_pVRExtendedDisplay == null)
				{
					EVRInitError peError = EVRInitError.None;
					IntPtr genericInterface = OpenVRInterop.GetGenericInterface("FnTable:IVRExtendedDisplay_001", ref peError);
					if (genericInterface != IntPtr.Zero && peError == EVRInitError.None)
					{
						m_pVRExtendedDisplay = new CVRExtendedDisplay(genericInterface);
					}
				}
				return m_pVRExtendedDisplay;
			}

			public CVRSettings VRSettings()
			{
				CheckClear();
				if (m_pVRSettings == null)
				{
					EVRInitError peError = EVRInitError.None;
					IntPtr genericInterface = OpenVRInterop.GetGenericInterface("FnTable:IVRSettings_002", ref peError);
					if (genericInterface != IntPtr.Zero && peError == EVRInitError.None)
					{
						m_pVRSettings = new CVRSettings(genericInterface);
					}
				}
				return m_pVRSettings;
			}

			public CVRApplications VRApplications()
			{
				CheckClear();
				if (m_pVRApplications == null)
				{
					EVRInitError peError = EVRInitError.None;
					IntPtr genericInterface = OpenVRInterop.GetGenericInterface("FnTable:IVRApplications_006", ref peError);
					if (genericInterface != IntPtr.Zero && peError == EVRInitError.None)
					{
						m_pVRApplications = new CVRApplications(genericInterface);
					}
				}
				return m_pVRApplications;
			}

			public CVRScreenshots VRScreenshots()
			{
				CheckClear();
				if (m_pVRScreenshots == null)
				{
					EVRInitError peError = EVRInitError.None;
					IntPtr genericInterface = OpenVRInterop.GetGenericInterface("FnTable:IVRScreenshots_001", ref peError);
					if (genericInterface != IntPtr.Zero && peError == EVRInitError.None)
					{
						m_pVRScreenshots = new CVRScreenshots(genericInterface);
					}
				}
				return m_pVRScreenshots;
			}

			public CVRTrackedCamera VRTrackedCamera()
			{
				CheckClear();
				if (m_pVRTrackedCamera == null)
				{
					EVRInitError peError = EVRInitError.None;
					IntPtr genericInterface = OpenVRInterop.GetGenericInterface("FnTable:IVRTrackedCamera_003", ref peError);
					if (genericInterface != IntPtr.Zero && peError == EVRInitError.None)
					{
						m_pVRTrackedCamera = new CVRTrackedCamera(genericInterface);
					}
				}
				return m_pVRTrackedCamera;
			}
		}

		public const uint k_nDriverNone = uint.MaxValue;

		public const uint k_unMaxDriverDebugResponseSize = 32768u;

		public const uint k_unTrackedDeviceIndex_Hmd = 0u;

		public const uint k_unMaxTrackedDeviceCount = 64u;

		public const uint k_unTrackedDeviceIndexOther = 4294967294u;

		public const uint k_unTrackedDeviceIndexInvalid = uint.MaxValue;

		public const ulong k_ulInvalidPropertyContainer = 0uL;

		public const uint k_unInvalidPropertyTag = 0u;

		public const uint k_unFloatPropertyTag = 1u;

		public const uint k_unInt32PropertyTag = 2u;

		public const uint k_unUint64PropertyTag = 3u;

		public const uint k_unBoolPropertyTag = 4u;

		public const uint k_unStringPropertyTag = 5u;

		public const uint k_unHmdMatrix34PropertyTag = 20u;

		public const uint k_unHmdMatrix44PropertyTag = 21u;

		public const uint k_unHmdVector3PropertyTag = 22u;

		public const uint k_unHmdVector4PropertyTag = 23u;

		public const uint k_unHiddenAreaPropertyTag = 30u;

		public const uint k_unPathHandleInfoTag = 31u;

		public const uint k_unActionPropertyTag = 32u;

		public const uint k_unInputValuePropertyTag = 33u;

		public const uint k_unWildcardPropertyTag = 34u;

		public const uint k_unHapticVibrationPropertyTag = 35u;

		public const uint k_unOpenVRInternalReserved_Start = 1000u;

		public const uint k_unOpenVRInternalReserved_End = 10000u;

		public const uint k_unMaxPropertyStringSize = 32768u;

		public const uint k_unControllerStateAxisCount = 5u;

		public const ulong k_ulOverlayHandleInvalid = 0uL;

		public const uint k_unScreenshotHandleInvalid = 0u;

		public const string IVRSystem_Version = "IVRSystem_019";

		public const string IVRExtendedDisplay_Version = "IVRExtendedDisplay_001";

		public const string IVRTrackedCamera_Version = "IVRTrackedCamera_003";

		public const uint k_unMaxApplicationKeyLength = 128u;

		public const string k_pch_MimeType_HomeApp = "vr/home";

		public const string k_pch_MimeType_GameTheater = "vr/game_theater";

		public const string IVRApplications_Version = "IVRApplications_006";

		public const string IVRChaperone_Version = "IVRChaperone_003";

		public const string IVRChaperoneSetup_Version = "IVRChaperoneSetup_005";

		public const string IVRCompositor_Version = "IVRCompositor_022";

		public const uint k_unVROverlayMaxKeyLength = 128u;

		public const uint k_unVROverlayMaxNameLength = 128u;

		public const uint k_unMaxOverlayCount = 64u;

		public const uint k_unMaxOverlayIntersectionMaskPrimitivesCount = 32u;

		public const string IVROverlay_Version = "IVROverlay_018";

		public const string k_pch_Controller_Component_GDC2015 = "gdc2015";

		public const string k_pch_Controller_Component_Base = "base";

		public const string k_pch_Controller_Component_Tip = "tip";

		public const string k_pch_Controller_Component_HandGrip = "handgrip";

		public const string k_pch_Controller_Component_Status = "status";

		public const string IVRRenderModels_Version = "IVRRenderModels_005";

		public const uint k_unNotificationTextMaxSize = 256u;

		public const string IVRNotifications_Version = "IVRNotifications_002";

		public const uint k_unMaxSettingsKeyLength = 128u;

		public const string IVRSettings_Version = "IVRSettings_002";

		public const string k_pch_SteamVR_Section = "steamvr";

		public const string k_pch_SteamVR_RequireHmd_String = "requireHmd";

		public const string k_pch_SteamVR_ForcedDriverKey_String = "forcedDriver";

		public const string k_pch_SteamVR_ForcedHmdKey_String = "forcedHmd";

		public const string k_pch_SteamVR_DisplayDebug_Bool = "displayDebug";

		public const string k_pch_SteamVR_DebugProcessPipe_String = "debugProcessPipe";

		public const string k_pch_SteamVR_DisplayDebugX_Int32 = "displayDebugX";

		public const string k_pch_SteamVR_DisplayDebugY_Int32 = "displayDebugY";

		public const string k_pch_SteamVR_SendSystemButtonToAllApps_Bool = "sendSystemButtonToAllApps";

		public const string k_pch_SteamVR_LogLevel_Int32 = "loglevel";

		public const string k_pch_SteamVR_IPD_Float = "ipd";

		public const string k_pch_SteamVR_Background_String = "background";

		public const string k_pch_SteamVR_BackgroundUseDomeProjection_Bool = "backgroundUseDomeProjection";

		public const string k_pch_SteamVR_BackgroundCameraHeight_Float = "backgroundCameraHeight";

		public const string k_pch_SteamVR_BackgroundDomeRadius_Float = "backgroundDomeRadius";

		public const string k_pch_SteamVR_GridColor_String = "gridColor";

		public const string k_pch_SteamVR_PlayAreaColor_String = "playAreaColor";

		public const string k_pch_SteamVR_ShowStage_Bool = "showStage";

		public const string k_pch_SteamVR_ActivateMultipleDrivers_Bool = "activateMultipleDrivers";

		public const string k_pch_SteamVR_DirectMode_Bool = "directMode";

		public const string k_pch_SteamVR_DirectModeEdidVid_Int32 = "directModeEdidVid";

		public const string k_pch_SteamVR_DirectModeEdidPid_Int32 = "directModeEdidPid";

		public const string k_pch_SteamVR_UsingSpeakers_Bool = "usingSpeakers";

		public const string k_pch_SteamVR_SpeakersForwardYawOffsetDegrees_Float = "speakersForwardYawOffsetDegrees";

		public const string k_pch_SteamVR_BaseStationPowerManagement_Bool = "basestationPowerManagement";

		public const string k_pch_SteamVR_NeverKillProcesses_Bool = "neverKillProcesses";

		public const string k_pch_SteamVR_SupersampleScale_Float = "supersampleScale";

		public const string k_pch_SteamVR_AllowAsyncReprojection_Bool = "allowAsyncReprojection";

		public const string k_pch_SteamVR_AllowReprojection_Bool = "allowInterleavedReprojection";

		public const string k_pch_SteamVR_ForceReprojection_Bool = "forceReprojection";

		public const string k_pch_SteamVR_ForceFadeOnBadTracking_Bool = "forceFadeOnBadTracking";

		public const string k_pch_SteamVR_DefaultMirrorView_Int32 = "defaultMirrorView";

		public const string k_pch_SteamVR_ShowMirrorView_Bool = "showMirrorView";

		public const string k_pch_SteamVR_MirrorViewGeometry_String = "mirrorViewGeometry";

		public const string k_pch_SteamVR_StartMonitorFromAppLaunch = "startMonitorFromAppLaunch";

		public const string k_pch_SteamVR_StartCompositorFromAppLaunch_Bool = "startCompositorFromAppLaunch";

		public const string k_pch_SteamVR_StartDashboardFromAppLaunch_Bool = "startDashboardFromAppLaunch";

		public const string k_pch_SteamVR_StartOverlayAppsFromDashboard_Bool = "startOverlayAppsFromDashboard";

		public const string k_pch_SteamVR_EnableHomeApp = "enableHomeApp";

		public const string k_pch_SteamVR_CycleBackgroundImageTimeSec_Int32 = "CycleBackgroundImageTimeSec";

		public const string k_pch_SteamVR_RetailDemo_Bool = "retailDemo";

		public const string k_pch_SteamVR_IpdOffset_Float = "ipdOffset";

		public const string k_pch_SteamVR_AllowSupersampleFiltering_Bool = "allowSupersampleFiltering";

		public const string k_pch_SteamVR_EnableLinuxVulkanAsync_Bool = "enableLinuxVulkanAsync";

		public const string k_pch_SteamVR_AllowDisplayLockedMode_Bool = "allowDisplayLockedMode";

		public const string k_pch_SteamVR_HaveStartedTutorialForNativeChaperoneDriver_Bool = "haveStartedTutorialForNativeChaperoneDriver";

		public const string k_pch_SteamVR_ForceWindows32bitVRMonitor = "forceWindows32BitVRMonitor";

		public const string k_pch_Lighthouse_Section = "driver_lighthouse";

		public const string k_pch_Lighthouse_DisableIMU_Bool = "disableimu";

		public const string k_pch_Lighthouse_DisableIMUExceptHMD_Bool = "disableimuexcepthmd";

		public const string k_pch_Lighthouse_UseDisambiguation_String = "usedisambiguation";

		public const string k_pch_Lighthouse_DisambiguationDebug_Int32 = "disambiguationdebug";

		public const string k_pch_Lighthouse_PrimaryBasestation_Int32 = "primarybasestation";

		public const string k_pch_Lighthouse_DBHistory_Bool = "dbhistory";

		public const string k_pch_Lighthouse_EnableBluetooth_Bool = "enableBluetooth";

		public const string k_pch_Null_Section = "driver_null";

		public const string k_pch_Null_SerialNumber_String = "serialNumber";

		public const string k_pch_Null_ModelNumber_String = "modelNumber";

		public const string k_pch_Null_WindowX_Int32 = "windowX";

		public const string k_pch_Null_WindowY_Int32 = "windowY";

		public const string k_pch_Null_WindowWidth_Int32 = "windowWidth";

		public const string k_pch_Null_WindowHeight_Int32 = "windowHeight";

		public const string k_pch_Null_RenderWidth_Int32 = "renderWidth";

		public const string k_pch_Null_RenderHeight_Int32 = "renderHeight";

		public const string k_pch_Null_SecondsFromVsyncToPhotons_Float = "secondsFromVsyncToPhotons";

		public const string k_pch_Null_DisplayFrequency_Float = "displayFrequency";

		public const string k_pch_UserInterface_Section = "userinterface";

		public const string k_pch_UserInterface_StatusAlwaysOnTop_Bool = "StatusAlwaysOnTop";

		public const string k_pch_UserInterface_MinimizeToTray_Bool = "MinimizeToTray";

		public const string k_pch_UserInterface_Screenshots_Bool = "screenshots";

		public const string k_pch_UserInterface_ScreenshotType_Int = "screenshotType";

		public const string k_pch_Notifications_Section = "notifications";

		public const string k_pch_Notifications_DoNotDisturb_Bool = "DoNotDisturb";

		public const string k_pch_Keyboard_Section = "keyboard";

		public const string k_pch_Keyboard_TutorialCompletions = "TutorialCompletions";

		public const string k_pch_Keyboard_ScaleX = "ScaleX";

		public const string k_pch_Keyboard_ScaleY = "ScaleY";

		public const string k_pch_Keyboard_OffsetLeftX = "OffsetLeftX";

		public const string k_pch_Keyboard_OffsetRightX = "OffsetRightX";

		public const string k_pch_Keyboard_OffsetY = "OffsetY";

		public const string k_pch_Keyboard_Smoothing = "Smoothing";

		public const string k_pch_Perf_Section = "perfcheck";

		public const string k_pch_Perf_HeuristicActive_Bool = "heuristicActive";

		public const string k_pch_Perf_NotifyInHMD_Bool = "warnInHMD";

		public const string k_pch_Perf_NotifyOnlyOnce_Bool = "warnOnlyOnce";

		public const string k_pch_Perf_AllowTimingStore_Bool = "allowTimingStore";

		public const string k_pch_Perf_SaveTimingsOnExit_Bool = "saveTimingsOnExit";

		public const string k_pch_Perf_TestData_Float = "perfTestData";

		public const string k_pch_Perf_LinuxGPUProfiling_Bool = "linuxGPUProfiling";

		public const string k_pch_CollisionBounds_Section = "collisionBounds";

		public const string k_pch_CollisionBounds_Style_Int32 = "CollisionBoundsStyle";

		public const string k_pch_CollisionBounds_GroundPerimeterOn_Bool = "CollisionBoundsGroundPerimeterOn";

		public const string k_pch_CollisionBounds_CenterMarkerOn_Bool = "CollisionBoundsCenterMarkerOn";

		public const string k_pch_CollisionBounds_PlaySpaceOn_Bool = "CollisionBoundsPlaySpaceOn";

		public const string k_pch_CollisionBounds_FadeDistance_Float = "CollisionBoundsFadeDistance";

		public const string k_pch_CollisionBounds_ColorGammaR_Int32 = "CollisionBoundsColorGammaR";

		public const string k_pch_CollisionBounds_ColorGammaG_Int32 = "CollisionBoundsColorGammaG";

		public const string k_pch_CollisionBounds_ColorGammaB_Int32 = "CollisionBoundsColorGammaB";

		public const string k_pch_CollisionBounds_ColorGammaA_Int32 = "CollisionBoundsColorGammaA";

		public const string k_pch_Camera_Section = "camera";

		public const string k_pch_Camera_EnableCamera_Bool = "enableCamera";

		public const string k_pch_Camera_EnableCameraInDashboard_Bool = "enableCameraInDashboard";

		public const string k_pch_Camera_EnableCameraForCollisionBounds_Bool = "enableCameraForCollisionBounds";

		public const string k_pch_Camera_EnableCameraForRoomView_Bool = "enableCameraForRoomView";

		public const string k_pch_Camera_BoundsColorGammaR_Int32 = "cameraBoundsColorGammaR";

		public const string k_pch_Camera_BoundsColorGammaG_Int32 = "cameraBoundsColorGammaG";

		public const string k_pch_Camera_BoundsColorGammaB_Int32 = "cameraBoundsColorGammaB";

		public const string k_pch_Camera_BoundsColorGammaA_Int32 = "cameraBoundsColorGammaA";

		public const string k_pch_Camera_BoundsStrength_Int32 = "cameraBoundsStrength";

		public const string k_pch_audio_Section = "audio";

		public const string k_pch_audio_OnPlaybackDevice_String = "onPlaybackDevice";

		public const string k_pch_audio_OnRecordDevice_String = "onRecordDevice";

		public const string k_pch_audio_OnPlaybackMirrorDevice_String = "onPlaybackMirrorDevice";

		public const string k_pch_audio_OffPlaybackDevice_String = "offPlaybackDevice";

		public const string k_pch_audio_OffRecordDevice_String = "offRecordDevice";

		public const string k_pch_audio_VIVEHDMIGain = "viveHDMIGain";

		public const string k_pch_Power_Section = "power";

		public const string k_pch_Power_PowerOffOnExit_Bool = "powerOffOnExit";

		public const string k_pch_Power_TurnOffScreensTimeout_Float = "turnOffScreensTimeout";

		public const string k_pch_Power_TurnOffControllersTimeout_Float = "turnOffControllersTimeout";

		public const string k_pch_Power_ReturnToWatchdogTimeout_Float = "returnToWatchdogTimeout";

		public const string k_pch_Power_AutoLaunchSteamVROnButtonPress = "autoLaunchSteamVROnButtonPress";

		public const string k_pch_Power_PauseCompositorOnStandby_Bool = "pauseCompositorOnStandby";

		public const string k_pch_Dashboard_Section = "dashboard";

		public const string k_pch_Dashboard_EnableDashboard_Bool = "enableDashboard";

		public const string k_pch_Dashboard_ArcadeMode_Bool = "arcadeMode";

		public const string k_pch_modelskin_Section = "modelskins";

		public const string k_pch_Driver_Enable_Bool = "enable";

		public const string IVRScreenshots_Version = "IVRScreenshots_001";

		public const string IVRResources_Version = "IVRResources_001";

		public const string IVRDriverManager_Version = "IVRDriverManager_001";

		private const string FnTable_Prefix = "FnTable:";

		private static COpenVRContext _OpenVRInternal_ModuleContext;

		private static uint VRToken { get; set; }

		private static COpenVRContext OpenVRInternal_ModuleContext
		{
			get
			{
				if (_OpenVRInternal_ModuleContext == null)
				{
					_OpenVRInternal_ModuleContext = new COpenVRContext();
				}
				return _OpenVRInternal_ModuleContext;
			}
		}

		public static CVRSystem System => OpenVRInternal_ModuleContext.VRSystem();

		public static CVRChaperone Chaperone => OpenVRInternal_ModuleContext.VRChaperone();

		public static CVRChaperoneSetup ChaperoneSetup => OpenVRInternal_ModuleContext.VRChaperoneSetup();

		public static CVRCompositor Compositor => OpenVRInternal_ModuleContext.VRCompositor();

		public static CVROverlay Overlay => OpenVRInternal_ModuleContext.VROverlay();

		public static CVRRenderModels RenderModels => OpenVRInternal_ModuleContext.VRRenderModels();

		public static CVRExtendedDisplay ExtendedDisplay => OpenVRInternal_ModuleContext.VRExtendedDisplay();

		public static CVRSettings Settings => OpenVRInternal_ModuleContext.VRSettings();

		public static CVRApplications Applications => OpenVRInternal_ModuleContext.VRApplications();

		public static CVRScreenshots Screenshots => OpenVRInternal_ModuleContext.VRScreenshots();

		public static CVRTrackedCamera TrackedCamera => OpenVRInternal_ModuleContext.VRTrackedCamera();

		public static uint InitInternal(ref EVRInitError peError, EVRApplicationType eApplicationType)
		{
			return OpenVRInterop.InitInternal(ref peError, eApplicationType);
		}

		public static void ShutdownInternal()
		{
			OpenVRInterop.ShutdownInternal();
		}

		public static bool IsHmdPresent()
		{
			return OpenVRInterop.IsHmdPresent();
		}

		public static bool IsRuntimeInstalled()
		{
			return OpenVRInterop.IsRuntimeInstalled();
		}

		public static string GetStringForHmdError(EVRInitError error)
		{
			return Marshal.PtrToStringAnsi(OpenVRInterop.GetStringForHmdError(error));
		}

		public static IntPtr GetGenericInterface(string pchInterfaceVersion, ref EVRInitError peError)
		{
			return OpenVRInterop.GetGenericInterface(pchInterfaceVersion, ref peError);
		}

		public static bool IsInterfaceVersionValid(string pchInterfaceVersion)
		{
			return OpenVRInterop.IsInterfaceVersionValid(pchInterfaceVersion);
		}

		public static uint GetInitToken()
		{
			return OpenVRInterop.GetInitToken();
		}

		public static CVRSystem Init(ref EVRInitError peError, EVRApplicationType eApplicationType = EVRApplicationType.VRApplication_Scene)
		{
			VRToken = InitInternal(ref peError, eApplicationType);
			OpenVRInternal_ModuleContext.Clear();
			if (peError != 0)
			{
				return null;
			}
			if (!IsInterfaceVersionValid("IVRSystem_019"))
			{
				ShutdownInternal();
				peError = EVRInitError.Init_InterfaceNotFound;
				return null;
			}
			return System;
		}

		public static void Shutdown()
		{
			ShutdownInternal();
		}
	}
}
namespace BoundarySystem_Ext
{
	internal static class Pvr_BoundaryAPI
	{
		private const string LibFileName = "Pvr_UnitySDK";

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_StartSDKBoundary();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_ShutdownSDKBoundary();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetMainSensorStateExt(ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz, ref float vfov, ref float hfov, ref int viewNumber);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr Pvr_GetCameraData_Ext();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_ResetVrModebyForce();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_ResumeBoundaryForSTS();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_PauseBoundaryForSTS();

		public static int UPvr_GetMainSensorStateExt(ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz, ref float vfov, ref float hfov, ref int viewNumber)
		{
			return Pvr_GetMainSensorStateExt(ref x, ref y, ref z, ref w, ref px, ref py, ref pz, ref vfov, ref hfov, ref viewNumber);
		}

		public static IntPtr UPvr_GetCameraData_Ext()
		{
			_ = IntPtr.Zero;
			return Pvr_GetCameraData_Ext();
		}

		public static bool UPvr_ResumeBoundaryForSTS()
		{
			return Pvr_ResumeBoundaryForSTS();
		}

		public static void UPvr_PauseBoundaryForSTS()
		{
			Pvr_PauseBoundaryForSTS();
		}

		public static IntPtr StructToIntPtr<T>(T info)
		{
			IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(info));
			Marshal.StructureToPtr(info, intPtr, fDeleteOld: true);
			return intPtr;
		}

		public static T IntPtrToStruct<T>(IntPtr info)
		{
			return (T)Marshal.PtrToStructure(info, typeof(T));
		}
	}
	internal static class Pvr_SafeAreaAlgoAPI
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		public delegate void SafeAreaCallback(IntPtr lineCollectionPtr, IntPtr safeAreaRectPtr);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		public delegate void SafeAreaCallbackShrink(IntPtr lineCollectionPtr, IntPtr safeAreaDetailRectPtr);

		public struct GSAPoint3i
		{
			public int x;

			public int y;

			public int z;
		}

		public struct GSALine
		{
			public IntPtr pointArray;

			public int pointCount;
		}

		public struct GSALineCollection
		{
			public IntPtr lineArray;

			public int lineCount;
		}

		public struct GSALegalData
		{
			public int overMaxRange;

			public int includeBigGrap;

			public int bigGapNum;

			public int centerOut;

			public int removeNarrow;

			public int overMaxRange_more;

			public int validShrinkArea;
		}

		public struct GSARect
		{
			public GSAPoint3i leftup;

			public GSAPoint3i leftdown;

			public GSAPoint3i rightup;

			public GSAPoint3i rightdown;

			public GSAPoint3i center;

			public uint width;

			public uint height;

			public int isLegal;

			public GSALegalData legalData;
		}

		private const string LibFileName = "SafetyArea";

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSAInit(int width, int height);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSAShutDown();

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSASetCallback(SafeAreaCallback cb);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSASetCallbackShrink(SafeAreaCallbackShrink cb);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSAUpDateData(IntPtr lineCollectionPtr);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSASetConfigFilePath(IntPtr configPath);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool GSAGetClosedAreaUpdateFlag();

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSALoadSafetyArea(IntPtr lineCollectionPtr);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern double GSABoundaryDetector(ref GSAPoint3i pointPtr);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSALoadSafetyArea2(IntPtr lineCollectionPtr, bool isPlayArea);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern double GSABoundaryDetector2(ref GSAPoint3i point, bool isPlayArea, ref GSAPoint3i closestPoint, ref GSAPoint3i normalDir);

		public static int Pvr_GSAInit(int width, int height)
		{
			return GSAInit(width, height);
		}

		public static int Pvr_GSASetCallback(SafeAreaCallback cb)
		{
			return GSASetCallback(cb);
		}

		public static int Pvr_GSASetCallbackShrink(SafeAreaCallbackShrink cb)
		{
			return GSASetCallbackShrink(cb);
		}

		public static int Pvr_GSAUpDateData(IntPtr lineCollectionPtr)
		{
			return GSAUpDateData(lineCollectionPtr);
		}

		public static bool Pvr_GSAGetClosedAreaUpdateFlag()
		{
			return GSAGetClosedAreaUpdateFlag();
		}

		public static int Pvr_GSASetConfigFilePath(string configPath)
		{
			int num = -1;
			IntPtr intPtr = Marshal.StringToHGlobalAnsi(configPath);
			num = GSASetConfigFilePath(intPtr);
			Marshal.FreeHGlobal(intPtr);
			return num;
		}

		public static int Pvr_GSALoadSafetyArea(IntPtr lineCollectionPtr)
		{
			return GSALoadSafetyArea(lineCollectionPtr);
		}

		public static double Pvr_GSABoundaryDetector(ref GSAPoint3i point)
		{
			return GSABoundaryDetector(ref point);
		}

		public static int Pvr_GSAShutDown()
		{
			return GSAShutDown();
		}

		public static int Pvr_GSALoadSafetyArea2(IntPtr lineCollectionPtr, bool isPlayArea)
		{
			return GSALoadSafetyArea2(lineCollectionPtr, isPlayArea);
		}

		public static double Pvr_GSABoundaryDetector2(ref GSAPoint3i point, bool isPlayArea, ref GSAPoint3i closestPoint, ref GSAPoint3i normalDir)
		{
			return GSABoundaryDetector2(ref point, isPlayArea, ref closestPoint, ref normalDir);
		}
	}
	public class Pvr_BoundarySystem
	{
		private static Pvr_BoundarySystem instance;

		public const int CameraImageWidth = 1280;

		public const int CameraImageHeight = 400;

		public IntPtr CameraFramePtr = IntPtr.Zero;

		public static Pvr_BoundarySystem Instance
		{
			get
			{
				if (instance == null)
				{
					instance = new Pvr_BoundarySystem();
				}
				return instance;
			}
		}

		public void OpenBoundary()
		{
			Pvr_BoundaryAPI.Pvr_StartSDKBoundary();
		}

		public void CloseBoundary()
		{
			Pvr_BoundaryAPI.Pvr_ShutdownSDKBoundary();
		}

		public void Reset6Dof()
		{
			Pvr_BoundaryAPI.Pvr_ResetVrModebyForce();
		}

		public float[] GetControllerFixedPoseData(int hand)
		{
			float[] result = new float[7] { 0f, 0f, 0f, 1f, 0f, 0f, 0f };
			if (Pvr_ControllerManager.controllerlink != null)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, Pvr_ControllerManager.controllerlink.javaCVClass, "getControllerFixedSensorState", hand);
			}
			result[2] = 0f - result[2];
			result[3] = 0f - result[3];
			return result;
		}
	}
	public class Pvr_SafeAreaAlgoModule
	{
		public struct ExtraInfo
		{
			public bool overMaxRange;

			public bool includeBigGap;

			public int bigGapNum;

			public bool centerOut;

			public bool removeNarrow;

			public bool overMaxRange_more;

			public int validShrinkArea;
		}

		public struct BoundaryPlayerArea
		{
			public Vector3 lowerleft;

			public Vector3 upperleft;

			public Vector3 upperRight;

			public Vector3 lowerRight;

			public Vector3 center;

			public uint width;

			public uint height;

			public bool isLegal;

			public ExtraInfo extraInfo;
		}

		public delegate void BoundarySystemCallback(BoundaryPlayerArea playAreaInfo, List<Vector3> boundaryPoints, List<List<Vector3>> unusedLines);

		public delegate void BoundarySystemCallbackShrink(List<Vector3> rectPoints, List<Vector3> boundaryPoints, List<List<Vector3>> unusedLines);

		private static Pvr_SafeAreaAlgoModule instance;

		private BoundarySystemCallback boundarySystemCallback;

		private BoundarySystemCallbackShrink boundarySystemCallbackShrink;

		public static Pvr_SafeAreaAlgoModule Instance
		{
			get
			{
				if (instance == null)
				{
					instance = new Pvr_SafeAreaAlgoModule();
				}
				return instance;
			}
		}

		public void RegisterCallBack(BoundarySystemCallback callback)
		{
			boundarySystemCallback = callback;
		}

		public void RegisterCallBackShrink(BoundarySystemCallbackShrink callback)
		{
			boundarySystemCallbackShrink = callback;
		}

		public bool Start()
		{
			int num = Pvr_SafeAreaAlgoAPI.Pvr_GSASetCallback(_SafeAreaCallback);
			int num2 = Pvr_SafeAreaAlgoAPI.Pvr_GSASetCallbackShrink(_SafeAreaCallbackShrink);
			if (num != 0 || num2 != 0)
			{
				UnityEngine.Debug.LogError("BoundarySystem register callback failed!");
				return false;
			}
			if (Pvr_SafeAreaAlgoAPI.Pvr_GSAInit(300, 300) != 0)
			{
				UnityEngine.Debug.LogError("BoundarySystem init failed!");
				return false;
			}
			return true;
		}

		public bool CommitNewLineData(bool isFistLine, Vector3[] points)
		{
			Pvr_SafeAreaAlgoAPI.GSALineCollection info = default(Pvr_SafeAreaAlgoAPI.GSALineCollection);
			info.lineCount = 2;
			Pvr_SafeAreaAlgoAPI.GSALine[] array = new Pvr_SafeAreaAlgoAPI.GSALine[2];
			if (isFistLine)
			{
				array[0].pointArray = IntPtr.Zero;
				array[0].pointCount = 0;
			}
			else
			{
				Pvr_SafeAreaAlgoAPI.GSAPoint3i[] arr = new Pvr_SafeAreaAlgoAPI.GSAPoint3i[1]
				{
					new Pvr_SafeAreaAlgoAPI.GSAPoint3i
					{
						x = 0,
						y = 0,
						z = 0
					}
				};
				array[0].pointArray = Marshal.UnsafeAddrOfPinnedArrayElement(arr, 0);
				array[0].pointCount = 1;
			}
			Pvr_SafeAreaAlgoAPI.GSAPoint3i[] array2 = new Pvr_SafeAreaAlgoAPI.GSAPoint3i[points.Length];
			for (int i = 0; i < points.Length; i++)
			{
				Pvr_SafeAreaAlgoAPI.GSAPoint3i gSAPoint3i = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
				gSAPoint3i.x = (int)(points[i].x * 1000f);
				gSAPoint3i.y = (int)(points[i].y * 1000f);
				gSAPoint3i.z = (int)(points[i].z * 1000f);
				array2[i] = gSAPoint3i;
			}
			array[1].pointArray = Marshal.UnsafeAddrOfPinnedArrayElement(array2, 0);
			array[1].pointCount = array2.Length;
			info.lineArray = Marshal.UnsafeAddrOfPinnedArrayElement(array, 0);
			IntPtr intPtr = Pvr_BoundaryAPI.StructToIntPtr(info);
			int num = Pvr_SafeAreaAlgoAPI.Pvr_GSAUpDateData(intPtr);
			Marshal.FreeHGlobal(intPtr);
			if (num != 0)
			{
				UnityEngine.Debug.LogError("BoundarySystem commit new line data failed!");
				return false;
			}
			return true;
		}

		public bool Shutdown()
		{
			if (Pvr_SafeAreaAlgoAPI.Pvr_GSAShutDown() != 0)
			{
				UnityEngine.Debug.LogError("BoundarySystem shutdown failed!");
				return false;
			}
			return true;
		}

		public double QueryDistanceOfPoint(Vector3 point)
		{
			Pvr_SafeAreaAlgoAPI.GSAPoint3i point2 = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
			point2.x = (int)(point.x * 1000f);
			point2.y = (int)(point.y * 1000f);
			point2.z = (int)(point.z * 1000f);
			return Pvr_SafeAreaAlgoAPI.Pvr_GSABoundaryDetector(ref point2) / 1000.0;
		}

		public double QueryDistanceOfPoint(Vector3 point, bool isPlayArea, ref Vector3 closestPoint, ref Vector3 normalDir)
		{
			Pvr_SafeAreaAlgoAPI.GSAPoint3i point2 = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
			point2.x = (int)(point.x * 1000f);
			point2.y = (int)(point.y * 1000f);
			point2.z = (int)(point.z * 1000f);
			Pvr_SafeAreaAlgoAPI.GSAPoint3i closestPoint2 = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
			Pvr_SafeAreaAlgoAPI.GSAPoint3i normalDir2 = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
			double num = Pvr_SafeAreaAlgoAPI.Pvr_GSABoundaryDetector2(ref point2, isPlayArea, ref closestPoint2, ref normalDir2);
			closestPoint.x = (float)closestPoint2.x / 1000f;
			closestPoint.y = (float)closestPoint2.y / 1000f;
			closestPoint.z = (float)closestPoint2.z / 1000f;
			normalDir.x = (float)normalDir2.x / 1000f;
			normalDir.y = (float)normalDir2.y / 1000f;
			normalDir.z = (float)normalDir2.z / 1000f;
			return num / 1000.0;
		}

		[MonoPInvokeCallback(typeof(Pvr_SafeAreaAlgoAPI.SafeAreaCallback))]
		private static void _SafeAreaCallback(IntPtr lineCollectionPtr, IntPtr safeAreaRectPtr)
		{
			if (lineCollectionPtr == IntPtr.Zero || safeAreaRectPtr == IntPtr.Zero)
			{
				UnityEngine.Debug.LogError("BoundarySystem callback is inValid!");
			}
			else
			{
				if (instance.boundarySystemCallback == null)
				{
					return;
				}
				List<Vector3> boundaryPoints = new List<Vector3>();
				List<List<Vector3>> list = new List<List<Vector3>>();
				int num = Marshal.SizeOf(typeof(Pvr_SafeAreaAlgoAPI.GSALine));
				int num2 = Marshal.SizeOf(typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
				Pvr_SafeAreaAlgoAPI.GSALineCollection gSALineCollection = Pvr_BoundaryAPI.IntPtrToStruct<Pvr_SafeAreaAlgoAPI.GSALineCollection>(lineCollectionPtr);
				for (int i = 0; i < gSALineCollection.lineCount; i++)
				{
					Pvr_SafeAreaAlgoAPI.GSALine gSALine = (Pvr_SafeAreaAlgoAPI.GSALine)Marshal.PtrToStructure(new IntPtr(gSALineCollection.lineArray.ToInt64() + num * i), typeof(Pvr_SafeAreaAlgoAPI.GSALine));
					List<Vector3> list2 = new List<Vector3>();
					for (int j = 0; j < gSALine.pointCount; j++)
					{
						Pvr_SafeAreaAlgoAPI.GSAPoint3i gSAPoint3i = (Pvr_SafeAreaAlgoAPI.GSAPoint3i)Marshal.PtrToStructure(new IntPtr(gSALine.pointArray.ToInt64() + num2 * j), typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
						list2.Add(new Vector3((float)gSAPoint3i.x / 1000f, (float)gSAPoint3i.y / 1000f, (float)gSAPoint3i.z / 1000f));
					}
					if (i == 0)
					{
						boundaryPoints = list2;
					}
					else
					{
						list.Add(list2);
					}
				}
				Pvr_SafeAreaAlgoAPI.GSARect gSARect = Pvr_BoundaryAPI.IntPtrToStruct<Pvr_SafeAreaAlgoAPI.GSARect>(safeAreaRectPtr);
				BoundaryPlayerArea playAreaInfo = default(BoundaryPlayerArea);
				playAreaInfo.lowerleft = new Vector3((float)gSARect.leftup.x / 1000f, (float)gSARect.leftup.y / 1000f, (float)gSARect.leftup.z / 1000f);
				playAreaInfo.upperleft = new Vector3((float)gSARect.leftdown.x / 1000f, (float)gSARect.leftdown.y / 1000f, (float)gSARect.leftdown.z / 1000f);
				playAreaInfo.upperRight = new Vector3((float)gSARect.rightdown.x / 1000f, (float)gSARect.rightdown.y / 1000f, (float)gSARect.rightdown.z / 1000f);
				playAreaInfo.lowerRight = new Vector3((float)gSARect.rightup.x / 1000f, (float)gSARect.rightup.y / 1000f, (float)gSARect.rightup.z / 1000f);
				playAreaInfo.center = new Vector3((float)gSARect.center.x / 1000f, (float)gSARect.center.y / 1000f, (float)gSARect.center.z / 1000f);
				playAreaInfo.width = gSARect.width;
				playAreaInfo.height = gSARect.height;
				playAreaInfo.isLegal = ((gSARect.isLegal != 0) ? true : false);
				playAreaInfo.extraInfo.overMaxRange = ((gSARect.legalData.overMaxRange != 0) ? true : false);
				playAreaInfo.extraInfo.includeBigGap = ((gSARect.legalData.includeBigGrap != 0) ? true : false);
				playAreaInfo.extraInfo.bigGapNum = gSARect.legalData.bigGapNum;
				playAreaInfo.extraInfo.centerOut = ((gSARect.legalData.centerOut != 0) ? true : false);
				playAreaInfo.extraInfo.removeNarrow = ((gSARect.legalData.removeNarrow != 0) ? true : false);
				playAreaInfo.extraInfo.overMaxRange_more = ((gSARect.legalData.overMaxRange_more != 0) ? true : false);
				playAreaInfo.extraInfo.validShrinkArea = gSARect.legalData.validShrinkArea;
				instance.boundarySystemCallback(playAreaInfo, boundaryPoints, list);
			}
		}

		[MonoPInvokeCallback(typeof(Pvr_SafeAreaAlgoAPI.SafeAreaCallbackShrink))]
		private static void _SafeAreaCallbackShrink(IntPtr lineCollectionPtr, IntPtr safeAreaDetailRectPtr)
		{
			if (lineCollectionPtr == IntPtr.Zero || safeAreaDetailRectPtr == IntPtr.Zero)
			{
				UnityEngine.Debug.LogError("BoundarySystem callback is inValid!");
			}
			else
			{
				if (instance.boundarySystemCallbackShrink == null)
				{
					return;
				}
				List<Vector3> boundaryPoints = new List<Vector3>();
				List<List<Vector3>> list = new List<List<Vector3>>();
				int num = Marshal.SizeOf(typeof(Pvr_SafeAreaAlgoAPI.GSALine));
				int num2 = Marshal.SizeOf(typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
				Pvr_SafeAreaAlgoAPI.GSALineCollection gSALineCollection = Pvr_BoundaryAPI.IntPtrToStruct<Pvr_SafeAreaAlgoAPI.GSALineCollection>(lineCollectionPtr);
				for (int i = 0; i < gSALineCollection.lineCount; i++)
				{
					Pvr_SafeAreaAlgoAPI.GSALine gSALine = (Pvr_SafeAreaAlgoAPI.GSALine)Marshal.PtrToStructure(new IntPtr(gSALineCollection.lineArray.ToInt64() + num * i), typeof(Pvr_SafeAreaAlgoAPI.GSALine));
					List<Vector3> list2 = new List<Vector3>();
					for (int j = 0; j < gSALine.pointCount; j++)
					{
						Pvr_SafeAreaAlgoAPI.GSAPoint3i gSAPoint3i = (Pvr_SafeAreaAlgoAPI.GSAPoint3i)Marshal.PtrToStructure(new IntPtr(gSALine.pointArray.ToInt64() + num2 * j), typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
						list2.Add(new Vector3((float)gSAPoint3i.x / 1000f, (float)gSAPoint3i.y / 1000f, (float)gSAPoint3i.z / 1000f));
					}
					if (i == 0)
					{
						boundaryPoints = list2;
					}
					else
					{
						list.Add(list2);
					}
				}
				List<Vector3> list3 = new List<Vector3>();
				Pvr_SafeAreaAlgoAPI.GSALineCollection gSALineCollection2 = Pvr_BoundaryAPI.IntPtrToStruct<Pvr_SafeAreaAlgoAPI.GSALineCollection>(safeAreaDetailRectPtr);
				for (int k = 0; k < gSALineCollection2.lineCount; k++)
				{
					Pvr_SafeAreaAlgoAPI.GSALine gSALine2 = (Pvr_SafeAreaAlgoAPI.GSALine)Marshal.PtrToStructure(new IntPtr(gSALineCollection2.lineArray.ToInt64() + num * k), typeof(Pvr_SafeAreaAlgoAPI.GSALine));
					for (int l = 0; l < gSALine2.pointCount; l++)
					{
						Pvr_SafeAreaAlgoAPI.GSAPoint3i gSAPoint3i2 = (Pvr_SafeAreaAlgoAPI.GSAPoint3i)Marshal.PtrToStructure(new IntPtr(gSALine2.pointArray.ToInt64() + num2 * l), typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
						list3.Add(new Vector3((float)gSAPoint3i2.x / 1000f, (float)gSAPoint3i2.y / 1000f, (float)gSAPoint3i2.z / 1000f));
					}
				}
				instance.boundarySystemCallbackShrink(list3, boundaryPoints, list);
			}
		}
	}
}
namespace Pvr_UnitySDKAPI
{
	public class PvrControllerKey
	{
		public bool State;

		public bool PressedDown;

		public bool PressedUp;

		public bool LongPressed;

		public bool Click;

		public bool Touch;

		public bool TouchDown;

		public bool TouchUp;

		public PvrControllerKey()
		{
			State = false;
			PressedDown = false;
			PressedUp = false;
			LongPressed = false;
			Click = false;
			Touch = false;
			TouchDown = false;
			TouchUp = false;
		}
	}
	public class ControllerHand
	{
		public PvrControllerKey App;

		public PvrControllerKey Touch;

		public PvrControllerKey Home;

		public PvrControllerKey VolumeDown;

		public PvrControllerKey VolumeUp;

		public PvrControllerKey Trigger;

		public PvrControllerKey X;

		public PvrControllerKey Y;

		public PvrControllerKey A;

		public PvrControllerKey B;

		public PvrControllerKey Left;

		public PvrControllerKey Right;

		public PvrControllerKey Thumbrest;

		public Vector2 TouchPadPosition;

		public int TriggerNum;

		public int GripValue;

		public Quaternion Rotation;

		public Vector3 Position;

		public int Battery;

		public ControllerState ConnectState;

		public SwipeDirection SwipeDirection;

		public TouchPadClick TouchPadClick;

		public bool isShowBoundary;

		public ControllerHand()
		{
			App = new PvrControllerKey();
			Touch = new PvrControllerKey();
			Home = new PvrControllerKey();
			VolumeDown = new PvrControllerKey();
			VolumeUp = new PvrControllerKey();
			Trigger = new PvrControllerKey();
			A = new PvrControllerKey();
			B = new PvrControllerKey();
			X = new PvrControllerKey();
			Y = new PvrControllerKey();
			Left = new PvrControllerKey();
			Right = new PvrControllerKey();
			Thumbrest = new PvrControllerKey();
			TouchPadPosition = default(Vector2);
			Rotation = default(Quaternion);
			Position = default(Vector3);
			Battery = 0;
			TriggerNum = 0;
			GripValue = 0;
			ConnectState = ControllerState.Error;
			SwipeDirection = SwipeDirection.No;
			TouchPadClick = TouchPadClick.No;
			isShowBoundary = false;
		}
	}
	public enum ControllerState
	{
		Error = -1,
		DisConnected,
		Connected
	}
	public enum Pvr_KeyCode
	{
		None = 0,
		APP = 1,
		TOUCHPAD = 2,
		HOME = 4,
		VOLUMEUP = 8,
		VOLUMEDOWN = 16,
		TRIGGER = 32,
		A = 64,
		B = 128,
		X = 256,
		Y = 512,
		Left = 1024,
		Right = 2048,
		Thumbrest = 4096,
		Any = -1
	}
	public enum SwipeDirection
	{
		No,
		SwipeUp,
		SwipeDown,
		SwipeLeft,
		SwipeRight
	}
	public enum TouchPadClick
	{
		No,
		ClickUp,
		ClickDown,
		ClickLeft,
		ClickRight
	}
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	public struct Controller
	{
		private const float JOYSTICK_THRESHOLD = 0.4f;

		public const string LibFileName = "Pvr_UnitySDK";

		public static Vector2 UPvr_GetTouchPadPosition(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition, 
				_ => new Vector2(0f, 0f), 
			};
		}

		public static float UPvr_GetAxis1D(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.TRIGGER => (float)Pvr_ControllerManager.controllerlink.Controller0.TriggerNum / 255f, 
					Pvr_KeyCode.Left => (float)Pvr_ControllerManager.controllerlink.Controller0.GripValue / 255f, 
					_ => 0f, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.TRIGGER => (float)Pvr_ControllerManager.controllerlink.Controller1.TriggerNum / 255f, 
					Pvr_KeyCode.Right => (float)Pvr_ControllerManager.controllerlink.Controller1.GripValue / 255f, 
					_ => 0f, 
				}, 
				_ => 0f, 
			};
		}

		public static Vector2 UPvr_GetAxis2D(int hand)
		{
			switch (hand)
			{
			case 0:
				if (Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition != Vector2.zero)
				{
					Vector2 result2 = new Vector2(Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.x / 128f - 1f, Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.y / 128f - 1f);
					if (result2.x > 1f || result2.x < -1f || result2.y > 1f || result2.y < -1f)
					{
						return Vector2.zero;
					}
					return result2;
				}
				return Vector2.zero;
			case 1:
				if (Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition != Vector2.zero)
				{
					Vector2 result = new Vector2(Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.x / 128f - 1f, Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.y / 128f - 1f);
					if (result.x > 1f || result.x < -1f || result.y > 1f || result.y < -1f)
					{
						return Vector2.zero;
					}
					return result;
				}
				return Vector2.zero;
			default:
				return Vector2.zero;
			}
		}

		public static bool UPvr_GetJoystickUp(int hand)
		{
			switch (hand)
			{
			case 0:
				if (Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition != Vector2.zero)
				{
					float value2 = Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.x / 128f - 1f;
					float num2 = Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.y / 128f - 1f;
					if (num2 > 0.4f && num2 > Math.Abs(value2))
					{
						return true;
					}
				}
				return false;
			case 1:
				if (Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition != Vector2.zero)
				{
					float value = Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.x / 128f - 1f;
					float num = Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.y / 128f - 1f;
					if (num > 0.4f && num > Math.Abs(value))
					{
						return true;
					}
				}
				return false;
			default:
				return false;
			}
		}

		public static bool UPvr_GetJoystickDown(int hand)
		{
			switch (hand)
			{
			case 0:
				if (Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition != Vector2.zero)
				{
					float value2 = Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.x / 128f - 1f;
					float num2 = Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.y / 128f - 1f;
					if (0f - num2 > 0.4f && 0f - num2 > Math.Abs(value2))
					{
						return true;
					}
				}
				return false;
			case 1:
				if (Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition != Vector2.zero)
				{
					float value = Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.x / 128f - 1f;
					float num = Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.y / 128f - 1f;
					if (0f - num > 0.4f && 0f - num > Math.Abs(value))
					{
						return true;
					}
				}
				return false;
			default:
				return false;
			}
		}

		public static bool UPvr_GetJoystickLeft(int hand)
		{
			switch (hand)
			{
			case 0:
				if (Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition != Vector2.zero)
				{
					float num2 = Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.x / 128f - 1f;
					float value2 = Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.y / 128f - 1f;
					if (0f - num2 > 0.4f && 0f - num2 > Math.Abs(value2))
					{
						return true;
					}
				}
				return false;
			case 1:
				if (Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition != Vector2.zero)
				{
					float num = Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.x / 128f - 1f;
					float value = Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.y / 128f - 1f;
					if (0f - num > 0.4f && 0f - num > Math.Abs(value))
					{
						return true;
					}
				}
				return false;
			default:
				return false;
			}
		}

		public static bool UPvr_GetJoystickRight(int hand)
		{
			switch (hand)
			{
			case 0:
				if (Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition != Vector2.zero)
				{
					float num2 = Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.x / 128f - 1f;
					float value2 = Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.y / 128f - 1f;
					if (num2 > 0.4f && num2 > Math.Abs(value2))
					{
						return true;
					}
				}
				return false;
			case 1:
				if (Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition != Vector2.zero)
				{
					float num = Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.x / 128f - 1f;
					float value = Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.y / 128f - 1f;
					if (num > 0.4f && num > Math.Abs(value))
					{
						return true;
					}
				}
				return false;
			default:
				return false;
			}
		}

		public static ControllerState UPvr_GetControllerState(int hand)
		{
			return hand switch
			{
				0 => (ControllerState)Convert.ToInt16(Pvr_ControllerManager.controllerlink.controller0Connected), 
				1 => (ControllerState)Convert.ToInt16(Pvr_ControllerManager.controllerlink.controller1Connected), 
				_ => ControllerState.Error, 
			};
		}

		public static Quaternion UPvr_GetControllerQUA(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.Rotation, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.Rotation, 
				_ => new Quaternion(0f, 0f, 0f, 1f), 
			};
		}

		public static Vector3 UPvr_GetControllerPOS(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.Position, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.Position, 
				_ => new Vector3(0f, 0f, 0f), 
			};
		}

		public static Quaternion UPvr_GetControllerPredictRotation(int hand, float predictTime)
		{
			float[] controllerPredictSensorData = Pvr_ControllerManager.controllerlink.GetControllerPredictSensorData(hand, predictTime);
			return new Quaternion(controllerPredictSensorData[0], controllerPredictSensorData[1], controllerPredictSensorData[2], controllerPredictSensorData[3]);
		}

		public static Vector3 UPvr_GetControllerPredictPosition(int hand, float predictTime)
		{
			float[] controllerPredictSensorData = Pvr_ControllerManager.controllerlink.GetControllerPredictSensorData(hand, predictTime);
			return new Vector3(controllerPredictSensorData[4] / 1000f, controllerPredictSensorData[5] / 1000f, (0f - controllerPredictSensorData[6]) / 1000f);
		}

		public static int UPvr_GetControllerTriggerValue(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.TriggerNum, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.TriggerNum, 
				_ => 0, 
			};
		}

		public static int UPvr_GetControllerPower(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.Battery, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.Battery, 
				_ => 0, 
			};
		}

		public static int UPvr_GetControllerPowerByPercent(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.Battery * 20, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.Battery * 20, 
				_ => 0, 
			};
		}

		public static SwipeDirection UPvr_GetSwipeDirection(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.SwipeDirection, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.SwipeDirection, 
				_ => SwipeDirection.No, 
			};
		}

		public static TouchPadClick UPvr_GetTouchPadClick(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.TouchPadClick, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.TouchPadClick, 
				_ => TouchPadClick.No, 
			};
		}

		public static bool UPvr_GetKey(int hand, Pvr_KeyCode key)
		{
			bool flag = false;
			if (hand == 0)
			{
				if ((Pvr_KeyCode.APP & key) == Pvr_KeyCode.APP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.App.State;
				}
				if ((Pvr_KeyCode.HOME & key) == Pvr_KeyCode.HOME)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Home.State;
				}
				if ((Pvr_KeyCode.TOUCHPAD & key) == Pvr_KeyCode.TOUCHPAD)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Touch.State;
				}
				if ((Pvr_KeyCode.VOLUMEUP & key) == Pvr_KeyCode.VOLUMEUP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.State;
				}
				if ((Pvr_KeyCode.VOLUMEDOWN & key) == Pvr_KeyCode.VOLUMEDOWN)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.State;
				}
				if ((Pvr_KeyCode.TRIGGER & key) == Pvr_KeyCode.TRIGGER)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Trigger.State;
				}
				if ((Pvr_KeyCode.X & key) == Pvr_KeyCode.X)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.X.State;
				}
				if ((Pvr_KeyCode.Y & key) == Pvr_KeyCode.Y)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Y.State;
				}
				if ((Pvr_KeyCode.Left & key) == Pvr_KeyCode.Left)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Left.State;
				}
			}
			if (hand == 1)
			{
				if ((Pvr_KeyCode.APP & key) == Pvr_KeyCode.APP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.App.State;
				}
				if ((Pvr_KeyCode.HOME & key) == Pvr_KeyCode.HOME)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Home.State;
				}
				if ((Pvr_KeyCode.TOUCHPAD & key) == Pvr_KeyCode.TOUCHPAD)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Touch.State;
				}
				if ((Pvr_KeyCode.VOLUMEUP & key) == Pvr_KeyCode.VOLUMEUP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.State;
				}
				if ((Pvr_KeyCode.VOLUMEDOWN & key) == Pvr_KeyCode.VOLUMEDOWN)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.State;
				}
				if ((Pvr_KeyCode.TRIGGER & key) == Pvr_KeyCode.TRIGGER)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Trigger.State;
				}
				if ((Pvr_KeyCode.A & key) == Pvr_KeyCode.A)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.A.State;
				}
				if ((Pvr_KeyCode.B & key) == Pvr_KeyCode.B)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.B.State;
				}
				if ((Pvr_KeyCode.Right & key) == Pvr_KeyCode.Right)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Right.State;
				}
			}
			return flag;
		}

		public static bool UPvr_GetKeyDown(int hand, Pvr_KeyCode key)
		{
			bool flag = false;
			if (hand == 0)
			{
				if ((Pvr_KeyCode.APP & key) == Pvr_KeyCode.APP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.App.PressedDown;
				}
				if ((Pvr_KeyCode.HOME & key) == Pvr_KeyCode.HOME)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Home.PressedDown;
				}
				if ((Pvr_KeyCode.TOUCHPAD & key) == Pvr_KeyCode.TOUCHPAD)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Touch.PressedDown;
				}
				if ((Pvr_KeyCode.VOLUMEUP & key) == Pvr_KeyCode.VOLUMEUP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.PressedDown;
				}
				if ((Pvr_KeyCode.VOLUMEDOWN & key) == Pvr_KeyCode.VOLUMEDOWN)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.PressedDown;
				}
				if ((Pvr_KeyCode.TRIGGER & key) == Pvr_KeyCode.TRIGGER)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Trigger.PressedDown;
				}
				if ((Pvr_KeyCode.X & key) == Pvr_KeyCode.X)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.X.PressedDown;
				}
				if ((Pvr_KeyCode.Y & key) == Pvr_KeyCode.Y)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Y.PressedDown;
				}
				if ((Pvr_KeyCode.Left & key) == Pvr_KeyCode.Left)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Left.PressedDown;
				}
			}
			if (hand == 1)
			{
				if ((Pvr_KeyCode.APP & key) == Pvr_KeyCode.APP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.App.PressedDown;
				}
				if ((Pvr_KeyCode.HOME & key) == Pvr_KeyCode.HOME)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Home.PressedDown;
				}
				if ((Pvr_KeyCode.TOUCHPAD & key) == Pvr_KeyCode.TOUCHPAD)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Touch.PressedDown;
				}
				if ((Pvr_KeyCode.VOLUMEUP & key) == Pvr_KeyCode.VOLUMEUP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.PressedDown;
				}
				if ((Pvr_KeyCode.VOLUMEDOWN & key) == Pvr_KeyCode.VOLUMEDOWN)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.PressedDown;
				}
				if ((Pvr_KeyCode.TRIGGER & key) == Pvr_KeyCode.TRIGGER)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Trigger.PressedDown;
				}
				if ((Pvr_KeyCode.A & key) == Pvr_KeyCode.A)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.A.PressedDown;
				}
				if ((Pvr_KeyCode.B & key) == Pvr_KeyCode.B)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.B.PressedDown;
				}
				if ((Pvr_KeyCode.Right & key) == Pvr_KeyCode.Right)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Right.PressedDown;
				}
			}
			return flag;
		}

		public static bool UPvr_GetKeyUp(int hand, Pvr_KeyCode key)
		{
			bool flag = false;
			if (hand == 0)
			{
				if ((Pvr_KeyCode.APP & key) == Pvr_KeyCode.APP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.App.PressedUp;
				}
				if ((Pvr_KeyCode.HOME & key) == Pvr_KeyCode.HOME)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Home.PressedUp;
				}
				if ((Pvr_KeyCode.TOUCHPAD & key) == Pvr_KeyCode.TOUCHPAD)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Touch.PressedUp;
				}
				if ((Pvr_KeyCode.VOLUMEUP & key) == Pvr_KeyCode.VOLUMEUP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.PressedUp;
				}
				if ((Pvr_KeyCode.VOLUMEDOWN & key) == Pvr_KeyCode.VOLUMEDOWN)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.PressedUp;
				}
				if ((Pvr_KeyCode.TRIGGER & key) == Pvr_KeyCode.TRIGGER)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Trigger.PressedUp;
				}
				if ((Pvr_KeyCode.X & key) == Pvr_KeyCode.X)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.X.PressedUp;
				}
				if ((Pvr_KeyCode.Y & key) == Pvr_KeyCode.Y)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Y.PressedUp;
				}
				if ((Pvr_KeyCode.Left & key) == Pvr_KeyCode.Left)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Left.PressedUp;
				}
			}
			if (hand == 1)
			{
				if ((Pvr_KeyCode.APP & key) == Pvr_KeyCode.APP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.App.PressedUp;
				}
				if ((Pvr_KeyCode.HOME & key) == Pvr_KeyCode.HOME)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Home.PressedUp;
				}
				if ((Pvr_KeyCode.TOUCHPAD & key) == Pvr_KeyCode.TOUCHPAD)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Touch.PressedUp;
				}
				if ((Pvr_KeyCode.VOLUMEUP & key) == Pvr_KeyCode.VOLUMEUP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.PressedUp;
				}
				if ((Pvr_KeyCode.VOLUMEDOWN & key) == Pvr_KeyCode.VOLUMEDOWN)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.PressedUp;
				}
				if ((Pvr_KeyCode.TRIGGER & key) == Pvr_KeyCode.TRIGGER)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Trigger.PressedUp;
				}
				if ((Pvr_KeyCode.A & key) == Pvr_KeyCode.A)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.A.PressedUp;
				}
				if ((Pvr_KeyCode.B & key) == Pvr_KeyCode.B)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.B.PressedUp;
				}
				if ((Pvr_KeyCode.Right & key) == Pvr_KeyCode.Right)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Right.PressedUp;
				}
			}
			return flag;
		}

		public static bool UPvr_GetTouch(int hand, Pvr_KeyCode key)
		{
			bool flag = false;
			if (hand == 0)
			{
				if ((Pvr_KeyCode.TOUCHPAD & key) == Pvr_KeyCode.TOUCHPAD)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Touch.Touch;
				}
				if ((Pvr_KeyCode.TRIGGER & key) == Pvr_KeyCode.TRIGGER)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Trigger.Touch;
				}
				if ((Pvr_KeyCode.X & key) == Pvr_KeyCode.X)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.X.Touch;
				}
				if ((Pvr_KeyCode.Y & key) == Pvr_KeyCode.Y)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Y.Touch;
				}
				if ((Pvr_KeyCode.Thumbrest & key) == Pvr_KeyCode.Thumbrest)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Thumbrest.Touch;
				}
			}
			if (hand == 1)
			{
				if ((Pvr_KeyCode.TOUCHPAD & key) == Pvr_KeyCode.TOUCHPAD)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Touch.Touch;
				}
				if ((Pvr_KeyCode.TRIGGER & key) == Pvr_KeyCode.TRIGGER)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Trigger.Touch;
				}
				if ((Pvr_KeyCode.A & key) == Pvr_KeyCode.A)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.A.Touch;
				}
				if ((Pvr_KeyCode.B & key) == Pvr_KeyCode.B)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.B.Touch;
				}
				if ((Pvr_KeyCode.Thumbrest & key) == Pvr_KeyCode.Thumbrest)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Thumbrest.Touch;
				}
			}
			return flag;
		}

		public static bool UPvr_GetTouchDown(int hand, Pvr_KeyCode key)
		{
			bool flag = false;
			if (hand == 0)
			{
				if ((Pvr_KeyCode.TOUCHPAD & key) == Pvr_KeyCode.TOUCHPAD)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Touch.TouchDown;
				}
				if ((Pvr_KeyCode.TRIGGER & key) == Pvr_KeyCode.TRIGGER)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Trigger.TouchDown;
				}
				if ((Pvr_KeyCode.X & key) == Pvr_KeyCode.X)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.X.TouchDown;
				}
				if ((Pvr_KeyCode.Y & key) == Pvr_KeyCode.Y)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Y.TouchDown;
				}
				if ((Pvr_KeyCode.Thumbrest & key) == Pvr_KeyCode.Thumbrest)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Thumbrest.TouchDown;
				}
			}
			if (hand == 1)
			{
				if ((Pvr_KeyCode.TOUCHPAD & key) == Pvr_KeyCode.TOUCHPAD)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Touch.TouchDown;
				}
				if ((Pvr_KeyCode.TRIGGER & key) == Pvr_KeyCode.TRIGGER)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Trigger.TouchDown;
				}
				if ((Pvr_KeyCode.A & key) == Pvr_KeyCode.A)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.A.TouchDown;
				}
				if ((Pvr_KeyCode.B & key) == Pvr_KeyCode.B)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.B.TouchDown;
				}
				if ((Pvr_KeyCode.Thumbrest & key) == Pvr_KeyCode.Thumbrest)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Thumbrest.TouchDown;
				}
			}
			return flag;
		}

		public static bool UPvr_GetTouchUp(int hand, Pvr_KeyCode key)
		{
			bool flag = false;
			if (hand == 0)
			{
				if ((Pvr_KeyCode.TOUCHPAD & key) == Pvr_KeyCode.TOUCHPAD)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Touch.TouchUp;
				}
				if ((Pvr_KeyCode.TRIGGER & key) == Pvr_KeyCode.TRIGGER)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Trigger.TouchUp;
				}
				if ((Pvr_KeyCode.X & key) == Pvr_KeyCode.X)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.X.TouchUp;
				}
				if ((Pvr_KeyCode.Y & key) == Pvr_KeyCode.Y)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Y.TouchUp;
				}
				if ((Pvr_KeyCode.Thumbrest & key) == Pvr_KeyCode.Thumbrest)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Thumbrest.TouchUp;
				}
			}
			if (hand == 1)
			{
				if ((Pvr_KeyCode.TOUCHPAD & key) == Pvr_KeyCode.TOUCHPAD)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Touch.TouchUp;
				}
				if ((Pvr_KeyCode.TRIGGER & key) == Pvr_KeyCode.TRIGGER)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Trigger.TouchUp;
				}
				if ((Pvr_KeyCode.A & key) == Pvr_KeyCode.A)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.A.TouchUp;
				}
				if ((Pvr_KeyCode.B & key) == Pvr_KeyCode.B)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.B.TouchUp;
				}
				if ((Pvr_KeyCode.Thumbrest & key) == Pvr_KeyCode.Thumbrest)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Thumbrest.TouchUp;
				}
			}
			return flag;
		}

		public static bool UPvr_GetKeyClick(int hand, Pvr_KeyCode key)
		{
			bool flag = false;
			if (hand == 0)
			{
				if ((Pvr_KeyCode.APP & key) == Pvr_KeyCode.APP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.App.Click;
				}
				if ((Pvr_KeyCode.HOME & key) == Pvr_KeyCode.HOME)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Home.Click;
				}
				if ((Pvr_KeyCode.TOUCHPAD & key) == Pvr_KeyCode.TOUCHPAD)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Touch.Click;
				}
				if ((Pvr_KeyCode.VOLUMEUP & key) == Pvr_KeyCode.VOLUMEUP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.Click;
				}
				if ((Pvr_KeyCode.VOLUMEDOWN & key) == Pvr_KeyCode.VOLUMEDOWN)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.Click;
				}
				if ((Pvr_KeyCode.TRIGGER & key) == Pvr_KeyCode.TRIGGER)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Trigger.Click;
				}
				if ((Pvr_KeyCode.X & key) == Pvr_KeyCode.X)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.X.Click;
				}
				if ((Pvr_KeyCode.Y & key) == Pvr_KeyCode.Y)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Y.Click;
				}
				if ((Pvr_KeyCode.Left & key) == Pvr_KeyCode.Left)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Left.Click;
				}
			}
			if (hand == 1)
			{
				if ((Pvr_KeyCode.APP & key) == Pvr_KeyCode.APP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.App.Click;
				}
				if ((Pvr_KeyCode.HOME & key) == Pvr_KeyCode.HOME)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Home.Click;
				}
				if ((Pvr_KeyCode.TOUCHPAD & key) == Pvr_KeyCode.TOUCHPAD)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Touch.Click;
				}
				if ((Pvr_KeyCode.VOLUMEUP & key) == Pvr_KeyCode.VOLUMEUP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.Click;
				}
				if ((Pvr_KeyCode.VOLUMEDOWN & key) == Pvr_KeyCode.VOLUMEDOWN)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.Click;
				}
				if ((Pvr_KeyCode.TRIGGER & key) == Pvr_KeyCode.TRIGGER)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Trigger.Click;
				}
				if ((Pvr_KeyCode.A & key) == Pvr_KeyCode.A)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.A.Click;
				}
				if ((Pvr_KeyCode.B & key) == Pvr_KeyCode.B)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.B.Click;
				}
				if ((Pvr_KeyCode.Right & key) == Pvr_KeyCode.Right)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Right.Click;
				}
			}
			return flag;
		}

		public static bool UPvr_GetKeyLongPressed(int hand, Pvr_KeyCode key)
		{
			bool flag = false;
			if (hand == 0)
			{
				if ((Pvr_KeyCode.APP & key) == Pvr_KeyCode.APP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.App.LongPressed;
				}
				if ((Pvr_KeyCode.HOME & key) == Pvr_KeyCode.HOME)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Home.LongPressed;
				}
				if ((Pvr_KeyCode.TOUCHPAD & key) == Pvr_KeyCode.TOUCHPAD)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Touch.LongPressed;
				}
				if ((Pvr_KeyCode.VOLUMEUP & key) == Pvr_KeyCode.VOLUMEUP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.LongPressed;
				}
				if ((Pvr_KeyCode.VOLUMEDOWN & key) == Pvr_KeyCode.VOLUMEDOWN)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.LongPressed;
				}
				if ((Pvr_KeyCode.TRIGGER & key) == Pvr_KeyCode.TRIGGER)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Trigger.LongPressed;
				}
				if ((Pvr_KeyCode.X & key) == Pvr_KeyCode.X)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.X.LongPressed;
				}
				if ((Pvr_KeyCode.Y & key) == Pvr_KeyCode.Y)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Y.LongPressed;
				}
				if ((Pvr_KeyCode.Left & key) == Pvr_KeyCode.Left)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Left.LongPressed;
				}
			}
			if (hand == 1)
			{
				if ((Pvr_KeyCode.APP & key) == Pvr_KeyCode.APP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.App.LongPressed;
				}
				if ((Pvr_KeyCode.HOME & key) == Pvr_KeyCode.HOME)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Home.LongPressed;
				}
				if ((Pvr_KeyCode.TOUCHPAD & key) == Pvr_KeyCode.TOUCHPAD)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Touch.LongPressed;
				}
				if ((Pvr_KeyCode.VOLUMEUP & key) == Pvr_KeyCode.VOLUMEUP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.LongPressed;
				}
				if ((Pvr_KeyCode.VOLUMEDOWN & key) == Pvr_KeyCode.VOLUMEDOWN)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.LongPressed;
				}
				if ((Pvr_KeyCode.TRIGGER & key) == Pvr_KeyCode.TRIGGER)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Trigger.LongPressed;
				}
				if ((Pvr_KeyCode.A & key) == Pvr_KeyCode.A)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.A.LongPressed;
				}
				if ((Pvr_KeyCode.B & key) == Pvr_KeyCode.B)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.B.LongPressed;
				}
				if ((Pvr_KeyCode.Right & key) == Pvr_KeyCode.Right)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Right.LongPressed;
				}
			}
			return flag;
		}

		public static bool UPvr_IsTouching(int hand)
		{
			switch (hand)
			{
			case 0:
				if (!(Math.Abs(Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.x) > 0f))
				{
					return Math.Abs(Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.y) > 0f;
				}
				return true;
			case 1:
				if (!(Math.Abs(Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.x) > 0f))
				{
					return Math.Abs(Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.y) > 0f;
				}
				return true;
			default:
				return false;
			}
		}

		public static void UPvr_SetHandNess(Pvr_Controller.UserHandNess hand)
		{
			if (Pvr_ControllerManager.controllerlink.getHandness() != (int)hand)
			{
				Pvr_ControllerManager.controllerlink.setHandness((int)hand);
			}
		}

		public static Pvr_Controller.UserHandNess UPvr_GetHandNess()
		{
			return Pvr_ControllerManager.controllerlink.handness;
		}

		public static int UPvr_GetPreferenceDevice()
		{
			int trackingmode = Pvr_ControllerManager.controllerlink.trackingmode;
			int systemProp = Pvr_ControllerManager.controllerlink.systemProp;
			if (trackingmode == 0 || trackingmode == 1 || ((trackingmode == 3 || trackingmode == 5 || trackingmode == 6) && (systemProp == 1 || systemProp == 3)))
			{
				return 1;
			}
			return 2;
		}

		public static bool UPvr_IsEnbleTrigger()
		{
			return Pvr_ControllerManager.controllerlink.IsEnbleTrigger();
		}

		public static int UPvr_GetDeviceType()
		{
			return Pvr_ControllerManager.controllerlink.controllerType;
		}

		public static int UPvr_GetMainHandNess()
		{
			return Pvr_ControllerManager.controllerlink.mainHandID;
		}

		public static void UPvr_SetMainHandNess(int hand)
		{
			Pvr_ControllerManager.controllerlink.SetMainController(hand);
		}

		public static int UPvr_GetControllerAbility(int hand)
		{
			return Pvr_ControllerManager.controllerlink.GetControllerAbility(hand);
		}

		public static void UPvr_VibrateNeo2Controller(float strength, int time, int hand)
		{
			Pvr_ControllerManager.controllerlink.VibrateNeo2Controller(strength, time, hand);
		}

		public static void UPvr_VibrateController(float strength, int time, int hand)
		{
			Pvr_ControllerManager.controllerlink.VibrateController(strength, time, hand);
		}

		public static int UPvr_GetControllerBindingState(int hand)
		{
			return Pvr_ControllerManager.controllerlink.GetControllerBindingState(hand);
		}

		public static Vector3 UPvr_GetVelocity(int hand)
		{
			return Pvr_ControllerManager.controllerlink.GetVelocity(hand);
		}

		public static Vector3 UPvr_GetAngularVelocity(int hand)
		{
			return Pvr_ControllerManager.controllerlink.GetAngularVelocity(hand);
		}

		public static Vector3 UPvr_GetAcceleration(int hand)
		{
			return Pvr_ControllerManager.controllerlink.GetAcceleration(hand);
		}

		public static void UPvr_ScanController()
		{
			Pvr_ControllerManager.controllerlink.StartScan();
		}

		public static void UPvr_StopScanController()
		{
			Pvr_ControllerManager.controllerlink.StopScan();
		}

		public static void UPvr_ConnectController(string mac)
		{
			if (mac != "")
			{
				Pvr_ControllerManager.controllerlink.hummingBirdMac = mac;
			}
			Pvr_ControllerManager.controllerlink.ConnectBLE();
		}

		public static void UPvr_DisConnectController()
		{
			Pvr_ControllerManager.controllerlink.DisConnectBLE();
		}

		public static void UPvr_ResetController(int hand)
		{
			Pvr_ControllerManager.controllerlink.ResetController(hand);
		}

		public static string UPvr_GetControllerVersion()
		{
			return Pvr_ControllerManager.controllerlink.GetControllerVersion();
		}

		public static void UPvr_GetDeviceVersion(int deviceType)
		{
			Pvr_ControllerManager.controllerlink.GetDeviceVersion(deviceType);
		}

		public static void UPvr_GetControllerSnCode(int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.GetControllerSnCode(controllerSerialNum);
		}

		public static void UPvr_SetControllerUnbind(int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.SetControllerUnbind(controllerSerialNum);
		}

		public static void UPvr_SetStationRestart()
		{
			Pvr_ControllerManager.controllerlink.SetStationRestart();
		}

		public static void UPvr_StartStationOtaUpdate()
		{
			Pvr_ControllerManager.controllerlink.StartStationOtaUpdate();
		}

		public static void UPvr_StartControllerOtaUpdate(int mode, int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.StartControllerOtaUpdate(mode, controllerSerialNum);
		}

		public static void UPvr_EnterPairMode(int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.EnterPairMode(controllerSerialNum);
		}

		public static void UPvr_SetControllerShutdown(int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.SetControllerShutdown(controllerSerialNum);
		}

		public static int UPvr_GetStationPairState()
		{
			return Pvr_ControllerManager.controllerlink.GetStationPairState();
		}

		public static int UPvr_GetStationOtaUpdateProgress()
		{
			return Pvr_ControllerManager.controllerlink.GetStationOtaUpdateProgress();
		}

		public static int UPvr_GetControllerOtaUpdateProgress()
		{
			return Pvr_ControllerManager.controllerlink.GetControllerOtaUpdateProgress();
		}

		public static void UPvr_GetControllerVersionAndSN(int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.GetControllerVersionAndSN(controllerSerialNum);
		}

		public static void UPvr_GetControllerUniqueID()
		{
			Pvr_ControllerManager.controllerlink.GetControllerUniqueID();
		}

		public void UPvr_InterruptStationPairMode()
		{
			Pvr_ControllerManager.controllerlink.InterruptStationPairMode();
		}

		public void UPvr_StartCV2PairingMode(int deviceType)
		{
			Pvr_ControllerManager.controllerlink.StartCV2PairingMode(deviceType);
		}

		public void UPvr_StopCV2PairingMode(int deviceType)
		{
			Pvr_ControllerManager.controllerlink.StopCV2PairingMode(deviceType);
		}

		public static void UPvr_SetArmModelParameters(int hand, int gazeType, float elbowHeight, float elbowDepth, float pointerTiltAngle)
		{
			Pvr_SetArmModelParameters(hand, gazeType, elbowHeight, elbowDepth, pointerTiltAngle);
		}

		public static void UPvr_CalcArmModelParameters(float[] headOrientation, float[] controllerOrientation, float[] controllerPrimary)
		{
			Pvr_CalcArmModelParameters(headOrientation, controllerOrientation, controllerPrimary);
		}

		public static void UPvr_GetPointerPose(float[] rotation, float[] position)
		{
			Pvr_GetPointerPose(rotation, position);
		}

		public static void UPvr_GetElbowPose(float[] rotation, float[] position)
		{
			Pvr_GetElbowPose(rotation, position);
		}

		public static void UPvr_GetWristPose(float[] rotation, float[] position)
		{
			Pvr_GetWristPose(rotation, position);
		}

		public static void UPvr_GetShoulderPose(float[] rotation, float[] position)
		{
			Pvr_GetShoulderPose(rotation, position);
		}

		public static void UPvr_IsEnbleHomeKey(bool state)
		{
			Pvr_ControllerManager.controllerlink.setIsEnbleHomeKey(state);
		}

		public static void UPvr_SwitchHomeKey(bool state)
		{
			Pvr_ControllerManager.controllerlink.SwitchHomeKey(state);
		}

		public static int UPvr_GetControllerSensorStatus(int id)
		{
			return Pvr_ControllerManager.controllerlink.getControllerSensorStatus(id);
		}

		public static void UPvr_SetControllerOriginOffset(int hand, Vector3 offset)
		{
			switch (hand)
			{
			case 0:
				Pvr_Controller.originOffsetL = offset;
				break;
			case 1:
				Pvr_Controller.originOffsetR = offset;
				break;
			}
		}

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_CalcArmModelParameters(float[] headOrientation, float[] controllerOrientation, float[] gyro);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_GetPointerPose(float[] rotation, float[] position);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_GetElbowPose(float[] rotation, float[] position);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_GetWristPose(float[] rotation, float[] position);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_GetShoulderPose(float[] rotation, float[] position);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetArmModelParameters(int hand, int gazeType, float elbowHeight, float elbowDepth, float pointerTiltAngle);
	}
	public enum ControllerVariety
	{
		Controller0,
		Controller1
	}
	public enum ControllerDevice
	{
		Goblin,
		Neo,
		G2,
		Neo2,
		Neo3,
		NewController
	}
	public enum PBS_SystemInfoEnum
	{
		ELECTRIC_QUANTITY,
		PUI_VERSION,
		EQUIPMENT_MODEL,
		EQUIPMENT_SN,
		CUSTOMER_SN,
		INTERNAL_STORAGE_SPACE_OF_THE_DEVICE,
		DEVICE_BLUETOOTH_STATUS,
		BLUETOOTH_NAME_CONNECTED,
		BLUETOOTH_MAC_ADDRESS,
		DEVICE_WIFI_STATUS,
		WIFI_NAME_CONNECTED,
		WLAN_MAC_ADDRESS,
		DEVICE_IP
	}
	public enum PBS_DeviceControlEnum
	{
		DEVICE_CONTROL_REBOOT,
		DEVICE_CONTROL_SHUTDOWN
	}
	public enum PBS_PackageControlEnum
	{
		PACKAGE_SILENCE_INSTALL,
		PACKAGE_SILENCE_UNINSTALL
	}
	public enum PBS_SwitchEnum
	{
		S_ON,
		S_OFF
	}
	public enum PBS_HomeEventEnum
	{
		SINGLE_CLICK,
		DOUBLE_CLICK,
		LONG_PRESS
	}
	public enum PBS_HomeFunctionEnum
	{
		VALUE_HOME_GO_TO_SETTING,
		VALUE_HOME_BACK,
		VALUE_HOME_RECENTER,
		VALUE_HOME_OPEN_APP,
		VALUE_HOME_DISABLE,
		VALUE_HOME_GO_TO_HOME,
		VALUE_HOME_SEND_BROADCAST,
		VALUE_HOME_CLEAN_MEMORY
	}
	public enum PBS_ScreenOffDelayTimeEnum
	{
		THREE = 3,
		TEN = 10,
		THIRTY = 30,
		SIXTY = 60,
		THREE_HUNDRED = 300,
		SIX_HUNDRED = 600,
		NEVER = -1
	}
	public enum PBS_SleepDelayTimeEnum
	{
		FIFTEEN = 15,
		THIRTY = 30,
		SIXTY = 60,
		THREE_HUNDRED = 300,
		SIX_HUNDRED = 600,
		ONE_THOUSAND_AND_EIGHT_HUNDRED = 1800,
		NEVER = -1
	}
	public enum PBS_SystemFunctionSwitchEnum
	{
		SFS_USB,
		SFS_AUTOSLEEP,
		SFS_SCREENON_CHARGING,
		SFS_OTG_CHARGING,
		SFS_RETURN_MENU_IN_2DMODE,
		SFS_COMBINATION_KEY,
		SFS_CALIBRATION_WITH_POWER_ON,
		SFS_SYSTEM_UPDATE,
		SFS_CAST_SERVICE,
		SFS_EYE_PROTECTION,
		SFS_SECURITY_ZONE_PERMANENTLY,
		SFS_GLOBAL_CALIBRATION,
		SFS_Auto_Calibration,
		SFS_USB_BOOT,
		SFS_VOLUME_UI,
		SFS_CONTROLLER_UI,
		SFS_NAVGATION_SWITCH
	}
	public enum PBS_USBConfigModeEnum
	{
		MTP,
		CHARGE
	}
	public struct ToBService
	{
		public static Action<bool> BoolCallback;

		public static Action<int> IntCallback;

		public static Action<long> LongCallback;

		private static AndroidJavaClass unityPlayer;

		private static AndroidJavaObject currentActivity;

		private static AndroidJavaObject tobHelper;

		private static AndroidJavaClass tobHelperClass;

		public static void UPvr_InitToBService()
		{
			tobHelperClass = new AndroidJavaClass("com.pvr.tobservice.ToBServiceHelper");
			tobHelper = tobHelperClass.CallStatic<AndroidJavaObject>("getInstance", Array.Empty<object>());
			unityPlayer = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
			currentActivity = unityPlayer.GetStatic<AndroidJavaObject>("currentActivity");
		}

		public static void UPvr_SetUnityObjectName(string obj)
		{
			System.UPvr_CallMethod(tobHelper, "setUnityObjectName", obj);
		}

		public static void UPvr_BindToBService()
		{
			System.UPvr_CallMethod(tobHelper, "bindTobService", currentActivity);
		}

		public static void UPvr_UnBindToBService()
		{
			System.UPvr_CallMethod(tobHelper, "unBindTobService", currentActivity);
		}

		private static AndroidJavaObject GetEnumType(Enum enumType)
		{
			return new AndroidJavaClass("com.pvr.tobservice.enums" + enumType.GetType().ToString().Replace("Pvr_UnitySDKAPI", "")).GetStatic<AndroidJavaObject>(enumType.ToString());
		}

		public static string UPvr_StateGetDeviceInfo(PBS_SystemInfoEnum type)
		{
			string result = "";
			System.UPvr_CallMethod(ref result, tobHelper, "pbsStateGetDeviceInfo", GetEnumType(type), 0);
			return result;
		}

		public static void UPvr_ControlSetDeviceAction(PBS_DeviceControlEnum deviceControl, Action<int> callback)
		{
			if (callback != null)
			{
				IntCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsControlSetDeviceAction", GetEnumType(deviceControl), null);
		}

		public static void UPvr_ControlAPPManger(PBS_PackageControlEnum packageControl, string path, Action<int> callback)
		{
			if (callback != null)
			{
				IntCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsControlAPPManger", GetEnumType(packageControl), path, 0, null);
		}

		public static void UPvr_ControlSetAutoConnectWIFI(string ssid, string pwd, Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsControlSetAutoConnectWIFI", ssid, pwd, 0, null);
		}

		public static void UPvr_ControlClearAutoConnectWIFI(Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsControlClearAutoConnectWIFI", null);
		}

		public static void UPvr_PropertySetHomeKey(PBS_HomeEventEnum eventEnum, PBS_HomeFunctionEnum function, Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsPropertySetHomeKey", GetEnumType(eventEnum), GetEnumType(function), null);
		}

		public static void UPvr_PropertySetHomeKeyAll(PBS_HomeEventEnum eventEnum, PBS_HomeFunctionEnum function, int timesetup, string pkg, string className, Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsPropertySetHomeKeyAll", GetEnumType(eventEnum), GetEnumType(function), timesetup, pkg, className, null);
		}

		public static void UPvr_PropertyDisablePowerKey(bool isSingleTap, bool enable, Action<int> callback)
		{
			if (callback != null)
			{
				IntCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsPropertyDisablePowerKey", isSingleTap, enable, null);
		}

		public static void UPvr_PropertySetScreenOffDelay(PBS_ScreenOffDelayTimeEnum timeEnum, Action<int> callback)
		{
			if (callback != null)
			{
				IntCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsPropertySetScreenOffDelay", GetEnumType(timeEnum), null);
		}

		public static void UPvr_PropertySetSleepDelay(PBS_SleepDelayTimeEnum timeEnum)
		{
			System.UPvr_CallMethod(tobHelper, "pbsPropertySetSleepDelay", GetEnumType(timeEnum));
		}

		public static void UPvr_SwitchSystemFunction(PBS_SystemFunctionSwitchEnum systemFunction, PBS_SwitchEnum switchEnum)
		{
			System.UPvr_CallMethod(tobHelper, "pbsSwitchSystemFunction", GetEnumType(systemFunction), GetEnumType(switchEnum), 0);
		}

		public static void UPvr_SwitchSetUsbConfigurationOption(PBS_USBConfigModeEnum uSBConfigModeEnum)
		{
			System.UPvr_CallMethod(tobHelper, "pbsSwitchSetUsbConfigurationOption", GetEnumType(uSBConfigModeEnum), 0);
		}

		public static void UPvr_ScreenOn()
		{
			System.UPvr_CallMethod(tobHelper, "pbsScreenOn");
		}

		public static void UPvr_ScreenOff()
		{
			System.UPvr_CallMethod(tobHelper, "pbsScreenOff");
		}

		public static void UPvr_AcquireWakeLock()
		{
			System.UPvr_CallMethod(tobHelper, "pbsAcquireWakeLock");
		}

		public static void UPvr_ReleaseWakeLock()
		{
			System.UPvr_CallMethod(tobHelper, "pbsReleaseWakeLock");
		}

		public static void UPvr_EnableEnterKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsEnableEnterKey");
		}

		public static void UPvr_DisableEnterKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsDisableEnterKey");
		}

		public static void UPvr_EnableVolumeKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsEnableVolumeKey");
		}

		public static void UPvr_DisableVolumeKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsDisableVolumeKey");
		}

		public static void UPvr_EnableBackKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsEnableBackKey");
		}

		public static void UPvr_DisableBackKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsDisableBackKey");
		}

		public static void UPvr_WriteConfigFileToDataLocal(string path, string content, Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsWriteConfigFileToDataLocal", path, content, null);
		}

		public static void UPvr_ResetAllKeyToDefault(Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsResetAllKeyToDefault", null);
		}

		public static void UPvr_SetAPPAsHome(PBS_SwitchEnum switchEnum, string packageName)
		{
			System.UPvr_CallMethod(tobHelper, "pbsAppSetAPPAsHomeTwo", GetEnumType(switchEnum), packageName);
		}
	}
	public enum GlobalIntConfigs
	{
		EYE_TEXTURE_RESOLUTION0,
		EYE_TEXTURE_RESOLUTION1,
		SEENSOR_COUNT,
		ABILITY6DOF,
		PLATFORM_TYPE,
		TRACKING_MODE,
		LOG_LEVEL,
		ENBLE_HAND6DOF_BY_HEAD,
		ENBLE_6DOF_GLOBAL_TRACKING,
		TARGET_FRAME_RATE,
		iShowFPS,
		SensorMode,
		LOGICFLOW,
		EYE_TEXTURE_RES_HIGH,
		EYE_TEXTURE_RES_NORMAL,
		iCtrlModelLoadingPri,
		iPhoneHMDModeEnabled,
		isEnableBoundary,
		Enable_Activity_Rotation,
		GetDisplay_Orientation,
		GetWaitFrameNum,
		GetResetFrameNum,
		EnableFFRBYSYS,
		RotControllerMode
	}
	public enum GlobalFloatConfigs
	{
		IPD,
		VFOV,
		HFOV,
		NECK_MODEL_X,
		NECK_MODEL_Y,
		NECK_MODEL_Z,
		DISPLAY_REFRESH_RATE
	}
	public enum RenderTextureAntiAliasing
	{
		X_1 = 1,
		X_2 = 2,
		X_4 = 4,
		X_8 = 8
	}
	public enum PlatForm
	{
		Android = 1,
		IOS,
		Win,
		Notsupport
	}
	public enum RenderTextureDepth
	{
		BD_0 = 0,
		BD_16 = 16,
		BD_24 = 24
	}
	public enum RenderTextureLevel
	{
		Normal,
		High
	}
	public enum Sensorindex
	{
		Default,
		FirstSensor,
		SecondSensor
	}
	public enum Eye
	{
		LeftEye,
		RightEye,
		BothEye
	}
	public enum ResUtilsType
	{
		TYPE_TEXTSIZE,
		TYPE_COLOR,
		TYPE_TEXT,
		TYPE_FONT,
		TYPE_VALUE,
		TYPE_DRAWABLE,
		TYPE_OBJECT,
		TYPR_OBJECTARRAY
	}
	public enum TrackingOrigin
	{
		EyeLevel,
		FloorLevel,
		StageLevel
	}
	public enum EFoveationLevel
	{
		Low,
		Med,
		High,
		Top_High
	}
	public enum StereoRenderingPathPico
	{
		MultiPass,
		SinglePass
	}
	public enum ExtraLatencyMode
	{
		ExtraLatencyModeOff,
		ExtraLatencyModeOn,
		ExtraLatencyModeDynamic
	}
	public enum pvrEyePoseStatus
	{
		kGazePointValid = 1,
		kGazeVectorValid = 2,
		kEyeOpennessValid = 4,
		kEyePupilDilationValid = 8,
		kEyePositionGuideValid = 0x10
	}
	public enum TrackingMode
	{
		PVR_TRACKING_MODE_ROTATION = 1,
		PVR_TRACKING_MODE_POSITION = 2,
		PVR_TRACKING_MODE_EYE = 4
	}
	public struct EyeTrackingData
	{
		public int leftEyePoseStatus;

		public int rightEyePoseStatus;

		public int combinedEyePoseStatus;

		public Vector3 leftEyeGazePoint;

		public Vector3 rightEyeGazePoint;

		public Vector3 combinedEyeGazePoint;

		public Vector3 leftEyeGazeVector;

		public Vector3 rightEyeGazeVector;

		public Vector3 combinedEyeGazeVector;

		public float leftEyeOpenness;

		public float rightEyeOpenness;

		public float leftEyePupilDilation;

		public float rightEyePupilDilation;

		public Vector3 leftEyePositionGuide;

		public Vector3 rightEyePositionGuide;

		public Vector3 foveatedGazeDirection;

		public int foveatedGazeTrackingState;

		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
		public byte[] reserved;
	}
	public struct EyeTrackingGazeRay
	{
		public Vector3 Direction;

		public bool IsValid;

		public Vector3 Origin;
	}
	public struct EyeDeviceInfo
	{
		public ViewFrustum targetFrustumLeft;

		public ViewFrustum targetFrustumRight;
	}
	public struct ViewFrustum
	{
		public float left;

		public float right;

		public float top;

		public float bottom;

		public float near;

		public float far;
	}
	public struct EyeSetting
	{
		public Transform eyelocalPosition;

		public Rect eyeRect;

		public float eyeFov;

		public float eyeAspect;

		public Matrix4x4 eyeProjectionMatrix;

		public Shader eyeShader;
	}
	public struct Sensor
	{
		public const string LibFileName = "Pvr_UnitySDK";

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_Enable6DofModule(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_OptionalResetSensor(int index, int resetRot, int resetPos);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_Init(int index);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_StartSensor(int index);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_StopSensor(int index);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_ResetSensor(int index);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_ResetSensorAll(int index);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetSensorState(int index, ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetMainSensorState(ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz, ref float vfov, ref float hfov, ref int viewNumber);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetPsensorState();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetHmdPSensorStatus();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetSensorGyroscope(int index, ref float x, ref float y, ref float z);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetSensorMagnet(int index, ref float x, ref float y, ref float z);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_Get6DofSensorQualityStatus();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_Get6DofSafePanelFlag();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetReinPosition(float x, float y, float z, float w, float px, float py, float pz, int hand, bool valid, int key);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_SetTrackingOriginType(TrackingOrigin trackingOriginType);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_GetAcceleration(ref float x, ref float y, ref float z);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_GetAngularVelocity(ref float x, ref float y, ref float z);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_GetVelocity(ref float x, ref float y, ref float z);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_GetAngularAcceleration(ref float x, ref float y, ref float z);

		public static bool UPvr_Pvr_Get6DofSafePanelFlag()
		{
			return Pvr_Get6DofSafePanelFlag();
		}

		public static int UPvr_Init(int index)
		{
			return Pvr_Init(index);
		}

		public static void UPvr_InitPsensor()
		{
			Pvr_InitPsensor();
		}

		public static int UPvr_GetPsensorState()
		{
			int res = -1;
			Render.UPvr_GetIntConfig(4, ref res);
			if (res == 1)
			{
				return Pvr_GetPsensorState();
			}
			int num = Pvr_GetAndroidPsensorState();
			if (num != 0 && num != -1)
			{
				num = 1;
			}
			return num;
		}

		public static int UPvr_GetPSensorStatus()
		{
			return Pvr_GetHmdPSensorStatus();
		}

		public static void UPvr_UnregisterPsensor()
		{
			Pvr_UnregisterPsensor();
		}

		public static int UPvr_StartSensor(int index)
		{
			return Pvr_StartSensor(index);
		}

		public static int UPvr_StopSensor(int index)
		{
			return Pvr_StopSensor(index);
		}

		public static int UPvr_ResetSensor(int index)
		{
			Pvr_UnitySDKManager.SDK.resetBasePos = default(Vector3);
			return Pvr_ResetSensor(index);
		}

		public static int UPvr_OptionalResetSensor(int index, int resetRot, int resetPos)
		{
			return Pvr_OptionalResetSensor(index, resetRot, resetPos);
		}

		public static int UPvr_GetSensorState(int index, ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz)
		{
			return Pvr_GetSensorState(index, ref x, ref y, ref z, ref w, ref px, ref py, ref pz);
		}

		public static int UPvr_GetMainSensorState(ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz, ref float vfov, ref float hfov, ref int viewNumber)
		{
			return Pvr_GetMainSensorState(ref x, ref y, ref z, ref w, ref px, ref py, ref pz, ref vfov, ref hfov, ref viewNumber);
		}

		public static int UPvr_GetSensorGyroscope(int index, ref float x, ref float y, ref float z)
		{
			return Pvr_GetSensorGyroscope(index, ref x, ref y, ref z);
		}

		public static int UPvr_GetSensorMagnet(int index, ref float x, ref float y, ref float z)
		{
			return Pvr_GetSensorMagnet(index, ref x, ref y, ref z);
		}

		public static int UPvr_Get6DofSensorQualityStatus()
		{
			return Pvr_Get6DofSensorQualityStatus();
		}

		public static int UPvr_Enable6DofModule(bool enable)
		{
			return Pvr_Enable6DofModule(enable);
		}

		public static void Pvr_InitPsensor()
		{
			try
			{
				System.UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaSysActivityClass, "initPsensor", Pvr_UnitySDKRender.Instance.activity);
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
		}

		public static bool Pvr_IsHead6dofReset()
		{
			int res = 0;
			Render.UPvr_GetIntConfig(17, ref res);
			if (res > 0)
			{
				return false;
			}
			bool result = false;
			try
			{
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaSysActivityClass, "isHead6dofReset", Pvr_UnitySDKRender.Instance.activity);
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
			return result;
		}

		public static int Pvr_GetAndroidPsensorState()
		{
			int result = -1;
			try
			{
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaSysActivityClass, "getPsensorState");
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
			return result;
		}

		public static void Pvr_UnregisterPsensor()
		{
			try
			{
				System.UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaSysActivityClass, "unregisterListener");
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
		}

		public static int UPvr_ResetSensorAll(int index)
		{
			return Pvr_ResetSensorAll(index);
		}

		public static void UPvr_SetReinPosition(float x, float y, float z, float w, float px, float py, float pz, int hand, bool valid, int key)
		{
			if (PLOG.logLevel > 2)
			{
				PLOG.D("PvrLog UPvr_SetReinPosition" + x + y + z + w + px + py + pz + hand + valid.ToString() + key);
			}
			Pvr_SetReinPosition(x, y, z, w, px, py, pz, hand, valid, key);
		}

		public static bool UPvr_SetTrackingOriginType(TrackingOrigin trackingOriginType)
		{
			return Pvr_SetTrackingOriginType(trackingOriginType);
		}

		public static Vector3 UPvr_GetAcceleration()
		{
			float x = 0f;
			float y = 0f;
			float z = 0f;
			Pvr_GetAcceleration(ref x, ref y, ref z);
			return new Vector3(0f - x, 0f - y, z);
		}

		public static Vector3 UPvr_AngularVelocity()
		{
			float x = 0f;
			float y = 0f;
			float z = 0f;
			Pvr_GetAngularVelocity(ref x, ref y, ref z);
			return new Vector3(x, y, z);
		}

		public static Vector3 UPvr_GetVelocity()
		{
			float x = 0f;
			float y = 0f;
			float z = 0f;
			Pvr_GetVelocity(ref x, ref y, ref z);
			return new Vector3(0f - x, 0f - y, z);
		}

		public static Vector3 UPvr_GetAngularAcceleration()
		{
			float x = 0f;
			float y = 0f;
			float z = 0f;
			Pvr_GetAngularAcceleration(ref x, ref y, ref z);
			return new Vector3(x, y, z);
		}
	}
	public struct Render
	{
		public const string LibFileName = "Pvr_UnitySDK";

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_ChangeScreenParameters(string model, int width, int height, double xppi, double yppi, double densityDpi);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_SetRatio(float midH, float midV);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_SetPupillaryPoint(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr Pvr_GetSupportHMDTypes();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetCurrentHMDType([MarshalAs(UnmanagedType.LPStr)] string type);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetIntConfig(int configsenum, ref int res);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetFloatConfig(int configsenum, ref float res);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetupLayerData(int layerIndex, int sideMask, int textureId, int textureType, int layerFlags, float[] colorScaleAndOffset);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetupLayerCoords(int layerIndex, int sideMask, float[] lowerLeft, float[] lowerRight, float[] upperLeft, float[] upperRight);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetOverlayModelViewMatrix(int overlayType, int overlayShape, int texId, int eyeSide, int layerIndex, bool isHeadLocked, int layerFlags, float[] mvMatrix, float[] modelS, float[] modelR, float[] modelT, float[] cameraR, float[] cameraT, float[] colorScaleAndOffset);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_EnableFoveation(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetFoveationParameters(int textureId, int previousId, float focalPointX, float focalPointY, float foveationGainX, float foveationGainY, float foveationArea, float foveationMinimum);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetFoveationResource(int textureId, int previousId, float focalPointX, float focalPointY);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetFoveationParameters2(float foveationGainX, float foveationGainY, float foveationArea, float foveationMinimum);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetFoveationLevel(EFoveationLevel level);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern EFoveationLevel Pvr_GetFoveationLevel();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_GetIntSysProc(string property, ref int res);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetColorspaceType(int colorspaceType);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetCastingColorspaceType(int colorspaceType);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr Pvr_CreateLayerAndroidSurface(int layerType, int layerIndex);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr Pvr_GetLayerAndroidSurface(int layerType, int layerIndex);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetMonoMode(bool openMono);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_GetStencilMesh(int eye, ref int vertexCount, ref int triangleCount, ref IntPtr vertexData, ref IntPtr indexData);

		public static void UPvr_ChangeScreenParameters(string model, int width, int height, double xppi, double yppi, double densityDpi)
		{
			Pvr_ChangeScreenParameters(model, width, height, xppi, yppi, densityDpi);
		}

		public static int UPvr_SetRatio(float midH, float midV)
		{
			return Pvr_SetRatio(midH, midV);
		}

		public static void UPvr_EnableFoveation(bool enable)
		{
			if (Pvr_UnitySDKManager.SDK.SystemFFRLevel != -1 || Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel != -1)
			{
				enable = true;
			}
			Pvr_EnableFoveation(enable);
		}

		[Obsolete("This API will be removed in later versions")]
		public static void UPvr_SetFoveationParameters(int textureId, int previousId, float focalPointX, float focalPointY, float foveationGainX, float foveationGainY, float foveationArea, float foveationMinimum)
		{
			Pvr_SetFoveationParameters(textureId, previousId, focalPointX, focalPointY, foveationGainX, foveationGainY, foveationArea, foveationMinimum);
		}

		public static void UPvr_SetFoveationResource(int textureId, int previousId, float focalPointX, float focalPointY)
		{
			Pvr_SetFoveationResource(textureId, previousId, focalPointX, focalPointY);
		}

		public static void SetFoveatedRenderingLevel(EFoveationLevel level)
		{
			if (Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel != -1)
			{
				Pvr_SetFoveationLevel((EFoveationLevel)Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel);
			}
			else if (Pvr_UnitySDKManager.SDK.SystemFFRLevel != -1)
			{
				Pvr_SetFoveationLevel((EFoveationLevel)Pvr_UnitySDKManager.SDK.SystemFFRLevel);
			}
			else
			{
				Pvr_SetFoveationLevel(level);
			}
		}

		public static EFoveationLevel GetFoveatedRenderingLevel()
		{
			return Pvr_GetFoveationLevel();
		}

		public static void SetFoveatedRenderingParameters(Vector2 ffrGainValue, float ffrAreaValue, float ffrMinimumValue)
		{
			if (Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel != -1)
			{
				Pvr_SetFoveationLevel((EFoveationLevel)Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel);
			}
			else if (Pvr_UnitySDKManager.SDK.SystemFFRLevel != -1)
			{
				Pvr_SetFoveationLevel((EFoveationLevel)Pvr_UnitySDKManager.SDK.SystemFFRLevel);
			}
			else
			{
				Pvr_SetFoveationParameters2(ffrGainValue.x, ffrGainValue.y, ffrAreaValue, ffrMinimumValue);
			}
		}

		public static bool UPvr_GetIntSysProc(string property, ref int res)
		{
			return Pvr_GetIntSysProc(property, ref res);
		}

		public static int UPvr_GetIntConfig(int configsenum, ref int res)
		{
			return Pvr_GetIntConfig(configsenum, ref res);
		}

		public static int UPvr_GetFloatConfig(int configsenum, ref float res)
		{
			return Pvr_GetFloatConfig(configsenum, ref res);
		}

		public static string UPvr_GetSupportHMDTypes()
		{
			IntPtr intPtr = Pvr_GetSupportHMDTypes();
			if (intPtr != IntPtr.Zero)
			{
				return Marshal.PtrToStringAnsi(intPtr);
			}
			return null;
		}

		public static void UPvr_SetCurrentHMDType(string type)
		{
			Pvr_SetCurrentHMDType(type);
		}

		public static void UPvr_SetupLayerData(int layerIndex, int sideMask, int textureId, int textureType, int layerFlags, Vector4 colorScale, Vector4 colorOffset)
		{
			Pvr_SetupLayerData(layerIndex, sideMask, textureId, textureType, layerFlags, new float[8] { colorScale.x, colorScale.y, colorScale.z, colorScale.w, colorOffset.x, colorOffset.y, colorOffset.z, colorOffset.w });
		}

		public static void UPvr_SetupLayerCoords(int layerIndex, int sideMask, float[] lowerLeft, float[] lowerRight, float[] upperLeft, float[] upperRight)
		{
			Pvr_SetupLayerCoords(layerIndex, sideMask, lowerLeft, lowerRight, upperLeft, upperRight);
		}

		public static void UPvr_SetOverlayModelViewMatrix(int overlayType, int overlayShape, int texId, int eyeSide, int layerIndex, bool isHeadLocked, int layerFlags, Matrix4x4 mvMatrix, Vector3 modelS, Quaternion modelR, Vector3 modelT, Quaternion cameraR, Vector3 cameraT, Vector4 colorScale, Vector4 colorOffset)
		{
			Pvr_SetOverlayModelViewMatrix(overlayType, overlayShape, texId, eyeSide, layerIndex, isHeadLocked, layerFlags, new float[16]
			{
				mvMatrix.m00, mvMatrix.m01, mvMatrix.m02, mvMatrix.m03, mvMatrix.m10, mvMatrix.m11, mvMatrix.m12, mvMatrix.m13, mvMatrix.m20, mvMatrix.m21,
				mvMatrix.m22, mvMatrix.m23, mvMatrix.m30, mvMatrix.m31, mvMatrix.m32, mvMatrix.m33
			}, new float[3] { modelS.x, modelS.y, modelS.z }, new float[4] { modelR.x, modelR.y, modelR.z, modelR.w }, new float[3] { modelT.x, modelT.y, modelT.z }, new float[4] { cameraR.x, cameraR.y, cameraR.z, cameraR.w }, new float[3] { cameraT.x, cameraT.y, cameraT.z }, new float[8] { colorScale.x, colorScale.y, colorScale.z, colorScale.w, colorOffset.x, colorOffset.y, colorOffset.z, colorOffset.w });
		}

		public static void UPvr_SetColorspaceType(int colorspaceType)
		{
			Pvr_SetColorspaceType(colorspaceType);
		}

		public static void UPvr_SetCastingColorspaceType(int colorspaceType)
		{
			Pvr_SetCastingColorspaceType(colorspaceType);
		}

		public static IntPtr UPvr_CreateLayerAndroidSurface(int layerType, int layerIndex)
		{
			return Pvr_CreateLayerAndroidSurface(layerType, layerIndex);
		}

		public static IntPtr UPvr_GetLayerAndroidSurface(int layerType, int layerIndex)
		{
			return Pvr_GetLayerAndroidSurface(layerType, layerIndex);
		}

		public static void UPvr_SetMonoMode(bool openMono)
		{
			Pvr_SetMonoMode(openMono);
		}

		public static void UPvr_GetStencilMesh(int eye, ref int vertexCount, ref int triangleCount, ref IntPtr vertexDataPtr, ref IntPtr indexDataPtr)
		{
			Pvr_GetStencilMesh(eye, ref vertexCount, ref triangleCount, ref vertexDataPtr, ref indexDataPtr);
		}
	}
	public struct System
	{
		public const string LibFileName = "Pvr_UnitySDK";

		public const string UnitySDKVersion = "2.8.10.4";

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_SetInitActivity(IntPtr activity, IntPtr vrActivityClass);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr Pvr_GetSDKVersion();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int Pvr_GetHmdHardwareVersion();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr Pvr_GetHmdFirmwareVersion();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr Pvr_GetHmdSerialNumber();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int PVR_GetHmdBatteryStatus();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern float PVR_GetHmdBatteryTemperature();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int PVR_SetHmdAudioStatus(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_GetEyeTrackingData(ref int leftEyePoseStatus, ref int rightEyePoseStatus, ref int combinedEyePoseStatus, ref float leftEyeGazePointX, ref float leftEyeGazePointY, ref float leftEyeGazePointZ, ref float rightEyeGazePointX, ref float rightEyeGazePointY, ref float rightEyeGazePointZ, ref float combinedEyeGazePointX, ref float combinedEyeGazePointY, ref float combinedEyeGazePointZ, ref float leftEyeGazeVectorX, ref float leftEyeGazeVectorY, ref float leftEyeGazeVectorZ, ref float rightEyeGazeVectorX, ref float rightEyeGazeVectorY, ref float rightEyeGazeVectorZ, ref float combinedEyeGazeVectorX, ref float combinedEyeGazeVectorY, ref float combinedEyeGazeVectorZ, ref float leftEyeOpenness, ref float rightEyeOpenness, ref float leftEyePupilDilation, ref float rightEyePupilDilation, ref float leftEyePositionGuideX, ref float leftEyePositionGuideY, ref float leftEyePositionGuideZ, ref float rightEyePositionGuideX, ref float rightEyePositionGuideY, ref float rightEyePositionGuideZ, ref float foveatedGazeDirectionX, ref float foveatedGazeDirectionY, ref float foveatedGazeDirectionZ, ref int foveatedGazeTrackingState);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_SetTrackingMode(int trackingMode);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int Pvr_GetTrackingMode();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr GetRenderEventFunc();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void UnityEventData(long data);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_EnableSinglePass(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_SetAntiAliasing(int antiAliasing);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_SinglePassBeforeForwardOpaque();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_SetCurrentRenderTexture(uint textureId);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_SetSinglePassDepthBufferWidthHeight(int width, int height);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int PVR_setPerformanceLevels(int cpuLevel, int gpuLevel);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_SetIPD(float distance);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern float Pvr_GetIPD();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_SetTrackingIPDEnabled(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_GetTrackingIPDEnabled();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_GetEyeTrackingAutoIPD(ref float autoIPD);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int PVR_GetHmdAudioStatus();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern float Pvr_GetPredictedDisplayTime();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_SetExtraLatencyMode(int mode);

		public static bool UPvr_CallStaticMethod<T>(ref T result, AndroidJavaClass jclass, string name, params object[] args)
		{
			try
			{
				result = jclass.CallStatic<T>(name, args);
				return true;
			}
			catch (AndroidJavaException ex)
			{
				PLOG.E("Exception calling static method " + name + ": " + ex);
				return false;
			}
		}

		public static bool UPvr_CallStaticMethod(AndroidJavaObject jobj, string name, params object[] args)
		{
			try
			{
				jobj.CallStatic(name, args);
				return true;
			}
			catch (AndroidJavaException ex)
			{
				PLOG.E("CallStaticMethod  Exception calling activity method " + name + ": " + ex);
				return false;
			}
		}

		public static bool UPvr_CallMethod<T>(ref T result, AndroidJavaObject jobj, string name, params object[] args)
		{
			try
			{
				result = jobj.Call<T>(name, args);
				return true;
			}
			catch (AndroidJavaException ex)
			{
				PLOG.E("Exception calling activity method " + name + ": " + ex);
				return false;
			}
		}

		public static bool UPvr_CallMethod(AndroidJavaObject jobj, string name, params object[] args)
		{
			try
			{
				jobj.Call(name, args);
				return true;
			}
			catch (AndroidJavaException ex)
			{
				PLOG.E(" Exception calling activity method " + name + ": " + ex);
				return false;
			}
		}

		public static string UPvr_GetSDKVersion()
		{
			IntPtr intPtr = Pvr_GetSDKVersion();
			if (intPtr != IntPtr.Zero)
			{
				return Marshal.PtrToStringAnsi(intPtr);
			}
			return "";
		}

		public static string UPvr_GetUnitySDKVersion()
		{
			return "2.8.10.4";
		}

		public static string UPvr_GetDeviceMode()
		{
			return SystemInfo.deviceModel;
		}

		public static string UPvr_GetDeviceModel()
		{
			return SystemInfo.deviceModel;
		}

		public static string UPvr_GetDeviceSN()
		{
			string result = "UNKONWN";
			UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaSysActivityClass, "getDeviceSN");
			return result;
		}

		public static AndroidJavaObject UPvr_GetCurrentActivity()
		{
			return new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		}

		public static bool UPvr_SetMonoPresentation()
		{
			return UPvr_CallMethod(UPvr_GetCurrentActivity(), "Pvr_setMonoPresentation");
		}

		public static bool UPvr_IsPresentationExisted()
		{
			bool result = false;
			return UPvr_CallMethod(ref result, UPvr_GetCurrentActivity(), "Pvr_isPresentationExisted") && result;
		}

		public static bool UPvr_GetMainActivityPauseStatus()
		{
			bool result = false;
			return UPvr_CallMethod(ref result, UPvr_GetCurrentActivity(), "Pvr_getMainActivityPauseStatus") && result;
		}

		public static void UPvr_Sleep()
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaSysActivityClass, "Pvr_Sleep");
		}

		public static bool UPvr_StartHomeKeyReceiver(string startreceivre)
		{
			try
			{
				if (Pvr_UnitySDKRender.Instance != null)
				{
					UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityLongReceiver, "Pvr_StartReceiver", Pvr_UnitySDKRender.Instance.activity, startreceivre);
					PLOG.I("Start home key Receiver");
					return true;
				}
			}
			catch (Exception ex)
			{
				PLOG.E("Start home key  Receiver  Error :" + ex.ToString());
				return false;
			}
			return true;
		}

		public static bool UPvr_StopHomeKeyReceiver()
		{
			try
			{
				if (Pvr_UnitySDKRender.Instance != null)
				{
					UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityLongReceiver, "Pvr_StopReceiver", Pvr_UnitySDKRender.Instance.activity);
					PLOG.I("Stop home key Receiver");
					return true;
				}
			}
			catch (Exception ex)
			{
				PLOG.E("Stop home key Receiver Error :" + ex.ToString());
				return false;
			}
			return true;
		}

		public static void UPvr_StartVRModel()
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClass, "startVRModel");
		}

		public static void UPvr_RemovePlatformLogo()
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClass, "removePlatformLogo");
		}

		public static void UPvr_ShowPlatformLogo()
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClass, "showPlatformLogo");
		}

		public static bool UPvr_IsPicoActivity()
		{
			bool result = false;
			return UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "isPicoActivity", UPvr_GetCurrentActivity()) && result;
		}

		public static void UPvr_StopVRModel()
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClass, "stopVRModel");
		}

		public static string UPvr_GetCountryCode()
		{
			string result = "";
			UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getCountryCode", UPvr_GetCurrentActivity());
			return result;
		}

		public static bool UPvr_SetIPD(float distance)
		{
			bool flag = false;
			flag = Pvr_SetIPD(distance);
			if (flag)
			{
				for (int i = 0; i < Pvr_UnitySDKEyeManager.Instance.Eyes.Length; i++)
				{
					Pvr_UnitySDKEyeManager.Instance.Eyes[i].RefreshCameraPosition(distance);
				}
			}
			return flag;
		}

		public static float UPvr_GetIPD()
		{
			float num = Pvr_GetIPD();
			UnityEngine.Debug.Log("DISFT IPD:" + num);
			return num;
		}

		public static bool UPvr_SetTrackingIPDEnabled(bool enable)
		{
			return Pvr_SetTrackingIPDEnabled(enable);
		}

		public static bool UPvr_GetTrackingIPDEnabled()
		{
			return Pvr_GetTrackingIPDEnabled();
		}

		public static bool UPvr_GetEyeTrackingAutoIPD(ref float autoipd)
		{
			return Pvr_GetEyeTrackingAutoIPD(ref autoipd);
		}

		public static void UPvr_UnityEventData(long data)
		{
			UnityEventData(data);
		}

		public static long UPvr_GetEyeBufferData(int id)
		{
			return ((long)Pvr_UnitySDKRender.Instance.RenderviewNumber << 32) | id;
		}

		public static bool UPvr_checkDevice(string packagename)
		{
			bool result = false;
			UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "checkDevice", packagename, UPvr_GetCurrentActivity());
			return result;
		}

		public static int UPvr_GetHmdHardwareVersion()
		{
			return Pvr_GetHmdHardwareVersion();
		}

		public static string UPvr_GetHmdFirmwareVersion()
		{
			IntPtr intPtr = Pvr_GetHmdFirmwareVersion();
			if (intPtr != IntPtr.Zero)
			{
				return Marshal.PtrToStringAnsi(intPtr);
			}
			return "";
		}

		public static string UPvr_GetHmdSerialNumber()
		{
			IntPtr intPtr = Pvr_GetHmdSerialNumber();
			if (intPtr != IntPtr.Zero)
			{
				return Marshal.PtrToStringAnsi(intPtr);
			}
			return "";
		}

		public static int UPvr_GetHmdBatteryStatus()
		{
			return PVR_GetHmdBatteryStatus();
		}

		public static float UPvr_GetHmdBatteryTemperature()
		{
			return PVR_GetHmdBatteryTemperature();
		}

		public static int UPvr_SetHmdAudioStatus(bool enable)
		{
			return PVR_SetHmdAudioStatus(enable);
		}

		public static int UPvr_GetTrackingMode()
		{
			return Pvr_GetTrackingMode();
		}

		public static bool UPvr_setTrackingMode(int trackingMode)
		{
			return Pvr_SetTrackingMode(trackingMode);
		}

		public static bool UPvr_getEyeTrackingData(ref EyeTrackingData trackingData)
		{
			if (!Pvr_UnitySDKEyeManager.supportEyeTracking)
			{
				PLOG.E("The device is not supported");
				return false;
			}
			if (!Pvr_UnitySDKEyeManager.Instance.EyeTracking)
			{
				PLOG.E("Please Enable \"Pvr_UnitySDK/Head/Pvr_UnitySDKEyeManager.cs/EyeTracking\"option first.");
				return false;
			}
			bool result = Pvr_GetEyeTrackingData(ref trackingData.leftEyePoseStatus, ref trackingData.rightEyePoseStatus, ref trackingData.combinedEyePoseStatus, ref trackingData.leftEyeGazePoint.x, ref trackingData.leftEyeGazePoint.y, ref trackingData.leftEyeGazePoint.z, ref trackingData.rightEyeGazePoint.x, ref trackingData.rightEyeGazePoint.y, ref trackingData.rightEyeGazePoint.z, ref trackingData.combinedEyeGazePoint.x, ref trackingData.combinedEyeGazePoint.y, ref trackingData.combinedEyeGazePoint.z, ref trackingData.leftEyeGazeVector.x, ref trackingData.leftEyeGazeVector.y, ref trackingData.leftEyeGazeVector.z, ref trackingData.rightEyeGazeVector.x, ref trackingData.rightEyeGazeVector.y, ref trackingData.rightEyeGazeVector.z, ref trackingData.combinedEyeGazeVector.x, ref trackingData.combinedEyeGazeVector.y, ref trackingData.combinedEyeGazeVector.z, ref trackingData.leftEyeOpenness, ref trackingData.rightEyeOpenness, ref trackingData.leftEyePupilDilation, ref trackingData.rightEyePupilDilation, ref trackingData.leftEyePositionGuide.x, ref trackingData.leftEyePositionGuide.y, ref trackingData.leftEyePositionGuide.z, ref trackingData.rightEyePositionGuide.x, ref trackingData.rightEyePositionGuide.y, ref trackingData.rightEyePositionGuide.z, ref trackingData.foveatedGazeDirection.x, ref trackingData.foveatedGazeDirection.y, ref trackingData.foveatedGazeDirection.z, ref trackingData.foveatedGazeTrackingState);
			trackingData.leftEyeGazeVector.z = 0f - trackingData.leftEyeGazeVector.z;
			trackingData.rightEyeGazeVector.z = 0f - trackingData.rightEyeGazeVector.z;
			trackingData.combinedEyeGazeVector.z = 0f - trackingData.combinedEyeGazeVector.z;
			trackingData.leftEyeGazePoint.z = 0f - trackingData.leftEyeGazePoint.z;
			trackingData.rightEyeGazePoint.z = 0f - trackingData.rightEyeGazePoint.z;
			trackingData.combinedEyeGazePoint.z = 0f - trackingData.combinedEyeGazePoint.z;
			trackingData.foveatedGazeDirection.z = 0f - trackingData.foveatedGazeDirection.z;
			return result;
		}

		public static bool UPvr_getEyeTrackingGazeRay(ref EyeTrackingGazeRay gazeRay)
		{
			if (!Pvr_UnitySDKEyeManager.supportEyeTracking)
			{
				PLOG.E("The device is not supported");
				return false;
			}
			if (!Pvr_UnitySDKEyeManager.Instance.EyeTracking)
			{
				PLOG.E("Please Enable \"Pvr_UnitySDK/Head/Pvr_UnitySDKEyeManager.cs/EyeTracking\"option first.");
				return false;
			}
			EyeTrackingData trackingData = default(EyeTrackingData);
			UPvr_getEyeTrackingData(ref trackingData);
			gazeRay.IsValid = ((uint)trackingData.combinedEyePoseStatus & (true ? 1u : 0u)) != 0 && (trackingData.combinedEyePoseStatus & 2) != 0;
			if (gazeRay.IsValid)
			{
				gazeRay.Direction = trackingData.combinedEyeGazeVector;
				gazeRay.Origin = trackingData.combinedEyeGazePoint;
				gazeRay.Origin = Pvr_UnitySDKSensor.Instance.HeadPose.Matrix.MultiplyPoint(gazeRay.Origin);
				gazeRay.Direction = Pvr_UnitySDKSensor.Instance.HeadPose.Matrix.MultiplyVector(gazeRay.Direction);
				return true;
			}
			return false;
		}

		public static bool UPvr_getEyeTrackingGazeRayWorld(ref EyeTrackingGazeRay gazeRay)
		{
			if (!Pvr_UnitySDKEyeManager.supportEyeTracking)
			{
				PLOG.E("The device is not supported");
				return false;
			}
			if (!Pvr_UnitySDKEyeManager.Instance.EyeTracking)
			{
				PLOG.E("Please Enable \"Pvr_UnitySDK/Head/Pvr_UnitySDKEyeManager.cs/EyeTracking\"option first.");
				return false;
			}
			Transform transform = Pvr_UnitySDKEyeManager.Instance.transform;
			Matrix4x4 matrix4x = Matrix4x4.TRS(transform.position, transform.rotation, Vector3.one);
			EyeTrackingData trackingData = default(EyeTrackingData);
			UPvr_getEyeTrackingData(ref trackingData);
			gazeRay.IsValid = ((uint)trackingData.combinedEyePoseStatus & (true ? 1u : 0u)) != 0 && (trackingData.combinedEyePoseStatus & 2) != 0;
			if (gazeRay.IsValid)
			{
				gazeRay.Direction = trackingData.combinedEyeGazeVector;
				gazeRay.Origin = trackingData.combinedEyeGazePoint;
				gazeRay.Origin = matrix4x.MultiplyPoint(gazeRay.Origin);
				gazeRay.Direction = matrix4x.MultiplyVector(gazeRay.Direction);
				return true;
			}
			return false;
		}

		public static Vector3 UPvr_getEyeTrackingPos()
		{
			if (!Pvr_UnitySDKEyeManager.supportEyeTracking)
			{
				PLOG.E("The device is not supported");
				return Vector3.zero;
			}
			if (!Pvr_UnitySDKEyeManager.Instance.EyeTracking)
			{
				PLOG.E("Please Enable \"Pvr_UnitySDK/Head/Pvr_UnitySDKEyeManager.cs/EyeTracking\"option first.");
				return Vector3.zero;
			}
			return Pvr_UnitySDKEyeManager.Instance.GetEyeTrackingPos();
		}

		public static int UPvr_GetPhoneScreenBrightness()
		{
			int result = 0;
			UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClientClass, "Pvr_GetScreen_Brightness", UPvr_GetCurrentActivity());
			return result;
		}

		public static void UPvr_SetPhoneScreenBrightness(int level)
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClientClass, "Pvr_setAPPScreen_Brightness", UPvr_GetCurrentActivity(), level);
		}

		public static bool UPvr_IsPicoDefaultActivity()
		{
			using (AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer"))
			{
				using AndroidJavaObject androidJavaObject = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
				if (androidJavaObject.Call<string>("getLocalClassName", Array.Empty<object>()) == "com.unity3d.player.UnityPlayerNativeActivityPico")
				{
					return true;
				}
			}
			return false;
		}

		public static bool UPvr_EnableSinglePass(bool enable)
		{
			return Pvr_EnableSinglePass(enable);
		}

		public static void UPvr_SetAntiAliasing(int antiAliasing)
		{
			Pvr_SetAntiAliasing(antiAliasing);
		}

		public static void UPvr_SinglePassBeforeForwardOpaque()
		{
			Pvr_SinglePassBeforeForwardOpaque();
		}

		public static void UPvr_SetCurrentRenderTexture(uint textureId)
		{
			Pvr_SetCurrentRenderTexture(textureId);
		}

		public static bool UPvr_SetSinglePassDepthBufferWidthHeight(int width, int height)
		{
			return Pvr_SetSinglePassDepthBufferWidthHeight(width, height);
		}

		public static int UPVR_setPerformanceLevels(int cpuLevel, int gpuLevel)
		{
			return PVR_setPerformanceLevels(cpuLevel, gpuLevel);
		}

		public static int UPvr_GetColorRes(string name)
		{
			int result = -1;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getColorRes", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetColorResError :" + ex.ToString());
			}
			return result;
		}

		public static int UPvr_GetConfigInt(string name)
		{
			int result = -1;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getConfigInt", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetConfigIntError :" + ex.ToString());
			}
			return result;
		}

		public static string UPvr_GetConfigString(string name)
		{
			string result = "";
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getConfigString", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetConfigStringError :" + ex.ToString());
			}
			return result;
		}

		public static string UPvr_GetDrawableLocation(string name)
		{
			string result = "";
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getDrawableLocation", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetDrawableLocationError :" + ex.ToString());
			}
			return result;
		}

		public static int UPvr_GetTextSize(string name)
		{
			int result = -1;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getTextSize", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetTextSizeError :" + ex.ToString());
			}
			return result;
		}

		public static string UPvr_GetLangString(string name)
		{
			string result = "";
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getLangString", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetLangStringError :" + ex.ToString());
			}
			return result;
		}

		public static string UPvr_GetStringValue(string id, int type)
		{
			string result = "";
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getStringValue", id, type);
			}
			catch (Exception ex)
			{
				PLOG.E("GetStringValueError :" + ex.ToString());
			}
			return result;
		}

		public static int UPvr_GetIntValue(string id, int type)
		{
			int result = -1;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getIntValue", id, type);
			}
			catch (Exception ex)
			{
				PLOG.E("GetIntValueError :" + ex.ToString());
			}
			return result;
		}

		public static float UPvr_GetFloatValue(string id)
		{
			float result = -1f;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getFloatValue", id);
			}
			catch (Exception ex)
			{
				PLOG.E("GetFloatValueError :" + ex.ToString());
			}
			return result;
		}

		public static string UPvr_GetObjectOrArray(string id, int type)
		{
			string result = "";
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getObjectOrArray", id, type);
			}
			catch (Exception ex)
			{
				PLOG.E("GetObjectOrArrayError :" + ex.ToString());
			}
			return result;
		}

		public static int UPvr_GetCharSpace(string id)
		{
			int result = -1;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getCharSpace", id);
			}
			catch (Exception ex)
			{
				PLOG.E("GetCharSpaceError :" + ex.ToString());
			}
			return result;
		}

		public static bool UPvr_SetExtraLatencyMode(ExtraLatencyMode mode)
		{
			return Pvr_SetExtraLatencyMode((int)mode);
		}

		public static float UPvr_GetPredictedDisplayTime()
		{
			float result = 0f;
			try
			{
				result = Pvr_GetPredictedDisplayTime();
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.Log("UPvr_GetPredictedDisplayTime :" + ex.ToString());
			}
			return result;
		}
	}
	public struct BoundarySystem
	{
		public enum BoundaryType
		{
			OuterBoundary,
			PlayArea
		}

		public struct BoundaryTestResult
		{
			public bool IsTriggering;

			public float ClosestDistance;

			public Vector3 ClosestPoint;

			public Vector3 ClosestPointNormal;
		}

		public enum BoundaryTrackingNode
		{
			HandLeft,
			HandRight,
			Head
		}

		public enum BoundaryTrackingState
		{
			LostNoReason = 3,
			LostCamera,
			LostHighLight,
			LostLowLight,
			LostLowFeatureCount,
			LostReLocation,
			LostInitialization,
			LostNoCamera,
			LostNoIMU,
			LostIMUJitter,
			LostUnknown
		}

		public const string LibFileName = "Pvr_UnitySDK";

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern float Pvr_GetFloorHeight();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetSeeThroughState();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_BoundarySetSTBackground(bool value);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetTrackingState();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_GetFrameRateLimit();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_IsBoundaryEnable();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_BoundaryGetConfigured();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_BoundaryTestNode(int node, bool isPlayArea, ref bool isTriggering, ref float closestDistance, ref float px, ref float py, ref float pz, ref float nx, ref float ny, ref float nz);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_BoundaryTestPoint(float x, float y, float z, bool isPlayArea, ref bool isTriggering, ref float closestDistance, ref float px, ref float py, ref float pz, ref float nx, ref float ny, ref float nz);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_BoundaryGetGeometry(out IntPtr handle, bool isPlayArea);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_BoundaryGetDimensions(ref float x, ref float y, ref float z, bool isPlayArea);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_BoundaryGetEnabled();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_BoundarySetVisible(bool value);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_BoundaryGetVisible();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_EnableLWRP(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_SetViewportSize(int w, int h);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_BoundarySetSeeThroughVisible(bool value);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void PVR_SetCameraImageRect(int width, int height);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetGuardianSystemDisable(bool value);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetDialogState();

		public static float UPvr_GetFloorHeight()
		{
			return Pvr_GetFloorHeight();
		}

		public static int UPvr_GetSeeThroughState()
		{
			return Pvr_GetSeeThroughState();
		}

		public static void UPvr_EnableSeeThroughManual(bool enable)
		{
			Pvr_BoundarySetSTBackground(enable);
		}

		public static BoundaryTrackingState UPvr_GetTrackingState()
		{
			return (BoundaryTrackingState)Pvr_GetTrackingState();
		}

		public static bool UPvr_GetFrameRateLimit()
		{
			return Pvr_GetFrameRateLimit();
		}

		public static bool UPvr_IsBoundaryEnable()
		{
			return Pvr_IsBoundaryEnable();
		}

		public static bool UPvr_BoundaryGetConfigured()
		{
			return Pvr_BoundaryGetConfigured();
		}

		public static BoundaryTestResult UPvr_BoundaryTestNode(BoundaryTrackingNode node, BoundaryType boundaryType)
		{
			BoundaryTestResult result = default(BoundaryTestResult);
			bool num = Pvr_BoundaryTestNode((int)node, boundaryType == BoundaryType.PlayArea, ref result.IsTriggering, ref result.ClosestDistance, ref result.ClosestPoint.x, ref result.ClosestPoint.y, ref result.ClosestPoint.z, ref result.ClosestPointNormal.x, ref result.ClosestPointNormal.y, ref result.ClosestPointNormal.z);
			result.ClosestPoint.z = 0f - result.ClosestPoint.z;
			result.ClosestPointNormal.z = 0f - result.ClosestPointNormal.z;
			if (!num)
			{
				UnityEngine.Debug.LogError($"UPvr_BoundaryTestNode({node}, {boundaryType}) API call failed!");
			}
			return result;
		}

		public static BoundaryTestResult UPvr_BoundaryTestPoint(Vector3 point, BoundaryType boundaryType)
		{
			BoundaryTestResult result = default(BoundaryTestResult);
			if (!Pvr_BoundaryTestPoint(point.x, point.y, 0f - point.z, boundaryType == BoundaryType.PlayArea, ref result.IsTriggering, ref result.ClosestDistance, ref result.ClosestPoint.x, ref result.ClosestPoint.y, ref result.ClosestPoint.z, ref result.ClosestPointNormal.x, ref result.ClosestPointNormal.y, ref result.ClosestPointNormal.z))
			{
				UnityEngine.Debug.LogError($"UPvr_BoundaryTestPoint({point}, {boundaryType}) API call failed!");
			}
			return result;
		}

		public static Vector3[] UPvr_BoundaryGetGeometry(BoundaryType boundaryType)
		{
			IntPtr handle = IntPtr.Zero;
			int num = Pvr_BoundaryGetGeometry(out handle, boundaryType == BoundaryType.PlayArea);
			if (num <= 0)
			{
				UnityEngine.Debug.LogError("Boundary geometry point count is " + num);
				return null;
			}
			int num2 = num * 3;
			float[] array = new float[num2];
			Marshal.Copy(handle, array, 0, num2);
			Vector3[] array2 = new Vector3[num];
			for (int i = 0; i < num; i++)
			{
				array2[i] = new Vector3
				{
					x = array[3 * i],
					y = array[3 * i + 1],
					z = 0f - array[3 * i + 2]
				};
			}
			return array2;
		}

		public static Vector3 UPvr_BoundaryGetDimensions(BoundaryType boundaryType)
		{
			float x = 0f;
			float y = 0f;
			float z = 0f;
			Pvr_BoundaryGetDimensions(ref x, ref y, ref z, boundaryType == BoundaryType.PlayArea);
			return new Vector3(x, y, z);
		}

		public static bool UPvr_BoundaryGetEnabled()
		{
			return Pvr_BoundaryGetEnabled();
		}

		public static void UPvr_BoundarySetVisible(bool value)
		{
			Pvr_BoundarySetVisible(value);
		}

		public static bool UPvr_BoundaryGetVisible()
		{
			return Pvr_BoundaryGetVisible();
		}

		public static bool UPvr_EnableLWRP(bool enable)
		{
			return Pvr_EnableLWRP(enable);
		}

		public static bool UPvr_SetViewportSize(int width, int height)
		{
			return Pvr_SetViewportSize(width, height);
		}

		public static void UPvr_StartCameraFrame()
		{
			try
			{
				Pvr_UnitySDKPluginEvent.Issue(RenderEventType.StartCameraFrame);
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_StartCameraFrame :" + ex.ToString());
			}
		}

		public static void UPvr_StopCameraFrame()
		{
			try
			{
				Pvr_UnitySDKPluginEvent.Issue(RenderEventType.StopCameraFrame);
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_StopCameraFrame :" + ex.ToString());
			}
		}

		public static void UPvr_BoundaryGetSeeThroughData(int cameraIndex, RenderTexture renderTexture)
		{
			try
			{
				if (renderTexture.IsCreated())
				{
					System.UPvr_UnityEventData(renderTexture.GetNativeTexturePtr().ToInt32());
					switch (cameraIndex)
					{
					case 0:
						Pvr_UnitySDKPluginEvent.Issue(RenderEventType.CameraFrameLeft);
						break;
					case 1:
						Pvr_UnitySDKPluginEvent.Issue(RenderEventType.CameraFrameRight);
						break;
					}
				}
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_BoundaryGetSeeThroughDataError :" + ex.ToString());
			}
		}

		public static void UPvr_BoundarySetCameraImageRect(int width, int height)
		{
			try
			{
				PVR_SetCameraImageRect(width, height);
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_BoundarySetCameraImageRectError :" + ex.ToString());
			}
		}

		public static void UPvr_BoundarySetSeeThroughVisible(bool value)
		{
			try
			{
				Pvr_BoundarySetSeeThroughVisible(value);
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_BoundarySetSeeThroughVisibleError :" + ex.ToString());
			}
		}

		public static void UPvr_SetGuardianSystemDisable(bool value)
		{
			try
			{
				Pvr_SetGuardianSystemDisable(value);
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_SetGuardianSystemDisableError :" + ex.ToString());
			}
		}

		public static int UPvr_GetDialogState()
		{
			int result = 0;
			try
			{
				result = Pvr_GetDialogState();
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_GetDialogStateError :" + ex.ToString());
			}
			return result;
		}
	}
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	public struct PlatformSettings
	{
		public static Pvr_UnitySDKPlatformSetting.simulationType UPvr_IsCurrentDeviceValid()
		{
			if (Pvr_UnitySDKPlatformSetting.Entitlementchecksimulation)
			{
				if (Pvr_UnitySDKPlatformSetting.Instance.deviceSN.Count <= 0)
				{
					UnityEngine.Debug.Log("DISFT Entitlement Check Simulation deviceSN is Null");
					return Pvr_UnitySDKPlatformSetting.simulationType.Null;
				}
				foreach (string item in Pvr_UnitySDKPlatformSetting.Instance.deviceSN)
				{
					if (System.UPvr_GetDeviceSN() == item)
					{
						return Pvr_UnitySDKPlatformSetting.simulationType.Valid;
					}
				}
				UnityEngine.Debug.Log("DISFT Entitlement Check Simulation deviceSN is Invalid");
				return Pvr_UnitySDKPlatformSetting.simulationType.Invalid;
			}
			UnityEngine.Debug.Log("DISFT Entitlement Check Simulation DO NOT Enable");
			return Pvr_UnitySDKPlatformSetting.simulationType.Invalid;
		}

		public static bool UPvr_AppEntitlementCheck(string appid)
		{
			bool result = false;
			try
			{
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "verifyAPP", System.UPvr_GetCurrentActivity(), appid, "");
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
			UnityEngine.Debug.Log("PvrLog UPvr_AppEntitlementCheck" + result);
			return result;
		}

		[Obsolete("This API will be removed in later versions")]
		public static bool UPvr_KeyEntitlementCheck(string publicKey)
		{
			bool result = false;
			try
			{
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "verifyAPP", System.UPvr_GetCurrentActivity(), "", publicKey);
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
			UnityEngine.Debug.Log("PvrLog UPvr_KeyEntitlementCheck" + result);
			return result;
		}

		public static int UPvr_AppEntitlementCheckExtra(string appid)
		{
			return 0;
		}

		public static int UPvr_KeyEntitlementCheckExtra(string publicKey)
		{
			int result = -1;
			try
			{
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "verifyAPPExt", System.UPvr_GetCurrentActivity(), "", publicKey);
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
			UnityEngine.Debug.Log("PvrLog UPvr_KeyEntitlementCheck" + result);
			return result;
		}

		public static int UPvr_GetHmdAudioStatus()
		{
			return System.PVR_GetHmdAudioStatus();
		}
	}
	public enum DeviceCommand
	{
		SET_PICO_NEO_HMD_BRIGHTNESS = 12,
		SET_PICO_NEO_HMD_SLEEPDELAY
	}
	public enum BrightnessLevel
	{
		VR_BRIGHTNESS_LEVEL_MIN = 1,
		VR_BRIGHTNESS_LEVEL_MAX = 100,
		VR_BRIGHTNESS_LEVEL_DOWN = 1000,
		VR_BRIGHTNESS_LEVEL_UP = 1001,
		VR_BRIGHTNESS_LEVEL_SCREEN_OFF = -100
	}
	public struct VolumePowerBrightness
	{
		public const string LibFileName = "Pvr_UnitySDK";

		public AndroidJavaObject activity;

		public static AndroidJavaClass javaSysActivityClass;

		private static AndroidJavaClass batteryjavaVrActivityClass;

		private static AndroidJavaClass volumejavaVrActivityClass;

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_SetInitActivity(IntPtr activity, IntPtr vrActivityClass);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_IsHmdExist();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetHmdScreenBrightness();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_SetHmdScreenBrightness(int brightness);

		public static bool UPvr_IsHmdExist()
		{
			return Pvr_IsHmdExist();
		}

		public static int UPvr_GetHmdScreenBrightness()
		{
			return Pvr_GetHmdScreenBrightness();
		}

		public static bool UPvr_SetHmdScreenBrightness(int brightness)
		{
			return Pvr_SetHmdScreenBrightness(brightness);
		}

		public static bool UPvr_SetCommonBrightness(int brightness)
		{
			bool flag = false;
			if (UPvr_IsHmdExist())
			{
				return UPvr_SetHmdScreenBrightness(brightness);
			}
			return UPvr_SetBrightness(brightness);
		}

		public static int UPvr_GetCommonBrightness()
		{
			int num = 0;
			if (UPvr_IsHmdExist())
			{
				return UPvr_GetHmdScreenBrightness();
			}
			return UPvr_GetCurrentBrightness();
		}

		public static int[] UPvr_GetScreenBrightnessLevel()
		{
			return Pvr_GetScreenBrightnessLevel();
		}

		public static void UPvr_SetScreenBrightnessLevel(int vrBrightness, int level)
		{
			Pvr_SetScreenBrightnessLevel(vrBrightness, level);
		}

		public static bool UPvr_SetDevicePropForUser(DeviceCommand deviceid, string number)
		{
			return setDevicePropForUser(deviceid, number);
		}

		public static string UPvr_GetDevicePropForUser(DeviceCommand deviceid)
		{
			return getDevicePropForUser(deviceid);
		}

		public static bool UPvr_InitBatteryClass()
		{
			try
			{
				if (javaSysActivityClass == null)
				{
					javaSysActivityClass = new AndroidJavaClass("com.psmart.aosoperation.SysActivity");
				}
				if (javaSysActivityClass != null && Pvr_UnitySDKRender.Instance.activity != null)
				{
					if (batteryjavaVrActivityClass == null)
					{
						batteryjavaVrActivityClass = new AndroidJavaClass("com.psmart.aosoperation.BatteryReceiver");
					}
					return true;
				}
				return false;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_InitBatteryVolClass()
		{
			try
			{
				javaSysActivityClass = new AndroidJavaClass("com.psmart.aosoperation.SysActivity");
				if (javaSysActivityClass != null && Pvr_UnitySDKRender.Instance.activity != null)
				{
					batteryjavaVrActivityClass = new AndroidJavaClass("com.psmart.aosoperation.BatteryReceiver");
					volumejavaVrActivityClass = new AndroidJavaClass("com.psmart.aosoperation.AudioReceiver");
					System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_InitAudioDevice", Pvr_UnitySDKRender.Instance.activity);
					return true;
				}
				return false;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_StartBatteryReceiver(string startreceivre)
		{
			try
			{
				System.UPvr_CallStaticMethod(batteryjavaVrActivityClass, "Pvr_StartReceiver", Pvr_UnitySDKRender.Instance.activity, startreceivre);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_StopBatteryReceiver()
		{
			try
			{
				System.UPvr_CallStaticMethod(batteryjavaVrActivityClass, "Pvr_StopReceiver", Pvr_UnitySDKRender.Instance.activity);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_SetBrightness(int brightness)
		{
			try
			{
				System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_SetScreen_Brightness", brightness, Pvr_UnitySDKRender.Instance.activity);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
				return false;
			}
		}

		public static int UPvr_GetCurrentBrightness()
		{
			int result = 0;
			try
			{
				System.UPvr_CallStaticMethod(ref result, javaSysActivityClass, "Pvr_GetScreen_Brightness", Pvr_UnitySDKRender.Instance.activity);
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
			}
			return result;
		}

		public static int[] Pvr_GetScreenBrightnessLevel()
		{
			int[] result = new int[1];
			try
			{
				System.UPvr_CallStaticMethod(ref result, javaSysActivityClass, "getScreenBrightnessLevel");
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
			}
			return result;
		}

		public static void Pvr_SetScreenBrightnessLevel(int vrBrightness, int level)
		{
			try
			{
				System.UPvr_CallStaticMethod(javaSysActivityClass, "setScreenBrightnessLevel", vrBrightness, level);
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
			}
		}

		public static bool UPvr_StartAudioReceiver(string startreceivre)
		{
			try
			{
				System.UPvr_CallStaticMethod(volumejavaVrActivityClass, "Pvr_StartReceiver", Pvr_UnitySDKRender.Instance.activity, startreceivre);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_StopAudioReceiver()
		{
			try
			{
				System.UPvr_CallStaticMethod(volumejavaVrActivityClass, "Pvr_StopReceiver", Pvr_UnitySDKRender.Instance.activity);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static int UPvr_GetMaxVolumeNumber()
		{
			int result = 0;
			try
			{
				System.UPvr_CallStaticMethod(ref result, javaSysActivityClass, "Pvr_GetMaxAudionumber");
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
			}
			return result;
		}

		public static int UPvr_GetCurrentVolumeNumber()
		{
			int result = 0;
			try
			{
				System.UPvr_CallStaticMethod(ref result, javaSysActivityClass, "Pvr_GetAudionumber");
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
			}
			return result;
		}

		public static bool UPvr_VolumeUp()
		{
			try
			{
				System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_UpAudio");
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_VolumeDown()
		{
			try
			{
				System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_DownAudio");
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_SetVolumeNum(int volume)
		{
			try
			{
				System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_ChangeAudio", volume);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_SetAudio(string s)
		{
			return false;
		}

		public static bool UPvr_SetBattery(string s)
		{
			return false;
		}

		private static string getDevicePropForUser(DeviceCommand deviceid)
		{
			string result = "0";
			System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getDevicePropForUser", (int)deviceid);
			return result;
		}

		private static bool setDevicePropForUser(DeviceCommand deviceid, string number)
		{
			bool result = false;
			System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "setDevicePropForUser", (int)deviceid, number);
			return result;
		}
	}
}
namespace Pvr_UnitySDKAPI.Achievement
{
	public class Pvr_AchievementDefinition
	{
		public readonly AchievementType Type;

		public readonly string Name;

		public readonly int BitfieldLength;

		public readonly long Target;

		public readonly string Title;

		public readonly string Description;

		public readonly string UnlockedDescription;

		public readonly string UnlockedIcon;

		public readonly string LockedIcon;

		public readonly bool IsSecrect;

		public Pvr_AchievementDefinition(AndroidJavaObject msg)
		{
			Type = Pvr_AchievementAPI.pvr_AchievementDefinition_GetType(msg);
			Name = Pvr_AchievementAPI.pvr_AchievementDefinition_GetName(msg);
			BitfieldLength = Pvr_AchievementAPI.pvr_AchievementDefinition_GetBitfieldLength(msg);
			Target = Pvr_AchievementAPI.pvr_AchievementDefinition_GetTarget(msg);
			Title = Pvr_AchievementAPI.pvr_AchievementDefinition_GetTitle(msg);
			Description = Pvr_AchievementAPI.pvr_AchievementDefinition_GetDescription(msg);
			UnlockedDescription = Pvr_AchievementAPI.pvr_AchievementDefinition_GetUnlockedDescription(msg);
			UnlockedIcon = Pvr_AchievementAPI.pvr_AchievementDefinition_GetUnlockedIcon(msg);
			LockedIcon = Pvr_AchievementAPI.pvr_AchievementDefinition_GetLockedIcon(msg);
			IsSecrect = Pvr_AchievementAPI.pvr_AchievementDefinition_GetIsSecrect(msg);
		}
	}
	public class Pvr_AchievementDefinitionList : Pvr_DeserializableList<Pvr_AchievementDefinition>
	{
		public Pvr_AchievementDefinitionList(AndroidJavaObject msg)
		{
			int num = Pvr_AchievementAPI.pvr_AchievementDefinitionArray_GetSize(msg);
			data = new List<Pvr_AchievementDefinition>(num);
			for (int i = 0; i < num; i++)
			{
				data.Add(new Pvr_AchievementDefinition(Pvr_AchievementAPI.pvr_AchievementDefinitionArray_GetElement(msg, i)));
			}
			nextUrl = Pvr_AchievementAPI.pvr_AchievementDefinitionArray_GetNextUrl(msg);
		}
	}
	public class Pvr_AchievementProgress
	{
		public readonly string Bitfield;

		public readonly long Count;

		public readonly bool IsUnlocked;

		public readonly string Name;

		public readonly DateTime UnlockTime;

		public Pvr_AchievementProgress(AndroidJavaObject msg)
		{
			Bitfield = Pvr_AchievementAPI.pvr_AchievementProgress_GetBitfield(msg);
			Count = Pvr_AchievementAPI.pvr_AchievementProgress_GetCount(msg);
			IsUnlocked = Pvr_AchievementAPI.pvr_AchievementProgress_GetIsUnlocked(msg);
			Name = Pvr_AchievementAPI.pvr_AchievementProgress_GetName(msg);
			UnlockTime = Pvr_AchievementAPI.pvr_AchievementProgress_GetUnlockTime(msg);
		}
	}
	public class Pvr_AchievementProgressList : Pvr_DeserializableList<Pvr_AchievementProgress>
	{
		public Pvr_AchievementProgressList(AndroidJavaObject msg)
		{
			int num = Pvr_AchievementAPI.pvr_AchievementProgressArray_GetSize(msg);
			data = new List<Pvr_AchievementProgress>(num);
			for (int i = 0; i < num; i++)
			{
				data.Add(new Pvr_AchievementProgress(Pvr_AchievementAPI.pvr_AchievementProgressArray_GetElement(msg, i)));
			}
			nextUrl = Pvr_AchievementAPI.pvr_AchievementProgressArray_GetNextUrl(msg);
		}
	}
	public class Pvr_AchievementUpdate
	{
		public readonly bool JustUnlocked;

		public readonly string Name;

		public Pvr_AchievementUpdate(AndroidJavaObject msg)
		{
			JustUnlocked = Pvr_AchievementAPI.pvr_AchievementUpdate_GetJustUnlocked(msg);
			Name = Pvr_AchievementAPI.pvr_AchievementUpdate_GetName(msg);
		}
	}
	public static class Pvr_Callback
	{
		private class RequestCallback
		{
			private Pvr_Message.Callback messageCallback;

			public RequestCallback()
			{
			}

			public RequestCallback(Pvr_Message.Callback callback)
			{
				messageCallback = callback;
			}

			public virtual void HandleMessage(Pvr_Message msg)
			{
				if (messageCallback != null)
				{
					messageCallback(msg);
				}
			}
		}

		private sealed class RequestCallback<T> : RequestCallback
		{
			private Pvr_Message<T>.Callback callback;

			public RequestCallback(Pvr_Message<T>.Callback callback)
			{
				this.callback = callback;
			}

			public override void HandleMessage(Pvr_Message msg)
			{
				if (callback != null)
				{
					if (msg is Pvr_Message<T>)
					{
						callback((Pvr_Message<T>)msg);
					}
					else
					{
						UnityEngine.Debug.LogError("Unable to handle message: " + msg.GetType());
					}
				}
			}
		}

		private static Dictionary<long, Request> requestIDsToRequests = new Dictionary<long, Request>();

		private static Dictionary<Pvr_Message.MessageType, RequestCallback> notificationCallbacks = new Dictionary<Pvr_Message.MessageType, RequestCallback>();

		internal static void AddRequest(Request request)
		{
			if (request.RequestID <= 2)
			{
				long requestID = request.RequestID;
				if ((ulong)requestID <= 2uL)
				{
					switch (requestID)
					{
					case 0L:
						UnityEngine.Debug.LogError("An PARAM_INVALIDE error occurred. Request failed.");
						return;
					case 1L:
						UnityEngine.Debug.LogError("An NETWORK_INVALIDE error occurred. Request failed.");
						return;
					case 2L:
						UnityEngine.Debug.LogError("An NOT_INTIALIZE error occurred. Request failed.");
						return;
					}
				}
				UnityEngine.Debug.LogError("An unknown error occurred. Request failed.");
			}
			else
			{
				requestIDsToRequests[request.RequestID] = request;
			}
		}

		internal static void RunCallbacks()
		{
			while (true)
			{
				Pvr_Message pvr_Message = Pvr_Message.PopMessage();
				if (pvr_Message != null)
				{
					HandleMessage(pvr_Message);
					continue;
				}
				break;
			}
		}

		internal static void RunLimitedCallbacks(uint limit)
		{
			for (int i = 0; i < limit; i++)
			{
				Pvr_Message pvr_Message = Pvr_Message.PopMessage();
				if (pvr_Message != null)
				{
					HandleMessage(pvr_Message);
					continue;
				}
				break;
			}
		}

		internal static void OnApplicationQuit()
		{
			requestIDsToRequests.Clear();
			notificationCallbacks.Clear();
		}

		internal static void HandleMessage(Pvr_Message msg)
		{
			if (msg.RequestID != 0L && requestIDsToRequests.TryGetValue(msg.RequestID, out var value))
			{
				try
				{
					value.HandleMessage(msg);
					return;
				}
				finally
				{
					requestIDsToRequests.Remove(msg.RequestID);
				}
			}
			if (notificationCallbacks.TryGetValue(msg.Type, out var value2))
			{
				value2.HandleMessage(msg);
			}
		}
	}
	public class Pvr_CallbackRunner : MonoBehaviour
	{
		public bool IsPersistantBetweenSceneLoads = true;

		private void Awake()
		{
			if (UnityEngine.Object.FindObjectOfType<Pvr_CallbackRunner>() != this)
			{
				UnityEngine.Debug.LogWarning("You only need one instance of CallbackRunner");
			}
			if (IsPersistantBetweenSceneLoads)
			{
				UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
			}
		}

		private void Update()
		{
			Request.RunCallbacks();
		}

		private void OnApplicationQuit()
		{
			Pvr_Callback.OnApplicationQuit();
		}
	}
	public class Pvr_DeserializableList<T> : IList<T>, ICollection<T>, IEnumerable<T>, IEnumerable
	{
		protected List<T> data;

		protected string nextUrl;

		protected string previousUrl;

		public int Count => data.Count;

		bool ICollection<T>.IsReadOnly => ((ICollection<T>)data).IsReadOnly;

		public T this[int index]
		{
			get
			{
				return data[index];
			}
			set
			{
				data[index] = value;
			}
		}

		public bool HasNextPage => !string.IsNullOrEmpty(NextUrl);

		public bool HasPreviousPage => !string.IsNullOrEmpty(PreviousUrl);

		public string NextUrl => nextUrl;

		public string PreviousUrl => previousUrl;

		public int IndexOf(T obj)
		{
			return data.IndexOf(obj);
		}

		public void Add(T item)
		{
			data.Add(item);
		}

		public void Clear()
		{
			data.Clear();
		}

		public bool Contains(T item)
		{
			return data.Contains(item);
		}

		public void CopyTo(T[] array, int arrayIndex)
		{
			data.CopyTo(array, arrayIndex);
		}

		public IEnumerator<T> GetEnumerator()
		{
			return data.GetEnumerator();
		}

		public void Insert(int index, T item)
		{
			data.Insert(index, item);
		}

		public bool Remove(T item)
		{
			return data.Remove(item);
		}

		public void RemoveAt(int index)
		{
			data.RemoveAt(index);
		}

		private IEnumerator GetEnumerator1()
		{
			return GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator1();
		}
	}
	public abstract class Pvr_Message<T> : Pvr_Message
	{
		public new delegate void Callback(Pvr_Message<T> message);

		private T data;

		public T Data => data;

		public Pvr_Message(AndroidJavaObject msg)
			: base(msg)
		{
			if (!base.IsError)
			{
				data = GetDataFromMessage(msg);
			}
		}

		protected abstract T GetDataFromMessage(AndroidJavaObject msg);
	}
	public class Pvr_Message
	{
		public delegate void Callback(Pvr_Message message);

		public enum MessageType : uint
		{
			Unknown = 0u,
			Achievements_AddCount = 65495601u,
			Achievements_AddFields = 346693929u,
			Achievements_GetAllDefinitions = 64177549u,
			Achievements_GetAllProgress = 1335877149u,
			Achievements_GetDefinitionsByName = 1653670332u,
			Achievements_GetNextAchievementDefinitionArrayPage = 712888917u,
			Achievements_GetNextAchievementProgressArrayPage = 792913703u,
			Achievements_GetProgressByName = 354837425u,
			Achievements_Unlock = 1497156573u,
			Achievements_WriteAchievementProgress = 121027549u,
			Achievements_VerifyAccessToken = 53284924u
		}

		internal delegate Pvr_Message ExtraMessageTypesHandler(AndroidJavaObject messageHandle, MessageType message_type);

		private MessageType type;

		private long requestID;

		private Error error;

		public MessageType Type => type;

		public bool IsError => error != null;

		public long RequestID => requestID;

		internal static ExtraMessageTypesHandler HandleExtraMessageTypes { private get; set; }

		public Pvr_Message(AndroidJavaObject msg)
		{
			type = (MessageType)Pvr_AchievementAPI.pvr_Message_GetType(msg);
			bool num = Pvr_AchievementAPI.pvr_Message_IsError(msg);
			requestID = Pvr_AchievementAPI.pvr_Message_GetRequestID(msg);
			if (num)
			{
				error = new Error(Pvr_AchievementAPI.pvr_Error_GetCode(msg), Pvr_AchievementAPI.pvr_Error_GetMessage(msg), Pvr_AchievementAPI.pvr_Error_GetHttpCode(msg));
			}
			else if (AchievementCore.LogMessages)
			{
				string text = Pvr_AchievementAPI.pvr_Message_GetString(msg);
				if (text != null)
				{
					UnityEngine.Debug.Log(text);
				}
				else
				{
					UnityEngine.Debug.Log($"null message string {msg}");
				}
			}
		}

		public virtual Error GetError()
		{
			return error;
		}

		public virtual Pvr_AchievementDefinitionList GetAchievementDefinitions()
		{
			return null;
		}

		public virtual Pvr_AchievementProgressList GetAchievementProgressList()
		{
			return null;
		}

		public virtual Pvr_AchievementUpdate GetAchievementUpdate()
		{
			return null;
		}

		public virtual string GetString()
		{
			return null;
		}

		internal static Pvr_Message ParseMessageHandle(AndroidJavaObject messageHandle)
		{
			if (messageHandle == null)
			{
				return null;
			}
			Pvr_Message result = null;
			switch ((MessageType)Pvr_AchievementAPI.pvr_Message_GetType(messageHandle))
			{
			case MessageType.Achievements_GetAllDefinitions:
			case MessageType.Achievements_GetNextAchievementDefinitionArrayPage:
			case MessageType.Achievements_GetDefinitionsByName:
				result = new MessageWithAchievementDefinitions(messageHandle);
				break;
			case MessageType.Achievements_GetProgressByName:
			case MessageType.Achievements_GetNextAchievementProgressArrayPage:
			case MessageType.Achievements_GetAllProgress:
				result = new MessageWithAchievementProgressList(messageHandle);
				break;
			case MessageType.Achievements_VerifyAccessToken:
			case MessageType.Achievements_AddCount:
			case MessageType.Achievements_AddFields:
			case MessageType.Achievements_Unlock:
				result = new MessageWithAchievementUpdate(messageHandle);
				break;
			}
			return result;
		}

		public static Pvr_Message PopMessage()
		{
			return ParseMessageHandle(Pvr_AchievementAPI.PopMessage());
		}
	}
	public class MessageWithAchievementDefinitions : Pvr_Message<Pvr_AchievementDefinitionList>
	{
		public MessageWithAchievementDefinitions(AndroidJavaObject msg)
			: base(msg)
		{
		}

		public override Pvr_AchievementDefinitionList GetAchievementDefinitions()
		{
			return base.Data;
		}

		protected override Pvr_AchievementDefinitionList GetDataFromMessage(AndroidJavaObject msg)
		{
			return new Pvr_AchievementDefinitionList(msg);
		}
	}
	public class MessageWithAchievementProgressList : Pvr_Message<Pvr_AchievementProgressList>
	{
		public MessageWithAchievementProgressList(AndroidJavaObject msg)
			: base(msg)
		{
		}

		public override Pvr_AchievementProgressList GetAchievementProgressList()
		{
			return base.Data;
		}

		protected override Pvr_AchievementProgressList GetDataFromMessage(AndroidJavaObject msg)
		{
			return new Pvr_AchievementProgressList(msg);
		}
	}
	public class MessageWithAchievementUpdate : Pvr_Message<Pvr_AchievementUpdate>
	{
		public MessageWithAchievementUpdate(AndroidJavaObject msg)
			: base(msg)
		{
		}

		public override Pvr_AchievementUpdate GetAchievementUpdate()
		{
			return base.Data;
		}

		protected override Pvr_AchievementUpdate GetDataFromMessage(AndroidJavaObject msg)
		{
			return new Pvr_AchievementUpdate(msg);
		}
	}
	public class MessageWithString : Pvr_Message<string>
	{
		public MessageWithString(AndroidJavaObject msg)
			: base(msg)
		{
		}

		public override string GetString()
		{
			return base.Data;
		}

		protected override string GetDataFromMessage(AndroidJavaObject msg)
		{
			return Pvr_AchievementAPI.pvr_Message_GetString(msg);
		}
	}
	public class Error
	{
		public readonly int Code;

		public readonly int HttpCode;

		public readonly string Message;

		public Error(int code, string message, int httpCode)
		{
			Message = message;
			Code = code;
			HttpCode = httpCode;
		}
	}
	public sealed class AchievementCore
	{
		private static bool IsPlatformInitialized = true;

		public static bool LogMessages = false;

		public static bool IsInitialized()
		{
			return IsPlatformInitialized;
		}

		public static void Initialize()
		{
		}

		public static void RegisterNetwork()
		{
			Pvr_AchievementAPI.RegisterNetwork();
		}

		public static void UnRegisterNetwork()
		{
			Pvr_AchievementAPI.UnRegisterNetwork();
		}
	}
	public static class Achievements
	{
		public static Pvr_Request<Pvr_AchievementUpdate> Init()
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementUpdate>(Pvr_AchievementAPI.Init());
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementUpdate> AddCount(string name, long count)
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementUpdate>(Pvr_AchievementAPI.pvr_Achievements_AddCount(name, count));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementUpdate> AddFields(string name, string fields)
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementUpdate>(Pvr_AchievementAPI.pvr_Achievements_AddFields(name, fields));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementDefinitionList> GetAllDefinitions()
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementDefinitionList>(Pvr_AchievementAPI.pvr_Achievements_GetAllDefinitions());
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementProgressList> GetAllProgress()
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementProgressList>(Pvr_AchievementAPI.pvr_Achievements_GetAllProgress());
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementDefinitionList> GetDefinitionsByName(string[] names)
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementDefinitionList>(Pvr_AchievementAPI.pvr_Achievements_GetDefinitionsByName(names, (names != null) ? names.Length : 0));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementProgressList> GetProgressByName(string[] names)
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementProgressList>(Pvr_AchievementAPI.pvr_Achievements_GetProgressByName(names, (names != null) ? names.Length : 0));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementUpdate> Unlock(string name)
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementUpdate>(Pvr_AchievementAPI.pvr_Achievements_Unlock(name));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementDefinitionList> GetNextAchievementDefinitionListPage(Pvr_AchievementDefinitionList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Platform.GetNextAchievementDefinitionListPage: List has no next page");
				return null;
			}
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementDefinitionList>(Pvr_AchievementAPI.pvr_HTTP_GetWithMessageType(list.NextUrl, Pvr_Message.MessageType.Achievements_GetNextAchievementDefinitionArrayPage));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementProgressList> GetNextAchievementProgressListPage(Pvr_AchievementProgressList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Platform.GetNextAchievementProgressListPage: List has no next page");
				return null;
			}
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementProgressList>(Pvr_AchievementAPI.pvr_HTTP_GetWithMessageType(list.NextUrl, Pvr_Message.MessageType.Achievements_GetNextAchievementProgressArrayPage));
			}
			return null;
		}
	}
	public sealed class Pvr_Request<T> : Request
	{
		private Pvr_Message<T>.Callback callback_;

		public Pvr_Request(long requestID)
			: base(requestID)
		{
		}

		public Pvr_Request<T> OnComplete(Pvr_Message<T>.Callback callback)
		{
			if (callback_ != null)
			{
				throw new UnityException("Attempted to attach multiple handlers to a Request.  This is not allowed.");
			}
			callback_ = callback;
			Pvr_Callback.AddRequest(this);
			return this;
		}

		public override void HandleMessage(Pvr_Message msg)
		{
			if (!(msg is Pvr_Message<T>))
			{
				UnityEngine.Debug.LogError("Unable to handle message: " + msg.GetType());
				return;
			}
			if (callback_ != null)
			{
				callback_((Pvr_Message<T>)msg);
				return;
			}
			throw new UnityException("Request with no handler.  This should never happen.");
		}
	}
	public class Request
	{
		private Pvr_Message.Callback callback_;

		public long RequestID { get; set; }

		public Request(long requestID)
		{
			RequestID = requestID;
		}

		public Request OnComplete(Pvr_Message.Callback callback)
		{
			callback_ = callback;
			Pvr_Callback.AddRequest(this);
			return this;
		}

		public virtual void HandleMessage(Pvr_Message msg)
		{
			if (callback_ != null)
			{
				callback_(msg);
				return;
			}
			throw new UnityException("Request with no handler.  This should never happen.");
		}

		public static void RunCallbacks(uint limit = 0u)
		{
			if (limit == 0)
			{
				Pvr_Callback.RunCallbacks();
			}
			else
			{
				Pvr_Callback.RunLimitedCallbacks(limit);
			}
		}
	}
	public enum AchievementType
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("SIMPLE")]
		Simple,
		[Description("BITFIELD")]
		Bitfield,
		[Description("COUNT")]
		Count
	}
	public class Pvr_AchievementAPI
	{
		private static AndroidJavaClass achievementAPI = new AndroidJavaClass("com.pico.achievement.AchievementAPI");

		private static AndroidJavaClass definitionArrayHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementDefinitionArrayHandle");

		private static AndroidJavaClass definitionHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementDefinitionHandle");

		private static AndroidJavaClass progressArrayHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementProgressArrayHandle");

		private static AndroidJavaClass progressHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementProgressHandle");

		private static AndroidJavaClass updateHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementUpdateHandle");

		private static AndroidJavaObject errorHandle = new AndroidJavaObject("com.picovr.achievement.utils.pvrAchievementErrorHandle");

		private static AndroidJavaObject unityInterface = new AndroidJavaObject("com.pico.loginpaysdk.UnityInterface");

		private static string openId;

		private static string accessToken;

		private static string appId = Pvr_UnitySDKPlatformSetting.Instance.appID;

		internal static long Init()
		{
			AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
			unityInterface.Call("init", @static);
			unityInterface.Call("authSSO");
			AndroidJavaObject androidJavaObject = new AndroidJavaClass("com.pico.loginpaysdk.utils.PicoAccessTokenKeeper").CallStatic<AndroidJavaObject>("readAccessToken", new object[1] { @static });
			accessToken = androidJavaObject.Call<string>("getAccessToken", Array.Empty<object>());
			openId = androidJavaObject.Call<string>("getOpenId", Array.Empty<object>());
			return achievementAPI.CallStatic<long>("init", new object[3] { accessToken, openId, @static });
		}

		internal static void RegisterNetwork()
		{
			AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
			achievementAPI.CallStatic("registerNetwork", @static);
		}

		internal static void UnRegisterNetwork()
		{
			achievementAPI.CallStatic("unregisterNetwork");
		}

		internal static AndroidJavaObject PopMessage()
		{
			return achievementAPI.CallStatic<AndroidJavaObject>("pvr_PopMessage", Array.Empty<object>());
		}

		internal static string pvr_Error_GetMessage(AndroidJavaObject popMessage)
		{
			return errorHandle.CallStatic<string>("pvr_Error_GetMessage", new object[1] { popMessage });
		}

		internal static int pvr_Error_GetHttpCode(AndroidJavaObject popMessage)
		{
			return errorHandle.CallStatic<int>("pvr_Error_GetHttpCode", new object[1] { popMessage });
		}

		internal static int pvr_Error_GetCode(AndroidJavaObject popMessage)
		{
			return errorHandle.CallStatic<int>("pvr_Error_GetCode", new object[1] { popMessage });
		}

		internal static long pvr_Achievements_AddCount(string name, long count)
		{
			return achievementAPI.CallStatic<long>("pvr_Achievements_AddCount", new object[3] { name, count, accessToken });
		}

		internal static long pvr_Achievements_AddFields(string name, string fields)
		{
			return achievementAPI.CallStatic<long>("pvr_Achievements_AddFields", new object[3] { name, fields, accessToken });
		}

		internal static long pvr_Achievements_GetAllDefinitions()
		{
			AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
			return achievementAPI.CallStatic<long>("pvr_Achievements_GetAllDefinitions", new object[2] { appId, @static });
		}

		internal static long pvr_Achievements_GetAllProgress()
		{
			return achievementAPI.CallStatic<long>("pvr_Achievements_GetAllProgress", new object[1] { accessToken });
		}

		internal static long pvr_Achievements_GetDefinitionsByName(string[] names, int v)
		{
			AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
			return achievementAPI.CallStatic<long>("pvr_Achievements_GetDefinitionsByName", new object[2] { names, @static });
		}

		internal static long pvr_Achievements_GetProgressByName(string[] names, int v)
		{
			return achievementAPI.CallStatic<long>("pvr_Achievements_GetProgressByName", new object[2] { names, accessToken });
		}

		internal static long pvr_Achievements_Unlock(string name)
		{
			return achievementAPI.CallStatic<long>("pvr_Achievements_Unlock", new object[2] { name, accessToken });
		}

		internal static long pvr_HTTP_GetWithMessageType(string nextUrl, Pvr_Message.MessageType messageType)
		{
			long result = 0L;
			switch (messageType)
			{
			case Pvr_Message.MessageType.Achievements_GetNextAchievementDefinitionArrayPage:
			{
				AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
				result = achievementAPI.CallStatic<long>("pvr_Achievements_GetAllDefinitionsByUrl", new object[2] { nextUrl, @static });
				break;
			}
			case Pvr_Message.MessageType.Achievements_GetNextAchievementProgressArrayPage:
				result = achievementAPI.CallStatic<long>("pvr_Achievements_GetAllProgressByUrl", new object[1] { nextUrl });
				break;
			}
			return result;
		}

		internal static long pvr_Message_GetType(AndroidJavaObject popMessage)
		{
			return popMessage.Call<AndroidJavaObject>("getHandleType", Array.Empty<object>()).Call<long>("getIndex", Array.Empty<object>());
		}

		internal static bool pvr_Message_IsError(AndroidJavaObject popMessage)
		{
			return popMessage.Call<bool>("isMessage_IsError", Array.Empty<object>());
		}

		internal static long pvr_Message_GetRequestID(AndroidJavaObject popMessage)
		{
			return popMessage.Call<long>("getId", Array.Empty<object>());
		}

		internal static string pvr_Message_GetString(AndroidJavaObject popMessage)
		{
			return popMessage.Call<string>("getContent", Array.Empty<object>());
		}

		internal static bool pvr_AchievementUpdate_GetJustUnlocked(AndroidJavaObject popMessage)
		{
			return updateHandle.CallStatic<bool>("pvr_AchievementUpdate_GetJustUnlocked", new object[1] { popMessage });
		}

		internal static string pvr_AchievementUpdate_GetName(AndroidJavaObject popMessage)
		{
			return updateHandle.CallStatic<string>("pvr_AchievementUpdate_GetName", new object[1] { popMessage });
		}

		internal static int pvr_AchievementProgressArray_GetSize(AndroidJavaObject msg)
		{
			return progressArrayHandle.CallStatic<int>("pvr_AchievementProgressArray_GetSize", new object[1] { msg });
		}

		internal static AndroidJavaObject pvr_AchievementProgressArray_GetElement(AndroidJavaObject msg, int index)
		{
			return progressArrayHandle.CallStatic<AndroidJavaObject>("pvr_AchievementProgressArray_GetElement", new object[2] { msg, index });
		}

		internal static string pvr_AchievementProgressArray_GetNextUrl(AndroidJavaObject msg)
		{
			return progressArrayHandle.CallStatic<string>("pvr_AchievementProgressArray_GetNextUrl", new object[1] { msg });
		}

		internal static string pvr_AchievementProgress_GetBitfield(AndroidJavaObject msg)
		{
			return progressHandle.CallStatic<string>("pvr_AchievementProgress_GetBitfield", new object[1] { msg });
		}

		internal static long pvr_AchievementProgress_GetCount(AndroidJavaObject msg)
		{
			return progressHandle.CallStatic<long>("pvr_AchievementProgress_GetCount", new object[1] { msg });
		}

		internal static bool pvr_AchievementProgress_GetIsUnlocked(AndroidJavaObject msg)
		{
			return progressHandle.CallStatic<bool>("pvr_AchievementProgress_GetIsUnlocked", new object[1] { msg });
		}

		internal static string pvr_AchievementProgress_GetName(AndroidJavaObject msg)
		{
			return progressHandle.CallStatic<string>("pvr_AchievementProgress_GetName", new object[1] { msg });
		}

		internal static DateTime pvr_AchievementProgress_GetUnlockTime(AndroidJavaObject msg)
		{
			new DateTime(1970, 1, 1, 0, 0, 0, 0);
			return DateTimeFromNative(progressHandle.CallStatic<long>("pvr_AchievementProgress_GetUnlockTime", new object[1] { msg }));
		}

		internal static DateTime DateTimeFromNative(long seconds_since_the_one_true_epoch)
		{
			return new DateTime(1970, 1, 1, 0, 0, 0, 0).AddSeconds(seconds_since_the_one_true_epoch).ToLocalTime();
		}

		internal static int pvr_AchievementDefinitionArray_GetSize(AndroidJavaObject msg)
		{
			return definitionArrayHandle.CallStatic<int>("pvr_AchievementDefinitionArray_GetSize", new object[1] { msg });
		}

		internal static AndroidJavaObject pvr_AchievementDefinitionArray_GetElement(AndroidJavaObject msg, int index)
		{
			return definitionArrayHandle.CallStatic<AndroidJavaObject>("pvr_AchievementDefinitionArray_GetElement", new object[2] { msg, index });
		}

		internal static string pvr_AchievementDefinitionArray_GetNextUrl(AndroidJavaObject msg)
		{
			return definitionArrayHandle.CallStatic<string>("pvr_AchievementDefinitionArray_GetNextUrl", new object[1] { msg });
		}

		internal static AchievementType pvr_AchievementDefinition_GetType(AndroidJavaObject msg)
		{
			return (AchievementType)definitionHandle.CallStatic<AndroidJavaObject>("pvr_AchievementDefinition_GetType", new object[1] { msg }).Call<int>("getIndex", Array.Empty<object>());
		}

		internal static string pvr_AchievementDefinition_GetName(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetName", new object[1] { msg });
		}

		internal static int pvr_AchievementDefinition_GetBitfieldLength(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<int>("pvr_AchievementDefinition_GetBitfieldLength", new object[1] { msg });
		}

		internal static long pvr_AchievementDefinition_GetTarget(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<long>("pvr_AchievementDefinition_GetTarget", new object[1] { msg });
		}

		internal static string pvr_AchievementDefinition_GetTitle(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetTitle", new object[1] { msg });
		}

		internal static string pvr_AchievementDefinition_GetUnlockedDescription(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetUnlocked_description", new object[1] { msg });
		}

		internal static string pvr_AchievementDefinition_GetLockedIcon(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetLocked_image", new object[1] { msg });
		}

		internal static bool pvr_AchievementDefinition_GetIsSecrect(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<bool>("pvr_AchievementDefinition_GetIs_secret", new object[1] { msg });
		}

		internal static string pvr_AchievementDefinition_GetUnlockedIcon(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetUnlocked_image", new object[1] { msg });
		}

		internal static string pvr_AchievementDefinition_GetDescription(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetDescription", new object[1] { msg });
		}
	}
}
namespace Oculus.Spatializer.Propagation
{
	public enum FaceType : uint
	{
		TRIANGLES,
		QUADS
	}
	public enum MaterialProperty : uint
	{
		ABSORPTION,
		TRANSMISSION,
		SCATTERING
	}
	[StructLayout(LayoutKind.Sequential, Pack = 1)]
	public struct MeshGroup
	{
		public UIntPtr indexOffset;

		public UIntPtr faceCount;

		[MarshalAs(UnmanagedType.U4)]
		public FaceType faceType;

		public IntPtr material;
	}
}
namespace Oculus.Platform
{
	public class AbuseReportOptions
	{
		private IntPtr Handle;

		public AbuseReportOptions()
		{
			Handle = CAPI.ovr_AbuseReportOptions_Create();
		}

		public void SetPreventPeopleChooser(bool value)
		{
			CAPI.ovr_AbuseReportOptions_SetPreventPeopleChooser(Handle, value);
		}

		public void SetReportType(AbuseReportType value)
		{
			CAPI.ovr_AbuseReportOptions_SetReportType(Handle, value);
		}

		public static explicit operator IntPtr(AbuseReportOptions options)
		{
			return options?.Handle ?? IntPtr.Zero;
		}

		~AbuseReportOptions()
		{
			CAPI.ovr_AbuseReportOptions_Destroy(Handle);
		}
	}
	public enum AbuseReportType
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("OBJECT")]
		Object,
		[Description("USER")]
		User
	}
	public enum AchievementType
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("SIMPLE")]
		Simple,
		[Description("BITFIELD")]
		Bitfield,
		[Description("COUNT")]
		Count
	}
	public class AndroidPlatform
	{
		public bool Initialize(string appId)
		{
			if (string.IsNullOrEmpty(appId))
			{
				throw new UnityException("AppID must not be null or empty");
			}
			return CAPI.ovr_UnityInitWrapper(appId);
		}

		public Request<PlatformInitialize> AsyncInitialize(string appId)
		{
			if (string.IsNullOrEmpty(appId))
			{
				throw new UnityException("AppID must not be null or empty");
			}
			return new Request<PlatformInitialize>(CAPI.ovr_UnityInitWrapperAsynchronous(appId));
		}
	}
	public class ApplicationOptions
	{
		private IntPtr Handle;

		public ApplicationOptions()
		{
			Handle = CAPI.ovr_ApplicationOptions_Create();
		}

		public void SetDeeplinkMessage(string value)
		{
			CAPI.ovr_ApplicationOptions_SetDeeplinkMessage(Handle, value);
		}

		public static explicit operator IntPtr(ApplicationOptions options)
		{
			return options?.Handle ?? IntPtr.Zero;
		}

		~ApplicationOptions()
		{
			CAPI.ovr_ApplicationOptions_Destroy(Handle);
		}
	}
	public static class Callback
	{
		private class RequestCallback
		{
			private Message.Callback messageCallback;

			public RequestCallback()
			{
			}

			public RequestCallback(Message.Callback callback)
			{
				messageCallback = callback;
			}

			public virtual void HandleMessage(Message msg)
			{
				if (messageCallback != null)
				{
					messageCallback(msg);
				}
			}
		}

		private sealed class RequestCallback<T> : RequestCallback
		{
			private Message<T>.Callback callback;

			public RequestCallback(Message<T>.Callback callback)
			{
				this.callback = callback;
			}

			public override void HandleMessage(Message msg)
			{
				if (callback != null)
				{
					if (!hasRegisteredRoomInviteNotificationHandler && msg.Type == Message.MessageType.Notification_Room_InviteAccepted)
					{
						pendingRoomInviteNotifications.Add(msg);
					}
					else if (msg is Message<T>)
					{
						callback((Message<T>)msg);
					}
					else
					{
						UnityEngine.Debug.LogError("Unable to handle message: " + msg.GetType());
					}
				}
			}
		}

		private static Dictionary<ulong, Request> requestIDsToRequests = new Dictionary<ulong, Request>();

		private static Dictionary<Message.MessageType, RequestCallback> notificationCallbacks = new Dictionary<Message.MessageType, RequestCallback>();

		private static bool hasRegisteredRoomInviteNotificationHandler = false;

		private static List<Message> pendingRoomInviteNotifications = new List<Message>();

		internal static void SetNotificationCallback<T>(Message.MessageType type, Message<T>.Callback callback)
		{
			if (callback == null)
			{
				throw new Exception("Cannot provide a null notification callback.");
			}
			notificationCallbacks[type] = new RequestCallback<T>(callback);
			if (type == Message.MessageType.Notification_Room_InviteAccepted)
			{
				FlushRoomInviteNotificationQueue();
			}
		}

		internal static void SetNotificationCallback(Message.MessageType type, Message.Callback callback)
		{
			if (callback == null)
			{
				throw new Exception("Cannot provide a null notification callback.");
			}
			notificationCallbacks[type] = new RequestCallback(callback);
		}

		internal static void AddRequest(Request request)
		{
			if (request.RequestID == 0L)
			{
				UnityEngine.Debug.LogError("An unknown error occurred. Request failed.");
			}
			else
			{
				requestIDsToRequests[request.RequestID] = request;
			}
		}

		internal static void RunCallbacks()
		{
			while (true)
			{
				Message message = Message.PopMessage();
				if (message != null)
				{
					HandleMessage(message);
					continue;
				}
				break;
			}
		}

		internal static void RunLimitedCallbacks(uint limit)
		{
			for (int i = 0; i < limit; i++)
			{
				Message message = Message.PopMessage();
				if (message != null)
				{
					HandleMessage(message);
					continue;
				}
				break;
			}
		}

		internal static void OnApplicationQuit()
		{
			requestIDsToRequests.Clear();
			notificationCallbacks.Clear();
		}

		private static void FlushRoomInviteNotificationQueue()
		{
			hasRegisteredRoomInviteNotificationHandler = true;
			foreach (Message pendingRoomInviteNotification in pendingRoomInviteNotifications)
			{
				HandleMessage(pendingRoomInviteNotification);
			}
			pendingRoomInviteNotifications.Clear();
		}

		internal static void HandleMessage(Message msg)
		{
			if (msg.RequestID != 0L && requestIDsToRequests.TryGetValue(msg.RequestID, out var value))
			{
				try
				{
					value.HandleMessage(msg);
					return;
				}
				finally
				{
					requestIDsToRequests.Remove(msg.RequestID);
				}
			}
			if (notificationCallbacks.TryGetValue(msg.Type, out var value2))
			{
				value2.HandleMessage(msg);
			}
		}
	}
	public class CallbackRunner : MonoBehaviour
	{
		public bool IsPersistantBetweenSceneLoads = true;

		[DllImport("ovrplatformloader")]
		private static extern void ovr_UnityResetTestPlatform();

		private void Awake()
		{
			if (UnityEngine.Object.FindObjectOfType<CallbackRunner>() != this)
			{
				UnityEngine.Debug.LogWarning("You only need one instance of CallbackRunner");
			}
			if (IsPersistantBetweenSceneLoads)
			{
				UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
			}
		}

		private void Update()
		{
			Request.RunCallbacks();
		}

		private void OnDestroy()
		{
		}

		private void OnApplicationQuit()
		{
			Callback.OnApplicationQuit();
		}
	}
	public class CAPI
	{
		public struct ovrKeyValuePair
		{
			public string key_;

			private KeyValuePairType valueType_;

			public string stringValue_;

			public int intValue_;

			public double doubleValue_;

			public ovrKeyValuePair(string key, string value)
			{
				key_ = key;
				valueType_ = KeyValuePairType.String;
				stringValue_ = value;
				intValue_ = 0;
				doubleValue_ = 0.0;
			}

			public ovrKeyValuePair(string key, int value)
			{
				key_ = key;
				valueType_ = KeyValuePairType.Int;
				intValue_ = value;
				stringValue_ = null;
				doubleValue_ = 0.0;
			}

			public ovrKeyValuePair(string key, double value)
			{
				key_ = key;
				valueType_ = KeyValuePairType.Double;
				doubleValue_ = value;
				stringValue_ = null;
				intValue_ = 0;
			}
		}

		public struct ovrNetSyncVec3
		{
			public float x;

			public float y;

			public float z;
		}

		public struct ovrMatchmakingCriterion
		{
			public string key_;

			public MatchmakingCriterionImportance importance_;

			public IntPtr parameterArray;

			public uint parameterArrayCount;

			public ovrMatchmakingCriterion(string key, MatchmakingCriterionImportance importance)
			{
				key_ = key;
				importance_ = importance;
				parameterArray = IntPtr.Zero;
				parameterArrayCount = 0u;
			}
		}

		public struct ovrMatchmakingCustomQueryData
		{
			public IntPtr dataArray;

			public uint dataArrayCount;

			public IntPtr criterionArray;

			public uint criterionArrayCount;
		}

		public struct OculusInitParams
		{
			public int sType;

			public string email;

			public string password;

			public ulong appId;

			public string uriPrefixOverride;
		}

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		public delegate void FilterCallback([In][Out][MarshalAs(UnmanagedType.LPArray, SizeConst = 480)] short[] pcmData, UIntPtr pcmDataLength, int frequency, int numChannels);

		public const string DLL_NAME = "ovrplatformloader";

		private static UTF8Encoding nativeStringEncoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);

		public const int VoipFilterBufferSize = 480;

		public static IntPtr ArrayOfStructsToIntPtr(Array ar)
		{
			int num = 0;
			for (int i = 0; i < ar.Length; i++)
			{
				num += Marshal.SizeOf(ar.GetValue(i));
			}
			IntPtr intPtr = Marshal.AllocHGlobal(num);
			IntPtr intPtr2 = intPtr;
			for (int j = 0; j < ar.Length; j++)
			{
				Marshal.StructureToPtr(ar.GetValue(j), intPtr2, fDeleteOld: false);
				intPtr2 = (IntPtr)((long)intPtr2 + Marshal.SizeOf(ar.GetValue(j)));
			}
			return intPtr;
		}

		public static ovrKeyValuePair[] DictionaryToOVRKeyValuePairs(Dictionary<string, object> dict)
		{
			if (dict == null || dict.Count == 0)
			{
				return null;
			}
			ovrKeyValuePair[] array = new ovrKeyValuePair[dict.Count];
			int num = 0;
			foreach (KeyValuePair<string, object> item in dict)
			{
				if (item.Value.GetType() == typeof(int))
				{
					array[num] = new ovrKeyValuePair(item.Key, (int)item.Value);
				}
				else if (item.Value.GetType() == typeof(string))
				{
					array[num] = new ovrKeyValuePair(item.Key, (string)item.Value);
				}
				else
				{
					if (!(item.Value.GetType() == typeof(double)))
					{
						throw new Exception("Only int, double or string are allowed types in CustomQuery.data");
					}
					array[num] = new ovrKeyValuePair(item.Key, (double)item.Value);
				}
				num++;
			}
			return array;
		}

		public static byte[] IntPtrToByteArray(IntPtr data, ulong size)
		{
			byte[] array = new byte[size];
			Marshal.Copy(data, array, 0, (int)size);
			return array;
		}

		public static Dictionary<string, string> DataStoreFromNative(IntPtr pointer)
		{
			Dictionary<string, string> dictionary = new Dictionary<string, string>();
			int num = (int)(uint)ovr_DataStore_GetNumKeys(pointer);
			for (int i = 0; i < num; i++)
			{
				string key = ovr_DataStore_GetKey(pointer, i);
				dictionary[key] = ovr_DataStore_GetValue(pointer, key);
			}
			return dictionary;
		}

		public static string StringFromNative(IntPtr pointer)
		{
			if (pointer == IntPtr.Zero)
			{
				return null;
			}
			int nativeStringLengthNotIncludingNullTerminator = GetNativeStringLengthNotIncludingNullTerminator(pointer);
			byte[] array = new byte[nativeStringLengthNotIncludingNullTerminator];
			Marshal.Copy(pointer, array, 0, nativeStringLengthNotIncludingNullTerminator);
			return nativeStringEncoding.GetString(array);
		}

		public static int GetNativeStringLengthNotIncludingNullTerminator(IntPtr pointer)
		{
			int i;
			for (i = 0; Marshal.ReadByte(pointer, i) != 0; i++)
			{
			}
			return i;
		}

		public static DateTime DateTimeFromNative(ulong seconds_since_the_one_true_epoch)
		{
			return new DateTime(1970, 1, 1, 0, 0, 0, 0).AddSeconds(seconds_since_the_one_true_epoch).ToLocalTime();
		}

		public static ulong DateTimeToNative(DateTime dt)
		{
			DateTime obj = ((dt.Kind != DateTimeKind.Utc) ? dt.ToUniversalTime() : dt);
			DateTime dateTime = new DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc);
			return (ulong)(obj - dateTime).TotalSeconds;
		}

		public static byte[] BlobFromNative(uint size, IntPtr pointer)
		{
			byte[] array = new byte[size];
			for (int i = 0; i < (int)size; i++)
			{
				array[i] = Marshal.ReadByte(pointer, i);
			}
			return array;
		}

		public static byte[] FiledataFromNative(uint size, IntPtr pointer)
		{
			byte[] array = new byte[size];
			Marshal.Copy(pointer, array, 0, (int)size);
			return array;
		}

		public static IntPtr StringToNative(string s)
		{
			if (s == null)
			{
				throw new Exception("StringFromNative: null argument");
			}
			int byteCount = nativeStringEncoding.GetByteCount(s);
			byte[] array = new byte[byteCount + 1];
			nativeStringEncoding.GetBytes(s, 0, s.Length, array, 0);
			IntPtr intPtr = Marshal.AllocCoTaskMem(byteCount + 1);
			Marshal.Copy(array, 0, intPtr, byteCount + 1);
			return intPtr;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_UnityInitWrapper(string appId);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_UnityInitGlobals(IntPtr loggingCB);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_UnityInitWrapperAsynchronous(string appId);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_UnityInitWrapperStandalone(string accessToken, IntPtr loggingCB);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Platform_InitializeStandaloneOculus(ref OculusInitParams init);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_PlatformInitializeWithAccessToken(ulong appId, string accessToken);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_UnityInitWrapperWindows(string appId, IntPtr loggingCB);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_UnityInitWrapperWindowsAsynchronous(string appId, IntPtr loggingCB);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_SetDeveloperAccessToken(string accessToken);

		public static string ovr_GetLoggedInUserLocale()
		{
			return StringFromNative(ovr_GetLoggedInUserLocale_Native());
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_GetLoggedInUserLocale")]
		private static extern IntPtr ovr_GetLoggedInUserLocale_Native();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_PopMessage();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_FreeMessage(IntPtr message);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_NetworkingPeer_GetSendPolicy(IntPtr networkingPeer);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Voip_CreateEncoder();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_DestroyEncoder(IntPtr encoder);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Voip_CreateDecoder();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_DestroyDecoder(IntPtr decoder);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_VoipDecoder_Decode(IntPtr obj, byte[] compressedData, ulong compressedSize);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Microphone_Create();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Microphone_Destroy(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_SetSystemVoipPassthrough(bool passthrough);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_SetSystemVoipMicrophoneMuted(VoipMuteState muted);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_UnityResetTestPlatform();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_HTTP_GetWithMessageType(string url, int messageType);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_CrashApplication();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_SetMicrophoneFilterCallback(FilterCallback cb);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_SetMicrophoneFilterCallbackWithFixedSizeBuffer(FilterCallback cb, UIntPtr bufferSizeElements);

		public static void LogNewEvent(string eventName, Dictionary<string, string> values)
		{
			IntPtr intPtr = StringToNative(eventName);
			int num = values?.Count ?? 0;
			IntPtr[] array = new IntPtr[num * 2];
			if (num > 0)
			{
				int num2 = 0;
				foreach (KeyValuePair<string, string> value in values)
				{
					array[num2 * 2] = StringToNative(value.Key);
					array[num2 * 2 + 1] = StringToNative(value.Value);
					num2++;
				}
			}
			ovr_Log_NewEvent(intPtr, array, (UIntPtr)(ulong)num);
			Marshal.FreeCoTaskMem(intPtr);
			IntPtr[] array2 = array;
			for (int i = 0; i < array2.Length; i++)
			{
				Marshal.FreeCoTaskMem(array2[i]);
			}
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Log_NewEvent(IntPtr eventName, IntPtr[] values, UIntPtr length);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_ApplicationLifecycle_GetLaunchDetails();

		public static ulong ovr_HTTP_StartTransfer(string url, ovrKeyValuePair[] headers)
		{
			IntPtr intPtr = StringToNative(url);
			UIntPtr numItems = (UIntPtr)(ulong)headers.Length;
			ulong result = ovr_HTTP_StartTransfer_Native(intPtr, headers, numItems);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_HTTP_StartTransfer")]
		private static extern ulong ovr_HTTP_StartTransfer_Native(IntPtr url, ovrKeyValuePair[] headers, UIntPtr numItems);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_HTTP_Write(ulong transferId, byte[] bytes, UIntPtr length);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_HTTP_WriteEOM(ulong transferId);

		public static string ovr_Message_GetStringForJavascript(IntPtr message)
		{
			return StringFromNative(ovr_Message_GetStringForJavascript_Native(message));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Message_GetStringForJavascript")]
		private static extern IntPtr ovr_Message_GetStringForJavascript_Native(IntPtr message);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_NetSync_GetAmbisonicFloatPCM(long connection_id, float[] outputBuffer, UIntPtr outputBufferNumElements);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_NetSync_GetAmbisonicInt16PCM(long connection_id, short[] outputBuffer, UIntPtr outputBufferNumElements);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_NetSync_GetAmbisonicInterleavedFloatPCM(long connection_id, float[] outputBuffer, UIntPtr outputBufferNumElements);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_NetSync_GetAmbisonicInterleavedInt16PCM(long connection_id, short[] outputBuffer, UIntPtr outputBufferNumElements);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_NetSync_GetListenerPosition(long connection_id, ulong sessionId, ref ovrNetSyncVec3 position);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_NetSync_GetMonostreamFloatPCM(long connection_id, ulong sessionId, float[] outputBuffer, UIntPtr outputBufferNumElements);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_NetSync_GetMonostreamInt16PCM(long connection_id, ulong session_id, short[] outputBuffer, UIntPtr outputBufferNumElements);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_NetSync_GetPcmBufferMaxSamples();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_NetSync_SetListenerPosition(long connection_id, ovrNetSyncVec3 position);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Net_Accept(ulong peerID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_Net_AcceptForCurrentRoom();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Net_Close(ulong peerID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Net_CloseForCurrentRoom();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Net_Connect(ulong peerID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_Net_IsConnected(ulong peerID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Net_Ping(ulong peerID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Net_ReadPacket();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_Net_SendPacket(ulong userID, UIntPtr length, byte[] bytes, SendPolicy policy);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_Net_SendPacketToCurrentRoom(UIntPtr length, byte[] bytes, SendPolicy policy);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_Party_PluginGetSharedMemHandle();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern VoipMuteState ovr_Party_PluginGetVoipMicrophoneMuted();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_Party_PluginGetVoipPassthrough();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern SystemVoipStatus ovr_Party_PluginGetVoipStatus();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_Accept(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern VoipDtxState ovr_Voip_GetIsConnectionUsingDtx(ulong peerID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern VoipBitrate ovr_Voip_GetLocalBitrate(ulong peerID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Voip_GetOutputBufferMaxSize();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Voip_GetPCM(ulong senderID, short[] outputBuffer, UIntPtr outputBufferNumElements);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Voip_GetPCMFloat(ulong senderID, float[] outputBuffer, UIntPtr outputBufferNumElements);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Voip_GetPCMSize(ulong senderID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Voip_GetPCMWithTimestamp(ulong senderID, short[] outputBuffer, UIntPtr outputBufferNumElements, uint[] timestamp);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Voip_GetPCMWithTimestampFloat(ulong senderID, float[] outputBuffer, UIntPtr outputBufferNumElements, uint[] timestamp);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern VoipBitrate ovr_Voip_GetRemoteBitrate(ulong peerID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_Voip_GetSyncTimestamp(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern long ovr_Voip_GetSyncTimestampDifference(uint lhs, uint rhs);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern VoipMuteState ovr_Voip_GetSystemVoipMicrophoneMuted();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern SystemVoipStatus ovr_Voip_GetSystemVoipStatus();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_SetMicrophoneMuted(VoipMuteState state);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_SetNewConnectionOptions(IntPtr voipOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_SetOutputSampleRate(VoipSampleRate rate);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_Start(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_Stop(ulong userID);

		public static ulong ovr_Achievements_AddCount(string name, ulong count)
		{
			IntPtr intPtr = StringToNative(name);
			ulong result = ovr_Achievements_AddCount_Native(intPtr, count);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Achievements_AddCount")]
		private static extern ulong ovr_Achievements_AddCount_Native(IntPtr name, ulong count);

		public static ulong ovr_Achievements_AddFields(string name, string fields)
		{
			IntPtr intPtr = StringToNative(name);
			IntPtr intPtr2 = StringToNative(fields);
			ulong result = ovr_Achievements_AddFields_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Achievements_AddFields")]
		private static extern ulong ovr_Achievements_AddFields_Native(IntPtr name, IntPtr fields);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Achievements_GetAllDefinitions();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Achievements_GetAllProgress();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Achievements_GetDefinitionsByName(string[] names, int count);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Achievements_GetProgressByName(string[] names, int count);

		public static ulong ovr_Achievements_Unlock(string name)
		{
			IntPtr intPtr = StringToNative(name);
			ulong result = ovr_Achievements_Unlock_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Achievements_Unlock")]
		private static extern ulong ovr_Achievements_Unlock_Native(IntPtr name);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Application_ExecuteCoordinatedLaunch(ulong appID, ulong roomID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Application_GetInstalledApplications();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Application_GetVersion();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Application_LaunchOtherApp(ulong appID, IntPtr deeplink_options);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_ApplicationLifecycle_GetRegisteredPIDs();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_ApplicationLifecycle_GetSessionKey();

		public static ulong ovr_ApplicationLifecycle_RegisterSessionKey(string sessionKey)
		{
			IntPtr intPtr = StringToNative(sessionKey);
			ulong result = ovr_ApplicationLifecycle_RegisterSessionKey_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_ApplicationLifecycle_RegisterSessionKey")]
		private static extern ulong ovr_ApplicationLifecycle_RegisterSessionKey_Native(IntPtr sessionKey);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFile_Delete(ulong assetFileID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFile_DeleteById(ulong assetFileID);

		public static ulong ovr_AssetFile_DeleteByName(string assetFileName)
		{
			IntPtr intPtr = StringToNative(assetFileName);
			ulong result = ovr_AssetFile_DeleteByName_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetFile_DeleteByName")]
		private static extern ulong ovr_AssetFile_DeleteByName_Native(IntPtr assetFileName);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFile_Download(ulong assetFileID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFile_DownloadById(ulong assetFileID);

		public static ulong ovr_AssetFile_DownloadByName(string assetFileName)
		{
			IntPtr intPtr = StringToNative(assetFileName);
			ulong result = ovr_AssetFile_DownloadByName_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetFile_DownloadByName")]
		private static extern ulong ovr_AssetFile_DownloadByName_Native(IntPtr assetFileName);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFile_DownloadCancel(ulong assetFileID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFile_DownloadCancelById(ulong assetFileID);

		public static ulong ovr_AssetFile_DownloadCancelByName(string assetFileName)
		{
			IntPtr intPtr = StringToNative(assetFileName);
			ulong result = ovr_AssetFile_DownloadCancelByName_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetFile_DownloadCancelByName")]
		private static extern ulong ovr_AssetFile_DownloadCancelByName_Native(IntPtr assetFileName);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFile_GetList();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFile_Status(ulong assetFileID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFile_StatusById(ulong assetFileID);

		public static ulong ovr_AssetFile_StatusByName(string assetFileName)
		{
			IntPtr intPtr = StringToNative(assetFileName);
			ulong result = ovr_AssetFile_StatusByName_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetFile_StatusByName")]
		private static extern ulong ovr_AssetFile_StatusByName_Native(IntPtr assetFileName);

		public static ulong ovr_Avatar_UpdateMetaData(string avatarMetaData, string imageFilePath)
		{
			IntPtr intPtr = StringToNative(avatarMetaData);
			IntPtr intPtr2 = StringToNative(imageFilePath);
			ulong result = ovr_Avatar_UpdateMetaData_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Avatar_UpdateMetaData")]
		private static extern ulong ovr_Avatar_UpdateMetaData_Native(IntPtr avatarMetaData, IntPtr imageFilePath);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Cal_FinalizeApplication(ulong groupingObject, ulong[] userIDs, int numUserIDs, ulong finalized_application_ID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Cal_GetSuggestedApplications(ulong groupingObject, ulong[] userIDs, int numUserIDs);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Cal_ProposeApplication(ulong groupingObject, ulong[] userIDs, int numUserIDs, ulong proposed_application_ID);

		public static ulong ovr_CloudStorage_Delete(string bucket, string key)
		{
			IntPtr intPtr = StringToNative(bucket);
			IntPtr intPtr2 = StringToNative(key);
			ulong result = ovr_CloudStorage_Delete_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_Delete")]
		private static extern ulong ovr_CloudStorage_Delete_Native(IntPtr bucket, IntPtr key);

		public static ulong ovr_CloudStorage_Load(string bucket, string key)
		{
			IntPtr intPtr = StringToNative(bucket);
			IntPtr intPtr2 = StringToNative(key);
			ulong result = ovr_CloudStorage_Load_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_Load")]
		private static extern ulong ovr_CloudStorage_Load_Native(IntPtr bucket, IntPtr key);

		public static ulong ovr_CloudStorage_LoadBucketMetadata(string bucket)
		{
			IntPtr intPtr = StringToNative(bucket);
			ulong result = ovr_CloudStorage_LoadBucketMetadata_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_LoadBucketMetadata")]
		private static extern ulong ovr_CloudStorage_LoadBucketMetadata_Native(IntPtr bucket);

		public static ulong ovr_CloudStorage_LoadConflictMetadata(string bucket, string key)
		{
			IntPtr intPtr = StringToNative(bucket);
			IntPtr intPtr2 = StringToNative(key);
			ulong result = ovr_CloudStorage_LoadConflictMetadata_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_LoadConflictMetadata")]
		private static extern ulong ovr_CloudStorage_LoadConflictMetadata_Native(IntPtr bucket, IntPtr key);

		public static ulong ovr_CloudStorage_LoadHandle(string handle)
		{
			IntPtr intPtr = StringToNative(handle);
			ulong result = ovr_CloudStorage_LoadHandle_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_LoadHandle")]
		private static extern ulong ovr_CloudStorage_LoadHandle_Native(IntPtr handle);

		public static ulong ovr_CloudStorage_LoadMetadata(string bucket, string key)
		{
			IntPtr intPtr = StringToNative(bucket);
			IntPtr intPtr2 = StringToNative(key);
			ulong result = ovr_CloudStorage_LoadMetadata_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_LoadMetadata")]
		private static extern ulong ovr_CloudStorage_LoadMetadata_Native(IntPtr bucket, IntPtr key);

		public static ulong ovr_CloudStorage_ResolveKeepLocal(string bucket, string key, string remoteHandle)
		{
			IntPtr intPtr = StringToNative(bucket);
			IntPtr intPtr2 = StringToNative(key);
			IntPtr intPtr3 = StringToNative(remoteHandle);
			ulong result = ovr_CloudStorage_ResolveKeepLocal_Native(intPtr, intPtr2, intPtr3);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			Marshal.FreeCoTaskMem(intPtr3);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_ResolveKeepLocal")]
		private static extern ulong ovr_CloudStorage_ResolveKeepLocal_Native(IntPtr bucket, IntPtr key, IntPtr remoteHandle);

		public static ulong ovr_CloudStorage_ResolveKeepRemote(string bucket, string key, string remoteHandle)
		{
			IntPtr intPtr = StringToNative(bucket);
			IntPtr intPtr2 = StringToNative(key);
			IntPtr intPtr3 = StringToNative(remoteHandle);
			ulong result = ovr_CloudStorage_ResolveKeepRemote_Native(intPtr, intPtr2, intPtr3);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			Marshal.FreeCoTaskMem(intPtr3);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_ResolveKeepRemote")]
		private static extern ulong ovr_CloudStorage_ResolveKeepRemote_Native(IntPtr bucket, IntPtr key, IntPtr remoteHandle);

		public static ulong ovr_CloudStorage_Save(string bucket, string key, byte[] data, uint dataSize, long counter, string extraData)
		{
			IntPtr intPtr = StringToNative(bucket);
			IntPtr intPtr2 = StringToNative(key);
			IntPtr intPtr3 = StringToNative(extraData);
			ulong result = ovr_CloudStorage_Save_Native(intPtr, intPtr2, data, dataSize, counter, intPtr3);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			Marshal.FreeCoTaskMem(intPtr3);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_Save")]
		private static extern ulong ovr_CloudStorage_Save_Native(IntPtr bucket, IntPtr key, byte[] data, uint dataSize, long counter, IntPtr extraData);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_CloudStorage2_GetUserDirectoryPath();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Colocation_GetCurrentMapUuid();

		public static ulong ovr_Colocation_RequestMap(string uuid)
		{
			IntPtr intPtr = StringToNative(uuid);
			ulong result = ovr_Colocation_RequestMap_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Colocation_RequestMap")]
		private static extern ulong ovr_Colocation_RequestMap_Native(IntPtr uuid);

		public static ulong ovr_Colocation_ShareMap(string uuid)
		{
			IntPtr intPtr = StringToNative(uuid);
			ulong result = ovr_Colocation_ShareMap_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Colocation_ShareMap")]
		private static extern ulong ovr_Colocation_ShareMap_Native(IntPtr uuid);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Entitlement_GetIsViewerEntitled();

		public static ulong ovr_GraphAPI_Get(string url)
		{
			IntPtr intPtr = StringToNative(url);
			ulong result = ovr_GraphAPI_Get_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_GraphAPI_Get")]
		private static extern ulong ovr_GraphAPI_Get_Native(IntPtr url);

		public static ulong ovr_GraphAPI_Post(string url)
		{
			IntPtr intPtr = StringToNative(url);
			ulong result = ovr_GraphAPI_Post_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_GraphAPI_Post")]
		private static extern ulong ovr_GraphAPI_Post_Native(IntPtr url);

		public static ulong ovr_HTTP_Get(string url)
		{
			IntPtr intPtr = StringToNative(url);
			ulong result = ovr_HTTP_Get_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_HTTP_Get")]
		private static extern ulong ovr_HTTP_Get_Native(IntPtr url);

		public static ulong ovr_HTTP_GetToFile(string url, string diskFile)
		{
			IntPtr intPtr = StringToNative(url);
			IntPtr intPtr2 = StringToNative(diskFile);
			ulong result = ovr_HTTP_GetToFile_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_HTTP_GetToFile")]
		private static extern ulong ovr_HTTP_GetToFile_Native(IntPtr url, IntPtr diskFile);

		public static ulong ovr_HTTP_MultiPartPost(string url, string filepath_param_name, string filepath, string access_token, ovrKeyValuePair[] post_params)
		{
			IntPtr intPtr = StringToNative(url);
			IntPtr intPtr2 = StringToNative(filepath_param_name);
			IntPtr intPtr3 = StringToNative(filepath);
			IntPtr intPtr4 = StringToNative(access_token);
			UIntPtr numItems = (UIntPtr)(ulong)post_params.Length;
			ulong result = ovr_HTTP_MultiPartPost_Native(intPtr, intPtr2, intPtr3, intPtr4, post_params, numItems);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			Marshal.FreeCoTaskMem(intPtr3);
			Marshal.FreeCoTaskMem(intPtr4);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_HTTP_MultiPartPost")]
		private static extern ulong ovr_HTTP_MultiPartPost_Native(IntPtr url, IntPtr filepath_param_name, IntPtr filepath, IntPtr access_token, ovrKeyValuePair[] post_params, UIntPtr numItems);

		public static ulong ovr_HTTP_Post(string url)
		{
			IntPtr intPtr = StringToNative(url);
			ulong result = ovr_HTTP_Post_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_HTTP_Post")]
		private static extern ulong ovr_HTTP_Post_Native(IntPtr url);

		public static ulong ovr_IAP_ConsumePurchase(string sku)
		{
			IntPtr intPtr = StringToNative(sku);
			ulong result = ovr_IAP_ConsumePurchase_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_IAP_ConsumePurchase")]
		private static extern ulong ovr_IAP_ConsumePurchase_Native(IntPtr sku);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_IAP_GetProductsBySKU(string[] skus, int count);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_IAP_GetViewerPurchases();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_IAP_GetViewerPurchasesDurableCache();

		public static ulong ovr_IAP_LaunchCheckoutFlow(string sku)
		{
			IntPtr intPtr = StringToNative(sku);
			ulong result = ovr_IAP_LaunchCheckoutFlow_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_IAP_LaunchCheckoutFlow")]
		private static extern ulong ovr_IAP_LaunchCheckoutFlow_Native(IntPtr sku);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_LanguagePack_GetCurrent();

		public static ulong ovr_LanguagePack_SetCurrent(string tag)
		{
			IntPtr intPtr = StringToNative(tag);
			ulong result = ovr_LanguagePack_SetCurrent_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LanguagePack_SetCurrent")]
		private static extern ulong ovr_LanguagePack_SetCurrent_Native(IntPtr tag);

		public static ulong ovr_Leaderboard_GetEntries(string leaderboardName, int limit, LeaderboardFilterType filter, LeaderboardStartAt startAt)
		{
			IntPtr intPtr = StringToNative(leaderboardName);
			ulong result = ovr_Leaderboard_GetEntries_Native(intPtr, limit, filter, startAt);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Leaderboard_GetEntries")]
		private static extern ulong ovr_Leaderboard_GetEntries_Native(IntPtr leaderboardName, int limit, LeaderboardFilterType filter, LeaderboardStartAt startAt);

		public static ulong ovr_Leaderboard_GetEntriesAfterRank(string leaderboardName, int limit, ulong afterRank)
		{
			IntPtr intPtr = StringToNative(leaderboardName);
			ulong result = ovr_Leaderboard_GetEntriesAfterRank_Native(intPtr, limit, afterRank);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Leaderboard_GetEntriesAfterRank")]
		private static extern ulong ovr_Leaderboard_GetEntriesAfterRank_Native(IntPtr leaderboardName, int limit, ulong afterRank);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Leaderboard_GetNextEntries(IntPtr handle);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Leaderboard_GetPreviousEntries(IntPtr handle);

		public static ulong ovr_Leaderboard_WriteEntry(string leaderboardName, long score, byte[] extraData, uint extraDataLength, bool forceUpdate)
		{
			IntPtr intPtr = StringToNative(leaderboardName);
			ulong result = ovr_Leaderboard_WriteEntry_Native(intPtr, score, extraData, extraDataLength, forceUpdate);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Leaderboard_WriteEntry")]
		private static extern ulong ovr_Leaderboard_WriteEntry_Native(IntPtr leaderboardName, long score, byte[] extraData, uint extraDataLength, bool forceUpdate);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Livestreaming_GetStatus();

		public static ulong ovr_Livestreaming_IsAllowedForApplication(string packageName)
		{
			IntPtr intPtr = StringToNative(packageName);
			ulong result = ovr_Livestreaming_IsAllowedForApplication_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Livestreaming_IsAllowedForApplication")]
		private static extern ulong ovr_Livestreaming_IsAllowedForApplication_Native(IntPtr packageName);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Livestreaming_PauseStream();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Livestreaming_ResumeStream();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Livestreaming_StartPartyStream();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Livestreaming_StartStream(LivestreamingAudience audience, LivestreamingMicrophoneStatus micStatus);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Livestreaming_StopPartyStream();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Livestreaming_StopStream();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Livestreaming_UpdateCommentsOverlayVisibility(bool isVisible);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Livestreaming_UpdateMicStatus(LivestreamingMicrophoneStatus micStatus);

		public static ulong ovr_Matchmaking_Browse(string pool, IntPtr customQueryData)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_Browse_Native(intPtr, customQueryData);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_Browse")]
		private static extern ulong ovr_Matchmaking_Browse_Native(IntPtr pool, IntPtr customQueryData);

		public static ulong ovr_Matchmaking_Browse2(string pool, IntPtr matchmakingOptions)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_Browse2_Native(intPtr, matchmakingOptions);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_Browse2")]
		private static extern ulong ovr_Matchmaking_Browse2_Native(IntPtr pool, IntPtr matchmakingOptions);

		public static ulong ovr_Matchmaking_Cancel(string pool, string requestHash)
		{
			IntPtr intPtr = StringToNative(pool);
			IntPtr intPtr2 = StringToNative(requestHash);
			ulong result = ovr_Matchmaking_Cancel_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_Cancel")]
		private static extern ulong ovr_Matchmaking_Cancel_Native(IntPtr pool, IntPtr requestHash);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Matchmaking_Cancel2();

		public static ulong ovr_Matchmaking_CreateAndEnqueueRoom(string pool, uint maxUsers, bool subscribeToUpdates, IntPtr customQueryData)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_CreateAndEnqueueRoom_Native(intPtr, maxUsers, subscribeToUpdates, customQueryData);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_CreateAndEnqueueRoom")]
		private static extern ulong ovr_Matchmaking_CreateAndEnqueueRoom_Native(IntPtr pool, uint maxUsers, bool subscribeToUpdates, IntPtr customQueryData);

		public static ulong ovr_Matchmaking_CreateAndEnqueueRoom2(string pool, IntPtr matchmakingOptions)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_CreateAndEnqueueRoom2_Native(intPtr, matchmakingOptions);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_CreateAndEnqueueRoom2")]
		private static extern ulong ovr_Matchmaking_CreateAndEnqueueRoom2_Native(IntPtr pool, IntPtr matchmakingOptions);

		public static ulong ovr_Matchmaking_CreateRoom(string pool, uint maxUsers, bool subscribeToUpdates)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_CreateRoom_Native(intPtr, maxUsers, subscribeToUpdates);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_CreateRoom")]
		private static extern ulong ovr_Matchmaking_CreateRoom_Native(IntPtr pool, uint maxUsers, bool subscribeToUpdates);

		public static ulong ovr_Matchmaking_CreateRoom2(string pool, IntPtr matchmakingOptions)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_CreateRoom2_Native(intPtr, matchmakingOptions);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_CreateRoom2")]
		private static extern ulong ovr_Matchmaking_CreateRoom2_Native(IntPtr pool, IntPtr matchmakingOptions);

		public static ulong ovr_Matchmaking_Enqueue(string pool, IntPtr customQueryData)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_Enqueue_Native(intPtr, customQueryData);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_Enqueue")]
		private static extern ulong ovr_Matchmaking_Enqueue_Native(IntPtr pool, IntPtr customQueryData);

		public static ulong ovr_Matchmaking_Enqueue2(string pool, IntPtr matchmakingOptions)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_Enqueue2_Native(intPtr, matchmakingOptions);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_Enqueue2")]
		private static extern ulong ovr_Matchmaking_Enqueue2_Native(IntPtr pool, IntPtr matchmakingOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Matchmaking_EnqueueRoom(ulong roomID, IntPtr customQueryData);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Matchmaking_EnqueueRoom2(ulong roomID, IntPtr matchmakingOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Matchmaking_GetAdminSnapshot();

		public static ulong ovr_Matchmaking_GetStats(string pool, uint maxLevel, MatchmakingStatApproach approach)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_GetStats_Native(intPtr, maxLevel, approach);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_GetStats")]
		private static extern ulong ovr_Matchmaking_GetStats_Native(IntPtr pool, uint maxLevel, MatchmakingStatApproach approach);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Matchmaking_JoinRoom(ulong roomID, bool subscribeToUpdates);

		public static ulong ovr_Matchmaking_ReportResultInsecure(ulong roomID, ovrKeyValuePair[] data)
		{
			UIntPtr numItems = (UIntPtr)(ulong)data.Length;
			return ovr_Matchmaking_ReportResultInsecure_Native(roomID, data, numItems);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_ReportResultInsecure")]
		private static extern ulong ovr_Matchmaking_ReportResultInsecure_Native(ulong roomID, ovrKeyValuePair[] data, UIntPtr numItems);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Matchmaking_StartMatch(ulong roomID);

		public static ulong ovr_Media_ShareToFacebook(string postTextSuggestion, string filePath, MediaContentType contentType)
		{
			IntPtr intPtr = StringToNative(postTextSuggestion);
			IntPtr intPtr2 = StringToNative(filePath);
			ulong result = ovr_Media_ShareToFacebook_Native(intPtr, intPtr2, contentType);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Media_ShareToFacebook")]
		private static extern ulong ovr_Media_ShareToFacebook_Native(IntPtr postTextSuggestion, IntPtr filePath, MediaContentType contentType);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_NetSync_Connect(IntPtr connect_options);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_NetSync_Disconnect(long connection_id);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_NetSync_GetSessions(long connection_id);

		public static ulong ovr_NetSync_SetVoipGroup(long connection_id, string group_id)
		{
			IntPtr intPtr = StringToNative(group_id);
			ulong result = ovr_NetSync_SetVoipGroup_Native(connection_id, intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_NetSync_SetVoipGroup")]
		private static extern ulong ovr_NetSync_SetVoipGroup_Native(long connection_id, IntPtr group_id);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_NetSync_SetVoipMicSource(long connection_id, NetSyncVoipMicSource mic_source);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_NetSync_SetVoipSessionMuted(long connection_id, ulong session_id, bool muted);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_NetSync_SetVoipStreamMode(long connection_id, ulong sessionId, NetSyncVoipStreamMode streamMode);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Notification_GetRoomInvites();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Notification_MarkAsRead(ulong notificationID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_Create();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_GatherInApplication(ulong partyID, ulong appID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_Get(ulong partyID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_GetCurrent();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_GetCurrentForUser(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_Invite(ulong partyID, ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_Join(ulong partyID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_Leave(ulong partyID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_RichPresence_Clear();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_RichPresence_GetDestinations();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_RichPresence_Set(IntPtr richPresenceOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_CreateAndJoinPrivate(RoomJoinPolicy joinPolicy, uint maxUsers, bool subscribeToUpdates);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_CreateAndJoinPrivate2(RoomJoinPolicy joinPolicy, uint maxUsers, IntPtr roomOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_Get(ulong roomID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetCurrent();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetCurrentForUser(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetInvitableUsers();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetInvitableUsers2(IntPtr roomOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetModeratedRooms();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetSocialRooms(ulong appID);

		public static ulong ovr_Room_InviteUser(ulong roomID, string inviteToken)
		{
			IntPtr intPtr = StringToNative(inviteToken);
			ulong result = ovr_Room_InviteUser_Native(roomID, intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Room_InviteUser")]
		private static extern ulong ovr_Room_InviteUser_Native(ulong roomID, IntPtr inviteToken);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_Join(ulong roomID, bool subscribeToUpdates);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_Join2(ulong roomID, IntPtr roomOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_KickUser(ulong roomID, ulong userID, int kickDurationSeconds);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_LaunchInvitableUserFlow(ulong roomID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_Leave(ulong roomID);

		public static ulong ovr_Room_SetDescription(ulong roomID, string description)
		{
			IntPtr intPtr = StringToNative(description);
			ulong result = ovr_Room_SetDescription_Native(roomID, intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Room_SetDescription")]
		private static extern ulong ovr_Room_SetDescription_Native(ulong roomID, IntPtr description);

		public static ulong ovr_Room_UpdateDataStore(ulong roomID, ovrKeyValuePair[] data)
		{
			UIntPtr numItems = (UIntPtr)(ulong)data.Length;
			return ovr_Room_UpdateDataStore_Native(roomID, data, numItems);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Room_UpdateDataStore")]
		private static extern ulong ovr_Room_UpdateDataStore_Native(ulong roomID, ovrKeyValuePair[] data, UIntPtr numItems);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_UpdateMembershipLockStatus(ulong roomID, RoomMembershipLockStatus membershipLockStatus);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_UpdateOwner(ulong roomID, ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_UpdatePrivateRoomJoinPolicy(ulong roomID, RoomJoinPolicy newJoinPolicy);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_SystemPermissions_GetStatus(PermissionType permType);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_SystemPermissions_LaunchDeeplink(PermissionType permType);

		public static ulong ovr_User_CancelRecordingForReportFlow(string recordingUUID)
		{
			IntPtr intPtr = StringToNative(recordingUUID);
			ulong result = ovr_User_CancelRecordingForReportFlow_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_CancelRecordingForReportFlow")]
		private static extern ulong ovr_User_CancelRecordingForReportFlow_Native(IntPtr recordingUUID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_Get(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetAccessToken();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetLinkedAccounts(IntPtr userOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetLoggedInUser();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetLoggedInUserFriends();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetLoggedInUserFriendsAndRooms();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetLoggedInUserRecentlyMetUsersAndRooms(IntPtr userOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetOrgScopedID(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetSdkAccounts();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetUserProof();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_LaunchBlockFlow(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_LaunchFriendRequestFlow(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_LaunchProfile(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_LaunchReportFlow(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_LaunchReportFlow2(ulong optionalUserID, IntPtr abuseReportOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_LaunchUnblockFlow(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_NewEntitledTestUser();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_NewTestUser();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_NewTestUserFriends();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_StartRecordingForReportFlow();

		public static ulong ovr_User_StopRecordingAndLaunchReportFlow(ulong optionalUserID, string optionalRecordingUUID)
		{
			IntPtr intPtr = StringToNative(optionalRecordingUUID);
			ulong result = ovr_User_StopRecordingAndLaunchReportFlow_Native(optionalUserID, intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_StopRecordingAndLaunchReportFlow")]
		private static extern ulong ovr_User_StopRecordingAndLaunchReportFlow_Native(ulong optionalUserID, IntPtr optionalRecordingUUID);

		public static ulong ovr_User_StopRecordingAndLaunchReportFlow2(ulong optionalUserID, string optionalRecordingUUID, IntPtr abuseReportOptions)
		{
			IntPtr intPtr = StringToNative(optionalRecordingUUID);
			ulong result = ovr_User_StopRecordingAndLaunchReportFlow2_Native(optionalUserID, intPtr, abuseReportOptions);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_StopRecordingAndLaunchReportFlow2")]
		private static extern ulong ovr_User_StopRecordingAndLaunchReportFlow2_Native(ulong optionalUserID, IntPtr optionalRecordingUUID, IntPtr abuseReportOptions);

		public static ulong ovr_User_TestUserCreateDeviceManifest(string deviceID, ulong[] appIDs, int numAppIDs)
		{
			IntPtr intPtr = StringToNative(deviceID);
			ulong result = ovr_User_TestUserCreateDeviceManifest_Native(intPtr, appIDs, numAppIDs);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_TestUserCreateDeviceManifest")]
		private static extern ulong ovr_User_TestUserCreateDeviceManifest_Native(IntPtr deviceID, ulong[] appIDs, int numAppIDs);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Voip_SetSystemVoipSuppressed(bool suppressed);

		public static string ovr_AbuseReportRecording_GetRecordingUuid(IntPtr obj)
		{
			return StringFromNative(ovr_AbuseReportRecording_GetRecordingUuid_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AbuseReportRecording_GetRecordingUuid")]
		private static extern IntPtr ovr_AbuseReportRecording_GetRecordingUuid_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_AchievementDefinition_GetBitfieldLength(IntPtr obj);

		public static string ovr_AchievementDefinition_GetName(IntPtr obj)
		{
			return StringFromNative(ovr_AchievementDefinition_GetName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AchievementDefinition_GetName")]
		private static extern IntPtr ovr_AchievementDefinition_GetName_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AchievementDefinition_GetTarget(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern AchievementType ovr_AchievementDefinition_GetType(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_AchievementDefinitionArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_AchievementDefinitionArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_AchievementDefinitionArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AchievementDefinitionArray_GetNextUrl")]
		private static extern IntPtr ovr_AchievementDefinitionArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_AchievementDefinitionArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_AchievementDefinitionArray_HasNextPage(IntPtr obj);

		public static string ovr_AchievementProgress_GetBitfield(IntPtr obj)
		{
			return StringFromNative(ovr_AchievementProgress_GetBitfield_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AchievementProgress_GetBitfield")]
		private static extern IntPtr ovr_AchievementProgress_GetBitfield_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AchievementProgress_GetCount(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_AchievementProgress_GetIsUnlocked(IntPtr obj);

		public static string ovr_AchievementProgress_GetName(IntPtr obj)
		{
			return StringFromNative(ovr_AchievementProgress_GetName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AchievementProgress_GetName")]
		private static extern IntPtr ovr_AchievementProgress_GetName_Native(IntPtr obj);

		public static DateTime ovr_AchievementProgress_GetUnlockTime(IntPtr obj)
		{
			return DateTimeFromNative(ovr_AchievementProgress_GetUnlockTime_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AchievementProgress_GetUnlockTime")]
		private static extern ulong ovr_AchievementProgress_GetUnlockTime_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_AchievementProgressArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_AchievementProgressArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_AchievementProgressArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AchievementProgressArray_GetNextUrl")]
		private static extern IntPtr ovr_AchievementProgressArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_AchievementProgressArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_AchievementProgressArray_HasNextPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_AchievementUpdate_GetJustUnlocked(IntPtr obj);

		public static string ovr_AchievementUpdate_GetName(IntPtr obj)
		{
			return StringFromNative(ovr_AchievementUpdate_GetName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AchievementUpdate_GetName")]
		private static extern IntPtr ovr_AchievementUpdate_GetName_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Application_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_ApplicationVersion_GetCurrentCode(IntPtr obj);

		public static string ovr_ApplicationVersion_GetCurrentName(IntPtr obj)
		{
			return StringFromNative(ovr_ApplicationVersion_GetCurrentName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_ApplicationVersion_GetCurrentName")]
		private static extern IntPtr ovr_ApplicationVersion_GetCurrentName_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_ApplicationVersion_GetLatestCode(IntPtr obj);

		public static string ovr_ApplicationVersion_GetLatestName(IntPtr obj)
		{
			return StringFromNative(ovr_ApplicationVersion_GetLatestName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_ApplicationVersion_GetLatestName")]
		private static extern IntPtr ovr_ApplicationVersion_GetLatestName_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetDetails_GetAssetId(IntPtr obj);

		public static string ovr_AssetDetails_GetAssetType(IntPtr obj)
		{
			return StringFromNative(ovr_AssetDetails_GetAssetType_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetDetails_GetAssetType")]
		private static extern IntPtr ovr_AssetDetails_GetAssetType_Native(IntPtr obj);

		public static string ovr_AssetDetails_GetDownloadStatus(IntPtr obj)
		{
			return StringFromNative(ovr_AssetDetails_GetDownloadStatus_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetDetails_GetDownloadStatus")]
		private static extern IntPtr ovr_AssetDetails_GetDownloadStatus_Native(IntPtr obj);

		public static string ovr_AssetDetails_GetFilepath(IntPtr obj)
		{
			return StringFromNative(ovr_AssetDetails_GetFilepath_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetDetails_GetFilepath")]
		private static extern IntPtr ovr_AssetDetails_GetFilepath_Native(IntPtr obj);

		public static string ovr_AssetDetails_GetIapStatus(IntPtr obj)
		{
			return StringFromNative(ovr_AssetDetails_GetIapStatus_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetDetails_GetIapStatus")]
		private static extern IntPtr ovr_AssetDetails_GetIapStatus_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_AssetDetails_GetLanguage(IntPtr obj);

		public static string ovr_AssetDetails_GetMetadata(IntPtr obj)
		{
			return StringFromNative(ovr_AssetDetails_GetMetadata_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetDetails_GetMetadata")]
		private static extern IntPtr ovr_AssetDetails_GetMetadata_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_AssetDetailsArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_AssetDetailsArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFileDeleteResult_GetAssetFileId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFileDeleteResult_GetAssetId(IntPtr obj);

		public static string ovr_AssetFileDeleteResult_GetFilepath(IntPtr obj)
		{
			return StringFromNative(ovr_AssetFileDeleteResult_GetFilepath_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetFileDeleteResult_GetFilepath")]
		private static extern IntPtr ovr_AssetFileDeleteResult_GetFilepath_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_AssetFileDeleteResult_GetSuccess(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFileDownloadCancelResult_GetAssetFileId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFileDownloadCancelResult_GetAssetId(IntPtr obj);

		public static string ovr_AssetFileDownloadCancelResult_GetFilepath(IntPtr obj)
		{
			return StringFromNative(ovr_AssetFileDownloadCancelResult_GetFilepath_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetFileDownloadCancelResult_GetFilepath")]
		private static extern IntPtr ovr_AssetFileDownloadCancelResult_GetFilepath_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_AssetFileDownloadCancelResult_GetSuccess(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFileDownloadResult_GetAssetId(IntPtr obj);

		public static string ovr_AssetFileDownloadResult_GetFilepath(IntPtr obj)
		{
			return StringFromNative(ovr_AssetFileDownloadResult_GetFilepath_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetFileDownloadResult_GetFilepath")]
		private static extern IntPtr ovr_AssetFileDownloadResult_GetFilepath_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFileDownloadUpdate_GetAssetFileId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFileDownloadUpdate_GetAssetId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_AssetFileDownloadUpdate_GetBytesTotal(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_AssetFileDownloadUpdate_GetBytesTransferred(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_AssetFileDownloadUpdate_GetCompleted(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_CalApplicationFinalized_GetCountdownMS(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_CalApplicationFinalized_GetID(IntPtr obj);

		public static string ovr_CalApplicationFinalized_GetLaunchDetails(IntPtr obj)
		{
			return StringFromNative(ovr_CalApplicationFinalized_GetLaunchDetails_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CalApplicationFinalized_GetLaunchDetails")]
		private static extern IntPtr ovr_CalApplicationFinalized_GetLaunchDetails_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_CalApplicationProposed_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_CalApplicationSuggestion_GetID(IntPtr obj);

		public static string ovr_CalApplicationSuggestion_GetSocialContext(IntPtr obj)
		{
			return StringFromNative(ovr_CalApplicationSuggestion_GetSocialContext_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CalApplicationSuggestion_GetSocialContext")]
		private static extern IntPtr ovr_CalApplicationSuggestion_GetSocialContext_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_CalApplicationSuggestionArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_CalApplicationSuggestionArray_GetSize(IntPtr obj);

		public static string ovr_CloudStorage2UserDirectoryPathResponse_GetPath(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorage2UserDirectoryPathResponse_GetPath_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage2UserDirectoryPathResponse_GetPath")]
		private static extern IntPtr ovr_CloudStorage2UserDirectoryPathResponse_GetPath_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_CloudStorageConflictMetadata_GetLocal(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_CloudStorageConflictMetadata_GetRemote(IntPtr obj);

		public static string ovr_CloudStorageData_GetBucket(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageData_GetBucket_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageData_GetBucket")]
		private static extern IntPtr ovr_CloudStorageData_GetBucket_Native(IntPtr obj);

		public static byte[] ovr_CloudStorageData_GetData(IntPtr obj)
		{
			return FiledataFromNative(ovr_CloudStorageData_GetDataSize(obj), ovr_CloudStorageData_GetData_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageData_GetData")]
		private static extern IntPtr ovr_CloudStorageData_GetData_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_CloudStorageData_GetDataSize(IntPtr obj);

		public static string ovr_CloudStorageData_GetKey(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageData_GetKey_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageData_GetKey")]
		private static extern IntPtr ovr_CloudStorageData_GetKey_Native(IntPtr obj);

		public static string ovr_CloudStorageMetadata_GetBucket(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageMetadata_GetBucket_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageMetadata_GetBucket")]
		private static extern IntPtr ovr_CloudStorageMetadata_GetBucket_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern long ovr_CloudStorageMetadata_GetCounter(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_CloudStorageMetadata_GetDataSize(IntPtr obj);

		public static string ovr_CloudStorageMetadata_GetExtraData(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageMetadata_GetExtraData_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageMetadata_GetExtraData")]
		private static extern IntPtr ovr_CloudStorageMetadata_GetExtraData_Native(IntPtr obj);

		public static string ovr_CloudStorageMetadata_GetKey(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageMetadata_GetKey_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageMetadata_GetKey")]
		private static extern IntPtr ovr_CloudStorageMetadata_GetKey_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_CloudStorageMetadata_GetSaveTime(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern CloudStorageDataStatus ovr_CloudStorageMetadata_GetStatus(IntPtr obj);

		public static string ovr_CloudStorageMetadata_GetVersionHandle(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageMetadata_GetVersionHandle_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageMetadata_GetVersionHandle")]
		private static extern IntPtr ovr_CloudStorageMetadata_GetVersionHandle_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_CloudStorageMetadataArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_CloudStorageMetadataArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageMetadataArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageMetadataArray_GetNextUrl")]
		private static extern IntPtr ovr_CloudStorageMetadataArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_CloudStorageMetadataArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_CloudStorageMetadataArray_HasNextPage(IntPtr obj);

		public static string ovr_CloudStorageUpdateResponse_GetBucket(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageUpdateResponse_GetBucket_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageUpdateResponse_GetBucket")]
		private static extern IntPtr ovr_CloudStorageUpdateResponse_GetBucket_Native(IntPtr obj);

		public static string ovr_CloudStorageUpdateResponse_GetKey(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageUpdateResponse_GetKey_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageUpdateResponse_GetKey")]
		private static extern IntPtr ovr_CloudStorageUpdateResponse_GetKey_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern CloudStorageUpdateStatus ovr_CloudStorageUpdateResponse_GetStatus(IntPtr obj);

		public static string ovr_CloudStorageUpdateResponse_GetVersionHandle(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageUpdateResponse_GetVersionHandle_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageUpdateResponse_GetVersionHandle")]
		private static extern IntPtr ovr_CloudStorageUpdateResponse_GetVersionHandle_Native(IntPtr obj);

		public static uint ovr_DataStore_Contains(IntPtr obj, string key)
		{
			IntPtr intPtr = StringToNative(key);
			uint result = ovr_DataStore_Contains_Native(obj, intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_DataStore_Contains")]
		private static extern uint ovr_DataStore_Contains_Native(IntPtr obj, IntPtr key);

		public static string ovr_DataStore_GetKey(IntPtr obj, int index)
		{
			return StringFromNative(ovr_DataStore_GetKey_Native(obj, index));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_DataStore_GetKey")]
		private static extern IntPtr ovr_DataStore_GetKey_Native(IntPtr obj, int index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_DataStore_GetNumKeys(IntPtr obj);

		public static string ovr_DataStore_GetValue(IntPtr obj, string key)
		{
			IntPtr intPtr = StringToNative(key);
			string result = StringFromNative(ovr_DataStore_GetValue_Native(obj, intPtr));
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_DataStore_GetValue")]
		private static extern IntPtr ovr_DataStore_GetValue_Native(IntPtr obj, IntPtr key);

		public static string ovr_Destination_GetApiName(IntPtr obj)
		{
			return StringFromNative(ovr_Destination_GetApiName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Destination_GetApiName")]
		private static extern IntPtr ovr_Destination_GetApiName_Native(IntPtr obj);

		public static string ovr_Destination_GetDeeplinkMessage(IntPtr obj)
		{
			return StringFromNative(ovr_Destination_GetDeeplinkMessage_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Destination_GetDeeplinkMessage")]
		private static extern IntPtr ovr_Destination_GetDeeplinkMessage_Native(IntPtr obj);

		public static string ovr_Destination_GetDisplayName(IntPtr obj)
		{
			return StringFromNative(ovr_Destination_GetDisplayName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Destination_GetDisplayName")]
		private static extern IntPtr ovr_Destination_GetDisplayName_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_DestinationArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_DestinationArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_DestinationArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_DestinationArray_GetNextUrl")]
		private static extern IntPtr ovr_DestinationArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_DestinationArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_DestinationArray_HasNextPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_Error_GetCode(IntPtr obj);

		public static string ovr_Error_GetDisplayableMessage(IntPtr obj)
		{
			return StringFromNative(ovr_Error_GetDisplayableMessage_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Error_GetDisplayableMessage")]
		private static extern IntPtr ovr_Error_GetDisplayableMessage_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_Error_GetHttpCode(IntPtr obj);

		public static string ovr_Error_GetMessage(IntPtr obj)
		{
			return StringFromNative(ovr_Error_GetMessage_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Error_GetMessage")]
		private static extern IntPtr ovr_Error_GetMessage_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_HttpTransferUpdate_GetBytes(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_HttpTransferUpdate_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_HttpTransferUpdate_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_HttpTransferUpdate_IsCompleted(IntPtr obj);

		public static string ovr_InstalledApplication_GetApplicationId(IntPtr obj)
		{
			return StringFromNative(ovr_InstalledApplication_GetApplicationId_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_InstalledApplication_GetApplicationId")]
		private static extern IntPtr ovr_InstalledApplication_GetApplicationId_Native(IntPtr obj);

		public static string ovr_InstalledApplication_GetPackageName(IntPtr obj)
		{
			return StringFromNative(ovr_InstalledApplication_GetPackageName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_InstalledApplication_GetPackageName")]
		private static extern IntPtr ovr_InstalledApplication_GetPackageName_Native(IntPtr obj);

		public static string ovr_InstalledApplication_GetStatus(IntPtr obj)
		{
			return StringFromNative(ovr_InstalledApplication_GetStatus_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_InstalledApplication_GetStatus")]
		private static extern IntPtr ovr_InstalledApplication_GetStatus_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_InstalledApplication_GetVersionCode(IntPtr obj);

		public static string ovr_InstalledApplication_GetVersionName(IntPtr obj)
		{
			return StringFromNative(ovr_InstalledApplication_GetVersionName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_InstalledApplication_GetVersionName")]
		private static extern IntPtr ovr_InstalledApplication_GetVersionName_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_InstalledApplicationArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_InstalledApplicationArray_GetSize(IntPtr obj);

		public static string ovr_LanguagePackInfo_GetEnglishName(IntPtr obj)
		{
			return StringFromNative(ovr_LanguagePackInfo_GetEnglishName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LanguagePackInfo_GetEnglishName")]
		private static extern IntPtr ovr_LanguagePackInfo_GetEnglishName_Native(IntPtr obj);

		public static string ovr_LanguagePackInfo_GetNativeName(IntPtr obj)
		{
			return StringFromNative(ovr_LanguagePackInfo_GetNativeName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LanguagePackInfo_GetNativeName")]
		private static extern IntPtr ovr_LanguagePackInfo_GetNativeName_Native(IntPtr obj);

		public static string ovr_LanguagePackInfo_GetTag(IntPtr obj)
		{
			return StringFromNative(ovr_LanguagePackInfo_GetTag_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LanguagePackInfo_GetTag")]
		private static extern IntPtr ovr_LanguagePackInfo_GetTag_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LaunchBlockFlowResult_GetDidBlock(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LaunchBlockFlowResult_GetDidCancel(IntPtr obj);

		public static string ovr_LaunchDetails_GetDeeplinkMessage(IntPtr obj)
		{
			return StringFromNative(ovr_LaunchDetails_GetDeeplinkMessage_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LaunchDetails_GetDeeplinkMessage")]
		private static extern IntPtr ovr_LaunchDetails_GetDeeplinkMessage_Native(IntPtr obj);

		public static string ovr_LaunchDetails_GetDestinationApiName(IntPtr obj)
		{
			return StringFromNative(ovr_LaunchDetails_GetDestinationApiName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LaunchDetails_GetDestinationApiName")]
		private static extern IntPtr ovr_LaunchDetails_GetDestinationApiName_Native(IntPtr obj);

		public static string ovr_LaunchDetails_GetLaunchSource(IntPtr obj)
		{
			return StringFromNative(ovr_LaunchDetails_GetLaunchSource_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LaunchDetails_GetLaunchSource")]
		private static extern IntPtr ovr_LaunchDetails_GetLaunchSource_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern LaunchType ovr_LaunchDetails_GetLaunchType(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_LaunchDetails_GetRoomID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_LaunchDetails_GetUsers(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LaunchFriendRequestFlowResult_GetDidCancel(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LaunchFriendRequestFlowResult_GetDidSendRequest(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LaunchReportFlowResult_GetDidCancel(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_LaunchReportFlowResult_GetUserReportId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LaunchUnblockFlowResult_GetDidCancel(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LaunchUnblockFlowResult_GetDidUnblock(IntPtr obj);

		public static byte[] ovr_LeaderboardEntry_GetExtraData(IntPtr obj)
		{
			return BlobFromNative(ovr_LeaderboardEntry_GetExtraDataLength(obj), ovr_LeaderboardEntry_GetExtraData_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LeaderboardEntry_GetExtraData")]
		private static extern IntPtr ovr_LeaderboardEntry_GetExtraData_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_LeaderboardEntry_GetExtraDataLength(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_LeaderboardEntry_GetRank(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern long ovr_LeaderboardEntry_GetScore(IntPtr obj);

		public static DateTime ovr_LeaderboardEntry_GetTimestamp(IntPtr obj)
		{
			return DateTimeFromNative(ovr_LeaderboardEntry_GetTimestamp_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LeaderboardEntry_GetTimestamp")]
		private static extern ulong ovr_LeaderboardEntry_GetTimestamp_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_LeaderboardEntry_GetUser(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_LeaderboardEntryArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_LeaderboardEntryArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_LeaderboardEntryArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LeaderboardEntryArray_GetNextUrl")]
		private static extern IntPtr ovr_LeaderboardEntryArray_GetNextUrl_Native(IntPtr obj);

		public static string ovr_LeaderboardEntryArray_GetPreviousUrl(IntPtr obj)
		{
			return StringFromNative(ovr_LeaderboardEntryArray_GetPreviousUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LeaderboardEntryArray_GetPreviousUrl")]
		private static extern IntPtr ovr_LeaderboardEntryArray_GetPreviousUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_LeaderboardEntryArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_LeaderboardEntryArray_GetTotalCount(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LeaderboardEntryArray_HasNextPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LeaderboardEntryArray_HasPreviousPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LeaderboardUpdateStatus_GetDidUpdate(IntPtr obj);

		public static string ovr_LinkedAccount_GetAccessToken(IntPtr obj)
		{
			return StringFromNative(ovr_LinkedAccount_GetAccessToken_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LinkedAccount_GetAccessToken")]
		private static extern IntPtr ovr_LinkedAccount_GetAccessToken_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ServiceProvider ovr_LinkedAccount_GetServiceProvider(IntPtr obj);

		public static string ovr_LinkedAccount_GetUserId(IntPtr obj)
		{
			return StringFromNative(ovr_LinkedAccount_GetUserId_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LinkedAccount_GetUserId")]
		private static extern IntPtr ovr_LinkedAccount_GetUserId_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_LinkedAccountArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_LinkedAccountArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LivestreamingApplicationStatus_GetStreamingEnabled(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern LivestreamingStartStatus ovr_LivestreamingStartResult_GetStreamingResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LivestreamingStatus_GetCommentsVisible(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LivestreamingStatus_GetIsPaused(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LivestreamingStatus_GetLivestreamingEnabled(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_LivestreamingStatus_GetLivestreamingType(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LivestreamingStatus_GetMicEnabled(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_LivestreamingVideoStats_GetCommentCount(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_LivestreamingVideoStats_GetReactionCount(IntPtr obj);

		public static string ovr_LivestreamingVideoStats_GetTotalViews(IntPtr obj)
		{
			return StringFromNative(ovr_LivestreamingVideoStats_GetTotalViews_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LivestreamingVideoStats_GetTotalViews")]
		private static extern IntPtr ovr_LivestreamingVideoStats_GetTotalViews_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingAdminSnapshot_GetCandidates(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern double ovr_MatchmakingAdminSnapshot_GetMyCurrentThreshold(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_MatchmakingAdminSnapshotCandidate_GetCanMatch(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern double ovr_MatchmakingAdminSnapshotCandidate_GetMyTotalScore(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern double ovr_MatchmakingAdminSnapshotCandidate_GetTheirCurrentThreshold(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern double ovr_MatchmakingAdminSnapshotCandidate_GetTheirTotalScore(IntPtr obj);

		public static string ovr_MatchmakingAdminSnapshotCandidate_GetTraceId(IntPtr obj)
		{
			return StringFromNative(ovr_MatchmakingAdminSnapshotCandidate_GetTraceId_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingAdminSnapshotCandidate_GetTraceId")]
		private static extern IntPtr ovr_MatchmakingAdminSnapshotCandidate_GetTraceId_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingAdminSnapshotCandidateArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_MatchmakingAdminSnapshotCandidateArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingBrowseResult_GetEnqueueResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingBrowseResult_GetRooms(IntPtr obj);

		public static string ovr_MatchmakingCandidate_GetEntryHash(IntPtr obj)
		{
			return StringFromNative(ovr_MatchmakingCandidate_GetEntryHash_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingCandidate_GetEntryHash")]
		private static extern IntPtr ovr_MatchmakingCandidate_GetEntryHash_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_MatchmakingCandidate_GetUserId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingCandidateArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_MatchmakingCandidateArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_MatchmakingCandidateArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingCandidateArray_GetNextUrl")]
		private static extern IntPtr ovr_MatchmakingCandidateArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_MatchmakingCandidateArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_MatchmakingCandidateArray_HasNextPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingEnqueueResult_GetAdminSnapshot(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingEnqueueResult_GetAverageWait(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingEnqueueResult_GetMatchesInLastHourCount(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingEnqueueResult_GetMaxExpectedWait(IntPtr obj);

		public static string ovr_MatchmakingEnqueueResult_GetPool(IntPtr obj)
		{
			return StringFromNative(ovr_MatchmakingEnqueueResult_GetPool_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingEnqueueResult_GetPool")]
		private static extern IntPtr ovr_MatchmakingEnqueueResult_GetPool_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingEnqueueResult_GetRecentMatchPercentage(IntPtr obj);

		public static string ovr_MatchmakingEnqueueResult_GetRequestHash(IntPtr obj)
		{
			return StringFromNative(ovr_MatchmakingEnqueueResult_GetRequestHash_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingEnqueueResult_GetRequestHash")]
		private static extern IntPtr ovr_MatchmakingEnqueueResult_GetRequestHash_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingEnqueueResultAndRoom_GetMatchmakingEnqueueResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingEnqueueResultAndRoom_GetRoom(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_MatchmakingEnqueuedUser_GetAdditionalUserID(IntPtr obj, uint index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingEnqueuedUser_GetAdditionalUserIDsSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingEnqueuedUser_GetCustomData(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingEnqueuedUser_GetUser(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingEnqueuedUserArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_MatchmakingEnqueuedUserArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_MatchmakingNotification_GetAddedByUserId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingNotification_GetRoom(IntPtr obj);

		public static string ovr_MatchmakingNotification_GetTraceId(IntPtr obj)
		{
			return StringFromNative(ovr_MatchmakingNotification_GetTraceId_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingNotification_GetTraceId")]
		private static extern IntPtr ovr_MatchmakingNotification_GetTraceId_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingRoom_GetPingTime(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingRoom_GetRoom(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_MatchmakingRoom_HasPingTime(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingRoomArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_MatchmakingRoomArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingStats_GetDrawCount(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingStats_GetLossCount(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingStats_GetSkillLevel(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern double ovr_MatchmakingStats_GetSkillMean(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern double ovr_MatchmakingStats_GetSkillStandardDeviation(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingStats_GetWinCount(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAbuseReportRecording(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAchievementDefinitionArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAchievementProgressArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAchievementUpdate(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetApplicationVersion(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAssetDetails(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAssetDetailsArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAssetFileDeleteResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAssetFileDownloadCancelResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAssetFileDownloadResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAssetFileDownloadUpdate(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetCalApplicationFinalized(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetCalApplicationProposed(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetCalApplicationSuggestionArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetCloudStorageConflictMetadata(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetCloudStorageData(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetCloudStorageMetadata(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetCloudStorageMetadataArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetCloudStorageUpdateResponse(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetDestinationArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetError(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetHttpTransferUpdate(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetInstalledApplicationArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLaunchBlockFlowResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLaunchFriendRequestFlowResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLaunchReportFlowResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLaunchUnblockFlowResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLeaderboardEntryArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLeaderboardUpdateStatus(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLinkedAccountArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLivestreamingApplicationStatus(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLivestreamingStartResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLivestreamingStatus(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLivestreamingVideoStats(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetMatchmakingAdminSnapshot(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetMatchmakingBrowseResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetMatchmakingEnqueueResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetMatchmakingEnqueueResultAndRoom(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetMatchmakingRoomArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetMatchmakingStats(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetNativeMessage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetNetSyncConnection(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetNetSyncSessionArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetNetSyncSessionsChangedNotification(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetNetSyncSetSessionPropertyResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetNetworkingPeer(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetOrgScopedID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetParty(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetPartyID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetPartyUpdateNotification(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetPidArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetPingResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetPlatformInitialize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetProductArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetPurchase(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetPurchaseArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Message_GetRequestID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetRoom(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetRoomArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetRoomInviteNotification(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetRoomInviteNotificationArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetSdkAccountArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetShareMediaResult(IntPtr obj);

		public static string ovr_Message_GetString(IntPtr obj)
		{
			return StringFromNative(ovr_Message_GetString_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Message_GetString")]
		private static extern IntPtr ovr_Message_GetString_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetSystemPermission(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetSystemVoipState(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern Message.MessageType ovr_Message_GetType(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetUser(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetUserAndRoomArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetUserArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetUserProof(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetUserReportID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_Message_IsError(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Microphone_GetNumSamplesAvailable(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Microphone_GetOutputBufferMaxSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Microphone_GetPCM(IntPtr obj, short[] outputBuffer, UIntPtr outputBufferNumElements);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Microphone_GetPCMFloat(IntPtr obj, float[] outputBuffer, UIntPtr outputBufferNumElements);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Microphone_ReadData(IntPtr obj, float[] outputBuffer, UIntPtr outputBufferSize);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Microphone_SetAcceptableRecordingDelayHint(IntPtr obj, UIntPtr delayMs);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Microphone_Start(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Microphone_Stop(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern long ovr_NetSyncConnection_GetConnectionId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern NetSyncDisconnectReason ovr_NetSyncConnection_GetDisconnectReason(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_NetSyncConnection_GetSessionId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern NetSyncConnectionStatus ovr_NetSyncConnection_GetStatus(IntPtr obj);

		public static string ovr_NetSyncConnection_GetZoneId(IntPtr obj)
		{
			return StringFromNative(ovr_NetSyncConnection_GetZoneId_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_NetSyncConnection_GetZoneId")]
		private static extern IntPtr ovr_NetSyncConnection_GetZoneId_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern long ovr_NetSyncSession_GetConnectionId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_NetSyncSession_GetMuted(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_NetSyncSession_GetSessionId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_NetSyncSession_GetUserId(IntPtr obj);

		public static string ovr_NetSyncSession_GetVoipGroup(IntPtr obj)
		{
			return StringFromNative(ovr_NetSyncSession_GetVoipGroup_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_NetSyncSession_GetVoipGroup")]
		private static extern IntPtr ovr_NetSyncSession_GetVoipGroup_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_NetSyncSessionArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_NetSyncSessionArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern long ovr_NetSyncSessionsChangedNotification_GetConnectionId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_NetSyncSessionsChangedNotification_GetSessions(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_NetSyncSetSessionPropertyResult_GetSession(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_NetworkingPeer_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern PeerConnectionState ovr_NetworkingPeer_GetState(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_OrgScopedID_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Packet_Free(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Packet_GetBytes(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern SendPolicy ovr_Packet_GetSendPolicy(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Packet_GetSenderID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Packet_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Party_GetInvitedUsers(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Party_GetLeader(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Party_GetRoom(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Party_GetUsers(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_PartyID_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern PartyUpdateAction ovr_PartyUpdateNotification_GetAction(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_PartyUpdateNotification_GetPartyId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_PartyUpdateNotification_GetSenderId(IntPtr obj);

		public static string ovr_PartyUpdateNotification_GetUpdateTimestamp(IntPtr obj)
		{
			return StringFromNative(ovr_PartyUpdateNotification_GetUpdateTimestamp_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_PartyUpdateNotification_GetUpdateTimestamp")]
		private static extern IntPtr ovr_PartyUpdateNotification_GetUpdateTimestamp_Native(IntPtr obj);

		public static string ovr_PartyUpdateNotification_GetUserAlias(IntPtr obj)
		{
			return StringFromNative(ovr_PartyUpdateNotification_GetUserAlias_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_PartyUpdateNotification_GetUserAlias")]
		private static extern IntPtr ovr_PartyUpdateNotification_GetUserAlias_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_PartyUpdateNotification_GetUserId(IntPtr obj);

		public static string ovr_PartyUpdateNotification_GetUserName(IntPtr obj)
		{
			return StringFromNative(ovr_PartyUpdateNotification_GetUserName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_PartyUpdateNotification_GetUserName")]
		private static extern IntPtr ovr_PartyUpdateNotification_GetUserName_Native(IntPtr obj);

		public static string ovr_Pid_GetId(IntPtr obj)
		{
			return StringFromNative(ovr_Pid_GetId_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Pid_GetId")]
		private static extern IntPtr ovr_Pid_GetId_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_PidArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_PidArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_PingResult_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_PingResult_GetPingTimeUsec(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_PingResult_IsTimeout(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern PlatformInitializeResult ovr_PlatformInitialize_GetResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_Price_GetAmountInHundredths(IntPtr obj);

		public static string ovr_Price_GetCurrency(IntPtr obj)
		{
			return StringFromNative(ovr_Price_GetCurrency_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Price_GetCurrency")]
		private static extern IntPtr ovr_Price_GetCurrency_Native(IntPtr obj);

		public static string ovr_Price_GetFormatted(IntPtr obj)
		{
			return StringFromNative(ovr_Price_GetFormatted_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Price_GetFormatted")]
		private static extern IntPtr ovr_Price_GetFormatted_Native(IntPtr obj);

		public static string ovr_Product_GetDescription(IntPtr obj)
		{
			return StringFromNative(ovr_Product_GetDescription_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Product_GetDescription")]
		private static extern IntPtr ovr_Product_GetDescription_Native(IntPtr obj);

		public static string ovr_Product_GetFormattedPrice(IntPtr obj)
		{
			return StringFromNative(ovr_Product_GetFormattedPrice_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Product_GetFormattedPrice")]
		private static extern IntPtr ovr_Product_GetFormattedPrice_Native(IntPtr obj);

		public static string ovr_Product_GetName(IntPtr obj)
		{
			return StringFromNative(ovr_Product_GetName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Product_GetName")]
		private static extern IntPtr ovr_Product_GetName_Native(IntPtr obj);

		public static string ovr_Product_GetSKU(IntPtr obj)
		{
			return StringFromNative(ovr_Product_GetSKU_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Product_GetSKU")]
		private static extern IntPtr ovr_Product_GetSKU_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_ProductArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_ProductArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_ProductArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_ProductArray_GetNextUrl")]
		private static extern IntPtr ovr_ProductArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_ProductArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_ProductArray_HasNextPage(IntPtr obj);

		public static DateTime ovr_Purchase_GetExpirationTime(IntPtr obj)
		{
			return DateTimeFromNative(ovr_Purchase_GetExpirationTime_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Purchase_GetExpirationTime")]
		private static extern ulong ovr_Purchase_GetExpirationTime_Native(IntPtr obj);

		public static DateTime ovr_Purchase_GetGrantTime(IntPtr obj)
		{
			return DateTimeFromNative(ovr_Purchase_GetGrantTime_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Purchase_GetGrantTime")]
		private static extern ulong ovr_Purchase_GetGrantTime_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Purchase_GetPurchaseID(IntPtr obj);

		public static string ovr_Purchase_GetSKU(IntPtr obj)
		{
			return StringFromNative(ovr_Purchase_GetSKU_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Purchase_GetSKU")]
		private static extern IntPtr ovr_Purchase_GetSKU_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_PurchaseArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_PurchaseArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_PurchaseArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_PurchaseArray_GetNextUrl")]
		private static extern IntPtr ovr_PurchaseArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_PurchaseArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_PurchaseArray_HasNextPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetApplicationID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Room_GetDataStore(IntPtr obj);

		public static string ovr_Room_GetDescription(IntPtr obj)
		{
			return StringFromNative(ovr_Room_GetDescription_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Room_GetDescription")]
		private static extern IntPtr ovr_Room_GetDescription_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Room_GetInvitedUsers(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_Room_GetIsMembershipLocked(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern RoomJoinPolicy ovr_Room_GetJoinPolicy(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern RoomJoinability ovr_Room_GetJoinability(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Room_GetMatchedUsers(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_Room_GetMaxUsers(IntPtr obj);

		public static string ovr_Room_GetName(IntPtr obj)
		{
			return StringFromNative(ovr_Room_GetName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Room_GetName")]
		private static extern IntPtr ovr_Room_GetName_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Room_GetOwner(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Room_GetTeams(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern RoomType ovr_Room_GetType(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Room_GetUsers(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_Room_GetVersion(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_RoomArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_RoomArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_RoomArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_RoomArray_GetNextUrl")]
		private static extern IntPtr ovr_RoomArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_RoomArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_RoomArray_HasNextPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_RoomInviteNotification_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_RoomInviteNotification_GetRoomID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_RoomInviteNotification_GetSenderID(IntPtr obj);

		public static DateTime ovr_RoomInviteNotification_GetSentTime(IntPtr obj)
		{
			return DateTimeFromNative(ovr_RoomInviteNotification_GetSentTime_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_RoomInviteNotification_GetSentTime")]
		private static extern ulong ovr_RoomInviteNotification_GetSentTime_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_RoomInviteNotificationArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_RoomInviteNotificationArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_RoomInviteNotificationArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_RoomInviteNotificationArray_GetNextUrl")]
		private static extern IntPtr ovr_RoomInviteNotificationArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_RoomInviteNotificationArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_RoomInviteNotificationArray_HasNextPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern SdkAccountType ovr_SdkAccount_GetAccountType(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_SdkAccount_GetUserId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_SdkAccountArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_SdkAccountArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ShareMediaStatus ovr_ShareMediaResult_GetStatus(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_SystemPermission_GetHasPermission(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern PermissionGrantStatus ovr_SystemPermission_GetPermissionGrantStatus(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern VoipMuteState ovr_SystemVoipState_GetMicrophoneMuted(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern SystemVoipStatus ovr_SystemVoipState_GetStatus(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Team_GetAssignedUsers(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_Team_GetMaxUsers(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_Team_GetMinUsers(IntPtr obj);

		public static string ovr_Team_GetName(IntPtr obj)
		{
			return StringFromNative(ovr_Team_GetName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Team_GetName")]
		private static extern IntPtr ovr_Team_GetName_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_TeamArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_TeamArray_GetSize(IntPtr obj);

		public static string ovr_TestUser_GetAccessToken(IntPtr obj)
		{
			return StringFromNative(ovr_TestUser_GetAccessToken_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_TestUser_GetAccessToken")]
		private static extern IntPtr ovr_TestUser_GetAccessToken_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_TestUser_GetAppAccessArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_TestUser_GetFbAppAccessArray(IntPtr obj);

		public static string ovr_TestUser_GetFriendAccessToken(IntPtr obj)
		{
			return StringFromNative(ovr_TestUser_GetFriendAccessToken_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_TestUser_GetFriendAccessToken")]
		private static extern IntPtr ovr_TestUser_GetFriendAccessToken_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_TestUser_GetFriendAppAccessArray(IntPtr obj);

		public static string ovr_TestUser_GetUserAlias(IntPtr obj)
		{
			return StringFromNative(ovr_TestUser_GetUserAlias_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_TestUser_GetUserAlias")]
		private static extern IntPtr ovr_TestUser_GetUserAlias_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_TestUser_GetUserFbid(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_TestUser_GetUserId(IntPtr obj);

		public static string ovr_TestUserAppAccess_GetAccessToken(IntPtr obj)
		{
			return StringFromNative(ovr_TestUserAppAccess_GetAccessToken_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_TestUserAppAccess_GetAccessToken")]
		private static extern IntPtr ovr_TestUserAppAccess_GetAccessToken_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_TestUserAppAccess_GetAppId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_TestUserAppAccess_GetUserId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_TestUserAppAccessArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_TestUserAppAccessArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetID(IntPtr obj);

		public static string ovr_User_GetImageUrl(IntPtr obj)
		{
			return StringFromNative(ovr_User_GetImageUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_GetImageUrl")]
		private static extern IntPtr ovr_User_GetImageUrl_Native(IntPtr obj);

		public static string ovr_User_GetInviteToken(IntPtr obj)
		{
			return StringFromNative(ovr_User_GetInviteToken_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_GetInviteToken")]
		private static extern IntPtr ovr_User_GetInviteToken_Native(IntPtr obj);

		public static string ovr_User_GetOculusID(IntPtr obj)
		{
			return StringFromNative(ovr_User_GetOculusID_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_GetOculusID")]
		private static extern IntPtr ovr_User_GetOculusID_Native(IntPtr obj);

		public static string ovr_User_GetPresence(IntPtr obj)
		{
			return StringFromNative(ovr_User_GetPresence_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_GetPresence")]
		private static extern IntPtr ovr_User_GetPresence_Native(IntPtr obj);

		public static string ovr_User_GetPresenceDeeplinkMessage(IntPtr obj)
		{
			return StringFromNative(ovr_User_GetPresenceDeeplinkMessage_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_GetPresenceDeeplinkMessage")]
		private static extern IntPtr ovr_User_GetPresenceDeeplinkMessage_Native(IntPtr obj);

		public static string ovr_User_GetPresenceDestinationApiName(IntPtr obj)
		{
			return StringFromNative(ovr_User_GetPresenceDestinationApiName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_GetPresenceDestinationApiName")]
		private static extern IntPtr ovr_User_GetPresenceDestinationApiName_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UserPresenceStatus ovr_User_GetPresenceStatus(IntPtr obj);

		public static string ovr_User_GetSmallImageUrl(IntPtr obj)
		{
			return StringFromNative(ovr_User_GetSmallImageUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_GetSmallImageUrl")]
		private static extern IntPtr ovr_User_GetSmallImageUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_UserAndRoom_GetRoom(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_UserAndRoom_GetUser(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_UserAndRoomArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_UserAndRoomArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_UserAndRoomArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_UserAndRoomArray_GetNextUrl")]
		private static extern IntPtr ovr_UserAndRoomArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_UserAndRoomArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_UserAndRoomArray_HasNextPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_UserArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_UserArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_UserArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_UserArray_GetNextUrl")]
		private static extern IntPtr ovr_UserArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_UserArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_UserArray_HasNextPage(IntPtr obj);

		public static string ovr_UserProof_GetNonce(IntPtr obj)
		{
			return StringFromNative(ovr_UserProof_GetNonce_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_UserProof_GetNonce")]
		private static extern IntPtr ovr_UserProof_GetNonce_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_UserReportID_GetDidCancel(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_UserReportID_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_VoipDecoder_Decode(IntPtr obj, byte[] compressedData, UIntPtr compressedSize);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_VoipDecoder_GetDecodedPCM(IntPtr obj, float[] outputBuffer, UIntPtr outputBufferSize);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_VoipEncoder_AddPCM(IntPtr obj, float[] inputData, uint inputSize);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_VoipEncoder_GetCompressedData(IntPtr obj, byte[] outputBuffer, UIntPtr intputSize);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_VoipEncoder_GetCompressedDataSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_AbuseReportOptions_Create();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_AbuseReportOptions_Destroy(IntPtr handle);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_AbuseReportOptions_SetPreventPeopleChooser(IntPtr handle, bool value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_AbuseReportOptions_SetReportType(IntPtr handle, AbuseReportType value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_ApplicationOptions_Create();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_ApplicationOptions_Destroy(IntPtr handle);

		public static void ovr_ApplicationOptions_SetDeeplinkMessage(IntPtr handle, string value)
		{
			IntPtr intPtr = StringToNative(value);
			ovr_ApplicationOptions_SetDeeplinkMessage_Native(handle, intPtr);
			Marshal.FreeCoTaskMem(intPtr);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_ApplicationOptions_SetDeeplinkMessage")]
		private static extern void ovr_ApplicationOptions_SetDeeplinkMessage_Native(IntPtr handle, IntPtr value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingOptions_Create();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_Destroy(IntPtr handle);

		public static void ovr_MatchmakingOptions_SetCreateRoomDataStoreString(IntPtr handle, string key, string value)
		{
			IntPtr intPtr = StringToNative(key);
			IntPtr intPtr2 = StringToNative(value);
			ovr_MatchmakingOptions_SetCreateRoomDataStoreString_Native(handle, intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingOptions_SetCreateRoomDataStoreString")]
		private static extern void ovr_MatchmakingOptions_SetCreateRoomDataStoreString_Native(IntPtr handle, IntPtr key, IntPtr value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_ClearCreateRoomDataStore(IntPtr handle);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_SetCreateRoomJoinPolicy(IntPtr handle, RoomJoinPolicy value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_SetCreateRoomMaxUsers(IntPtr handle, uint value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_AddEnqueueAdditionalUser(IntPtr handle, ulong value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_ClearEnqueueAdditionalUsers(IntPtr handle);

		public static void ovr_MatchmakingOptions_SetEnqueueDataSettingsInt(IntPtr handle, string key, int value)
		{
			IntPtr intPtr = StringToNative(key);
			ovr_MatchmakingOptions_SetEnqueueDataSettingsInt_Native(handle, intPtr, value);
			Marshal.FreeCoTaskMem(intPtr);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingOptions_SetEnqueueDataSettingsInt")]
		private static extern void ovr_MatchmakingOptions_SetEnqueueDataSettingsInt_Native(IntPtr handle, IntPtr key, int value);

		public static void ovr_MatchmakingOptions_SetEnqueueDataSettingsDouble(IntPtr handle, string key, double value)
		{
			IntPtr intPtr = StringToNative(key);
			ovr_MatchmakingOptions_SetEnqueueDataSettingsDouble_Native(handle, intPtr, value);
			Marshal.FreeCoTaskMem(intPtr);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingOptions_SetEnqueueDataSettingsDouble")]
		private static extern void ovr_MatchmakingOptions_SetEnqueueDataSettingsDouble_Native(IntPtr handle, IntPtr key, double value);

		public static void ovr_MatchmakingOptions_SetEnqueueDataSettingsString(IntPtr handle, string key, string value)
		{
			IntPtr intPtr = StringToNative(key);
			IntPtr intPtr2 = StringToNative(value);
			ovr_MatchmakingOptions_SetEnqueueDataSettingsString_Native(handle, intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingOptions_SetEnqueueDataSettingsString")]
		private static extern void ovr_MatchmakingOptions_SetEnqueueDataSettingsString_Native(IntPtr handle, IntPtr key, IntPtr value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_ClearEnqueueDataSettings(IntPtr handle);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_SetEnqueueIsDebug(IntPtr handle, bool value);

		public static void ovr_MatchmakingOptions_SetEnqueueQueryKey(IntPtr handle, string value)
		{
			IntPtr intPtr = StringToNative(value);
			ovr_MatchmakingOptions_SetEnqueueQueryKey_Native(handle, intPtr);
			Marshal.FreeCoTaskMem(intPtr);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingOptions_SetEnqueueQueryKey")]
		private static extern void ovr_MatchmakingOptions_SetEnqueueQueryKey_Native(IntPtr handle, IntPtr value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_NetSyncOptions_Create();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_NetSyncOptions_Destroy(IntPtr handle);

		public static void ovr_NetSyncOptions_SetVoipGroup(IntPtr handle, string value)
		{
			IntPtr intPtr = StringToNative(value);
			ovr_NetSyncOptions_SetVoipGroup_Native(handle, intPtr);
			Marshal.FreeCoTaskMem(intPtr);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_NetSyncOptions_SetVoipGroup")]
		private static extern void ovr_NetSyncOptions_SetVoipGroup_Native(IntPtr handle, IntPtr value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_NetSyncOptions_SetVoipStreamDefault(IntPtr handle, NetSyncVoipStreamMode value);

		public static void ovr_NetSyncOptions_SetZoneId(IntPtr handle, string value)
		{
			IntPtr intPtr = StringToNative(value);
			ovr_NetSyncOptions_SetZoneId_Native(handle, intPtr);
			Marshal.FreeCoTaskMem(intPtr);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_NetSyncOptions_SetZoneId")]
		private static extern void ovr_NetSyncOptions_SetZoneId_Native(IntPtr handle, IntPtr value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_RichPresenceOptions_Create();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RichPresenceOptions_Destroy(IntPtr handle);

		public static void ovr_RichPresenceOptions_SetApiName(IntPtr handle, string value)
		{
			IntPtr intPtr = StringToNative(value);
			ovr_RichPresenceOptions_SetApiName_Native(handle, intPtr);
			Marshal.FreeCoTaskMem(intPtr);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_RichPresenceOptions_SetApiName")]
		private static extern void ovr_RichPresenceOptions_SetApiName_Native(IntPtr handle, IntPtr value);

		public static void ovr_RichPresenceOptions_SetArgsString(IntPtr handle, string key, string value)
		{
			IntPtr intPtr = StringToNative(key);
			IntPtr intPtr2 = StringToNative(value);
			ovr_RichPresenceOptions_SetArgsString_Native(handle, intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_RichPresenceOptions_SetArgsString")]
		private static extern void ovr_RichPresenceOptions_SetArgsString_Native(IntPtr handle, IntPtr key, IntPtr value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RichPresenceOptions_ClearArgs(IntPtr handle);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RichPresenceOptions_SetCurrentCapacity(IntPtr handle, uint value);

		public static void ovr_RichPresenceOptions_SetDeeplinkMessageOverride(IntPtr handle, string value)
		{
			IntPtr intPtr = StringToNative(value);
			ovr_RichPresenceOptions_SetDeeplinkMessageOverride_Native(handle, intPtr);
			Marshal.FreeCoTaskMem(intPtr);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_RichPresenceOptions_SetDeeplinkMessageOverride")]
		private static extern void ovr_RichPresenceOptions_SetDeeplinkMessageOverride_Native(IntPtr handle, IntPtr value);

		public static void ovr_RichPresenceOptions_SetEndTime(IntPtr handle, DateTime value)
		{
			ulong value2 = DateTimeToNative(value);
			ovr_RichPresenceOptions_SetEndTime_Native(handle, value2);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_RichPresenceOptions_SetEndTime")]
		private static extern void ovr_RichPresenceOptions_SetEndTime_Native(IntPtr handle, ulong value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RichPresenceOptions_SetExtraContext(IntPtr handle, RichPresenceExtraContext value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RichPresenceOptions_SetIsIdle(IntPtr handle, bool value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RichPresenceOptions_SetIsJoinable(IntPtr handle, bool value);

		public static void ovr_RichPresenceOptions_SetJoinableId(IntPtr handle, string value)
		{
			IntPtr intPtr = StringToNative(value);
			ovr_RichPresenceOptions_SetJoinableId_Native(handle, intPtr);
			Marshal.FreeCoTaskMem(intPtr);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_RichPresenceOptions_SetJoinableId")]
		private static extern void ovr_RichPresenceOptions_SetJoinableId_Native(IntPtr handle, IntPtr value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RichPresenceOptions_SetMaxCapacity(IntPtr handle, uint value);

		public static void ovr_RichPresenceOptions_SetStartTime(IntPtr handle, DateTime value)
		{
			ulong value2 = DateTimeToNative(value);
			ovr_RichPresenceOptions_SetStartTime_Native(handle, value2);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_RichPresenceOptions_SetStartTime")]
		private static extern void ovr_RichPresenceOptions_SetStartTime_Native(IntPtr handle, ulong value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_RoomOptions_Create();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RoomOptions_Destroy(IntPtr handle);

		public static void ovr_RoomOptions_SetDataStoreString(IntPtr handle, string key, string value)
		{
			IntPtr intPtr = StringToNative(key);
			IntPtr intPtr2 = StringToNative(value);
			ovr_RoomOptions_SetDataStoreString_Native(handle, intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_RoomOptions_SetDataStoreString")]
		private static extern void ovr_RoomOptions_SetDataStoreString_Native(IntPtr handle, IntPtr key, IntPtr value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RoomOptions_ClearDataStore(IntPtr handle);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RoomOptions_SetExcludeRecentlyMet(IntPtr handle, bool value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RoomOptions_SetMaxUserResults(IntPtr handle, uint value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RoomOptions_SetOrdering(IntPtr handle, UserOrdering value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RoomOptions_SetRecentlyMetTimeWindow(IntPtr handle, TimeWindow value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RoomOptions_SetRoomId(IntPtr handle, ulong value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RoomOptions_SetTurnOffUpdates(IntPtr handle, bool value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_UserOptions_Create();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_UserOptions_Destroy(IntPtr handle);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_UserOptions_SetMaxUsers(IntPtr handle, uint value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_UserOptions_AddServiceProvider(IntPtr handle, ServiceProvider value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_UserOptions_ClearServiceProviders(IntPtr handle);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_UserOptions_SetTimeWindow(IntPtr handle, TimeWindow value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_VoipOptions_Create();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_VoipOptions_Destroy(IntPtr handle);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_VoipOptions_SetBitrateForNewConnections(IntPtr handle, VoipBitrate value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_VoipOptions_SetCreateNewConnectionUseDtx(IntPtr handle, VoipDtxState value);
	}
	public enum CloudStorageDataStatus
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("IN_SYNC")]
		InSync,
		[Description("NEEDS_DOWNLOAD")]
		NeedsDownload,
		[Description("REMOTE_DOWNLOADING")]
		RemoteDownloading,
		[Description("NEEDS_UPLOAD")]
		NeedsUpload,
		[Description("LOCAL_UPLOADING")]
		LocalUploading,
		[Description("IN_CONFLICT")]
		InConflict
	}
	public enum CloudStorageUpdateStatus
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("OK")]
		Ok,
		[Description("BETTER_VERSION_STORED")]
		BetterVersionStored,
		[Description("MANUAL_MERGE_REQUIRED")]
		ManualMergeRequired
	}
	public interface IMicrophone
	{
		void Start();

		void Stop();

		float[] Update();
	}
	public interface IVoipPCMSource
	{
		int GetPCM(float[] dest, int length);

		void SetSenderID(ulong senderID);

		void Update();

		int PeekSizeElements();
	}
	public enum KeyValuePairType
	{
		[Description("STRING")]
		String,
		[Description("INTEGER")]
		Int,
		[Description("DOUBLE")]
		Double,
		[Description("UNKNOWN")]
		Unknown
	}
	public enum LaunchType
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("NORMAL")]
		Normal,
		[Description("INVITE")]
		Invite,
		[Description("COORDINATED")]
		Coordinated,
		[Description("DEEPLINK")]
		Deeplink
	}
	public enum LeaderboardFilterType
	{
		[Description("NONE")]
		None,
		[Description("FRIENDS")]
		Friends,
		[Description("UNKNOWN")]
		Unknown
	}
	public enum LeaderboardStartAt
	{
		[Description("TOP")]
		Top,
		[Description("CENTERED_ON_VIEWER")]
		CenteredOnViewer,
		[Description("CENTERED_ON_VIEWER_OR_TOP")]
		CenteredOnViewerOrTop,
		[Description("UNKNOWN")]
		Unknown
	}
	public enum LivestreamingAudience
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("PUBLIC")]
		Public,
		[Description("FRIENDS")]
		Friends,
		[Description("ONLY_ME")]
		OnlyMe
	}
	public enum LivestreamingMicrophoneStatus
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("MICROPHONE_ON")]
		MicrophoneOn,
		[Description("MICROPHONE_OFF")]
		MicrophoneOff
	}
	public enum LivestreamingStartStatus
	{
		[Description("SUCCESS")]
		Success = 1,
		[Description("UNKNOWN")]
		Unknown = 0,
		[Description("NO_PACKAGE_SET")]
		NoPackageSet = -1,
		[Description("NO_FB_CONNECT")]
		NoFbConnect = -2,
		[Description("NO_SESSION_ID")]
		NoSessionId = -3,
		[Description("MISSING_PARAMETERS")]
		MissingParameters = -4
	}
	public enum MatchmakingCriterionImportance
	{
		[Description("REQUIRED")]
		Required,
		[Description("HIGH")]
		High,
		[Description("MEDIUM")]
		Medium,
		[Description("LOW")]
		Low,
		[Description("UNKNOWN")]
		Unknown
	}
	public class MatchmakingOptions
	{
		private IntPtr Handle;

		public MatchmakingOptions()
		{
			Handle = CAPI.ovr_MatchmakingOptions_Create();
		}

		public void SetCreateRoomDataStore(string key, string value)
		{
			CAPI.ovr_MatchmakingOptions_SetCreateRoomDataStoreString(Handle, key, value);
		}

		public void ClearCreateRoomDataStore()
		{
			CAPI.ovr_MatchmakingOptions_ClearCreateRoomDataStore(Handle);
		}

		public void SetCreateRoomJoinPolicy(RoomJoinPolicy value)
		{
			CAPI.ovr_MatchmakingOptions_SetCreateRoomJoinPolicy(Handle, value);
		}

		public void SetCreateRoomMaxUsers(uint value)
		{
			CAPI.ovr_MatchmakingOptions_SetCreateRoomMaxUsers(Handle, value);
		}

		public void AddEnqueueAdditionalUser(ulong userID)
		{
			CAPI.ovr_MatchmakingOptions_AddEnqueueAdditionalUser(Handle, userID);
		}

		public void ClearEnqueueAdditionalUsers()
		{
			CAPI.ovr_MatchmakingOptions_ClearEnqueueAdditionalUsers(Handle);
		}

		public void SetEnqueueDataSettings(string key, int value)
		{
			CAPI.ovr_MatchmakingOptions_SetEnqueueDataSettingsInt(Handle, key, value);
		}

		public void SetEnqueueDataSettings(string key, double value)
		{
			CAPI.ovr_MatchmakingOptions_SetEnqueueDataSettingsDouble(Handle, key, value);
		}

		public void SetEnqueueDataSettings(string key, string value)
		{
			CAPI.ovr_MatchmakingOptions_SetEnqueueDataSettingsString(Handle, key, value);
		}

		public void ClearEnqueueDataSettings()
		{
			CAPI.ovr_MatchmakingOptions_ClearEnqueueDataSettings(Handle);
		}

		public void SetEnqueueIsDebug(bool value)
		{
			CAPI.ovr_MatchmakingOptions_SetEnqueueIsDebug(Handle, value);
		}

		public void SetEnqueueQueryKey(string value)
		{
			CAPI.ovr_MatchmakingOptions_SetEnqueueQueryKey(Handle, value);
		}

		public static explicit operator IntPtr(MatchmakingOptions options)
		{
			return options?.Handle ?? IntPtr.Zero;
		}

		~MatchmakingOptions()
		{
			CAPI.ovr_MatchmakingOptions_Destroy(Handle);
		}
	}
	public enum MatchmakingStatApproach
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("TRAILING")]
		Trailing,
		[Description("SWINGY")]
		Swingy
	}
	public enum MediaContentType
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("PHOTO")]
		Photo
	}
	public abstract class Message<T> : Message
	{
		public new delegate void Callback(Message<T> message);

		private T data;

		public T Data => data;

		public Message(IntPtr c_message)
			: base(c_message)
		{
			if (!base.IsError)
			{
				data = GetDataFromMessage(c_message);
			}
		}

		protected abstract T GetDataFromMessage(IntPtr c_message);
	}
	public class Message
	{
		public delegate void Callback(Message message);

		public enum MessageType : uint
		{
			Unknown = 0u,
			Achievements_AddCount = 65495601u,
			Achievements_AddFields = 346693929u,
			Achievements_GetAllDefinitions = 64177549u,
			Achievements_GetAllProgress = 1335877149u,
			Achievements_GetDefinitionsByName = 1653670332u,
			Achievements_GetNextAchievementDefinitionArrayPage = 712888917u,
			Achievements_GetNextAchievementProgressArrayPage = 792913703u,
			Achievements_GetProgressByName = 354837425u,
			Achievements_Unlock = 1497156573u,
			ApplicationLifecycle_GetRegisteredPIDs = 82169698u,
			ApplicationLifecycle_GetSessionKey = 984570141u,
			ApplicationLifecycle_RegisterSessionKey = 1303818232u,
			Application_GetVersion = 1751583246u,
			Application_LaunchOtherApp = 1424151032u,
			AssetFile_Delete = 1834842246u,
			AssetFile_DeleteById = 1525206354u,
			AssetFile_DeleteByName = 1108001231u,
			AssetFile_Download = 289710021u,
			AssetFile_DownloadById = 755009938u,
			AssetFile_DownloadByName = 1664536314u,
			AssetFile_DownloadCancel = 134927303u,
			AssetFile_DownloadCancelById = 1365611796u,
			AssetFile_DownloadCancelByName = 1147858170u,
			AssetFile_GetList = 1258057588u,
			AssetFile_Status = 47394656u,
			AssetFile_StatusById = 1570069816u,
			AssetFile_StatusByName = 1104140880u,
			CloudStorage2_GetUserDirectoryPath = 1990471406u,
			CloudStorage_Delete = 685393261u,
			CloudStorage_GetNextCloudStorageMetadataArrayPage = 1544004335u,
			CloudStorage_Load = 1082420033u,
			CloudStorage_LoadBucketMetadata = 1931977997u,
			CloudStorage_LoadConflictMetadata = 1146770162u,
			CloudStorage_LoadHandle = 845863478u,
			CloudStorage_LoadMetadata = 65446546u,
			CloudStorage_ResolveKeepLocal = 811109637u,
			CloudStorage_ResolveKeepRemote = 1965400838u,
			CloudStorage_Save = 1270570030u,
			Entitlement_GetIsViewerEntitled = 409688241u,
			IAP_ConsumePurchase = 532378329u,
			IAP_GetNextProductArrayPage = 467225263u,
			IAP_GetNextPurchaseArrayPage = 1196886677u,
			IAP_GetProductsBySKU = 2124073717u,
			IAP_GetViewerPurchases = 974095385u,
			IAP_GetViewerPurchasesDurableCache = 1666817579u,
			IAP_LaunchCheckoutFlow = 1067126029u,
			LanguagePack_GetCurrent = 529592533u,
			LanguagePack_SetCurrent = 1531952096u,
			Leaderboard_GetEntries = 1572030284u,
			Leaderboard_GetEntriesAfterRank = 406293487u,
			Leaderboard_GetNextEntries = 1310751961u,
			Leaderboard_GetPreviousEntries = 1224858304u,
			Leaderboard_WriteEntry = 293587198u,
			Livestreaming_GetStatus = 1218079125u,
			Livestreaming_PauseStream = 916223619u,
			Livestreaming_ResumeStream = 575827343u,
			Matchmaking_Browse = 509948616u,
			Matchmaking_Browse2 = 1715641947u,
			Matchmaking_Cancel = 543705519u,
			Matchmaking_Cancel2 = 285117908u,
			Matchmaking_CreateAndEnqueueRoom = 1615617480u,
			Matchmaking_CreateAndEnqueueRoom2 = 693889755u,
			Matchmaking_CreateRoom = 54203178u,
			Matchmaking_CreateRoom2 = 1231922052u,
			Matchmaking_Enqueue = 1086418033u,
			Matchmaking_Enqueue2 = 303174325u,
			Matchmaking_EnqueueRoom = 1888108644u,
			Matchmaking_EnqueueRoom2 = 1428741028u,
			Matchmaking_GetAdminSnapshot = 1008820116u,
			Matchmaking_GetStats = 1123849272u,
			Matchmaking_JoinRoom = 1295177725u,
			Matchmaking_ReportResultInsecure = 439800205u,
			Matchmaking_StartMatch = 1154746693u,
			Media_ShareToFacebook = 14912239u,
			Notification_GetNextRoomInviteNotificationArrayPage = 102890359u,
			Notification_GetRoomInvites = 1871801234u,
			Notification_MarkAsRead = 1903319523u,
			Party_GetCurrent = 1200830304u,
			RichPresence_Clear = 1471632051u,
			RichPresence_GetDestinations = 1483681044u,
			RichPresence_GetNextDestinationArrayPage = 1731624773u,
			RichPresence_Set = 1007973641u,
			Room_CreateAndJoinPrivate = 1977017207u,
			Room_CreateAndJoinPrivate2 = 1513775683u,
			Room_Get = 1704628152u,
			Room_GetCurrent = 161916164u,
			Room_GetCurrentForUser = 234887141u,
			Room_GetInvitableUsers = 506615698u,
			Room_GetInvitableUsers2 = 1330899120u,
			Room_GetModeratedRooms = 159645047u,
			Room_GetNextRoomArrayPage = 1317239238u,
			Room_InviteUser = 1093266451u,
			Room_Join = 382373641u,
			Room_Join2 = 1303059522u,
			Room_KickUser = 1233344310u,
			Room_LaunchInvitableUserFlow = 843047539u,
			Room_Leave = 1916281973u,
			Room_SetDescription = 809796911u,
			Room_UpdateDataStore = 40779816u,
			Room_UpdateMembershipLockStatus = 923514796u,
			Room_UpdateOwner = 850803997u,
			Room_UpdatePrivateRoomJoinPolicy = 289473179u,
			User_Get = 1808768583u,
			User_GetAccessToken = 111696574u,
			User_GetLoggedInUser = 1131361373u,
			User_GetLoggedInUserFriends = 1484532365u,
			User_GetLoggedInUserFriendsAndRooms = 1585908615u,
			User_GetLoggedInUserRecentlyMetUsersAndRooms = 694139440u,
			User_GetNextUserAndRoomArrayPage = 2143146719u,
			User_GetNextUserArrayPage = 645723971u,
			User_GetOrgScopedID = 418426907u,
			User_GetSdkAccounts = 1733454467u,
			User_GetUserProof = 578880643u,
			User_LaunchFriendRequestFlow = 151303576u,
			User_LaunchProfile = 171537047u,
			Voip_SetSystemVoipSuppressed = 1161808298u,
			Notification_ApplicationLifecycle_LaunchIntentChanged = 78859427u,
			Notification_AssetFile_DownloadUpdate = 803015885u,
			Notification_Cal_FinalizeApplication = 1963741337u,
			Notification_Cal_ProposeApplication = 779375093u,
			Notification_HTTP_Transfer = 2111073839u,
			Notification_Livestreaming_StatusChange = 575101294u,
			Notification_Matchmaking_MatchFound = 197393623u,
			Notification_NetSync_ConnectionStatusChanged = 120882378u,
			Notification_NetSync_SessionsChanged = 947814198u,
			Notification_Networking_ConnectionStateChange = 1577243802u,
			Notification_Networking_PeerConnectRequest = 1295114959u,
			Notification_Networking_PingResult = 1360343058u,
			Notification_Party_PartyUpdate = 487688882u,
			Notification_Room_InviteAccepted = 1829794225u,
			Notification_Room_InviteReceived = 1783209300u,
			Notification_Room_RoomUpdate = 1626094639u,
			Notification_Voip_ConnectRequest = 908343318u,
			Notification_Voip_StateChange = 888120928u,
			Notification_Voip_SystemVoipState = 1490179237u,
			Platform_InitializeWithAccessToken = 896085803u,
			Platform_InitializeStandaloneOculus = 1375260172u,
			Platform_InitializeAndroidAsynchronous = 450037684u,
			Platform_InitializeWindowsAsynchronous = 1839708815u
		}

		internal delegate Message ExtraMessageTypesHandler(IntPtr messageHandle, MessageType message_type);

		private MessageType type;

		private ulong requestID;

		private Oculus.Platform.Models.Error error;

		public MessageType Type => type;

		public bool IsError => error != null;

		public ulong RequestID => requestID;

		internal static ExtraMessageTypesHandler HandleExtraMessageTypes { private get; set; }

		public Message(IntPtr c_message)
		{
			type = CAPI.ovr_Message_GetType(c_message);
			bool num = CAPI.ovr_Message_IsError(c_message);
			requestID = CAPI.ovr_Message_GetRequestID(c_message);
			if (num)
			{
				IntPtr obj = CAPI.ovr_Message_GetError(c_message);
				error = new Oculus.Platform.Models.Error(CAPI.ovr_Error_GetCode(obj), CAPI.ovr_Error_GetMessage(obj), CAPI.ovr_Error_GetHttpCode(obj));
			}
			else if (Core.LogMessages)
			{
				string text = CAPI.ovr_Message_GetString(c_message);
				if (text != null)
				{
					UnityEngine.Debug.Log(text);
				}
				else
				{
					UnityEngine.Debug.Log($"null message string {c_message}");
				}
			}
		}

		~Message()
		{
		}

		public virtual Oculus.Platform.Models.Error GetError()
		{
			return error;
		}

		public virtual PingResult GetPingResult()
		{
			return null;
		}

		public virtual NetworkingPeer GetNetworkingPeer()
		{
			return null;
		}

		public virtual HttpTransferUpdate GetHttpTransferUpdate()
		{
			return null;
		}

		public virtual PlatformInitialize GetPlatformInitialize()
		{
			return null;
		}

		public virtual AbuseReportRecording GetAbuseReportRecording()
		{
			return null;
		}

		public virtual AchievementDefinitionList GetAchievementDefinitions()
		{
			return null;
		}

		public virtual AchievementProgressList GetAchievementProgressList()
		{
			return null;
		}

		public virtual AchievementUpdate GetAchievementUpdate()
		{
			return null;
		}

		public virtual ApplicationVersion GetApplicationVersion()
		{
			return null;
		}

		public virtual AssetDetails GetAssetDetails()
		{
			return null;
		}

		public virtual AssetDetailsList GetAssetDetailsList()
		{
			return null;
		}

		public virtual AssetFileDeleteResult GetAssetFileDeleteResult()
		{
			return null;
		}

		public virtual AssetFileDownloadCancelResult GetAssetFileDownloadCancelResult()
		{
			return null;
		}

		public virtual AssetFileDownloadResult GetAssetFileDownloadResult()
		{
			return null;
		}

		public virtual AssetFileDownloadUpdate GetAssetFileDownloadUpdate()
		{
			return null;
		}

		public virtual CalApplicationFinalized GetCalApplicationFinalized()
		{
			return null;
		}

		public virtual CalApplicationProposed GetCalApplicationProposed()
		{
			return null;
		}

		public virtual CalApplicationSuggestionList GetCalApplicationSuggestionList()
		{
			return null;
		}

		public virtual CloudStorageConflictMetadata GetCloudStorageConflictMetadata()
		{
			return null;
		}

		public virtual CloudStorageData GetCloudStorageData()
		{
			return null;
		}

		public virtual CloudStorageMetadata GetCloudStorageMetadata()
		{
			return null;
		}

		public virtual CloudStorageMetadataList GetCloudStorageMetadataList()
		{
			return null;
		}

		public virtual CloudStorageUpdateResponse GetCloudStorageUpdateResponse()
		{
			return null;
		}

		public virtual DestinationList GetDestinationList()
		{
			return null;
		}

		public virtual InstalledApplicationList GetInstalledApplicationList()
		{
			return null;
		}

		public virtual LaunchBlockFlowResult GetLaunchBlockFlowResult()
		{
			return null;
		}

		public virtual LaunchFriendRequestFlowResult GetLaunchFriendRequestFlowResult()
		{
			return null;
		}

		public virtual LaunchReportFlowResult GetLaunchReportFlowResult()
		{
			return null;
		}

		public virtual LaunchUnblockFlowResult GetLaunchUnblockFlowResult()
		{
			return null;
		}

		public virtual bool GetLeaderboardDidUpdate()
		{
			return false;
		}

		public virtual LeaderboardEntryList GetLeaderboardEntryList()
		{
			return null;
		}

		public virtual LinkedAccountList GetLinkedAccountList()
		{
			return null;
		}

		public virtual LivestreamingApplicationStatus GetLivestreamingApplicationStatus()
		{
			return null;
		}

		public virtual LivestreamingStartResult GetLivestreamingStartResult()
		{
			return null;
		}

		public virtual LivestreamingStatus GetLivestreamingStatus()
		{
			return null;
		}

		public virtual LivestreamingVideoStats GetLivestreamingVideoStats()
		{
			return null;
		}

		public virtual MatchmakingAdminSnapshot GetMatchmakingAdminSnapshot()
		{
			return null;
		}

		public virtual MatchmakingBrowseResult GetMatchmakingBrowseResult()
		{
			return null;
		}

		public virtual MatchmakingEnqueueResult GetMatchmakingEnqueueResult()
		{
			return null;
		}

		public virtual MatchmakingEnqueueResultAndRoom GetMatchmakingEnqueueResultAndRoom()
		{
			return null;
		}

		public virtual MatchmakingStats GetMatchmakingStats()
		{
			return null;
		}

		public virtual NetSyncConnection GetNetSyncConnection()
		{
			return null;
		}

		public virtual NetSyncSessionList GetNetSyncSessionList()
		{
			return null;
		}

		public virtual NetSyncSessionsChangedNotification GetNetSyncSessionsChangedNotification()
		{
			return null;
		}

		public virtual NetSyncSetSessionPropertyResult GetNetSyncSetSessionPropertyResult()
		{
			return null;
		}

		public virtual OrgScopedID GetOrgScopedID()
		{
			return null;
		}

		public virtual Party GetParty()
		{
			return null;
		}

		public virtual PartyID GetPartyID()
		{
			return null;
		}

		public virtual PartyUpdateNotification GetPartyUpdateNotification()
		{
			return null;
		}

		public virtual PidList GetPidList()
		{
			return null;
		}

		public virtual ProductList GetProductList()
		{
			return null;
		}

		public virtual Purchase GetPurchase()
		{
			return null;
		}

		public virtual PurchaseList GetPurchaseList()
		{
			return null;
		}

		public virtual Oculus.Platform.Models.Room GetRoom()
		{
			return null;
		}

		public virtual RoomInviteNotification GetRoomInviteNotification()
		{
			return null;
		}

		public virtual RoomInviteNotificationList GetRoomInviteNotificationList()
		{
			return null;
		}

		public virtual RoomList GetRoomList()
		{
			return null;
		}

		public virtual SdkAccountList GetSdkAccountList()
		{
			return null;
		}

		public virtual ShareMediaResult GetShareMediaResult()
		{
			return null;
		}

		public virtual string GetString()
		{
			return null;
		}

		public virtual SystemPermission GetSystemPermission()
		{
			return null;
		}

		public virtual SystemVoipState GetSystemVoipState()
		{
			return null;
		}

		public virtual User GetUser()
		{
			return null;
		}

		public virtual UserAndRoomList GetUserAndRoomList()
		{
			return null;
		}

		public virtual UserList GetUserList()
		{
			return null;
		}

		public virtual UserProof GetUserProof()
		{
			return null;
		}

		public virtual UserReportID GetUserReportID()
		{
			return null;
		}

		internal static Message ParseMessageHandle(IntPtr messageHandle)
		{
			if (messageHandle.ToInt64() == 0L)
			{
				return null;
			}
			Message message = null;
			MessageType messageType = CAPI.ovr_Message_GetType(messageHandle);
			switch (messageType)
			{
			case MessageType.Achievements_GetAllDefinitions:
			case MessageType.Achievements_GetNextAchievementDefinitionArrayPage:
			case MessageType.Achievements_GetDefinitionsByName:
				message = new MessageWithAchievementDefinitions(messageHandle);
				break;
			case MessageType.Achievements_GetProgressByName:
			case MessageType.Achievements_GetNextAchievementProgressArrayPage:
			case MessageType.Achievements_GetAllProgress:
				message = new MessageWithAchievementProgressList(messageHandle);
				break;
			case MessageType.Achievements_AddCount:
			case MessageType.Achievements_AddFields:
			case MessageType.Achievements_Unlock:
				message = new MessageWithAchievementUpdate(messageHandle);
				break;
			case MessageType.Application_GetVersion:
				message = new MessageWithApplicationVersion(messageHandle);
				break;
			case MessageType.AssetFile_Status:
			case MessageType.LanguagePack_GetCurrent:
			case MessageType.AssetFile_StatusByName:
			case MessageType.AssetFile_StatusById:
				message = new MessageWithAssetDetails(messageHandle);
				break;
			case MessageType.AssetFile_GetList:
				message = new MessageWithAssetDetailsList(messageHandle);
				break;
			case MessageType.AssetFile_DeleteByName:
			case MessageType.AssetFile_DeleteById:
			case MessageType.AssetFile_Delete:
				message = new MessageWithAssetFileDeleteResult(messageHandle);
				break;
			case MessageType.AssetFile_DownloadCancel:
			case MessageType.AssetFile_DownloadCancelByName:
			case MessageType.AssetFile_DownloadCancelById:
				message = new MessageWithAssetFileDownloadCancelResult(messageHandle);
				break;
			case MessageType.AssetFile_Download:
			case MessageType.AssetFile_DownloadById:
			case MessageType.LanguagePack_SetCurrent:
			case MessageType.AssetFile_DownloadByName:
				message = new MessageWithAssetFileDownloadResult(messageHandle);
				break;
			case MessageType.Notification_AssetFile_DownloadUpdate:
				message = new MessageWithAssetFileDownloadUpdate(messageHandle);
				break;
			case MessageType.Notification_Cal_FinalizeApplication:
				message = new MessageWithCalApplicationFinalized(messageHandle);
				break;
			case MessageType.Notification_Cal_ProposeApplication:
				message = new MessageWithCalApplicationProposed(messageHandle);
				break;
			case MessageType.CloudStorage_LoadConflictMetadata:
				message = new MessageWithCloudStorageConflictMetadata(messageHandle);
				break;
			case MessageType.CloudStorage_LoadHandle:
			case MessageType.CloudStorage_Load:
				message = new MessageWithCloudStorageData(messageHandle);
				break;
			case MessageType.CloudStorage_LoadMetadata:
				message = new MessageWithCloudStorageMetadataUnderLocal(messageHandle);
				break;
			case MessageType.CloudStorage_GetNextCloudStorageMetadataArrayPage:
			case MessageType.CloudStorage_LoadBucketMetadata:
				message = new MessageWithCloudStorageMetadataList(messageHandle);
				break;
			case MessageType.CloudStorage_Delete:
			case MessageType.CloudStorage_ResolveKeepLocal:
			case MessageType.CloudStorage_Save:
			case MessageType.CloudStorage_ResolveKeepRemote:
				message = new MessageWithCloudStorageUpdateResponse(messageHandle);
				break;
			case MessageType.RichPresence_GetDestinations:
			case MessageType.RichPresence_GetNextDestinationArrayPage:
				message = new MessageWithDestinationList(messageHandle);
				break;
			case MessageType.User_LaunchProfile:
			case MessageType.Matchmaking_Cancel2:
			case MessageType.Entitlement_GetIsViewerEntitled:
			case MessageType.Matchmaking_ReportResultInsecure:
			case MessageType.IAP_ConsumePurchase:
			case MessageType.Matchmaking_Cancel:
			case MessageType.Room_LaunchInvitableUserFlow:
			case MessageType.Room_UpdateOwner:
			case MessageType.RichPresence_Set:
			case MessageType.Matchmaking_StartMatch:
			case MessageType.ApplicationLifecycle_RegisterSessionKey:
			case MessageType.RichPresence_Clear:
			case MessageType.Notification_MarkAsRead:
				message = new Message(messageHandle);
				break;
			case MessageType.User_LaunchFriendRequestFlow:
				message = new MessageWithLaunchFriendRequestFlowResult(messageHandle);
				break;
			case MessageType.Leaderboard_GetEntriesAfterRank:
			case MessageType.Leaderboard_GetPreviousEntries:
			case MessageType.Leaderboard_GetNextEntries:
			case MessageType.Leaderboard_GetEntries:
				message = new MessageWithLeaderboardEntryList(messageHandle);
				break;
			case MessageType.Leaderboard_WriteEntry:
				message = new MessageWithLeaderboardDidUpdate(messageHandle);
				break;
			case MessageType.Notification_Livestreaming_StatusChange:
			case MessageType.Livestreaming_ResumeStream:
			case MessageType.Livestreaming_PauseStream:
			case MessageType.Livestreaming_GetStatus:
				message = new MessageWithLivestreamingStatus(messageHandle);
				break;
			case MessageType.Matchmaking_GetAdminSnapshot:
				message = new MessageWithMatchmakingAdminSnapshot(messageHandle);
				break;
			case MessageType.Matchmaking_Browse:
			case MessageType.Matchmaking_Browse2:
				message = new MessageWithMatchmakingBrowseResult(messageHandle);
				break;
			case MessageType.Matchmaking_Enqueue2:
			case MessageType.Matchmaking_Enqueue:
			case MessageType.Matchmaking_EnqueueRoom2:
			case MessageType.Matchmaking_EnqueueRoom:
				message = new MessageWithMatchmakingEnqueueResult(messageHandle);
				break;
			case MessageType.Matchmaking_CreateAndEnqueueRoom2:
			case MessageType.Matchmaking_CreateAndEnqueueRoom:
				message = new MessageWithMatchmakingEnqueueResultAndRoom(messageHandle);
				break;
			case MessageType.Matchmaking_GetStats:
				message = new MessageWithMatchmakingStatsUnderMatchmakingStats(messageHandle);
				break;
			case MessageType.Notification_NetSync_ConnectionStatusChanged:
				message = new MessageWithNetSyncConnection(messageHandle);
				break;
			case MessageType.Notification_NetSync_SessionsChanged:
				message = new MessageWithNetSyncSessionsChangedNotification(messageHandle);
				break;
			case MessageType.User_GetOrgScopedID:
				message = new MessageWithOrgScopedID(messageHandle);
				break;
			case MessageType.Party_GetCurrent:
				message = new MessageWithPartyUnderCurrentParty(messageHandle);
				break;
			case MessageType.Notification_Party_PartyUpdate:
				message = new MessageWithPartyUpdateNotification(messageHandle);
				break;
			case MessageType.ApplicationLifecycle_GetRegisteredPIDs:
				message = new MessageWithPidList(messageHandle);
				break;
			case MessageType.IAP_GetNextProductArrayPage:
			case MessageType.IAP_GetProductsBySKU:
				message = new MessageWithProductList(messageHandle);
				break;
			case MessageType.IAP_LaunchCheckoutFlow:
				message = new MessageWithPurchase(messageHandle);
				break;
			case MessageType.IAP_GetViewerPurchases:
			case MessageType.IAP_GetNextPurchaseArrayPage:
			case MessageType.IAP_GetViewerPurchasesDurableCache:
				message = new MessageWithPurchaseList(messageHandle);
				break;
			case MessageType.Room_Get:
				message = new MessageWithRoom(messageHandle);
				break;
			case MessageType.Room_GetCurrent:
			case MessageType.Room_GetCurrentForUser:
				message = new MessageWithRoomUnderCurrentRoom(messageHandle);
				break;
			case MessageType.Room_UpdateDataStore:
			case MessageType.Matchmaking_CreateRoom:
			case MessageType.Room_UpdatePrivateRoomJoinPolicy:
			case MessageType.Room_Join:
			case MessageType.Room_SetDescription:
			case MessageType.Room_UpdateMembershipLockStatus:
			case MessageType.Room_InviteUser:
			case MessageType.Matchmaking_CreateRoom2:
			case MessageType.Room_KickUser:
			case MessageType.Matchmaking_JoinRoom:
			case MessageType.Room_Join2:
			case MessageType.Room_CreateAndJoinPrivate2:
			case MessageType.Notification_Room_RoomUpdate:
			case MessageType.Room_Leave:
			case MessageType.Room_CreateAndJoinPrivate:
				message = new MessageWithRoomUnderViewerRoom(messageHandle);
				break;
			case MessageType.Room_GetModeratedRooms:
			case MessageType.Room_GetNextRoomArrayPage:
				message = new MessageWithRoomList(messageHandle);
				break;
			case MessageType.Notification_Room_InviteReceived:
				message = new MessageWithRoomInviteNotification(messageHandle);
				break;
			case MessageType.Notification_GetNextRoomInviteNotificationArrayPage:
			case MessageType.Notification_GetRoomInvites:
				message = new MessageWithRoomInviteNotificationList(messageHandle);
				break;
			case MessageType.User_GetSdkAccounts:
				message = new MessageWithSdkAccountList(messageHandle);
				break;
			case MessageType.Media_ShareToFacebook:
				message = new MessageWithShareMediaResult(messageHandle);
				break;
			case MessageType.Notification_ApplicationLifecycle_LaunchIntentChanged:
			case MessageType.User_GetAccessToken:
			case MessageType.ApplicationLifecycle_GetSessionKey:
			case MessageType.Application_LaunchOtherApp:
			case MessageType.Notification_Room_InviteAccepted:
			case MessageType.CloudStorage2_GetUserDirectoryPath:
				message = new MessageWithString(messageHandle);
				break;
			case MessageType.Voip_SetSystemVoipSuppressed:
				message = new MessageWithSystemVoipState(messageHandle);
				break;
			case MessageType.User_GetLoggedInUser:
			case MessageType.User_Get:
				message = new MessageWithUser(messageHandle);
				break;
			case MessageType.User_GetLoggedInUserRecentlyMetUsersAndRooms:
			case MessageType.User_GetLoggedInUserFriendsAndRooms:
			case MessageType.User_GetNextUserAndRoomArrayPage:
				message = new MessageWithUserAndRoomList(messageHandle);
				break;
			case MessageType.Room_GetInvitableUsers:
			case MessageType.User_GetNextUserArrayPage:
			case MessageType.Room_GetInvitableUsers2:
			case MessageType.User_GetLoggedInUserFriends:
				message = new MessageWithUserList(messageHandle);
				break;
			case MessageType.User_GetUserProof:
				message = new MessageWithUserProof(messageHandle);
				break;
			case MessageType.Notification_Networking_PeerConnectRequest:
			case MessageType.Notification_Networking_ConnectionStateChange:
				message = new MessageWithNetworkingPeer(messageHandle);
				break;
			case MessageType.Notification_Networking_PingResult:
				message = new MessageWithPingResult(messageHandle);
				break;
			case MessageType.Notification_Matchmaking_MatchFound:
				message = new MessageWithMatchmakingNotification(messageHandle);
				break;
			case MessageType.Notification_Voip_StateChange:
			case MessageType.Notification_Voip_ConnectRequest:
				message = new MessageWithNetworkingPeer(messageHandle);
				break;
			case MessageType.Notification_Voip_SystemVoipState:
				message = new MessageWithSystemVoipState(messageHandle);
				break;
			case MessageType.Notification_HTTP_Transfer:
				message = new MessageWithHttpTransferUpdate(messageHandle);
				break;
			case MessageType.Platform_InitializeAndroidAsynchronous:
			case MessageType.Platform_InitializeWithAccessToken:
			case MessageType.Platform_InitializeStandaloneOculus:
			case MessageType.Platform_InitializeWindowsAsynchronous:
				message = new MessageWithPlatformInitialize(messageHandle);
				break;
			default:
				message = PlatformInternal.ParseMessageHandle(messageHandle, messageType);
				if (message == null)
				{
					UnityEngine.Debug.LogError($"Unrecognized message type {messageType}\n");
				}
				break;
			}
			return message;
		}

		public static Message PopMessage()
		{
			if (!Core.IsInitialized())
			{
				return null;
			}
			IntPtr intPtr = CAPI.ovr_PopMessage();
			Message result = ParseMessageHandle(intPtr);
			CAPI.ovr_FreeMessage(intPtr);
			return result;
		}
	}
	public class MessageWithAbuseReportRecording : Message<AbuseReportRecording>
	{
		public MessageWithAbuseReportRecording(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AbuseReportRecording GetAbuseReportRecording()
		{
			return base.Data;
		}

		protected override AbuseReportRecording GetDataFromMessage(IntPtr c_message)
		{
			return new AbuseReportRecording(CAPI.ovr_Message_GetAbuseReportRecording(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithAchievementDefinitions : Message<AchievementDefinitionList>
	{
		public MessageWithAchievementDefinitions(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AchievementDefinitionList GetAchievementDefinitions()
		{
			return base.Data;
		}

		protected override AchievementDefinitionList GetDataFromMessage(IntPtr c_message)
		{
			return new AchievementDefinitionList(CAPI.ovr_Message_GetAchievementDefinitionArray(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithAchievementProgressList : Message<AchievementProgressList>
	{
		public MessageWithAchievementProgressList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AchievementProgressList GetAchievementProgressList()
		{
			return base.Data;
		}

		protected override AchievementProgressList GetDataFromMessage(IntPtr c_message)
		{
			return new AchievementProgressList(CAPI.ovr_Message_GetAchievementProgressArray(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithAchievementUpdate : Message<AchievementUpdate>
	{
		public MessageWithAchievementUpdate(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AchievementUpdate GetAchievementUpdate()
		{
			return base.Data;
		}

		protected override AchievementUpdate GetDataFromMessage(IntPtr c_message)
		{
			return new AchievementUpdate(CAPI.ovr_Message_GetAchievementUpdate(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithApplicationVersion : Message<ApplicationVersion>
	{
		public MessageWithApplicationVersion(IntPtr c_message)
			: base(c_message)
		{
		}

		public override ApplicationVersion GetApplicationVersion()
		{
			return base.Data;
		}

		protected override ApplicationVersion GetDataFromMessage(IntPtr c_message)
		{
			return new ApplicationVersion(CAPI.ovr_Message_GetApplicationVersion(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithAssetDetails : Message<AssetDetails>
	{
		public MessageWithAssetDetails(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AssetDetails GetAssetDetails()
		{
			return base.Data;
		}

		protected override AssetDetails GetDataFromMessage(IntPtr c_message)
		{
			return new AssetDetails(CAPI.ovr_Message_GetAssetDetails(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithAssetDetailsList : Message<AssetDetailsList>
	{
		public MessageWithAssetDetailsList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AssetDetailsList GetAssetDetailsList()
		{
			return base.Data;
		}

		protected override AssetDetailsList GetDataFromMessage(IntPtr c_message)
		{
			return new AssetDetailsList(CAPI.ovr_Message_GetAssetDetailsArray(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithAssetFileDeleteResult : Message<AssetFileDeleteResult>
	{
		public MessageWithAssetFileDeleteResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AssetFileDeleteResult GetAssetFileDeleteResult()
		{
			return base.Data;
		}

		protected override AssetFileDeleteResult GetDataFromMessage(IntPtr c_message)
		{
			return new AssetFileDeleteResult(CAPI.ovr_Message_GetAssetFileDeleteResult(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithAssetFileDownloadCancelResult : Message<AssetFileDownloadCancelResult>
	{
		public MessageWithAssetFileDownloadCancelResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AssetFileDownloadCancelResult GetAssetFileDownloadCancelResult()
		{
			return base.Data;
		}

		protected override AssetFileDownloadCancelResult GetDataFromMessage(IntPtr c_message)
		{
			return new AssetFileDownloadCancelResult(CAPI.ovr_Message_GetAssetFileDownloadCancelResult(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithAssetFileDownloadResult : Message<AssetFileDownloadResult>
	{
		public MessageWithAssetFileDownloadResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AssetFileDownloadResult GetAssetFileDownloadResult()
		{
			return base.Data;
		}

		protected override AssetFileDownloadResult GetDataFromMessage(IntPtr c_message)
		{
			return new AssetFileDownloadResult(CAPI.ovr_Message_GetAssetFileDownloadResult(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithAssetFileDownloadUpdate : Message<AssetFileDownloadUpdate>
	{
		public MessageWithAssetFileDownloadUpdate(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AssetFileDownloadUpdate GetAssetFileDownloadUpdate()
		{
			return base.Data;
		}

		protected override AssetFileDownloadUpdate GetDataFromMessage(IntPtr c_message)
		{
			return new AssetFileDownloadUpdate(CAPI.ovr_Message_GetAssetFileDownloadUpdate(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithCalApplicationFinalized : Message<CalApplicationFinalized>
	{
		public MessageWithCalApplicationFinalized(IntPtr c_message)
			: base(c_message)
		{
		}

		public override CalApplicationFinalized GetCalApplicationFinalized()
		{
			return base.Data;
		}

		protected override CalApplicationFinalized GetDataFromMessage(IntPtr c_message)
		{
			return new CalApplicationFinalized(CAPI.ovr_Message_GetCalApplicationFinalized(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithCalApplicationProposed : Message<CalApplicationProposed>
	{
		public MessageWithCalApplicationProposed(IntPtr c_message)
			: base(c_message)
		{
		}

		public override CalApplicationProposed GetCalApplicationProposed()
		{
			return base.Data;
		}

		protected override CalApplicationProposed GetDataFromMessage(IntPtr c_message)
		{
			return new CalApplicationProposed(CAPI.ovr_Message_GetCalApplicationProposed(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithCalApplicationSuggestionList : Message<CalApplicationSuggestionList>
	{
		public MessageWithCalApplicationSuggestionList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override CalApplicationSuggestionList GetCalApplicationSuggestionList()
		{
			return base.Data;
		}

		protected override CalApplicationSuggestionList GetDataFromMessage(IntPtr c_message)
		{
			return new CalApplicationSuggestionList(CAPI.ovr_Message_GetCalApplicationSuggestionArray(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithCloudStorageConflictMetadata : Message<CloudStorageConflictMetadata>
	{
		public MessageWithCloudStorageConflictMetadata(IntPtr c_message)
			: base(c_message)
		{
		}

		public override CloudStorageConflictMetadata GetCloudStorageConflictMetadata()
		{
			return base.Data;
		}

		protected override CloudStorageConflictMetadata GetDataFromMessage(IntPtr c_message)
		{
			return new CloudStorageConflictMetadata(CAPI.ovr_Message_GetCloudStorageConflictMetadata(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithCloudStorageData : Message<CloudStorageData>
	{
		public MessageWithCloudStorageData(IntPtr c_message)
			: base(c_message)
		{
		}

		public override CloudStorageData GetCloudStorageData()
		{
			return base.Data;
		}

		protected override CloudStorageData GetDataFromMessage(IntPtr c_message)
		{
			return new CloudStorageData(CAPI.ovr_Message_GetCloudStorageData(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithCloudStorageMetadataUnderLocal : Message<CloudStorageMetadata>
	{
		public MessageWithCloudStorageMetadataUnderLocal(IntPtr c_message)
			: base(c_message)
		{
		}

		public override CloudStorageMetadata GetCloudStorageMetadata()
		{
			return base.Data;
		}

		protected override CloudStorageMetadata GetDataFromMessage(IntPtr c_message)
		{
			return new CloudStorageMetadata(CAPI.ovr_Message_GetCloudStorageMetadata(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithCloudStorageMetadataList : Message<CloudStorageMetadataList>
	{
		public MessageWithCloudStorageMetadataList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override CloudStorageMetadataList GetCloudStorageMetadataList()
		{
			return base.Data;
		}

		protected override CloudStorageMetadataList GetDataFromMessage(IntPtr c_message)
		{
			return new CloudStorageMetadataList(CAPI.ovr_Message_GetCloudStorageMetadataArray(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithCloudStorageUpdateResponse : Message<CloudStorageUpdateResponse>
	{
		public MessageWithCloudStorageUpdateResponse(IntPtr c_message)
			: base(c_message)
		{
		}

		public override CloudStorageUpdateResponse GetCloudStorageUpdateResponse()
		{
			return base.Data;
		}

		protected override CloudStorageUpdateResponse GetDataFromMessage(IntPtr c_message)
		{
			return new CloudStorageUpdateResponse(CAPI.ovr_Message_GetCloudStorageUpdateResponse(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithDestinationList : Message<DestinationList>
	{
		public MessageWithDestinationList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override DestinationList GetDestinationList()
		{
			return base.Data;
		}

		protected override DestinationList GetDataFromMessage(IntPtr c_message)
		{
			return new DestinationList(CAPI.ovr_Message_GetDestinationArray(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithInstalledApplicationList : Message<InstalledApplicationList>
	{
		public MessageWithInstalledApplicationList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override InstalledApplicationList GetInstalledApplicationList()
		{
			return base.Data;
		}

		protected override InstalledApplicationList GetDataFromMessage(IntPtr c_message)
		{
			return new InstalledApplicationList(CAPI.ovr_Message_GetInstalledApplicationArray(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithLaunchBlockFlowResult : Message<LaunchBlockFlowResult>
	{
		public MessageWithLaunchBlockFlowResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LaunchBlockFlowResult GetLaunchBlockFlowResult()
		{
			return base.Data;
		}

		protected override LaunchBlockFlowResult GetDataFromMessage(IntPtr c_message)
		{
			return new LaunchBlockFlowResult(CAPI.ovr_Message_GetLaunchBlockFlowResult(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithLaunchFriendRequestFlowResult : Message<LaunchFriendRequestFlowResult>
	{
		public MessageWithLaunchFriendRequestFlowResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LaunchFriendRequestFlowResult GetLaunchFriendRequestFlowResult()
		{
			return base.Data;
		}

		protected override LaunchFriendRequestFlowResult GetDataFromMessage(IntPtr c_message)
		{
			return new LaunchFriendRequestFlowResult(CAPI.ovr_Message_GetLaunchFriendRequestFlowResult(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithLaunchReportFlowResult : Message<LaunchReportFlowResult>
	{
		public MessageWithLaunchReportFlowResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LaunchReportFlowResult GetLaunchReportFlowResult()
		{
			return base.Data;
		}

		protected override LaunchReportFlowResult GetDataFromMessage(IntPtr c_message)
		{
			return new LaunchReportFlowResult(CAPI.ovr_Message_GetLaunchReportFlowResult(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithLaunchUnblockFlowResult : Message<LaunchUnblockFlowResult>
	{
		public MessageWithLaunchUnblockFlowResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LaunchUnblockFlowResult GetLaunchUnblockFlowResult()
		{
			return base.Data;
		}

		protected override LaunchUnblockFlowResult GetDataFromMessage(IntPtr c_message)
		{
			return new LaunchUnblockFlowResult(CAPI.ovr_Message_GetLaunchUnblockFlowResult(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithLeaderboardEntryList : Message<LeaderboardEntryList>
	{
		public MessageWithLeaderboardEntryList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LeaderboardEntryList GetLeaderboardEntryList()
		{
			return base.Data;
		}

		protected override LeaderboardEntryList GetDataFromMessage(IntPtr c_message)
		{
			return new LeaderboardEntryList(CAPI.ovr_Message_GetLeaderboardEntryArray(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithLinkedAccountList : Message<LinkedAccountList>
	{
		public MessageWithLinkedAccountList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LinkedAccountList GetLinkedAccountList()
		{
			return base.Data;
		}

		protected override LinkedAccountList GetDataFromMessage(IntPtr c_message)
		{
			return new LinkedAccountList(CAPI.ovr_Message_GetLinkedAccountArray(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithLivestreamingApplicationStatus : Message<LivestreamingApplicationStatus>
	{
		public MessageWithLivestreamingApplicationStatus(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LivestreamingApplicationStatus GetLivestreamingApplicationStatus()
		{
			return base.Data;
		}

		protected override LivestreamingApplicationStatus GetDataFromMessage(IntPtr c_message)
		{
			return new LivestreamingApplicationStatus(CAPI.ovr_Message_GetLivestreamingApplicationStatus(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithLivestreamingStartResult : Message<LivestreamingStartResult>
	{
		public MessageWithLivestreamingStartResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LivestreamingStartResult GetLivestreamingStartResult()
		{
			return base.Data;
		}

		protected override LivestreamingStartResult GetDataFromMessage(IntPtr c_message)
		{
			return new LivestreamingStartResult(CAPI.ovr_Message_GetLivestreamingStartResult(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithLivestreamingStatus : Message<LivestreamingStatus>
	{
		public MessageWithLivestreamingStatus(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LivestreamingStatus GetLivestreamingStatus()
		{
			return base.Data;
		}

		protected override LivestreamingStatus GetDataFromMessage(IntPtr c_message)
		{
			return new LivestreamingStatus(CAPI.ovr_Message_GetLivestreamingStatus(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithLivestreamingVideoStats : Message<LivestreamingVideoStats>
	{
		public MessageWithLivestreamingVideoStats(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LivestreamingVideoStats GetLivestreamingVideoStats()
		{
			return base.Data;
		}

		protected override LivestreamingVideoStats GetDataFromMessage(IntPtr c_message)
		{
			return new LivestreamingVideoStats(CAPI.ovr_Message_GetLivestreamingVideoStats(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithMatchmakingAdminSnapshot : Message<MatchmakingAdminSnapshot>
	{
		public MessageWithMatchmakingAdminSnapshot(IntPtr c_message)
			: base(c_message)
		{
		}

		public override MatchmakingAdminSnapshot GetMatchmakingAdminSnapshot()
		{
			return base.Data;
		}

		protected override MatchmakingAdminSnapshot GetDataFromMessage(IntPtr c_message)
		{
			return new MatchmakingAdminSnapshot(CAPI.ovr_Message_GetMatchmakingAdminSnapshot(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithMatchmakingEnqueueResult : Message<MatchmakingEnqueueResult>
	{
		public MessageWithMatchmakingEnqueueResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override MatchmakingEnqueueResult GetMatchmakingEnqueueResult()
		{
			return base.Data;
		}

		protected override MatchmakingEnqueueResult GetDataFromMessage(IntPtr c_message)
		{
			return new MatchmakingEnqueueResult(CAPI.ovr_Message_GetMatchmakingEnqueueResult(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithMatchmakingEnqueueResultAndRoom : Message<MatchmakingEnqueueResultAndRoom>
	{
		public MessageWithMatchmakingEnqueueResultAndRoom(IntPtr c_message)
			: base(c_message)
		{
		}

		public override MatchmakingEnqueueResultAndRoom GetMatchmakingEnqueueResultAndRoom()
		{
			return base.Data;
		}

		protected override MatchmakingEnqueueResultAndRoom GetDataFromMessage(IntPtr c_message)
		{
			return new MatchmakingEnqueueResultAndRoom(CAPI.ovr_Message_GetMatchmakingEnqueueResultAndRoom(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithMatchmakingStatsUnderMatchmakingStats : Message<MatchmakingStats>
	{
		public MessageWithMatchmakingStatsUnderMatchmakingStats(IntPtr c_message)
			: base(c_message)
		{
		}

		public override MatchmakingStats GetMatchmakingStats()
		{
			return base.Data;
		}

		protected override MatchmakingStats GetDataFromMessage(IntPtr c_message)
		{
			return new MatchmakingStats(CAPI.ovr_Message_GetMatchmakingStats(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithNetSyncConnection : Message<NetSyncConnection>
	{
		public MessageWithNetSyncConnection(IntPtr c_message)
			: base(c_message)
		{
		}

		public override NetSyncConnection GetNetSyncConnection()
		{
			return base.Data;
		}

		protected override NetSyncConnection GetDataFromMessage(IntPtr c_message)
		{
			return new NetSyncConnection(CAPI.ovr_Message_GetNetSyncConnection(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithNetSyncSessionList : Message<NetSyncSessionList>
	{
		public MessageWithNetSyncSessionList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override NetSyncSessionList GetNetSyncSessionList()
		{
			return base.Data;
		}

		protected override NetSyncSessionList GetDataFromMessage(IntPtr c_message)
		{
			return new NetSyncSessionList(CAPI.ovr_Message_GetNetSyncSessionArray(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithNetSyncSessionsChangedNotification : Message<NetSyncSessionsChangedNotification>
	{
		public MessageWithNetSyncSessionsChangedNotification(IntPtr c_message)
			: base(c_message)
		{
		}

		public override NetSyncSessionsChangedNotification GetNetSyncSessionsChangedNotification()
		{
			return base.Data;
		}

		protected override NetSyncSessionsChangedNotification GetDataFromMessage(IntPtr c_message)
		{
			return new NetSyncSessionsChangedNotification(CAPI.ovr_Message_GetNetSyncSessionsChangedNotification(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithNetSyncSetSessionPropertyResult : Message<NetSyncSetSessionPropertyResult>
	{
		public MessageWithNetSyncSetSessionPropertyResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override NetSyncSetSessionPropertyResult GetNetSyncSetSessionPropertyResult()
		{
			return base.Data;
		}

		protected override NetSyncSetSessionPropertyResult GetDataFromMessage(IntPtr c_message)
		{
			return new NetSyncSetSessionPropertyResult(CAPI.ovr_Message_GetNetSyncSetSessionPropertyResult(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithOrgScopedID : Message<OrgScopedID>
	{
		public MessageWithOrgScopedID(IntPtr c_message)
			: base(c_message)
		{
		}

		public override OrgScopedID GetOrgScopedID()
		{
			return base.Data;
		}

		protected override OrgScopedID GetDataFromMessage(IntPtr c_message)
		{
			return new OrgScopedID(CAPI.ovr_Message_GetOrgScopedID(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithParty : Message<Party>
	{
		public MessageWithParty(IntPtr c_message)
			: base(c_message)
		{
		}

		public override Party GetParty()
		{
			return base.Data;
		}

		protected override Party GetDataFromMessage(IntPtr c_message)
		{
			return new Party(CAPI.ovr_Message_GetParty(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithPartyUnderCurrentParty : Message<Party>
	{
		public MessageWithPartyUnderCurrentParty(IntPtr c_message)
			: base(c_message)
		{
		}

		public override Party GetParty()
		{
			return base.Data;
		}

		protected override Party GetDataFromMessage(IntPtr c_message)
		{
			return new Party(CAPI.ovr_Message_GetParty(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithPartyID : Message<PartyID>
	{
		public MessageWithPartyID(IntPtr c_message)
			: base(c_message)
		{
		}

		public override PartyID GetPartyID()
		{
			return base.Data;
		}

		protected override PartyID GetDataFromMessage(IntPtr c_message)
		{
			return new PartyID(CAPI.ovr_Message_GetPartyID(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithPartyUpdateNotification : Message<PartyUpdateNotification>
	{
		public MessageWithPartyUpdateNotification(IntPtr c_message)
			: base(c_message)
		{
		}

		public override PartyUpdateNotification GetPartyUpdateNotification()
		{
			return base.Data;
		}

		protected override PartyUpdateNotification GetDataFromMessage(IntPtr c_message)
		{
			return new PartyUpdateNotification(CAPI.ovr_Message_GetPartyUpdateNotification(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithPidList : Message<PidList>
	{
		public MessageWithPidList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override PidList GetPidList()
		{
			return base.Data;
		}

		protected override PidList GetDataFromMessage(IntPtr c_message)
		{
			return new PidList(CAPI.ovr_Message_GetPidArray(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithProductList : Message<ProductList>
	{
		public MessageWithProductList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override ProductList GetProductList()
		{
			return base.Data;
		}

		protected override ProductList GetDataFromMessage(IntPtr c_message)
		{
			return new ProductList(CAPI.ovr_Message_GetProductArray(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithPurchase : Message<Purchase>
	{
		public MessageWithPurchase(IntPtr c_message)
			: base(c_message)
		{
		}

		public override Purchase GetPurchase()
		{
			return base.Data;
		}

		protected override Purchase GetDataFromMessage(IntPtr c_message)
		{
			return new Purchase(CAPI.ovr_Message_GetPurchase(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithPurchaseList : Message<PurchaseList>
	{
		public MessageWithPurchaseList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override PurchaseList GetPurchaseList()
		{
			return base.Data;
		}

		protected override PurchaseList GetDataFromMessage(IntPtr c_message)
		{
			return new PurchaseList(CAPI.ovr_Message_GetPurchaseArray(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithRoom : Message<Oculus.Platform.Models.Room>
	{
		public MessageWithRoom(IntPtr c_message)
			: base(c_message)
		{
		}

		public override Oculus.Platform.Models.Room GetRoom()
		{
			return base.Data;
		}

		protected override Oculus.Platform.Models.Room GetDataFromMessage(IntPtr c_message)
		{
			return new Oculus.Platform.Models.Room(CAPI.ovr_Message_GetRoom(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithRoomUnderCurrentRoom : Message<Oculus.Platform.Models.Room>
	{
		public MessageWithRoomUnderCurrentRoom(IntPtr c_message)
			: base(c_message)
		{
		}

		public override Oculus.Platform.Models.Room GetRoom()
		{
			return base.Data;
		}

		protected override Oculus.Platform.Models.Room GetDataFromMessage(IntPtr c_message)
		{
			return new Oculus.Platform.Models.Room(CAPI.ovr_Message_GetRoom(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithRoomUnderViewerRoom : Message<Oculus.Platform.Models.Room>
	{
		public MessageWithRoomUnderViewerRoom(IntPtr c_message)
			: base(c_message)
		{
		}

		public override Oculus.Platform.Models.Room GetRoom()
		{
			return base.Data;
		}

		protected override Oculus.Platform.Models.Room GetDataFromMessage(IntPtr c_message)
		{
			return new Oculus.Platform.Models.Room(CAPI.ovr_Message_GetRoom(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithRoomList : Message<RoomList>
	{
		public MessageWithRoomList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override RoomList GetRoomList()
		{
			return base.Data;
		}

		protected override RoomList GetDataFromMessage(IntPtr c_message)
		{
			return new RoomList(CAPI.ovr_Message_GetRoomArray(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithRoomInviteNotification : Message<RoomInviteNotification>
	{
		public MessageWithRoomInviteNotification(IntPtr c_message)
			: base(c_message)
		{
		}

		public override RoomInviteNotification GetRoomInviteNotification()
		{
			return base.Data;
		}

		protected override RoomInviteNotification GetDataFromMessage(IntPtr c_message)
		{
			return new RoomInviteNotification(CAPI.ovr_Message_GetRoomInviteNotification(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithRoomInviteNotificationList : Message<RoomInviteNotificationList>
	{
		public MessageWithRoomInviteNotificationList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override RoomInviteNotificationList GetRoomInviteNotificationList()
		{
			return base.Data;
		}

		protected override RoomInviteNotificationList GetDataFromMessage(IntPtr c_message)
		{
			return new RoomInviteNotificationList(CAPI.ovr_Message_GetRoomInviteNotificationArray(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithSdkAccountList : Message<SdkAccountList>
	{
		public MessageWithSdkAccountList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override SdkAccountList GetSdkAccountList()
		{
			return base.Data;
		}

		protected override SdkAccountList GetDataFromMessage(IntPtr c_message)
		{
			return new SdkAccountList(CAPI.ovr_Message_GetSdkAccountArray(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithShareMediaResult : Message<ShareMediaResult>
	{
		public MessageWithShareMediaResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override ShareMediaResult GetShareMediaResult()
		{
			return base.Data;
		}

		protected override ShareMediaResult GetDataFromMessage(IntPtr c_message)
		{
			return new ShareMediaResult(CAPI.ovr_Message_GetShareMediaResult(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithString : Message<string>
	{
		public MessageWithString(IntPtr c_message)
			: base(c_message)
		{
		}

		public override string GetString()
		{
			return base.Data;
		}

		protected override string GetDataFromMessage(IntPtr c_message)
		{
			return CAPI.ovr_Message_GetString(c_message);
		}
	}
	public class MessageWithSystemPermission : Message<SystemPermission>
	{
		public MessageWithSystemPermission(IntPtr c_message)
			: base(c_message)
		{
		}

		public override SystemPermission GetSystemPermission()
		{
			return base.Data;
		}

		protected override SystemPermission GetDataFromMessage(IntPtr c_message)
		{
			return new SystemPermission(CAPI.ovr_Message_GetSystemPermission(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithSystemVoipState : Message<SystemVoipState>
	{
		public MessageWithSystemVoipState(IntPtr c_message)
			: base(c_message)
		{
		}

		public override SystemVoipState GetSystemVoipState()
		{
			return base.Data;
		}

		protected override SystemVoipState GetDataFromMessage(IntPtr c_message)
		{
			return new SystemVoipState(CAPI.ovr_Message_GetSystemVoipState(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithUser : Message<User>
	{
		public MessageWithUser(IntPtr c_message)
			: base(c_message)
		{
		}

		public override User GetUser()
		{
			return base.Data;
		}

		protected override User GetDataFromMessage(IntPtr c_message)
		{
			return new User(CAPI.ovr_Message_GetUser(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithUserAndRoomList : Message<UserAndRoomList>
	{
		public MessageWithUserAndRoomList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override UserAndRoomList GetUserAndRoomList()
		{
			return base.Data;
		}

		protected override UserAndRoomList GetDataFromMessage(IntPtr c_message)
		{
			return new UserAndRoomList(CAPI.ovr_Message_GetUserAndRoomArray(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithUserList : Message<UserList>
	{
		public MessageWithUserList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override UserList GetUserList()
		{
			return base.Data;
		}

		protected override UserList GetDataFromMessage(IntPtr c_message)
		{
			return new UserList(CAPI.ovr_Message_GetUserArray(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithUserProof : Message<UserProof>
	{
		public MessageWithUserProof(IntPtr c_message)
			: base(c_message)
		{
		}

		public override UserProof GetUserProof()
		{
			return base.Data;
		}

		protected override UserProof GetDataFromMessage(IntPtr c_message)
		{
			return new UserProof(CAPI.ovr_Message_GetUserProof(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithUserReportID : Message<UserReportID>
	{
		public MessageWithUserReportID(IntPtr c_message)
			: base(c_message)
		{
		}

		public override UserReportID GetUserReportID()
		{
			return base.Data;
		}

		protected override UserReportID GetDataFromMessage(IntPtr c_message)
		{
			return new UserReportID(CAPI.ovr_Message_GetUserReportID(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithNetworkingPeer : Message<NetworkingPeer>
	{
		public MessageWithNetworkingPeer(IntPtr c_message)
			: base(c_message)
		{
		}

		public override NetworkingPeer GetNetworkingPeer()
		{
			return base.Data;
		}

		protected override NetworkingPeer GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNetworkingPeer(c_message);
			return new NetworkingPeer(CAPI.ovr_NetworkingPeer_GetID(obj), CAPI.ovr_NetworkingPeer_GetState(obj));
		}
	}
	public class MessageWithPingResult : Message<PingResult>
	{
		public MessageWithPingResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override PingResult GetPingResult()
		{
			return base.Data;
		}

		protected override PingResult GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetPingResult(c_message);
			bool flag = CAPI.ovr_PingResult_IsTimeout(obj);
			return new PingResult(CAPI.ovr_PingResult_GetID(obj), flag ? null : new ulong?(CAPI.ovr_PingResult_GetPingTimeUsec(obj)));
		}
	}
	public class MessageWithLeaderboardDidUpdate : Message<bool>
	{
		public MessageWithLeaderboardDidUpdate(IntPtr c_message)
			: base(c_message)
		{
		}

		public override bool GetLeaderboardDidUpdate()
		{
			return base.Data;
		}

		protected override bool GetDataFromMessage(IntPtr c_message)
		{
			return CAPI.ovr_LeaderboardUpdateStatus_GetDidUpdate(CAPI.ovr_Message_GetLeaderboardUpdateStatus(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithMatchmakingNotification : Message<Oculus.Platform.Models.Room>
	{
		public MessageWithMatchmakingNotification(IntPtr c_message)
			: base(c_message)
		{
		}

		public override Oculus.Platform.Models.Room GetRoom()
		{
			return base.Data;
		}

		protected override Oculus.Platform.Models.Room GetDataFromMessage(IntPtr c_message)
		{
			return new Oculus.Platform.Models.Room(CAPI.ovr_Message_GetRoom(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithMatchmakingBrowseResult : Message<MatchmakingBrowseResult>
	{
		public MessageWithMatchmakingBrowseResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override MatchmakingEnqueueResult GetMatchmakingEnqueueResult()
		{
			return base.Data.EnqueueResult;
		}

		public override RoomList GetRoomList()
		{
			return base.Data.Rooms;
		}

		protected override MatchmakingBrowseResult GetDataFromMessage(IntPtr c_message)
		{
			return new MatchmakingBrowseResult(CAPI.ovr_Message_GetMatchmakingBrowseResult(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithHttpTransferUpdate : Message<HttpTransferUpdate>
	{
		public MessageWithHttpTransferUpdate(IntPtr c_message)
			: base(c_message)
		{
		}

		public override HttpTransferUpdate GetHttpTransferUpdate()
		{
			return base.Data;
		}

		protected override HttpTransferUpdate GetDataFromMessage(IntPtr c_message)
		{
			return new HttpTransferUpdate(CAPI.ovr_Message_GetHttpTransferUpdate(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithPlatformInitialize : Message<PlatformInitialize>
	{
		public MessageWithPlatformInitialize(IntPtr c_message)
			: base(c_message)
		{
		}

		public override PlatformInitialize GetPlatformInitialize()
		{
			return base.Data;
		}

		protected override PlatformInitialize GetDataFromMessage(IntPtr c_message)
		{
			return new PlatformInitialize(CAPI.ovr_Message_GetPlatformInitialize(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public enum NetSyncConnectionStatus
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("CONNECTING")]
		Connecting,
		[Description("DISCONNECTED")]
		Disconnected,
		[Description("CONNECTED")]
		Connected
	}
	public enum NetSyncDisconnectReason
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("LOCAL_TERMINATED")]
		LocalTerminated,
		[Description("SERVER_TERMINATED")]
		ServerTerminated,
		[Description("FAILED")]
		Failed,
		[Description("LOST")]
		Lost
	}
	public class NetSyncOptions
	{
		private IntPtr Handle;

		public NetSyncOptions()
		{
			Handle = CAPI.ovr_NetSyncOptions_Create();
		}

		public void SetVoipGroup(string value)
		{
			CAPI.ovr_NetSyncOptions_SetVoipGroup(Handle, value);
		}

		public void SetVoipStreamDefault(NetSyncVoipStreamMode value)
		{
			CAPI.ovr_NetSyncOptions_SetVoipStreamDefault(Handle, value);
		}

		public void SetZoneId(string value)
		{
			CAPI.ovr_NetSyncOptions_SetZoneId(Handle, value);
		}

		public static explicit operator IntPtr(NetSyncOptions options)
		{
			return options?.Handle ?? IntPtr.Zero;
		}

		~NetSyncOptions()
		{
			CAPI.ovr_NetSyncOptions_Destroy(Handle);
		}
	}
	public enum NetSyncVoipMicSource
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("NONE")]
		None,
		[Description("INTERNAL")]
		Internal
	}
	public enum NetSyncVoipStreamMode
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("AMBISONIC")]
		Ambisonic,
		[Description("MONO")]
		Mono
	}
	public sealed class Packet : IDisposable
	{
		private readonly ulong size;

		private readonly IntPtr packetHandle;

		public ulong SenderID => CAPI.ovr_Packet_GetSenderID(packetHandle);

		public ulong Size => size;

		public SendPolicy Policy => CAPI.ovr_Packet_GetSendPolicy(packetHandle);

		public Packet(IntPtr packetHandle)
		{
			this.packetHandle = packetHandle;
			size = (ulong)CAPI.ovr_Packet_GetSize(packetHandle);
		}

		public ulong ReadBytes(byte[] destination)
		{
			if ((ulong)destination.LongLength < size)
			{
				throw new ArgumentException($"Destination array was not big enough to hold {size} bytes");
			}
			Marshal.Copy(CAPI.ovr_Packet_GetBytes(packetHandle), destination, 0, (int)size);
			return size;
		}

		~Packet()
		{
			Dispose();
		}

		public void Dispose()
		{
			CAPI.ovr_Packet_Free(packetHandle);
			GC.SuppressFinalize(this);
		}
	}
	public enum PartyUpdateAction
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("Join")]
		Join,
		[Description("Leave")]
		Leave,
		[Description("Invite")]
		Invite,
		[Description("Uninvite")]
		Uninvite
	}
	public enum PeerConnectionState
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("CONNECTED")]
		Connected,
		[Description("TIMEOUT")]
		Timeout,
		[Description("CLOSED")]
		Closed
	}
	public enum PermissionGrantStatus
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("GRANTED")]
		Granted,
		[Description("DENIED")]
		Denied,
		[Description("BLOCKED")]
		Blocked
	}
	public enum PermissionType
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("MICROPHONE")]
		Microphone,
		[Description("WRITE_EXTERNAL_STORAGE")]
		WriteExternalStorage
	}
	public sealed class Core
	{
		private static bool IsPlatformInitialized;

		public static bool LogMessages;

		public static bool IsInitialized()
		{
			return IsPlatformInitialized;
		}

		internal static void ForceInitialized()
		{
			IsPlatformInitialized = true;
		}

		private static string getAppID(string appId = null)
		{
			string appIDFromConfig = GetAppIDFromConfig();
			if (string.IsNullOrEmpty(appId))
			{
				if (string.IsNullOrEmpty(appIDFromConfig))
				{
					throw new UnityException("Update your app id by selecting 'Oculus Platform' -> 'Edit Settings'");
				}
				appId = appIDFromConfig;
			}
			else if (!string.IsNullOrEmpty(appIDFromConfig))
			{
				UnityEngine.Debug.LogWarningFormat("The 'Oculus App Id ({0})' field in 'Oculus Platform/Edit Settings' is being overridden by the App Id ({1}) that you passed in to Platform.Core.Initialize.  You should only specify this in one place.  We recommend the menu location.", appIDFromConfig, appId);
			}
			return appId;
		}

		public static Request<PlatformInitialize> AsyncInitialize(string appId = null)
		{
			appId = getAppID(appId);
			Request<PlatformInitialize> request;
			if (UnityEngine.Application.isEditor && PlatformSettings.UseStandalonePlatform)
			{
				request = new StandalonePlatform().InitializeInEditor();
			}
			else if (UnityEngine.Application.platform == RuntimePlatform.WindowsEditor || UnityEngine.Application.platform == RuntimePlatform.WindowsPlayer)
			{
				request = new WindowsPlatform().AsyncInitialize(appId);
			}
			else
			{
				if (UnityEngine.Application.platform != RuntimePlatform.Android)
				{
					throw new NotImplementedException("Oculus platform is not implemented on this platform yet.");
				}
				request = new AndroidPlatform().AsyncInitialize(appId);
			}
			IsPlatformInitialized = request != null;
			if (!IsPlatformInitialized)
			{
				throw new UnityException("Oculus Platform failed to initialize.");
			}
			if (LogMessages)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.Core.LogMessages is set to true. This will cause extra heap allocations, and should not be used outside of testing and debugging.");
			}
			new GameObject("Oculus.Platform.CallbackRunner").AddComponent<CallbackRunner>();
			return request;
		}

		public static void Initialize(string appId = null)
		{
			appId = getAppID(appId);
			if (UnityEngine.Application.isEditor && PlatformSettings.UseStandalonePlatform)
			{
				IsPlatformInitialized = new StandalonePlatform().InitializeInEditor() != null;
			}
			else if (UnityEngine.Application.platform == RuntimePlatform.WindowsEditor || UnityEngine.Application.platform == RuntimePlatform.WindowsPlayer)
			{
				IsPlatformInitialized = new WindowsPlatform().Initialize(appId);
			}
			else
			{
				if (UnityEngine.Application.platform != RuntimePlatform.Android)
				{
					throw new NotImplementedException("Oculus platform is not implemented on this platform yet.");
				}
				IsPlatformInitialized = new AndroidPlatform().Initialize(appId);
			}
			if (!IsPlatformInitialized)
			{
				throw new UnityException("Oculus Platform failed to initialize.");
			}
			if (LogMessages)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.Core.LogMessages is set to true. This will cause extra heap allocations, and should not be used outside of testing and debugging.");
			}
			new GameObject("Oculus.Platform.CallbackRunner").AddComponent<CallbackRunner>();
		}

		private static string GetAppIDFromConfig()
		{
			if (UnityEngine.Application.platform == RuntimePlatform.Android)
			{
				return PlatformSettings.MobileAppID;
			}
			return PlatformSettings.AppID;
		}
	}
	public static class ApplicationLifecycle
	{
		public static LaunchDetails GetLaunchDetails()
		{
			return new LaunchDetails(CAPI.ovr_ApplicationLifecycle_GetLaunchDetails());
		}

		public static void SetLaunchIntentChangedNotificationCallback(Message<string>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_ApplicationLifecycle_LaunchIntentChanged, callback);
		}
	}
	public static class Rooms
	{
		public static Request<Oculus.Platform.Models.Room> UpdateDataStore(ulong roomID, Dictionary<string, string> data)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovrKeyValuePair[] array = new CAPI.ovrKeyValuePair[data.Count];
				int num = 0;
				foreach (KeyValuePair<string, string> datum in data)
				{
					array[num++] = new CAPI.ovrKeyValuePair(datum.Key, datum.Value);
				}
				return new Request<Oculus.Platform.Models.Room>(CAPI.ovr_Room_UpdateDataStore(roomID, array));
			}
			return null;
		}

		[Obsolete("Deprecated in favor of SetRoomInviteAcceptedNotificationCallback")]
		public static void SetRoomInviteNotificationCallback(Message<string>.Callback callback)
		{
			SetRoomInviteAcceptedNotificationCallback(callback);
		}

		public static Request<Oculus.Platform.Models.Room> CreateAndJoinPrivate(RoomJoinPolicy joinPolicy, uint maxUsers, bool subscribeToUpdates = false)
		{
			if (Core.IsInitialized())
			{
				return new Request<Oculus.Platform.Models.Room>(CAPI.ovr_Room_CreateAndJoinPrivate(joinPolicy, maxUsers, subscribeToUpdates));
			}
			return null;
		}

		public static Request<Oculus.Platform.Models.Room> CreateAndJoinPrivate2(RoomJoinPolicy joinPolicy, uint maxUsers, RoomOptions roomOptions)
		{
			if (Core.IsInitialized())
			{
				return new Request<Oculus.Platform.Models.Room>(CAPI.ovr_Room_CreateAndJoinPrivate2(joinPolicy, maxUsers, (IntPtr)roomOptions));
			}
			return null;
		}

		public static Request<Oculus.Platform.Models.Room> Get(ulong roomID)
		{
			if (Core.IsInitialized())
			{
				return new Request<Oculus.Platform.Models.Room>(CAPI.ovr_Room_Get(roomID));
			}
			return null;
		}

		public static Request<Oculus.Platform.Models.Room> GetCurrent()
		{
			if (Core.IsInitialized())
			{
				return new Request<Oculus.Platform.Models.Room>(CAPI.ovr_Room_GetCurrent());
			}
			return null;
		}

		public static Request<Oculus.Platform.Models.Room> GetCurrentForUser(ulong userID)
		{
			if (Core.IsInitialized())
			{
				return new Request<Oculus.Platform.Models.Room>(CAPI.ovr_Room_GetCurrentForUser(userID));
			}
			return null;
		}

		public static Request<UserList> GetInvitableUsers()
		{
			if (Core.IsInitialized())
			{
				return new Request<UserList>(CAPI.ovr_Room_GetInvitableUsers());
			}
			return null;
		}

		public static Request<UserList> GetInvitableUsers2(RoomOptions roomOptions = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<UserList>(CAPI.ovr_Room_GetInvitableUsers2((IntPtr)roomOptions));
			}
			return null;
		}

		public static Request<RoomList> GetModeratedRooms()
		{
			if (Core.IsInitialized())
			{
				return new Request<RoomList>(CAPI.ovr_Room_GetModeratedRooms());
			}
			return null;
		}

		public static Request<Oculus.Platform.Models.Room> InviteUser(ulong roomID, string inviteToken)
		{
			if (Core.IsInitialized())
			{
				return new Request<Oculus.Platform.Models.Room>(CAPI.ovr_Room_InviteUser(roomID, inviteToken));
			}
			return null;
		}

		public static Request<Oculus.Platform.Models.Room> Join(ulong roomID, bool subscribeToUpdates = false)
		{
			if (Core.IsInitialized())
			{
				return new Request<Oculus.Platform.Models.Room>(CAPI.ovr_Room_Join(roomID, subscribeToUpdates));
			}
			return null;
		}

		public static Request<Oculus.Platform.Models.Room> Join2(ulong roomID, RoomOptions roomOptions)
		{
			if (Core.IsInitialized())
			{
				return new Request<Oculus.Platform.Models.Room>(CAPI.ovr_Room_Join2(roomID, (IntPtr)roomOptions));
			}
			return null;
		}

		public static Request<Oculus.Platform.Models.Room> KickUser(ulong roomID, ulong userID, int kickDurationSeconds)
		{
			if (Core.IsInitialized())
			{
				return new Request<Oculus.Platform.Models.Room>(CAPI.ovr_Room_KickUser(roomID, userID, kickDurationSeconds));
			}
			return null;
		}

		public static Request LaunchInvitableUserFlow(ulong roomID)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Room_LaunchInvitableUserFlow(roomID));
			}
			return null;
		}

		public static Request<Oculus.Platform.Models.Room> Leave(ulong roomID)
		{
			if (Core.IsInitialized())
			{
				return new Request<Oculus.Platform.Models.Room>(CAPI.ovr_Room_Leave(roomID));
			}
			return null;
		}

		public static Request<Oculus.Platform.Models.Room> SetDescription(ulong roomID, string description)
		{
			if (Core.IsInitialized())
			{
				return new Request<Oculus.Platform.Models.Room>(CAPI.ovr_Room_SetDescription(roomID, description));
			}
			return null;
		}

		public static Request<Oculus.Platform.Models.Room> UpdateMembershipLockStatus(ulong roomID, RoomMembershipLockStatus membershipLockStatus)
		{
			if (Core.IsInitialized())
			{
				return new Request<Oculus.Platform.Models.Room>(CAPI.ovr_Room_UpdateMembershipLockStatus(roomID, membershipLockStatus));
			}
			return null;
		}

		public static Request UpdateOwner(ulong roomID, ulong userID)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Room_UpdateOwner(roomID, userID));
			}
			return null;
		}

		public static Request<Oculus.Platform.Models.Room> UpdatePrivateRoomJoinPolicy(ulong roomID, RoomJoinPolicy newJoinPolicy)
		{
			if (Core.IsInitialized())
			{
				return new Request<Oculus.Platform.Models.Room>(CAPI.ovr_Room_UpdatePrivateRoomJoinPolicy(roomID, newJoinPolicy));
			}
			return null;
		}

		public static void SetRoomInviteAcceptedNotificationCallback(Message<string>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Room_InviteAccepted, callback);
		}

		public static void SetRoomInviteReceivedNotificationCallback(Message<RoomInviteNotification>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Room_InviteReceived, callback);
		}

		public static void SetUpdateNotificationCallback(Message<Oculus.Platform.Models.Room>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Room_RoomUpdate, callback);
		}

		public static Request<RoomList> GetNextRoomListPage(RoomList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.GetNextRoomListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<RoomList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 1317239238));
			}
			return null;
		}
	}
	public static class Matchmaking
	{
		public class CustomQuery
		{
			public struct Criterion
			{
				public string key;

				public MatchmakingCriterionImportance importance;

				public Dictionary<string, object> parameters;

				public Criterion(string key_, MatchmakingCriterionImportance importance_)
				{
					key = key_;
					importance = importance_;
					parameters = null;
				}
			}

			public Dictionary<string, object> data;

			public Criterion[] criteria;

			public IntPtr ToUnmanaged()
			{
				CAPI.ovrMatchmakingCustomQueryData structure = default(CAPI.ovrMatchmakingCustomQueryData);
				if (criteria != null && criteria.Length != 0)
				{
					structure.criterionArrayCount = (uint)criteria.Length;
					CAPI.ovrMatchmakingCriterion[] array = new CAPI.ovrMatchmakingCriterion[criteria.Length];
					for (int i = 0; i < criteria.Length; i++)
					{
						array[i].importance_ = criteria[i].importance;
						array[i].key_ = criteria[i].key;
						if (criteria[i].parameters != null && criteria[i].parameters.Count > 0)
						{
							array[i].parameterArrayCount = (uint)criteria[i].parameters.Count;
							array[i].parameterArray = CAPI.ArrayOfStructsToIntPtr(CAPI.DictionaryToOVRKeyValuePairs(criteria[i].parameters));
						}
						else
						{
							array[i].parameterArrayCount = 0u;
							array[i].parameterArray = IntPtr.Zero;
						}
					}
					structure.criterionArray = CAPI.ArrayOfStructsToIntPtr(array);
				}
				else
				{
					structure.criterionArrayCount = 0u;
					structure.criterionArray = IntPtr.Zero;
				}
				if (data != null && data.Count > 0)
				{
					structure.dataArrayCount = (uint)data.Count;
					structure.dataArray = CAPI.ArrayOfStructsToIntPtr(CAPI.DictionaryToOVRKeyValuePairs(data));
				}
				else
				{
					structure.dataArrayCount = 0u;
					structure.dataArray = IntPtr.Zero;
				}
				IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(structure));
				Marshal.StructureToPtr(structure, intPtr, fDeleteOld: true);
				return intPtr;
			}
		}

		public static Request ReportResultsInsecure(ulong roomID, Dictionary<string, int> data)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovrKeyValuePair[] array = new CAPI.ovrKeyValuePair[data.Count];
				int num = 0;
				foreach (KeyValuePair<string, int> datum in data)
				{
					array[num++] = new CAPI.ovrKeyValuePair(datum.Key, datum.Value);
				}
				return new Request(CAPI.ovr_Matchmaking_ReportResultInsecure(roomID, array));
			}
			return null;
		}

		public static Request<MatchmakingStats> GetStats(string pool, uint maxLevel, MatchmakingStatApproach approach = MatchmakingStatApproach.Trailing)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingStats>(CAPI.ovr_Matchmaking_GetStats(pool, maxLevel, approach));
			}
			return null;
		}

		public static Request<MatchmakingBrowseResult> Browse(string pool, CustomQuery customQueryData = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingBrowseResult>(CAPI.ovr_Matchmaking_Browse(pool, customQueryData?.ToUnmanaged() ?? IntPtr.Zero));
			}
			return null;
		}

		public static Request<MatchmakingBrowseResult> Browse2(string pool, MatchmakingOptions matchmakingOptions = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingBrowseResult>(CAPI.ovr_Matchmaking_Browse2(pool, (IntPtr)matchmakingOptions));
			}
			return null;
		}

		public static Request Cancel(string pool, string requestHash)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Matchmaking_Cancel(pool, requestHash));
			}
			return null;
		}

		public static Request Cancel()
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Matchmaking_Cancel2());
			}
			return null;
		}

		public static Request<MatchmakingEnqueueResultAndRoom> CreateAndEnqueueRoom(string pool, uint maxUsers, bool subscribeToUpdates = false, CustomQuery customQueryData = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingEnqueueResultAndRoom>(CAPI.ovr_Matchmaking_CreateAndEnqueueRoom(pool, maxUsers, subscribeToUpdates, customQueryData?.ToUnmanaged() ?? IntPtr.Zero));
			}
			return null;
		}

		public static Request<MatchmakingEnqueueResultAndRoom> CreateAndEnqueueRoom2(string pool, MatchmakingOptions matchmakingOptions = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingEnqueueResultAndRoom>(CAPI.ovr_Matchmaking_CreateAndEnqueueRoom2(pool, (IntPtr)matchmakingOptions));
			}
			return null;
		}

		public static Request<Oculus.Platform.Models.Room> CreateRoom(string pool, uint maxUsers, bool subscribeToUpdates = false)
		{
			if (Core.IsInitialized())
			{
				return new Request<Oculus.Platform.Models.Room>(CAPI.ovr_Matchmaking_CreateRoom(pool, maxUsers, subscribeToUpdates));
			}
			return null;
		}

		public static Request<Oculus.Platform.Models.Room> CreateRoom2(string pool, MatchmakingOptions matchmakingOptions = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<Oculus.Platform.Models.Room>(CAPI.ovr_Matchmaking_CreateRoom2(pool, (IntPtr)matchmakingOptions));
			}
			return null;
		}

		public static Request<MatchmakingEnqueueResult> Enqueue(string pool, CustomQuery customQueryData = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingEnqueueResult>(CAPI.ovr_Matchmaking_Enqueue(pool, customQueryData?.ToUnmanaged() ?? IntPtr.Zero));
			}
			return null;
		}

		public static Request<MatchmakingEnqueueResult> Enqueue2(string pool, MatchmakingOptions matchmakingOptions = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingEnqueueResult>(CAPI.ovr_Matchmaking_Enqueue2(pool, (IntPtr)matchmakingOptions));
			}
			return null;
		}

		public static Request<MatchmakingEnqueueResult> EnqueueRoom(ulong roomID, CustomQuery customQueryData = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingEnqueueResult>(CAPI.ovr_Matchmaking_EnqueueRoom(roomID, customQueryData?.ToUnmanaged() ?? IntPtr.Zero));
			}
			return null;
		}

		public static Request<MatchmakingEnqueueResult> EnqueueRoom2(ulong roomID, MatchmakingOptions matchmakingOptions = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingEnqueueResult>(CAPI.ovr_Matchmaking_EnqueueRoom2(roomID, (IntPtr)matchmakingOptions));
			}
			return null;
		}

		public static Request<MatchmakingAdminSnapshot> GetAdminSnapshot()
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingAdminSnapshot>(CAPI.ovr_Matchmaking_GetAdminSnapshot());
			}
			return null;
		}

		public static Request<Oculus.Platform.Models.Room> JoinRoom(ulong roomID, bool subscribeToUpdates = false)
		{
			if (Core.IsInitialized())
			{
				return new Request<Oculus.Platform.Models.Room>(CAPI.ovr_Matchmaking_JoinRoom(roomID, subscribeToUpdates));
			}
			return null;
		}

		public static Request StartMatch(ulong roomID)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Matchmaking_StartMatch(roomID));
			}
			return null;
		}

		public static void SetMatchFoundNotificationCallback(Message<Oculus.Platform.Models.Room>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Matchmaking_MatchFound, callback);
		}
	}
	public static class Net
	{
		public static Packet ReadPacket()
		{
			if (!Core.IsInitialized())
			{
				return null;
			}
			IntPtr intPtr = CAPI.ovr_Net_ReadPacket();
			if (intPtr == IntPtr.Zero)
			{
				return null;
			}
			return new Packet(intPtr);
		}

		public static bool SendPacket(ulong userID, byte[] bytes, SendPolicy policy)
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Net_SendPacket(userID, (UIntPtr)(ulong)bytes.Length, bytes, policy);
			}
			return false;
		}

		public static void Connect(ulong userID)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Net_Connect(userID);
			}
		}

		public static void Accept(ulong userID)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Net_Accept(userID);
			}
		}

		public static void Close(ulong userID)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Net_Close(userID);
			}
		}

		public static bool IsConnected(ulong userID)
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Net_IsConnected(userID);
			}
			return false;
		}

		public static bool SendPacketToCurrentRoom(byte[] bytes, SendPolicy policy)
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Net_SendPacketToCurrentRoom((UIntPtr)(ulong)bytes.Length, bytes, policy);
			}
			return false;
		}

		public static bool AcceptForCurrentRoom()
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Net_AcceptForCurrentRoom();
			}
			return false;
		}

		public static void CloseForCurrentRoom()
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Net_CloseForCurrentRoom();
			}
		}

		public static Request<PingResult> Ping(ulong userID)
		{
			if (Core.IsInitialized())
			{
				return new Request<PingResult>(CAPI.ovr_Net_Ping(userID));
			}
			return null;
		}

		public static void SetConnectionStateChangedCallback(Message<NetworkingPeer>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Networking_ConnectionStateChange, callback);
		}

		public static void SetPeerConnectRequestCallback(Message<NetworkingPeer>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Networking_PeerConnectRequest, callback);
		}

		public static void SetPingResultNotificationCallback(Message<PingResult>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Networking_PingResult, callback);
		}
	}
	public static class Leaderboards
	{
		public static Request<LeaderboardEntryList> GetNextEntries(LeaderboardEntryList list)
		{
			if (Core.IsInitialized())
			{
				return new Request<LeaderboardEntryList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 1310751961));
			}
			return null;
		}

		public static Request<LeaderboardEntryList> GetPreviousEntries(LeaderboardEntryList list)
		{
			if (Core.IsInitialized())
			{
				return new Request<LeaderboardEntryList>(CAPI.ovr_HTTP_GetWithMessageType(list.PreviousUrl, 1224858304));
			}
			return null;
		}

		public static Request<LeaderboardEntryList> GetEntries(string leaderboardName, int limit, LeaderboardFilterType filter, LeaderboardStartAt startAt)
		{
			if (Core.IsInitialized())
			{
				return new Request<LeaderboardEntryList>(CAPI.ovr_Leaderboard_GetEntries(leaderboardName, limit, filter, startAt));
			}
			return null;
		}

		public static Request<LeaderboardEntryList> GetEntriesAfterRank(string leaderboardName, int limit, ulong afterRank)
		{
			if (Core.IsInitialized())
			{
				return new Request<LeaderboardEntryList>(CAPI.ovr_Leaderboard_GetEntriesAfterRank(leaderboardName, limit, afterRank));
			}
			return null;
		}

		public static Request<bool> WriteEntry(string leaderboardName, long score, byte[] extraData = null, bool forceUpdate = false)
		{
			if (Core.IsInitialized())
			{
				return new Request<bool>(CAPI.ovr_Leaderboard_WriteEntry(leaderboardName, score, extraData, (extraData != null) ? ((uint)extraData.Length) : 0u, forceUpdate));
			}
			return null;
		}
	}
	public static class Voip
	{
		public static void Start(ulong userID)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Voip_Start(userID);
			}
		}

		public static void Accept(ulong userID)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Voip_Accept(userID);
			}
		}

		public static void Stop(ulong userID)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Voip_Stop(userID);
			}
		}

		public static void SetMicrophoneFilterCallback(CAPI.FilterCallback callback)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Voip_SetMicrophoneFilterCallbackWithFixedSizeBuffer(callback, (UIntPtr)480uL);
			}
		}

		public static void SetMicrophoneMuted(VoipMuteState state)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Voip_SetMicrophoneMuted(state);
			}
		}

		public static VoipMuteState GetSystemVoipMicrophoneMuted()
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Voip_GetSystemVoipMicrophoneMuted();
			}
			return VoipMuteState.Unknown;
		}

		public static SystemVoipStatus GetSystemVoipStatus()
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Voip_GetSystemVoipStatus();
			}
			return SystemVoipStatus.Unknown;
		}

		public static VoipDtxState GetIsConnectionUsingDtx(ulong peerID)
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Voip_GetIsConnectionUsingDtx(peerID);
			}
			return VoipDtxState.Unknown;
		}

		public static VoipBitrate GetLocalBitrate(ulong peerID)
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Voip_GetLocalBitrate(peerID);
			}
			return VoipBitrate.Unknown;
		}

		public static VoipBitrate GetRemoteBitrate(ulong peerID)
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Voip_GetRemoteBitrate(peerID);
			}
			return VoipBitrate.Unknown;
		}

		public static void SetNewConnectionOptions(VoipOptions voipOptions)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Voip_SetNewConnectionOptions((IntPtr)voipOptions);
			}
		}

		public static Request<SystemVoipState> SetSystemVoipSuppressed(bool suppressed)
		{
			if (Core.IsInitialized())
			{
				return new Request<SystemVoipState>(CAPI.ovr_Voip_SetSystemVoipSuppressed(suppressed));
			}
			return null;
		}

		public static void SetVoipConnectRequestCallback(Message<NetworkingPeer>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Voip_ConnectRequest, callback);
		}

		public static void SetVoipStateChangeCallback(Message<NetworkingPeer>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Voip_StateChange, callback);
		}

		public static void SetSystemVoipStateNotificationCallback(Message<SystemVoipState>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Voip_SystemVoipState, callback);
		}
	}
	public static class Achievements
	{
		public static Request<AchievementUpdate> AddCount(string name, ulong count)
		{
			if (Core.IsInitialized())
			{
				return new Request<AchievementUpdate>(CAPI.ovr_Achievements_AddCount(name, count));
			}
			return null;
		}

		public static Request<AchievementUpdate> AddFields(string name, string fields)
		{
			if (Core.IsInitialized())
			{
				return new Request<AchievementUpdate>(CAPI.ovr_Achievements_AddFields(name, fields));
			}
			return null;
		}

		public static Request<AchievementDefinitionList> GetAllDefinitions()
		{
			if (Core.IsInitialized())
			{
				return new Request<AchievementDefinitionList>(CAPI.ovr_Achievements_GetAllDefinitions());
			}
			return null;
		}

		public static Request<AchievementProgressList> GetAllProgress()
		{
			if (Core.IsInitialized())
			{
				return new Request<AchievementProgressList>(CAPI.ovr_Achievements_GetAllProgress());
			}
			return null;
		}

		public static Request<AchievementDefinitionList> GetDefinitionsByName(string[] names)
		{
			if (Core.IsInitialized())
			{
				return new Request<AchievementDefinitionList>(CAPI.ovr_Achievements_GetDefinitionsByName(names, (names != null) ? names.Length : 0));
			}
			return null;
		}

		public static Request<AchievementProgressList> GetProgressByName(string[] names)
		{
			if (Core.IsInitialized())
			{
				return new Request<AchievementProgressList>(CAPI.ovr_Achievements_GetProgressByName(names, (names != null) ? names.Length : 0));
			}
			return null;
		}

		public static Request<AchievementUpdate> Unlock(string name)
		{
			if (Core.IsInitialized())
			{
				return new Request<AchievementUpdate>(CAPI.ovr_Achievements_Unlock(name));
			}
			return null;
		}

		public static Request<AchievementDefinitionList> GetNextAchievementDefinitionListPage(AchievementDefinitionList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.GetNextAchievementDefinitionListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<AchievementDefinitionList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 712888917));
			}
			return null;
		}

		public static Request<AchievementProgressList> GetNextAchievementProgressListPage(AchievementProgressList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.GetNextAchievementProgressListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<AchievementProgressList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 792913703));
			}
			return null;
		}
	}
	public static class Application
	{
		public static Request<ApplicationVersion> GetVersion()
		{
			if (Core.IsInitialized())
			{
				return new Request<ApplicationVersion>(CAPI.ovr_Application_GetVersion());
			}
			return null;
		}

		public static Request<string> LaunchOtherApp(ulong appID, ApplicationOptions deeplink_options = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<string>(CAPI.ovr_Application_LaunchOtherApp(appID, (IntPtr)deeplink_options));
			}
			return null;
		}
	}
	public static class AssetFile
	{
		public static Request<AssetFileDeleteResult> Delete(ulong assetFileID)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetFileDeleteResult>(CAPI.ovr_AssetFile_Delete(assetFileID));
			}
			return null;
		}

		public static Request<AssetFileDeleteResult> DeleteById(ulong assetFileID)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetFileDeleteResult>(CAPI.ovr_AssetFile_DeleteById(assetFileID));
			}
			return null;
		}

		public static Request<AssetFileDeleteResult> DeleteByName(string assetFileName)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetFileDeleteResult>(CAPI.ovr_AssetFile_DeleteByName(assetFileName));
			}
			return null;
		}

		public static Request<AssetFileDownloadResult> Download(ulong assetFileID)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetFileDownloadResult>(CAPI.ovr_AssetFile_Download(assetFileID));
			}
			return null;
		}

		public static Request<AssetFileDownloadResult> DownloadById(ulong assetFileID)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetFileDownloadResult>(CAPI.ovr_AssetFile_DownloadById(assetFileID));
			}
			return null;
		}

		public static Request<AssetFileDownloadResult> DownloadByName(string assetFileName)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetFileDownloadResult>(CAPI.ovr_AssetFile_DownloadByName(assetFileName));
			}
			return null;
		}

		public static Request<AssetFileDownloadCancelResult> DownloadCancel(ulong assetFileID)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetFileDownloadCancelResult>(CAPI.ovr_AssetFile_DownloadCancel(assetFileID));
			}
			return null;
		}

		public static Request<AssetFileDownloadCancelResult> DownloadCancelById(ulong assetFileID)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetFileDownloadCancelResult>(CAPI.ovr_AssetFile_DownloadCancelById(assetFileID));
			}
			return null;
		}

		public static Request<AssetFileDownloadCancelResult> DownloadCancelByName(string assetFileName)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetFileDownloadCancelResult>(CAPI.ovr_AssetFile_DownloadCancelByName(assetFileName));
			}
			return null;
		}

		public static Request<AssetDetailsList> GetList()
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetDetailsList>(CAPI.ovr_AssetFile_GetList());
			}
			return null;
		}

		public static Request<AssetDetails> Status(ulong assetFileID)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetDetails>(CAPI.ovr_AssetFile_Status(assetFileID));
			}
			return null;
		}

		public static Request<AssetDetails> StatusById(ulong assetFileID)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetDetails>(CAPI.ovr_AssetFile_StatusById(assetFileID));
			}
			return null;
		}

		public static Request<AssetDetails> StatusByName(string assetFileName)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetDetails>(CAPI.ovr_AssetFile_StatusByName(assetFileName));
			}
			return null;
		}

		public static void SetDownloadUpdateNotificationCallback(Message<AssetFileDownloadUpdate>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_AssetFile_DownloadUpdate, callback);
		}
	}
	public static class Avatar
	{
	}
	public static class Cal
	{
	}
	public static class CloudStorage
	{
		public static Request<CloudStorageUpdateResponse> Delete(string bucket, string key)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageUpdateResponse>(CAPI.ovr_CloudStorage_Delete(bucket, key));
			}
			return null;
		}

		public static Request<CloudStorageData> Load(string bucket, string key)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageData>(CAPI.ovr_CloudStorage_Load(bucket, key));
			}
			return null;
		}

		public static Request<CloudStorageMetadataList> LoadBucketMetadata(string bucket)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageMetadataList>(CAPI.ovr_CloudStorage_LoadBucketMetadata(bucket));
			}
			return null;
		}

		public static Request<CloudStorageConflictMetadata> LoadConflictMetadata(string bucket, string key)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageConflictMetadata>(CAPI.ovr_CloudStorage_LoadConflictMetadata(bucket, key));
			}
			return null;
		}

		public static Request<CloudStorageData> LoadHandle(string handle)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageData>(CAPI.ovr_CloudStorage_LoadHandle(handle));
			}
			return null;
		}

		public static Request<CloudStorageMetadata> LoadMetadata(string bucket, string key)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageMetadata>(CAPI.ovr_CloudStorage_LoadMetadata(bucket, key));
			}
			return null;
		}

		public static Request<CloudStorageUpdateResponse> ResolveKeepLocal(string bucket, string key, string remoteHandle)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageUpdateResponse>(CAPI.ovr_CloudStorage_ResolveKeepLocal(bucket, key, remoteHandle));
			}
			return null;
		}

		public static Request<CloudStorageUpdateResponse> ResolveKeepRemote(string bucket, string key, string remoteHandle)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageUpdateResponse>(CAPI.ovr_CloudStorage_ResolveKeepRemote(bucket, key, remoteHandle));
			}
			return null;
		}

		public static Request<CloudStorageUpdateResponse> Save(string bucket, string key, byte[] data, long counter, string extraData)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageUpdateResponse>(CAPI.ovr_CloudStorage_Save(bucket, key, data, (data != null) ? ((uint)data.Length) : 0u, counter, extraData));
			}
			return null;
		}

		public static Request<CloudStorageMetadataList> GetNextCloudStorageMetadataListPage(CloudStorageMetadataList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.GetNextCloudStorageMetadataListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageMetadataList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 1544004335));
			}
			return null;
		}
	}
	public static class CloudStorage2
	{
		public static Request<string> GetUserDirectoryPath()
		{
			if (Core.IsInitialized())
			{
				return new Request<string>(CAPI.ovr_CloudStorage2_GetUserDirectoryPath());
			}
			return null;
		}
	}
	public static class Colocation
	{
	}
	public static class Entitlements
	{
		public static Request IsUserEntitledToApplication()
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Entitlement_GetIsViewerEntitled());
			}
			return null;
		}
	}
	public static class GraphAPI
	{
	}
	public static class HTTP
	{
	}
	public static class IAP
	{
		public static Request ConsumePurchase(string sku)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_IAP_ConsumePurchase(sku));
			}
			return null;
		}

		public static Request<ProductList> GetProductsBySKU(string[] skus)
		{
			if (Core.IsInitialized())
			{
				return new Request<ProductList>(CAPI.ovr_IAP_GetProductsBySKU(skus, (skus != null) ? skus.Length : 0));
			}
			return null;
		}

		public static Request<PurchaseList> GetViewerPurchases()
		{
			if (Core.IsInitialized())
			{
				return new Request<PurchaseList>(CAPI.ovr_IAP_GetViewerPurchases());
			}
			return null;
		}

		public static Request<PurchaseList> GetViewerPurchasesDurableCache()
		{
			if (Core.IsInitialized())
			{
				return new Request<PurchaseList>(CAPI.ovr_IAP_GetViewerPurchasesDurableCache());
			}
			return null;
		}

		public static Request<Purchase> LaunchCheckoutFlow(string sku)
		{
			if (Core.IsInitialized())
			{
				if (UnityEngine.Application.isEditor)
				{
					throw new NotImplementedException("LaunchCheckoutFlow() is not implemented in the editor yet.");
				}
				return new Request<Purchase>(CAPI.ovr_IAP_LaunchCheckoutFlow(sku));
			}
			return null;
		}

		public static Request<ProductList> GetNextProductListPage(ProductList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.GetNextProductListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<ProductList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 467225263));
			}
			return null;
		}

		public static Request<PurchaseList> GetNextPurchaseListPage(PurchaseList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.GetNextPurchaseListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<PurchaseList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 1196886677));
			}
			return null;
		}
	}
	public static class LanguagePack
	{
		public static Request<AssetDetails> GetCurrent()
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetDetails>(CAPI.ovr_LanguagePack_GetCurrent());
			}
			return null;
		}

		public static Request<AssetFileDownloadResult> SetCurrent(string tag)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetFileDownloadResult>(CAPI.ovr_LanguagePack_SetCurrent(tag));
			}
			return null;
		}
	}
	public static class Livestreaming
	{
		public static Request<LivestreamingStatus> GetStatus()
		{
			if (Core.IsInitialized())
			{
				return new Request<LivestreamingStatus>(CAPI.ovr_Livestreaming_GetStatus());
			}
			return null;
		}

		public static Request<LivestreamingStatus> PauseStream()
		{
			if (Core.IsInitialized())
			{
				return new Request<LivestreamingStatus>(CAPI.ovr_Livestreaming_PauseStream());
			}
			return null;
		}

		public static Request<LivestreamingStatus> ResumeStream()
		{
			if (Core.IsInitialized())
			{
				return new Request<LivestreamingStatus>(CAPI.ovr_Livestreaming_ResumeStream());
			}
			return null;
		}

		public static void SetStatusUpdateNotificationCallback(Message<LivestreamingStatus>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Livestreaming_StatusChange, callback);
		}
	}
	public static class Media
	{
		public static Request<ShareMediaResult> ShareToFacebook(string postTextSuggestion, string filePath, MediaContentType contentType)
		{
			if (Core.IsInitialized())
			{
				return new Request<ShareMediaResult>(CAPI.ovr_Media_ShareToFacebook(postTextSuggestion, filePath, contentType));
			}
			return null;
		}
	}
	public static class NetSync
	{
		public static void SetConnectionStatusChangedNotificationCallback(Message<NetSyncConnection>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_NetSync_ConnectionStatusChanged, callback);
		}

		public static void SetSessionsChangedNotificationCallback(Message<NetSyncSessionsChangedNotification>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_NetSync_SessionsChanged, callback);
		}
	}
	public static class Notifications
	{
		public static Request<RoomInviteNotificationList> GetRoomInviteNotifications()
		{
			if (Core.IsInitialized())
			{
				return new Request<RoomInviteNotificationList>(CAPI.ovr_Notification_GetRoomInvites());
			}
			return null;
		}

		public static Request MarkAsRead(ulong notificationID)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Notification_MarkAsRead(notificationID));
			}
			return null;
		}

		public static Request<RoomInviteNotificationList> GetNextRoomInviteNotificationListPage(RoomInviteNotificationList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.GetNextRoomInviteNotificationListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<RoomInviteNotificationList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 102890359));
			}
			return null;
		}
	}
	public static class Parties
	{
		public static Request<Party> GetCurrent()
		{
			if (Core.IsInitialized())
			{
				return new Request<Party>(CAPI.ovr_Party_GetCurrent());
			}
			return null;
		}

		public static void SetPartyUpdateNotificationCallback(Message<PartyUpdateNotification>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Party_PartyUpdate, callback);
		}
	}
	public static class RichPresence
	{
		public static Request Clear()
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_RichPresence_Clear());
			}
			return null;
		}

		public static Request<DestinationList> GetDestinations()
		{
			if (Core.IsInitialized())
			{
				return new Request<DestinationList>(CAPI.ovr_RichPresence_GetDestinations());
			}
			return null;
		}

		public static Request Set(RichPresenceOptions richPresenceOptions)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_RichPresence_Set((IntPtr)richPresenceOptions));
			}
			return null;
		}

		public static Request<DestinationList> GetNextDestinationListPage(DestinationList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.GetNextDestinationListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<DestinationList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 1731624773));
			}
			return null;
		}
	}
	public static class Users
	{
		public static Request<User> Get(ulong userID)
		{
			if (Core.IsInitialized())
			{
				return new Request<User>(CAPI.ovr_User_Get(userID));
			}
			return null;
		}

		public static Request<string> GetAccessToken()
		{
			if (Core.IsInitialized())
			{
				return new Request<string>(CAPI.ovr_User_GetAccessToken());
			}
			return null;
		}

		public static Request<User> GetLoggedInUser()
		{
			if (Core.IsInitialized())
			{
				return new Request<User>(CAPI.ovr_User_GetLoggedInUser());
			}
			return null;
		}

		public static Request<UserList> GetLoggedInUserFriends()
		{
			if (Core.IsInitialized())
			{
				return new Request<UserList>(CAPI.ovr_User_GetLoggedInUserFriends());
			}
			return null;
		}

		public static Request<UserAndRoomList> GetLoggedInUserFriendsAndRooms()
		{
			if (Core.IsInitialized())
			{
				return new Request<UserAndRoomList>(CAPI.ovr_User_GetLoggedInUserFriendsAndRooms());
			}
			return null;
		}

		public static Request<UserAndRoomList> GetLoggedInUserRecentlyMetUsersAndRooms(UserOptions userOptions = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<UserAndRoomList>(CAPI.ovr_User_GetLoggedInUserRecentlyMetUsersAndRooms((IntPtr)userOptions));
			}
			return null;
		}

		public static Request<OrgScopedID> GetOrgScopedID(ulong userID)
		{
			if (Core.IsInitialized())
			{
				return new Request<OrgScopedID>(CAPI.ovr_User_GetOrgScopedID(userID));
			}
			return null;
		}

		public static Request<SdkAccountList> GetSdkAccounts()
		{
			if (Core.IsInitialized())
			{
				return new Request<SdkAccountList>(CAPI.ovr_User_GetSdkAccounts());
			}
			return null;
		}

		public static Request<UserProof> GetUserProof()
		{
			if (Core.IsInitialized())
			{
				return new Request<UserProof>(CAPI.ovr_User_GetUserProof());
			}
			return null;
		}

		public static Request<LaunchFriendRequestFlowResult> LaunchFriendRequestFlow(ulong userID)
		{
			if (Core.IsInitialized())
			{
				return new Request<LaunchFriendRequestFlowResult>(CAPI.ovr_User_LaunchFriendRequestFlow(userID));
			}
			return null;
		}

		public static Request LaunchProfile(ulong userID)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_User_LaunchProfile(userID));
			}
			return null;
		}

		public static Request<UserAndRoomList> GetNextUserAndRoomListPage(UserAndRoomList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.GetNextUserAndRoomListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<UserAndRoomList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 2143146719));
			}
			return null;
		}

		public static Request<UserList> GetNextUserListPage(UserList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.GetNextUserListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<UserList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 645723971));
			}
			return null;
		}
	}
	public enum PlatformInitializeResult
	{
		[Description("SUCCESS")]
		Success = 0,
		[Description("UNINITIALIZED")]
		Uninitialized = -1,
		[Description("PRE_LOADED")]
		PreLoaded = -2,
		[Description("FILE_INVALID")]
		FileInvalid = -3,
		[Description("SIGNATURE_INVALID")]
		SignatureInvalid = -4,
		[Description("UNABLE_TO_VERIFY")]
		UnableToVerify = -5,
		[Description("VERSION_MISMATCH")]
		VersionMismatch = -6,
		[Description("UNKNOWN")]
		Unknown = -7,
		[Description("INVALID_CREDENTIALS")]
		InvalidCredentials = -8,
		[Description("NOT_ENTITLED")]
		NotEntitled = -9
	}
	public static class PlatformInternal
	{
		public enum MessageTypeInternal : uint
		{
			Application_ExecuteCoordinatedLaunch = 645772532u,
			Application_GetInstalledApplications = 1376744524u,
			Avatar_UpdateMetaData = 2077219214u,
			Cal_FinalizeApplication = 497667029u,
			Cal_GetSuggestedApplications = 1450209301u,
			Cal_ProposeApplication = 1317270237u,
			Colocation_GetCurrentMapUuid = 878018226u,
			Colocation_RequestMap = 840263277u,
			Colocation_ShareMap = 409847005u,
			GraphAPI_Get = 822018158u,
			GraphAPI_Post = 1990567876u,
			HTTP_Get = 1874211363u,
			HTTP_GetToFile = 1317133401u,
			HTTP_MultiPartPost = 1480774160u,
			HTTP_Post = 1798743375u,
			Livestreaming_IsAllowedForApplication = 191729014u,
			Livestreaming_StartPartyStream = 2066701532u,
			Livestreaming_StartStream = 1343932350u,
			Livestreaming_StopPartyStream = 661065560u,
			Livestreaming_StopStream = 1155796426u,
			Livestreaming_UpdateCommentsOverlayVisibility = 528318516u,
			Livestreaming_UpdateMicStatus = 475495815u,
			NetSync_Connect = 1684899167u,
			NetSync_Disconnect = 359268021u,
			NetSync_GetSessions = 1859521077u,
			NetSync_SetVoipGroup = 1477614734u,
			NetSync_SetVoipMicSource = 855832432u,
			NetSync_SetVoipSessionMuted = 1434844938u,
			NetSync_SetVoipStreamMode = 1742839095u,
			Party_Create = 450042703u,
			Party_GatherInApplication = 1921499523u,
			Party_Get = 1586058173u,
			Party_GetCurrentForUser = 1489764138u,
			Party_Invite = 901104867u,
			Party_Join = 1744993395u,
			Party_Leave = 848430801u,
			Room_CreateOrUpdateAndJoinNamed = 2089683601u,
			Room_GetNamedRooms = 125660812u,
			Room_GetSocialRooms = 1636310390u,
			SystemPermissions_GetStatus = 493497353u,
			SystemPermissions_LaunchDeeplink = 442139697u,
			User_CancelRecordingForReportFlow = 65065289u,
			User_GetLinkedAccounts = 1469314134u,
			User_LaunchBlockFlow = 1876305192u,
			User_LaunchReportFlow = 1449304081u,
			User_LaunchReportFlow2 = 2139314275u,
			User_LaunchUnblockFlow = 346172055u,
			User_NewEntitledTestUser = 292822787u,
			User_NewTestUser = 921194380u,
			User_NewTestUserFriends = 517416647u,
			User_StartRecordingForReportFlow = 1819161571u,
			User_StopRecordingAndLaunchReportFlow = 1618513035u,
			User_StopRecordingAndLaunchReportFlow2 = 432190251u,
			User_TestUserCreateDeviceManifest = 1701884605u
		}

		public static class HTTP
		{
			public static void SetHttpTransferUpdateCallback(Message<HttpTransferUpdate>.Callback callback)
			{
				Callback.SetNotificationCallback(Message.MessageType.Notification_HTTP_Transfer, callback);
			}
		}

		public static class Users
		{
			public static Request<LinkedAccountList> GetLinkedAccounts(ServiceProvider[] providers)
			{
				if (Core.IsInitialized())
				{
					UserOptions userOptions = new UserOptions();
					foreach (ServiceProvider value in providers)
					{
						userOptions.AddServiceProvider(value);
					}
					return new Request<LinkedAccountList>(CAPI.ovr_User_GetLinkedAccounts((IntPtr)userOptions));
				}
				return null;
			}
		}

		public static void CrashApplication()
		{
			CAPI.ovr_CrashApplication();
		}

		internal static Message ParseMessageHandle(IntPtr messageHandle, Message.MessageType messageType)
		{
			Message result = null;
			switch ((MessageTypeInternal)messageType)
			{
			case MessageTypeInternal.User_StartRecordingForReportFlow:
				result = new MessageWithAbuseReportRecording(messageHandle);
				break;
			case MessageTypeInternal.Cal_FinalizeApplication:
				result = new MessageWithCalApplicationFinalized(messageHandle);
				break;
			case MessageTypeInternal.Cal_GetSuggestedApplications:
				result = new MessageWithCalApplicationSuggestionList(messageHandle);
				break;
			case MessageTypeInternal.User_CancelRecordingForReportFlow:
			case MessageTypeInternal.Colocation_ShareMap:
			case MessageTypeInternal.Livestreaming_UpdateMicStatus:
			case MessageTypeInternal.Application_ExecuteCoordinatedLaunch:
			case MessageTypeInternal.Livestreaming_StopPartyStream:
			case MessageTypeInternal.Colocation_RequestMap:
			case MessageTypeInternal.Party_Leave:
			case MessageTypeInternal.NetSync_SetVoipMicSource:
			case MessageTypeInternal.Cal_ProposeApplication:
			case MessageTypeInternal.NetSync_SetVoipGroup:
			case MessageTypeInternal.User_TestUserCreateDeviceManifest:
				result = new Message(messageHandle);
				break;
			case MessageTypeInternal.Application_GetInstalledApplications:
				result = new MessageWithInstalledApplicationList(messageHandle);
				break;
			case MessageTypeInternal.User_LaunchBlockFlow:
				result = new MessageWithLaunchBlockFlowResult(messageHandle);
				break;
			case MessageTypeInternal.User_LaunchReportFlow2:
				result = new MessageWithLaunchReportFlowResult(messageHandle);
				break;
			case MessageTypeInternal.User_LaunchUnblockFlow:
				result = new MessageWithLaunchUnblockFlowResult(messageHandle);
				break;
			case MessageTypeInternal.User_GetLinkedAccounts:
				result = new MessageWithLinkedAccountList(messageHandle);
				break;
			case MessageTypeInternal.Livestreaming_IsAllowedForApplication:
				result = new MessageWithLivestreamingApplicationStatus(messageHandle);
				break;
			case MessageTypeInternal.Livestreaming_StartStream:
			case MessageTypeInternal.Livestreaming_StartPartyStream:
				result = new MessageWithLivestreamingStartResult(messageHandle);
				break;
			case MessageTypeInternal.Livestreaming_UpdateCommentsOverlayVisibility:
				result = new MessageWithLivestreamingStatus(messageHandle);
				break;
			case MessageTypeInternal.Livestreaming_StopStream:
				result = new MessageWithLivestreamingVideoStats(messageHandle);
				break;
			case MessageTypeInternal.NetSync_Disconnect:
			case MessageTypeInternal.NetSync_Connect:
				result = new MessageWithNetSyncConnection(messageHandle);
				break;
			case MessageTypeInternal.NetSync_GetSessions:
				result = new MessageWithNetSyncSessionList(messageHandle);
				break;
			case MessageTypeInternal.NetSync_SetVoipSessionMuted:
			case MessageTypeInternal.NetSync_SetVoipStreamMode:
				result = new MessageWithNetSyncSetSessionPropertyResult(messageHandle);
				break;
			case MessageTypeInternal.Party_Get:
				result = new MessageWithParty(messageHandle);
				break;
			case MessageTypeInternal.Party_GetCurrentForUser:
				result = new MessageWithPartyUnderCurrentParty(messageHandle);
				break;
			case MessageTypeInternal.Party_Create:
			case MessageTypeInternal.Party_Invite:
			case MessageTypeInternal.Party_Join:
			case MessageTypeInternal.Party_GatherInApplication:
				result = new MessageWithPartyID(messageHandle);
				break;
			case MessageTypeInternal.Room_CreateOrUpdateAndJoinNamed:
				result = new MessageWithRoomUnderViewerRoom(messageHandle);
				break;
			case MessageTypeInternal.Room_GetNamedRooms:
			case MessageTypeInternal.Room_GetSocialRooms:
				result = new MessageWithRoomList(messageHandle);
				break;
			case MessageTypeInternal.User_NewEntitledTestUser:
			case MessageTypeInternal.User_NewTestUserFriends:
			case MessageTypeInternal.GraphAPI_Get:
			case MessageTypeInternal.Colocation_GetCurrentMapUuid:
			case MessageTypeInternal.User_NewTestUser:
			case MessageTypeInternal.HTTP_GetToFile:
			case MessageTypeInternal.HTTP_MultiPartPost:
			case MessageTypeInternal.HTTP_Post:
			case MessageTypeInternal.HTTP_Get:
			case MessageTypeInternal.GraphAPI_Post:
			case MessageTypeInternal.Avatar_UpdateMetaData:
				result = new MessageWithString(messageHandle);
				break;
			case MessageTypeInternal.SystemPermissions_LaunchDeeplink:
			case MessageTypeInternal.SystemPermissions_GetStatus:
				result = new MessageWithSystemPermission(messageHandle);
				break;
			case MessageTypeInternal.User_StopRecordingAndLaunchReportFlow2:
			case MessageTypeInternal.User_LaunchReportFlow:
			case MessageTypeInternal.User_StopRecordingAndLaunchReportFlow:
				result = new MessageWithUserReportID(messageHandle);
				break;
			}
			return result;
		}

		public static Request<PlatformInitialize> InitializeStandaloneAsync(ulong appID, string accessToken)
		{
			Request<PlatformInitialize> result = new StandalonePlatform().AsyncInitialize(appID, accessToken) ?? throw new UnityException("Oculus Platform failed to initialize.");
			Core.ForceInitialized();
			new GameObject("Oculus.Platform.CallbackRunner").AddComponent<CallbackRunner>();
			return result;
		}
	}
	public sealed class PlatformSettings : ScriptableObject
	{
		[SerializeField]
		private string ovrAppID = "";

		[SerializeField]
		private string ovrMobileAppID = "";

		[SerializeField]
		private bool ovrUseStandalonePlatform = true;

		private static PlatformSettings instance;

		public static string AppID
		{
			get
			{
				return Instance.ovrAppID;
			}
			set
			{
				Instance.ovrAppID = value;
			}
		}

		public static string MobileAppID
		{
			get
			{
				return Instance.ovrMobileAppID;
			}
			set
			{
				Instance.ovrMobileAppID = value;
			}
		}

		public static bool UseStandalonePlatform
		{
			get
			{
				return Instance.ovrUseStandalonePlatform;
			}
			set
			{
				Instance.ovrUseStandalonePlatform = value;
			}
		}

		public static PlatformSettings Instance
		{
			get
			{
				if (instance == null)
				{
					instance = Resources.Load<PlatformSettings>("OculusPlatformSettings");
					if (instance == null)
					{
						instance = ScriptableObject.CreateInstance<PlatformSettings>();
					}
				}
				return instance;
			}
			set
			{
				instance = value;
			}
		}
	}
	public sealed class Request<T> : Request
	{
		private Message<T>.Callback callback_;

		public Request(ulong requestID)
			: base(requestID)
		{
		}

		public Request<T> OnComplete(Message<T>.Callback callback)
		{
			if (callback_ != null)
			{
				throw new UnityException("Attempted to attach multiple handlers to a Request.  This is not allowed.");
			}
			callback_ = callback;
			Callback.AddRequest(this);
			return this;
		}

		public override void HandleMessage(Message msg)
		{
			if (!(msg is Message<T>))
			{
				UnityEngine.Debug.LogError("Unable to handle message: " + msg.GetType());
				return;
			}
			if (callback_ != null)
			{
				callback_((Message<T>)msg);
				return;
			}
			throw new UnityException("Request with no handler.  This should never happen.");
		}
	}
	public class Request
	{
		private Message.Callback callback_;

		public ulong RequestID { get; set; }

		public Request(ulong requestID)
		{
			RequestID = requestID;
		}

		public Request OnComplete(Message.Callback callback)
		{
			callback_ = callback;
			Callback.AddRequest(this);
			return this;
		}

		public virtual void HandleMessage(Message msg)
		{
			if (callback_ != null)
			{
				callback_(msg);
				return;
			}
			throw new UnityException("Request with no handler.  This should never happen.");
		}

		public static void RunCallbacks(uint limit = 0u)
		{
			if (limit == 0)
			{
				Callback.RunCallbacks();
			}
			else
			{
				Callback.RunLimitedCallbacks(limit);
			}
		}
	}
	public enum RichPresenceExtraContext
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("NONE")]
		None,
		[Description("CURRENT_CAPACITY")]
		CurrentCapacity,
		[Description("STARTED_AGO")]
		StartedAgo,
		[Description("ENDING_IN")]
		EndingIn,
		[Description("LOOKING_FOR_A_MATCH")]
		LookingForAMatch
	}
	public class RichPresenceOptions
	{
		private IntPtr Handle;

		public RichPresenceOptions()
		{
			Handle = CAPI.ovr_RichPresenceOptions_Create();
		}

		public void SetApiName(string value)
		{
			CAPI.ovr_RichPresenceOptions_SetApiName(Handle, value);
		}

		public void SetArgs(string key, string value)
		{
			CAPI.ovr_RichPresenceOptions_SetArgsString(Handle, key, value);
		}

		public void ClearArgs()
		{
			CAPI.ovr_RichPresenceOptions_ClearArgs(Handle);
		}

		public void SetCurrentCapacity(uint value)
		{
			CAPI.ovr_RichPresenceOptions_SetCurrentCapacity(Handle, value);
		}

		public void SetDeeplinkMessageOverride(string value)
		{
			CAPI.ovr_RichPresenceOptions_SetDeeplinkMessageOverride(Handle, value);
		}

		public void SetEndTime(DateTime value)
		{
			CAPI.ovr_RichPresenceOptions_SetEndTime(Handle, value);
		}

		public void SetExtraContext(RichPresenceExtraContext value)
		{
			CAPI.ovr_RichPresenceOptions_SetExtraContext(Handle, value);
		}

		public void SetIsIdle(bool value)
		{
			CAPI.ovr_RichPresenceOptions_SetIsIdle(Handle, value);
		}

		public void SetIsJoinable(bool value)
		{
			CAPI.ovr_RichPresenceOptions_SetIsJoinable(Handle, value);
		}

		public void SetJoinableId(string value)
		{
			CAPI.ovr_RichPresenceOptions_SetJoinableId(Handle, value);
		}

		public void SetMaxCapacity(uint value)
		{
			CAPI.ovr_RichPresenceOptions_SetMaxCapacity(Handle, value);
		}

		public void SetStartTime(DateTime value)
		{
			CAPI.ovr_RichPresenceOptions_SetStartTime(Handle, value);
		}

		public static explicit operator IntPtr(RichPresenceOptions options)
		{
			return options?.Handle ?? IntPtr.Zero;
		}

		~RichPresenceOptions()
		{
			CAPI.ovr_RichPresenceOptions_Destroy(Handle);
		}
	}
	public enum RoomJoinability
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("ARE_IN")]
		AreIn,
		[Description("ARE_KICKED")]
		AreKicked,
		[Description("CAN_JOIN")]
		CanJoin,
		[Description("IS_FULL")]
		IsFull,
		[Description("NO_VIEWER")]
		NoViewer,
		[Description("POLICY_PREVENTS")]
		PolicyPrevents
	}
	public enum RoomJoinPolicy
	{
		[Description("NONE")]
		None,
		[Description("EVERYONE")]
		Everyone,
		[Description("FRIENDS_OF_MEMBERS")]
		FriendsOfMembers,
		[Description("FRIENDS_OF_OWNER")]
		FriendsOfOwner,
		[Description("INVITED_USERS")]
		InvitedUsers,
		[Description("UNKNOWN")]
		Unknown
	}
	public enum RoomMembershipLockStatus
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("LOCK")]
		Lock,
		[Description("UNLOCK")]
		Unlock
	}
	public class RoomOptions
	{
		private IntPtr Handle;

		public RoomOptions()
		{
			Handle = CAPI.ovr_RoomOptions_Create();
		}

		public void SetDataStore(string key, string value)
		{
			CAPI.ovr_RoomOptions_SetDataStoreString(Handle, key, value);
		}

		public void ClearDataStore()
		{
			CAPI.ovr_RoomOptions_ClearDataStore(Handle);
		}

		public void SetExcludeRecentlyMet(bool value)
		{
			CAPI.ovr_RoomOptions_SetExcludeRecentlyMet(Handle, value);
		}

		public void SetMaxUserResults(uint value)
		{
			CAPI.ovr_RoomOptions_SetMaxUserResults(Handle, value);
		}

		public void SetOrdering(UserOrdering value)
		{
			CAPI.ovr_RoomOptions_SetOrdering(Handle, value);
		}

		public void SetRecentlyMetTimeWindow(TimeWindow value)
		{
			CAPI.ovr_RoomOptions_SetRecentlyMetTimeWindow(Handle, value);
		}

		public void SetRoomId(ulong value)
		{
			CAPI.ovr_RoomOptions_SetRoomId(Handle, value);
		}

		public void SetTurnOffUpdates(bool value)
		{
			CAPI.ovr_RoomOptions_SetTurnOffUpdates(Handle, value);
		}

		public static explicit operator IntPtr(RoomOptions options)
		{
			return options?.Handle ?? IntPtr.Zero;
		}

		~RoomOptions()
		{
			CAPI.ovr_RoomOptions_Destroy(Handle);
		}
	}
	public enum RoomType
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("MATCHMAKING")]
		Matchmaking,
		[Description("MODERATED")]
		Moderated,
		[Description("PRIVATE")]
		Private,
		[Description("SOLO")]
		Solo
	}
	public enum SdkAccountType
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("OCULUS")]
		Oculus,
		[Description("FACEBOOK_GAMEROOM")]
		FacebookGameroom
	}
	public enum SendPolicy
	{
		[Description("UNRELIABLE")]
		Unreliable,
		[Description("RELIABLE")]
		Reliable,
		[Description("UNKNOWN")]
		Unknown
	}
	public enum ServiceProvider
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("DROPBOX")]
		Dropbox,
		[Description("FACEBOOK")]
		Facebook,
		[Description("GOOGLE")]
		Google,
		[Description("INSTAGRAM")]
		Instagram,
		[Description("REMOTE_MEDIA")]
		RemoteMedia
	}
	public enum ShareMediaStatus
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("SHARED")]
		Shared,
		[Description("CANCELED")]
		Canceled
	}
	public sealed class StandalonePlatform
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		public delegate void UnityLogDelegate(IntPtr tag, IntPtr msg);

		public Request<PlatformInitialize> InitializeInEditor()
		{
			if (string.IsNullOrEmpty(PlatformSettings.MobileAppID))
			{
				throw new UnityException("Update your App ID by selecting 'Oculus Platform' -> 'Edit Settings'");
			}
			string mobileAppID = PlatformSettings.MobileAppID;
			if (string.IsNullOrEmpty(StandalonePlatformSettings.OculusPlatformTestUserAccessToken))
			{
				throw new UnityException("Update your standalone credentials by selecting 'Oculus Platform' -> 'Edit Settings'");
			}
			string oculusPlatformTestUserAccessToken = StandalonePlatformSettings.OculusPlatformTestUserAccessToken;
			return AsyncInitialize(ulong.Parse(mobileAppID), oculusPlatformTestUserAccessToken);
		}

		public Request<PlatformInitialize> AsyncInitialize(ulong appID, string accessToken)
		{
			CAPI.ovr_UnityResetTestPlatform();
			CAPI.ovr_UnityInitGlobals(IntPtr.Zero);
			return new Request<PlatformInitialize>(CAPI.ovr_PlatformInitializeWithAccessToken(appID, accessToken));
		}
	}
	public sealed class StandalonePlatformSettings
	{
		public static string OculusPlatformTestUserEmail
		{
			get
			{
				return string.Empty;
			}
			set
			{
			}
		}

		public static string OculusPlatformTestUserPassword
		{
			get
			{
				return string.Empty;
			}
			set
			{
			}
		}

		public static string OculusPlatformTestUserAccessToken
		{
			get
			{
				return string.Empty;
			}
			set
			{
			}
		}
	}
	public enum SystemVoipStatus
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("UNAVAILABLE")]
		Unavailable,
		[Description("SUPPRESSED")]
		Suppressed,
		[Description("ACTIVE")]
		Active
	}
	public enum TimeWindow
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("ONE_HOUR")]
		OneHour,
		[Description("ONE_DAY")]
		OneDay,
		[Description("ONE_WEEK")]
		OneWeek,
		[Description("THIRTY_DAYS")]
		ThirtyDays,
		[Description("NINETY_DAYS")]
		NinetyDays
	}
	public class UserOptions
	{
		private IntPtr Handle;

		public UserOptions()
		{
			Handle = CAPI.ovr_UserOptions_Create();
		}

		public void SetMaxUsers(uint value)
		{
			CAPI.ovr_UserOptions_SetMaxUsers(Handle, value);
		}

		public void AddServiceProvider(ServiceProvider value)
		{
			CAPI.ovr_UserOptions_AddServiceProvider(Handle, value);
		}

		public void ClearServiceProviders()
		{
			CAPI.ovr_UserOptions_ClearServiceProviders(Handle);
		}

		public void SetTimeWindow(TimeWindow value)
		{
			CAPI.ovr_UserOptions_SetTimeWindow(Handle, value);
		}

		public static explicit operator IntPtr(UserOptions options)
		{
			return options?.Handle ?? IntPtr.Zero;
		}

		~UserOptions()
		{
			CAPI.ovr_UserOptions_Destroy(Handle);
		}
	}
	public enum UserOrdering
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("NONE")]
		None,
		[Description("PRESENCE_ALPHABETICAL")]
		PresenceAlphabetical
	}
	public enum UserPresenceStatus
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("ONLINE")]
		Online,
		[Description("OFFLINE")]
		Offline
	}
	public class VoipAudioSourceHiLevel : MonoBehaviour
	{
		public class FilterReadDelegate : MonoBehaviour
		{
			public VoipAudioSourceHiLevel parent;

			private float[] scratchBuffer;

			private void Awake()
			{
				int num = (int)(uint)CAPI.ovr_Voip_GetOutputBufferMaxSize();
				scratchBuffer = new float[num];
			}

			private void OnAudioFilterRead(float[] data, int channels)
			{
				int num = data.Length / channels;
				int num2 = num;
				if (num2 > scratchBuffer.Length)
				{
					Array.Clear(data, 0, data.Length);
					throw new Exception($"Audio system tried to pull {num} bytes, max voip internal ring buffer size {scratchBuffer.Length}");
				}
				int num3 = parent.pcmSource.PeekSizeElements();
				if (num3 < num2)
				{
					if (verboseLogging)
					{
						UnityEngine.Debug.LogFormat("Voip starved! Want {0}, but only have {1} available", num2, num3);
					}
					return;
				}
				int pCM = parent.pcmSource.GetPCM(scratchBuffer, num2);
				if (pCM < num2)
				{
					UnityEngine.Debug.LogWarningFormat("GetPCM() returned {0} samples, expected {1}", pCM, num2);
					return;
				}
				int num4 = 0;
				float num5 = -1f;
				for (int i = 0; i < num; i++)
				{
					float num6 = scratchBuffer[i];
					for (int j = 0; j < channels; j++)
					{
						data[num4++] = num6;
						if (num6 > num5)
						{
							num5 = num6;
						}
					}
				}
				parent.peakAmplitude = num5;
			}
		}

		private int initialPlaybackDelayMS;

		public AudioSource audioSource;

		public float peakAmplitude;

		protected IVoipPCMSource pcmSource;

		private static int audioSystemPlaybackFrequency;

		private static bool verboseLogging;

		public ulong senderID
		{
			set
			{
				pcmSource.SetSenderID(value);
			}
		}

		protected void Stop()
		{
		}

		private VoipSampleRate SampleRateToEnum(int rate)
		{
			return rate switch
			{
				48000 => VoipSampleRate.HZ48000, 
				44100 => VoipSampleRate.HZ44100, 
				24000 => VoipSampleRate.HZ24000, 
				_ => VoipSampleRate.Unknown, 
			};
		}

		protected void Awake()
		{
			CreatePCMSource();
			if (audioSource == null)
			{
				audioSource = base.gameObject.AddComponent<AudioSource>();
			}
			audioSource.gameObject.AddComponent<FilterReadDelegate>();
			audioSource.gameObject.GetComponent<FilterReadDelegate>().parent = this;
			initialPlaybackDelayMS = 40;
			audioSystemPlaybackFrequency = AudioSettings.outputSampleRate;
			CAPI.ovr_Voip_SetOutputSampleRate(SampleRateToEnum(audioSystemPlaybackFrequency));
			if (verboseLogging)
			{
				UnityEngine.Debug.LogFormat("freq {0}", audioSystemPlaybackFrequency);
			}
		}

		private void Start()
		{
			audioSource.Stop();
		}

		protected virtual void CreatePCMSource()
		{
			pcmSource = new VoipPCMSourceNative();
		}

		protected static int MSToElements(int ms)
		{
			return ms * audioSystemPlaybackFrequency / 1000;
		}

		private void Update()
		{
			pcmSource.Update();
			if (!audioSource.isPlaying && pcmSource.PeekSizeElements() >= MSToElements(initialPlaybackDelayMS))
			{
				if (verboseLogging)
				{
					UnityEngine.Debug.LogFormat("buffered {0} elements, starting playback", pcmSource.PeekSizeElements());
				}
				audioSource.Play();
			}
		}
	}
	public enum VoipBitrate
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("B16000")]
		B16000,
		[Description("B24000")]
		B24000,
		[Description("B32000")]
		B32000,
		[Description("B64000")]
		B64000,
		[Description("B96000")]
		B96000,
		[Description("B128000")]
		B128000
	}
	public enum VoipDtxState
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("ENABLED")]
		Enabled,
		[Description("DISABLED")]
		Disabled
	}
	public enum VoipMuteState
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("MUTED")]
		Muted,
		[Description("UNMUTED")]
		Unmuted
	}
	public class VoipOptions
	{
		private IntPtr Handle;

		public VoipOptions()
		{
			Handle = CAPI.ovr_VoipOptions_Create();
		}

		public void SetBitrateForNewConnections(VoipBitrate value)
		{
			CAPI.ovr_VoipOptions_SetBitrateForNewConnections(Handle, value);
		}

		public void SetCreateNewConnectionUseDtx(VoipDtxState value)
		{
			CAPI.ovr_VoipOptions_SetCreateNewConnectionUseDtx(Handle, value);
		}

		public static explicit operator IntPtr(VoipOptions options)
		{
			return options?.Handle ?? IntPtr.Zero;
		}

		~VoipOptions()
		{
			CAPI.ovr_VoipOptions_Destroy(Handle);
		}
	}
	public class VoipPCMSourceNative : IVoipPCMSource
	{
		private ulong senderID;

		public int GetPCM(float[] dest, int length)
		{
			return (int)(uint)CAPI.ovr_Voip_GetPCMFloat(senderID, dest, (UIntPtr)(ulong)length);
		}

		public void SetSenderID(ulong senderID)
		{
			this.senderID = senderID;
		}

		public int PeekSizeElements()
		{
			return (int)(uint)CAPI.ovr_Voip_GetPCMSize(senderID);
		}

		public void Update()
		{
		}
	}
	public enum VoipSampleRate
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("HZ24000")]
		HZ24000,
		[Description("HZ44100")]
		HZ44100,
		[Description("HZ48000")]
		HZ48000
	}
	public class WindowsPlatform
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		public delegate void UnityLogDelegate(IntPtr tag, IntPtr msg);

		private void CPPLogCallback(IntPtr tag, IntPtr message)
		{
			UnityEngine.Debug.Log($"{Marshal.PtrToStringAnsi(tag)}: {Marshal.PtrToStringAnsi(message)}");
		}

		private IntPtr getCallbackPointer()
		{
			return IntPtr.Zero;
		}

		public bool Initialize(string appId)
		{
			if (string.IsNullOrEmpty(appId))
			{
				throw new UnityException("AppID must not be null or empty");
			}
			CAPI.ovr_UnityInitWrapperWindows(appId, getCallbackPointer());
			return true;
		}

		public Request<PlatformInitialize> AsyncInitialize(string appId)
		{
			if (string.IsNullOrEmpty(appId))
			{
				throw new UnityException("AppID must not be null or empty");
			}
			return new Request<PlatformInitialize>(CAPI.ovr_UnityInitWrapperWindowsAsynchronous(appId, getCallbackPointer()));
		}
	}
}
namespace Oculus.Platform.Models
{
	public class AbuseReportRecording
	{
		public readonly string RecordingUuid;

		public AbuseReportRecording(IntPtr o)
		{
			RecordingUuid = CAPI.ovr_AbuseReportRecording_GetRecordingUuid(o);
		}
	}
	public class AchievementDefinition
	{
		public readonly AchievementType Type;

		public readonly string Name;

		public readonly uint BitfieldLength;

		public readonly ulong Target;

		public AchievementDefinition(IntPtr o)
		{
			Type = CAPI.ovr_AchievementDefinition_GetType(o);
			Name = CAPI.ovr_AchievementDefinition_GetName(o);
			BitfieldLength = CAPI.ovr_AchievementDefinition_GetBitfieldLength(o);
			Target = CAPI.ovr_AchievementDefinition_GetTarget(o);
		}
	}
	public class AchievementDefinitionList : DeserializableList<AchievementDefinition>
	{
		public AchievementDefinitionList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_AchievementDefinitionArray_GetSize(a);
			_Data = new List<AchievementDefinition>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new AchievementDefinition(CAPI.ovr_AchievementDefinitionArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_AchievementDefinitionArray_GetNextUrl(a);
		}
	}
	public class AchievementProgress
	{
		public readonly string Bitfield;

		public readonly ulong Count;

		public readonly bool IsUnlocked;

		public readonly string Name;

		public readonly DateTime UnlockTime;

		public AchievementProgress(IntPtr o)
		{
			Bitfield = CAPI.ovr_AchievementProgress_GetBitfield(o);
			Count = CAPI.ovr_AchievementProgress_GetCount(o);
			IsUnlocked = CAPI.ovr_AchievementProgress_GetIsUnlocked(o);
			Name = CAPI.ovr_AchievementProgress_GetName(o);
			UnlockTime = CAPI.ovr_AchievementProgress_GetUnlockTime(o);
		}
	}
	public class AchievementProgressList : DeserializableList<AchievementProgress>
	{
		public AchievementProgressList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_AchievementProgressArray_GetSize(a);
			_Data = new List<AchievementProgress>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new AchievementProgress(CAPI.ovr_AchievementProgressArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_AchievementProgressArray_GetNextUrl(a);
		}
	}
	public class AchievementUpdate
	{
		public readonly bool JustUnlocked;

		public readonly string Name;

		public AchievementUpdate(IntPtr o)
		{
			JustUnlocked = CAPI.ovr_AchievementUpdate_GetJustUnlocked(o);
			Name = CAPI.ovr_AchievementUpdate_GetName(o);
		}
	}
	public class ApplicationVersion
	{
		public readonly int CurrentCode;

		public readonly string CurrentName;

		public readonly int LatestCode;

		public readonly string LatestName;

		public ApplicationVersion(IntPtr o)
		{
			CurrentCode = CAPI.ovr_ApplicationVersion_GetCurrentCode(o);
			CurrentName = CAPI.ovr_ApplicationVersion_GetCurrentName(o);
			LatestCode = CAPI.ovr_ApplicationVersion_GetLatestCode(o);
			LatestName = CAPI.ovr_ApplicationVersion_GetLatestName(o);
		}
	}
	public class AssetDetails
	{
		public readonly ulong AssetId;

		public readonly string AssetType;

		public readonly string DownloadStatus;

		public readonly string Filepath;

		public readonly string IapStatus;

		public readonly LanguagePackInfo LanguageOptional;

		[Obsolete("Deprecated in favor of LanguageOptional")]
		public readonly LanguagePackInfo Language;

		public readonly string Metadata;

		public AssetDetails(IntPtr o)
		{
			AssetId = CAPI.ovr_AssetDetails_GetAssetId(o);
			AssetType = CAPI.ovr_AssetDetails_GetAssetType(o);
			DownloadStatus = CAPI.ovr_AssetDetails_GetDownloadStatus(o);
			Filepath = CAPI.ovr_AssetDetails_GetFilepath(o);
			IapStatus = CAPI.ovr_AssetDetails_GetIapStatus(o);
			IntPtr intPtr = CAPI.ovr_AssetDetails_GetLanguage(o);
			Language = new LanguagePackInfo(intPtr);
			if (intPtr == IntPtr.Zero)
			{
				LanguageOptional = null;
			}
			else
			{
				LanguageOptional = Language;
			}
			Metadata = CAPI.ovr_AssetDetails_GetMetadata(o);
		}
	}
	public class AssetDetailsList : DeserializableList<AssetDetails>
	{
		public AssetDetailsList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_AssetDetailsArray_GetSize(a);
			_Data = new List<AssetDetails>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new AssetDetails(CAPI.ovr_AssetDetailsArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
		}
	}
	public class AssetFileDeleteResult
	{
		public readonly ulong AssetFileId;

		public readonly ulong AssetId;

		public readonly string Filepath;

		public readonly bool Success;

		public AssetFileDeleteResult(IntPtr o)
		{
			AssetFileId = CAPI.ovr_AssetFileDeleteResult_GetAssetFileId(o);
			AssetId = CAPI.ovr_AssetFileDeleteResult_GetAssetId(o);
			Filepath = CAPI.ovr_AssetFileDeleteResult_GetFilepath(o);
			Success = CAPI.ovr_AssetFileDeleteResult_GetSuccess(o);
		}
	}
	public class AssetFileDownloadCancelResult
	{
		public readonly ulong AssetFileId;

		public readonly ulong AssetId;

		public readonly string Filepath;

		public readonly bool Success;

		public AssetFileDownloadCancelResult(IntPtr o)
		{
			AssetFileId = CAPI.ovr_AssetFileDownloadCancelResult_GetAssetFileId(o);
			AssetId = CAPI.ovr_AssetFileDownloadCancelResult_GetAssetId(o);
			Filepath = CAPI.ovr_AssetFileDownloadCancelResult_GetFilepath(o);
			Success = CAPI.ovr_AssetFileDownloadCancelResult_GetSuccess(o);
		}
	}
	public class AssetFileDownloadResult
	{
		public readonly ulong AssetId;

		public readonly string Filepath;

		public AssetFileDownloadResult(IntPtr o)
		{
			AssetId = CAPI.ovr_AssetFileDownloadResult_GetAssetId(o);
			Filepath = CAPI.ovr_AssetFileDownloadResult_GetFilepath(o);
		}
	}
	public class AssetFileDownloadUpdate
	{
		public readonly ulong AssetFileId;

		public readonly ulong AssetId;

		public readonly uint BytesTotal;

		public readonly int BytesTransferred;

		public readonly bool Completed;

		public AssetFileDownloadUpdate(IntPtr o)
		{
			AssetFileId = CAPI.ovr_AssetFileDownloadUpdate_GetAssetFileId(o);
			AssetId = CAPI.ovr_AssetFileDownloadUpdate_GetAssetId(o);
			BytesTotal = CAPI.ovr_AssetFileDownloadUpdate_GetBytesTotal(o);
			BytesTransferred = CAPI.ovr_AssetFileDownloadUpdate_GetBytesTransferred(o);
			Completed = CAPI.ovr_AssetFileDownloadUpdate_GetCompleted(o);
		}
	}
	public class CalApplicationFinalized
	{
		public readonly int CountdownMS;

		public readonly ulong ID;

		public readonly string LaunchDetails;

		public CalApplicationFinalized(IntPtr o)
		{
			CountdownMS = CAPI.ovr_CalApplicationFinalized_GetCountdownMS(o);
			ID = CAPI.ovr_CalApplicationFinalized_GetID(o);
			LaunchDetails = CAPI.ovr_CalApplicationFinalized_GetLaunchDetails(o);
		}
	}
	public class CalApplicationProposed
	{
		public readonly ulong ID;

		public CalApplicationProposed(IntPtr o)
		{
			ID = CAPI.ovr_CalApplicationProposed_GetID(o);
		}
	}
	public class CalApplicationSuggestion
	{
		public readonly ulong ID;

		public readonly string SocialContext;

		public CalApplicationSuggestion(IntPtr o)
		{
			ID = CAPI.ovr_CalApplicationSuggestion_GetID(o);
			SocialContext = CAPI.ovr_CalApplicationSuggestion_GetSocialContext(o);
		}
	}
	public class CalApplicationSuggestionList : DeserializableList<CalApplicationSuggestion>
	{
		public CalApplicationSuggestionList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_CalApplicationSuggestionArray_GetSize(a);
			_Data = new List<CalApplicationSuggestion>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new CalApplicationSuggestion(CAPI.ovr_CalApplicationSuggestionArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
		}
	}
	public class CloudStorageConflictMetadata
	{
		public readonly CloudStorageMetadata Local;

		public readonly CloudStorageMetadata Remote;

		public CloudStorageConflictMetadata(IntPtr o)
		{
			Local = new CloudStorageMetadata(CAPI.ovr_CloudStorageConflictMetadata_GetLocal(o));
			Remote = new CloudStorageMetadata(CAPI.ovr_CloudStorageConflictMetadata_GetRemote(o));
		}
	}
	public class CloudStorageData
	{
		public readonly string Bucket;

		public readonly byte[] Data;

		public readonly uint DataSize;

		public readonly string Key;

		public CloudStorageData(IntPtr o)
		{
			Bucket = CAPI.ovr_CloudStorageData_GetBucket(o);
			Data = CAPI.ovr_CloudStorageData_GetData(o);
			DataSize = CAPI.ovr_CloudStorageData_GetDataSize(o);
			Key = CAPI.ovr_CloudStorageData_GetKey(o);
		}
	}
	public class CloudStorageMetadata
	{
		public readonly string Bucket;

		public readonly long Counter;

		public readonly uint DataSize;

		public readonly string ExtraData;

		public readonly string Key;

		public readonly ulong SaveTime;

		public readonly CloudStorageDataStatus Status;

		public readonly string VersionHandle;

		public CloudStorageMetadata(IntPtr o)
		{
			Bucket = CAPI.ovr_CloudStorageMetadata_GetBucket(o);
			Counter = CAPI.ovr_CloudStorageMetadata_GetCounter(o);
			DataSize = CAPI.ovr_CloudStorageMetadata_GetDataSize(o);
			ExtraData = CAPI.ovr_CloudStorageMetadata_GetExtraData(o);
			Key = CAPI.ovr_CloudStorageMetadata_GetKey(o);
			SaveTime = CAPI.ovr_CloudStorageMetadata_GetSaveTime(o);
			Status = CAPI.ovr_CloudStorageMetadata_GetStatus(o);
			VersionHandle = CAPI.ovr_CloudStorageMetadata_GetVersionHandle(o);
		}
	}
	public class CloudStorageMetadataList : DeserializableList<CloudStorageMetadata>
	{
		public CloudStorageMetadataList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_CloudStorageMetadataArray_GetSize(a);
			_Data = new List<CloudStorageMetadata>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new CloudStorageMetadata(CAPI.ovr_CloudStorageMetadataArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_CloudStorageMetadataArray_GetNextUrl(a);
		}
	}
	public class CloudStorageUpdateResponse
	{
		public readonly string Bucket;

		public readonly string Key;

		public readonly CloudStorageUpdateStatus Status;

		public readonly string VersionHandle;

		public CloudStorageUpdateResponse(IntPtr o)
		{
			Bucket = CAPI.ovr_CloudStorageUpdateResponse_GetBucket(o);
			Key = CAPI.ovr_CloudStorageUpdateResponse_GetKey(o);
			Status = CAPI.ovr_CloudStorageUpdateResponse_GetStatus(o);
			VersionHandle = CAPI.ovr_CloudStorageUpdateResponse_GetVersionHandle(o);
		}
	}
	public class DeserializableList<T> : IList<T>, ICollection<T>, IEnumerable<T>, IEnumerable
	{
		protected List<T> _Data;

		protected string _NextUrl;

		protected string _PreviousUrl;

		public int Count => _Data.Count;

		bool ICollection<T>.IsReadOnly => ((ICollection<T>)_Data).IsReadOnly;

		public T this[int index]
		{
			get
			{
				return _Data[index];
			}
			set
			{
				_Data[index] = value;
			}
		}

		[Obsolete("Use IList interface on the DeserializableList object instead.", false)]
		public List<T> Data => _Data;

		public bool HasNextPage => !string.IsNullOrEmpty(NextUrl);

		public bool HasPreviousPage => !string.IsNullOrEmpty(PreviousUrl);

		public string NextUrl => _NextUrl;

		public string PreviousUrl => _PreviousUrl;

		public int IndexOf(T obj)
		{
			return _Data.IndexOf(obj);
		}

		public void Add(T item)
		{
			_Data.Add(item);
		}

		public void Clear()
		{
			_Data.Clear();
		}

		public bool Contains(T item)
		{
			return _Data.Contains(item);
		}

		public void CopyTo(T[] array, int arrayIndex)
		{
			_Data.CopyTo(array, arrayIndex);
		}

		public IEnumerator<T> GetEnumerator()
		{
			return _Data.GetEnumerator();
		}

		public void Insert(int index, T item)
		{
			_Data.Insert(index, item);
		}

		public bool Remove(T item)
		{
			return _Data.Remove(item);
		}

		public void RemoveAt(int index)
		{
			_Data.RemoveAt(index);
		}

		private IEnumerator GetEnumerator1()
		{
			return GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator1();
		}
	}
	public class Destination
	{
		public readonly string ApiName;

		public readonly string DeeplinkMessage;

		public readonly string DisplayName;

		public Destination(IntPtr o)
		{
			ApiName = CAPI.ovr_Destination_GetApiName(o);
			DeeplinkMessage = CAPI.ovr_Destination_GetDeeplinkMessage(o);
			DisplayName = CAPI.ovr_Destination_GetDisplayName(o);
		}
	}
	public class DestinationList : DeserializableList<Destination>
	{
		public DestinationList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_DestinationArray_GetSize(a);
			_Data = new List<Destination>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new Destination(CAPI.ovr_DestinationArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_DestinationArray_GetNextUrl(a);
		}
	}
	public class Error
	{
		public readonly int Code;

		public readonly int HttpCode;

		public readonly string Message;

		public Error(int code, string message, int httpCode)
		{
			Message = message;
			Code = code;
			HttpCode = httpCode;
		}
	}
	public class HttpTransferUpdate
	{
		public readonly ulong ID;

		public readonly byte[] Payload;

		public readonly bool IsCompleted;

		public HttpTransferUpdate(IntPtr o)
		{
			ID = CAPI.ovr_HttpTransferUpdate_GetID(o);
			IsCompleted = CAPI.ovr_HttpTransferUpdate_IsCompleted(o);
			long num = (long)(ulong)CAPI.ovr_HttpTransferUpdate_GetSize(o);
			Payload = new byte[num];
			Marshal.Copy(CAPI.ovr_Packet_GetBytes(o), Payload, 0, (int)num);
		}
	}
	public class InstalledApplication
	{
		public readonly string ApplicationId;

		public readonly string PackageName;

		public readonly string Status;

		public readonly int VersionCode;

		public readonly string VersionName;

		public InstalledApplication(IntPtr o)
		{
			ApplicationId = CAPI.ovr_InstalledApplication_GetApplicationId(o);
			PackageName = CAPI.ovr_InstalledApplication_GetPackageName(o);
			Status = CAPI.ovr_InstalledApplication_GetStatus(o);
			VersionCode = CAPI.ovr_InstalledApplication_GetVersionCode(o);
			VersionName = CAPI.ovr_InstalledApplication_GetVersionName(o);
		}
	}
	public class InstalledApplicationList : DeserializableList<InstalledApplication>
	{
		public InstalledApplicationList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_InstalledApplicationArray_GetSize(a);
			_Data = new List<InstalledApplication>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new InstalledApplication(CAPI.ovr_InstalledApplicationArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
		}
	}
	public class LanguagePackInfo
	{
		public readonly string EnglishName;

		public readonly string NativeName;

		public readonly string Tag;

		public LanguagePackInfo(IntPtr o)
		{
			EnglishName = CAPI.ovr_LanguagePackInfo_GetEnglishName(o);
			NativeName = CAPI.ovr_LanguagePackInfo_GetNativeName(o);
			Tag = CAPI.ovr_LanguagePackInfo_GetTag(o);
		}
	}
	public class LaunchBlockFlowResult
	{
		public readonly bool DidBlock;

		public readonly bool DidCancel;

		public LaunchBlockFlowResult(IntPtr o)
		{
			DidBlock = CAPI.ovr_LaunchBlockFlowResult_GetDidBlock(o);
			DidCancel = CAPI.ovr_LaunchBlockFlowResult_GetDidCancel(o);
		}
	}
	public class LaunchDetails
	{
		public readonly string DeeplinkMessage;

		public readonly string DestinationApiName;

		public readonly string LaunchSource;

		public readonly LaunchType LaunchType;

		public readonly ulong RoomID;

		public readonly UserList UsersOptional;

		[Obsolete("Deprecated in favor of UsersOptional")]
		public readonly UserList Users;

		public LaunchDetails(IntPtr o)
		{
			DeeplinkMessage = CAPI.ovr_LaunchDetails_GetDeeplinkMessage(o);
			DestinationApiName = CAPI.ovr_LaunchDetails_GetDestinationApiName(o);
			LaunchSource = CAPI.ovr_LaunchDetails_GetLaunchSource(o);
			LaunchType = CAPI.ovr_LaunchDetails_GetLaunchType(o);
			RoomID = CAPI.ovr_LaunchDetails_GetRoomID(o);
			IntPtr intPtr = CAPI.ovr_LaunchDetails_GetUsers(o);
			Users = new UserList(intPtr);
			if (intPtr == IntPtr.Zero)
			{
				UsersOptional = null;
			}
			else
			{
				UsersOptional = Users;
			}
		}
	}
	public class LaunchFriendRequestFlowResult
	{
		public readonly bool DidCancel;

		public readonly bool DidSendRequest;

		public LaunchFriendRequestFlowResult(IntPtr o)
		{
			DidCancel = CAPI.ovr_LaunchFriendRequestFlowResult_GetDidCancel(o);
			DidSendRequest = CAPI.ovr_LaunchFriendRequestFlowResult_GetDidSendRequest(o);
		}
	}
	public class LaunchReportFlowResult
	{
		public readonly bool DidCancel;

		public readonly ulong UserReportId;

		public LaunchReportFlowResult(IntPtr o)
		{
			DidCancel = CAPI.ovr_LaunchReportFlowResult_GetDidCancel(o);
			UserReportId = CAPI.ovr_LaunchReportFlowResult_GetUserReportId(o);
		}
	}
	public class LaunchUnblockFlowResult
	{
		public readonly bool DidCancel;

		public readonly bool DidUnblock;

		public LaunchUnblockFlowResult(IntPtr o)
		{
			DidCancel = CAPI.ovr_LaunchUnblockFlowResult_GetDidCancel(o);
			DidUnblock = CAPI.ovr_LaunchUnblockFlowResult_GetDidUnblock(o);
		}
	}
	public class LeaderboardEntry
	{
		public readonly byte[] ExtraData;

		public readonly int Rank;

		public readonly long Score;

		public readonly DateTime Timestamp;

		public readonly User User;

		public LeaderboardEntry(IntPtr o)
		{
			ExtraData = CAPI.ovr_LeaderboardEntry_GetExtraData(o);
			Rank = CAPI.ovr_LeaderboardEntry_GetRank(o);
			Score = CAPI.ovr_LeaderboardEntry_GetScore(o);
			Timestamp = CAPI.ovr_LeaderboardEntry_GetTimestamp(o);
			User = new User(CAPI.ovr_LeaderboardEntry_GetUser(o));
		}
	}
	public class LeaderboardEntryList : DeserializableList<LeaderboardEntry>
	{
		public readonly ulong TotalCount;

		public LeaderboardEntryList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_LeaderboardEntryArray_GetSize(a);
			_Data = new List<LeaderboardEntry>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new LeaderboardEntry(CAPI.ovr_LeaderboardEntryArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			TotalCount = CAPI.ovr_LeaderboardEntryArray_GetTotalCount(a);
			_PreviousUrl = CAPI.ovr_LeaderboardEntryArray_GetPreviousUrl(a);
			_NextUrl = CAPI.ovr_LeaderboardEntryArray_GetNextUrl(a);
		}
	}
	public class LinkedAccount
	{
		public readonly string AccessToken;

		public readonly ServiceProvider ServiceProvider;

		public readonly string UserId;

		public LinkedAccount(IntPtr o)
		{
			AccessToken = CAPI.ovr_LinkedAccount_GetAccessToken(o);
			ServiceProvider = CAPI.ovr_LinkedAccount_GetServiceProvider(o);
			UserId = CAPI.ovr_LinkedAccount_GetUserId(o);
		}
	}
	public class LinkedAccountList : DeserializableList<LinkedAccount>
	{
		public LinkedAccountList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_LinkedAccountArray_GetSize(a);
			_Data = new List<LinkedAccount>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new LinkedAccount(CAPI.ovr_LinkedAccountArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
		}
	}
	public class LivestreamingApplicationStatus
	{
		public readonly bool StreamingEnabled;

		public LivestreamingApplicationStatus(IntPtr o)
		{
			StreamingEnabled = CAPI.ovr_LivestreamingApplicationStatus_GetStreamingEnabled(o);
		}
	}
	public class LivestreamingStartResult
	{
		public readonly LivestreamingStartStatus StreamingResult;

		public LivestreamingStartResult(IntPtr o)
		{
			StreamingResult = CAPI.ovr_LivestreamingStartResult_GetStreamingResult(o);
		}
	}
	public class LivestreamingStatus
	{
		public readonly bool CommentsVisible;

		public readonly bool IsPaused;

		public readonly bool LivestreamingEnabled;

		public readonly int LivestreamingType;

		public readonly bool MicEnabled;

		public LivestreamingStatus(IntPtr o)
		{
			CommentsVisible = CAPI.ovr_LivestreamingStatus_GetCommentsVisible(o);
			IsPaused = CAPI.ovr_LivestreamingStatus_GetIsPaused(o);
			LivestreamingEnabled = CAPI.ovr_LivestreamingStatus_GetLivestreamingEnabled(o);
			LivestreamingType = CAPI.ovr_LivestreamingStatus_GetLivestreamingType(o);
			MicEnabled = CAPI.ovr_LivestreamingStatus_GetMicEnabled(o);
		}
	}
	public class LivestreamingVideoStats
	{
		public readonly int CommentCount;

		public readonly int ReactionCount;

		public readonly string TotalViews;

		public LivestreamingVideoStats(IntPtr o)
		{
			CommentCount = CAPI.ovr_LivestreamingVideoStats_GetCommentCount(o);
			ReactionCount = CAPI.ovr_LivestreamingVideoStats_GetReactionCount(o);
			TotalViews = CAPI.ovr_LivestreamingVideoStats_GetTotalViews(o);
		}
	}
	public class MatchmakingAdminSnapshot
	{
		public readonly MatchmakingAdminSnapshotCandidateList Candidates;

		public readonly double MyCurrentThreshold;

		public MatchmakingAdminSnapshot(IntPtr o)
		{
			Candidates = new MatchmakingAdminSnapshotCandidateList(CAPI.ovr_MatchmakingAdminSnapshot_GetCandidates(o));
			MyCurrentThreshold = CAPI.ovr_MatchmakingAdminSnapshot_GetMyCurrentThreshold(o);
		}
	}
	public class MatchmakingAdminSnapshotCandidate
	{
		public readonly bool CanMatch;

		public readonly double MyTotalScore;

		public readonly double TheirCurrentThreshold;

		public readonly double TheirTotalScore;

		public readonly string TraceId;

		public MatchmakingAdminSnapshotCandidate(IntPtr o)
		{
			CanMatch = CAPI.ovr_MatchmakingAdminSnapshotCandidate_GetCanMatch(o);
			MyTotalScore = CAPI.ovr_MatchmakingAdminSnapshotCandidate_GetMyTotalScore(o);
			TheirCurrentThreshold = CAPI.ovr_MatchmakingAdminSnapshotCandidate_GetTheirCurrentThreshold(o);
			TheirTotalScore = CAPI.ovr_MatchmakingAdminSnapshotCandidate_GetTheirTotalScore(o);
			TraceId = CAPI.ovr_MatchmakingAdminSnapshotCandidate_GetTraceId(o);
		}
	}
	public class MatchmakingAdminSnapshotCandidateList : DeserializableList<MatchmakingAdminSnapshotCandidate>
	{
		public MatchmakingAdminSnapshotCandidateList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_MatchmakingAdminSnapshotCandidateArray_GetSize(a);
			_Data = new List<MatchmakingAdminSnapshotCandidate>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new MatchmakingAdminSnapshotCandidate(CAPI.ovr_MatchmakingAdminSnapshotCandidateArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
		}
	}
	public class MatchmakingBrowseResult
	{
		public readonly MatchmakingEnqueueResult EnqueueResult;

		public readonly RoomList Rooms;

		public MatchmakingBrowseResult(IntPtr o)
		{
			EnqueueResult = new MatchmakingEnqueueResult(CAPI.ovr_MatchmakingBrowseResult_GetEnqueueResult(o));
			Rooms = new RoomList(CAPI.ovr_MatchmakingBrowseResult_GetRooms(o));
		}
	}
	public class MatchmakingEnqueuedUser
	{
		public readonly Dictionary<string, string> CustomData;

		public readonly User UserOptional;

		[Obsolete("Deprecated in favor of UserOptional")]
		public readonly User User;

		public MatchmakingEnqueuedUser(IntPtr o)
		{
			CustomData = CAPI.DataStoreFromNative(CAPI.ovr_MatchmakingEnqueuedUser_GetCustomData(o));
			IntPtr intPtr = CAPI.ovr_MatchmakingEnqueuedUser_GetUser(o);
			User = new User(intPtr);
			if (intPtr == IntPtr.Zero)
			{
				UserOptional = null;
			}
			else
			{
				UserOptional = User;
			}
		}
	}
	public class MatchmakingEnqueuedUserList : DeserializableList<MatchmakingEnqueuedUser>
	{
		public MatchmakingEnqueuedUserList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_MatchmakingEnqueuedUserArray_GetSize(a);
			_Data = new List<MatchmakingEnqueuedUser>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new MatchmakingEnqueuedUser(CAPI.ovr_MatchmakingEnqueuedUserArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
		}
	}
	public class MatchmakingEnqueueResult
	{
		public readonly MatchmakingAdminSnapshot AdminSnapshotOptional;

		[Obsolete("Deprecated in favor of AdminSnapshotOptional")]
		public readonly MatchmakingAdminSnapshot AdminSnapshot;

		public readonly uint AverageWait;

		public readonly uint MatchesInLastHourCount;

		public readonly uint MaxExpectedWait;

		public readonly string Pool;

		public readonly uint RecentMatchPercentage;

		public readonly string RequestHash;

		public MatchmakingEnqueueResult(IntPtr o)
		{
			IntPtr intPtr = CAPI.ovr_MatchmakingEnqueueResult_GetAdminSnapshot(o);
			AdminSnapshot = new MatchmakingAdminSnapshot(intPtr);
			if (intPtr == IntPtr.Zero)
			{
				AdminSnapshotOptional = null;
			}
			else
			{
				AdminSnapshotOptional = AdminSnapshot;
			}
			AverageWait = CAPI.ovr_MatchmakingEnqueueResult_GetAverageWait(o);
			MatchesInLastHourCount = CAPI.ovr_MatchmakingEnqueueResult_GetMatchesInLastHourCount(o);
			MaxExpectedWait = CAPI.ovr_MatchmakingEnqueueResult_GetMaxExpectedWait(o);
			Pool = CAPI.ovr_MatchmakingEnqueueResult_GetPool(o);
			RecentMatchPercentage = CAPI.ovr_MatchmakingEnqueueResult_GetRecentMatchPercentage(o);
			RequestHash = CAPI.ovr_MatchmakingEnqueueResult_GetRequestHash(o);
		}
	}
	public class MatchmakingEnqueueResultAndRoom
	{
		public readonly MatchmakingEnqueueResult MatchmakingEnqueueResult;

		public readonly Room Room;

		public MatchmakingEnqueueResultAndRoom(IntPtr o)
		{
			MatchmakingEnqueueResult = new MatchmakingEnqueueResult(CAPI.ovr_MatchmakingEnqueueResultAndRoom_GetMatchmakingEnqueueResult(o));
			Room = new Room(CAPI.ovr_MatchmakingEnqueueResultAndRoom_GetRoom(o));
		}
	}
	public class MatchmakingStats
	{
		public readonly uint DrawCount;

		public readonly uint LossCount;

		public readonly uint SkillLevel;

		public readonly double SkillMean;

		public readonly double SkillStandardDeviation;

		public readonly uint WinCount;

		public MatchmakingStats(IntPtr o)
		{
			DrawCount = CAPI.ovr_MatchmakingStats_GetDrawCount(o);
			LossCount = CAPI.ovr_MatchmakingStats_GetLossCount(o);
			SkillLevel = CAPI.ovr_MatchmakingStats_GetSkillLevel(o);
			SkillMean = CAPI.ovr_MatchmakingStats_GetSkillMean(o);
			SkillStandardDeviation = CAPI.ovr_MatchmakingStats_GetSkillStandardDeviation(o);
			WinCount = CAPI.ovr_MatchmakingStats_GetWinCount(o);
		}
	}
	public class NetSyncConnection
	{
		public readonly long ConnectionId;

		public readonly NetSyncDisconnectReason DisconnectReason;

		public readonly ulong SessionId;

		public readonly NetSyncConnectionStatus Status;

		public readonly string ZoneId;

		public NetSyncConnection(IntPtr o)
		{
			ConnectionId = CAPI.ovr_NetSyncConnection_GetConnectionId(o);
			DisconnectReason = CAPI.ovr_NetSyncConnection_GetDisconnectReason(o);
			SessionId = CAPI.ovr_NetSyncConnection_GetSessionId(o);
			Status = CAPI.ovr_NetSyncConnection_GetStatus(o);
			ZoneId = CAPI.ovr_NetSyncConnection_GetZoneId(o);
		}
	}
	public class NetSyncSession
	{
		public readonly long ConnectionId;

		public readonly bool Muted;

		public readonly ulong SessionId;

		public readonly ulong UserId;

		public readonly string VoipGroup;

		public NetSyncSession(IntPtr o)
		{
			ConnectionId = CAPI.ovr_NetSyncSession_GetConnectionId(o);
			Muted = CAPI.ovr_NetSyncSession_GetMuted(o);
			SessionId = CAPI.ovr_NetSyncSession_GetSessionId(o);
			UserId = CAPI.ovr_NetSyncSession_GetUserId(o);
			VoipGroup = CAPI.ovr_NetSyncSession_GetVoipGroup(o);
		}
	}
	public class NetSyncSessionList : DeserializableList<NetSyncSession>
	{
		public NetSyncSessionList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_NetSyncSessionArray_GetSize(a);
			_Data = new List<NetSyncSession>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new NetSyncSession(CAPI.ovr_NetSyncSessionArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
		}
	}
	public class NetSyncSessionsChangedNotification
	{
		public readonly long ConnectionId;

		public readonly NetSyncSessionList Sessions;

		public NetSyncSessionsChangedNotification(IntPtr o)
		{
			ConnectionId = CAPI.ovr_NetSyncSessionsChangedNotification_GetConnectionId(o);
			Sessions = new NetSyncSessionList(CAPI.ovr_NetSyncSessionsChangedNotification_GetSessions(o));
		}
	}
	public class NetSyncSetSessionPropertyResult
	{
		public readonly NetSyncSession Session;

		public NetSyncSetSessionPropertyResult(IntPtr o)
		{
			Session = new NetSyncSession(CAPI.ovr_NetSyncSetSessionPropertyResult_GetSession(o));
		}
	}
	public class NetworkingPeer
	{
		public ulong ID { get; private set; }

		public PeerConnectionState State { get; private set; }

		public NetworkingPeer(ulong id, PeerConnectionState state)
		{
			ID = id;
			State = state;
		}
	}
	public class OrgScopedID
	{
		public readonly ulong ID;

		public OrgScopedID(IntPtr o)
		{
			ID = CAPI.ovr_OrgScopedID_GetID(o);
		}
	}
	public class Party
	{
		public readonly ulong ID;

		public readonly UserList InvitedUsersOptional;

		[Obsolete("Deprecated in favor of InvitedUsersOptional")]
		public readonly UserList InvitedUsers;

		public readonly User LeaderOptional;

		[Obsolete("Deprecated in favor of LeaderOptional")]
		public readonly User Leader;

		public readonly Room RoomOptional;

		[Obsolete("Deprecated in favor of RoomOptional")]
		public readonly Room Room;

		public readonly UserList UsersOptional;

		[Obsolete("Deprecated in favor of UsersOptional")]
		public readonly UserList Users;

		public Party(IntPtr o)
		{
			ID = CAPI.ovr_Party_GetID(o);
			IntPtr intPtr = CAPI.ovr_Party_GetInvitedUsers(o);
			InvitedUsers = new UserList(intPtr);
			if (intPtr == IntPtr.Zero)
			{
				InvitedUsersOptional = null;
			}
			else
			{
				InvitedUsersOptional = InvitedUsers;
			}
			IntPtr intPtr2 = CAPI.ovr_Party_GetLeader(o);
			Leader = new User(intPtr2);
			if (intPtr2 == IntPtr.Zero)
			{
				LeaderOptional = null;
			}
			else
			{
				LeaderOptional = Leader;
			}
			IntPtr intPtr3 = CAPI.ovr_Party_GetRoom(o);
			Room = new Room(intPtr3);
			if (intPtr3 == IntPtr.Zero)
			{
				RoomOptional = null;
			}
			else
			{
				RoomOptional = Room;
			}
			IntPtr intPtr4 = CAPI.ovr_Party_GetUsers(o);
			Users = new UserList(intPtr4);
			if (intPtr4 == IntPtr.Zero)
			{
				UsersOptional = null;
			}
			else
			{
				UsersOptional = Users;
			}
		}
	}
	public class PartyID
	{
		public readonly ulong ID;

		public PartyID(IntPtr o)
		{
			ID = CAPI.ovr_PartyID_GetID(o);
		}
	}
	public class PartyUpdateNotification
	{
		public readonly PartyUpdateAction Action;

		public readonly ulong PartyId;

		public readonly ulong SenderId;

		public readonly string UpdateTimestamp;

		public readonly string UserAlias;

		public readonly ulong UserId;

		public readonly string UserName;

		public PartyUpdateNotification(IntPtr o)
		{
			Action = CAPI.ovr_PartyUpdateNotification_GetAction(o);
			PartyId = CAPI.ovr_PartyUpdateNotification_GetPartyId(o);
			SenderId = CAPI.ovr_PartyUpdateNotification_GetSenderId(o);
			UpdateTimestamp = CAPI.ovr_PartyUpdateNotification_GetUpdateTimestamp(o);
			UserAlias = CAPI.ovr_PartyUpdateNotification_GetUserAlias(o);
			UserId = CAPI.ovr_PartyUpdateNotification_GetUserId(o);
			UserName = CAPI.ovr_PartyUpdateNotification_GetUserName(o);
		}
	}
	public class Pid
	{
		public readonly string Id;

		public Pid(IntPtr o)
		{
			Id = CAPI.ovr_Pid_GetId(o);
		}
	}
	public class PidList : DeserializableList<Pid>
	{
		public PidList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_PidArray_GetSize(a);
			_Data = new List<Pid>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new Pid(CAPI.ovr_PidArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
		}
	}
	public class PingResult
	{
		private ulong? pingTimeUsec;

		public ulong ID { get; private set; }

		public ulong PingTimeUsec
		{
			get
			{
				if (!pingTimeUsec.HasValue)
				{
					return 0uL;
				}
				return pingTimeUsec.Value;
			}
		}

		public bool IsTimeout => !pingTimeUsec.HasValue;

		public PingResult(ulong id, ulong? pingTimeUsec)
		{
			ID = id;
			this.pingTimeUsec = pingTimeUsec;
		}
	}
	public class PlatformInitialize
	{
		public readonly PlatformInitializeResult Result;

		public PlatformInitialize(IntPtr o)
		{
			Result = CAPI.ovr_PlatformInitialize_GetResult(o);
		}
	}
	public class Product
	{
		public readonly string Description;

		public readonly string FormattedPrice;

		public readonly string Name;

		public readonly string Sku;

		public Product(IntPtr o)
		{
			Description = CAPI.ovr_Product_GetDescription(o);
			FormattedPrice = CAPI.ovr_Product_GetFormattedPrice(o);
			Name = CAPI.ovr_Product_GetName(o);
			Sku = CAPI.ovr_Product_GetSKU(o);
		}
	}
	public class ProductList : DeserializableList<Product>
	{
		public ProductList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_ProductArray_GetSize(a);
			_Data = new List<Product>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new Product(CAPI.ovr_ProductArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_ProductArray_GetNextUrl(a);
		}
	}
	public class Purchase
	{
		public readonly DateTime ExpirationTime;

		public readonly DateTime GrantTime;

		public readonly ulong ID;

		public readonly string Sku;

		public Purchase(IntPtr o)
		{
			ExpirationTime = CAPI.ovr_Purchase_GetExpirationTime(o);
			GrantTime = CAPI.ovr_Purchase_GetGrantTime(o);
			ID = CAPI.ovr_Purchase_GetPurchaseID(o);
			Sku = CAPI.ovr_Purchase_GetSKU(o);
		}
	}
	public class PurchaseList : DeserializableList<Purchase>
	{
		public PurchaseList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_PurchaseArray_GetSize(a);
			_Data = new List<Purchase>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new Purchase(CAPI.ovr_PurchaseArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_PurchaseArray_GetNextUrl(a);
		}
	}
	public class Room
	{
		public readonly ulong ApplicationID;

		public readonly Dictionary<string, string> DataStore;

		public readonly string Description;

		public readonly ulong ID;

		public readonly UserList InvitedUsersOptional;

		[Obsolete("Deprecated in favor of InvitedUsersOptional")]
		public readonly UserList InvitedUsers;

		public readonly bool IsMembershipLocked;

		public readonly RoomJoinPolicy JoinPolicy;

		public readonly RoomJoinability Joinability;

		public readonly MatchmakingEnqueuedUserList MatchedUsersOptional;

		[Obsolete("Deprecated in favor of MatchedUsersOptional")]
		public readonly MatchmakingEnqueuedUserList MatchedUsers;

		public readonly uint MaxUsers;

		public readonly string Name;

		public readonly User OwnerOptional;

		[Obsolete("Deprecated in favor of OwnerOptional")]
		public readonly User Owner;

		public readonly TeamList TeamsOptional;

		[Obsolete("Deprecated in favor of TeamsOptional")]
		public readonly TeamList Teams;

		public readonly RoomType Type;

		public readonly UserList UsersOptional;

		[Obsolete("Deprecated in favor of UsersOptional")]
		public readonly UserList Users;

		public readonly uint Version;

		public Room(IntPtr o)
		{
			ApplicationID = CAPI.ovr_Room_GetApplicationID(o);
			DataStore = CAPI.DataStoreFromNative(CAPI.ovr_Room_GetDataStore(o));
			Description = CAPI.ovr_Room_GetDescription(o);
			ID = CAPI.ovr_Room_GetID(o);
			IntPtr intPtr = CAPI.ovr_Room_GetInvitedUsers(o);
			InvitedUsers = new UserList(intPtr);
			if (intPtr == IntPtr.Zero)
			{
				InvitedUsersOptional = null;
			}
			else
			{
				InvitedUsersOptional = InvitedUsers;
			}
			IsMembershipLocked = CAPI.ovr_Room_GetIsMembershipLocked(o);
			JoinPolicy = CAPI.ovr_Room_GetJoinPolicy(o);
			Joinability = CAPI.ovr_Room_GetJoinability(o);
			IntPtr intPtr2 = CAPI.ovr_Room_GetMatchedUsers(o);
			MatchedUsers = new MatchmakingEnqueuedUserList(intPtr2);
			if (intPtr2 == IntPtr.Zero)
			{
				MatchedUsersOptional = null;
			}
			else
			{
				MatchedUsersOptional = MatchedUsers;
			}
			MaxUsers = CAPI.ovr_Room_GetMaxUsers(o);
			Name = CAPI.ovr_Room_GetName(o);
			IntPtr intPtr3 = CAPI.ovr_Room_GetOwner(o);
			Owner = new User(intPtr3);
			if (intPtr3 == IntPtr.Zero)
			{
				OwnerOptional = null;
			}
			else
			{
				OwnerOptional = Owner;
			}
			IntPtr intPtr4 = CAPI.ovr_Room_GetTeams(o);
			Teams = new TeamList(intPtr4);
			if (intPtr4 == IntPtr.Zero)
			{
				TeamsOptional = null;
			}
			else
			{
				TeamsOptional = Teams;
			}
			Type = CAPI.ovr_Room_GetType(o);
			IntPtr intPtr5 = CAPI.ovr_Room_GetUsers(o);
			Users = new UserList(intPtr5);
			if (intPtr5 == IntPtr.Zero)
			{
				UsersOptional = null;
			}
			else
			{
				UsersOptional = Users;
			}
			Version = CAPI.ovr_Room_GetVersion(o);
		}
	}
	public class RoomList : DeserializableList<Room>
	{
		public RoomList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_RoomArray_GetSize(a);
			_Data = new List<Room>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new Room(CAPI.ovr_RoomArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_RoomArray_GetNextUrl(a);
		}
	}
	public class RoomInviteNotification
	{
		public readonly ulong ID;

		public readonly ulong RoomID;

		public readonly ulong SenderID;

		public readonly DateTime SentTime;

		public RoomInviteNotification(IntPtr o)
		{
			ID = CAPI.ovr_RoomInviteNotification_GetID(o);
			RoomID = CAPI.ovr_RoomInviteNotification_GetRoomID(o);
			SenderID = CAPI.ovr_RoomInviteNotification_GetSenderID(o);
			SentTime = CAPI.ovr_RoomInviteNotification_GetSentTime(o);
		}
	}
	public class RoomInviteNotificationList : DeserializableList<RoomInviteNotification>
	{
		public RoomInviteNotificationList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_RoomInviteNotificationArray_GetSize(a);
			_Data = new List<RoomInviteNotification>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new RoomInviteNotification(CAPI.ovr_RoomInviteNotificationArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_RoomInviteNotificationArray_GetNextUrl(a);
		}
	}
	public class SdkAccount
	{
		public readonly SdkAccountType AccountType;

		public readonly ulong UserId;

		public SdkAccount(IntPtr o)
		{
			AccountType = CAPI.ovr_SdkAccount_GetAccountType(o);
			UserId = CAPI.ovr_SdkAccount_GetUserId(o);
		}
	}
	public class SdkAccountList : DeserializableList<SdkAccount>
	{
		public SdkAccountList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_SdkAccountArray_GetSize(a);
			_Data = new List<SdkAccount>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new SdkAccount(CAPI.ovr_SdkAccountArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
		}
	}
	public class ShareMediaResult
	{
		public readonly ShareMediaStatus Status;

		public ShareMediaResult(IntPtr o)
		{
			Status = CAPI.ovr_ShareMediaResult_GetStatus(o);
		}
	}
	public class SystemPermission
	{
		public readonly bool HasPermission;

		public readonly PermissionGrantStatus PermissionGrantStatus;

		public SystemPermission(IntPtr o)
		{
			HasPermission = CAPI.ovr_SystemPermission_GetHasPermission(o);
			PermissionGrantStatus = CAPI.ovr_SystemPermission_GetPermissionGrantStatus(o);
		}
	}
	public class SystemVoipState
	{
		public readonly VoipMuteState MicrophoneMuted;

		public readonly SystemVoipStatus Status;

		public SystemVoipState(IntPtr o)
		{
			MicrophoneMuted = CAPI.ovr_SystemVoipState_GetMicrophoneMuted(o);
			Status = CAPI.ovr_SystemVoipState_GetStatus(o);
		}
	}
	public class Team
	{
		public readonly UserList AssignedUsers;

		public readonly int MaxUsers;

		public readonly int MinUsers;

		public readonly string Name;

		public Team(IntPtr o)
		{
			AssignedUsers = new UserList(CAPI.ovr_Team_GetAssignedUsers(o));
			MaxUsers = CAPI.ovr_Team_GetMaxUsers(o);
			MinUsers = CAPI.ovr_Team_GetMinUsers(o);
			Name = CAPI.ovr_Team_GetName(o);
		}
	}
	public class TeamList : DeserializableList<Team>
	{
		public TeamList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_TeamArray_GetSize(a);
			_Data = new List<Team>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new Team(CAPI.ovr_TeamArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
		}
	}
	public class User
	{
		public readonly ulong ID;

		public readonly string ImageURL;

		public readonly string InviteToken;

		public readonly string OculusID;

		public readonly string Presence;

		public readonly string PresenceDeeplinkMessage;

		public readonly string PresenceDestinationApiName;

		public readonly UserPresenceStatus PresenceStatus;

		public readonly string SmallImageUrl;

		public User(IntPtr o)
		{
			ID = CAPI.ovr_User_GetID(o);
			ImageURL = CAPI.ovr_User_GetImageUrl(o);
			InviteToken = CAPI.ovr_User_GetInviteToken(o);
			OculusID = CAPI.ovr_User_GetOculusID(o);
			Presence = CAPI.ovr_User_GetPresence(o);
			PresenceDeeplinkMessage = CAPI.ovr_User_GetPresenceDeeplinkMessage(o);
			PresenceDestinationApiName = CAPI.ovr_User_GetPresenceDestinationApiName(o);
			PresenceStatus = CAPI.ovr_User_GetPresenceStatus(o);
			SmallImageUrl = CAPI.ovr_User_GetSmallImageUrl(o);
		}
	}
	public class UserList : DeserializableList<User>
	{
		public UserList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_UserArray_GetSize(a);
			_Data = new List<User>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new User(CAPI.ovr_UserArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_UserArray_GetNextUrl(a);
		}
	}
	public class UserAndRoom
	{
		public readonly Room RoomOptional;

		[Obsolete("Deprecated in favor of RoomOptional")]
		public readonly Room Room;

		public readonly User User;

		public UserAndRoom(IntPtr o)
		{
			IntPtr intPtr = CAPI.ovr_UserAndRoom_GetRoom(o);
			Room = new Room(intPtr);
			if (intPtr == IntPtr.Zero)
			{
				RoomOptional = null;
			}
			else
			{
				RoomOptional = Room;
			}
			User = new User(CAPI.ovr_UserAndRoom_GetUser(o));
		}
	}
	public class UserAndRoomList : DeserializableList<UserAndRoom>
	{
		public UserAndRoomList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_UserAndRoomArray_GetSize(a);
			_Data = new List<UserAndRoom>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new UserAndRoom(CAPI.ovr_UserAndRoomArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_UserAndRoomArray_GetNextUrl(a);
		}
	}
	public class UserProof
	{
		public readonly string Value;

		public UserProof(IntPtr o)
		{
			Value = CAPI.ovr_UserProof_GetNonce(o);
		}
	}
	public class UserReportID
	{
		public readonly bool DidCancel;

		public readonly ulong ID;

		public UserReportID(IntPtr o)
		{
			DidCancel = CAPI.ovr_UserReportID_GetDidCancel(o);
			ID = CAPI.ovr_UserReportID_GetID(o);
		}
	}
}
namespace Oculus.Avatar
{
	public static class AvatarLogger
	{
		public const string LogAvatar = "[Avatars] - ";

		public const string Tab = "    ";

		[Conditional("ENABLE_AVATAR_LOGS")]
		[Conditional("ENABLE_AVATAR_LOG_BASIC")]
		public static void Log(string logMsg)
		{
			UnityEngine.Debug.Log("[Avatars] - " + logMsg);
		}

		[Conditional("ENABLE_AVATAR_LOGS")]
		[Conditional("ENABLE_AVATAR_LOG_BASIC")]
		public static void Log(string logMsg, UnityEngine.Object context)
		{
			UnityEngine.Debug.Log("[Avatars] - " + logMsg, context);
		}

		[Conditional("ENABLE_AVATAR_LOGS")]
		[Conditional("ENABLE_AVATAR_LOG_WARNING")]
		public static void LogWarning(string logMsg)
		{
			UnityEngine.Debug.LogWarning("[Avatars] - " + logMsg);
		}

		[Conditional("ENABLE_AVATAR_LOGS")]
		[Conditional("ENABLE_AVATAR_LOG_ERROR")]
		public static void LogError(string logMsg)
		{
			UnityEngine.Debug.LogError("[Avatars] - " + logMsg);
		}

		[Conditional("ENABLE_AVATAR_LOGS")]
		[Conditional("ENABLE_AVATAR_LOG_ERROR")]
		public static void LogError(string logMsg, UnityEngine.Object context)
		{
			UnityEngine.Debug.LogError("[Avatars] - " + logMsg, context);
		}
	}
	public class CAPI
	{
		public delegate void LoggingDelegate(IntPtr str);

		public enum Result
		{
			Success = 0,
			Failure = -1000,
			Failure_InvalidParameter = -1001,
			Failure_NotInitialized = -1002,
			Failure_InvalidOperation = -1003,
			Failure_Unsupported = -1004,
			Failure_NotYetImplemented = -1005,
			Failure_OperationFailed = -1006,
			Failure_InsufficientSize = -1007
		}

		private static class OVRP_1_30_0
		{
			public static readonly Version version = new Version(1, 30, 0);

			[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
			public static extern Result ovrp_SendEvent2(string name, string param, string source);
		}

		private const string LibFile = "ovravatarloader";

		private static IntPtr nativeVisemeData = IntPtr.Zero;

		private static IntPtr nativeGazeTargetsData = IntPtr.Zero;

		private static IntPtr nativeAvatarLightsData = IntPtr.Zero;

		private static IntPtr DebugLineCountData = IntPtr.Zero;

		private static float[] scratchBufferFloat = new float[16];

		private static GameObject debugLineGo;

		private static string SDKRuntimePrefix = "[RUNTIME] - ";

		private const string ovrPluginDLL = "OVRPlugin";

		private static Version ovrPluginVersion;

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_InitializeAndroidUnity(string appID);

		public static void Initialize()
		{
			nativeVisemeData = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(ovrAvatarVisemes)));
			nativeGazeTargetsData = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(ovrAvatarGazeTargets)));
			nativeAvatarLightsData = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(ovrAvatarLights)));
			DebugLineCountData = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(uint)));
			debugLineGo = new GameObject();
			debugLineGo.name = "AvatarSDKDebugDrawHelper";
		}

		public static void Shutdown()
		{
			Marshal.FreeHGlobal(nativeVisemeData);
			Marshal.FreeHGlobal(nativeGazeTargetsData);
			Marshal.FreeHGlobal(nativeAvatarLightsData);
			Marshal.FreeHGlobal(DebugLineCountData);
			debugLineGo = null;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_Shutdown();

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatarMessage_Pop();

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarMessageType ovrAvatarMessage_GetType(IntPtr msg);

		public static ovrAvatarMessage_AvatarSpecification ovrAvatarMessage_GetAvatarSpecification(IntPtr msg)
		{
			return (ovrAvatarMessage_AvatarSpecification)Marshal.PtrToStructure(ovrAvatarMessage_GetAvatarSpecification_Native(msg), typeof(ovrAvatarMessage_AvatarSpecification));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarMessage_GetAvatarSpecification")]
		private static extern IntPtr ovrAvatarMessage_GetAvatarSpecification_Native(IntPtr msg);

		public static ovrAvatarMessage_AssetLoaded ovrAvatarMessage_GetAssetLoaded(IntPtr msg)
		{
			return (ovrAvatarMessage_AssetLoaded)Marshal.PtrToStructure(ovrAvatarMessage_GetAssetLoaded_Native(msg), typeof(ovrAvatarMessage_AssetLoaded));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarMessage_GetAssetLoaded")]
		private static extern IntPtr ovrAvatarMessage_GetAssetLoaded_Native(IntPtr msg);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarMessage_Free(IntPtr msg);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatarSpecificationRequest_Create(ulong userID);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarSpecificationRequest_Destroy(IntPtr specificationRequest);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarSpecificationRequest_SetCombineMeshes(IntPtr specificationRequest, bool useCombinedMesh);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarSpecificationRequest_SetLookAndFeelVersion(IntPtr specificationRequest, ovrAvatarLookAndFeelVersion version);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarSpecificationRequest_SetLevelOfDetail(IntPtr specificationRequest, ovrAvatarAssetLevelOfDetail lod);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_RequestAvatarSpecification(ulong userID);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_RequestAvatarSpecificationFromSpecRequest(IntPtr specificationRequest);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarSpecificationRequest_SetFallbackLookAndFeelVersion(IntPtr specificationRequest, ovrAvatarLookAndFeelVersion version);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarSpecificationRequest_SetExpressiveFlag(IntPtr specificationRequest, bool enable);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatar_Create(IntPtr avatarSpecification, ovrAvatarCapabilities capabilities);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_Destroy(IntPtr avatar);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarPose_UpdateBody(IntPtr avatar, ovrAvatarTransform headPose);

		public static void ovrAvatarPose_UpdateVoiceVisualization(IntPtr avatar, float[] pcmData)
		{
			ovrAvatarPose_UpdateVoiceVisualization_Native(avatar, (uint)pcmData.Length, pcmData);
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarPose_UpdateVoiceVisualization")]
		private static extern void ovrAvatarPose_UpdateVoiceVisualization_Native(IntPtr avatar, uint pcmDataSize, [In] float[] pcmData);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarPose_UpdateHands(IntPtr avatar, ovrAvatarHandInputState inputStateLeft, ovrAvatarHandInputState inputStateRight);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarPose_UpdateHandsWithType(IntPtr avatar, ovrAvatarHandInputState inputStateLeft, ovrAvatarHandInputState inputStateRight, ovrAvatarControllerType type);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarPose_Finalize(IntPtr avatar, float elapsedSeconds);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetLeftControllerVisibility(IntPtr avatar, bool show);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetRightControllerVisibility(IntPtr avatar, bool show);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetLeftHandVisibility(IntPtr avatar, bool show);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetRightHandVisibility(IntPtr avatar, bool show);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovrAvatarComponent_Count(IntPtr avatar);

		public static void ovrAvatarComponent_Get(IntPtr avatar, uint index, bool includeName, ref ovrAvatarComponent component)
		{
			ovrAvatarComponent_Get(ovrAvatarComponent_Get_Native(avatar, index), includeName, ref component);
		}

		public static void ovrAvatarComponent_Get(IntPtr componentPtr, bool includeName, ref ovrAvatarComponent component)
		{
			Marshal.Copy(new IntPtr(componentPtr.ToInt64() + ovrAvatarComponent_Offsets.transform), scratchBufferFloat, 0, 10);
			OvrAvatar.ConvertTransform(scratchBufferFloat, ref component.transform);
			component.renderPartCount = (uint)Marshal.ReadInt32(componentPtr, ovrAvatarComponent_Offsets.renderPartCount);
			component.renderParts = Marshal.ReadIntPtr(componentPtr, ovrAvatarComponent_Offsets.renderParts);
			if (includeName)
			{
				IntPtr ptr = Marshal.ReadIntPtr(componentPtr, ovrAvatarComponent_Offsets.name);
				component.name = Marshal.PtrToStringAnsi(ptr);
			}
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarComponent_Get")]
		public static extern IntPtr ovrAvatarComponent_Get_Native(IntPtr avatar, uint index);

		public static bool ovrAvatarPose_GetBaseComponent(IntPtr avatar, ref ovrAvatarBaseComponent component)
		{
			IntPtr intPtr = ovrAvatarPose_GetBaseComponent_Native(avatar);
			if (intPtr == IntPtr.Zero)
			{
				return false;
			}
			int ofs = Marshal.SizeOf(typeof(ovrAvatarBaseComponent)) - Marshal.SizeOf(typeof(IntPtr));
			component.renderComponent = Marshal.ReadIntPtr(intPtr, ofs);
			return true;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarPose_GetBaseComponent")]
		private static extern IntPtr ovrAvatarPose_GetBaseComponent_Native(IntPtr avatar);

		public static IntPtr MarshalRenderComponent<T>(IntPtr ptr) where T : struct
		{
			return Marshal.ReadIntPtr(new IntPtr(ptr.ToInt64() + Marshal.OffsetOf(typeof(T), "renderComponent").ToInt64()));
		}

		public static bool ovrAvatarPose_GetBodyComponent(IntPtr avatar, ref ovrAvatarBodyComponent component)
		{
			IntPtr intPtr = ovrAvatarPose_GetBodyComponent_Native(avatar);
			if (intPtr == IntPtr.Zero)
			{
				return false;
			}
			Marshal.Copy(new IntPtr(intPtr.ToInt64() + ovrAvatarBodyComponent_Offsets.leftEyeTransform), scratchBufferFloat, 0, 10);
			OvrAvatar.ConvertTransform(scratchBufferFloat, ref component.leftEyeTransform);
			Marshal.Copy(new IntPtr(intPtr.ToInt64() + ovrAvatarBodyComponent_Offsets.rightEyeTransform), scratchBufferFloat, 0, 10);
			OvrAvatar.ConvertTransform(scratchBufferFloat, ref component.rightEyeTransform);
			Marshal.Copy(new IntPtr(intPtr.ToInt64() + ovrAvatarBodyComponent_Offsets.centerEyeTransform), scratchBufferFloat, 0, 10);
			OvrAvatar.ConvertTransform(scratchBufferFloat, ref component.centerEyeTransform);
			component.renderComponent = MarshalRenderComponent<ovrAvatarBodyComponent>(intPtr);
			return true;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarPose_GetBodyComponent")]
		private static extern IntPtr ovrAvatarPose_GetBodyComponent_Native(IntPtr avatar);

		public static bool ovrAvatarPose_GetLeftControllerComponent(IntPtr avatar, ref ovrAvatarControllerComponent component)
		{
			IntPtr intPtr = ovrAvatarPose_GetLeftControllerComponent_Native(avatar);
			if (intPtr == IntPtr.Zero)
			{
				return false;
			}
			int ofs = Marshal.SizeOf(typeof(ovrAvatarControllerComponent)) - Marshal.SizeOf(typeof(IntPtr));
			component.renderComponent = Marshal.ReadIntPtr(intPtr, ofs);
			return true;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarPose_GetLeftControllerComponent")]
		private static extern IntPtr ovrAvatarPose_GetLeftControllerComponent_Native(IntPtr avatar);

		public static bool ovrAvatarPose_GetRightControllerComponent(IntPtr avatar, ref ovrAvatarControllerComponent component)
		{
			IntPtr intPtr = ovrAvatarPose_GetRightControllerComponent_Native(avatar);
			if (intPtr == IntPtr.Zero)
			{
				return false;
			}
			int ofs = Marshal.SizeOf(typeof(ovrAvatarControllerComponent)) - Marshal.SizeOf(typeof(IntPtr));
			component.renderComponent = Marshal.ReadIntPtr(intPtr, ofs);
			return true;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarPose_GetRightControllerComponent")]
		private static extern IntPtr ovrAvatarPose_GetRightControllerComponent_Native(IntPtr avatar);

		public static bool ovrAvatarPose_GetLeftHandComponent(IntPtr avatar, ref ovrAvatarHandComponent component)
		{
			IntPtr intPtr = ovrAvatarPose_GetLeftHandComponent_Native(avatar);
			if (intPtr == IntPtr.Zero)
			{
				return false;
			}
			int ofs = Marshal.SizeOf(typeof(ovrAvatarHandComponent)) - Marshal.SizeOf(typeof(IntPtr));
			component.renderComponent = Marshal.ReadIntPtr(intPtr, ofs);
			return true;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarPose_GetLeftHandComponent")]
		private static extern IntPtr ovrAvatarPose_GetLeftHandComponent_Native(IntPtr avatar);

		public static bool ovrAvatarPose_GetRightHandComponent(IntPtr avatar, ref ovrAvatarHandComponent component)
		{
			IntPtr intPtr = ovrAvatarPose_GetRightHandComponent_Native(avatar);
			if (intPtr == IntPtr.Zero)
			{
				return false;
			}
			int ofs = Marshal.SizeOf(typeof(ovrAvatarHandComponent)) - Marshal.SizeOf(typeof(IntPtr));
			component.renderComponent = Marshal.ReadIntPtr(intPtr, ofs);
			return true;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarPose_GetRightHandComponent")]
		private static extern IntPtr ovrAvatarPose_GetRightHandComponent_Native(IntPtr avatar);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarAsset_BeginLoading(ulong assetID);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovrAvatarAsset_BeginLoadingLOD(ulong assetId, ovrAvatarAssetLevelOfDetail lod);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarAssetType ovrAvatarAsset_GetType(IntPtr assetHandle);

		public static ovrAvatarMeshAssetData ovrAvatarAsset_GetMeshData(IntPtr assetPtr)
		{
			return (ovrAvatarMeshAssetData)Marshal.PtrToStructure(ovrAvatarAsset_GetMeshData_Native(assetPtr), typeof(ovrAvatarMeshAssetData));
		}

		public static ovrAvatarMeshAssetDataV2 ovrAvatarAsset_GetCombinedMeshData(IntPtr assetPtr)
		{
			return (ovrAvatarMeshAssetDataV2)Marshal.PtrToStructure(ovrAvatarAsset_GetCombinedMeshData_Native(assetPtr), typeof(ovrAvatarMeshAssetDataV2));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarAsset_GetCombinedMeshData")]
		private static extern IntPtr ovrAvatarAsset_GetCombinedMeshData_Native(IntPtr assetPtr);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarAsset_GetMeshData")]
		private static extern IntPtr ovrAvatarAsset_GetMeshData_Native(IntPtr assetPtr);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovrAvatarAsset_GetMeshBlendShapeCount(IntPtr assetPtr);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatarAsset_GetMeshBlendShapeName(IntPtr assetPtr, uint index);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovrAvatarAsset_GetSubmeshCount(IntPtr assetPtr);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovrAvatarAsset_GetSubmeshLastIndex(IntPtr assetPtr, uint index);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatarAsset_GetMeshBlendShapeVertices(IntPtr assetPtr);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatarAsset_GetAvatar(IntPtr assetHandle);

		public static ulong[] ovrAvatarAsset_GetCombinedMeshIDs(IntPtr assetHandle)
		{
			uint structure = 0u;
			IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(structure));
			IntPtr ptr = ovrAvatarAsset_GetCombinedMeshIDs_Native(assetHandle, intPtr);
			structure = (uint)Marshal.PtrToStructure(intPtr, typeof(uint));
			ulong[] array = new ulong[structure];
			for (int i = 0; i < structure; i++)
			{
				array[i] = (ulong)Marshal.ReadInt64(ptr, i * Marshal.SizeOf(typeof(ulong)));
			}
			Marshal.FreeHGlobal(intPtr);
			return array;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarAsset_GetCombinedMeshIDs")]
		public static extern IntPtr ovrAvatarAsset_GetCombinedMeshIDs_Native(IntPtr assetHandle, IntPtr count);

		public static void ovrAvatar_GetCombinedMeshAlphaData(IntPtr avatar, ref ulong textureID, ref Vector4 offset)
		{
			IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(ulong)));
			IntPtr intPtr2 = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(Vector4)));
			ovrAvatar_GetCombinedMeshAlphaData_Native(avatar, intPtr, intPtr2);
			textureID = (ulong)Marshal.PtrToStructure(intPtr, typeof(ulong));
			offset = (Vector4)Marshal.PtrToStructure(intPtr2, typeof(Vector4));
			Marshal.FreeHGlobal(intPtr);
			Marshal.FreeHGlobal(intPtr2);
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatar_GetCombinedMeshAlphaData")]
		public static extern IntPtr ovrAvatar_GetCombinedMeshAlphaData_Native(IntPtr avatar, IntPtr textureIDPtr, IntPtr offsetPtr);

		public static ovrAvatarTextureAssetData ovrAvatarAsset_GetTextureData(IntPtr assetPtr)
		{
			return (ovrAvatarTextureAssetData)Marshal.PtrToStructure(ovrAvatarAsset_GetTextureData_Native(assetPtr), typeof(ovrAvatarTextureAssetData));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarAsset_GetTextureData")]
		private static extern IntPtr ovrAvatarAsset_GetTextureData_Native(IntPtr assetPtr);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarAsset_GetMaterialData")]
		private static extern IntPtr ovrAvatarAsset_GetMaterialData_Native(IntPtr assetPtr);

		public static ovrAvatarMaterialState ovrAvatarAsset_GetMaterialState(IntPtr assetPtr)
		{
			return (ovrAvatarMaterialState)Marshal.PtrToStructure(ovrAvatarAsset_GetMaterialData_Native(assetPtr), typeof(ovrAvatarMaterialState));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarRenderPartType ovrAvatarRenderPart_GetType(IntPtr renderPart);

		public static ovrAvatarRenderPart_SkinnedMeshRender ovrAvatarRenderPart_GetSkinnedMeshRender(IntPtr renderPart)
		{
			return (ovrAvatarRenderPart_SkinnedMeshRender)Marshal.PtrToStructure(ovrAvatarRenderPart_GetSkinnedMeshRender_Native(renderPart), typeof(ovrAvatarRenderPart_SkinnedMeshRender));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarRenderPart_GetSkinnedMeshRender")]
		private static extern IntPtr ovrAvatarRenderPart_GetSkinnedMeshRender_Native(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarTransform ovrAvatarSkinnedMeshRender_GetTransform(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarTransform ovrAvatarSkinnedMeshRenderPBS_GetTransform(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarTransform ovrAvatarSkinnedMeshRenderPBSV2_GetTransform(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarVisibilityFlags ovrAvatarSkinnedMeshRender_GetVisibilityMask(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovrAvatarSkinnedMeshRender_MaterialStateChanged(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovrAvatarSkinnedMeshRenderPBSV2_MaterialStateChanged(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarVisibilityFlags ovrAvatarSkinnedMeshRenderPBS_GetVisibilityMask(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarVisibilityFlags ovrAvatarSkinnedMeshRenderPBSV2_GetVisibilityMask(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarMaterialState ovrAvatarSkinnedMeshRender_GetMaterialState(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarPBSMaterialState ovrAvatarSkinnedMeshRenderPBSV2_GetPBSMaterialState(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarExpressiveParameters ovrAvatar_GetExpressiveParameters(IntPtr avatar);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovrAvatarSkinnedMeshRender_GetDirtyJoints(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovrAvatarSkinnedMeshRenderPBS_GetDirtyJoints(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovrAvatarSkinnedMeshRenderPBSV2_GetDirtyJoints(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarTransform ovrAvatarSkinnedMeshRender_GetJointTransform(IntPtr renderPart, uint jointIndex);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetActionUnitOnsetSpeed(IntPtr avatar, float onsetSpeed);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetActionUnitFalloffSpeed(IntPtr avatar, float falloffSpeed);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetVisemeMultiplier(IntPtr avatar, float visemeMultiplier);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarTransform ovrAvatarSkinnedMeshRenderPBS_GetJointTransform(IntPtr renderPart, uint jointIndex);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarTransform ovrAvatarSkinnedMeshRenderPBSV2_GetJointTransform(IntPtr renderPart, uint jointIndex);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovrAvatarSkinnedMeshRenderPBS_GetAlbedoTextureAssetID(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovrAvatarSkinnedMeshRenderPBS_GetSurfaceTextureAssetID(IntPtr renderPart);

		public static ovrAvatarRenderPart_SkinnedMeshRenderPBS ovrAvatarRenderPart_GetSkinnedMeshRenderPBS(IntPtr renderPart)
		{
			return (ovrAvatarRenderPart_SkinnedMeshRenderPBS)Marshal.PtrToStructure(ovrAvatarRenderPart_GetSkinnedMeshRenderPBS_Native(renderPart), typeof(ovrAvatarRenderPart_SkinnedMeshRenderPBS));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarRenderPart_GetSkinnedMeshRenderPBS")]
		private static extern IntPtr ovrAvatarRenderPart_GetSkinnedMeshRenderPBS_Native(IntPtr renderPart);

		public static ovrAvatarRenderPart_SkinnedMeshRenderPBS_V2 ovrAvatarRenderPart_GetSkinnedMeshRenderPBSV2(IntPtr renderPart)
		{
			return (ovrAvatarRenderPart_SkinnedMeshRenderPBS_V2)Marshal.PtrToStructure(ovrAvatarRenderPart_GetSkinnedMeshRenderPBSV2_Native(renderPart), typeof(ovrAvatarRenderPart_SkinnedMeshRenderPBS_V2));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarRenderPart_GetSkinnedMeshRenderPBSV2")]
		private static extern IntPtr ovrAvatarRenderPart_GetSkinnedMeshRenderPBSV2_Native(IntPtr renderPart);

		public static void ovrAvatarSkinnedMeshRender_GetBlendShapeParams(IntPtr renderPart, ref ovrAvatarBlendShapeParams blendParams)
		{
			IntPtr ptr = ovrAvatarSkinnedMeshRender_GetBlendShapeParams_Native(renderPart);
			blendParams.blendShapeParamCount = (uint)Marshal.ReadInt32(ptr);
			Marshal.Copy(new IntPtr(ptr.ToInt64() + ovrAvatarBlendShapeParams_Offsets.blendShapeParams), blendParams.blendShapeParams, 0, (int)blendParams.blendShapeParamCount);
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarSkinnedMeshRender_GetBlendShapeParams")]
		private static extern IntPtr ovrAvatarSkinnedMeshRender_GetBlendShapeParams_Native(IntPtr renderPart);

		public static ovrAvatarRenderPart_ProjectorRender ovrAvatarRenderPart_GetProjectorRender(IntPtr renderPart)
		{
			return (ovrAvatarRenderPart_ProjectorRender)Marshal.PtrToStructure(ovrAvatarRenderPart_GetProjectorRender_Native(renderPart), typeof(ovrAvatarRenderPart_ProjectorRender));
		}

		public static ovrAvatarPBSMaterialState[] ovrAvatar_GetBodyPBSMaterialStates(IntPtr renderPart)
		{
			IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(uint)));
			IntPtr intPtr2 = ovrAvatar_GetBodyPBSMaterialStates_Native(renderPart, intPtr);
			ovrAvatarPBSMaterialState[] array = new ovrAvatarPBSMaterialState[Marshal.ReadInt32(intPtr)];
			for (int i = 0; i < array.Length; i++)
			{
				IntPtr ptr = new IntPtr(intPtr2.ToInt64() + i * Marshal.SizeOf(typeof(ovrAvatarPBSMaterialState)));
				array[i] = (ovrAvatarPBSMaterialState)Marshal.PtrToStructure(ptr, typeof(ovrAvatarPBSMaterialState));
			}
			Marshal.FreeHGlobal(intPtr);
			return array;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatar_GetBodyPBSMaterialStates")]
		private static extern IntPtr ovrAvatar_GetBodyPBSMaterialStates_Native(IntPtr avatar, IntPtr count);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarRenderPart_GetProjectorRender")]
		private static extern IntPtr ovrAvatarRenderPart_GetProjectorRender_Native(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovrAvatar_GetReferencedAssetCount(IntPtr avatar);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovrAvatar_GetReferencedAsset(IntPtr avatar, uint index);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetLeftHandGesture(IntPtr avatar, ovrAvatarHandGesture gesture);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetRightHandGesture(IntPtr avatar, ovrAvatarHandGesture gesture);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetLeftHandCustomGesture(IntPtr avatar, uint jointCount, [In] ovrAvatarTransform[] customJointTransforms);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetRightHandCustomGesture(IntPtr avatar, uint jointCount, [In] ovrAvatarTransform[] customJointTransforms);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_UpdatePoseFromPacket(IntPtr avatar, IntPtr packet, float secondsFromStart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarPacket_BeginRecording(IntPtr avatar);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatarPacket_EndRecording(IntPtr avatar);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovrAvatarPacket_GetSize(IntPtr packet);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern float ovrAvatarPacket_GetDurationSeconds(IntPtr packet);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarPacket_Free(IntPtr packet);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovrAvatarPacket_Write(IntPtr packet, uint bufferSize, [Out] byte[] buffer);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatarPacket_Read(uint bufferSize, [In] byte[] buffer);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		private static extern void ovrAvatar_SetInternalForceASTCTextures(bool value);

		public static void ovrAvatar_SetForceASTCTextures(bool value)
		{
			ovrAvatar_SetInternalForceASTCTextures(value);
		}

		public static void ovrAvatar_OverrideExpressiveLogic(IntPtr avatar, ovrAvatarBlendShapeParams blendParams)
		{
			IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(ovrAvatarBlendShapeParams)));
			Marshal.StructureToPtr(blendParams, intPtr, fDeleteOld: false);
			ovrAvatar_OverrideExpressiveLogic_Native(avatar, intPtr);
			Marshal.FreeHGlobal(intPtr);
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatar_OverrideExpressiveLogic")]
		private static extern void ovrAvatar_OverrideExpressiveLogic_Native(IntPtr avatar, IntPtr state);

		public static void ovrAvatar_SetVisemes(IntPtr avatar, ovrAvatarVisemes visemes)
		{
			Marshal.WriteInt32(nativeVisemeData, (int)visemes.visemeParamCount);
			Marshal.Copy(visemes.visemeParams, 0, new IntPtr(nativeVisemeData.ToInt64() + ovrAvatarVisemes_Offsets.visemeParams), (int)visemes.visemeParamCount);
			ovrAvatar_SetVisemes_Native(avatar, nativeVisemeData);
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatar_SetVisemes")]
		private static extern void ovrAvatar_SetVisemes_Native(IntPtr avatar, IntPtr visemes);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_UpdateWorldTransform(IntPtr avatar, ovrAvatarTransform transform);

		public static void ovrAvatar_UpdateGazeTargets(ovrAvatarGazeTargets targets)
		{
			Marshal.WriteInt32(nativeGazeTargetsData, (int)targets.targetCount);
			long targets2 = ovrAvatarGazeTargets_Offsets.targets;
			for (uint num = 0u; num < targets.targetCount; num++)
			{
				long num2 = targets2 + num * Marshal.SizeOf(typeof(ovrAvatarGazeTarget));
				Marshal.WriteInt32(new IntPtr(nativeGazeTargetsData.ToInt64() + num2 + ovrAvatarGazeTarget_Offsets.id), (int)targets.targets[num].id);
				scratchBufferFloat[0] = targets.targets[num].worldPosition.x;
				scratchBufferFloat[1] = targets.targets[num].worldPosition.y;
				scratchBufferFloat[2] = targets.targets[num].worldPosition.z;
				Marshal.Copy(scratchBufferFloat, 0, new IntPtr(nativeGazeTargetsData.ToInt64() + num2 + ovrAvatarGazeTarget_Offsets.worldPosition), 3);
				Marshal.WriteInt32(new IntPtr(nativeGazeTargetsData.ToInt64() + num2 + ovrAvatarGazeTarget_Offsets.type), (int)targets.targets[num].type);
			}
			ovrAvatar_UpdateGazeTargets_Native(nativeGazeTargetsData);
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatar_UpdateGazeTargets")]
		private static extern void ovrAvatar_UpdateGazeTargets_Native(IntPtr targets);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_RemoveGazeTargets(uint targetCount, uint[] ids);

		public static void ovrAvatar_UpdateLights(ovrAvatarLights lights)
		{
			scratchBufferFloat[0] = lights.ambientIntensity;
			Marshal.Copy(scratchBufferFloat, 0, nativeAvatarLightsData, 1);
			Marshal.WriteInt32(new IntPtr(nativeAvatarLightsData.ToInt64() + Marshal.OffsetOf(typeof(ovrAvatarLights), "lightCount").ToInt64()), (int)lights.lightCount);
			long num = Marshal.OffsetOf(typeof(ovrAvatarLights), "lights").ToInt64();
			for (uint num2 = 0u; num2 < lights.lightCount; num2++)
			{
				long num3 = num + num2 * Marshal.SizeOf(typeof(ovrAvatarLight));
				Marshal.WriteInt32(new IntPtr(nativeAvatarLightsData.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarLight), "id").ToInt64()), (int)lights.lights[num2].id);
				Marshal.WriteInt32(new IntPtr(nativeAvatarLightsData.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarLight), "type").ToInt64()), (int)lights.lights[num2].type);
				scratchBufferFloat[0] = lights.lights[num2].intensity;
				Marshal.Copy(scratchBufferFloat, 0, new IntPtr(nativeAvatarLightsData.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarLight), "intensity").ToInt64()), 1);
				scratchBufferFloat[0] = lights.lights[num2].worldDirection.x;
				scratchBufferFloat[1] = lights.lights[num2].worldDirection.y;
				scratchBufferFloat[2] = lights.lights[num2].worldDirection.z;
				Marshal.Copy(scratchBufferFloat, 0, new IntPtr(nativeAvatarLightsData.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarLight), "worldDirection").ToInt64()), 3);
				scratchBufferFloat[0] = lights.lights[num2].worldPosition.x;
				scratchBufferFloat[1] = lights.lights[num2].worldPosition.y;
				scratchBufferFloat[2] = lights.lights[num2].worldPosition.z;
				Marshal.Copy(scratchBufferFloat, 0, new IntPtr(nativeAvatarLightsData.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarLight), "worldPosition").ToInt64()), 3);
				scratchBufferFloat[0] = lights.lights[num2].range;
				Marshal.Copy(scratchBufferFloat, 0, new IntPtr(nativeAvatarLightsData.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarLight), "range").ToInt64()), 1);
				scratchBufferFloat[0] = lights.lights[num2].spotAngleDeg;
				Marshal.Copy(scratchBufferFloat, 0, new IntPtr(nativeAvatarLightsData.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarLight), "spotAngleDeg").ToInt64()), 1);
			}
			ovrAvatar_UpdateLights_Native(nativeAvatarLightsData);
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatar_UpdateLights")]
		private static extern void ovrAvatar_UpdateLights_Native(IntPtr lights);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_RemoveLights(uint lightCount, uint[] ids);

		[MonoPInvokeCallback(typeof(LoggingDelegate))]
		public static void LoggingCallback(IntPtr str)
		{
			Marshal.PtrToStringAnsi(str);
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_RegisterLoggingCallback(LoggingDelegate callback);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetLoggingLevel(ovrAvatarLogLevel level);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatar_GetDebugTransforms")]
		public static extern IntPtr ovrAvatar_GetDebugTransforms_Native(IntPtr count);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatar_GetDebugLines")]
		public static extern IntPtr ovrAvatar_GetDebugLines_Native(IntPtr count);

		public static void ovrAvatar_DrawDebugLines()
		{
			IntPtr intPtr = ovrAvatar_GetDebugLines_Native(DebugLineCountData);
			int num = Marshal.ReadInt32(DebugLineCountData);
			ovrAvatarDebugLine ovrAvatarDebugLine = default(ovrAvatarDebugLine);
			for (int i = 0; i < num; i++)
			{
				int num2 = i * Marshal.SizeOf(typeof(ovrAvatarDebugLine));
				Marshal.Copy(new IntPtr(intPtr.ToInt64() + num2), scratchBufferFloat, 0, 9);
				ovrAvatarDebugLine.startPoint.x = scratchBufferFloat[0];
				ovrAvatarDebugLine.startPoint.y = scratchBufferFloat[1];
				ovrAvatarDebugLine.startPoint.z = 0f - scratchBufferFloat[2];
				ovrAvatarDebugLine.endPoint.x = scratchBufferFloat[3];
				ovrAvatarDebugLine.endPoint.y = scratchBufferFloat[4];
				ovrAvatarDebugLine.endPoint.z = 0f - scratchBufferFloat[5];
				ovrAvatarDebugLine.color.x = scratchBufferFloat[6];
				ovrAvatarDebugLine.color.y = scratchBufferFloat[7];
				ovrAvatarDebugLine.color.z = scratchBufferFloat[8];
				ovrAvatarDebugLine.context = (ovrAvatarDebugContext)Marshal.ReadInt32(new IntPtr(intPtr.ToInt64() + num2 + Marshal.OffsetOf(typeof(ovrAvatarDebugLine), "context").ToInt64()));
				ovrAvatarDebugLine.text = Marshal.ReadIntPtr(new IntPtr(intPtr.ToInt64() + num2 + Marshal.OffsetOf(typeof(ovrAvatarDebugLine), "text").ToInt64()));
				UnityEngine.Debug.DrawLine(ovrAvatarDebugLine.startPoint, ovrAvatarDebugLine.endPoint, new Color(ovrAvatarDebugLine.color.x, ovrAvatarDebugLine.color.y, ovrAvatarDebugLine.color.z));
			}
			intPtr = ovrAvatar_GetDebugTransforms_Native(DebugLineCountData);
			num = Marshal.ReadInt32(DebugLineCountData);
			ovrAvatarDebugTransform ovrAvatarDebugTransform = default(ovrAvatarDebugTransform);
			for (int j = 0; j < num; j++)
			{
				int num3 = j * Marshal.SizeOf(typeof(ovrAvatarDebugTransform));
				Marshal.Copy(new IntPtr(intPtr.ToInt64() + num3), scratchBufferFloat, 0, 10);
				OvrAvatar.ConvertTransform(scratchBufferFloat, ref ovrAvatarDebugTransform.transform);
				OvrAvatar.ConvertTransform(ovrAvatarDebugTransform.transform, debugLineGo.transform);
				ovrAvatarDebugTransform.context = (ovrAvatarDebugContext)Marshal.ReadInt32(new IntPtr(intPtr.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarDebugTransform), "context").ToInt64()));
				ovrAvatarDebugTransform.text = Marshal.ReadIntPtr(new IntPtr(intPtr.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarDebugTransform), "text").ToInt64()));
				Vector3 vector = 0.1f * debugLineGo.transform.TransformVector(Vector3.up);
				Vector3 vector2 = 0.1f * debugLineGo.transform.TransformVector(Vector3.right);
				Vector3 vector3 = 0.1f * debugLineGo.transform.TransformVector(Vector3.forward);
				UnityEngine.Debug.DrawLine(debugLineGo.transform.position, debugLineGo.transform.position + vector, Color.green);
				UnityEngine.Debug.DrawLine(debugLineGo.transform.position, debugLineGo.transform.position + vector2, Color.red);
				UnityEngine.Debug.DrawLine(debugLineGo.transform.position, debugLineGo.transform.position + vector3, Color.blue);
			}
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetDebugDrawContext(uint context);

		public static bool SendEvent(string name, string param = "", string source = "")
		{
			try
			{
				if (ovrPluginVersion == null)
				{
					string text = ovrp_GetVersion();
					if (!string.IsNullOrEmpty(text))
					{
						ovrPluginVersion = new Version(text.Split('-')[0]);
					}
					else
					{
						ovrPluginVersion = new Version(0, 0, 0);
					}
				}
				if (ovrPluginVersion >= OVRP_1_30_0.version)
				{
					return OVRP_1_30_0.ovrp_SendEvent2(name, param, (source.Length == 0) ? "avatar_sdk" : source) == Result.Success;
				}
				return false;
			}
			catch (Exception)
			{
				return false;
			}
		}

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrp_GetVersion")]
		private static extern IntPtr _ovrp_GetVersion();

		public static string ovrp_GetVersion()
		{
			return Marshal.PtrToStringAnsi(_ovrp_GetVersion());
		}
	}
}
namespace EpicToonFX
{
	public class ETFXLightFade : MonoBehaviour
	{
		[Header("Seconds to dim the light")]
		public float life = 0.2f;

		public bool killAfterLife = true;

		private Light li;

		private float initIntensity;

		private void Start()
		{
			if ((bool)base.gameObject.GetComponent<Light>())
			{
				li = base.gameObject.GetComponent<Light>();
				initIntensity = li.intensity;
			}
			else
			{
				MonoBehaviour.print("No light object found on " + base.gameObject.name);
			}
		}

		private void Update()
		{
			if ((bool)base.gameObject.GetComponent<Light>())
			{
				li.intensity -= initIntensity * (Time.deltaTime / life);
				if (killAfterLife && li.intensity <= 0f)
				{
					UnityEngine.Object.Destroy(base.gameObject.GetComponent<Light>());
				}
			}
		}
	}
	public class ETFXPitchRandomizer : MonoBehaviour
	{
		public float randomPercent = 10f;

		private void Start()
		{
			base.transform.GetComponent<AudioSource>().pitch *= 1f + UnityEngine.Random.Range((0f - randomPercent) / 100f, randomPercent / 100f);
		}
	}
}
namespace UnityStandardAssets.Utility
{
	public class AutoMoveAndRotate : MonoBehaviour
	{
		[Serializable]
		public class Vector3andSpace
		{
			public Vector3 value;

			public Space space = Space.Self;
		}

		public Vector3andSpace moveUnitsPerSecond;

		public Vector3andSpace rotateDegreesPerSecond;

		public bool ignoreTimescale;

		private float m_LastRealTime;

		private void Start()
		{
			m_LastRealTime = Time.realtimeSinceStartup;
		}

		private void Update()
		{
			float num = Time.deltaTime;
			if (ignoreTimescale)
			{
				num = Time.realtimeSinceStartup - m_LastRealTime;
				m_LastRealTime = Time.realtimeSinceStartup;
			}
			base.transform.Translate(moveUnitsPerSecond.value * num, moveUnitsPerSecond.space);
			base.transform.Rotate(rotateDegreesPerSecond.value * num, moveUnitsPerSecond.space);
		}
	}
}
namespace MissileBehaviours.Misc
{
	public class DestroyAfterTime : MonoBehaviour
	{
		[Tooltip("The time, in seconds, after which this Gameobject is destroyed.")]
		public float time = 10f;

		private void Start()
		{
			UnityEngine.Object.Destroy(base.gameObject, time);
		}
	}
}
namespace I2.Loc
{
	public class CallbackNotification : MonoBehaviour
	{
		public void OnModifyLocalization()
		{
			if (!string.IsNullOrEmpty(Localize.MainTranslation))
			{
				string translation = LocalizationManager.GetTranslation("Color/Red");
				Localize.MainTranslation = Localize.MainTranslation.Replace("{PLAYER_COLOR}", translation);
			}
		}
	}
	public class Example_ChangeLanguage : MonoBehaviour
	{
		public void SetLanguage_English()
		{
			SetLanguage("English");
		}

		public void SetLanguage_French()
		{
			SetLanguage("French");
		}

		public void SetLanguage_Spanish()
		{
			SetLanguage("Spanish");
		}

		public void SetLanguage(string LangName)
		{
			if (LocalizationManager.HasLanguage(LangName))
			{
				LocalizationManager.CurrentLanguage = LangName;
			}
		}
	}
	public class Example_LocalizedString : MonoBehaviour
	{
		public LocalizedString _MyLocalizedString;

		public string _NormalString;

		[TermsPopup("")]
		public string _StringWithTermPopup;

		public void Start()
		{
			UnityEngine.Debug.Log(_MyLocalizedString);
			UnityEngine.Debug.Log(LocalizationManager.GetTranslation(_NormalString));
			UnityEngine.Debug.Log(LocalizationManager.GetTranslation(_StringWithTermPopup));
			UnityEngine.Debug.Log((string)(LocalizedString)"Term2");
			UnityEngine.Debug.Log(_MyLocalizedString);
			UnityEngine.Debug.Log((LocalizedString)"Term3");
			LocalizedString localizedString = "Term3";
			localizedString.mRTL_IgnoreArabicFix = true;
			UnityEngine.Debug.Log(localizedString);
			LocalizedString localizedString2 = "Term3";
			localizedString2.mRTL_ConvertNumbers = true;
			localizedString2.mRTL_MaxLineLength = 20;
			UnityEngine.Debug.Log(localizedString2);
			UnityEngine.Debug.Log(localizedString2);
		}
	}
	public class GlobalParametersExample : RegisterGlobalParameters
	{
		public override string GetParameterValue(string ParamName)
		{
			if (ParamName == "WINNER")
			{
				return "Javier";
			}
			if (ParamName == "NUM PLAYERS")
			{
				return 5.ToString();
			}
			return null;
		}
	}
	public class RealTimeTranslation : MonoBehaviour
	{
		private string OriginalText = "This is an example showing how to use the google translator to translate chat messages within the game.\nIt also supports multiline translations.";

		private string TranslatedText = string.Empty;

		private bool IsTranslating;

		public void OnGUI()
		{
			GUILayout.Label("Translate:");
			OriginalText = GUILayout.TextArea(OriginalText, GUILayout.Width(Screen.width));
			GUILayout.Space(10f);
			GUILayout.BeginHorizontal();
			if (GUILayout.Button("English -> Espaol", GUILayout.Height(100f)))
			{
				StartTranslating("en", "es");
			}
			if (GUILayout.Button("Espaol -> English", GUILayout.Height(100f)))
			{
				StartTranslating("es", "en");
			}
			GUILayout.EndHorizontal();
			GUILayout.Space(10f);
			GUILayout.BeginHorizontal();
			GUILayout.TextArea("Multiple Translation with 1 call:\n'This is an example' -> en,zh\n'Hola' -> en");
			if (GUILayout.Button("Multi Translate", GUILayout.ExpandHeight(expand: true)))
			{
				ExampleMultiTranslations_Async();
			}
			GUILayout.EndHorizontal();
			GUILayout.TextArea(TranslatedText, GUILayout.Width(Screen.width));
			GUILayout.Space(10f);
			if (IsTranslating)
			{
				GUILayout.Label("Contacting Google....");
			}
		}

		public void StartTranslating(string fromCode, string toCode)
		{
			IsTranslating = true;
			GoogleTranslation.Translate(OriginalText, fromCode, toCode, OnTranslationReady);
		}

		private void OnTranslationReady(string Translation, string errorMsg)
		{
			IsTranslating = false;
			if (errorMsg != null)
			{
				UnityEngine.Debug.LogError(errorMsg);
			}
			else
			{
				TranslatedText = Translation;
			}
		}

		public void ExampleMultiTranslations_Blocking()
		{
			Dictionary<string, TranslationQuery> dictionary = new Dictionary<string, TranslationQuery>();
			GoogleTranslation.AddQuery("This is an example", "en", "es", dictionary);
			GoogleTranslation.AddQuery("This is an example", "auto", "zh", dictionary);
			GoogleTranslation.AddQuery("Hola", "es", "en", dictionary);
			if (GoogleTranslation.ForceTranslate(dictionary))
			{
				UnityEngine.Debug.Log(GoogleTranslation.GetQueryResult("This is an example", "en", dictionary));
				UnityEngine.Debug.Log(GoogleTranslation.GetQueryResult("This is an example", "zh", dictionary));
				UnityEngine.Debug.Log(GoogleTranslation.GetQueryResult("This is an example", "", dictionary));
				UnityEngine.Debug.Log(dictionary["Hola"].Results[0]);
			}
		}

		public void ExampleMultiTranslations_Async()
		{
			IsTranslating = true;
			Dictionary<string, TranslationQuery> dictionary = new Dictionary<string, TranslationQuery>();
			GoogleTranslation.AddQuery("This is an example", "en", "es", dictionary);
			GoogleTranslation.AddQuery("This is an example", "auto", "zh", dictionary);
			GoogleTranslation.AddQuery("Hola", "es", "en", dictionary);
			GoogleTranslation.Translate(dictionary, OnMultitranslationReady);
		}

		private void OnMultitranslationReady(Dictionary<string, TranslationQuery> dict, string errorMsg)
		{
			if (!string.IsNullOrEmpty(errorMsg))
			{
				UnityEngine.Debug.LogError(errorMsg);
				return;
			}
			IsTranslating = false;
			TranslatedText = "";
			TranslatedText = TranslatedText + GoogleTranslation.GetQueryResult("This is an example", "es", dict) + "\n";
			TranslatedText = TranslatedText + GoogleTranslation.GetQueryResult("This is an example", "zh", dict) + "\n";
			TranslatedText = TranslatedText + GoogleTranslation.GetQueryResult("This is an example", "", dict) + "\n";
			TranslatedText += dict["Hola"].Results[0];
		}

		public bool IsWaitingForTranslation()
		{
			return IsTranslating;
		}

		public string GetTranslatedText()
		{
			return TranslatedText;
		}

		public void SetOriginalText(string text)
		{
			OriginalText = text;
		}
	}
	public class RegisterBundlesManager : MonoBehaviour, IResourceManager_Bundles
	{
		public void OnEnable()
		{
			if (!ResourceManager.pInstance.mBundleManagers.Contains(this))
			{
				ResourceManager.pInstance.mBundleManagers.Add(this);
			}
		}

		public void OnDisable()
		{
			ResourceManager.pInstance.mBundleManagers.Remove(this);
		}

		public virtual UnityEngine.Object LoadFromBundle(string path, Type assetType)
		{
			return null;
		}
	}
	public class ToggleLanguage : MonoBehaviour
	{
		private void Start()
		{
			Invoke("test", 3f);
		}

		private void test()
		{
			List<string> allLanguages = LocalizationManager.GetAllLanguages();
			int num = allLanguages.IndexOf(LocalizationManager.CurrentLanguage);
			if (num < 0)
			{
				num = 0;
			}
			else
			{
				num = (num + 1) % allLanguages.Count;
			}
			Invoke("test", 3f);
		}
	}
	public static class PersistentStorage
	{
		public enum eFileType
		{
			Raw,
			Persistent,
			Temporal,
			Streaming
		}

		private static I2CustomPersistentStorage mStorage;

		public static void SetSetting_String(string key, string value)
		{
			if (mStorage == null)
			{
				mStorage = new I2CustomPersistentStorage();
			}
			mStorage.SetSetting_String(key, value);
		}

		public static string GetSetting_String(string key, string defaultValue)
		{
			if (mStorage == null)
			{
				mStorage = new I2CustomPersistentStorage();
			}
			return mStorage.GetSetting_String(key, defaultValue);
		}

		public static void DeleteSetting(string key)
		{
			if (mStorage == null)
			{
				mStorage = new I2CustomPersistentStorage();
			}
			mStorage.DeleteSetting(key);
		}

		public static bool HasSetting(string key)
		{
			if (mStorage == null)
			{
				mStorage = new I2CustomPersistentStorage();
			}
			return mStorage.HasSetting(key);
		}

		public static void ForceSaveSettings()
		{
			if (mStorage == null)
			{
				mStorage = new I2CustomPersistentStorage();
			}
			mStorage.ForceSaveSettings();
		}

		public static bool CanAccessFiles()
		{
			if (mStorage == null)
			{
				mStorage = new I2CustomPersistentStorage();
			}
			return mStorage.CanAccessFiles();
		}

		public static bool SaveFile(eFileType fileType, string fileName, string data, bool logExceptions = true)
		{
			if (mStorage == null)
			{
				mStorage = new I2CustomPersistentStorage();
			}
			return mStorage.SaveFile(fileType, fileName, data, logExceptions);
		}

		public static string LoadFile(eFileType fileType, string fileName, bool logExceptions = true)
		{
			if (mStorage == null)
			{
				mStorage = new I2CustomPersistentStorage();
			}
			return mStorage.LoadFile(fileType, fileName, logExceptions);
		}

		public static bool DeleteFile(eFileType fileType, string fileName, bool logExceptions = true)
		{
			if (mStorage == null)
			{
				mStorage = new I2CustomPersistentStorage();
			}
			return mStorage.DeleteFile(fileType, fileName, logExceptions);
		}

		public static bool HasFile(eFileType fileType, string fileName, bool logExceptions = true)
		{
			if (mStorage == null)
			{
				mStorage = new I2CustomPersistentStorage();
			}
			return mStorage.HasFile(fileType, fileName, logExceptions);
		}
	}
	public abstract class I2BasePersistentStorage
	{
		public virtual void SetSetting_String(string key, string value)
		{
			try
			{
				int length = value.Length;
				int num = 8000;
				if (length <= num)
				{
					PlayerPrefs.SetString(key, value);
					return;
				}
				int num2 = Mathf.CeilToInt((float)length / (float)num);
				for (int i = 0; i < num2; i++)
				{
					int num3 = num * i;
					PlayerPrefs.SetString($"[I2split]{i}{key}", value.Substring(num3, Mathf.Min(num, length - num3)));
				}
				PlayerPrefs.SetString(key, "[$I2#@div$]" + num2);
			}
			catch (Exception)
			{
				UnityEngine.Debug.LogError("Error saving PlayerPrefs " + key);
			}
		}

		public virtual string GetSetting_String(string key, string defaultValue)
		{
			try
			{
				string text = PlayerPrefs.GetString(key, defaultValue);
				if (!string.IsNullOrEmpty(text) && text.StartsWith("[I2split]"))
				{
					int num = int.Parse(text.Substring("[I2split]".Length));
					text = "";
					for (int i = 0; i < num; i++)
					{
						text += PlayerPrefs.GetString($"[I2split]{i}{key}", "");
					}
				}
				return text;
			}
			catch (Exception)
			{
				UnityEngine.Debug.LogError("Error loading PlayerPrefs " + key);
				return defaultValue;
			}
		}

		public virtual void DeleteSetting(string key)
		{
			try
			{
				string @string = PlayerPrefs.GetString(key, null);
				if (!string.IsNullOrEmpty(@string) && @string.StartsWith("[I2split]"))
				{
					int num = int.Parse(@string.Substring("[I2split]".Length));
					for (int i = 0; i < num; i++)
					{
						PlayerPrefs.DeleteKey($"[I2split]{i}{key}");
					}
				}
				PlayerPrefs.DeleteKey(key);
			}
			catch (Exception)
			{
				UnityEngine.Debug.LogError("Error deleting PlayerPrefs " + key);
			}
		}

		public virtual void ForceSaveSettings()
		{
			PlayerPrefs.Save();
		}

		public virtual bool HasSetting(string key)
		{
			return PlayerPrefs.HasKey(key);
		}

		public virtual bool CanAccessFiles()
		{
			return true;
		}

		private string UpdateFilename(PersistentStorage.eFileType fileType, string fileName)
		{
			switch (fileType)
			{
			case PersistentStorage.eFileType.Persistent:
				fileName = UnityEngine.Application.persistentDataPath + "/" + fileName;
				break;
			case PersistentStorage.eFileType.Temporal:
				fileName = UnityEngine.Application.temporaryCachePath + "/" + fileName;
				break;
			case PersistentStorage.eFileType.Streaming:
				fileName = UnityEngine.Application.streamingAssetsPath + "/" + fileName;
				break;
			}
			return fileName;
		}

		public virtual bool SaveFile(PersistentStorage.eFileType fileType, string fileName, string data, bool logExceptions = true)
		{
			if (!CanAccessFiles())
			{
				return false;
			}
			try
			{
				fileName = UpdateFilename(fileType, fileName);
				File.WriteAllText(fileName, data, Encoding.UTF8);
				return true;
			}
			catch (Exception ex)
			{
				if (logExceptions)
				{
					UnityEngine.Debug.LogError("Error saving file '" + fileName + "'\n" + ex);
				}
				return false;
			}
		}

		public virtual string LoadFile(PersistentStorage.eFileType fileType, string fileName, bool logExceptions = true)
		{
			if (!CanAccessFiles())
			{
				return null;
			}
			try
			{
				fileName = UpdateFilename(fileType, fileName);
				return File.ReadAllText(fileName, Encoding.UTF8);
			}
			catch (Exception ex)
			{
				if (logExceptions)
				{
					UnityEngine.Debug.LogError("Error loading file '" + fileName + "'\n" + ex);
				}
				return null;
			}
		}

		public virtual bool DeleteFile(PersistentStorage.eFileType fileType, string fileName, bool logExceptions = true)
		{
			if (!CanAccessFiles())
			{
				return false;
			}
			try
			{
				fileName = UpdateFilename(fileType, fileName);
				File.Delete(fileName);
				return true;
			}
			catch (Exception ex)
			{
				if (logExceptions)
				{
					UnityEngine.Debug.LogError("Error deleting file '" + fileName + "'\n" + ex);
				}
				return false;
			}
		}

		public virtual bool HasFile(PersistentStorage.eFileType fileType, string fileName, bool logExceptions = true)
		{
			if (!CanAccessFiles())
			{
				return false;
			}
			try
			{
				fileName = UpdateFilename(fileType, fileName);
				return File.Exists(fileName);
			}
			catch (Exception ex)
			{
				if (logExceptions)
				{
					UnityEngine.Debug.LogError("Error requesting file '" + fileName + "'\n" + ex);
				}
				return false;
			}
		}
	}
	public class I2CustomPersistentStorage : I2BasePersistentStorage
	{
	}
	public class BaseSpecializationManager
	{
		public string[] mSpecializations;

		public Dictionary<string, string> mSpecializationsFallbacks;

		public virtual void InitializeSpecializations()
		{
			mSpecializations = new string[12]
			{
				"Any", "PC", "Touch", "Controller", "VR", "XBox", "PS4", "OculusVR", "ViveVR", "GearVR",
				"Android", "IOS"
			};
			mSpecializationsFallbacks = new Dictionary<string, string>
			{
				{ "XBox", "Controller" },
				{ "PS4", "Controller" },
				{ "OculusVR", "VR" },
				{ "ViveVR", "VR" },
				{ "GearVR", "VR" },
				{ "Android", "Touch" },
				{ "IOS", "Touch" }
			};
		}

		public virtual string GetCurrentSpecialization()
		{
			if (mSpecializations == null)
			{
				InitializeSpecializations();
			}
			return "Android";
		}

		public virtual string GetFallbackSpecialization(string specialization)
		{
			if (mSpecializationsFallbacks == null)
			{
				InitializeSpecializations();
			}
			if (mSpecializationsFallbacks.TryGetValue(specialization, out var value))
			{
				return value;
			}
			return "Any";
		}
	}
	public class SpecializationManager : BaseSpecializationManager
	{
		public static SpecializationManager Singleton = new SpecializationManager();

		private SpecializationManager()
		{
			InitializeSpecializations();
		}

		public static string GetSpecializedText(string text, string specialization = null)
		{
			int num = text.IndexOf("[i2s_");
			if (num < 0)
			{
				return text;
			}
			if (string.IsNullOrEmpty(specialization))
			{
				specialization = Singleton.GetCurrentSpecialization();
			}
			while (!string.IsNullOrEmpty(specialization) && specialization != "Any")
			{
				string text2 = "[i2s_" + specialization + "]";
				int num2 = text.IndexOf(text2);
				if (num2 < 0)
				{
					specialization = Singleton.GetFallbackSpecialization(specialization);
					continue;
				}
				num2 += text2.Length;
				int num3 = text.IndexOf("[i2s_", num2);
				if (num3 < 0)
				{
					num3 = text.Length;
				}
				return text.Substring(num2, num3 - num2);
			}
			return text.Substring(0, num);
		}

		public static string SetSpecializedText(string text, string newText, string specialization)
		{
			if (string.IsNullOrEmpty(specialization))
			{
				specialization = "Any";
			}
			if ((text == null || !text.Contains("[i2s_")) && specialization == "Any")
			{
				return newText;
			}
			Dictionary<string, string> specializations = GetSpecializations(text);
			specializations[specialization] = newText;
			return SetSpecializedText(specializations);
		}

		public static string SetSpecializedText(Dictionary<string, string> specializations)
		{
			if (!specializations.TryGetValue("Any", out var value))
			{
				value = string.Empty;
			}
			foreach (KeyValuePair<string, string> specialization in specializations)
			{
				if (specialization.Key != "Any" && !string.IsNullOrEmpty(specialization.Value))
				{
					value = value + "[i2s_" + specialization.Key + "]" + specialization.Value;
				}
			}
			return value;
		}

		public static Dictionary<string, string> GetSpecializations(string text, Dictionary<string, string> buffer = null)
		{
			if (buffer == null)
			{
				buffer = new Dictionary<string, string>();
			}
			else
			{
				buffer.Clear();
			}
			if (text == null)
			{
				buffer["Any"] = "";
				return buffer;
			}
			int num = 0;
			int num2 = text.IndexOf("[i2s_");
			if (num2 < 0)
			{
				num2 = text.Length;
			}
			buffer["Any"] = text.Substring(0, num2);
			for (num = num2; num < text.Length; num = num2)
			{
				num += "[i2s_".Length;
				int num3 = text.IndexOf(']', num);
				if (num3 < 0)
				{
					break;
				}
				string key = text.Substring(num, num3 - num);
				num = num3 + 1;
				num2 = text.IndexOf("[i2s_", num);
				if (num2 < 0)
				{
					num2 = text.Length;
				}
				string value = text.Substring(num, num2 - num);
				buffer[key] = value;
			}
			return buffer;
		}

		public static void AppendSpecializations(string text, List<string> list = null)
		{
			if (text == null)
			{
				return;
			}
			if (list == null)
			{
				list = new List<string>();
			}
			if (!list.Contains("Any"))
			{
				list.Add("Any");
			}
			int num = 0;
			while (num < text.Length)
			{
				num = text.IndexOf("[i2s_", num);
				if (num >= 0)
				{
					num += "[i2s_".Length;
					int num2 = text.IndexOf(']', num);
					if (num2 >= 0)
					{
						string item = text.Substring(num, num2 - num);
						if (!list.Contains(item))
						{
							list.Add(item);
						}
						continue;
					}
					break;
				}
				break;
			}
		}
	}
	[Serializable]
	public class EventCallback
	{
		public MonoBehaviour Target;

		public string MethodName = string.Empty;

		public void Execute(UnityEngine.Object Sender = null)
		{
			if (HasCallback() && UnityEngine.Application.isPlaying)
			{
				Target.gameObject.SendMessage(MethodName, Sender, SendMessageOptions.DontRequireReceiver);
			}
		}

		public bool HasCallback()
		{
			if (Target != null)
			{
				return !string.IsNullOrEmpty(MethodName);
			}
			return false;
		}
	}
	public enum ePluralType
	{
		Zero,
		One,
		Two,
		Few,
		Many,
		Plural
	}
	public static class GoogleLanguages
	{
		public struct LanguageCodeDef
		{
			public string Code;

			public string GoogleCode;

			public bool HasJoinedWords;

			public int PluralRule;
		}

		public static Dictionary<string, LanguageCodeDef> mLanguageDef = new Dictionary<string, LanguageCodeDef>(StringComparer.Ordinal)
		{
			{
				"Abkhazian",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ab",
					GoogleCode = "-"
				}
			},
			{
				"Afar",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "aa",
					GoogleCode = "-"
				}
			},
			{
				"Afrikaans",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "af"
				}
			},
			{
				"Akan",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ak",
					GoogleCode = "-"
				}
			},
			{
				"Albanian",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "sq"
				}
			},
			{
				"Amharic",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "am"
				}
			},
			{
				"Arabic",
				new LanguageCodeDef
				{
					PluralRule = 11,
					Code = "ar"
				}
			},
			{
				"Arabic/Algeria",
				new LanguageCodeDef
				{
					PluralRule = 11,
					Code = "ar-DZ",
					GoogleCode = "ar"
				}
			},
			{
				"Arabic/Bahrain",
				new LanguageCodeDef
				{
					PluralRule = 11,
					Code = "ar-BH",
					GoogleCode = "ar"
				}
			},
			{
				"Arabic/Egypt",
				new LanguageCodeDef
				{
					PluralRule = 11,
					Code = "ar-EG",
					GoogleCode = "ar"
				}
			},
			{
				"Arabic/Iraq",
				new LanguageCodeDef
				{
					PluralRule = 11,
					Code = "ar-IQ",
					GoogleCode = "ar"
				}
			},
			{
				"Arabic/Jordan",
				new LanguageCodeDef
				{
					PluralRule = 11,
					Code = "ar-JO",
					GoogleCode = "ar"
				}
			},
			{
				"Arabic/Kuwait",
				new LanguageCodeDef
				{
					PluralRule = 11,
					Code = "ar-KW",
					GoogleCode = "ar"
				}
			},
			{
				"Arabic/Lebanon",
				new LanguageCodeDef
				{
					PluralRule = 11,
					Code = "ar-LB",
					GoogleCode = "ar"
				}
			},
			{
				"Arabic/Libya",
				new LanguageCodeDef
				{
					PluralRule = 11,
					Code = "ar-LY",
					GoogleCode = "ar"
				}
			},
			{
				"Arabic/Morocco",
				new LanguageCodeDef
				{
					PluralRule = 11,
					Code = "ar-MA",
					GoogleCode = "ar"
				}
			},
			{
				"Arabic/Oman",
				new LanguageCodeDef
				{
					PluralRule = 11,
					Code = "ar-OM",
					GoogleCode = "ar"
				}
			},
			{
				"Arabic/Qatar",
				new LanguageCodeDef
				{
					PluralRule = 11,
					Code = "ar-QA",
					GoogleCode = "ar"
				}
			},
			{
				"Arabic/Saudi Arabia",
				new LanguageCodeDef
				{
					PluralRule = 11,
					Code = "ar-SA",
					GoogleCode = "ar"
				}
			},
			{
				"Arabic/Syria",
				new LanguageCodeDef
				{
					PluralRule = 11,
					Code = "ar-SY",
					GoogleCode = "ar"
				}
			},
			{
				"Arabic/Tunisia",
				new LanguageCodeDef
				{
					PluralRule = 11,
					Code = "ar-TN",
					GoogleCode = "ar"
				}
			},
			{
				"Arabic/U.A.E.",
				new LanguageCodeDef
				{
					PluralRule = 11,
					Code = "ar-AE",
					GoogleCode = "ar"
				}
			},
			{
				"Arabic/Yemen",
				new LanguageCodeDef
				{
					PluralRule = 11,
					Code = "ar-YE",
					GoogleCode = "ar"
				}
			},
			{
				"Aragonese",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "an",
					GoogleCode = "-"
				}
			},
			{
				"Armenian",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "hy"
				}
			},
			{
				"Assamese",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "as",
					GoogleCode = "-"
				}
			},
			{
				"Avaric",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "av",
					GoogleCode = "-"
				}
			},
			{
				"Avestan",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ae",
					GoogleCode = "-"
				}
			},
			{
				"Aymara",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ay",
					GoogleCode = "-"
				}
			},
			{
				"Azerbaijani",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "az"
				}
			},
			{
				"Bambara",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "bm",
					GoogleCode = "-"
				}
			},
			{
				"Bashkir",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ba",
					GoogleCode = "-"
				}
			},
			{
				"Basque",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "eu"
				}
			},
			{
				"Basque/Spain",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "eu-ES",
					GoogleCode = "eu"
				}
			},
			{
				"Belarusian",
				new LanguageCodeDef
				{
					PluralRule = 6,
					Code = "be"
				}
			},
			{
				"Bengali",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "bn"
				}
			},
			{
				"Bihari",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "bh",
					GoogleCode = "-"
				}
			},
			{
				"Bislama",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "bi",
					GoogleCode = "-"
				}
			},
			{
				"Bosnian",
				new LanguageCodeDef
				{
					PluralRule = 6,
					Code = "bs"
				}
			},
			{
				"Breton",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "br",
					GoogleCode = "-"
				}
			},
			{
				"Bulgariaa",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "bg"
				}
			},
			{
				"Burmese",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "my"
				}
			},
			{
				"Catalan",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ca"
				}
			},
			{
				"Chamorro",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ch",
					GoogleCode = "-"
				}
			},
			{
				"Chechen",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ce",
					GoogleCode = "-"
				}
			},
			{
				"Chichewa",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ny"
				}
			},
			{
				"Chinese",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "zh",
					GoogleCode = "zh-CN",
					HasJoinedWords = true
				}
			},
			{
				"Chinese/Hong Kong",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "zh-HK",
					GoogleCode = "zh-TW",
					HasJoinedWords = true
				}
			},
			{
				"Chinese/Macau",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "zh-MO",
					GoogleCode = "zh-CN",
					HasJoinedWords = true
				}
			},
			{
				"Chinese/PRC",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "zh-CN",
					GoogleCode = "zh-CN",
					HasJoinedWords = true
				}
			},
			{
				"Chinese/Simplified",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "zh-CN",
					GoogleCode = "zh-CN",
					HasJoinedWords = true
				}
			},
			{
				"Chinese/Singapore",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "zh-SG",
					GoogleCode = "zh-CN",
					HasJoinedWords = true
				}
			},
			{
				"Chinese/Taiwan",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "zh-TW",
					GoogleCode = "zh-TW",
					HasJoinedWords = true
				}
			},
			{
				"Chinese/Traditional",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "zh-TW",
					GoogleCode = "zh-TW",
					HasJoinedWords = true
				}
			},
			{
				"Chuvash",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "cv",
					GoogleCode = "-"
				}
			},
			{
				"Cornish",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "kw",
					GoogleCode = "-"
				}
			},
			{
				"Corsican",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "co"
				}
			},
			{
				"Cree",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "cr",
					GoogleCode = "-"
				}
			},
			{
				"Croatian",
				new LanguageCodeDef
				{
					PluralRule = 6,
					Code = "hr"
				}
			},
			{
				"Croatian/Bosnia and Herzegovina",
				new LanguageCodeDef
				{
					PluralRule = 5,
					Code = "hr-BA",
					GoogleCode = "hr"
				}
			},
			{
				"Czech",
				new LanguageCodeDef
				{
					PluralRule = 7,
					Code = "cs"
				}
			},
			{
				"Danish",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "da"
				}
			},
			{
				"Divehi",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "dv",
					GoogleCode = "-"
				}
			},
			{
				"Dutch",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "nl"
				}
			},
			{
				"Dutch/Belgium",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "nl-BE",
					GoogleCode = "nl"
				}
			},
			{
				"Dutch/Netherlands",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "nl-NL",
					GoogleCode = "nl"
				}
			},
			{
				"Dzongkha",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "dz",
					GoogleCode = "-"
				}
			},
			{
				"English",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "en"
				}
			},
			{
				"English/Australia",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "en-AU",
					GoogleCode = "en"
				}
			},
			{
				"English/Belize",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "en-BZ",
					GoogleCode = "en"
				}
			},
			{
				"English/Canada",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "en-CA",
					GoogleCode = "en"
				}
			},
			{
				"English/Caribbean",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "en-CB",
					GoogleCode = "en"
				}
			},
			{
				"English/Ireland",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "en-IE",
					GoogleCode = "en"
				}
			},
			{
				"English/Jamaica",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "en-JM",
					GoogleCode = "en"
				}
			},
			{
				"English/New Zealand",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "en-NZ",
					GoogleCode = "en"
				}
			},
			{
				"English/Republic of the Philippines",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "en-PH",
					GoogleCode = "en"
				}
			},
			{
				"English/South Africa",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "en-ZA",
					GoogleCode = "en"
				}
			},
			{
				"English/Trinidad",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "en-TT",
					GoogleCode = "en"
				}
			},
			{
				"English/United Kingdom",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "en-GB",
					GoogleCode = "en"
				}
			},
			{
				"English/United States",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "en-US",
					GoogleCode = "en"
				}
			},
			{
				"English/Zimbabwe",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "en-ZW",
					GoogleCode = "en"
				}
			},
			{
				"Esperanto",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "eo"
				}
			},
			{
				"Estonian",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "et"
				}
			},
			{
				"Ewe",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ee",
					GoogleCode = "-"
				}
			},
			{
				"Faeroese",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "fo",
					GoogleCode = "-"
				}
			},
			{
				"Fijian",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "fj",
					GoogleCode = "-"
				}
			},
			{
				"Finnish",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "fi"
				}
			},
			{
				"French",
				new LanguageCodeDef
				{
					PluralRule = 2,
					Code = "fr"
				}
			},
			{
				"French/Belgium",
				new LanguageCodeDef
				{
					PluralRule = 2,
					Code = "fr-BE",
					GoogleCode = "fr"
				}
			},
			{
				"French/Canada",
				new LanguageCodeDef
				{
					PluralRule = 2,
					Code = "fr-CA",
					GoogleCode = "fr"
				}
			},
			{
				"French/France",
				new LanguageCodeDef
				{
					PluralRule = 2,
					Code = "fr-FR",
					GoogleCode = "fr"
				}
			},
			{
				"French/Luxembourg",
				new LanguageCodeDef
				{
					PluralRule = 2,
					Code = "fr-LU",
					GoogleCode = "fr"
				}
			},
			{
				"French/Principality of Monaco",
				new LanguageCodeDef
				{
					PluralRule = 2,
					Code = "fr-MC",
					GoogleCode = "fr"
				}
			},
			{
				"French/Switzerland",
				new LanguageCodeDef
				{
					PluralRule = 2,
					Code = "fr-CH",
					GoogleCode = "fr"
				}
			},
			{
				"Fulah",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ff",
					GoogleCode = "-"
				}
			},
			{
				"Galician",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "gl"
				}
			},
			{
				"Galician/Spain",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "gl-ES",
					GoogleCode = "gl"
				}
			},
			{
				"Georgian",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "ka"
				}
			},
			{
				"German",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "de"
				}
			},
			{
				"German/Austria",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "de-AT",
					GoogleCode = "de"
				}
			},
			{
				"German/Germany",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "de-DE",
					GoogleCode = "de"
				}
			},
			{
				"German/Liechtenstein",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "de-LI",
					GoogleCode = "de"
				}
			},
			{
				"German/Luxembourg",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "de-LU",
					GoogleCode = "de"
				}
			},
			{
				"German/Switzerland",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "de-CH",
					GoogleCode = "de"
				}
			},
			{
				"Greek",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "el"
				}
			},
			{
				"Guaran",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "gn",
					GoogleCode = "-"
				}
			},
			{
				"Gujarati",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "gu"
				}
			},
			{
				"Haitian",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ht"
				}
			},
			{
				"Hausa",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ha"
				}
			},
			{
				"Hebrew",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "he",
					GoogleCode = "iw"
				}
			},
			{
				"Herero",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "hz",
					GoogleCode = "-"
				}
			},
			{
				"Hindi",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "hi"
				}
			},
			{
				"Hiri Motu",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ho",
					GoogleCode = "-"
				}
			},
			{
				"Hungarian",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "hu"
				}
			},
			{
				"Interlingua",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ia",
					GoogleCode = "-"
				}
			},
			{
				"Indonesian",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "id"
				}
			},
			{
				"Interlingue",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ie",
					GoogleCode = "-"
				}
			},
			{
				"Irish",
				new LanguageCodeDef
				{
					PluralRule = 10,
					Code = "ga"
				}
			},
			{
				"Igbo",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ig"
				}
			},
			{
				"Inupiaq",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ik",
					GoogleCode = "-"
				}
			},
			{
				"Ido",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "io",
					GoogleCode = "-"
				}
			},
			{
				"Icelandic",
				new LanguageCodeDef
				{
					PluralRule = 14,
					Code = "is"
				}
			},
			{
				"Italian",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "it"
				}
			},
			{
				"Italian/Italy",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "it-IT",
					GoogleCode = "it"
				}
			},
			{
				"Italian/Switzerland",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "it-CH",
					GoogleCode = "it"
				}
			},
			{
				"Inuktitut",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "iu",
					GoogleCode = "-"
				}
			},
			{
				"Japanese",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "ja",
					HasJoinedWords = true
				}
			},
			{
				"Javanese",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "jv"
				}
			},
			{
				"Kalaallisut",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "kl",
					GoogleCode = "-"
				}
			},
			{
				"Kannada",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "kn"
				}
			},
			{
				"Kanuri",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "kr",
					GoogleCode = "-"
				}
			},
			{
				"Kashmiri",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ks",
					GoogleCode = "-"
				}
			},
			{
				"Kazakh",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "kk"
				}
			},
			{
				"Central Khmer",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "km"
				}
			},
			{
				"Kikuyu",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ki",
					GoogleCode = "-"
				}
			},
			{
				"Kinyarwanda",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "rw",
					GoogleCode = "-"
				}
			},
			{
				"Kirghiz",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ky"
				}
			},
			{
				"Komi",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "kv",
					GoogleCode = "-"
				}
			},
			{
				"Kongo",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "kg",
					GoogleCode = "-"
				}
			},
			{
				"Korean",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "ko"
				}
			},
			{
				"Kurdish",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ku"
				}
			},
			{
				"Kuanyama",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "kj",
					GoogleCode = "-"
				}
			},
			{
				"Latin",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "la"
				}
			},
			{
				"Luxembourgish",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "lb"
				}
			},
			{
				"Ganda",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "lg",
					GoogleCode = "-"
				}
			},
			{
				"Limburgan",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "li",
					GoogleCode = "-"
				}
			},
			{
				"Lingala",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ln",
					GoogleCode = "-"
				}
			},
			{
				"Lao",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "lo"
				}
			},
			{
				"Latvian",
				new LanguageCodeDef
				{
					PluralRule = 5,
					Code = "lv"
				}
			},
			{
				"Luba-Katanga",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "lu",
					GoogleCode = "-"
				}
			},
			{
				"Lithuanian",
				new LanguageCodeDef
				{
					PluralRule = 5,
					Code = "lt"
				}
			},
			{
				"Manx",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "gv",
					GoogleCode = "-"
				}
			},
			{
				"Macedonian",
				new LanguageCodeDef
				{
					PluralRule = 13,
					Code = "mk"
				}
			},
			{
				"Malagasy",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "mg"
				}
			},
			{
				"Malay",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "ms"
				}
			},
			{
				"Malay/Brunei Darussalam",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "ms-BN",
					GoogleCode = "ms"
				}
			},
			{
				"Malay/Malaysia",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "ms-MY",
					GoogleCode = "ms"
				}
			},
			{
				"Malayalam",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ml"
				}
			},
			{
				"Maltese",
				new LanguageCodeDef
				{
					PluralRule = 12,
					Code = "mt"
				}
			},
			{
				"Maori",
				new LanguageCodeDef
				{
					PluralRule = 2,
					Code = "mi"
				}
			},
			{
				"Marathi",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "mr"
				}
			},
			{
				"Marshallese",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "mh",
					GoogleCode = "-"
				}
			},
			{
				"Mongolian",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "mn"
				}
			},
			{
				"Nauru",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "na",
					GoogleCode = "-"
				}
			},
			{
				"Navajo",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "nv",
					GoogleCode = "-"
				}
			},
			{
				"North Ndebele",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "nd",
					GoogleCode = "-"
				}
			},
			{
				"Nepali",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ne"
				}
			},
			{
				"Ndonga",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ng",
					GoogleCode = "-"
				}
			},
			{
				"Northern Sotho",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ns",
					GoogleCode = "st"
				}
			},
			{
				"Norwegian",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "nb",
					GoogleCode = "no"
				}
			},
			{
				"Norwegian/Nynorsk",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "nn",
					GoogleCode = "no"
				}
			},
			{
				"Sichuan Yi",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ii",
					GoogleCode = "-"
				}
			},
			{
				"South Ndebele",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "nr",
					GoogleCode = "-"
				}
			},
			{
				"Occitan",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "oc",
					GoogleCode = "-"
				}
			},
			{
				"Ojibwa",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "oj",
					GoogleCode = "-"
				}
			},
			{
				"Church\u00a0Slavic",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "cu",
					GoogleCode = "-"
				}
			},
			{
				"Oromo",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "om",
					GoogleCode = "-"
				}
			},
			{
				"Oriya",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "or",
					GoogleCode = "-"
				}
			},
			{
				"Ossetian",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "os",
					GoogleCode = "-"
				}
			},
			{
				"Pali",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "pi",
					GoogleCode = "-"
				}
			},
			{
				"Pashto",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ps"
				}
			},
			{
				"Persian",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "fa"
				}
			},
			{
				"Polish",
				new LanguageCodeDef
				{
					PluralRule = 8,
					Code = "pl"
				}
			},
			{
				"Portuguese",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "pt"
				}
			},
			{
				"Portuguese/Brazil",
				new LanguageCodeDef
				{
					PluralRule = 2,
					Code = "pt-BR",
					GoogleCode = "pt"
				}
			},
			{
				"Portuguese/Portugal",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "pt-PT",
					GoogleCode = "pt"
				}
			},
			{
				"Punjabi",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "pa"
				}
			},
			{
				"Quechua",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "qu",
					GoogleCode = "-"
				}
			},
			{
				"Quechua/Bolivia",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "qu-BO",
					GoogleCode = "-"
				}
			},
			{
				"Quechua/Ecuador",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "qu-EC",
					GoogleCode = "-"
				}
			},
			{
				"Quechua/Peru",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "qu-PE",
					GoogleCode = "-"
				}
			},
			{
				"Rhaeto-Romanic",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "rm",
					GoogleCode = "ro"
				}
			},
			{
				"Romanian",
				new LanguageCodeDef
				{
					PluralRule = 4,
					Code = "ro"
				}
			},
			{
				"Rundi",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "rn",
					GoogleCode = "-"
				}
			},
			{
				"Russian",
				new LanguageCodeDef
				{
					PluralRule = 6,
					Code = "ru"
				}
			},
			{
				"Russian/Republic of Moldova",
				new LanguageCodeDef
				{
					PluralRule = 6,
					Code = "ru-MO",
					GoogleCode = "ru"
				}
			},
			{
				"Sanskrit",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "sa",
					GoogleCode = "-"
				}
			},
			{
				"Sardinian",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "sc",
					GoogleCode = "-"
				}
			},
			{
				"Sindhi",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "sd"
				}
			},
			{
				"Northern Sami",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "se",
					GoogleCode = "-"
				}
			},
			{
				"Samoan",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "sm"
				}
			},
			{
				"Sango",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "sg",
					GoogleCode = "-"
				}
			},
			{
				"Serbian",
				new LanguageCodeDef
				{
					PluralRule = 6,
					Code = "sr"
				}
			},
			{
				"Serbian/Bosnia and Herzegovina",
				new LanguageCodeDef
				{
					PluralRule = 5,
					Code = "sr-BA",
					GoogleCode = "sr"
				}
			},
			{
				"Serbian/Serbia and Montenegro",
				new LanguageCodeDef
				{
					PluralRule = 5,
					Code = "sr-SP",
					GoogleCode = "sr"
				}
			},
			{
				"Scottish Gaelic",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "gd"
				}
			},
			{
				"Shona",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "sn"
				}
			},
			{
				"Sinhala",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "si"
				}
			},
			{
				"Slovak",
				new LanguageCodeDef
				{
					PluralRule = 7,
					Code = "sk"
				}
			},
			{
				"Slovenian",
				new LanguageCodeDef
				{
					PluralRule = 9,
					Code = "sl"
				}
			},
			{
				"Somali",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "so"
				}
			},
			{
				"Southern Sotho",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "st"
				}
			},
			{
				"Spanish",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es"
				}
			},
			{
				"Spanish/Argentina",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-AR",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Bolivia",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-BO",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Castilian",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-ES",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Chile",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-CL",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Colombia",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-CO",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Costa Rica",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-CR",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Dominican Republic",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-DO",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Ecuador",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-EC",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/El Salvador",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-SV",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Guatemala",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-GT",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Honduras",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-HN",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Mexico",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-MX",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Nicaragua",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-NI",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Panama",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-PA",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Paraguay",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-PY",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Peru",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-PE",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Puerto Rico",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-PR",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Spain",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-ES",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Uruguay",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-UY",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Venezuela",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-VE",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Latin Americas",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-US",
					GoogleCode = "es"
				}
			},
			{
				"Sundanese",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "su"
				}
			},
			{
				"Swahili",
				new LanguageCodeDef
				{
					Code = "sw"
				}
			},
			{
				"Swati",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ss",
					GoogleCode = "-"
				}
			},
			{
				"Swedish",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "sv"
				}
			},
			{
				"Swedish/Finland",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "sv-FI",
					GoogleCode = "sv"
				}
			},
			{
				"Swedish/Sweden",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "sv-SE",
					GoogleCode = "sv"
				}
			},
			{
				"Tamil",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ta"
				}
			},
			{
				"Tatar",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "tt",
					GoogleCode = "-"
				}
			},
			{
				"Telugu",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "te"
				}
			},
			{
				"Tajik",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "tg"
				}
			},
			{
				"Thai",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "th",
					HasJoinedWords = true
				}
			},
			{
				"Tigrinya",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ti",
					GoogleCode = "-"
				}
			},
			{
				"Tibetan",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "bo",
					GoogleCode = "-"
				}
			},
			{
				"Turkmen",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "tk",
					GoogleCode = "-"
				}
			},
			{
				"Tagalog",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "tl"
				}
			},
			{
				"Tswana",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "tn",
					GoogleCode = "-"
				}
			},
			{
				"Tonga",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "to",
					GoogleCode = "-"
				}
			},
			{
				"Turkish",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "tr"
				}
			},
			{
				"Tsonga",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ts",
					GoogleCode = "-"
				}
			},
			{
				"Twi",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "tw",
					GoogleCode = "-"
				}
			},
			{
				"Tahitian",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ty",
					GoogleCode = "-"
				}
			},
			{
				"Uighur",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ug",
					GoogleCode = "-"
				}
			},
			{
				"Ukrainian",
				new LanguageCodeDef
				{
					PluralRule = 6,
					Code = "uk"
				}
			},
			{
				"Urdu",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ur"
				}
			},
			{
				"Uzbek",
				new LanguageCodeDef
				{
					PluralRule = 2,
					Code = "uz"
				}
			},
			{
				"Venda",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ve",
					GoogleCode = "-"
				}
			},
			{
				"Vietnamese",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "vi"
				}
			},
			{
				"Volapk",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "vo",
					GoogleCode = "-"
				}
			},
			{
				"Walloon",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "wa",
					GoogleCode = "-"
				}
			},
			{
				"Welsh",
				new LanguageCodeDef
				{
					PluralRule = 16,
					Code = "cy"
				}
			},
			{
				"Wolof",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "wo",
					GoogleCode = "-"
				}
			},
			{
				"Frisian",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "fy"
				}
			},
			{
				"Xhosa",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "xh"
				}
			},
			{
				"Yiddish",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "yi"
				}
			},
			{
				"Yoruba",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "yo"
				}
			},
			{
				"Zhuang",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "za",
					GoogleCode = "-"
				}
			},
			{
				"Zulu",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "zu"
				}
			}
		};

		public static string GetLanguageCode(string Filter, bool ShowWarnings = false)
		{
			if (string.IsNullOrEmpty(Filter))
			{
				return string.Empty;
			}
			string[] filters = Filter.ToLowerInvariant().Split(" /(),".ToCharArray());
			foreach (KeyValuePair<string, LanguageCodeDef> item in mLanguageDef)
			{
				if (LanguageMatchesFilter(item.Key, filters))
				{
					return item.Value.Code;
				}
			}
			if (ShowWarnings)
			{
				UnityEngine.Debug.Log($"Language '{Filter}' not recognized. Please, add the language code to GoogleTranslation.cs");
			}
			return string.Empty;
		}

		public static List<string> GetLanguagesForDropdown(string Filter, string CodesToExclude)
		{
			string[] filters = Filter.ToLowerInvariant().Split(" /(),".ToCharArray());
			List<string> list = new List<string>();
			foreach (KeyValuePair<string, LanguageCodeDef> item in mLanguageDef)
			{
				if (string.IsNullOrEmpty(Filter) || LanguageMatchesFilter(item.Key, filters))
				{
					string text = string.Concat("[" + item.Value.Code + "]");
					if (!CodesToExclude.Contains(text))
					{
						list.Add(item.Key + " " + text);
					}
				}
			}
			for (int num = list.Count - 2; num >= 0; num--)
			{
				string text2 = list[num].Substring(0, list[num].IndexOf(" ["));
				if (list[num + 1].StartsWith(text2))
				{
					list[num] = text2 + "/" + list[num];
					list.Insert(num + 1, text2 + "/");
				}
			}
			return list;
		}

		private static bool LanguageMatchesFilter(string Language, string[] Filters)
		{
			Language = Language.ToLowerInvariant();
			int i = 0;
			for (int num = Filters.Length; i < num; i++)
			{
				if (Filters[i] != "")
				{
					if (!Language.Contains(Filters[i].ToLower()))
					{
						return false;
					}
					Language = Language.Remove(Language.IndexOf(Filters[i]), Filters[i].Length);
				}
			}
			return true;
		}

		public static string GetFormatedLanguageName(string Language)
		{
			string empty = string.Empty;
			int num = Language.IndexOf(" [");
			if (num > 0)
			{
				Language = Language.Substring(0, num);
			}
			num = Language.IndexOf('/');
			if (num > 0)
			{
				empty = Language.Substring(0, num);
				if (Language == empty + "/" + empty)
				{
					return empty;
				}
				Language = Language.Replace("/", " (") + ")";
			}
			return Language;
		}

		public static string GetCodedLanguage(string Language, string code)
		{
			string languageCode = GetLanguageCode(Language);
			if (string.Compare(code, languageCode, StringComparison.OrdinalIgnoreCase) == 0)
			{
				return Language;
			}
			return Language + " [" + code + "]";
		}

		public static void UnPackCodeFromLanguageName(string CodedLanguage, out string Language, out string code)
		{
			if (string.IsNullOrEmpty(CodedLanguage))
			{
				Language = string.Empty;
				code = string.Empty;
				return;
			}
			int num = CodedLanguage.IndexOf("[");
			if (num < 0)
			{
				Language = CodedLanguage;
				code = GetLanguageCode(Language);
			}
			else
			{
				Language = CodedLanguage.Substring(0, num).Trim();
				code = CodedLanguage.Substring(num + 1, CodedLanguage.IndexOf("]", num) - num - 1);
			}
		}

		public static string GetGoogleLanguageCode(string InternationalCode)
		{
			foreach (KeyValuePair<string, LanguageCodeDef> item in mLanguageDef)
			{
				if (InternationalCode == item.Value.Code)
				{
					if (item.Value.GoogleCode == "-")
					{
						return null;
					}
					return (!string.IsNullOrEmpty(item.Value.GoogleCode)) ? item.Value.GoogleCode : InternationalCode;
				}
			}
			return InternationalCode;
		}

		public static string GetLanguageName(string code, bool useParenthesesForRegion = false, bool allowDiscardRegion = true)
		{
			foreach (KeyValuePair<string, LanguageCodeDef> item in mLanguageDef)
			{
				if (!(code == item.Value.Code))
				{
					continue;
				}
				string text = item.Key;
				if (useParenthesesForRegion)
				{
					int num = text.IndexOf('/');
					if (num > 0)
					{
						text = text.Substring(0, num) + " (" + text.Substring(num + 1) + ")";
					}
				}
				return text;
			}
			if (allowDiscardRegion)
			{
				int num2 = code.IndexOf("-");
				if (num2 > 0)
				{
					return GetLanguageName(code.Substring(0, num2), useParenthesesForRegion, allowDiscardRegion: false);
				}
			}
			return null;
		}

		public static List<string> GetAllInternationalCodes()
		{
			HashSet<string> hashSet = new HashSet<string>();
			foreach (KeyValuePair<string, LanguageCodeDef> item in mLanguageDef)
			{
				hashSet.Add(item.Value.Code);
			}
			return new List<string>(hashSet);
		}

		public static bool LanguageCode_HasJoinedWord(string languageCode)
		{
			foreach (KeyValuePair<string, LanguageCodeDef> item in mLanguageDef)
			{
				if (languageCode == item.Value.GoogleCode || languageCode == item.Value.Code)
				{
					return item.Value.HasJoinedWords;
				}
			}
			return false;
		}

		private static int GetPluralRule(string langCode)
		{
			if (langCode.Length > 2)
			{
				langCode = langCode.Substring(0, 2);
			}
			langCode = langCode.ToLower();
			foreach (KeyValuePair<string, LanguageCodeDef> item in mLanguageDef)
			{
				if (item.Value.Code == langCode)
				{
					return item.Value.PluralRule;
				}
			}
			return 0;
		}

		public static bool LanguageHasPluralType(string langCode, string pluralType)
		{
			switch (pluralType)
			{
			case "Plural":
			case "Zero":
			case "One":
				return true;
			default:
				switch (GetPluralRule(langCode))
				{
				case 3:
					if (!(pluralType == "Two"))
					{
						return pluralType == "Few";
					}
					return true;
				case 4:
				case 5:
				case 6:
				case 7:
				case 8:
					return pluralType == "Few";
				case 9:
					if (!(pluralType == "Two"))
					{
						return pluralType == "Few";
					}
					return true;
				case 10:
				case 11:
				case 15:
				case 16:
					if (!(pluralType == "Two") && !(pluralType == "Few"))
					{
						return pluralType == "Many";
					}
					return true;
				case 12:
					if (!(pluralType == "Few"))
					{
						return pluralType == "Many";
					}
					return true;
				case 13:
					return pluralType == "Two";
				default:
					return false;
				}
			}
		}

		public static ePluralType GetPluralType(string langCode, int n)
		{
			switch (n)
			{
			case 0:
				return ePluralType.Zero;
			case 1:
				return ePluralType.One;
			default:
				switch (GetPluralRule(langCode))
				{
				case 0:
					return ePluralType.Plural;
				case 1:
					if (n != 1)
					{
						return ePluralType.Plural;
					}
					return ePluralType.One;
				case 2:
					if (n > 1)
					{
						return ePluralType.Plural;
					}
					return ePluralType.One;
				case 3:
					switch (n)
					{
					default:
						if (!inRange(n, 3, 10) && !inRange(n, 13, 19))
						{
							return ePluralType.Plural;
						}
						return ePluralType.Few;
					case 2:
					case 12:
						return ePluralType.Two;
					case 1:
					case 11:
						return ePluralType.One;
					}
				case 4:
					if (n != 1)
					{
						if (!inRange(n % 100, 1, 19))
						{
							return ePluralType.Plural;
						}
						return ePluralType.Few;
					}
					return ePluralType.One;
				case 5:
					if (n % 10 != 1 || n % 100 == 11)
					{
						if (n % 10 < 2 || (n % 100 >= 10 && n % 100 < 20))
						{
							return ePluralType.Plural;
						}
						return ePluralType.Few;
					}
					return ePluralType.One;
				case 6:
					if (n % 10 != 1 || n % 100 == 11)
					{
						if (!inRange(n % 10, 2, 4) || inRange(n % 100, 12, 14))
						{
							return ePluralType.Plural;
						}
						return ePluralType.Few;
					}
					return ePluralType.One;
				case 7:
					if (n != 1)
					{
						if (!inRange(n, 2, 4))
						{
							return ePluralType.Plural;
						}
						return ePluralType.Few;
					}
					return ePluralType.One;
				case 8:
					if (n != 1)
					{
						if (!inRange(n % 10, 2, 4) || inRange(n % 100, 12, 14))
						{
							return ePluralType.Plural;
						}
						return ePluralType.Few;
					}
					return ePluralType.One;
				case 9:
					if (n % 100 != 1)
					{
						if (n % 100 != 2)
						{
							if (!inRange(n % 100, 3, 4))
							{
								return ePluralType.Plural;
							}
							return ePluralType.Few;
						}
						return ePluralType.Two;
					}
					return ePluralType.One;
				case 10:
					switch (n)
					{
					default:
						if (!inRange(n, 3, 6))
						{
							if (!inRange(n, 7, 10))
							{
								return ePluralType.Plural;
							}
							return ePluralType.Many;
						}
						return ePluralType.Few;
					case 2:
						return ePluralType.Two;
					case 1:
						return ePluralType.One;
					}
				case 11:
					switch (n)
					{
					default:
						if (!inRange(n % 100, 3, 10))
						{
							if (n % 100 < 11)
							{
								return ePluralType.Plural;
							}
							return ePluralType.Many;
						}
						return ePluralType.Few;
					case 2:
						return ePluralType.Two;
					case 1:
						return ePluralType.One;
					case 0:
						return ePluralType.Zero;
					}
				case 12:
					if (n != 1)
					{
						if (!inRange(n % 100, 1, 10))
						{
							if (!inRange(n % 100, 11, 19))
							{
								return ePluralType.Plural;
							}
							return ePluralType.Many;
						}
						return ePluralType.Few;
					}
					return ePluralType.One;
				case 13:
					if (n % 10 != 1)
					{
						if (n % 10 != 2)
						{
							return ePluralType.Plural;
						}
						return ePluralType.Two;
					}
					return ePluralType.One;
				case 14:
					if (n % 10 != 1 || n % 100 == 11)
					{
						return ePluralType.Plural;
					}
					return ePluralType.One;
				case 15:
					if (n % 10 != 1 || n % 100 == 11 || n % 100 == 71 || n % 100 == 91)
					{
						if (n % 10 != 2 || n % 100 == 12 || n % 100 == 72 || n % 100 == 92)
						{
							if ((n % 10 != 3 && n % 10 != 4 && n % 10 != 9) || n % 100 == 13 || n % 100 == 14 || n % 100 == 19 || n % 100 == 73 || n % 100 == 74 || n % 100 == 79 || n % 100 == 93 || n % 100 == 94 || n % 100 == 99)
							{
								if (n % 1000000 != 0)
								{
									return ePluralType.Plural;
								}
								return ePluralType.Many;
							}
							return ePluralType.Few;
						}
						return ePluralType.Two;
					}
					return ePluralType.One;
				case 16:
					return n switch
					{
						6 => ePluralType.Many, 
						3 => ePluralType.Few, 
						2 => ePluralType.Two, 
						1 => ePluralType.One, 
						0 => ePluralType.Zero, 
						_ => ePluralType.Plural, 
					};
				default:
					return ePluralType.Plural;
				}
			}
		}

		public static int GetPluralTestNumber(string langCode, ePluralType pluralType)
		{
			switch (pluralType)
			{
			case ePluralType.Zero:
				return 0;
			case ePluralType.One:
				return 1;
			case ePluralType.Few:
				return 3;
			case ePluralType.Many:
				switch (GetPluralRule(langCode))
				{
				case 10:
					return 8;
				case 11:
				case 12:
					return 13;
				case 15:
					return 1000000;
				default:
					return 6;
				}
			default:
				return 936;
			}
		}

		private static bool inRange(int amount, int min, int max)
		{
			if (amount >= min)
			{
				return amount <= max;
			}
			return false;
		}
	}
	public static class GoogleTranslation
	{
		public delegate void fnOnTranslated(string Translation, string Error);

		public delegate void fnOnTranslationReady(Dictionary<string, TranslationQuery> dict, string error);

		private static List<UnityWebRequest> mCurrentTranslations = new List<UnityWebRequest>();

		private static List<TranslationJob> mTranslationJobs = new List<TranslationJob>();

		public static bool CanTranslate()
		{
			if (LocalizationManager.Sources.Count > 0)
			{
				return !string.IsNullOrEmpty(LocalizationManager.GetWebServiceURL());
			}
			return false;
		}

		public static void Translate(string text, string LanguageCodeFrom, string LanguageCodeTo, fnOnTranslated OnTranslationReady)
		{
			LocalizationManager.InitializeIfNeeded();
			if (!CanTranslate())
			{
				OnTranslationReady(null, "WebService is not set correctly or needs to be reinstalled");
				return;
			}
			if (LanguageCodeTo == LanguageCodeFrom)
			{
				OnTranslationReady(text, null);
				return;
			}
			Dictionary<string, TranslationQuery> queries = new Dictionary<string, TranslationQuery>();
			if (string.IsNullOrEmpty(LanguageCodeTo))
			{
				OnTranslationReady(string.Empty, null);
				return;
			}
			CreateQueries(text, LanguageCodeFrom, LanguageCodeTo, queries);
			Translate(queries, delegate(Dictionary<string, TranslationQuery> results, string error)
			{
				if (!string.IsNullOrEmpty(error) || results.Count == 0)
				{
					OnTranslationReady(null, error);
				}
				else
				{
					string translation = RebuildTranslation(text, queries, LanguageCodeTo);
					OnTranslationReady(translation, null);
				}
			});
		}

		public static string ForceTranslate(string text, string LanguageCodeFrom, string LanguageCodeTo)
		{
			Dictionary<string, TranslationQuery> dictionary = new Dictionary<string, TranslationQuery>();
			AddQuery(text, LanguageCodeFrom, LanguageCodeTo, dictionary);
			TranslationJob_Main translationJob_Main = new TranslationJob_Main(dictionary, null);
			while (true)
			{
				switch (translationJob_Main.GetState())
				{
				case TranslationJob.eJobState.Running:
					break;
				case TranslationJob.eJobState.Failed:
					return null;
				default:
					return GetQueryResult(text, "", dictionary);
				}
			}
		}

		public static void Translate(Dictionary<string, TranslationQuery> requests, fnOnTranslationReady OnTranslationReady, bool usePOST = true)
		{
			AddTranslationJob(new TranslationJob_Main(requests, OnTranslationReady));
		}

		public static bool ForceTranslate(Dictionary<string, TranslationQuery> requests, bool usePOST = true)
		{
			TranslationJob_Main translationJob_Main = new TranslationJob_Main(requests, null);
			while (true)
			{
				switch (translationJob_Main.GetState())
				{
				case TranslationJob.eJobState.Running:
					break;
				case TranslationJob.eJobState.Failed:
					return false;
				default:
					return true;
				}
			}
		}

		public static List<string> ConvertTranslationRequest(Dictionary<string, TranslationQuery> requests, bool encodeGET)
		{
			List<string> list = new List<string>();
			StringBuilder stringBuilder = new StringBuilder();
			foreach (KeyValuePair<string, TranslationQuery> request in requests)
			{
				TranslationQuery value = request.Value;
				if (stringBuilder.Length > 0)
				{
					stringBuilder.Append("<I2Loc>");
				}
				stringBuilder.Append(GoogleLanguages.GetGoogleLanguageCode(value.LanguageCode));
				stringBuilder.Append(":");
				for (int i = 0; i < value.TargetLanguagesCode.Length; i++)
				{
					if (i != 0)
					{
						stringBuilder.Append(",");
					}
					stringBuilder.Append(GoogleLanguages.GetGoogleLanguageCode(value.TargetLanguagesCode[i]));
				}
				stringBuilder.Append("=");
				string text = ((TitleCase(value.Text) == value.Text) ? value.Text.ToLowerInvariant() : value.Text);
				if (!encodeGET)
				{
					stringBuilder.Append(text);
					continue;
				}
				stringBuilder.Append(Uri.EscapeDataString(text));
				if (stringBuilder.Length > 4000)
				{
					list.Add(stringBuilder.ToString());
					stringBuilder.Length = 0;
				}
			}
			list.Add(stringBuilder.ToString());
			return list;
		}

		private static void AddTranslationJob(TranslationJob job)
		{
			mTranslationJobs.Add(job);
			if (mTranslationJobs.Count == 1)
			{
				CoroutineManager.Start(WaitForTranslations());
			}
		}

		private static IEnumerator WaitForTranslations()
		{
			while (mTranslationJobs.Count > 0)
			{
				TranslationJob[] array = mTranslationJobs.ToArray();
				foreach (TranslationJob translationJob in array)
				{
					if (translationJob.GetState() != 0)
					{
						mTranslationJobs.Remove(translationJob);
					}
				}
				yield return null;
			}
		}

		public static string ParseTranslationResult(string html, Dictionary<string, TranslationQuery> requests)
		{
			if (html.StartsWith("<!DOCTYPE html>") || html.StartsWith("<HTML>"))
			{
				if (html.Contains("The script completed but did not return anything"))
				{
					return "The current Google WebService is not supported.\nPlease, delete the WebService from the Google Drive and Install the latest version.";
				}
				if (html.Contains("Service invoked too many times in a short time"))
				{
					return "";
				}
				return "There was a problem contacting the WebService. Please try again later\n" + html;
			}
			string[] array = html.Split(new string[1] { "<I2Loc>" }, StringSplitOptions.None);
			string[] separator = new string[1] { "<i2>" };
			int num = 0;
			string[] array2 = requests.Keys.ToArray();
			foreach (string text in array2)
			{
				TranslationQuery value = FindQueryFromOrigText(text, requests);
				string text2 = array[num++];
				if (value.Tags != null)
				{
					for (int num2 = value.Tags.Length - 1; num2 >= 0; num2--)
					{
						text2 = text2.Replace(GetGoogleNoTranslateTag(num2), value.Tags[num2]);
					}
				}
				value.Results = text2.Split(separator, StringSplitOptions.None);
				if (TitleCase(text) == text)
				{
					for (int j = 0; j < value.Results.Length; j++)
					{
						value.Results[j] = TitleCase(value.Results[j]);
					}
				}
				requests[value.OrigText] = value;
			}
			return null;
		}

		public static bool IsTranslating()
		{
			if (mCurrentTranslations.Count <= 0)
			{
				return mTranslationJobs.Count > 0;
			}
			return true;
		}

		public static void CancelCurrentGoogleTranslations()
		{
			mCurrentTranslations.Clear();
			foreach (TranslationJob mTranslationJob in mTranslationJobs)
			{
				mTranslationJob.Dispose();
			}
			mTranslationJobs.Clear();
		}

		public static void CreateQueries(string text, string LanguageCodeFrom, string LanguageCodeTo, Dictionary<string, TranslationQuery> dict)
		{
			if (!text.Contains("[i2s_"))
			{
				CreateQueries_Plurals(text, LanguageCodeFrom, LanguageCodeTo, dict);
				return;
			}
			foreach (KeyValuePair<string, string> specialization in SpecializationManager.GetSpecializations(text))
			{
				CreateQueries_Plurals(specialization.Value, LanguageCodeFrom, LanguageCodeTo, dict);
			}
		}

		private static void CreateQueries_Plurals(string text, string LanguageCodeFrom, string LanguageCodeTo, Dictionary<string, TranslationQuery> dict)
		{
			bool flag = text.Contains("{[#");
			bool flag2 = text.Contains("[i2p_");
			if (!HasParameters(text) || (!flag && !flag2))
			{
				AddQuery(text, LanguageCodeFrom, LanguageCodeTo, dict);
				return;
			}
			bool forceTag = flag;
			for (ePluralType ePluralType2 = ePluralType.Zero; ePluralType2 <= ePluralType.Plural; ePluralType2++)
			{
				string pluralType = ePluralType2.ToString();
				if (GoogleLanguages.LanguageHasPluralType(LanguageCodeTo, pluralType))
				{
					string text2 = GetPluralText(text, pluralType);
					int pluralTestNumber = GoogleLanguages.GetPluralTestNumber(LanguageCodeTo, ePluralType2);
					string pluralParameter = GetPluralParameter(text2, forceTag);
					if (!string.IsNullOrEmpty(pluralParameter))
					{
						text2 = text2.Replace(pluralParameter, pluralTestNumber.ToString());
					}
					AddQuery(text2, LanguageCodeFrom, LanguageCodeTo, dict);
				}
			}
		}

		public static void AddQuery(string text, string LanguageCodeFrom, string LanguageCodeTo, Dictionary<string, TranslationQuery> dict)
		{
			if (string.IsNullOrEmpty(text))
			{
				return;
			}
			if (!dict.ContainsKey(text))
			{
				TranslationQuery translationQuery = default(TranslationQuery);
				translationQuery.OrigText = text;
				translationQuery.LanguageCode = LanguageCodeFrom;
				translationQuery.TargetLanguagesCode = new string[1] { LanguageCodeTo };
				TranslationQuery query = translationQuery;
				query.Text = text;
				ParseNonTranslatableElements(ref query);
				dict[text] = query;
			}
			else
			{
				TranslationQuery value = dict[text];
				if (Array.IndexOf(value.TargetLanguagesCode, LanguageCodeTo) < 0)
				{
					value.TargetLanguagesCode = value.TargetLanguagesCode.Concat(new string[1] { LanguageCodeTo }).Distinct().ToArray();
				}
				dict[text] = value;
			}
		}

		private static string GetTranslation(string text, string LanguageCodeTo, Dictionary<string, TranslationQuery> dict)
		{
			if (!dict.ContainsKey(text))
			{
				return null;
			}
			TranslationQuery translationQuery = dict[text];
			int num = Array.IndexOf(translationQuery.TargetLanguagesCode, LanguageCodeTo);
			if (num < 0)
			{
				return "";
			}
			if (translationQuery.Results == null)
			{
				return "";
			}
			return translationQuery.Results[num];
		}

		private static TranslationQuery FindQueryFromOrigText(string origText, Dictionary<string, TranslationQuery> dict)
		{
			foreach (KeyValuePair<string, TranslationQuery> item in dict)
			{
				if (item.Value.OrigText == origText)
				{
					return item.Value;
				}
			}
			return default(TranslationQuery);
		}

		public static bool HasParameters(string text)
		{
			int num = text.IndexOf("{[");
			if (num < 0)
			{
				return false;
			}
			return text.IndexOf("]}", num) > 0;
		}

		public static string GetPluralParameter(string text, bool forceTag)
		{
			int num = text.IndexOf("{[#");
			if (num < 0)
			{
				if (forceTag)
				{
					return null;
				}
				num = text.IndexOf("{[");
			}
			if (num < 0)
			{
				return null;
			}
			int num2 = text.IndexOf("]}", num + 2);
			if (num2 < 0)
			{
				return null;
			}
			return text.Substring(num, num2 - num + 2);
		}

		public static string GetPluralText(string text, string pluralType)
		{
			pluralType = "[i2p_" + pluralType + "]";
			int num = text.IndexOf(pluralType);
			if (num >= 0)
			{
				num += pluralType.Length;
				int num2 = text.IndexOf("[i2p_", num);
				if (num2 < 0)
				{
					num2 = text.Length;
				}
				return text.Substring(num, num2 - num);
			}
			num = text.IndexOf("[i2p_");
			if (num < 0)
			{
				return text;
			}
			if (num > 0)
			{
				return text.Substring(0, num);
			}
			num = text.IndexOf("]");
			if (num < 0)
			{
				return text;
			}
			num++;
			int num3 = text.IndexOf("[i2p_", num);
			if (num3 < 0)
			{
				num3 = text.Length;
			}
			return text.Substring(num, num3 - num);
		}

		private static int FindClosingTag(string tag, MatchCollection matches, int startIndex)
		{
			int i = startIndex;
			for (int count = matches.Count; i < count; i++)
			{
				string captureMatch = I2Utils.GetCaptureMatch(matches[i]);
				if (captureMatch[0] == '/' && tag.StartsWith(captureMatch.Substring(1)))
				{
					return i;
				}
			}
			return -1;
		}

		private static string GetGoogleNoTranslateTag(int tagNumber)
		{
			if (tagNumber < 70)
			{
				return "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++".Substring(0, tagNumber + 1);
			}
			string text = "";
			for (int i = -1; i < tagNumber; i++)
			{
				text += "+";
			}
			return text;
		}

		private static void ParseNonTranslatableElements(ref TranslationQuery query)
		{
			MatchCollection matchCollection = Regex.Matches(query.Text, "\\{\\[(.*?)]}|\\[(.*?)]|\\<(.*?)>");
			if (matchCollection == null || matchCollection.Count == 0)
			{
				return;
			}
			string text = query.Text;
			List<string> list = new List<string>();
			int i = 0;
			for (int count = matchCollection.Count; i < count; i++)
			{
				string captureMatch = I2Utils.GetCaptureMatch(matchCollection[i]);
				int num = FindClosingTag(captureMatch, matchCollection, i);
				if (num < 0)
				{
					string text2 = matchCollection[i].ToString();
					if (text2.StartsWith("{[") && text2.EndsWith("]}"))
					{
						text = text.Replace(text2, GetGoogleNoTranslateTag(list.Count) + " ");
						list.Add(text2);
					}
				}
				else if (captureMatch == "i2nt")
				{
					string text3 = query.Text.Substring(matchCollection[i].Index, matchCollection[num].Index - matchCollection[i].Index + matchCollection[num].Length);
					text = text.Replace(text3, GetGoogleNoTranslateTag(list.Count) + " ");
					list.Add(text3);
				}
				else
				{
					string text4 = matchCollection[i].ToString();
					text = text.Replace(text4, GetGoogleNoTranslateTag(list.Count) + " ");
					list.Add(text4);
					string text5 = matchCollection[num].ToString();
					text = text.Replace(text5, GetGoogleNoTranslateTag(list.Count) + " ");
					list.Add(text5);
				}
			}
			query.Text = text;
			query.Tags = list.ToArray();
		}

		public static string GetQueryResult(string text, string LanguageCodeTo, Dictionary<string, TranslationQuery> dict)
		{
			if (!dict.ContainsKey(text))
			{
				return null;
			}
			TranslationQuery translationQuery = dict[text];
			if (translationQuery.Results == null || translationQuery.Results.Length < 0)
			{
				return null;
			}
			if (string.IsNullOrEmpty(LanguageCodeTo))
			{
				return translationQuery.Results[0];
			}
			int num = Array.IndexOf(translationQuery.TargetLanguagesCode, LanguageCodeTo);
			if (num < 0)
			{
				return null;
			}
			return translationQuery.Results[num];
		}

		public static string RebuildTranslation(string text, Dictionary<string, TranslationQuery> dict, string LanguageCodeTo)
		{
			if (!text.Contains("[i2s_"))
			{
				return RebuildTranslation_Plural(text, dict, LanguageCodeTo);
			}
			Dictionary<string, string> specializations = SpecializationManager.GetSpecializations(text);
			Dictionary<string, string> dictionary = new Dictionary<string, string>();
			foreach (KeyValuePair<string, string> item in specializations)
			{
				dictionary[item.Key] = RebuildTranslation_Plural(item.Value, dict, LanguageCodeTo);
			}
			return SpecializationManager.SetSpecializedText(dictionary);
		}

		private static string RebuildTranslation_Plural(string text, Dictionary<string, TranslationQuery> dict, string LanguageCodeTo)
		{
			bool flag = text.Contains("{[#");
			bool flag2 = text.Contains("[i2p_");
			if (!HasParameters(text) || (!flag && !flag2))
			{
				return GetTranslation(text, LanguageCodeTo, dict);
			}
			StringBuilder stringBuilder = new StringBuilder();
			string text2 = null;
			bool forceTag = flag;
			for (ePluralType ePluralType2 = ePluralType.Plural; ePluralType2 >= ePluralType.Zero; ePluralType2--)
			{
				string text3 = ePluralType2.ToString();
				if (!GoogleLanguages.LanguageHasPluralType(LanguageCodeTo, text3))
				{
					continue;
				}
				string text4 = GetPluralText(text, text3);
				int pluralTestNumber = GoogleLanguages.GetPluralTestNumber(LanguageCodeTo, ePluralType2);
				string pluralParameter = GetPluralParameter(text4, forceTag);
				if (!string.IsNullOrEmpty(pluralParameter))
				{
					text4 = text4.Replace(pluralParameter, pluralTestNumber.ToString());
				}
				string text5 = GetTranslation(text4, LanguageCodeTo, dict);
				if (!string.IsNullOrEmpty(pluralParameter))
				{
					text5 = text5.Replace(pluralTestNumber.ToString(), pluralParameter);
				}
				if (ePluralType2 == ePluralType.Plural)
				{
					text2 = text5;
				}
				else
				{
					if (text5 == text2)
					{
						continue;
					}
					stringBuilder.AppendFormat("[i2p_{0}]", text3);
				}
				stringBuilder.Append(text5);
			}
			return stringBuilder.ToString();
		}

		public static string UppercaseFirst(string s)
		{
			if (string.IsNullOrEmpty(s))
			{
				return string.Empty;
			}
			char[] array = s.ToLower().ToCharArray();
			array[0] = char.ToUpper(array[0]);
			return new string(array);
		}

		public static string TitleCase(string s)
		{
			if (string.IsNullOrEmpty(s))
			{
				return string.Empty;
			}
			return CultureInfo.CurrentCulture.TextInfo.ToTitleCase(s);
		}
	}
	public struct TranslationQuery
	{
		public string OrigText;

		public string Text;

		public string LanguageCode;

		public string[] TargetLanguagesCode;

		public string[] Results;

		public string[] Tags;
	}
	public class TranslationJob : IDisposable
	{
		public enum eJobState
		{
			Running,
			Succeeded,
			Failed
		}

		public eJobState mJobState;

		public virtual eJobState GetState()
		{
			return mJobState;
		}

		public virtual void Dispose()
		{
		}
	}
	public class TranslationJob_WWW : TranslationJob
	{
		public UnityWebRequest www;

		public override void Dispose()
		{
			if (www != null)
			{
				www.Dispose();
			}
			www = null;
		}
	}
	public class TranslationJob_GET : TranslationJob_WWW
	{
		private Dictionary<string, TranslationQuery> _requests;

		private GoogleTranslation.fnOnTranslationReady _OnTranslationReady;

		private List<string> mQueries;

		public string mErrorMessage;

		public TranslationJob_GET(Dictionary<string, TranslationQuery> requests, GoogleTranslation.fnOnTranslationReady OnTranslationReady)
		{
			_requests = requests;
			_OnTranslationReady = OnTranslationReady;
			mQueries = GoogleTranslation.ConvertTranslationRequest(requests, encodeGET: true);
			GetState();
		}

		private void ExecuteNextQuery()
		{
			if (mQueries.Count == 0)
			{
				mJobState = eJobState.Succeeded;
				return;
			}
			int index = mQueries.Count - 1;
			string arg = mQueries[index];
			mQueries.RemoveAt(index);
			string uri = $"{LocalizationManager.GetWebServiceURL()}?action=Translate&list={arg}";
			www = UnityWebRequest.Get(uri);
			I2Utils.SendWebRequest(www);
		}

		public override eJobState GetState()
		{
			if (www != null && www.isDone)
			{
				ProcessResult(www.downloadHandler.data, www.error);
				www.Dispose();
				www = null;
			}
			if (www == null)
			{
				ExecuteNextQuery();
			}
			return mJobState;
		}

		public void ProcessResult(byte[] bytes, string errorMsg)
		{
			if (string.IsNullOrEmpty(errorMsg))
			{
				errorMsg = GoogleTranslation.ParseTranslationResult(Encoding.UTF8.GetString(bytes, 0, bytes.Length), _requests);
				if (string.IsNullOrEmpty(errorMsg))
				{
					if (_OnTranslationReady != null)
					{
						_OnTranslationReady(_requests, null);
					}
					return;
				}
			}
			mJobState = eJobState.Failed;
			mErrorMessage = errorMsg;
		}
	}
	public class TranslationJob_Main : TranslationJob
	{
		private TranslationJob_WEB mWeb;

		private TranslationJob_POST mPost;

		private TranslationJob_GET mGet;

		private Dictionary<string, TranslationQuery> _requests;

		private GoogleTranslation.fnOnTranslationReady _OnTranslationReady;

		public string mErrorMessage;

		public TranslationJob_Main(Dictionary<string, TranslationQuery> requests, GoogleTranslation.fnOnTranslationReady OnTranslationReady)
		{
			_requests = requests;
			_OnTranslationReady = OnTranslationReady;
			mPost = new TranslationJob_POST(requests, OnTranslationReady);
		}

		public override eJobState GetState()
		{
			if (mWeb != null)
			{
				switch (mWeb.GetState())
				{
				case eJobState.Running:
					return eJobState.Running;
				case eJobState.Succeeded:
					mJobState = eJobState.Succeeded;
					break;
				case eJobState.Failed:
					mWeb.Dispose();
					mWeb = null;
					mPost = new TranslationJob_POST(_requests, _OnTranslationReady);
					break;
				}
			}
			if (mPost != null)
			{
				switch (mPost.GetState())
				{
				case eJobState.Running:
					return eJobState.Running;
				case eJobState.Succeeded:
					mJobState = eJobState.Succeeded;
					break;
				case eJobState.Failed:
					mPost.Dispose();
					mPost = null;
					mGet = new TranslationJob_GET(_requests, _OnTranslationReady);
					break;
				}
			}
			if (mGet != null)
			{
				switch (mGet.GetState())
				{
				case eJobState.Running:
					return eJobState.Running;
				case eJobState.Succeeded:
					mJobState = eJobState.Succeeded;
					break;
				case eJobState.Failed:
					mErrorMessage = mGet.mErrorMessage;
					if (_OnTranslationReady != null)
					{
						_OnTranslationReady(_requests, mErrorMessage);
					}
					mGet.Dispose();
					mGet = null;
					break;
				}
			}
			return mJobState;
		}

		public override void Dispose()
		{
			if (mPost != null)
			{
				mPost.Dispose();
			}
			if (mGet != null)
			{
				mGet.Dispose();
			}
			mPost = null;
			mGet = null;
		}
	}
	public class TranslationJob_POST : TranslationJob_WWW
	{
		private Dictionary<string, TranslationQuery> _requests;

		private GoogleTranslation.fnOnTranslationReady _OnTranslationReady;

		public TranslationJob_POST(Dictionary<string, TranslationQuery> requests, GoogleTranslation.fnOnTranslationReady OnTranslationReady)
		{
			_requests = requests;
			_OnTranslationReady = OnTranslationReady;
			List<string> list = GoogleTranslation.ConvertTranslationRequest(requests, encodeGET: false);
			WWWForm wWWForm = new WWWForm();
			wWWForm.AddField("action", "Translate");
			wWWForm.AddField("list", list[0]);
			www = UnityWebRequest.Post(LocalizationManager.GetWebServiceURL(), wWWForm);
			I2Utils.SendWebRequest(www);
		}

		public override eJobState GetState()
		{
			if (www != null && www.isDone)
			{
				ProcessResult(www.downloadHandler.data, www.error);
				www.Dispose();
				www = null;
			}
			return mJobState;
		}

		public void ProcessResult(byte[] bytes, string errorMsg)
		{
			if (!string.IsNullOrEmpty(errorMsg))
			{
				mJobState = eJobState.Failed;
				return;
			}
			errorMsg = GoogleTranslation.ParseTranslationResult(Encoding.UTF8.GetString(bytes, 0, bytes.Length), _requests);
			if (_OnTranslationReady != null)
			{
				_OnTranslationReady(_requests, errorMsg);
			}
			mJobState = eJobState.Succeeded;
		}
	}
	public class TranslationJob_WEB : TranslationJob_WWW
	{
		private Dictionary<string, TranslationQuery> _requests;

		private GoogleTranslation.fnOnTranslationReady _OnTranslationReady;

		public string mErrorMessage;

		private string mCurrentBatch_ToLanguageCode;

		private string mCurrentBatch_FromLanguageCode;

		private List<string> mCurrentBatch_Text;

		private List<KeyValuePair<string, string>> mQueries;

		public TranslationJob_WEB(Dictionary<string, TranslationQuery> requests, GoogleTranslation.fnOnTranslationReady OnTranslationReady)
		{
			_requests = requests;
			_OnTranslationReady = OnTranslationReady;
			FindAllQueries();
			ExecuteNextBatch();
		}

		private void FindAllQueries()
		{
			mQueries = new List<KeyValuePair<string, string>>();
			foreach (KeyValuePair<string, TranslationQuery> request in _requests)
			{
				string[] targetLanguagesCode = request.Value.TargetLanguagesCode;
				foreach (string text in targetLanguagesCode)
				{
					mQueries.Add(new KeyValuePair<string, string>(request.Value.OrigText, request.Value.LanguageCode + ":" + text));
				}
			}
			mQueries.Sort((KeyValuePair<string, string> a, KeyValuePair<string, string> b) => a.Value.CompareTo(b.Value));
		}

		private void ExecuteNextBatch()
		{
			if (mQueries.Count == 0)
			{
				mJobState = eJobState.Succeeded;
				return;
			}
			mCurrentBatch_Text = new List<string>();
			string text = null;
			int num = 200;
			StringBuilder stringBuilder = new StringBuilder();
			int i;
			for (i = 0; i < mQueries.Count; i++)
			{
				string key = mQueries[i].Key;
				string value = mQueries[i].Value;
				if (text == null || value == text)
				{
					if (i != 0)
					{
						stringBuilder.Append("|||");
					}
					stringBuilder.Append(key);
					mCurrentBatch_Text.Add(key);
					text = value;
				}
				if (stringBuilder.Length > num)
				{
					break;
				}
			}
			mQueries.RemoveRange(0, i);
			string[] array = text.Split(':');
			mCurrentBatch_FromLanguageCode = array[0];
			mCurrentBatch_ToLanguageCode = array[1];
			string text2 = $"http://www.google.com/translate_t?hl=en&vi=c&ie=UTF8&oe=UTF8&submit=Translate&langpair={mCurrentBatch_FromLanguageCode}|{mCurrentBatch_ToLanguageCode}&text={Uri.EscapeUriString(stringBuilder.ToString())}";
			UnityEngine.Debug.Log(text2);
			www = UnityWebRequest.Get(text2);
			I2Utils.SendWebRequest(www);
		}

		public override eJobState GetState()
		{
			if (www != null && www.isDone)
			{
				ProcessResult(www.downloadHandler.data, www.error);
				www.Dispose();
				www = null;
			}
			if (www == null)
			{
				ExecuteNextBatch();
			}
			return mJobState;
		}

		public void ProcessResult(byte[] bytes, string errorMsg)
		{
			if (string.IsNullOrEmpty(errorMsg))
			{
				string @string = Encoding.UTF8.GetString(bytes, 0, bytes.Length);
				UnityEngine.Debug.Log(ParseTranslationResult(@string, "aab"));
				if (string.IsNullOrEmpty(errorMsg))
				{
					if (_OnTranslationReady != null)
					{
						_OnTranslationReady(_requests, null);
					}
					return;
				}
			}
			mJobState = eJobState.Failed;
			mErrorMessage = errorMsg;
		}

		private string ParseTranslationResult(string html, string OriginalText)
		{
			try
			{
				int num = html.IndexOf("TRANSLATED_TEXT='") + "TRANSLATED_TEXT='".Length;
				int num2 = html.IndexOf("';var", num);
				string input = html.Substring(num, num2 - num);
				input = Regex.Replace(input, "\\\\x([a-fA-F0-9]{2})", (Match match) => char.ConvertFromUtf32(int.Parse(match.Groups[1].Value, NumberStyles.HexNumber)));
				input = Regex.Replace(input, "&#(\\d+);", (Match match) => char.ConvertFromUtf32(int.Parse(match.Groups[1].Value)));
				input = input.Replace("<br>", "\n");
				if (OriginalText.ToUpper() == OriginalText)
				{
					input = input.ToUpper();
				}
				else if (GoogleTranslation.UppercaseFirst(OriginalText) == OriginalText)
				{
					input = GoogleTranslation.UppercaseFirst(input);
				}
				else if (GoogleTranslation.TitleCase(OriginalText) == OriginalText)
				{
					input = GoogleTranslation.TitleCase(input);
				}
				return input;
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogError(ex.Message);
				return string.Empty;
			}
		}
	}
	public enum eLanguageDataFlags
	{
		DISABLED = 1,
		KEEP_LOADED = 2,
		NOT_LOADED = 4
	}
	[Serializable]
	public class LanguageData
	{
		public string Name;

		public string Code;

		public byte Flags;

		[NonSerialized]
		public bool Compressed;

		public bool IsEnabled()
		{
			return (Flags & 1) == 0;
		}

		public void SetEnabled(bool bEnabled)
		{
			if (bEnabled)
			{
				Flags = (byte)(Flags & 0xFFFFFFFEu);
			}
			else
			{
				Flags |= 1;
			}
		}

		public bool IsLoaded()
		{
			return (Flags & 4) == 0;
		}

		public bool CanBeUnloaded()
		{
			return (Flags & 2) == 0;
		}

		public void SetLoaded(bool loaded)
		{
			if (loaded)
			{
				Flags = (byte)(Flags & 0xFFFFFFFBu);
			}
			else
			{
				Flags |= 4;
			}
		}

		public void SetCanBeUnLoaded(bool allowUnloading)
		{
			if (allowUnloading)
			{
				Flags = (byte)(Flags & 0xFFFFFFFDu);
			}
			else
			{
				Flags |= 2;
			}
		}
	}
	[AddComponentMenu("I2/Localization/Source")]
	[ExecuteInEditMode]
	public class LanguageSource : MonoBehaviour, ISerializationCallbackReceiver, ILanguageSource
	{
		public delegate void fnOnSourceUpdated(LanguageSourceData source, bool ReceivedNewData, string errorMsg);

		public LanguageSourceData mSource = new LanguageSourceData();

		public int version;

		public bool NeverDestroy;

		public bool UserAgreesToHaveItOnTheScene;

		public bool UserAgreesToHaveItInsideThePluginsFolder;

		public bool GoogleLiveSyncIsUptoDate = true;

		public List<UnityEngine.Object> Assets = new List<UnityEngine.Object>();

		public string Google_WebServiceURL;

		public string Google_SpreadsheetKey;

		public string Google_SpreadsheetName;

		public string Google_LastUpdatedVersion;

		public LanguageSourceData.eGoogleUpdateFrequency GoogleUpdateFrequency = LanguageSourceData.eGoogleUpdateFrequency.Weekly;

		public float GoogleUpdateDelay = 5f;

		public List<LanguageData> mLanguages = new List<LanguageData>();

		public bool IgnoreDeviceLanguage;

		public LanguageSourceData.eAllowUnloadLanguages _AllowUnloadingLanguages;

		public List<TermData> mTerms = new List<TermData>();

		public bool CaseInsensitiveTerms;

		public LanguageSourceData.MissingTranslationAction OnMissingTranslation = LanguageSourceData.MissingTranslationAction.Fallback;

		public string mTerm_AppName;

		public LanguageSourceData SourceData
		{
			get
			{
				return mSource;
			}
			set
			{
				mSource = value;
			}
		}

		public event fnOnSourceUpdated Event_OnSourceUpdateFromGoogle;

		private void Awake()
		{
			mSource.owner = this;
			mSource.Awake();
		}

		private void OnDestroy()
		{
			NeverDestroy = false;
			if (!NeverDestroy)
			{
				mSource.OnDestroy();
			}
		}

		public string GetSourceName()
		{
			string text = base.gameObject.name;
			Transform parent = base.transform.parent;
			while ((bool)parent)
			{
				text = parent.name + "_" + text;
				parent = parent.parent;
			}
			return text;
		}

		public void OnBeforeSerialize()
		{
			version = 1;
		}

		public void OnAfterDeserialize()
		{
			if (version != 0 && mSource != null)
			{
				return;
			}
			mSource = new LanguageSourceData();
			mSource.owner = this;
			mSource.UserAgreesToHaveItOnTheScene = UserAgreesToHaveItOnTheScene;
			mSource.UserAgreesToHaveItInsideThePluginsFolder = UserAgreesToHaveItInsideThePluginsFolder;
			mSource.IgnoreDeviceLanguage = IgnoreDeviceLanguage;
			mSource._AllowUnloadingLanguages = _AllowUnloadingLanguages;
			mSource.CaseInsensitiveTerms = CaseInsensitiveTerms;
			mSource.OnMissingTranslation = OnMissingTranslation;
			mSource.mTerm_AppName = mTerm_AppName;
			mSource.GoogleLiveSyncIsUptoDate = GoogleLiveSyncIsUptoDate;
			mSource.Google_WebServiceURL = Google_WebServiceURL;
			mSource.Google_SpreadsheetKey = Google_SpreadsheetKey;
			mSource.Google_SpreadsheetName = Google_SpreadsheetName;
			mSource.Google_LastUpdatedVersion = Google_LastUpdatedVersion;
			mSource.GoogleUpdateFrequency = GoogleUpdateFrequency;
			mSource.GoogleUpdateDelay = GoogleUpdateDelay;
			mSource.Event_OnSourceUpdateFromGoogle += this.Event_OnSourceUpdateFromGoogle;
			if (mLanguages != null && mLanguages.Count > 0)
			{
				mSource.mLanguages.Clear();
				mSource.mLanguages.AddRange(mLanguages);
				mLanguages.Clear();
			}
			if (Assets != null && Assets.Count > 0)
			{
				mSource.Assets.Clear();
				mSource.Assets.AddRange(Assets);
				Assets.Clear();
			}
			if (mTerms != null && mTerms.Count > 0)
			{
				mSource.mTerms.Clear();
				for (int i = 0; i < mTerms.Count; i++)
				{
					mSource.mTerms.Add(mTerms[i]);
				}
				mTerms.Clear();
			}
			version = 1;
			this.Event_OnSourceUpdateFromGoogle = null;
		}
	}
	[CreateAssetMenu(fileName = "I2Languages", menuName = "I2 Localization/LanguageSource", order = 1)]
	public class LanguageSourceAsset : ScriptableObject, ILanguageSource
	{
		public LanguageSourceData mSource = new LanguageSourceData();

		public LanguageSourceData SourceData
		{
			get
			{
				return mSource;
			}
			set
			{
				mSource = value;
			}
		}
	}
	public interface ILanguageSource
	{
		LanguageSourceData SourceData { get; set; }
	}
	[Serializable]
	[ExecuteInEditMode]
	public class LanguageSourceData
	{
		public enum MissingTranslationAction
		{
			Empty,
			Fallback,
			ShowWarning,
			ShowTerm
		}

		public enum eAllowUnloadLanguages
		{
			Never,
			OnlyInDevice,
			EditorAndDevice
		}

		public enum eGoogleUpdateFrequency
		{
			Always,
			Never,
			Daily,
			Weekly,
			Monthly,
			OnlyOnce,
			EveryOtherDay
		}

		public enum eGoogleUpdateSynchronization
		{
			Manual,
			OnSceneLoaded,
			AsSoonAsDownloaded
		}

		[NonSerialized]
		public ILanguageSource owner;

		public bool UserAgreesToHaveItOnTheScene;

		public bool UserAgreesToHaveItInsideThePluginsFolder;

		public bool GoogleLiveSyncIsUptoDate = true;

		[NonSerialized]
		public bool mIsGlobalSource;

		public List<TermData> mTerms = new List<TermData>();

		public bool CaseInsensitiveTerms;

		[NonSerialized]
		public Dictionary<string, TermData> mDictionary = new Dictionary<string, TermData>(StringComparer.Ordinal);

		public MissingTranslationAction OnMissingTranslation = MissingTranslationAction.Fallback;

		public string mTerm_AppName;

		public List<LanguageData> mLanguages = new List<LanguageData>();

		public bool IgnoreDeviceLanguage;

		public eAllowUnloadLanguages _AllowUnloadingLanguages;

		public string Google_WebServiceURL;

		public string Google_SpreadsheetKey;

		public string Google_SpreadsheetName;

		public string Google_LastUpdatedVersion;

		public eGoogleUpdateFrequency GoogleUpdateFrequency = eGoogleUpdateFrequency.Weekly;

		public eGoogleUpdateFrequency GoogleInEditorCheckFrequency = eGoogleUpdateFrequency.Daily;

		public eGoogleUpdateSynchronization GoogleUpdateSynchronization = eGoogleUpdateSynchronization.OnSceneLoaded;

		public float GoogleUpdateDelay;

		public List<UnityEngine.Object> Assets = new List<UnityEngine.Object>();

		[NonSerialized]
		public Dictionary<string, UnityEngine.Object> mAssetDictionary = new Dictionary<string, UnityEngine.Object>(StringComparer.Ordinal);

		private string mDelayedGoogleData;

		public static string EmptyCategory = "Default";

		public static char[] CategorySeparators = "/\\".ToCharArray();

		public UnityEngine.Object ownerObject => owner as UnityEngine.Object;

		public event LanguageSource.fnOnSourceUpdated Event_OnSourceUpdateFromGoogle;

		public void Awake()
		{
			LocalizationManager.AddSource(this);
			UpdateDictionary();
			UpdateAssetDictionary();
			LocalizationManager.LocalizeAll(Force: true);
		}

		public void OnDestroy()
		{
			LocalizationManager.RemoveSource(this);
		}

		public bool IsEqualTo(LanguageSourceData Source)
		{
			if (Source.mLanguages.Count != mLanguages.Count)
			{
				return false;
			}
			int i = 0;
			for (int count = mLanguages.Count; i < count; i++)
			{
				if (Source.GetLanguageIndex(mLanguages[i].Name) < 0)
				{
					return false;
				}
			}
			if (Source.mTerms.Count != mTerms.Count)
			{
				return false;
			}
			for (int j = 0; j < mTerms.Count; j++)
			{
				if (Source.GetTermData(mTerms[j].Term) == null)
				{
					return false;
				}
			}
			return true;
		}

		internal bool ManagerHasASimilarSource()
		{
			int i = 0;
			for (int count = LocalizationManager.Sources.Count; i < count; i++)
			{
				LanguageSourceData languageSourceData = LocalizationManager.Sources[i];
				if (languageSourceData != null && languageSourceData.IsEqualTo(this) && languageSourceData != this)
				{
					return true;
				}
			}
			return false;
		}

		public void ClearAllData()
		{
			mTerms.Clear();
			mLanguages.Clear();
			mDictionary.Clear();
			mAssetDictionary.Clear();
		}

		public bool IsGlobalSource()
		{
			return mIsGlobalSource;
		}

		public void Editor_SetDirty()
		{
		}

		public void UpdateAssetDictionary()
		{
			Assets.RemoveAll((UnityEngine.Object x) => x == null);
			mAssetDictionary = (from o in Assets.Distinct()
				group o by o.name).ToDictionary((IGrouping<string, UnityEngine.Object> g) => g.Key, (IGrouping<string, UnityEngine.Object> g) => g.First());
		}

		public UnityEngine.Object FindAsset(string Name)
		{
			if (Assets != null)
			{
				if (mAssetDictionary == null || mAssetDictionary.Count != Assets.Count)
				{
					UpdateAssetDictionary();
				}
				if (mAssetDictionary.TryGetValue(Name, out var value))
				{
					return value;
				}
			}
			return null;
		}

		public bool HasAsset(UnityEngine.Object Obj)
		{
			return Assets.Contains(Obj);
		}

		public void AddAsset(UnityEngine.Object Obj)
		{
			if (!Assets.Contains(Obj))
			{
				Assets.Add(Obj);
				UpdateAssetDictionary();
			}
		}

		public string Export_I2CSV(string Category, char Separator = ',', bool specializationsAsRows = true)
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append("Key[*]Type[*]Desc");
			foreach (LanguageData mLanguage in mLanguages)
			{
				stringBuilder.Append("[*]");
				if (!mLanguage.IsEnabled())
				{
					stringBuilder.Append('$');
				}
				stringBuilder.Append(GoogleLanguages.GetCodedLanguage(mLanguage.Name, mLanguage.Code));
			}
			stringBuilder.Append("[ln]");
			mTerms.Sort((TermData a, TermData b) => string.CompareOrdinal(a.Term, b.Term));
			int count = mLanguages.Count;
			bool flag = true;
			foreach (TermData mTerm in mTerms)
			{
				string term;
				if (string.IsNullOrEmpty(Category) || (Category == EmptyCategory && mTerm.Term.IndexOfAny(CategorySeparators) < 0))
				{
					term = mTerm.Term;
				}
				else
				{
					if (!mTerm.Term.StartsWith(Category + "/") || !(Category != mTerm.Term))
					{
						continue;
					}
					term = mTerm.Term.Substring(Category.Length + 1);
				}
				if (!flag)
				{
					stringBuilder.Append("[ln]");
				}
				flag = false;
				if (!specializationsAsRows)
				{
					AppendI2Term(stringBuilder, count, term, mTerm, Separator, null);
					continue;
				}
				List<string> allSpecializations = mTerm.GetAllSpecializations();
				for (int i = 0; i < allSpecializations.Count; i++)
				{
					if (i != 0)
					{
						stringBuilder.Append("[ln]");
					}
					string forceSpecialization = allSpecializations[i];
					AppendI2Term(stringBuilder, count, term, mTerm, Separator, forceSpecialization);
				}
			}
			return stringBuilder.ToString();
		}

		private static void AppendI2Term(StringBuilder Builder, int nLanguages, string Term, TermData termData, char Separator, string forceSpecialization)
		{
			AppendI2Text(Builder, Term);
			if (!string.IsNullOrEmpty(forceSpecialization) && forceSpecialization != "Any")
			{
				Builder.Append("[");
				Builder.Append(forceSpecialization);
				Builder.Append("]");
			}
			Builder.Append("[*]");
			Builder.Append(termData.TermType.ToString());
			Builder.Append("[*]");
			Builder.Append(termData.Description);
			for (int i = 0; i < Mathf.Min(nLanguages, termData.Languages.Length); i++)
			{
				Builder.Append("[*]");
				string text = termData.Languages[i];
				if (!string.IsNullOrEmpty(forceSpecialization))
				{
					text = termData.GetTranslation(i, forceSpecialization);
				}
				AppendI2Text(Builder, text);
			}
		}

		private static void AppendI2Text(StringBuilder Builder, string text)
		{
			if (!string.IsNullOrEmpty(text))
			{
				if (text.StartsWith("'") || text.StartsWith("="))
				{
					Builder.Append('\'');
				}
				Builder.Append(text);
			}
		}

		private string Export_Language_to_Cache(int langIndex, bool fillTermWithFallback)
		{
			if (!mLanguages[langIndex].IsLoaded())
			{
				return null;
			}
			StringBuilder stringBuilder = new StringBuilder();
			for (int i = 0; i < mTerms.Count; i++)
			{
				if (i > 0)
				{
					stringBuilder.Append("[i2t]");
				}
				TermData termData = mTerms[i];
				stringBuilder.Append(termData.Term);
				stringBuilder.Append("=");
				string Translation = termData.Languages[langIndex];
				if (OnMissingTranslation == MissingTranslationAction.Fallback && string.IsNullOrEmpty(Translation) && TryGetFallbackTranslation(termData, out Translation, langIndex, null, skipDisabled: true))
				{
					stringBuilder.Append("[i2fb]");
					if (fillTermWithFallback)
					{
						termData.Languages[langIndex] = Translation;
					}
				}
				if (!string.IsNullOrEmpty(Translation))
				{
					stringBuilder.Append(Translation);
				}
			}
			return stringBuilder.ToString();
		}

		public string Export_CSV(string Category, char Separator = ',', bool specializationsAsRows = true)
		{
			StringBuilder stringBuilder = new StringBuilder();
			int count = mLanguages.Count;
			stringBuilder.AppendFormat("Key{0}Type{0}Desc", Separator);
			foreach (LanguageData mLanguage in mLanguages)
			{
				stringBuilder.Append(Separator);
				if (!mLanguage.IsEnabled())
				{
					stringBuilder.Append('$');
				}
				AppendString(stringBuilder, GoogleLanguages.GetCodedLanguage(mLanguage.Name, mLanguage.Code), Separator);
			}
			stringBuilder.Append("\n");
			mTerms.Sort((TermData a, TermData b) => string.CompareOrdinal(a.Term, b.Term));
			foreach (TermData mTerm in mTerms)
			{
				string term;
				if (string.IsNullOrEmpty(Category) || (Category == EmptyCategory && mTerm.Term.IndexOfAny(CategorySeparators) < 0))
				{
					term = mTerm.Term;
				}
				else
				{
					if (!mTerm.Term.StartsWith(Category + "/") || !(Category != mTerm.Term))
					{
						continue;
					}
					term = mTerm.Term.Substring(Category.Length + 1);
				}
				if (specializationsAsRows)
				{
					foreach (string allSpecialization in mTerm.GetAllSpecializations())
					{
						AppendTerm(stringBuilder, count, term, mTerm, allSpecialization, Separator);
					}
				}
				else
				{
					AppendTerm(stringBuilder, count, term, mTerm, null, Separator);
				}
			}
			return stringBuilder.ToString();
		}

		private static void AppendTerm(StringBuilder Builder, int nLanguages, string Term, TermData termData, string specialization, char Separator)
		{
			AppendString(Builder, Term, Separator);
			if (!string.IsNullOrEmpty(specialization) && specialization != "Any")
			{
				Builder.AppendFormat("[{0}]", specialization);
			}
			Builder.Append(Separator);
			Builder.Append(termData.TermType.ToString());
			Builder.Append(Separator);
			AppendString(Builder, termData.Description, Separator);
			for (int i = 0; i < Mathf.Min(nLanguages, termData.Languages.Length); i++)
			{
				Builder.Append(Separator);
				string text = termData.Languages[i];
				if (!string.IsNullOrEmpty(specialization))
				{
					text = termData.GetTranslation(i, specialization);
				}
				AppendTranslation(Builder, text, Separator, null);
			}
			Builder.Append("\n");
		}

		private static void AppendString(StringBuilder Builder, string Text, char Separator)
		{
			if (!string.IsNullOrEmpty(Text))
			{
				Text = Text.Replace("\\n", "\n");
				if (Text.IndexOfAny((Separator + "\n\"").ToCharArray()) >= 0)
				{
					Text = Text.Replace("\"", "\"\"");
					Builder.AppendFormat("\"{0}\"", Text);
				}
				else
				{
					Builder.Append(Text);
				}
			}
		}

		private static void AppendTranslation(StringBuilder Builder, string Text, char Separator, string tags)
		{
			if (!string.IsNullOrEmpty(Text))
			{
				Text = Text.Replace("\\n", "\n");
				if (Text.IndexOfAny((Separator + "\n\"").ToCharArray()) >= 0)
				{
					Text = Text.Replace("\"", "\"\"");
					Builder.AppendFormat("\"{0}{1}\"", tags, Text);
				}
				else
				{
					Builder.Append(tags);
					Builder.Append(Text);
				}
			}
		}

		public UnityWebRequest Export_Google_CreateWWWcall(eSpreadsheetUpdateMode UpdateMode = eSpreadsheetUpdateMode.Replace)
		{
			string value = Export_Google_CreateData();
			WWWForm wWWForm = new WWWForm();
			wWWForm.AddField("key", Google_SpreadsheetKey);
			wWWForm.AddField("action", "SetLanguageSource");
			wWWForm.AddField("data", value);
			wWWForm.AddField("updateMode", UpdateMode.ToString());
			UnityWebRequest unityWebRequest = UnityWebRequest.Post(LocalizationManager.GetWebServiceURL(this), wWWForm);
			I2Utils.SendWebRequest(unityWebRequest);
			return unityWebRequest;
		}

		private string Export_Google_CreateData()
		{
			List<string> categories = GetCategories(OnlyMainCategory: true);
			StringBuilder stringBuilder = new StringBuilder();
			bool flag = true;
			foreach (string item in categories)
			{
				if (flag)
				{
					flag = false;
				}
				else
				{
					stringBuilder.Append("<I2Loc>");
				}
				bool specializationsAsRows = true;
				string value = Export_I2CSV(item, ',', specializationsAsRows);
				stringBuilder.Append(item);
				stringBuilder.Append("<I2Loc>");
				stringBuilder.Append(value);
			}
			return stringBuilder.ToString();
		}

		public string Import_CSV(string Category, string CSVstring, eSpreadsheetUpdateMode UpdateMode = eSpreadsheetUpdateMode.Replace, char Separator = ',')
		{
			List<string[]> cSV = LocalizationReader.ReadCSV(CSVstring, Separator);
			return Import_CSV(Category, cSV, UpdateMode);
		}

		public string Import_I2CSV(string Category, string I2CSVstring, eSpreadsheetUpdateMode UpdateMode = eSpreadsheetUpdateMode.Replace)
		{
			List<string[]> cSV = LocalizationReader.ReadI2CSV(I2CSVstring);
			return Import_CSV(Category, cSV, UpdateMode);
		}

		public string Import_CSV(string Category, List<string[]> CSV, eSpreadsheetUpdateMode UpdateMode = eSpreadsheetUpdateMode.Replace)
		{
			string[] array = CSV[0];
			int num = 1;
			int num2 = -1;
			int num3 = -1;
			string[] texts = new string[1] { "Key" };
			string[] texts2 = new string[1] { "Type" };
			string[] texts3 = new string[2] { "Desc", "Description" };
			if (array.Length > 1 && ArrayContains(array[0], texts))
			{
				if (UpdateMode == eSpreadsheetUpdateMode.Replace)
				{
					ClearAllData();
				}
				if (array.Length > 2)
				{
					if (ArrayContains(array[1], texts2))
					{
						num2 = 1;
						num = 2;
					}
					if (ArrayContains(array[1], texts3))
					{
						num3 = 1;
						num = 2;
					}
				}
				if (array.Length > 3)
				{
					if (ArrayContains(array[2], texts2))
					{
						num2 = 2;
						num = 3;
					}
					if (ArrayContains(array[2], texts3))
					{
						num3 = 2;
						num = 3;
					}
				}
				int num4 = Mathf.Max(array.Length - num, 0);
				int[] array2 = new int[num4];
				for (int i = 0; i < num4; i++)
				{
					if (string.IsNullOrEmpty(array[i + num]))
					{
						array2[i] = -1;
						continue;
					}
					string text = array[i + num];
					bool flag = true;
					if (text.StartsWith("$"))
					{
						flag = false;
						text = text.Substring(1);
					}
					GoogleLanguages.UnPackCodeFromLanguageName(text, out var Language, out var code);
					int num5 = -1;
					num5 = (string.IsNullOrEmpty(code) ? GetLanguageIndex(Language, AllowDiscartingRegion: true, SkipDisabled: false) : GetLanguageIndexFromCode(code));
					if (num5 < 0)
					{
						LanguageData languageData = new LanguageData();
						languageData.Name = Language;
						languageData.Code = code;
						languageData.Flags = (byte)(0u | ((!flag) ? 1u : 0u));
						mLanguages.Add(languageData);
						num5 = mLanguages.Count - 1;
					}
					array2[i] = num5;
				}
				num4 = mLanguages.Count;
				int j = 0;
				for (int count = mTerms.Count; j < count; j++)
				{
					TermData termData = mTerms[j];
					if (termData.Languages.Length < num4)
					{
						Array.Resize(ref termData.Languages, num4);
						Array.Resize(ref termData.Flags, num4);
					}
				}
				int k = 1;
				for (int count2 = CSV.Count; k < count2; k++)
				{
					array = CSV[k];
					string Term = (string.IsNullOrEmpty(Category) ? array[0] : (Category + "/" + array[0]));
					string text2 = null;
					if (Term.EndsWith("]"))
					{
						int num6 = Term.LastIndexOf('[');
						if (num6 > 0)
						{
							text2 = Term.Substring(num6 + 1, Term.Length - num6 - 2);
							if (text2 == "touch")
							{
								text2 = "Touch";
							}
							Term = Term.Remove(num6);
						}
					}
					ValidateFullTerm(ref Term);
					if (string.IsNullOrEmpty(Term))
					{
						continue;
					}
					TermData termData2 = GetTermData(Term);
					if (termData2 == null)
					{
						termData2 = new TermData();
						termData2.Term = Term;
						termData2.Languages = new string[mLanguages.Count];
						termData2.Flags = new byte[mLanguages.Count];
						for (int l = 0; l < mLanguages.Count; l++)
						{
							termData2.Languages[l] = string.Empty;
						}
						mTerms.Add(termData2);
						mDictionary.Add(Term, termData2);
					}
					else if (UpdateMode == eSpreadsheetUpdateMode.AddNewTerms)
					{
						continue;
					}
					if (num2 > 0)
					{
						termData2.TermType = GetTermType(array[num2]);
					}
					if (num3 > 0)
					{
						termData2.Description = array[num3];
					}
					for (int m = 0; m < array2.Length && m < array.Length - num; m++)
					{
						if (string.IsNullOrEmpty(array[m + num]))
						{
							continue;
						}
						int num7 = array2[m];
						if (num7 >= 0)
						{
							string text3 = array[m + num];
							if (text3 == "-")
							{
								text3 = string.Empty;
							}
							else if (text3 == "")
							{
								text3 = null;
							}
							termData2.SetTranslation(num7, text3, text2);
						}
					}
				}
				if (UnityEngine.Application.isPlaying)
				{
					SaveLanguages(HasUnloadedLanguages());
				}
				return string.Empty;
			}
			return "Bad Spreadsheet Format.\nFirst columns should be 'Key', 'Type' and 'Desc'";
		}

		private bool ArrayContains(string MainText, params string[] texts)
		{
			int i = 0;
			for (int num = texts.Length; i < num; i++)
			{
				if (MainText.IndexOf(texts[i], StringComparison.OrdinalIgnoreCase) >= 0)
				{
					return true;
				}
			}
			return false;
		}

		public static eTermType GetTermType(string type)
		{
			int i = 0;
			for (int num = 10; i <= num; i++)
			{
				eTermType eTermType2 = (eTermType)i;
				if (string.Equals(eTermType2.ToString(), type, StringComparison.OrdinalIgnoreCase))
				{
					return (eTermType)i;
				}
			}
			return eTermType.Text;
		}

		private void Import_Language_from_Cache(int langIndex, string langData, bool useFallback, bool onlyCurrentSpecialization)
		{
			int num = 0;
			while (num < langData.Length)
			{
				int num2 = langData.IndexOf("[i2t]", num);
				if (num2 < 0)
				{
					num2 = langData.Length;
				}
				int num3 = langData.IndexOf("=", num);
				if (num3 >= num2)
				{
					break;
				}
				string term = langData.Substring(num, num3 - num);
				num = num3 + 1;
				TermData termData = GetTermData(term);
				if (termData != null)
				{
					string text = null;
					if (num != num2)
					{
						text = langData.Substring(num, num2 - num);
						if (text.StartsWith("[i2fb]"))
						{
							text = (useFallback ? text.Substring(6) : null);
						}
						if (onlyCurrentSpecialization && text != null)
						{
							text = SpecializationManager.GetSpecializedText(text);
						}
					}
					termData.Languages[langIndex] = text;
				}
				num = num2 + 5;
			}
		}

		public static void FreeUnusedLanguages()
		{
			LanguageSourceData languageSourceData = LocalizationManager.Sources[0];
			int languageIndex = languageSourceData.GetLanguageIndex(LocalizationManager.CurrentLanguage);
			for (int i = 0; i < languageSourceData.mTerms.Count; i++)
			{
				TermData termData = languageSourceData.mTerms[i];
				for (int j = 0; j < termData.Languages.Length; j++)
				{
					if (j != languageIndex)
					{
						termData.Languages[j] = null;
					}
				}
			}
		}

		public void Import_Google_FromCache()
		{
			if (GoogleUpdateFrequency == eGoogleUpdateFrequency.Never || !I2Utils.IsPlaying())
			{
				return;
			}
			string sourcePlayerPrefName = GetSourcePlayerPrefName();
			string text = PersistentStorage.LoadFile(PersistentStorage.eFileType.Persistent, "I2Source_" + sourcePlayerPrefName + ".loc", logExceptions: false);
			if (string.IsNullOrEmpty(text))
			{
				return;
			}
			if (text.StartsWith("[i2e]", StringComparison.Ordinal))
			{
				text = StringObfucator.Decode(text.Substring(5, text.Length - 5));
			}
			bool flag = false;
			string text2 = Google_LastUpdatedVersion;
			if (PersistentStorage.HasSetting("I2SourceVersion_" + sourcePlayerPrefName))
			{
				text2 = PersistentStorage.GetSetting_String("I2SourceVersion_" + sourcePlayerPrefName, Google_LastUpdatedVersion);
				flag = IsNewerVersion(Google_LastUpdatedVersion, text2);
			}
			if (!flag)
			{
				PersistentStorage.DeleteFile(PersistentStorage.eFileType.Persistent, "I2Source_" + sourcePlayerPrefName + ".loc", logExceptions: false);
				PersistentStorage.DeleteSetting("I2SourceVersion_" + sourcePlayerPrefName);
				return;
			}
			if (text2.Length > 19)
			{
				text2 = string.Empty;
			}
			Google_LastUpdatedVersion = text2;
			Import_Google_Result(text, eSpreadsheetUpdateMode.Replace);
		}

		private bool IsNewerVersion(string currentVersion, string newVersion)
		{
			if (string.IsNullOrEmpty(newVersion))
			{
				return false;
			}
			if (string.IsNullOrEmpty(currentVersion))
			{
				return true;
			}
			if (!long.TryParse(newVersion, out var result) || !long.TryParse(currentVersion, out var result2))
			{
				return true;
			}
			return result > result2;
		}

		public void Import_Google(bool ForceUpdate, bool justCheck)
		{
			if ((!ForceUpdate && GoogleUpdateFrequency == eGoogleUpdateFrequency.Never) || !I2Utils.IsPlaying())
			{
				return;
			}
			eGoogleUpdateFrequency googleUpdateFrequency = GoogleUpdateFrequency;
			string sourcePlayerPrefName = GetSourcePlayerPrefName();
			if (!ForceUpdate && googleUpdateFrequency != 0)
			{
				string setting_String = PersistentStorage.GetSetting_String("LastGoogleUpdate_" + sourcePlayerPrefName, "");
				try
				{
					if (DateTime.TryParse(setting_String, out var result))
					{
						double totalDays = (DateTime.Now - result).TotalDays;
						switch (googleUpdateFrequency)
						{
						case eGoogleUpdateFrequency.Daily:
							if (totalDays < 1.0)
							{
								return;
							}
							break;
						case eGoogleUpdateFrequency.Weekly:
							if (totalDays < 8.0)
							{
								return;
							}
							break;
						case eGoogleUpdateFrequency.Monthly:
							if (totalDays < 31.0)
							{
								return;
							}
							break;
						case eGoogleUpdateFrequency.OnlyOnce:
							return;
						case eGoogleUpdateFrequency.EveryOtherDay:
							if (totalDays < 2.0)
							{
								return;
							}
							break;
						}
					}
				}
				catch (Exception)
				{
				}
			}
			PersistentStorage.SetSetting_String("LastGoogleUpdate_" + sourcePlayerPrefName, DateTime.Now.ToString());
			CoroutineManager.Start(Import_Google_Coroutine(justCheck));
		}

		private string GetSourcePlayerPrefName()
		{
			if (owner == null)
			{
				return null;
			}
			string text = (owner as UnityEngine.Object).name;
			if (!string.IsNullOrEmpty(Google_SpreadsheetKey))
			{
				text += Google_SpreadsheetKey;
			}
			if (Array.IndexOf(LocalizationManager.GlobalSources, (owner as UnityEngine.Object).name) >= 0)
			{
				return text;
			}
			return SceneManager.GetActiveScene().name + "_" + text;
		}

		private IEnumerator Import_Google_Coroutine(bool JustCheck)
		{
			UnityWebRequest www = Import_Google_CreateWWWcall(ForceUpdate: false, JustCheck);
			if (www == null)
			{
				yield break;
			}
			while (!www.isDone)
			{
				yield return null;
			}
			if (string.IsNullOrEmpty(www.error))
			{
				byte[] data = www.downloadHandler.data;
				string @string = Encoding.UTF8.GetString(data, 0, data.Length);
				bool flag = string.IsNullOrEmpty(@string) || @string == "\"\"";
				if (JustCheck)
				{
					if (!flag)
					{
						UnityEngine.Debug.LogWarning("Spreadsheet is not up-to-date and Google Live Synchronization is enabled\nWhen playing in the device the Spreadsheet will be downloaded and translations may not behave as what you see in the editor.\nTo fix this, Import or Export replace to Google");
						GoogleLiveSyncIsUptoDate = false;
					}
					yield break;
				}
				if (!flag)
				{
					mDelayedGoogleData = @string;
					switch (GoogleUpdateSynchronization)
					{
					case eGoogleUpdateSynchronization.AsSoonAsDownloaded:
						ApplyDownloadedDataFromGoogle();
						break;
					case eGoogleUpdateSynchronization.OnSceneLoaded:
						SceneManager.sceneLoaded += ApplyDownloadedDataOnSceneLoaded;
						break;
					}
					yield break;
				}
			}
			if (this.Event_OnSourceUpdateFromGoogle != null)
			{
				this.Event_OnSourceUpdateFromGoogle(this, ReceivedNewData: false, www.error);
			}
			UnityEngine.Debug.Log("Language Source was up-to-date with Google Spreadsheet");
		}

		private void ApplyDownloadedDataOnSceneLoaded(Scene scene, LoadSceneMode mode)
		{
			SceneManager.sceneLoaded -= ApplyDownloadedDataOnSceneLoaded;
			ApplyDownloadedDataFromGoogle();
		}

		public void ApplyDownloadedDataFromGoogle()
		{
			if (string.IsNullOrEmpty(mDelayedGoogleData))
			{
				return;
			}
			if (string.IsNullOrEmpty(Import_Google_Result(mDelayedGoogleData, eSpreadsheetUpdateMode.Replace, saveInPlayerPrefs: true)))
			{
				if (this.Event_OnSourceUpdateFromGoogle != null)
				{
					this.Event_OnSourceUpdateFromGoogle(this, ReceivedNewData: true, "");
				}
				LocalizationManager.LocalizeAll(Force: true);
				UnityEngine.Debug.Log("Done Google Sync");
			}
			else
			{
				if (this.Event_OnSourceUpdateFromGoogle != null)
				{
					this.Event_OnSourceUpdateFromGoogle(this, ReceivedNewData: false, "");
				}
				UnityEngine.Debug.Log("Done Google Sync: source was up-to-date");
			}
		}

		public UnityWebRequest Import_Google_CreateWWWcall(bool ForceUpdate, bool justCheck)
		{
			if (!HasGoogleSpreadsheet())
			{
				return null;
			}
			string text = PersistentStorage.GetSetting_String("I2SourceVersion_" + GetSourcePlayerPrefName(), Google_LastUpdatedVersion);
			if (text.Length > 19)
			{
				text = string.Empty;
			}
			if (IsNewerVersion(text, Google_LastUpdatedVersion))
			{
				Google_LastUpdatedVersion = text;
			}
			UnityWebRequest unityWebRequest = UnityWebRequest.Get(string.Format("{0}?key={1}&action=GetLanguageSource&version={2}", LocalizationManager.GetWebServiceURL(this), Google_SpreadsheetKey, ForceUpdate ? "0" : Google_LastUpdatedVersion));
			I2Utils.SendWebRequest(unityWebRequest);
			return unityWebRequest;
		}

		public bool HasGoogleSpreadsheet()
		{
			if (!string.IsNullOrEmpty(Google_WebServiceURL) && !string.IsNullOrEmpty(Google_SpreadsheetKey))
			{
				return !string.IsNullOrEmpty(LocalizationManager.GetWebServiceURL(this));
			}
			return false;
		}

		public string Import_Google_Result(string JsonString, eSpreadsheetUpdateMode UpdateMode, bool saveInPlayerPrefs = false)
		{
			try
			{
				string empty = string.Empty;
				if (string.IsNullOrEmpty(JsonString) || JsonString == "\"\"")
				{
					return empty;
				}
				int num = JsonString.IndexOf("version=", StringComparison.Ordinal);
				int num2 = JsonString.IndexOf("script_version=", StringComparison.Ordinal);
				if (num < 0 || num2 < 0)
				{
					return "Invalid Response from Google, Most likely the WebService needs to be updated";
				}
				num += "version=".Length;
				num2 += "script_version=".Length;
				string text = JsonString.Substring(num, JsonString.IndexOf(",", num, StringComparison.Ordinal) - num);
				int num3 = int.Parse(JsonString.Substring(num2, JsonString.IndexOf(",", num2, StringComparison.Ordinal) - num2));
				if (text.Length > 19)
				{
					text = string.Empty;
				}
				if (num3 != LocalizationManager.GetRequiredWebServiceVersion())
				{
					return "The current Google WebService is not supported.\nPlease, delete the WebService from the Google Drive and Install the latest version.";
				}
				if (saveInPlayerPrefs && !IsNewerVersion(Google_LastUpdatedVersion, text))
				{
					return "LanguageSource is up-to-date";
				}
				if (saveInPlayerPrefs)
				{
					string sourcePlayerPrefName = GetSourcePlayerPrefName();
					PersistentStorage.SaveFile(PersistentStorage.eFileType.Persistent, "I2Source_" + sourcePlayerPrefName + ".loc", "[i2e]" + StringObfucator.Encode(JsonString));
					PersistentStorage.SetSetting_String("I2SourceVersion_" + sourcePlayerPrefName, text);
					PersistentStorage.ForceSaveSettings();
				}
				Google_LastUpdatedVersion = text;
				if (UpdateMode == eSpreadsheetUpdateMode.Replace)
				{
					ClearAllData();
				}
				int num4 = JsonString.IndexOf("[i2category]", StringComparison.Ordinal);
				while (num4 > 0)
				{
					num4 += "[i2category]".Length;
					int num5 = JsonString.IndexOf("[/i2category]", num4, StringComparison.Ordinal);
					string category = JsonString.Substring(num4, num5 - num4);
					num5 += "[/i2category]".Length;
					int num6 = JsonString.IndexOf("[/i2csv]", num5, StringComparison.Ordinal);
					string i2CSVstring = JsonString.Substring(num5, num6 - num5);
					num4 = JsonString.IndexOf("[i2category]", num6, StringComparison.Ordinal);
					Import_I2CSV(category, i2CSVstring, UpdateMode);
					if (UpdateMode == eSpreadsheetUpdateMode.Replace)
					{
						UpdateMode = eSpreadsheetUpdateMode.Merge;
					}
				}
				GoogleLiveSyncIsUptoDate = true;
				if (I2Utils.IsPlaying())
				{
					SaveLanguages(unloadAll: true);
				}
				if (!string.IsNullOrEmpty(empty))
				{
					Editor_SetDirty();
				}
				return empty;
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogWarning(ex);
				return ex.ToString();
			}
		}

		public int GetLanguageIndex(string language, bool AllowDiscartingRegion = true, bool SkipDisabled = true)
		{
			int i = 0;
			for (int count = mLanguages.Count; i < count; i++)
			{
				if ((!SkipDisabled || mLanguages[i].IsEnabled()) && string.Compare(mLanguages[i].Name, language, StringComparison.OrdinalIgnoreCase) == 0)
				{
					return i;
				}
			}
			if (AllowDiscartingRegion)
			{
				int num = -1;
				int num2 = 0;
				int j = 0;
				for (int count2 = mLanguages.Count; j < count2; j++)
				{
					if (!SkipDisabled || mLanguages[j].IsEnabled())
					{
						int commonWordInLanguageNames = GetCommonWordInLanguageNames(mLanguages[j].Name, language);
						if (commonWordInLanguageNames > num2)
						{
							num2 = commonWordInLanguageNames;
							num = j;
						}
					}
				}
				if (num >= 0)
				{
					return num;
				}
			}
			return -1;
		}

		public LanguageData GetLanguageData(string language, bool AllowDiscartingRegion = true)
		{
			int languageIndex = GetLanguageIndex(language, AllowDiscartingRegion, SkipDisabled: false);
			if (languageIndex >= 0)
			{
				return mLanguages[languageIndex];
			}
			return null;
		}

		public bool IsCurrentLanguage(int languageIndex)
		{
			return LocalizationManager.CurrentLanguage == mLanguages[languageIndex].Name;
		}

		public int GetLanguageIndexFromCode(string Code, bool exactMatch = true, bool ignoreDisabled = false)
		{
			int i = 0;
			for (int count = mLanguages.Count; i < count; i++)
			{
				if ((!ignoreDisabled || mLanguages[i].IsEnabled()) && string.Compare(mLanguages[i].Code, Code, StringComparison.OrdinalIgnoreCase) == 0)
				{
					return i;
				}
			}
			if (!exactMatch)
			{
				int j = 0;
				for (int count2 = mLanguages.Count; j < count2; j++)
				{
					if ((!ignoreDisabled || mLanguages[j].IsEnabled()) && string.Compare(mLanguages[j].Code, 0, Code, 0, 2, StringComparison.OrdinalIgnoreCase) == 0)
					{
						return j;
					}
				}
			}
			return -1;
		}

		public static int GetCommonWordInLanguageNames(string Language1, string Language2)
		{
			if (string.IsNullOrEmpty(Language1) || string.IsNullOrEmpty(Language2))
			{
				return 0;
			}
			char[] separator = "( )-/\\".ToCharArray();
			string[] array = Language1.ToLower().Split(separator);
			string[] array2 = Language2.ToLower().Split(separator);
			int num = 0;
			string[] array3 = array;
			foreach (string value in array3)
			{
				if (!string.IsNullOrEmpty(value) && array2.Contains(value))
				{
					num++;
				}
			}
			array3 = array2;
			foreach (string value2 in array3)
			{
				if (!string.IsNullOrEmpty(value2) && array.Contains(value2))
				{
					num++;
				}
			}
			return num;
		}

		public static bool AreTheSameLanguage(string Language1, string Language2)
		{
			Language1 = GetLanguageWithoutRegion(Language1);
			Language2 = GetLanguageWithoutRegion(Language2);
			return string.Compare(Language1, Language2, StringComparison.OrdinalIgnoreCase) == 0;
		}

		public static string GetLanguageWithoutRegion(string Language)
		{
			int num = Language.IndexOfAny("(/\\[,{".ToCharArray());
			if (num < 0)
			{
				return Language;
			}
			return Language.Substring(0, num).Trim();
		}

		public void AddLanguage(string LanguageName)
		{
			AddLanguage(LanguageName, GoogleLanguages.GetLanguageCode(LanguageName));
		}

		public void AddLanguage(string LanguageName, string LanguageCode)
		{
			if (GetLanguageIndex(LanguageName, AllowDiscartingRegion: false) < 0)
			{
				LanguageData languageData = new LanguageData();
				languageData.Name = LanguageName;
				languageData.Code = LanguageCode;
				mLanguages.Add(languageData);
				int count = mLanguages.Count;
				int i = 0;
				for (int count2 = mTerms.Count; i < count2; i++)
				{
					Array.Resize(ref mTerms[i].Languages, count);
					Array.Resize(ref mTerms[i].Flags, count);
				}
				Editor_SetDirty();
			}
		}

		public void RemoveLanguage(string LanguageName)
		{
			int languageIndex = GetLanguageIndex(LanguageName, AllowDiscartingRegion: false, SkipDisabled: false);
			if (languageIndex < 0)
			{
				return;
			}
			int count = mLanguages.Count;
			int i = 0;
			for (int count2 = mTerms.Count; i < count2; i++)
			{
				for (int j = languageIndex + 1; j < count; j++)
				{
					mTerms[i].Languages[j - 1] = mTerms[i].Languages[j];
					mTerms[i].Flags[j - 1] = mTerms[i].Flags[j];
				}
				Array.Resize(ref mTerms[i].Languages, count - 1);
				Array.Resize(ref mTerms[i].Flags, count - 1);
			}
			mLanguages.RemoveAt(languageIndex);
			Editor_SetDirty();
		}

		public List<string> GetLanguages(bool skipDisabled = true)
		{
			List<string> list = new List<string>();
			int i = 0;
			for (int count = mLanguages.Count; i < count; i++)
			{
				if (!skipDisabled || mLanguages[i].IsEnabled())
				{
					list.Add(mLanguages[i].Name);
				}
			}
			return list;
		}

		public List<string> GetLanguagesCode(bool allowRegions = true, bool skipDisabled = true)
		{
			List<string> list = new List<string>();
			int i = 0;
			for (int count = mLanguages.Count; i < count; i++)
			{
				if (!skipDisabled || mLanguages[i].IsEnabled())
				{
					string text = mLanguages[i].Code;
					if (!allowRegions && text != null && text.Length > 2)
					{
						text = text.Substring(0, 2);
					}
					if (!string.IsNullOrEmpty(text) && !list.Contains(text))
					{
						list.Add(text);
					}
				}
			}
			return list;
		}

		public bool IsLanguageEnabled(string Language)
		{
			int languageIndex = GetLanguageIndex(Language, AllowDiscartingRegion: false);
			if (languageIndex >= 0)
			{
				return mLanguages[languageIndex].IsEnabled();
			}
			return false;
		}

		public void EnableLanguage(string Language, bool bEnabled)
		{
			int languageIndex = GetLanguageIndex(Language, AllowDiscartingRegion: false, SkipDisabled: false);
			if (languageIndex >= 0)
			{
				mLanguages[languageIndex].SetEnabled(bEnabled);
			}
		}

		public bool AllowUnloadingLanguages()
		{
			return _AllowUnloadingLanguages != eAllowUnloadLanguages.Never;
		}

		private string GetSavedLanguageFileName(int languageIndex)
		{
			if (languageIndex < 0)
			{
				return null;
			}
			return "LangSource_" + GetSourcePlayerPrefName() + "_" + mLanguages[languageIndex].Name + ".loc";
		}

		public void LoadLanguage(int languageIndex, bool UnloadOtherLanguages, bool useFallback, bool onlyCurrentSpecialization, bool forceLoad)
		{
			if (!AllowUnloadingLanguages() || !PersistentStorage.CanAccessFiles())
			{
				return;
			}
			if (languageIndex >= 0 && (forceLoad || !mLanguages[languageIndex].IsLoaded()))
			{
				string savedLanguageFileName = GetSavedLanguageFileName(languageIndex);
				string text = PersistentStorage.LoadFile(PersistentStorage.eFileType.Temporal, savedLanguageFileName, logExceptions: false);
				if (!string.IsNullOrEmpty(text))
				{
					Import_Language_from_Cache(languageIndex, text, useFallback, onlyCurrentSpecialization);
					mLanguages[languageIndex].SetLoaded(loaded: true);
				}
			}
			if (!UnloadOtherLanguages || !I2Utils.IsPlaying())
			{
				return;
			}
			for (int i = 0; i < mLanguages.Count; i++)
			{
				if (i != languageIndex)
				{
					UnloadLanguage(i);
				}
			}
		}

		public void LoadAllLanguages(bool forceLoad = false)
		{
			for (int i = 0; i < mLanguages.Count; i++)
			{
				LoadLanguage(i, UnloadOtherLanguages: false, useFallback: false, onlyCurrentSpecialization: false, forceLoad);
			}
		}

		public void UnloadLanguage(int languageIndex)
		{
			if (!AllowUnloadingLanguages() || !PersistentStorage.CanAccessFiles() || !I2Utils.IsPlaying() || !mLanguages[languageIndex].IsLoaded() || !mLanguages[languageIndex].CanBeUnloaded() || IsCurrentLanguage(languageIndex) || !PersistentStorage.HasFile(PersistentStorage.eFileType.Temporal, GetSavedLanguageFileName(languageIndex)))
			{
				return;
			}
			foreach (TermData mTerm in mTerms)
			{
				mTerm.Languages[languageIndex] = null;
			}
			mLanguages[languageIndex].SetLoaded(loaded: false);
		}

		public void SaveLanguages(bool unloadAll, PersistentStorage.eFileType fileLocation = PersistentStorage.eFileType.Temporal)
		{
			if (!AllowUnloadingLanguages() || !PersistentStorage.CanAccessFiles())
			{
				return;
			}
			for (int i = 0; i < mLanguages.Count; i++)
			{
				string text = Export_Language_to_Cache(i, IsCurrentLanguage(i));
				if (!string.IsNullOrEmpty(text))
				{
					PersistentStorage.SaveFile(PersistentStorage.eFileType.Temporal, GetSavedLanguageFileName(i), text);
				}
			}
			if (!unloadAll)
			{
				return;
			}
			for (int j = 0; j < mLanguages.Count; j++)
			{
				if (unloadAll && !IsCurrentLanguage(j))
				{
					UnloadLanguage(j);
				}
			}
		}

		public bool HasUnloadedLanguages()
		{
			for (int i = 0; i < mLanguages.Count; i++)
			{
				if (!mLanguages[i].IsLoaded())
				{
					return true;
				}
			}
			return false;
		}

		public List<string> GetCategories(bool OnlyMainCategory = false, List<string> Categories = null)
		{
			if (Categories == null)
			{
				Categories = new List<string>();
			}
			foreach (TermData mTerm in mTerms)
			{
				string categoryFromFullTerm = GetCategoryFromFullTerm(mTerm.Term, OnlyMainCategory);
				if (!Categories.Contains(categoryFromFullTerm))
				{
					Categories.Add(categoryFromFullTerm);
				}
			}
			Categories.Sort();
			return Categories;
		}

		public static string GetKeyFromFullTerm(string FullTerm, bool OnlyMainCategory = false)
		{
			int num = (OnlyMainCategory ? FullTerm.IndexOfAny(CategorySeparators) : FullTerm.LastIndexOfAny(CategorySeparators));
			if (num >= 0)
			{
				return FullTerm.Substring(num + 1);
			}
			return FullTerm;
		}

		public static string GetCategoryFromFullTerm(string FullTerm, bool OnlyMainCategory = false)
		{
			int num = (OnlyMainCategory ? FullTerm.IndexOfAny(CategorySeparators) : FullTerm.LastIndexOfAny(CategorySeparators));
			if (num >= 0)
			{
				return FullTerm.Substring(0, num);
			}
			return EmptyCategory;
		}

		public static void DeserializeFullTerm(string FullTerm, out string Key, out string Category, bool OnlyMainCategory = false)
		{
			int num = (OnlyMainCategory ? FullTerm.IndexOfAny(CategorySeparators) : FullTerm.LastIndexOfAny(CategorySeparators));
			if (num < 0)
			{
				Category = EmptyCategory;
				Key = FullTerm;
			}
			else
			{
				Category = FullTerm.Substring(0, num);
				Key = FullTerm.Substring(num + 1);
			}
		}

		public void UpdateDictionary(bool force = false)
		{
			if (force || mDictionary == null || mDictionary.Count != mTerms.Count)
			{
				StringComparer stringComparer = (CaseInsensitiveTerms ? StringComparer.OrdinalIgnoreCase : StringComparer.Ordinal);
				if (mDictionary.Comparer != stringComparer)
				{
					mDictionary = new Dictionary<string, TermData>(stringComparer);
				}
				else
				{
					mDictionary.Clear();
				}
				int i = 0;
				for (int count = mTerms.Count; i < count; i++)
				{
					TermData termData = mTerms[i];
					ValidateFullTerm(ref termData.Term);
					mDictionary[termData.Term] = mTerms[i];
					mTerms[i].Validate();
				}
				if (I2Utils.IsPlaying())
				{
					SaveLanguages(unloadAll: true);
				}
			}
		}

		public string GetTranslation(string term, string overrideLanguage = null, string overrideSpecialization = null, bool skipDisabled = false, bool allowCategoryMistmatch = false)
		{
			if (TryGetTranslation(term, out var Translation, overrideLanguage, overrideSpecialization, skipDisabled, allowCategoryMistmatch))
			{
				return Translation;
			}
			return string.Empty;
		}

		public bool TryGetTranslation(string term, out string Translation, string overrideLanguage = null, string overrideSpecialization = null, bool skipDisabled = false, bool allowCategoryMistmatch = false)
		{
			int languageIndex = GetLanguageIndex((overrideLanguage == null) ? LocalizationManager.CurrentLanguage : overrideLanguage, AllowDiscartingRegion: true, SkipDisabled: false);
			if (languageIndex >= 0 && (!skipDisabled || mLanguages[languageIndex].IsEnabled()))
			{
				TermData termData = GetTermData(term, allowCategoryMistmatch);
				if (termData != null)
				{
					Translation = termData.GetTranslation(languageIndex, overrideSpecialization, editMode: true);
					if (Translation == "---")
					{
						Translation = string.Empty;
						return true;
					}
					if (!string.IsNullOrEmpty(Translation))
					{
						return true;
					}
					Translation = null;
				}
				if (OnMissingTranslation == MissingTranslationAction.ShowWarning)
				{
					Translation = $"<!-Missing Translation [{term}]-!>";
					return true;
				}
				if (OnMissingTranslation == MissingTranslationAction.Fallback && termData != null)
				{
					return TryGetFallbackTranslation(termData, out Translation, languageIndex, overrideSpecialization, skipDisabled);
				}
				if (OnMissingTranslation == MissingTranslationAction.Empty)
				{
					Translation = string.Empty;
					return true;
				}
				if (OnMissingTranslation == MissingTranslationAction.ShowTerm)
				{
					Translation = term;
					return true;
				}
			}
			Translation = null;
			return false;
		}

		private bool TryGetFallbackTranslation(TermData termData, out string Translation, int langIndex, string overrideSpecialization = null, bool skipDisabled = false)
		{
			string text = mLanguages[langIndex].Code;
			if (!string.IsNullOrEmpty(text))
			{
				if (text.Contains('-'))
				{
					text = text.Substring(0, text.IndexOf('-'));
				}
				for (int i = 0; i < mLanguages.Count; i++)
				{
					if (i != langIndex && mLanguages[i].Code.StartsWith(text) && (!skipDisabled || mLanguages[i].IsEnabled()))
					{
						Translation = termData.GetTranslation(i, overrideSpecialization, editMode: true);
						if (!string.IsNullOrEmpty(Translation))
						{
							return true;
						}
					}
				}
			}
			for (int j = 0; j < mLanguages.Count; j++)
			{
				if (j != langIndex && (!skipDisabled || mLanguages[j].IsEnabled()) && (text == null || !mLanguages[j].Code.StartsWith(text)))
				{
					Translation = termData.GetTranslation(j, overrideSpecialization, editMode: true);
					if (!string.IsNullOrEmpty(Translation))
					{
						return true;
					}
				}
			}
			Translation = null;
			return false;
		}

		public TermData AddTerm(string term)
		{
			return AddTerm(term, eTermType.Text);
		}

		public TermData GetTermData(string term, bool allowCategoryMistmatch = false)
		{
			if (string.IsNullOrEmpty(term))
			{
				return null;
			}
			if (mDictionary.Count == 0)
			{
				UpdateDictionary();
			}
			if (mDictionary.TryGetValue(term, out var value))
			{
				return value;
			}
			TermData termData = null;
			if (allowCategoryMistmatch)
			{
				string keyFromFullTerm = GetKeyFromFullTerm(term);
				foreach (KeyValuePair<string, TermData> item in mDictionary)
				{
					if (item.Value.IsTerm(keyFromFullTerm, allowCategoryMistmatch: true))
					{
						if (termData != null)
						{
							return null;
						}
						termData = item.Value;
					}
				}
			}
			return termData;
		}

		public bool ContainsTerm(string term)
		{
			return GetTermData(term) != null;
		}

		public List<string> GetTermsList(string Category = null)
		{
			if (mDictionary.Count != mTerms.Count)
			{
				UpdateDictionary();
			}
			if (string.IsNullOrEmpty(Category))
			{
				return new List<string>(mDictionary.Keys);
			}
			List<string> list = new List<string>();
			for (int i = 0; i < mTerms.Count; i++)
			{
				TermData termData = mTerms[i];
				if (GetCategoryFromFullTerm(termData.Term) == Category)
				{
					list.Add(termData.Term);
				}
			}
			return list;
		}

		public TermData AddTerm(string NewTerm, eTermType termType, bool SaveSource = true)
		{
			ValidateFullTerm(ref NewTerm);
			NewTerm = NewTerm.Trim();
			if (mLanguages.Count == 0)
			{
				AddLanguage("English", "en");
			}
			TermData termData = GetTermData(NewTerm);
			if (termData == null)
			{
				termData = new TermData();
				termData.Term = NewTerm;
				termData.TermType = termType;
				termData.Languages = new string[mLanguages.Count];
				termData.Flags = new byte[mLanguages.Count];
				mTerms.Add(termData);
				mDictionary.Add(NewTerm, termData);
			}
			return termData;
		}

		public void RemoveTerm(string term)
		{
			int i = 0;
			for (int count = mTerms.Count; i < count; i++)
			{
				if (mTerms[i].Term == term)
				{
					mTerms.RemoveAt(i);
					mDictionary.Remove(term);
					break;
				}
			}
		}

		public static void ValidateFullTerm(ref string Term)
		{
			Term = Term.Replace('\\', '/');
			Term = Term.Trim();
			if (Term.StartsWith(EmptyCategory, StringComparison.Ordinal) && Term.Length > EmptyCategory.Length && Term[EmptyCategory.Length] == '/')
			{
				Term = Term.Substring(EmptyCategory.Length + 1);
			}
			Term = I2Utils.GetValidTermName(Term, allowCategory: true);
		}
	}
	public enum eSpreadsheetUpdateMode
	{
		None,
		Replace,
		Merge,
		AddNewTerms
	}
	public class LocalizationReader
	{
		public static Dictionary<string, string> ReadTextAsset(TextAsset asset)
		{
			StringReader stringReader = new StringReader(Encoding.UTF8.GetString(asset.bytes, 0, asset.bytes.Length).Replace("\r\n", "\n").Replace("\r", "\n"));
			Dictionary<string, string> dictionary = new Dictionary<string, string>(StringComparer.Ordinal);
			string line;
			while ((line = stringReader.ReadLine()) != null)
			{
				if (TextAsset_ReadLine(line, out var key, out var value, out var _, out var _, out var _) && !string.IsNullOrEmpty(key) && !string.IsNullOrEmpty(value))
				{
					dictionary[key] = value;
				}
			}
			return dictionary;
		}

		public static bool TextAsset_ReadLine(string line, out string key, out string value, out string category, out string comment, out string termType)
		{
			key = string.Empty;
			category = string.Empty;
			comment = string.Empty;
			termType = string.Empty;
			value = string.Empty;
			int num = line.LastIndexOf("//");
			if (num >= 0)
			{
				comment = line.Substring(num + 2).Trim();
				comment = DecodeString(comment);
				line = line.Substring(0, num);
			}
			int num2 = line.IndexOf("=");
			if (num2 < 0)
			{
				return false;
			}
			key = line.Substring(0, num2).Trim();
			value = line.Substring(num2 + 1).Trim();
			value = value.Replace("\r\n", "\n").Replace("\n", "\\n");
			value = DecodeString(value);
			if (key.Length > 2 && key[0] == '[')
			{
				int num3 = key.IndexOf(']');
				if (num3 >= 0)
				{
					termType = key.Substring(1, num3 - 1);
					key = key.Substring(num3 + 1);
				}
			}
			ValidateFullTerm(ref key);
			return true;
		}

		public static string ReadCSVfile(string Path, Encoding encoding)
		{
			string text = string.Empty;
			using (StreamReader streamReader = new StreamReader(Path, encoding))
			{
				text = streamReader.ReadToEnd();
			}
			text = text.Replace("\r\n", "\n");
			return text.Replace("\r", "\n");
		}

		public static List<string[]> ReadCSV(string Text, char Separator = ',')
		{
			int iStart = 0;
			List<string[]> list = new List<string[]>();
			while (iStart < Text.Length)
			{
				string[] array = ParseCSVline(Text, ref iStart, Separator);
				if (array == null)
				{
					break;
				}
				list.Add(array);
			}
			return list;
		}

		private static string[] ParseCSVline(string Line, ref int iStart, char Separator)
		{
			List<string> list = new List<string>();
			int length = Line.Length;
			int iWordStart = iStart;
			bool flag = false;
			while (iStart < length)
			{
				char c = Line[iStart];
				if (flag)
				{
					if (c == '"')
					{
						if (iStart + 1 >= length || Line[iStart + 1] != '"')
						{
							flag = false;
						}
						else if (iStart + 2 < length && Line[iStart + 2] == '"')
						{
							flag = false;
							iStart += 2;
						}
						else
						{
							iStart++;
						}
					}
				}
				else if (c == '\n' || c == Separator)
				{
					AddCSVtoken(ref list, ref Line, iStart, ref iWordStart);
					if (c == '\n')
					{
						iStart++;
						break;
					}
				}
				else if (c == '"')
				{
					flag = true;
				}
				iStart++;
			}
			if (iStart > iWordStart)
			{
				AddCSVtoken(ref list, ref Line, iStart, ref iWordStart);
			}
			return list.ToArray();
		}

		private static void AddCSVtoken(ref List<string> list, ref string Line, int iEnd, ref int iWordStart)
		{
			string text = Line.Substring(iWordStart, iEnd - iWordStart);
			iWordStart = iEnd + 1;
			text = text.Replace("\"\"", "\"");
			if (text.Length > 1 && text[0] == '"' && text[text.Length - 1] == '"')
			{
				text = text.Substring(1, text.Length - 2);
			}
			list.Add(text);
		}

		public static List<string[]> ReadI2CSV(string Text)
		{
			string[] separator = new string[1] { "[*]" };
			string[] separator2 = new string[1] { "[ln]" };
			List<string[]> list = new List<string[]>();
			string[] array = Text.Split(separator2, StringSplitOptions.None);
			foreach (string text in array)
			{
				list.Add(text.Split(separator, StringSplitOptions.None));
			}
			return list;
		}

		public static void ValidateFullTerm(ref string Term)
		{
			Term = Term.Replace('\\', '/');
			int num = Term.IndexOf('/');
			if (num >= 0)
			{
				int startIndex;
				while ((startIndex = Term.LastIndexOf('/')) != num)
				{
					Term = Term.Remove(startIndex, 1);
				}
			}
		}

		public static string EncodeString(string str)
		{
			if (string.IsNullOrEmpty(str))
			{
				return string.Empty;
			}
			return str.Replace("\r\n", "<\\n>").Replace("\r", "<\\n>").Replace("\n", "<\\n>");
		}

		public static string DecodeString(string str)
		{
			if (string.IsNullOrEmpty(str))
			{
				return string.Empty;
			}
			return str.Replace("<\\n>", "\r\n");
		}
	}
	[AddComponentMenu("I2/Localization/I2 Localize")]
	public class Localize : MonoBehaviour
	{
		public enum TermModification
		{
			DontModify,
			ToUpper,
			ToLower,
			ToUpperFirst,
			ToTitle
		}

		public string mTerm = string.Empty;

		public string mTermSecondary = string.Empty;

		[NonSerialized]
		public string FinalTerm;

		[NonSerialized]
		public string FinalSecondaryTerm;

		public TermModification PrimaryTermModifier;

		public TermModification SecondaryTermModifier;

		public string TermPrefix;

		public string TermSuffix;

		public bool LocalizeOnAwake = true;

		private string LastLocalizedLanguage;

		public bool IgnoreRTL;

		public int MaxCharactersInRTL;

		public bool IgnoreNumbersInRTL = true;

		public bool CorrectAlignmentForRTL = true;

		public bool AddSpacesToJoinedLanguages;

		public bool AllowLocalizedParameters = true;

		public List<UnityEngine.Object> TranslatedObjects = new List<UnityEngine.Object>();

		[NonSerialized]
		public Dictionary<string, UnityEngine.Object> mAssetDictionary = new Dictionary<string, UnityEngine.Object>(StringComparer.Ordinal);

		public UnityEvent LocalizeEvent = new UnityEvent();

		public static string MainTranslation;

		public static string SecondaryTranslation;

		public static string CallBackTerm;

		public static string CallBackSecondaryTerm;

		public static Localize CurrentLocalizeComponent;

		public bool AlwaysForceLocalize;

		[SerializeField]
		public EventCallback LocalizeCallBack = new EventCallback();

		public bool mGUI_ShowReferences;

		public bool mGUI_ShowTems = true;

		public bool mGUI_ShowCallback;

		public ILocalizeTarget mLocalizeTarget;

		public string mLocalizeTargetName;

		public string Term
		{
			get
			{
				return mTerm;
			}
			set
			{
				SetTerm(value);
			}
		}

		public string SecondaryTerm
		{
			get
			{
				return mTermSecondary;
			}
			set
			{
				SetTerm(null, value);
			}
		}

		private void Awake()
		{
			UpdateAssetDictionary();
			FindTarget();
			if (LocalizeOnAwake)
			{
				OnLocalize();
			}
		}

		private void OnEnable()
		{
			OnLocalize();
		}

		public bool HasCallback()
		{
			if (LocalizeCallBack.HasCallback())
			{
				return true;
			}
			return LocalizeEvent.GetPersistentEventCount() > 0;
		}

		public void OnLocalize(bool Force = false)
		{
			if ((!Force && (!base.enabled || base.gameObject == null || !base.gameObject.activeInHierarchy)) || string.IsNullOrEmpty(LocalizationManager.CurrentLanguage) || (!AlwaysForceLocalize && !Force && !HasCallback() && LastLocalizedLanguage == LocalizationManager.CurrentLanguage))
			{
				return;
			}
			LastLocalizedLanguage = LocalizationManager.CurrentLanguage;
			if (string.IsNullOrEmpty(FinalTerm) || string.IsNullOrEmpty(FinalSecondaryTerm))
			{
				GetFinalTerms(out FinalTerm, out FinalSecondaryTerm);
			}
			bool flag = I2Utils.IsPlaying() && HasCallback();
			if (!flag && string.IsNullOrEmpty(FinalTerm) && string.IsNullOrEmpty(FinalSecondaryTerm))
			{
				return;
			}
			CallBackTerm = FinalTerm;
			CallBackSecondaryTerm = FinalSecondaryTerm;
			MainTranslation = ((string.IsNullOrEmpty(FinalTerm) || FinalTerm == "-") ? null : LocalizationManager.GetTranslation(FinalTerm, FixForRTL: false));
			SecondaryTranslation = ((string.IsNullOrEmpty(FinalSecondaryTerm) || FinalSecondaryTerm == "-") ? null : LocalizationManager.GetTranslation(FinalSecondaryTerm, FixForRTL: false));
			if (!flag && string.IsNullOrEmpty(FinalTerm) && string.IsNullOrEmpty(SecondaryTranslation))
			{
				return;
			}
			CurrentLocalizeComponent = this;
			LocalizeCallBack.Execute(this);
			LocalizeEvent.Invoke();
			LocalizationManager.ApplyLocalizationParams(ref MainTranslation, base.gameObject, AllowLocalizedParameters);
			if (!FindTarget())
			{
				return;
			}
			bool flag2 = LocalizationManager.IsRight2Left && !IgnoreRTL;
			if (MainTranslation != null)
			{
				switch (PrimaryTermModifier)
				{
				case TermModification.ToUpper:
					MainTranslation = MainTranslation.ToUpper();
					break;
				case TermModification.ToLower:
					MainTranslation = MainTranslation.ToLower();
					break;
				case TermModification.ToUpperFirst:
					MainTranslation = GoogleTranslation.UppercaseFirst(MainTranslation);
					break;
				case TermModification.ToTitle:
					MainTranslation = GoogleTranslation.TitleCase(MainTranslation);
					break;
				}
				if (!string.IsNullOrEmpty(TermPrefix))
				{
					MainTranslation = (flag2 ? (MainTranslation + TermPrefix) : (TermPrefix + MainTranslation));
				}
				if (!string.IsNullOrEmpty(TermSuffix))
				{
					MainTranslation = (flag2 ? (TermSuffix + MainTranslation) : (MainTranslation + TermSuffix));
				}
				if (AddSpacesToJoinedLanguages && LocalizationManager.HasJoinedWords && !string.IsNullOrEmpty(MainTranslation))
				{
					StringBuilder stringBuilder = new StringBuilder();
					stringBuilder.Append(MainTranslation[0]);
					int i = 1;
					for (int length = MainTranslation.Length; i < length; i++)
					{
						stringBuilder.Append(' ');
						stringBuilder.Append(MainTranslation[i]);
					}
					MainTranslation = stringBuilder.ToString();
				}
				if (flag2 && mLocalizeTarget.AllowMainTermToBeRTL() && !string.IsNullOrEmpty(MainTranslation))
				{
					MainTranslation = LocalizationManager.ApplyRTLfix(MainTranslation, MaxCharactersInRTL, IgnoreNumbersInRTL);
				}
			}
			if (SecondaryTranslation != null)
			{
				switch (SecondaryTermModifier)
				{
				case TermModification.ToUpper:
					SecondaryTranslation = SecondaryTranslation.ToUpper();
					break;
				case TermModification.ToLower:
					SecondaryTranslation = SecondaryTranslation.ToLower();
					break;
				case TermModification.ToUpperFirst:
					SecondaryTranslation = GoogleTranslation.UppercaseFirst(SecondaryTranslation);
					break;
				case TermModification.ToTitle:
					SecondaryTranslation = GoogleTranslation.TitleCase(SecondaryTranslation);
					break;
				}
				if (flag2 && mLocalizeTarget.AllowSecondTermToBeRTL() && !string.IsNullOrEmpty(SecondaryTranslation))
				{
					SecondaryTranslation = LocalizationManager.ApplyRTLfix(SecondaryTranslation);
				}
			}
			if (LocalizationManager.HighlightLocalizedTargets)
			{
				MainTranslation = "LOC:" + FinalTerm;
			}
			mLocalizeTarget.DoLocalize(this, MainTranslation, SecondaryTranslation);
			CurrentLocalizeComponent = null;
		}

		public bool FindTarget()
		{
			if (mLocalizeTarget != null && mLocalizeTarget.IsValid(this))
			{
				return true;
			}
			if (mLocalizeTarget != null)
			{
				UnityEngine.Object.DestroyImmediate(mLocalizeTarget);
				mLocalizeTarget = null;
				mLocalizeTargetName = null;
			}
			if (!string.IsNullOrEmpty(mLocalizeTargetName))
			{
				foreach (ILocalizeTargetDescriptor mLocalizeTarget in LocalizationManager.mLocalizeTargets)
				{
					if (mLocalizeTargetName == mLocalizeTarget.GetTargetType().ToString())
					{
						if (mLocalizeTarget.CanLocalize(this))
						{
							this.mLocalizeTarget = mLocalizeTarget.CreateTarget(this);
						}
						if (this.mLocalizeTarget != null)
						{
							return true;
						}
					}
				}
			}
			foreach (ILocalizeTargetDescriptor mLocalizeTarget2 in LocalizationManager.mLocalizeTargets)
			{
				if (mLocalizeTarget2.CanLocalize(this))
				{
					this.mLocalizeTarget = mLocalizeTarget2.CreateTarget(this);
					mLocalizeTargetName = mLocalizeTarget2.GetTargetType().ToString();
					if (this.mLocalizeTarget != null)
					{
						return true;
					}
				}
			}
			return false;
		}

		public void GetFinalTerms(out string primaryTerm, out string secondaryTerm)
		{
			primaryTerm = string.Empty;
			secondaryTerm = string.Empty;
			if (FindTarget())
			{
				if (mLocalizeTarget != null)
				{
					mLocalizeTarget.GetFinalTerms(this, mTerm, mTermSecondary, out primaryTerm, out secondaryTerm);
					primaryTerm = I2Utils.GetValidTermName(primaryTerm);
				}
				if (!string.IsNullOrEmpty(mTerm))
				{
					primaryTerm = mTerm;
				}
				if (!string.IsNullOrEmpty(mTermSecondary))
				{
					secondaryTerm = mTermSecondary;
				}
				if (primaryTerm != null)
				{
					primaryTerm = primaryTerm.Trim();
				}
				if (secondaryTerm != null)
				{
					secondaryTerm = secondaryTerm.Trim();
				}
			}
		}

		public string GetMainTargetsText()
		{
			string primaryTerm = null;
			string secondaryTerm = null;
			if (mLocalizeTarget != null)
			{
				mLocalizeTarget.GetFinalTerms(this, null, null, out primaryTerm, out secondaryTerm);
			}
			if (!string.IsNullOrEmpty(primaryTerm))
			{
				return primaryTerm;
			}
			return mTerm;
		}

		public void SetFinalTerms(string Main, string Secondary, out string primaryTerm, out string secondaryTerm, bool RemoveNonASCII)
		{
			primaryTerm = (RemoveNonASCII ? I2Utils.GetValidTermName(Main) : Main);
			secondaryTerm = Secondary;
		}

		public void SetTerm(string primary)
		{
			if (!string.IsNullOrEmpty(primary))
			{
				FinalTerm = (mTerm = primary);
			}
			OnLocalize(Force: true);
		}

		public void SetTerm(string primary, string secondary)
		{
			if (!string.IsNullOrEmpty(primary))
			{
				FinalTerm = (mTerm = primary);
			}
			FinalSecondaryTerm = (mTermSecondary = secondary);
			OnLocalize(Force: true);
		}

		internal T GetSecondaryTranslatedObj<T>(ref string mainTranslation, ref string secondaryTranslation) where T : UnityEngine.Object
		{
			DeserializeTranslation(mainTranslation, out var value, out var secondary);
			T val = null;
			if (!string.IsNullOrEmpty(secondary))
			{
				val = GetObject<T>(secondary);
				if (val != null)
				{
					mainTranslation = value;
					secondaryTranslation = secondary;
				}
			}
			if (val == null)
			{
				val = GetObject<T>(secondaryTranslation);
			}
			return val;
		}

		public void UpdateAssetDictionary()
		{
			TranslatedObjects.RemoveAll((UnityEngine.Object x) => x == null);
			mAssetDictionary = (from o in TranslatedObjects.Distinct()
				group o by o.name).ToDictionary((IGrouping<string, UnityEngine.Object> g) => g.Key, (IGrouping<string, UnityEngine.Object> g) => g.First());
		}

		internal T GetObject<T>(string Translation) where T : UnityEngine.Object
		{
			if (string.IsNullOrEmpty(Translation))
			{
				return null;
			}
			return GetTranslatedObject<T>(Translation);
		}

		private T GetTranslatedObject<T>(string Translation) where T : UnityEngine.Object
		{
			return FindTranslatedObject<T>(Translation);
		}

		private void DeserializeTranslation(string translation, out string value, out string secondary)
		{
			if (!string.IsNullOrEmpty(translation) && translation.Length > 1 && translation[0] == '[')
			{
				int num = translation.IndexOf(']');
				if (num > 0)
				{
					secondary = translation.Substring(1, num - 1);
					value = translation.Substring(num + 1);
					return;
				}
			}
			value = translation;
			secondary = string.Empty;
		}

		public T FindTranslatedObject<T>(string value) where T : UnityEngine.Object
		{
			if (string.IsNullOrEmpty(value))
			{
				return null;
			}
			if (mAssetDictionary == null || mAssetDictionary.Count != TranslatedObjects.Count)
			{
				UpdateAssetDictionary();
			}
			foreach (KeyValuePair<string, UnityEngine.Object> item in mAssetDictionary)
			{
				if (item.Value is T && value.EndsWith(item.Key, StringComparison.OrdinalIgnoreCase) && string.Compare(value, item.Key, StringComparison.OrdinalIgnoreCase) == 0)
				{
					return (T)item.Value;
				}
			}
			T val = LocalizationManager.FindAsset(value) as T;
			if ((bool)val)
			{
				return val;
			}
			return ResourceManager.pInstance.GetAsset<T>(value);
		}

		public bool HasTranslatedObject(UnityEngine.Object Obj)
		{
			if (TranslatedObjects.Contains(Obj))
			{
				return true;
			}
			return ResourceManager.pInstance.HasAsset(Obj);
		}

		public void AddTranslatedObject(UnityEngine.Object Obj)
		{
			if (!TranslatedObjects.Contains(Obj))
			{
				TranslatedObjects.Add(Obj);
				UpdateAssetDictionary();
			}
		}

		public void SetGlobalLanguage(string Language)
		{
			LocalizationManager.CurrentLanguage = Language;
		}
	}
	[AddComponentMenu("I2/Localization/Localize Dropdown")]
	public class LocalizeDropdown : MonoBehaviour
	{
		public List<string> _Terms = new List<string>();

		public void Start()
		{
			LocalizationManager.OnLocalizeEvent += OnLocalize;
			OnLocalize();
		}

		public void OnDestroy()
		{
			LocalizationManager.OnLocalizeEvent -= OnLocalize;
		}

		private void OnEnable()
		{
			if (_Terms.Count == 0)
			{
				FillValues();
			}
			OnLocalize();
		}

		public void OnLocalize()
		{
			if (base.enabled && !(base.gameObject == null) && base.gameObject.activeInHierarchy && !string.IsNullOrEmpty(LocalizationManager.CurrentLanguage))
			{
				UpdateLocalization();
			}
		}

		private void FillValues()
		{
			Dropdown component = GetComponent<Dropdown>();
			if (component == null && I2Utils.IsPlaying())
			{
				FillValuesTMPro();
				return;
			}
			foreach (Dropdown.OptionData option in component.options)
			{
				_Terms.Add(option.text);
			}
		}

		public void UpdateLocalization()
		{
			Dropdown component = GetComponent<Dropdown>();
			if (component == null)
			{
				UpdateLocalizationTMPro();
				return;
			}
			component.options.Clear();
			foreach (string term in _Terms)
			{
				string translation = LocalizationManager.GetTranslation(term);
				component.options.Add(new Dropdown.OptionData(translation));
			}
			component.RefreshShownValue();
		}

		public void UpdateLocalizationTMPro()
		{
			TMP_Dropdown component = GetComponent<TMP_Dropdown>();
			if (component == null)
			{
				return;
			}
			component.options.Clear();
			foreach (string term in _Terms)
			{
				string translation = LocalizationManager.GetTranslation(term);
				component.options.Add(new TMP_Dropdown.OptionData(translation));
			}
			component.RefreshShownValue();
		}

		private void FillValuesTMPro()
		{
			TMP_Dropdown component = GetComponent<TMP_Dropdown>();
			if (component == null)
			{
				return;
			}
			foreach (TMP_Dropdown.OptionData option in component.options)
			{
				_Terms.Add(option.text);
			}
		}
	}
	public static class LocalizationManager
	{
		public delegate object _GetParam(string param);

		public delegate void OnLocalizeCallback();

		private static string mCurrentLanguage;

		private static string mLanguageCode;

		private static CultureInfo mCurrentCulture;

		private static bool mChangeCultureInfo = false;

		public static bool IsRight2Left = false;

		public static bool HasJoinedWords = false;

		public static List<ILocalizationParamsManager> ParamManagers = new List<ILocalizationParamsManager>();

		private static string[] LanguagesRTL = new string[21]
		{
			"ar-DZ", "ar", "ar-BH", "ar-EG", "ar-IQ", "ar-JO", "ar-KW", "ar-LB", "ar-LY", "ar-MA",
			"ar-OM", "ar-QA", "ar-SA", "ar-SY", "ar-TN", "ar-AE", "ar-YE", "fa", "he", "ur",
			"ji"
		};

		public static List<LanguageSourceData> Sources = new List<LanguageSourceData>();

		public static string[] GlobalSources = new string[1] { "I2Languages" };

		private static string mCurrentDeviceLanguage;

		public static List<ILocalizeTargetDescriptor> mLocalizeTargets = new List<ILocalizeTargetDescriptor>();

		private static bool mLocalizeIsScheduled = false;

		private static bool mLocalizeIsScheduledWithForcedValue = false;

		public static bool HighlightLocalizedTargets = false;

		public static string CurrentLanguage
		{
			get
			{
				InitializeIfNeeded();
				return mCurrentLanguage;
			}
			set
			{
				InitializeIfNeeded();
				string supportedLanguage = GetSupportedLanguage(value);
				if (!string.IsNullOrEmpty(supportedLanguage) && mCurrentLanguage != supportedLanguage)
				{
					SetLanguageAndCode(supportedLanguage, GetLanguageCode(supportedLanguage));
				}
			}
		}

		public static string CurrentLanguageCode
		{
			get
			{
				InitializeIfNeeded();
				return mLanguageCode;
			}
			set
			{
				InitializeIfNeeded();
				if (mLanguageCode != value)
				{
					string languageFromCode = GetLanguageFromCode(value);
					if (!string.IsNullOrEmpty(languageFromCode))
					{
						SetLanguageAndCode(languageFromCode, value);
					}
				}
			}
		}

		public static string CurrentRegion
		{
			get
			{
				string currentLanguage = CurrentLanguage;
				int num = currentLanguage.IndexOfAny("/\\".ToCharArray());
				if (num > 0)
				{
					return currentLanguage.Substring(num + 1);
				}
				num = currentLanguage.IndexOfAny("[(".ToCharArray());
				int num2 = currentLanguage.LastIndexOfAny("])".ToCharArray());
				if (num > 0 && num != num2)
				{
					return currentLanguage.Substring(num + 1, num2 - num - 1);
				}
				return string.Empty;
			}
			set
			{
				string text = CurrentLanguage;
				int num = text.IndexOfAny("/\\".ToCharArray());
				if (num > 0)
				{
					CurrentLanguage = text.Substring(num + 1) + value;
					return;
				}
				num = text.IndexOfAny("[(".ToCharArray());
				int num2 = text.LastIndexOfAny("])".ToCharArray());
				if (num > 0 && num != num2)
				{
					text = text.Substring(num);
				}
				CurrentLanguage = text + "(" + value + ")";
			}
		}

		public static string CurrentRegionCode
		{
			get
			{
				string currentLanguageCode = CurrentLanguageCode;
				int num = currentLanguageCode.IndexOfAny(" -_/\\".ToCharArray());
				if (num >= 0)
				{
					return currentLanguageCode.Substring(num + 1);
				}
				return string.Empty;
			}
			set
			{
				string text = CurrentLanguageCode;
				int num = text.IndexOfAny(" -_/\\".ToCharArray());
				if (num > 0)
				{
					text = text.Substring(0, num);
				}
				CurrentLanguageCode = text + "-" + value;
			}
		}

		public static CultureInfo CurrentCulture => mCurrentCulture;

		public static event OnLocalizeCallback OnLocalizeEvent;

		public static void InitializeIfNeeded()
		{
			if (string.IsNullOrEmpty(mCurrentLanguage) || Sources.Count == 0)
			{
				AutoLoadGlobalParamManagers();
				UpdateSources();
				SelectStartupLanguage();
			}
		}

		public static string GetVersion()
		{
			return "2.8.13 f2";
		}

		public static int GetRequiredWebServiceVersion()
		{
			return 5;
		}

		public static string GetWebServiceURL(LanguageSourceData source = null)
		{
			if (source != null && !string.IsNullOrEmpty(source.Google_WebServiceURL))
			{
				return source.Google_WebServiceURL;
			}
			InitializeIfNeeded();
			for (int i = 0; i < Sources.Count; i++)
			{
				if (Sources[i] != null && !string.IsNullOrEmpty(Sources[i].Google_WebServiceURL))
				{
					return Sources[i].Google_WebServiceURL;
				}
			}
			return string.Empty;
		}

		public static void SetLanguageAndCode(string LanguageName, string LanguageCode, bool RememberLanguage = true, bool Force = false)
		{
			if (mCurrentLanguage != LanguageName || mLanguageCode != LanguageCode || Force)
			{
				if (RememberLanguage)
				{
					PersistentStorage.SetSetting_String("I2 Language", LanguageName);
				}
				mCurrentLanguage = LanguageName;
				mLanguageCode = LanguageCode;
				mCurrentCulture = CreateCultureForCode(LanguageCode);
				if (mChangeCultureInfo)
				{
					SetCurrentCultureInfo();
				}
				IsRight2Left = IsRTL(mLanguageCode);
				HasJoinedWords = GoogleLanguages.LanguageCode_HasJoinedWord(mLanguageCode);
				LocalizeAll(Force);
			}
		}

		private static CultureInfo CreateCultureForCode(string code)
		{
			try
			{
				return CultureInfo.CreateSpecificCulture(code);
			}
			catch (Exception)
			{
				return CultureInfo.InvariantCulture;
			}
		}

		public static void EnableChangingCultureInfo(bool bEnable)
		{
			if (!mChangeCultureInfo && bEnable)
			{
				SetCurrentCultureInfo();
			}
			mChangeCultureInfo = bEnable;
		}

		private static void SetCurrentCultureInfo()
		{
			Thread.CurrentThread.CurrentCulture = mCurrentCulture;
		}

		private static void SelectStartupLanguage()
		{
			if (Sources.Count == 0)
			{
				return;
			}
			string setting_String = PersistentStorage.GetSetting_String("I2 Language", string.Empty);
			string currentDeviceLanguage = GetCurrentDeviceLanguage();
			if (!string.IsNullOrEmpty(setting_String) && HasLanguage(setting_String, AllowDiscartingRegion: true, Initialize: false))
			{
				SetLanguageAndCode(setting_String, GetLanguageCode(setting_String));
				return;
			}
			if (!Sources[0].IgnoreDeviceLanguage)
			{
				string supportedLanguage = GetSupportedLanguage(currentDeviceLanguage, ignoreDisabled: true);
				if (!string.IsNullOrEmpty(supportedLanguage))
				{
					SetLanguageAndCode(supportedLanguage, GetLanguageCode(supportedLanguage), RememberLanguage: false);
					return;
				}
			}
			int i = 0;
			for (int count = Sources.Count; i < count; i++)
			{
				if (Sources[i].mLanguages.Count <= 0)
				{
					continue;
				}
				for (int j = 0; j < Sources[i].mLanguages.Count; j++)
				{
					if (Sources[i].mLanguages[j].IsEnabled())
					{
						SetLanguageAndCode(Sources[i].mLanguages[j].Name, Sources[i].mLanguages[j].Code, RememberLanguage: false);
						return;
					}
				}
			}
		}

		public static bool HasLanguage(string Language, bool AllowDiscartingRegion = true, bool Initialize = true, bool SkipDisabled = true)
		{
			if (Initialize)
			{
				InitializeIfNeeded();
			}
			int i = 0;
			for (int count = Sources.Count; i < count; i++)
			{
				if (Sources[i].GetLanguageIndex(Language, AllowDiscartingRegion: false, SkipDisabled) >= 0)
				{
					return true;
				}
			}
			if (AllowDiscartingRegion)
			{
				int j = 0;
				for (int count2 = Sources.Count; j < count2; j++)
				{
					if (Sources[j].GetLanguageIndex(Language, AllowDiscartingRegion: true, SkipDisabled) >= 0)
					{
						return true;
					}
				}
			}
			return false;
		}

		public static string GetSupportedLanguage(string Language, bool ignoreDisabled = false)
		{
			string languageCode = GoogleLanguages.GetLanguageCode(Language);
			if (!string.IsNullOrEmpty(languageCode))
			{
				int i = 0;
				for (int count = Sources.Count; i < count; i++)
				{
					int languageIndexFromCode = Sources[i].GetLanguageIndexFromCode(languageCode, exactMatch: true, ignoreDisabled);
					if (languageIndexFromCode >= 0)
					{
						return Sources[i].mLanguages[languageIndexFromCode].Name;
					}
				}
				int j = 0;
				for (int count2 = Sources.Count; j < count2; j++)
				{
					int languageIndexFromCode2 = Sources[j].GetLanguageIndexFromCode(languageCode, exactMatch: false, ignoreDisabled);
					if (languageIndexFromCode2 >= 0)
					{
						return Sources[j].mLanguages[languageIndexFromCode2].Name;
					}
				}
			}
			int k = 0;
			for (int count3 = Sources.Count; k < count3; k++)
			{
				int languageIndex = Sources[k].GetLanguageIndex(Language, AllowDiscartingRegion: false, ignoreDisabled);
				if (languageIndex >= 0)
				{
					return Sources[k].mLanguages[languageIndex].Name;
				}
			}
			int l = 0;
			for (int count4 = Sources.Count; l < count4; l++)
			{
				int languageIndex2 = Sources[l].GetLanguageIndex(Language, AllowDiscartingRegion: true, ignoreDisabled);
				if (languageIndex2 >= 0)
				{
					return Sources[l].mLanguages[languageIndex2].Name;
				}
			}
			return string.Empty;
		}

		public static string GetLanguageCode(string Language)
		{
			if (Sources.Count == 0)
			{
				UpdateSources();
			}
			int i = 0;
			for (int count = Sources.Count; i < count; i++)
			{
				int languageIndex = Sources[i].GetLanguageIndex(Language);
				if (languageIndex >= 0)
				{
					return Sources[i].mLanguages[languageIndex].Code;
				}
			}
			return string.Empty;
		}

		public static string GetLanguageFromCode(string Code, bool exactMatch = true)
		{
			if (Sources.Count == 0)
			{
				UpdateSources();
			}
			int i = 0;
			for (int count = Sources.Count; i < count; i++)
			{
				int languageIndexFromCode = Sources[i].GetLanguageIndexFromCode(Code, exactMatch);
				if (languageIndexFromCode >= 0)
				{
					return Sources[i].mLanguages[languageIndexFromCode].Name;
				}
			}
			return string.Empty;
		}

		public static List<string> GetAllLanguages(bool SkipDisabled = true)
		{
			if (Sources.Count == 0)
			{
				UpdateSources();
			}
			List<string> Languages = new List<string>();
			int i = 0;
			for (int count = Sources.Count; i < count; i++)
			{
				Languages.AddRange(from x in Sources[i].GetLanguages(SkipDisabled)
					where !Languages.Contains(x)
					select x);
			}
			return Languages;
		}

		public static List<string> GetAllLanguagesCode(bool allowRegions = true, bool SkipDisabled = true)
		{
			List<string> Languages = new List<string>();
			int i = 0;
			for (int count = Sources.Count; i < count; i++)
			{
				Languages.AddRange(from x in Sources[i].GetLanguagesCode(allowRegions, SkipDisabled)
					where !Languages.Contains(x)
					select x);
			}
			return Languages;
		}

		public static bool IsLanguageEnabled(string Language)
		{
			int i = 0;
			for (int count = Sources.Count; i < count; i++)
			{
				if (!Sources[i].IsLanguageEnabled(Language))
				{
					return false;
				}
			}
			return true;
		}

		private static void LoadCurrentLanguage()
		{
			for (int i = 0; i < Sources.Count; i++)
			{
				int languageIndex = Sources[i].GetLanguageIndex(mCurrentLanguage, AllowDiscartingRegion: true, SkipDisabled: false);
				Sources[i].LoadLanguage(languageIndex, UnloadOtherLanguages: true, useFallback: true, onlyCurrentSpecialization: true, forceLoad: false);
			}
		}

		public static void PreviewLanguage(string NewLanguage)
		{
			mCurrentLanguage = NewLanguage;
			mLanguageCode = GetLanguageCode(mCurrentLanguage);
			IsRight2Left = IsRTL(mLanguageCode);
			HasJoinedWords = GoogleLanguages.LanguageCode_HasJoinedWord(mLanguageCode);
		}

		public static void AutoLoadGlobalParamManagers()
		{
			LocalizationParamsManager[] array = UnityEngine.Object.FindObjectsOfType<LocalizationParamsManager>();
			foreach (LocalizationParamsManager localizationParamsManager in array)
			{
				if (localizationParamsManager._IsGlobalManager && !ParamManagers.Contains(localizationParamsManager))
				{
					UnityEngine.Debug.Log(localizationParamsManager);
					ParamManagers.Add(localizationParamsManager);
				}
			}
		}

		public static void ApplyLocalizationParams(ref string translation, bool allowLocalizedParameters = true)
		{
			ApplyLocalizationParams(ref translation, (string p) => GetLocalizationParam(p, null), allowLocalizedParameters);
		}

		public static void ApplyLocalizationParams(ref string translation, GameObject root, bool allowLocalizedParameters = true)
		{
			ApplyLocalizationParams(ref translation, (string p) => GetLocalizationParam(p, root), allowLocalizedParameters);
		}

		public static void ApplyLocalizationParams(ref string translation, Dictionary<string, object> parameters, bool allowLocalizedParameters = true)
		{
			ApplyLocalizationParams(ref translation, delegate(string p)
			{
				object value = null;
				return parameters.TryGetValue(p, out value) ? value : null;
			}, allowLocalizedParameters);
		}

		public static void ApplyLocalizationParams(ref string translation, _GetParam getParam, bool allowLocalizedParameters = true)
		{
			if (translation == null)
			{
				return;
			}
			string text = null;
			int num = 0;
			int length = translation.Length;
			int num2 = 0;
			while (num2 >= 0 && num2 < translation.Length)
			{
				int num3 = translation.IndexOf("{[", num2);
				if (num3 < 0)
				{
					break;
				}
				int num4 = translation.IndexOf("]}", num3);
				if (num4 < 0)
				{
					break;
				}
				int num5 = translation.IndexOf("{[", num3 + 1);
				if (num5 > 0 && num5 < num4)
				{
					num2 = num5;
					continue;
				}
				int num6 = ((translation[num3 + 2] == '#') ? 3 : 2);
				string param = translation.Substring(num3 + num6, num4 - num3 - num6);
				string text2 = (string)getParam(param);
				if (text2 != null && allowLocalizedParameters)
				{
					LanguageSourceData source;
					TermData termData = GetTermData(text2, out source);
					if (termData != null)
					{
						int languageIndex = source.GetLanguageIndex(CurrentLanguage);
						if (languageIndex >= 0)
						{
							text2 = termData.GetTranslation(languageIndex);
						}
					}
					string oldValue = translation.Substring(num3, num4 - num3 + 2);
					translation = translation.Replace(oldValue, text2);
					int result = 0;
					if (int.TryParse(text2, out result))
					{
						text = GoogleLanguages.GetPluralType(CurrentLanguageCode, result).ToString();
					}
					num2 = num3 + text2.Length;
				}
				else
				{
					num2 = num4 + 2;
				}
			}
			if (text != null)
			{
				string text3 = "[i2p_" + text + "]";
				num = translation.IndexOf(text3, StringComparison.OrdinalIgnoreCase);
				num = ((num >= 0) ? (num + text3.Length) : 0);
				length = translation.IndexOf("[i2p_", num + 1, StringComparison.OrdinalIgnoreCase);
				if (length < 0)
				{
					length = translation.Length;
				}
				translation = translation.Substring(num, length - num);
			}
		}

		internal static string GetLocalizationParam(string ParamName, GameObject root)
		{
			string text = null;
			if ((bool)root)
			{
				MonoBehaviour[] components = root.GetComponents<MonoBehaviour>();
				int i = 0;
				for (int num = components.Length; i < num; i++)
				{
					if (components[i] is ILocalizationParamsManager localizationParamsManager && components[i].enabled)
					{
						text = localizationParamsManager.GetParameterValue(ParamName);
						if (text != null)
						{
							return text;
						}
					}
				}
			}
			int j = 0;
			for (int count = ParamManagers.Count; j < count; j++)
			{
				text = ParamManagers[j].GetParameterValue(ParamName);
				if (text != null)
				{
					return text;
				}
			}
			return null;
		}

		private static string GetPluralType(MatchCollection matches, string langCode, _GetParam getParam)
		{
			int i = 0;
			for (int count = matches.Count; i < count; i++)
			{
				Match match = matches[i];
				string value = match.Groups[match.Groups.Count - 1].Value;
				string text = (string)getParam(value);
				if (text != null)
				{
					int result = 0;
					if (int.TryParse(text, out result))
					{
						return GoogleLanguages.GetPluralType(langCode, result).ToString();
					}
				}
			}
			return null;
		}

		public static string ApplyRTLfix(string line)
		{
			return ApplyRTLfix(line, 0, ignoreNumbers: true);
		}

		public static string ApplyRTLfix(string line, int maxCharacters, bool ignoreNumbers)
		{
			if (string.IsNullOrEmpty(line))
			{
				return line;
			}
			char c = line[0];
			if (c == '!' || c == '.' || c == '?')
			{
				line = line.Substring(1) + c;
			}
			int tagStart = -1;
			int num = 0;
			int num2 = 40000;
			num = 0;
			List<string> list = new List<string>();
			while (I2Utils.FindNextTag(line, num, out tagStart, out num))
			{
				string text = "@@" + (char)(num2 + list.Count) + "@@";
				list.Add(line.Substring(tagStart, num - tagStart + 1));
				line = line.Substring(0, tagStart) + text + line.Substring(num + 1);
				num = tagStart + 5;
			}
			line = line.Replace("\r\n", "\n");
			line = I2Utils.SplitLine(line, maxCharacters);
			line = RTLFixer.Fix(line, showTashkeel: true, !ignoreNumbers);
			for (int i = 0; i < list.Count; i++)
			{
				int length = line.Length;
				for (int j = 0; j < length; j++)
				{
					if (line[j] == '@' && line[j + 1] == '@' && line[j + 2] >= num2 && line[j + 3] == '@' && line[j + 4] == '@')
					{
						int num3 = line[j + 2] - num2;
						num3 = ((num3 % 2 != 0) ? (num3 - 1) : (num3 + 1));
						if (num3 >= list.Count)
						{
							num3 = list.Count - 1;
						}
						line = line.Substring(0, j) + list[num3] + line.Substring(j + 5);
						break;
					}
				}
			}
			return line;
		}

		public static string FixRTL_IfNeeded(string text, int maxCharacters = 0, bool ignoreNumber = false)
		{
			if (IsRight2Left)
			{
				return ApplyRTLfix(text, maxCharacters, ignoreNumber);
			}
			return text;
		}

		public static bool IsRTL(string Code)
		{
			return Array.IndexOf(LanguagesRTL, Code) >= 0;
		}

		public static bool UpdateSources()
		{
			UnregisterDeletededSources();
			RegisterSourceInResources();
			RegisterSceneSources();
			return Sources.Count > 0;
		}

		private static void UnregisterDeletededSources()
		{
			for (int num = Sources.Count - 1; num >= 0; num--)
			{
				if (Sources[num] == null)
				{
					RemoveSource(Sources[num]);
				}
			}
		}

		private static void RegisterSceneSources()
		{
			LanguageSource[] array = (LanguageSource[])Resources.FindObjectsOfTypeAll(typeof(LanguageSource));
			foreach (LanguageSource languageSource in array)
			{
				if (!Sources.Contains(languageSource.mSource))
				{
					if (languageSource.mSource.owner == null)
					{
						languageSource.mSource.owner = languageSource;
					}
					AddSource(languageSource.mSource);
				}
			}
		}

		private static void RegisterSourceInResources()
		{
			string[] globalSources = GlobalSources;
			foreach (string name in globalSources)
			{
				LanguageSourceAsset asset = ResourceManager.pInstance.GetAsset<LanguageSourceAsset>(name);
				if ((bool)asset && !Sources.Contains(asset.mSource))
				{
					if (!asset.mSource.mIsGlobalSource)
					{
						asset.mSource.mIsGlobalSource = true;
					}
					asset.mSource.owner = asset;
					AddSource(asset.mSource);
				}
			}
		}

		internal static void AddSource(LanguageSourceData Source)
		{
			if (Sources.Contains(Source))
			{
				return;
			}
			Sources.Add(Source);
			if (Source.HasGoogleSpreadsheet() && Source.GoogleUpdateFrequency != LanguageSourceData.eGoogleUpdateFrequency.Never)
			{
				Source.Import_Google_FromCache();
				bool justCheck = false;
				if (Source.GoogleUpdateDelay > 0f)
				{
					CoroutineManager.Start(Delayed_Import_Google(Source, Source.GoogleUpdateDelay, justCheck));
				}
				else
				{
					Source.Import_Google(ForceUpdate: false, justCheck);
				}
			}
			for (int i = 0; i < Source.mLanguages.Count(); i++)
			{
				Source.mLanguages[i].SetLoaded(loaded: true);
			}
			if (Source.mDictionary.Count == 0)
			{
				Source.UpdateDictionary(force: true);
			}
		}

		private static IEnumerator Delayed_Import_Google(LanguageSourceData source, float delay, bool justCheck)
		{
			yield return new WaitForSeconds(delay);
			source?.Import_Google(ForceUpdate: false, justCheck);
		}

		internal static void RemoveSource(LanguageSourceData Source)
		{
			Sources.Remove(Source);
		}

		public static bool IsGlobalSource(string SourceName)
		{
			return Array.IndexOf(GlobalSources, SourceName) >= 0;
		}

		public static LanguageSourceData GetSourceContaining(string term, bool fallbackToFirst = true)
		{
			if (!string.IsNullOrEmpty(term))
			{
				int i = 0;
				for (int count = Sources.Count; i < count; i++)
				{
					if (Sources[i].GetTermData(term) != null)
					{
						return Sources[i];
					}
				}
			}
			if (!fallbackToFirst || Sources.Count <= 0)
			{
				return null;
			}
			return Sources[0];
		}

		public static UnityEngine.Object FindAsset(string value)
		{
			int i = 0;
			for (int count = Sources.Count; i < count; i++)
			{
				UnityEngine.Object @object = Sources[i].FindAsset(value);
				if ((bool)@object)
				{
					return @object;
				}
			}
			return null;
		}

		public static void ApplyDownloadedDataFromGoogle()
		{
			int i = 0;
			for (int count = Sources.Count; i < count; i++)
			{
				Sources[i].ApplyDownloadedDataFromGoogle();
			}
		}

		public static string GetCurrentDeviceLanguage(bool force = false)
		{
			if (force || string.IsNullOrEmpty(mCurrentDeviceLanguage))
			{
				DetectDeviceLanguage();
			}
			return mCurrentDeviceLanguage;
		}

		private static void DetectDeviceLanguage()
		{
			try
			{
				mCurrentDeviceLanguage = new AndroidJavaClass("java/util/Locale").CallStatic<AndroidJavaObject>("getDefault", Array.Empty<object>()).Call<string>("toString", Array.Empty<object>());
				if (!string.IsNullOrEmpty(mCurrentDeviceLanguage))
				{
					mCurrentDeviceLanguage = mCurrentDeviceLanguage.Replace('_', '-');
					mCurrentDeviceLanguage = GoogleLanguages.GetLanguageName(mCurrentDeviceLanguage, useParenthesesForRegion: true);
					if (!string.IsNullOrEmpty(mCurrentDeviceLanguage))
					{
						return;
					}
				}
			}
			catch (Exception)
			{
			}
			mCurrentDeviceLanguage = UnityEngine.Application.systemLanguage.ToString();
			if (mCurrentDeviceLanguage == "ChineseSimplified")
			{
				mCurrentDeviceLanguage = "Chinese (Simplified)";
			}
			if (mCurrentDeviceLanguage == "ChineseTraditional")
			{
				mCurrentDeviceLanguage = "Chinese (Traditional)";
			}
		}

		public static void RegisterTarget(ILocalizeTargetDescriptor desc)
		{
			if (mLocalizeTargets.FindIndex((ILocalizeTargetDescriptor x) => x.Name == desc.Name) != -1)
			{
				return;
			}
			for (int i = 0; i < mLocalizeTargets.Count; i++)
			{
				if (mLocalizeTargets[i].Priority > desc.Priority)
				{
					mLocalizeTargets.Insert(i, desc);
					return;
				}
			}
			mLocalizeTargets.Add(desc);
		}

		public static string GetTranslation(string Term, bool FixForRTL = true, int maxLineLengthForRTL = 0, bool ignoreRTLnumbers = true, bool applyParameters = false, GameObject localParametersRoot = null, string overrideLanguage = null)
		{
			string Translation = null;
			TryGetTranslation(Term, out Translation, FixForRTL, maxLineLengthForRTL, ignoreRTLnumbers, applyParameters, localParametersRoot, overrideLanguage);
			return Translation;
		}

		public static string GetTermTranslation(string Term, bool FixForRTL = true, int maxLineLengthForRTL = 0, bool ignoreRTLnumbers = true, bool applyParameters = false, GameObject localParametersRoot = null, string overrideLanguage = null)
		{
			return GetTranslation(Term, FixForRTL, maxLineLengthForRTL, ignoreRTLnumbers, applyParameters, localParametersRoot, overrideLanguage);
		}

		public static bool TryGetTranslation(string Term, out string Translation, bool FixForRTL = true, int maxLineLengthForRTL = 0, bool ignoreRTLnumbers = true, bool applyParameters = false, GameObject localParametersRoot = null, string overrideLanguage = null)
		{
			Translation = null;
			if (string.IsNullOrEmpty(Term))
			{
				return false;
			}
			InitializeIfNeeded();
			int i = 0;
			for (int count = Sources.Count; i < count; i++)
			{
				if (Sources[i].TryGetTranslation(Term, out Translation, overrideLanguage))
				{
					if (applyParameters)
					{
						ApplyLocalizationParams(ref Translation, localParametersRoot);
					}
					if (IsRight2Left && FixForRTL)
					{
						Translation = ApplyRTLfix(Translation, maxLineLengthForRTL, ignoreRTLnumbers);
					}
					return true;
				}
			}
			return false;
		}

		public static T GetTranslatedObject<T>(string AssetName, Localize optionalLocComp = null) where T : UnityEngine.Object
		{
			if (optionalLocComp != null)
			{
				return optionalLocComp.FindTranslatedObject<T>(AssetName);
			}
			T val = FindAsset(AssetName) as T;
			if ((bool)val)
			{
				return val;
			}
			return ResourceManager.pInstance.GetAsset<T>(AssetName);
		}

		public static T GetTranslatedObjectByTermName<T>(string Term, Localize optionalLocComp = null) where T : UnityEngine.Object
		{
			return GetTranslatedObject<T>(GetTranslation(Term, FixForRTL: false));
		}

		public static string GetAppName(string languageCode)
		{
			if (!string.IsNullOrEmpty(languageCode))
			{
				for (int i = 0; i < Sources.Count; i++)
				{
					if (string.IsNullOrEmpty(Sources[i].mTerm_AppName))
					{
						continue;
					}
					int languageIndexFromCode = Sources[i].GetLanguageIndexFromCode(languageCode, exactMatch: false);
					if (languageIndexFromCode < 0)
					{
						continue;
					}
					TermData termData = Sources[i].GetTermData(Sources[i].mTerm_AppName);
					if (termData != null)
					{
						string translation = termData.GetTranslation(languageIndexFromCode);
						if (!string.IsNullOrEmpty(translation))
						{
							return translation;
						}
					}
				}
			}
			return UnityEngine.Application.productName;
		}

		public static void LocalizeAll(bool Force = false)
		{
			LoadCurrentLanguage();
			if (!UnityEngine.Application.isPlaying)
			{
				DoLocalizeAll(Force);
				return;
			}
			mLocalizeIsScheduledWithForcedValue |= Force;
			if (!mLocalizeIsScheduled)
			{
				CoroutineManager.Start(Coroutine_LocalizeAll());
			}
		}

		private static IEnumerator Coroutine_LocalizeAll()
		{
			mLocalizeIsScheduled = true;
			yield return null;
			mLocalizeIsScheduled = false;
			bool force = mLocalizeIsScheduledWithForcedValue;
			mLocalizeIsScheduledWithForcedValue = false;
			DoLocalizeAll(force);
		}

		private static void DoLocalizeAll(bool Force = false)
		{
			Localize[] array = (Localize[])Resources.FindObjectsOfTypeAll(typeof(Localize));
			int i = 0;
			for (int num = array.Length; i < num; i++)
			{
				array[i].OnLocalize(Force);
			}
			if (LocalizationManager.OnLocalizeEvent != null)
			{
				LocalizationManager.OnLocalizeEvent();
			}
		}

		public static List<string> GetCategories()
		{
			List<string> list = new List<string>();
			int i = 0;
			for (int count = Sources.Count; i < count; i++)
			{
				Sources[i].GetCategories(OnlyMainCategory: false, list);
			}
			return list;
		}

		public static List<string> GetTermsList(string Category = null)
		{
			if (Sources.Count == 0)
			{
				UpdateSources();
			}
			if (Sources.Count == 1)
			{
				return Sources[0].GetTermsList(Category);
			}
			HashSet<string> hashSet = new HashSet<string>();
			int i = 0;
			for (int count = Sources.Count; i < count; i++)
			{
				hashSet.UnionWith(Sources[i].GetTermsList(Category));
			}
			return new List<string>(hashSet);
		}

		public static TermData GetTermData(string term)
		{
			InitializeIfNeeded();
			int i = 0;
			for (int count = Sources.Count; i < count; i++)
			{
				TermData termData = Sources[i].GetTermData(term);
				if (termData != null)
				{
					return termData;
				}
			}
			return null;
		}

		public static TermData GetTermData(string term, out LanguageSourceData source)
		{
			InitializeIfNeeded();
			int i = 0;
			for (int count = Sources.Count; i < count; i++)
			{
				TermData termData = Sources[i].GetTermData(term);
				if (termData != null)
				{
					source = Sources[i];
					return termData;
				}
			}
			source = null;
			return null;
		}
	}
	public abstract class ILocalizeTarget : ScriptableObject
	{
		public abstract bool IsValid(Localize cmp);

		public abstract void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm);

		public abstract void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation);

		public abstract bool CanUseSecondaryTerm();

		public abstract bool AllowMainTermToBeRTL();

		public abstract bool AllowSecondTermToBeRTL();

		public abstract eTermType GetPrimaryTermType(Localize cmp);

		public abstract eTermType GetSecondaryTermType(Localize cmp);
	}
	public abstract class LocalizeTarget<T> : ILocalizeTarget where T : UnityEngine.Object
	{
		public T mTarget;

		public override bool IsValid(Localize cmp)
		{
			if (mTarget != null)
			{
				UnityEngine.Component component = mTarget as UnityEngine.Component;
				if (component != null && component.gameObject != cmp.gameObject)
				{
					mTarget = null;
				}
			}
			if (mTarget == null)
			{
				mTarget = cmp.GetComponent<T>();
			}
			return mTarget != null;
		}
	}
	public abstract class ILocalizeTargetDescriptor
	{
		public string Name;

		public int Priority;

		public abstract bool CanLocalize(Localize cmp);

		public abstract ILocalizeTarget CreateTarget(Localize cmp);

		public abstract Type GetTargetType();
	}
	public abstract class LocalizeTargetDesc<T> : ILocalizeTargetDescriptor where T : ILocalizeTarget
	{
		public override ILocalizeTarget CreateTarget(Localize cmp)
		{
			return ScriptableObject.CreateInstance<T>();
		}

		public override Type GetTargetType()
		{
			return typeof(T);
		}
	}
	public class LocalizeTargetDesc_Type<T, G> : LocalizeTargetDesc<G> where T : UnityEngine.Object where G : LocalizeTarget<T>
	{
		public override bool CanLocalize(Localize cmp)
		{
			return cmp.GetComponent<T>() != null;
		}

		public override ILocalizeTarget CreateTarget(Localize cmp)
		{
			T component = cmp.GetComponent<T>();
			if (component == null)
			{
				return null;
			}
			G val = ScriptableObject.CreateInstance<G>();
			val.mTarget = component;
			return val;
		}
	}
	public class LocalizeTarget_TextMeshPro_Label : LocalizeTarget<TextMeshPro>
	{
		private TextAlignmentOptions mAlignment_RTL = TextAlignmentOptions.Right;

		private TextAlignmentOptions mAlignment_LTR = TextAlignmentOptions.Left;

		private bool mAlignmentWasRTL;

		private bool mInitializeAlignment = true;

		static LocalizeTarget_TextMeshPro_Label()
		{
			AutoRegister();
		}

		[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
		private static void AutoRegister()
		{
			LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Type<TextMeshPro, LocalizeTarget_TextMeshPro_Label>
			{
				Name = "TextMeshPro Label",
				Priority = 100
			});
		}

		public override eTermType GetPrimaryTermType(Localize cmp)
		{
			return eTermType.Text;
		}

		public override eTermType GetSecondaryTermType(Localize cmp)
		{
			return eTermType.Font;
		}

		public override bool CanUseSecondaryTerm()
		{
			return true;
		}

		public override bool AllowMainTermToBeRTL()
		{
			return true;
		}

		public override bool AllowSecondTermToBeRTL()
		{
			return false;
		}

		public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
		{
			primaryTerm = (mTarget ? mTarget.text : null);
			secondaryTerm = ((mTarget.font != null) ? mTarget.font.name : string.Empty);
		}

		public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
		{
			TMP_FontAsset secondaryTranslatedObj = cmp.GetSecondaryTranslatedObj<TMP_FontAsset>(ref mainTranslation, ref secondaryTranslation);
			if (secondaryTranslatedObj != null)
			{
				SetFont(mTarget, secondaryTranslatedObj);
			}
			else
			{
				Material secondaryTranslatedObj2 = cmp.GetSecondaryTranslatedObj<Material>(ref mainTranslation, ref secondaryTranslation);
				if (secondaryTranslatedObj2 != null && mTarget.fontMaterial != secondaryTranslatedObj2)
				{
					if (!secondaryTranslatedObj2.name.StartsWith(mTarget.font.name, StringComparison.Ordinal))
					{
						secondaryTranslatedObj = GetTMPFontFromMaterial(cmp, secondaryTranslation.EndsWith(secondaryTranslatedObj2.name, StringComparison.Ordinal) ? secondaryTranslation : secondaryTranslatedObj2.name);
						if (secondaryTranslatedObj != null)
						{
							SetFont(mTarget, secondaryTranslatedObj);
						}
					}
					SetMaterial(mTarget, secondaryTranslatedObj2);
				}
			}
			if (mInitializeAlignment)
			{
				mInitializeAlignment = false;
				mAlignmentWasRTL = LocalizationManager.IsRight2Left;
				InitAlignment_TMPro(mAlignmentWasRTL, mTarget.alignment, out mAlignment_LTR, out mAlignment_RTL);
			}
			else
			{
				InitAlignment_TMPro(mAlignmentWasRTL, mTarget.alignment, out var alignLTR, out var alignRTL);
				if ((mAlignmentWasRTL && mAlignment_RTL != alignRTL) || (!mAlignmentWasRTL && mAlignment_LTR != alignLTR))
				{
					mAlignment_LTR = alignLTR;
					mAlignment_RTL = alignRTL;
				}
				mAlignmentWasRTL = LocalizationManager.IsRight2Left;
			}
			if (mainTranslation == null || !(mTarget.text != mainTranslation))
			{
				return;
			}
			if (mainTranslation != null && cmp.CorrectAlignmentForRTL)
			{
				mTarget.alignment = (LocalizationManager.IsRight2Left ? mAlignment_RTL : mAlignment_LTR);
				mTarget.isRightToLeftText = LocalizationManager.IsRight2Left;
				if (LocalizationManager.IsRight2Left)
				{
					mainTranslation = I2Utils.ReverseText(mainTranslation);
				}
			}
			mTarget.text = mainTranslation;
		}

		internal static TMP_FontAsset GetTMPFontFromMaterial(Localize cmp, string matName)
		{
			string text = " .\\/-[]()";
			int num = matName.Length - 1;
			while (num > 0)
			{
				while (num > 0 && text.IndexOf(matName[num]) >= 0)
				{
					num--;
				}
				if (num <= 0)
				{
					break;
				}
				string translation = matName.Substring(0, num + 1);
				TMP_FontAsset @object = cmp.GetObject<TMP_FontAsset>(translation);
				if (@object != null)
				{
					return @object;
				}
				while (num > 0 && text.IndexOf(matName[num]) < 0)
				{
					num--;
				}
			}
			return null;
		}

		internal static void InitAlignment_TMPro(bool isRTL, TextAlignmentOptions alignment, out TextAlignmentOptions alignLTR, out TextAlignmentOptions alignRTL)
		{
			alignLTR = (alignRTL = alignment);
			if (isRTL)
			{
				switch (alignment)
				{
				case TextAlignmentOptions.TopRight:
					alignLTR = TextAlignmentOptions.TopLeft;
					break;
				case TextAlignmentOptions.Right:
					alignLTR = TextAlignmentOptions.Left;
					break;
				case TextAlignmentOptions.BottomRight:
					alignLTR = TextAlignmentOptions.BottomLeft;
					break;
				case TextAlignmentOptions.BaselineRight:
					alignLTR = TextAlignmentOptions.BaselineLeft;
					break;
				case TextAlignmentOptions.MidlineRight:
					alignLTR = TextAlignmentOptions.MidlineLeft;
					break;
				case TextAlignmentOptions.CaplineRight:
					alignLTR = TextAlignmentOptions.CaplineLeft;
					break;
				case TextAlignmentOptions.TopLeft:
					alignLTR = TextAlignmentOptions.TopRight;
					break;
				case TextAlignmentOptions.Left:
					alignLTR = TextAlignmentOptions.Right;
					break;
				case TextAlignmentOptions.BottomLeft:
					alignLTR = TextAlignmentOptions.BottomRight;
					break;
				case TextAlignmentOptions.BaselineLeft:
					alignLTR = TextAlignmentOptions.BaselineRight;
					break;
				case TextAlignmentOptions.MidlineLeft:
					alignLTR = TextAlignmentOptions.MidlineRight;
					break;
				case TextAlignmentOptions.CaplineLeft:
					alignLTR = TextAlignmentOptions.CaplineRight;
					break;
				}
			}
			else
			{
				switch (alignment)
				{
				case TextAlignmentOptions.TopRight:
					alignRTL = TextAlignmentOptions.TopLeft;
					break;
				case TextAlignmentOptions.Right:
					alignRTL = TextAlignmentOptions.Left;
					break;
				case TextAlignmentOptions.BottomRight:
					alignRTL = TextAlignmentOptions.BottomLeft;
					break;
				case TextAlignmentOptions.BaselineRight:
					alignRTL = TextAlignmentOptions.BaselineLeft;
					break;
				case TextAlignmentOptions.MidlineRight:
					alignRTL = TextAlignmentOptions.MidlineLeft;
					break;
				case TextAlignmentOptions.CaplineRight:
					alignRTL = TextAlignmentOptions.CaplineLeft;
					break;
				case TextAlignmentOptions.TopLeft:
					alignRTL = TextAlignmentOptions.TopRight;
					break;
				case TextAlignmentOptions.Left:
					alignRTL = TextAlignmentOptions.Right;
					break;
				case TextAlignmentOptions.BottomLeft:
					alignRTL = TextAlignmentOptions.BottomRight;
					break;
				case TextAlignmentOptions.BaselineLeft:
					alignRTL = TextAlignmentOptions.BaselineRight;
					break;
				case TextAlignmentOptions.MidlineLeft:
					alignRTL = TextAlignmentOptions.MidlineRight;
					break;
				case TextAlignmentOptions.CaplineLeft:
					alignRTL = TextAlignmentOptions.CaplineRight;
					break;
				}
			}
		}

		internal static void SetFont(TMP_Text label, TMP_FontAsset newFont)
		{
			if (label.font != newFont)
			{
				label.font = newFont;
			}
			if (label.linkedTextComponent != null)
			{
				SetFont(label.linkedTextComponent, newFont);
			}
		}

		internal static void SetMaterial(TMP_Text label, Material newMat)
		{
			if (label.fontSharedMaterial != newMat)
			{
				label.fontSharedMaterial = newMat;
			}
			if (label.linkedTextComponent != null)
			{
				SetMaterial(label.linkedTextComponent, newMat);
			}
		}
	}
	public class LocalizeTarget_TextMeshPro_UGUI : LocalizeTarget<TextMeshProUGUI>
	{
		public TextAlignmentOptions mAlignment_RTL = TextAlignmentOptions.Right;

		public TextAlignmentOptions mAlignment_LTR = TextAlignmentOptions.Left;

		public bool mAlignmentWasRTL;

		public bool mInitializeAlignment = true;

		static LocalizeTarget_TextMeshPro_UGUI()
		{
			AutoRegister();
		}

		[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
		private static void AutoRegister()
		{
			LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Type<TextMeshProUGUI, LocalizeTarget_TextMeshPro_UGUI>
			{
				Name = "TextMeshPro UGUI",
				Priority = 100
			});
		}

		public override eTermType GetPrimaryTermType(Localize cmp)
		{
			return eTermType.Text;
		}

		public override eTermType GetSecondaryTermType(Localize cmp)
		{
			return eTermType.TextMeshPFont;
		}

		public override bool CanUseSecondaryTerm()
		{
			return true;
		}

		public override bool AllowMainTermToBeRTL()
		{
			return true;
		}

		public override bool AllowSecondTermToBeRTL()
		{
			return false;
		}

		public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
		{
			primaryTerm = (mTarget ? mTarget.text : null);
			secondaryTerm = ((mTarget.font != null) ? mTarget.font.name : string.Empty);
		}

		public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
		{
			TMP_FontAsset secondaryTranslatedObj = cmp.GetSecondaryTranslatedObj<TMP_FontAsset>(ref mainTranslation, ref secondaryTranslation);
			if (secondaryTranslatedObj != null)
			{
				LocalizeTarget_TextMeshPro_Label.SetFont(mTarget, secondaryTranslatedObj);
			}
			else
			{
				Material secondaryTranslatedObj2 = cmp.GetSecondaryTranslatedObj<Material>(ref mainTranslation, ref secondaryTranslation);
				if (secondaryTranslatedObj2 != null && mTarget.fontMaterial != secondaryTranslatedObj2)
				{
					if (!secondaryTranslatedObj2.name.StartsWith(mTarget.font.name, StringComparison.Ordinal))
					{
						secondaryTranslatedObj = LocalizeTarget_TextMeshPro_Label.GetTMPFontFromMaterial(cmp, secondaryTranslation.EndsWith(secondaryTranslatedObj2.name, StringComparison.Ordinal) ? secondaryTranslation : secondaryTranslatedObj2.name);
						if (secondaryTranslatedObj != null)
						{
							LocalizeTarget_TextMeshPro_Label.SetFont(mTarget, secondaryTranslatedObj);
						}
					}
					LocalizeTarget_TextMeshPro_Label.SetMaterial(mTarget, secondaryTranslatedObj2);
				}
			}
			if (mInitializeAlignment)
			{
				mInitializeAlignment = false;
				mAlignmentWasRTL = LocalizationManager.IsRight2Left;
				LocalizeTarget_TextMeshPro_Label.InitAlignment_TMPro(mAlignmentWasRTL, mTarget.alignment, out mAlignment_LTR, out mAlignment_RTL);
			}
			else
			{
				LocalizeTarget_TextMeshPro_Label.InitAlignment_TMPro(mAlignmentWasRTL, mTarget.alignment, out var alignLTR, out var alignRTL);
				if ((mAlignmentWasRTL && mAlignment_RTL != alignRTL) || (!mAlignmentWasRTL && mAlignment_LTR != alignLTR))
				{
					mAlignment_LTR = alignLTR;
					mAlignment_RTL = alignRTL;
				}
				mAlignmentWasRTL = LocalizationManager.IsRight2Left;
			}
			if (mainTranslation == null || !(mTarget.text != mainTranslation))
			{
				return;
			}
			if (mainTranslation != null && cmp.CorrectAlignmentForRTL)
			{
				mTarget.alignment = (LocalizationManager.IsRight2Left ? mAlignment_RTL : mAlignment_LTR);
				mTarget.isRightToLeftText = LocalizationManager.IsRight2Left;
				if (LocalizationManager.IsRight2Left)
				{
					mainTranslation = I2Utils.ReverseText(mainTranslation);
				}
			}
			mTarget.text = mainTranslation;
		}
	}
	public class LocalizeTarget_UnityStandard_AudioSource : LocalizeTarget<AudioSource>
	{
		static LocalizeTarget_UnityStandard_AudioSource()
		{
			AutoRegister();
		}

		[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
		private static void AutoRegister()
		{
			LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Type<AudioSource, LocalizeTarget_UnityStandard_AudioSource>
			{
				Name = "AudioSource",
				Priority = 100
			});
		}

		public override eTermType GetPrimaryTermType(Localize cmp)
		{
			return eTermType.AudioClip;
		}

		public override eTermType GetSecondaryTermType(Localize cmp)
		{
			return eTermType.Text;
		}

		public override bool CanUseSecondaryTerm()
		{
			return false;
		}

		public override bool AllowMainTermToBeRTL()
		{
			return false;
		}

		public override bool AllowSecondTermToBeRTL()
		{
			return false;
		}

		public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
		{
			primaryTerm = (mTarget.clip ? mTarget.clip.name : string.Empty);
			secondaryTerm = null;
		}

		public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
		{
			bool num = (mTarget.isPlaying || mTarget.loop) && UnityEngine.Application.isPlaying;
			AudioClip clip = mTarget.clip;
			AudioClip audioClip = cmp.FindTranslatedObject<AudioClip>(mainTranslation);
			if (clip != audioClip)
			{
				mTarget.clip = audioClip;
			}
			if (num && (bool)mTarget.clip)
			{
				mTarget.Play();
			}
		}
	}
	public class LocalizeTargetDesc_Child : LocalizeTargetDesc<LocalizeTarget_UnityStandard_Child>
	{
		public override bool CanLocalize(Localize cmp)
		{
			return cmp.transform.childCount > 1;
		}
	}
	public class LocalizeTarget_UnityStandard_Child : LocalizeTarget<GameObject>
	{
		static LocalizeTarget_UnityStandard_Child()
		{
			AutoRegister();
		}

		[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
		private static void AutoRegister()
		{
			LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Child
			{
				Name = "Child",
				Priority = 200
			});
		}

		public override bool IsValid(Localize cmp)
		{
			return cmp.transform.childCount > 1;
		}

		public override eTermType GetPrimaryTermType(Localize cmp)
		{
			return eTermType.GameObject;
		}

		public override eTermType GetSecondaryTermType(Localize cmp)
		{
			return eTermType.Text;
		}

		public override bool CanUseSecondaryTerm()
		{
			return false;
		}

		public override bool AllowMainTermToBeRTL()
		{
			return false;
		}

		public override bool AllowSecondTermToBeRTL()
		{
			return false;
		}

		public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
		{
			primaryTerm = cmp.name;
			secondaryTerm = null;
		}

		public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
		{
			if (!string.IsNullOrEmpty(mainTranslation))
			{
				Transform transform = cmp.transform;
				string text = mainTranslation;
				int num = mainTranslation.LastIndexOfAny(LanguageSourceData.CategorySeparators);
				if (num >= 0)
				{
					text = text.Substring(num + 1);
				}
				for (int i = 0; i < transform.childCount; i++)
				{
					Transform child = transform.GetChild(i);
					child.gameObject.SetActive(child.name == text);
				}
			}
		}
	}
	public class LocalizeTarget_UnityStandard_MeshRenderer : LocalizeTarget<MeshRenderer>
	{
		static LocalizeTarget_UnityStandard_MeshRenderer()
		{
			AutoRegister();
		}

		[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
		private static void AutoRegister()
		{
			LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Type<MeshRenderer, LocalizeTarget_UnityStandard_MeshRenderer>
			{
				Name = "MeshRenderer",
				Priority = 800
			});
		}

		public override eTermType GetPrimaryTermType(Localize cmp)
		{
			return eTermType.Mesh;
		}

		public override eTermType GetSecondaryTermType(Localize cmp)
		{
			return eTermType.Material;
		}

		public override bool CanUseSecondaryTerm()
		{
			return true;
		}

		public override bool AllowMainTermToBeRTL()
		{
			return false;
		}

		public override bool AllowSecondTermToBeRTL()
		{
			return false;
		}

		public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
		{
			if (mTarget == null)
			{
				primaryTerm = (secondaryTerm = null);
			}
			else
			{
				MeshFilter component = mTarget.GetComponent<MeshFilter>();
				if (component == null || component.sharedMesh == null)
				{
					primaryTerm = null;
				}
				else
				{
					primaryTerm = component.sharedMesh.name;
				}
			}
			if (mTarget == null || mTarget.sharedMaterial == null)
			{
				secondaryTerm = null;
			}
			else
			{
				secondaryTerm = mTarget.sharedMaterial.name;
			}
		}

		public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
		{
			Material secondaryTranslatedObj = cmp.GetSecondaryTranslatedObj<Material>(ref mainTranslation, ref secondaryTranslation);
			if (secondaryTranslatedObj != null && mTarget.sharedMaterial != secondaryTranslatedObj)
			{
				mTarget.material = secondaryTranslatedObj;
			}
			Mesh mesh = cmp.FindTranslatedObject<Mesh>(mainTranslation);
			MeshFilter component = mTarget.GetComponent<MeshFilter>();
			if (mesh != null && component.sharedMesh != mesh)
			{
				component.mesh = mesh;
			}
		}
	}
	public class LocalizeTargetDesc_Prefab : LocalizeTargetDesc<LocalizeTarget_UnityStandard_Prefab>
	{
		public override bool CanLocalize(Localize cmp)
		{
			return true;
		}
	}
	public class LocalizeTarget_UnityStandard_Prefab : LocalizeTarget<GameObject>
	{
		static LocalizeTarget_UnityStandard_Prefab()
		{
			AutoRegister();
		}

		[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
		private static void AutoRegister()
		{
			LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Prefab
			{
				Name = "Prefab",
				Priority = 250
			});
		}

		public override bool IsValid(Localize cmp)
		{
			return true;
		}

		public override eTermType GetPrimaryTermType(Localize cmp)
		{
			return eTermType.GameObject;
		}

		public override eTermType GetSecondaryTermType(Localize cmp)
		{
			return eTermType.Text;
		}

		public override bool CanUseSecondaryTerm()
		{
			return false;
		}

		public override bool AllowMainTermToBeRTL()
		{
			return false;
		}

		public override bool AllowSecondTermToBeRTL()
		{
			return false;
		}

		public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
		{
			primaryTerm = cmp.name;
			secondaryTerm = null;
		}

		public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
		{
			if (string.IsNullOrEmpty(mainTranslation) || ((bool)mTarget && mTarget.name == mainTranslation))
			{
				return;
			}
			Transform transform = cmp.transform;
			string text = mainTranslation;
			int num = mainTranslation.LastIndexOfAny(LanguageSourceData.CategorySeparators);
			if (num >= 0)
			{
				text = text.Substring(num + 1);
			}
			Transform transform2 = InstantiateNewPrefab(cmp, mainTranslation);
			if (transform2 == null)
			{
				return;
			}
			transform2.name = text;
			for (int num2 = transform.childCount - 1; num2 >= 0; num2--)
			{
				Transform child = transform.GetChild(num2);
				if (child != transform2)
				{
					UnityEngine.Object.Destroy(child.gameObject);
				}
			}
		}

		private Transform InstantiateNewPrefab(Localize cmp, string mainTranslation)
		{
			GameObject gameObject = cmp.FindTranslatedObject<GameObject>(mainTranslation);
			if (gameObject == null)
			{
				return null;
			}
			GameObject gameObject2 = mTarget;
			mTarget = UnityEngine.Object.Instantiate(gameObject);
			if (mTarget == null)
			{
				return null;
			}
			Transform transform = cmp.transform;
			Transform transform2 = mTarget.transform;
			transform2.SetParent(transform);
			Transform transform3 = (gameObject2 ? gameObject2.transform : transform);
			transform2.rotation = transform3.rotation;
			transform2.position = transform3.position;
			return transform2;
		}
	}
	public class LocalizeTarget_UnityStandard_SpriteRenderer : LocalizeTarget<SpriteRenderer>
	{
		static LocalizeTarget_UnityStandard_SpriteRenderer()
		{
			AutoRegister();
		}

		[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
		private static void AutoRegister()
		{
			LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Type<SpriteRenderer, LocalizeTarget_UnityStandard_SpriteRenderer>
			{
				Name = "SpriteRenderer",
				Priority = 100
			});
		}

		public override eTermType GetPrimaryTermType(Localize cmp)
		{
			return eTermType.Sprite;
		}

		public override eTermType GetSecondaryTermType(Localize cmp)
		{
			return eTermType.Text;
		}

		public override bool CanUseSecondaryTerm()
		{
			return false;
		}

		public override bool AllowMainTermToBeRTL()
		{
			return false;
		}

		public override bool AllowSecondTermToBeRTL()
		{
			return false;
		}

		public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
		{
			primaryTerm = ((mTarget.sprite != null) ? mTarget.sprite.name : string.Empty);
			secondaryTerm = null;
		}

		public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
		{
			Sprite sprite = mTarget.sprite;
			if (sprite == null || sprite.name != mainTranslation)
			{
				mTarget.sprite = cmp.FindTranslatedObject<Sprite>(mainTranslation);
			}
		}
	}
	public class LocalizeTarget_UnityStandard_TextMesh : LocalizeTarget<TextMesh>
	{
		private TextAlignment mAlignment_RTL = TextAlignment.Right;

		private TextAlignment mAlignment_LTR;

		private bool mAlignmentWasRTL;

		private bool mInitializeAlignment = true;

		static LocalizeTarget_UnityStandard_TextMesh()
		{
			AutoRegister();
		}

		[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
		private static void AutoRegister()
		{
			LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Type<TextMesh, LocalizeTarget_UnityStandard_TextMesh>
			{
				Name = "TextMesh",
				Priority = 100
			});
		}

		public override eTermType GetPrimaryTermType(Localize cmp)
		{
			return eTermType.Text;
		}

		public override eTermType GetSecondaryTermType(Localize cmp)
		{
			return eTermType.Font;
		}

		public override bool CanUseSecondaryTerm()
		{
			return true;
		}

		public override bool AllowMainTermToBeRTL()
		{
			return true;
		}

		public override bool AllowSecondTermToBeRTL()
		{
			return false;
		}

		public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
		{
			primaryTerm = (mTarget ? mTarget.text : null);
			secondaryTerm = ((string.IsNullOrEmpty(Secondary) && mTarget.font != null) ? mTarget.font.name : null);
		}

		public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
		{
			Font secondaryTranslatedObj = cmp.GetSecondaryTranslatedObj<Font>(ref mainTranslation, ref secondaryTranslation);
			if (secondaryTranslatedObj != null && mTarget.font != secondaryTranslatedObj)
			{
				mTarget.font = secondaryTranslatedObj;
			}
			if (mInitializeAlignment)
			{
				mInitializeAlignment = false;
				mAlignment_LTR = (mAlignment_RTL = mTarget.alignment);
				if (LocalizationManager.IsRight2Left && mAlignment_RTL == TextAlignment.Right)
				{
					mAlignment_LTR = TextAlignment.Left;
				}
				if (!LocalizationManager.IsRight2Left && mAlignment_LTR == TextAlignment.Left)
				{
					mAlignment_RTL = TextAlignment.Right;
				}
			}
			if (mainTranslation != null && mTarget.text != mainTranslation)
			{
				if (cmp.CorrectAlignmentForRTL && mTarget.alignment != TextAlignment.Center)
				{
					mTarget.alignment = (LocalizationManager.IsRight2Left ? mAlignment_RTL : mAlignment_LTR);
				}
				mTarget.font.RequestCharactersInTexture(mainTranslation);
				mTarget.text = mainTranslation;
			}
		}
	}
	public class LocalizeTarget_UnityUI_Image : LocalizeTarget<Image>
	{
		static LocalizeTarget_UnityUI_Image()
		{
			AutoRegister();
		}

		[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
		private static void AutoRegister()
		{
			LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Type<Image, LocalizeTarget_UnityUI_Image>
			{
				Name = "Image",
				Priority = 100
			});
		}

		public override bool CanUseSecondaryTerm()
		{
			return false;
		}

		public override bool AllowMainTermToBeRTL()
		{
			return false;
		}

		public override bool AllowSecondTermToBeRTL()
		{
			return false;
		}

		public override eTermType GetPrimaryTermType(Localize cmp)
		{
			if (!(mTarget.sprite == null))
			{
				return eTermType.Sprite;
			}
			return eTermType.Texture;
		}

		public override eTermType GetSecondaryTermType(Localize cmp)
		{
			return eTermType.Text;
		}

		public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
		{
			primaryTerm = (mTarget.mainTexture ? mTarget.mainTexture.name : "");
			if (mTarget.sprite != null && mTarget.sprite.name != primaryTerm)
			{
				primaryTerm = primaryTerm + "." + mTarget.sprite.name;
			}
			secondaryTerm = null;
		}

		public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
		{
			Sprite sprite = mTarget.sprite;
			if (sprite == null || sprite.name != mainTranslation)
			{
				mTarget.sprite = cmp.FindTranslatedObject<Sprite>(mainTranslation);
			}
		}
	}
	public class LocalizeTarget_UnityUI_RawImage : LocalizeTarget<RawImage>
	{
		static LocalizeTarget_UnityUI_RawImage()
		{
			AutoRegister();
		}

		[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
		private static void AutoRegister()
		{
			LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Type<RawImage, LocalizeTarget_UnityUI_RawImage>
			{
				Name = "RawImage",
				Priority = 100
			});
		}

		public override eTermType GetPrimaryTermType(Localize cmp)
		{
			return eTermType.Texture;
		}

		public override eTermType GetSecondaryTermType(Localize cmp)
		{
			return eTermType.Text;
		}

		public override bool CanUseSecondaryTerm()
		{
			return false;
		}

		public override bool AllowMainTermToBeRTL()
		{
			return false;
		}

		public override bool AllowSecondTermToBeRTL()
		{
			return false;
		}

		public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
		{
			primaryTerm = (mTarget.mainTexture ? mTarget.mainTexture.name : "");
			secondaryTerm = null;
		}

		public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
		{
			Texture texture = mTarget.texture;
			if (texture == null || texture.name != mainTranslation)
			{
				mTarget.texture = cmp.FindTranslatedObject<Texture>(mainTranslation);
			}
		}
	}
	public class LocalizeTarget_UnityUI_Text : LocalizeTarget<Text>
	{
		private TextAnchor mAlignment_RTL = TextAnchor.UpperRight;

		private TextAnchor mAlignment_LTR;

		private bool mAlignmentWasRTL;

		private bool mInitializeAlignment = true;

		static LocalizeTarget_UnityUI_Text()
		{
			AutoRegister();
		}

		[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
		private static void AutoRegister()
		{
			LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Type<Text, LocalizeTarget_UnityUI_Text>
			{
				Name = "Text",
				Priority = 100
			});
		}

		public override eTermType GetPrimaryTermType(Localize cmp)
		{
			return eTermType.Text;
		}

		public override eTermType GetSecondaryTermType(Localize cmp)
		{
			return eTermType.Font;
		}

		public override bool CanUseSecondaryTerm()
		{
			return true;
		}

		public override bool AllowMainTermToBeRTL()
		{
			return true;
		}

		public override bool AllowSecondTermToBeRTL()
		{
			return false;
		}

		public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
		{
			primaryTerm = (mTarget ? mTarget.text : null);
			secondaryTerm = ((mTarget.font != null) ? mTarget.font.name : string.Empty);
		}

		public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
		{
			Font secondaryTranslatedObj = cmp.GetSecondaryTranslatedObj<Font>(ref mainTranslation, ref secondaryTranslation);
			if (secondaryTranslatedObj != null && secondaryTranslatedObj != mTarget.font)
			{
				mTarget.font = secondaryTranslatedObj;
			}
			if (mInitializeAlignment)
			{
				mInitializeAlignment = false;
				mAlignmentWasRTL = LocalizationManager.IsRight2Left;
				InitAlignment(mAlignmentWasRTL, mTarget.alignment, out mAlignment_LTR, out mAlignment_RTL);
			}
			else
			{
				InitAlignment(mAlignmentWasRTL, mTarget.alignment, out var alignLTR, out var alignRTL);
				if ((mAlignmentWasRTL && mAlignment_RTL != alignRTL) || (!mAlignmentWasRTL && mAlignment_LTR != alignLTR))
				{
					mAlignment_LTR = alignLTR;
					mAlignment_RTL = alignRTL;
				}
				mAlignmentWasRTL = LocalizationManager.IsRight2Left;
			}
			if (mainTranslation != null && mTarget.text != mainTranslation)
			{
				if (cmp.CorrectAlignmentForRTL)
				{
					mTarget.alignment = (LocalizationManager.IsRight2Left ? mAlignment_RTL : mAlignment_LTR);
				}
				mTarget.text = mainTranslation;
				mTarget.SetVerticesDirty();
			}
		}

		private void InitAlignment(bool isRTL, TextAnchor alignment, out TextAnchor alignLTR, out TextAnchor alignRTL)
		{
			alignLTR = (alignRTL = alignment);
			if (isRTL)
			{
				switch (alignment)
				{
				case TextAnchor.UpperRight:
					alignLTR = TextAnchor.UpperLeft;
					break;
				case TextAnchor.MiddleRight:
					alignLTR = TextAnchor.MiddleLeft;
					break;
				case TextAnchor.LowerRight:
					alignLTR = TextAnchor.LowerLeft;
					break;
				case TextAnchor.UpperLeft:
					alignLTR = TextAnchor.UpperRight;
					break;
				case TextAnchor.MiddleLeft:
					alignLTR = TextAnchor.MiddleRight;
					break;
				case TextAnchor.LowerLeft:
					alignLTR = TextAnchor.LowerRight;
					break;
				case TextAnchor.UpperCenter:
				case TextAnchor.MiddleCenter:
				case TextAnchor.LowerCenter:
					break;
				}
			}
			else
			{
				switch (alignment)
				{
				case TextAnchor.UpperRight:
					alignRTL = TextAnchor.UpperLeft;
					break;
				case TextAnchor.MiddleRight:
					alignRTL = TextAnchor.MiddleLeft;
					break;
				case TextAnchor.LowerRight:
					alignRTL = TextAnchor.LowerLeft;
					break;
				case TextAnchor.UpperLeft:
					alignRTL = TextAnchor.UpperRight;
					break;
				case TextAnchor.MiddleLeft:
					alignRTL = TextAnchor.MiddleRight;
					break;
				case TextAnchor.LowerLeft:
					alignRTL = TextAnchor.LowerRight;
					break;
				case TextAnchor.UpperCenter:
				case TextAnchor.MiddleCenter:
				case TextAnchor.LowerCenter:
					break;
				}
			}
		}
	}
	public enum eTermType
	{
		Text,
		Font,
		Texture,
		AudioClip,
		GameObject,
		Sprite,
		Material,
		Child,
		Mesh,
		TextMeshPFont,
		Object
	}
	public enum TranslationFlag : byte
	{
		Normal = 1,
		AutoTranslated
	}
	[Serializable]
	public class TermData
	{
		public string Term = string.Empty;

		public eTermType TermType;

		[NonSerialized]
		public string Description;

		public string[] Languages = new string[0];

		public byte[] Flags = new byte[0];

		[SerializeField]
		private string[] Languages_Touch;

		public string GetTranslation(int idx, string specialization = null, bool editMode = false)
		{
			string text = Languages[idx];
			if (text != null)
			{
				text = SpecializationManager.GetSpecializedText(text, specialization);
				if (!editMode)
				{
					text = text.Replace("[i2nt]", "").Replace("[/i2nt]", "");
				}
			}
			return text;
		}

		public void SetTranslation(int idx, string translation, string specialization = null)
		{
			Languages[idx] = SpecializationManager.SetSpecializedText(Languages[idx], translation, specialization);
		}

		public void RemoveSpecialization(string specialization)
		{
			for (int i = 0; i < Languages.Length; i++)
			{
				RemoveSpecialization(i, specialization);
			}
		}

		public void RemoveSpecialization(int idx, string specialization)
		{
			string text = Languages[idx];
			if (!(specialization == "Any") && text.Contains("[i2s_" + specialization + "]"))
			{
				Dictionary<string, string> specializations = SpecializationManager.GetSpecializations(text);
				specializations.Remove(specialization);
				Languages[idx] = SpecializationManager.SetSpecializedText(specializations);
			}
		}

		public bool IsAutoTranslated(int idx, bool IsTouch)
		{
			return (Flags[idx] & 2) > 0;
		}

		public void Validate()
		{
			int num = Mathf.Max(Languages.Length, Flags.Length);
			if (Languages.Length != num)
			{
				Array.Resize(ref Languages, num);
			}
			if (Flags.Length != num)
			{
				Array.Resize(ref Flags, num);
			}
			if (Languages_Touch == null)
			{
				return;
			}
			for (int i = 0; i < Mathf.Min(Languages_Touch.Length, num); i++)
			{
				if (string.IsNullOrEmpty(Languages[i]) && !string.IsNullOrEmpty(Languages_Touch[i]))
				{
					Languages[i] = Languages_Touch[i];
					Languages_Touch[i] = null;
				}
			}
			Languages_Touch = null;
		}

		public bool IsTerm(string name, bool allowCategoryMistmatch)
		{
			if (!allowCategoryMistmatch)
			{
				return name == Term;
			}
			return name == LanguageSourceData.GetKeyFromFullTerm(Term);
		}

		public bool HasSpecializations()
		{
			for (int i = 0; i < Languages.Length; i++)
			{
				if (!string.IsNullOrEmpty(Languages[i]) && Languages[i].Contains("[i2s_"))
				{
					return true;
				}
			}
			return false;
		}

		public List<string> GetAllSpecializations()
		{
			List<string> list = new List<string>();
			for (int i = 0; i < Languages.Length; i++)
			{
				SpecializationManager.AppendSpecializations(Languages[i], list);
			}
			return list;
		}
	}
	public class TermsPopup : PropertyAttribute
	{
		public string Filter { get; private set; }

		public TermsPopup(string filter = "")
		{
			Filter = filter;
		}
	}
	public class AutoChangeCultureInfo : MonoBehaviour
	{
		public void Start()
		{
			LocalizationManager.EnableChangingCultureInfo(bEnable: true);
		}
	}
	public class CoroutineManager : MonoBehaviour
	{
		private static CoroutineManager mInstance;

		private static CoroutineManager pInstance
		{
			get
			{
				if (mInstance == null)
				{
					GameObject gameObject = new GameObject("_Coroutiner");
					gameObject.hideFlags = HideFlags.HideAndDontSave;
					mInstance = gameObject.AddComponent<CoroutineManager>();
					if (UnityEngine.Application.isPlaying)
					{
						UnityEngine.Object.DontDestroyOnLoad(gameObject);
					}
				}
				return mInstance;
			}
		}

		private void Awake()
		{
			if (UnityEngine.Application.isPlaying)
			{
				UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
			}
		}

		public static Coroutine Start(IEnumerator coroutine)
		{
			return pInstance.StartCoroutine(coroutine);
		}
	}
	[AddComponentMenu("I2/Localization/I2 Localize Callback")]
	public class CustomLocalizeCallback : MonoBehaviour
	{
		public UnityEvent _OnLocalize = new UnityEvent();

		public void OnEnable()
		{
			LocalizationManager.OnLocalizeEvent -= OnLocalize;
			LocalizationManager.OnLocalizeEvent += OnLocalize;
		}

		public void OnDisable()
		{
			LocalizationManager.OnLocalizeEvent -= OnLocalize;
		}

		public void OnLocalize()
		{
			_OnLocalize.Invoke();
		}
	}
	public class HindiFixer
	{
		internal static string Fix(string text)
		{
			char[] array = text.ToCharArray();
			bool flag = false;
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i] == '\u093f' && !char.IsWhiteSpace(array[i - 1]) && array[i - 1] != 0)
				{
					array[i] = array[i - 1];
					array[i - 1] = '\u093f';
					flag = true;
				}
				if (i != array.Length - 1)
				{
					if (array[i] == '' && array[i + 1] == '\u093c')
					{
						array[i] = '';
						array[i + 1] = '\0';
						flag = true;
					}
					if (array[i] == '\u0943' && array[i + 1] == '\u093c')
					{
						array[i] = '\u0944';
						array[i + 1] = '\0';
						flag = true;
					}
					if (array[i] == '\u0901' && array[i + 1] == '\u093c')
					{
						array[i] = '';
						array[i + 1] = '\0';
						flag = true;
					}
					if (array[i] == '' && array[i + 1] == '\u093c')
					{
						array[i] = '';
						array[i + 1] = '\0';
						flag = true;
					}
					if (array[i] == '' && array[i + 1] == '\u093c')
					{
						array[i] = '';
						array[i + 1] = '\0';
						flag = true;
					}
					if (array[i] == '\u093f' && array[i + 1] == '\u093c')
					{
						array[i] = '\u0962';
						array[i + 1] = '\0';
						flag = true;
					}
					if (array[i] == '\u0940' && array[i + 1] == '\u093c')
					{
						array[i] = '\u0963';
						array[i + 1] = '\0';
						flag = true;
					}
					if (array[i] == '' && array[i + 1] == '\u093c')
					{
						array[i] = '';
						array[i + 1] = '\0';
						flag = true;
					}
				}
			}
			if (!flag)
			{
				return text;
			}
			string text2 = new string(array.Where((char x) => x != '\0').ToArray());
			if (text2 == text)
			{
				return text2;
			}
			text = text2;
			return text;
		}
	}
	public static class I2Utils
	{
		public const string ValidChars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_";

		public const string NumberChars = "0123456789";

		public const string ValidNameSymbols = ".-_$#@*()[]{}+:?!&',^=<>~`";

		public static string ReverseText(string source)
		{
			int length = source.Length;
			char[] array = new char[length];
			for (int i = 0; i < length; i++)
			{
				array[length - 1 - i] = source[i];
			}
			return new string(array);
		}

		public static string RemoveNonASCII(string text, bool allowCategory = false)
		{
			if (string.IsNullOrEmpty(text))
			{
				return text;
			}
			int num = 0;
			char[] array = new char[text.Length];
			bool flag = false;
			char[] array2 = text.Trim().ToCharArray();
			foreach (char c in array2)
			{
				char c2 = ' ';
				if ((allowCategory && (c == '\\' || c == '"' || c == '/')) || char.IsLetterOrDigit(c) || ".-_$#@*()[]{}+:?!&',^=<>~`".IndexOf(c) >= 0)
				{
					c2 = c;
				}
				if (char.IsWhiteSpace(c2))
				{
					if (!flag)
					{
						if (num > 0)
						{
							array[num++] = ' ';
						}
						flag = true;
					}
				}
				else
				{
					flag = false;
					array[num++] = c2;
				}
			}
			return new string(array, 0, num);
		}

		public static string GetValidTermName(string text, bool allowCategory = false)
		{
			if (text == null)
			{
				return null;
			}
			text = RemoveTags(text);
			return RemoveNonASCII(text, allowCategory);
		}

		public static string SplitLine(string line, int maxCharacters)
		{
			if (maxCharacters <= 0 || line.Length < maxCharacters)
			{
				return line;
			}
			char[] array = line.ToCharArray();
			bool flag = true;
			bool flag2 = false;
			int i = 0;
			int num = 0;
			for (; i < array.Length; i++)
			{
				if (flag)
				{
					num++;
					if (array[i] == '\n')
					{
						num = 0;
					}
					if (num >= maxCharacters && char.IsWhiteSpace(array[i]))
					{
						array[i] = '\n';
						flag = false;
						flag2 = false;
					}
				}
				else if (!char.IsWhiteSpace(array[i]))
				{
					flag = true;
					num = 0;
				}
				else if (array[i] != '\n')
				{
					array[i] = '\0';
				}
				else
				{
					if (!flag2)
					{
						array[i] = '\0';
					}
					flag2 = true;
				}
			}
			return new string(array.Where((char c) => c != '\0').ToArray());
		}

		public static bool FindNextTag(string line, int iStart, out int tagStart, out int tagEnd)
		{
			tagStart = -1;
			tagEnd = -1;
			int length = line.Length;
			tagStart = iStart;
			while (tagStart < length && line[tagStart] != '[' && line[tagStart] != '(' && line[tagStart] != '{' && line[tagStart] != '<')
			{
				tagStart++;
			}
			if (tagStart == length)
			{
				return false;
			}
			bool flag = false;
			for (tagEnd = tagStart + 1; tagEnd < length; tagEnd++)
			{
				char c = line[tagEnd];
				if (c == ']' || c == ')' || c == '}' || c == '>')
				{
					if (flag)
					{
						return FindNextTag(line, tagEnd + 1, out tagStart, out tagEnd);
					}
					return true;
				}
				if (c > '')
				{
					flag = true;
				}
			}
			return false;
		}

		public static string RemoveTags(string text)
		{
			return Regex.Replace(text, "\\{\\[(.*?)]}|\\[(.*?)]|\\<(.*?)>", "");
		}

		public static bool RemoveResourcesPath(ref string sPath)
		{
			int num = sPath.IndexOf("\\Resources\\");
			int num2 = sPath.IndexOf("\\Resources/");
			int num3 = sPath.IndexOf("/Resources\\");
			int num4 = sPath.IndexOf("/Resources/");
			int num5 = Mathf.Max(num, num2, num3, num4);
			bool result = false;
			if (num5 >= 0)
			{
				sPath = sPath.Substring(num5 + 11);
				result = true;
			}
			else
			{
				num5 = sPath.LastIndexOfAny(LanguageSourceData.CategorySeparators);
				if (num5 > 0)
				{
					sPath = sPath.Substring(num5 + 1);
				}
			}
			string extension = Path.GetExtension(sPath);
			if (!string.IsNullOrEmpty(extension))
			{
				sPath = sPath.Substring(0, sPath.Length - extension.Length);
			}
			return result;
		}

		public static bool IsPlaying()
		{
			if (UnityEngine.Application.isPlaying)
			{
				return true;
			}
			return false;
		}

		public static string GetPath(this Transform tr)
		{
			Transform parent = tr.parent;
			if (tr == null)
			{
				return tr.name;
			}
			return parent.GetPath() + "/" + tr.name;
		}

		public static Transform FindObject(string objectPath)
		{
			return FindObject(SceneManager.GetActiveScene(), objectPath);
		}

		public static Transform FindObject(Scene scene, string objectPath)
		{
			GameObject[] rootGameObjects = scene.GetRootGameObjects();
			for (int i = 0; i < rootGameObjects.Length; i++)
			{
				Transform transform = rootGameObjects[i].transform;
				if (transform.name == objectPath)
				{
					return transform;
				}
				if (objectPath.StartsWith(transform.name + "/"))
				{
					return FindObject(transform, objectPath.Substring(transform.name.Length + 1));
				}
			}
			return null;
		}

		public static Transform FindObject(Transform root, string objectPath)
		{
			for (int i = 0; i < root.childCount; i++)
			{
				Transform child = root.GetChild(i);
				if (child.name == objectPath)
				{
					return child;
				}
				if (objectPath.StartsWith(child.name + "/"))
				{
					return FindObject(child, objectPath.Substring(child.name.Length + 1));
				}
			}
			return null;
		}

		public static H FindInParents<H>(Transform tr) where H : UnityEngine.Component
		{
			if (!tr)
			{
				return null;
			}
			H component = tr.GetComponent<H>();
			while (!component && (bool)tr)
			{
				component = tr.GetComponent<H>();
				tr = tr.parent;
			}
			return component;
		}

		public static string GetCaptureMatch(Match match)
		{
			for (int num = match.Groups.Count - 1; num >= 0; num--)
			{
				if (match.Groups[num].Success)
				{
					return match.Groups[num].ToString();
				}
			}
			return match.ToString();
		}

		public static void SendWebRequest(UnityWebRequest www)
		{
			www.SendWebRequest();
		}
	}
	public interface ILocalizationParamsManager
	{
		string GetParameterValue(string Param);
	}
	public class LocalizationParamsManager : MonoBehaviour, ILocalizationParamsManager
	{
		[Serializable]
		public struct ParamValue
		{
			public string Name;

			public string Value;
		}

		[SerializeField]
		public List<ParamValue> _Params = new List<ParamValue>();

		public bool _IsGlobalManager;

		public string GetParameterValue(string ParamName)
		{
			if (_Params != null)
			{
				int i = 0;
				for (int count = _Params.Count; i < count; i++)
				{
					if (_Params[i].Name == ParamName)
					{
						return _Params[i].Value;
					}
				}
			}
			return null;
		}

		public void SetParameterValue(string ParamName, string ParamValue, bool localize = true)
		{
			bool flag = false;
			int i = 0;
			for (int count = _Params.Count; i < count; i++)
			{
				if (_Params[i].Name == ParamName)
				{
					ParamValue value = _Params[i];
					value.Value = ParamValue;
					_Params[i] = value;
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				_Params.Add(new ParamValue
				{
					Name = ParamName,
					Value = ParamValue
				});
			}
			if (localize)
			{
				OnLocalize();
			}
		}

		public void OnLocalize()
		{
			Localize component = GetComponent<Localize>();
			if (component != null)
			{
				component.OnLocalize(Force: true);
			}
		}

		public virtual void OnEnable()
		{
			if (_IsGlobalManager)
			{
				DoAutoRegister();
			}
		}

		public void DoAutoRegister()
		{
			if (!LocalizationManager.ParamManagers.Contains(this))
			{
				LocalizationManager.ParamManagers.Add(this);
				LocalizationManager.LocalizeAll(Force: true);
			}
		}

		public void OnDisable()
		{
			LocalizationManager.ParamManagers.Remove(this);
		}
	}
	[Serializable]
	public struct LocalizedString
	{
		public string mTerm;

		public bool mRTL_IgnoreArabicFix;

		public int mRTL_MaxLineLength;

		public bool mRTL_ConvertNumbers;

		public bool m_DontLocalizeParameters;

		public static implicit operator string(LocalizedString s)
		{
			return s.ToString();
		}

		public static implicit operator LocalizedString(string term)
		{
			LocalizedString result = default(LocalizedString);
			result.mTerm = term;
			return result;
		}

		public LocalizedString(LocalizedString str)
		{
			mTerm = str.mTerm;
			mRTL_IgnoreArabicFix = str.mRTL_IgnoreArabicFix;
			mRTL_MaxLineLength = str.mRTL_MaxLineLength;
			mRTL_ConvertNumbers = str.mRTL_ConvertNumbers;
			m_DontLocalizeParameters = str.m_DontLocalizeParameters;
		}

		public override string ToString()
		{
			string translation = LocalizationManager.GetTranslation(mTerm, !mRTL_IgnoreArabicFix, mRTL_MaxLineLength, !mRTL_ConvertNumbers, applyParameters: true);
			LocalizationManager.ApplyLocalizationParams(ref translation, !m_DontLocalizeParameters);
			return translation;
		}
	}
	public class RegisterGlobalParameters : MonoBehaviour, ILocalizationParamsManager
	{
		public virtual void OnEnable()
		{
			if (!LocalizationManager.ParamManagers.Contains(this))
			{
				LocalizationManager.ParamManagers.Add(this);
				LocalizationManager.LocalizeAll(Force: true);
			}
		}

		public virtual void OnDisable()
		{
			LocalizationManager.ParamManagers.Remove(this);
		}

		public virtual string GetParameterValue(string ParamName)
		{
			return null;
		}
	}
	public interface IResourceManager_Bundles
	{
		UnityEngine.Object LoadFromBundle(string path, Type assetType);
	}
	public class ResourceManager : MonoBehaviour
	{
		private static ResourceManager mInstance;

		public List<IResourceManager_Bundles> mBundleManagers = new List<IResourceManager_Bundles>();

		public UnityEngine.Object[] Assets;

		private readonly Dictionary<string, UnityEngine.Object> mResourcesCache = new Dictionary<string, UnityEngine.Object>(StringComparer.Ordinal);

		public static ResourceManager pInstance
		{
			get
			{
				bool flag = mInstance == null;
				if (mInstance == null)
				{
					mInstance = (ResourceManager)UnityEngine.Object.FindObjectOfType(typeof(ResourceManager));
				}
				if (mInstance == null)
				{
					GameObject obj = new GameObject("I2ResourceManager", typeof(ResourceManager));
					obj.hideFlags |= HideFlags.HideAndDontSave;
					mInstance = obj.GetComponent<ResourceManager>();
					SceneManager.sceneLoaded += MyOnLevelWasLoaded;
				}
				if (flag && UnityEngine.Application.isPlaying)
				{
					UnityEngine.Object.DontDestroyOnLoad(mInstance.gameObject);
				}
				return mInstance;
			}
		}

		public static void MyOnLevelWasLoaded(Scene scene, LoadSceneMode mode)
		{
			pInstance.CleanResourceCache();
			LocalizationManager.UpdateSources();
		}

		public T GetAsset<T>(string Name) where T : UnityEngine.Object
		{
			T val = FindAsset(Name) as T;
			if (val != null)
			{
				return val;
			}
			return LoadFromResources<T>(Name);
		}

		private UnityEngine.Object FindAsset(string Name)
		{
			if (Assets != null)
			{
				int i = 0;
				for (int num = Assets.Length; i < num; i++)
				{
					if (Assets[i] != null && Assets[i].name == Name)
					{
						return Assets[i];
					}
				}
			}
			return null;
		}

		public bool HasAsset(UnityEngine.Object Obj)
		{
			if (Assets == null)
			{
				return false;
			}
			return Array.IndexOf(Assets, Obj) >= 0;
		}

		public T LoadFromResources<T>(string Path) where T : UnityEngine.Object
		{
			try
			{
				if (string.IsNullOrEmpty(Path))
				{
					return null;
				}
				if (mResourcesCache.TryGetValue(Path, out var value) && value != null)
				{
					return value as T;
				}
				T val = null;
				if (Path.EndsWith("]", StringComparison.OrdinalIgnoreCase))
				{
					int num = Path.LastIndexOf("[", StringComparison.OrdinalIgnoreCase);
					int length = Path.Length - num - 2;
					string value2 = Path.Substring(num + 1, length);
					Path = Path.Substring(0, num);
					T[] array = Resources.LoadAll<T>(Path);
					int i = 0;
					for (int num2 = array.Length; i < num2; i++)
					{
						if (array[i].name.Equals(value2))
						{
							val = array[i];
							break;
						}
					}
				}
				else
				{
					val = Resources.Load(Path, typeof(T)) as T;
				}
				if (val == null)
				{
					val = LoadFromBundle<T>(Path);
				}
				if (val != null)
				{
					mResourcesCache[Path] = val;
				}
				return val;
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogErrorFormat("Unable to load {0} '{1}'\nERROR: {2}", typeof(T), Path, ex.ToString());
				return null;
			}
		}

		public T LoadFromBundle<T>(string path) where T : UnityEngine.Object
		{
			int i = 0;
			for (int count = mBundleManagers.Count; i < count; i++)
			{
				if (mBundleManagers[i] != null)
				{
					T val = mBundleManagers[i].LoadFromBundle(path, typeof(T)) as T;
					if (val != null)
					{
						return val;
					}
				}
			}
			return null;
		}

		public void CleanResourceCache()
		{
			mResourcesCache.Clear();
			Resources.UnloadUnusedAssets();
			CancelInvoke();
		}
	}
	public class RTLFixer
	{
		public static string Fix(string str)
		{
			return Fix(str, showTashkeel: false, useHinduNumbers: true);
		}

		public static string Fix(string str, bool rtl)
		{
			if (rtl)
			{
				return Fix(str);
			}
			string[] array = str.Split(' ');
			string text = "";
			string text2 = "";
			string[] array2 = array;
			foreach (string text3 in array2)
			{
				if (char.IsLower(text3.ToLower()[text3.Length / 2]))
				{
					text = text + Fix(text2) + text3 + " ";
					text2 = "";
				}
				else
				{
					text2 = text2 + text3 + " ";
				}
			}
			if (text2 != "")
			{
				text += Fix(text2);
			}
			return text;
		}

		public static string Fix(string str, bool showTashkeel, bool useHinduNumbers)
		{
			string text = HindiFixer.Fix(str);
			if (text != str)
			{
				return text;
			}
			RTLFixerTool.showTashkeel = showTashkeel;
			RTLFixerTool.useHinduNumbers = useHinduNumbers;
			if (str.Contains("\n"))
			{
				str = str.Replace("\n", Environment.NewLine);
			}
			if (str.Contains(Environment.NewLine))
			{
				string[] separator = new string[1] { Environment.NewLine };
				string[] array = str.Split(separator, StringSplitOptions.None);
				if (array.Length == 0)
				{
					return RTLFixerTool.FixLine(str);
				}
				if (array.Length == 1)
				{
					return RTLFixerTool.FixLine(str);
				}
				string text2 = RTLFixerTool.FixLine(array[0]);
				int i = 1;
				if (array.Length > 1)
				{
					for (; i < array.Length; i++)
					{
						text2 = text2 + Environment.NewLine + RTLFixerTool.FixLine(array[i]);
					}
				}
				return text2;
			}
			return RTLFixerTool.FixLine(str);
		}
	}
	internal enum IsolatedArabicLetters
	{
		Hamza = 65152,
		Alef = 65165,
		AlefHamza = 65155,
		WawHamza = 65157,
		AlefMaksoor = 65159,
		AlefMaksora = 64508,
		HamzaNabera = 65161,
		Ba = 65167,
		Ta = 65173,
		Tha2 = 65177,
		Jeem = 65181,
		H7aa = 65185,
		Khaa2 = 65189,
		Dal = 65193,
		Thal = 65195,
		Ra2 = 65197,
		Zeen = 65199,
		Seen = 65201,
		Sheen = 65205,
		S9a = 65209,
		Dha = 65213,
		T6a = 65217,
		T6ha = 65221,
		Ain = 65225,
		Gain = 65229,
		Fa = 65233,
		Gaf = 65237,
		Kaf = 65241,
		Lam = 65245,
		Meem = 65249,
		Noon = 65253,
		Ha = 65257,
		Waw = 65261,
		Ya = 65265,
		AlefMad = 65153,
		TaMarboota = 65171,
		PersianPe = 64342,
		PersianChe = 64378,
		PersianZe = 64394,
		PersianGaf = 64402,
		PersianGaf2 = 64398
	}
	internal enum GeneralArabicLetters
	{
		Hamza = 1569,
		Alef = 1575,
		AlefHamza = 1571,
		WawHamza = 1572,
		AlefMaksoor = 1573,
		AlefMagsora = 1609,
		HamzaNabera = 1574,
		Ba = 1576,
		Ta = 1578,
		Tha2 = 1579,
		Jeem = 1580,
		H7aa = 1581,
		Khaa2 = 1582,
		Dal = 1583,
		Thal = 1584,
		Ra2 = 1585,
		Zeen = 1586,
		Seen = 1587,
		Sheen = 1588,
		S9a = 1589,
		Dha = 1590,
		T6a = 1591,
		T6ha = 1592,
		Ain = 1593,
		Gain = 1594,
		Fa = 1601,
		Gaf = 1602,
		Kaf = 1603,
		Lam = 1604,
		Meem = 1605,
		Noon = 1606,
		Ha = 1607,
		Waw = 1608,
		Ya = 1610,
		AlefMad = 1570,
		TaMarboota = 1577,
		PersianPe = 1662,
		PersianChe = 1670,
		PersianZe = 1688,
		PersianGaf = 1711,
		PersianGaf2 = 1705
	}
	internal class ArabicMapping
	{
		public int from;

		public int to;

		public ArabicMapping(int from, int to)
		{
			this.from = from;
			this.to = to;
		}
	}
	internal class ArabicTable
	{
		private static List<ArabicMapping> mapList;

		private static ArabicTable arabicMapper;

		internal static ArabicTable ArabicMapper
		{
			get
			{
				if (arabicMapper == null)
				{
					arabicMapper = new ArabicTable();
				}
				return arabicMapper;
			}
		}

		private ArabicTable()
		{
			mapList = new List<ArabicMapping>();
			mapList.Add(new ArabicMapping(1569, 65152));
			mapList.Add(new ArabicMapping(1575, 65165));
			mapList.Add(new ArabicMapping(1571, 65155));
			mapList.Add(new ArabicMapping(1572, 65157));
			mapList.Add(new ArabicMapping(1573, 65159));
			mapList.Add(new ArabicMapping(1609, 64508));
			mapList.Add(new ArabicMapping(1574, 65161));
			mapList.Add(new ArabicMapping(1576, 65167));
			mapList.Add(new ArabicMapping(1578, 65173));
			mapList.Add(new ArabicMapping(1579, 65177));
			mapList.Add(new ArabicMapping(1580, 65181));
			mapList.Add(new ArabicMapping(1581, 65185));
			mapList.Add(new ArabicMapping(1582, 65189));
			mapList.Add(new ArabicMapping(1583, 65193));
			mapList.Add(new ArabicMapping(1584, 65195));
			mapList.Add(new ArabicMapping(1585, 65197));
			mapList.Add(new ArabicMapping(1586, 65199));
			mapList.Add(new ArabicMapping(1587, 65201));
			mapList.Add(new ArabicMapping(1588, 65205));
			mapList.Add(new ArabicMapping(1589, 65209));
			mapList.Add(new ArabicMapping(1590, 65213));
			mapList.Add(new ArabicMapping(1591, 65217));
			mapList.Add(new ArabicMapping(1592, 65221));
			mapList.Add(new ArabicMapping(1593, 65225));
			mapList.Add(new ArabicMapping(1594, 65229));
			mapList.Add(new ArabicMapping(1601, 65233));
			mapList.Add(new ArabicMapping(1602, 65237));
			mapList.Add(new ArabicMapping(1603, 65241));
			mapList.Add(new ArabicMapping(1604, 65245));
			mapList.Add(new ArabicMapping(1605, 65249));
			mapList.Add(new ArabicMapping(1606, 65253));
			mapList.Add(new ArabicMapping(1607, 65257));
			mapList.Add(new ArabicMapping(1608, 65261));
			mapList.Add(new ArabicMapping(1610, 65265));
			mapList.Add(new ArabicMapping(1570, 65153));
			mapList.Add(new ArabicMapping(1577, 65171));
			mapList.Add(new ArabicMapping(1662, 64342));
			mapList.Add(new ArabicMapping(1670, 64378));
			mapList.Add(new ArabicMapping(1688, 64394));
			mapList.Add(new ArabicMapping(1711, 64402));
			mapList.Add(new ArabicMapping(1705, 64398));
		}

		internal int Convert(int toBeConverted)
		{
			foreach (ArabicMapping map in mapList)
			{
				if (map.from == toBeConverted)
				{
					return map.to;
				}
			}
			return toBeConverted;
		}
	}
	internal class TashkeelLocation
	{
		public char tashkeel;

		public int position;

		public TashkeelLocation(char tashkeel, int position)
		{
			this.tashkeel = tashkeel;
			this.position = position;
		}
	}
	internal class RTLFixerTool
	{
		internal static bool showTashkeel = true;

		internal static bool useHinduNumbers = false;

		internal static string RemoveTashkeel(string str, out List<TashkeelLocation> tashkeelLocation)
		{
			tashkeelLocation = new List<TashkeelLocation>();
			char[] array = str.ToCharArray();
			int num = 0;
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i] == '\u064b')
				{
					tashkeelLocation.Add(new TashkeelLocation('\u064b', i));
					num++;
				}
				else if (array[i] == '\u064c')
				{
					tashkeelLocation.Add(new TashkeelLocation('\u064c', i));
					num++;
				}
				else if (array[i] == '\u064d')
				{
					tashkeelLocation.Add(new TashkeelLocation('\u064d', i));
					num++;
				}
				else if (array[i] == '\u064e')
				{
					if (num > 0 && tashkeelLocation[num - 1].tashkeel == '\u0651')
					{
						tashkeelLocation[num - 1].tashkeel = '';
						continue;
					}
					tashkeelLocation.Add(new TashkeelLocation('\u064e', i));
					num++;
				}
				else if (array[i] == '\u064f')
				{
					if (num > 0 && tashkeelLocation[num - 1].tashkeel == '\u0651')
					{
						tashkeelLocation[num - 1].tashkeel = '';
						continue;
					}
					tashkeelLocation.Add(new TashkeelLocation('\u064f', i));
					num++;
				}
				else if (array[i] == '\u0650')
				{
					if (num > 0 && tashkeelLocation[num - 1].tashkeel == '\u0651')
					{
						tashkeelLocation[num - 1].tashkeel = '';
						continue;
					}
					tashkeelLocation.Add(new TashkeelLocation('\u0650', i));
					num++;
				}
				else if (array[i] == '\u0651')
				{
					if (num > 0)
					{
						if (tashkeelLocation[num - 1].tashkeel == '\u064e')
						{
							tashkeelLocation[num - 1].tashkeel = '';
							continue;
						}
						if (tashkeelLocation[num - 1].tashkeel == '\u064f')
						{
							tashkeelLocation[num - 1].tashkeel = '';
							continue;
						}
						if (tashkeelLocation[num - 1].tashkeel == '\u0650')
						{
							tashkeelLocation[num - 1].tashkeel = '';
							continue;
						}
					}
					tashkeelLocation.Add(new TashkeelLocation('\u0651', i));
					num++;
				}
				else if (array[i] == '\u0652')
				{
					tashkeelLocation.Add(new TashkeelLocation('\u0652', i));
					num++;
				}
				else if (array[i] == '\u0653')
				{
					tashkeelLocation.Add(new TashkeelLocation('\u0653', i));
					num++;
				}
			}
			string[] array2 = str.Split('\u064b', '\u064c', '\u064d', '\u064e', '\u064f', '\u0650', '\u0651', '\u0652', '\u0653', '', '', '');
			str = "";
			string[] array3 = array2;
			foreach (string text in array3)
			{
				str += text;
			}
			return str;
		}

		internal static char[] ReturnTashkeel(char[] letters, List<TashkeelLocation> tashkeelLocation)
		{
			char[] array = new char[letters.Length + tashkeelLocation.Count];
			int num = 0;
			for (int i = 0; i < letters.Length; i++)
			{
				array[num] = letters[i];
				num++;
				foreach (TashkeelLocation item in tashkeelLocation)
				{
					if (item.position == num)
					{
						array[num] = item.tashkeel;
						num++;
					}
				}
			}
			return array;
		}

		internal static string FixLine(string str)
		{
			string text = "";
			List<TashkeelLocation> tashkeelLocation;
			string text2 = RemoveTashkeel(str, out tashkeelLocation);
			char[] array = text2.ToCharArray();
			char[] array2 = text2.ToCharArray();
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = (char)ArabicTable.ArabicMapper.Convert(array[i]);
			}
			for (int j = 0; j < array.Length; j++)
			{
				bool flag = false;
				if (array[j] == '' && j < array.Length - 1)
				{
					if (array[j + 1] == '')
					{
						array[j] = '';
						array2[j + 1] = '\uffff';
						flag = true;
					}
					else if (array[j + 1] == '')
					{
						array[j] = '';
						array2[j + 1] = '\uffff';
						flag = true;
					}
					else if (array[j + 1] == '')
					{
						array[j] = '';
						array2[j + 1] = '\uffff';
						flag = true;
					}
					else if (array[j + 1] == '')
					{
						array[j] = '';
						array2[j + 1] = '\uffff';
						flag = true;
					}
				}
				if (!IsIgnoredCharacter(array[j]))
				{
					if (IsMiddleLetter(array, j))
					{
						array2[j] = (char)(array[j] + 3);
					}
					else if (IsFinishingLetter(array, j))
					{
						array2[j] = (char)(array[j] + 1);
					}
					else if (IsLeadingLetter(array, j))
					{
						array2[j] = (char)(array[j] + 2);
					}
				}
				text = text + Convert.ToString(array[j], 16) + " ";
				if (flag)
				{
					j++;
				}
				if (useHinduNumbers)
				{
					if (array[j] == '0')
					{
						array2[j] = '';
					}
					else if (array[j] == '1')
					{
						array2[j] = '';
					}
					else if (array[j] == '2')
					{
						array2[j] = '';
					}
					else if (array[j] == '3')
					{
						array2[j] = '';
					}
					else if (array[j] == '4')
					{
						array2[j] = '';
					}
					else if (array[j] == '5')
					{
						array2[j] = '';
					}
					else if (array[j] == '6')
					{
						array2[j] = '';
					}
					else if (array[j] == '7')
					{
						array2[j] = '';
					}
					else if (array[j] == '8')
					{
						array2[j] = '';
					}
					else if (array[j] == '9')
					{
						array2[j] = '';
					}
				}
			}
			if (showTashkeel)
			{
				array2 = ReturnTashkeel(array2, tashkeelLocation);
			}
			List<char> list = new List<char>();
			List<char> list2 = new List<char>();
			for (int num = array2.Length - 1; num >= 0; num--)
			{
				if (char.IsPunctuation(array2[num]) && num > 0 && num < array2.Length - 1 && (char.IsPunctuation(array2[num - 1]) || char.IsPunctuation(array2[num + 1])))
				{
					if (array2[num] == '(')
					{
						list.Add(')');
					}
					else if (array2[num] == ')')
					{
						list.Add('(');
					}
					else if (array2[num] == '<')
					{
						list.Add('>');
					}
					else if (array2[num] == '>')
					{
						list.Add('<');
					}
					else if (array2[num] == '[')
					{
						list.Add(']');
					}
					else if (array2[num] == ']')
					{
						list.Add('[');
					}
					else if (array2[num] != '\uffff')
					{
						list.Add(array2[num]);
					}
				}
				else if (array2[num] == ' ' && num > 0 && num < array2.Length - 1 && (char.IsLower(array2[num - 1]) || char.IsUpper(array2[num - 1]) || char.IsNumber(array2[num - 1])) && (char.IsLower(array2[num + 1]) || char.IsUpper(array2[num + 1]) || char.IsNumber(array2[num + 1])))
				{
					list2.Add(array2[num]);
				}
				else if (char.IsNumber(array2[num]) || char.IsLower(array2[num]) || char.IsUpper(array2[num]) || char.IsSymbol(array2[num]) || char.IsPunctuation(array2[num]))
				{
					if (array2[num] == '(')
					{
						list2.Add(')');
					}
					else if (array2[num] == ')')
					{
						list2.Add('(');
					}
					else if (array2[num] == '<')
					{
						list2.Add('>');
					}
					else if (array2[num] == '>')
					{
						list2.Add('<');
					}
					else if (array2[num] == '[')
					{
						list.Add(']');
					}
					else if (array2[num] == ']')
					{
						list.Add('[');
					}
					else
					{
						list2.Add(array2[num]);
					}
				}
				else if ((array2[num] >= '\ud800' && array2[num] <= '\udbff') || (array2[num] >= '\udc00' && array2[num] <= '\udfff'))
				{
					list2.Add(array2[num]);
				}
				else
				{
					if (list2.Count > 0)
					{
						for (int k = 0; k < list2.Count; k++)
						{
							list.Add(list2[list2.Count - 1 - k]);
						}
						list2.Clear();
					}
					if (array2[num] != '\uffff')
					{
						list.Add(array2[num]);
					}
				}
			}
			if (list2.Count > 0)
			{
				for (int l = 0; l < list2.Count; l++)
				{
					list.Add(list2[list2.Count - 1 - l]);
				}
				list2.Clear();
			}
			array2 = new char[list.Count];
			for (int m = 0; m < array2.Length; m++)
			{
				array2[m] = list[m];
			}
			str = new string(array2);
			return str;
		}

		internal static bool IsIgnoredCharacter(char ch)
		{
			bool num = char.IsPunctuation(ch);
			bool flag = char.IsNumber(ch);
			bool flag2 = char.IsLower(ch);
			bool flag3 = char.IsUpper(ch);
			bool flag4 = char.IsSymbol(ch);
			bool flag5 = ch == '' || ch == '' || ch == '' || ch == '' || ch == '';
			bool flag6 = (ch <= '\ufeff' && ch >= '') || flag5 || ch == '';
			if (!(num || flag || flag2 || flag3 || flag4) && flag6 && ch != 'a' && ch != '>' && ch != '<')
			{
				return ch == '';
			}
			return true;
		}

		internal static bool IsLeadingLetter(char[] letters, int index)
		{
			bool num = index == 0 || letters[index - 1] == ' ' || letters[index - 1] == '*' || letters[index - 1] == 'A' || char.IsPunctuation(letters[index - 1]) || letters[index - 1] == '>' || letters[index - 1] == '<' || letters[index - 1] == '' || letters[index - 1] == '' || letters[index - 1] == '' || letters[index - 1] == '' || letters[index - 1] == '' || letters[index - 1] == '' || letters[index - 1] == '' || letters[index - 1] == '' || letters[index - 1] == '' || letters[index - 1] == '' || letters[index - 1] == '';
			bool flag = letters[index] != ' ' && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '';
			bool flag2 = index < letters.Length - 1 && letters[index + 1] != ' ' && !char.IsPunctuation(letters[index + 1]) && !char.IsNumber(letters[index + 1]) && !char.IsSymbol(letters[index + 1]) && !char.IsLower(letters[index + 1]) && !char.IsUpper(letters[index + 1]) && letters[index + 1] != '';
			if (num && flag && flag2)
			{
				return true;
			}
			return false;
		}

		internal static bool IsFinishingLetter(char[] letters, int index)
		{
			bool num = index != 0 && letters[index - 1] != ' ' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && !char.IsPunctuation(letters[index - 1]) && letters[index - 1] != '>' && letters[index - 1] != '<';
			bool flag = letters[index] != ' ' && letters[index] != '';
			if (num && flag)
			{
				return true;
			}
			return false;
		}

		internal static bool IsMiddleLetter(char[] letters, int index)
		{
			bool flag = index != 0 && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '';
			bool flag2 = index != 0 && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && !char.IsPunctuation(letters[index - 1]) && letters[index - 1] != '>' && letters[index - 1] != '<' && letters[index - 1] != ' ' && letters[index - 1] != '*';
			if (index < letters.Length - 1 && letters[index + 1] != ' ' && letters[index + 1] != '\r' && letters[index + 1] != '' && !char.IsNumber(letters[index + 1]) && !char.IsSymbol(letters[index + 1]) && !char.IsPunctuation(letters[index + 1]) && flag2 && flag)
			{
				try
				{
					if (char.IsPunctuation(letters[index + 1]))
					{
						return false;
					}
					return true;
				}
				catch
				{
					return false;
				}
			}
			return false;
		}
	}
	[AddComponentMenu("I2/Localization/SetLanguage Button")]
	public class SetLanguage : MonoBehaviour
	{
		public string _Language;

		private void OnClick()
		{
			ApplyLanguage();
		}

		public void ApplyLanguage()
		{
			if (LocalizationManager.HasLanguage(_Language))
			{
				LocalizationManager.CurrentLanguage = _Language;
			}
		}
	}
	[AddComponentMenu("I2/Localization/SetLanguage Dropdown")]
	public class SetLanguageDropdown : MonoBehaviour
	{
		private void OnEnable()
		{
			Dropdown component = GetComponent<Dropdown>();
			if (!(component == null))
			{
				string currentLanguage = LocalizationManager.CurrentLanguage;
				if (LocalizationManager.Sources.Count == 0)
				{
					LocalizationManager.UpdateSources();
				}
				List<string> allLanguages = LocalizationManager.GetAllLanguages();
				component.ClearOptions();
				component.AddOptions(allLanguages);
				component.value = allLanguages.IndexOf(currentLanguage);
				component.onValueChanged.RemoveListener(OnValueChanged);
				component.onValueChanged.AddListener(OnValueChanged);
			}
		}

		private void OnValueChanged(int index)
		{
			Dropdown component = GetComponent<Dropdown>();
			if (index < 0)
			{
				index = 0;
				component.value = index;
			}
			LocalizationManager.CurrentLanguage = component.options[index].text;
		}
	}
	public class StringObfucator
	{
		public static char[] StringObfuscatorPassword = "bUu\u00b8C*4P-@T6DlWuzm4G$=g,QiKEr60t4~^y:d1<QbUu\u00b8C*4P-@T6DlWuzm4G$=g,QiKEr60t4~^y:d".ToCharArray();

		public static string Encode(string NormalString)
		{
			try
			{
				return ToBase64(XoREncode(NormalString));
			}
			catch (Exception)
			{
				return null;
			}
		}

		public static string Decode(string ObfucatedString)
		{
			try
			{
				return XoREncode(FromBase64(ObfucatedString));
			}
			catch (Exception)
			{
				return null;
			}
		}

		private static string ToBase64(string regularString)
		{
			return Convert.ToBase64String(Encoding.UTF8.GetBytes(regularString));
		}

		private static string FromBase64(string base64string)
		{
			byte[] array = Convert.FromBase64String(base64string);
			return Encoding.UTF8.GetString(array, 0, array.Length);
		}

		private static string XoREncode(string NormalString)
		{
			try
			{
				char[] stringObfuscatorPassword = StringObfuscatorPassword;
				char[] array = NormalString.ToCharArray();
				int num = stringObfuscatorPassword.Length;
				int i = 0;
				for (int num2 = array.Length; i < num2; i++)
				{
					array[i] = (char)(array[i] ^ stringObfuscatorPassword[i % num] ^ (byte)((i % 2 == 0) ? (i * 23) : (-i * 51)));
				}
				return new string(array);
			}
			catch (Exception)
			{
				return null;
			}
		}
	}
}
namespace I2.Loc.SimpleJSON
{
	public enum JSONBinaryTag
	{
		Array = 1,
		Class,
		Value,
		IntValue,
		DoubleValue,
		BoolValue,
		FloatValue
	}
	public class JSONNode
	{
		public virtual JSONNode this[int aIndex]
		{
			get
			{
				return null;
			}
			set
			{
			}
		}

		public virtual JSONNode this[string aKey]
		{
			get
			{
				return null;
			}
			set
			{
			}
		}

		public virtual string Value
		{
			get
			{
				return "";
			}
			set
			{
			}
		}

		public virtual int Count => 0;

		public virtual IEnumerable<JSONNode> Childs
		{
			get
			{
				yield break;
			}
		}

		public IEnumerable<JSONNode> DeepChilds
		{
			get
			{
				foreach (JSONNode child in Childs)
				{
					foreach (JSONNode deepChild in child.DeepChilds)
					{
						yield return deepChild;
					}
				}
			}
		}

		public virtual int AsInt
		{
			get
			{
				int result = 0;
				if (int.TryParse(Value, out result))
				{
					return result;
				}
				return 0;
			}
			set
			{
				Value = value.ToString();
			}
		}

		public virtual float AsFloat
		{
			get
			{
				float result = 0f;
				if (float.TryParse(Value, out result))
				{
					return result;
				}
				return 0f;
			}
			set
			{
				Value = value.ToString();
			}
		}

		public virtual double AsDouble
		{
			get
			{
				double result = 0.0;
				if (double.TryParse(Value, out result))
				{
					return result;
				}
				return 0.0;
			}
			set
			{
				Value = value.ToString();
			}
		}

		public virtual bool AsBool
		{
			get
			{
				bool result = false;
				if (bool.TryParse(Value, out result))
				{
					return result;
				}
				return !string.IsNullOrEmpty(Value);
			}
			set
			{
				Value = (value ? "true" : "false");
			}
		}

		public virtual JSONArray AsArray => this as JSONArray;

		public virtual JSONClass AsObject => this as JSONClass;

		public virtual void Add(string aKey, JSONNode aItem)
		{
		}

		public virtual void Add(JSONNode aItem)
		{
			Add("", aItem);
		}

		public virtual JSONNode Remove(string aKey)
		{
			return null;
		}

		public virtual JSONNode Remove(int aIndex)
		{
			return null;
		}

		public virtual JSONNode Remove(JSONNode aNode)
		{
			return aNode;
		}

		public override string ToString()
		{
			return "JSONNode";
		}

		public virtual string ToString(string aPrefix)
		{
			return "JSONNode";
		}

		public static implicit operator JSONNode(string s)
		{
			return new JSONData(s);
		}

		public static implicit operator string(JSONNode d)
		{
			if (!(d == null))
			{
				return d.Value;
			}
			return null;
		}

		public static bool operator ==(JSONNode a, object b)
		{
			if (b == null && a is JSONLazyCreator)
			{
				return true;
			}
			return (object)a == b;
		}

		public static bool operator !=(JSONNode a, object b)
		{
			return !(a == b);
		}

		public override bool Equals(object obj)
		{
			return (object)this == obj;
		}

		public override int GetHashCode()
		{
			return base.GetHashCode();
		}

		internal static string Escape(string aText)
		{
			string text = "";
			for (int i = 0; i < aText.Length; i++)
			{
				char c = aText[i];
				text = c switch
				{
					'\\' => text + "\\\\", 
					'"' => text + "\\\"", 
					'\n' => text + "\\n", 
					'\r' => text + "\\r", 
					'\t' => text + "\\t", 
					'\b' => text + "\\b", 
					'\f' => text + "\\f", 
					_ => text + c, 
				};
			}
			return text;
		}

		public static JSONNode Parse(string aJSON)
		{
			Stack<JSONNode> stack = new Stack<JSONNode>();
			JSONNode jSONNode = null;
			int i = 0;
			string text = "";
			string text2 = "";
			bool flag = false;
			for (; i < aJSON.Length; i++)
			{
				switch (aJSON[i])
				{
				case '{':
					if (flag)
					{
						text += aJSON[i];
						break;
					}
					stack.Push(new JSONClass());
					if (jSONNode != null)
					{
						text2 = text2.Trim();
						if (jSONNode is JSONArray)
						{
							jSONNode.Add(stack.Peek());
						}
						else if (text2 != "")
						{
							jSONNode.Add(text2, stack.Peek());
						}
					}
					text2 = "";
					text = "";
					jSONNode = stack.Peek();
					break;
				case '[':
					if (flag)
					{
						text += aJSON[i];
						break;
					}
					stack.Push(new JSONArray());
					if (jSONNode != null)
					{
						text2 = text2.Trim();
						if (jSONNode is JSONArray)
						{
							jSONNode.Add(stack.Peek());
						}
						else if (text2 != "")
						{
							jSONNode.Add(text2, stack.Peek());
						}
					}
					text2 = "";
					text = "";
					jSONNode = stack.Peek();
					break;
				case ']':
				case '}':
					if (flag)
					{
						text += aJSON[i];
						break;
					}
					if (stack.Count == 0)
					{
						throw new Exception("JSON Parse: Too many closing brackets");
					}
					stack.Pop();
					if (text != "")
					{
						text2 = text2.Trim();
						if (jSONNode is JSONArray)
						{
							jSONNode.Add(text);
						}
						else if (text2 != "")
						{
							jSONNode.Add(text2, text);
						}
					}
					text2 = "";
					text = "";
					if (stack.Count > 0)
					{
						jSONNode = stack.Peek();
					}
					break;
				case ':':
					if (flag)
					{
						text += aJSON[i];
						break;
					}
					text2 = text;
					text = "";
					break;
				case '"':
					flag = !flag;
					break;
				case ',':
					if (flag)
					{
						text += aJSON[i];
						break;
					}
					if (text != "")
					{
						if (jSONNode is JSONArray)
						{
							jSONNode.Add(text);
						}
						else if (text2 != "")
						{
							jSONNode.Add(text2, text);
						}
					}
					text2 = "";
					text = "";
					break;
				case '\t':
				case ' ':
					if (flag)
					{
						text += aJSON[i];
					}
					break;
				case '\\':
					i++;
					if (flag)
					{
						char c = aJSON[i];
						switch (c)
						{
						case 't':
							text += "\t";
							break;
						case 'r':
							text += "\r";
							break;
						case 'n':
							text += "\n";
							break;
						case 'b':
							text += "\b";
							break;
						case 'f':
							text += "\f";
							break;
						case 'u':
						{
							string s = aJSON.Substring(i + 1, 4);
							text += (char)int.Parse(s, NumberStyles.AllowHexSpecifier);
							i += 4;
							break;
						}
						default:
							text += c;
							break;
						}
					}
					break;
				default:
					text += aJSON[i];
					break;
				case '\n':
				case '\r':
					break;
				}
			}
			if (flag)
			{
				throw new Exception("JSON Parse: Quotation marks seems to be messed up.");
			}
			return jSONNode;
		}

		public virtual void Serialize(BinaryWriter aWriter)
		{
		}

		public void SaveToStream(Stream aData)
		{
			BinaryWriter aWriter = new BinaryWriter(aData);
			Serialize(aWriter);
		}

		public void SaveToCompressedStream(Stream aData)
		{
			throw new Exception("Can't use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON");
		}

		public void SaveToCompressedFile(string aFileName)
		{
			throw new Exception("Can't use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON");
		}

		public string SaveToCompressedBase64()
		{
			throw new Exception("Can't use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON");
		}

		public void SaveToFile(string aFileName)
		{
			Directory.CreateDirectory(new FileInfo(aFileName).Directory.FullName);
			using FileStream aData = File.OpenWrite(aFileName);
			SaveToStream(aData);
		}

		public string SaveToBase64()
		{
			using MemoryStream memoryStream = new MemoryStream();
			SaveToStream(memoryStream);
			memoryStream.Position = 0L;
			return Convert.ToBase64String(memoryStream.ToArray());
		}

		public static JSONNode Deserialize(BinaryReader aReader)
		{
			JSONBinaryTag jSONBinaryTag = (JSONBinaryTag)aReader.ReadByte();
			switch (jSONBinaryTag)
			{
			case JSONBinaryTag.Array:
			{
				int num2 = aReader.ReadInt32();
				JSONArray jSONArray = new JSONArray();
				for (int j = 0; j < num2; j++)
				{
					jSONArray.Add(Deserialize(aReader));
				}
				return jSONArray;
			}
			case JSONBinaryTag.Class:
			{
				int num = aReader.ReadInt32();
				JSONClass jSONClass = new JSONClass();
				for (int i = 0; i < num; i++)
				{
					string aKey = aReader.ReadString();
					JSONNode aItem = Deserialize(aReader);
					jSONClass.Add(aKey, aItem);
				}
				return jSONClass;
			}
			case JSONBinaryTag.Value:
				return new JSONData(aReader.ReadString());
			case JSONBinaryTag.IntValue:
				return new JSONData(aReader.ReadInt32());
			case JSONBinaryTag.DoubleValue:
				return new JSONData(aReader.ReadDouble());
			case JSONBinaryTag.BoolValue:
				return new JSONData(aReader.ReadBoolean());
			case JSONBinaryTag.FloatValue:
				return new JSONData(aReader.ReadSingle());
			default:
				throw new Exception("Error deserializing JSON. Unknown tag: " + jSONBinaryTag);
			}
		}

		public static JSONNode LoadFromCompressedFile(string aFileName)
		{
			throw new Exception("Can't use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON");
		}

		public static JSONNode LoadFromCompressedStream(Stream aData)
		{
			throw new Exception("Can't use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON");
		}

		public static JSONNode LoadFromCompressedBase64(string aBase64)
		{
			throw new Exception("Can't use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON");
		}

		public static JSONNode LoadFromStream(Stream aData)
		{
			using BinaryReader aReader = new BinaryReader(aData);
			return Deserialize(aReader);
		}

		public static JSONNode LoadFromFile(string aFileName)
		{
			using FileStream aData = File.OpenRead(aFileName);
			return LoadFromStream(aData);
		}

		public static JSONNode LoadFromBase64(string aBase64)
		{
			return LoadFromStream(new MemoryStream(Convert.FromBase64String(aBase64))
			{
				Position = 0L
			});
		}
	}
	public class JSONArray : JSONNode, IEnumerable
	{
		private List<JSONNode> m_List = new List<JSONNode>();

		public override JSONNode this[int aIndex]
		{
			get
			{
				if (aIndex < 0 || aIndex >= m_List.Count)
				{
					return new JSONLazyCreator(this);
				}
				return m_List[aIndex];
			}
			set
			{
				if (aIndex < 0 || aIndex >= m_List.Count)
				{
					m_List.Add(value);
				}
				else
				{
					m_List[aIndex] = value;
				}
			}
		}

		public override JSONNode this[string aKey]
		{
			get
			{
				return new JSONLazyCreator(this);
			}
			set
			{
				m_List.Add(value);
			}
		}

		public override int Count => m_List.Count;

		public override IEnumerable<JSONNode> Childs
		{
			get
			{
				foreach (JSONNode item in m_List)
				{
					yield return item;
				}
			}
		}

		public override void Add(string aKey, JSONNode aItem)
		{
			m_List.Add(aItem);
		}

		public override JSONNode Remove(int aIndex)
		{
			if (aIndex < 0 || aIndex >= m_List.Count)
			{
				return null;
			}
			JSONNode result = m_List[aIndex];
			m_List.RemoveAt(aIndex);
			return result;
		}

		public override JSONNode Remove(JSONNode aNode)
		{
			m_List.Remove(aNode);
			return aNode;
		}

		public IEnumerator GetEnumerator()
		{
			foreach (JSONNode item in m_List)
			{
				yield return item;
			}
		}

		public override string ToString()
		{
			string text = "[ ";
			foreach (JSONNode item in m_List)
			{
				if (text.Length > 2)
				{
					text += ", ";
				}
				text += item.ToString();
			}
			return text + " ]";
		}

		public override string ToString(string aPrefix)
		{
			string text = "[ ";
			foreach (JSONNode item in m_List)
			{
				if (text.Length > 3)
				{
					text += ", ";
				}
				text = text + "\n" + aPrefix + "   ";
				text += item.ToString(aPrefix + "   ");
			}
			return text + "\n" + aPrefix + "]";
		}

		public override void Serialize(BinaryWriter aWriter)
		{
			aWriter.Write((byte)1);
			aWriter.Write(m_List.Count);
			for (int i = 0; i < m_List.Count; i++)
			{
				m_List[i].Serialize(aWriter);
			}
		}
	}
	public class JSONClass : JSONNode, IEnumerable
	{
		private Dictionary<string, JSONNode> m_Dict = new Dictionary<string, JSONNode>(StringComparer.Ordinal);

		public override JSONNode this[string aKey]
		{
			get
			{
				if (m_Dict.ContainsKey(aKey))
				{
					return m_Dict[aKey];
				}
				return new JSONLazyCreator(this, aKey);
			}
			set
			{
				if (m_Dict.ContainsKey(aKey))
				{
					m_Dict[aKey] = value;
				}
				else
				{
					m_Dict.Add(aKey, value);
				}
			}
		}

		public override JSONNode this[int aIndex]
		{
			get
			{
				if (aIndex < 0 || aIndex >= m_Dict.Count)
				{
					return null;
				}
				return m_Dict.ElementAt(aIndex).Value;
			}
			set
			{
				if (aIndex >= 0 && aIndex < m_Dict.Count)
				{
					string key = m_Dict.ElementAt(aIndex).Key;
					m_Dict[key] = value;
				}
			}
		}

		public override int Count => m_Dict.Count;

		public override IEnumerable<JSONNode> Childs
		{
			get
			{
				foreach (KeyValuePair<string, JSONNode> item in m_Dict)
				{
					yield return item.Value;
				}
			}
		}

		public override void Add(string aKey, JSONNode aItem)
		{
			if (!string.IsNullOrEmpty(aKey))
			{
				if (m_Dict.ContainsKey(aKey))
				{
					m_Dict[aKey] = aItem;
				}
				else
				{
					m_Dict.Add(aKey, aItem);
				}
			}
			else
			{
				m_Dict.Add(Guid.NewGuid().ToString(), aItem);
			}
		}

		public override JSONNode Remove(string aKey)
		{
			if (!m_Dict.ContainsKey(aKey))
			{
				return null;
			}
			JSONNode result = m_Dict[aKey];
			m_Dict.Remove(aKey);
			return result;
		}

		public override JSONNode Remove(int aIndex)
		{
			if (aIndex < 0 || aIndex >= m_Dict.Count)
			{
				return null;
			}
			KeyValuePair<string, JSONNode> keyValuePair = m_Dict.ElementAt(aIndex);
			m_Dict.Remove(keyValuePair.Key);
			return keyValuePair.Value;
		}

		public override JSONNode Remove(JSONNode aNode)
		{
			try
			{
				KeyValuePair<string, JSONNode> keyValuePair = m_Dict.Where((KeyValuePair<string, JSONNode> k) => k.Value == aNode).First();
				m_Dict.Remove(keyValuePair.Key);
				return aNode;
			}
			catch
			{
				return null;
			}
		}

		public IEnumerator GetEnumerator()
		{
			foreach (KeyValuePair<string, JSONNode> item in m_Dict)
			{
				yield return item;
			}
		}

		public override string ToString()
		{
			string text = "{";
			foreach (KeyValuePair<string, JSONNode> item in m_Dict)
			{
				if (text.Length > 2)
				{
					text += ", ";
				}
				text = text + "\"" + JSONNode.Escape(item.Key) + "\":" + item.Value.ToString();
			}
			return text + "}";
		}

		public override string ToString(string aPrefix)
		{
			string text = "{ ";
			foreach (KeyValuePair<string, JSONNode> item in m_Dict)
			{
				if (text.Length > 3)
				{
					text += ", ";
				}
				text = text + "\n" + aPrefix + "   ";
				text = text + "\"" + JSONNode.Escape(item.Key) + "\" : " + item.Value.ToString(aPrefix + "   ");
			}
			return text + "\n" + aPrefix + "}";
		}

		public override void Serialize(BinaryWriter aWriter)
		{
			aWriter.Write((byte)2);
			aWriter.Write(m_Dict.Count);
			foreach (string key in m_Dict.Keys)
			{
				aWriter.Write(key);
				m_Dict[key].Serialize(aWriter);
			}
		}
	}
	public class JSONData : JSONNode
	{
		private string m_Data;

		public override string Value
		{
			get
			{
				return m_Data;
			}
			set
			{
				m_Data = value;
			}
		}

		public JSONData(string aData)
		{
			m_Data = aData;
		}

		public JSONData(float aData)
		{
			AsFloat = aData;
		}

		public JSONData(double aData)
		{
			AsDouble = aData;
		}

		public JSONData(bool aData)
		{
			AsBool = aData;
		}

		public JSONData(int aData)
		{
			AsInt = aData;
		}

		public override string ToString()
		{
			return "\"" + JSONNode.Escape(m_Data) + "\"";
		}

		public override string ToString(string aPrefix)
		{
			return "\"" + JSONNode.Escape(m_Data) + "\"";
		}

		public override void Serialize(BinaryWriter aWriter)
		{
			JSONData jSONData = new JSONData("");
			jSONData.AsInt = AsInt;
			if (jSONData.m_Data == m_Data)
			{
				aWriter.Write((byte)4);
				aWriter.Write(AsInt);
				return;
			}
			jSONData.AsFloat = AsFloat;
			if (jSONData.m_Data == m_Data)
			{
				aWriter.Write((byte)7);
				aWriter.Write(AsFloat);
				return;
			}
			jSONData.AsDouble = AsDouble;
			if (jSONData.m_Data == m_Data)
			{
				aWriter.Write((byte)5);
				aWriter.Write(AsDouble);
				return;
			}
			jSONData.AsBool = AsBool;
			if (jSONData.m_Data == m_Data)
			{
				aWriter.Write((byte)6);
				aWriter.Write(AsBool);
			}
			else
			{
				aWriter.Write((byte)3);
				aWriter.Write(m_Data);
			}
		}
	}
	internal class JSONLazyCreator : JSONNode
	{
		private JSONNode m_Node;

		private string m_Key;

		public override JSONNode this[int aIndex]
		{
			get
			{
				return new JSONLazyCreator(this);
			}
			set
			{
				JSONArray jSONArray = new JSONArray();
				jSONArray.Add(value);
				Set(jSONArray);
			}
		}

		public override JSONNode this[string aKey]
		{
			get
			{
				return new JSONLazyCreator(this, aKey);
			}
			set
			{
				JSONClass jSONClass = new JSONClass();
				jSONClass.Add(aKey, value);
				Set(jSONClass);
			}
		}

		public override int AsInt
		{
			get
			{
				JSONData aVal = new JSONData(0);
				Set(aVal);
				return 0;
			}
			set
			{
				JSONData aVal = new JSONData(value);
				Set(aVal);
			}
		}

		public override float AsFloat
		{
			get
			{
				JSONData aVal = new JSONData(0f);
				Set(aVal);
				return 0f;
			}
			set
			{
				JSONData aVal = new JSONData(value);
				Set(aVal);
			}
		}

		public override double AsDouble
		{
			get
			{
				JSONData aVal = new JSONData(0.0);
				Set(aVal);
				return 0.0;
			}
			set
			{
				JSONData aVal = new JSONData(value);
				Set(aVal);
			}
		}

		public override bool AsBool
		{
			get
			{
				JSONData aVal = new JSONData(aData: false);
				Set(aVal);
				return false;
			}
			set
			{
				JSONData aVal = new JSONData(value);
				Set(aVal);
			}
		}

		public override JSONArray AsArray
		{
			get
			{
				JSONArray jSONArray = new JSONArray();
				Set(jSONArray);
				return jSONArray;
			}
		}

		public override JSONClass AsObject
		{
			get
			{
				JSONClass jSONClass = new JSONClass();
				Set(jSONClass);
				return jSONClass;
			}
		}

		public JSONLazyCreator(JSONNode aNode)
		{
			m_Node = aNode;
			m_Key = null;
		}

		public JSONLazyCreator(JSONNode aNode, string aKey)
		{
			m_Node = aNode;
			m_Key = aKey;
		}

		private void Set(JSONNode aVal)
		{
			if (m_Key == null)
			{
				m_Node.Add(aVal);
			}
			else
			{
				m_Node.Add(m_Key, aVal);
			}
			m_Node = null;
		}

		public override void Add(JSONNode aItem)
		{
			JSONArray jSONArray = new JSONArray();
			jSONArray.Add(aItem);
			Set(jSONArray);
		}

		public override void Add(string aKey, JSONNode aItem)
		{
			JSONClass jSONClass = new JSONClass();
			jSONClass.Add(aKey, aItem);
			Set(jSONClass);
		}

		public static bool operator ==(JSONLazyCreator a, object b)
		{
			if (b == null)
			{
				return true;
			}
			return (object)a == b;
		}

		public static bool operator !=(JSONLazyCreator a, object b)
		{
			return !(a == b);
		}

		public override bool Equals(object obj)
		{
			if (obj == null)
			{
				return true;
			}
			return (object)this == obj;
		}

		public override int GetHashCode()
		{
			return base.GetHashCode();
		}

		public override string ToString()
		{
			return "";
		}

		public override string ToString(string aPrefix)
		{
			return "";
		}
	}
	public static class JSON
	{
		public static JSONNode Parse(string aJSON)
		{
			return JSONNode.Parse(aJSON);
		}
	}
}
namespace DynamicShadowProjector
{
	[ExecuteInEditMode]
	[DisallowMultipleComponent]
	[RequireComponent(typeof(ShadowTextureRenderer))]
	public class DrawSceneObject : MonoBehaviour
	{
		[SerializeField]
		private Shader m_replacementShader;

		[SerializeField]
		private LayerMask m_cullingMask;

		private ShadowTextureRenderer m_shadowTextureRenderer;

		public Shader replacementShader
		{
			get
			{
				return m_replacementShader;
			}
			set
			{
				m_replacementShader = value;
				shadowTextureRenderer.SetReplacementShader(m_replacementShader, "RenderType");
			}
		}

		public LayerMask cullingMask
		{
			get
			{
				return m_cullingMask;
			}
			set
			{
				m_cullingMask = value;
				if (shadowTextureRenderer.isProjectorVisible)
				{
					shadowTextureRenderer.cameraCullingMask = value;
				}
			}
		}

		public ShadowTextureRenderer shadowTextureRenderer
		{
			get
			{
				if (m_shadowTextureRenderer == null)
				{
					m_shadowTextureRenderer = GetComponent<ShadowTextureRenderer>();
				}
				return m_shadowTextureRenderer;
			}
		}

		private void OnValidate()
		{
			shadowTextureRenderer.SetReplacementShader(m_replacementShader, "RenderType");
			if (shadowTextureRenderer.isProjectorVisible)
			{
				shadowTextureRenderer.cameraCullingMask = m_cullingMask;
			}
		}

		private void OnEnable()
		{
			shadowTextureRenderer.cameraCullingMask = m_cullingMask;
			shadowTextureRenderer.SetReplacementShader(m_replacementShader, "RenderType");
		}

		private void OnDisable()
		{
			shadowTextureRenderer.cameraCullingMask = 0;
			shadowTextureRenderer.SetReplacementShader(null, null);
		}

		private void OnVisibilityChanged(bool isVisible)
		{
			if (isVisible)
			{
				shadowTextureRenderer.cameraCullingMask = m_cullingMask;
			}
			else
			{
				shadowTextureRenderer.cameraCullingMask = 0;
			}
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(ShadowTextureRenderer))]
	public class DrawTargetObject : MonoBehaviour
	{
		[Serializable]
		public struct ReplaceShader
		{
			public string renderType;

			public Shader shader;
		}

		public enum TextureAlignment
		{
			None,
			TargetAxisX,
			TargetAxisY,
			TargetAxisZ
		}

		public enum UpdateFunction
		{
			OnPreCull,
			LateUpdate,
			UpdateTransform
		}

		[SerializeField]
		private Transform m_target;

		[SerializeField]
		private Transform m_targetDirection;

		[SerializeField]
		private LayerMask m_layerMask = -1;

		[SerializeField]
		private TextureAlignment m_textureAlignment;

		[SerializeField]
		private UpdateFunction m_updateFunction;

		[SerializeField]
		private Material m_shadowShader;

		[SerializeField]
		private ReplaceShader[] m_replacementShaders;

		[SerializeField]
		private bool m_renderChildren = true;

		[SerializeField]
		private bool m_followTarget = true;

		private bool m_isCommandBufferDirty;

		private CommandBuffer m_commandBuffer;

		private ShadowTextureRenderer m_shadowRenderer;

		private Vector3 m_localTargetPosition;

		private Dictionary<Material, Material> m_replacedMaterialCache;

		public Transform target
		{
			get
			{
				return m_target;
			}
			set
			{
				if (m_target != value)
				{
					m_target = value;
					SetCommandBufferDirty();
				}
			}
		}

		public Transform targetDirection
		{
			get
			{
				return m_targetDirection;
			}
			set
			{
				m_targetDirection = value;
			}
		}

		public bool renderChildren
		{
			get
			{
				return m_renderChildren;
			}
			set
			{
				if (m_renderChildren != value)
				{
					m_renderChildren = value;
					SetCommandBufferDirty();
				}
			}
		}

		public LayerMask layerMask
		{
			get
			{
				return m_layerMask;
			}
			set
			{
				if ((int)m_layerMask != (int)value)
				{
					m_layerMask = value;
					if (m_renderChildren)
					{
						SetCommandBufferDirty();
					}
				}
			}
		}

		public TextureAlignment textureAlignment
		{
			get
			{
				return m_textureAlignment;
			}
			set
			{
				m_textureAlignment = value;
			}
		}

		public UpdateFunction updateFunction
		{
			get
			{
				return m_updateFunction;
			}
			set
			{
				m_updateFunction = value;
			}
		}

		public bool followTarget
		{
			get
			{
				return m_followTarget;
			}
			set
			{
				m_followTarget = value;
			}
		}

		public Material shadowShader
		{
			get
			{
				return m_shadowShader;
			}
			set
			{
				if (m_shadowShader != value)
				{
					m_shadowShader = value;
					SetCommandBufferDirty();
				}
			}
		}

		public ReplaceShader[] replacementShaders
		{
			get
			{
				return m_replacementShaders;
			}
			set
			{
				m_replacementShaders = value;
				SetCommandBufferDirty();
			}
		}

		public void SetCommandBufferDirty()
		{
			m_isCommandBufferDirty = true;
		}

		public void UpdateCommandBuffer()
		{
			if (m_target == null)
			{
				return;
			}
			m_commandBuffer.Clear();
			int num = ((m_replacementShaders != null) ? m_replacementShaders.Length : 0);
			if (m_renderChildren)
			{
				Renderer[] componentsInChildren = m_target.gameObject.GetComponentsInChildren<Renderer>();
				for (int i = -1; i < num; i++)
				{
					Renderer[] array = componentsInChildren;
					foreach (Renderer renderer in array)
					{
						if (((int)m_layerMask & (1 << renderer.gameObject.layer)) != 0)
						{
							AddDrawCommand(renderer, i);
						}
					}
				}
			}
			else
			{
				Renderer component = m_target.gameObject.GetComponent<Renderer>();
				if (component != null)
				{
					for (int k = -1; k < num; k++)
					{
						AddDrawCommand(component, k);
					}
				}
				else if (UnityEngine.Debug.isDebugBuild || UnityEngine.Application.isEditor)
				{
					UnityEngine.Debug.LogError("The target object does not have a Renderer component!", m_target);
				}
			}
			m_isCommandBufferDirty = false;
		}

		public void UpdateMaterial(Material mat)
		{
			if (m_replacedMaterialCache != null && m_replacedMaterialCache.TryGetValue(mat, out var value))
			{
				value.CopyPropertiesFromMaterial(mat);
			}
		}

		public void UpdateTransform()
		{
			if (m_textureAlignment != 0 || m_targetDirection != null)
			{
				Vector3 worldUp = m_textureAlignment switch
				{
					TextureAlignment.TargetAxisX => m_target.right, 
					TextureAlignment.TargetAxisZ => m_target.forward, 
					_ => m_target.up, 
				};
				Vector3 vector = ((m_targetDirection != null) ? m_targetDirection.forward : base.transform.forward);
				base.transform.LookAt(base.transform.position + vector, worldUp);
			}
			if (m_followTarget)
			{
				Vector3 vector2 = base.transform.TransformPoint(m_localTargetPosition);
				base.transform.position += m_target.position - vector2;
			}
		}

		private void Awake()
		{
			m_shadowRenderer = GetComponent<ShadowTextureRenderer>();
			if (m_target != null)
			{
				m_localTargetPosition = base.transform.InverseTransformPoint(m_target.position);
			}
			CreateCommandBuffer();
		}

		private void OnValidate()
		{
			if (m_commandBuffer != null)
			{
				UpdateCommandBuffer();
			}
		}

		private void OnEnable()
		{
			if (m_commandBuffer == null)
			{
				CreateCommandBuffer();
			}
			else if (m_shadowRenderer != null && m_shadowRenderer.isProjectorVisible)
			{
				m_shadowRenderer.AddCommandBuffer(m_commandBuffer);
			}
		}

		private void OnDisable()
		{
			if (m_shadowRenderer != null && m_commandBuffer != null)
			{
				m_shadowRenderer.RemoveCommandBuffer(m_commandBuffer);
			}
		}

		private void OnDestroy()
		{
			if (m_commandBuffer != null)
			{
				m_commandBuffer.Dispose();
				m_commandBuffer = null;
			}
			if (m_replacedMaterialCache == null)
			{
				return;
			}
			foreach (KeyValuePair<Material, Material> item in m_replacedMaterialCache)
			{
				UnityEngine.Object.DestroyImmediate(item.Value);
			}
			m_replacedMaterialCache.Clear();
		}

		private void LateUpdate()
		{
			if (m_updateFunction == UpdateFunction.LateUpdate)
			{
				UpdateTransform();
			}
		}

		private void OnPreCull()
		{
			if (m_isCommandBufferDirty)
			{
				UpdateCommandBuffer();
			}
			if (m_updateFunction == UpdateFunction.OnPreCull)
			{
				UpdateTransform();
			}
		}

		private void OnVisibilityChanged(bool isVisible)
		{
			if (isVisible)
			{
				m_shadowRenderer.AddCommandBuffer(m_commandBuffer);
			}
			else
			{
				m_shadowRenderer.RemoveCommandBuffer(m_commandBuffer);
			}
		}

		private void CreateCommandBuffer()
		{
			m_commandBuffer = new CommandBuffer();
			if (m_shadowRenderer.isProjectorVisible)
			{
				m_shadowRenderer.AddCommandBuffer(m_commandBuffer);
			}
			m_isCommandBufferDirty = true;
		}

		private void AddDrawCommand(Renderer renderer, int renderTypeIndex)
		{
			Material[] sharedMaterials = renderer.sharedMaterials;
			for (int i = 0; i < sharedMaterials.Length; i++)
			{
				Material material = sharedMaterials[i];
				if (material == null)
				{
					UnityEngine.Debug.LogWarning("The target object has a null material!", renderer);
					continue;
				}
				string text = material.GetTag("RenderType", searchFallbacks: false);
				if (material.shader.name == "Standard" && (material.IsKeywordEnabled("_ALPHABLEND_ON") || material.IsKeywordEnabled("_ALPHATEST_ON") || material.IsKeywordEnabled("_ALPHAPREMULTIPLY_ON")))
				{
					text = "Transparent";
				}
				int num = -1;
				if (m_replacementShaders != null && !string.IsNullOrEmpty(text))
				{
					for (int j = 0; j < m_replacementShaders.Length; j++)
					{
						if (!(text == m_replacementShaders[j].renderType))
						{
							continue;
						}
						num = j;
						Shader shader = m_replacementShaders[j].shader;
						if (renderTypeIndex == j && shader != null)
						{
							if (m_replacedMaterialCache == null)
							{
								m_replacedMaterialCache = new Dictionary<Material, Material>();
							}
							if (!m_replacedMaterialCache.TryGetValue(material, out var value))
							{
								value = new Material(material);
								value.shader = shader;
								value.hideFlags = HideFlags.HideAndDontSave;
								m_replacedMaterialCache.Add(material, value);
							}
							else
							{
								value.CopyPropertiesFromMaterial(material);
								value.shader = shader;
							}
							m_commandBuffer.DrawRenderer(renderer, value, i);
						}
						break;
					}
				}
				if (num == -1 && renderTypeIndex == -1)
				{
					m_commandBuffer.DrawRenderer(renderer, m_shadowShader, i);
				}
			}
		}
	}
	public class FollowTargetObject : MonoBehaviour
	{
		public enum TextureAlignment
		{
			None,
			TargetAxisX,
			TargetAxisY,
			TargetAxisZ
		}

		public enum UpdateFunction
		{
			OnPreCull,
			LateUpdate,
			UpdateTransform
		}

		[SerializeField]
		private Transform m_target;

		[SerializeField]
		private Transform m_targetDirection;

		[SerializeField]
		private TextureAlignment m_textureAlignment;

		[SerializeField]
		private UpdateFunction m_updateFunction = UpdateFunction.LateUpdate;

		private Vector3 m_localTargetPosition;

		public Transform target
		{
			get
			{
				return m_target;
			}
			set
			{
				m_target = value;
			}
		}

		public Transform targetDirection
		{
			get
			{
				return m_targetDirection;
			}
			set
			{
				m_targetDirection = value;
			}
		}

		public TextureAlignment textureAlignment
		{
			get
			{
				return m_textureAlignment;
			}
			set
			{
				m_textureAlignment = value;
			}
		}

		public UpdateFunction updateFunction
		{
			get
			{
				return m_updateFunction;
			}
			set
			{
				m_updateFunction = value;
			}
		}

		public void UpdateTransform()
		{
			if (m_textureAlignment != 0 || m_targetDirection != null)
			{
				Vector3 worldUp = m_textureAlignment switch
				{
					TextureAlignment.TargetAxisX => m_target.right, 
					TextureAlignment.TargetAxisZ => m_target.forward, 
					_ => m_target.up, 
				};
				Vector3 vector = ((m_targetDirection != null) ? m_targetDirection.forward : base.transform.forward);
				base.transform.LookAt(base.transform.position + vector, worldUp);
			}
			Vector3 vector2 = base.transform.TransformPoint(m_localTargetPosition);
			base.transform.position += m_target.position - vector2;
		}

		private void Awake()
		{
			if (m_target != null)
			{
				m_localTargetPosition = base.transform.InverseTransformPoint(m_target.position);
			}
		}

		private void LateUpdate()
		{
			if (m_updateFunction == UpdateFunction.LateUpdate)
			{
				UpdateTransform();
			}
		}

		private void OnPreCull()
		{
			if (m_updateFunction == UpdateFunction.OnPreCull)
			{
				UpdateTransform();
			}
		}
	}
	[RequireComponent(typeof(ShadowTextureRenderer))]
	public class MipmappedShadowFallback : MonoBehaviour
	{
		public UnityEngine.Object m_fallbackShaderOrMaterial;

		public int m_blurLevel = 1;

		public float m_blurSize = 2f;

		public bool m_modifyTextureSize;

		public ShadowTextureRenderer.TextureMultiSample m_multiSampling = ShadowTextureRenderer.TextureMultiSample.x4;

		public ShadowTextureRenderer.TextureSuperSample m_superSampling = ShadowTextureRenderer.TextureSuperSample.x1;

		public int m_textureWidth = 64;

		public int m_textureHeight = 64;

		public Shader m_tex2DlodCheckShader;

		public Shader m_glslCheckShader;

		private void Awake()
		{
			Projector component = GetComponent<Projector>();
			if (component == null || component.material == null)
			{
				return;
			}
			bool isSupported = component.material.shader.isSupported;
			if (isSupported && m_tex2DlodCheckShader != null && m_glslCheckShader != null && m_glslCheckShader.isSupported)
			{
				isSupported = m_tex2DlodCheckShader.isSupported;
			}
			if (!isSupported)
			{
				if (UnityEngine.Debug.isDebugBuild)
				{
					UnityEngine.Debug.Log("This device does not support tex2Dlod. Use fallback shader instead: " + SystemInfo.graphicsDeviceID);
				}
				ApplyFallback(component);
			}
		}

		public void ApplyFallback(Projector projector)
		{
			if (m_fallbackShaderOrMaterial is Shader)
			{
				projector.material.shader = m_fallbackShaderOrMaterial as Shader;
			}
			else if (m_fallbackShaderOrMaterial is Material)
			{
				projector.material = m_fallbackShaderOrMaterial as Material;
			}
			ShadowTextureRenderer component = projector.GetComponent<ShadowTextureRenderer>();
			component.blurLevel = m_blurLevel;
			component.blurSize = m_blurSize;
			component.mipLevel = 0;
			if (m_modifyTextureSize)
			{
				component.textureWidth = m_textureWidth;
				component.textureHeight = m_textureHeight;
				component.multiSampling = m_multiSampling;
				component.superSampling = m_superSampling;
			}
		}
	}
	[ExecuteInEditMode]
	[DisallowMultipleComponent]
	[RequireComponent(typeof(Projector))]
	public class ShadowTextureRenderer : MonoBehaviour
	{
		public enum TextureMultiSample
		{
			x1 = 1,
			x2 = 2,
			x4 = 4,
			x8 = 8
		}

		public enum TextureSuperSample
		{
			x1 = 1,
			x4 = 2,
			x16 = 4
		}

		public enum MipmapFalloff
		{
			None,
			Linear,
			Custom
		}

		public enum BlurFilter
		{
			Uniform,
			Gaussian
		}

		private struct BlurParam
		{
			public int tap;

			public Vector4 offset;

			public Vector4 weight;
		}

		[SerializeField]
		private TextureMultiSample m_multiSampling = TextureMultiSample.x4;

		[SerializeField]
		private TextureSuperSample m_superSampling = TextureSuperSample.x1;

		[SerializeField]
		private MipmapFalloff m_mipmapFalloff = MipmapFalloff.Linear;

		[SerializeField]
		private BlurFilter m_blurFilter;

		[SerializeField]
		private bool m_testViewClip = true;

		[SerializeField]
		private int m_textureWidth = 64;

		[SerializeField]
		private int m_textureHeight = 64;

		[SerializeField]
		private int m_mipLevel;

		[SerializeField]
		private int m_blurLevel = 1;

		[SerializeField]
		private float m_blurSize = 3f;

		[SerializeField]
		private float m_mipmapBlurSize;

		[SerializeField]
		private bool m_singlePassMipmapBlur;

		[SerializeField]
		private Color m_shadowColor = new Color(0f, 0f, 0f, 1f);

		[SerializeField]
		private Material m_blurShader;

		[SerializeField]
		private Material m_downsampleShader;

		[SerializeField]
		private Material m_copyMipmapShader;

		[SerializeField]
		private Material m_eraseShadowShader;

		[SerializeField]
		private float[] m_customMipmapFalloff;

		[SerializeField]
		private RenderTextureFormat[] m_preferredTextureFormats;

		[SerializeField]
		private Camera[] m_camerasForViewClipTest;

		private static int s_falloffParamID;

		private static int s_blurOffsetHParamID;

		private static int s_blurOffsetVParamID;

		private static int s_blurWeightHParamID;

		private static int s_blurWeightVParamID;

		private static int s_downSampleBlurOffset0ParamID;

		private static int s_downSampleBlurOffset1ParamID;

		private static int s_downSampleBlurOffset2ParamID;

		private static int s_downSampleBlurOffset3ParamID;

		private static int s_downSampleBlurWeightParamID;

		private Projector m_projector;

		private Material m_projectorMaterial;

		private CommandBuffer m_commandBuffer;

		private RenderTexture m_shadowTexture;

		[SerializeField]
		[HideInInspector]
		private Camera m_camera;

		private bool m_isTexturePropertyChanged;

		private bool m_isVisible;

		private bool m_shadowTextureValid;

		private static HashSet<Material> s_sharedMaterials;

		private const HideFlags CLONED_MATERIAL_HIDE_FLAGS = HideFlags.HideAndDontSave;

		private const int MAX_BLUR_TAP_SIZE = 7;

		private static float[] s_blurWeights = new float[7];

		public TextureMultiSample multiSampling
		{
			get
			{
				return m_multiSampling;
			}
			set
			{
				if (m_multiSampling != value)
				{
					m_multiSampling = value;
					SetTexturePropertyDirty();
				}
			}
		}

		public TextureSuperSample superSampling
		{
			get
			{
				return m_superSampling;
			}
			set
			{
				if (m_superSampling != value)
				{
					bool num = useIntermediateTexture;
					m_superSampling = value;
					if (num != useIntermediateTexture && m_multiSampling != TextureMultiSample.x1)
					{
						SetTexturePropertyDirty();
					}
				}
			}
		}

		public int textureWidth
		{
			get
			{
				return m_textureWidth;
			}
			set
			{
				if (m_textureWidth != value)
				{
					m_textureWidth = value;
					SetTexturePropertyDirty();
				}
			}
		}

		public int textureHeight
		{
			get
			{
				return m_textureHeight;
			}
			set
			{
				if (m_textureHeight != value)
				{
					m_textureHeight = value;
					SetTexturePropertyDirty();
				}
			}
		}

		public int mipLevel
		{
			get
			{
				return m_mipLevel;
			}
			set
			{
				if (m_mipLevel != value)
				{
					if (m_mipLevel == 0 || value == 0)
					{
						SetTexturePropertyDirty();
					}
					m_mipLevel = value;
				}
			}
		}

		public int blurLevel
		{
			get
			{
				return m_blurLevel;
			}
			set
			{
				if (m_blurLevel != value)
				{
					bool num = useIntermediateTexture;
					m_blurLevel = value;
					if (num != useIntermediateTexture && m_multiSampling != TextureMultiSample.x1)
					{
						SetTexturePropertyDirty();
					}
				}
			}
		}

		public float blurSize
		{
			get
			{
				return m_blurSize;
			}
			set
			{
				m_blurSize = value;
			}
		}

		public BlurFilter blurFilter
		{
			get
			{
				return m_blurFilter;
			}
			set
			{
				m_blurFilter = value;
			}
		}

		public float mipmapBlurSize
		{
			get
			{
				return m_mipmapBlurSize;
			}
			set
			{
				m_mipmapBlurSize = value;
			}
		}

		public bool singlePassMipmapBlur
		{
			get
			{
				return m_singlePassMipmapBlur;
			}
			set
			{
				m_singlePassMipmapBlur = value;
			}
		}

		public MipmapFalloff mipmapFalloff
		{
			get
			{
				return m_mipmapFalloff;
			}
			set
			{
				m_mipmapFalloff = value;
			}
		}

		public float[] customMipmapFalloff
		{
			get
			{
				return m_customMipmapFalloff;
			}
			set
			{
				m_customMipmapFalloff = value;
			}
		}

		public Color shadowColor
		{
			get
			{
				return m_shadowColor;
			}
			set
			{
				if (m_shadowColor != value)
				{
					bool num = useIntermediateTexture;
					m_shadowColor = value;
					if (num != useIntermediateTexture && m_multiSampling != TextureMultiSample.x1)
					{
						SetTexturePropertyDirty();
					}
				}
			}
		}

		public Material blurShader
		{
			get
			{
				return m_blurShader;
			}
			set
			{
				m_blurShader = value;
			}
		}

		public Material downsampleShader
		{
			get
			{
				return m_downsampleShader;
			}
			set
			{
				m_downsampleShader = value;
			}
		}

		public Material copyMipmapShader
		{
			get
			{
				return m_copyMipmapShader;
			}
			set
			{
				m_copyMipmapShader = value;
			}
		}

		public Material eraseShadowShader
		{
			get
			{
				return m_eraseShadowShader;
			}
			set
			{
				m_eraseShadowShader = value;
			}
		}

		public RenderTexture shadowTexture => m_shadowTexture;

		public bool testViewClip
		{
			get
			{
				return m_testViewClip;
			}
			set
			{
				m_testViewClip = value;
			}
		}

		public Camera[] camerasForViewClipTest
		{
			get
			{
				return m_camerasForViewClipTest;
			}
			set
			{
				m_camerasForViewClipTest = value;
			}
		}

		public float cameraNearClipPlane
		{
			get
			{
				if (m_camera == null)
				{
					Initialize();
				}
				return m_camera.nearClipPlane;
			}
			set
			{
				if (m_camera == null)
				{
					Initialize();
				}
				m_camera.nearClipPlane = value;
			}
		}

		public LayerMask cameraCullingMask
		{
			get
			{
				if (m_camera == null)
				{
					Initialize();
				}
				return m_camera.cullingMask;
			}
			set
			{
				if (m_camera == null)
				{
					Initialize();
				}
				m_camera.cullingMask = value;
			}
		}

		public bool isProjectorVisible => m_isVisible;

		private bool useIntermediateTexture
		{
			get
			{
				if (m_superSampling == TextureSuperSample.x1 && 0 >= m_blurLevel && !HasShadowColor())
				{
					if (0 < m_mipLevel)
					{
						return m_multiSampling != TextureMultiSample.x1;
					}
					return false;
				}
				return true;
			}
		}

		public void SetReplacementShader(Shader shader, string replacementTag)
		{
			if (m_camera == null)
			{
				Initialize();
			}
			if (shader != null)
			{
				m_camera.SetReplacementShader(shader, replacementTag);
			}
			else
			{
				m_camera.ResetReplacementShader();
			}
		}

		public void SetTexturePropertyDirty()
		{
			m_isTexturePropertyChanged = true;
		}

		public void CreateRenderTexture()
		{
			if (m_textureWidth <= 0 || m_textureHeight <= 0 || m_projector == null)
			{
				return;
			}
			RenderTextureFormat format = RenderTextureFormat.ARGB32;
			if (m_preferredTextureFormats != null && m_preferredTextureFormats.Length != 0)
			{
				RenderTextureFormat[] preferredTextureFormats = m_preferredTextureFormats;
				foreach (RenderTextureFormat renderTextureFormat in preferredTextureFormats)
				{
					if (SystemInfo.SupportsRenderTextureFormat(format))
					{
						format = renderTextureFormat;
					}
				}
			}
			if (m_shadowTexture != null)
			{
				if (m_camera != null)
				{
					m_camera.targetTexture = null;
				}
				UnityEngine.Object.DestroyImmediate(m_shadowTexture);
			}
			m_shadowTexture = new RenderTexture(m_textureWidth, m_textureHeight, 0, format, RenderTextureReadWrite.Linear);
			if (useIntermediateTexture)
			{
				m_shadowTexture.antiAliasing = 1;
			}
			else
			{
				m_shadowTexture.antiAliasing = (int)m_multiSampling;
			}
			if (0 < m_mipLevel)
			{
				m_shadowTexture.useMipMap = true;
				m_shadowTexture.autoGenerateMips = false;
				m_shadowTexture.mipMapBias = 0f;
				m_shadowTexture.filterMode = FilterMode.Trilinear;
			}
			else
			{
				m_shadowTexture.useMipMap = false;
				m_shadowTexture.filterMode = FilterMode.Bilinear;
			}
			m_shadowTexture.wrapMode = TextureWrapMode.Clamp;
			m_shadowTexture.Create();
			m_shadowTextureValid = false;
			if (m_projector.material != null)
			{
				m_projector.material.SetTexture("_ShadowTex", m_shadowTexture);
				m_projector.material.SetFloat("_DSPMipLevel", m_mipLevel);
			}
			if (m_camera != null)
			{
				m_camera.targetTexture = m_shadowTexture;
			}
			m_isTexturePropertyChanged = false;
		}

		public void AddCommandBuffer(CommandBuffer commandBuffer)
		{
			m_camera.RemoveCommandBuffer(CameraEvent.BeforeImageEffectsOpaque, commandBuffer);
			m_camera.AddCommandBuffer(CameraEvent.BeforeImageEffectsOpaque, commandBuffer);
		}

		public void RemoveCommandBuffer(CommandBuffer commandBuffer)
		{
			m_camera.RemoveCommandBuffer(CameraEvent.BeforeImageEffectsOpaque, commandBuffer);
		}

		private static void InitializeShaderPropertyIDs()
		{
			s_falloffParamID = Shader.PropertyToID("_Falloff");
			s_blurOffsetHParamID = Shader.PropertyToID("_OffsetH");
			s_blurOffsetVParamID = Shader.PropertyToID("_OffsetV");
			s_blurWeightHParamID = Shader.PropertyToID("_WeightH");
			s_blurWeightVParamID = Shader.PropertyToID("_WeightV");
			s_downSampleBlurOffset0ParamID = Shader.PropertyToID("_Offset0");
			s_downSampleBlurOffset1ParamID = Shader.PropertyToID("_Offset1");
			s_downSampleBlurOffset2ParamID = Shader.PropertyToID("_Offset2");
			s_downSampleBlurOffset3ParamID = Shader.PropertyToID("_Offset3");
			s_downSampleBlurWeightParamID = Shader.PropertyToID("_Weight");
		}

		private bool Initialize()
		{
			m_isVisible = false;
			if (IsInitialized())
			{
				return true;
			}
			m_isTexturePropertyChanged = true;
			InitializeShaderPropertyIDs();
			m_projector = GetComponent<Projector>();
			CloneProjectorMaterialIfShared();
			if (m_camera == null)
			{
				m_camera = base.gameObject.GetComponent<Camera>();
				if (m_camera == null)
				{
					m_camera = base.gameObject.AddComponent<Camera>();
				}
				m_camera.hideFlags = HideFlags.HideInInspector;
			}
			else
			{
				m_camera.RemoveAllCommandBuffers();
			}
			m_camera.depth = -100f;
			m_camera.cullingMask = 0;
			m_camera.clearFlags = CameraClearFlags.Nothing;
			m_camera.backgroundColor = new Color(1f, 1f, 1f, 0f);
			m_camera.useOcclusionCulling = false;
			m_camera.renderingPath = RenderingPath.Forward;
			m_camera.nearClipPlane = 0.01f;
			m_camera.forceIntoRenderTexture = true;
			m_camera.enabled = true;
			CreateRenderTexture();
			return true;
		}

		private bool IsInitialized()
		{
			if (m_projector != null)
			{
				return m_camera != null;
			}
			return false;
		}

		private void Awake()
		{
			Initialize();
		}

		private void OnEnable()
		{
			if (m_camera != null)
			{
				m_camera.enabled = true;
			}
		}

		private void OnDisable()
		{
			if (m_camera != null)
			{
				m_camera.enabled = false;
			}
		}

		private void Start()
		{
			if (m_testViewClip && (m_camerasForViewClipTest == null || m_camerasForViewClipTest.Length == 0) && Camera.main != null)
			{
				m_camerasForViewClipTest = new Camera[1] { Camera.main };
			}
		}

		private void OnValidate()
		{
			CreateRenderTexture();
			InitializeShaderPropertyIDs();
			if (m_mipmapFalloff != MipmapFalloff.Custom || 0 >= m_mipLevel)
			{
				return;
			}
			if (m_customMipmapFalloff == null || m_customMipmapFalloff.Length == 0)
			{
				m_customMipmapFalloff = new float[m_mipLevel];
				for (int i = 0; i < m_mipLevel; i++)
				{
					m_customMipmapFalloff[i] = (float)(m_mipLevel - i) / (float)(m_mipLevel + 1);
				}
			}
			else if (m_mipLevel != m_customMipmapFalloff.Length)
			{
				float[] array = new float[m_mipLevel];
				for (int j = 0; j < m_mipLevel; j++)
				{
					float num = (float)(m_customMipmapFalloff.Length + 1) * (float)(j + 1) / (float)(m_mipLevel + 1);
					int num2 = Mathf.FloorToInt(num);
					float t = num - (float)num2;
					float a = ((num2 == 0) ? 1f : m_customMipmapFalloff[num2 - 1]);
					float b = ((num2 < m_customMipmapFalloff.Length) ? m_customMipmapFalloff[num2] : 0f);
					array[j] = Mathf.Lerp(a, b, t);
				}
				m_customMipmapFalloff = array;
			}
		}

		private void CloneProjectorMaterialIfShared()
		{
			if (!(m_projector.material == null) && (m_projector.material.hideFlags != HideFlags.HideAndDontSave || !(m_projector.material == m_projectorMaterial)))
			{
				if (m_projectorMaterial != null && m_projectorMaterial.hideFlags == HideFlags.HideAndDontSave)
				{
					UnityEngine.Object.DestroyImmediate(m_projectorMaterial);
				}
				if (s_sharedMaterials == null)
				{
					s_sharedMaterials = new HashSet<Material>();
				}
				if (s_sharedMaterials.Contains(m_projector.material))
				{
					m_projector.material = new Material(m_projector.material);
					m_projector.material.hideFlags = HideFlags.HideAndDontSave;
				}
				else
				{
					s_sharedMaterials.Add(m_projector.material);
				}
				m_projectorMaterial = m_projector.material;
			}
		}

		private void OnDestroy()
		{
			if (m_projectorMaterial != null)
			{
				if (s_sharedMaterials != null && s_sharedMaterials.Contains(m_projectorMaterial))
				{
					s_sharedMaterials.Remove(m_projectorMaterial);
				}
				if (m_projectorMaterial.hideFlags == HideFlags.HideAndDontSave)
				{
					if (m_projector.material == m_projectorMaterial)
					{
						m_projector.material = null;
					}
					UnityEngine.Object.DestroyImmediate(m_projectorMaterial);
				}
			}
			if (m_shadowTexture != null)
			{
				if (m_camera != null)
				{
					m_camera.targetTexture = null;
				}
				UnityEngine.Object.DestroyImmediate(m_shadowTexture);
				m_shadowTexture = null;
			}
			if (m_camera != null)
			{
				m_camera.RemoveAllCommandBuffers();
			}
			m_isVisible = false;
		}

		private bool IsReadyToExecute()
		{
			if (m_textureWidth <= 0 || m_textureHeight <= 0 || m_eraseShadowShader == null)
			{
				return false;
			}
			if ((0 < m_mipLevel || m_superSampling != TextureSuperSample.x1) && m_downsampleShader == null)
			{
				return false;
			}
			if ((0 < m_blurLevel || (0f < m_mipmapBlurSize && 0 < m_mipLevel)) && m_blurShader == null)
			{
				return false;
			}
			if (0 < m_mipLevel && (m_copyMipmapShader == null || m_downsampleShader == null))
			{
				return false;
			}
			return true;
		}

		private void SetVisible(bool isVisible)
		{
			m_isVisible = isVisible;
			SendMessage("OnVisibilityChanged", isVisible);
		}

		private void Update()
		{
			if (m_camera != null && !m_camera.enabled)
			{
				m_camera.enabled = true;
			}
		}

		private void OnPreCull()
		{
			if (m_projector.material != m_projectorMaterial)
			{
				CloneProjectorMaterialIfShared();
				m_projector.material.SetTexture("_ShadowTex", m_shadowTexture);
				m_projector.material.SetFloat("_DSPMipLevel", m_mipLevel);
			}
			if (m_isTexturePropertyChanged)
			{
				CreateRenderTexture();
			}
			m_camera.orthographic = m_projector.orthographic;
			m_camera.orthographicSize = m_projector.orthographicSize;
			m_camera.fieldOfView = m_projector.fieldOfView;
			m_camera.aspect = m_projector.aspectRatio;
			m_camera.farClipPlane = m_projector.farClipPlane;
			bool flag = true;
			if (!m_projector.enabled)
			{
				flag = false;
			}
			else if (m_testViewClip)
			{
				if ((m_camerasForViewClipTest == null || m_camerasForViewClipTest.Length == 0) && Camera.main != null)
				{
					m_camerasForViewClipTest = new Camera[1] { Camera.main };
				}
				if (m_camerasForViewClipTest != null && m_camerasForViewClipTest.Length != 0)
				{
					Vector3 position = m_camera.ViewportToWorldPoint(new Vector3(0f, 0f, m_camera.nearClipPlane));
					Vector3 position2 = m_camera.ViewportToWorldPoint(new Vector3(1f, 0f, m_camera.nearClipPlane));
					Vector3 position3 = m_camera.ViewportToWorldPoint(new Vector3(0f, 1f, m_camera.nearClipPlane));
					Vector3 position4 = m_camera.ViewportToWorldPoint(new Vector3(1f, 1f, m_camera.nearClipPlane));
					Vector3 position5 = m_camera.ViewportToWorldPoint(new Vector3(0f, 0f, m_camera.farClipPlane));
					Vector3 position6 = m_camera.ViewportToWorldPoint(new Vector3(1f, 0f, m_camera.farClipPlane));
					Vector3 position7 = m_camera.ViewportToWorldPoint(new Vector3(0f, 1f, m_camera.farClipPlane));
					Vector3 position8 = m_camera.ViewportToWorldPoint(new Vector3(1f, 1f, m_camera.farClipPlane));
					flag = false;
					for (int i = 0; i < m_camerasForViewClipTest.Length; i++)
					{
						Camera camera = m_camerasForViewClipTest[i];
						Vector3 vector = camera.WorldToViewportPoint(position);
						if (vector.z < 0f)
						{
							vector.x = 0f - vector.x;
							vector.y = 0f - vector.y;
						}
						Vector3 vector2 = vector;
						Vector3 vector3 = camera.WorldToViewportPoint(position2);
						if (vector3.z < 0f)
						{
							vector3.x = 0f - vector3.x;
							vector3.y = 0f - vector3.y;
						}
						vector.x = Mathf.Min(vector.x, vector3.x);
						vector.y = Mathf.Min(vector.y, vector3.y);
						vector.z = Mathf.Min(vector.z, vector3.z);
						vector2.x = Mathf.Max(vector2.x, vector3.x);
						vector2.y = Mathf.Max(vector2.y, vector3.y);
						vector2.z = Mathf.Max(vector2.z, vector3.z);
						vector3 = camera.WorldToViewportPoint(position3);
						if (vector3.z < 0f)
						{
							vector3.x = 0f - vector3.x;
							vector3.y = 0f - vector3.y;
						}
						vector.x = Mathf.Min(vector.x, vector3.x);
						vector.y = Mathf.Min(vector.y, vector3.y);
						vector.z = Mathf.Min(vector.z, vector3.z);
						vector2.x = Mathf.Max(vector2.x, vector3.x);
						vector2.y = Mathf.Max(vector2.y, vector3.y);
						vector2.z = Mathf.Max(vector2.z, vector3.z);
						vector3 = camera.WorldToViewportPoint(position4);
						if (vector3.z < 0f)
						{
							vector3.x = 0f - vector3.x;
							vector3.y = 0f - vector3.y;
						}
						vector.x = Mathf.Min(vector.x, vector3.x);
						vector.y = Mathf.Min(vector.y, vector3.y);
						vector.z = Mathf.Min(vector.z, vector3.z);
						vector2.x = Mathf.Max(vector2.x, vector3.x);
						vector2.y = Mathf.Max(vector2.y, vector3.y);
						vector2.z = Mathf.Max(vector2.z, vector3.z);
						vector3 = camera.WorldToViewportPoint(position5);
						if (vector3.z < 0f)
						{
							vector3.x = 0f - vector3.x;
							vector3.y = 0f - vector3.y;
						}
						vector.x = Mathf.Min(vector.x, vector3.x);
						vector.y = Mathf.Min(vector.y, vector3.y);
						vector.z = Mathf.Min(vector.z, vector3.z);
						vector2.x = Mathf.Max(vector2.x, vector3.x);
						vector2.y = Mathf.Max(vector2.y, vector3.y);
						vector2.z = Mathf.Max(vector2.z, vector3.z);
						vector3 = camera.WorldToViewportPoint(position6);
						if (vector3.z < 0f)
						{
							vector3.x = 0f - vector3.x;
							vector3.y = 0f - vector3.y;
						}
						vector.x = Mathf.Min(vector.x, vector3.x);
						vector.y = Mathf.Min(vector.y, vector3.y);
						vector.z = Mathf.Min(vector.z, vector3.z);
						vector2.x = Mathf.Max(vector2.x, vector3.x);
						vector2.y = Mathf.Max(vector2.y, vector3.y);
						vector2.z = Mathf.Max(vector2.z, vector3.z);
						vector3 = camera.WorldToViewportPoint(position7);
						if (vector3.z < 0f)
						{
							vector3.x = 0f - vector3.x;
							vector3.y = 0f - vector3.y;
						}
						vector.x = Mathf.Min(vector.x, vector3.x);
						vector.y = Mathf.Min(vector.y, vector3.y);
						vector.z = Mathf.Min(vector.z, vector3.z);
						vector2.x = Mathf.Max(vector2.x, vector3.x);
						vector2.y = Mathf.Max(vector2.y, vector3.y);
						vector2.z = Mathf.Max(vector2.z, vector3.z);
						vector3 = camera.WorldToViewportPoint(position8);
						if (vector3.z < 0f)
						{
							vector3.x = 0f - vector3.x;
							vector3.y = 0f - vector3.y;
						}
						vector.x = Mathf.Min(vector.x, vector3.x);
						vector.y = Mathf.Min(vector.y, vector3.y);
						vector.z = Mathf.Min(vector.z, vector3.z);
						vector2.x = Mathf.Max(vector2.x, vector3.x);
						vector2.y = Mathf.Max(vector2.y, vector3.y);
						vector2.z = Mathf.Max(vector2.z, vector3.z);
						if (0f < vector2.x && vector.x < 1f && 0f < vector2.y && vector.y < 1f && camera.nearClipPlane < vector2.z && vector.z < camera.farClipPlane)
						{
							flag = true;
							break;
						}
					}
				}
			}
			if (flag != m_isVisible)
			{
				SetVisible(flag);
			}
			if (!flag)
			{
				if (m_camera != null)
				{
					m_camera.enabled = false;
				}
				if (m_shadowTexture != null && !m_shadowTextureValid)
				{
					RenderTexture active = RenderTexture.active;
					RenderTexture.active = m_shadowTexture;
					GL.Clear(clearDepth: false, clearColor: true, new Color(1f, 1f, 1f, 0f));
					m_shadowTextureValid = true;
					RenderTexture.active = active;
				}
			}
		}

		private bool HasShadowColor()
		{
			if (m_shadowColor.a == 1f)
			{
				return m_shadowColor.r + shadowColor.g + shadowColor.b != 0f;
			}
			return true;
		}

		private void OnPreRender()
		{
			if (m_isVisible)
			{
				m_shadowTexture.DiscardContents();
				if (useIntermediateTexture)
				{
					int width = m_textureWidth * (int)m_superSampling;
					int height = m_textureHeight * (int)m_superSampling;
					m_camera.targetTexture = RenderTexture.GetTemporary(width, height, 0, m_shadowTexture.format, RenderTextureReadWrite.Linear, (int)m_multiSampling);
					m_camera.targetTexture.filterMode = FilterMode.Bilinear;
				}
				else
				{
					m_camera.targetTexture = m_shadowTexture;
				}
				m_camera.clearFlags = CameraClearFlags.Color;
			}
		}

		private static BlurParam GetBlurParam(float blurSize, BlurFilter filter)
		{
			BlurParam result = default(BlurParam);
			if (blurSize < 0.1f)
			{
				result.tap = 3;
				result.offset.x = 0f;
				result.offset.y = 0f;
				result.offset.z = 0f;
				result.offset.w = 0f;
				result.weight.x = 1f;
				result.weight.y = 0f;
				result.weight.z = 0f;
				result.weight.w = 0f;
				return result;
			}
			if (filter == BlurFilter.Gaussian)
			{
				float num = 1f / (2f * blurSize * blurSize);
				float num2 = 1f;
				s_blurWeights[0] = 1f;
				for (int i = 1; i < s_blurWeights.Length; i++)
				{
					s_blurWeights[i] = Mathf.Exp((float)(-i * i) * num);
					num2 += 2f * s_blurWeights[i];
				}
				float num3 = 1f / num2;
				for (int j = 0; j < s_blurWeights.Length; j++)
				{
					s_blurWeights[j] *= num3;
				}
			}
			else
			{
				float num4 = 0.5f / (0.5f + blurSize);
				for (int k = 0; k < s_blurWeights.Length; k++)
				{
					if ((float)k <= blurSize)
					{
						s_blurWeights[k] = num4;
					}
					else if ((float)(k - 1) < blurSize)
					{
						s_blurWeights[k] = num4 * (blurSize - (float)(k - 1));
					}
					else
					{
						s_blurWeights[k] = 0f;
					}
				}
			}
			result.offset.x = 1f + s_blurWeights[2] / (s_blurWeights[1] + s_blurWeights[2]);
			result.offset.y = 3f + s_blurWeights[4] / (s_blurWeights[3] + s_blurWeights[4]);
			result.offset.z = 5f + s_blurWeights[6] / (s_blurWeights[5] + s_blurWeights[6]);
			result.offset.w = 0f;
			if (s_blurWeights[3] < 0.02f)
			{
				result.tap = 3;
				float num5 = 0.5f / (0.5f * s_blurWeights[0] + s_blurWeights[1] + s_blurWeights[2]);
				result.weight.x = Mathf.Round(255f * num5 * s_blurWeights[0]) / 255f;
				result.weight.y = 0.5f - 0.5f * result.weight.x;
				result.weight.z = 0f;
				result.weight.w = 0f;
			}
			else if (s_blurWeights[5] < 0.02f)
			{
				result.tap = 5;
				float num6 = 0.5f / (0.5f * s_blurWeights[0] + s_blurWeights[1] + s_blurWeights[2] + s_blurWeights[3] + s_blurWeights[4]);
				result.weight.x = Mathf.Round(255f * num6 * s_blurWeights[0]) / 255f;
				result.weight.y = Mathf.Round(255f * num6 * (s_blurWeights[1] + s_blurWeights[2])) / 255f;
				result.weight.z = 0.5f - (0.5f * result.weight.x + result.weight.y);
				result.weight.w = 0f;
			}
			else
			{
				result.tap = 7;
				result.weight.x = Mathf.Round(255f * s_blurWeights[0]) / 255f;
				result.weight.y = Mathf.Round(255f * (s_blurWeights[1] + s_blurWeights[2])) / 255f;
				result.weight.z = Mathf.Round(255f * (s_blurWeights[3] + s_blurWeights[4])) / 255f;
				result.weight.w = 0.5f - (0.5f * result.weight.x + result.weight.y + result.weight.z);
			}
			return result;
		}

		private static BlurParam GetDownsampleBlurParam(float blurSize, BlurFilter filter)
		{
			BlurParam result = default(BlurParam);
			result.tap = 4;
			if (blurSize < 0.1f)
			{
				result.offset.x = 0f;
				result.offset.y = 0f;
				result.offset.z = 0f;
				result.offset.w = 0f;
				result.weight.x = 1f;
				result.weight.y = 0f;
				result.weight.z = 0f;
				result.weight.w = 0f;
				return result;
			}
			if (filter == BlurFilter.Gaussian)
			{
				float num = 1f / (2f * blurSize * blurSize);
				float num2 = 0f;
				for (int i = 0; i < result.tap; i++)
				{
					float num3 = (float)i + 0.5f;
					s_blurWeights[i] = Mathf.Exp((0f - num3) * num3 * num);
					num2 += 2f * s_blurWeights[i];
				}
				float num4 = 1f / num2;
				for (int j = 0; j < result.tap; j++)
				{
					s_blurWeights[j] *= num4;
				}
			}
			else
			{
				float num5 = 0.5f / blurSize;
				for (int k = 0; k < result.tap; k++)
				{
					if ((float)(k + 1) <= blurSize)
					{
						s_blurWeights[k] = num5;
					}
					else if ((float)k < blurSize)
					{
						s_blurWeights[k] = num5 * (blurSize - (float)k);
					}
					else
					{
						s_blurWeights[k] = 0f;
					}
				}
			}
			result.offset.x = 0.5f + s_blurWeights[1] / (s_blurWeights[0] + s_blurWeights[1]);
			result.offset.y = 2.5f + s_blurWeights[3] / (s_blurWeights[2] + s_blurWeights[3]);
			result.offset.z = 0f;
			result.offset.w = 0f;
			result.weight.x = s_blurWeights[0] + s_blurWeights[1];
			result.weight.y = s_blurWeights[2] + s_blurWeights[3];
			result.weight.z = 0f;
			result.weight.w = 0f;
			return result;
		}

		private void OnPostRender()
		{
			m_camera.clearFlags = CameraClearFlags.Nothing;
			if (!m_isVisible)
			{
				return;
			}
			RenderTexture renderTexture = m_camera.targetTexture;
			m_camera.targetTexture = m_shadowTexture;
			if (m_superSampling != TextureSuperSample.x1 || HasShadowColor())
			{
				m_downsampleShader.color = m_shadowColor;
				RenderTexture temporary;
				if (0 < m_blurLevel)
				{
					temporary = RenderTexture.GetTemporary(m_textureWidth, m_textureHeight, 0, m_shadowTexture.format, RenderTextureReadWrite.Linear);
					temporary.filterMode = FilterMode.Bilinear;
				}
				else
				{
					temporary = m_shadowTexture;
				}
				Graphics.SetRenderTarget(temporary);
				int num = ((m_superSampling != TextureSuperSample.x16) ? 2 : 0);
				Graphics.Blit(renderTexture, temporary, m_downsampleShader, HasShadowColor() ? (num + 1) : num);
				RenderTexture.ReleaseTemporary(renderTexture);
				renderTexture = temporary;
			}
			if (0 < m_blurLevel)
			{
				float num2 = m_projector.aspectRatio * (float)m_textureHeight / (float)m_textureWidth;
				float num3 = m_blurSize;
				float num4 = m_blurSize;
				if (num2 < 1f)
				{
					num4 *= num2;
				}
				else
				{
					num3 /= num2;
				}
				BlurParam blurParam = GetBlurParam(num3, m_blurFilter);
				BlurParam blurParam2 = GetBlurParam(num4, m_blurFilter);
				blurParam.tap -= 3;
				blurParam2.tap = blurParam2.tap - 3 + 1;
				m_blurShader.SetVector(s_blurOffsetHParamID, blurParam.offset);
				m_blurShader.SetVector(s_blurOffsetVParamID, blurParam2.offset);
				m_blurShader.SetVector(s_blurWeightHParamID, blurParam.weight);
				m_blurShader.SetVector(s_blurWeightVParamID, blurParam2.weight);
				RenderTexture temporary2 = RenderTexture.GetTemporary(m_textureWidth, m_textureHeight, 0, m_shadowTexture.format, RenderTextureReadWrite.Linear);
				temporary2.filterMode = FilterMode.Bilinear;
				renderTexture.wrapMode = TextureWrapMode.Clamp;
				temporary2.wrapMode = TextureWrapMode.Clamp;
				Graphics.Blit(renderTexture, temporary2, m_blurShader, blurParam.tap);
				if (1 < renderTexture.antiAliasing)
				{
					RenderTexture.ReleaseTemporary(renderTexture);
					renderTexture = RenderTexture.GetTemporary(m_textureWidth, m_textureHeight, 0, m_shadowTexture.format, RenderTextureReadWrite.Linear);
				}
				else
				{
					renderTexture.DiscardContents();
				}
				for (int i = 1; i < m_blurLevel - 1; i++)
				{
					Graphics.Blit(temporary2, renderTexture, m_blurShader, blurParam2.tap);
					temporary2.DiscardContents();
					Graphics.Blit(renderTexture, temporary2, m_blurShader, blurParam.tap);
					renderTexture.DiscardContents();
				}
				RenderTexture.ReleaseTemporary(renderTexture);
				renderTexture = m_shadowTexture;
				Graphics.Blit(temporary2, renderTexture, m_blurShader, blurParam2.tap);
				RenderTexture.ReleaseTemporary(temporary2);
			}
			Graphics.SetRenderTarget(m_shadowTexture);
			if (renderTexture != m_shadowTexture)
			{
				Graphics.Blit(renderTexture, m_downsampleShader, 2);
				if (m_mipLevel == 0)
				{
					RenderTexture.ReleaseTemporary(renderTexture);
				}
			}
			EraseShadowOnBoarder(m_textureWidth, m_textureHeight);
			if (0 < m_mipLevel)
			{
				BlurParam blurH = default(BlurParam);
				BlurParam blurV = default(BlurParam);
				if (0.1f < m_mipmapBlurSize)
				{
					float num5 = m_projector.aspectRatio * (float)m_textureHeight / (float)m_textureWidth;
					float num6 = m_mipmapBlurSize;
					float num7 = m_mipmapBlurSize;
					if (num5 < 1f)
					{
						num7 *= num5;
					}
					else
					{
						num6 /= num5;
					}
					if (m_singlePassMipmapBlur)
					{
						blurH = GetDownsampleBlurParam(2f + 2f * num6, m_blurFilter);
						blurV = GetDownsampleBlurParam(2f + 2f * num7, m_blurFilter);
						Vector4 value = new Vector4(blurH.weight.x * blurV.weight.x, blurH.weight.x * blurV.weight.y, blurH.weight.y * blurV.weight.x, blurH.weight.y * blurV.weight.y);
						float num8 = 0.25f / (value.x + value.y + value.z + value.w);
						value.x = Mathf.Round(255f * num8 * value.x) / 255f;
						value.y = Mathf.Round(255f * num8 * value.y) / 255f;
						value.z = Mathf.Round(255f * num8 * value.z) / 255f;
						value.w = 0.25f - value.x - value.y - value.z;
						m_downsampleShader.SetVector(s_downSampleBlurWeightParamID, value);
					}
					else
					{
						blurH = GetBlurParam(num6, m_blurFilter);
						blurV = GetBlurParam(num7, m_blurFilter);
						blurH.tap -= 3;
						blurV.tap = blurV.tap - 3 + 1;
						m_blurShader.SetVector(s_blurOffsetHParamID, blurH.offset);
						m_blurShader.SetVector(s_blurOffsetVParamID, blurV.offset);
						m_blurShader.SetVector(s_blurWeightHParamID, blurH.weight);
						m_blurShader.SetVector(s_blurWeightVParamID, blurV.weight);
					}
				}
				int num9 = m_textureWidth >> 1;
				int num10 = m_textureHeight >> 1;
				RenderTexture temporary3 = RenderTexture.GetTemporary(num9, num10, 0, m_shadowTexture.format, RenderTextureReadWrite.Linear);
				temporary3.filterMode = FilterMode.Bilinear;
				bool flag = m_singlePassMipmapBlur && 0.1f < m_mipmapBlurSize;
				if (flag)
				{
					SetDownsampleBlurOffsetParams(blurH, blurV, num9, num10);
				}
				if (renderTexture == m_shadowTexture)
				{
					if (flag)
					{
						Graphics.Blit(renderTexture, temporary3, m_downsampleShader, 5);
					}
					else
					{
						Graphics.Blit(renderTexture, temporary3, m_copyMipmapShader, 1);
					}
				}
				else
				{
					Graphics.Blit(renderTexture, temporary3, m_downsampleShader, flag ? 4 : 0);
					RenderTexture.ReleaseTemporary(renderTexture);
				}
				renderTexture = temporary3;
				int num11 = 0;
				float value2 = 1f;
				while (true)
				{
					if (0.1f < m_mipmapBlurSize && !m_singlePassMipmapBlur)
					{
						temporary3 = RenderTexture.GetTemporary(num9, num10, 0, m_shadowTexture.format, RenderTextureReadWrite.Linear);
						temporary3.filterMode = FilterMode.Bilinear;
						temporary3.wrapMode = TextureWrapMode.Clamp;
						renderTexture.wrapMode = TextureWrapMode.Clamp;
						Graphics.Blit(renderTexture, temporary3, m_blurShader, blurH.tap);
						renderTexture.DiscardContents();
						Graphics.Blit(temporary3, renderTexture, m_blurShader, blurV.tap);
						RenderTexture.ReleaseTemporary(temporary3);
					}
					if (m_mipmapFalloff == MipmapFalloff.Linear)
					{
						value2 = (float)(m_mipLevel - num11) / ((float)m_mipLevel + 1f);
					}
					else if (m_mipmapFalloff == MipmapFalloff.Custom && m_customMipmapFalloff != null && m_customMipmapFalloff.Length != 0)
					{
						value2 = m_customMipmapFalloff[Mathf.Min(num11, m_customMipmapFalloff.Length - 1)];
					}
					m_copyMipmapShader.SetFloat(s_falloffParamID, value2);
					m_copyMipmapShader.SetFloat(s_falloffParamID, value2);
					m_shadowTexture.DiscardContents();
					num11++;
					Graphics.SetRenderTarget(m_shadowTexture, num11);
					Graphics.Blit(renderTexture, m_copyMipmapShader, 0);
					EraseShadowOnBoarder(num9, num10);
					num9 = Mathf.Max(1, num9 >> 1);
					num10 = Mathf.Max(1, num10 >> 1);
					if (num11 == m_mipLevel || num9 <= 4 || num10 <= 4)
					{
						break;
					}
					temporary3 = RenderTexture.GetTemporary(num9, num10, 0, m_shadowTexture.format, RenderTextureReadWrite.Linear);
					temporary3.filterMode = FilterMode.Bilinear;
					if (flag)
					{
						SetDownsampleBlurOffsetParams(blurH, blurV, num9, num10);
						Graphics.Blit(renderTexture, temporary3, m_downsampleShader, 4);
					}
					else
					{
						Graphics.Blit(renderTexture, temporary3, m_downsampleShader, 0);
					}
					RenderTexture.ReleaseTemporary(renderTexture);
					renderTexture = temporary3;
				}
				RenderTexture.ReleaseTemporary(renderTexture);
				while (1 <= num9 || 1 <= num10)
				{
					num11++;
					Graphics.SetRenderTarget(m_shadowTexture, num11);
					GL.Clear(clearDepth: false, clearColor: true, new Color(1f, 1f, 1f, 0f));
					num9 >>= 1;
					num10 >>= 1;
				}
			}
			m_shadowTextureValid = true;
		}

		private void EraseShadowOnBoarder(int w, int h)
		{
			float num = 1f - 1f / (float)w;
			float num2 = 1f - 1f / (float)h;
			m_eraseShadowShader.SetPass(0);
			GL.Begin(1);
			GL.Vertex3(0f - num, 0f - num2, 0f);
			GL.Vertex3(num, 0f - num2, 0f);
			GL.Vertex3(num, 0f - num2, 0f);
			GL.Vertex3(num, num2, 0f);
			GL.Vertex3(num, num2, 0f);
			GL.Vertex3(0f - num, num2, 0f);
			GL.Vertex3(0f - num, num2, 0f);
			GL.Vertex3(0f - num, 0f - num2, 0f);
			GL.End();
		}

		private void SetDownsampleBlurOffsetParams(BlurParam blurH, BlurParam blurV, int w, int h)
		{
			float num = 0.5f / (float)w;
			float num2 = 0.5f / (float)h;
			float num3 = num * blurH.offset.x;
			float num4 = num * blurH.offset.y;
			float num5 = num2 * blurV.offset.x;
			float num6 = num2 * blurV.offset.y;
			m_downsampleShader.SetVector(s_downSampleBlurOffset0ParamID, new Vector4(num3, num5, 0f - num3, 0f - num5));
			m_downsampleShader.SetVector(s_downSampleBlurOffset1ParamID, new Vector4(num3, num6, 0f - num3, 0f - num6));
			m_downsampleShader.SetVector(s_downSampleBlurOffset2ParamID, new Vector4(num4, num5, 0f - num4, 0f - num5));
			m_downsampleShader.SetVector(s_downSampleBlurOffset3ParamID, new Vector4(num4, num6, 0f - num4, 0f - num6));
		}
	}
}
namespace DynamicShadowProjector.Sample
{
	public class Swing : MonoBehaviour
	{
		public float m_minAngle = -30f;

		public float m_maxAngle = 30f;

		public float m_swingSpeed = 0.1f;

		private Quaternion m_initialRotation;

		private float m_swing;

		private void Start()
		{
			m_initialRotation = base.transform.rotation;
			m_swing = 0f;
		}

		private void Update()
		{
			m_swing += m_swingSpeed * Time.deltaTime;
			m_swing -= Mathf.Floor(m_swing);
			float angle = Mathf.Lerp(m_minAngle, m_maxAngle, 0.5f - 0.5f * Mathf.Cos((float)Math.PI * 2f * m_swing));
			base.transform.rotation = Quaternion.AngleAxis(angle, Vector3.up) * m_initialRotation;
		}
	}
	public class Rotate : MonoBehaviour
	{
		public float m_rotateSpeed = 90f;

		private void Update()
		{
			base.transform.rotation = Quaternion.AngleAxis(m_rotateSpeed * Time.deltaTime, Vector3.up) * base.transform.rotation;
		}
	}
}
